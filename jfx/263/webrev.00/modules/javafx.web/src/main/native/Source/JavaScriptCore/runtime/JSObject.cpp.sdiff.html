<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSONObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  58 // This value is capped by the constant FIRST_VECTOR_GROW defined in
  59 // ArrayConventions.h.
  60 static unsigned lastArraySize = 0;
  61 
  62 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSObject);
  63 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSFinalObject);
  64 
  65 const ASCIILiteral NonExtensibleObjectPropertyDefineError { &quot;Attempting to define property on object that is not extensible.&quot;_s };
  66 const ASCIILiteral ReadonlyPropertyWriteError { &quot;Attempted to assign to readonly property.&quot;_s };
  67 const ASCIILiteral ReadonlyPropertyChangeError { &quot;Attempting to change value of a readonly property.&quot;_s };
  68 const ASCIILiteral UnableToDeletePropertyError { &quot;Unable to delete property.&quot;_s };
  69 const ASCIILiteral UnconfigurablePropertyChangeAccessMechanismError { &quot;Attempting to change access mechanism for an unconfigurable property.&quot;_s };
  70 const ASCIILiteral UnconfigurablePropertyChangeConfigurabilityError { &quot;Attempting to change configurable attribute of unconfigurable property.&quot;_s };
  71 const ASCIILiteral UnconfigurablePropertyChangeEnumerabilityError { &quot;Attempting to change enumerable attribute of unconfigurable property.&quot;_s };
  72 const ASCIILiteral UnconfigurablePropertyChangeWritabilityError { &quot;Attempting to change writable attribute of unconfigurable property.&quot;_s };
  73 
  74 const ClassInfo JSObject::s_info = { &quot;Object&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSObject) };
  75 
  76 const ClassInfo JSFinalObject::s_info = { &quot;Object&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFinalObject) };
  77 
<span class="line-modified">  78 static inline void getClassPropertyNames(ExecState* exec, const ClassInfo* classInfo, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  79 {
<span class="line-modified">  80     VM&amp; vm = exec-&gt;vm();</span>
  81 
  82     // Add properties from the static hashtables of properties
  83     for (; classInfo; classInfo = classInfo-&gt;parentClass) {
  84         const HashTable* table = classInfo-&gt;staticPropHashTable;
  85         if (!table)
  86             continue;
  87 
  88         for (auto iter = table-&gt;begin(); iter != table-&gt;end(); ++iter) {
  89             if (!(iter-&gt;attributes() &amp; PropertyAttribute::DontEnum) || mode.includeDontEnumProperties())
  90                 propertyNames.add(Identifier::fromString(vm, iter.key()));
  91         }
  92     }
  93 }
  94 
<span class="line-modified">  95 ALWAYS_INLINE void JSObject::markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp; visitor, Butterfly* butterfly, Structure* structure, PropertyOffset lastOffset)</span>
  96 {
  97     // We call this when we found everything without races.
  98     ASSERT(structure);
  99 
 100     if (!butterfly)
 101         return;
 102 
 103     if (isCopyOnWrite(structure-&gt;indexingMode())) {
 104         visitor.append(bitwise_cast&lt;WriteBarrier&lt;JSCell&gt;&gt;(JSImmutableButterfly::fromButterfly(butterfly)));
 105         return;
 106     }
 107 
 108     bool hasIndexingHeader = structure-&gt;hasIndexingHeader(this);
 109     size_t preCapacity;
 110     if (hasIndexingHeader)
 111         preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
 112     else
 113         preCapacity = 0;
 114 
 115     HeapCell* base = bitwise_cast&lt;HeapCell*&gt;(
<span class="line-modified"> 116         butterfly-&gt;base(preCapacity, Structure::outOfLineCapacity(lastOffset)));</span>
 117 
 118     ASSERT(Heap::heap(base) == visitor.heap());
 119 
 120     visitor.markAuxiliary(base);
 121 
<span class="line-modified"> 122     unsigned outOfLineSize = Structure::outOfLineSize(lastOffset);</span>
 123     visitor.appendValuesHidden(butterfly-&gt;propertyStorage() - outOfLineSize, outOfLineSize);
 124 }
 125 
 126 ALWAYS_INLINE Structure* JSObject::visitButterfly(SlotVisitor&amp; visitor)
 127 {
 128     static const char* const raceReason = &quot;JSObject::visitButterfly&quot;;
 129     Structure* result = visitButterflyImpl(visitor);
 130     if (!result)
 131         visitor.didRace(this, raceReason);
 132     return result;
 133 }
 134 
 135 ALWAYS_INLINE Structure* JSObject::visitButterflyImpl(SlotVisitor&amp; visitor)
 136 {
 137     VM&amp; vm = visitor.vm();
 138 
 139     Butterfly* butterfly;
 140     Structure* structure;
<span class="line-modified"> 141     PropertyOffset lastOffset;</span>
 142 
 143     auto visitElements = [&amp;] (IndexingType indexingMode) {
 144         switch (indexingMode) {
 145         // We don&#39;t need to visit the elements for CopyOnWrite butterflies since they we marked the JSImmutableButterfly acting as out butterfly.
 146         case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 147             visitor.appendValuesHidden(butterfly-&gt;contiguous().data(), butterfly-&gt;publicLength());
 148             break;
 149         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 150             visitor.appendValuesHidden(butterfly-&gt;arrayStorage()-&gt;m_vector, butterfly-&gt;arrayStorage()-&gt;vectorLength());
 151             if (butterfly-&gt;arrayStorage()-&gt;m_sparseMap)
 152                 visitor.append(butterfly-&gt;arrayStorage()-&gt;m_sparseMap);
 153             break;
 154         default:
 155             break;
 156         }
 157     };
 158 
 159     if (visitor.mutatorIsStopped()) {
 160         butterfly = this-&gt;butterfly();
 161         structure = this-&gt;structure(vm);
<span class="line-modified"> 162         lastOffset = structure-&gt;lastOffset();</span>
 163 
<span class="line-modified"> 164         markAuxiliaryAndVisitOutOfLineProperties(visitor, butterfly, structure, lastOffset);</span>
 165         visitElements(structure-&gt;indexingMode());
 166 
 167         return structure;
 168     }
 169 
 170     // We want to ensure that we only scan the butterfly if we have an exactly matched structure and an
 171     // exactly matched size. The mutator is required to perform the following shenanigans when
 172     // reallocating the butterfly with a concurrent collector, with all fencing necessary to ensure
 173     // that this executes as if under sequential consistency:
 174     //
 175     //     object-&gt;structure = nuke(object-&gt;structure)
 176     //     object-&gt;butterfly = newButterfly
<span class="line-modified"> 177     //     structure-&gt;m_offset = newLastOffset</span>
 178     //     object-&gt;structure = newStructure
 179     //
 180     // It&#39;s OK to skip this when reallocating the butterfly in a way that does not affect the m_offset.
 181     // We have other protocols in place for that.
 182     //
 183     // Note that the m_offset can change without the structure changing, but in that case the mutator
 184     // will still store null to the structure.
 185     //
 186     // The collector will ensure that it always sees a matched butterfly/structure by reading the
 187     // structure before and after reading the butterfly. For simplicity, let&#39;s first consider the case
 188     // where the only way to change the outOfLineCapacity is to change the structure. This works
 189     // because the mutator performs the following steps sequentially:
 190     //
 191     //     NukeStructure ChangeButterfly PutNewStructure
 192     //
 193     // Meanwhile the collector performs the following steps sequentially:
 194     //
 195     //     ReadStructureEarly ReadButterfly ReadStructureLate
 196     //
 197     // The collector is allowed to do any of these three things:
</pre>
<hr />
<pre>
 213     // NukeStructure ReadStructureEarly ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
 214     // NukeStructure ReadStructureEarly ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
 215     // NukeStructure ReadStructureEarly ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
 216     // NukeStructure ReadStructureEarly ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
 217     // NukeStructure ReadStructureEarly ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read early
 218     // ReadStructureEarly NukeStructure ChangeButterfly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 219     // ReadStructureEarly NukeStructure ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 220     // ReadStructureEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
 221     // ReadStructureEarly NukeStructure ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 222     // ReadStructureEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
 223     // ReadStructureEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
 224     // ReadStructureEarly ReadButterfly NukeStructure ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 225     // ReadStructureEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
 226     // ReadStructureEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
 227     // ReadStructureEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly PutNewStructure: BEFORE, trivially.
 228     //
 229     // But we additionally have to worry about the size changing. We make this work by requiring that
 230     // the collector reads the size early and late as well. Lets consider the interleaving of the
 231     // mutator changing the size without changing the structure:
 232     //
<span class="line-modified"> 233     //     NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure</span>
 234     //
 235     // Meanwhile the collector does:
 236     //
<span class="line-modified"> 237     //     ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate</span>
 238     //
 239     // The collector can detect races by not only comparing the early structure to the late structure
 240     // (which will be the same before and after the algorithm runs) but also by comparing the early and
<span class="line-modified"> 241     // late lastOffsets.  Note: the IGNORE proofs do not cite all of the reasons why the collector will</span>
 242     // ignore the case, since we only need to identify one to say that we&#39;re in the ignore case.
 243     //
<span class="line-modified"> 244     // NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: AFTER, trivially</span>
<span class="line-modified"> 245     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly RestoreStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 246     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly ReadLastOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 247     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly ReadLastOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 248     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 249     // NukeStructure ChangeButterfly ChangeLastOffset ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 250     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset RestoreStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 251     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset ReadLastOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 252     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset ReadLastOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 253     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 254     // NukeStructure ChangeButterfly ReadStructureEarly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 255     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 256     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 257     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 258     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 259     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 260     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 261     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 262     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 263     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 264     // NukeStructure ChangeButterfly ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 265     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 266     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset ReadLastOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 267     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 268     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 269     // NukeStructure ReadStructureEarly ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 270     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 271     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 272     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 273     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 274     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 275     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 276     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 277     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 278     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 279     // NukeStructure ReadStructureEarly ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 280     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 281     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 282     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 283     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 284     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 285     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 286     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 287     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 288     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 289     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 290     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 291     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 292     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 293     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 294     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 295     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 296     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 297     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 298     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 299     // NukeStructure ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 300     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate: AFTER, the ReadStructureEarly sees the same structure as after and everything else runs after.</span>
<span class="line-modified"> 301     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: AFTER, as above and the ReadLastOffsetEarly sees the lastOffset after.</span>
<span class="line-modified"> 302     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: AFTER, as above and the ReadButterfly sees the right butterfly after.</span>
<span class="line-modified"> 303     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure late</span>
<span class="line-modified"> 304     // ReadStructureEarly NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 305     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 306     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 307     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 308     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 309     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 310     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 311     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 312     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 313     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 314     // ReadStructureEarly NukeStructure ChangeButterfly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 315     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 316     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 317     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 318     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 319     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 320     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 321     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 322     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 323     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 324     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 325     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 326     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 327     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 328     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 329     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 330     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 331     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 332     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 333     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 334     // ReadStructureEarly NukeStructure ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 335     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadButterfly ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 336     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ChangeLastOffset ReadButterfly RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 337     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure late</span>
<span class="line-modified"> 338     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ChangeLastOffset ReadButterfly ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 339     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 340     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 341     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 342     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 343     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 344     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 345     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 346     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 347     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 348     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 349     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 350     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 351     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 352     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 353     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 354     // ReadStructureEarly ReadLastOffsetEarly NukeStructure ReadButterfly ReadStructureLate ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 355     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadStructureLate ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 356     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeLastOffset ReadStructureLate RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 357     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeLastOffset ReadStructureLate ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 358     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 359     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 360     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 361     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read nuked structure late</span>
<span class="line-modified"> 362     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 363     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 364     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly NukeStructure ReadStructureLate ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 365     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure ReadLastOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 366     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ChangeLastOffset ReadLastOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 367     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ReadLastOffsetLate ChangeLastOffset RestoreStructure: BEFORE, reads the offset before, everything else happens before</span>
<span class="line-modified"> 368     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate NukeStructure ReadLastOffsetLate ChangeButterfly ChangeLastOffset RestoreStructure: BEFORE, reads the offset before, everything else happens before</span>
<span class="line-modified"> 369     // ReadStructureEarly ReadLastOffsetEarly ReadButterfly ReadStructureLate ReadLastOffsetLate NukeStructure ChangeButterfly ChangeLastOffset RestoreStructure: BEFORE, trivially</span>
 370     //
 371     // Whew.
 372     //
 373     // What the collector is doing is just the &quot;double collect&quot; snapshot from &quot;The Unbounded Single-
 374     // Writer Algorithm&quot; from Yehuda Afek et al&#39;s &quot;Atomic Snapshots of Shared Memory&quot; in JACM 1993,
 375     // also available here:
 376     //
 377     // http://people.csail.mit.edu/shanir/publications/AADGMS.pdf
 378     //
 379     // Unlike Afek et al&#39;s algorithm, ours does not require extra hacks to force wait-freedom (see
 380     // &quot;Observation 2&quot; in the paper). This simplifies the whole algorithm. Instead we are happy with
 381     // obstruction-freedom, and like any good obstruction-free algorithm, we ensure progress using
 382     // scheduling. We also only collect the butterfly once instead of twice; this optimization seems
 383     // to hold up in my proofs above and I&#39;m not sure it&#39;s part of Afek et al&#39;s algos.
 384     //
 385     // For more background on this kind of madness, I like this paper; it&#39;s where I learned about
 386     // both the snapshot algorithm and obstruction-freedom:
 387     //
 388     // Lunchangco, Moir, Shavit. &quot;Nonblocking k-compare-single-swap.&quot; SPAA &#39;03
 389     // https://pdfs.semanticscholar.org/343f/7182cde7669ca2a7de3dc01127927f384ef7.pdf
 390 
 391     StructureID structureID = this-&gt;structureID();
 392     if (isNuked(structureID))
 393         return nullptr;
 394     structure = vm.getStructure(structureID);
<span class="line-modified"> 395     lastOffset = structure-&gt;lastOffset();</span>
 396     IndexingType indexingMode = structure-&gt;indexingMode();
 397     Dependency indexingModeDependency = Dependency::fence(indexingMode);
 398     Locker&lt;JSCellLock&gt; locker(NoLockingNecessary);
 399     switch (indexingMode) {
 400     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 401         // We need to hold this lock to protect against changes to the innards of the butterfly
 402         // that can happen when the butterfly is used for array storage.
 403         // We do not need to hold this lock for contiguous butterflies. We do not reuse the existing
 404         // butterfly with contiguous shape for new array storage butterfly. When converting the butterfly
 405         // with contiguous shape to array storage, we always allocate a new one. Holding this lock for contiguous
 406         // butterflies is unnecessary since contiguous shaped butterfly never becomes broken state.
 407         locker = holdLock(cellLock());
 408         break;
 409     default:
 410         break;
 411     }
 412     butterfly = indexingModeDependency.consume(this)-&gt;butterfly();
 413     Dependency butterflyDependency = Dependency::fence(butterfly);
 414     if (!butterfly)
 415         return structure;
 416     if (butterflyDependency.consume(this)-&gt;structureID() != structureID)
 417         return nullptr;
<span class="line-modified"> 418     if (butterflyDependency.consume(structure)-&gt;lastOffset() != lastOffset)</span>
 419         return nullptr;
 420 
<span class="line-modified"> 421     markAuxiliaryAndVisitOutOfLineProperties(visitor, butterfly, structure, lastOffset);</span>
 422     ASSERT(indexingMode == structure-&gt;indexingMode());
 423     visitElements(indexingMode);
 424 
 425     return structure;
 426 }
 427 
 428 size_t JSObject::estimatedSize(JSCell* cell, VM&amp; vm)
 429 {
 430     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 431     size_t butterflyOutOfLineSize = thisObject-&gt;m_butterfly ? thisObject-&gt;structure(vm)-&gt;outOfLineSize() : 0;
 432     return Base::estimatedSize(cell, vm) + butterflyOutOfLineSize;
 433 }
 434 
 435 void JSObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 436 {
 437     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 438     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
<span class="line-modified"> 439 #if !ASSERT_DISABLED</span>
 440     bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
 441     visitor.m_isCheckingForDefaultMarkViolation = false;
 442 #endif
 443 
 444     JSCell::visitChildren(thisObject, visitor);
 445 
 446     thisObject-&gt;visitButterfly(visitor);
 447 
<span class="line-modified"> 448 #if !ASSERT_DISABLED</span>
 449     visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
 450 #endif
 451 }
 452 
 453 void JSObject::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)
 454 {
 455     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 456     Base::analyzeHeap(cell, analyzer);
 457 
 458     Structure* structure = thisObject-&gt;structure();
 459     for (auto&amp; entry : structure-&gt;getPropertiesConcurrently()) {
 460         JSValue toValue = thisObject-&gt;getDirect(entry.offset);
 461         if (toValue &amp;&amp; toValue.isCell())
 462             analyzer.analyzePropertyNameEdge(thisObject, toValue.asCell(), entry.key);
 463     }
 464 
 465     Butterfly* butterfly = thisObject-&gt;butterfly();
 466     if (butterfly) {
 467         WriteBarrier&lt;Unknown&gt;* data = nullptr;
 468         uint32_t count = 0;
</pre>
<hr />
<pre>
 475         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 476             data = butterfly-&gt;arrayStorage()-&gt;m_vector;
 477             count = butterfly-&gt;arrayStorage()-&gt;vectorLength();
 478             break;
 479         default:
 480             break;
 481         }
 482 
 483         for (uint32_t i = 0; i &lt; count; ++i) {
 484             JSValue toValue = data[i].get();
 485             if (toValue &amp;&amp; toValue.isCell())
 486                 analyzer.analyzeIndexEdge(thisObject, toValue.asCell(), i);
 487         }
 488     }
 489 }
 490 
 491 void JSFinalObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 492 {
 493     JSFinalObject* thisObject = jsCast&lt;JSFinalObject*&gt;(cell);
 494     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
<span class="line-modified"> 495 #if !ASSERT_DISABLED</span>
 496     bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
 497     visitor.m_isCheckingForDefaultMarkViolation = false;
 498 #endif
 499 
 500     JSCell::visitChildren(thisObject, visitor);
 501 
 502     if (Structure* structure = thisObject-&gt;visitButterfly(visitor)) {
 503         if (unsigned storageSize = structure-&gt;inlineSize())
 504             visitor.appendValuesHidden(thisObject-&gt;inlineStorage(), storageSize);
 505     }
 506 
<span class="line-modified"> 507 #if !ASSERT_DISABLED</span>
 508     visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
 509 #endif
 510 }
 511 
 512 String JSObject::className(const JSObject* object, VM&amp; vm)
 513 {
 514     const ClassInfo* info = object-&gt;classInfo(vm);
 515     ASSERT(info);
 516     return info-&gt;className;
 517 }
 518 
<span class="line-modified"> 519 String JSObject::toStringName(const JSObject* object, ExecState* exec)</span>
 520 {
<span class="line-modified"> 521     VM&amp; vm = exec-&gt;vm();</span>
 522     const ClassInfo* info = object-&gt;classInfo(vm);
 523     ASSERT(info);
 524     return info-&gt;className;
 525 }
 526 
 527 String JSObject::calculatedClassName(JSObject* object)
 528 {
 529     String constructorFunctionName;
 530     auto* structure = object-&gt;structure();
 531     auto* globalObject = structure-&gt;globalObject();
 532     VM&amp; vm = globalObject-&gt;vm();
 533     auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-removed"> 534     auto* exec = globalObject-&gt;globalExec();</span>
 535 
 536     // Check for a display name of obj.constructor.
 537     // This is useful to get `Foo` for the `(class Foo).prototype` object.
 538     PropertySlot slot(object, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified"> 539     if (object-&gt;getOwnPropertySlot(object, exec, vm.propertyNames-&gt;constructor, slot)) {</span>
 540         EXCEPTION_ASSERT(!scope.exception());
 541         if (slot.isValue()) {
<span class="line-modified"> 542             if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(exec, vm.propertyNames-&gt;constructor))) {</span>
 543                 if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))
 544                     constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
 545                 else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))
 546                     constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
 547             }
 548         }
 549     }
 550 
 551     EXCEPTION_ASSERT(!scope.exception() || constructorFunctionName.isNull());
 552     if (UNLIKELY(scope.exception()))
 553         scope.clearException();
 554 
 555     // Get the display name of obj.__proto__.constructor.
 556     // This is useful to get `Foo` for a `new Foo` object.
 557     if (constructorFunctionName.isNull()) {
 558         MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
 559         if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype)) {
 560             JSValue protoValue = object-&gt;getPrototypeDirect(vm);
 561             if (protoValue.isObject()) {
 562                 JSObject* protoObject = asObject(protoValue);
 563                 PropertySlot slot(protoValue, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified"> 564                 if (protoObject-&gt;getPropertySlot(exec, vm.propertyNames-&gt;constructor, slot)) {</span>
 565                     EXCEPTION_ASSERT(!scope.exception());
 566                     if (slot.isValue()) {
<span class="line-modified"> 567                         if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(exec, vm.propertyNames-&gt;constructor))) {</span>
 568                             if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))
 569                                 constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
 570                             else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))
 571                                 constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
 572                         }
 573                     }
 574                 }
 575             }
 576         }
 577     }
 578 
 579     EXCEPTION_ASSERT(!scope.exception() || constructorFunctionName.isNull());
 580     if (UNLIKELY(scope.exception()))
 581         scope.clearException();
 582 
 583     if (constructorFunctionName.isNull() || constructorFunctionName == &quot;Object&quot;) {
 584         String tableClassName = object-&gt;methodTable(vm)-&gt;className(object, vm);
 585         if (!tableClassName.isNull() &amp;&amp; tableClassName != &quot;Object&quot;)
 586             return tableClassName;
 587 
 588         String classInfoName = object-&gt;classInfo(vm)-&gt;className;
 589         if (!classInfoName.isNull())
 590             return classInfoName;
 591 
 592         if (constructorFunctionName.isNull())
 593             return &quot;Object&quot;_s;
 594     }
 595 
 596     return constructorFunctionName;
 597 }
 598 
<span class="line-modified"> 599 bool JSObject::getOwnPropertySlotByIndex(JSObject* thisObject, ExecState* exec, unsigned i, PropertySlot&amp; slot)</span>
 600 {
<span class="line-modified"> 601     VM&amp; vm = exec-&gt;vm();</span>
 602 
 603     // NB. The fact that we&#39;re directly consulting our indexed storage implies that it is not
 604     // legal for anyone to override getOwnPropertySlot() without also overriding
 605     // getOwnPropertySlotByIndex().
 606 
 607     if (i &gt; MAX_ARRAY_INDEX)
<span class="line-modified"> 608         return thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, exec, Identifier::from(vm, i), slot);</span>
 609 
 610     switch (thisObject-&gt;indexingType()) {
 611     case ALL_BLANK_INDEXING_TYPES:
 612     case ALL_UNDECIDED_INDEXING_TYPES:
 613         break;
 614 
 615     case ALL_INT32_INDEXING_TYPES:
 616     case ALL_CONTIGUOUS_INDEXING_TYPES: {
 617         Butterfly* butterfly = thisObject-&gt;butterfly();
 618         if (i &gt;= butterfly-&gt;vectorLength())
 619             return false;
 620 
 621         JSValue value = butterfly-&gt;contiguous().at(thisObject, i).get();
 622         if (value) {
 623             slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), value);
 624             return true;
 625         }
 626 
 627         return false;
 628     }
</pre>
<hr />
<pre>
 654             }
 655         } else if (SparseArrayValueMap* map = storage-&gt;m_sparseMap.get()) {
 656             SparseArrayValueMap::iterator it = map-&gt;find(i);
 657             if (it != map-&gt;notFound()) {
 658                 it-&gt;value.get(thisObject, slot);
 659                 return true;
 660             }
 661         }
 662         break;
 663     }
 664 
 665     default:
 666         RELEASE_ASSERT_NOT_REACHED();
 667         break;
 668     }
 669 
 670     return false;
 671 }
 672 
 673 // https://tc39.github.io/ecma262/#sec-ordinaryset
<span class="line-modified"> 674 bool ordinarySetSlow(ExecState* exec, JSObject* object, PropertyName propertyName, JSValue value, JSValue receiver, bool shouldThrow)</span>
 675 {
 676     // If we find the receiver is not the same to the object, we fall to this slow path.
 677     // Currently, there are 3 candidates.
 678     // 1. Reflect.set can alter the receiver with an arbitrary value.
 679     // 2. Window Proxy.
 680     // 3. ES6 Proxy.
 681 
<span class="line-modified"> 682     VM&amp; vm = exec-&gt;vm();</span>
 683     auto scope = DECLARE_THROW_SCOPE(vm);
 684     JSObject* current = object;
 685     PropertyDescriptor ownDescriptor;
 686     while (true) {
 687         if (current-&gt;type() == ProxyObjectType) {
 688             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
 689             PutPropertySlot slot(receiver, shouldThrow);
<span class="line-modified"> 690             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));</span>
 691         }
 692 
 693         // 9.1.9.1-2 Let ownDesc be ? O.[[GetOwnProperty]](P).
<span class="line-modified"> 694         bool ownDescriptorFound = current-&gt;getOwnPropertyDescriptor(exec, propertyName, ownDescriptor);</span>
 695         RETURN_IF_EXCEPTION(scope, false);
 696 
 697         if (!ownDescriptorFound) {
 698             // 9.1.9.1-3-a Let parent be ? O.[[GetPrototypeOf]]().
<span class="line-modified"> 699             JSValue prototype = current-&gt;getPrototype(vm, exec);</span>
 700             RETURN_IF_EXCEPTION(scope, false);
 701 
 702             // 9.1.9.1-3-b If parent is not null, then
 703             if (!prototype.isNull()) {
 704                 // 9.1.9.1-3-b-i Return ? parent.[[Set]](P, V, Receiver).
 705                 current = asObject(prototype);
 706                 continue;
 707             }
 708             // 9.1.9.1-3-c-i Let ownDesc be the PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.
 709             ownDescriptor = PropertyDescriptor(jsUndefined(), static_cast&lt;unsigned&gt;(PropertyAttribute::None));
 710         }
 711         break;
 712     }
 713 
 714     // 9.1.9.1-4 If IsDataDescriptor(ownDesc) is true, then
 715     if (ownDescriptor.isDataDescriptor()) {
 716         // 9.1.9.1-4-a If ownDesc.[[Writable]] is false, return false.
 717         if (!ownDescriptor.writable())
<span class="line-modified"> 718             return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
 719 
 720         // 9.1.9.1-4-b If Type(Receiver) is not Object, return false.
 721         if (!receiver.isObject())
<span class="line-modified"> 722             return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
 723 
 724         // In OrdinarySet, the receiver may not be the same to the object.
 725         // So, we perform [[GetOwnProperty]] onto the receiver while we already perform [[GetOwnProperty]] onto the object.
 726 
 727         // 9.1.9.1-4-c Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).
 728         JSObject* receiverObject = asObject(receiver);
 729         PropertyDescriptor existingDescriptor;
<span class="line-modified"> 730         bool existingDescriptorFound = receiverObject-&gt;getOwnPropertyDescriptor(exec, propertyName, existingDescriptor);</span>
 731         RETURN_IF_EXCEPTION(scope, false);
 732 
 733         // 9.1.9.1-4-d If existingDescriptor is not undefined, then
 734         if (existingDescriptorFound) {
 735             // 9.1.9.1-4-d-i If IsAccessorDescriptor(existingDescriptor) is true, return false.
 736             if (existingDescriptor.isAccessorDescriptor())
<span class="line-modified"> 737                 return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
 738 
 739             // 9.1.9.1-4-d-ii If existingDescriptor.[[Writable]] is false, return false.
 740             if (!existingDescriptor.writable())
<span class="line-modified"> 741                 return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
 742 
 743             // 9.1.9.1-4-d-iii Let valueDesc be the PropertyDescriptor{[[Value]]: V}.
 744             PropertyDescriptor valueDescriptor;
 745             valueDescriptor.setValue(value);
 746 
 747             // 9.1.9.1-4-d-iv Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).
<span class="line-modified"> 748             RELEASE_AND_RETURN(scope, receiverObject-&gt;methodTable(vm)-&gt;defineOwnProperty(receiverObject, exec, propertyName, valueDescriptor, shouldThrow));</span>
 749         }
 750 
 751         // 9.1.9.1-4-e Else Receiver does not currently have a property P,
 752         // 9.1.9.1-4-e-i Return ? CreateDataProperty(Receiver, P, V).
<span class="line-modified"> 753         RELEASE_AND_RETURN(scope, receiverObject-&gt;methodTable(vm)-&gt;defineOwnProperty(receiverObject, exec, propertyName, PropertyDescriptor(value, static_cast&lt;unsigned&gt;(PropertyAttribute::None)), shouldThrow));</span>
 754     }
 755 
 756     // 9.1.9.1-5 Assert: IsAccessorDescriptor(ownDesc) is true.
 757     ASSERT(ownDescriptor.isAccessorDescriptor());
 758 
 759     // 9.1.9.1-6 Let setter be ownDesc.[[Set]].
 760     // 9.1.9.1-7 If setter is undefined, return false.
 761     JSValue setter = ownDescriptor.setter();
 762     if (!setter.isObject())
<span class="line-modified"> 763         return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
 764 
 765     // 9.1.9.1-8 Perform ? Call(setter, Receiver, &lt;&lt; V &gt;&gt;).
 766     JSObject* setterObject = asObject(setter);
 767     MarkedArgumentBuffer args;
 768     args.append(value);
 769     ASSERT(!args.hasOverflowed());
 770 
 771     CallData callData;
 772     CallType callType = setterObject-&gt;methodTable(vm)-&gt;getCallData(setterObject, callData);
 773     scope.release();
<span class="line-modified"> 774     call(exec, setterObject, callType, callData, receiver, args);</span>
 775 
 776     // 9.1.9.1-9 Return true.
 777     return true;
 778 }
 779 
 780 // ECMA 8.6.2.2
<span class="line-modified"> 781 bool JSObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
 782 {
<span class="line-modified"> 783     return putInlineForJSObject(cell, exec, propertyName, value, slot);</span>
 784 }
 785 
<span class="line-modified"> 786 bool JSObject::putInlineSlow(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
 787 {
 788     ASSERT(!isThisValueAltered(slot, this));
 789 
<span class="line-modified"> 790     VM&amp; vm = exec-&gt;vm();</span>
 791     auto scope = DECLARE_THROW_SCOPE(vm);
 792 
 793     JSObject* obj = this;
 794     for (;;) {
 795         Structure* structure = obj-&gt;structure(vm);
 796         if (UNLIKELY(structure-&gt;typeInfo().hasPutPropertySecurityCheck())) {
<span class="line-modified"> 797             obj-&gt;methodTable(vm)-&gt;doPutPropertySecurityCheck(obj, exec, propertyName, slot);</span>
 798             RETURN_IF_EXCEPTION(scope, false);
 799         }
 800         unsigned attributes;
 801         PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
 802         if (isValidOffset(offset)) {
 803             if (attributes &amp; PropertyAttribute::ReadOnly) {
 804                 ASSERT(this-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName) || obj == this);
<span class="line-modified"> 805                 return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
 806             }
 807 
 808             JSValue gs = obj-&gt;getDirect(offset);
 809             if (gs.isGetterSetter()) {
 810                 // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
 811                 if (!this-&gt;structure(vm)-&gt;isDictionary())
 812                     slot.setCacheableSetter(obj, offset);
 813 
<span class="line-modified"> 814                 bool result = callSetter(exec, slot.thisValue(), gs, value, slot.isStrictMode() ? StrictMode : NotStrictMode);</span>
 815                 RETURN_IF_EXCEPTION(scope, false);
 816                 return result;
 817             }
 818             if (gs.isCustomGetterSetter()) {
 819                 // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
 820                 if (attributes &amp; PropertyAttribute::CustomAccessor)
 821                     slot.setCustomAccessor(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
 822                 else
 823                     slot.setCustomValue(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
 824 
<span class="line-modified"> 825                 bool result = callCustomSetter(exec, gs, attributes &amp; PropertyAttribute::CustomAccessor, obj, slot.thisValue(), value);</span>
 826                 RETURN_IF_EXCEPTION(scope, false);
 827                 return result;
 828             }
 829             ASSERT(!(attributes &amp; PropertyAttribute::Accessor));
 830 
 831             // If there&#39;s an existing property on the base object, or on one of its
 832             // prototypes, we should store the property on the *base* object.
 833             break;
 834         }
 835         if (!obj-&gt;staticPropertiesReified(vm)) {
 836             if (obj-&gt;classInfo(vm)-&gt;hasStaticSetterOrReadonlyProperties()) {
 837                 if (auto entry = obj-&gt;findPropertyHashEntry(vm, propertyName))
<span class="line-modified"> 838                     RELEASE_AND_RETURN(scope, putEntry(exec, entry-&gt;table-&gt;classForThis, entry-&gt;value, obj, this, propertyName, value, slot));</span>
 839             }
 840         }
 841         if (obj-&gt;type() == ProxyObjectType) {
<span class="line-removed"> 842             // FIXME: We shouldn&#39;t unconditionally perform [[Set]] here.</span>
<span class="line-removed"> 843             // We need to do more because this is observable behavior.</span>
<span class="line-removed"> 844             // https://bugs.webkit.org/show_bug.cgi?id=155012</span>
 845             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(obj);
<span class="line-modified"> 846             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));</span>
 847         }
<span class="line-modified"> 848         JSValue prototype = obj-&gt;getPrototype(vm, exec);</span>
 849         RETURN_IF_EXCEPTION(scope, false);
 850         if (prototype.isNull())
 851             break;
 852         obj = asObject(prototype);
 853     }
 854 
 855     if (!putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot))
<span class="line-modified"> 856         return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
 857     return true;
 858 }
 859 
<span class="line-modified"> 860 bool JSObject::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)</span>
 861 {
<span class="line-modified"> 862     VM&amp; vm = exec-&gt;vm();</span>
 863     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 864 
 865     if (propertyName &gt; MAX_ARRAY_INDEX) {
 866         PutPropertySlot slot(cell, shouldThrow);
<span class="line-modified"> 867         return thisObject-&gt;methodTable(vm)-&gt;put(thisObject, exec, Identifier::from(vm, propertyName), value, slot);</span>
 868     }
 869 
 870     thisObject-&gt;ensureWritable(vm);
 871 
 872     switch (thisObject-&gt;indexingType()) {
 873     case ALL_BLANK_INDEXING_TYPES:
 874         break;
 875 
 876     case ALL_UNDECIDED_INDEXING_TYPES: {
 877         thisObject-&gt;convertUndecidedForValue(vm, value);
 878         // Reloop.
<span class="line-modified"> 879         return putByIndex(cell, exec, propertyName, value, shouldThrow);</span>
 880     }
 881 
 882     case ALL_INT32_INDEXING_TYPES: {
 883         if (!value.isInt32()) {
 884             thisObject-&gt;convertInt32ForValue(vm, value);
<span class="line-modified"> 885             return putByIndex(cell, exec, propertyName, value, shouldThrow);</span>
 886         }
 887         FALLTHROUGH;
 888     }
 889 
 890     case ALL_CONTIGUOUS_INDEXING_TYPES: {
 891         Butterfly* butterfly = thisObject-&gt;butterfly();
 892         if (propertyName &gt;= butterfly-&gt;vectorLength())
 893             break;
<span class="line-modified"> 894         butterfly-&gt;contiguous().at(thisObject, propertyName).set(vm, thisObject, value);</span>
 895         if (propertyName &gt;= butterfly-&gt;publicLength())
 896             butterfly-&gt;setPublicLength(propertyName + 1);

 897         return true;
 898     }
 899 
 900     case ALL_DOUBLE_INDEXING_TYPES: {
 901         if (!value.isNumber()) {
 902             thisObject-&gt;convertDoubleToContiguous(vm);
 903             // Reloop.
<span class="line-modified"> 904             return putByIndex(cell, exec, propertyName, value, shouldThrow);</span>
 905         }
 906 
 907         double valueAsDouble = value.asNumber();
 908         if (valueAsDouble != valueAsDouble) {
 909             thisObject-&gt;convertDoubleToContiguous(vm);
 910             // Reloop.
<span class="line-modified"> 911             return putByIndex(cell, exec, propertyName, value, shouldThrow);</span>
 912         }
 913         Butterfly* butterfly = thisObject-&gt;butterfly();
 914         if (propertyName &gt;= butterfly-&gt;vectorLength())
 915             break;
 916         butterfly-&gt;contiguousDouble().at(thisObject, propertyName) = valueAsDouble;
 917         if (propertyName &gt;= butterfly-&gt;publicLength())
 918             butterfly-&gt;setPublicLength(propertyName + 1);
 919         return true;
 920     }
 921 
 922     case NonArrayWithArrayStorage:
 923     case ArrayWithArrayStorage: {
 924         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
 925 
 926         if (propertyName &gt;= storage-&gt;vectorLength())
 927             break;
 928 
 929         WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[propertyName];
 930         unsigned length = storage-&gt;length();
 931 
</pre>
<hr />
<pre>
 939 
 940         valueSlot.set(vm, thisObject, value);
 941         return true;
 942     }
 943 
 944     case NonArrayWithSlowPutArrayStorage:
 945     case ArrayWithSlowPutArrayStorage: {
 946         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
 947 
 948         if (propertyName &gt;= storage-&gt;vectorLength())
 949             break;
 950 
 951         WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[propertyName];
 952         unsigned length = storage-&gt;length();
 953 
 954         auto scope = DECLARE_THROW_SCOPE(vm);
 955 
 956         // Update length &amp; m_numValuesInVector as necessary.
 957         if (propertyName &gt;= length) {
 958             bool putResult = false;
<span class="line-modified"> 959             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult);</span>
 960             RETURN_IF_EXCEPTION(scope, false);
 961             if (result)
 962                 return putResult;
 963             length = propertyName + 1;
 964             storage-&gt;setLength(length);
 965             ++storage-&gt;m_numValuesInVector;
 966         } else if (!valueSlot) {
 967             bool putResult = false;
<span class="line-modified"> 968             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult);</span>
 969             RETURN_IF_EXCEPTION(scope, false);
 970             if (result)
 971                 return putResult;
 972             ++storage-&gt;m_numValuesInVector;
 973         }
 974 
 975         valueSlot.set(vm, thisObject, value);
 976         return true;
 977     }
 978 
 979     default:
 980         RELEASE_ASSERT_NOT_REACHED();
 981     }
 982 
<span class="line-modified"> 983     return thisObject-&gt;putByIndexBeyondVectorLength(exec, propertyName, value, shouldThrow);</span>
 984 }
 985 
 986 ArrayStorage* JSObject::enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(VM&amp; vm, ArrayStorage* storage)
 987 {
 988     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
 989 
 990     if (!map)
 991         map = allocateSparseIndexMap(vm);
 992 
 993     if (map-&gt;sparseMode())
 994         return storage;
 995 
 996     map-&gt;setSparseMode();
 997 
 998     unsigned usedVectorLength = std::min(storage-&gt;length(), storage-&gt;vectorLength());
 999     for (unsigned i = 0; i &lt; usedVectorLength; ++i) {
1000         JSValue value = storage-&gt;m_vector[i].get();
1001         // This will always be a new entry in the map, so no need to check we can write,
1002         // and attributes are default so no need to set them.
1003         if (value)
</pre>
<hr />
<pre>
1193 {
1194     ASSERT(hasUndecided(indexingType()));
1195 
1196     Butterfly* butterfly = m_butterfly.get();
1197     for (unsigned i = butterfly-&gt;vectorLength(); i--;)
1198         butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(JSValue());
1199 
1200     WTF::storeStoreFence();
1201     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateContiguous));
1202     return m_butterfly-&gt;contiguous();
1203 }
1204 
1205 ArrayStorage* JSObject::constructConvertedArrayStorageWithoutCopyingElements(VM&amp; vm, unsigned neededLength)
1206 {
1207     Structure* structure = this-&gt;structure(vm);
1208     unsigned publicLength = m_butterfly-&gt;publicLength();
1209     unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
1210 
1211     Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, 0, propertyCapacity, true, ArrayStorage::sizeFor(neededLength));
1212 
<span class="line-modified">1213     memcpy(</span>
<span class="line-modified">1214         newButterfly-&gt;base(0, propertyCapacity),</span>
<span class="line-modified">1215         m_butterfly-&gt;base(0, propertyCapacity),</span>
1216         propertyCapacity * sizeof(EncodedJSValue));
1217 
1218     ArrayStorage* newStorage = newButterfly-&gt;arrayStorage();
1219     newStorage-&gt;setVectorLength(neededLength);
1220     newStorage-&gt;setLength(publicLength);
1221     newStorage-&gt;m_sparseMap.clear();
1222     newStorage-&gt;m_indexBias = 0;
1223     newStorage-&gt;m_numValuesInVector = 0;
1224 
1225     return newStorage;
1226 }
1227 
1228 ArrayStorage* JSObject::convertUndecidedToArrayStorage(VM&amp; vm, NonPropertyTransition transition)
1229 {
1230     DeferGC deferGC(vm.heap);
1231     ASSERT(hasUndecided(indexingType()));
1232 
1233     unsigned vectorLength = m_butterfly-&gt;vectorLength();
1234     ArrayStorage* storage = constructConvertedArrayStorageWithoutCopyingElements(vm, vectorLength);
1235 
</pre>
<hr />
<pre>
1486 
1487     if (value.isDouble() &amp;&amp; !std::isnan(value.asDouble())) {
1488         convertInt32ToDouble(vm);
1489         return;
1490     }
1491 
1492     convertInt32ToContiguous(vm);
1493 }
1494 
1495 void JSObject::convertFromCopyOnWrite(VM&amp; vm)
1496 {
1497     ASSERT(isCopyOnWrite(indexingMode()));
1498     ASSERT(structure(vm)-&gt;indexingMode() == indexingMode());
1499 
1500     const bool hasIndexingHeader = true;
1501     Butterfly* oldButterfly = butterfly();
1502     size_t propertyCapacity = 0;
1503     unsigned newVectorLength = Butterfly::optimalContiguousVectorLength(propertyCapacity, std::min(oldButterfly-&gt;vectorLength() * 2, MAX_STORAGE_VECTOR_LENGTH));
1504     Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, 0, propertyCapacity, hasIndexingHeader, newVectorLength * sizeof(JSValue));
1505 
<span class="line-modified">1506     memcpy(newButterfly-&gt;propertyStorage(), oldButterfly-&gt;propertyStorage(), oldButterfly-&gt;vectorLength() * sizeof(JSValue) + sizeof(IndexingHeader));</span>
1507 
1508     WTF::storeStoreFence();
1509     NonPropertyTransition transition = ([&amp;] () {
1510         switch (indexingType()) {
1511         case ArrayWithInt32:
1512             return NonPropertyTransition::AllocateInt32;
1513         case ArrayWithDouble:
1514             return NonPropertyTransition::AllocateDouble;
1515         case ArrayWithContiguous:
1516             return NonPropertyTransition::AllocateContiguous;
1517         default:
1518             RELEASE_ASSERT_NOT_REACHED();
1519             return NonPropertyTransition::AllocateContiguous;
1520         }
1521     })();
1522     StructureID oldStructureID = structureID();
1523     Structure* newStructure = Structure::nonPropertyTransition(vm, structure(vm), transition);
1524     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1525     setStructure(vm, newStructure);
1526 }
</pre>
<hr />
<pre>
1792     } else
1793         putDirect(vm, knownPolyProtoOffset, prototype);
1794 
1795     if (!anyObjectInChainMayInterceptIndexedAccesses(vm))
1796         return;
1797 
1798     if (mayBePrototype()) {
1799         structure(vm)-&gt;globalObject()-&gt;haveABadTime(vm);
1800         return;
1801     }
1802 
1803     if (!hasIndexedProperties(indexingType()))
1804         return;
1805 
1806     if (shouldUseSlowPut(indexingType()))
1807         return;
1808 
1809     switchToSlowPutArrayStorage(vm);
1810 }
1811 
<span class="line-modified">1812 bool JSObject::setPrototypeWithCycleCheck(VM&amp; vm, ExecState* exec, JSValue prototype, bool shouldThrowIfCantSet)</span>
1813 {
1814     auto scope = DECLARE_THROW_SCOPE(vm);
1815 
1816     if (this-&gt;structure(vm)-&gt;isImmutablePrototypeExoticObject()) {
1817         // This implements https://tc39.github.io/ecma262/#sec-set-immutable-prototype.
<span class="line-modified">1818         if (this-&gt;getPrototype(vm, exec) == prototype)</span>
1819             return true;
1820 
<span class="line-modified">1821         return typeError(exec, scope, shouldThrowIfCantSet, &quot;Cannot set prototype of immutable prototype object&quot;_s);</span>
1822     }
1823 
<span class="line-modified">1824     ASSERT(methodTable(vm)-&gt;toThis(this, exec, NotStrictMode) == this);</span>
1825 
1826     if (this-&gt;getPrototypeDirect(vm) == prototype)
1827         return true;
1828 
<span class="line-modified">1829     bool isExtensible = this-&gt;isExtensible(exec);</span>
1830     RETURN_IF_EXCEPTION(scope, false);
1831 
1832     if (!isExtensible)
<span class="line-modified">1833         return typeError(exec, scope, shouldThrowIfCantSet, ReadonlyPropertyWriteError);</span>
1834 
1835     JSValue nextPrototype = prototype;
1836     while (nextPrototype &amp;&amp; nextPrototype.isObject()) {
1837         if (nextPrototype == this)
<span class="line-modified">1838             return typeError(exec, scope, shouldThrowIfCantSet, &quot;cyclic __proto__ value&quot;_s);</span>
1839         // FIXME: The specification currently says we should check if the [[GetPrototypeOf]] internal method of nextPrototype
1840         // is not the ordinary object internal method. However, we currently restrict this to Proxy objects as it would allow
1841         // for cycles with certain HTML objects (WindowProxy, Location) otherwise.
1842         // https://bugs.webkit.org/show_bug.cgi?id=161534
1843         if (UNLIKELY(asObject(nextPrototype)-&gt;type() == ProxyObjectType))
1844             break; // We&#39;re done. Set the prototype.
1845         nextPrototype = asObject(nextPrototype)-&gt;getPrototypeDirect(vm);
1846     }
1847     setPrototypeDirect(vm, prototype);
1848     return true;
1849 }
1850 
<span class="line-modified">1851 bool JSObject::setPrototype(JSObject* object, ExecState* exec, JSValue prototype, bool shouldThrowIfCantSet)</span>
1852 {
<span class="line-modified">1853     return object-&gt;setPrototypeWithCycleCheck(exec-&gt;vm(), exec, prototype, shouldThrowIfCantSet);</span>
1854 }
1855 
<span class="line-modified">1856 JSValue JSObject::getPrototype(JSObject* object, ExecState* exec)</span>
1857 {
<span class="line-modified">1858     return object-&gt;getPrototypeDirect(exec-&gt;vm());</span>
1859 }
1860 
<span class="line-modified">1861 bool JSObject::setPrototype(VM&amp; vm, ExecState* exec, JSValue prototype, bool shouldThrowIfCantSet)</span>
1862 {
<span class="line-modified">1863     return methodTable(vm)-&gt;setPrototype(this, exec, prototype, shouldThrowIfCantSet);</span>
1864 }
1865 
<span class="line-modified">1866 bool JSObject::putGetter(ExecState* exec, PropertyName propertyName, JSValue getter, unsigned attributes)</span>
1867 {
1868     PropertyDescriptor descriptor;
1869     descriptor.setGetter(getter);
1870 
1871     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1872     if (!(attributes &amp; PropertyAttribute::ReadOnly))
1873         descriptor.setConfigurable(true);
1874     if (!(attributes &amp; PropertyAttribute::DontEnum))
1875         descriptor.setEnumerable(true);
1876 
<span class="line-modified">1877     return defineOwnProperty(this, exec, propertyName, descriptor, true);</span>
1878 }
1879 
<span class="line-modified">1880 bool JSObject::putSetter(ExecState* exec, PropertyName propertyName, JSValue setter, unsigned attributes)</span>
1881 {
1882     PropertyDescriptor descriptor;
1883     descriptor.setSetter(setter);
1884 
1885     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1886     if (!(attributes &amp; PropertyAttribute::ReadOnly))
1887         descriptor.setConfigurable(true);
1888     if (!(attributes &amp; PropertyAttribute::DontEnum))
1889         descriptor.setEnumerable(true);
1890 
<span class="line-modified">1891     return defineOwnProperty(this, exec, propertyName, descriptor, true);</span>
1892 }
1893 
<span class="line-modified">1894 bool JSObject::putDirectAccessor(ExecState* exec, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)</span>
1895 {
1896     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1897 
1898     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">1899         return putDirectIndex(exec, index.value(), accessor, attributes, PutDirectIndexLikePutDirect);</span>
1900 
<span class="line-modified">1901     return putDirectNonIndexAccessor(exec-&gt;vm(), propertyName, accessor, attributes);</span>
1902 }
1903 
1904 // FIXME: Introduce a JSObject::putDirectCustomValue() method instead of using
1905 // JSObject::putDirectCustomAccessor() to put CustomValues.
1906 // https://bugs.webkit.org/show_bug.cgi?id=192576
1907 bool JSObject::putDirectCustomAccessor(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes)
1908 {
1909     ASSERT(!parseIndex(propertyName));
1910     ASSERT(value.isCustomGetterSetter());
1911     if (!(attributes &amp; PropertyAttribute::CustomAccessor))
1912         attributes |= PropertyAttribute::CustomValue;
1913 
1914     PutPropertySlot slot(this);
1915     bool result = putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, value, attributes, slot);
1916 
1917     ASSERT(slot.type() == PutPropertySlot::NewProperty);
1918 
1919     Structure* structure = this-&gt;structure(vm);
1920     if (attributes &amp; PropertyAttribute::ReadOnly)
1921         structure-&gt;setContainsReadOnlyProperties();
</pre>
<hr />
<pre>
1935 
1936     structure-&gt;setHasGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
1937     return result;
1938 }
1939 
1940 void JSObject::putDirectNonIndexAccessorWithoutTransition(VM&amp; vm, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)
1941 {
1942     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1943     StructureID structureID = this-&gt;structureID();
1944     Structure* structure = vm.heap.structureIDTable().get(structureID);
1945     PropertyOffset offset = prepareToPutDirectWithoutTransition(vm, propertyName, attributes, structureID, structure);
1946     putDirect(vm, offset, accessor);
1947     if (attributes &amp; PropertyAttribute::ReadOnly)
1948         structure-&gt;setContainsReadOnlyProperties();
1949 
1950     structure-&gt;setHasGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
1951 }
1952 
1953 // HasProperty(O, P) from Section 7.3.10 of the spec.
1954 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hasproperty
<span class="line-modified">1955 bool JSObject::hasProperty(ExecState* exec, PropertyName propertyName) const</span>
1956 {
<span class="line-modified">1957     return hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::HasProperty);</span>
1958 }
1959 
<span class="line-modified">1960 bool JSObject::hasProperty(ExecState* exec, unsigned propertyName) const</span>
1961 {
<span class="line-modified">1962     return hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::HasProperty);</span>
1963 }
1964 
<span class="line-modified">1965 bool JSObject::hasPropertyGeneric(ExecState* exec, PropertyName propertyName, PropertySlot::InternalMethodType internalMethodType) const</span>
1966 {
1967     PropertySlot slot(this, internalMethodType);
<span class="line-modified">1968     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);</span>
1969 }
1970 
<span class="line-modified">1971 bool JSObject::hasPropertyGeneric(ExecState* exec, unsigned propertyName, PropertySlot::InternalMethodType internalMethodType) const</span>
1972 {
1973     PropertySlot slot(this, internalMethodType);
<span class="line-modified">1974     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);</span>
1975 }
1976 
1977 // ECMA 8.6.2.5
<span class="line-modified">1978 bool JSObject::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
1979 {
1980     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
<span class="line-modified">1981     VM&amp; vm = exec-&gt;vm();</span>
1982 
1983     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">1984         return thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, exec, index.value());</span>
1985 
1986     unsigned attributes;
1987 
1988     if (!thisObject-&gt;staticPropertiesReified(vm)) {
1989         if (auto entry = thisObject-&gt;findPropertyHashEntry(vm, propertyName)) {
1990             // If the static table contains a non-configurable (DontDelete) property then we can return early;
1991             // if there is a property in the storage array it too must be non-configurable (the language does
1992             // not allow repacement of a non-configurable property with a configurable one).
1993             if (entry-&gt;value-&gt;attributes() &amp; PropertyAttribute::DontDelete &amp;&amp; vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable) {
1994                 ASSERT(!isValidOffset(thisObject-&gt;structure(vm)-&gt;get(vm, propertyName, attributes)) || attributes &amp; PropertyAttribute::DontDelete);
1995                 return false;
1996             }
<span class="line-modified">1997             thisObject-&gt;reifyAllStaticProperties(exec);</span>
1998         }
1999     }
2000 
2001     Structure* structure = thisObject-&gt;structure(vm);
2002 
2003     bool propertyIsPresent = isValidOffset(structure-&gt;get(vm, propertyName, attributes));
2004     if (propertyIsPresent) {
2005         if (attributes &amp; PropertyAttribute::DontDelete &amp;&amp; vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable)
2006             return false;

2007 
<span class="line-modified">2008         PropertyOffset offset;</span>
2009         if (structure-&gt;isUncacheableDictionary())
<span class="line-modified">2010             offset = structure-&gt;removePropertyWithoutTransition(vm, propertyName, [] (const ConcurrentJSLocker&amp;, PropertyOffset) { });</span>
<span class="line-modified">2011         else</span>
<span class="line-modified">2012             thisObject-&gt;setStructure(vm, Structure::removePropertyTransition(vm, structure, propertyName, offset));</span>









2013 
2014         if (offset != invalidOffset)
2015             thisObject-&gt;locationForOffset(offset)-&gt;clear();
2016     }
2017 
2018     return true;
2019 }
2020 
<span class="line-modified">2021 bool JSObject::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned i)</span>
2022 {
<span class="line-modified">2023     VM&amp; vm = exec-&gt;vm();</span>
2024     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
2025 
2026     if (i &gt; MAX_ARRAY_INDEX)
<span class="line-modified">2027         return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, exec, Identifier::from(vm, i));</span>
2028 
2029     switch (thisObject-&gt;indexingMode()) {
2030     case ALL_BLANK_INDEXING_TYPES:
2031     case ALL_UNDECIDED_INDEXING_TYPES:
2032         return true;
2033 
2034     case CopyOnWriteArrayWithInt32:
2035     case CopyOnWriteArrayWithContiguous: {
2036         Butterfly* butterfly = thisObject-&gt;butterfly();
2037         if (i &gt;= butterfly-&gt;vectorLength())
2038             return true;
2039         thisObject-&gt;convertFromCopyOnWrite(vm);
2040         FALLTHROUGH;
2041     }
2042 
2043     case ALL_WRITABLE_INT32_INDEXING_TYPES:
2044     case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES: {
2045         Butterfly* butterfly = thisObject-&gt;butterfly();
2046         if (i &gt;= butterfly-&gt;vectorLength())
2047             return true;
</pre>
<hr />
<pre>
2078             SparseArrayValueMap::iterator it = map-&gt;find(i);
2079             if (it != map-&gt;notFound()) {
2080                 if (it-&gt;value.attributes() &amp; PropertyAttribute::DontDelete)
2081                     return false;
2082                 map-&gt;remove(it);
2083             }
2084         }
2085 
2086         return true;
2087     }
2088 
2089     default:
2090         RELEASE_ASSERT_NOT_REACHED();
2091         return false;
2092     }
2093 }
2094 
2095 enum class TypeHintMode { TakesHint, DoesNotTakeHint };
2096 
2097 template&lt;TypeHintMode mode = TypeHintMode::DoesNotTakeHint&gt;
<span class="line-modified">2098 static ALWAYS_INLINE JSValue callToPrimitiveFunction(ExecState* exec, const JSObject* object, PropertyName propertyName, PreferredPrimitiveType hint)</span>
2099 {
<span class="line-modified">2100     VM&amp; vm = exec-&gt;vm();</span>
2101     auto scope = DECLARE_THROW_SCOPE(vm);
2102 
2103     PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
2104     // FIXME: Remove this when we have fixed: rdar://problem/33451840
2105     // https://bugs.webkit.org/show_bug.cgi?id=187109.
2106     constexpr bool debugNullStructure = mode == TypeHintMode::TakesHint;
<span class="line-modified">2107     bool hasProperty = const_cast&lt;JSObject*&gt;(object)-&gt;getPropertySlot&lt;debugNullStructure&gt;(exec, propertyName, slot);</span>
2108     RETURN_IF_EXCEPTION(scope, scope.exception());
<span class="line-modified">2109     JSValue function = hasProperty ? slot.getValue(exec, propertyName) : jsUndefined();</span>
2110     RETURN_IF_EXCEPTION(scope, scope.exception());
2111     if (function.isUndefinedOrNull() &amp;&amp; mode == TypeHintMode::TakesHint)
2112         return JSValue();
2113     CallData callData;
2114     CallType callType = getCallData(vm, function, callData);
2115     if (callType == CallType::None) {
2116         if (mode == TypeHintMode::TakesHint)
<span class="line-modified">2117             throwTypeError(exec, scope, &quot;Symbol.toPrimitive is not a function, undefined, or null&quot;_s);</span>
2118         return scope.exception();
2119     }
2120 
2121     MarkedArgumentBuffer callArgs;
2122     if (mode == TypeHintMode::TakesHint) {
2123         JSString* hintString = nullptr;
2124         switch (hint) {
2125         case NoPreference:
2126             hintString = vm.smallStrings.defaultString();
2127             break;
2128         case PreferNumber:
2129             hintString = vm.smallStrings.numberString();
2130             break;
2131         case PreferString:
2132             hintString = vm.smallStrings.stringString();
2133             break;
2134         }
2135         callArgs.append(hintString);
2136     }
2137     ASSERT(!callArgs.hasOverflowed());
2138 
<span class="line-modified">2139     JSValue result = call(exec, function, callType, callData, const_cast&lt;JSObject*&gt;(object), callArgs);</span>
2140     RETURN_IF_EXCEPTION(scope, scope.exception());
2141     ASSERT(!result.isGetterSetter());
2142     if (result.isObject())
<span class="line-modified">2143         return mode == TypeHintMode::DoesNotTakeHint ? JSValue() : throwTypeError(exec, scope, &quot;Symbol.toPrimitive returned an object&quot;_s);</span>
2144     return result;
2145 }
2146 
2147 // ECMA 7.1.1
<span class="line-modified">2148 JSValue JSObject::ordinaryToPrimitive(ExecState* exec, PreferredPrimitiveType hint) const</span>
2149 {
<span class="line-modified">2150     VM&amp; vm = exec-&gt;vm();</span>
2151     auto scope = DECLARE_THROW_SCOPE(vm);
2152 
2153     // Make sure that whatever default value methods there are on object&#39;s prototype chain are
2154     // being watched.
2155     for (const JSObject* object = this; object; object = object-&gt;structure(vm)-&gt;storedPrototypeObject(object))
2156         object-&gt;structure(vm)-&gt;startWatchingInternalPropertiesIfNecessary(vm);
2157 
2158     JSValue value;
2159     if (hint == PreferString) {
<span class="line-modified">2160         value = callToPrimitiveFunction(exec, this, vm.propertyNames-&gt;toString, hint);</span>
2161         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2162         if (value)
2163             return value;
<span class="line-modified">2164         value = callToPrimitiveFunction(exec, this, vm.propertyNames-&gt;valueOf, hint);</span>
2165         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2166         if (value)
2167             return value;
2168     } else {
<span class="line-modified">2169         value = callToPrimitiveFunction(exec, this, vm.propertyNames-&gt;valueOf, hint);</span>
2170         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2171         if (value)
2172             return value;
<span class="line-modified">2173         value = callToPrimitiveFunction(exec, this, vm.propertyNames-&gt;toString, hint);</span>
2174         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2175         if (value)
2176             return value;
2177     }
2178 
2179     scope.assertNoException();
2180 
<span class="line-modified">2181     return throwTypeError(exec, scope, &quot;No default value&quot;_s);</span>
2182 }
2183 
<span class="line-modified">2184 JSValue JSObject::defaultValue(const JSObject* object, ExecState* exec, PreferredPrimitiveType hint)</span>
2185 {
<span class="line-modified">2186     return object-&gt;ordinaryToPrimitive(exec, hint);</span>
2187 }
2188 
<span class="line-modified">2189 JSValue JSObject::toPrimitive(ExecState* exec, PreferredPrimitiveType preferredType) const</span>
2190 {
<span class="line-modified">2191     VM&amp; vm = exec-&gt;vm();</span>
2192     auto scope = DECLARE_THROW_SCOPE(vm);
2193 
<span class="line-modified">2194     JSValue value = callToPrimitiveFunction&lt;TypeHintMode::TakesHint&gt;(exec, this, vm.propertyNames-&gt;toPrimitiveSymbol, preferredType);</span>
2195     RETURN_IF_EXCEPTION(scope, { });
2196     if (value)
2197         return value;
2198 
<span class="line-modified">2199     RELEASE_AND_RETURN(scope, this-&gt;methodTable(vm)-&gt;defaultValue(this, exec, preferredType));</span>
2200 }
2201 
<span class="line-modified">2202 bool JSObject::getPrimitiveNumber(ExecState* exec, double&amp; number, JSValue&amp; result) const</span>
2203 {
<span class="line-modified">2204     VM&amp; vm = exec-&gt;vm();</span>
2205     auto scope = DECLARE_THROW_SCOPE(vm);
2206 
<span class="line-modified">2207     result = toPrimitive(exec, PreferNumber);</span>
2208     RETURN_IF_EXCEPTION(scope, false);
2209     scope.release();
<span class="line-modified">2210     number = result.toNumber(exec);</span>
2211     return !result.isString();
2212 }
2213 
2214 bool JSObject::getOwnStaticPropertySlot(VM&amp; vm, PropertyName propertyName, PropertySlot&amp; slot)
2215 {
2216     for (auto* info = classInfo(vm); info; info = info-&gt;parentClass) {
2217         if (auto* table = info-&gt;staticPropHashTable) {
2218             if (getStaticPropertySlotFromTable(vm, table-&gt;classForThis, *table, this, propertyName, slot))
2219                 return true;
2220         }
2221     }
2222     return false;
2223 }
2224 
<span class="line-modified">2225 auto JSObject::findPropertyHashEntry(VM&amp; vm, PropertyName propertyName) const -&gt; Optional&lt;PropertyHashEntry&gt;</span>
2226 {
<span class="line-modified">2227     for (const ClassInfo* info = classInfo(vm); info; info = info-&gt;parentClass) {</span>
<span class="line-removed">2228         if (const HashTable* propHashTable = info-&gt;staticPropHashTable) {</span>
<span class="line-removed">2229             if (const HashTableValue* entry = propHashTable-&gt;entry(propertyName))</span>
<span class="line-removed">2230                 return PropertyHashEntry { propHashTable, entry };</span>
<span class="line-removed">2231         }</span>
<span class="line-removed">2232     }</span>
<span class="line-removed">2233     return WTF::nullopt;</span>
2234 }
2235 
<span class="line-modified">2236 bool JSObject::hasInstance(ExecState* exec, JSValue value, JSValue hasInstanceValue)</span>
2237 {
<span class="line-modified">2238     VM&amp; vm = exec-&gt;vm();</span>
2239     auto scope = DECLARE_THROW_SCOPE(vm);
2240 
<span class="line-modified">2241     if (!hasInstanceValue.isUndefinedOrNull() &amp;&amp; hasInstanceValue != exec-&gt;lexicalGlobalObject()-&gt;functionProtoHasInstanceSymbolFunction()) {</span>
2242         CallData callData;
2243         CallType callType = JSC::getCallData(vm, hasInstanceValue, callData);
2244         if (callType == CallType::None) {
<span class="line-modified">2245             throwException(exec, scope, createInvalidInstanceofParameterErrorHasInstanceValueNotFunction(exec, this));</span>
2246             return false;
2247         }
2248 
2249         MarkedArgumentBuffer args;
2250         args.append(value);
2251         ASSERT(!args.hasOverflowed());
<span class="line-modified">2252         JSValue result = call(exec, hasInstanceValue, callType, callData, this, args);</span>
2253         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">2254         return result.toBoolean(exec);</span>
2255     }
2256 
2257     TypeInfo info = structure(vm)-&gt;typeInfo();
2258     if (info.implementsDefaultHasInstance()) {
<span class="line-modified">2259         JSValue prototype = get(exec, vm.propertyNames-&gt;prototype);</span>
2260         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">2261         RELEASE_AND_RETURN(scope, defaultHasInstance(exec, value, prototype));</span>
2262     }
2263     if (info.implementsHasInstance()) {
2264         if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">2265             throwStackOverflowError(exec, scope);</span>
2266             return false;
2267         }
<span class="line-modified">2268         RELEASE_AND_RETURN(scope, methodTable(vm)-&gt;customHasInstance(this, exec, value));</span>
2269     }
2270 
<span class="line-modified">2271     throwException(exec, scope, createInvalidInstanceofParameterErrorNotFunction(exec, this));</span>
2272     return false;
2273 }
2274 
<span class="line-modified">2275 bool JSObject::hasInstance(ExecState* exec, JSValue value)</span>
2276 {
<span class="line-modified">2277     VM&amp; vm = exec-&gt;vm();</span>
2278     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2279     JSValue hasInstanceValue = get(exec, vm.propertyNames-&gt;hasInstanceSymbol);</span>
2280     RETURN_IF_EXCEPTION(scope, false);
2281 
<span class="line-modified">2282     RELEASE_AND_RETURN(scope, hasInstance(exec, value, hasInstanceValue));</span>
2283 }
2284 
<span class="line-modified">2285 bool JSObject::defaultHasInstance(ExecState* exec, JSValue value, JSValue proto)</span>
2286 {
<span class="line-modified">2287     VM&amp; vm = exec-&gt;vm();</span>
2288     auto scope = DECLARE_THROW_SCOPE(vm);
2289 
2290     if (!value.isObject())
2291         return false;
2292 
2293     if (!proto.isObject()) {
<span class="line-modified">2294         throwTypeError(exec, scope, &quot;instanceof called on an object with an invalid prototype property.&quot;_s);</span>
2295         return false;
2296     }
2297 
2298     JSObject* object = asObject(value);
2299     while (true) {
<span class="line-modified">2300         JSValue objectValue = object-&gt;getPrototype(vm, exec);</span>
2301         RETURN_IF_EXCEPTION(scope, false);
2302         if (!objectValue.isObject())
2303             return false;
2304         object = asObject(objectValue);
2305         if (proto == object)
2306             return true;
2307     }
2308     ASSERT_NOT_REACHED();
2309 }
2310 
<span class="line-modified">2311 EncodedJSValue JSC_HOST_CALL objectPrivateFuncInstanceOf(ExecState* exec)</span>
2312 {
<span class="line-modified">2313     JSValue value = exec-&gt;uncheckedArgument(0);</span>
<span class="line-modified">2314     JSValue proto = exec-&gt;uncheckedArgument(1);</span>
2315 
<span class="line-modified">2316     return JSValue::encode(jsBoolean(JSObject::defaultHasInstance(exec, value, proto)));</span>
2317 }
2318 
<span class="line-modified">2319 void JSObject::getPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
2320 {
<span class="line-modified">2321     VM&amp; vm = exec-&gt;vm();</span>
2322     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2323     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, propertyNames, mode);</span>
2324     RETURN_IF_EXCEPTION(scope, void());
2325 
<span class="line-modified">2326     JSValue nextProto = object-&gt;getPrototype(vm, exec);</span>
2327     RETURN_IF_EXCEPTION(scope, void());
2328     if (nextProto.isNull())
2329         return;
2330 
2331     JSObject* prototype = asObject(nextProto);
2332     while(1) {
2333         if (prototype-&gt;structure(vm)-&gt;typeInfo().overridesGetPropertyNames()) {
2334             scope.release();
<span class="line-modified">2335             prototype-&gt;methodTable(vm)-&gt;getPropertyNames(prototype, exec, propertyNames, mode);</span>
2336             return;
2337         }
<span class="line-modified">2338         prototype-&gt;methodTable(vm)-&gt;getOwnPropertyNames(prototype, exec, propertyNames, mode);</span>
2339         RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">2340         nextProto = prototype-&gt;getPrototype(vm, exec);</span>
2341         RETURN_IF_EXCEPTION(scope, void());
2342         if (nextProto.isNull())
2343             break;
2344         prototype = asObject(nextProto);
2345     }
2346 }
2347 
<span class="line-modified">2348 void JSObject::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
2349 {
<span class="line-modified">2350     VM&amp; vm = exec-&gt;vm();</span>
2351     if (!mode.includeJSObjectProperties()) {
2352         // We still have to get non-indexed properties from any subclasses of JSObject that have them.
<span class="line-modified">2353         object-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(object, exec, propertyNames, mode);</span>
2354         return;
2355     }
2356 
2357     if (propertyNames.includeStringProperties()) {
2358         // Add numeric properties first. That appears to be the accepted convention.
2359         // FIXME: Filling PropertyNameArray with an identifier for every integer
2360         // is incredibly inefficient for large arrays. We need a different approach,
2361         // which almost certainly means a different structure for PropertyNameArray.
2362         switch (object-&gt;indexingType()) {
2363         case ALL_BLANK_INDEXING_TYPES:
2364         case ALL_UNDECIDED_INDEXING_TYPES:
2365             break;
2366 
2367         case ALL_INT32_INDEXING_TYPES:
2368         case ALL_CONTIGUOUS_INDEXING_TYPES: {
2369             Butterfly* butterfly = object-&gt;butterfly();
2370             unsigned usedLength = butterfly-&gt;publicLength();
2371             for (unsigned i = 0; i &lt; usedLength; ++i) {
2372                 if (!butterfly-&gt;contiguous().at(object, i))
2373                     continue;
</pre>
<hr />
<pre>
2402                 keys.reserveInitialCapacity(map-&gt;size());
2403 
2404                 SparseArrayValueMap::const_iterator end = map-&gt;end();
2405                 for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it) {
2406                     if (mode.includeDontEnumProperties() || !(it-&gt;value.attributes() &amp; PropertyAttribute::DontEnum))
2407                         keys.uncheckedAppend(static_cast&lt;unsigned&gt;(it-&gt;key));
2408                 }
2409 
2410                 std::sort(keys.begin(), keys.end());
2411                 for (unsigned i = 0; i &lt; keys.size(); ++i)
2412                     propertyNames.add(keys[i]);
2413             }
2414             break;
2415         }
2416 
2417         default:
2418             RELEASE_ASSERT_NOT_REACHED();
2419         }
2420     }
2421 
<span class="line-modified">2422     object-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(object, exec, propertyNames, mode);</span>
2423 }
2424 
<span class="line-modified">2425 void JSObject::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
2426 {
<span class="line-modified">2427     VM&amp; vm = exec-&gt;vm();</span>
2428     if (!object-&gt;staticPropertiesReified(vm))
<span class="line-modified">2429         getClassPropertyNames(exec, object-&gt;classInfo(vm), propertyNames, mode);</span>
2430 
2431     if (!mode.includeJSObjectProperties())
2432         return;
2433 
2434     object-&gt;structure(vm)-&gt;getPropertyNamesFromStructure(vm, propertyNames, mode);
2435 }
2436 
<span class="line-modified">2437 double JSObject::toNumber(ExecState* exec) const</span>
2438 {
<span class="line-modified">2439     VM&amp; vm = exec-&gt;vm();</span>
2440     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2441     JSValue primitive = toPrimitive(exec, PreferNumber);</span>
2442     RETURN_IF_EXCEPTION(scope, 0.0); // should be picked up soon in Nodes.cpp
<span class="line-modified">2443     RELEASE_AND_RETURN(scope, primitive.toNumber(exec));</span>
2444 }
2445 
<span class="line-modified">2446 JSString* JSObject::toString(ExecState* exec) const</span>
2447 {
<span class="line-modified">2448     VM&amp; vm = exec-&gt;vm();</span>
2449     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2450     JSValue primitive = toPrimitive(exec, PreferString);</span>
2451     RETURN_IF_EXCEPTION(scope, jsEmptyString(vm));
<span class="line-modified">2452     RELEASE_AND_RETURN(scope, primitive.toString(exec));</span>
2453 }
2454 
<span class="line-modified">2455 JSValue JSObject::toThis(JSCell* cell, ExecState*, ECMAMode)</span>
2456 {
2457     return jsCast&lt;JSObject*&gt;(cell);
2458 }
2459 
2460 void JSObject::seal(VM&amp; vm)
2461 {
2462     if (isSealed(vm))
2463         return;
2464     enterDictionaryIndexingMode(vm);
2465     setStructure(vm, Structure::sealTransition(vm, structure(vm)));
2466 }
2467 
2468 void JSObject::freeze(VM&amp; vm)
2469 {
2470     if (isFrozen(vm))
2471         return;
2472     enterDictionaryIndexingMode(vm);
2473     setStructure(vm, Structure::freezeTransition(vm, structure(vm)));
2474 }
2475 
<span class="line-modified">2476 bool JSObject::preventExtensions(JSObject* object, ExecState* exec)</span>
2477 {
<span class="line-modified">2478     VM&amp; vm = exec-&gt;vm();</span>
2479     if (!object-&gt;isStructureExtensible(vm)) {
2480         // We&#39;ve already set the internal [[PreventExtensions]] field to false.
2481         // We don&#39;t call the methodTable isExtensible here because it&#39;s not defined
2482         // that way in the specification. We are just doing an optimization here.
2483         return true;
2484     }
2485 
2486     object-&gt;enterDictionaryIndexingMode(vm);
2487     object-&gt;setStructure(vm, Structure::preventExtensionsTransition(vm, object-&gt;structure(vm)));
2488     return true;
2489 }
2490 
<span class="line-modified">2491 bool JSObject::isExtensible(JSObject* obj, ExecState* exec)</span>
2492 {
<span class="line-modified">2493     return obj-&gt;isStructureExtensible(exec-&gt;vm());</span>
2494 }
2495 
<span class="line-modified">2496 bool JSObject::isExtensible(ExecState* exec)</span>
2497 {
<span class="line-modified">2498     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2499     return methodTable(vm)-&gt;isExtensible(this, exec);</span>
2500 }
2501 
<span class="line-modified">2502 void JSObject::reifyAllStaticProperties(ExecState* exec)</span>
2503 {
<span class="line-modified">2504     VM&amp; vm = exec-&gt;vm();</span>
2505     ASSERT(!staticPropertiesReified(vm));
2506 
2507     // If this object&#39;s ClassInfo has no static properties, then nothing to reify!
2508     // We can safely set the flag to avoid the expensive check again in the future.
2509     if (!TypeInfo::hasStaticPropertyTable(inlineTypeFlags())) {
2510         structure(vm)-&gt;setStaticPropertiesReified(true);
2511         return;
2512     }
2513 
2514     if (!structure(vm)-&gt;isDictionary())
2515         setStructure(vm, Structure::toCacheableDictionaryTransition(vm, structure(vm)));
2516 
2517     for (const ClassInfo* info = classInfo(vm); info; info = info-&gt;parentClass) {
2518         const HashTable* hashTable = info-&gt;staticPropHashTable;
2519         if (!hashTable)
2520             continue;
2521 
2522         for (auto&amp; value : *hashTable) {
2523             unsigned attributes;
2524             auto key = Identifier::fromString(vm, value.m_key);
</pre>
<hr />
<pre>
2526             if (!isValidOffset(offset))
2527                 reifyStaticProperty(vm, hashTable-&gt;classForThis, key, value, *this);
2528         }
2529     }
2530 
2531     structure(vm)-&gt;setStaticPropertiesReified(true);
2532 }
2533 
2534 NEVER_INLINE void JSObject::fillGetterPropertySlot(VM&amp; vm, PropertySlot&amp; slot, JSCell* getterSetter, unsigned attributes, PropertyOffset offset)
2535 {
2536     if (structure(vm)-&gt;isUncacheableDictionary()) {
2537         slot.setGetterSlot(this, attributes, jsCast&lt;GetterSetter*&gt;(getterSetter));
2538         return;
2539     }
2540 
2541     // This access is cacheable because Structure requires an attributeChangedTransition
2542     // if this property stops being an accessor.
2543     slot.setCacheableGetterSlot(this, attributes, jsCast&lt;GetterSetter*&gt;(getterSetter), offset);
2544 }
2545 
<span class="line-modified">2546 static bool putIndexedDescriptor(ExecState* exec, SparseArrayValueMap* map, SparseArrayEntry* entryInMap, const PropertyDescriptor&amp; descriptor, PropertyDescriptor&amp; oldDescriptor)</span>
2547 {
<span class="line-modified">2548     VM&amp; vm = exec-&gt;vm();</span>
2549 
2550     if (descriptor.isDataDescriptor()) {
2551         unsigned attributes = descriptor.attributesOverridingCurrent(oldDescriptor) &amp; ~PropertyAttribute::Accessor;
2552         if (descriptor.value())
2553             entryInMap-&gt;forceSet(vm, map, descriptor.value(), attributes);
2554         else if (oldDescriptor.isAccessorDescriptor())
2555             entryInMap-&gt;forceSet(vm, map, jsUndefined(), attributes);
2556         else
2557             entryInMap-&gt;forceSet(attributes);
2558         return true;
2559     }
2560 
2561     if (descriptor.isAccessorDescriptor()) {
2562         JSObject* getter = nullptr;
2563         if (descriptor.getterPresent())
2564             getter = descriptor.getterObject();
2565         else if (oldDescriptor.isAccessorDescriptor())
2566             getter = oldDescriptor.getterObject();
2567         JSObject* setter = nullptr;
2568         if (descriptor.setterPresent())
2569             setter = descriptor.setterObject();
2570         else if (oldDescriptor.isAccessorDescriptor())
2571             setter = oldDescriptor.setterObject();
2572 
<span class="line-modified">2573         GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);</span>
2574         entryInMap-&gt;forceSet(vm, map, accessor, descriptor.attributesOverridingCurrent(oldDescriptor) &amp; ~PropertyAttribute::ReadOnly);
2575         return true;
2576     }
2577 
2578     ASSERT(descriptor.isGenericDescriptor());
2579     entryInMap-&gt;forceSet(descriptor.attributesOverridingCurrent(oldDescriptor));
2580     return true;
2581 }
2582 
2583 ALWAYS_INLINE static bool canDoFastPutDirectIndex(VM&amp; vm, JSObject* object)
2584 {
2585     return (isJSArray(object) &amp;&amp; !isCopyOnWrite(object-&gt;indexingMode()))
2586         || jsDynamicCast&lt;JSFinalObject*&gt;(vm, object)
2587         || TypeInfo::isArgumentsType(object-&gt;type());
2588 }
2589 
2590 // Defined in ES5.1 8.12.9
<span class="line-modified">2591 bool JSObject::defineOwnIndexedProperty(ExecState* exec, unsigned index, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
2592 {
<span class="line-modified">2593     VM&amp; vm = exec-&gt;vm();</span>
2594     auto scope = DECLARE_THROW_SCOPE(vm);
2595 
2596     ASSERT(index &lt;= MAX_ARRAY_INDEX);
2597 
2598     ensureWritable(vm);
2599 
2600     if (!inSparseIndexingMode()) {
2601         // Fast case: we&#39;re putting a regular property to a regular array
2602         // FIXME: this will pessimistically assume that if attributes are missing then they&#39;ll default to false
2603         // however if the property currently exists missing attributes will override from their current &#39;true&#39;
2604         // state (i.e. defineOwnProperty could be used to set a value without needing to entering &#39;SparseMode&#39;).
2605         if (!descriptor.attributes() &amp;&amp; descriptor.value() &amp;&amp; canDoFastPutDirectIndex(vm, this)) {
2606             ASSERT(!descriptor.isAccessorDescriptor());
<span class="line-modified">2607             RELEASE_AND_RETURN(scope, putDirectIndex(exec, index, descriptor.value(), 0, throwException ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow));</span>
2608         }
2609 
2610         ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm);
2611     }
2612 
2613     if (descriptor.attributes() &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor))
2614         notifyPresenceOfIndexedAccessors(vm);
2615 
2616     SparseArrayValueMap* map = m_butterfly-&gt;arrayStorage()-&gt;m_sparseMap.get();
2617     RELEASE_ASSERT(map);
2618 
2619     // 1. Let current be the result of calling the [[GetOwnProperty]] internal method of O with property name P.
2620     SparseArrayValueMap::AddResult result = map-&gt;add(this, index);
2621     SparseArrayEntry* entryInMap = &amp;result.iterator-&gt;value;
2622 
2623     // 2. Let extensible be the value of the [[Extensible]] internal property of O.
2624     // 3. If current is undefined and extensible is false, then Reject.
2625     // 4. If current is undefined and extensible is true, then
2626     if (result.isNewEntry) {
2627         if (!isStructureExtensible(vm)) {
2628             map-&gt;remove(result.iterator);
<span class="line-modified">2629             return typeError(exec, scope, throwException, NonExtensibleObjectPropertyDefineError);</span>
2630         }
2631 
2632         // 4.a. If IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is true, then create an own data property
2633         // named P of object O whose [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]] attribute values
2634         // are described by Desc. If the value of an attribute field of Desc is absent, the attribute of the newly
2635         // created property is set to its default value.
2636         // 4.b. Else, Desc must be an accessor Property Descriptor so, create an own accessor property named P of
2637         // object O whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by
2638         // Desc. If the value of an attribute field of Desc is absent, the attribute of the newly created property
2639         // is set to its default value.
2640         // 4.c. Return true.
2641 
2642         PropertyDescriptor defaults(jsUndefined(), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
<span class="line-modified">2643         putIndexedDescriptor(exec, map, entryInMap, descriptor, defaults);</span>
2644         Butterfly* butterfly = m_butterfly.get();
2645         if (index &gt;= butterfly-&gt;arrayStorage()-&gt;length())
2646             butterfly-&gt;arrayStorage()-&gt;setLength(index + 1);
2647         return true;
2648     }
2649 
2650     // 5. Return true, if every field in Desc is absent.
2651     // 6. Return true, if every field in Desc also occurs in current and the value of every field in Desc is the same value as the corresponding field in current when compared using the SameValue algorithm (9.12).
2652     PropertyDescriptor current;
2653     entryInMap-&gt;get(current);
<span class="line-modified">2654     bool isEmptyOrEqual = descriptor.isEmpty() || descriptor.equalTo(exec, current);</span>
2655     RETURN_IF_EXCEPTION(scope, false);
2656     if (isEmptyOrEqual)
2657         return true;
2658 
2659     // 7. If the [[Configurable]] field of current is false then
2660     if (!current.configurable()) {
2661         // 7.a. Reject, if the [[Configurable]] field of Desc is true.
2662         if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<span class="line-modified">2663             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
2664         // 7.b. Reject, if the [[Enumerable]] field of Desc is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other.
2665         if (descriptor.enumerablePresent() &amp;&amp; current.enumerable() != descriptor.enumerable())
<span class="line-modified">2666             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
2667     }
2668 
2669     // 8. If IsGenericDescriptor(Desc) is true, then no further validation is required.
2670     if (!descriptor.isGenericDescriptor()) {
2671         // 9. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then
2672         if (current.isDataDescriptor() != descriptor.isDataDescriptor()) {
2673             // 9.a. Reject, if the [[Configurable]] field of current is false.
2674             if (!current.configurable())
<span class="line-modified">2675                 return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
2676             // 9.b. If IsDataDescriptor(current) is true, then convert the property named P of object O from a
2677             // data property to an accessor property. Preserve the existing values of the converted property&#39;s
2678             // [[Configurable]] and [[Enumerable]] attributes and set the rest of the property&#39;s attributes to
2679             // their default values.
2680             // 9.c. Else, convert the property named P of object O from an accessor property to a data property.
2681             // Preserve the existing values of the converted property&#39;s [[Configurable]] and [[Enumerable]]
2682             // attributes and set the rest of the property&#39;s attributes to their default values.
2683         } else if (current.isDataDescriptor() &amp;&amp; descriptor.isDataDescriptor()) {
2684             // 10. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then
2685             // 10.a. If the [[Configurable]] field of current is false, then
2686             if (!current.configurable() &amp;&amp; !current.writable()) {
2687                 // 10.a.i. Reject, if the [[Writable]] field of current is false and the [[Writable]] field of Desc is true.
2688                 if (descriptor.writable())
<span class="line-modified">2689                     return typeError(exec, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
2690                 // 10.a.ii. If the [[Writable]] field of current is false, then
2691                 // 10.a.ii.1. Reject, if the [[Value]] field of Desc is present and SameValue(Desc.[[Value]], current.[[Value]]) is false.
<span class="line-modified">2692                 if (descriptor.value() &amp;&amp; !sameValue(exec, descriptor.value(), current.value()))</span>
<span class="line-modified">2693                     return typeError(exec, scope, throwException, ReadonlyPropertyChangeError);</span>




2694             }
2695             // 10.b. else, the [[Configurable]] field of current is true, so any change is acceptable.
2696         } else {
2697             ASSERT(current.isAccessorDescriptor() &amp;&amp; current.getterPresent() &amp;&amp; current.setterPresent());
2698             // 11. Else, IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true so, if the [[Configurable]] field of current is false, then
2699             if (!current.configurable()) {
2700                 // 11.i. Reject, if the [[Set]] field of Desc is present and SameValue(Desc.[[Set]], current.[[Set]]) is false.
2701                 if (descriptor.setterPresent() &amp;&amp; descriptor.setter() != current.setter())
<span class="line-modified">2702                     return typeError(exec, scope, throwException, &quot;Attempting to change the setter of an unconfigurable property.&quot;_s);</span>
2703                 // 11.ii. Reject, if the [[Get]] field of Desc is present and SameValue(Desc.[[Get]], current.[[Get]]) is false.
2704                 if (descriptor.getterPresent() &amp;&amp; descriptor.getter() != current.getter())
<span class="line-modified">2705                     return typeError(exec, scope, throwException, &quot;Attempting to change the getter of an unconfigurable property.&quot;_s);</span>
2706             }
2707         }
2708     }
2709 
2710     // 12. For each attribute field of Desc that is present, set the correspondingly named attribute of the property named P of object O to the value of the field.
<span class="line-modified">2711     putIndexedDescriptor(exec, map, entryInMap, descriptor, current);</span>
2712     // 13. Return true.
2713     return true;
2714 }
2715 
2716 SparseArrayValueMap* JSObject::allocateSparseIndexMap(VM&amp; vm)
2717 {
2718     SparseArrayValueMap* result = SparseArrayValueMap::create(vm);
2719     arrayStorage()-&gt;m_sparseMap.set(vm, this, result);
2720     return result;
2721 }
2722 
2723 void JSObject::deallocateSparseIndexMap()
2724 {
2725     if (ArrayStorage* arrayStorage = arrayStorageOrNull())
2726         arrayStorage-&gt;m_sparseMap.clear();
2727 }
2728 
<span class="line-modified">2729 bool JSObject::attemptToInterceptPutByIndexOnHoleForPrototype(ExecState* exec, JSValue thisValue, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)</span>
2730 {
<span class="line-modified">2731     VM&amp; vm = exec-&gt;vm();</span>
2732     auto scope = DECLARE_THROW_SCOPE(vm);
2733 
2734     for (JSObject* current = this; ;) {
2735         // This has the same behavior with respect to prototypes as JSObject::put(). It only
2736         // allows a prototype to intercept a put if (a) the prototype declares the property
2737         // we&#39;re after rather than intercepting it via an override of JSObject::put(), and
2738         // (b) that property is declared as ReadOnly or Accessor.
2739 
2740         ArrayStorage* storage = current-&gt;arrayStorageOrNull();
2741         if (storage &amp;&amp; storage-&gt;m_sparseMap) {
2742             SparseArrayValueMap::iterator iter = storage-&gt;m_sparseMap-&gt;find(i);
2743             if (iter != storage-&gt;m_sparseMap-&gt;notFound() &amp;&amp; (iter-&gt;value.attributes() &amp; (PropertyAttribute::Accessor | PropertyAttribute::ReadOnly))) {
2744                 scope.release();
<span class="line-modified">2745                 putResult = iter-&gt;value.put(exec, thisValue, storage-&gt;m_sparseMap.get(), value, shouldThrow);</span>
2746                 return true;
2747             }
2748         }
2749 
2750         if (current-&gt;type() == ProxyObjectType) {
2751             scope.release();
2752             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
<span class="line-modified">2753             putResult = proxy-&gt;putByIndexCommon(exec, thisValue, i, value, shouldThrow);</span>
2754             return true;
2755         }
2756 
<span class="line-modified">2757         JSValue prototypeValue = current-&gt;getPrototype(vm, exec);</span>
2758         RETURN_IF_EXCEPTION(scope, false);
2759         if (prototypeValue.isNull())
2760             return false;
2761 
2762         current = asObject(prototypeValue);
2763     }
2764 }
2765 
<span class="line-modified">2766 bool JSObject::attemptToInterceptPutByIndexOnHole(ExecState* exec, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)</span>
2767 {
<span class="line-modified">2768     VM&amp; vm = exec-&gt;vm();</span>
2769     auto scope = DECLARE_THROW_SCOPE(vm);
2770 
<span class="line-modified">2771     JSValue prototypeValue = getPrototype(vm, exec);</span>
2772     RETURN_IF_EXCEPTION(scope, false);
2773     if (prototypeValue.isNull())
2774         return false;
2775 
<span class="line-modified">2776     RELEASE_AND_RETURN(scope, asObject(prototypeValue)-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(exec, this, i, value, shouldThrow, putResult));</span>
2777 }
2778 
2779 template&lt;IndexingType indexingShape&gt;
<span class="line-modified">2780 bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes(ExecState* exec, unsigned i, JSValue value)</span>
2781 {
<span class="line-modified">2782     VM&amp; vm = exec-&gt;vm();</span>
2783     auto scope = DECLARE_THROW_SCOPE(vm);
2784 
2785     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
2786     ASSERT((indexingType() &amp; IndexingShapeMask) == indexingShape);
2787     ASSERT(!indexingShouldBeSparse(vm));
2788 
2789     Butterfly* butterfly = m_butterfly.get();
2790 
2791     // For us to get here, the index is either greater than the public length, or greater than
2792     // or equal to the vector length.
2793     ASSERT(i &gt;= butterfly-&gt;vectorLength());
2794 
2795     if (i &gt; MAX_STORAGE_VECTOR_INDEX
2796         || (i &gt;= MIN_SPARSE_ARRAY_INDEX &amp;&amp; !isDenseEnoughForVector(i, countElements&lt;indexingShape&gt;(butterfly)))
2797         || indexIsSufficientlyBeyondLengthForSparseMap(i, butterfly-&gt;vectorLength())) {
2798         ASSERT(i &lt;= MAX_ARRAY_INDEX);
2799         ensureArrayStorageSlow(vm);
2800         SparseArrayValueMap* map = allocateSparseIndexMap(vm);
<span class="line-modified">2801         bool result = map-&gt;putEntry(exec, this, i, value, false);</span>
2802         RETURN_IF_EXCEPTION(scope, false);
2803         ASSERT(i &gt;= arrayStorage()-&gt;length());
2804         arrayStorage()-&gt;setLength(i + 1);
2805         return result;
2806     }
2807 
2808     if (!ensureLength(vm, i + 1)) {
<span class="line-modified">2809         throwOutOfMemoryError(exec, scope);</span>
2810         return false;
2811     }
2812     butterfly = m_butterfly.get();
2813 
2814     RELEASE_ASSERT(i &lt; butterfly-&gt;vectorLength());
2815     switch (indexingShape) {
2816     case Int32Shape:
2817         ASSERT(value.isInt32());
2818         butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(value);
2819         return true;
2820 
2821     case DoubleShape: {
2822         ASSERT(value.isNumber());
2823         double valueAsDouble = value.asNumber();
2824         ASSERT(valueAsDouble == valueAsDouble);
2825         butterfly-&gt;contiguousDouble().at(this, i) = valueAsDouble;
2826         return true;
2827     }
2828 
2829     case ContiguousShape:
2830         butterfly-&gt;contiguous().at(this, i).set(vm, this, value);
2831         return true;
2832 
2833     default:
2834         CRASH();
2835         return false;
2836     }
2837 }
2838 
2839 // Explicit instantiations needed by JSArray.cpp.
<span class="line-modified">2840 template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(ExecState*, unsigned, JSValue);</span>
<span class="line-modified">2841 template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(ExecState*, unsigned, JSValue);</span>
<span class="line-modified">2842 template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(ExecState*, unsigned, JSValue);</span>
2843 
<span class="line-modified">2844 bool JSObject::putByIndexBeyondVectorLengthWithArrayStorage(ExecState* exec, unsigned i, JSValue value, bool shouldThrow, ArrayStorage* storage)</span>
2845 {
<span class="line-modified">2846     VM&amp; vm = exec-&gt;vm();</span>
2847     auto scope = DECLARE_THROW_SCOPE(vm);
2848 
2849     ASSERT(!isCopyOnWrite(indexingMode()));
2850     // i should be a valid array index that is outside of the current vector.
2851     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2852     ASSERT(i &gt;= storage-&gt;vectorLength());
2853 
2854     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
2855 
2856     // First, handle cases where we don&#39;t currently have a sparse map.
2857     if (LIKELY(!map)) {
2858         // If the array is not extensible, we should have entered dictionary mode, and created the sparse map.
2859         ASSERT(isStructureExtensible(vm));
2860 
2861         // Update m_length if necessary.
2862         if (i &gt;= storage-&gt;length())
2863             storage-&gt;setLength(i + 1);
2864 
2865         // Check that it is sensible to still be using a vector, and then try to grow the vector.
2866         if (LIKELY(!indexIsSufficientlyBeyondLengthForSparseMap(i, storage-&gt;vectorLength())
2867             &amp;&amp; isDenseEnoughForVector(i, storage-&gt;m_numValuesInVector)
2868             &amp;&amp; increaseVectorLength(vm, i + 1))) {
2869             // success! - reread m_storage since it has likely been reallocated, and store to the vector.
2870             storage = arrayStorage();
2871             storage-&gt;m_vector[i].set(vm, this, value);
2872             ++storage-&gt;m_numValuesInVector;
2873             return true;
2874         }
2875         // We don&#39;t want to, or can&#39;t use a vector to hold this property - allocate a sparse map &amp; add the value.
2876         map = allocateSparseIndexMap(vm);
<span class="line-modified">2877         RELEASE_AND_RETURN(scope, map-&gt;putEntry(exec, this, i, value, shouldThrow));</span>
2878     }
2879 
2880     // Update m_length if necessary.
2881     unsigned length = storage-&gt;length();
2882     if (i &gt;= length) {
2883         // Prohibit growing the array if length is not writable.
2884         if (map-&gt;lengthIsReadOnly() || !isStructureExtensible(vm))
<span class="line-modified">2885             return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
2886         length = i + 1;
2887         storage-&gt;setLength(length);
2888     }
2889 
2890     // We are currently using a map - check whether we still want to be doing so.
2891     // We will continue  to use a sparse map if SparseMode is set, a vector would be too sparse, or if allocation fails.
2892     unsigned numValuesInArray = storage-&gt;m_numValuesInVector + map-&gt;size();
2893     if (map-&gt;sparseMode() || !isDenseEnoughForVector(length, numValuesInArray) || !increaseVectorLength(vm, length))
<span class="line-modified">2894         RELEASE_AND_RETURN(scope, map-&gt;putEntry(exec, this, i, value, shouldThrow));</span>
2895 
2896     // Reread m_storage after increaseVectorLength, update m_numValuesInVector.
2897     storage = arrayStorage();
2898     storage-&gt;m_numValuesInVector = numValuesInArray;
2899 
2900     // Copy all values from the map into the vector, and delete the map.
2901     WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
2902     SparseArrayValueMap::const_iterator end = map-&gt;end();
2903     for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it)
2904         vector[it-&gt;key].set(vm, this, it-&gt;value.getNonSparseMode());
2905     deallocateSparseIndexMap();
2906 
2907     // Store the new property into the vector.
2908     WriteBarrier&lt;Unknown&gt;&amp; valueSlot = vector[i];
2909     if (!valueSlot)
2910         ++storage-&gt;m_numValuesInVector;
2911     valueSlot.set(vm, this, value);
2912     return true;
2913 }
2914 
<span class="line-modified">2915 bool JSObject::putByIndexBeyondVectorLength(ExecState* exec, unsigned i, JSValue value, bool shouldThrow)</span>
2916 {
<span class="line-modified">2917     VM&amp; vm = exec-&gt;vm();</span>
2918     auto scope = DECLARE_THROW_SCOPE(vm);
2919 
2920     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
2921 
2922     // i should be a valid array index that is outside of the current vector.
2923     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2924 
2925     switch (indexingType()) {
2926     case ALL_BLANK_INDEXING_TYPES: {
2927         if (indexingShouldBeSparse(vm)) {
2928             RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(
<span class="line-modified">2929                 exec, i, value, shouldThrow,</span>
2930                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm)));
2931         }
2932         if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {
<span class="line-modified">2933             RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(exec, i, value, shouldThrow, createArrayStorage(vm, 0, 0)));</span>
2934         }
2935         if (needsSlowPutIndexing(vm)) {
2936             // Convert the indexing type to the SlowPutArrayStorage and retry.
2937             createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
<span class="line-modified">2938             RELEASE_AND_RETURN(scope, putByIndex(this, exec, i, value, shouldThrow));</span>
2939         }
2940 
2941         createInitialForValueAndSet(vm, i, value);
2942         return true;
2943     }
2944 
2945     case ALL_UNDECIDED_INDEXING_TYPES: {
2946         CRASH();
2947         break;
2948     }
2949 
2950     case ALL_INT32_INDEXING_TYPES:
<span class="line-modified">2951         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(exec, i, value));</span>
2952 
2953     case ALL_DOUBLE_INDEXING_TYPES:
<span class="line-modified">2954         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(exec, i, value));</span>
2955 
2956     case ALL_CONTIGUOUS_INDEXING_TYPES:
<span class="line-modified">2957         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(exec, i, value));</span>
2958 
2959     case NonArrayWithSlowPutArrayStorage:
2960     case ArrayWithSlowPutArrayStorage: {
2961         // No own property present in the vector, but there might be in the sparse map!
2962         SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
2963         bool putResult = false;
2964         if (!(map &amp;&amp; map-&gt;contains(i))) {
<span class="line-modified">2965             bool result = attemptToInterceptPutByIndexOnHole(exec, i, value, shouldThrow, putResult);</span>
2966             RETURN_IF_EXCEPTION(scope, false);
2967             if (result)
2968                 return putResult;
2969         }
2970         FALLTHROUGH;
2971     }
2972 
2973     case NonArrayWithArrayStorage:
2974     case ArrayWithArrayStorage:
<span class="line-modified">2975         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(exec, i, value, shouldThrow, arrayStorage()));</span>
2976 
2977     default:
2978         RELEASE_ASSERT_NOT_REACHED();
2979     }
2980     return false;
2981 }
2982 
<span class="line-modified">2983 bool JSObject::putDirectIndexBeyondVectorLengthWithArrayStorage(ExecState* exec, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode, ArrayStorage* storage)</span>
2984 {
<span class="line-modified">2985     VM&amp; vm = exec-&gt;vm();</span>
2986     auto scope = DECLARE_THROW_SCOPE(vm);
2987 
2988     // i should be a valid array index that is outside of the current vector.
2989     ASSERT(hasAnyArrayStorage(indexingType()));
2990     ASSERT(arrayStorage() == storage);
2991     ASSERT(i &gt;= storage-&gt;vectorLength() || attributes);
2992     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2993 
2994     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
2995 
2996     // First, handle cases where we don&#39;t currently have a sparse map.
2997     if (LIKELY(!map)) {
2998         // If the array is not extensible, we should have entered dictionary mode, and created the spare map.
2999         ASSERT(isStructureExtensible(vm));
3000 
3001         // Update m_length if necessary.
3002         if (i &gt;= storage-&gt;length())
3003             storage-&gt;setLength(i + 1);
3004 
3005         // Check that it is sensible to still be using a vector, and then try to grow the vector.
3006         if (LIKELY(
3007                 !attributes
3008                 &amp;&amp; (isDenseEnoughForVector(i, storage-&gt;m_numValuesInVector))
3009                 &amp;&amp; !indexIsSufficientlyBeyondLengthForSparseMap(i, storage-&gt;vectorLength()))
3010                 &amp;&amp; increaseVectorLength(vm, i + 1)) {
3011             // success! - reread m_storage since it has likely been reallocated, and store to the vector.
3012             storage = arrayStorage();
3013             storage-&gt;m_vector[i].set(vm, this, value);
3014             ++storage-&gt;m_numValuesInVector;
3015             return true;
3016         }
3017         // We don&#39;t want to, or can&#39;t use a vector to hold this property - allocate a sparse map &amp; add the value.
3018         map = allocateSparseIndexMap(vm);
<span class="line-modified">3019         RELEASE_AND_RETURN(scope, map-&gt;putDirect(exec, this, i, value, attributes, mode));</span>
3020     }
3021 
3022     // Update m_length if necessary.
3023     unsigned length = storage-&gt;length();
3024     if (i &gt;= length) {
3025         if (mode != PutDirectIndexLikePutDirect) {
3026             // Prohibit growing the array if length is not writable.
3027             if (map-&gt;lengthIsReadOnly())
<span class="line-modified">3028                 return typeError(exec, scope, mode == PutDirectIndexShouldThrow, ReadonlyPropertyWriteError);</span>
3029             if (!isStructureExtensible(vm))
<span class="line-modified">3030                 return typeError(exec, scope, mode == PutDirectIndexShouldThrow, NonExtensibleObjectPropertyDefineError);</span>
3031         }
3032         length = i + 1;
3033         storage-&gt;setLength(length);
3034     }
3035 
3036     // We are currently using a map - check whether we still want to be doing so.
3037     // We will continue  to use a sparse map if SparseMode is set, a vector would be too sparse, or if allocation fails.
3038     unsigned numValuesInArray = storage-&gt;m_numValuesInVector + map-&gt;size();
3039     if (map-&gt;sparseMode() || attributes || !isDenseEnoughForVector(length, numValuesInArray) || !increaseVectorLength(vm, length))
<span class="line-modified">3040         RELEASE_AND_RETURN(scope, map-&gt;putDirect(exec, this, i, value, attributes, mode));</span>
3041 
3042     // Reread m_storage after increaseVectorLength, update m_numValuesInVector.
3043     storage = arrayStorage();
3044     storage-&gt;m_numValuesInVector = numValuesInArray;
3045 
3046     // Copy all values from the map into the vector, and delete the map.
3047     WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
3048     SparseArrayValueMap::const_iterator end = map-&gt;end();
3049     for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it)
3050         vector[it-&gt;key].set(vm, this, it-&gt;value.getNonSparseMode());
3051     deallocateSparseIndexMap();
3052 
3053     // Store the new property into the vector.
3054     WriteBarrier&lt;Unknown&gt;&amp; valueSlot = vector[i];
3055     if (!valueSlot)
3056         ++storage-&gt;m_numValuesInVector;
3057     valueSlot.set(vm, this, value);
3058     return true;
3059 }
3060 
<span class="line-modified">3061 bool JSObject::putDirectIndexSlowOrBeyondVectorLength(ExecState* exec, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode)</span>
3062 {
<span class="line-modified">3063     VM&amp; vm = exec-&gt;vm();</span>
3064     ASSERT(!value.isCustomGetterSetter());
3065 
3066     if (!canDoFastPutDirectIndex(vm, this)) {
3067         PropertyDescriptor descriptor;
3068         descriptor.setDescriptor(value, attributes);
<span class="line-modified">3069         return methodTable(vm)-&gt;defineOwnProperty(this, exec, Identifier::from(vm, i), descriptor, mode == PutDirectIndexShouldThrow);</span>
3070     }
3071 
3072     // i should be a valid array index that is outside of the current vector.
3073     ASSERT(i &lt;= MAX_ARRAY_INDEX);
3074 
3075     if (attributes &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor))
3076         notifyPresenceOfIndexedAccessors(vm);
3077 
3078     switch (indexingType()) {
3079     case ALL_BLANK_INDEXING_TYPES: {
3080         if (indexingShouldBeSparse(vm) || attributes) {
3081             return putDirectIndexBeyondVectorLengthWithArrayStorage(
<span class="line-modified">3082                 exec, i, value, attributes, mode,</span>
3083                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3084         }
3085         if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {
3086             return putDirectIndexBeyondVectorLengthWithArrayStorage(
<span class="line-modified">3087                 exec, i, value, attributes, mode, createArrayStorage(vm, 0, 0));</span>
3088         }
3089         if (needsSlowPutIndexing(vm)) {
3090             ArrayStorage* storage = createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
3091             storage-&gt;m_vector[i].set(vm, this, value);
3092             storage-&gt;m_numValuesInVector++;
3093             return true;
3094         }
3095 
3096         createInitialForValueAndSet(vm, i, value);
3097         return true;
3098     }
3099 
3100     case ALL_UNDECIDED_INDEXING_TYPES: {
3101         convertUndecidedForValue(vm, value);
3102         // Reloop.
<span class="line-modified">3103         return putDirectIndex(exec, i, value, attributes, mode);</span>
3104     }
3105 
3106     case ALL_INT32_INDEXING_TYPES: {
3107         ASSERT(!indexingShouldBeSparse(vm));
3108         if (attributes)
<span class="line-modified">3109             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
3110         if (!value.isInt32()) {
3111             convertInt32ForValue(vm, value);
<span class="line-modified">3112             return putDirectIndexSlowOrBeyondVectorLength(exec, i, value, attributes, mode);</span>
3113         }
<span class="line-modified">3114         putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(exec, i, value);</span>
3115         return true;
3116     }
3117 
3118     case ALL_DOUBLE_INDEXING_TYPES: {
3119         ASSERT(!indexingShouldBeSparse(vm));
3120         if (attributes)
<span class="line-modified">3121             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
3122         if (!value.isNumber()) {
3123             convertDoubleToContiguous(vm);
<span class="line-modified">3124             return putDirectIndexSlowOrBeyondVectorLength(exec, i, value, attributes, mode);</span>
3125         }
3126         double valueAsDouble = value.asNumber();
3127         if (valueAsDouble != valueAsDouble) {
3128             convertDoubleToContiguous(vm);
<span class="line-modified">3129             return putDirectIndexSlowOrBeyondVectorLength(exec, i, value, attributes, mode);</span>
3130         }
<span class="line-modified">3131         putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(exec, i, value);</span>
3132         return true;
3133     }
3134 
3135     case ALL_CONTIGUOUS_INDEXING_TYPES: {
3136         ASSERT(!indexingShouldBeSparse(vm));
3137         if (attributes)
<span class="line-modified">3138             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
<span class="line-modified">3139         putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(exec, i, value);</span>
3140         return true;
3141     }
3142 
3143     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
3144         if (attributes)
<span class="line-modified">3145             return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
<span class="line-modified">3146         return putDirectIndexBeyondVectorLengthWithArrayStorage(exec, i, value, attributes, mode, arrayStorage());</span>
3147 
3148     default:
3149         RELEASE_ASSERT_NOT_REACHED();
3150         return false;
3151     }
3152 }
3153 
3154 bool JSObject::putDirectNativeIntrinsicGetter(VM&amp; vm, JSGlobalObject* globalObject, Identifier name, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3155 {
3156     JSFunction* function = JSFunction::create(vm, globalObject, 0, makeString(&quot;get &quot;, name.string()), nativeFunction, intrinsic);
3157     GetterSetter* accessor = GetterSetter::create(vm, globalObject, function, nullptr);
3158     return putDirectNonIndexAccessor(vm, name, accessor, attributes);
3159 }
3160 
3161 void JSObject::putDirectNativeIntrinsicGetterWithoutTransition(VM&amp; vm, JSGlobalObject* globalObject, Identifier name, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3162 {
3163     JSFunction* function = JSFunction::create(vm, globalObject, 0, makeString(&quot;get &quot;, name.string()), nativeFunction, intrinsic);
3164     GetterSetter* accessor = GetterSetter::create(vm, globalObject, function, nullptr);
3165     putDirectNonIndexAccessorWithoutTransition(vm, name, accessor, attributes);
3166 }
</pre>
<hr />
<pre>
3414             butterfly-&gt;indexingPayload&lt;WriteBarrier&lt;Unknown&gt;&gt;()[i].clear();
3415     }
3416 
3417     if (newButterfly) {
3418         butterfly-&gt;setVectorLength(newVectorLength);
3419         WTF::storeStoreFence();
3420         m_butterfly.set(vm, this, newButterfly);
3421     } else {
3422         WTF::storeStoreFence();
3423         butterfly-&gt;setVectorLength(newVectorLength);
3424     }
3425 
3426     return true;
3427 }
3428 
3429 void JSObject::reallocateAndShrinkButterfly(VM&amp; vm, unsigned length)
3430 {
3431     ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
3432     ASSERT(hasContiguous(indexingType()) || hasInt32(indexingType()) || hasDouble(indexingType()) || hasUndecided(indexingType()));
3433     ASSERT(m_butterfly-&gt;vectorLength() &gt; length);

3434     ASSERT(!m_butterfly-&gt;indexingHeader()-&gt;preCapacity(structure(vm)));
3435 
3436     DeferGC deferGC(vm.heap);
3437     Butterfly* newButterfly = butterfly()-&gt;resizeArray(vm, this, structure(vm), 0, ArrayStorage::sizeFor(length));
3438     newButterfly-&gt;setVectorLength(length);
3439     newButterfly-&gt;setPublicLength(length);
3440     WTF::storeStoreFence();
3441     m_butterfly.set(vm, this, newButterfly);
3442 
3443 }
3444 
3445 Butterfly* JSObject::allocateMoreOutOfLineStorage(VM&amp; vm, size_t oldSize, size_t newSize)
3446 {
3447     ASSERT(newSize &gt; oldSize);
3448 
3449     // It&#39;s important that this function not rely on structure(), for the property
3450     // capacity, since we might have already mutated the structure in-place.
3451 
3452     return Butterfly::createOrGrowPropertyStorage(butterfly(), vm, this, structure(vm), oldSize, newSize);
3453 }
3454 
<span class="line-modified">3455 static JSCustomGetterSetterFunction* getCustomGetterSetterFunctionForGetterSetter(ExecState* exec, PropertyName propertyName, CustomGetterSetter* getterSetter, JSCustomGetterSetterFunction::Type type)</span>
3456 {
<span class="line-modified">3457     VM&amp; vm = exec-&gt;vm();</span>
3458     auto key = std::make_pair(getterSetter, (int)type);
3459     JSCustomGetterSetterFunction* customGetterSetterFunction = vm.customGetterSetterFunctionMap.get(key);
3460     if (!customGetterSetterFunction) {
<span class="line-modified">3461         customGetterSetterFunction = JSCustomGetterSetterFunction::create(vm, exec-&gt;lexicalGlobalObject(), getterSetter, type, propertyName.publicName());</span>
3462         vm.customGetterSetterFunctionMap.set(key, customGetterSetterFunction);
3463     }
3464     return customGetterSetterFunction;
3465 }
3466 
<span class="line-modified">3467 bool JSObject::getOwnPropertyDescriptor(ExecState* exec, PropertyName propertyName, PropertyDescriptor&amp; descriptor)</span>
3468 {
<span class="line-modified">3469     VM&amp; vm = exec-&gt;vm();</span>
3470     auto scope = DECLARE_THROW_SCOPE(vm);
3471     JSC::PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
3472 
<span class="line-modified">3473     bool result = methodTable(vm)-&gt;getOwnPropertySlot(this, exec, propertyName, slot);</span>
3474     EXCEPTION_ASSERT(!scope.exception() || !result);
3475     if (!result)
3476         return false;
3477 
3478 
3479     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=200560
3480     // This breaks the assumption that getOwnPropertySlot should return &quot;own&quot; property.
3481     // We should fix DebuggerScope, ProxyObject etc. to remove this.
3482     //
3483     // DebuggerScope::getOwnPropertySlot() (and possibly others) may return attributes from the prototype chain
3484     // but getOwnPropertyDescriptor() should only work for &#39;own&#39; properties so we exit early if we detect that
3485     // the property is not an own property.
3486     if (slot.slotBase() != this &amp;&amp; slot.slotBase()) {
3487         JSProxy* jsProxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this);
3488         if (!jsProxy || jsProxy-&gt;target() != slot.slotBase()) {
3489             // Try ProxyObject.
3490             ProxyObject* proxyObject = jsDynamicCast&lt;ProxyObject*&gt;(vm, this);
3491             if (!proxyObject || proxyObject-&gt;target() != slot.slotBase())
3492                 return false;
3493         }
3494     }
3495 
3496     if (slot.isAccessor())
3497         descriptor.setAccessorDescriptor(slot.getterSetter(), slot.attributes());
3498     else if (slot.attributes() &amp; PropertyAttribute::CustomAccessor) {
3499         descriptor.setCustomDescriptor(slot.attributes());
3500 
3501         JSObject* thisObject = this;
3502         if (auto* proxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this))
3503             thisObject = proxy-&gt;target();
3504 
3505         CustomGetterSetter* getterSetter;
3506         if (slot.isCustomAccessor())
3507             getterSetter = slot.customGetterSetter();
3508         else {
3509             JSValue maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
3510             if (!maybeGetterSetter) {
<span class="line-modified">3511                 thisObject-&gt;reifyAllStaticProperties(exec);</span>
3512                 maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
3513             }
3514 
3515             ASSERT(maybeGetterSetter);
3516             getterSetter = jsDynamicCast&lt;CustomGetterSetter*&gt;(vm, maybeGetterSetter);
3517         }
3518         ASSERT(getterSetter);
3519         if (!getterSetter)
3520             return false;
3521 
3522         if (getterSetter-&gt;getter())
<span class="line-modified">3523             descriptor.setGetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Getter));</span>
3524         if (getterSetter-&gt;setter())
<span class="line-modified">3525             descriptor.setSetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Setter));</span>
3526     } else {
<span class="line-modified">3527         JSValue value = slot.getValue(exec, propertyName);</span>
3528         RETURN_IF_EXCEPTION(scope, false);
3529         descriptor.setDescriptor(value, slot.attributes());
3530     }
3531 
3532     return true;
3533 }
3534 
<span class="line-modified">3535 static bool putDescriptor(ExecState* exec, JSObject* target, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, unsigned attributes, const PropertyDescriptor&amp; oldDescriptor)</span>
3536 {
<span class="line-modified">3537     VM&amp; vm = exec-&gt;vm();</span>
3538     if (descriptor.isGenericDescriptor() || descriptor.isDataDescriptor()) {
3539         if (descriptor.isGenericDescriptor() &amp;&amp; oldDescriptor.isAccessorDescriptor()) {
3540             JSObject* getter = oldDescriptor.getterPresent() ? oldDescriptor.getterObject() : nullptr;
3541             JSObject* setter = oldDescriptor.setterPresent() ? oldDescriptor.setterObject() : nullptr;
<span class="line-modified">3542             GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);</span>
<span class="line-modified">3543             target-&gt;putDirectAccessor(exec, propertyName, accessor, attributes | PropertyAttribute::Accessor);</span>
3544             return true;
3545         }
3546         JSValue newValue = jsUndefined();
3547         if (descriptor.value())
3548             newValue = descriptor.value();
3549         else if (oldDescriptor.value())
3550             newValue = oldDescriptor.value();
3551         target-&gt;putDirect(vm, propertyName, newValue, attributes &amp; ~PropertyAttribute::Accessor);
3552         if (attributes &amp; PropertyAttribute::ReadOnly)
3553             target-&gt;structure(vm)-&gt;setContainsReadOnlyProperties();
3554         return true;
3555     }
3556     attributes &amp;= ~PropertyAttribute::ReadOnly;
3557 
3558     JSObject* getter = descriptor.getterPresent()
3559         ? descriptor.getterObject() : oldDescriptor.getterPresent()
3560         ? oldDescriptor.getterObject() : nullptr;
3561     JSObject* setter = descriptor.setterPresent()
3562         ? descriptor.setterObject() : oldDescriptor.setterPresent()
3563         ? oldDescriptor.setterObject() : nullptr;
<span class="line-modified">3564     GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);</span>
3565 
<span class="line-modified">3566     target-&gt;putDirectAccessor(exec, propertyName, accessor, attributes | PropertyAttribute::Accessor);</span>
3567     return true;
3568 }
3569 
<span class="line-modified">3570 bool JSObject::putDirectMayBeIndex(ExecState* exec, PropertyName propertyName, JSValue value)</span>
3571 {
3572     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">3573         return putDirectIndex(exec, index.value(), value);</span>
<span class="line-modified">3574     return putDirect(exec-&gt;vm(), propertyName, value);</span>
3575 }
3576 
3577 // 9.1.6.3 of the spec
3578 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-validateandapplypropertydescriptor
<span class="line-modified">3579 bool validateAndApplyPropertyDescriptor(ExecState* exec, JSObject* object, PropertyName propertyName, bool isExtensible,</span>
3580     const PropertyDescriptor&amp; descriptor, bool isCurrentDefined, const PropertyDescriptor&amp; current, bool throwException)
3581 {
<span class="line-modified">3582     VM&amp; vm = exec-&gt;vm();</span>
3583     auto scope = DECLARE_THROW_SCOPE(vm);
3584 
3585     // If we have a new property we can just put it on normally
3586     // Step 2.
3587     if (!isCurrentDefined) {
3588         // unless extensions are prevented!
3589         // Step 2.a
3590         if (!isExtensible)
<span class="line-modified">3591             return typeError(exec, scope, throwException, NonExtensibleObjectPropertyDefineError);</span>
3592         if (!object)
3593             return true;
3594         // Step 2.c/d
3595         PropertyDescriptor oldDescriptor;
3596         oldDescriptor.setValue(jsUndefined());
3597         // FIXME: spec says to always return true here.
<span class="line-modified">3598         return putDescriptor(exec, object, propertyName, descriptor, descriptor.attributes(), oldDescriptor);</span>
3599     }
3600     // Step 3.
3601     if (descriptor.isEmpty())
3602         return true;
3603     // Step 4.
<span class="line-modified">3604     bool isEqual = current.equalTo(exec, descriptor);</span>
3605     RETURN_IF_EXCEPTION(scope, false);
3606     if (isEqual)
3607         return true;
3608 
3609     // Step 5.
3610     // Filter out invalid changes
3611     if (!current.configurable()) {
3612         if (descriptor.configurable())
<span class="line-modified">3613             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
3614         if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable() != current.enumerable())
<span class="line-modified">3615             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
3616     }
3617 
3618     // Step 6.
3619     // A generic descriptor is simply changing the attributes of an existing property
3620     if (descriptor.isGenericDescriptor()) {
3621         if (!current.attributesEqual(descriptor) &amp;&amp; object) {
<span class="line-modified">3622             object-&gt;methodTable(vm)-&gt;deleteProperty(object, exec, propertyName);</span>
3623             RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">3624             return putDescriptor(exec, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);</span>
3625         }
3626         return true;
3627     }
3628 
3629     // Step 7.
3630     // Changing between a normal property or an accessor property
3631     if (descriptor.isDataDescriptor() != current.isDataDescriptor()) {
3632         if (!current.configurable())
<span class="line-modified">3633             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
3634 
3635         if (!object)
3636             return true;
3637 
<span class="line-modified">3638         object-&gt;methodTable(vm)-&gt;deleteProperty(object, exec, propertyName);</span>
3639         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">3640         return putDescriptor(exec, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);</span>
3641     }
3642 
3643     // Step 8.
3644     // Changing the value and attributes of an existing property
3645     if (descriptor.isDataDescriptor()) {
3646         if (!current.configurable()) {
3647             if (!current.writable() &amp;&amp; descriptor.writable())
<span class="line-modified">3648                 return typeError(exec, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
3649             if (!current.writable()) {
<span class="line-modified">3650                 if (descriptor.value() &amp;&amp; !sameValue(exec, current.value(), descriptor.value()))</span>
<span class="line-modified">3651                     return typeError(exec, scope, throwException, ReadonlyPropertyChangeError);</span>




3652             }
3653         }
3654         if (current.attributesEqual(descriptor) &amp;&amp; !descriptor.value())
3655             return true;
3656         if (!object)
3657             return true;
<span class="line-modified">3658         object-&gt;methodTable(vm)-&gt;deleteProperty(object, exec, propertyName);</span>
3659         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">3660         return putDescriptor(exec, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);</span>
3661     }
3662 
3663     // Step 9.
3664     // Changing the accessor functions of an existing accessor property
3665     ASSERT(descriptor.isAccessorDescriptor());
3666     if (!current.configurable()) {
<span class="line-modified">3667         if (descriptor.setterPresent() &amp;&amp; !(current.setterPresent() &amp;&amp; JSValue::strictEqual(exec, current.setter(), descriptor.setter())))</span>
<span class="line-modified">3668             return typeError(exec, scope, throwException, &quot;Attempting to change the setter of an unconfigurable property.&quot;_s);</span>
<span class="line-modified">3669         if (descriptor.getterPresent() &amp;&amp; !(current.getterPresent() &amp;&amp; JSValue::strictEqual(exec, current.getter(), descriptor.getter())))</span>
<span class="line-modified">3670             return typeError(exec, scope, throwException, &quot;Attempting to change the getter of an unconfigurable property.&quot;_s);</span>
3671         if (current.attributes() &amp; PropertyAttribute::CustomAccessor)
<span class="line-modified">3672             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
3673     }
3674 
3675     // Step 10/11.
3676     if (!object)
3677         return true;
3678     JSValue accessor = object-&gt;getDirect(vm, propertyName);
3679     if (!accessor)
3680         return false;
3681     JSObject* getter = nullptr;
3682     JSObject* setter = nullptr;
3683     bool getterSetterChanged = false;
3684 
3685     if (accessor.isCustomGetterSetter()) {
3686         auto* customGetterSetter = jsCast&lt;CustomGetterSetter*&gt;(accessor);
3687         if (customGetterSetter-&gt;setter())
<span class="line-modified">3688             setter = getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, customGetterSetter, JSCustomGetterSetterFunction::Type::Setter);</span>
3689         if (customGetterSetter-&gt;getter())
<span class="line-modified">3690             getter = getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, customGetterSetter, JSCustomGetterSetterFunction::Type::Getter);</span>
3691     } else {
3692         ASSERT(accessor.isGetterSetter());
3693         auto* getterSetter = jsCast&lt;GetterSetter*&gt;(accessor);
3694         getter = getterSetter-&gt;getter();
3695         setter = getterSetter-&gt;setter();
3696     }
3697     if (descriptor.setterPresent()) {
3698         setter = descriptor.setterObject();
3699         getterSetterChanged = true;
3700     }
3701     if (descriptor.getterPresent()) {
3702         getter = descriptor.getterObject();
3703         getterSetterChanged = true;
3704     }
3705 
3706     if (current.attributesEqual(descriptor) &amp;&amp; !getterSetterChanged)
3707         return true;
3708 
<span class="line-modified">3709     GetterSetter* getterSetter = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);</span>
3710 
<span class="line-modified">3711     object-&gt;methodTable(vm)-&gt;deleteProperty(object, exec, propertyName);</span>
3712     RETURN_IF_EXCEPTION(scope, false);
3713     unsigned attrs = descriptor.attributesOverridingCurrent(current);
<span class="line-modified">3714     object-&gt;putDirectAccessor(exec, propertyName, getterSetter, attrs | PropertyAttribute::Accessor);</span>
3715     return true;
3716 }
3717 
<span class="line-modified">3718 bool JSObject::defineOwnNonIndexProperty(ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
3719 {
<span class="line-modified">3720     VM&amp; vm  = exec-&gt;vm();</span>
3721     auto throwScope = DECLARE_THROW_SCOPE(vm);
3722 
3723     // Track on the globaldata that we&#39;re in define property.
3724     // Currently DefineOwnProperty uses delete to remove properties when they are being replaced
3725     // (particularly when changing attributes), however delete won&#39;t allow non-configurable (i.e.
3726     // DontDelete) properties to be deleted. For now, we can use this flag to make this work.
3727     VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
3728     PropertyDescriptor current;
<span class="line-modified">3729     bool isCurrentDefined = getOwnPropertyDescriptor(exec, propertyName, current);</span>
<span class="line-modified">3730     bool isExtensible = this-&gt;isExtensible(exec);</span>

3731     RETURN_IF_EXCEPTION(throwScope, false);
<span class="line-modified">3732     RELEASE_AND_RETURN(throwScope, validateAndApplyPropertyDescriptor(exec, this, propertyName, isExtensible, descriptor, isCurrentDefined, current, throwException));</span>
3733 }
3734 
<span class="line-modified">3735 bool JSObject::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
3736 {
3737     // If it&#39;s an array index, then use the indexed property storage.
3738     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
3739         // c. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing P, Desc, and false as arguments.
3740         // d. Reject if succeeded is false.
3741         // e. If index &gt;= oldLen
3742         // e.i. Set oldLenDesc.[[Value]] to index + 1.
3743         // e.ii. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, oldLenDesc, and false as arguments. This call will always return true.
3744         // f. Return true.
<span class="line-modified">3745         return object-&gt;defineOwnIndexedProperty(exec, index.value(), descriptor, throwException);</span>
3746     }
3747 
<span class="line-modified">3748     return object-&gt;defineOwnNonIndexProperty(exec, propertyName, descriptor, throwException);</span>
3749 }
3750 
3751 void JSObject::convertToDictionary(VM&amp; vm)
3752 {
3753     DeferredStructureTransitionWatchpointFire deferredWatchpointFire(vm, structure(vm));
3754     setStructure(
3755         vm, Structure::toCacheableDictionaryTransition(vm, structure(vm), &amp;deferredWatchpointFire));
3756 }
3757 
3758 void JSObject::shiftButterflyAfterFlattening(const GCSafeConcurrentJSLocker&amp;, VM&amp; vm, Structure* structure, size_t outOfLineCapacityAfter)
3759 {
3760     // This could interleave visitChildren because some old structure could have been a non
3761     // dictionary structure. We have to be crazy careful. But, we are guaranteed to be holding
3762     // the structure&#39;s lock right now, and that helps a bit.
3763 
3764     Butterfly* oldButterfly = this-&gt;butterfly();
3765     size_t preCapacity;
3766     size_t indexingPayloadSizeInBytes;
3767     bool hasIndexingHeader = this-&gt;hasIndexingHeader(vm);
3768     if (UNLIKELY(hasIndexingHeader)) {
3769         preCapacity = oldButterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
3770         indexingPayloadSizeInBytes = oldButterfly-&gt;indexingHeader()-&gt;indexingPayloadSizeInBytes(structure);
3771     } else {
3772         preCapacity = 0;
3773         indexingPayloadSizeInBytes = 0;
3774     }
3775 
3776     Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, preCapacity, outOfLineCapacityAfter, hasIndexingHeader, indexingPayloadSizeInBytes);
3777 
3778     // No need to copy the precapacity.
3779     void* currentBase = oldButterfly-&gt;base(0, outOfLineCapacityAfter);
3780     void* newBase = newButterfly-&gt;base(0, outOfLineCapacityAfter);
3781 
<span class="line-modified">3782     memcpy(newBase, currentBase, Butterfly::totalSize(0, outOfLineCapacityAfter, hasIndexingHeader, indexingPayloadSizeInBytes));</span>
3783 
3784     setButterfly(vm, newButterfly);
3785 }
3786 
<span class="line-modified">3787 uint32_t JSObject::getEnumerableLength(ExecState* exec, JSObject* object)</span>
3788 {
<span class="line-modified">3789     VM&amp; vm = exec-&gt;vm();</span>
3790     Structure* structure = object-&gt;structure(vm);
3791     if (structure-&gt;holesMustForwardToPrototype(vm, object))
3792         return 0;
3793     switch (object-&gt;indexingType()) {
3794     case ALL_BLANK_INDEXING_TYPES:
3795     case ALL_UNDECIDED_INDEXING_TYPES:
3796         return 0;
3797 
3798     case ALL_INT32_INDEXING_TYPES:
3799     case ALL_CONTIGUOUS_INDEXING_TYPES: {
3800         Butterfly* butterfly = object-&gt;butterfly();
3801         unsigned usedLength = butterfly-&gt;publicLength();
3802         for (unsigned i = 0; i &lt; usedLength; ++i) {
3803             if (!butterfly-&gt;contiguous().at(object, i))
3804                 return 0;
3805         }
3806         return usedLength;
3807     }
3808 
3809     case ALL_DOUBLE_INDEXING_TYPES: {
</pre>
<hr />
<pre>
3819 
3820     case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
3821         ArrayStorage* storage = object-&gt;m_butterfly-&gt;arrayStorage();
3822         if (storage-&gt;m_sparseMap.get())
3823             return 0;
3824 
3825         unsigned usedVectorLength = std::min(storage-&gt;length(), storage-&gt;vectorLength());
3826         for (unsigned i = 0; i &lt; usedVectorLength; ++i) {
3827             if (!storage-&gt;m_vector[i])
3828                 return 0;
3829         }
3830         return usedVectorLength;
3831     }
3832 
3833     default:
3834         RELEASE_ASSERT_NOT_REACHED();
3835         return 0;
3836     }
3837 }
3838 
<span class="line-modified">3839 void JSObject::getStructurePropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
3840 {
<span class="line-modified">3841     VM&amp; vm = exec-&gt;vm();</span>
3842     object-&gt;structure(vm)-&gt;getPropertyNamesFromStructure(vm, propertyNames, mode);
3843 }
3844 
<span class="line-modified">3845 void JSObject::getGenericPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
3846 {
<span class="line-modified">3847     VM&amp; vm = exec-&gt;vm();</span>
3848     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">3849     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, propertyNames, EnumerationMode(mode, JSObjectPropertiesMode::Exclude));</span>
3850     RETURN_IF_EXCEPTION(scope, void());
3851 
<span class="line-modified">3852     JSValue nextProto = object-&gt;getPrototype(vm, exec);</span>
3853     RETURN_IF_EXCEPTION(scope, void());
3854     if (nextProto.isNull())
3855         return;
3856 
3857     JSObject* prototype = asObject(nextProto);
3858     while (true) {
3859         if (prototype-&gt;structure(vm)-&gt;typeInfo().overridesGetPropertyNames()) {
3860             scope.release();
<span class="line-modified">3861             prototype-&gt;methodTable(vm)-&gt;getPropertyNames(prototype, exec, propertyNames, mode);</span>
3862             return;
3863         }
<span class="line-modified">3864         prototype-&gt;methodTable(vm)-&gt;getOwnPropertyNames(prototype, exec, propertyNames, mode);</span>
3865         RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">3866         nextProto = prototype-&gt;getPrototype(vm, exec);</span>
3867         RETURN_IF_EXCEPTION(scope, void());
3868         if (nextProto.isNull())
3869             break;
3870         prototype = asObject(nextProto);
3871     }
3872 }
3873 
3874 // Implements GetMethod(O, P) in section 7.3.9 of the spec.
3875 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-getmethod
<span class="line-modified">3876 JSValue JSObject::getMethod(ExecState* exec, CallData&amp; callData, CallType&amp; callType, const Identifier&amp; ident, const String&amp; errorMessage)</span>
3877 {
<span class="line-modified">3878     VM&amp; vm = exec-&gt;vm();</span>
3879     auto scope = DECLARE_THROW_SCOPE(vm);
3880 
<span class="line-modified">3881     JSValue method = get(exec, ident);</span>
3882     RETURN_IF_EXCEPTION(scope, JSValue());
3883 
3884     if (!method.isCell()) {
3885         if (method.isUndefinedOrNull())
3886             return jsUndefined();
3887 
<span class="line-modified">3888         throwVMTypeError(exec, scope, errorMessage);</span>
3889         return jsUndefined();
3890     }
3891 
3892     callType = method.asCell()-&gt;methodTable(vm)-&gt;getCallData(method.asCell(), callData);
3893     if (callType == CallType::None) {
<span class="line-modified">3894         throwVMTypeError(exec, scope, errorMessage);</span>
3895         return jsUndefined();
3896     }
3897 
3898     return method;
3899 }
3900 
3901 bool JSObject::anyObjectInChainMayInterceptIndexedAccesses(VM&amp; vm) const
3902 {
3903     for (const JSObject* current = this; ;) {
3904         if (current-&gt;structure(vm)-&gt;mayInterceptIndexedAccesses())
3905             return true;
3906 
3907         JSValue prototype = current-&gt;getPrototypeDirect(vm);
3908         if (prototype.isNull())
3909             return false;
3910 
3911         current = asObject(prototype);
3912     }
3913 }
3914 
</pre>
</td>
<td>
<hr />
<pre>
  58 // This value is capped by the constant FIRST_VECTOR_GROW defined in
  59 // ArrayConventions.h.
  60 static unsigned lastArraySize = 0;
  61 
  62 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSObject);
  63 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSFinalObject);
  64 
  65 const ASCIILiteral NonExtensibleObjectPropertyDefineError { &quot;Attempting to define property on object that is not extensible.&quot;_s };
  66 const ASCIILiteral ReadonlyPropertyWriteError { &quot;Attempted to assign to readonly property.&quot;_s };
  67 const ASCIILiteral ReadonlyPropertyChangeError { &quot;Attempting to change value of a readonly property.&quot;_s };
  68 const ASCIILiteral UnableToDeletePropertyError { &quot;Unable to delete property.&quot;_s };
  69 const ASCIILiteral UnconfigurablePropertyChangeAccessMechanismError { &quot;Attempting to change access mechanism for an unconfigurable property.&quot;_s };
  70 const ASCIILiteral UnconfigurablePropertyChangeConfigurabilityError { &quot;Attempting to change configurable attribute of unconfigurable property.&quot;_s };
  71 const ASCIILiteral UnconfigurablePropertyChangeEnumerabilityError { &quot;Attempting to change enumerable attribute of unconfigurable property.&quot;_s };
  72 const ASCIILiteral UnconfigurablePropertyChangeWritabilityError { &quot;Attempting to change writable attribute of unconfigurable property.&quot;_s };
  73 
  74 const ClassInfo JSObject::s_info = { &quot;Object&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSObject) };
  75 
  76 const ClassInfo JSFinalObject::s_info = { &quot;Object&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFinalObject) };
  77 
<span class="line-modified">  78 static inline void getClassPropertyNames(JSGlobalObject* globalObject, const ClassInfo* classInfo, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  79 {
<span class="line-modified">  80     VM&amp; vm = globalObject-&gt;vm();</span>
  81 
  82     // Add properties from the static hashtables of properties
  83     for (; classInfo; classInfo = classInfo-&gt;parentClass) {
  84         const HashTable* table = classInfo-&gt;staticPropHashTable;
  85         if (!table)
  86             continue;
  87 
  88         for (auto iter = table-&gt;begin(); iter != table-&gt;end(); ++iter) {
  89             if (!(iter-&gt;attributes() &amp; PropertyAttribute::DontEnum) || mode.includeDontEnumProperties())
  90                 propertyNames.add(Identifier::fromString(vm, iter.key()));
  91         }
  92     }
  93 }
  94 
<span class="line-modified">  95 ALWAYS_INLINE void JSObject::markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp; visitor, Butterfly* butterfly, Structure* structure, PropertyOffset maxOffset)</span>
  96 {
  97     // We call this when we found everything without races.
  98     ASSERT(structure);
  99 
 100     if (!butterfly)
 101         return;
 102 
 103     if (isCopyOnWrite(structure-&gt;indexingMode())) {
 104         visitor.append(bitwise_cast&lt;WriteBarrier&lt;JSCell&gt;&gt;(JSImmutableButterfly::fromButterfly(butterfly)));
 105         return;
 106     }
 107 
 108     bool hasIndexingHeader = structure-&gt;hasIndexingHeader(this);
 109     size_t preCapacity;
 110     if (hasIndexingHeader)
 111         preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
 112     else
 113         preCapacity = 0;
 114 
 115     HeapCell* base = bitwise_cast&lt;HeapCell*&gt;(
<span class="line-modified"> 116         butterfly-&gt;base(preCapacity, Structure::outOfLineCapacity(maxOffset)));</span>
 117 
 118     ASSERT(Heap::heap(base) == visitor.heap());
 119 
 120     visitor.markAuxiliary(base);
 121 
<span class="line-modified"> 122     unsigned outOfLineSize = Structure::outOfLineSize(maxOffset);</span>
 123     visitor.appendValuesHidden(butterfly-&gt;propertyStorage() - outOfLineSize, outOfLineSize);
 124 }
 125 
 126 ALWAYS_INLINE Structure* JSObject::visitButterfly(SlotVisitor&amp; visitor)
 127 {
 128     static const char* const raceReason = &quot;JSObject::visitButterfly&quot;;
 129     Structure* result = visitButterflyImpl(visitor);
 130     if (!result)
 131         visitor.didRace(this, raceReason);
 132     return result;
 133 }
 134 
 135 ALWAYS_INLINE Structure* JSObject::visitButterflyImpl(SlotVisitor&amp; visitor)
 136 {
 137     VM&amp; vm = visitor.vm();
 138 
 139     Butterfly* butterfly;
 140     Structure* structure;
<span class="line-modified"> 141     PropertyOffset maxOffset;</span>
 142 
 143     auto visitElements = [&amp;] (IndexingType indexingMode) {
 144         switch (indexingMode) {
 145         // We don&#39;t need to visit the elements for CopyOnWrite butterflies since they we marked the JSImmutableButterfly acting as out butterfly.
 146         case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 147             visitor.appendValuesHidden(butterfly-&gt;contiguous().data(), butterfly-&gt;publicLength());
 148             break;
 149         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 150             visitor.appendValuesHidden(butterfly-&gt;arrayStorage()-&gt;m_vector, butterfly-&gt;arrayStorage()-&gt;vectorLength());
 151             if (butterfly-&gt;arrayStorage()-&gt;m_sparseMap)
 152                 visitor.append(butterfly-&gt;arrayStorage()-&gt;m_sparseMap);
 153             break;
 154         default:
 155             break;
 156         }
 157     };
 158 
 159     if (visitor.mutatorIsStopped()) {
 160         butterfly = this-&gt;butterfly();
 161         structure = this-&gt;structure(vm);
<span class="line-modified"> 162         maxOffset = structure-&gt;maxOffset();</span>
 163 
<span class="line-modified"> 164         markAuxiliaryAndVisitOutOfLineProperties(visitor, butterfly, structure, maxOffset);</span>
 165         visitElements(structure-&gt;indexingMode());
 166 
 167         return structure;
 168     }
 169 
 170     // We want to ensure that we only scan the butterfly if we have an exactly matched structure and an
 171     // exactly matched size. The mutator is required to perform the following shenanigans when
 172     // reallocating the butterfly with a concurrent collector, with all fencing necessary to ensure
 173     // that this executes as if under sequential consistency:
 174     //
 175     //     object-&gt;structure = nuke(object-&gt;structure)
 176     //     object-&gt;butterfly = newButterfly
<span class="line-modified"> 177     //     structure-&gt;m_offset = newMaxOffset</span>
 178     //     object-&gt;structure = newStructure
 179     //
 180     // It&#39;s OK to skip this when reallocating the butterfly in a way that does not affect the m_offset.
 181     // We have other protocols in place for that.
 182     //
 183     // Note that the m_offset can change without the structure changing, but in that case the mutator
 184     // will still store null to the structure.
 185     //
 186     // The collector will ensure that it always sees a matched butterfly/structure by reading the
 187     // structure before and after reading the butterfly. For simplicity, let&#39;s first consider the case
 188     // where the only way to change the outOfLineCapacity is to change the structure. This works
 189     // because the mutator performs the following steps sequentially:
 190     //
 191     //     NukeStructure ChangeButterfly PutNewStructure
 192     //
 193     // Meanwhile the collector performs the following steps sequentially:
 194     //
 195     //     ReadStructureEarly ReadButterfly ReadStructureLate
 196     //
 197     // The collector is allowed to do any of these three things:
</pre>
<hr />
<pre>
 213     // NukeStructure ReadStructureEarly ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
 214     // NukeStructure ReadStructureEarly ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
 215     // NukeStructure ReadStructureEarly ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
 216     // NukeStructure ReadStructureEarly ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
 217     // NukeStructure ReadStructureEarly ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read early
 218     // ReadStructureEarly NukeStructure ChangeButterfly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 219     // ReadStructureEarly NukeStructure ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 220     // ReadStructureEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
 221     // ReadStructureEarly NukeStructure ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 222     // ReadStructureEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
 223     // ReadStructureEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
 224     // ReadStructureEarly ReadButterfly NukeStructure ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 225     // ReadStructureEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
 226     // ReadStructureEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
 227     // ReadStructureEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly PutNewStructure: BEFORE, trivially.
 228     //
 229     // But we additionally have to worry about the size changing. We make this work by requiring that
 230     // the collector reads the size early and late as well. Lets consider the interleaving of the
 231     // mutator changing the size without changing the structure:
 232     //
<span class="line-modified"> 233     //     NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure</span>
 234     //
 235     // Meanwhile the collector does:
 236     //
<span class="line-modified"> 237     //     ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate</span>
 238     //
 239     // The collector can detect races by not only comparing the early structure to the late structure
 240     // (which will be the same before and after the algorithm runs) but also by comparing the early and
<span class="line-modified"> 241     // late maxOffsets. Note: the IGNORE proofs do not cite all of the reasons why the collector will</span>
 242     // ignore the case, since we only need to identify one to say that we&#39;re in the ignore case.
 243     //
<span class="line-modified"> 244     // NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: AFTER, trivially</span>
<span class="line-modified"> 245     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly RestoreStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 246     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly ReadMaxOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 247     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly ReadMaxOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 248     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 249     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 250     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset RestoreStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 251     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset ReadMaxOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 252     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 253     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 254     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 255     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 256     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 257     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 258     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 259     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 260     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 261     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 262     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 263     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 264     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 265     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 266     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 267     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 268     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 269     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 270     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 271     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 272     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 273     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 274     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 275     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 276     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 277     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 278     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 279     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 280     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 281     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 282     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 283     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 284     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 285     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 286     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 287     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 288     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 289     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 290     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 291     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 292     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 293     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 294     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 295     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 296     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early</span>
<span class="line-modified"> 297     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 298     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 299     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early</span>
<span class="line-modified"> 300     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: AFTER, the ReadStructureEarly sees the same structure as after and everything else runs after.</span>
<span class="line-modified"> 301     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: AFTER, as above and the ReadMaxOffsetEarly sees the maxOffset after.</span>
<span class="line-modified"> 302     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: AFTER, as above and the ReadButterfly sees the right butterfly after.</span>
<span class="line-modified"> 303     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure late</span>
<span class="line-modified"> 304     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 305     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 306     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 307     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 308     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 309     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 310     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 311     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 312     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 313     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 314     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 315     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 316     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 317     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 318     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 319     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 320     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 321     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 322     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 323     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 324     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 325     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 326     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 327     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 328     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 329     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 330     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 331     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 332     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 333     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 334     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 335     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 336     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 337     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure late</span>
<span class="line-modified"> 338     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 339     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 340     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 341     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 342     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 343     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 344     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 345     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 346     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 347     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 348     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 349     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 350     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 351     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 352     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 353     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 354     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 355     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 356     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 357     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 358     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 359     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 360     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 361     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure late</span>
<span class="line-modified"> 362     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 363     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 364     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ReadStructureLate ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late</span>
<span class="line-modified"> 365     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets</span>
<span class="line-modified"> 366     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets</span>
<span class="line-modified"> 367     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: BEFORE, reads the offset before, everything else happens before</span>
<span class="line-modified"> 368     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate NukeStructure ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: BEFORE, reads the offset before, everything else happens before</span>
<span class="line-modified"> 369     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure: BEFORE, trivially</span>
 370     //
 371     // Whew.
 372     //
 373     // What the collector is doing is just the &quot;double collect&quot; snapshot from &quot;The Unbounded Single-
 374     // Writer Algorithm&quot; from Yehuda Afek et al&#39;s &quot;Atomic Snapshots of Shared Memory&quot; in JACM 1993,
 375     // also available here:
 376     //
 377     // http://people.csail.mit.edu/shanir/publications/AADGMS.pdf
 378     //
 379     // Unlike Afek et al&#39;s algorithm, ours does not require extra hacks to force wait-freedom (see
 380     // &quot;Observation 2&quot; in the paper). This simplifies the whole algorithm. Instead we are happy with
 381     // obstruction-freedom, and like any good obstruction-free algorithm, we ensure progress using
 382     // scheduling. We also only collect the butterfly once instead of twice; this optimization seems
 383     // to hold up in my proofs above and I&#39;m not sure it&#39;s part of Afek et al&#39;s algos.
 384     //
 385     // For more background on this kind of madness, I like this paper; it&#39;s where I learned about
 386     // both the snapshot algorithm and obstruction-freedom:
 387     //
 388     // Lunchangco, Moir, Shavit. &quot;Nonblocking k-compare-single-swap.&quot; SPAA &#39;03
 389     // https://pdfs.semanticscholar.org/343f/7182cde7669ca2a7de3dc01127927f384ef7.pdf
 390 
 391     StructureID structureID = this-&gt;structureID();
 392     if (isNuked(structureID))
 393         return nullptr;
 394     structure = vm.getStructure(structureID);
<span class="line-modified"> 395     maxOffset = structure-&gt;maxOffset();</span>
 396     IndexingType indexingMode = structure-&gt;indexingMode();
 397     Dependency indexingModeDependency = Dependency::fence(indexingMode);
 398     Locker&lt;JSCellLock&gt; locker(NoLockingNecessary);
 399     switch (indexingMode) {
 400     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 401         // We need to hold this lock to protect against changes to the innards of the butterfly
 402         // that can happen when the butterfly is used for array storage.
 403         // We do not need to hold this lock for contiguous butterflies. We do not reuse the existing
 404         // butterfly with contiguous shape for new array storage butterfly. When converting the butterfly
 405         // with contiguous shape to array storage, we always allocate a new one. Holding this lock for contiguous
 406         // butterflies is unnecessary since contiguous shaped butterfly never becomes broken state.
 407         locker = holdLock(cellLock());
 408         break;
 409     default:
 410         break;
 411     }
 412     butterfly = indexingModeDependency.consume(this)-&gt;butterfly();
 413     Dependency butterflyDependency = Dependency::fence(butterfly);
 414     if (!butterfly)
 415         return structure;
 416     if (butterflyDependency.consume(this)-&gt;structureID() != structureID)
 417         return nullptr;
<span class="line-modified"> 418     if (butterflyDependency.consume(structure)-&gt;maxOffset() != maxOffset)</span>
 419         return nullptr;
 420 
<span class="line-modified"> 421     markAuxiliaryAndVisitOutOfLineProperties(visitor, butterfly, structure, maxOffset);</span>
 422     ASSERT(indexingMode == structure-&gt;indexingMode());
 423     visitElements(indexingMode);
 424 
 425     return structure;
 426 }
 427 
 428 size_t JSObject::estimatedSize(JSCell* cell, VM&amp; vm)
 429 {
 430     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 431     size_t butterflyOutOfLineSize = thisObject-&gt;m_butterfly ? thisObject-&gt;structure(vm)-&gt;outOfLineSize() : 0;
 432     return Base::estimatedSize(cell, vm) + butterflyOutOfLineSize;
 433 }
 434 
 435 void JSObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 436 {
 437     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 438     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
<span class="line-modified"> 439 #if ASSERT_ENABLED</span>
 440     bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
 441     visitor.m_isCheckingForDefaultMarkViolation = false;
 442 #endif
 443 
 444     JSCell::visitChildren(thisObject, visitor);
 445 
 446     thisObject-&gt;visitButterfly(visitor);
 447 
<span class="line-modified"> 448 #if ASSERT_ENABLED</span>
 449     visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
 450 #endif
 451 }
 452 
 453 void JSObject::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)
 454 {
 455     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 456     Base::analyzeHeap(cell, analyzer);
 457 
 458     Structure* structure = thisObject-&gt;structure();
 459     for (auto&amp; entry : structure-&gt;getPropertiesConcurrently()) {
 460         JSValue toValue = thisObject-&gt;getDirect(entry.offset);
 461         if (toValue &amp;&amp; toValue.isCell())
 462             analyzer.analyzePropertyNameEdge(thisObject, toValue.asCell(), entry.key);
 463     }
 464 
 465     Butterfly* butterfly = thisObject-&gt;butterfly();
 466     if (butterfly) {
 467         WriteBarrier&lt;Unknown&gt;* data = nullptr;
 468         uint32_t count = 0;
</pre>
<hr />
<pre>
 475         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 476             data = butterfly-&gt;arrayStorage()-&gt;m_vector;
 477             count = butterfly-&gt;arrayStorage()-&gt;vectorLength();
 478             break;
 479         default:
 480             break;
 481         }
 482 
 483         for (uint32_t i = 0; i &lt; count; ++i) {
 484             JSValue toValue = data[i].get();
 485             if (toValue &amp;&amp; toValue.isCell())
 486                 analyzer.analyzeIndexEdge(thisObject, toValue.asCell(), i);
 487         }
 488     }
 489 }
 490 
 491 void JSFinalObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 492 {
 493     JSFinalObject* thisObject = jsCast&lt;JSFinalObject*&gt;(cell);
 494     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
<span class="line-modified"> 495 #if ASSERT_ENABLED</span>
 496     bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
 497     visitor.m_isCheckingForDefaultMarkViolation = false;
 498 #endif
 499 
 500     JSCell::visitChildren(thisObject, visitor);
 501 
 502     if (Structure* structure = thisObject-&gt;visitButterfly(visitor)) {
 503         if (unsigned storageSize = structure-&gt;inlineSize())
 504             visitor.appendValuesHidden(thisObject-&gt;inlineStorage(), storageSize);
 505     }
 506 
<span class="line-modified"> 507 #if ASSERT_ENABLED</span>
 508     visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
 509 #endif
 510 }
 511 
 512 String JSObject::className(const JSObject* object, VM&amp; vm)
 513 {
 514     const ClassInfo* info = object-&gt;classInfo(vm);
 515     ASSERT(info);
 516     return info-&gt;className;
 517 }
 518 
<span class="line-modified"> 519 String JSObject::toStringName(const JSObject* object, JSGlobalObject* globalObject)</span>
 520 {
<span class="line-modified"> 521     VM&amp; vm = globalObject-&gt;vm();</span>
 522     const ClassInfo* info = object-&gt;classInfo(vm);
 523     ASSERT(info);
 524     return info-&gt;className;
 525 }
 526 
 527 String JSObject::calculatedClassName(JSObject* object)
 528 {
 529     String constructorFunctionName;
 530     auto* structure = object-&gt;structure();
 531     auto* globalObject = structure-&gt;globalObject();
 532     VM&amp; vm = globalObject-&gt;vm();
 533     auto scope = DECLARE_CATCH_SCOPE(vm);

 534 
 535     // Check for a display name of obj.constructor.
 536     // This is useful to get `Foo` for the `(class Foo).prototype` object.
 537     PropertySlot slot(object, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified"> 538     if (object-&gt;getOwnPropertySlot(object, globalObject, vm.propertyNames-&gt;constructor, slot)) {</span>
 539         EXCEPTION_ASSERT(!scope.exception());
 540         if (slot.isValue()) {
<span class="line-modified"> 541             if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(globalObject, vm.propertyNames-&gt;constructor))) {</span>
 542                 if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))
 543                     constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
 544                 else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))
 545                     constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
 546             }
 547         }
 548     }
 549 
 550     EXCEPTION_ASSERT(!scope.exception() || constructorFunctionName.isNull());
 551     if (UNLIKELY(scope.exception()))
 552         scope.clearException();
 553 
 554     // Get the display name of obj.__proto__.constructor.
 555     // This is useful to get `Foo` for a `new Foo` object.
 556     if (constructorFunctionName.isNull()) {
 557         MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
 558         if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype)) {
 559             JSValue protoValue = object-&gt;getPrototypeDirect(vm);
 560             if (protoValue.isObject()) {
 561                 JSObject* protoObject = asObject(protoValue);
 562                 PropertySlot slot(protoValue, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified"> 563                 if (protoObject-&gt;getPropertySlot(globalObject, vm.propertyNames-&gt;constructor, slot)) {</span>
 564                     EXCEPTION_ASSERT(!scope.exception());
 565                     if (slot.isValue()) {
<span class="line-modified"> 566                         if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(globalObject, vm.propertyNames-&gt;constructor))) {</span>
 567                             if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))
 568                                 constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
 569                             else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))
 570                                 constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
 571                         }
 572                     }
 573                 }
 574             }
 575         }
 576     }
 577 
 578     EXCEPTION_ASSERT(!scope.exception() || constructorFunctionName.isNull());
 579     if (UNLIKELY(scope.exception()))
 580         scope.clearException();
 581 
 582     if (constructorFunctionName.isNull() || constructorFunctionName == &quot;Object&quot;) {
 583         String tableClassName = object-&gt;methodTable(vm)-&gt;className(object, vm);
 584         if (!tableClassName.isNull() &amp;&amp; tableClassName != &quot;Object&quot;)
 585             return tableClassName;
 586 
 587         String classInfoName = object-&gt;classInfo(vm)-&gt;className;
 588         if (!classInfoName.isNull())
 589             return classInfoName;
 590 
 591         if (constructorFunctionName.isNull())
 592             return &quot;Object&quot;_s;
 593     }
 594 
 595     return constructorFunctionName;
 596 }
 597 
<span class="line-modified"> 598 bool JSObject::getOwnPropertySlotByIndex(JSObject* thisObject, JSGlobalObject* globalObject, unsigned i, PropertySlot&amp; slot)</span>
 599 {
<span class="line-modified"> 600     VM&amp; vm = globalObject-&gt;vm();</span>
 601 
 602     // NB. The fact that we&#39;re directly consulting our indexed storage implies that it is not
 603     // legal for anyone to override getOwnPropertySlot() without also overriding
 604     // getOwnPropertySlotByIndex().
 605 
 606     if (i &gt; MAX_ARRAY_INDEX)
<span class="line-modified"> 607         return thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, globalObject, Identifier::from(vm, i), slot);</span>
 608 
 609     switch (thisObject-&gt;indexingType()) {
 610     case ALL_BLANK_INDEXING_TYPES:
 611     case ALL_UNDECIDED_INDEXING_TYPES:
 612         break;
 613 
 614     case ALL_INT32_INDEXING_TYPES:
 615     case ALL_CONTIGUOUS_INDEXING_TYPES: {
 616         Butterfly* butterfly = thisObject-&gt;butterfly();
 617         if (i &gt;= butterfly-&gt;vectorLength())
 618             return false;
 619 
 620         JSValue value = butterfly-&gt;contiguous().at(thisObject, i).get();
 621         if (value) {
 622             slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), value);
 623             return true;
 624         }
 625 
 626         return false;
 627     }
</pre>
<hr />
<pre>
 653             }
 654         } else if (SparseArrayValueMap* map = storage-&gt;m_sparseMap.get()) {
 655             SparseArrayValueMap::iterator it = map-&gt;find(i);
 656             if (it != map-&gt;notFound()) {
 657                 it-&gt;value.get(thisObject, slot);
 658                 return true;
 659             }
 660         }
 661         break;
 662     }
 663 
 664     default:
 665         RELEASE_ASSERT_NOT_REACHED();
 666         break;
 667     }
 668 
 669     return false;
 670 }
 671 
 672 // https://tc39.github.io/ecma262/#sec-ordinaryset
<span class="line-modified"> 673 bool ordinarySetSlow(JSGlobalObject* globalObject, JSObject* object, PropertyName propertyName, JSValue value, JSValue receiver, bool shouldThrow)</span>
 674 {
 675     // If we find the receiver is not the same to the object, we fall to this slow path.
 676     // Currently, there are 3 candidates.
 677     // 1. Reflect.set can alter the receiver with an arbitrary value.
 678     // 2. Window Proxy.
 679     // 3. ES6 Proxy.
 680 
<span class="line-modified"> 681     VM&amp; vm = globalObject-&gt;vm();</span>
 682     auto scope = DECLARE_THROW_SCOPE(vm);
 683     JSObject* current = object;
 684     PropertyDescriptor ownDescriptor;
 685     while (true) {
 686         if (current-&gt;type() == ProxyObjectType) {
 687             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
 688             PutPropertySlot slot(receiver, shouldThrow);
<span class="line-modified"> 689             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, globalObject, propertyName, value, slot));</span>
 690         }
 691 
 692         // 9.1.9.1-2 Let ownDesc be ? O.[[GetOwnProperty]](P).
<span class="line-modified"> 693         bool ownDescriptorFound = current-&gt;getOwnPropertyDescriptor(globalObject, propertyName, ownDescriptor);</span>
 694         RETURN_IF_EXCEPTION(scope, false);
 695 
 696         if (!ownDescriptorFound) {
 697             // 9.1.9.1-3-a Let parent be ? O.[[GetPrototypeOf]]().
<span class="line-modified"> 698             JSValue prototype = current-&gt;getPrototype(vm, globalObject);</span>
 699             RETURN_IF_EXCEPTION(scope, false);
 700 
 701             // 9.1.9.1-3-b If parent is not null, then
 702             if (!prototype.isNull()) {
 703                 // 9.1.9.1-3-b-i Return ? parent.[[Set]](P, V, Receiver).
 704                 current = asObject(prototype);
 705                 continue;
 706             }
 707             // 9.1.9.1-3-c-i Let ownDesc be the PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.
 708             ownDescriptor = PropertyDescriptor(jsUndefined(), static_cast&lt;unsigned&gt;(PropertyAttribute::None));
 709         }
 710         break;
 711     }
 712 
 713     // 9.1.9.1-4 If IsDataDescriptor(ownDesc) is true, then
 714     if (ownDescriptor.isDataDescriptor()) {
 715         // 9.1.9.1-4-a If ownDesc.[[Writable]] is false, return false.
 716         if (!ownDescriptor.writable())
<span class="line-modified"> 717             return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
 718 
 719         // 9.1.9.1-4-b If Type(Receiver) is not Object, return false.
 720         if (!receiver.isObject())
<span class="line-modified"> 721             return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
 722 
 723         // In OrdinarySet, the receiver may not be the same to the object.
 724         // So, we perform [[GetOwnProperty]] onto the receiver while we already perform [[GetOwnProperty]] onto the object.
 725 
 726         // 9.1.9.1-4-c Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).
 727         JSObject* receiverObject = asObject(receiver);
 728         PropertyDescriptor existingDescriptor;
<span class="line-modified"> 729         bool existingDescriptorFound = receiverObject-&gt;getOwnPropertyDescriptor(globalObject, propertyName, existingDescriptor);</span>
 730         RETURN_IF_EXCEPTION(scope, false);
 731 
 732         // 9.1.9.1-4-d If existingDescriptor is not undefined, then
 733         if (existingDescriptorFound) {
 734             // 9.1.9.1-4-d-i If IsAccessorDescriptor(existingDescriptor) is true, return false.
 735             if (existingDescriptor.isAccessorDescriptor())
<span class="line-modified"> 736                 return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
 737 
 738             // 9.1.9.1-4-d-ii If existingDescriptor.[[Writable]] is false, return false.
 739             if (!existingDescriptor.writable())
<span class="line-modified"> 740                 return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
 741 
 742             // 9.1.9.1-4-d-iii Let valueDesc be the PropertyDescriptor{[[Value]]: V}.
 743             PropertyDescriptor valueDescriptor;
 744             valueDescriptor.setValue(value);
 745 
 746             // 9.1.9.1-4-d-iv Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).
<span class="line-modified"> 747             RELEASE_AND_RETURN(scope, receiverObject-&gt;methodTable(vm)-&gt;defineOwnProperty(receiverObject, globalObject, propertyName, valueDescriptor, shouldThrow));</span>
 748         }
 749 
 750         // 9.1.9.1-4-e Else Receiver does not currently have a property P,
 751         // 9.1.9.1-4-e-i Return ? CreateDataProperty(Receiver, P, V).
<span class="line-modified"> 752         RELEASE_AND_RETURN(scope, receiverObject-&gt;methodTable(vm)-&gt;defineOwnProperty(receiverObject, globalObject, propertyName, PropertyDescriptor(value, static_cast&lt;unsigned&gt;(PropertyAttribute::None)), shouldThrow));</span>
 753     }
 754 
 755     // 9.1.9.1-5 Assert: IsAccessorDescriptor(ownDesc) is true.
 756     ASSERT(ownDescriptor.isAccessorDescriptor());
 757 
 758     // 9.1.9.1-6 Let setter be ownDesc.[[Set]].
 759     // 9.1.9.1-7 If setter is undefined, return false.
 760     JSValue setter = ownDescriptor.setter();
 761     if (!setter.isObject())
<span class="line-modified"> 762         return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
 763 
 764     // 9.1.9.1-8 Perform ? Call(setter, Receiver, &lt;&lt; V &gt;&gt;).
 765     JSObject* setterObject = asObject(setter);
 766     MarkedArgumentBuffer args;
 767     args.append(value);
 768     ASSERT(!args.hasOverflowed());
 769 
 770     CallData callData;
 771     CallType callType = setterObject-&gt;methodTable(vm)-&gt;getCallData(setterObject, callData);
 772     scope.release();
<span class="line-modified"> 773     call(globalObject, setterObject, callType, callData, receiver, args);</span>
 774 
 775     // 9.1.9.1-9 Return true.
 776     return true;
 777 }
 778 
 779 // ECMA 8.6.2.2
<span class="line-modified"> 780 bool JSObject::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
 781 {
<span class="line-modified"> 782     return putInlineForJSObject(cell, globalObject, propertyName, value, slot);</span>
 783 }
 784 
<span class="line-modified"> 785 bool JSObject::putInlineSlow(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
 786 {
 787     ASSERT(!isThisValueAltered(slot, this));
 788 
<span class="line-modified"> 789     VM&amp; vm = globalObject-&gt;vm();</span>
 790     auto scope = DECLARE_THROW_SCOPE(vm);
 791 
 792     JSObject* obj = this;
 793     for (;;) {
 794         Structure* structure = obj-&gt;structure(vm);
 795         if (UNLIKELY(structure-&gt;typeInfo().hasPutPropertySecurityCheck())) {
<span class="line-modified"> 796             obj-&gt;methodTable(vm)-&gt;doPutPropertySecurityCheck(obj, globalObject, propertyName, slot);</span>
 797             RETURN_IF_EXCEPTION(scope, false);
 798         }
 799         unsigned attributes;
 800         PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
 801         if (isValidOffset(offset)) {
 802             if (attributes &amp; PropertyAttribute::ReadOnly) {
 803                 ASSERT(this-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName) || obj == this);
<span class="line-modified"> 804                 return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
 805             }
 806 
 807             JSValue gs = obj-&gt;getDirect(offset);
 808             if (gs.isGetterSetter()) {
 809                 // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
 810                 if (!this-&gt;structure(vm)-&gt;isDictionary())
 811                     slot.setCacheableSetter(obj, offset);
 812 
<span class="line-modified"> 813                 bool result = callSetter(globalObject, slot.thisValue(), gs, value, slot.isStrictMode() ? StrictMode : NotStrictMode);</span>
 814                 RETURN_IF_EXCEPTION(scope, false);
 815                 return result;
 816             }
 817             if (gs.isCustomGetterSetter()) {
 818                 // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
 819                 if (attributes &amp; PropertyAttribute::CustomAccessor)
 820                     slot.setCustomAccessor(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
 821                 else
 822                     slot.setCustomValue(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
 823 
<span class="line-modified"> 824                 bool result = callCustomSetter(globalObject, gs, attributes &amp; PropertyAttribute::CustomAccessor, obj, slot.thisValue(), value);</span>
 825                 RETURN_IF_EXCEPTION(scope, false);
 826                 return result;
 827             }
 828             ASSERT(!(attributes &amp; PropertyAttribute::Accessor));
 829 
 830             // If there&#39;s an existing property on the base object, or on one of its
 831             // prototypes, we should store the property on the *base* object.
 832             break;
 833         }
 834         if (!obj-&gt;staticPropertiesReified(vm)) {
 835             if (obj-&gt;classInfo(vm)-&gt;hasStaticSetterOrReadonlyProperties()) {
 836                 if (auto entry = obj-&gt;findPropertyHashEntry(vm, propertyName))
<span class="line-modified"> 837                     RELEASE_AND_RETURN(scope, putEntry(globalObject, entry-&gt;table-&gt;classForThis, entry-&gt;value, obj, this, propertyName, value, slot));</span>
 838             }
 839         }
 840         if (obj-&gt;type() == ProxyObjectType) {



 841             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(obj);
<span class="line-modified"> 842             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, globalObject, propertyName, value, slot));</span>
 843         }
<span class="line-modified"> 844         JSValue prototype = obj-&gt;getPrototype(vm, globalObject);</span>
 845         RETURN_IF_EXCEPTION(scope, false);
 846         if (prototype.isNull())
 847             break;
 848         obj = asObject(prototype);
 849     }
 850 
 851     if (!putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot))
<span class="line-modified"> 852         return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
 853     return true;
 854 }
 855 
<span class="line-modified"> 856 bool JSObject::putByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool shouldThrow)</span>
 857 {
<span class="line-modified"> 858     VM&amp; vm = globalObject-&gt;vm();</span>
 859     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 860 
 861     if (propertyName &gt; MAX_ARRAY_INDEX) {
 862         PutPropertySlot slot(cell, shouldThrow);
<span class="line-modified"> 863         return thisObject-&gt;methodTable(vm)-&gt;put(thisObject, globalObject, Identifier::from(vm, propertyName), value, slot);</span>
 864     }
 865 
 866     thisObject-&gt;ensureWritable(vm);
 867 
 868     switch (thisObject-&gt;indexingType()) {
 869     case ALL_BLANK_INDEXING_TYPES:
 870         break;
 871 
 872     case ALL_UNDECIDED_INDEXING_TYPES: {
 873         thisObject-&gt;convertUndecidedForValue(vm, value);
 874         // Reloop.
<span class="line-modified"> 875         return putByIndex(cell, globalObject, propertyName, value, shouldThrow);</span>
 876     }
 877 
 878     case ALL_INT32_INDEXING_TYPES: {
 879         if (!value.isInt32()) {
 880             thisObject-&gt;convertInt32ForValue(vm, value);
<span class="line-modified"> 881             return putByIndex(cell, globalObject, propertyName, value, shouldThrow);</span>
 882         }
 883         FALLTHROUGH;
 884     }
 885 
 886     case ALL_CONTIGUOUS_INDEXING_TYPES: {
 887         Butterfly* butterfly = thisObject-&gt;butterfly();
 888         if (propertyName &gt;= butterfly-&gt;vectorLength())
 889             break;
<span class="line-modified"> 890         butterfly-&gt;contiguous().at(thisObject, propertyName).setWithoutWriteBarrier(value);</span>
 891         if (propertyName &gt;= butterfly-&gt;publicLength())
 892             butterfly-&gt;setPublicLength(propertyName + 1);
<span class="line-added"> 893         vm.heap.writeBarrier(thisObject, value);</span>
 894         return true;
 895     }
 896 
 897     case ALL_DOUBLE_INDEXING_TYPES: {
 898         if (!value.isNumber()) {
 899             thisObject-&gt;convertDoubleToContiguous(vm);
 900             // Reloop.
<span class="line-modified"> 901             return putByIndex(cell, globalObject, propertyName, value, shouldThrow);</span>
 902         }
 903 
 904         double valueAsDouble = value.asNumber();
 905         if (valueAsDouble != valueAsDouble) {
 906             thisObject-&gt;convertDoubleToContiguous(vm);
 907             // Reloop.
<span class="line-modified"> 908             return putByIndex(cell, globalObject, propertyName, value, shouldThrow);</span>
 909         }
 910         Butterfly* butterfly = thisObject-&gt;butterfly();
 911         if (propertyName &gt;= butterfly-&gt;vectorLength())
 912             break;
 913         butterfly-&gt;contiguousDouble().at(thisObject, propertyName) = valueAsDouble;
 914         if (propertyName &gt;= butterfly-&gt;publicLength())
 915             butterfly-&gt;setPublicLength(propertyName + 1);
 916         return true;
 917     }
 918 
 919     case NonArrayWithArrayStorage:
 920     case ArrayWithArrayStorage: {
 921         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
 922 
 923         if (propertyName &gt;= storage-&gt;vectorLength())
 924             break;
 925 
 926         WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[propertyName];
 927         unsigned length = storage-&gt;length();
 928 
</pre>
<hr />
<pre>
 936 
 937         valueSlot.set(vm, thisObject, value);
 938         return true;
 939     }
 940 
 941     case NonArrayWithSlowPutArrayStorage:
 942     case ArrayWithSlowPutArrayStorage: {
 943         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
 944 
 945         if (propertyName &gt;= storage-&gt;vectorLength())
 946             break;
 947 
 948         WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[propertyName];
 949         unsigned length = storage-&gt;length();
 950 
 951         auto scope = DECLARE_THROW_SCOPE(vm);
 952 
 953         // Update length &amp; m_numValuesInVector as necessary.
 954         if (propertyName &gt;= length) {
 955             bool putResult = false;
<span class="line-modified"> 956             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(globalObject, propertyName, value, shouldThrow, putResult);</span>
 957             RETURN_IF_EXCEPTION(scope, false);
 958             if (result)
 959                 return putResult;
 960             length = propertyName + 1;
 961             storage-&gt;setLength(length);
 962             ++storage-&gt;m_numValuesInVector;
 963         } else if (!valueSlot) {
 964             bool putResult = false;
<span class="line-modified"> 965             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(globalObject, propertyName, value, shouldThrow, putResult);</span>
 966             RETURN_IF_EXCEPTION(scope, false);
 967             if (result)
 968                 return putResult;
 969             ++storage-&gt;m_numValuesInVector;
 970         }
 971 
 972         valueSlot.set(vm, thisObject, value);
 973         return true;
 974     }
 975 
 976     default:
 977         RELEASE_ASSERT_NOT_REACHED();
 978     }
 979 
<span class="line-modified"> 980     return thisObject-&gt;putByIndexBeyondVectorLength(globalObject, propertyName, value, shouldThrow);</span>
 981 }
 982 
 983 ArrayStorage* JSObject::enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(VM&amp; vm, ArrayStorage* storage)
 984 {
 985     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
 986 
 987     if (!map)
 988         map = allocateSparseIndexMap(vm);
 989 
 990     if (map-&gt;sparseMode())
 991         return storage;
 992 
 993     map-&gt;setSparseMode();
 994 
 995     unsigned usedVectorLength = std::min(storage-&gt;length(), storage-&gt;vectorLength());
 996     for (unsigned i = 0; i &lt; usedVectorLength; ++i) {
 997         JSValue value = storage-&gt;m_vector[i].get();
 998         // This will always be a new entry in the map, so no need to check we can write,
 999         // and attributes are default so no need to set them.
1000         if (value)
</pre>
<hr />
<pre>
1190 {
1191     ASSERT(hasUndecided(indexingType()));
1192 
1193     Butterfly* butterfly = m_butterfly.get();
1194     for (unsigned i = butterfly-&gt;vectorLength(); i--;)
1195         butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(JSValue());
1196 
1197     WTF::storeStoreFence();
1198     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateContiguous));
1199     return m_butterfly-&gt;contiguous();
1200 }
1201 
1202 ArrayStorage* JSObject::constructConvertedArrayStorageWithoutCopyingElements(VM&amp; vm, unsigned neededLength)
1203 {
1204     Structure* structure = this-&gt;structure(vm);
1205     unsigned publicLength = m_butterfly-&gt;publicLength();
1206     unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
1207 
1208     Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, 0, propertyCapacity, true, ArrayStorage::sizeFor(neededLength));
1209 
<span class="line-modified">1210     gcSafeMemcpy(</span>
<span class="line-modified">1211         static_cast&lt;JSValue*&gt;(newButterfly-&gt;base(0, propertyCapacity)),</span>
<span class="line-modified">1212         static_cast&lt;JSValue*&gt;(m_butterfly-&gt;base(0, propertyCapacity)),</span>
1213         propertyCapacity * sizeof(EncodedJSValue));
1214 
1215     ArrayStorage* newStorage = newButterfly-&gt;arrayStorage();
1216     newStorage-&gt;setVectorLength(neededLength);
1217     newStorage-&gt;setLength(publicLength);
1218     newStorage-&gt;m_sparseMap.clear();
1219     newStorage-&gt;m_indexBias = 0;
1220     newStorage-&gt;m_numValuesInVector = 0;
1221 
1222     return newStorage;
1223 }
1224 
1225 ArrayStorage* JSObject::convertUndecidedToArrayStorage(VM&amp; vm, NonPropertyTransition transition)
1226 {
1227     DeferGC deferGC(vm.heap);
1228     ASSERT(hasUndecided(indexingType()));
1229 
1230     unsigned vectorLength = m_butterfly-&gt;vectorLength();
1231     ArrayStorage* storage = constructConvertedArrayStorageWithoutCopyingElements(vm, vectorLength);
1232 
</pre>
<hr />
<pre>
1483 
1484     if (value.isDouble() &amp;&amp; !std::isnan(value.asDouble())) {
1485         convertInt32ToDouble(vm);
1486         return;
1487     }
1488 
1489     convertInt32ToContiguous(vm);
1490 }
1491 
1492 void JSObject::convertFromCopyOnWrite(VM&amp; vm)
1493 {
1494     ASSERT(isCopyOnWrite(indexingMode()));
1495     ASSERT(structure(vm)-&gt;indexingMode() == indexingMode());
1496 
1497     const bool hasIndexingHeader = true;
1498     Butterfly* oldButterfly = butterfly();
1499     size_t propertyCapacity = 0;
1500     unsigned newVectorLength = Butterfly::optimalContiguousVectorLength(propertyCapacity, std::min(oldButterfly-&gt;vectorLength() * 2, MAX_STORAGE_VECTOR_LENGTH));
1501     Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, 0, propertyCapacity, hasIndexingHeader, newVectorLength * sizeof(JSValue));
1502 
<span class="line-modified">1503     gcSafeMemcpy(newButterfly-&gt;propertyStorage(), oldButterfly-&gt;propertyStorage(), oldButterfly-&gt;vectorLength() * sizeof(JSValue) + sizeof(IndexingHeader));</span>
1504 
1505     WTF::storeStoreFence();
1506     NonPropertyTransition transition = ([&amp;] () {
1507         switch (indexingType()) {
1508         case ArrayWithInt32:
1509             return NonPropertyTransition::AllocateInt32;
1510         case ArrayWithDouble:
1511             return NonPropertyTransition::AllocateDouble;
1512         case ArrayWithContiguous:
1513             return NonPropertyTransition::AllocateContiguous;
1514         default:
1515             RELEASE_ASSERT_NOT_REACHED();
1516             return NonPropertyTransition::AllocateContiguous;
1517         }
1518     })();
1519     StructureID oldStructureID = structureID();
1520     Structure* newStructure = Structure::nonPropertyTransition(vm, structure(vm), transition);
1521     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1522     setStructure(vm, newStructure);
1523 }
</pre>
<hr />
<pre>
1789     } else
1790         putDirect(vm, knownPolyProtoOffset, prototype);
1791 
1792     if (!anyObjectInChainMayInterceptIndexedAccesses(vm))
1793         return;
1794 
1795     if (mayBePrototype()) {
1796         structure(vm)-&gt;globalObject()-&gt;haveABadTime(vm);
1797         return;
1798     }
1799 
1800     if (!hasIndexedProperties(indexingType()))
1801         return;
1802 
1803     if (shouldUseSlowPut(indexingType()))
1804         return;
1805 
1806     switchToSlowPutArrayStorage(vm);
1807 }
1808 
<span class="line-modified">1809 bool JSObject::setPrototypeWithCycleCheck(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, bool shouldThrowIfCantSet)</span>
1810 {
1811     auto scope = DECLARE_THROW_SCOPE(vm);
1812 
1813     if (this-&gt;structure(vm)-&gt;isImmutablePrototypeExoticObject()) {
1814         // This implements https://tc39.github.io/ecma262/#sec-set-immutable-prototype.
<span class="line-modified">1815         if (this-&gt;getPrototype(vm, globalObject) == prototype)</span>
1816             return true;
1817 
<span class="line-modified">1818         return typeError(globalObject, scope, shouldThrowIfCantSet, &quot;Cannot set prototype of immutable prototype object&quot;_s);</span>
1819     }
1820 
<span class="line-modified">1821     ASSERT(methodTable(vm)-&gt;toThis(this, globalObject, NotStrictMode) == this);</span>
1822 
1823     if (this-&gt;getPrototypeDirect(vm) == prototype)
1824         return true;
1825 
<span class="line-modified">1826     bool isExtensible = this-&gt;isExtensible(globalObject);</span>
1827     RETURN_IF_EXCEPTION(scope, false);
1828 
1829     if (!isExtensible)
<span class="line-modified">1830         return typeError(globalObject, scope, shouldThrowIfCantSet, ReadonlyPropertyWriteError);</span>
1831 
1832     JSValue nextPrototype = prototype;
1833     while (nextPrototype &amp;&amp; nextPrototype.isObject()) {
1834         if (nextPrototype == this)
<span class="line-modified">1835             return typeError(globalObject, scope, shouldThrowIfCantSet, &quot;cyclic __proto__ value&quot;_s);</span>
1836         // FIXME: The specification currently says we should check if the [[GetPrototypeOf]] internal method of nextPrototype
1837         // is not the ordinary object internal method. However, we currently restrict this to Proxy objects as it would allow
1838         // for cycles with certain HTML objects (WindowProxy, Location) otherwise.
1839         // https://bugs.webkit.org/show_bug.cgi?id=161534
1840         if (UNLIKELY(asObject(nextPrototype)-&gt;type() == ProxyObjectType))
1841             break; // We&#39;re done. Set the prototype.
1842         nextPrototype = asObject(nextPrototype)-&gt;getPrototypeDirect(vm);
1843     }
1844     setPrototypeDirect(vm, prototype);
1845     return true;
1846 }
1847 
<span class="line-modified">1848 bool JSObject::setPrototype(JSObject* object, JSGlobalObject* globalObject, JSValue prototype, bool shouldThrowIfCantSet)</span>
1849 {
<span class="line-modified">1850     return object-&gt;setPrototypeWithCycleCheck(globalObject-&gt;vm(), globalObject, prototype, shouldThrowIfCantSet);</span>
1851 }
1852 
<span class="line-modified">1853 JSValue JSObject::getPrototype(JSObject* object, JSGlobalObject* globalObject)</span>
1854 {
<span class="line-modified">1855     return object-&gt;getPrototypeDirect(globalObject-&gt;vm());</span>
1856 }
1857 
<span class="line-modified">1858 bool JSObject::setPrototype(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, bool shouldThrowIfCantSet)</span>
1859 {
<span class="line-modified">1860     return methodTable(vm)-&gt;setPrototype(this, globalObject, prototype, shouldThrowIfCantSet);</span>
1861 }
1862 
<span class="line-modified">1863 bool JSObject::putGetter(JSGlobalObject* globalObject, PropertyName propertyName, JSValue getter, unsigned attributes)</span>
1864 {
1865     PropertyDescriptor descriptor;
1866     descriptor.setGetter(getter);
1867 
1868     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1869     if (!(attributes &amp; PropertyAttribute::ReadOnly))
1870         descriptor.setConfigurable(true);
1871     if (!(attributes &amp; PropertyAttribute::DontEnum))
1872         descriptor.setEnumerable(true);
1873 
<span class="line-modified">1874     return defineOwnProperty(this, globalObject, propertyName, descriptor, true);</span>
1875 }
1876 
<span class="line-modified">1877 bool JSObject::putSetter(JSGlobalObject* globalObject, PropertyName propertyName, JSValue setter, unsigned attributes)</span>
1878 {
1879     PropertyDescriptor descriptor;
1880     descriptor.setSetter(setter);
1881 
1882     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1883     if (!(attributes &amp; PropertyAttribute::ReadOnly))
1884         descriptor.setConfigurable(true);
1885     if (!(attributes &amp; PropertyAttribute::DontEnum))
1886         descriptor.setEnumerable(true);
1887 
<span class="line-modified">1888     return defineOwnProperty(this, globalObject, propertyName, descriptor, true);</span>
1889 }
1890 
<span class="line-modified">1891 bool JSObject::putDirectAccessor(JSGlobalObject* globalObject, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)</span>
1892 {
1893     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1894 
1895     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">1896         return putDirectIndex(globalObject, index.value(), accessor, attributes, PutDirectIndexLikePutDirect);</span>
1897 
<span class="line-modified">1898     return putDirectNonIndexAccessor(globalObject-&gt;vm(), propertyName, accessor, attributes);</span>
1899 }
1900 
1901 // FIXME: Introduce a JSObject::putDirectCustomValue() method instead of using
1902 // JSObject::putDirectCustomAccessor() to put CustomValues.
1903 // https://bugs.webkit.org/show_bug.cgi?id=192576
1904 bool JSObject::putDirectCustomAccessor(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes)
1905 {
1906     ASSERT(!parseIndex(propertyName));
1907     ASSERT(value.isCustomGetterSetter());
1908     if (!(attributes &amp; PropertyAttribute::CustomAccessor))
1909         attributes |= PropertyAttribute::CustomValue;
1910 
1911     PutPropertySlot slot(this);
1912     bool result = putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, value, attributes, slot);
1913 
1914     ASSERT(slot.type() == PutPropertySlot::NewProperty);
1915 
1916     Structure* structure = this-&gt;structure(vm);
1917     if (attributes &amp; PropertyAttribute::ReadOnly)
1918         structure-&gt;setContainsReadOnlyProperties();
</pre>
<hr />
<pre>
1932 
1933     structure-&gt;setHasGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
1934     return result;
1935 }
1936 
1937 void JSObject::putDirectNonIndexAccessorWithoutTransition(VM&amp; vm, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)
1938 {
1939     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1940     StructureID structureID = this-&gt;structureID();
1941     Structure* structure = vm.heap.structureIDTable().get(structureID);
1942     PropertyOffset offset = prepareToPutDirectWithoutTransition(vm, propertyName, attributes, structureID, structure);
1943     putDirect(vm, offset, accessor);
1944     if (attributes &amp; PropertyAttribute::ReadOnly)
1945         structure-&gt;setContainsReadOnlyProperties();
1946 
1947     structure-&gt;setHasGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
1948 }
1949 
1950 // HasProperty(O, P) from Section 7.3.10 of the spec.
1951 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hasproperty
<span class="line-modified">1952 bool JSObject::hasProperty(JSGlobalObject* globalObject, PropertyName propertyName) const</span>
1953 {
<span class="line-modified">1954     return hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::HasProperty);</span>
1955 }
1956 
<span class="line-modified">1957 bool JSObject::hasProperty(JSGlobalObject* globalObject, unsigned propertyName) const</span>
1958 {
<span class="line-modified">1959     return hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::HasProperty);</span>
1960 }
1961 
<span class="line-modified">1962 bool JSObject::hasPropertyGeneric(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot::InternalMethodType internalMethodType) const</span>
1963 {
1964     PropertySlot slot(this, internalMethodType);
<span class="line-modified">1965     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
1966 }
1967 
<span class="line-modified">1968 bool JSObject::hasPropertyGeneric(JSGlobalObject* globalObject, unsigned propertyName, PropertySlot::InternalMethodType internalMethodType) const</span>
1969 {
1970     PropertySlot slot(this, internalMethodType);
<span class="line-modified">1971     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
1972 }
1973 
1974 // ECMA 8.6.2.5
<span class="line-modified">1975 bool JSObject::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
1976 {
1977     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
<span class="line-modified">1978     VM&amp; vm = globalObject-&gt;vm();</span>
1979 
1980     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">1981         return thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, globalObject, index.value());</span>
1982 
1983     unsigned attributes;
1984 
1985     if (!thisObject-&gt;staticPropertiesReified(vm)) {
1986         if (auto entry = thisObject-&gt;findPropertyHashEntry(vm, propertyName)) {
1987             // If the static table contains a non-configurable (DontDelete) property then we can return early;
1988             // if there is a property in the storage array it too must be non-configurable (the language does
1989             // not allow repacement of a non-configurable property with a configurable one).
1990             if (entry-&gt;value-&gt;attributes() &amp; PropertyAttribute::DontDelete &amp;&amp; vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable) {
1991                 ASSERT(!isValidOffset(thisObject-&gt;structure(vm)-&gt;get(vm, propertyName, attributes)) || attributes &amp; PropertyAttribute::DontDelete);
1992                 return false;
1993             }
<span class="line-modified">1994             thisObject-&gt;reifyAllStaticProperties(globalObject);</span>
1995         }
1996     }
1997 
1998     Structure* structure = thisObject-&gt;structure(vm);
1999 
2000     bool propertyIsPresent = isValidOffset(structure-&gt;get(vm, propertyName, attributes));
2001     if (propertyIsPresent) {
2002         if (attributes &amp; PropertyAttribute::DontDelete &amp;&amp; vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable)
2003             return false;
<span class="line-added">2004         DeferredStructureTransitionWatchpointFire deferredWatchpointFire(vm, structure);</span>
2005 
<span class="line-modified">2006         PropertyOffset offset = invalidOffset;</span>
2007         if (structure-&gt;isUncacheableDictionary())
<span class="line-modified">2008             offset = structure-&gt;removePropertyWithoutTransition(vm, propertyName, [] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset, PropertyOffset) { });</span>
<span class="line-modified">2009         else {</span>
<span class="line-modified">2010             structure = Structure::removePropertyTransition(vm, structure, propertyName, offset, &amp;deferredWatchpointFire);</span>
<span class="line-added">2011             if (thisObject-&gt;m_butterfly &amp;&amp; !structure-&gt;outOfLineCapacity() &amp;&amp; !structure-&gt;hasIndexingHeader(thisObject)) {</span>
<span class="line-added">2012                 thisObject-&gt;nukeStructureAndSetButterfly(vm, thisObject-&gt;structureID(), nullptr);</span>
<span class="line-added">2013                 offset = invalidOffset;</span>
<span class="line-added">2014                 ASSERT(structure-&gt;maxOffset() == invalidOffset);</span>
<span class="line-added">2015             }</span>
<span class="line-added">2016             thisObject-&gt;setStructure(vm, structure);</span>
<span class="line-added">2017         }</span>
<span class="line-added">2018 </span>
<span class="line-added">2019         ASSERT(!isValidOffset(structure-&gt;get(vm, propertyName, attributes)));</span>
2020 
2021         if (offset != invalidOffset)
2022             thisObject-&gt;locationForOffset(offset)-&gt;clear();
2023     }
2024 
2025     return true;
2026 }
2027 
<span class="line-modified">2028 bool JSObject::deletePropertyByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned i)</span>
2029 {
<span class="line-modified">2030     VM&amp; vm = globalObject-&gt;vm();</span>
2031     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
2032 
2033     if (i &gt; MAX_ARRAY_INDEX)
<span class="line-modified">2034         return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, globalObject, Identifier::from(vm, i));</span>
2035 
2036     switch (thisObject-&gt;indexingMode()) {
2037     case ALL_BLANK_INDEXING_TYPES:
2038     case ALL_UNDECIDED_INDEXING_TYPES:
2039         return true;
2040 
2041     case CopyOnWriteArrayWithInt32:
2042     case CopyOnWriteArrayWithContiguous: {
2043         Butterfly* butterfly = thisObject-&gt;butterfly();
2044         if (i &gt;= butterfly-&gt;vectorLength())
2045             return true;
2046         thisObject-&gt;convertFromCopyOnWrite(vm);
2047         FALLTHROUGH;
2048     }
2049 
2050     case ALL_WRITABLE_INT32_INDEXING_TYPES:
2051     case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES: {
2052         Butterfly* butterfly = thisObject-&gt;butterfly();
2053         if (i &gt;= butterfly-&gt;vectorLength())
2054             return true;
</pre>
<hr />
<pre>
2085             SparseArrayValueMap::iterator it = map-&gt;find(i);
2086             if (it != map-&gt;notFound()) {
2087                 if (it-&gt;value.attributes() &amp; PropertyAttribute::DontDelete)
2088                     return false;
2089                 map-&gt;remove(it);
2090             }
2091         }
2092 
2093         return true;
2094     }
2095 
2096     default:
2097         RELEASE_ASSERT_NOT_REACHED();
2098         return false;
2099     }
2100 }
2101 
2102 enum class TypeHintMode { TakesHint, DoesNotTakeHint };
2103 
2104 template&lt;TypeHintMode mode = TypeHintMode::DoesNotTakeHint&gt;
<span class="line-modified">2105 static ALWAYS_INLINE JSValue callToPrimitiveFunction(JSGlobalObject* globalObject, const JSObject* object, PropertyName propertyName, PreferredPrimitiveType hint)</span>
2106 {
<span class="line-modified">2107     VM&amp; vm = globalObject-&gt;vm();</span>
2108     auto scope = DECLARE_THROW_SCOPE(vm);
2109 
2110     PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
2111     // FIXME: Remove this when we have fixed: rdar://problem/33451840
2112     // https://bugs.webkit.org/show_bug.cgi?id=187109.
2113     constexpr bool debugNullStructure = mode == TypeHintMode::TakesHint;
<span class="line-modified">2114     bool hasProperty = const_cast&lt;JSObject*&gt;(object)-&gt;getPropertySlot&lt;debugNullStructure&gt;(globalObject, propertyName, slot);</span>
2115     RETURN_IF_EXCEPTION(scope, scope.exception());
<span class="line-modified">2116     JSValue function = hasProperty ? slot.getValue(globalObject, propertyName) : jsUndefined();</span>
2117     RETURN_IF_EXCEPTION(scope, scope.exception());
2118     if (function.isUndefinedOrNull() &amp;&amp; mode == TypeHintMode::TakesHint)
2119         return JSValue();
2120     CallData callData;
2121     CallType callType = getCallData(vm, function, callData);
2122     if (callType == CallType::None) {
2123         if (mode == TypeHintMode::TakesHint)
<span class="line-modified">2124             throwTypeError(globalObject, scope, &quot;Symbol.toPrimitive is not a function, undefined, or null&quot;_s);</span>
2125         return scope.exception();
2126     }
2127 
2128     MarkedArgumentBuffer callArgs;
2129     if (mode == TypeHintMode::TakesHint) {
2130         JSString* hintString = nullptr;
2131         switch (hint) {
2132         case NoPreference:
2133             hintString = vm.smallStrings.defaultString();
2134             break;
2135         case PreferNumber:
2136             hintString = vm.smallStrings.numberString();
2137             break;
2138         case PreferString:
2139             hintString = vm.smallStrings.stringString();
2140             break;
2141         }
2142         callArgs.append(hintString);
2143     }
2144     ASSERT(!callArgs.hasOverflowed());
2145 
<span class="line-modified">2146     JSValue result = call(globalObject, function, callType, callData, const_cast&lt;JSObject*&gt;(object), callArgs);</span>
2147     RETURN_IF_EXCEPTION(scope, scope.exception());
2148     ASSERT(!result.isGetterSetter());
2149     if (result.isObject())
<span class="line-modified">2150         return mode == TypeHintMode::DoesNotTakeHint ? JSValue() : throwTypeError(globalObject, scope, &quot;Symbol.toPrimitive returned an object&quot;_s);</span>
2151     return result;
2152 }
2153 
2154 // ECMA 7.1.1
<span class="line-modified">2155 JSValue JSObject::ordinaryToPrimitive(JSGlobalObject* globalObject, PreferredPrimitiveType hint) const</span>
2156 {
<span class="line-modified">2157     VM&amp; vm = globalObject-&gt;vm();</span>
2158     auto scope = DECLARE_THROW_SCOPE(vm);
2159 
2160     // Make sure that whatever default value methods there are on object&#39;s prototype chain are
2161     // being watched.
2162     for (const JSObject* object = this; object; object = object-&gt;structure(vm)-&gt;storedPrototypeObject(object))
2163         object-&gt;structure(vm)-&gt;startWatchingInternalPropertiesIfNecessary(vm);
2164 
2165     JSValue value;
2166     if (hint == PreferString) {
<span class="line-modified">2167         value = callToPrimitiveFunction(globalObject, this, vm.propertyNames-&gt;toString, hint);</span>
2168         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2169         if (value)
2170             return value;
<span class="line-modified">2171         value = callToPrimitiveFunction(globalObject, this, vm.propertyNames-&gt;valueOf, hint);</span>
2172         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2173         if (value)
2174             return value;
2175     } else {
<span class="line-modified">2176         value = callToPrimitiveFunction(globalObject, this, vm.propertyNames-&gt;valueOf, hint);</span>
2177         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2178         if (value)
2179             return value;
<span class="line-modified">2180         value = callToPrimitiveFunction(globalObject, this, vm.propertyNames-&gt;toString, hint);</span>
2181         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2182         if (value)
2183             return value;
2184     }
2185 
2186     scope.assertNoException();
2187 
<span class="line-modified">2188     return throwTypeError(globalObject, scope, &quot;No default value&quot;_s);</span>
2189 }
2190 
<span class="line-modified">2191 JSValue JSObject::defaultValue(const JSObject* object, JSGlobalObject* globalObject, PreferredPrimitiveType hint)</span>
2192 {
<span class="line-modified">2193     return object-&gt;ordinaryToPrimitive(globalObject, hint);</span>
2194 }
2195 
<span class="line-modified">2196 JSValue JSObject::toPrimitive(JSGlobalObject* globalObject, PreferredPrimitiveType preferredType) const</span>
2197 {
<span class="line-modified">2198     VM&amp; vm = globalObject-&gt;vm();</span>
2199     auto scope = DECLARE_THROW_SCOPE(vm);
2200 
<span class="line-modified">2201     JSValue value = callToPrimitiveFunction&lt;TypeHintMode::TakesHint&gt;(globalObject, this, vm.propertyNames-&gt;toPrimitiveSymbol, preferredType);</span>
2202     RETURN_IF_EXCEPTION(scope, { });
2203     if (value)
2204         return value;
2205 
<span class="line-modified">2206     RELEASE_AND_RETURN(scope, this-&gt;methodTable(vm)-&gt;defaultValue(this, globalObject, preferredType));</span>
2207 }
2208 
<span class="line-modified">2209 bool JSObject::getPrimitiveNumber(JSGlobalObject* globalObject, double&amp; number, JSValue&amp; result) const</span>
2210 {
<span class="line-modified">2211     VM&amp; vm = globalObject-&gt;vm();</span>
2212     auto scope = DECLARE_THROW_SCOPE(vm);
2213 
<span class="line-modified">2214     result = toPrimitive(globalObject, PreferNumber);</span>
2215     RETURN_IF_EXCEPTION(scope, false);
2216     scope.release();
<span class="line-modified">2217     number = result.toNumber(globalObject);</span>
2218     return !result.isString();
2219 }
2220 
2221 bool JSObject::getOwnStaticPropertySlot(VM&amp; vm, PropertyName propertyName, PropertySlot&amp; slot)
2222 {
2223     for (auto* info = classInfo(vm); info; info = info-&gt;parentClass) {
2224         if (auto* table = info-&gt;staticPropHashTable) {
2225             if (getStaticPropertySlotFromTable(vm, table-&gt;classForThis, *table, this, propertyName, slot))
2226                 return true;
2227         }
2228     }
2229     return false;
2230 }
2231 
<span class="line-modified">2232 Optional&lt;Structure::PropertyHashEntry&gt; JSObject::findPropertyHashEntry(VM&amp; vm, PropertyName propertyName) const</span>
2233 {
<span class="line-modified">2234     return structure(vm)-&gt;findPropertyHashEntry(propertyName);</span>






2235 }
2236 
<span class="line-modified">2237 bool JSObject::hasInstance(JSGlobalObject* globalObject, JSValue value, JSValue hasInstanceValue)</span>
2238 {
<span class="line-modified">2239     VM&amp; vm = globalObject-&gt;vm();</span>
2240     auto scope = DECLARE_THROW_SCOPE(vm);
2241 
<span class="line-modified">2242     if (!hasInstanceValue.isUndefinedOrNull() &amp;&amp; hasInstanceValue != globalObject-&gt;functionProtoHasInstanceSymbolFunction()) {</span>
2243         CallData callData;
2244         CallType callType = JSC::getCallData(vm, hasInstanceValue, callData);
2245         if (callType == CallType::None) {
<span class="line-modified">2246             throwException(globalObject, scope, createInvalidInstanceofParameterErrorHasInstanceValueNotFunction(globalObject, this));</span>
2247             return false;
2248         }
2249 
2250         MarkedArgumentBuffer args;
2251         args.append(value);
2252         ASSERT(!args.hasOverflowed());
<span class="line-modified">2253         JSValue result = call(globalObject, hasInstanceValue, callType, callData, this, args);</span>
2254         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">2255         return result.toBoolean(globalObject);</span>
2256     }
2257 
2258     TypeInfo info = structure(vm)-&gt;typeInfo();
2259     if (info.implementsDefaultHasInstance()) {
<span class="line-modified">2260         JSValue prototype = get(globalObject, vm.propertyNames-&gt;prototype);</span>
2261         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">2262         RELEASE_AND_RETURN(scope, defaultHasInstance(globalObject, value, prototype));</span>
2263     }
2264     if (info.implementsHasInstance()) {
2265         if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">2266             throwStackOverflowError(globalObject, scope);</span>
2267             return false;
2268         }
<span class="line-modified">2269         RELEASE_AND_RETURN(scope, methodTable(vm)-&gt;customHasInstance(this, globalObject, value));</span>
2270     }
2271 
<span class="line-modified">2272     throwException(globalObject, scope, createInvalidInstanceofParameterErrorNotFunction(globalObject, this));</span>
2273     return false;
2274 }
2275 
<span class="line-modified">2276 bool JSObject::hasInstance(JSGlobalObject* globalObject, JSValue value)</span>
2277 {
<span class="line-modified">2278     VM&amp; vm = globalObject-&gt;vm();</span>
2279     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2280     JSValue hasInstanceValue = get(globalObject, vm.propertyNames-&gt;hasInstanceSymbol);</span>
2281     RETURN_IF_EXCEPTION(scope, false);
2282 
<span class="line-modified">2283     RELEASE_AND_RETURN(scope, hasInstance(globalObject, value, hasInstanceValue));</span>
2284 }
2285 
<span class="line-modified">2286 bool JSObject::defaultHasInstance(JSGlobalObject* globalObject, JSValue value, JSValue proto)</span>
2287 {
<span class="line-modified">2288     VM&amp; vm = globalObject-&gt;vm();</span>
2289     auto scope = DECLARE_THROW_SCOPE(vm);
2290 
2291     if (!value.isObject())
2292         return false;
2293 
2294     if (!proto.isObject()) {
<span class="line-modified">2295         throwTypeError(globalObject, scope, &quot;instanceof called on an object with an invalid prototype property.&quot;_s);</span>
2296         return false;
2297     }
2298 
2299     JSObject* object = asObject(value);
2300     while (true) {
<span class="line-modified">2301         JSValue objectValue = object-&gt;getPrototype(vm, globalObject);</span>
2302         RETURN_IF_EXCEPTION(scope, false);
2303         if (!objectValue.isObject())
2304             return false;
2305         object = asObject(objectValue);
2306         if (proto == object)
2307             return true;
2308     }
2309     ASSERT_NOT_REACHED();
2310 }
2311 
<span class="line-modified">2312 EncodedJSValue JSC_HOST_CALL objectPrivateFuncInstanceOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2313 {
<span class="line-modified">2314     JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
<span class="line-modified">2315     JSValue proto = callFrame-&gt;uncheckedArgument(1);</span>
2316 
<span class="line-modified">2317     return JSValue::encode(jsBoolean(JSObject::defaultHasInstance(globalObject, value, proto)));</span>
2318 }
2319 
<span class="line-modified">2320 void JSObject::getPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
2321 {
<span class="line-modified">2322     VM&amp; vm = globalObject-&gt;vm();</span>
2323     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2324     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, globalObject, propertyNames, mode);</span>
2325     RETURN_IF_EXCEPTION(scope, void());
2326 
<span class="line-modified">2327     JSValue nextProto = object-&gt;getPrototype(vm, globalObject);</span>
2328     RETURN_IF_EXCEPTION(scope, void());
2329     if (nextProto.isNull())
2330         return;
2331 
2332     JSObject* prototype = asObject(nextProto);
2333     while(1) {
2334         if (prototype-&gt;structure(vm)-&gt;typeInfo().overridesGetPropertyNames()) {
2335             scope.release();
<span class="line-modified">2336             prototype-&gt;methodTable(vm)-&gt;getPropertyNames(prototype, globalObject, propertyNames, mode);</span>
2337             return;
2338         }
<span class="line-modified">2339         prototype-&gt;methodTable(vm)-&gt;getOwnPropertyNames(prototype, globalObject, propertyNames, mode);</span>
2340         RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">2341         nextProto = prototype-&gt;getPrototype(vm, globalObject);</span>
2342         RETURN_IF_EXCEPTION(scope, void());
2343         if (nextProto.isNull())
2344             break;
2345         prototype = asObject(nextProto);
2346     }
2347 }
2348 
<span class="line-modified">2349 void JSObject::getOwnPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
2350 {
<span class="line-modified">2351     VM&amp; vm = globalObject-&gt;vm();</span>
2352     if (!mode.includeJSObjectProperties()) {
2353         // We still have to get non-indexed properties from any subclasses of JSObject that have them.
<span class="line-modified">2354         object-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(object, globalObject, propertyNames, mode);</span>
2355         return;
2356     }
2357 
2358     if (propertyNames.includeStringProperties()) {
2359         // Add numeric properties first. That appears to be the accepted convention.
2360         // FIXME: Filling PropertyNameArray with an identifier for every integer
2361         // is incredibly inefficient for large arrays. We need a different approach,
2362         // which almost certainly means a different structure for PropertyNameArray.
2363         switch (object-&gt;indexingType()) {
2364         case ALL_BLANK_INDEXING_TYPES:
2365         case ALL_UNDECIDED_INDEXING_TYPES:
2366             break;
2367 
2368         case ALL_INT32_INDEXING_TYPES:
2369         case ALL_CONTIGUOUS_INDEXING_TYPES: {
2370             Butterfly* butterfly = object-&gt;butterfly();
2371             unsigned usedLength = butterfly-&gt;publicLength();
2372             for (unsigned i = 0; i &lt; usedLength; ++i) {
2373                 if (!butterfly-&gt;contiguous().at(object, i))
2374                     continue;
</pre>
<hr />
<pre>
2403                 keys.reserveInitialCapacity(map-&gt;size());
2404 
2405                 SparseArrayValueMap::const_iterator end = map-&gt;end();
2406                 for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it) {
2407                     if (mode.includeDontEnumProperties() || !(it-&gt;value.attributes() &amp; PropertyAttribute::DontEnum))
2408                         keys.uncheckedAppend(static_cast&lt;unsigned&gt;(it-&gt;key));
2409                 }
2410 
2411                 std::sort(keys.begin(), keys.end());
2412                 for (unsigned i = 0; i &lt; keys.size(); ++i)
2413                     propertyNames.add(keys[i]);
2414             }
2415             break;
2416         }
2417 
2418         default:
2419             RELEASE_ASSERT_NOT_REACHED();
2420         }
2421     }
2422 
<span class="line-modified">2423     object-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(object, globalObject, propertyNames, mode);</span>
2424 }
2425 
<span class="line-modified">2426 void JSObject::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
2427 {
<span class="line-modified">2428     VM&amp; vm = globalObject-&gt;vm();</span>
2429     if (!object-&gt;staticPropertiesReified(vm))
<span class="line-modified">2430         getClassPropertyNames(globalObject, object-&gt;classInfo(vm), propertyNames, mode);</span>
2431 
2432     if (!mode.includeJSObjectProperties())
2433         return;
2434 
2435     object-&gt;structure(vm)-&gt;getPropertyNamesFromStructure(vm, propertyNames, mode);
2436 }
2437 
<span class="line-modified">2438 double JSObject::toNumber(JSGlobalObject* globalObject) const</span>
2439 {
<span class="line-modified">2440     VM&amp; vm = globalObject-&gt;vm();</span>
2441     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2442     JSValue primitive = toPrimitive(globalObject, PreferNumber);</span>
2443     RETURN_IF_EXCEPTION(scope, 0.0); // should be picked up soon in Nodes.cpp
<span class="line-modified">2444     RELEASE_AND_RETURN(scope, primitive.toNumber(globalObject));</span>
2445 }
2446 
<span class="line-modified">2447 JSString* JSObject::toString(JSGlobalObject* globalObject) const</span>
2448 {
<span class="line-modified">2449     VM&amp; vm = globalObject-&gt;vm();</span>
2450     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2451     JSValue primitive = toPrimitive(globalObject, PreferString);</span>
2452     RETURN_IF_EXCEPTION(scope, jsEmptyString(vm));
<span class="line-modified">2453     RELEASE_AND_RETURN(scope, primitive.toString(globalObject));</span>
2454 }
2455 
<span class="line-modified">2456 JSValue JSObject::toThis(JSCell* cell, JSGlobalObject*, ECMAMode)</span>
2457 {
2458     return jsCast&lt;JSObject*&gt;(cell);
2459 }
2460 
2461 void JSObject::seal(VM&amp; vm)
2462 {
2463     if (isSealed(vm))
2464         return;
2465     enterDictionaryIndexingMode(vm);
2466     setStructure(vm, Structure::sealTransition(vm, structure(vm)));
2467 }
2468 
2469 void JSObject::freeze(VM&amp; vm)
2470 {
2471     if (isFrozen(vm))
2472         return;
2473     enterDictionaryIndexingMode(vm);
2474     setStructure(vm, Structure::freezeTransition(vm, structure(vm)));
2475 }
2476 
<span class="line-modified">2477 bool JSObject::preventExtensions(JSObject* object, JSGlobalObject* globalObject)</span>
2478 {
<span class="line-modified">2479     VM&amp; vm = globalObject-&gt;vm();</span>
2480     if (!object-&gt;isStructureExtensible(vm)) {
2481         // We&#39;ve already set the internal [[PreventExtensions]] field to false.
2482         // We don&#39;t call the methodTable isExtensible here because it&#39;s not defined
2483         // that way in the specification. We are just doing an optimization here.
2484         return true;
2485     }
2486 
2487     object-&gt;enterDictionaryIndexingMode(vm);
2488     object-&gt;setStructure(vm, Structure::preventExtensionsTransition(vm, object-&gt;structure(vm)));
2489     return true;
2490 }
2491 
<span class="line-modified">2492 bool JSObject::isExtensible(JSObject* obj, JSGlobalObject* globalObject)</span>
2493 {
<span class="line-modified">2494     return obj-&gt;isStructureExtensible(globalObject-&gt;vm());</span>
2495 }
2496 
<span class="line-modified">2497 bool JSObject::isExtensible(JSGlobalObject* globalObject)</span>
2498 {
<span class="line-modified">2499     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2500     return methodTable(vm)-&gt;isExtensible(this, globalObject);</span>
2501 }
2502 
<span class="line-modified">2503 void JSObject::reifyAllStaticProperties(JSGlobalObject* globalObject)</span>
2504 {
<span class="line-modified">2505     VM&amp; vm = globalObject-&gt;vm();</span>
2506     ASSERT(!staticPropertiesReified(vm));
2507 
2508     // If this object&#39;s ClassInfo has no static properties, then nothing to reify!
2509     // We can safely set the flag to avoid the expensive check again in the future.
2510     if (!TypeInfo::hasStaticPropertyTable(inlineTypeFlags())) {
2511         structure(vm)-&gt;setStaticPropertiesReified(true);
2512         return;
2513     }
2514 
2515     if (!structure(vm)-&gt;isDictionary())
2516         setStructure(vm, Structure::toCacheableDictionaryTransition(vm, structure(vm)));
2517 
2518     for (const ClassInfo* info = classInfo(vm); info; info = info-&gt;parentClass) {
2519         const HashTable* hashTable = info-&gt;staticPropHashTable;
2520         if (!hashTable)
2521             continue;
2522 
2523         for (auto&amp; value : *hashTable) {
2524             unsigned attributes;
2525             auto key = Identifier::fromString(vm, value.m_key);
</pre>
<hr />
<pre>
2527             if (!isValidOffset(offset))
2528                 reifyStaticProperty(vm, hashTable-&gt;classForThis, key, value, *this);
2529         }
2530     }
2531 
2532     structure(vm)-&gt;setStaticPropertiesReified(true);
2533 }
2534 
2535 NEVER_INLINE void JSObject::fillGetterPropertySlot(VM&amp; vm, PropertySlot&amp; slot, JSCell* getterSetter, unsigned attributes, PropertyOffset offset)
2536 {
2537     if (structure(vm)-&gt;isUncacheableDictionary()) {
2538         slot.setGetterSlot(this, attributes, jsCast&lt;GetterSetter*&gt;(getterSetter));
2539         return;
2540     }
2541 
2542     // This access is cacheable because Structure requires an attributeChangedTransition
2543     // if this property stops being an accessor.
2544     slot.setCacheableGetterSlot(this, attributes, jsCast&lt;GetterSetter*&gt;(getterSetter), offset);
2545 }
2546 
<span class="line-modified">2547 static bool putIndexedDescriptor(JSGlobalObject* globalObject, SparseArrayValueMap* map, SparseArrayEntry* entryInMap, const PropertyDescriptor&amp; descriptor, PropertyDescriptor&amp; oldDescriptor)</span>
2548 {
<span class="line-modified">2549     VM&amp; vm = globalObject-&gt;vm();</span>
2550 
2551     if (descriptor.isDataDescriptor()) {
2552         unsigned attributes = descriptor.attributesOverridingCurrent(oldDescriptor) &amp; ~PropertyAttribute::Accessor;
2553         if (descriptor.value())
2554             entryInMap-&gt;forceSet(vm, map, descriptor.value(), attributes);
2555         else if (oldDescriptor.isAccessorDescriptor())
2556             entryInMap-&gt;forceSet(vm, map, jsUndefined(), attributes);
2557         else
2558             entryInMap-&gt;forceSet(attributes);
2559         return true;
2560     }
2561 
2562     if (descriptor.isAccessorDescriptor()) {
2563         JSObject* getter = nullptr;
2564         if (descriptor.getterPresent())
2565             getter = descriptor.getterObject();
2566         else if (oldDescriptor.isAccessorDescriptor())
2567             getter = oldDescriptor.getterObject();
2568         JSObject* setter = nullptr;
2569         if (descriptor.setterPresent())
2570             setter = descriptor.setterObject();
2571         else if (oldDescriptor.isAccessorDescriptor())
2572             setter = oldDescriptor.setterObject();
2573 
<span class="line-modified">2574         GetterSetter* accessor = GetterSetter::create(vm, globalObject, getter, setter);</span>
2575         entryInMap-&gt;forceSet(vm, map, accessor, descriptor.attributesOverridingCurrent(oldDescriptor) &amp; ~PropertyAttribute::ReadOnly);
2576         return true;
2577     }
2578 
2579     ASSERT(descriptor.isGenericDescriptor());
2580     entryInMap-&gt;forceSet(descriptor.attributesOverridingCurrent(oldDescriptor));
2581     return true;
2582 }
2583 
2584 ALWAYS_INLINE static bool canDoFastPutDirectIndex(VM&amp; vm, JSObject* object)
2585 {
2586     return (isJSArray(object) &amp;&amp; !isCopyOnWrite(object-&gt;indexingMode()))
2587         || jsDynamicCast&lt;JSFinalObject*&gt;(vm, object)
2588         || TypeInfo::isArgumentsType(object-&gt;type());
2589 }
2590 
2591 // Defined in ES5.1 8.12.9
<span class="line-modified">2592 bool JSObject::defineOwnIndexedProperty(JSGlobalObject* globalObject, unsigned index, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
2593 {
<span class="line-modified">2594     VM&amp; vm = globalObject-&gt;vm();</span>
2595     auto scope = DECLARE_THROW_SCOPE(vm);
2596 
2597     ASSERT(index &lt;= MAX_ARRAY_INDEX);
2598 
2599     ensureWritable(vm);
2600 
2601     if (!inSparseIndexingMode()) {
2602         // Fast case: we&#39;re putting a regular property to a regular array
2603         // FIXME: this will pessimistically assume that if attributes are missing then they&#39;ll default to false
2604         // however if the property currently exists missing attributes will override from their current &#39;true&#39;
2605         // state (i.e. defineOwnProperty could be used to set a value without needing to entering &#39;SparseMode&#39;).
2606         if (!descriptor.attributes() &amp;&amp; descriptor.value() &amp;&amp; canDoFastPutDirectIndex(vm, this)) {
2607             ASSERT(!descriptor.isAccessorDescriptor());
<span class="line-modified">2608             RELEASE_AND_RETURN(scope, putDirectIndex(globalObject, index, descriptor.value(), 0, throwException ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow));</span>
2609         }
2610 
2611         ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm);
2612     }
2613 
2614     if (descriptor.attributes() &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor))
2615         notifyPresenceOfIndexedAccessors(vm);
2616 
2617     SparseArrayValueMap* map = m_butterfly-&gt;arrayStorage()-&gt;m_sparseMap.get();
2618     RELEASE_ASSERT(map);
2619 
2620     // 1. Let current be the result of calling the [[GetOwnProperty]] internal method of O with property name P.
2621     SparseArrayValueMap::AddResult result = map-&gt;add(this, index);
2622     SparseArrayEntry* entryInMap = &amp;result.iterator-&gt;value;
2623 
2624     // 2. Let extensible be the value of the [[Extensible]] internal property of O.
2625     // 3. If current is undefined and extensible is false, then Reject.
2626     // 4. If current is undefined and extensible is true, then
2627     if (result.isNewEntry) {
2628         if (!isStructureExtensible(vm)) {
2629             map-&gt;remove(result.iterator);
<span class="line-modified">2630             return typeError(globalObject, scope, throwException, NonExtensibleObjectPropertyDefineError);</span>
2631         }
2632 
2633         // 4.a. If IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is true, then create an own data property
2634         // named P of object O whose [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]] attribute values
2635         // are described by Desc. If the value of an attribute field of Desc is absent, the attribute of the newly
2636         // created property is set to its default value.
2637         // 4.b. Else, Desc must be an accessor Property Descriptor so, create an own accessor property named P of
2638         // object O whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by
2639         // Desc. If the value of an attribute field of Desc is absent, the attribute of the newly created property
2640         // is set to its default value.
2641         // 4.c. Return true.
2642 
2643         PropertyDescriptor defaults(jsUndefined(), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
<span class="line-modified">2644         putIndexedDescriptor(globalObject, map, entryInMap, descriptor, defaults);</span>
2645         Butterfly* butterfly = m_butterfly.get();
2646         if (index &gt;= butterfly-&gt;arrayStorage()-&gt;length())
2647             butterfly-&gt;arrayStorage()-&gt;setLength(index + 1);
2648         return true;
2649     }
2650 
2651     // 5. Return true, if every field in Desc is absent.
2652     // 6. Return true, if every field in Desc also occurs in current and the value of every field in Desc is the same value as the corresponding field in current when compared using the SameValue algorithm (9.12).
2653     PropertyDescriptor current;
2654     entryInMap-&gt;get(current);
<span class="line-modified">2655     bool isEmptyOrEqual = descriptor.isEmpty() || descriptor.equalTo(globalObject, current);</span>
2656     RETURN_IF_EXCEPTION(scope, false);
2657     if (isEmptyOrEqual)
2658         return true;
2659 
2660     // 7. If the [[Configurable]] field of current is false then
2661     if (!current.configurable()) {
2662         // 7.a. Reject, if the [[Configurable]] field of Desc is true.
2663         if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<span class="line-modified">2664             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
2665         // 7.b. Reject, if the [[Enumerable]] field of Desc is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other.
2666         if (descriptor.enumerablePresent() &amp;&amp; current.enumerable() != descriptor.enumerable())
<span class="line-modified">2667             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
2668     }
2669 
2670     // 8. If IsGenericDescriptor(Desc) is true, then no further validation is required.
2671     if (!descriptor.isGenericDescriptor()) {
2672         // 9. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then
2673         if (current.isDataDescriptor() != descriptor.isDataDescriptor()) {
2674             // 9.a. Reject, if the [[Configurable]] field of current is false.
2675             if (!current.configurable())
<span class="line-modified">2676                 return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
2677             // 9.b. If IsDataDescriptor(current) is true, then convert the property named P of object O from a
2678             // data property to an accessor property. Preserve the existing values of the converted property&#39;s
2679             // [[Configurable]] and [[Enumerable]] attributes and set the rest of the property&#39;s attributes to
2680             // their default values.
2681             // 9.c. Else, convert the property named P of object O from an accessor property to a data property.
2682             // Preserve the existing values of the converted property&#39;s [[Configurable]] and [[Enumerable]]
2683             // attributes and set the rest of the property&#39;s attributes to their default values.
2684         } else if (current.isDataDescriptor() &amp;&amp; descriptor.isDataDescriptor()) {
2685             // 10. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then
2686             // 10.a. If the [[Configurable]] field of current is false, then
2687             if (!current.configurable() &amp;&amp; !current.writable()) {
2688                 // 10.a.i. Reject, if the [[Writable]] field of current is false and the [[Writable]] field of Desc is true.
2689                 if (descriptor.writable())
<span class="line-modified">2690                     return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
2691                 // 10.a.ii. If the [[Writable]] field of current is false, then
2692                 // 10.a.ii.1. Reject, if the [[Value]] field of Desc is present and SameValue(Desc.[[Value]], current.[[Value]]) is false.
<span class="line-modified">2693                 if (descriptor.value()) {</span>
<span class="line-modified">2694                     bool isSame = sameValue(globalObject, descriptor.value(), current.value());</span>
<span class="line-added">2695                     RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">2696                     if (!isSame)</span>
<span class="line-added">2697                         return typeError(globalObject, scope, throwException, ReadonlyPropertyChangeError);</span>
<span class="line-added">2698                 }</span>
2699             }
2700             // 10.b. else, the [[Configurable]] field of current is true, so any change is acceptable.
2701         } else {
2702             ASSERT(current.isAccessorDescriptor() &amp;&amp; current.getterPresent() &amp;&amp; current.setterPresent());
2703             // 11. Else, IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true so, if the [[Configurable]] field of current is false, then
2704             if (!current.configurable()) {
2705                 // 11.i. Reject, if the [[Set]] field of Desc is present and SameValue(Desc.[[Set]], current.[[Set]]) is false.
2706                 if (descriptor.setterPresent() &amp;&amp; descriptor.setter() != current.setter())
<span class="line-modified">2707                     return typeError(globalObject, scope, throwException, &quot;Attempting to change the setter of an unconfigurable property.&quot;_s);</span>
2708                 // 11.ii. Reject, if the [[Get]] field of Desc is present and SameValue(Desc.[[Get]], current.[[Get]]) is false.
2709                 if (descriptor.getterPresent() &amp;&amp; descriptor.getter() != current.getter())
<span class="line-modified">2710                     return typeError(globalObject, scope, throwException, &quot;Attempting to change the getter of an unconfigurable property.&quot;_s);</span>
2711             }
2712         }
2713     }
2714 
2715     // 12. For each attribute field of Desc that is present, set the correspondingly named attribute of the property named P of object O to the value of the field.
<span class="line-modified">2716     putIndexedDescriptor(globalObject, map, entryInMap, descriptor, current);</span>
2717     // 13. Return true.
2718     return true;
2719 }
2720 
2721 SparseArrayValueMap* JSObject::allocateSparseIndexMap(VM&amp; vm)
2722 {
2723     SparseArrayValueMap* result = SparseArrayValueMap::create(vm);
2724     arrayStorage()-&gt;m_sparseMap.set(vm, this, result);
2725     return result;
2726 }
2727 
2728 void JSObject::deallocateSparseIndexMap()
2729 {
2730     if (ArrayStorage* arrayStorage = arrayStorageOrNull())
2731         arrayStorage-&gt;m_sparseMap.clear();
2732 }
2733 
<span class="line-modified">2734 bool JSObject::attemptToInterceptPutByIndexOnHoleForPrototype(JSGlobalObject* globalObject, JSValue thisValue, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)</span>
2735 {
<span class="line-modified">2736     VM&amp; vm = globalObject-&gt;vm();</span>
2737     auto scope = DECLARE_THROW_SCOPE(vm);
2738 
2739     for (JSObject* current = this; ;) {
2740         // This has the same behavior with respect to prototypes as JSObject::put(). It only
2741         // allows a prototype to intercept a put if (a) the prototype declares the property
2742         // we&#39;re after rather than intercepting it via an override of JSObject::put(), and
2743         // (b) that property is declared as ReadOnly or Accessor.
2744 
2745         ArrayStorage* storage = current-&gt;arrayStorageOrNull();
2746         if (storage &amp;&amp; storage-&gt;m_sparseMap) {
2747             SparseArrayValueMap::iterator iter = storage-&gt;m_sparseMap-&gt;find(i);
2748             if (iter != storage-&gt;m_sparseMap-&gt;notFound() &amp;&amp; (iter-&gt;value.attributes() &amp; (PropertyAttribute::Accessor | PropertyAttribute::ReadOnly))) {
2749                 scope.release();
<span class="line-modified">2750                 putResult = iter-&gt;value.put(globalObject, thisValue, storage-&gt;m_sparseMap.get(), value, shouldThrow);</span>
2751                 return true;
2752             }
2753         }
2754 
2755         if (current-&gt;type() == ProxyObjectType) {
2756             scope.release();
2757             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
<span class="line-modified">2758             putResult = proxy-&gt;putByIndexCommon(globalObject, thisValue, i, value, shouldThrow);</span>
2759             return true;
2760         }
2761 
<span class="line-modified">2762         JSValue prototypeValue = current-&gt;getPrototype(vm, globalObject);</span>
2763         RETURN_IF_EXCEPTION(scope, false);
2764         if (prototypeValue.isNull())
2765             return false;
2766 
2767         current = asObject(prototypeValue);
2768     }
2769 }
2770 
<span class="line-modified">2771 bool JSObject::attemptToInterceptPutByIndexOnHole(JSGlobalObject* globalObject, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)</span>
2772 {
<span class="line-modified">2773     VM&amp; vm = globalObject-&gt;vm();</span>
2774     auto scope = DECLARE_THROW_SCOPE(vm);
2775 
<span class="line-modified">2776     JSValue prototypeValue = getPrototype(vm, globalObject);</span>
2777     RETURN_IF_EXCEPTION(scope, false);
2778     if (prototypeValue.isNull())
2779         return false;
2780 
<span class="line-modified">2781     RELEASE_AND_RETURN(scope, asObject(prototypeValue)-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(globalObject, this, i, value, shouldThrow, putResult));</span>
2782 }
2783 
2784 template&lt;IndexingType indexingShape&gt;
<span class="line-modified">2785 bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes(JSGlobalObject* globalObject, unsigned i, JSValue value)</span>
2786 {
<span class="line-modified">2787     VM&amp; vm = globalObject-&gt;vm();</span>
2788     auto scope = DECLARE_THROW_SCOPE(vm);
2789 
2790     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
2791     ASSERT((indexingType() &amp; IndexingShapeMask) == indexingShape);
2792     ASSERT(!indexingShouldBeSparse(vm));
2793 
2794     Butterfly* butterfly = m_butterfly.get();
2795 
2796     // For us to get here, the index is either greater than the public length, or greater than
2797     // or equal to the vector length.
2798     ASSERT(i &gt;= butterfly-&gt;vectorLength());
2799 
2800     if (i &gt; MAX_STORAGE_VECTOR_INDEX
2801         || (i &gt;= MIN_SPARSE_ARRAY_INDEX &amp;&amp; !isDenseEnoughForVector(i, countElements&lt;indexingShape&gt;(butterfly)))
2802         || indexIsSufficientlyBeyondLengthForSparseMap(i, butterfly-&gt;vectorLength())) {
2803         ASSERT(i &lt;= MAX_ARRAY_INDEX);
2804         ensureArrayStorageSlow(vm);
2805         SparseArrayValueMap* map = allocateSparseIndexMap(vm);
<span class="line-modified">2806         bool result = map-&gt;putEntry(globalObject, this, i, value, false);</span>
2807         RETURN_IF_EXCEPTION(scope, false);
2808         ASSERT(i &gt;= arrayStorage()-&gt;length());
2809         arrayStorage()-&gt;setLength(i + 1);
2810         return result;
2811     }
2812 
2813     if (!ensureLength(vm, i + 1)) {
<span class="line-modified">2814         throwOutOfMemoryError(globalObject, scope);</span>
2815         return false;
2816     }
2817     butterfly = m_butterfly.get();
2818 
2819     RELEASE_ASSERT(i &lt; butterfly-&gt;vectorLength());
2820     switch (indexingShape) {
2821     case Int32Shape:
2822         ASSERT(value.isInt32());
2823         butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(value);
2824         return true;
2825 
2826     case DoubleShape: {
2827         ASSERT(value.isNumber());
2828         double valueAsDouble = value.asNumber();
2829         ASSERT(valueAsDouble == valueAsDouble);
2830         butterfly-&gt;contiguousDouble().at(this, i) = valueAsDouble;
2831         return true;
2832     }
2833 
2834     case ContiguousShape:
2835         butterfly-&gt;contiguous().at(this, i).set(vm, this, value);
2836         return true;
2837 
2838     default:
2839         CRASH();
2840         return false;
2841     }
2842 }
2843 
2844 // Explicit instantiations needed by JSArray.cpp.
<span class="line-modified">2845 template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(JSGlobalObject*, unsigned, JSValue);</span>
<span class="line-modified">2846 template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(JSGlobalObject*, unsigned, JSValue);</span>
<span class="line-modified">2847 template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(JSGlobalObject*, unsigned, JSValue);</span>
2848 
<span class="line-modified">2849 bool JSObject::putByIndexBeyondVectorLengthWithArrayStorage(JSGlobalObject* globalObject, unsigned i, JSValue value, bool shouldThrow, ArrayStorage* storage)</span>
2850 {
<span class="line-modified">2851     VM&amp; vm = globalObject-&gt;vm();</span>
2852     auto scope = DECLARE_THROW_SCOPE(vm);
2853 
2854     ASSERT(!isCopyOnWrite(indexingMode()));
2855     // i should be a valid array index that is outside of the current vector.
2856     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2857     ASSERT(i &gt;= storage-&gt;vectorLength());
2858 
2859     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
2860 
2861     // First, handle cases where we don&#39;t currently have a sparse map.
2862     if (LIKELY(!map)) {
2863         // If the array is not extensible, we should have entered dictionary mode, and created the sparse map.
2864         ASSERT(isStructureExtensible(vm));
2865 
2866         // Update m_length if necessary.
2867         if (i &gt;= storage-&gt;length())
2868             storage-&gt;setLength(i + 1);
2869 
2870         // Check that it is sensible to still be using a vector, and then try to grow the vector.
2871         if (LIKELY(!indexIsSufficientlyBeyondLengthForSparseMap(i, storage-&gt;vectorLength())
2872             &amp;&amp; isDenseEnoughForVector(i, storage-&gt;m_numValuesInVector)
2873             &amp;&amp; increaseVectorLength(vm, i + 1))) {
2874             // success! - reread m_storage since it has likely been reallocated, and store to the vector.
2875             storage = arrayStorage();
2876             storage-&gt;m_vector[i].set(vm, this, value);
2877             ++storage-&gt;m_numValuesInVector;
2878             return true;
2879         }
2880         // We don&#39;t want to, or can&#39;t use a vector to hold this property - allocate a sparse map &amp; add the value.
2881         map = allocateSparseIndexMap(vm);
<span class="line-modified">2882         RELEASE_AND_RETURN(scope, map-&gt;putEntry(globalObject, this, i, value, shouldThrow));</span>
2883     }
2884 
2885     // Update m_length if necessary.
2886     unsigned length = storage-&gt;length();
2887     if (i &gt;= length) {
2888         // Prohibit growing the array if length is not writable.
2889         if (map-&gt;lengthIsReadOnly() || !isStructureExtensible(vm))
<span class="line-modified">2890             return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
2891         length = i + 1;
2892         storage-&gt;setLength(length);
2893     }
2894 
2895     // We are currently using a map - check whether we still want to be doing so.
2896     // We will continue  to use a sparse map if SparseMode is set, a vector would be too sparse, or if allocation fails.
2897     unsigned numValuesInArray = storage-&gt;m_numValuesInVector + map-&gt;size();
2898     if (map-&gt;sparseMode() || !isDenseEnoughForVector(length, numValuesInArray) || !increaseVectorLength(vm, length))
<span class="line-modified">2899         RELEASE_AND_RETURN(scope, map-&gt;putEntry(globalObject, this, i, value, shouldThrow));</span>
2900 
2901     // Reread m_storage after increaseVectorLength, update m_numValuesInVector.
2902     storage = arrayStorage();
2903     storage-&gt;m_numValuesInVector = numValuesInArray;
2904 
2905     // Copy all values from the map into the vector, and delete the map.
2906     WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
2907     SparseArrayValueMap::const_iterator end = map-&gt;end();
2908     for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it)
2909         vector[it-&gt;key].set(vm, this, it-&gt;value.getNonSparseMode());
2910     deallocateSparseIndexMap();
2911 
2912     // Store the new property into the vector.
2913     WriteBarrier&lt;Unknown&gt;&amp; valueSlot = vector[i];
2914     if (!valueSlot)
2915         ++storage-&gt;m_numValuesInVector;
2916     valueSlot.set(vm, this, value);
2917     return true;
2918 }
2919 
<span class="line-modified">2920 bool JSObject::putByIndexBeyondVectorLength(JSGlobalObject* globalObject, unsigned i, JSValue value, bool shouldThrow)</span>
2921 {
<span class="line-modified">2922     VM&amp; vm = globalObject-&gt;vm();</span>
2923     auto scope = DECLARE_THROW_SCOPE(vm);
2924 
2925     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
2926 
2927     // i should be a valid array index that is outside of the current vector.
2928     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2929 
2930     switch (indexingType()) {
2931     case ALL_BLANK_INDEXING_TYPES: {
2932         if (indexingShouldBeSparse(vm)) {
2933             RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(
<span class="line-modified">2934                 globalObject, i, value, shouldThrow,</span>
2935                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm)));
2936         }
2937         if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {
<span class="line-modified">2938             RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, shouldThrow, createArrayStorage(vm, 0, 0)));</span>
2939         }
2940         if (needsSlowPutIndexing(vm)) {
2941             // Convert the indexing type to the SlowPutArrayStorage and retry.
2942             createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
<span class="line-modified">2943             RELEASE_AND_RETURN(scope, putByIndex(this, globalObject, i, value, shouldThrow));</span>
2944         }
2945 
2946         createInitialForValueAndSet(vm, i, value);
2947         return true;
2948     }
2949 
2950     case ALL_UNDECIDED_INDEXING_TYPES: {
2951         CRASH();
2952         break;
2953     }
2954 
2955     case ALL_INT32_INDEXING_TYPES:
<span class="line-modified">2956         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(globalObject, i, value));</span>
2957 
2958     case ALL_DOUBLE_INDEXING_TYPES:
<span class="line-modified">2959         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(globalObject, i, value));</span>
2960 
2961     case ALL_CONTIGUOUS_INDEXING_TYPES:
<span class="line-modified">2962         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(globalObject, i, value));</span>
2963 
2964     case NonArrayWithSlowPutArrayStorage:
2965     case ArrayWithSlowPutArrayStorage: {
2966         // No own property present in the vector, but there might be in the sparse map!
2967         SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
2968         bool putResult = false;
2969         if (!(map &amp;&amp; map-&gt;contains(i))) {
<span class="line-modified">2970             bool result = attemptToInterceptPutByIndexOnHole(globalObject, i, value, shouldThrow, putResult);</span>
2971             RETURN_IF_EXCEPTION(scope, false);
2972             if (result)
2973                 return putResult;
2974         }
2975         FALLTHROUGH;
2976     }
2977 
2978     case NonArrayWithArrayStorage:
2979     case ArrayWithArrayStorage:
<span class="line-modified">2980         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, shouldThrow, arrayStorage()));</span>
2981 
2982     default:
2983         RELEASE_ASSERT_NOT_REACHED();
2984     }
2985     return false;
2986 }
2987 
<span class="line-modified">2988 bool JSObject::putDirectIndexBeyondVectorLengthWithArrayStorage(JSGlobalObject* globalObject, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode, ArrayStorage* storage)</span>
2989 {
<span class="line-modified">2990     VM&amp; vm = globalObject-&gt;vm();</span>
2991     auto scope = DECLARE_THROW_SCOPE(vm);
2992 
2993     // i should be a valid array index that is outside of the current vector.
2994     ASSERT(hasAnyArrayStorage(indexingType()));
2995     ASSERT(arrayStorage() == storage);
2996     ASSERT(i &gt;= storage-&gt;vectorLength() || attributes);
2997     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2998 
2999     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
3000 
3001     // First, handle cases where we don&#39;t currently have a sparse map.
3002     if (LIKELY(!map)) {
3003         // If the array is not extensible, we should have entered dictionary mode, and created the spare map.
3004         ASSERT(isStructureExtensible(vm));
3005 
3006         // Update m_length if necessary.
3007         if (i &gt;= storage-&gt;length())
3008             storage-&gt;setLength(i + 1);
3009 
3010         // Check that it is sensible to still be using a vector, and then try to grow the vector.
3011         if (LIKELY(
3012                 !attributes
3013                 &amp;&amp; (isDenseEnoughForVector(i, storage-&gt;m_numValuesInVector))
3014                 &amp;&amp; !indexIsSufficientlyBeyondLengthForSparseMap(i, storage-&gt;vectorLength()))
3015                 &amp;&amp; increaseVectorLength(vm, i + 1)) {
3016             // success! - reread m_storage since it has likely been reallocated, and store to the vector.
3017             storage = arrayStorage();
3018             storage-&gt;m_vector[i].set(vm, this, value);
3019             ++storage-&gt;m_numValuesInVector;
3020             return true;
3021         }
3022         // We don&#39;t want to, or can&#39;t use a vector to hold this property - allocate a sparse map &amp; add the value.
3023         map = allocateSparseIndexMap(vm);
<span class="line-modified">3024         RELEASE_AND_RETURN(scope, map-&gt;putDirect(globalObject, this, i, value, attributes, mode));</span>
3025     }
3026 
3027     // Update m_length if necessary.
3028     unsigned length = storage-&gt;length();
3029     if (i &gt;= length) {
3030         if (mode != PutDirectIndexLikePutDirect) {
3031             // Prohibit growing the array if length is not writable.
3032             if (map-&gt;lengthIsReadOnly())
<span class="line-modified">3033                 return typeError(globalObject, scope, mode == PutDirectIndexShouldThrow, ReadonlyPropertyWriteError);</span>
3034             if (!isStructureExtensible(vm))
<span class="line-modified">3035                 return typeError(globalObject, scope, mode == PutDirectIndexShouldThrow, NonExtensibleObjectPropertyDefineError);</span>
3036         }
3037         length = i + 1;
3038         storage-&gt;setLength(length);
3039     }
3040 
3041     // We are currently using a map - check whether we still want to be doing so.
3042     // We will continue  to use a sparse map if SparseMode is set, a vector would be too sparse, or if allocation fails.
3043     unsigned numValuesInArray = storage-&gt;m_numValuesInVector + map-&gt;size();
3044     if (map-&gt;sparseMode() || attributes || !isDenseEnoughForVector(length, numValuesInArray) || !increaseVectorLength(vm, length))
<span class="line-modified">3045         RELEASE_AND_RETURN(scope, map-&gt;putDirect(globalObject, this, i, value, attributes, mode));</span>
3046 
3047     // Reread m_storage after increaseVectorLength, update m_numValuesInVector.
3048     storage = arrayStorage();
3049     storage-&gt;m_numValuesInVector = numValuesInArray;
3050 
3051     // Copy all values from the map into the vector, and delete the map.
3052     WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
3053     SparseArrayValueMap::const_iterator end = map-&gt;end();
3054     for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it)
3055         vector[it-&gt;key].set(vm, this, it-&gt;value.getNonSparseMode());
3056     deallocateSparseIndexMap();
3057 
3058     // Store the new property into the vector.
3059     WriteBarrier&lt;Unknown&gt;&amp; valueSlot = vector[i];
3060     if (!valueSlot)
3061         ++storage-&gt;m_numValuesInVector;
3062     valueSlot.set(vm, this, value);
3063     return true;
3064 }
3065 
<span class="line-modified">3066 bool JSObject::putDirectIndexSlowOrBeyondVectorLength(JSGlobalObject* globalObject, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode)</span>
3067 {
<span class="line-modified">3068     VM&amp; vm = globalObject-&gt;vm();</span>
3069     ASSERT(!value.isCustomGetterSetter());
3070 
3071     if (!canDoFastPutDirectIndex(vm, this)) {
3072         PropertyDescriptor descriptor;
3073         descriptor.setDescriptor(value, attributes);
<span class="line-modified">3074         return methodTable(vm)-&gt;defineOwnProperty(this, globalObject, Identifier::from(vm, i), descriptor, mode == PutDirectIndexShouldThrow);</span>
3075     }
3076 
3077     // i should be a valid array index that is outside of the current vector.
3078     ASSERT(i &lt;= MAX_ARRAY_INDEX);
3079 
3080     if (attributes &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor))
3081         notifyPresenceOfIndexedAccessors(vm);
3082 
3083     switch (indexingType()) {
3084     case ALL_BLANK_INDEXING_TYPES: {
3085         if (indexingShouldBeSparse(vm) || attributes) {
3086             return putDirectIndexBeyondVectorLengthWithArrayStorage(
<span class="line-modified">3087                 globalObject, i, value, attributes, mode,</span>
3088                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3089         }
3090         if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {
3091             return putDirectIndexBeyondVectorLengthWithArrayStorage(
<span class="line-modified">3092                 globalObject, i, value, attributes, mode, createArrayStorage(vm, 0, 0));</span>
3093         }
3094         if (needsSlowPutIndexing(vm)) {
3095             ArrayStorage* storage = createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
3096             storage-&gt;m_vector[i].set(vm, this, value);
3097             storage-&gt;m_numValuesInVector++;
3098             return true;
3099         }
3100 
3101         createInitialForValueAndSet(vm, i, value);
3102         return true;
3103     }
3104 
3105     case ALL_UNDECIDED_INDEXING_TYPES: {
3106         convertUndecidedForValue(vm, value);
3107         // Reloop.
<span class="line-modified">3108         return putDirectIndex(globalObject, i, value, attributes, mode);</span>
3109     }
3110 
3111     case ALL_INT32_INDEXING_TYPES: {
3112         ASSERT(!indexingShouldBeSparse(vm));
3113         if (attributes)
<span class="line-modified">3114             return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
3115         if (!value.isInt32()) {
3116             convertInt32ForValue(vm, value);
<span class="line-modified">3117             return putDirectIndexSlowOrBeyondVectorLength(globalObject, i, value, attributes, mode);</span>
3118         }
<span class="line-modified">3119         putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(globalObject, i, value);</span>
3120         return true;
3121     }
3122 
3123     case ALL_DOUBLE_INDEXING_TYPES: {
3124         ASSERT(!indexingShouldBeSparse(vm));
3125         if (attributes)
<span class="line-modified">3126             return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
3127         if (!value.isNumber()) {
3128             convertDoubleToContiguous(vm);
<span class="line-modified">3129             return putDirectIndexSlowOrBeyondVectorLength(globalObject, i, value, attributes, mode);</span>
3130         }
3131         double valueAsDouble = value.asNumber();
3132         if (valueAsDouble != valueAsDouble) {
3133             convertDoubleToContiguous(vm);
<span class="line-modified">3134             return putDirectIndexSlowOrBeyondVectorLength(globalObject, i, value, attributes, mode);</span>
3135         }
<span class="line-modified">3136         putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(globalObject, i, value);</span>
3137         return true;
3138     }
3139 
3140     case ALL_CONTIGUOUS_INDEXING_TYPES: {
3141         ASSERT(!indexingShouldBeSparse(vm));
3142         if (attributes)
<span class="line-modified">3143             return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
<span class="line-modified">3144         putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(globalObject, i, value);</span>
3145         return true;
3146     }
3147 
3148     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
3149         if (attributes)
<span class="line-modified">3150             return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
<span class="line-modified">3151         return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, arrayStorage());</span>
3152 
3153     default:
3154         RELEASE_ASSERT_NOT_REACHED();
3155         return false;
3156     }
3157 }
3158 
3159 bool JSObject::putDirectNativeIntrinsicGetter(VM&amp; vm, JSGlobalObject* globalObject, Identifier name, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3160 {
3161     JSFunction* function = JSFunction::create(vm, globalObject, 0, makeString(&quot;get &quot;, name.string()), nativeFunction, intrinsic);
3162     GetterSetter* accessor = GetterSetter::create(vm, globalObject, function, nullptr);
3163     return putDirectNonIndexAccessor(vm, name, accessor, attributes);
3164 }
3165 
3166 void JSObject::putDirectNativeIntrinsicGetterWithoutTransition(VM&amp; vm, JSGlobalObject* globalObject, Identifier name, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3167 {
3168     JSFunction* function = JSFunction::create(vm, globalObject, 0, makeString(&quot;get &quot;, name.string()), nativeFunction, intrinsic);
3169     GetterSetter* accessor = GetterSetter::create(vm, globalObject, function, nullptr);
3170     putDirectNonIndexAccessorWithoutTransition(vm, name, accessor, attributes);
3171 }
</pre>
<hr />
<pre>
3419             butterfly-&gt;indexingPayload&lt;WriteBarrier&lt;Unknown&gt;&gt;()[i].clear();
3420     }
3421 
3422     if (newButterfly) {
3423         butterfly-&gt;setVectorLength(newVectorLength);
3424         WTF::storeStoreFence();
3425         m_butterfly.set(vm, this, newButterfly);
3426     } else {
3427         WTF::storeStoreFence();
3428         butterfly-&gt;setVectorLength(newVectorLength);
3429     }
3430 
3431     return true;
3432 }
3433 
3434 void JSObject::reallocateAndShrinkButterfly(VM&amp; vm, unsigned length)
3435 {
3436     ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
3437     ASSERT(hasContiguous(indexingType()) || hasInt32(indexingType()) || hasDouble(indexingType()) || hasUndecided(indexingType()));
3438     ASSERT(m_butterfly-&gt;vectorLength() &gt; length);
<span class="line-added">3439     ASSERT(m_butterfly-&gt;publicLength() &gt;= length);</span>
3440     ASSERT(!m_butterfly-&gt;indexingHeader()-&gt;preCapacity(structure(vm)));
3441 
3442     DeferGC deferGC(vm.heap);
3443     Butterfly* newButterfly = butterfly()-&gt;resizeArray(vm, this, structure(vm), 0, ArrayStorage::sizeFor(length));
3444     newButterfly-&gt;setVectorLength(length);
3445     newButterfly-&gt;setPublicLength(length);
3446     WTF::storeStoreFence();
3447     m_butterfly.set(vm, this, newButterfly);
3448 
3449 }
3450 
3451 Butterfly* JSObject::allocateMoreOutOfLineStorage(VM&amp; vm, size_t oldSize, size_t newSize)
3452 {
3453     ASSERT(newSize &gt; oldSize);
3454 
3455     // It&#39;s important that this function not rely on structure(), for the property
3456     // capacity, since we might have already mutated the structure in-place.
3457 
3458     return Butterfly::createOrGrowPropertyStorage(butterfly(), vm, this, structure(vm), oldSize, newSize);
3459 }
3460 
<span class="line-modified">3461 static JSCustomGetterSetterFunction* getCustomGetterSetterFunctionForGetterSetter(JSGlobalObject* globalObject, PropertyName propertyName, CustomGetterSetter* getterSetter, JSCustomGetterSetterFunction::Type type)</span>
3462 {
<span class="line-modified">3463     VM&amp; vm = globalObject-&gt;vm();</span>
3464     auto key = std::make_pair(getterSetter, (int)type);
3465     JSCustomGetterSetterFunction* customGetterSetterFunction = vm.customGetterSetterFunctionMap.get(key);
3466     if (!customGetterSetterFunction) {
<span class="line-modified">3467         customGetterSetterFunction = JSCustomGetterSetterFunction::create(vm, globalObject, getterSetter, type, propertyName.publicName());</span>
3468         vm.customGetterSetterFunctionMap.set(key, customGetterSetterFunction);
3469     }
3470     return customGetterSetterFunction;
3471 }
3472 
<span class="line-modified">3473 bool JSObject::getOwnPropertyDescriptor(JSGlobalObject* globalObject, PropertyName propertyName, PropertyDescriptor&amp; descriptor)</span>
3474 {
<span class="line-modified">3475     VM&amp; vm = globalObject-&gt;vm();</span>
3476     auto scope = DECLARE_THROW_SCOPE(vm);
3477     JSC::PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
3478 
<span class="line-modified">3479     bool result = methodTable(vm)-&gt;getOwnPropertySlot(this, globalObject, propertyName, slot);</span>
3480     EXCEPTION_ASSERT(!scope.exception() || !result);
3481     if (!result)
3482         return false;
3483 
3484 
3485     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=200560
3486     // This breaks the assumption that getOwnPropertySlot should return &quot;own&quot; property.
3487     // We should fix DebuggerScope, ProxyObject etc. to remove this.
3488     //
3489     // DebuggerScope::getOwnPropertySlot() (and possibly others) may return attributes from the prototype chain
3490     // but getOwnPropertyDescriptor() should only work for &#39;own&#39; properties so we exit early if we detect that
3491     // the property is not an own property.
3492     if (slot.slotBase() != this &amp;&amp; slot.slotBase()) {
3493         JSProxy* jsProxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this);
3494         if (!jsProxy || jsProxy-&gt;target() != slot.slotBase()) {
3495             // Try ProxyObject.
3496             ProxyObject* proxyObject = jsDynamicCast&lt;ProxyObject*&gt;(vm, this);
3497             if (!proxyObject || proxyObject-&gt;target() != slot.slotBase())
3498                 return false;
3499         }
3500     }
3501 
3502     if (slot.isAccessor())
3503         descriptor.setAccessorDescriptor(slot.getterSetter(), slot.attributes());
3504     else if (slot.attributes() &amp; PropertyAttribute::CustomAccessor) {
3505         descriptor.setCustomDescriptor(slot.attributes());
3506 
3507         JSObject* thisObject = this;
3508         if (auto* proxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this))
3509             thisObject = proxy-&gt;target();
3510 
3511         CustomGetterSetter* getterSetter;
3512         if (slot.isCustomAccessor())
3513             getterSetter = slot.customGetterSetter();
3514         else {
3515             JSValue maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
3516             if (!maybeGetterSetter) {
<span class="line-modified">3517                 thisObject-&gt;reifyAllStaticProperties(globalObject);</span>
3518                 maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
3519             }
3520 
3521             ASSERT(maybeGetterSetter);
3522             getterSetter = jsDynamicCast&lt;CustomGetterSetter*&gt;(vm, maybeGetterSetter);
3523         }
3524         ASSERT(getterSetter);
3525         if (!getterSetter)
3526             return false;
3527 
3528         if (getterSetter-&gt;getter())
<span class="line-modified">3529             descriptor.setGetter(getCustomGetterSetterFunctionForGetterSetter(globalObject, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Getter));</span>
3530         if (getterSetter-&gt;setter())
<span class="line-modified">3531             descriptor.setSetter(getCustomGetterSetterFunctionForGetterSetter(globalObject, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Setter));</span>
3532     } else {
<span class="line-modified">3533         JSValue value = slot.getValue(globalObject, propertyName);</span>
3534         RETURN_IF_EXCEPTION(scope, false);
3535         descriptor.setDescriptor(value, slot.attributes());
3536     }
3537 
3538     return true;
3539 }
3540 
<span class="line-modified">3541 static bool putDescriptor(JSGlobalObject* globalObject, JSObject* target, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, unsigned attributes, const PropertyDescriptor&amp; oldDescriptor)</span>
3542 {
<span class="line-modified">3543     VM&amp; vm = globalObject-&gt;vm();</span>
3544     if (descriptor.isGenericDescriptor() || descriptor.isDataDescriptor()) {
3545         if (descriptor.isGenericDescriptor() &amp;&amp; oldDescriptor.isAccessorDescriptor()) {
3546             JSObject* getter = oldDescriptor.getterPresent() ? oldDescriptor.getterObject() : nullptr;
3547             JSObject* setter = oldDescriptor.setterPresent() ? oldDescriptor.setterObject() : nullptr;
<span class="line-modified">3548             GetterSetter* accessor = GetterSetter::create(vm, globalObject, getter, setter);</span>
<span class="line-modified">3549             target-&gt;putDirectAccessor(globalObject, propertyName, accessor, attributes | PropertyAttribute::Accessor);</span>
3550             return true;
3551         }
3552         JSValue newValue = jsUndefined();
3553         if (descriptor.value())
3554             newValue = descriptor.value();
3555         else if (oldDescriptor.value())
3556             newValue = oldDescriptor.value();
3557         target-&gt;putDirect(vm, propertyName, newValue, attributes &amp; ~PropertyAttribute::Accessor);
3558         if (attributes &amp; PropertyAttribute::ReadOnly)
3559             target-&gt;structure(vm)-&gt;setContainsReadOnlyProperties();
3560         return true;
3561     }
3562     attributes &amp;= ~PropertyAttribute::ReadOnly;
3563 
3564     JSObject* getter = descriptor.getterPresent()
3565         ? descriptor.getterObject() : oldDescriptor.getterPresent()
3566         ? oldDescriptor.getterObject() : nullptr;
3567     JSObject* setter = descriptor.setterPresent()
3568         ? descriptor.setterObject() : oldDescriptor.setterPresent()
3569         ? oldDescriptor.setterObject() : nullptr;
<span class="line-modified">3570     GetterSetter* accessor = GetterSetter::create(vm, globalObject, getter, setter);</span>
3571 
<span class="line-modified">3572     target-&gt;putDirectAccessor(globalObject, propertyName, accessor, attributes | PropertyAttribute::Accessor);</span>
3573     return true;
3574 }
3575 
<span class="line-modified">3576 bool JSObject::putDirectMayBeIndex(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value)</span>
3577 {
3578     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">3579         return putDirectIndex(globalObject, index.value(), value);</span>
<span class="line-modified">3580     return putDirect(globalObject-&gt;vm(), propertyName, value);</span>
3581 }
3582 
3583 // 9.1.6.3 of the spec
3584 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-validateandapplypropertydescriptor
<span class="line-modified">3585 bool validateAndApplyPropertyDescriptor(JSGlobalObject* globalObject, JSObject* object, PropertyName propertyName, bool isExtensible,</span>
3586     const PropertyDescriptor&amp; descriptor, bool isCurrentDefined, const PropertyDescriptor&amp; current, bool throwException)
3587 {
<span class="line-modified">3588     VM&amp; vm = globalObject-&gt;vm();</span>
3589     auto scope = DECLARE_THROW_SCOPE(vm);
3590 
3591     // If we have a new property we can just put it on normally
3592     // Step 2.
3593     if (!isCurrentDefined) {
3594         // unless extensions are prevented!
3595         // Step 2.a
3596         if (!isExtensible)
<span class="line-modified">3597             return typeError(globalObject, scope, throwException, NonExtensibleObjectPropertyDefineError);</span>
3598         if (!object)
3599             return true;
3600         // Step 2.c/d
3601         PropertyDescriptor oldDescriptor;
3602         oldDescriptor.setValue(jsUndefined());
3603         // FIXME: spec says to always return true here.
<span class="line-modified">3604         return putDescriptor(globalObject, object, propertyName, descriptor, descriptor.attributes(), oldDescriptor);</span>
3605     }
3606     // Step 3.
3607     if (descriptor.isEmpty())
3608         return true;
3609     // Step 4.
<span class="line-modified">3610     bool isEqual = current.equalTo(globalObject, descriptor);</span>
3611     RETURN_IF_EXCEPTION(scope, false);
3612     if (isEqual)
3613         return true;
3614 
3615     // Step 5.
3616     // Filter out invalid changes
3617     if (!current.configurable()) {
3618         if (descriptor.configurable())
<span class="line-modified">3619             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
3620         if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable() != current.enumerable())
<span class="line-modified">3621             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
3622     }
3623 
3624     // Step 6.
3625     // A generic descriptor is simply changing the attributes of an existing property
3626     if (descriptor.isGenericDescriptor()) {
3627         if (!current.attributesEqual(descriptor) &amp;&amp; object) {
<span class="line-modified">3628             object-&gt;methodTable(vm)-&gt;deleteProperty(object, globalObject, propertyName);</span>
3629             RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">3630             return putDescriptor(globalObject, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);</span>
3631         }
3632         return true;
3633     }
3634 
3635     // Step 7.
3636     // Changing between a normal property or an accessor property
3637     if (descriptor.isDataDescriptor() != current.isDataDescriptor()) {
3638         if (!current.configurable())
<span class="line-modified">3639             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
3640 
3641         if (!object)
3642             return true;
3643 
<span class="line-modified">3644         object-&gt;methodTable(vm)-&gt;deleteProperty(object, globalObject, propertyName);</span>
3645         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">3646         return putDescriptor(globalObject, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);</span>
3647     }
3648 
3649     // Step 8.
3650     // Changing the value and attributes of an existing property
3651     if (descriptor.isDataDescriptor()) {
3652         if (!current.configurable()) {
3653             if (!current.writable() &amp;&amp; descriptor.writable())
<span class="line-modified">3654                 return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
3655             if (!current.writable()) {
<span class="line-modified">3656                 if (descriptor.value()) {</span>
<span class="line-modified">3657                     bool isSame = sameValue(globalObject, current.value(), descriptor.value());</span>
<span class="line-added">3658                     RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">3659                     if (!isSame)</span>
<span class="line-added">3660                         return typeError(globalObject, scope, throwException, ReadonlyPropertyChangeError);</span>
<span class="line-added">3661                 }</span>
3662             }
3663         }
3664         if (current.attributesEqual(descriptor) &amp;&amp; !descriptor.value())
3665             return true;
3666         if (!object)
3667             return true;
<span class="line-modified">3668         object-&gt;methodTable(vm)-&gt;deleteProperty(object, globalObject, propertyName);</span>
3669         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">3670         return putDescriptor(globalObject, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);</span>
3671     }
3672 
3673     // Step 9.
3674     // Changing the accessor functions of an existing accessor property
3675     ASSERT(descriptor.isAccessorDescriptor());
3676     if (!current.configurable()) {
<span class="line-modified">3677         if (descriptor.setterPresent() &amp;&amp; !(current.setterPresent() &amp;&amp; JSValue::strictEqual(globalObject, current.setter(), descriptor.setter())))</span>
<span class="line-modified">3678             return typeError(globalObject, scope, throwException, &quot;Attempting to change the setter of an unconfigurable property.&quot;_s);</span>
<span class="line-modified">3679         if (descriptor.getterPresent() &amp;&amp; !(current.getterPresent() &amp;&amp; JSValue::strictEqual(globalObject, current.getter(), descriptor.getter())))</span>
<span class="line-modified">3680             return typeError(globalObject, scope, throwException, &quot;Attempting to change the getter of an unconfigurable property.&quot;_s);</span>
3681         if (current.attributes() &amp; PropertyAttribute::CustomAccessor)
<span class="line-modified">3682             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
3683     }
3684 
3685     // Step 10/11.
3686     if (!object)
3687         return true;
3688     JSValue accessor = object-&gt;getDirect(vm, propertyName);
3689     if (!accessor)
3690         return false;
3691     JSObject* getter = nullptr;
3692     JSObject* setter = nullptr;
3693     bool getterSetterChanged = false;
3694 
3695     if (accessor.isCustomGetterSetter()) {
3696         auto* customGetterSetter = jsCast&lt;CustomGetterSetter*&gt;(accessor);
3697         if (customGetterSetter-&gt;setter())
<span class="line-modified">3698             setter = getCustomGetterSetterFunctionForGetterSetter(globalObject, propertyName, customGetterSetter, JSCustomGetterSetterFunction::Type::Setter);</span>
3699         if (customGetterSetter-&gt;getter())
<span class="line-modified">3700             getter = getCustomGetterSetterFunctionForGetterSetter(globalObject, propertyName, customGetterSetter, JSCustomGetterSetterFunction::Type::Getter);</span>
3701     } else {
3702         ASSERT(accessor.isGetterSetter());
3703         auto* getterSetter = jsCast&lt;GetterSetter*&gt;(accessor);
3704         getter = getterSetter-&gt;getter();
3705         setter = getterSetter-&gt;setter();
3706     }
3707     if (descriptor.setterPresent()) {
3708         setter = descriptor.setterObject();
3709         getterSetterChanged = true;
3710     }
3711     if (descriptor.getterPresent()) {
3712         getter = descriptor.getterObject();
3713         getterSetterChanged = true;
3714     }
3715 
3716     if (current.attributesEqual(descriptor) &amp;&amp; !getterSetterChanged)
3717         return true;
3718 
<span class="line-modified">3719     GetterSetter* getterSetter = GetterSetter::create(vm, globalObject, getter, setter);</span>
3720 
<span class="line-modified">3721     object-&gt;methodTable(vm)-&gt;deleteProperty(object, globalObject, propertyName);</span>
3722     RETURN_IF_EXCEPTION(scope, false);
3723     unsigned attrs = descriptor.attributesOverridingCurrent(current);
<span class="line-modified">3724     object-&gt;putDirectAccessor(globalObject, propertyName, getterSetter, attrs | PropertyAttribute::Accessor);</span>
3725     return true;
3726 }
3727 
<span class="line-modified">3728 bool JSObject::defineOwnNonIndexProperty(JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
3729 {
<span class="line-modified">3730     VM&amp; vm  = globalObject-&gt;vm();</span>
3731     auto throwScope = DECLARE_THROW_SCOPE(vm);
3732 
3733     // Track on the globaldata that we&#39;re in define property.
3734     // Currently DefineOwnProperty uses delete to remove properties when they are being replaced
3735     // (particularly when changing attributes), however delete won&#39;t allow non-configurable (i.e.
3736     // DontDelete) properties to be deleted. For now, we can use this flag to make this work.
3737     VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
3738     PropertyDescriptor current;
<span class="line-modified">3739     bool isCurrentDefined = getOwnPropertyDescriptor(globalObject, propertyName, current);</span>
<span class="line-modified">3740     RETURN_IF_EXCEPTION(throwScope, false);</span>
<span class="line-added">3741     bool isExtensible = this-&gt;isExtensible(globalObject);</span>
3742     RETURN_IF_EXCEPTION(throwScope, false);
<span class="line-modified">3743     RELEASE_AND_RETURN(throwScope, validateAndApplyPropertyDescriptor(globalObject, this, propertyName, isExtensible, descriptor, isCurrentDefined, current, throwException));</span>
3744 }
3745 
<span class="line-modified">3746 bool JSObject::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
3747 {
3748     // If it&#39;s an array index, then use the indexed property storage.
3749     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
3750         // c. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing P, Desc, and false as arguments.
3751         // d. Reject if succeeded is false.
3752         // e. If index &gt;= oldLen
3753         // e.i. Set oldLenDesc.[[Value]] to index + 1.
3754         // e.ii. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, oldLenDesc, and false as arguments. This call will always return true.
3755         // f. Return true.
<span class="line-modified">3756         return object-&gt;defineOwnIndexedProperty(globalObject, index.value(), descriptor, throwException);</span>
3757     }
3758 
<span class="line-modified">3759     return object-&gt;defineOwnNonIndexProperty(globalObject, propertyName, descriptor, throwException);</span>
3760 }
3761 
3762 void JSObject::convertToDictionary(VM&amp; vm)
3763 {
3764     DeferredStructureTransitionWatchpointFire deferredWatchpointFire(vm, structure(vm));
3765     setStructure(
3766         vm, Structure::toCacheableDictionaryTransition(vm, structure(vm), &amp;deferredWatchpointFire));
3767 }
3768 
3769 void JSObject::shiftButterflyAfterFlattening(const GCSafeConcurrentJSLocker&amp;, VM&amp; vm, Structure* structure, size_t outOfLineCapacityAfter)
3770 {
3771     // This could interleave visitChildren because some old structure could have been a non
3772     // dictionary structure. We have to be crazy careful. But, we are guaranteed to be holding
3773     // the structure&#39;s lock right now, and that helps a bit.
3774 
3775     Butterfly* oldButterfly = this-&gt;butterfly();
3776     size_t preCapacity;
3777     size_t indexingPayloadSizeInBytes;
3778     bool hasIndexingHeader = this-&gt;hasIndexingHeader(vm);
3779     if (UNLIKELY(hasIndexingHeader)) {
3780         preCapacity = oldButterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
3781         indexingPayloadSizeInBytes = oldButterfly-&gt;indexingHeader()-&gt;indexingPayloadSizeInBytes(structure);
3782     } else {
3783         preCapacity = 0;
3784         indexingPayloadSizeInBytes = 0;
3785     }
3786 
3787     Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, preCapacity, outOfLineCapacityAfter, hasIndexingHeader, indexingPayloadSizeInBytes);
3788 
3789     // No need to copy the precapacity.
3790     void* currentBase = oldButterfly-&gt;base(0, outOfLineCapacityAfter);
3791     void* newBase = newButterfly-&gt;base(0, outOfLineCapacityAfter);
3792 
<span class="line-modified">3793     gcSafeMemcpy(static_cast&lt;JSValue*&gt;(newBase), static_cast&lt;JSValue*&gt;(currentBase), Butterfly::totalSize(0, outOfLineCapacityAfter, hasIndexingHeader, indexingPayloadSizeInBytes));</span>
3794 
3795     setButterfly(vm, newButterfly);
3796 }
3797 
<span class="line-modified">3798 uint32_t JSObject::getEnumerableLength(JSGlobalObject* globalObject, JSObject* object)</span>
3799 {
<span class="line-modified">3800     VM&amp; vm = globalObject-&gt;vm();</span>
3801     Structure* structure = object-&gt;structure(vm);
3802     if (structure-&gt;holesMustForwardToPrototype(vm, object))
3803         return 0;
3804     switch (object-&gt;indexingType()) {
3805     case ALL_BLANK_INDEXING_TYPES:
3806     case ALL_UNDECIDED_INDEXING_TYPES:
3807         return 0;
3808 
3809     case ALL_INT32_INDEXING_TYPES:
3810     case ALL_CONTIGUOUS_INDEXING_TYPES: {
3811         Butterfly* butterfly = object-&gt;butterfly();
3812         unsigned usedLength = butterfly-&gt;publicLength();
3813         for (unsigned i = 0; i &lt; usedLength; ++i) {
3814             if (!butterfly-&gt;contiguous().at(object, i))
3815                 return 0;
3816         }
3817         return usedLength;
3818     }
3819 
3820     case ALL_DOUBLE_INDEXING_TYPES: {
</pre>
<hr />
<pre>
3830 
3831     case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
3832         ArrayStorage* storage = object-&gt;m_butterfly-&gt;arrayStorage();
3833         if (storage-&gt;m_sparseMap.get())
3834             return 0;
3835 
3836         unsigned usedVectorLength = std::min(storage-&gt;length(), storage-&gt;vectorLength());
3837         for (unsigned i = 0; i &lt; usedVectorLength; ++i) {
3838             if (!storage-&gt;m_vector[i])
3839                 return 0;
3840         }
3841         return usedVectorLength;
3842     }
3843 
3844     default:
3845         RELEASE_ASSERT_NOT_REACHED();
3846         return 0;
3847     }
3848 }
3849 
<span class="line-modified">3850 void JSObject::getStructurePropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
3851 {
<span class="line-modified">3852     VM&amp; vm = globalObject-&gt;vm();</span>
3853     object-&gt;structure(vm)-&gt;getPropertyNamesFromStructure(vm, propertyNames, mode);
3854 }
3855 
<span class="line-modified">3856 void JSObject::getGenericPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
3857 {
<span class="line-modified">3858     VM&amp; vm = globalObject-&gt;vm();</span>
3859     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">3860     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, globalObject, propertyNames, EnumerationMode(mode, JSObjectPropertiesMode::Exclude));</span>
3861     RETURN_IF_EXCEPTION(scope, void());
3862 
<span class="line-modified">3863     JSValue nextProto = object-&gt;getPrototype(vm, globalObject);</span>
3864     RETURN_IF_EXCEPTION(scope, void());
3865     if (nextProto.isNull())
3866         return;
3867 
3868     JSObject* prototype = asObject(nextProto);
3869     while (true) {
3870         if (prototype-&gt;structure(vm)-&gt;typeInfo().overridesGetPropertyNames()) {
3871             scope.release();
<span class="line-modified">3872             prototype-&gt;methodTable(vm)-&gt;getPropertyNames(prototype, globalObject, propertyNames, mode);</span>
3873             return;
3874         }
<span class="line-modified">3875         prototype-&gt;methodTable(vm)-&gt;getOwnPropertyNames(prototype, globalObject, propertyNames, mode);</span>
3876         RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">3877         nextProto = prototype-&gt;getPrototype(vm, globalObject);</span>
3878         RETURN_IF_EXCEPTION(scope, void());
3879         if (nextProto.isNull())
3880             break;
3881         prototype = asObject(nextProto);
3882     }
3883 }
3884 
3885 // Implements GetMethod(O, P) in section 7.3.9 of the spec.
3886 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-getmethod
<span class="line-modified">3887 JSValue JSObject::getMethod(JSGlobalObject* globalObject, CallData&amp; callData, CallType&amp; callType, const Identifier&amp; ident, const String&amp; errorMessage)</span>
3888 {
<span class="line-modified">3889     VM&amp; vm = globalObject-&gt;vm();</span>
3890     auto scope = DECLARE_THROW_SCOPE(vm);
3891 
<span class="line-modified">3892     JSValue method = get(globalObject, ident);</span>
3893     RETURN_IF_EXCEPTION(scope, JSValue());
3894 
3895     if (!method.isCell()) {
3896         if (method.isUndefinedOrNull())
3897             return jsUndefined();
3898 
<span class="line-modified">3899         throwVMTypeError(globalObject, scope, errorMessage);</span>
3900         return jsUndefined();
3901     }
3902 
3903     callType = method.asCell()-&gt;methodTable(vm)-&gt;getCallData(method.asCell(), callData);
3904     if (callType == CallType::None) {
<span class="line-modified">3905         throwVMTypeError(globalObject, scope, errorMessage);</span>
3906         return jsUndefined();
3907     }
3908 
3909     return method;
3910 }
3911 
3912 bool JSObject::anyObjectInChainMayInterceptIndexedAccesses(VM&amp; vm) const
3913 {
3914     for (const JSObject* current = this; ;) {
3915         if (current-&gt;structure(vm)-&gt;mayInterceptIndexedAccesses())
3916             return true;
3917 
3918         JSValue prototype = current-&gt;getPrototypeDirect(vm);
3919         if (prototype.isNull())
3920             return false;
3921 
3922         current = asObject(prototype);
3923     }
3924 }
3925 
</pre>
</td>
</tr>
</table>
<center><a href="JSONObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/generateYarrCanonicalizeUnicode</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 #! /usr/bin/env python
  2 
  3 # Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  4 #
  5 # Redistribution and use in source and binary forms, with or without
  6 # modification, are permitted provided that the following conditions
  7 # are met:
  8 #
  9 # 1.  Redistributions of source code must retain the above copyright
 10 #     notice, this list of conditions and the following disclaimer. 
 11 # 2.  Redistributions in binary form must reproduce the above copyright
 12 #     notice, this list of conditions and the following disclaimer in the
 13 #     documentation and/or other materials provided with the distribution. 
 14 #
 15 # THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 16 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17 # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18 # DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 19 # DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20 # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21 # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22 # ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25 
 26 # This tool processes the Unicode Character Database file CaseFolding.txt to create
 27 # canonicalization table as decribed in ECMAScript 6 standard in section
 28 # &quot;21.2.2.8.2 Runtime Semantics: Canonicalize()&quot;, step 2.
 29 
 30 import optparse
 31 import os
 32 import re
 33 import sys
 34 
 35 header = &quot;&quot;&quot;/*
 36 * Copyright (C) 2016 Apple Inc. All rights reserved.
 37 *
 38 * Redistribution and use in source and binary forms, with or without
 39 * modification, are permitted provided that the following conditions
 40 * are met:
 41 *
 42 * 1.  Redistributions of source code must retain the above copyright
 43 *     notice, this list of conditions and the following disclaimer. 
 44 * 2.  Redistributions in binary form must reproduce the above copyright
 45 *     notice, this list of conditions and the following disclaimer in the
 46 *     documentation and/or other materials provided with the distribution. 
 47 *
 48 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 49 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 50 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 51 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 52 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 53 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 54 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 55 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 56 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 57 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 58 */
 59 
 60 // DO NO EDIT! - This file was generated by generateYarrCanonicalizeUnicode
 61 
 62 #include &quot;config.h&quot;
 63 #include &quot;YarrCanonicalize.h&quot;
 64 
 65 namespace JSC { namespace Yarr {
 66 
 67 &quot;&quot;&quot;
 68 
 69 footer = &quot;&quot;&quot;} } // JSC::Yarr
 70 &quot;&quot;&quot;
 71 
 72 MaxUnicode = 0x10ffff
 73 commonAndSimpleLinesRE = re.compile(r&quot;(?P&lt;code&gt;[0-9A-F]+)\s*;\s*[CS]\s*;\s*(?P&lt;mapping&gt;[0-9A-F]+)&quot;, re.IGNORECASE)
 74 
 75 def openOrExit(path, mode):
 76     try:
 77         dirname = os.path.dirname(path)
 78         if not os.path.isdir(dirname):
 79             os.makedirs(dirname)
 80         if sys.version_info.major &gt;= 3:
 81             return open(path, mode, encoding=&quot;UTF-8&quot;)
 82         else:
 83             return open(path, mode)
 84     except IOError as e:
 85         print(&quot;I/O error opening {0}, ({1}): {2}&quot;.format(path, e.errno, e.strerror))
 86         exit(1)
 87 
 88 class Canonicalize:
 89     def __init__(self):
 90         self.canonicalGroups = {};
 91 
 92     def addMapping(self, code, mapping):
 93         if mapping not in self.canonicalGroups:
 94             self.canonicalGroups[mapping] = []
 95         self.canonicalGroups[mapping].append(code)
 96         
 97     def readCaseFolding(self, file):
 98         codesSeen = set()
 99         for line in file:
100             line = line.split(&#39;#&#39;, 1)[0]
101             line = line.rstrip()
102             if (not len(line)):
103                 continue
104 
105             fields = commonAndSimpleLinesRE.match(line)
106             if (not fields):
107                 continue
108 
109             code = int(fields.group(&#39;code&#39;), 16)
110             mapping = int(fields.group(&#39;mapping&#39;), 16)
111 
112             codesSeen.add(code)
113             self.addMapping(code, mapping)
114 
115         for i in range(MaxUnicode + 1):
116             if i in codesSeen:
117                 continue;
118 
119             self.addMapping(i, i)
120 
121     def createTables(self, file):
122         typeInfo = [&quot;&quot;] * (MaxUnicode + 1)
123         characterSets = []
124 
125         for mapping in sorted(self.canonicalGroups.keys()):
126             characters = self.canonicalGroups[mapping]
127             if len(characters) == 1:
128                 typeInfo[characters[0]] = &quot;CanonicalizeUnique:0&quot;
129             else:
130                 characters.sort()
131                 if len(characters) &gt; 2:
132                     for ch in characters:
133                         typeInfo[ch] = &quot;CanonicalizeSet:%d&quot; % len(characterSets)
134                     characterSets.append(characters)
135                 else:
136                     low = characters[0]
137                     high = characters[1]
138                     delta = high - low
139                     if delta == 1:
140                         type = &quot;CanonicalizeAlternatingUnaligned:0&quot; if low &amp; 1 else &quot;CanonicalizeAlternatingAligned:0&quot;
141                         typeInfo[low] = type
142                         typeInfo[high] = type
143                     else:
144                         typeInfo[low] = &quot;CanonicalizeRangeLo:%d&quot; % delta
145                         typeInfo[high] = &quot;CanonicalizeRangeHi:%d&quot; % delta
146 
147         rangeInfo = []
148         end = 0
149         while end &lt;= MaxUnicode:
150             begin = end
151             type = typeInfo[end]
152             while end &lt; MaxUnicode and typeInfo[end + 1] == type:
153                 end = end + 1
154             rangeInfo.append({&quot;begin&quot;: begin, &quot;end&quot;: end, &quot;type&quot;: type})
155             end = end + 1
156         
157         for i in range(len(characterSets)):
158             characters = &quot;&quot;
159             cur_set = characterSets[i]
160             for ch in cur_set:
161                 characters = characters + &quot;0x{character:04x}, &quot;.format(character=ch)
162             file.write(&quot;const UChar32 unicodeCharacterSet{index:d}[] = {{ {characters}0 }};\n&quot;.format(index=i, characters=characters))
163 
164         file.write(&quot;\n&quot;)
165         file.write(&quot;static constexpr size_t UNICODE_CANONICALIZATION_SETS = {setCount:d};\n&quot;.format(setCount=len(characterSets)))
166         file.write(&quot;const UChar32* const unicodeCharacterSetInfo[UNICODE_CANONICALIZATION_SETS] = {\n&quot;)
167 
168         for i in range(len(characterSets)):
169             file.write(&quot;    unicodeCharacterSet{setNumber:d},\n&quot;.format(setNumber=i))
170 
171         file.write(&quot;};\n&quot;)
172         file.write(&quot;\n&quot;)
173         file.write(&quot;const size_t UNICODE_CANONICALIZATION_RANGES = {rangeCount:d};\n&quot;.format(rangeCount=len(rangeInfo)))
174         file.write(&quot;const CanonicalizationRange unicodeRangeInfo[UNICODE_CANONICALIZATION_RANGES] = {\n&quot;)
175 
176         for info in rangeInfo:
177             typeAndValue = info[&quot;type&quot;].split(&quot;:&quot;)
178             file.write(&quot;    {{ 0x{begin:04x}, 0x{end:04x}, 0x{value:04x}, {type} }},\n&quot;.format(begin=info[&quot;begin&quot;], end=info[&quot;end&quot;], value=int(typeAndValue[1]), type=typeAndValue[0]))
179 
180         file.write(&quot;};\n&quot;)
181         file.write(&quot;\n&quot;)
182 
183         
184 if __name__ == &quot;__main__&quot;:
185     parser = optparse.OptionParser(usage = &quot;usage: %prog  &lt;CaseFolding.txt&gt; &lt;YarrCanonicalizeUnicode.h&gt;&quot;)
186     (options, args) = parser.parse_args()
187 
188     if len(args) != 2:
189         parser.error(&quot;&lt;CaseFolding.txt&gt; &lt;YarrCanonicalizeUnicode.h&gt;&quot;)
190 
191     caseFoldingTxtPath = args[0]
192     canonicalizeHPath = args[1]
193     caseFoldingTxtFile = openOrExit(caseFoldingTxtPath, &quot;r&quot;)
194     canonicalizeHFile = openOrExit(canonicalizeHPath, &quot;w&quot;)
195 
196     canonicalize = Canonicalize()
197     canonicalize.readCaseFolding(caseFoldingTxtFile)
198 
199     canonicalizeHFile.write(header);
200     canonicalize.createTables(canonicalizeHFile)
201     canonicalizeHFile.write(footer);
202 
203     caseFoldingTxtFile.close()
204     canonicalizeHFile.close()
205 
206     exit(0)
    </pre>
  </body>
</html>
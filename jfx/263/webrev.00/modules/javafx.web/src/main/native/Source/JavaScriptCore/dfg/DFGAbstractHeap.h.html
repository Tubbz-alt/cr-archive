<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractHeap.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DOMJITHeapRange.h&quot;
 31 #include &quot;OperandsInlines.h&quot;
 32 #include &quot;VirtualRegister.h&quot;
 33 #include &lt;wtf/HashMap.h&gt;
 34 #include &lt;wtf/PrintStream.h&gt;
 35 
 36 namespace JSC { namespace DFG {
 37 
 38 // Implements a four-level type hierarchy:
 39 // - World is the supertype of all of the things.
 40 // - Stack with a TOP payload is a direct subtype of World
 41 // - Stack with a non-TOP payload is a direct subtype of Stack with a TOP payload.
 42 // - Heap is a direct subtype of World.
 43 // - SideState is a direct subtype of World.
 44 // - Any other kind with TOP payload is the direct subtype of Heap.
 45 // - Any other kind with non-TOP payload is the direct subtype of the same kind with a TOP payload.
 46 
 47 #define FOR_EACH_ABSTRACT_HEAP_KIND(macro) \
 48     macro(InvalidAbstractHeap) \
 49     macro(World) \
 50     macro(Stack) \
 51     macro(Heap) \
 52     macro(Butterfly_publicLength) \
 53     macro(Butterfly_vectorLength) \
 54     macro(GetterSetter_getter) \
 55     macro(GetterSetter_setter) \
 56     macro(JSCell_cellState) \
 57     macro(JSCell_indexingType) \
 58     macro(JSCell_structureID) \
 59     macro(JSCell_typeInfoFlags) \
 60     macro(JSObject_butterfly) \
 61     macro(JSPropertyNameEnumerator_cachedPropertyNames) \
 62     macro(RegExpObject_lastIndex) \
 63     macro(NamedProperties) \
 64     macro(IndexedInt32Properties) \
 65     macro(IndexedDoubleProperties) \
 66     macro(IndexedContiguousProperties) \
 67     macro(IndexedArrayStorageProperties) \
 68     macro(DirectArgumentsProperties) \
 69     macro(ScopeProperties) \
 70     macro(TypedArrayProperties) \
 71     macro(HeapObjectCount) /* Used to reflect the fact that some allocations reveal object identity */\
 72     macro(RegExpState) \
 73     macro(MathDotRandomState) \
 74     macro(JSDateFields) \
 75     macro(JSMapFields) \
 76     macro(JSSetFields) \
 77     macro(JSWeakMapFields) \
 78     macro(JSWeakSetFields) \
 79     macro(JSInternalFields) \
 80     macro(InternalState) \
 81     macro(CatchLocals) \
 82     macro(Absolute) \
 83     /* DOMJIT tells the heap range with the pair of integers. */\
 84     macro(DOMState) \
 85     /* Use this for writes only, to indicate that this may fire watchpoints. Usually this is never directly written but instead we test to see if a node clobbers this; it just so happens that you have to write world to clobber it. */\
 86     macro(Watchpoint_fire) \
 87     /* Use these for reads only, just to indicate that if the world got clobbered, then this operation will not work. */\
 88     macro(MiscFields) \
 89     /* Use this for writes only, just to indicate that hoisting the node is invalid. This works because we don&#39;t hoist anything that has any side effects at all. */\
 90     macro(SideState)
 91 
 92 enum AbstractHeapKind {
 93 #define ABSTRACT_HEAP_DECLARATION(name) name,
 94     FOR_EACH_ABSTRACT_HEAP_KIND(ABSTRACT_HEAP_DECLARATION)
 95 #undef ABSTRACT_HEAP_DECLARATION
 96 };
 97 
 98 class AbstractHeap {
 99 public:
100     class Payload {
101     public:
102         Payload()
103             : m_isTop(false)
104             , m_value(0)
105         {
106         }
107 
108         Payload(bool isTop, int64_t value)
109             : m_isTop(isTop)
110             , m_value(value)
111         {
112             ASSERT(!(isTop &amp;&amp; value));
113         }
114 
115         Payload(int64_t value)
116             : m_isTop(false)
117             , m_value(value)
118         {
119         }
120 
121         Payload(const void* pointer)
122             : m_isTop(false)
123             , m_value(bitwise_cast&lt;intptr_t&gt;(pointer))
124         {
125         }
126 
127         Payload(Operand operand)
128             : m_isTop(false)
129             , m_value(operand.asBits())
130         {
131         }
132 
133         Payload(VirtualRegister operand)
134             : Payload(Operand(operand))
135         {
136         }
137 
138         static Payload top() { return Payload(true, 0); }
139 
140         bool isTop() const { return m_isTop; }
141         int64_t value() const
142         {
143             ASSERT(!isTop());
144             return valueImpl();
145         }
146         int64_t valueImpl() const
147         {
148             return m_value;
149         }
150 
151         int32_t value32() const
152         {
153             return static_cast&lt;int32_t&gt;(value());
154         }
155 
156         bool operator==(const Payload&amp; other) const
157         {
158             return m_isTop == other.m_isTop
159                 &amp;&amp; m_value == other.m_value;
160         }
161 
162         bool operator!=(const Payload&amp; other) const
163         {
164             return !(*this == other);
165         }
166 
167         bool operator&lt;(const Payload&amp; other) const
168         {
169             if (isTop())
170                 return !other.isTop();
171             if (other.isTop())
172                 return false;
173             return value() &lt; other.value();
174         }
175 
176         bool isDisjoint(const Payload&amp; other) const
177         {
178             if (isTop())
179                 return false;
180             if (other.isTop())
181                 return false;
182             return m_value != other.m_value;
183         }
184 
185         bool overlaps(const Payload&amp; other) const
186         {
187             return !isDisjoint(other);
188         }
189 
190         void dump(PrintStream&amp;) const;
191         void dumpAsOperand(PrintStream&amp;) const;
192 
193     private:
194         bool m_isTop;
195         int64_t m_value;
196     };
197 
198     AbstractHeap()
199     {
200         m_value = encode(InvalidAbstractHeap, Payload());
201     }
202 
203     AbstractHeap(AbstractHeapKind kind)
204     {
205         ASSERT(kind != InvalidAbstractHeap);
206         m_value = encode(kind, Payload::top());
207     }
208 
209     AbstractHeap(AbstractHeapKind kind, Payload payload)
210     {
211         ASSERT(kind != InvalidAbstractHeap &amp;&amp; kind != World &amp;&amp; kind != Heap &amp;&amp; kind != SideState);
212         m_value = encode(kind, payload);
213         ASSERT(this-&gt;kind() == kind &amp;&amp; this-&gt;payload() == payload);
214     }
215 
216     AbstractHeap(WTF::HashTableDeletedValueType)
217     {
218         m_value = encode(InvalidAbstractHeap, Payload::top());
219     }
220 
221     bool operator!() const { return kind() == InvalidAbstractHeap &amp;&amp; !payloadImpl().isTop(); }
222 
223     AbstractHeapKind kind() const { return static_cast&lt;AbstractHeapKind&gt;(m_value &amp; ((1 &lt;&lt; topShift) - 1)); }
224     Payload payload() const
225     {
226         ASSERT(kind() != World &amp;&amp; kind() != InvalidAbstractHeap);
227         return payloadImpl();
228     }
229     Operand operand() const
230     {
231         ASSERT(kind() == Stack &amp;&amp; !payload().isTop());
232         return Operand::fromBits(payload().value());
233     }
234 
235     AbstractHeap supertype() const
236     {
237         ASSERT(kind() != InvalidAbstractHeap);
238         switch (kind()) {
239         case World:
240             return AbstractHeap();
241         case Heap:
242         case SideState:
243             return World;
244         default:
245             if (payload().isTop()) {
246                 if (kind() == Stack)
247                     return World;
248                 return Heap;
249             }
250             return AbstractHeap(kind());
251         }
252     }
253 
254     bool isStrictSubtypeOf(const AbstractHeap&amp; other) const
255     {
256         AbstractHeap current = *this;
257         if (current.kind() == DOMState &amp;&amp; other.kind() == DOMState) {
258             Payload currentPayload = current.payload();
259             Payload otherPayload = other.payload();
260             if (currentPayload.isTop())
261                 return false;
262             if (otherPayload.isTop())
263                 return true;
264             return DOMJIT::HeapRange::fromRaw(currentPayload.value32()).isStrictSubtypeOf(DOMJIT::HeapRange::fromRaw(otherPayload.value32()));
265         }
266         while (current.kind() != World) {
267             current = current.supertype();
268             if (current == other)
269                 return true;
270         }
271         return false;
272     }
273 
274     bool isSubtypeOf(const AbstractHeap&amp; other) const
275     {
276         return *this == other || isStrictSubtypeOf(other);
277     }
278 
279     bool overlaps(const AbstractHeap&amp; other) const
280     {
281         return *this == other || isStrictSubtypeOf(other) || other.isStrictSubtypeOf(*this);
282     }
283 
284     bool isDisjoint(const AbstractHeap&amp; other) const
285     {
286         return !overlaps(other);
287     }
288 
289     unsigned hash() const
290     {
291         return WTF::IntHash&lt;int64_t&gt;::hash(m_value);
292     }
293 
294     bool operator==(const AbstractHeap&amp; other) const
295     {
296         return m_value == other.m_value;
297     }
298 
299     bool operator!=(const AbstractHeap&amp; other) const
300     {
301         return !(*this == other);
302     }
303 
304     bool operator&lt;(const AbstractHeap&amp; other) const
305     {
306         if (kind() != other.kind())
307             return kind() &lt; other.kind();
308         return payload() &lt; other.payload();
309     }
310 
311     bool isHashTableDeletedValue() const
312     {
313         return kind() == InvalidAbstractHeap &amp;&amp; payloadImpl().isTop();
314     }
315 
316     void dump(PrintStream&amp; out) const;
317 
318 private:
319     static constexpr unsigned valueShift = 15;
320     static constexpr unsigned topShift = 14;
321     static_assert((64 - valueShift) &gt;= Operand::maxBits, &quot;Operand should fit in Payload&#39;s encoded format&quot;);
322 
323     Payload payloadImpl() const
324     {
325         return Payload((m_value &gt;&gt; topShift) &amp; 1, m_value &gt;&gt; valueShift);
326     }
327 
328     static int64_t encode(AbstractHeapKind kind, Payload payload)
329     {
330         int64_t kindAsInt = static_cast&lt;int64_t&gt;(kind);
331         ASSERT(kindAsInt &lt; (1 &lt;&lt; topShift));
332         return kindAsInt | (static_cast&lt;uint64_t&gt;(payload.isTop()) &lt;&lt; topShift) | (bitwise_cast&lt;uint64_t&gt;(payload.valueImpl()) &lt;&lt; valueShift);
333     }
334 
335     // The layout of the value is:
336     // Low 14 bits: the Kind
337     // 15th bit: whether or not the payload is TOP.
338     // The upper bits: the payload.value().
339     int64_t m_value;
340 };
341 
342 struct AbstractHeapHash {
343     static unsigned hash(const AbstractHeap&amp; key) { return key.hash(); }
344     static bool equal(const AbstractHeap&amp; a, const AbstractHeap&amp; b) { return a == b; }
345     static constexpr bool safeToCompareToEmptyOrDeleted = true;
346 };
347 
348 } } // namespace JSC::DFG
349 
350 namespace WTF {
351 
352 void printInternal(PrintStream&amp;, JSC::DFG::AbstractHeapKind);
353 
354 template&lt;typename T&gt; struct DefaultHash;
355 template&lt;&gt; struct DefaultHash&lt;JSC::DFG::AbstractHeap&gt; {
356     typedef JSC::DFG::AbstractHeapHash Hash;
357 };
358 
359 template&lt;typename T&gt; struct HashTraits;
360 template&lt;&gt; struct HashTraits&lt;JSC::DFG::AbstractHeap&gt; : SimpleClassHashTraits&lt;JSC::DFG::AbstractHeap&gt; { };
361 
362 } // namespace WTF
363 
364 #endif // ENABLE(DFG_JIT)
    </pre>
  </body>
</html>
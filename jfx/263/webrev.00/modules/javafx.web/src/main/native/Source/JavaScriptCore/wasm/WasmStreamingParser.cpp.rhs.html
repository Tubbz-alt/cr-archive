<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmStreamingParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018 Yusuke Suzuki &lt;yusukesuzuki@slowstart.org&gt;.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmStreamingParser.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
<a name="1" id="anc1"></a><span class="line-modified"> 31 #include &quot;WasmOps.h&quot;</span>
 32 #include &quot;WasmSectionParser.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 33 #include &quot;WasmSignatureInlines.h&quot;</span>
 34 #include &lt;wtf/Optional.h&gt;
 35 #include &lt;wtf/UnalignedAccess.h&gt;
 36 
 37 namespace JSC { namespace Wasm {
 38 
 39 namespace WasmStreamingParserInternal {
 40 static constexpr bool verbose = false;
 41 }
 42 
 43 #define WASM_STREAMING_PARSER_FAIL_IF_HELPER_FAILS(helper) \
 44     do { \
 45         auto helperResult = helper; \
 46         if (UNLIKELY(!helperResult)) { \
 47             m_errorMessage = helperResult.error(); \
 48             return State::FatalError; \
 49         } \
 50     } while (0)
 51 
 52 ALWAYS_INLINE Optional&lt;uint8_t&gt; parseUInt7(const uint8_t* data, size_t&amp; offset, size_t size)
 53 {
 54     if (offset &gt;= size)
 55         return false;
 56     uint8_t result = data[offset++];
 57     if (result &lt; 0x80)
 58         return result;
 59     return WTF::nullopt;
 60 }
 61 
 62 template &lt;typename ...Args&gt;
 63 NEVER_INLINE auto WARN_UNUSED_RETURN StreamingParser::fail(Args... args) -&gt; State
 64 {
 65     using namespace FailureHelper; // See ADL comment in namespace above.
 66     m_errorMessage = makeString(&quot;WebAssembly.Module doesn&#39;t parse at byte &quot;_s, String::number(m_offset), &quot;: &quot;_s, makeString(args)...);
 67     dataLogLnIf(WasmStreamingParserInternal::verbose, m_errorMessage);
 68     return State::FatalError;
 69 }
 70 
<a name="3" id="anc3"></a><span class="line-modified"> 71 StreamingParser::StreamingParser(ModuleInformation&amp; info, StreamingParserClient&amp; client)</span>
 72     : m_info(info)
<a name="4" id="anc4"></a><span class="line-added"> 73     , m_client(client)</span>
 74 {
 75     dataLogLnIf(WasmStreamingParserInternal::verbose, &quot;starting validation&quot;);
 76 }
 77 
 78 auto StreamingParser::parseModuleHeader(Vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; State
 79 {
 80     ASSERT(data.size() == moduleHeaderSize);
 81     dataLogLnIf(WasmStreamingParserInternal::verbose, &quot;header validation&quot;);
 82     WASM_PARSER_FAIL_IF(data[0] != &#39;\0&#39; || data[1] != &#39;a&#39; || data[2] != &#39;s&#39; || data[3] != &#39;m&#39;, &quot;modules doesn&#39;t start with &#39;\\0asm&#39;&quot;);
 83     uint32_t versionNumber = WTF::unalignedLoad&lt;uint32_t&gt;(data.data() + 4);
 84     WASM_PARSER_FAIL_IF(versionNumber != expectedVersionNumber, &quot;unexpected version number &quot;, versionNumber, &quot; expected &quot;, expectedVersionNumber);
 85     return State::SectionID;
 86 }
 87 
 88 auto StreamingParser::parseSectionID(Vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; State
 89 {
 90     ASSERT(data.size() == sectionIDSize);
 91     size_t offset = 0;
 92     auto result = parseUInt7(data.data(), offset, data.size());
 93     WASM_PARSER_FAIL_IF(!result, &quot;can&#39;t get section byte&quot;);
 94 
 95     Section section = Section::Custom;
 96     WASM_PARSER_FAIL_IF(!decodeSection(*result, section), &quot;invalid section&quot;);
 97     ASSERT(section != Section::Begin);
 98     WASM_PARSER_FAIL_IF(!validateOrder(m_previousKnownSection, section), &quot;invalid section order, &quot;, m_previousKnownSection, &quot; followed by &quot;, section);
 99     m_section = section;
100     if (isKnownSection(section))
101         m_previousKnownSection = section;
102     return State::SectionSize;
103 }
104 
105 auto StreamingParser::parseSectionSize(uint32_t sectionLength) -&gt; State
106 {
107     m_sectionLength = sectionLength;
108     if (m_section == Section::Code)
109         return State::CodeSectionSize;
110     return State::SectionPayload;
111 }
112 
113 auto StreamingParser::parseCodeSectionSize(uint32_t functionCount) -&gt; State
114 {
115     m_info-&gt;codeSectionSize = m_sectionLength;
116     m_functionCount = functionCount;
117     m_functionIndex = 0;
118     m_codeOffset = m_offset;
119 
120     WASM_PARSER_FAIL_IF(functionCount == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;Code section&#39;s count is too big &quot;, functionCount);
121     WASM_PARSER_FAIL_IF(functionCount != m_info-&gt;functions.size(), &quot;Code section count &quot;, functionCount, &quot; exceeds the declared number of functions &quot;, m_info-&gt;functions.size());
122 
123     if (m_functionIndex == m_functionCount) {
124         WASM_PARSER_FAIL_IF((m_codeOffset + m_sectionLength) != m_nextOffset, &quot;parsing ended before the end of &quot;, m_section, &quot; section&quot;);
<a name="5" id="anc5"></a><span class="line-added">125         if (!m_client.didReceiveSectionData(m_section))</span>
<span class="line-added">126             return State::FatalError;</span>
127         return State::SectionID;
128     }
129     return State::FunctionSize;
130 }
131 
132 auto StreamingParser::parseFunctionSize(uint32_t functionSize) -&gt; State
133 {
134     m_functionSize = functionSize;
135     WASM_PARSER_FAIL_IF(functionSize &gt; maxFunctionSize, &quot;Code function&#39;s size &quot;, functionSize, &quot; is too big&quot;);
136     return State::FunctionPayload;
137 }
138 
139 auto StreamingParser::parseFunctionPayload(Vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; State
140 {
141     auto&amp; function = m_info-&gt;functions[m_functionIndex];
142     function.start = m_offset;
143     function.end = m_offset + m_functionSize;
144     function.data = WTFMove(data);
145     dataLogLnIf(WasmStreamingParserInternal::verbose, &quot;Processing function starting at: &quot;, function.start, &quot; and ending at: &quot;, function.end);
<a name="6" id="anc6"></a><span class="line-added">146     if (!m_client.didReceiveFunctionData(m_functionIndex, function))</span>
<span class="line-added">147         return State::FatalError;</span>
148     ++m_functionIndex;
<a name="7" id="anc7"></a><span class="line-added">149 </span>
150     if (m_functionIndex == m_functionCount) {
151         WASM_PARSER_FAIL_IF((m_codeOffset + m_sectionLength) != (m_offset + m_functionSize), &quot;parsing ended before the end of &quot;, m_section, &quot; section&quot;);
<a name="8" id="anc8"></a><span class="line-added">152         if (!m_client.didReceiveSectionData(m_section))</span>
<span class="line-added">153             return State::FatalError;</span>
154         return State::SectionID;
155     }
156     return State::FunctionSize;
157 }
158 
159 auto StreamingParser::parseSectionPayload(Vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; State
160 {
161     SectionParser parser(data.data(), data.size(), m_offset, m_info.get());
162     switch (m_section) {
163 #define WASM_SECTION_PARSE(NAME, ID, DESCRIPTION) \
164     case Section::NAME: { \
165         WASM_STREAMING_PARSER_FAIL_IF_HELPER_FAILS(parser.parse ## NAME()); \
166         break; \
167     }
168     FOR_EACH_KNOWN_WASM_SECTION(WASM_SECTION_PARSE)
169 #undef WASM_SECTION_PARSE
170 
171     case Section::Custom: {
172         WASM_STREAMING_PARSER_FAIL_IF_HELPER_FAILS(parser.parseCustom());
173         break;
174     }
175 
176     case Section::Begin: {
177         RELEASE_ASSERT_NOT_REACHED();
178         break;
179     }
180     }
181 
182     WASM_PARSER_FAIL_IF(parser.length() != parser.offset(), &quot;parsing ended before the end of &quot;, m_section, &quot; section&quot;);
183 
<a name="9" id="anc9"></a><span class="line-added">184     if (!m_client.didReceiveSectionData(m_section))</span>
<span class="line-added">185         return State::FatalError;</span>
186     return State::SectionID;
187 }
188 
189 auto StreamingParser::consume(const uint8_t* bytes, size_t bytesSize, size_t&amp; offsetInBytes, size_t requiredSize) -&gt; Optional&lt;Vector&lt;uint8_t&gt;&gt;
190 {
191     if (m_remaining.size() == requiredSize) {
192         Vector&lt;uint8_t&gt; result = WTFMove(m_remaining);
193         m_nextOffset += requiredSize;
194         return result;
195     }
196 
197     if (m_remaining.size() &gt; requiredSize) {
198         Vector&lt;uint8_t&gt; result(requiredSize);
199         memcpy(result.data(), m_remaining.data(), requiredSize);
200         m_remaining.remove(0, requiredSize);
201         m_nextOffset += requiredSize;
202         return result;
203     }
204 
205     ASSERT(m_remaining.size() &lt; requiredSize);
206     size_t bytesRemainingSize = bytesSize - offsetInBytes;
207     size_t totalDataSize = m_remaining.size() + bytesRemainingSize;
208     if (totalDataSize &lt; requiredSize) {
209         m_remaining.append(bytes + offsetInBytes, bytesRemainingSize);
210         offsetInBytes = bytesSize;
211         return WTF::nullopt;
212     }
213 
214     size_t usedSize = requiredSize - m_remaining.size();
215     m_remaining.append(bytes + offsetInBytes, usedSize);
216     offsetInBytes += usedSize;
217     Vector&lt;uint8_t&gt; result = WTFMove(m_remaining);
218     m_nextOffset += requiredSize;
219     return result;
220 }
221 
222 auto StreamingParser::consumeVarUInt32(const uint8_t* bytes, size_t bytesSize, size_t&amp; offsetInBytes, IsEndOfStream isEndOfStream) -&gt; Expected&lt;uint32_t, State&gt;
223 {
224     constexpr size_t maxSize = WTF::LEBDecoder::maxByteLength&lt;uint32_t&gt;();
225     size_t bytesRemainingSize = bytesSize - offsetInBytes;
226     size_t totalDataSize = m_remaining.size() + bytesRemainingSize;
227     if (m_remaining.size() &gt;= maxSize) {
228         // Do nothing.
229     } else if (totalDataSize &gt;= maxSize) {
230         size_t usedSize = maxSize - m_remaining.size();
231         m_remaining.append(bytes + offsetInBytes, usedSize);
232         offsetInBytes += usedSize;
233     } else {
234         m_remaining.append(bytes + offsetInBytes, bytesRemainingSize);
235         offsetInBytes += bytesRemainingSize;
236         // If the given bytes are the end of the stream, we try to parse VarUInt32
237         // with the current remaining data since VarUInt32 may not require `maxSize`.
238         if (isEndOfStream == IsEndOfStream::No)
239             return makeUnexpected(m_state);
240     }
241 
242     size_t offset = 0;
243     uint32_t result = 0;
244     if (!WTF::LEBDecoder::decodeUInt32(m_remaining.data(), m_remaining.size(), offset, result))
245         return makeUnexpected(State::FatalError);
246     size_t consumedSize = offset;
247     m_remaining.remove(0, consumedSize);
248     m_nextOffset += consumedSize;
249     return result;
250 }
251 
252 auto StreamingParser::addBytes(const uint8_t* bytes, size_t bytesSize, IsEndOfStream isEndOfStream) -&gt; State
253 {
254     if (m_state == State::FatalError)
255         return m_state;
256 
257     m_totalSize += bytesSize;
258     if (UNLIKELY(m_totalSize.hasOverflowed() || m_totalSize.unsafeGet() &gt; maxModuleSize)) {
259         m_state = fail(&quot;module size is too large, maximum &quot;, maxModuleSize);
260         return m_state;
261     }
262 
263     if (UNLIKELY(Options::useEagerWebAssemblyModuleHashing()))
264         m_hasher.addBytes(bytes, bytesSize);
265 
266     size_t offsetInBytes = 0;
267     while (true) {
268         ASSERT(offsetInBytes &lt;= bytesSize);
269         switch (m_state) {
270         case State::ModuleHeader: {
271             auto result = consume(bytes, bytesSize, offsetInBytes, moduleHeaderSize);
272             if (!result)
273                 return m_state;
274             m_state = parseModuleHeader(WTFMove(*result));
275             break;
276         }
277 
278         case State::SectionID: {
279             auto result = consume(bytes, bytesSize, offsetInBytes, sectionIDSize);
280             if (!result)
281                 return m_state;
282             m_state = parseSectionID(WTFMove(*result));
283             break;
284         }
285 
286         case State::SectionSize: {
287             auto result = consumeVarUInt32(bytes, bytesSize, offsetInBytes, isEndOfStream);
288             if (!result) {
289                 if (result.error() == State::FatalError)
290                     m_state = failOnState(m_state);
291                 else
292                     m_state = result.error();
293                 return m_state;
294             }
295             m_state = parseSectionSize(*result);
296             break;
297         }
298 
299         case State::SectionPayload: {
300             auto result = consume(bytes, bytesSize, offsetInBytes, m_sectionLength);
301             if (!result)
302                 return m_state;
303             m_state = parseSectionPayload(WTFMove(*result));
304             break;
305         }
306 
307         case State::CodeSectionSize: {
308             auto result = consumeVarUInt32(bytes, bytesSize, offsetInBytes, isEndOfStream);
309             if (!result) {
310                 if (result.error() == State::FatalError)
311                     m_state = failOnState(m_state);
312                 else
313                     m_state = result.error();
314                 return m_state;
315             }
316             m_state = parseCodeSectionSize(*result);
317             break;
318         }
319 
320         case State::FunctionSize: {
321             auto result = consumeVarUInt32(bytes, bytesSize, offsetInBytes, isEndOfStream);
322             if (!result) {
323                 if (result.error() == State::FatalError)
324                     m_state = failOnState(m_state);
325                 else
326                     m_state = result.error();
327                 return m_state;
328             }
329             m_state = parseFunctionSize(*result);
330             break;
331         }
332 
333         case State::FunctionPayload: {
334             auto result = consume(bytes, bytesSize, offsetInBytes, m_functionSize);
335             if (!result)
336                 return m_state;
337             m_state = parseFunctionPayload(WTFMove(*result));
338             break;
339         }
340 
341         case State::Finished:
342         case State::FatalError:
343             return m_state;
344         }
345 
346         m_offset = m_nextOffset;
347     }
348 }
349 
350 auto StreamingParser::failOnState(State) -&gt; State
351 {
352     switch (m_state) {
353     case State::ModuleHeader:
354         return fail(&quot;expected a module of at least &quot;, moduleHeaderSize, &quot; bytes&quot;);
355     case State::SectionID:
356         return fail(&quot;can&#39;t get section byte&quot;);
357     case State::SectionSize:
358         return fail(&quot;can&#39;t get &quot;, m_section, &quot; section&#39;s length&quot;);
359     case State::SectionPayload:
360         return fail(m_section, &quot; section of size &quot;, m_sectionLength, &quot; would overflow Module&#39;s size&quot;);
361     case State::CodeSectionSize:
362         return fail(&quot;can&#39;t get Code section&#39;s count&quot;);
363     case State::FunctionSize:
364         return fail(&quot;can&#39;t get &quot;, m_functionIndex, &quot;th Code function&#39;s size&quot;);
365     case State::FunctionPayload:
366         return fail(&quot;Code function&#39;s size &quot;, m_functionSize, &quot; exceeds the module&#39;s remaining size&quot;);
367     case State::Finished:
368     case State::FatalError:
369         return m_state;
370     }
371     return m_state;
372 }
373 
374 auto StreamingParser::finalize() -&gt; State
375 {
376     addBytes(nullptr, 0, IsEndOfStream::Yes);
377     switch (m_state) {
378     case State::ModuleHeader:
379     case State::SectionSize:
380     case State::SectionPayload:
381     case State::CodeSectionSize:
382     case State::FunctionSize:
383     case State::FunctionPayload:
384         m_state = failOnState(m_state);
385         break;
386 
387     case State::Finished:
388     case State::FatalError:
389         break;
390 
391     case State::SectionID:
<a name="10" id="anc10"></a><span class="line-added">392         if (m_functionIndex != m_info-&gt;functions.size()) {</span>
<span class="line-added">393             m_state = fail(&quot;Number of functions parsed (&quot;, m_functionCount, &quot;) does not match the number of declared functions (&quot;, m_info-&gt;functions.size(), &quot;)&quot;);</span>
<span class="line-added">394             break;</span>
<span class="line-added">395         }</span>
396         if (m_remaining.isEmpty()) {
397             if (UNLIKELY(Options::useEagerWebAssemblyModuleHashing()))
398                 m_info-&gt;nameSection-&gt;setHash(m_hasher.computeHexDigest());
399             m_state = State::Finished;
<a name="11" id="anc11"></a><span class="line-added">400             m_client.didFinishParsing();</span>
401         } else
402             m_state = failOnState(State::SectionID);
403         break;
404     }
405     return m_state;
406 }
407 
408 } } // namespace JSC::Wasm
409 
410 #endif // ENABLE(WEBASSEMBLY)
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
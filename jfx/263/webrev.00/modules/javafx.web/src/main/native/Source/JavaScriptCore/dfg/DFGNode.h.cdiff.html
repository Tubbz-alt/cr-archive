<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGNode.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGNode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGNodeFlowProjection.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGNode.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 53,10 ***</span>
<span class="line-new-header">--- 53,11 ---</span>
  #include &quot;PutByIdVariant.h&quot;
  #include &quot;SpeculatedType.h&quot;
  #include &quot;TypeLocation.h&quot;
  #include &quot;ValueProfile.h&quot;
  #include &lt;type_traits&gt;
<span class="line-added">+ #include &lt;wtf/FastMalloc.h&gt;</span>
  #include &lt;wtf/ListDump.h&gt;
  #include &lt;wtf/LoggingHashSet.h&gt;
  
  namespace JSC {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 248,17 ***</span>
      StackAccessData()
          : format(DeadFlush)
      {
      }
  
<span class="line-modified">!     StackAccessData(VirtualRegister local, FlushFormat format)</span>
<span class="line-modified">!         : local(local)</span>
          , format(format)
      {
      }
  
<span class="line-modified">!     VirtualRegister local;</span>
      VirtualRegister machineLocal;
      FlushFormat format;
  
      FlushedAt flushedAt() { return FlushedAt(format, machineLocal); }
  };
<span class="line-new-header">--- 249,17 ---</span>
      StackAccessData()
          : format(DeadFlush)
      {
      }
  
<span class="line-modified">!     StackAccessData(Operand operand, FlushFormat format)</span>
<span class="line-modified">!         : operand(operand)</span>
          , format(format)
      {
      }
  
<span class="line-modified">!     Operand operand;</span>
      VirtualRegister machineLocal;
      FlushFormat format;
  
      FlushedAt flushedAt() { return FlushedAt(format, machineLocal); }
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 276,12 ***</span>
  };
  
  // === Node ===
  //
  // Node represents a single operation in the data flow graph.
  struct Node {
<span class="line-modified">!     WTF_MAKE_FAST_ALLOCATED;</span>
  public:
      static const char HashSetTemplateInstantiationString[];
  
      enum VarArgTag { VarArg };
  
<span class="line-new-header">--- 277,13 ---</span>
  };
  
  // === Node ===
  //
  // Node represents a single operation in the data flow graph.
<span class="line-added">+ DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(DFGNode);</span>
  struct Node {
<span class="line-modified">!     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(DFGNode);</span>
  public:
      static const char HashSetTemplateInstantiationString[];
  
      enum VarArgTag { VarArg };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 476,10 ***</span>
<span class="line-new-header">--- 478,16 ---</span>
          ASSERT(op() == CheckStructure || op() == CheckStructureOrEmpty);
          m_op = CheckStructureImmediate;
          children.setChild1(Edge(structure, CellUse));
      }
  
<span class="line-added">+     void convertCheckArrayOrEmptyToCheckArray()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ASSERT(op() == CheckArrayOrEmpty);</span>
<span class="line-added">+         setOpAndDefaultFlags(CheckArray);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void replaceWith(Graph&amp;, Node* other);
      void replaceWithWithoutChecks(Node* other);
  
      void convertToIdentity();
      void convertToIdentityOn(Node*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 610,11 ***</span>
          m_op = MultiPutByOffset;
      }
  
      void convertToPhantomNewObject()
      {
<span class="line-modified">!         ASSERT(m_op == NewObject || m_op == MaterializeNewObject);</span>
          m_op = PhantomNewObject;
          m_flags &amp;= ~NodeHasVarArgs;
          m_flags |= NodeMustGenerate;
          m_opInfo = OpInfoWrapper();
          m_opInfo2 = OpInfoWrapper();
<span class="line-new-header">--- 618,11 ---</span>
          m_op = MultiPutByOffset;
      }
  
      void convertToPhantomNewObject()
      {
<span class="line-modified">!         ASSERT(m_op == NewObject);</span>
          m_op = PhantomNewObject;
          m_flags &amp;= ~NodeHasVarArgs;
          m_flags |= NodeMustGenerate;
          m_opInfo = OpInfoWrapper();
          m_opInfo2 = OpInfoWrapper();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 639,10 ***</span>
<span class="line-new-header">--- 647,21 ---</span>
          m_opInfo = OpInfoWrapper();
          m_opInfo2 = OpInfoWrapper();
          children = AdjacencyList();
      }
  
<span class="line-added">+     void convertToPhantomNewArrayIterator()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ASSERT(m_op == NewArrayIterator);</span>
<span class="line-added">+         m_op = PhantomNewArrayIterator;</span>
<span class="line-added">+         m_flags &amp;= ~NodeHasVarArgs;</span>
<span class="line-added">+         m_flags |= NodeMustGenerate;</span>
<span class="line-added">+         m_opInfo = OpInfoWrapper();</span>
<span class="line-added">+         m_opInfo2 = OpInfoWrapper();</span>
<span class="line-added">+         children = AdjacencyList();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void convertToPhantomNewAsyncFunction()
      {
          ASSERT(m_op == NewAsyncFunction);
          m_op = PhantomNewAsyncFunction;
          m_flags |= NodeMustGenerate;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 661,11 ***</span>
          children = AdjacencyList();
      }
  
      void convertToPhantomCreateActivation()
      {
<span class="line-modified">!         ASSERT(m_op == CreateActivation || m_op == MaterializeCreateActivation);</span>
          m_op = PhantomCreateActivation;
          m_flags &amp;= ~NodeHasVarArgs;
          m_flags |= NodeMustGenerate;
          m_opInfo = OpInfoWrapper();
          m_opInfo2 = OpInfoWrapper();
<span class="line-new-header">--- 680,11 ---</span>
          children = AdjacencyList();
      }
  
      void convertToPhantomCreateActivation()
      {
<span class="line-modified">!         ASSERT(m_op == CreateActivation);</span>
          m_op = PhantomCreateActivation;
          m_flags &amp;= ~NodeHasVarArgs;
          m_flags |= NodeMustGenerate;
          m_opInfo = OpInfoWrapper();
          m_opInfo2 = OpInfoWrapper();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,11 ***</span>
          children = AdjacencyList();
      }
  
      void convertToToString()
      {
<span class="line-modified">!         ASSERT(m_op == ToPrimitive || m_op == StringValueOf);</span>
          m_op = ToString;
      }
  
      void convertToArithNegate()
      {
<span class="line-new-header">--- 715,11 ---</span>
          children = AdjacencyList();
      }
  
      void convertToToString()
      {
<span class="line-modified">!         ASSERT(m_op == ToPrimitive || m_op == StringValueOf || m_op == ToPropertyKey);</span>
          m_op = ToString;
      }
  
      void convertToArithNegate()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 755,10 ***</span>
<span class="line-new-header">--- 774,29 ---</span>
          children.reset();
          m_opInfo = structure;
          m_opInfo2 = OpInfoWrapper();
      }
  
<span class="line-added">+     void convertToNewPromise(RegisteredStructure structure)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ASSERT(m_op == CreatePromise);</span>
<span class="line-added">+         bool internal = isInternalPromise();</span>
<span class="line-added">+         setOpAndDefaultFlags(NewPromise);</span>
<span class="line-added">+         children.reset();</span>
<span class="line-added">+         m_opInfo = structure;</span>
<span class="line-added">+         m_opInfo2 = internal;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void convertToNewInternalFieldObject(NodeType newOp, RegisteredStructure structure)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ASSERT(m_op == CreateAsyncGenerator || m_op == CreateGenerator);</span>
<span class="line-added">+         setOpAndDefaultFlags(newOp);</span>
<span class="line-added">+         children.reset();</span>
<span class="line-added">+         m_opInfo = structure;</span>
<span class="line-added">+         m_opInfo2 = OpInfoWrapper();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void convertToNewArrayBuffer(FrozenValue* immutableButterfly);
  
      void convertToDirectCall(FrozenValue*);
  
      void convertToCallDOM(Graph&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 881,10 ***</span>
<span class="line-new-header">--- 919,11 ---</span>
      bool hasArgumentsChild()
      {
          switch (op()) {
          case GetMyArgumentByVal:
          case GetMyArgumentByValOutOfBounds:
<span class="line-added">+         case VarargsLength:</span>
          case LoadVarargs:
          case ForwardVarargs:
          case CallVarargs:
          case CallForwardVarargs:
          case ConstructVarargs:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 902,13 ***</span>
      Edge&amp; argumentsChild()
      {
          switch (op()) {
          case GetMyArgumentByVal:
          case GetMyArgumentByValOutOfBounds:
          case LoadVarargs:
          case ForwardVarargs:
<span class="line-modified">!             return child1();</span>
          case CallVarargs:
          case CallForwardVarargs:
          case ConstructVarargs:
          case ConstructForwardVarargs:
          case TailCallVarargs:
<span class="line-new-header">--- 941,15 ---</span>
      Edge&amp; argumentsChild()
      {
          switch (op()) {
          case GetMyArgumentByVal:
          case GetMyArgumentByValOutOfBounds:
<span class="line-added">+         case VarargsLength:</span>
<span class="line-added">+             return child1();</span>
          case LoadVarargs:
          case ForwardVarargs:
<span class="line-modified">!             return child2();</span>
          case CallVarargs:
          case CallForwardVarargs:
          case ConstructVarargs:
          case ConstructForwardVarargs:
          case TailCallVarargs:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 952,21 ***</span>
      VariableAccessData* variableAccessData()
      {
          return m_opInfo.as&lt;VariableAccessData*&gt;()-&gt;find();
      }
  
<span class="line-modified">!     VirtualRegister local()</span>
      {
<span class="line-modified">!         return variableAccessData()-&gt;local();</span>
      }
  
      VirtualRegister machineLocal()
      {
          return variableAccessData()-&gt;machineLocal();
      }
  
<span class="line-modified">!     bool hasUnlinkedLocal()</span>
      {
          switch (op()) {
          case ExtractOSREntryLocal:
          case MovHint:
          case ZombieHint:
<span class="line-new-header">--- 993,21 ---</span>
      VariableAccessData* variableAccessData()
      {
          return m_opInfo.as&lt;VariableAccessData*&gt;()-&gt;find();
      }
  
<span class="line-modified">!     Operand operand()</span>
      {
<span class="line-modified">!         return variableAccessData()-&gt;operand();</span>
      }
  
      VirtualRegister machineLocal()
      {
          return variableAccessData()-&gt;machineLocal();
      }
  
<span class="line-modified">!     bool hasUnlinkedOperand()</span>
      {
          switch (op()) {
          case ExtractOSREntryLocal:
          case MovHint:
          case ZombieHint:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 975,14 ***</span>
          default:
              return false;
          }
      }
  
<span class="line-modified">!     VirtualRegister unlinkedLocal()</span>
      {
<span class="line-modified">!         ASSERT(hasUnlinkedLocal());</span>
<span class="line-modified">!         return VirtualRegister(m_opInfo.as&lt;int32_t&gt;());</span>
      }
  
      bool hasStackAccessData()
      {
          switch (op()) {
<span class="line-new-header">--- 1016,14 ---</span>
          default:
              return false;
          }
      }
  
<span class="line-modified">!     Operand unlinkedOperand()</span>
      {
<span class="line-modified">!         ASSERT(hasUnlinkedOperand());</span>
<span class="line-modified">!         return Operand::fromBits(m_opInfo.as&lt;uint64_t&gt;());</span>
      }
  
      bool hasStackAccessData()
      {
          switch (op()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1244,10 ***</span>
<span class="line-new-header">--- 1285,21 ---</span>
      {
          ASSERT(hasInlineCapacity());
          return m_opInfo.as&lt;unsigned&gt;();
      }
  
<span class="line-added">+     bool hasIsInternalPromise()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return op() == CreatePromise || op() == NewPromise;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool isInternalPromise()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ASSERT(hasIsInternalPromise());</span>
<span class="line-added">+         return m_opInfo2.as&lt;bool&gt;();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void setIndexingType(IndexingType indexingType)
      {
          ASSERT(hasIndexingType());
          m_opInfo = indexingType;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1261,10 ***</span>
<span class="line-new-header">--- 1313,21 ---</span>
      {
          ASSERT(hasScopeOffset());
          return ScopeOffset(m_opInfo.as&lt;uint32_t&gt;());
      }
  
<span class="line-added">+     unsigned hasInternalFieldIndex()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return op() == GetInternalField || op() == PutInternalField;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     unsigned internalFieldIndex()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ASSERT(hasInternalFieldIndex());</span>
<span class="line-added">+         return m_opInfo.as&lt;uint32_t&gt;();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      bool hasDirectArgumentsOffset()
      {
          return op() == GetFromArguments || op() == PutToArguments;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1307,11 ***</span>
          return m_opInfo.as&lt;CallVarargsData*&gt;();
      }
  
      bool hasLoadVarargsData()
      {
<span class="line-modified">!         return op() == LoadVarargs || op() == ForwardVarargs;</span>
      }
  
      LoadVarargsData* loadVarargsData()
      {
          ASSERT(hasLoadVarargsData());
<span class="line-new-header">--- 1370,11 ---</span>
          return m_opInfo.as&lt;CallVarargsData*&gt;();
      }
  
      bool hasLoadVarargsData()
      {
<span class="line-modified">!         return op() == LoadVarargs || op() == ForwardVarargs || op() == VarargsLength;</span>
      }
  
      LoadVarargsData* loadVarargsData()
      {
          ASSERT(hasLoadVarargsData());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1338,11 ***</span>
      bool hasSpeculatedTypeForQuery()
      {
          return op() == IsCellWithType;
      }
  
<span class="line-modified">!     SpeculatedType speculatedTypeForQuery()</span>
      {
          return speculationFromJSType(queriedType());
      }
  
      bool hasResult()
<span class="line-new-header">--- 1401,11 ---</span>
      bool hasSpeculatedTypeForQuery()
      {
          return op() == IsCellWithType;
      }
  
<span class="line-modified">!     Optional&lt;SpeculatedType&gt; speculatedTypeForQuery()</span>
      {
          return speculationFromJSType(queriedType());
      }
  
      bool hasResult()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1376,10 ***</span>
<span class="line-new-header">--- 1439,13 ---</span>
          case ValueSub:
          case ValueMul:
          case ValueBitAnd:
          case ValueBitOr:
          case ValueBitXor:
<span class="line-added">+         case ValueBitNot:</span>
<span class="line-added">+         case ValueBitLShift:</span>
<span class="line-added">+         case ValueBitRShift:</span>
          case ValueNegate:
              return true;
          default:
              return false;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1508,13 ***</span>
      {
          ASSERT(isEntrySwitch());
          return m_opInfo.as&lt;EntrySwitchData*&gt;();
      }
  
      Intrinsic intrinsic()
      {
<span class="line-modified">!         RELEASE_ASSERT(op() == CPUIntrinsic);</span>
          return m_opInfo.as&lt;Intrinsic&gt;();
      }
  
      unsigned numSuccessors()
      {
<span class="line-new-header">--- 1574,25 ---</span>
      {
          ASSERT(isEntrySwitch());
          return m_opInfo.as&lt;EntrySwitchData*&gt;();
      }
  
<span class="line-added">+     bool hasIntrinsic()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         switch (op()) {</span>
<span class="line-added">+         case CPUIntrinsic:</span>
<span class="line-added">+         case DateGetTime:</span>
<span class="line-added">+         case DateGetInt32OrNaN:</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      Intrinsic intrinsic()
      {
<span class="line-modified">!         ASSERT(hasIntrinsic());</span>
          return m_opInfo.as&lt;Intrinsic&gt;();
      }
  
      unsigned numSuccessors()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1665,10 ***</span>
<span class="line-new-header">--- 1743,11 ---</span>
          case CallForwardVarargs:
          case TailCallForwardVarargsInlinedCaller:
          case GetByOffset:
          case MultiGetByOffset:
          case GetClosureVar:
<span class="line-added">+         case GetInternalField:</span>
          case GetFromArguments:
          case GetArgument:
          case ArrayPop:
          case ArrayPush:
          case RegExpExec:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1679,16 ***</span>
<span class="line-new-header">--- 1758,18 ---</span>
          case GetGlobalVar:
          case GetGlobalLexicalVariable:
          case StringReplace:
          case StringReplaceRegExp:
          case ToNumber:
<span class="line-added">+         case ToNumeric:</span>
          case ToObject:
          case ValueBitAnd:
          case ValueBitOr:
          case ValueBitXor:
          case ValueBitNot:
          case ValueBitLShift:
<span class="line-added">+         case ValueBitRShift:</span>
          case CallObjectConstructor:
          case LoadKeyFromMapBucket:
          case LoadValueFromMapBucket:
          case CallDOMGetter:
          case CallDOM:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1705,10 ***</span>
<span class="line-new-header">--- 1786,11 ---</span>
          case GetDynamicVar:
          case ExtractValueFromWeakMapGet:
          case ToThis:
          case DataViewGetInt:
          case DataViewGetFloat:
<span class="line-added">+         case DateGetInt32OrNaN:</span>
              return true;
          default:
              return false;
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1811,11 ***</span>
          return m_opInfo.as&lt;void*&gt;();
      }
  
      bool hasUidOperand()
      {
<span class="line-modified">!         return op() == CheckStringIdent;</span>
      }
  
      UniquedStringImpl* uidOperand()
      {
          ASSERT(hasUidOperand());
<span class="line-new-header">--- 1893,11 ---</span>
          return m_opInfo.as&lt;void*&gt;();
      }
  
      bool hasUidOperand()
      {
<span class="line-modified">!         return op() == CheckIdent;</span>
      }
  
      UniquedStringImpl* uidOperand()
      {
          ASSERT(hasUidOperand());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1872,11 ***</span>
<span class="line-new-header">--- 1954,16 ---</span>
  
      bool hasStructure()
      {
          switch (op()) {
          case ArrayifyToStructure:
<span class="line-added">+         case MaterializeNewInternalFieldObject:</span>
          case NewObject:
<span class="line-added">+         case NewPromise:</span>
<span class="line-added">+         case NewGenerator:</span>
<span class="line-added">+         case NewAsyncGenerator:</span>
<span class="line-added">+         case NewArrayIterator:</span>
          case NewStringObject:
              return true;
          default:
              return false;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1941,10 ***</span>
<span class="line-new-header">--- 2028,11 ---</span>
  
      bool hasObjectMaterializationData()
      {
          switch (op()) {
          case MaterializeNewObject:
<span class="line-added">+         case MaterializeNewInternalFieldObject:</span>
          case MaterializeCreateActivation:
              return true;
  
          default:
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2037,10 ***</span>
<span class="line-new-header">--- 2125,11 ---</span>
          case PhantomClonedArguments:
          case PhantomNewFunction:
          case PhantomNewGeneratorFunction:
          case PhantomNewAsyncFunction:
          case PhantomNewAsyncGeneratorFunction:
<span class="line-added">+         case PhantomNewArrayIterator:</span>
          case PhantomCreateActivation:
          case PhantomNewRegexp:
              return true;
          default:
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2058,11 ***</span>
<span class="line-new-header">--- 2147,13 ---</span>
          case PutByVal:
          case PutByValAlias:
          case GetByVal:
          case StringCharAt:
          case StringCharCodeAt:
<span class="line-added">+         case StringCodePointAt:</span>
          case CheckArray:
<span class="line-added">+         case CheckArrayOrEmpty:</span>
          case Arrayify:
          case ArrayifyToStructure:
          case ArrayPush:
          case ArrayPop:
          case ArrayIndexOf:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2850,19 ***</span>
      {
          ASSERT(hasCallLinkStatus());
          return m_opInfo.as&lt;CallLinkStatus*&gt;();
      }
  
<span class="line-modified">!     bool hasGetByIdStatus()</span>
      {
<span class="line-modified">!         return op() == FilterGetByIdStatus;</span>
      }
  
<span class="line-modified">!     GetByIdStatus* getByIdStatus()</span>
      {
<span class="line-modified">!         ASSERT(hasGetByIdStatus());</span>
<span class="line-modified">!         return m_opInfo.as&lt;GetByIdStatus*&gt;();</span>
      }
  
      bool hasInByIdStatus()
      {
          return op() == FilterInByIdStatus;
<span class="line-new-header">--- 2941,19 ---</span>
      {
          ASSERT(hasCallLinkStatus());
          return m_opInfo.as&lt;CallLinkStatus*&gt;();
      }
  
<span class="line-modified">!     bool hasGetByStatus()</span>
      {
<span class="line-modified">!         return op() == FilterGetByStatus;</span>
      }
  
<span class="line-modified">!     GetByStatus* getByStatus()</span>
      {
<span class="line-modified">!         ASSERT(hasGetByStatus());</span>
<span class="line-modified">!         return m_opInfo.as&lt;GetByStatus*&gt;();</span>
      }
  
      bool hasInByIdStatus()
      {
          return op() == FilterInByIdStatus;
</pre>
<center><a href="DFGNode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGNodeFlowProjection.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
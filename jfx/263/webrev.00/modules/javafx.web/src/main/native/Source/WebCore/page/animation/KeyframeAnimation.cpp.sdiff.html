<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/animation/KeyframeAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ImplicitAnimation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../csp/ContentSecurityPolicy.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/animation/KeyframeAnimation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
236         // Get the from/to styles and progress between
237         const RenderStyle* fromStyle = nullptr;
238         const RenderStyle* toStyle = nullptr;
239         double progress = 0;
240         fetchIntervalEndpointsForProperty(propertyID, fromStyle, toStyle, progress);
241 
242         CSSPropertyAnimation::blendProperties(this, propertyID, animatedStyle.get(), fromStyle, toStyle, progress);
243     }
244 }
245 
246 bool KeyframeAnimation::computeExtentOfTransformAnimation(LayoutRect&amp; bounds) const
247 {
248     ASSERT(m_keyframes.containsProperty(CSSPropertyTransform));
249 
250     if (!is&lt;RenderBox&gt;(renderer()))
251         return true; // Non-boxes don&#39;t get transformed;
252 
253     auto&amp; box = downcast&lt;RenderBox&gt;(*renderer());
254     auto rendererBox = snapRectToDevicePixels(box.borderBoxRect(), box.document().deviceScaleFactor());
255 
<span class="line-modified">256     auto cumulativeBounds = bounds;</span>
257 
258     for (auto&amp; keyframe : m_keyframes.keyframes()) {
259         const RenderStyle* keyframeStyle = keyframe.style();
260 
261         if (!keyframe.containsProperty(CSSPropertyTransform)) {
262             // If the first keyframe is missing transform style, use the current style.
263             if (!keyframe.key())
264                 keyframeStyle = &amp;box.style();
265             else
266                 continue;
267         }
268 
269         auto keyframeBounds = bounds;
270 
271         bool canCompute;
272         if (transformFunctionListsMatch())
273             canCompute = computeTransformedExtentViaTransformList(rendererBox, *keyframeStyle, keyframeBounds);
274         else
275             canCompute = computeTransformedExtentViaMatrix(rendererBox, *keyframeStyle, keyframeBounds);
276 
</pre>
<hr />
<pre>
345 
346 bool KeyframeAnimation::sendAnimationEvent(const AtomString&amp; eventType, double elapsedTime)
347 {
348     Document::ListenerType listenerType;
349     if (eventType == eventNames().webkitAnimationIterationEvent || eventType == eventNames().animationiterationEvent)
350         listenerType = Document::ANIMATIONITERATION_LISTENER;
351     else if (eventType == eventNames().webkitAnimationEndEvent || eventType == eventNames().animationendEvent)
352         listenerType = Document::ANIMATIONEND_LISTENER;
353     else {
354         ASSERT(eventType == eventNames().webkitAnimationStartEvent || eventType == eventNames().animationstartEvent);
355         if (m_startEventDispatched)
356             return false;
357         m_startEventDispatched = true;
358         listenerType = Document::ANIMATIONSTART_LISTENER;
359     }
360 
361     if (shouldSendEventForListener(listenerType)) {
362         // Dispatch the event
363         auto element = makeRefPtr(this-&gt;element());
364 
<span class="line-modified">365         ASSERT(!element || element-&gt;document().pageCacheState() == Document::NotInPageCache);</span>
366         if (!element)
367             return false;
368 
369         // Schedule event handling
370         m_compositeAnimation-&gt;animationController().addEventToDispatch(*element, eventType, m_keyframes.animationName(), elapsedTime);
371 
372         // Restore the original (unanimated) style
373         if ((eventType == eventNames().webkitAnimationEndEvent || eventType == eventNames().animationendEvent) &amp;&amp; element-&gt;renderer())
374             setNeedsStyleRecalc(element.get());
375 
376         return true; // Did dispatch an event
377     }
378 
379     return false; // Did not dispatch an event
380 }
381 
382 void KeyframeAnimation::overrideAnimations()
383 {
384     // This will override implicit animations that match the properties in the keyframe animation
385     for (auto propertyID : m_keyframes.properties())
</pre>
<hr />
<pre>
498 #if ENABLE(FILTERS_LEVEL_2)
499 void KeyframeAnimation::checkForMatchingBackdropFilterFunctionLists()
500 {
501     m_backdropFilterFunctionListsMatch = checkForMatchingFilterFunctionLists(CSSPropertyWebkitBackdropFilter, [] (const RenderStyle&amp; style) -&gt; const FilterOperations&amp; {
502         return style.backdropFilter();
503     });
504 }
505 #endif
506 
507 void KeyframeAnimation::checkForMatchingColorFilterFunctionLists()
508 {
509     m_colorFilterFunctionListsMatch = checkForMatchingFilterFunctionLists(CSSPropertyAppleColorFilter, [] (const RenderStyle&amp; style) -&gt; const FilterOperations&amp; {
510         return style.appleColorFilter();
511     });
512 }
513 
514 Optional&lt;Seconds&gt; KeyframeAnimation::timeToNextService()
515 {
516     Optional&lt;Seconds&gt; t = AnimationBase::timeToNextService();
517     if (!t || t.value() != 0_s || preActive())



518         return t;

519 
520     // A return value of 0 means we need service. But if we only have accelerated animations we
521     // only need service at the end of the transition.
522     bool acceleratedPropertiesOnly = true;
523 
524     for (auto propertyID : m_keyframes.properties()) {
525         if (!CSSPropertyAnimation::animationOfPropertyIsAccelerated(propertyID) || !isAccelerated()) {
526             acceleratedPropertiesOnly = false;
527             break;
528         }
529     }
530 
531     if (acceleratedPropertiesOnly) {
532         bool isLooping;
533         getTimeToNextEvent(t.value(), isLooping);
534     }
535 
536     return t;
537 }
538 
</pre>
</td>
<td>
<hr />
<pre>
236         // Get the from/to styles and progress between
237         const RenderStyle* fromStyle = nullptr;
238         const RenderStyle* toStyle = nullptr;
239         double progress = 0;
240         fetchIntervalEndpointsForProperty(propertyID, fromStyle, toStyle, progress);
241 
242         CSSPropertyAnimation::blendProperties(this, propertyID, animatedStyle.get(), fromStyle, toStyle, progress);
243     }
244 }
245 
246 bool KeyframeAnimation::computeExtentOfTransformAnimation(LayoutRect&amp; bounds) const
247 {
248     ASSERT(m_keyframes.containsProperty(CSSPropertyTransform));
249 
250     if (!is&lt;RenderBox&gt;(renderer()))
251         return true; // Non-boxes don&#39;t get transformed;
252 
253     auto&amp; box = downcast&lt;RenderBox&gt;(*renderer());
254     auto rendererBox = snapRectToDevicePixels(box.borderBoxRect(), box.document().deviceScaleFactor());
255 
<span class="line-modified">256     LayoutRect cumulativeBounds;</span>
257 
258     for (auto&amp; keyframe : m_keyframes.keyframes()) {
259         const RenderStyle* keyframeStyle = keyframe.style();
260 
261         if (!keyframe.containsProperty(CSSPropertyTransform)) {
262             // If the first keyframe is missing transform style, use the current style.
263             if (!keyframe.key())
264                 keyframeStyle = &amp;box.style();
265             else
266                 continue;
267         }
268 
269         auto keyframeBounds = bounds;
270 
271         bool canCompute;
272         if (transformFunctionListsMatch())
273             canCompute = computeTransformedExtentViaTransformList(rendererBox, *keyframeStyle, keyframeBounds);
274         else
275             canCompute = computeTransformedExtentViaMatrix(rendererBox, *keyframeStyle, keyframeBounds);
276 
</pre>
<hr />
<pre>
345 
346 bool KeyframeAnimation::sendAnimationEvent(const AtomString&amp; eventType, double elapsedTime)
347 {
348     Document::ListenerType listenerType;
349     if (eventType == eventNames().webkitAnimationIterationEvent || eventType == eventNames().animationiterationEvent)
350         listenerType = Document::ANIMATIONITERATION_LISTENER;
351     else if (eventType == eventNames().webkitAnimationEndEvent || eventType == eventNames().animationendEvent)
352         listenerType = Document::ANIMATIONEND_LISTENER;
353     else {
354         ASSERT(eventType == eventNames().webkitAnimationStartEvent || eventType == eventNames().animationstartEvent);
355         if (m_startEventDispatched)
356             return false;
357         m_startEventDispatched = true;
358         listenerType = Document::ANIMATIONSTART_LISTENER;
359     }
360 
361     if (shouldSendEventForListener(listenerType)) {
362         // Dispatch the event
363         auto element = makeRefPtr(this-&gt;element());
364 
<span class="line-modified">365         ASSERT(!element || element-&gt;document().backForwardCacheState() == Document::NotInBackForwardCache);</span>
366         if (!element)
367             return false;
368 
369         // Schedule event handling
370         m_compositeAnimation-&gt;animationController().addEventToDispatch(*element, eventType, m_keyframes.animationName(), elapsedTime);
371 
372         // Restore the original (unanimated) style
373         if ((eventType == eventNames().webkitAnimationEndEvent || eventType == eventNames().animationendEvent) &amp;&amp; element-&gt;renderer())
374             setNeedsStyleRecalc(element.get());
375 
376         return true; // Did dispatch an event
377     }
378 
379     return false; // Did not dispatch an event
380 }
381 
382 void KeyframeAnimation::overrideAnimations()
383 {
384     // This will override implicit animations that match the properties in the keyframe animation
385     for (auto propertyID : m_keyframes.properties())
</pre>
<hr />
<pre>
498 #if ENABLE(FILTERS_LEVEL_2)
499 void KeyframeAnimation::checkForMatchingBackdropFilterFunctionLists()
500 {
501     m_backdropFilterFunctionListsMatch = checkForMatchingFilterFunctionLists(CSSPropertyWebkitBackdropFilter, [] (const RenderStyle&amp; style) -&gt; const FilterOperations&amp; {
502         return style.backdropFilter();
503     });
504 }
505 #endif
506 
507 void KeyframeAnimation::checkForMatchingColorFilterFunctionLists()
508 {
509     m_colorFilterFunctionListsMatch = checkForMatchingFilterFunctionLists(CSSPropertyAppleColorFilter, [] (const RenderStyle&amp; style) -&gt; const FilterOperations&amp; {
510         return style.appleColorFilter();
511     });
512 }
513 
514 Optional&lt;Seconds&gt; KeyframeAnimation::timeToNextService()
515 {
516     Optional&lt;Seconds&gt; t = AnimationBase::timeToNextService();
517     if (!t || t.value() != 0_s || preActive())
<span class="line-added">518 #if COMPILER(MSVC) &amp;&amp; _MSC_VER &gt;= 1920</span>
<span class="line-added">519         return WTFMove(t);</span>
<span class="line-added">520 #else</span>
521         return t;
<span class="line-added">522 #endif</span>
523 
524     // A return value of 0 means we need service. But if we only have accelerated animations we
525     // only need service at the end of the transition.
526     bool acceleratedPropertiesOnly = true;
527 
528     for (auto propertyID : m_keyframes.properties()) {
529         if (!CSSPropertyAnimation::animationOfPropertyIsAccelerated(propertyID) || !isAccelerated()) {
530             acceleratedPropertiesOnly = false;
531             break;
532         }
533     }
534 
535     if (acceleratedPropertiesOnly) {
536         bool isLooping;
537         getTimeToNextEvent(t.value(), isLooping);
538     }
539 
540     return t;
541 }
542 
</pre>
</td>
</tr>
</table>
<center><a href="ImplicitAnimation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../csp/ContentSecurityPolicy.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
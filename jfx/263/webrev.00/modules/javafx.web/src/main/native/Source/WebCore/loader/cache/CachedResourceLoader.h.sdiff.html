<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResourceLoader.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CachedResourceLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedResourceRequest.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResourceLoader.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
111     CachedResource* cachedResource(const String&amp; url) const;
112     CachedResource* cachedResource(const URL&amp; url) const;
113 
114     typedef HashMap&lt;String, CachedResourceHandle&lt;CachedResource&gt;&gt; DocumentResourceMap;
115     const DocumentResourceMap&amp; allCachedResources() const { return m_documentResources; }
116 
117     bool autoLoadImages() const { return m_autoLoadImages; }
118     void setAutoLoadImages(bool);
119 
120     bool imagesEnabled() const { return m_imagesEnabled; }
121     void setImagesEnabled(bool);
122 
123     bool shouldDeferImageLoad(const URL&amp;) const;
124     bool shouldPerformImageLoad(const URL&amp;) const;
125 
126     CachePolicy cachePolicy(CachedResource::Type, const URL&amp;) const;
127 
128     Frame* frame() const; // Can be null
129     Document* document() const { return m_document.get(); } // Can be null
130     void setDocument(Document* document) { m_document = makeWeakPtr(document); }

131     void clearDocumentLoader() { m_documentLoader = nullptr; }
<span class="line-removed">132     PAL::SessionID sessionID() const;</span>
133 
134     void loadDone(LoadCompletionType, bool shouldPerformPostLoadActions = true);
135 
136     WEBCORE_EXPORT void garbageCollectDocumentResources();
137 
138     void incrementRequestCount(const CachedResource&amp;);
139     void decrementRequestCount(const CachedResource&amp;);
140     int requestCount() const { return m_requestCount; }
141 
142     WEBCORE_EXPORT bool isPreloaded(const String&amp; urlString) const;
143     enum class ClearPreloadsMode { ClearSpeculativePreloads, ClearAllPreloads };
144     void clearPreloads(ClearPreloadsMode);
145     ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; preload(CachedResource::Type, CachedResourceRequest&amp;&amp;);
146     void printPreloadStats();
147     void warnUnusedPreloads();
148     void stopUnusedPreloadsTimer();
149 
150     bool updateRequestAfterRedirection(CachedResource::Type, ResourceRequest&amp;, const ResourceLoaderOptions&amp;);
151     bool allowedByContentSecurityPolicy(CachedResource::Type, const URL&amp;, const ResourceLoaderOptions&amp;, ContentSecurityPolicy::RedirectResponseReceived) const;
152 
153     static const ResourceLoaderOptions&amp; defaultCachedResourceOptions();
154 
155     void documentDidFinishLoadEvent();
156 
157     ResourceTimingInformation&amp; resourceTimingInformation() { return m_resourceTimingInfo; }
158 
159     bool isAlwaysOnLoggingAllowed() const;
160 
161     KeepaliveRequestTracker&amp; keepaliveRequestTracker() { return m_keepaliveRequestTracker; }
162 
163 private:
164     explicit CachedResourceLoader(DocumentLoader*);
165 
166     enum class ForPreload { Yes, No };
167     enum class DeferOption { NoDefer, DeferredByClient };
168 
169     ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; requestResource(CachedResource::Type, CachedResourceRequest&amp;&amp;, ForPreload = ForPreload::No, DeferOption = DeferOption::NoDefer);
170     CachedResourceHandle&lt;CachedResource&gt; revalidateResource(CachedResourceRequest&amp;&amp;, CachedResource&amp;);
<span class="line-modified">171     CachedResourceHandle&lt;CachedResource&gt; loadResource(CachedResource::Type, CachedResourceRequest&amp;&amp;, const CookieJar*);</span>
172 
173     void prepareFetch(CachedResource::Type, CachedResourceRequest&amp;);
174     void updateHTTPRequestHeaders(CachedResource::Type, CachedResourceRequest&amp;);
175 
176     bool canRequest(CachedResource::Type, const URL&amp;, const CachedResourceRequest&amp;, ForPreload);
177 
178     enum RevalidationPolicy { Use, Revalidate, Reload, Load };
179     RevalidationPolicy determineRevalidationPolicy(CachedResource::Type, CachedResourceRequest&amp;, CachedResource* existingResource, ForPreload, DeferOption) const;
180 
181     bool shouldUpdateCachedResourceWithCurrentRequest(const CachedResource&amp;, const CachedResourceRequest&amp;);
<span class="line-modified">182     CachedResourceHandle&lt;CachedResource&gt; updateCachedResourceWithCurrentRequest(const CachedResource&amp;, CachedResourceRequest&amp;&amp;, const PAL::SessionID&amp;, const CookieJar*);</span>
183 
184     bool shouldContinueAfterNotifyingLoadedFromMemoryCache(const CachedResourceRequest&amp;, CachedResource&amp;, ResourceError&amp;);
185     bool checkInsecureContent(CachedResource::Type, const URL&amp;) const;
186 
187     void performPostLoadActions();
188 
189     bool clientDefersImage(const URL&amp;) const;
190     void reloadImagesIfNotDeferred();
191 
192     bool canRequestAfterRedirection(CachedResource::Type, const URL&amp;, const ResourceLoaderOptions&amp;) const;
193     bool canRequestInContentDispositionAttachmentSandbox(CachedResource::Type, const URL&amp;) const;
194 
195     HashSet&lt;String&gt; m_validatedURLs;
196     mutable DocumentResourceMap m_documentResources;
197     WeakPtr&lt;Document&gt; m_document;
198     DocumentLoader* m_documentLoader;
199 
200     int m_requestCount;
201 
202     std::unique_ptr&lt;ListHashSet&lt;CachedResource*&gt;&gt; m_preloads;
</pre>
</td>
<td>
<hr />
<pre>
111     CachedResource* cachedResource(const String&amp; url) const;
112     CachedResource* cachedResource(const URL&amp; url) const;
113 
114     typedef HashMap&lt;String, CachedResourceHandle&lt;CachedResource&gt;&gt; DocumentResourceMap;
115     const DocumentResourceMap&amp; allCachedResources() const { return m_documentResources; }
116 
117     bool autoLoadImages() const { return m_autoLoadImages; }
118     void setAutoLoadImages(bool);
119 
120     bool imagesEnabled() const { return m_imagesEnabled; }
121     void setImagesEnabled(bool);
122 
123     bool shouldDeferImageLoad(const URL&amp;) const;
124     bool shouldPerformImageLoad(const URL&amp;) const;
125 
126     CachePolicy cachePolicy(CachedResource::Type, const URL&amp;) const;
127 
128     Frame* frame() const; // Can be null
129     Document* document() const { return m_document.get(); } // Can be null
130     void setDocument(Document* document) { m_document = makeWeakPtr(document); }
<span class="line-added">131     DocumentLoader* documentLoader() const { return m_documentLoader; }</span>
132     void clearDocumentLoader() { m_documentLoader = nullptr; }

133 
134     void loadDone(LoadCompletionType, bool shouldPerformPostLoadActions = true);
135 
136     WEBCORE_EXPORT void garbageCollectDocumentResources();
137 
138     void incrementRequestCount(const CachedResource&amp;);
139     void decrementRequestCount(const CachedResource&amp;);
140     int requestCount() const { return m_requestCount; }
141 
142     WEBCORE_EXPORT bool isPreloaded(const String&amp; urlString) const;
143     enum class ClearPreloadsMode { ClearSpeculativePreloads, ClearAllPreloads };
144     void clearPreloads(ClearPreloadsMode);
145     ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; preload(CachedResource::Type, CachedResourceRequest&amp;&amp;);
146     void printPreloadStats();
147     void warnUnusedPreloads();
148     void stopUnusedPreloadsTimer();
149 
150     bool updateRequestAfterRedirection(CachedResource::Type, ResourceRequest&amp;, const ResourceLoaderOptions&amp;);
151     bool allowedByContentSecurityPolicy(CachedResource::Type, const URL&amp;, const ResourceLoaderOptions&amp;, ContentSecurityPolicy::RedirectResponseReceived) const;
152 
153     static const ResourceLoaderOptions&amp; defaultCachedResourceOptions();
154 
155     void documentDidFinishLoadEvent();
156 
157     ResourceTimingInformation&amp; resourceTimingInformation() { return m_resourceTimingInfo; }
158 
159     bool isAlwaysOnLoggingAllowed() const;
160 
161     KeepaliveRequestTracker&amp; keepaliveRequestTracker() { return m_keepaliveRequestTracker; }
162 
163 private:
164     explicit CachedResourceLoader(DocumentLoader*);
165 
166     enum class ForPreload { Yes, No };
167     enum class DeferOption { NoDefer, DeferredByClient };
168 
169     ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; requestResource(CachedResource::Type, CachedResourceRequest&amp;&amp;, ForPreload = ForPreload::No, DeferOption = DeferOption::NoDefer);
170     CachedResourceHandle&lt;CachedResource&gt; revalidateResource(CachedResourceRequest&amp;&amp;, CachedResource&amp;);
<span class="line-modified">171     CachedResourceHandle&lt;CachedResource&gt; loadResource(CachedResource::Type, PAL::SessionID, CachedResourceRequest&amp;&amp;, const CookieJar&amp;);</span>
172 
173     void prepareFetch(CachedResource::Type, CachedResourceRequest&amp;);
174     void updateHTTPRequestHeaders(CachedResource::Type, CachedResourceRequest&amp;);
175 
176     bool canRequest(CachedResource::Type, const URL&amp;, const CachedResourceRequest&amp;, ForPreload);
177 
178     enum RevalidationPolicy { Use, Revalidate, Reload, Load };
179     RevalidationPolicy determineRevalidationPolicy(CachedResource::Type, CachedResourceRequest&amp;, CachedResource* existingResource, ForPreload, DeferOption) const;
180 
181     bool shouldUpdateCachedResourceWithCurrentRequest(const CachedResource&amp;, const CachedResourceRequest&amp;);
<span class="line-modified">182     CachedResourceHandle&lt;CachedResource&gt; updateCachedResourceWithCurrentRequest(const CachedResource&amp;, CachedResourceRequest&amp;&amp;, const PAL::SessionID&amp;, const CookieJar&amp;);</span>
183 
184     bool shouldContinueAfterNotifyingLoadedFromMemoryCache(const CachedResourceRequest&amp;, CachedResource&amp;, ResourceError&amp;);
185     bool checkInsecureContent(CachedResource::Type, const URL&amp;) const;
186 
187     void performPostLoadActions();
188 
189     bool clientDefersImage(const URL&amp;) const;
190     void reloadImagesIfNotDeferred();
191 
192     bool canRequestAfterRedirection(CachedResource::Type, const URL&amp;, const ResourceLoaderOptions&amp;) const;
193     bool canRequestInContentDispositionAttachmentSandbox(CachedResource::Type, const URL&amp;) const;
194 
195     HashSet&lt;String&gt; m_validatedURLs;
196     mutable DocumentResourceMap m_documentResources;
197     WeakPtr&lt;Document&gt; m_document;
198     DocumentLoader* m_documentLoader;
199 
200     int m_requestCount;
201 
202     std::unique_ptr&lt;ListHashSet&lt;CachedResource*&gt;&gt; m_preloads;
</pre>
</td>
</tr>
</table>
<center><a href="CachedResourceLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedResourceRequest.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
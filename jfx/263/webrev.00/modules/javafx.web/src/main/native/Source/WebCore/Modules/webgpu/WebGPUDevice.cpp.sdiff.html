<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WebGPUDevice.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGPUComputePipelineDescriptor.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGPUDevice.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WebGPUDevice.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGPUDevice.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 



 31 #include &quot;Exception.h&quot;
 32 #include &quot;GPUBindGroup.h&quot;
 33 #include &quot;GPUBindGroupBinding.h&quot;
 34 #include &quot;GPUBindGroupDescriptor.h&quot;
 35 #include &quot;GPUBindGroupLayoutDescriptor.h&quot;
 36 #include &quot;GPUBufferBinding.h&quot;
 37 #include &quot;GPUBufferDescriptor.h&quot;
 38 #include &quot;GPUCommandBuffer.h&quot;

 39 #include &quot;GPUComputePipelineDescriptor.h&quot;
<span class="line-modified"> 40 #include &quot;GPUPipelineStageDescriptor.h&quot;</span>

 41 #include &quot;GPURenderPipelineDescriptor.h&quot;
 42 #include &quot;GPUSampler.h&quot;
 43 #include &quot;GPUSamplerDescriptor.h&quot;
 44 #include &quot;GPUShaderModuleDescriptor.h&quot;
 45 #include &quot;GPUTextureDescriptor.h&quot;


 46 #include &quot;JSDOMConvertBufferSource.h&quot;

 47 #include &quot;JSGPUOutOfMemoryError.h&quot;
 48 #include &quot;JSGPUValidationError.h&quot;
 49 #include &quot;JSWebGPUBuffer.h&quot;
 50 #include &quot;Logging.h&quot;
 51 #include &quot;WebGPUBindGroup.h&quot;
 52 #include &quot;WebGPUBindGroupBinding.h&quot;
 53 #include &quot;WebGPUBindGroupDescriptor.h&quot;
 54 #include &quot;WebGPUBindGroupLayout.h&quot;
 55 #include &quot;WebGPUBufferBinding.h&quot;
 56 #include &quot;WebGPUCommandEncoder.h&quot;
 57 #include &quot;WebGPUComputePipeline.h&quot;
 58 #include &quot;WebGPUComputePipelineDescriptor.h&quot;

 59 #include &quot;WebGPUPipelineLayout.h&quot;
 60 #include &quot;WebGPUPipelineLayoutDescriptor.h&quot;
<span class="line-modified"> 61 #include &quot;WebGPUPipelineStageDescriptor.h&quot;</span>
 62 #include &quot;WebGPUQueue.h&quot;
 63 #include &quot;WebGPURenderPipeline.h&quot;
 64 #include &quot;WebGPURenderPipelineDescriptor.h&quot;
 65 #include &quot;WebGPUSampler.h&quot;
 66 #include &quot;WebGPUShaderModule.h&quot;
 67 #include &quot;WebGPUShaderModuleDescriptor.h&quot;
 68 #include &quot;WebGPUSwapChain.h&quot;
 69 #include &quot;WebGPUTexture.h&quot;







 70 #include &lt;wtf/Optional.h&gt;




 71 #include &lt;wtf/text/WTFString.h&gt;
 72 
 73 namespace WebCore {
 74 
<span class="line-modified"> 75 RefPtr&lt;WebGPUDevice&gt; WebGPUDevice::tryCreate(Ref&lt;const WebGPUAdapter&gt;&amp;&amp; adapter)</span>


 76 {
 77     if (auto device = GPUDevice::tryCreate(adapter-&gt;options()))
<span class="line-modified"> 78         return adoptRef(new WebGPUDevice(WTFMove(adapter), device.releaseNonNull()));</span>
 79     return nullptr;
 80 }
 81 
<span class="line-modified"> 82 WebGPUDevice::WebGPUDevice(Ref&lt;const WebGPUAdapter&gt;&amp;&amp; adapter, Ref&lt;GPUDevice&gt;&amp;&amp; device)</span>
<span class="line-modified"> 83     : m_adapter(WTFMove(adapter))</span>

















 84     , m_device(WTFMove(device))
<span class="line-modified"> 85     , m_errorScopes(GPUErrorScopes::create())</span>



 86 {




























 87 }
 88 
 89 Ref&lt;WebGPUBuffer&gt; WebGPUDevice::createBuffer(const GPUBufferDescriptor&amp; descriptor) const
 90 {
 91     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createBuffer(): &quot;);
 92 
 93     auto buffer = m_device-&gt;tryCreateBuffer(descriptor, GPUBufferMappedOption::NotMapped, m_errorScopes);
 94     return WebGPUBuffer::create(WTFMove(buffer), m_errorScopes);
 95 }
 96 
<span class="line-modified"> 97 Vector&lt;JSC::JSValue&gt; WebGPUDevice::createBufferMapped(JSC::ExecState&amp; state, const GPUBufferDescriptor&amp; descriptor) const</span>
 98 {
 99     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createBufferMapped(): &quot;);
100 
101     JSC::JSValue wrappedArrayBuffer = JSC::jsNull();
102 
103     auto buffer = m_device-&gt;tryCreateBuffer(descriptor, GPUBufferMappedOption::IsMapped, m_errorScopes);
104     if (buffer) {
105         auto arrayBuffer = buffer-&gt;mapOnCreation();
<span class="line-modified">106         wrappedArrayBuffer = toJS(&amp;state, JSC::jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject()), arrayBuffer);</span>
107     }
108 
109     auto webBuffer = WebGPUBuffer::create(WTFMove(buffer), m_errorScopes);
<span class="line-modified">110     auto wrappedWebBuffer = toJS(&amp;state, JSC::jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject()), webBuffer);</span>
111 
112     return { wrappedWebBuffer, wrappedArrayBuffer };
113 }
114 
115 Ref&lt;WebGPUTexture&gt; WebGPUDevice::createTexture(const GPUTextureDescriptor&amp; descriptor) const
116 {
117     auto texture = m_device-&gt;tryCreateTexture(descriptor);
118     return WebGPUTexture::create(WTFMove(texture));
119 }
120 
121 Ref&lt;WebGPUSampler&gt; WebGPUDevice::createSampler(const GPUSamplerDescriptor&amp; descriptor) const
122 {
123     auto sampler = m_device-&gt;tryCreateSampler(descriptor);
124     return WebGPUSampler::create(WTFMove(sampler));
125 }
126 
127 Ref&lt;WebGPUBindGroupLayout&gt; WebGPUDevice::createBindGroupLayout(const GPUBindGroupLayoutDescriptor&amp; descriptor) const
128 {
129     auto layout = m_device-&gt;tryCreateBindGroupLayout(descriptor);
130     return WebGPUBindGroupLayout::create(WTFMove(layout));
</pre>
<hr />
<pre>
137         return WebGPUPipelineLayout::create(nullptr);
138 
139     auto layout = m_device-&gt;createPipelineLayout(WTFMove(*gpuDescriptor));
140     return WebGPUPipelineLayout::create(WTFMove(layout));
141 }
142 
143 Ref&lt;WebGPUBindGroup&gt; WebGPUDevice::createBindGroup(const WebGPUBindGroupDescriptor&amp; descriptor) const
144 {
145     auto gpuDescriptor = descriptor.tryCreateGPUBindGroupDescriptor();
146     if (!gpuDescriptor)
147         return WebGPUBindGroup::create(nullptr);
148 
149     auto bindGroup = m_device-&gt;tryCreateBindGroup(*gpuDescriptor, m_errorScopes);
150     return WebGPUBindGroup::create(WTFMove(bindGroup));
151 }
152 
153 Ref&lt;WebGPUShaderModule&gt; WebGPUDevice::createShaderModule(const WebGPUShaderModuleDescriptor&amp; descriptor) const
154 {
155     // FIXME: What can be validated here?
156     auto module = m_device-&gt;tryCreateShaderModule(GPUShaderModuleDescriptor { descriptor.code });
<span class="line-modified">157     return WebGPUShaderModule::create(WTFMove(module));</span>
158 }
159 
<span class="line-modified">160 Ref&lt;WebGPURenderPipeline&gt; WebGPUDevice::createRenderPipeline(const WebGPURenderPipelineDescriptor&amp; descriptor) const</span>
161 {
162     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createRenderPipeline(): &quot;);
163 
164     auto gpuDescriptor = descriptor.tryCreateGPURenderPipelineDescriptor(m_errorScopes);
165     if (!gpuDescriptor)
<span class="line-modified">166         return WebGPURenderPipeline::create(nullptr);</span>
167 
<span class="line-modified">168     auto pipeline = m_device-&gt;tryCreateRenderPipeline(*gpuDescriptor, m_errorScopes);</span>
<span class="line-modified">169     return WebGPURenderPipeline::create(WTFMove(pipeline));</span>










170 }
171 
<span class="line-modified">172 Ref&lt;WebGPUComputePipeline&gt; WebGPUDevice::createComputePipeline(const WebGPUComputePipelineDescriptor&amp; descriptor) const</span>
173 {
174     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createComputePipeline(): &quot;);
175 
176     auto gpuDescriptor = descriptor.tryCreateGPUComputePipelineDescriptor(m_errorScopes);
177     if (!gpuDescriptor)
<span class="line-modified">178         return WebGPUComputePipeline::create(nullptr);</span>


179 
<span class="line-modified">180     auto pipeline = m_device-&gt;tryCreateComputePipeline(*gpuDescriptor, m_errorScopes);</span>
<span class="line-modified">181     return WebGPUComputePipeline::create(WTFMove(pipeline));</span>




182 }
183 
184 Ref&lt;WebGPUCommandEncoder&gt; WebGPUDevice::createCommandEncoder() const
185 {
186     auto commandBuffer = m_device-&gt;tryCreateCommandBuffer();
187     return WebGPUCommandEncoder::create(WTFMove(commandBuffer));
188 }
189 
190 Ref&lt;WebGPUQueue&gt; WebGPUDevice::getQueue() const
191 {
192     if (!m_queue)
193         m_queue = WebGPUQueue::create(m_device-&gt;tryGetQueue());
194 
195     return makeRef(*m_queue.get());
196 }
197 
198 void WebGPUDevice::popErrorScope(ErrorPromise&amp;&amp; promise)
199 {
200     String failMessage;
201     Optional&lt;GPUError&gt; error = m_errorScopes-&gt;popErrorScope(failMessage);
202     if (failMessage.isEmpty())
203         promise.resolve(error);
204     else
205         promise.reject(Exception { OperationError, &quot;GPUDevice::popErrorScope(): &quot; + failMessage });
206 }
207 

























208 } // namespace WebCore
209 
210 #endif // ENABLE(WEBGPU)
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGPUDevice.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
<span class="line-added"> 31 #include &quot;DOMWindow.h&quot;</span>
<span class="line-added"> 32 #include &quot;Document.h&quot;</span>
<span class="line-added"> 33 #include &quot;EventNames.h&quot;</span>
 34 #include &quot;Exception.h&quot;
 35 #include &quot;GPUBindGroup.h&quot;
 36 #include &quot;GPUBindGroupBinding.h&quot;
 37 #include &quot;GPUBindGroupDescriptor.h&quot;
 38 #include &quot;GPUBindGroupLayoutDescriptor.h&quot;
 39 #include &quot;GPUBufferBinding.h&quot;
 40 #include &quot;GPUBufferDescriptor.h&quot;
 41 #include &quot;GPUCommandBuffer.h&quot;
<span class="line-added"> 42 #include &quot;GPUComputePipeline.h&quot;</span>
 43 #include &quot;GPUComputePipelineDescriptor.h&quot;
<span class="line-modified"> 44 #include &quot;GPUProgrammableStageDescriptor.h&quot;</span>
<span class="line-added"> 45 #include &quot;GPURenderPipeline.h&quot;</span>
 46 #include &quot;GPURenderPipelineDescriptor.h&quot;
 47 #include &quot;GPUSampler.h&quot;
 48 #include &quot;GPUSamplerDescriptor.h&quot;
 49 #include &quot;GPUShaderModuleDescriptor.h&quot;
 50 #include &quot;GPUTextureDescriptor.h&quot;
<span class="line-added"> 51 #include &quot;GPUUncapturedErrorEvent.h&quot;</span>
<span class="line-added"> 52 #include &quot;InspectorInstrumentation.h&quot;</span>
 53 #include &quot;JSDOMConvertBufferSource.h&quot;
<span class="line-added"> 54 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 55 #include &quot;JSGPUOutOfMemoryError.h&quot;
 56 #include &quot;JSGPUValidationError.h&quot;
 57 #include &quot;JSWebGPUBuffer.h&quot;
 58 #include &quot;Logging.h&quot;
 59 #include &quot;WebGPUBindGroup.h&quot;
 60 #include &quot;WebGPUBindGroupBinding.h&quot;
 61 #include &quot;WebGPUBindGroupDescriptor.h&quot;
 62 #include &quot;WebGPUBindGroupLayout.h&quot;
 63 #include &quot;WebGPUBufferBinding.h&quot;
 64 #include &quot;WebGPUCommandEncoder.h&quot;
 65 #include &quot;WebGPUComputePipeline.h&quot;
 66 #include &quot;WebGPUComputePipelineDescriptor.h&quot;
<span class="line-added"> 67 #include &quot;WebGPUPipeline.h&quot;</span>
 68 #include &quot;WebGPUPipelineLayout.h&quot;
 69 #include &quot;WebGPUPipelineLayoutDescriptor.h&quot;
<span class="line-modified"> 70 #include &quot;WebGPUProgrammableStageDescriptor.h&quot;</span>
 71 #include &quot;WebGPUQueue.h&quot;
 72 #include &quot;WebGPURenderPipeline.h&quot;
 73 #include &quot;WebGPURenderPipelineDescriptor.h&quot;
 74 #include &quot;WebGPUSampler.h&quot;
 75 #include &quot;WebGPUShaderModule.h&quot;
 76 #include &quot;WebGPUShaderModuleDescriptor.h&quot;
 77 #include &quot;WebGPUSwapChain.h&quot;
 78 #include &quot;WebGPUTexture.h&quot;
<span class="line-added"> 79 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;</span>
<span class="line-added"> 80 #include &lt;memory&gt;</span>
<span class="line-added"> 81 #include &lt;wtf/HashSet.h&gt;</span>
<span class="line-added"> 82 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
<span class="line-added"> 83 #include &lt;wtf/Lock.h&gt;</span>
<span class="line-added"> 84 #include &lt;wtf/MainThread.h&gt;</span>
<span class="line-added"> 85 #include &lt;wtf/NeverDestroyed.h&gt;</span>
 86 #include &lt;wtf/Optional.h&gt;
<span class="line-added"> 87 #include &lt;wtf/Ref.h&gt;</span>
<span class="line-added"> 88 #include &lt;wtf/RefPtr.h&gt;</span>
<span class="line-added"> 89 #include &lt;wtf/Variant.h&gt;</span>
<span class="line-added"> 90 #include &lt;wtf/Vector.h&gt;</span>
 91 #include &lt;wtf/text/WTFString.h&gt;
 92 
 93 namespace WebCore {
 94 
<span class="line-modified"> 95 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGPUDevice);</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97 RefPtr&lt;WebGPUDevice&gt; WebGPUDevice::tryCreate(ScriptExecutionContext&amp; context, Ref&lt;const WebGPUAdapter&gt;&amp;&amp; adapter)</span>
 98 {
 99     if (auto device = GPUDevice::tryCreate(adapter-&gt;options()))
<span class="line-modified">100         return adoptRef(new WebGPUDevice(context, WTFMove(adapter), device.releaseNonNull()));</span>
101     return nullptr;
102 }
103 
<span class="line-modified">104 HashSet&lt;WebGPUDevice*&gt;&amp; WebGPUDevice::instances(const LockHolder&amp;)</span>
<span class="line-modified">105 {</span>
<span class="line-added">106     static NeverDestroyed&lt;HashSet&lt;WebGPUDevice*&gt;&gt; instances;</span>
<span class="line-added">107     return instances;</span>
<span class="line-added">108 }</span>
<span class="line-added">109 </span>
<span class="line-added">110 Lock&amp; WebGPUDevice::instancesMutex()</span>
<span class="line-added">111 {</span>
<span class="line-added">112     static LazyNeverDestroyed&lt;Lock&gt; mutex;</span>
<span class="line-added">113     static std::once_flag initializeMutex;</span>
<span class="line-added">114     std::call_once(initializeMutex, [] {</span>
<span class="line-added">115         mutex.construct();</span>
<span class="line-added">116     });</span>
<span class="line-added">117     return mutex.get();</span>
<span class="line-added">118 }</span>
<span class="line-added">119 </span>
<span class="line-added">120 WebGPUDevice::WebGPUDevice(ScriptExecutionContext&amp; context, Ref&lt;const WebGPUAdapter&gt;&amp;&amp; adapter, Ref&lt;GPUDevice&gt;&amp;&amp; device)</span>
<span class="line-added">121     : m_scriptExecutionContext(context)</span>
<span class="line-added">122     , m_adapter(WTFMove(adapter))</span>
123     , m_device(WTFMove(device))
<span class="line-modified">124     , m_errorScopes(GPUErrorScopes::create([this, weakThis = makeWeakPtr(this)] (GPUError&amp;&amp; error) {</span>
<span class="line-added">125         if (weakThis)</span>
<span class="line-added">126             dispatchUncapturedError(WTFMove(error));</span>
<span class="line-added">127     }))</span>
128 {
<span class="line-added">129     ASSERT(m_scriptExecutionContext.isDocument());</span>
<span class="line-added">130 </span>
<span class="line-added">131     {</span>
<span class="line-added">132         LockHolder lock(instancesMutex());</span>
<span class="line-added">133         instances(lock).add(this);</span>
<span class="line-added">134     }</span>
<span class="line-added">135 }</span>
<span class="line-added">136 </span>
<span class="line-added">137 WebGPUDevice::~WebGPUDevice()</span>
<span class="line-added">138 {</span>
<span class="line-added">139     InspectorInstrumentation::willDestroyWebGPUDevice(*this);</span>
<span class="line-added">140 </span>
<span class="line-added">141     {</span>
<span class="line-added">142         LockHolder lock(WebGPUPipeline::instancesMutex());</span>
<span class="line-added">143         for (auto&amp; entry : WebGPUPipeline::instances(lock)) {</span>
<span class="line-added">144             if (entry.value == this) {</span>
<span class="line-added">145                 // Don&#39;t remove any WebGPUPipeline from the instances list, as they may still exist.</span>
<span class="line-added">146                 // Only remove the association with a WebGPU device.</span>
<span class="line-added">147                 entry.value = nullptr;</span>
<span class="line-added">148             }</span>
<span class="line-added">149         }</span>
<span class="line-added">150     }</span>
<span class="line-added">151 </span>
<span class="line-added">152     {</span>
<span class="line-added">153         LockHolder lock(instancesMutex());</span>
<span class="line-added">154         ASSERT(instances(lock).contains(this));</span>
<span class="line-added">155         instances(lock).remove(this);</span>
<span class="line-added">156     }</span>
157 }
158 
159 Ref&lt;WebGPUBuffer&gt; WebGPUDevice::createBuffer(const GPUBufferDescriptor&amp; descriptor) const
160 {
161     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createBuffer(): &quot;);
162 
163     auto buffer = m_device-&gt;tryCreateBuffer(descriptor, GPUBufferMappedOption::NotMapped, m_errorScopes);
164     return WebGPUBuffer::create(WTFMove(buffer), m_errorScopes);
165 }
166 
<span class="line-modified">167 Vector&lt;JSC::JSValue&gt; WebGPUDevice::createBufferMapped(JSC::JSGlobalObject&amp; lexicalGlobalObject, const GPUBufferDescriptor&amp; descriptor) const</span>
168 {
169     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createBufferMapped(): &quot;);
170 
171     JSC::JSValue wrappedArrayBuffer = JSC::jsNull();
172 
173     auto buffer = m_device-&gt;tryCreateBuffer(descriptor, GPUBufferMappedOption::IsMapped, m_errorScopes);
174     if (buffer) {
175         auto arrayBuffer = buffer-&gt;mapOnCreation();
<span class="line-modified">176         wrappedArrayBuffer = toJS(&amp;lexicalGlobalObject, JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), arrayBuffer);</span>
177     }
178 
179     auto webBuffer = WebGPUBuffer::create(WTFMove(buffer), m_errorScopes);
<span class="line-modified">180     auto wrappedWebBuffer = toJS(&amp;lexicalGlobalObject, JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), webBuffer);</span>
181 
182     return { wrappedWebBuffer, wrappedArrayBuffer };
183 }
184 
185 Ref&lt;WebGPUTexture&gt; WebGPUDevice::createTexture(const GPUTextureDescriptor&amp; descriptor) const
186 {
187     auto texture = m_device-&gt;tryCreateTexture(descriptor);
188     return WebGPUTexture::create(WTFMove(texture));
189 }
190 
191 Ref&lt;WebGPUSampler&gt; WebGPUDevice::createSampler(const GPUSamplerDescriptor&amp; descriptor) const
192 {
193     auto sampler = m_device-&gt;tryCreateSampler(descriptor);
194     return WebGPUSampler::create(WTFMove(sampler));
195 }
196 
197 Ref&lt;WebGPUBindGroupLayout&gt; WebGPUDevice::createBindGroupLayout(const GPUBindGroupLayoutDescriptor&amp; descriptor) const
198 {
199     auto layout = m_device-&gt;tryCreateBindGroupLayout(descriptor);
200     return WebGPUBindGroupLayout::create(WTFMove(layout));
</pre>
<hr />
<pre>
207         return WebGPUPipelineLayout::create(nullptr);
208 
209     auto layout = m_device-&gt;createPipelineLayout(WTFMove(*gpuDescriptor));
210     return WebGPUPipelineLayout::create(WTFMove(layout));
211 }
212 
213 Ref&lt;WebGPUBindGroup&gt; WebGPUDevice::createBindGroup(const WebGPUBindGroupDescriptor&amp; descriptor) const
214 {
215     auto gpuDescriptor = descriptor.tryCreateGPUBindGroupDescriptor();
216     if (!gpuDescriptor)
217         return WebGPUBindGroup::create(nullptr);
218 
219     auto bindGroup = m_device-&gt;tryCreateBindGroup(*gpuDescriptor, m_errorScopes);
220     return WebGPUBindGroup::create(WTFMove(bindGroup));
221 }
222 
223 Ref&lt;WebGPUShaderModule&gt; WebGPUDevice::createShaderModule(const WebGPUShaderModuleDescriptor&amp; descriptor) const
224 {
225     // FIXME: What can be validated here?
226     auto module = m_device-&gt;tryCreateShaderModule(GPUShaderModuleDescriptor { descriptor.code });
<span class="line-modified">227     return WebGPUShaderModule::create(WTFMove(module), descriptor.code);</span>
228 }
229 
<span class="line-modified">230 Ref&lt;WebGPURenderPipeline&gt; WebGPUDevice::createRenderPipeline(const WebGPURenderPipelineDescriptor&amp; descriptor)</span>
231 {
232     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createRenderPipeline(): &quot;);
233 
234     auto gpuDescriptor = descriptor.tryCreateGPURenderPipelineDescriptor(m_errorScopes);
235     if (!gpuDescriptor)
<span class="line-modified">236         return WebGPURenderPipeline::create(*this, nullptr, m_errorScopes, { }, { });</span>
237 
<span class="line-modified">238     auto gpuPipeline = m_device-&gt;tryCreateRenderPipeline(*gpuDescriptor, m_errorScopes);</span>
<span class="line-modified">239 </span>
<span class="line-added">240     WebGPUPipeline::ShaderData vertexShader = { descriptor.vertexStage.module, descriptor.vertexStage.entryPoint };</span>
<span class="line-added">241 </span>
<span class="line-added">242     WebGPUPipeline::ShaderData fragmentShader;</span>
<span class="line-added">243     if (descriptor.fragmentStage)</span>
<span class="line-added">244         fragmentShader = { descriptor.fragmentStage.value().module, descriptor.fragmentStage.value().entryPoint };</span>
<span class="line-added">245 </span>
<span class="line-added">246     auto webGPUPipeline = WebGPURenderPipeline::create(*this, WTFMove(gpuPipeline), m_errorScopes, WTFMove(vertexShader), WTFMove(fragmentShader));</span>
<span class="line-added">247     if (webGPUPipeline-&gt;isValid())</span>
<span class="line-added">248         InspectorInstrumentation::didCreateWebGPUPipeline(*this, webGPUPipeline.get());</span>
<span class="line-added">249     return webGPUPipeline;</span>
250 }
251 
<span class="line-modified">252 Ref&lt;WebGPUComputePipeline&gt; WebGPUDevice::createComputePipeline(const WebGPUComputePipelineDescriptor&amp; descriptor)</span>
253 {
254     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createComputePipeline(): &quot;);
255 
256     auto gpuDescriptor = descriptor.tryCreateGPUComputePipelineDescriptor(m_errorScopes);
257     if (!gpuDescriptor)
<span class="line-modified">258         return WebGPUComputePipeline::create(*this, nullptr, m_errorScopes, { });</span>
<span class="line-added">259 </span>
<span class="line-added">260     auto gpuPipeline = m_device-&gt;tryCreateComputePipeline(*gpuDescriptor, m_errorScopes);</span>
261 
<span class="line-modified">262     WebGPUPipeline::ShaderData computeShader = { descriptor.computeStage.module, descriptor.computeStage.entryPoint };</span>
<span class="line-modified">263 </span>
<span class="line-added">264     auto webGPUPipeline = WebGPUComputePipeline::create(*this, WTFMove(gpuPipeline), m_errorScopes, WTFMove(computeShader));</span>
<span class="line-added">265     if (webGPUPipeline-&gt;isValid())</span>
<span class="line-added">266         InspectorInstrumentation::didCreateWebGPUPipeline(*this, webGPUPipeline.get());</span>
<span class="line-added">267     return webGPUPipeline;</span>
268 }
269 
270 Ref&lt;WebGPUCommandEncoder&gt; WebGPUDevice::createCommandEncoder() const
271 {
272     auto commandBuffer = m_device-&gt;tryCreateCommandBuffer();
273     return WebGPUCommandEncoder::create(WTFMove(commandBuffer));
274 }
275 
276 Ref&lt;WebGPUQueue&gt; WebGPUDevice::getQueue() const
277 {
278     if (!m_queue)
279         m_queue = WebGPUQueue::create(m_device-&gt;tryGetQueue());
280 
281     return makeRef(*m_queue.get());
282 }
283 
284 void WebGPUDevice::popErrorScope(ErrorPromise&amp;&amp; promise)
285 {
286     String failMessage;
287     Optional&lt;GPUError&gt; error = m_errorScopes-&gt;popErrorScope(failMessage);
288     if (failMessage.isEmpty())
289         promise.resolve(error);
290     else
291         promise.reject(Exception { OperationError, &quot;GPUDevice::popErrorScope(): &quot; + failMessage });
292 }
293 
<span class="line-added">294 // Errors reported via the validation error event should also appear in the console as warnings.</span>
<span class="line-added">295 static void printValidationErrorToConsole(GPUError&amp; error, ScriptExecutionContext&amp; context)</span>
<span class="line-added">296 {</span>
<span class="line-added">297     if (!WTF::holds_alternative&lt;RefPtr&lt;GPUValidationError&gt;&gt;(error))</span>
<span class="line-added">298         return;</span>
<span class="line-added">299 </span>
<span class="line-added">300     auto validationError = WTF::get&lt;RefPtr&lt;GPUValidationError&gt;&gt;(error);</span>
<span class="line-added">301     if (!validationError)</span>
<span class="line-added">302         return;</span>
<span class="line-added">303 </span>
<span class="line-added">304     auto message = validationError-&gt;message();</span>
<span class="line-added">305     auto consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Warning, message);</span>
<span class="line-added">306 </span>
<span class="line-added">307     downcast&lt;Document&gt;(context).addConsoleMessage(WTFMove(consoleMessage));</span>
<span class="line-added">308 }</span>
<span class="line-added">309 </span>
<span class="line-added">310 void WebGPUDevice::dispatchUncapturedError(GPUError&amp;&amp; error)</span>
<span class="line-added">311 {</span>
<span class="line-added">312     printValidationErrorToConsole(error, m_scriptExecutionContext);</span>
<span class="line-added">313 </span>
<span class="line-added">314     callOnMainThread([error = WTFMove(error), this, protectedThis = makeRef(*this)] () mutable {</span>
<span class="line-added">315         dispatchEvent(GPUUncapturedErrorEvent::create(eventNames().uncapturederrorEvent, WTFMove(error)));</span>
<span class="line-added">316     });</span>
<span class="line-added">317 }</span>
<span class="line-added">318 </span>
319 } // namespace WebCore
320 
321 #endif // ENABLE(WEBGPU)
</pre>
</td>
</tr>
</table>
<center><a href="WebGPUComputePipelineDescriptor.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGPUDevice.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
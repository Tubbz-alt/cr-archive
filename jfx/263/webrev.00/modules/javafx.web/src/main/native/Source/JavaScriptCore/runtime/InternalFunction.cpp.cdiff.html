<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/InternalFunction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorInstrumentationObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InternalFunction.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/InternalFunction.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,35 ***</span>
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(InternalFunction);
  
  const ClassInfo InternalFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(InternalFunction) };
  
  InternalFunction::InternalFunction(VM&amp; vm, Structure* structure, NativeFunction functionForCall, NativeFunction functionForConstruct)
<span class="line-modified">!     : JSDestructibleObject(vm, structure)</span>
      , m_functionForCall(functionForCall)
      , m_functionForConstruct(functionForConstruct ? functionForConstruct : callHostFunctionAsConstructor)
  {
<span class="line-removed">-     // exec-&gt;vm() wants callees to not be large allocations.</span>
<span class="line-removed">-     RELEASE_ASSERT(!isLargeAllocation());</span>
      ASSERT_WITH_MESSAGE(m_functionForCall, &quot;[[Call]] must be implemented&quot;);
      ASSERT(m_functionForConstruct);
  }
  
<span class="line-modified">! void InternalFunction::finishCreation(VM&amp; vm, const String&amp; name, NameVisibility nameVisibility, NameAdditionMode nameAdditionMode)</span>
  {
      Base::finishCreation(vm);
      ASSERT(jsDynamicCast&lt;InternalFunction*&gt;(vm, this));
      ASSERT(methodTable(vm)-&gt;getCallData == InternalFunction::info()-&gt;methodTable.getCallData);
      ASSERT(methodTable(vm)-&gt;getConstructData == InternalFunction::info()-&gt;methodTable.getConstructData);
      ASSERT(type() == InternalFunctionType);
      JSString* nameString = jsString(vm, name);
      m_originalName.set(vm, this, nameString);
<span class="line-modified">!     if (nameVisibility == NameVisibility::Visible) {</span>
<span class="line-modified">!         if (nameAdditionMode == NameAdditionMode::WithStructureTransition)</span>
<span class="line-modified">!             putDirect(vm, vm.propertyNames-&gt;name, nameString, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);</span>
<span class="line-modified">!         else</span>
<span class="line-removed">-             putDirectWithoutTransition(vm, vm.propertyNames-&gt;name, nameString, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);</span>
<span class="line-removed">-     }</span>
  }
  
  void InternalFunction::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
  {
      InternalFunction* thisObject = jsCast&lt;InternalFunction*&gt;(cell);
<span class="line-new-header">--- 33,32 ---</span>
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(InternalFunction);
  
  const ClassInfo InternalFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(InternalFunction) };
  
  InternalFunction::InternalFunction(VM&amp; vm, Structure* structure, NativeFunction functionForCall, NativeFunction functionForConstruct)
<span class="line-modified">!     : Base(vm, structure)</span>
      , m_functionForCall(functionForCall)
      , m_functionForConstruct(functionForConstruct ? functionForConstruct : callHostFunctionAsConstructor)
<span class="line-added">+     , m_globalObject(vm, this, structure-&gt;globalObject())</span>
  {
      ASSERT_WITH_MESSAGE(m_functionForCall, &quot;[[Call]] must be implemented&quot;);
      ASSERT(m_functionForConstruct);
  }
  
<span class="line-modified">! void InternalFunction::finishCreation(VM&amp; vm, const String&amp; name, NameAdditionMode nameAdditionMode)</span>
  {
      Base::finishCreation(vm);
      ASSERT(jsDynamicCast&lt;InternalFunction*&gt;(vm, this));
      ASSERT(methodTable(vm)-&gt;getCallData == InternalFunction::info()-&gt;methodTable.getCallData);
      ASSERT(methodTable(vm)-&gt;getConstructData == InternalFunction::info()-&gt;methodTable.getConstructData);
      ASSERT(type() == InternalFunctionType);
      JSString* nameString = jsString(vm, name);
      m_originalName.set(vm, this, nameString);
<span class="line-modified">!     if (nameAdditionMode == NameAdditionMode::WithStructureTransition)</span>
<span class="line-modified">!         putDirect(vm, vm.propertyNames-&gt;name, nameString, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!         putDirectWithoutTransition(vm, vm.propertyNames-&gt;name, nameString, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);</span>
  }
  
  void InternalFunction::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
  {
      InternalFunction* thisObject = jsCast&lt;InternalFunction*&gt;(cell);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,40 ***</span>
          return explicitName;
  
      return name();
  }
  
<span class="line-modified">! Structure* InternalFunction::createSubclassStructureSlow(ExecState* exec, JSValue newTarget, Structure* baseClass)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-removed">-     ASSERT(!newTarget || newTarget.isConstructor(vm));</span>
<span class="line-removed">-     ASSERT(newTarget &amp;&amp; newTarget != exec-&gt;jsCallee());</span>
  
      ASSERT(baseClass-&gt;hasMonoProto());
  
      // newTarget may be an InternalFunction if we were called from Reflect.construct.
      JSFunction* targetFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, newTarget);
<span class="line-modified">!     JSGlobalObject* lexicalGlobalObject = exec-&gt;lexicalGlobalObject();</span>
  
      if (LIKELY(targetFunction)) {
<span class="line-modified">!         Structure* structure = targetFunction-&gt;rareData(vm)-&gt;internalFunctionAllocationStructure();</span>
<span class="line-modified">!         if (LIKELY(structure &amp;&amp; structure-&gt;classInfo() == baseClass-&gt;classInfo()))</span>
              return structure;
  
          // Note, Reflect.construct might cause the profile to churn but we don&#39;t care.
<span class="line-modified">!         JSValue prototypeValue = newTarget.get(exec, vm.propertyNames-&gt;prototype);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
          if (JSObject* prototype = jsDynamicCast&lt;JSObject*&gt;(vm, prototypeValue))
<span class="line-modified">!             return targetFunction-&gt;rareData(vm)-&gt;createInternalFunctionAllocationStructureFromBase(vm, lexicalGlobalObject, prototype, baseClass);</span>
      } else {
<span class="line-modified">!         JSValue prototypeValue = newTarget.get(exec, vm.propertyNames-&gt;prototype);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
          if (JSObject* prototype = jsDynamicCast&lt;JSObject*&gt;(vm, prototypeValue)) {
              // This only happens if someone Reflect.constructs our builtin constructor with another builtin constructor as the new.target.
              // Thus, we don&#39;t care about the cost of looking up the structure from our hash table every time.
<span class="line-modified">!             return vm.structureCache.emptyStructureForPrototypeFromBaseStructure(lexicalGlobalObject, prototype, baseClass);</span>
          }
      }
  
      return baseClass;
  }
<span class="line-new-header">--- 110,39 ---</span>
          return explicitName;
  
      return name();
  }
  
<span class="line-modified">! Structure* InternalFunction::createSubclassStructureSlow(JSGlobalObject* globalObject, JSValue newTarget, Structure* baseClass)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(baseClass-&gt;hasMonoProto());
  
      // newTarget may be an InternalFunction if we were called from Reflect.construct.
      JSFunction* targetFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, newTarget);
<span class="line-modified">!     JSGlobalObject* baseGlobalObject = baseClass-&gt;globalObject();</span>
  
      if (LIKELY(targetFunction)) {
<span class="line-modified">!         FunctionRareData* rareData = targetFunction-&gt;ensureRareData(vm);</span>
<span class="line-modified">!         Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="line-added">+         if (LIKELY(structure &amp;&amp; structure-&gt;classInfo() == baseClass-&gt;classInfo() &amp;&amp; structure-&gt;globalObject() == baseGlobalObject))</span>
              return structure;
  
          // Note, Reflect.construct might cause the profile to churn but we don&#39;t care.
<span class="line-modified">!         JSValue prototypeValue = targetFunction-&gt;get(globalObject, vm.propertyNames-&gt;prototype);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
          if (JSObject* prototype = jsDynamicCast&lt;JSObject*&gt;(vm, prototypeValue))
<span class="line-modified">!             return rareData-&gt;createInternalFunctionAllocationStructureFromBase(vm, baseGlobalObject, prototype, baseClass);</span>
      } else {
<span class="line-modified">!         JSValue prototypeValue = newTarget.get(globalObject, vm.propertyNames-&gt;prototype);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
          if (JSObject* prototype = jsDynamicCast&lt;JSObject*&gt;(vm, prototypeValue)) {
              // This only happens if someone Reflect.constructs our builtin constructor with another builtin constructor as the new.target.
              // Thus, we don&#39;t care about the cost of looking up the structure from our hash table every time.
<span class="line-modified">!             return vm.structureCache.emptyStructureForPrototypeFromBaseStructure(baseGlobalObject, prototype, baseClass);</span>
          }
      }
  
      return baseClass;
  }
</pre>
<center><a href="InspectorInstrumentationObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InternalFunction.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
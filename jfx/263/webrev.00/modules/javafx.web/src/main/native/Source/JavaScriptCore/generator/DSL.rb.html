<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/generator/DSL.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 # Copyright (C) 2018 Apple Inc. All rights reserved.
  2 #
  3 # Redistribution and use in source and binary forms, with or without
  4 # modification, are permitted provided that the following conditions
  5 # are met:
  6 # 1. Redistributions of source code must retain the above copyright
  7 #    notice, this list of conditions and the following disclaimer.
  8 # 2. Redistributions in binary form must reproduce the above copyright
  9 #    notice, this list of conditions and the following disclaimer in the
 10 #    documentation and/or other materials provided with the distribution.
 11 #
 12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 22 # THE POSSIBILITY OF SUCH DAMAGE.
 23 
 24 require_relative &#39;Assertion&#39;
 25 require_relative &#39;GeneratedFile&#39;
 26 require_relative &#39;Section&#39;
 27 require_relative &#39;Template&#39;
 28 require_relative &#39;Type&#39;
 29 require_relative &#39;Wasm&#39;
 30 
 31 module DSL
 32     @sections = []
 33     @wasm_section = nil
 34     @current_section = nil
 35     @context = binding()
 36     @namespaces = []
 37 
 38     def self.begin_section(name, config={})
 39         assert(&quot;must call `end_section` before beginning a new section&quot;) { @current_section.nil? }
 40         @current_section = Section.new name, config
 41     end
 42 
 43     def self.end_section(name)
 44         assert(&quot;current section&#39;s name is `#{@current_section.name}`, but end_section was called with `#{name}`&quot;) { @current_section.name == name }
 45         @current_section.sort!
 46         @sections &lt;&lt; @current_section
 47         if @current_section.is_wasm?
 48           assert(&quot;Cannot have 2 wasm sections&quot;) { @wasm_section.nil? }
 49           @wasm_section = @current_section
 50         end
 51         @current_section = nil
 52     end
 53 
 54     def self.op(name, config = {})
 55         assert(&quot;`op` can only be called in between `begin_section` and `end_section`&quot;) { not @current_section.nil? }
 56         @current_section.add_opcode(name, config)
 57     end
 58 
 59     def self.op_group(desc, ops, config)
 60         assert(&quot;`op_group` can only be called in between `begin_section` and `end_section`&quot;) { not @current_section.nil? }
 61         @current_section.add_opcode_group(desc, ops, config)
 62     end
 63 
 64     def self.types(types)
 65         types.map do |type|
 66             type = (@namespaces + [type]).join &quot;::&quot;
 67             @context.eval(&quot;#{type} = Type.new &#39;#{type}&#39;&quot;)
 68         end
 69     end
 70 
 71     def self.templates(types)
 72         types.map do |type|
 73             type = (@namespaces + [type]).join &quot;::&quot;
 74             @context.eval(&quot;#{type} = Template.new &#39;#{type}&#39;&quot;)
 75         end
 76     end
 77 
 78     def self.namespace(name)
 79         @namespaces &lt;&lt; name.to_s
 80         ctx = @context
 81         @context = @context.eval(&quot;
 82             module #{name}
 83               def self.get_binding
 84                 binding()
 85               end
 86             end
 87             #{name}.get_binding
 88          &quot;)
 89         yield
 90         @context = ctx
 91         @namespaces.pop
 92     end
 93 
 94     def self.autogenerate_wasm_opcodes()
 95         assert(&quot;`autogenerate_wasm_opcodes` can only be called in between `begin_section` and `end_section`&quot;) { not @current_section.nil? }
 96         assert(&quot;`autogenerate_wasm_opcodes` can only be called from the `Wasm` section&quot;) { @current_section.name == :Wasm }
 97         Wasm::autogenerate_opcodes(@context, @wasm_json)
 98     end
 99 
100     def self.run(options)
101         bytecode_list_path = options[:bytecode_list]
102         bytecode_list = File.open(bytecode_list_path).read
103 
104         @wasm_json = File.open(options[:wasm_json_filename]).read
105 
106         @context.eval(bytecode_list, bytecode_list_path)
107         assert(&quot;must end last section&quot;) { @current_section.nil? }
108 
109         write_bytecodes(bytecode_list, options[:bytecodes_filename])
110         write_bytecode_structs(bytecode_list, options[:bytecode_structs_filename])
111         write_bytecode_dumper(bytecode_list, options[:bytecode_dumper_filename])
112         write_bytecodes_init(options[:init_asm_filename], bytecode_list)
113         write_indices(bytecode_list, options[:bytecode_indices_filename])
114         write_llint_generator(options[:wasm_llint_generator_filename], bytecode_list, @wasm_json)
115         write_wasm_init(options[:wasm_init_filename], bytecode_list, @wasm_json)
116     end
117 
118     def self.write_bytecodes(bytecode_list, bytecodes_filename)
119         GeneratedFile::create(bytecodes_filename, bytecode_list) do |template|
120             template.prefix = &quot;#pragma once\n&quot;
121             num_opcodes = @sections.map(&amp;:opcodes).flatten.size
122             template.body = [
123                 @sections.map { |s| s.header_helpers(num_opcodes) },
124                 @sections.select { |s| s.config[:emit_in_structs_file] }.map(&amp;:for_each_struct)
125             ].flatten.join(&quot;\n&quot;)
126         end
127     end
128 
129     def self.write_bytecode_structs(bytecode_list, bytecode_structs_filename)
130         GeneratedFile::create(bytecode_structs_filename, bytecode_list) do |template|
131             template.prefix = &lt;&lt;-EOF
132 #pragma once
133 
134 #include &quot;ArithProfile.h&quot;
135 #include &quot;BytecodeDumper.h&quot;
136 #include &quot;Fits.h&quot;
137 #include &quot;GetByIdMetadata.h&quot;
138 #include &quot;GetByValHistory.h&quot;
139 #include &quot;Instruction.h&quot;
140 #include &quot;Opcode.h&quot;
141 #include &quot;PutByIdStatus.h&quot;
142 #include &quot;PutByIdFlags.h&quot;
143 #include &quot;ToThisStatus.h&quot;
144 
145 namespace JSC {
146 
147 void dumpBytecode(BytecodeDumperBase* dumper, InstructionStream::Offset, const Instruction*);
148 
149 #if ENABLE(WEBASSEMBLY)
150 void dumpWasm(BytecodeDumperBase* dumper, InstructionStream::Offset, const Instruction*);
151 #endif // ENABLE(WEBASSEMBLY)
152 
153 EOF
154 
155             template.body = &lt;&lt;-EOF
156 #{opcodes_filter { |s| s.config[:emit_in_structs_file] &amp;&amp; !s.is_wasm? }.map(&amp;:struct).join(&quot;\n&quot;)}
157 
158 #if ENABLE(WEBASSEMBLY)
159 #{opcodes_filter { |s| s.config[:emit_in_structs_file] &amp;&amp; s.is_wasm? }.map(&amp;:struct).join(&quot;\n&quot;)}
160 #endif // ENABLE(WEBASSEMBLY)
161 EOF
162             template.suffix = &quot;} // namespace JSC&quot;
163         end
164     end
165 
166     def self.write_bytecode_dumper(bytecode_list, bytecode_dumper_filename)
167         GeneratedFile::create(bytecode_dumper_filename, bytecode_list) do |template|
168             template.prefix = &lt;&lt;-EOF
169 #include &quot;config.h&quot;
170 #include &quot;BytecodeDumper.h&quot;
171 
172 #include &quot;BytecodeStructs.h&quot;
173 
174 namespace JSC {
175 EOF
176 
177             template.body = &lt;&lt;-EOF
178 #{Opcode.dump_bytecode(:Bytecode, :JSOpcodeTraits, opcodes_filter { |s| s.config[:emit_in_structs_file] &amp;&amp; !s.is_wasm? })}
179 
180 #if ENABLE(WEBASSEMBLY)
181 #{Opcode.dump_bytecode(:Wasm, :WasmOpcodeTraits, opcodes_filter { |s| s.is_wasm? })}
182 #endif // ENABLE(WEBASSEMBLY)
183 EOF
184             template.suffix = &quot;} // namespace JSC&quot;
185         end
186     end
187 
188     def self.write_init_asm(opcodes, filename, *dependencies)
189         GeneratedFile::create(filename, *dependencies) do |template|
190             template.multiline_comment = nil
191             template.line_comment = &quot;#&quot;
192             template.body = (opcodes.map.with_index(&amp;:set_entry_address) + opcodes.map.with_index(&amp;:set_entry_address_wide16) + opcodes.map.with_index(&amp;:set_entry_address_wide32)) .join(&quot;\n&quot;)
193         end
194     end
195 
196     def self.write_bytecodes_init(bytecodes_init_filename, *dependencies)
197         write_init_asm(opcodes_for(:emit_in_asm_file), bytecodes_init_filename, *dependencies)
198     end
199 
200     def self.write_wasm_init(wasm_init_filename, *dependencies)
201         write_init_asm(@wasm_section.opcodes, wasm_init_filename, *dependencies)
202     end
203 
204     def self.write_llint_generator(generator_filename, *dependencies)
205         GeneratedFile::create(generator_filename, *dependencies) do |template|
206             template.body = Wasm::generate_llint_generator(@wasm_section)
207         end
208     end
209 
210     def self.write_indices(bytecode_list, indices_filename)
211         opcodes = opcodes_for(:emit_in_structs_file)
212 
213         GeneratedFile::create(indices_filename, bytecode_list) do |template|
214             template.prefix = &quot;namespace JSC {\n&quot;
215             template.body = opcodes.map(&amp;:struct_indices).join(&quot;\n&quot;)
216             template.suffix = &quot;\n} // namespace JSC&quot;
217         end
218     end
219 
220     def self.opcodes_for(file)
221         sections = @sections.select { |s| s.config[file] }
222         sections.map(&amp;:opcodes).flatten
223     end
224 
225     def self.opcodes_filter
226         sections = @sections.select { |s| yield s }
227         sections.map(&amp;:opcodes).flatten
228     end
229 end
    </pre>
  </body>
</html>
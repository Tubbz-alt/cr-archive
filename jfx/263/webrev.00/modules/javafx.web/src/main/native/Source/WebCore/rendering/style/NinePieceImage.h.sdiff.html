<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/style/NinePieceImage.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NinePieceImage.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderStyle.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/style/NinePieceImage.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #pragma once
 25 
 26 #include &quot;DataRef.h&quot;
 27 #include &quot;LengthBox.h&quot;
 28 #include &quot;StyleImage.h&quot;
 29 #include &lt;wtf/Vector.h&gt;
 30 
 31 namespace WebCore {
 32 
 33 class LayoutSize;
 34 class LayoutRect;
 35 class RenderStyle;
 36 
<span class="line-modified"> 37 enum ENinePieceImageRule { StretchImageRule, RoundImageRule, SpaceImageRule, RepeatImageRule };</span>





 38 

 39 enum ImagePiece {
 40     MinPiece = 0,
 41     TopLeftPiece = MinPiece,
 42     LeftPiece,
 43     BottomLeftPiece,
 44     TopRightPiece,
 45     RightPiece,
 46     BottomRightPiece,
 47     TopPiece,
 48     BottomPiece,
 49     MiddlePiece,
 50     MaxPiece
 51 };
 52 
 53 inline ImagePiece&amp; operator++(ImagePiece&amp; piece)
 54 {
 55     piece = static_cast&lt;ImagePiece&gt;(static_cast&lt;int&gt;(piece) + 1);
 56     return piece;
 57 }
 58 
</pre>
<hr />
<pre>
 83 
 84     if (piece == BottomLeftPiece || piece == BottomPiece || piece == BottomRightPiece)
 85         return PhysicalBoxSide::Bottom;
 86 
 87     return WTF::nullopt;
 88 }
 89 
 90 inline Optional&lt;PhysicalBoxSide&gt; imagePieceVerticalSide(ImagePiece piece)
 91 {
 92     if (piece == TopLeftPiece || piece == LeftPiece || piece == BottomLeftPiece)
 93         return PhysicalBoxSide::Left;
 94 
 95     if (piece == TopRightPiece || piece == RightPiece || piece == BottomRightPiece)
 96         return PhysicalBoxSide::Right;
 97 
 98     return WTF::nullopt;
 99 }
100 
101 class NinePieceImage {
102 public:
<span class="line-modified">103     NinePieceImage();</span>
<span class="line-modified">104     NinePieceImage(RefPtr&lt;StyleImage&gt;&amp;&amp;, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, ENinePieceImageRule horizontalRule, ENinePieceImageRule verticalRule);</span>





105 
106     bool operator==(const NinePieceImage&amp; other) const { return m_data == other.m_data; }
107     bool operator!=(const NinePieceImage&amp; other) const { return m_data != other.m_data; }
108 
109     bool hasImage() const { return m_data-&gt;image; }
110     StyleImage* image() const { return m_data-&gt;image.get(); }
111     void setImage(RefPtr&lt;StyleImage&gt;&amp;&amp; image) { m_data.access().image = WTFMove(image); }
112 
113     const LengthBox&amp; imageSlices() const { return m_data-&gt;imageSlices; }
114     void setImageSlices(LengthBox slices) { m_data.access().imageSlices = WTFMove(slices); }
115 
116     bool fill() const { return m_data-&gt;fill; }
117     void setFill(bool fill) { m_data.access().fill = fill; }
118 
119     const LengthBox&amp; borderSlices() const { return m_data-&gt;borderSlices; }
120     void setBorderSlices(LengthBox slices) { m_data.access().borderSlices = WTFMove(slices); }
121 
122     const LengthBox&amp; outset() const { return m_data-&gt;outset; }
123     void setOutset(LengthBox outset) { m_data.access().outset = WTFMove(outset); }
124 
<span class="line-modified">125     ENinePieceImageRule horizontalRule() const { return static_cast&lt;ENinePieceImageRule&gt;(m_data-&gt;horizontalRule); }</span>
<span class="line-modified">126     void setHorizontalRule(ENinePieceImageRule rule) { m_data.access().horizontalRule = rule; }</span>
127 
<span class="line-modified">128     ENinePieceImageRule verticalRule() const { return static_cast&lt;ENinePieceImageRule&gt;(m_data-&gt;verticalRule); }</span>
<span class="line-modified">129     void setVerticalRule(ENinePieceImageRule rule) { m_data.access().verticalRule = rule; }</span>
130 
131     void copyImageSlicesFrom(const NinePieceImage&amp; other)
132     {
133         m_data.access().imageSlices = other.m_data-&gt;imageSlices;
134         m_data.access().fill = other.m_data-&gt;fill;
135     }
136 
137     void copyBorderSlicesFrom(const NinePieceImage&amp; other)
138     {
139         m_data.access().borderSlices = other.m_data-&gt;borderSlices;
140     }
141 
142     void copyOutsetFrom(const NinePieceImage&amp; other)
143     {
144         m_data.access().outset = other.m_data-&gt;outset;
145     }
146 
147     void copyRepeatFrom(const NinePieceImage&amp; other)
148     {
149         m_data.access().horizontalRule = other.m_data-&gt;horizontalRule;
150         m_data.access().verticalRule = other.m_data-&gt;verticalRule;
151     }
152 
<span class="line-removed">153     void setMaskDefaults()</span>
<span class="line-removed">154     {</span>
<span class="line-removed">155         m_data.access().imageSlices = LengthBox(0);</span>
<span class="line-removed">156         m_data.access().fill = true;</span>
<span class="line-removed">157         m_data.access().borderSlices = LengthBox();</span>
<span class="line-removed">158     }</span>
<span class="line-removed">159 </span>
160     static LayoutUnit computeOutset(const Length&amp; outsetSide, LayoutUnit borderSide)
161     {
162         if (outsetSide.isRelative())
163             return LayoutUnit(outsetSide.value() * borderSide);
164         return LayoutUnit(outsetSide.value());
165     }
166 
167     static LayoutUnit computeSlice(Length, LayoutUnit width, LayoutUnit slice, LayoutUnit extent);
168     static LayoutBoxExtent computeSlices(const LayoutSize&amp;, const LengthBox&amp; lengths, int scaleFactor);
169     static LayoutBoxExtent computeSlices(const LayoutSize&amp;, const LengthBox&amp; lengths, const FloatBoxExtent&amp; widths, const LayoutBoxExtent&amp; slices);
170 
171     static bool isEmptyPieceRect(ImagePiece, const LayoutBoxExtent&amp; slices);
172     static bool isEmptyPieceRect(ImagePiece, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects);
173 
174     static Vector&lt;FloatRect&gt; computeNineRects(const FloatRect&amp; outer, const LayoutBoxExtent&amp; slices, float deviceScaleFactor);
175 
176     static void scaleSlicesIfNeeded(const LayoutSize&amp;, LayoutBoxExtent&amp; slices, float deviceScaleFactor);
177 
178     static FloatSize computeSideTileScale(ImagePiece, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects);
<span class="line-modified">179     static FloatSize computeMiddleTileScale(const Vector&lt;FloatSize&gt;&amp; scales, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects, ENinePieceImageRule hRule, ENinePieceImageRule vRule);</span>
<span class="line-modified">180     static Vector&lt;FloatSize&gt; computeTileScales(const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects, ENinePieceImageRule hRule, ENinePieceImageRule vRule);</span>
181 
182     void paint(GraphicsContext&amp;, RenderElement*, const RenderStyle&amp;, const LayoutRect&amp; destination, const LayoutSize&amp; source, float deviceScaleFactor, CompositeOperator) const;
183 
184 private:
185     struct Data : RefCounted&lt;Data&gt; {
186         static Ref&lt;Data&gt; create();
<span class="line-modified">187         static Ref&lt;Data&gt; create(RefPtr&lt;StyleImage&gt;&amp;&amp;, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, ENinePieceImageRule horizontalRule, ENinePieceImageRule verticalRule);</span>
188         Ref&lt;Data&gt; copy() const;
189 
190         bool operator==(const Data&amp;) const;
191         bool operator!=(const Data&amp; other) const { return !(*this == other); }
192 
<span class="line-modified">193         bool fill : 1;</span>
<span class="line-modified">194         unsigned horizontalRule : 2; // ENinePieceImageRule</span>
<span class="line-modified">195         unsigned verticalRule : 2; // ENinePieceImageRule</span>
196         RefPtr&lt;StyleImage&gt; image;
197         LengthBox imageSlices { { 100, Percent }, { 100, Percent }, { 100, Percent }, { 100, Percent } };
198         LengthBox borderSlices { { 1, Relative }, { 1, Relative }, { 1, Relative }, { 1, Relative } };
199         LengthBox outset { 0 };
200 
201     private:
202         Data();
<span class="line-modified">203         Data(RefPtr&lt;StyleImage&gt;&amp;&amp;, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, ENinePieceImageRule horizontalRule, ENinePieceImageRule verticalRule);</span>
204         Data(const Data&amp;);
205     };
206 
207     static DataRef&lt;Data&gt;&amp; defaultData();

208 
209     DataRef&lt;Data&gt; m_data;
210 };
211 
212 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const NinePieceImage&amp;);
213 
214 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #pragma once
 25 
 26 #include &quot;DataRef.h&quot;
 27 #include &quot;LengthBox.h&quot;
 28 #include &quot;StyleImage.h&quot;
 29 #include &lt;wtf/Vector.h&gt;
 30 
 31 namespace WebCore {
 32 
 33 class LayoutSize;
 34 class LayoutRect;
 35 class RenderStyle;
 36 
<span class="line-modified"> 37 enum class NinePieceImageRule : uint8_t {</span>
<span class="line-added"> 38     Stretch,</span>
<span class="line-added"> 39     Round,</span>
<span class="line-added"> 40     Space,</span>
<span class="line-added"> 41     Repeat,</span>
<span class="line-added"> 42 };</span>
 43 
<span class="line-added"> 44 // Used for array indexing, so not an enum class.</span>
 45 enum ImagePiece {
 46     MinPiece = 0,
 47     TopLeftPiece = MinPiece,
 48     LeftPiece,
 49     BottomLeftPiece,
 50     TopRightPiece,
 51     RightPiece,
 52     BottomRightPiece,
 53     TopPiece,
 54     BottomPiece,
 55     MiddlePiece,
 56     MaxPiece
 57 };
 58 
 59 inline ImagePiece&amp; operator++(ImagePiece&amp; piece)
 60 {
 61     piece = static_cast&lt;ImagePiece&gt;(static_cast&lt;int&gt;(piece) + 1);
 62     return piece;
 63 }
 64 
</pre>
<hr />
<pre>
 89 
 90     if (piece == BottomLeftPiece || piece == BottomPiece || piece == BottomRightPiece)
 91         return PhysicalBoxSide::Bottom;
 92 
 93     return WTF::nullopt;
 94 }
 95 
 96 inline Optional&lt;PhysicalBoxSide&gt; imagePieceVerticalSide(ImagePiece piece)
 97 {
 98     if (piece == TopLeftPiece || piece == LeftPiece || piece == BottomLeftPiece)
 99         return PhysicalBoxSide::Left;
100 
101     if (piece == TopRightPiece || piece == RightPiece || piece == BottomRightPiece)
102         return PhysicalBoxSide::Right;
103 
104     return WTF::nullopt;
105 }
106 
107 class NinePieceImage {
108 public:
<span class="line-modified">109     enum class Type {</span>
<span class="line-modified">110         Normal,</span>
<span class="line-added">111         Mask</span>
<span class="line-added">112     };</span>
<span class="line-added">113 </span>
<span class="line-added">114     NinePieceImage(Type = Type::Normal);</span>
<span class="line-added">115     NinePieceImage(RefPtr&lt;StyleImage&gt;&amp;&amp;, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, NinePieceImageRule horizontalRule, NinePieceImageRule verticalRule);</span>
116 
117     bool operator==(const NinePieceImage&amp; other) const { return m_data == other.m_data; }
118     bool operator!=(const NinePieceImage&amp; other) const { return m_data != other.m_data; }
119 
120     bool hasImage() const { return m_data-&gt;image; }
121     StyleImage* image() const { return m_data-&gt;image.get(); }
122     void setImage(RefPtr&lt;StyleImage&gt;&amp;&amp; image) { m_data.access().image = WTFMove(image); }
123 
124     const LengthBox&amp; imageSlices() const { return m_data-&gt;imageSlices; }
125     void setImageSlices(LengthBox slices) { m_data.access().imageSlices = WTFMove(slices); }
126 
127     bool fill() const { return m_data-&gt;fill; }
128     void setFill(bool fill) { m_data.access().fill = fill; }
129 
130     const LengthBox&amp; borderSlices() const { return m_data-&gt;borderSlices; }
131     void setBorderSlices(LengthBox slices) { m_data.access().borderSlices = WTFMove(slices); }
132 
133     const LengthBox&amp; outset() const { return m_data-&gt;outset; }
134     void setOutset(LengthBox outset) { m_data.access().outset = WTFMove(outset); }
135 
<span class="line-modified">136     NinePieceImageRule horizontalRule() const { return m_data-&gt;horizontalRule; }</span>
<span class="line-modified">137     void setHorizontalRule(NinePieceImageRule rule) { m_data.access().horizontalRule = rule; }</span>
138 
<span class="line-modified">139     NinePieceImageRule verticalRule() const { return m_data-&gt;verticalRule; }</span>
<span class="line-modified">140     void setVerticalRule(NinePieceImageRule rule) { m_data.access().verticalRule = rule; }</span>
141 
142     void copyImageSlicesFrom(const NinePieceImage&amp; other)
143     {
144         m_data.access().imageSlices = other.m_data-&gt;imageSlices;
145         m_data.access().fill = other.m_data-&gt;fill;
146     }
147 
148     void copyBorderSlicesFrom(const NinePieceImage&amp; other)
149     {
150         m_data.access().borderSlices = other.m_data-&gt;borderSlices;
151     }
152 
153     void copyOutsetFrom(const NinePieceImage&amp; other)
154     {
155         m_data.access().outset = other.m_data-&gt;outset;
156     }
157 
158     void copyRepeatFrom(const NinePieceImage&amp; other)
159     {
160         m_data.access().horizontalRule = other.m_data-&gt;horizontalRule;
161         m_data.access().verticalRule = other.m_data-&gt;verticalRule;
162     }
163 







164     static LayoutUnit computeOutset(const Length&amp; outsetSide, LayoutUnit borderSide)
165     {
166         if (outsetSide.isRelative())
167             return LayoutUnit(outsetSide.value() * borderSide);
168         return LayoutUnit(outsetSide.value());
169     }
170 
171     static LayoutUnit computeSlice(Length, LayoutUnit width, LayoutUnit slice, LayoutUnit extent);
172     static LayoutBoxExtent computeSlices(const LayoutSize&amp;, const LengthBox&amp; lengths, int scaleFactor);
173     static LayoutBoxExtent computeSlices(const LayoutSize&amp;, const LengthBox&amp; lengths, const FloatBoxExtent&amp; widths, const LayoutBoxExtent&amp; slices);
174 
175     static bool isEmptyPieceRect(ImagePiece, const LayoutBoxExtent&amp; slices);
176     static bool isEmptyPieceRect(ImagePiece, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects);
177 
178     static Vector&lt;FloatRect&gt; computeNineRects(const FloatRect&amp; outer, const LayoutBoxExtent&amp; slices, float deviceScaleFactor);
179 
180     static void scaleSlicesIfNeeded(const LayoutSize&amp;, LayoutBoxExtent&amp; slices, float deviceScaleFactor);
181 
182     static FloatSize computeSideTileScale(ImagePiece, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects);
<span class="line-modified">183     static FloatSize computeMiddleTileScale(const Vector&lt;FloatSize&gt;&amp; scales, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects, NinePieceImageRule hRule, NinePieceImageRule vRule);</span>
<span class="line-modified">184     static Vector&lt;FloatSize&gt; computeTileScales(const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects, NinePieceImageRule hRule, NinePieceImageRule vRule);</span>
185 
186     void paint(GraphicsContext&amp;, RenderElement*, const RenderStyle&amp;, const LayoutRect&amp; destination, const LayoutSize&amp; source, float deviceScaleFactor, CompositeOperator) const;
187 
188 private:
189     struct Data : RefCounted&lt;Data&gt; {
190         static Ref&lt;Data&gt; create();
<span class="line-modified">191         static Ref&lt;Data&gt; create(RefPtr&lt;StyleImage&gt;&amp;&amp;, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, NinePieceImageRule horizontalRule, NinePieceImageRule verticalRule);</span>
192         Ref&lt;Data&gt; copy() const;
193 
194         bool operator==(const Data&amp;) const;
195         bool operator!=(const Data&amp; other) const { return !(*this == other); }
196 
<span class="line-modified">197         bool fill { false };</span>
<span class="line-modified">198         NinePieceImageRule horizontalRule { NinePieceImageRule::Stretch };</span>
<span class="line-modified">199         NinePieceImageRule verticalRule { NinePieceImageRule::Stretch };</span>
200         RefPtr&lt;StyleImage&gt; image;
201         LengthBox imageSlices { { 100, Percent }, { 100, Percent }, { 100, Percent }, { 100, Percent } };
202         LengthBox borderSlices { { 1, Relative }, { 1, Relative }, { 1, Relative }, { 1, Relative } };
203         LengthBox outset { 0 };
204 
205     private:
206         Data();
<span class="line-modified">207         Data(RefPtr&lt;StyleImage&gt;&amp;&amp;, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, NinePieceImageRule horizontalRule, NinePieceImageRule verticalRule);</span>
208         Data(const Data&amp;);
209     };
210 
211     static DataRef&lt;Data&gt;&amp; defaultData();
<span class="line-added">212     static DataRef&lt;Data&gt;&amp; defaultMaskData();</span>
213 
214     DataRef&lt;Data&gt; m_data;
215 };
216 
217 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const NinePieceImage&amp;);
218 
219 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="NinePieceImage.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderStyle.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
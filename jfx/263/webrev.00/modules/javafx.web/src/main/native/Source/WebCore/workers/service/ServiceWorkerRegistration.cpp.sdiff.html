<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerRegistration.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServiceWorkerProvider.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerRegistration.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerRegistration.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerRegistration.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 #include &quot;DOMWindow.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventNames.h&quot;

 34 #include &quot;Logging.h&quot;
 35 #include &quot;ServiceWorker.h&quot;
 36 #include &quot;ServiceWorkerContainer.h&quot;
 37 #include &quot;ServiceWorkerTypes.h&quot;
 38 #include &quot;WorkerGlobalScope.h&quot;
 39 #include &lt;wtf/IsoMallocInlines.h&gt;
 40 
 41 #define REGISTRATION_RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(m_container-&gt;isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerRegistration::&quot; fmt, this, ##__VA_ARGS__)
 42 #define REGISTRATION_RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(m_container-&gt;isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerRegistration::&quot; fmt, this, ##__VA_ARGS__)
 43 
 44 namespace WebCore {
 45 
 46 WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerRegistration);
 47 
<span class="line-removed"> 48 const Seconds softUpdateDelay { 1_s };</span>
<span class="line-removed"> 49 </span>
 50 Ref&lt;ServiceWorkerRegistration&gt; ServiceWorkerRegistration::getOrCreate(ScriptExecutionContext&amp; context, Ref&lt;ServiceWorkerContainer&gt;&amp;&amp; container, ServiceWorkerRegistrationData&amp;&amp; data)
 51 {
 52     if (auto* registration = container-&gt;registration(data.identifier)) {
 53         ASSERT(!registration-&gt;m_isStopped);
 54         return *registration;
 55     }
 56 
 57     return adoptRef(*new ServiceWorkerRegistration(context, WTFMove(container), WTFMove(data)));
 58 }
 59 
 60 ServiceWorkerRegistration::ServiceWorkerRegistration(ScriptExecutionContext&amp; context, Ref&lt;ServiceWorkerContainer&gt;&amp;&amp; container, ServiceWorkerRegistrationData&amp;&amp; registrationData)
 61     : ActiveDOMObject(&amp;context)
 62     , m_registrationData(WTFMove(registrationData))
 63     , m_container(WTFMove(container))
<span class="line-removed"> 64     , m_softUpdateTimer([this] { softUpdate(); })</span>
 65 {
 66     LOG(ServiceWorker, &quot;Creating registration %p for registration key %s&quot;, this, m_registrationData.key.loggingString().utf8().data());
 67     suspendIfNeeded();
 68 
 69     if (m_registrationData.installingWorker)
 70         m_installingWorker = ServiceWorker::getOrCreate(context, WTFMove(*m_registrationData.installingWorker));
 71     if (m_registrationData.waitingWorker)
 72         m_waitingWorker = ServiceWorker::getOrCreate(context, WTFMove(*m_registrationData.waitingWorker));
 73     if (m_registrationData.activeWorker)
 74         m_activeWorker = ServiceWorker::getOrCreate(context, WTFMove(*m_registrationData.activeWorker));
 75 
 76     REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;ServiceWorkerRegistration: ID %llu, installing: %llu, waiting: %llu, active: %llu&quot;, identifier().toUInt64(), m_installingWorker ? m_installingWorker-&gt;identifier().toUInt64() : 0, m_waitingWorker ? m_waitingWorker-&gt;identifier().toUInt64() : 0, m_activeWorker ? m_activeWorker-&gt;identifier().toUInt64() : 0);
 77 
 78     m_container-&gt;addRegistration(*this);
 79 
 80     relaxAdoptionRequirement();
<span class="line-removed"> 81     updatePendingActivityForEventDispatch();</span>
 82 }
 83 
 84 ServiceWorkerRegistration::~ServiceWorkerRegistration()
 85 {
 86     LOG(ServiceWorker, &quot;Deleting registration %p for registration key %s&quot;, this, m_registrationData.key.loggingString().utf8().data());
 87 
 88     m_container-&gt;removeRegistration(*this);
 89 }
 90 
 91 ServiceWorker* ServiceWorkerRegistration::installing()
 92 {
 93     return m_installingWorker.get();
 94 }
 95 
 96 ServiceWorker* ServiceWorkerRegistration::waiting()
 97 {
 98     return m_waitingWorker.get();
 99 }
100 
101 ServiceWorker* ServiceWorkerRegistration::active()
102 {
103     return m_activeWorker.get();
104 }
105 
<span class="line-modified">106 ServiceWorker* ServiceWorkerRegistration::getNewestWorker()</span>
107 {
108     if (m_installingWorker)
109         return m_installingWorker.get();
110     if (m_waitingWorker)
111         return m_waitingWorker.get();
112 
113     return m_activeWorker.get();
114 }
115 
116 const String&amp; ServiceWorkerRegistration::scope() const
117 {
118     return m_registrationData.scopeURL;
119 }
120 
121 ServiceWorkerUpdateViaCache ServiceWorkerRegistration::updateViaCache() const
122 {
123     return m_registrationData.updateViaCache;
124 }
125 
126 WallTime ServiceWorkerRegistration::lastUpdateTime() const
</pre>
<hr />
<pre>
138     m_registrationData.updateViaCache = updateViaCache;
139 }
140 
141 void ServiceWorkerRegistration::update(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
142 {
143     if (m_isStopped) {
144         promise-&gt;reject(Exception(InvalidStateError));
145         return;
146     }
147 
148     auto* newestWorker = getNewestWorker();
149     if (!newestWorker) {
150         promise-&gt;reject(Exception(InvalidStateError, &quot;newestWorker is null&quot;_s));
151         return;
152     }
153 
154     // FIXME: Support worker types.
155     m_container-&gt;updateRegistration(m_registrationData.scopeURL, newestWorker-&gt;scriptURL(), WorkerType::Classic, WTFMove(promise));
156 }
157 
<span class="line-removed">158 // To avoid scheduling many updates during a single page load, we do soft updates on a 1 second delay and keep delaying</span>
<span class="line-removed">159 // as long as soft update requests keep coming. This seems to match Chrome&#39;s behavior.</span>
<span class="line-removed">160 void ServiceWorkerRegistration::scheduleSoftUpdate()</span>
<span class="line-removed">161 {</span>
<span class="line-removed">162     if (m_softUpdateTimer.isActive())</span>
<span class="line-removed">163         m_softUpdateTimer.stop();</span>
<span class="line-removed">164     m_softUpdateTimer.startOneShot(softUpdateDelay);</span>
<span class="line-removed">165 }</span>
<span class="line-removed">166 </span>
<span class="line-removed">167 void ServiceWorkerRegistration::softUpdate()</span>
<span class="line-removed">168 {</span>
<span class="line-removed">169     if (m_isStopped)</span>
<span class="line-removed">170         return;</span>
<span class="line-removed">171 </span>
<span class="line-removed">172     auto* newestWorker = getNewestWorker();</span>
<span class="line-removed">173     if (!newestWorker)</span>
<span class="line-removed">174         return;</span>
<span class="line-removed">175 </span>
<span class="line-removed">176     // FIXME: Support worker types.</span>
<span class="line-removed">177     m_container-&gt;updateRegistration(m_registrationData.scopeURL, newestWorker-&gt;scriptURL(), WorkerType::Classic, nullptr);</span>
<span class="line-removed">178 }</span>
<span class="line-removed">179 </span>
180 void ServiceWorkerRegistration::unregister(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
181 {
182     if (m_isStopped) {
183         promise-&gt;reject(Exception(InvalidStateError));
184         return;
185     }
186 
187     m_container-&gt;removeRegistration(m_registrationData.scopeURL, WTFMove(promise));
188 }
189 
190 void ServiceWorkerRegistration::updateStateFromServer(ServiceWorkerRegistrationState state, RefPtr&lt;ServiceWorker&gt;&amp;&amp; serviceWorker)
191 {
192     switch (state) {
193     case ServiceWorkerRegistrationState::Installing:
194         REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;updateStateFromServer: Setting registration %llu installing worker to %llu&quot;, identifier().toUInt64(), serviceWorker ? serviceWorker-&gt;identifier().toUInt64() : 0);
195         m_installingWorker = WTFMove(serviceWorker);
196         break;
197     case ServiceWorkerRegistrationState::Waiting:
198         REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;updateStateFromServer: Setting registration %llu waiting worker to %llu&quot;, identifier().toUInt64(), serviceWorker ? serviceWorker-&gt;identifier().toUInt64() : 0);
199         m_waitingWorker = WTFMove(serviceWorker);
200         break;
201     case ServiceWorkerRegistrationState::Active:
202         REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;updateStateFromServer: Setting registration %llu active worker to %llu&quot;, identifier().toUInt64(), serviceWorker ? serviceWorker-&gt;identifier().toUInt64() : 0);
203         m_activeWorker = WTFMove(serviceWorker);
204         break;
205     }
<span class="line-removed">206     updatePendingActivityForEventDispatch();</span>
207 }
208 
<span class="line-modified">209 void ServiceWorkerRegistration::fireUpdateFoundEvent()</span>
210 {
211     if (m_isStopped)
212         return;
213 
214     REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;fireUpdateFoundEvent: Firing updatefound event for registration %llu&quot;, identifier().toUInt64());
215 
<span class="line-modified">216     ASSERT(m_pendingActivityForEventDispatch);</span>
<span class="line-removed">217     dispatchEvent(Event::create(eventNames().updatefoundEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
218 }
219 
220 EventTargetInterface ServiceWorkerRegistration::eventTargetInterface() const
221 {
222     return ServiceWorkerRegistrationEventTargetInterfaceType;
223 }
224 
225 ScriptExecutionContext* ServiceWorkerRegistration::scriptExecutionContext() const
226 {
227     return ActiveDOMObject::scriptExecutionContext();
228 }
229 
230 const char* ServiceWorkerRegistration::activeDOMObjectName() const
231 {
232     return &quot;ServiceWorkerRegistration&quot;;
233 }
234 
<span class="line-removed">235 bool ServiceWorkerRegistration::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">236 {</span>
<span class="line-removed">237     // FIXME: We should do better as this prevents a page from entering PageCache when there is a service worker registration.</span>
<span class="line-removed">238     return !hasPendingActivity();</span>
<span class="line-removed">239 }</span>
<span class="line-removed">240 </span>
241 void ServiceWorkerRegistration::stop()
242 {
243     m_isStopped = true;
244     removeAllEventListeners();
<span class="line-removed">245     updatePendingActivityForEventDispatch();</span>
246 }
247 
<span class="line-modified">248 void ServiceWorkerRegistration::updatePendingActivityForEventDispatch()</span>
249 {
<span class="line-modified">250     // If a registration has no ServiceWorker, then it has been cleared on server-side.</span>
<span class="line-modified">251     if (m_isStopped || !getNewestWorker()) {</span>
<span class="line-modified">252         m_pendingActivityForEventDispatch = nullptr;</span>
<span class="line-modified">253         return;</span>
<span class="line-removed">254     }</span>
<span class="line-removed">255     if (m_pendingActivityForEventDispatch)</span>
<span class="line-removed">256         return;</span>
<span class="line-removed">257     m_pendingActivityForEventDispatch = makePendingActivity(*this);</span>
258 }
259 
260 } // namespace WebCore
261 
262 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
<td>
<hr />
<pre>
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerRegistration.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 #include &quot;DOMWindow.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventNames.h&quot;
<span class="line-added"> 34 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 35 #include &quot;Logging.h&quot;
 36 #include &quot;ServiceWorker.h&quot;
 37 #include &quot;ServiceWorkerContainer.h&quot;
 38 #include &quot;ServiceWorkerTypes.h&quot;
 39 #include &quot;WorkerGlobalScope.h&quot;
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 
 42 #define REGISTRATION_RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(m_container-&gt;isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerRegistration::&quot; fmt, this, ##__VA_ARGS__)
 43 #define REGISTRATION_RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(m_container-&gt;isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerRegistration::&quot; fmt, this, ##__VA_ARGS__)
 44 
 45 namespace WebCore {
 46 
 47 WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerRegistration);
 48 


 49 Ref&lt;ServiceWorkerRegistration&gt; ServiceWorkerRegistration::getOrCreate(ScriptExecutionContext&amp; context, Ref&lt;ServiceWorkerContainer&gt;&amp;&amp; container, ServiceWorkerRegistrationData&amp;&amp; data)
 50 {
 51     if (auto* registration = container-&gt;registration(data.identifier)) {
 52         ASSERT(!registration-&gt;m_isStopped);
 53         return *registration;
 54     }
 55 
 56     return adoptRef(*new ServiceWorkerRegistration(context, WTFMove(container), WTFMove(data)));
 57 }
 58 
 59 ServiceWorkerRegistration::ServiceWorkerRegistration(ScriptExecutionContext&amp; context, Ref&lt;ServiceWorkerContainer&gt;&amp;&amp; container, ServiceWorkerRegistrationData&amp;&amp; registrationData)
 60     : ActiveDOMObject(&amp;context)
 61     , m_registrationData(WTFMove(registrationData))
 62     , m_container(WTFMove(container))

 63 {
 64     LOG(ServiceWorker, &quot;Creating registration %p for registration key %s&quot;, this, m_registrationData.key.loggingString().utf8().data());
 65     suspendIfNeeded();
 66 
 67     if (m_registrationData.installingWorker)
 68         m_installingWorker = ServiceWorker::getOrCreate(context, WTFMove(*m_registrationData.installingWorker));
 69     if (m_registrationData.waitingWorker)
 70         m_waitingWorker = ServiceWorker::getOrCreate(context, WTFMove(*m_registrationData.waitingWorker));
 71     if (m_registrationData.activeWorker)
 72         m_activeWorker = ServiceWorker::getOrCreate(context, WTFMove(*m_registrationData.activeWorker));
 73 
 74     REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;ServiceWorkerRegistration: ID %llu, installing: %llu, waiting: %llu, active: %llu&quot;, identifier().toUInt64(), m_installingWorker ? m_installingWorker-&gt;identifier().toUInt64() : 0, m_waitingWorker ? m_waitingWorker-&gt;identifier().toUInt64() : 0, m_activeWorker ? m_activeWorker-&gt;identifier().toUInt64() : 0);
 75 
 76     m_container-&gt;addRegistration(*this);
 77 
 78     relaxAdoptionRequirement();

 79 }
 80 
 81 ServiceWorkerRegistration::~ServiceWorkerRegistration()
 82 {
 83     LOG(ServiceWorker, &quot;Deleting registration %p for registration key %s&quot;, this, m_registrationData.key.loggingString().utf8().data());
 84 
 85     m_container-&gt;removeRegistration(*this);
 86 }
 87 
 88 ServiceWorker* ServiceWorkerRegistration::installing()
 89 {
 90     return m_installingWorker.get();
 91 }
 92 
 93 ServiceWorker* ServiceWorkerRegistration::waiting()
 94 {
 95     return m_waitingWorker.get();
 96 }
 97 
 98 ServiceWorker* ServiceWorkerRegistration::active()
 99 {
100     return m_activeWorker.get();
101 }
102 
<span class="line-modified">103 ServiceWorker* ServiceWorkerRegistration::getNewestWorker() const</span>
104 {
105     if (m_installingWorker)
106         return m_installingWorker.get();
107     if (m_waitingWorker)
108         return m_waitingWorker.get();
109 
110     return m_activeWorker.get();
111 }
112 
113 const String&amp; ServiceWorkerRegistration::scope() const
114 {
115     return m_registrationData.scopeURL;
116 }
117 
118 ServiceWorkerUpdateViaCache ServiceWorkerRegistration::updateViaCache() const
119 {
120     return m_registrationData.updateViaCache;
121 }
122 
123 WallTime ServiceWorkerRegistration::lastUpdateTime() const
</pre>
<hr />
<pre>
135     m_registrationData.updateViaCache = updateViaCache;
136 }
137 
138 void ServiceWorkerRegistration::update(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
139 {
140     if (m_isStopped) {
141         promise-&gt;reject(Exception(InvalidStateError));
142         return;
143     }
144 
145     auto* newestWorker = getNewestWorker();
146     if (!newestWorker) {
147         promise-&gt;reject(Exception(InvalidStateError, &quot;newestWorker is null&quot;_s));
148         return;
149     }
150 
151     // FIXME: Support worker types.
152     m_container-&gt;updateRegistration(m_registrationData.scopeURL, newestWorker-&gt;scriptURL(), WorkerType::Classic, WTFMove(promise));
153 }
154 






















155 void ServiceWorkerRegistration::unregister(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
156 {
157     if (m_isStopped) {
158         promise-&gt;reject(Exception(InvalidStateError));
159         return;
160     }
161 
162     m_container-&gt;removeRegistration(m_registrationData.scopeURL, WTFMove(promise));
163 }
164 
165 void ServiceWorkerRegistration::updateStateFromServer(ServiceWorkerRegistrationState state, RefPtr&lt;ServiceWorker&gt;&amp;&amp; serviceWorker)
166 {
167     switch (state) {
168     case ServiceWorkerRegistrationState::Installing:
169         REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;updateStateFromServer: Setting registration %llu installing worker to %llu&quot;, identifier().toUInt64(), serviceWorker ? serviceWorker-&gt;identifier().toUInt64() : 0);
170         m_installingWorker = WTFMove(serviceWorker);
171         break;
172     case ServiceWorkerRegistrationState::Waiting:
173         REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;updateStateFromServer: Setting registration %llu waiting worker to %llu&quot;, identifier().toUInt64(), serviceWorker ? serviceWorker-&gt;identifier().toUInt64() : 0);
174         m_waitingWorker = WTFMove(serviceWorker);
175         break;
176     case ServiceWorkerRegistrationState::Active:
177         REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;updateStateFromServer: Setting registration %llu active worker to %llu&quot;, identifier().toUInt64(), serviceWorker ? serviceWorker-&gt;identifier().toUInt64() : 0);
178         m_activeWorker = WTFMove(serviceWorker);
179         break;
180     }

181 }
182 
<span class="line-modified">183 void ServiceWorkerRegistration::queueTaskToFireUpdateFoundEvent()</span>
184 {
185     if (m_isStopped)
186         return;
187 
188     REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;fireUpdateFoundEvent: Firing updatefound event for registration %llu&quot;, identifier().toUInt64());
189 
<span class="line-modified">190     queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, Event::create(eventNames().updatefoundEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>

191 }
192 
193 EventTargetInterface ServiceWorkerRegistration::eventTargetInterface() const
194 {
195     return ServiceWorkerRegistrationEventTargetInterfaceType;
196 }
197 
198 ScriptExecutionContext* ServiceWorkerRegistration::scriptExecutionContext() const
199 {
200     return ActiveDOMObject::scriptExecutionContext();
201 }
202 
203 const char* ServiceWorkerRegistration::activeDOMObjectName() const
204 {
205     return &quot;ServiceWorkerRegistration&quot;;
206 }
207 






208 void ServiceWorkerRegistration::stop()
209 {
210     m_isStopped = true;
211     removeAllEventListeners();

212 }
213 
<span class="line-modified">214 bool ServiceWorkerRegistration::hasPendingActivity() const</span>
215 {
<span class="line-modified">216     if (!m_isStopped &amp;&amp; getNewestWorker() &amp;&amp; hasEventListeners())</span>
<span class="line-modified">217         return true;</span>
<span class="line-modified">218 </span>
<span class="line-modified">219     return ActiveDOMObject::hasPendingActivity();</span>




220 }
221 
222 } // namespace WebCore
223 
224 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
</tr>
</table>
<center><a href="ServiceWorkerProvider.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerRegistration.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
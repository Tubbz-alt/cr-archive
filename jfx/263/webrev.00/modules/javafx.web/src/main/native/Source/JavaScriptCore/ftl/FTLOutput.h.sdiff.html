<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLOutput.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLSlowPathCall.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;DFGCommon.h&quot;
 29 
 30 #if ENABLE(FTL_JIT)
 31 
 32 #include &quot;B3BasicBlockInlines.h&quot;
 33 #include &quot;B3CCallValue.h&quot;
 34 #include &quot;B3Compilation.h&quot;
 35 #include &quot;B3FrequentedBlock.h&quot;
 36 #include &quot;B3Procedure.h&quot;
 37 #include &quot;B3SwitchValue.h&quot;
 38 #include &quot;B3Width.h&quot;
 39 #include &quot;FTLAbbreviatedTypes.h&quot;
 40 #include &quot;FTLAbstractHeapRepository.h&quot;
 41 #include &quot;FTLCommonValues.h&quot;

 42 #include &quot;FTLState.h&quot;
 43 #include &quot;FTLSwitchCase.h&quot;
 44 #include &quot;FTLTypedPointer.h&quot;
 45 #include &quot;FTLValueFromBlock.h&quot;
 46 #include &quot;FTLWeight.h&quot;
 47 #include &quot;FTLWeightedTarget.h&quot;
 48 #include &quot;HeapCell.h&quot;
 49 #include &lt;wtf/OrderMaker.h&gt;
 50 #include &lt;wtf/StringPrintStream.h&gt;
 51 
 52 // FIXME: remove this once everything can be generated through B3.
 53 IGNORE_WARNINGS_BEGIN(&quot;missing-noreturn&quot;)
 54 ALLOW_UNUSED_PARAMETERS_BEGIN
 55 
 56 namespace JSC {
 57 
 58 namespace DFG {
 59 struct Node;
 60 } // namespace DFG
 61 
</pre>
<hr />
<pre>
 87         LBasicBlock lastNextBlock = m_nextBlock;
 88         m_nextBlock = nextBlock;
 89         return lastNextBlock;
 90     }
 91 
 92     void applyBlockOrder();
 93 
 94     LBasicBlock appendTo(LBasicBlock, LBasicBlock nextBlock);
 95     void appendTo(LBasicBlock);
 96 
 97     void setOrigin(DFG::Node* node) { m_origin = node; }
 98     B3::Origin origin() { return B3::Origin(m_origin); }
 99 
100     LValue framePointer();
101 
102     B3::SlotBaseValue* lockedStackSlot(size_t bytes);
103 
104     LValue constBool(bool value);
105     LValue constInt32(int32_t value);
106 
<span class="line-modified">107     LValue weakPointer(DFG::Graph&amp; graph, JSCell* cell)</span>
108     {
109         ASSERT(graph.m_plan.weakReferences().contains(cell));
110 
111         return constIntPtr(bitwise_cast&lt;intptr_t&gt;(cell));
112     }
113 
<span class="line-modified">114     LValue weakPointer(DFG::FrozenValue* value)</span>
115     {
116         RELEASE_ASSERT(value-&gt;value().isCell());
117 
118         return constIntPtr(bitwise_cast&lt;intptr_t&gt;(value-&gt;cell()));
119     }
120 
121     template&lt;typename T&gt;
122     LValue constIntPtr(T* value)
123     {
124         static_assert(!std::is_base_of&lt;HeapCell, T&gt;::value, &quot;To use a GC pointer, the graph must be aware of it. Use gcPointer instead and make sure the graph is aware of this reference.&quot;);
125         if (sizeof(void*) == 8)
126             return constInt64(bitwise_cast&lt;intptr_t&gt;(value));
127         return constInt32(bitwise_cast&lt;intptr_t&gt;(value));
128     }
129     template&lt;typename T&gt;
130     LValue constIntPtr(T value)
131     {
132         if (sizeof(void*) == 8)
133             return constInt64(static_cast&lt;intptr_t&gt;(value));
134         return constInt32(static_cast&lt;intptr_t&gt;(value));
</pre>
<hr />
<pre>
171     LValue lShr(LValue, LValue shiftAmount);
172     LValue bitNot(LValue);
173     LValue logicalNot(LValue);
174 
175     LValue ctlz32(LValue);
176     LValue doubleAbs(LValue);
177     LValue doubleCeil(LValue);
178     LValue doubleFloor(LValue);
179     LValue doubleTrunc(LValue);
180 
181     LValue doubleUnary(DFG::Arith::UnaryType, LValue);
182 
183     LValue doublePow(LValue base, LValue exponent);
184     LValue doublePowi(LValue base, LValue exponent);
185 
186     LValue doubleSqrt(LValue);
187 
188     LValue doubleLog(LValue);
189 
190     LValue doubleToInt(LValue);

191     LValue doubleToUInt(LValue);
192 
193     LValue signExt32To64(LValue);
194     LValue signExt32ToPtr(LValue);
195     LValue zeroExt(LValue, LType);
196     LValue zeroExtPtr(LValue value) { return zeroExt(value, B3::Int64); }
197     LValue intToDouble(LValue);
198     LValue unsignedToDouble(LValue);
199     LValue castToInt32(LValue);
200     LValue doubleToFloat(LValue);
201     LValue floatToDouble(LValue);
202     LValue bitCast(LValue, LType);
203     LValue fround(LValue);
204 
205     LValue load(TypedPointer, LType);
206     LValue store(LValue, TypedPointer);
207     B3::FenceValue* fence(const AbstractHeap* read, const AbstractHeap* write);
208 
209     LValue load8SignExt32(TypedPointer);
210     LValue load8ZeroExt32(TypedPointer);
</pre>
<hr />
<pre>
347     LValue doubleNotEqualAndOrdered(LValue, LValue);
348     LValue doubleLessThanOrUnordered(LValue, LValue);
349     LValue doubleLessThanOrEqualOrUnordered(LValue, LValue);
350     LValue doubleGreaterThanOrUnordered(LValue, LValue);
351     LValue doubleGreaterThanOrEqualOrUnordered(LValue, LValue);
352 
353     LValue isZero32(LValue);
354     LValue notZero32(LValue);
355     LValue isZero64(LValue);
356     LValue notZero64(LValue);
357     LValue isNull(LValue value) { return isZero64(value); }
358     LValue notNull(LValue value) { return notZero64(value); }
359 
360     LValue testIsZero32(LValue value, LValue mask) { return isZero32(bitAnd(value, mask)); }
361     LValue testNonZero32(LValue value, LValue mask) { return notZero32(bitAnd(value, mask)); }
362     LValue testIsZero64(LValue value, LValue mask) { return isZero64(bitAnd(value, mask)); }
363     LValue testNonZero64(LValue value, LValue mask) { return notZero64(bitAnd(value, mask)); }
364     LValue testIsZeroPtr(LValue value, LValue mask) { return isNull(bitAnd(value, mask)); }
365     LValue testNonZeroPtr(LValue value, LValue mask) { return notNull(bitAnd(value, mask)); }
366 
<span class="line-modified">367     LValue select(LValue value, LValue taken, LValue notTaken);</span>
368 
369     // These are relaxed atomics by default. Use AbstractHeapRepository::decorateFencedAccess() with a
370     // non-null heap to make them seq_cst fenced.
371     LValue atomicXchgAdd(LValue operand, TypedPointer pointer, B3::Width);
372     LValue atomicXchgAnd(LValue operand, TypedPointer pointer, B3::Width);
373     LValue atomicXchgOr(LValue operand, TypedPointer pointer, B3::Width);
374     LValue atomicXchgSub(LValue operand, TypedPointer pointer, B3::Width);
375     LValue atomicXchgXor(LValue operand, TypedPointer pointer, B3::Width);
376     LValue atomicXchg(LValue operand, TypedPointer pointer, B3::Width);
377     LValue atomicStrongCAS(LValue expected, LValue newValue, TypedPointer pointer, B3::Width);
378 
379     template&lt;typename VectorType&gt;
380     LValue call(LType type, LValue function, const VectorType&amp; vector)
381     {
382         B3::CCallValue* result = m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), function);
383         result-&gt;appendArgs(vector);
384         return result;
385     }
386     LValue call(LType type, LValue function) { return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), function); }
387     LValue call(LType type, LValue function, LValue arg1) { return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), function, arg1); }
388     template&lt;typename... Args&gt;
389     LValue call(LType type, LValue function, LValue arg1, Args... args) { return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), function, arg1, args...); }
390 
391     template&lt;typename Function, typename... Args&gt;
392     LValue callWithoutSideEffects(B3::Type type, Function function, LValue arg1, Args... args)
393     {

394         return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), B3::Effects::none(),
395             constIntPtr(tagCFunctionPtr&lt;void*&gt;(function, B3CCallPtrTag)), arg1, args...);
396     }
397 
398     // FIXME: Consider enhancing this to allow the client to choose the target PtrTag to use.
399     // https://bugs.webkit.org/show_bug.cgi?id=184324
400     template&lt;typename FunctionType&gt;
401     LValue operation(FunctionType function) { return constIntPtr(tagCFunctionPtr&lt;void*&gt;(function, B3CCallPtrTag)); }
402 
403     void jump(LBasicBlock);
404     void branch(LValue condition, LBasicBlock taken, Weight takenWeight, LBasicBlock notTaken, Weight notTakenWeight);
405     void branch(LValue condition, WeightedTarget taken, WeightedTarget notTaken)
406     {
407         branch(condition, taken.target(), taken.weight(), notTaken.target(), notTaken.weight());
408     }
409 
410     // Branches to an already-created handler if true, &quot;falls through&quot; if false. Fall-through is
411     // simulated by creating a continuation for you.
412     void check(LValue condition, WeightedTarget taken, Weight notTakenWeight);
413 
</pre>
</td>
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;DFGCommon.h&quot;
 29 
 30 #if ENABLE(FTL_JIT)
 31 
 32 #include &quot;B3BasicBlockInlines.h&quot;
 33 #include &quot;B3CCallValue.h&quot;
 34 #include &quot;B3Compilation.h&quot;
 35 #include &quot;B3FrequentedBlock.h&quot;
 36 #include &quot;B3Procedure.h&quot;
 37 #include &quot;B3SwitchValue.h&quot;
 38 #include &quot;B3Width.h&quot;
 39 #include &quot;FTLAbbreviatedTypes.h&quot;
 40 #include &quot;FTLAbstractHeapRepository.h&quot;
 41 #include &quot;FTLCommonValues.h&quot;
<span class="line-added"> 42 #include &quot;FTLSelectPredictability.h&quot;</span>
 43 #include &quot;FTLState.h&quot;
 44 #include &quot;FTLSwitchCase.h&quot;
 45 #include &quot;FTLTypedPointer.h&quot;
 46 #include &quot;FTLValueFromBlock.h&quot;
 47 #include &quot;FTLWeight.h&quot;
 48 #include &quot;FTLWeightedTarget.h&quot;
 49 #include &quot;HeapCell.h&quot;
 50 #include &lt;wtf/OrderMaker.h&gt;
 51 #include &lt;wtf/StringPrintStream.h&gt;
 52 
 53 // FIXME: remove this once everything can be generated through B3.
 54 IGNORE_WARNINGS_BEGIN(&quot;missing-noreturn&quot;)
 55 ALLOW_UNUSED_PARAMETERS_BEGIN
 56 
 57 namespace JSC {
 58 
 59 namespace DFG {
 60 struct Node;
 61 } // namespace DFG
 62 
</pre>
<hr />
<pre>
 88         LBasicBlock lastNextBlock = m_nextBlock;
 89         m_nextBlock = nextBlock;
 90         return lastNextBlock;
 91     }
 92 
 93     void applyBlockOrder();
 94 
 95     LBasicBlock appendTo(LBasicBlock, LBasicBlock nextBlock);
 96     void appendTo(LBasicBlock);
 97 
 98     void setOrigin(DFG::Node* node) { m_origin = node; }
 99     B3::Origin origin() { return B3::Origin(m_origin); }
100 
101     LValue framePointer();
102 
103     B3::SlotBaseValue* lockedStackSlot(size_t bytes);
104 
105     LValue constBool(bool value);
106     LValue constInt32(int32_t value);
107 
<span class="line-modified">108     LValue alreadyRegisteredWeakPointer(DFG::Graph&amp; graph, JSCell* cell)</span>
109     {
110         ASSERT(graph.m_plan.weakReferences().contains(cell));
111 
112         return constIntPtr(bitwise_cast&lt;intptr_t&gt;(cell));
113     }
114 
<span class="line-modified">115     LValue alreadyRegisteredFrozenPointer(DFG::FrozenValue* value)</span>
116     {
117         RELEASE_ASSERT(value-&gt;value().isCell());
118 
119         return constIntPtr(bitwise_cast&lt;intptr_t&gt;(value-&gt;cell()));
120     }
121 
122     template&lt;typename T&gt;
123     LValue constIntPtr(T* value)
124     {
125         static_assert(!std::is_base_of&lt;HeapCell, T&gt;::value, &quot;To use a GC pointer, the graph must be aware of it. Use gcPointer instead and make sure the graph is aware of this reference.&quot;);
126         if (sizeof(void*) == 8)
127             return constInt64(bitwise_cast&lt;intptr_t&gt;(value));
128         return constInt32(bitwise_cast&lt;intptr_t&gt;(value));
129     }
130     template&lt;typename T&gt;
131     LValue constIntPtr(T value)
132     {
133         if (sizeof(void*) == 8)
134             return constInt64(static_cast&lt;intptr_t&gt;(value));
135         return constInt32(static_cast&lt;intptr_t&gt;(value));
</pre>
<hr />
<pre>
172     LValue lShr(LValue, LValue shiftAmount);
173     LValue bitNot(LValue);
174     LValue logicalNot(LValue);
175 
176     LValue ctlz32(LValue);
177     LValue doubleAbs(LValue);
178     LValue doubleCeil(LValue);
179     LValue doubleFloor(LValue);
180     LValue doubleTrunc(LValue);
181 
182     LValue doubleUnary(DFG::Arith::UnaryType, LValue);
183 
184     LValue doublePow(LValue base, LValue exponent);
185     LValue doublePowi(LValue base, LValue exponent);
186 
187     LValue doubleSqrt(LValue);
188 
189     LValue doubleLog(LValue);
190 
191     LValue doubleToInt(LValue);
<span class="line-added">192     LValue doubleToInt64(LValue);</span>
193     LValue doubleToUInt(LValue);
194 
195     LValue signExt32To64(LValue);
196     LValue signExt32ToPtr(LValue);
197     LValue zeroExt(LValue, LType);
198     LValue zeroExtPtr(LValue value) { return zeroExt(value, B3::Int64); }
199     LValue intToDouble(LValue);
200     LValue unsignedToDouble(LValue);
201     LValue castToInt32(LValue);
202     LValue doubleToFloat(LValue);
203     LValue floatToDouble(LValue);
204     LValue bitCast(LValue, LType);
205     LValue fround(LValue);
206 
207     LValue load(TypedPointer, LType);
208     LValue store(LValue, TypedPointer);
209     B3::FenceValue* fence(const AbstractHeap* read, const AbstractHeap* write);
210 
211     LValue load8SignExt32(TypedPointer);
212     LValue load8ZeroExt32(TypedPointer);
</pre>
<hr />
<pre>
349     LValue doubleNotEqualAndOrdered(LValue, LValue);
350     LValue doubleLessThanOrUnordered(LValue, LValue);
351     LValue doubleLessThanOrEqualOrUnordered(LValue, LValue);
352     LValue doubleGreaterThanOrUnordered(LValue, LValue);
353     LValue doubleGreaterThanOrEqualOrUnordered(LValue, LValue);
354 
355     LValue isZero32(LValue);
356     LValue notZero32(LValue);
357     LValue isZero64(LValue);
358     LValue notZero64(LValue);
359     LValue isNull(LValue value) { return isZero64(value); }
360     LValue notNull(LValue value) { return notZero64(value); }
361 
362     LValue testIsZero32(LValue value, LValue mask) { return isZero32(bitAnd(value, mask)); }
363     LValue testNonZero32(LValue value, LValue mask) { return notZero32(bitAnd(value, mask)); }
364     LValue testIsZero64(LValue value, LValue mask) { return isZero64(bitAnd(value, mask)); }
365     LValue testNonZero64(LValue value, LValue mask) { return notZero64(bitAnd(value, mask)); }
366     LValue testIsZeroPtr(LValue value, LValue mask) { return isNull(bitAnd(value, mask)); }
367     LValue testNonZeroPtr(LValue value, LValue mask) { return notNull(bitAnd(value, mask)); }
368 
<span class="line-modified">369     LValue select(LValue value, LValue taken, LValue notTaken, SelectPredictability = SelectPredictability::NotPredictable);</span>
370 
371     // These are relaxed atomics by default. Use AbstractHeapRepository::decorateFencedAccess() with a
372     // non-null heap to make them seq_cst fenced.
373     LValue atomicXchgAdd(LValue operand, TypedPointer pointer, B3::Width);
374     LValue atomicXchgAnd(LValue operand, TypedPointer pointer, B3::Width);
375     LValue atomicXchgOr(LValue operand, TypedPointer pointer, B3::Width);
376     LValue atomicXchgSub(LValue operand, TypedPointer pointer, B3::Width);
377     LValue atomicXchgXor(LValue operand, TypedPointer pointer, B3::Width);
378     LValue atomicXchg(LValue operand, TypedPointer pointer, B3::Width);
379     LValue atomicStrongCAS(LValue expected, LValue newValue, TypedPointer pointer, B3::Width);
380 
381     template&lt;typename VectorType&gt;
382     LValue call(LType type, LValue function, const VectorType&amp; vector)
383     {
384         B3::CCallValue* result = m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), function);
385         result-&gt;appendArgs(vector);
386         return result;
387     }
388     LValue call(LType type, LValue function) { return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), function); }
389     LValue call(LType type, LValue function, LValue arg1) { return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), function, arg1); }
390     template&lt;typename... Args&gt;
391     LValue call(LType type, LValue function, LValue arg1, Args... args) { return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), function, arg1, args...); }
392 
393     template&lt;typename Function, typename... Args&gt;
394     LValue callWithoutSideEffects(B3::Type type, Function function, LValue arg1, Args... args)
395     {
<span class="line-added">396         static_assert(!std::is_same&lt;Function, LValue&gt;::value);</span>
397         return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), B3::Effects::none(),
398             constIntPtr(tagCFunctionPtr&lt;void*&gt;(function, B3CCallPtrTag)), arg1, args...);
399     }
400 
401     // FIXME: Consider enhancing this to allow the client to choose the target PtrTag to use.
402     // https://bugs.webkit.org/show_bug.cgi?id=184324
403     template&lt;typename FunctionType&gt;
404     LValue operation(FunctionType function) { return constIntPtr(tagCFunctionPtr&lt;void*&gt;(function, B3CCallPtrTag)); }
405 
406     void jump(LBasicBlock);
407     void branch(LValue condition, LBasicBlock taken, Weight takenWeight, LBasicBlock notTaken, Weight notTakenWeight);
408     void branch(LValue condition, WeightedTarget taken, WeightedTarget notTaken)
409     {
410         branch(condition, taken.target(), taken.weight(), notTaken.target(), notTaken.weight());
411     }
412 
413     // Branches to an already-created handler if true, &quot;falls through&quot; if false. Fall-through is
414     // simulated by creating a continuation for you.
415     void check(LValue condition, WeightedTarget taken, Weight notTakenWeight);
416 
</pre>
</td>
</tr>
</table>
<center><a href="FTLOutput.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLSlowPathCall.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Operations.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Operations.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Options.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Operations.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  *
 15  *  You should have received a copy of the GNU Library General Public License
 16  *  along with this library; see the file COPYING.LIB.  If not, write to
 17  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  *  Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CallFrame.h&quot;
 25 #include &quot;ExceptionHelpers.h&quot;
 26 #include &quot;JSBigInt.h&quot;
 27 #include &quot;JSCJSValueInlines.h&quot;
 28 #include &lt;wtf/Variant.h&gt;
 29 
 30 namespace JSC {
 31 
 32 #define InvalidPrototypeChain (std::numeric_limits&lt;size_t&gt;::max())
 33 
<span class="line-modified"> 34 NEVER_INLINE JSValue jsAddSlowCase(CallFrame*, JSValue, JSValue);</span>
<span class="line-modified"> 35 JSValue jsTypeStringForValue(CallFrame*, JSValue);</span>
 36 JSValue jsTypeStringForValue(VM&amp;, JSGlobalObject*, JSValue);
<span class="line-modified"> 37 bool jsIsObjectTypeOrNull(CallFrame*, JSValue);</span>
<span class="line-modified"> 38 size_t normalizePrototypeChain(CallFrame*, JSCell*, bool&amp; sawPolyProto);</span>
 39 
<span class="line-modified"> 40 ALWAYS_INLINE JSString* jsString(ExecState* exec, const String&amp; u1, JSString* s2)</span>
 41 {
<span class="line-modified"> 42     VM&amp; vm = exec-&gt;vm();</span>
 43     auto scope = DECLARE_THROW_SCOPE(vm);
 44 
 45     unsigned length1 = u1.length();
 46     if (!length1)
 47         return s2;
 48     unsigned length2 = s2-&gt;length();
 49     if (!length2)
 50         return jsString(vm, u1);
 51     static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
 52     if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified"> 53         throwOutOfMemoryError(exec, scope);</span>
 54         return nullptr;
 55     }
 56 
 57     // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2
 58     // (2) Cost of making JSRopeString: sizeof(JSString) (for u1) + sizeof(JSRopeString)
 59     // We do not account u1 cost in (2) since u1 may be shared StringImpl, and it may not introduce additional cost.
 60     // We conservatively consider the cost of u1. Currently, we are not considering about is8Bit() case because 16-bit
 61     // strings are relatively rare. But we can do that if we need to consider it.
 62     if (s2-&gt;isRope() || (StringImpl::headerSize&lt;LChar&gt;() + length1 + length2) &gt;= sizeof(JSRopeString))
 63         return JSRopeString::create(vm, jsString(vm, u1), s2);
 64 
 65     ASSERT(!s2-&gt;isRope());
<span class="line-modified"> 66     const String&amp; u2 = s2-&gt;value(exec);</span>
 67     scope.assertNoException();
 68     String newString = tryMakeString(u1, u2);
 69     if (!newString) {
<span class="line-modified"> 70         throwOutOfMemoryError(exec, scope);</span>
 71         return nullptr;
 72     }
 73     return JSString::create(vm, newString.releaseImpl().releaseNonNull());
 74 }
 75 
<span class="line-modified"> 76 ALWAYS_INLINE JSString* jsString(ExecState* exec, JSString* s1, const String&amp; u2)</span>
 77 {
<span class="line-modified"> 78     VM&amp; vm = exec-&gt;vm();</span>
 79     auto scope = DECLARE_THROW_SCOPE(vm);
 80 
 81     unsigned length1 = s1-&gt;length();
 82     if (!length1)
 83         return jsString(vm, u2);
 84     unsigned length2 = u2.length();
 85     if (!length2)
 86         return s1;
 87     static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
 88     if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified"> 89         throwOutOfMemoryError(exec, scope);</span>
 90         return nullptr;
 91     }
 92 
 93     // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2
 94     // (2) Cost of making JSRopeString: sizeof(JSString) (for u2) + sizeof(JSRopeString)
 95     if (s1-&gt;isRope() || (StringImpl::headerSize&lt;LChar&gt;() + length1 + length2) &gt;= sizeof(JSRopeString))
 96         return JSRopeString::create(vm, s1, jsString(vm, u2));
 97 
 98     ASSERT(!s1-&gt;isRope());
<span class="line-modified"> 99     const String&amp; u1 = s1-&gt;value(exec);</span>
100     scope.assertNoException();
101     String newString = tryMakeString(u1, u2);
102     if (!newString) {
<span class="line-modified">103         throwOutOfMemoryError(exec, scope);</span>
104         return nullptr;
105     }
106     return JSString::create(vm, newString.releaseImpl().releaseNonNull());
107 }
108 
<span class="line-modified">109 ALWAYS_INLINE JSString* jsString(ExecState* exec, JSString* s1, JSString* s2)</span>
110 {
<span class="line-modified">111     VM&amp; vm = exec-&gt;vm();</span>
112     auto scope = DECLARE_THROW_SCOPE(vm);
113 
114     unsigned length1 = s1-&gt;length();
115     if (!length1)
116         return s2;
117     unsigned length2 = s2-&gt;length();
118     if (!length2)
119         return s1;
120     static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
121     if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified">122         throwOutOfMemoryError(exec, scope);</span>
123         return nullptr;
124     }
125 
126     return JSRopeString::create(vm, s1, s2);
127 }
128 
<span class="line-modified">129 ALWAYS_INLINE JSString* jsString(ExecState* exec, JSString* s1, JSString* s2, JSString* s3)</span>
130 {
<span class="line-modified">131     VM&amp; vm = exec-&gt;vm();</span>
132     auto scope = DECLARE_THROW_SCOPE(vm);
133 
134     unsigned length1 = s1-&gt;length();
135     if (!length1)
<span class="line-modified">136         RELEASE_AND_RETURN(scope, jsString(exec, s2, s3));</span>
137 
138     unsigned length2 = s2-&gt;length();
139     if (!length2)
<span class="line-modified">140         RELEASE_AND_RETURN(scope, jsString(exec, s1, s3));</span>
141 
142     unsigned length3 = s3-&gt;length();
143     if (!length3)
<span class="line-modified">144         RELEASE_AND_RETURN(scope, jsString(exec, s1, s2));</span>
145 
146     static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
147     if (sumOverflows&lt;int32_t&gt;(length1, length2, length3)) {
<span class="line-modified">148         throwOutOfMemoryError(exec, scope);</span>
149         return nullptr;
150     }
151 
152     return JSRopeString::create(vm, s1, s2, s3);
153 }
154 
<span class="line-modified">155 ALWAYS_INLINE JSString* jsString(ExecState* exec, const String&amp; u1, const String&amp; u2)</span>
156 {
<span class="line-modified">157     VM&amp; vm = exec-&gt;vm();</span>
158     auto scope = DECLARE_THROW_SCOPE(vm);
159 
160     unsigned length1 = u1.length();
161     if (!length1)
162         return jsString(vm, u2);
163     unsigned length2 = u2.length();
164     if (!length2)
165         return jsString(vm, u1);
166     static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
167     if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified">168         throwOutOfMemoryError(exec, scope);</span>
169         return nullptr;
170     }
171 
172     // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2
173     // (2) Cost of making JSRopeString: sizeof(JSString) (for u1) + sizeof(JSString) (for u2) + sizeof(JSRopeString)
174     if ((StringImpl::headerSize&lt;LChar&gt;() + length1 + length2) &gt;= (sizeof(JSRopeString) + sizeof(JSString)))
175         return JSRopeString::create(vm, jsString(vm, u1), jsString(vm, u2));
176 
177     String newString = tryMakeString(u1, u2);
178     if (!newString) {
<span class="line-modified">179         throwOutOfMemoryError(exec, scope);</span>
180         return nullptr;
181     }
182     return JSString::create(vm, newString.releaseImpl().releaseNonNull());
183 }
184 
<span class="line-modified">185 ALWAYS_INLINE JSString* jsString(ExecState* exec, const String&amp; u1, const String&amp; u2, const String&amp; u3)</span>
186 {
<span class="line-modified">187     VM&amp; vm = exec-&gt;vm();</span>
188     auto scope = DECLARE_THROW_SCOPE(vm);
189 
190     unsigned length1 = u1.length();
191     unsigned length2 = u2.length();
192     unsigned length3 = u3.length();
193     ASSERT(length1 &lt;= JSString::MaxLength);
194     ASSERT(length2 &lt;= JSString::MaxLength);
195     ASSERT(length3 &lt;= JSString::MaxLength);
196 
197     if (!length1)
<span class="line-modified">198         RELEASE_AND_RETURN(scope, jsString(exec, u2, u3));</span>
199 
200     if (!length2)
<span class="line-modified">201         RELEASE_AND_RETURN(scope, jsString(exec, u1, u3));</span>
202 
203     if (!length3)
<span class="line-modified">204         RELEASE_AND_RETURN(scope, jsString(exec, u1, u2));</span>
205 
206     static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
207     if (sumOverflows&lt;int32_t&gt;(length1, length2, length3)) {
<span class="line-modified">208         throwOutOfMemoryError(exec, scope);</span>
209         return nullptr;
210     }
211 
212     // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2 + length3
213     // (2) Cost of making JSRopeString: sizeof(JSString) (for u1) + sizeof(JSString) (for u2) + sizeof(JSString) (for u3) + sizeof(JSRopeString)
214     if ((StringImpl::headerSize&lt;LChar&gt;() + length1 + length2 + length3) &gt;= (sizeof(JSRopeString) + sizeof(JSString) * 2))
215         return JSRopeString::create(vm, jsString(vm, u1), jsString(vm, u2), jsString(vm, u3));
216 
217     String newString = tryMakeString(u1, u2, u3);
218     if (!newString) {
<span class="line-modified">219         throwOutOfMemoryError(exec, scope);</span>
220         return nullptr;
221     }
222     return JSString::create(vm, newString.releaseImpl().releaseNonNull());
223 }
224 
<span class="line-modified">225 ALWAYS_INLINE JSValue jsStringFromRegisterArray(ExecState* exec, Register* strings, unsigned count)</span>
226 {
<span class="line-modified">227     VM&amp; vm = exec-&gt;vm();</span>
228     auto scope = DECLARE_THROW_SCOPE(vm);
229     JSRopeString::RopeBuilder&lt;RecordOverflow&gt; ropeBuilder(vm);
230 
231     for (unsigned i = 0; i &lt; count; ++i) {
232         JSValue v = strings[-static_cast&lt;int&gt;(i)].jsValue();
<span class="line-modified">233         JSString* string = v.toString(exec);</span>
234         RETURN_IF_EXCEPTION(scope, { });
235         if (!ropeBuilder.append(string))
<span class="line-modified">236             return throwOutOfMemoryError(exec, scope);</span>
<span class="line-removed">237     }</span>
<span class="line-removed">238 </span>
<span class="line-removed">239     return ropeBuilder.release();</span>
<span class="line-removed">240 }</span>
<span class="line-removed">241 </span>
<span class="line-removed">242 ALWAYS_INLINE JSValue jsStringFromArguments(ExecState* exec, JSValue thisValue)</span>
<span class="line-removed">243 {</span>
<span class="line-removed">244     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">245     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">246     JSRopeString::RopeBuilder&lt;RecordOverflow&gt; ropeBuilder(vm);</span>
<span class="line-removed">247     JSString* str = thisValue.toString(exec);</span>
<span class="line-removed">248     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-removed">249     ropeBuilder.append(str);</span>
<span class="line-removed">250 </span>
<span class="line-removed">251     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-removed">252         JSValue v = exec-&gt;argument(i);</span>
<span class="line-removed">253         JSString* str = v.toString(exec);</span>
<span class="line-removed">254         RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-removed">255         if (UNLIKELY(!ropeBuilder.append(str)))</span>
<span class="line-removed">256             return throwOutOfMemoryError(exec, scope);</span>
257     }
258 
259     return ropeBuilder.release();
260 }
261 
262 ALWAYS_INLINE bool bigIntCompareResult(JSBigInt::ComparisonResult comparisonResult, JSBigInt::ComparisonMode comparisonMode)
263 {
264     if (comparisonMode == JSBigInt::ComparisonMode::LessThan)
265         return comparisonResult == JSBigInt::ComparisonResult::LessThan;
266 
267     ASSERT(comparisonMode == JSBigInt::ComparisonMode::LessThanOrEqual);
268     return comparisonResult == JSBigInt::ComparisonResult::LessThan || comparisonResult == JSBigInt::ComparisonResult::Equal;
269 }
270 
<span class="line-modified">271 ALWAYS_INLINE bool bigIntCompare(CallFrame* callFrame, JSValue v1, JSValue v2, JSBigInt::ComparisonMode comparisonMode)</span>
272 {
273     ASSERT(v1.isBigInt() || v2.isBigInt());
274     ASSERT(v1.isPrimitive() &amp;&amp; v2.isPrimitive());
275 
<span class="line-modified">276     VM&amp; vm = callFrame-&gt;vm();</span>
277     auto scope = DECLARE_THROW_SCOPE(vm);
278 
279     if (v1.isBigInt() &amp;&amp; v2.isBigInt())
280         return bigIntCompareResult(JSBigInt::compare(asBigInt(v1), asBigInt(v2)), comparisonMode);
281 
282     if (v1.isBigInt()) {
283         JSValue primValue = v2;
284         if (primValue.isString()) {
<span class="line-modified">285             JSBigInt* bigIntValue = JSBigInt::stringToBigInt(callFrame, asString(primValue)-&gt;value(callFrame));</span>
286             RETURN_IF_EXCEPTION(scope, false);
287             if (!bigIntValue)
288                 return false;
289 
290             return bigIntCompareResult(JSBigInt::compare(asBigInt(v1), bigIntValue), comparisonMode);
291         }
292 
293         if (primValue.isBigInt())
294             return bigIntCompareResult(JSBigInt::compare(asBigInt(v1), asBigInt(primValue)), comparisonMode);
295 
<span class="line-modified">296         double numberValue = primValue.toNumber(callFrame);</span>
297         RETURN_IF_EXCEPTION(scope, false);
298         return bigIntCompareResult(JSBigInt::compareToDouble(asBigInt(v1), numberValue), comparisonMode);
299     }
300 
301     JSValue primValue = v1;
302     if (primValue.isString()) {
<span class="line-modified">303         JSBigInt* bigIntValue = JSBigInt::stringToBigInt(callFrame, asString(primValue)-&gt;value(callFrame));</span>
304         RETURN_IF_EXCEPTION(scope, false);
305         if (!bigIntValue)
306             return false;
307 
308         return bigIntCompareResult(JSBigInt::compare(bigIntValue, asBigInt(v2)), comparisonMode);
309     }
310 
311     if (primValue.isBigInt())
312         return bigIntCompareResult(JSBigInt::compare(asBigInt(primValue), asBigInt(v2)), comparisonMode);
313 
<span class="line-modified">314     double numberValue = primValue.toNumber(callFrame);</span>
315     RETURN_IF_EXCEPTION(scope, false);
316 
317     // Here we check inverted because BigInt is the v2
318     JSBigInt::ComparisonResult comparisonResult = JSBigInt::compareToDouble(asBigInt(v2), numberValue);
319     if (comparisonMode == JSBigInt::ComparisonMode::LessThan)
320         return comparisonResult == JSBigInt::ComparisonResult::GreaterThan;
321 
322     return comparisonResult == JSBigInt::ComparisonResult::GreaterThan || comparisonResult == JSBigInt::ComparisonResult::Equal;
323 }
324 
<span class="line-modified">325 ALWAYS_INLINE bool toPrimitiveNumeric(CallFrame* callFrame, JSValue v, JSValue&amp; p, double&amp; n)</span>
326 {
<span class="line-modified">327     VM&amp; vm = callFrame-&gt;vm();</span>
328     auto scope = DECLARE_THROW_SCOPE(vm);
329 
<span class="line-modified">330     p = v.toPrimitive(callFrame, PreferNumber);</span>
331     RETURN_IF_EXCEPTION(scope, false);
332     if (p.isBigInt())
333         return true;
334 
<span class="line-modified">335     n = p.toNumber(callFrame);</span>
336     RETURN_IF_EXCEPTION(scope, false);
337     return !p.isString();
338 }
339 
340 // See ES5 11.8.1/11.8.2/11.8.5 for definition of leftFirst, this value ensures correct
341 // evaluation ordering for argument conversions for &#39;&lt;&#39; and &#39;&gt;&#39;. For &#39;&lt;&#39; pass the value
342 // true, for leftFirst, for &#39;&gt;&#39; pass the value false (and reverse operand order).
343 template&lt;bool leftFirst&gt;
<span class="line-modified">344 ALWAYS_INLINE bool jsLess(CallFrame* callFrame, JSValue v1, JSValue v2)</span>
345 {
<span class="line-modified">346     VM&amp; vm = callFrame-&gt;vm();</span>
347     auto scope = DECLARE_THROW_SCOPE(vm);
348 
349     if (v1.isInt32() &amp;&amp; v2.isInt32())
350         return v1.asInt32() &lt; v2.asInt32();
351 
352     if (v1.isNumber() &amp;&amp; v2.isNumber())
353         return v1.asNumber() &lt; v2.asNumber();
354 
355     if (isJSString(v1) &amp;&amp; isJSString(v2)) {
<span class="line-modified">356         String s1 = asString(v1)-&gt;value(callFrame);</span>
357         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">358         String s2 = asString(v2)-&gt;value(callFrame);</span>
359         RETURN_IF_EXCEPTION(scope, false);
360         return codePointCompareLessThan(s1, s2);
361     }
362 
363     double n1;
364     double n2;
365     JSValue p1;
366     JSValue p2;
367     bool wasNotString1;
368     bool wasNotString2;
369     if (leftFirst) {
<span class="line-modified">370         wasNotString1 = toPrimitiveNumeric(callFrame, v1, p1, n1);</span>
371         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">372         wasNotString2 = toPrimitiveNumeric(callFrame, v2, p2, n2);</span>
373     } else {
<span class="line-modified">374         wasNotString2 = toPrimitiveNumeric(callFrame, v2, p2, n2);</span>
375         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">376         wasNotString1 = toPrimitiveNumeric(callFrame, v1, p1, n1);</span>
377     }
378     RETURN_IF_EXCEPTION(scope, false);
379 
380     if (wasNotString1 | wasNotString2) {
381         if (p1.isBigInt() || p2.isBigInt())
<span class="line-modified">382             RELEASE_AND_RETURN(scope, bigIntCompare(callFrame, p1, p2, JSBigInt::ComparisonMode::LessThan));</span>
383 
384         return n1 &lt; n2;
385     }
386 
<span class="line-modified">387     return codePointCompareLessThan(asString(p1)-&gt;value(callFrame), asString(p2)-&gt;value(callFrame));</span>
388 }
389 
390 // See ES5 11.8.3/11.8.4/11.8.5 for definition of leftFirst, this value ensures correct
391 // evaluation ordering for argument conversions for &#39;&lt;=&#39; and &#39;=&gt;&#39;. For &#39;&lt;=&#39; pass the
392 // value true, for leftFirst, for &#39;=&gt;&#39; pass the value false (and reverse operand order).
393 template&lt;bool leftFirst&gt;
<span class="line-modified">394 ALWAYS_INLINE bool jsLessEq(CallFrame* callFrame, JSValue v1, JSValue v2)</span>
395 {
<span class="line-modified">396     VM&amp; vm = callFrame-&gt;vm();</span>
397     auto scope = DECLARE_THROW_SCOPE(vm);
398 
399     if (v1.isInt32() &amp;&amp; v2.isInt32())
400         return v1.asInt32() &lt;= v2.asInt32();
401 
402     if (v1.isNumber() &amp;&amp; v2.isNumber())
403         return v1.asNumber() &lt;= v2.asNumber();
404 
405     if (isJSString(v1) &amp;&amp; isJSString(v2)) {
<span class="line-modified">406         String s1 = asString(v1)-&gt;value(callFrame);</span>
407         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">408         String s2 = asString(v2)-&gt;value(callFrame);</span>
409         RETURN_IF_EXCEPTION(scope, false);
410         return !codePointCompareLessThan(s2, s1);
411     }
412 
413     double n1;
414     double n2;
415     JSValue p1;
416     JSValue p2;
417     bool wasNotString1;
418     bool wasNotString2;
419     if (leftFirst) {
<span class="line-modified">420         wasNotString1 = toPrimitiveNumeric(callFrame, v1, p1, n1);</span>
421         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">422         wasNotString2 = toPrimitiveNumeric(callFrame, v2, p2, n2);</span>
423     } else {
<span class="line-modified">424         wasNotString2 = toPrimitiveNumeric(callFrame, v2, p2, n2);</span>
425         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">426         wasNotString1 = toPrimitiveNumeric(callFrame, v1, p1, n1);</span>
427     }
428     RETURN_IF_EXCEPTION(scope, false);
429 
430     if (wasNotString1 | wasNotString2) {
431         if (p1.isBigInt() || p2.isBigInt())
<span class="line-modified">432             RELEASE_AND_RETURN(scope, bigIntCompare(callFrame, p1, p2, JSBigInt::ComparisonMode::LessThanOrEqual));</span>
433 
434         return n1 &lt;= n2;
435     }
<span class="line-modified">436     return !codePointCompareLessThan(asString(p2)-&gt;value(callFrame), asString(p1)-&gt;value(callFrame));</span>
437 }
438 
439 // Fast-path choices here are based on frequency data from SunSpider:
440 //    &lt;times&gt; Add case: &lt;t1&gt; &lt;t2&gt;
441 //    ---------------------------
442 //    5626160 Add case: 3 3 (of these, 3637690 are for immediate values)
443 //    247412  Add case: 5 5
444 //    20900   Add case: 5 6
445 //    13962   Add case: 5 3
446 //    4000    Add case: 3 5
447 
448 
<span class="line-modified">449 ALWAYS_INLINE JSValue jsAddNonNumber(CallFrame* callFrame, JSValue v1, JSValue v2)</span>
450 {
<span class="line-modified">451     VM&amp; vm = callFrame-&gt;vm();</span>
452     auto scope = DECLARE_THROW_SCOPE(vm);
453     ASSERT(!v1.isNumber() || !v2.isNumber());
454 
455     if (LIKELY(v1.isString() &amp;&amp; !v2.isObject())) {
456         if (v2.isString())
<span class="line-modified">457             RELEASE_AND_RETURN(scope, jsString(callFrame, asString(v1), asString(v2)));</span>
<span class="line-modified">458         String s2 = v2.toWTFString(callFrame);</span>
459         RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">460         RELEASE_AND_RETURN(scope, jsString(callFrame, asString(v1), s2));</span>
461     }
462 
463     // All other cases are pretty uncommon
<span class="line-modified">464     RELEASE_AND_RETURN(scope, jsAddSlowCase(callFrame, v1, v2));</span>
465 }
466 
<span class="line-modified">467 ALWAYS_INLINE JSValue jsAdd(CallFrame* callFrame, JSValue v1, JSValue v2)</span>
468 {
469     if (v1.isNumber() &amp;&amp; v2.isNumber())
470         return jsNumber(v1.asNumber() + v2.asNumber());
471 
<span class="line-modified">472     return jsAddNonNumber(callFrame, v1, v2);</span>
473 }
474 
<span class="line-modified">475 ALWAYS_INLINE JSValue jsSub(ExecState* exec, JSValue v1, JSValue v2)</span>
476 {
<span class="line-modified">477     VM&amp; vm = exec-&gt;vm();</span>
478     auto scope = DECLARE_THROW_SCOPE(vm);
479 
<span class="line-modified">480     auto leftNumeric = v1.toNumeric(exec);</span>
481     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">482     auto rightNumeric = v2.toNumeric(exec);</span>
483     RETURN_IF_EXCEPTION(scope, { });
484 
485     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
486         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
487             scope.release();
<span class="line-modified">488             return JSBigInt::sub(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
489         }
490 
<span class="line-modified">491         return throwTypeError(exec, scope, &quot;Invalid mix of BigInt and other type in subtraction.&quot;_s);</span>
492     }
493 
494     return jsNumber(WTF::get&lt;double&gt;(leftNumeric) - WTF::get&lt;double&gt;(rightNumeric));
495 }
496 
<span class="line-modified">497 ALWAYS_INLINE JSValue jsMul(ExecState* state, JSValue v1, JSValue v2)</span>
498 {
<span class="line-modified">499     VM&amp; vm = state-&gt;vm();</span>
500     auto scope = DECLARE_THROW_SCOPE(vm);
501 
<span class="line-modified">502     Variant&lt;JSBigInt*, double&gt; leftNumeric = v1.toNumeric(state);</span>
503     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">504     Variant&lt;JSBigInt*, double&gt; rightNumeric = v2.toNumeric(state);</span>
505     RETURN_IF_EXCEPTION(scope, { });
506 
507     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
508         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
509             scope.release();
<span class="line-modified">510             return JSBigInt::multiply(state, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
511         }
512 
<span class="line-modified">513         throwTypeError(state, scope, &quot;Invalid mix of BigInt and other type in multiplication.&quot;_s);</span>
514         return { };
515     }
516 
517     double leftValue =  WTF::get&lt;double&gt;(leftNumeric);
518     double rightValue =  WTF::get&lt;double&gt;(rightNumeric);
519     return jsNumber(leftValue * rightValue);
520 }
521 
522 inline bool scribbleFreeCells()
523 {
<span class="line-modified">524     return !ASSERT_DISABLED || Options::scribbleFreeCells();</span>
525 }
526 
527 #define SCRIBBLE_WORD static_cast&lt;intptr_t&gt;(0xbadbeef0)
528 
529 inline bool isScribbledValue(JSValue value)
530 {
531     return JSValue::encode(value) == JSValue::encode(bitwise_cast&lt;JSCell*&gt;(SCRIBBLE_WORD));
532 }
533 
534 inline void scribble(void* base, size_t size)
535 {
536     for (size_t i = size / sizeof(EncodedJSValue); i--;) {
537         // Use a 16-byte aligned value to ensure that it passes the cell check.
538         static_cast&lt;EncodedJSValue*&gt;(base)[i] = JSValue::encode(bitwise_cast&lt;JSCell*&gt;(SCRIBBLE_WORD));
539     }
540 }
541 














542 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 14  *
 15  *  You should have received a copy of the GNU Library General Public License
 16  *  along with this library; see the file COPYING.LIB.  If not, write to
 17  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  *  Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CallFrame.h&quot;
 25 #include &quot;ExceptionHelpers.h&quot;
 26 #include &quot;JSBigInt.h&quot;
 27 #include &quot;JSCJSValueInlines.h&quot;
 28 #include &lt;wtf/Variant.h&gt;
 29 
 30 namespace JSC {
 31 
 32 #define InvalidPrototypeChain (std::numeric_limits&lt;size_t&gt;::max())
 33 
<span class="line-modified"> 34 NEVER_INLINE JSValue jsAddSlowCase(JSGlobalObject*, JSValue, JSValue);</span>
<span class="line-modified"> 35 JSValue jsTypeStringForValue(JSGlobalObject*, JSValue);</span>
 36 JSValue jsTypeStringForValue(VM&amp;, JSGlobalObject*, JSValue);
<span class="line-modified"> 37 bool jsIsObjectTypeOrNull(JSGlobalObject*, JSValue);</span>
<span class="line-modified"> 38 size_t normalizePrototypeChain(JSGlobalObject*, JSCell*, bool&amp; sawPolyProto);</span>
 39 
<span class="line-modified"> 40 ALWAYS_INLINE JSString* jsString(JSGlobalObject* globalObject, const String&amp; u1, JSString* s2)</span>
 41 {
<span class="line-modified"> 42     VM&amp; vm = getVM(globalObject);</span>
 43     auto scope = DECLARE_THROW_SCOPE(vm);
 44 
 45     unsigned length1 = u1.length();
 46     if (!length1)
 47         return s2;
 48     unsigned length2 = s2-&gt;length();
 49     if (!length2)
 50         return jsString(vm, u1);
 51     static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
 52     if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified"> 53         throwOutOfMemoryError(globalObject, scope);</span>
 54         return nullptr;
 55     }
 56 
 57     // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2
 58     // (2) Cost of making JSRopeString: sizeof(JSString) (for u1) + sizeof(JSRopeString)
 59     // We do not account u1 cost in (2) since u1 may be shared StringImpl, and it may not introduce additional cost.
 60     // We conservatively consider the cost of u1. Currently, we are not considering about is8Bit() case because 16-bit
 61     // strings are relatively rare. But we can do that if we need to consider it.
 62     if (s2-&gt;isRope() || (StringImpl::headerSize&lt;LChar&gt;() + length1 + length2) &gt;= sizeof(JSRopeString))
 63         return JSRopeString::create(vm, jsString(vm, u1), s2);
 64 
 65     ASSERT(!s2-&gt;isRope());
<span class="line-modified"> 66     const String&amp; u2 = s2-&gt;value(globalObject);</span>
 67     scope.assertNoException();
 68     String newString = tryMakeString(u1, u2);
 69     if (!newString) {
<span class="line-modified"> 70         throwOutOfMemoryError(globalObject, scope);</span>
 71         return nullptr;
 72     }
 73     return JSString::create(vm, newString.releaseImpl().releaseNonNull());
 74 }
 75 
<span class="line-modified"> 76 ALWAYS_INLINE JSString* jsString(JSGlobalObject* globalObject, JSString* s1, const String&amp; u2)</span>
 77 {
<span class="line-modified"> 78     VM&amp; vm = getVM(globalObject);</span>
 79     auto scope = DECLARE_THROW_SCOPE(vm);
 80 
 81     unsigned length1 = s1-&gt;length();
 82     if (!length1)
 83         return jsString(vm, u2);
 84     unsigned length2 = u2.length();
 85     if (!length2)
 86         return s1;
 87     static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
 88     if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified"> 89         throwOutOfMemoryError(globalObject, scope);</span>
 90         return nullptr;
 91     }
 92 
 93     // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2
 94     // (2) Cost of making JSRopeString: sizeof(JSString) (for u2) + sizeof(JSRopeString)
 95     if (s1-&gt;isRope() || (StringImpl::headerSize&lt;LChar&gt;() + length1 + length2) &gt;= sizeof(JSRopeString))
 96         return JSRopeString::create(vm, s1, jsString(vm, u2));
 97 
 98     ASSERT(!s1-&gt;isRope());
<span class="line-modified"> 99     const String&amp; u1 = s1-&gt;value(globalObject);</span>
100     scope.assertNoException();
101     String newString = tryMakeString(u1, u2);
102     if (!newString) {
<span class="line-modified">103         throwOutOfMemoryError(globalObject, scope);</span>
104         return nullptr;
105     }
106     return JSString::create(vm, newString.releaseImpl().releaseNonNull());
107 }
108 
<span class="line-modified">109 ALWAYS_INLINE JSString* jsString(JSGlobalObject* globalObject, JSString* s1, JSString* s2)</span>
110 {
<span class="line-modified">111     VM&amp; vm = getVM(globalObject);</span>
112     auto scope = DECLARE_THROW_SCOPE(vm);
113 
114     unsigned length1 = s1-&gt;length();
115     if (!length1)
116         return s2;
117     unsigned length2 = s2-&gt;length();
118     if (!length2)
119         return s1;
120     static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
121     if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified">122         throwOutOfMemoryError(globalObject, scope);</span>
123         return nullptr;
124     }
125 
126     return JSRopeString::create(vm, s1, s2);
127 }
128 
<span class="line-modified">129 ALWAYS_INLINE JSString* jsString(JSGlobalObject* globalObject, JSString* s1, JSString* s2, JSString* s3)</span>
130 {
<span class="line-modified">131     VM&amp; vm = getVM(globalObject);</span>
132     auto scope = DECLARE_THROW_SCOPE(vm);
133 
134     unsigned length1 = s1-&gt;length();
135     if (!length1)
<span class="line-modified">136         RELEASE_AND_RETURN(scope, jsString(globalObject, s2, s3));</span>
137 
138     unsigned length2 = s2-&gt;length();
139     if (!length2)
<span class="line-modified">140         RELEASE_AND_RETURN(scope, jsString(globalObject, s1, s3));</span>
141 
142     unsigned length3 = s3-&gt;length();
143     if (!length3)
<span class="line-modified">144         RELEASE_AND_RETURN(scope, jsString(globalObject, s1, s2));</span>
145 
146     static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
147     if (sumOverflows&lt;int32_t&gt;(length1, length2, length3)) {
<span class="line-modified">148         throwOutOfMemoryError(globalObject, scope);</span>
149         return nullptr;
150     }
151 
152     return JSRopeString::create(vm, s1, s2, s3);
153 }
154 
<span class="line-modified">155 ALWAYS_INLINE JSString* jsString(JSGlobalObject* globalObject, const String&amp; u1, const String&amp; u2)</span>
156 {
<span class="line-modified">157     VM&amp; vm = getVM(globalObject);</span>
158     auto scope = DECLARE_THROW_SCOPE(vm);
159 
160     unsigned length1 = u1.length();
161     if (!length1)
162         return jsString(vm, u2);
163     unsigned length2 = u2.length();
164     if (!length2)
165         return jsString(vm, u1);
166     static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
167     if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified">168         throwOutOfMemoryError(globalObject, scope);</span>
169         return nullptr;
170     }
171 
172     // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2
173     // (2) Cost of making JSRopeString: sizeof(JSString) (for u1) + sizeof(JSString) (for u2) + sizeof(JSRopeString)
174     if ((StringImpl::headerSize&lt;LChar&gt;() + length1 + length2) &gt;= (sizeof(JSRopeString) + sizeof(JSString)))
175         return JSRopeString::create(vm, jsString(vm, u1), jsString(vm, u2));
176 
177     String newString = tryMakeString(u1, u2);
178     if (!newString) {
<span class="line-modified">179         throwOutOfMemoryError(globalObject, scope);</span>
180         return nullptr;
181     }
182     return JSString::create(vm, newString.releaseImpl().releaseNonNull());
183 }
184 
<span class="line-modified">185 ALWAYS_INLINE JSString* jsString(JSGlobalObject* globalObject, const String&amp; u1, const String&amp; u2, const String&amp; u3)</span>
186 {
<span class="line-modified">187     VM&amp; vm = getVM(globalObject);</span>
188     auto scope = DECLARE_THROW_SCOPE(vm);
189 
190     unsigned length1 = u1.length();
191     unsigned length2 = u2.length();
192     unsigned length3 = u3.length();
193     ASSERT(length1 &lt;= JSString::MaxLength);
194     ASSERT(length2 &lt;= JSString::MaxLength);
195     ASSERT(length3 &lt;= JSString::MaxLength);
196 
197     if (!length1)
<span class="line-modified">198         RELEASE_AND_RETURN(scope, jsString(globalObject, u2, u3));</span>
199 
200     if (!length2)
<span class="line-modified">201         RELEASE_AND_RETURN(scope, jsString(globalObject, u1, u3));</span>
202 
203     if (!length3)
<span class="line-modified">204         RELEASE_AND_RETURN(scope, jsString(globalObject, u1, u2));</span>
205 
206     static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
207     if (sumOverflows&lt;int32_t&gt;(length1, length2, length3)) {
<span class="line-modified">208         throwOutOfMemoryError(globalObject, scope);</span>
209         return nullptr;
210     }
211 
212     // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2 + length3
213     // (2) Cost of making JSRopeString: sizeof(JSString) (for u1) + sizeof(JSString) (for u2) + sizeof(JSString) (for u3) + sizeof(JSRopeString)
214     if ((StringImpl::headerSize&lt;LChar&gt;() + length1 + length2 + length3) &gt;= (sizeof(JSRopeString) + sizeof(JSString) * 2))
215         return JSRopeString::create(vm, jsString(vm, u1), jsString(vm, u2), jsString(vm, u3));
216 
217     String newString = tryMakeString(u1, u2, u3);
218     if (!newString) {
<span class="line-modified">219         throwOutOfMemoryError(globalObject, scope);</span>
220         return nullptr;
221     }
222     return JSString::create(vm, newString.releaseImpl().releaseNonNull());
223 }
224 
<span class="line-modified">225 ALWAYS_INLINE JSValue jsStringFromRegisterArray(JSGlobalObject* globalObject, Register* strings, unsigned count)</span>
226 {
<span class="line-modified">227     VM&amp; vm = getVM(globalObject);</span>
228     auto scope = DECLARE_THROW_SCOPE(vm);
229     JSRopeString::RopeBuilder&lt;RecordOverflow&gt; ropeBuilder(vm);
230 
231     for (unsigned i = 0; i &lt; count; ++i) {
232         JSValue v = strings[-static_cast&lt;int&gt;(i)].jsValue();
<span class="line-modified">233         JSString* string = v.toString(globalObject);</span>
234         RETURN_IF_EXCEPTION(scope, { });
235         if (!ropeBuilder.append(string))
<span class="line-modified">236             return throwOutOfMemoryError(globalObject, scope);</span>




















237     }
238 
239     return ropeBuilder.release();
240 }
241 
242 ALWAYS_INLINE bool bigIntCompareResult(JSBigInt::ComparisonResult comparisonResult, JSBigInt::ComparisonMode comparisonMode)
243 {
244     if (comparisonMode == JSBigInt::ComparisonMode::LessThan)
245         return comparisonResult == JSBigInt::ComparisonResult::LessThan;
246 
247     ASSERT(comparisonMode == JSBigInt::ComparisonMode::LessThanOrEqual);
248     return comparisonResult == JSBigInt::ComparisonResult::LessThan || comparisonResult == JSBigInt::ComparisonResult::Equal;
249 }
250 
<span class="line-modified">251 ALWAYS_INLINE bool bigIntCompare(JSGlobalObject* globalObject, JSValue v1, JSValue v2, JSBigInt::ComparisonMode comparisonMode)</span>
252 {
253     ASSERT(v1.isBigInt() || v2.isBigInt());
254     ASSERT(v1.isPrimitive() &amp;&amp; v2.isPrimitive());
255 
<span class="line-modified">256     VM&amp; vm = globalObject-&gt;vm();</span>
257     auto scope = DECLARE_THROW_SCOPE(vm);
258 
259     if (v1.isBigInt() &amp;&amp; v2.isBigInt())
260         return bigIntCompareResult(JSBigInt::compare(asBigInt(v1), asBigInt(v2)), comparisonMode);
261 
262     if (v1.isBigInt()) {
263         JSValue primValue = v2;
264         if (primValue.isString()) {
<span class="line-modified">265             JSBigInt* bigIntValue = JSBigInt::stringToBigInt(globalObject, asString(primValue)-&gt;value(globalObject));</span>
266             RETURN_IF_EXCEPTION(scope, false);
267             if (!bigIntValue)
268                 return false;
269 
270             return bigIntCompareResult(JSBigInt::compare(asBigInt(v1), bigIntValue), comparisonMode);
271         }
272 
273         if (primValue.isBigInt())
274             return bigIntCompareResult(JSBigInt::compare(asBigInt(v1), asBigInt(primValue)), comparisonMode);
275 
<span class="line-modified">276         double numberValue = primValue.toNumber(globalObject);</span>
277         RETURN_IF_EXCEPTION(scope, false);
278         return bigIntCompareResult(JSBigInt::compareToDouble(asBigInt(v1), numberValue), comparisonMode);
279     }
280 
281     JSValue primValue = v1;
282     if (primValue.isString()) {
<span class="line-modified">283         JSBigInt* bigIntValue = JSBigInt::stringToBigInt(globalObject, asString(primValue)-&gt;value(globalObject));</span>
284         RETURN_IF_EXCEPTION(scope, false);
285         if (!bigIntValue)
286             return false;
287 
288         return bigIntCompareResult(JSBigInt::compare(bigIntValue, asBigInt(v2)), comparisonMode);
289     }
290 
291     if (primValue.isBigInt())
292         return bigIntCompareResult(JSBigInt::compare(asBigInt(primValue), asBigInt(v2)), comparisonMode);
293 
<span class="line-modified">294     double numberValue = primValue.toNumber(globalObject);</span>
295     RETURN_IF_EXCEPTION(scope, false);
296 
297     // Here we check inverted because BigInt is the v2
298     JSBigInt::ComparisonResult comparisonResult = JSBigInt::compareToDouble(asBigInt(v2), numberValue);
299     if (comparisonMode == JSBigInt::ComparisonMode::LessThan)
300         return comparisonResult == JSBigInt::ComparisonResult::GreaterThan;
301 
302     return comparisonResult == JSBigInt::ComparisonResult::GreaterThan || comparisonResult == JSBigInt::ComparisonResult::Equal;
303 }
304 
<span class="line-modified">305 ALWAYS_INLINE bool toPrimitiveNumeric(JSGlobalObject* globalObject, JSValue v, JSValue&amp; p, double&amp; n)</span>
306 {
<span class="line-modified">307     VM&amp; vm = globalObject-&gt;vm();</span>
308     auto scope = DECLARE_THROW_SCOPE(vm);
309 
<span class="line-modified">310     p = v.toPrimitive(globalObject, PreferNumber);</span>
311     RETURN_IF_EXCEPTION(scope, false);
312     if (p.isBigInt())
313         return true;
314 
<span class="line-modified">315     n = p.toNumber(globalObject);</span>
316     RETURN_IF_EXCEPTION(scope, false);
317     return !p.isString();
318 }
319 
320 // See ES5 11.8.1/11.8.2/11.8.5 for definition of leftFirst, this value ensures correct
321 // evaluation ordering for argument conversions for &#39;&lt;&#39; and &#39;&gt;&#39;. For &#39;&lt;&#39; pass the value
322 // true, for leftFirst, for &#39;&gt;&#39; pass the value false (and reverse operand order).
323 template&lt;bool leftFirst&gt;
<span class="line-modified">324 ALWAYS_INLINE bool jsLess(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
325 {
<span class="line-modified">326     VM&amp; vm = globalObject-&gt;vm();</span>
327     auto scope = DECLARE_THROW_SCOPE(vm);
328 
329     if (v1.isInt32() &amp;&amp; v2.isInt32())
330         return v1.asInt32() &lt; v2.asInt32();
331 
332     if (v1.isNumber() &amp;&amp; v2.isNumber())
333         return v1.asNumber() &lt; v2.asNumber();
334 
335     if (isJSString(v1) &amp;&amp; isJSString(v2)) {
<span class="line-modified">336         String s1 = asString(v1)-&gt;value(globalObject);</span>
337         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">338         String s2 = asString(v2)-&gt;value(globalObject);</span>
339         RETURN_IF_EXCEPTION(scope, false);
340         return codePointCompareLessThan(s1, s2);
341     }
342 
343     double n1;
344     double n2;
345     JSValue p1;
346     JSValue p2;
347     bool wasNotString1;
348     bool wasNotString2;
349     if (leftFirst) {
<span class="line-modified">350         wasNotString1 = toPrimitiveNumeric(globalObject, v1, p1, n1);</span>
351         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">352         wasNotString2 = toPrimitiveNumeric(globalObject, v2, p2, n2);</span>
353     } else {
<span class="line-modified">354         wasNotString2 = toPrimitiveNumeric(globalObject, v2, p2, n2);</span>
355         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">356         wasNotString1 = toPrimitiveNumeric(globalObject, v1, p1, n1);</span>
357     }
358     RETURN_IF_EXCEPTION(scope, false);
359 
360     if (wasNotString1 | wasNotString2) {
361         if (p1.isBigInt() || p2.isBigInt())
<span class="line-modified">362             RELEASE_AND_RETURN(scope, bigIntCompare(globalObject, p1, p2, JSBigInt::ComparisonMode::LessThan));</span>
363 
364         return n1 &lt; n2;
365     }
366 
<span class="line-modified">367     return codePointCompareLessThan(asString(p1)-&gt;value(globalObject), asString(p2)-&gt;value(globalObject));</span>
368 }
369 
370 // See ES5 11.8.3/11.8.4/11.8.5 for definition of leftFirst, this value ensures correct
371 // evaluation ordering for argument conversions for &#39;&lt;=&#39; and &#39;=&gt;&#39;. For &#39;&lt;=&#39; pass the
372 // value true, for leftFirst, for &#39;=&gt;&#39; pass the value false (and reverse operand order).
373 template&lt;bool leftFirst&gt;
<span class="line-modified">374 ALWAYS_INLINE bool jsLessEq(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
375 {
<span class="line-modified">376     VM&amp; vm = globalObject-&gt;vm();</span>
377     auto scope = DECLARE_THROW_SCOPE(vm);
378 
379     if (v1.isInt32() &amp;&amp; v2.isInt32())
380         return v1.asInt32() &lt;= v2.asInt32();
381 
382     if (v1.isNumber() &amp;&amp; v2.isNumber())
383         return v1.asNumber() &lt;= v2.asNumber();
384 
385     if (isJSString(v1) &amp;&amp; isJSString(v2)) {
<span class="line-modified">386         String s1 = asString(v1)-&gt;value(globalObject);</span>
387         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">388         String s2 = asString(v2)-&gt;value(globalObject);</span>
389         RETURN_IF_EXCEPTION(scope, false);
390         return !codePointCompareLessThan(s2, s1);
391     }
392 
393     double n1;
394     double n2;
395     JSValue p1;
396     JSValue p2;
397     bool wasNotString1;
398     bool wasNotString2;
399     if (leftFirst) {
<span class="line-modified">400         wasNotString1 = toPrimitiveNumeric(globalObject, v1, p1, n1);</span>
401         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">402         wasNotString2 = toPrimitiveNumeric(globalObject, v2, p2, n2);</span>
403     } else {
<span class="line-modified">404         wasNotString2 = toPrimitiveNumeric(globalObject, v2, p2, n2);</span>
405         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">406         wasNotString1 = toPrimitiveNumeric(globalObject, v1, p1, n1);</span>
407     }
408     RETURN_IF_EXCEPTION(scope, false);
409 
410     if (wasNotString1 | wasNotString2) {
411         if (p1.isBigInt() || p2.isBigInt())
<span class="line-modified">412             RELEASE_AND_RETURN(scope, bigIntCompare(globalObject, p1, p2, JSBigInt::ComparisonMode::LessThanOrEqual));</span>
413 
414         return n1 &lt;= n2;
415     }
<span class="line-modified">416     return !codePointCompareLessThan(asString(p2)-&gt;value(globalObject), asString(p1)-&gt;value(globalObject));</span>
417 }
418 
419 // Fast-path choices here are based on frequency data from SunSpider:
420 //    &lt;times&gt; Add case: &lt;t1&gt; &lt;t2&gt;
421 //    ---------------------------
422 //    5626160 Add case: 3 3 (of these, 3637690 are for immediate values)
423 //    247412  Add case: 5 5
424 //    20900   Add case: 5 6
425 //    13962   Add case: 5 3
426 //    4000    Add case: 3 5
427 
428 
<span class="line-modified">429 ALWAYS_INLINE JSValue jsAddNonNumber(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
430 {
<span class="line-modified">431     VM&amp; vm = globalObject-&gt;vm();</span>
432     auto scope = DECLARE_THROW_SCOPE(vm);
433     ASSERT(!v1.isNumber() || !v2.isNumber());
434 
435     if (LIKELY(v1.isString() &amp;&amp; !v2.isObject())) {
436         if (v2.isString())
<span class="line-modified">437             RELEASE_AND_RETURN(scope, jsString(globalObject, asString(v1), asString(v2)));</span>
<span class="line-modified">438         String s2 = v2.toWTFString(globalObject);</span>
439         RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">440         RELEASE_AND_RETURN(scope, jsString(globalObject, asString(v1), s2));</span>
441     }
442 
443     // All other cases are pretty uncommon
<span class="line-modified">444     RELEASE_AND_RETURN(scope, jsAddSlowCase(globalObject, v1, v2));</span>
445 }
446 
<span class="line-modified">447 ALWAYS_INLINE JSValue jsAdd(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
448 {
449     if (v1.isNumber() &amp;&amp; v2.isNumber())
450         return jsNumber(v1.asNumber() + v2.asNumber());
451 
<span class="line-modified">452     return jsAddNonNumber(globalObject, v1, v2);</span>
453 }
454 
<span class="line-modified">455 ALWAYS_INLINE JSValue jsSub(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
456 {
<span class="line-modified">457     VM&amp; vm = getVM(globalObject);</span>
458     auto scope = DECLARE_THROW_SCOPE(vm);
459 
<span class="line-modified">460     auto leftNumeric = v1.toNumeric(globalObject);</span>
461     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">462     auto rightNumeric = v2.toNumeric(globalObject);</span>
463     RETURN_IF_EXCEPTION(scope, { });
464 
465     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
466         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
467             scope.release();
<span class="line-modified">468             return JSBigInt::sub(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
469         }
470 
<span class="line-modified">471         return throwTypeError(globalObject, scope, &quot;Invalid mix of BigInt and other type in subtraction.&quot;_s);</span>
472     }
473 
474     return jsNumber(WTF::get&lt;double&gt;(leftNumeric) - WTF::get&lt;double&gt;(rightNumeric));
475 }
476 
<span class="line-modified">477 ALWAYS_INLINE JSValue jsMul(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
478 {
<span class="line-modified">479     VM&amp; vm = globalObject-&gt;vm();</span>
480     auto scope = DECLARE_THROW_SCOPE(vm);
481 
<span class="line-modified">482     Variant&lt;JSBigInt*, double&gt; leftNumeric = v1.toNumeric(globalObject);</span>
483     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">484     Variant&lt;JSBigInt*, double&gt; rightNumeric = v2.toNumeric(globalObject);</span>
485     RETURN_IF_EXCEPTION(scope, { });
486 
487     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
488         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
489             scope.release();
<span class="line-modified">490             return JSBigInt::multiply(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
491         }
492 
<span class="line-modified">493         throwTypeError(globalObject, scope, &quot;Invalid mix of BigInt and other type in multiplication.&quot;_s);</span>
494         return { };
495     }
496 
497     double leftValue =  WTF::get&lt;double&gt;(leftNumeric);
498     double rightValue =  WTF::get&lt;double&gt;(rightNumeric);
499     return jsNumber(leftValue * rightValue);
500 }
501 
502 inline bool scribbleFreeCells()
503 {
<span class="line-modified">504     return ASSERT_ENABLED || Options::scribbleFreeCells();</span>
505 }
506 
507 #define SCRIBBLE_WORD static_cast&lt;intptr_t&gt;(0xbadbeef0)
508 
509 inline bool isScribbledValue(JSValue value)
510 {
511     return JSValue::encode(value) == JSValue::encode(bitwise_cast&lt;JSCell*&gt;(SCRIBBLE_WORD));
512 }
513 
514 inline void scribble(void* base, size_t size)
515 {
516     for (size_t i = size / sizeof(EncodedJSValue); i--;) {
517         // Use a 16-byte aligned value to ensure that it passes the cell check.
518         static_cast&lt;EncodedJSValue*&gt;(base)[i] = JSValue::encode(bitwise_cast&lt;JSCell*&gt;(SCRIBBLE_WORD));
519     }
520 }
521 
<span class="line-added">522 ALWAYS_INLINE EncodedJSValue getByValWithIndex(JSGlobalObject* globalObject, JSCell* base, uint32_t index)</span>
<span class="line-added">523 {</span>
<span class="line-added">524     if (base-&gt;isObject()) {</span>
<span class="line-added">525         JSObject* object = asObject(base);</span>
<span class="line-added">526         if (object-&gt;canGetIndexQuickly(index))</span>
<span class="line-added">527             return JSValue::encode(object-&gt;getIndexQuickly(index));</span>
<span class="line-added">528     }</span>
<span class="line-added">529 </span>
<span class="line-added">530     if (isJSString(base) &amp;&amp; asString(base)-&gt;canGetIndex(index))</span>
<span class="line-added">531         return JSValue::encode(asString(base)-&gt;getIndex(globalObject, index));</span>
<span class="line-added">532 </span>
<span class="line-added">533     return JSValue::encode(JSValue(base).get(globalObject, index));</span>
<span class="line-added">534 }</span>
<span class="line-added">535 </span>
536 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="Operations.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Options.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
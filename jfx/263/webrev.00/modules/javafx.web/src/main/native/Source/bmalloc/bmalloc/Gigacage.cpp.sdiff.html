<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Environment.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Gigacage.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;Gigacage.h&quot;
 27 
 28 #include &quot;CryptoRandom.h&quot;
 29 #include &quot;Environment.h&quot;
 30 #include &quot;ProcessCheck.h&quot;
 31 #include &quot;StaticPerProcess.h&quot;
 32 #include &quot;VMAllocate.h&quot;
 33 #include &quot;Vector.h&quot;
 34 #include &quot;bmalloc.h&quot;
 35 #include &lt;cstdio&gt;
 36 #include &lt;mutex&gt;
 37 




 38 #if GIGACAGE_ENABLED
 39 
 40 namespace Gigacage {
 41 
 42 struct Callback {
 43     Callback() { }
 44 
 45     Callback(void (*function)(void*), void *argument)
 46         : function(function)
 47         , argument(argument)
 48     {
 49     }
 50 
 51     void (*function)(void*) { nullptr };
 52     void* argument { nullptr };
 53 };
 54 
 55 }
 56 
 57 namespace bmalloc {
 58 
 59 struct PrimitiveDisableCallbacks : public StaticPerProcess&lt;PrimitiveDisableCallbacks&gt; {
<span class="line-modified"> 60     PrimitiveDisableCallbacks(std::lock_guard&lt;Mutex&gt;&amp;) { }</span>
 61 
 62     Vector&lt;Gigacage::Callback&gt; callbacks;
 63 };
 64 DECLARE_STATIC_PER_PROCESS_STORAGE(PrimitiveDisableCallbacks);
 65 DEFINE_STATIC_PER_PROCESS_STORAGE(PrimitiveDisableCallbacks);
 66 
 67 } // namespace bmalloc
 68 
 69 namespace Gigacage {
 70 
 71 // This is exactly 32GB because inside JSC, indexed accesses for arrays, typed arrays, etc,
 72 // use unsigned 32-bit ints as indices. The items those indices access are 8 bytes or less
 73 // in size. 2^32 * 8 = 32GB. This means if an access on a caged type happens to go out of
 74 // bounds, the access is guaranteed to land somewhere else in the cage or inside the runway.
 75 // If this were less than 32GB, those OOB accesses could reach outside of the cage.
<span class="line-modified"> 76 constexpr size_t gigacageRunway = 32llu * 1024 * 1024 * 1024;</span>
 77 
<span class="line-modified"> 78 // Note: g_gigacageBasePtrs[0] is reserved for storing the wasEnabled flag.</span>
<span class="line-removed"> 79 // The first gigacageBasePtr will start at g_gigacageBasePtrs[sizeof(void*)].</span>
<span class="line-removed"> 80 // This is done so that the wasEnabled flag will also be protected along with the</span>
<span class="line-removed"> 81 // gigacageBasePtrs.</span>
<span class="line-removed"> 82 alignas(gigacageBasePtrsSize) char g_gigacageBasePtrs[gigacageBasePtrsSize];</span>
 83 
 84 using namespace bmalloc;
 85 
 86 namespace {
 87 
<span class="line-modified"> 88 bool s_isDisablingPrimitiveGigacageDisabled;</span>
















 89 
<span class="line-modified"> 90 void protectGigacageBasePtrs()</span>
 91 {
<span class="line-modified"> 92     uintptr_t basePtrs = reinterpret_cast&lt;uintptr_t&gt;(g_gigacageBasePtrs);</span>
<span class="line-modified"> 93     // We might only get page size alignment, but that&#39;s also the minimum we need.</span>
<span class="line-modified"> 94     RELEASE_BASSERT(!(basePtrs &amp; (vmPageSize() - 1)));</span>
<span class="line-modified"> 95     mprotect(g_gigacageBasePtrs, gigacageBasePtrsSize, PROT_READ);</span>




 96 }
 97 
<span class="line-modified"> 98 void unprotectGigacageBasePtrs()</span>
 99 {
<span class="line-modified">100     mprotect(g_gigacageBasePtrs, gigacageBasePtrsSize, PROT_READ | PROT_WRITE);</span>












101 }
102 
<span class="line-modified">103 class UnprotectGigacageBasePtrsScope {</span>
104 public:
<span class="line-modified">105     UnprotectGigacageBasePtrsScope()</span>
106     {
<span class="line-modified">107         unprotectGigacageBasePtrs();</span>
108     }
109 
<span class="line-modified">110     ~UnprotectGigacageBasePtrsScope()</span>
111     {
<span class="line-modified">112         protectGigacageBasePtrs();</span>
113     }
114 };
115 
116 size_t runwaySize(Kind kind)
117 {
118     switch (kind) {
<span class="line-removed">119     case Kind::ReservedForFlagsAndNotABasePtr:</span>
<span class="line-removed">120         RELEASE_BASSERT_NOT_REACHED();</span>
121     case Kind::Primitive:
122         return gigacageRunway;
123     case Kind::JSValue:
124         return 0;


125     }
126     return 0;
127 }
128 
129 } // anonymous namespace
130 
131 void ensureGigacage()
132 {
133     static std::once_flag onceFlag;
134     std::call_once(
135         onceFlag,
136         [] {



137             if (!shouldBeEnabled())
138                 return;
139 
<span class="line-modified">140             Kind shuffledKinds[numKinds];</span>
<span class="line-modified">141             for (unsigned i = 0; i &lt; numKinds; ++i)</span>
<span class="line-modified">142                 shuffledKinds[i] = static_cast&lt;Kind&gt;(i + 1); // + 1 to skip Kind::ReservedForFlagsAndNotABasePtr.</span>




143 
144             // We just go ahead and assume that 64 bits is enough randomness. That&#39;s trivially true right
145             // now, but would stop being true if we went crazy with gigacages. Based on my math, 21 is the
146             // largest value of n so that n! &lt;= 2^64.
<span class="line-modified">147             static_assert(numKinds &lt;= 21, &quot;too many kinds&quot;);</span>
148             uint64_t random;
149             cryptoRandom(reinterpret_cast&lt;unsigned char*&gt;(&amp;random), sizeof(random));
<span class="line-modified">150             for (unsigned i = numKinds; i--;) {</span>
151                 unsigned limit = i + 1;
152                 unsigned j = static_cast&lt;unsigned&gt;(random % limit);
153                 random /= limit;
154                 std::swap(shuffledKinds[i], shuffledKinds[j]);
155             }
156 
157             auto alignTo = [] (Kind kind, size_t totalSize) -&gt; size_t {
158                 return roundUpToMultipleOf(alignment(kind), totalSize);
159             };
160             auto bump = [] (Kind kind, size_t totalSize) -&gt; size_t {
161                 return totalSize + size(kind);
162             };
163 
164             size_t totalSize = 0;
165             size_t maxAlignment = 0;
166 
167             for (Kind kind : shuffledKinds) {
168                 totalSize = bump(kind, alignTo(kind, totalSize));
169                 totalSize += runwaySize(kind);
170                 maxAlignment = std::max(maxAlignment, alignment(kind));
171             }
172 
173             // FIXME: Randomize where this goes.
174             // https://bugs.webkit.org/show_bug.cgi?id=175245
175             void* base = tryVMAllocate(maxAlignment, totalSize, VMTag::JSGigacage);
176             if (!base) {
177                 if (GIGACAGE_ALLOCATION_CAN_FAIL)
178                     return;
179                 fprintf(stderr, &quot;FATAL: Could not allocate gigacage memory with maxAlignment = %lu, totalSize = %lu.\n&quot;, maxAlignment, totalSize);
180                 fprintf(stderr, &quot;(Make sure you have not set a virtual memory limit.)\n&quot;);
181                 BCRASH();
182             }
183 
184             size_t nextCage = 0;
185             for (Kind kind : shuffledKinds) {
186                 nextCage = alignTo(kind, nextCage);
<span class="line-modified">187                 basePtr(kind) = reinterpret_cast&lt;char*&gt;(base) + nextCage;</span>
188                 nextCage = bump(kind, nextCage);
189                 if (runwaySize(kind) &gt; 0) {
190                     char* runway = reinterpret_cast&lt;char*&gt;(base) + nextCage;
191                     // Make OOB accesses into the runway crash.
192                     vmRevokePermissions(runway, runwaySize(kind));
193                     nextCage += runwaySize(kind);
194                 }
195             }
196 


197             vmDeallocatePhysicalPages(base, totalSize);
<span class="line-modified">198             setWasEnabled();</span>
<span class="line-modified">199             protectGigacageBasePtrs();</span>
200         });
201 }
202 
203 void disablePrimitiveGigacage()
204 {






205     ensureGigacage();
<span class="line-modified">206     if (!basePtrs().primitive) {</span>
207         // It was never enabled. That means that we never even saved any callbacks. Or, we had already disabled
208         // it before, and already called the callbacks.
209         return;
210     }
211 
212     PrimitiveDisableCallbacks&amp; callbacks = *PrimitiveDisableCallbacks::get();
<span class="line-modified">213     std::unique_lock&lt;Mutex&gt; lock(PrimitiveDisableCallbacks::mutex());</span>
214     for (Callback&amp; callback : callbacks.callbacks)
215         callback.function(callback.argument);
216     callbacks.callbacks.shrink(0);
<span class="line-modified">217     UnprotectGigacageBasePtrsScope unprotectScope;</span>
<span class="line-modified">218     basePtrs().primitive = nullptr;</span>
219 }
220 
221 void addPrimitiveDisableCallback(void (*function)(void*), void* argument)
222 {
223     ensureGigacage();
<span class="line-modified">224     if (!basePtrs().primitive) {</span>
225         // It was already disabled or we were never able to enable it.
226         function(argument);
227         return;
228     }
229 
230     PrimitiveDisableCallbacks&amp; callbacks = *PrimitiveDisableCallbacks::get();
<span class="line-modified">231     std::unique_lock&lt;Mutex&gt; lock(PrimitiveDisableCallbacks::mutex());</span>
232     callbacks.callbacks.push(Callback(function, argument));
233 }
234 
235 void removePrimitiveDisableCallback(void (*function)(void*), void* argument)
236 {
237     PrimitiveDisableCallbacks&amp; callbacks = *PrimitiveDisableCallbacks::get();
<span class="line-modified">238     std::unique_lock&lt;Mutex&gt; lock(PrimitiveDisableCallbacks::mutex());</span>
239     for (size_t i = 0; i &lt; callbacks.callbacks.size(); ++i) {
240         if (callbacks.callbacks[i].function == function
241             &amp;&amp; callbacks.callbacks[i].argument == argument) {
242             callbacks.callbacks[i] = callbacks.callbacks.last();
243             callbacks.callbacks.pop();
244             return;
245         }
246     }
247 }
248 
<span class="line-modified">249 static void primitiveGigacageDisabled(void*)</span>
250 {
<span class="line-modified">251     if (GIGACAGE_ALLOCATION_CAN_FAIL &amp;&amp; !wasEnabled())</span>
<span class="line-modified">252         return;</span>
<span class="line-modified">253 </span>
<span class="line-modified">254     static bool s_false;</span>
<span class="line-modified">255     fprintf(stderr, &quot;FATAL: Primitive gigacage disabled, but we don&#39;t want that in this process.\n&quot;);</span>
<span class="line-modified">256     if (!s_false)</span>
<span class="line-removed">257         BCRASH();</span>
258 }
259 
<span class="line-modified">260 void disableDisablingPrimitiveGigacageIfShouldBeEnabled()</span>
261 {
<span class="line-modified">262     if (shouldBeEnabled()) {</span>
<span class="line-modified">263         addPrimitiveDisableCallback(primitiveGigacageDisabled, nullptr);</span>
<span class="line-modified">264         s_isDisablingPrimitiveGigacageDisabled = true;</span>




265     }


266 }
267 
<span class="line-modified">268 bool isDisablingPrimitiveGigacageDisabled()</span>
269 {
<span class="line-modified">270     return s_isDisablingPrimitiveGigacageDisabled;</span>
271 }
272 
273 bool shouldBeEnabled()
274 {
<span class="line-removed">275     static bool cached = false;</span>
276     static std::once_flag onceFlag;
277     std::call_once(
278         onceFlag,
279         [] {



280             bool debugHeapEnabled = Environment::get()-&gt;isDebugHeapEnabled();
281             if (debugHeapEnabled)
282                 return;
283 
284             if (!gigacageEnabledForProcess())
285                 return;
286 
287             if (char* gigacageEnabled = getenv(&quot;GIGACAGE_ENABLED&quot;)) {
288                 if (!strcasecmp(gigacageEnabled, &quot;no&quot;) || !strcasecmp(gigacageEnabled, &quot;false&quot;) || !strcasecmp(gigacageEnabled, &quot;0&quot;)) {
289                     fprintf(stderr, &quot;Warning: disabling gigacage because GIGACAGE_ENABLED=%s!\n&quot;, gigacageEnabled);
290                     return;
291                 } else if (strcasecmp(gigacageEnabled, &quot;yes&quot;) &amp;&amp; strcasecmp(gigacageEnabled, &quot;true&quot;) &amp;&amp; strcasecmp(gigacageEnabled, &quot;1&quot;))
292                     fprintf(stderr, &quot;Warning: invalid argument to GIGACAGE_ENABLED: %s\n&quot;, gigacageEnabled);
293             }
294 
<span class="line-modified">295             cached = true;</span>
296         });
<span class="line-modified">297     return cached;</span>
298 }
299 
300 } // namespace Gigacage
301 
302 #endif // GIGACAGE_ENABLED
<span class="line-removed">303 </span>
<span class="line-removed">304 </span>
</pre>
</td>
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;Gigacage.h&quot;
 27 
 28 #include &quot;CryptoRandom.h&quot;
 29 #include &quot;Environment.h&quot;
 30 #include &quot;ProcessCheck.h&quot;
 31 #include &quot;StaticPerProcess.h&quot;
 32 #include &quot;VMAllocate.h&quot;
 33 #include &quot;Vector.h&quot;
 34 #include &quot;bmalloc.h&quot;
 35 #include &lt;cstdio&gt;
 36 #include &lt;mutex&gt;
 37 
<span class="line-added"> 38 #if BOS(DARWIN)</span>
<span class="line-added"> 39 #include &lt;mach/mach.h&gt;</span>
<span class="line-added"> 40 #endif</span>
<span class="line-added"> 41 </span>
 42 #if GIGACAGE_ENABLED
 43 
 44 namespace Gigacage {
 45 
 46 struct Callback {
 47     Callback() { }
 48 
 49     Callback(void (*function)(void*), void *argument)
 50         : function(function)
 51         , argument(argument)
 52     {
 53     }
 54 
 55     void (*function)(void*) { nullptr };
 56     void* argument { nullptr };
 57 };
 58 
 59 }
 60 
 61 namespace bmalloc {
 62 
 63 struct PrimitiveDisableCallbacks : public StaticPerProcess&lt;PrimitiveDisableCallbacks&gt; {
<span class="line-modified"> 64     PrimitiveDisableCallbacks(const LockHolder&amp;) { }</span>
 65 
 66     Vector&lt;Gigacage::Callback&gt; callbacks;
 67 };
 68 DECLARE_STATIC_PER_PROCESS_STORAGE(PrimitiveDisableCallbacks);
 69 DEFINE_STATIC_PER_PROCESS_STORAGE(PrimitiveDisableCallbacks);
 70 
 71 } // namespace bmalloc
 72 
 73 namespace Gigacage {
 74 
 75 // This is exactly 32GB because inside JSC, indexed accesses for arrays, typed arrays, etc,
 76 // use unsigned 32-bit ints as indices. The items those indices access are 8 bytes or less
 77 // in size. 2^32 * 8 = 32GB. This means if an access on a caged type happens to go out of
 78 // bounds, the access is guaranteed to land somewhere else in the cage or inside the runway.
 79 // If this were less than 32GB, those OOB accesses could reach outside of the cage.
<span class="line-modified"> 80 constexpr size_t gigacageRunway = 32llu * bmalloc::Sizes::GB;</span>
 81 
<span class="line-modified"> 82 alignas(configSizeToProtect) Config g_gigacageConfig;</span>




 83 
 84 using namespace bmalloc;
 85 
 86 namespace {
 87 
<span class="line-modified"> 88 #if BOS(DARWIN)</span>
<span class="line-added"> 89 enum {</span>
<span class="line-added"> 90     AllowPermissionChangesAfterThis = false,</span>
<span class="line-added"> 91     DisallowPermissionChangesAfterThis = true</span>
<span class="line-added"> 92 };</span>
<span class="line-added"> 93 #endif</span>
<span class="line-added"> 94 </span>
<span class="line-added"> 95 static void freezeGigacageConfig()</span>
<span class="line-added"> 96 {</span>
<span class="line-added"> 97     int result;</span>
<span class="line-added"> 98 #if BOS(DARWIN)</span>
<span class="line-added"> 99     result = vm_protect(mach_task_self(), reinterpret_cast&lt;vm_address_t&gt;(&amp;g_gigacageConfig), configSizeToProtect, AllowPermissionChangesAfterThis, VM_PROT_READ);</span>
<span class="line-added">100 #else</span>
<span class="line-added">101     result = mprotect(&amp;g_gigacageConfig, configSizeToProtect, PROT_READ);</span>
<span class="line-added">102 #endif</span>
<span class="line-added">103     RELEASE_BASSERT(!result);</span>
<span class="line-added">104 }</span>
105 
<span class="line-modified">106 static void unfreezeGigacageConfig()</span>
107 {
<span class="line-modified">108     RELEASE_BASSERT(!g_gigacageConfig.isPermanentlyFrozen);</span>
<span class="line-modified">109     int result;</span>
<span class="line-modified">110 #if BOS(DARWIN)</span>
<span class="line-modified">111     result = vm_protect(mach_task_self(), reinterpret_cast&lt;vm_address_t&gt;(&amp;g_gigacageConfig), configSizeToProtect, AllowPermissionChangesAfterThis, VM_PROT_READ | VM_PROT_WRITE);</span>
<span class="line-added">112 #else</span>
<span class="line-added">113     result = mprotect(&amp;g_gigacageConfig, configSizeToProtect, PROT_READ | PROT_WRITE);</span>
<span class="line-added">114 #endif</span>
<span class="line-added">115     RELEASE_BASSERT(!result);</span>
116 }
117 
<span class="line-modified">118 static void permanentlyFreezeGigacageConfig()</span>
119 {
<span class="line-modified">120     if (!g_gigacageConfig.isPermanentlyFrozen) {</span>
<span class="line-added">121         unfreezeGigacageConfig();</span>
<span class="line-added">122         g_gigacageConfig.isPermanentlyFrozen = true;</span>
<span class="line-added">123     }</span>
<span class="line-added">124 </span>
<span class="line-added">125     // There&#39;s no going back now!</span>
<span class="line-added">126     int result;</span>
<span class="line-added">127 #if BOS(DARWIN)</span>
<span class="line-added">128     result = vm_protect(mach_task_self(), reinterpret_cast&lt;vm_address_t&gt;(&amp;g_gigacageConfig), configSizeToProtect, DisallowPermissionChangesAfterThis, VM_PROT_READ);</span>
<span class="line-added">129 #else</span>
<span class="line-added">130     result = mprotect(&amp;g_gigacageConfig, configSizeToProtect, PROT_READ);</span>
<span class="line-added">131 #endif</span>
<span class="line-added">132     RELEASE_BASSERT(!result);</span>
133 }
134 
<span class="line-modified">135 class UnfreezeGigacageConfigScope {</span>
136 public:
<span class="line-modified">137     UnfreezeGigacageConfigScope()</span>
138     {
<span class="line-modified">139         unfreezeGigacageConfig();</span>
140     }
141 
<span class="line-modified">142     ~UnfreezeGigacageConfigScope()</span>
143     {
<span class="line-modified">144         freezeGigacageConfig();</span>
145     }
146 };
147 
148 size_t runwaySize(Kind kind)
149 {
150     switch (kind) {


151     case Kind::Primitive:
152         return gigacageRunway;
153     case Kind::JSValue:
154         return 0;
<span class="line-added">155     case Kind::NumberOfKinds:</span>
<span class="line-added">156         RELEASE_BASSERT_NOT_REACHED();</span>
157     }
158     return 0;
159 }
160 
161 } // anonymous namespace
162 
163 void ensureGigacage()
164 {
165     static std::once_flag onceFlag;
166     std::call_once(
167         onceFlag,
168         [] {
<span class="line-added">169             RELEASE_BASSERT(!g_gigacageConfig.ensureGigacageHasBeenCalled);</span>
<span class="line-added">170             g_gigacageConfig.ensureGigacageHasBeenCalled = true;</span>
<span class="line-added">171 </span>
172             if (!shouldBeEnabled())
173                 return;
174 
<span class="line-modified">175             // We might only get page size alignment, but that&#39;s also the minimum</span>
<span class="line-modified">176             // alignment we need for freezing the Config.</span>
<span class="line-modified">177             RELEASE_BASSERT(!(reinterpret_cast&lt;size_t&gt;(&amp;g_gigacageConfig) &amp; (vmPageSize() - 1)));</span>
<span class="line-added">178 </span>
<span class="line-added">179             Kind shuffledKinds[NumberOfKinds];</span>
<span class="line-added">180             for (unsigned i = 0; i &lt; NumberOfKinds; ++i)</span>
<span class="line-added">181                 shuffledKinds[i] = static_cast&lt;Kind&gt;(i);</span>
182 
183             // We just go ahead and assume that 64 bits is enough randomness. That&#39;s trivially true right
184             // now, but would stop being true if we went crazy with gigacages. Based on my math, 21 is the
185             // largest value of n so that n! &lt;= 2^64.
<span class="line-modified">186             static_assert(NumberOfKinds &lt;= 21, &quot;too many kinds&quot;);</span>
187             uint64_t random;
188             cryptoRandom(reinterpret_cast&lt;unsigned char*&gt;(&amp;random), sizeof(random));
<span class="line-modified">189             for (unsigned i = NumberOfKinds; i--;) {</span>
190                 unsigned limit = i + 1;
191                 unsigned j = static_cast&lt;unsigned&gt;(random % limit);
192                 random /= limit;
193                 std::swap(shuffledKinds[i], shuffledKinds[j]);
194             }
195 
196             auto alignTo = [] (Kind kind, size_t totalSize) -&gt; size_t {
197                 return roundUpToMultipleOf(alignment(kind), totalSize);
198             };
199             auto bump = [] (Kind kind, size_t totalSize) -&gt; size_t {
200                 return totalSize + size(kind);
201             };
202 
203             size_t totalSize = 0;
204             size_t maxAlignment = 0;
205 
206             for (Kind kind : shuffledKinds) {
207                 totalSize = bump(kind, alignTo(kind, totalSize));
208                 totalSize += runwaySize(kind);
209                 maxAlignment = std::max(maxAlignment, alignment(kind));
210             }
211 
212             // FIXME: Randomize where this goes.
213             // https://bugs.webkit.org/show_bug.cgi?id=175245
214             void* base = tryVMAllocate(maxAlignment, totalSize, VMTag::JSGigacage);
215             if (!base) {
216                 if (GIGACAGE_ALLOCATION_CAN_FAIL)
217                     return;
218                 fprintf(stderr, &quot;FATAL: Could not allocate gigacage memory with maxAlignment = %lu, totalSize = %lu.\n&quot;, maxAlignment, totalSize);
219                 fprintf(stderr, &quot;(Make sure you have not set a virtual memory limit.)\n&quot;);
220                 BCRASH();
221             }
222 
223             size_t nextCage = 0;
224             for (Kind kind : shuffledKinds) {
225                 nextCage = alignTo(kind, nextCage);
<span class="line-modified">226                 g_gigacageConfig.setBasePtr(kind, reinterpret_cast&lt;char*&gt;(base) + nextCage);</span>
227                 nextCage = bump(kind, nextCage);
228                 if (runwaySize(kind) &gt; 0) {
229                     char* runway = reinterpret_cast&lt;char*&gt;(base) + nextCage;
230                     // Make OOB accesses into the runway crash.
231                     vmRevokePermissions(runway, runwaySize(kind));
232                     nextCage += runwaySize(kind);
233                 }
234             }
235 
<span class="line-added">236             g_gigacageConfig.start = base;</span>
<span class="line-added">237             g_gigacageConfig.totalSize = totalSize;</span>
238             vmDeallocatePhysicalPages(base, totalSize);
<span class="line-modified">239             g_gigacageConfig.isEnabled = true;</span>
<span class="line-modified">240             freezeGigacageConfig();</span>
241         });
242 }
243 
244 void disablePrimitiveGigacage()
245 {
<span class="line-added">246     if (g_gigacageConfig.disablingPrimitiveGigacageIsForbidden)</span>
<span class="line-added">247         fprintf(stderr, &quot;FATAL: Disabling Primitive gigacage is forbidden, but we don&#39;t want that in this process.\n&quot;);</span>
<span class="line-added">248 </span>
<span class="line-added">249     RELEASE_BASSERT(!g_gigacageConfig.disablingPrimitiveGigacageIsForbidden);</span>
<span class="line-added">250     RELEASE_BASSERT(!g_gigacageConfig.isPermanentlyFrozen);</span>
<span class="line-added">251 </span>
252     ensureGigacage();
<span class="line-modified">253     if (!g_gigacageConfig.basePtrs[Primitive]) {</span>
254         // It was never enabled. That means that we never even saved any callbacks. Or, we had already disabled
255         // it before, and already called the callbacks.
256         return;
257     }
258 
259     PrimitiveDisableCallbacks&amp; callbacks = *PrimitiveDisableCallbacks::get();
<span class="line-modified">260     UniqueLockHolder lock(PrimitiveDisableCallbacks::mutex());</span>
261     for (Callback&amp; callback : callbacks.callbacks)
262         callback.function(callback.argument);
263     callbacks.callbacks.shrink(0);
<span class="line-modified">264     UnfreezeGigacageConfigScope unfreezeScope;</span>
<span class="line-modified">265     g_gigacageConfig.basePtrs[Primitive] = nullptr;</span>
266 }
267 
268 void addPrimitiveDisableCallback(void (*function)(void*), void* argument)
269 {
270     ensureGigacage();
<span class="line-modified">271     if (!g_gigacageConfig.basePtrs[Primitive]) {</span>
272         // It was already disabled or we were never able to enable it.
273         function(argument);
274         return;
275     }
276 
277     PrimitiveDisableCallbacks&amp; callbacks = *PrimitiveDisableCallbacks::get();
<span class="line-modified">278     UniqueLockHolder lock(PrimitiveDisableCallbacks::mutex());</span>
279     callbacks.callbacks.push(Callback(function, argument));
280 }
281 
282 void removePrimitiveDisableCallback(void (*function)(void*), void* argument)
283 {
284     PrimitiveDisableCallbacks&amp; callbacks = *PrimitiveDisableCallbacks::get();
<span class="line-modified">285     UniqueLockHolder lock(PrimitiveDisableCallbacks::mutex());</span>
286     for (size_t i = 0; i &lt; callbacks.callbacks.size(); ++i) {
287         if (callbacks.callbacks[i].function == function
288             &amp;&amp; callbacks.callbacks[i].argument == argument) {
289             callbacks.callbacks[i] = callbacks.callbacks.last();
290             callbacks.callbacks.pop();
291             return;
292         }
293     }
294 }
295 
<span class="line-modified">296 static bool verifyGigacageIsEnabled()</span>
297 {
<span class="line-modified">298     bool isEnabled = g_gigacageConfig.isEnabled;</span>
<span class="line-modified">299     for (size_t i = 0; i &lt; NumberOfKinds; ++i)</span>
<span class="line-modified">300         isEnabled = isEnabled &amp;&amp; g_gigacageConfig.basePtrs[i];</span>
<span class="line-modified">301     isEnabled = isEnabled &amp;&amp; g_gigacageConfig.start;</span>
<span class="line-modified">302     isEnabled = isEnabled &amp;&amp; g_gigacageConfig.totalSize;</span>
<span class="line-modified">303     return isEnabled;</span>

304 }
305 
<span class="line-modified">306 void forbidDisablingPrimitiveGigacage()</span>
307 {
<span class="line-modified">308     ensureGigacage();</span>
<span class="line-modified">309     RELEASE_BASSERT(g_gigacageConfig.shouldBeEnabledHasBeenCalled</span>
<span class="line-modified">310         &amp;&amp; (GIGACAGE_ALLOCATION_CAN_FAIL || !g_gigacageConfig.shouldBeEnabled || verifyGigacageIsEnabled()));</span>
<span class="line-added">311 </span>
<span class="line-added">312     if (!g_gigacageConfig.disablingPrimitiveGigacageIsForbidden) {</span>
<span class="line-added">313         unfreezeGigacageConfig();</span>
<span class="line-added">314         g_gigacageConfig.disablingPrimitiveGigacageIsForbidden = true;</span>
315     }
<span class="line-added">316     permanentlyFreezeGigacageConfig();</span>
<span class="line-added">317     RELEASE_BASSERT(isDisablingPrimitiveGigacageForbidden());</span>
318 }
319 
<span class="line-modified">320 BNO_INLINE bool isDisablingPrimitiveGigacageForbidden()</span>
321 {
<span class="line-modified">322     return g_gigacageConfig.disablingPrimitiveGigacageIsForbidden;</span>
323 }
324 
325 bool shouldBeEnabled()
326 {

327     static std::once_flag onceFlag;
328     std::call_once(
329         onceFlag,
330         [] {
<span class="line-added">331             RELEASE_BASSERT(!g_gigacageConfig.shouldBeEnabledHasBeenCalled);</span>
<span class="line-added">332             g_gigacageConfig.shouldBeEnabledHasBeenCalled = true;</span>
<span class="line-added">333 </span>
334             bool debugHeapEnabled = Environment::get()-&gt;isDebugHeapEnabled();
335             if (debugHeapEnabled)
336                 return;
337 
338             if (!gigacageEnabledForProcess())
339                 return;
340 
341             if (char* gigacageEnabled = getenv(&quot;GIGACAGE_ENABLED&quot;)) {
342                 if (!strcasecmp(gigacageEnabled, &quot;no&quot;) || !strcasecmp(gigacageEnabled, &quot;false&quot;) || !strcasecmp(gigacageEnabled, &quot;0&quot;)) {
343                     fprintf(stderr, &quot;Warning: disabling gigacage because GIGACAGE_ENABLED=%s!\n&quot;, gigacageEnabled);
344                     return;
345                 } else if (strcasecmp(gigacageEnabled, &quot;yes&quot;) &amp;&amp; strcasecmp(gigacageEnabled, &quot;true&quot;) &amp;&amp; strcasecmp(gigacageEnabled, &quot;1&quot;))
346                     fprintf(stderr, &quot;Warning: invalid argument to GIGACAGE_ENABLED: %s\n&quot;, gigacageEnabled);
347             }
348 
<span class="line-modified">349             g_gigacageConfig.shouldBeEnabled = true;</span>
350         });
<span class="line-modified">351     return g_gigacageConfig.shouldBeEnabled;</span>
352 }
353 
354 } // namespace Gigacage
355 
356 #endif // GIGACAGE_ENABLED


</pre>
</td>
</tr>
</table>
<center><a href="Environment.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Gigacage.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/PerProcess.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PerProcess.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PerThread.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/PerProcess.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 #include &quot;Mutex.h&quot;
 30 #include &quot;Sizes.h&quot;
 31 
 32 namespace bmalloc {
 33 
 34 // Usage:
 35 //     Object* object = PerProcess&lt;Object&gt;::get();
 36 //     x = object-&gt;field-&gt;field;
 37 //
 38 // Object will be instantiated only once, even in the face of concurrency.
 39 //
 40 // NOTE: If you observe global side-effects of the Object constructor, be
 41 // sure to lock the Object mutex. For example:
 42 //
 43 // Object() : m_field(...) { globalFlag = true }
 44 //
 45 // Object* object = PerProcess&lt;Object&gt;::get();
 46 // x = object-&gt;m_field; // OK
 47 // if (globalFlag) { ... } // Undefined behavior.
 48 //
<span class="line-modified"> 49 // std::lock_guard&lt;Mutex&gt; lock(PerProcess&lt;Object&gt;::mutex());</span>
 50 // Object* object = PerProcess&lt;Object&gt;::get(lock);
 51 // if (globalFlag) { ... } // OK.
 52 
 53 struct PerProcessData {
 54     const char* disambiguator;
 55     void* memory;
 56     size_t size;
 57     size_t alignment;
 58     Mutex mutex;
 59     bool isInitialized;
 60     PerProcessData* next;
 61 };
 62 
 63 constexpr unsigned stringHash(const char* string)
 64 {
 65     unsigned result = 5381;
 66     while (char c = *string++)
 67         result = result * 33 + c;
 68     return result;
 69 }
</pre>
<hr />
<pre>
 88 
 89     static Mutex&amp; mutex()
 90     {
 91         if (!s_data)
 92             coalesce();
 93         return s_data-&gt;mutex;
 94     }
 95 
 96 private:
 97     static void coalesce()
 98     {
 99         if (s_data)
100             return;
101 
102         const char* disambiguator = __PRETTY_FUNCTION__;
103         s_data = getPerProcessData(stringHash(disambiguator), disambiguator, sizeof(T), std::alignment_of&lt;T&gt;::value);
104     }
105 
106     BNO_INLINE static T* getSlowCase()
107     {
<span class="line-modified">108         std::lock_guard&lt;Mutex&gt; lock(mutex());</span>
109         if (!s_object.load()) {
110             if (s_data-&gt;isInitialized)
111                 s_object.store(static_cast&lt;T*&gt;(s_data-&gt;memory));
112             else {
113                 T* t = new (s_data-&gt;memory) T(lock);
114                 s_object.store(t);
115                 s_data-&gt;isInitialized = true;
116             }
117         }
118         return s_object.load();
119     }
120 
121     static std::atomic&lt;T*&gt; s_object;
122     static PerProcessData* s_data;
123 };
124 
125 template&lt;typename T&gt;
126 std::atomic&lt;T*&gt; PerProcess&lt;T&gt;::s_object { nullptr };
127 
128 template&lt;typename T&gt;
</pre>
</td>
<td>
<hr />
<pre>
 29 #include &quot;Mutex.h&quot;
 30 #include &quot;Sizes.h&quot;
 31 
 32 namespace bmalloc {
 33 
 34 // Usage:
 35 //     Object* object = PerProcess&lt;Object&gt;::get();
 36 //     x = object-&gt;field-&gt;field;
 37 //
 38 // Object will be instantiated only once, even in the face of concurrency.
 39 //
 40 // NOTE: If you observe global side-effects of the Object constructor, be
 41 // sure to lock the Object mutex. For example:
 42 //
 43 // Object() : m_field(...) { globalFlag = true }
 44 //
 45 // Object* object = PerProcess&lt;Object&gt;::get();
 46 // x = object-&gt;m_field; // OK
 47 // if (globalFlag) { ... } // Undefined behavior.
 48 //
<span class="line-modified"> 49 // LockHolder lock(PerProcess&lt;Object&gt;::mutex());</span>
 50 // Object* object = PerProcess&lt;Object&gt;::get(lock);
 51 // if (globalFlag) { ... } // OK.
 52 
 53 struct PerProcessData {
 54     const char* disambiguator;
 55     void* memory;
 56     size_t size;
 57     size_t alignment;
 58     Mutex mutex;
 59     bool isInitialized;
 60     PerProcessData* next;
 61 };
 62 
 63 constexpr unsigned stringHash(const char* string)
 64 {
 65     unsigned result = 5381;
 66     while (char c = *string++)
 67         result = result * 33 + c;
 68     return result;
 69 }
</pre>
<hr />
<pre>
 88 
 89     static Mutex&amp; mutex()
 90     {
 91         if (!s_data)
 92             coalesce();
 93         return s_data-&gt;mutex;
 94     }
 95 
 96 private:
 97     static void coalesce()
 98     {
 99         if (s_data)
100             return;
101 
102         const char* disambiguator = __PRETTY_FUNCTION__;
103         s_data = getPerProcessData(stringHash(disambiguator), disambiguator, sizeof(T), std::alignment_of&lt;T&gt;::value);
104     }
105 
106     BNO_INLINE static T* getSlowCase()
107     {
<span class="line-modified">108         LockHolder lock(mutex());</span>
109         if (!s_object.load()) {
110             if (s_data-&gt;isInitialized)
111                 s_object.store(static_cast&lt;T*&gt;(s_data-&gt;memory));
112             else {
113                 T* t = new (s_data-&gt;memory) T(lock);
114                 s_object.store(t);
115                 s_data-&gt;isInitialized = true;
116             }
117         }
118         return s_object.load();
119     }
120 
121     static std::atomic&lt;T*&gt; s_object;
122     static PerProcessData* s_data;
123 };
124 
125 template&lt;typename T&gt;
126 std::atomic&lt;T*&gt; PerProcess&lt;T&gt;::s_object { nullptr };
127 
128 template&lt;typename T&gt;
</pre>
</td>
</tr>
</table>
<center><a href="PerProcess.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PerThread.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
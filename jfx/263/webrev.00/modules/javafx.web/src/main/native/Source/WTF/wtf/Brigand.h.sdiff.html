<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/Brigand.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BloomFilter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BumpPointerAllocator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/Brigand.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 265     };
 266     template&lt;std::size_t N, typename Seq&gt; struct at_impl;
 267     template&lt;std::size_t N, template&lt;typename...&gt; class L, class... Ts&gt;
 268     struct at_impl&lt;N,L&lt;Ts...&gt;&gt;
 269     : decltype(element_at&lt;brigand::filled_list&lt;void const *, N&gt;&gt;::at(static_cast&lt;type_&lt;Ts&gt;*&gt;(nullptr)...))
 270     {
 271     };
 272   }
 273   template &lt;class L, std::size_t Index&gt;
 274   using at_c = typename detail::at_impl&lt;Index, L&gt;::type;
 275 namespace detail
 276 {
 277     template &lt;typename T&gt;
 278     struct has_at_method
 279     {
 280         struct dummy {};
 281         template &lt;typename C, typename P&gt;
 282         static auto test(P * p) -&gt; decltype(C::at(*p), std::true_type());
 283         template &lt;typename, typename&gt;
 284         static std::false_type test(...);
<span class="line-modified"> 285         static const bool value = std::is_same&lt;std::true_type, decltype(test&lt;T, dummy&gt;(nullptr))&gt;::value;</span>
 286     };
 287     template &lt;class L, typename Index, bool&gt;
 288     struct at_dispatch
 289     {
 290         using type = at_c&lt;L, Index::value&gt;;
 291     };
 292     template &lt;class L, typename Index&gt;
 293     struct at_dispatch&lt;L, Index, true&gt;
 294     {
 295         using type = lookup&lt;L, Index&gt;;
 296     };
 297 }
 298     template &lt;class Seq, typename K&gt;
 299     using at = typename detail::at_dispatch&lt;Seq, K, detail::has_at_method&lt;Seq&gt;::value&gt;::type;
 300 }
 301 namespace brigand
 302 {
 303     template &lt;template &lt;typename...&gt; class, typename...&gt;
 304     struct bind
 305     {
</pre>
<hr />
<pre>
2269     using make_sequence = typename detail::make_sequence_impl&lt;List, Start, N, Next, (N&lt;=8)&gt;::type;
2270 }
2271 
2272 namespace brigand
2273 {
2274     template&lt;class L, std::size_t Index&gt;
2275     using erase_c = append&lt;
2276         front&lt;split_at&lt;L, size_t&lt;Index&gt;&gt;&gt;,
2277         pop_front&lt;back&lt;split_at&lt;L, size_t&lt;Index&gt;&gt;&gt;&gt;
2278     &gt;;
2279 namespace detail
2280 {
2281     template &lt;typename T&gt;
2282     struct has_erase_method
2283     {
2284         struct dummy {};
2285         template &lt;typename C, typename P&gt;
2286         static auto test(P * p) -&gt; decltype(C::erase(type_&lt;P&gt;{}), std::true_type());
2287         template &lt;typename, typename&gt;
2288         static std::false_type test(...);
<span class="line-modified">2289         static const bool value = std::is_same&lt;std::true_type, decltype(test&lt;T, dummy&gt;(nullptr))&gt;::value;</span>
2290     };
2291     template&lt;class L, class I, bool&gt;
2292     struct erase_dispatch
2293     {
2294         using type = erase_c&lt;L, I::value&gt;;
2295     };
2296     template&lt;class C, class K&gt;
2297     struct erase_dispatch&lt;C, K, true&gt;
2298     {
2299         using type = decltype(C::erase(type_&lt;K&gt;{}));
2300     };
2301 }
2302     template&lt;class L, class K&gt;
2303     using erase = typename detail::erase_dispatch&lt;L, K, detail::has_erase_method&lt;L&gt;::value&gt;::type;
2304 }
2305 namespace brigand
2306 {
2307 namespace detail
2308 {
2309     template &lt;class C, class T&gt;
</pre>
</td>
<td>
<hr />
<pre>
 265     };
 266     template&lt;std::size_t N, typename Seq&gt; struct at_impl;
 267     template&lt;std::size_t N, template&lt;typename...&gt; class L, class... Ts&gt;
 268     struct at_impl&lt;N,L&lt;Ts...&gt;&gt;
 269     : decltype(element_at&lt;brigand::filled_list&lt;void const *, N&gt;&gt;::at(static_cast&lt;type_&lt;Ts&gt;*&gt;(nullptr)...))
 270     {
 271     };
 272   }
 273   template &lt;class L, std::size_t Index&gt;
 274   using at_c = typename detail::at_impl&lt;Index, L&gt;::type;
 275 namespace detail
 276 {
 277     template &lt;typename T&gt;
 278     struct has_at_method
 279     {
 280         struct dummy {};
 281         template &lt;typename C, typename P&gt;
 282         static auto test(P * p) -&gt; decltype(C::at(*p), std::true_type());
 283         template &lt;typename, typename&gt;
 284         static std::false_type test(...);
<span class="line-modified"> 285         static constexpr bool value = std::is_same&lt;std::true_type, decltype(test&lt;T, dummy&gt;(nullptr))&gt;::value;</span>
 286     };
 287     template &lt;class L, typename Index, bool&gt;
 288     struct at_dispatch
 289     {
 290         using type = at_c&lt;L, Index::value&gt;;
 291     };
 292     template &lt;class L, typename Index&gt;
 293     struct at_dispatch&lt;L, Index, true&gt;
 294     {
 295         using type = lookup&lt;L, Index&gt;;
 296     };
 297 }
 298     template &lt;class Seq, typename K&gt;
 299     using at = typename detail::at_dispatch&lt;Seq, K, detail::has_at_method&lt;Seq&gt;::value&gt;::type;
 300 }
 301 namespace brigand
 302 {
 303     template &lt;template &lt;typename...&gt; class, typename...&gt;
 304     struct bind
 305     {
</pre>
<hr />
<pre>
2269     using make_sequence = typename detail::make_sequence_impl&lt;List, Start, N, Next, (N&lt;=8)&gt;::type;
2270 }
2271 
2272 namespace brigand
2273 {
2274     template&lt;class L, std::size_t Index&gt;
2275     using erase_c = append&lt;
2276         front&lt;split_at&lt;L, size_t&lt;Index&gt;&gt;&gt;,
2277         pop_front&lt;back&lt;split_at&lt;L, size_t&lt;Index&gt;&gt;&gt;&gt;
2278     &gt;;
2279 namespace detail
2280 {
2281     template &lt;typename T&gt;
2282     struct has_erase_method
2283     {
2284         struct dummy {};
2285         template &lt;typename C, typename P&gt;
2286         static auto test(P * p) -&gt; decltype(C::erase(type_&lt;P&gt;{}), std::true_type());
2287         template &lt;typename, typename&gt;
2288         static std::false_type test(...);
<span class="line-modified">2289         static constexpr bool value = std::is_same&lt;std::true_type, decltype(test&lt;T, dummy&gt;(nullptr))&gt;::value;</span>
2290     };
2291     template&lt;class L, class I, bool&gt;
2292     struct erase_dispatch
2293     {
2294         using type = erase_c&lt;L, I::value&gt;;
2295     };
2296     template&lt;class C, class K&gt;
2297     struct erase_dispatch&lt;C, K, true&gt;
2298     {
2299         using type = decltype(C::erase(type_&lt;K&gt;{}));
2300     };
2301 }
2302     template&lt;class L, class K&gt;
2303     using erase = typename detail::erase_dispatch&lt;L, K, detail::has_erase_method&lt;L&gt;::value&gt;::type;
2304 }
2305 namespace brigand
2306 {
2307 namespace detail
2308 {
2309     template &lt;class C, class T&gt;
</pre>
</td>
</tr>
</table>
<center><a href="BloomFilter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BumpPointerAllocator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
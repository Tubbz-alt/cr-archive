<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerThread.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008-2017 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  *
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;WorkerThread.h&quot;
 29 
 30 #include &quot;IDBConnectionProxy.h&quot;
 31 #include &quot;ScriptSourceCode.h&quot;
 32 #include &quot;SecurityOrigin.h&quot;
 33 #include &quot;SocketProvider.h&quot;
 34 #include &quot;ThreadGlobalData.h&quot;
 35 #include &quot;WorkerGlobalScope.h&quot;
 36 #include &quot;WorkerInspectorController.h&quot;
 37 #include &lt;utility&gt;
 38 #include &lt;wtf/Lock.h&gt;
 39 #include &lt;wtf/NeverDestroyed.h&gt;
 40 #include &lt;wtf/Noncopyable.h&gt;
 41 #include &lt;wtf/text/WTFString.h&gt;
 42 
 43 #if PLATFORM(IOS_FAMILY)
 44 #include &quot;FloatingPointEnvironment.h&quot;
 45 #include &quot;WebCoreThread.h&quot;
 46 #endif
 47 
 48 #if PLATFORM(JAVA)
 49 #include &lt;wtf/java/JavaEnv.h&gt;
 50 #endif
 51 
 52 #if USE(GLIB)
 53 #include &lt;wtf/glib/GRefPtr.h&gt;
 54 #endif
 55 
 56 namespace WebCore {
 57 
 58 HashSet&lt;WorkerThread*&gt;&amp; WorkerThread::workerThreads(const LockHolder&amp;)
 59 {
 60     static NeverDestroyed&lt;HashSet&lt;WorkerThread*&gt;&gt; workerThreads;
 61     return workerThreads;
 62 }
 63 
 64 Lock&amp; WorkerThread::workerThreadsMutex()
 65 {
 66     static Lock mutex;
 67     return mutex;
 68 }
 69 
 70 unsigned WorkerThread::workerThreadCount()
 71 {
 72     LockHolder lock(workerThreadsMutex());
 73     return workerThreads(lock).size();
 74 }
 75 
 76 WorkerParameters WorkerParameters::isolatedCopy() const
 77 {
 78     return {
 79         scriptURL.isolatedCopy(),
 80         name.isolatedCopy(),
 81         identifier.isolatedCopy(),
 82         userAgent.isolatedCopy(),
 83         isOnline,
 84         contentSecurityPolicyResponseHeaders,
 85         shouldBypassMainWorldContentSecurityPolicy,
 86         timeOrigin,
 87         referrerPolicy,
 88     };
 89 }
 90 
 91 struct WorkerThreadStartupData {
 92     WTF_MAKE_NONCOPYABLE(WorkerThreadStartupData); WTF_MAKE_FAST_ALLOCATED;
 93 public:
 94     WorkerThreadStartupData(const WorkerParameters&amp; params, const String&amp; sourceCode, WorkerThreadStartMode, const SecurityOrigin&amp; topOrigin);
 95 
 96     WorkerParameters params;
 97     Ref&lt;SecurityOrigin&gt; origin;
 98     String sourceCode;
 99     WorkerThreadStartMode startMode;
100     Ref&lt;SecurityOrigin&gt; topOrigin;
101 };
102 
103 WorkerThreadStartupData::WorkerThreadStartupData(const WorkerParameters&amp; other, const String&amp; sourceCode, WorkerThreadStartMode startMode, const SecurityOrigin&amp; topOrigin)
104     : params(other.isolatedCopy())
105     , origin(SecurityOrigin::create(other.scriptURL)-&gt;isolatedCopy())
106     , sourceCode(sourceCode.isolatedCopy())
107     , startMode(startMode)
108     , topOrigin(topOrigin.isolatedCopy())
109 {
110 }
111 
112 WorkerThread::WorkerThread(const WorkerParameters&amp; params, const String&amp; sourceCode, WorkerLoaderProxy&amp; workerLoaderProxy, WorkerDebuggerProxy&amp; workerDebuggerProxy, WorkerReportingProxy&amp; workerReportingProxy, WorkerThreadStartMode startMode, const SecurityOrigin&amp; topOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider, JSC::RuntimeFlags runtimeFlags)
113     : m_identifier(params.identifier.isolatedCopy())
114     , m_workerLoaderProxy(workerLoaderProxy)
115     , m_workerDebuggerProxy(workerDebuggerProxy)
116     , m_workerReportingProxy(workerReportingProxy)
117     , m_runtimeFlags(runtimeFlags)
118     , m_startupData(makeUnique&lt;WorkerThreadStartupData&gt;(params, sourceCode, startMode, topOrigin))
119 #if ENABLE(INDEXED_DATABASE)
120     , m_idbConnectionProxy(connectionProxy)
121 #endif
122     , m_socketProvider(socketProvider)
123 {
124 #if !ENABLE(INDEXED_DATABASE)
125     UNUSED_PARAM(connectionProxy);
126 #endif
127 
128     LockHolder lock(workerThreadsMutex());
129     workerThreads(lock).add(this);
130 }
131 
132 WorkerThread::~WorkerThread()
133 {
134     LockHolder lock(workerThreadsMutex());
135     ASSERT(workerThreads(lock).contains(this));
136     workerThreads(lock).remove(this);
137 }
138 
139 void WorkerThread::start(WTF::Function&lt;void(const String&amp;)&gt;&amp;&amp; evaluateCallback)
140 {
141     // Mutex protection is necessary to ensure that m_thread is initialized when the thread starts.
142     LockHolder lock(m_threadCreationAndWorkerGlobalScopeMutex);
143 
144     if (m_thread)
145         return;
146 
147     m_evaluateCallback = WTFMove(evaluateCallback);
148 
149     m_thread = Thread::create(isServiceWorkerThread() ? &quot;WebCore: Service Worker&quot; : &quot;WebCore: Worker&quot;, [this] {
150         workerThread();
151     });
152 }
153 
154 void WorkerThread::workerThread()
155 {
156 #if PLATFORM(JAVA)
157     WTF::AttachThreadAsDaemonToJavaEnv autoAttach;
158 #endif
159     auto protectedThis = makeRef(*this);
160 
161     // Propagate the mainThread&#39;s fenv to workers.
162 #if PLATFORM(IOS_FAMILY)
163     FloatingPointEnvironment::singleton().propagateMainThreadEnvironment();
164 #endif
165 
166 #if USE(GLIB)
167     GRefPtr&lt;GMainContext&gt; mainContext = adoptGRef(g_main_context_new());
168     g_main_context_push_thread_default(mainContext.get());
169 #endif
170 
171     WorkerScriptController* scriptController;
172     {
173         // Mutex protection is necessary to ensure that we don&#39;t change m_workerGlobalScope
174         // while WorkerThread::stop() is accessing it. Note that WorkerThread::stop() can
175         // be called before we&#39;ve finished creating the WorkerGlobalScope.
176         LockHolder lock(m_threadCreationAndWorkerGlobalScopeMutex);
177         m_workerGlobalScope = createWorkerGlobalScope(m_startupData-&gt;params, WTFMove(m_startupData-&gt;origin), WTFMove(m_startupData-&gt;topOrigin));
178 
179         scriptController = m_workerGlobalScope-&gt;script();
180 
181         if (m_runLoop.terminated()) {
182             // The worker was terminated before the thread had a chance to run. Since the context didn&#39;t exist yet,
183             // forbidExecution() couldn&#39;t be called from stop().
184             scriptController-&gt;scheduleExecutionTermination();
185             scriptController-&gt;forbidExecution();
186         }
187     }
188 
189     if (m_startupData-&gt;startMode == WorkerThreadStartMode::WaitForInspector) {
190         startRunningDebuggerTasks();
191 
192         // If the worker was somehow terminated while processing debugger commands.
193         if (m_runLoop.terminated())
194             scriptController-&gt;forbidExecution();
195     }
196 
197     String exceptionMessage;
198     scriptController-&gt;evaluate(ScriptSourceCode(m_startupData-&gt;sourceCode, URL(m_startupData-&gt;params.scriptURL)), &amp;exceptionMessage);
199 
200     finishedEvaluatingScript();
201 
202     callOnMainThread([evaluateCallback = WTFMove(m_evaluateCallback), message = exceptionMessage.isolatedCopy()] {
203         if (evaluateCallback)
204             evaluateCallback(message);
205     });
206 
207     // Free the startup data to cause its member variable deref&#39;s happen on the worker&#39;s thread (since
208     // all ref/derefs of these objects are happening on the thread at this point). Note that
209     // WorkerThread::~WorkerThread happens on a different thread where it was created.
210     m_startupData = nullptr;
211 
212     runEventLoop();
213 
214 #if USE(GLIB)
215     g_main_context_pop_thread_default(mainContext.get());
216 #endif
217 
218     RefPtr&lt;Thread&gt; protector = m_thread;
219 
220     ASSERT(m_workerGlobalScope-&gt;hasOneRef());
221 
222     RefPtr&lt;WorkerGlobalScope&gt; workerGlobalScopeToDelete;
223     {
224         // Mutex protection is necessary to ensure that we don&#39;t change m_workerGlobalScope
225         // while WorkerThread::stop is accessing it.
226         LockHolder lock(m_threadCreationAndWorkerGlobalScopeMutex);
227 
228         // Delay the destruction of the WorkerGlobalScope context until after we&#39;ve unlocked the
229         // m_threadCreationAndWorkerGlobalScopeMutex. This is needed because destructing the
230         // context will trigger the main thread to race against us to delete the WorkerThread
231         // object, and the WorkerThread object owns the mutex we need to unlock after this.
232         workerGlobalScopeToDelete = WTFMove(m_workerGlobalScope);
233 
234         if (m_stoppedCallback)
235             callOnMainThread(WTFMove(m_stoppedCallback));
236     }
237 
238     // The below assignment will destroy the context, which will in turn notify messaging proxy.
239     // We cannot let any objects survive past thread exit, because no other thread will run GC or otherwise destroy them.
240     workerGlobalScopeToDelete = nullptr;
241 
242     // Clean up WebCore::ThreadGlobalData before WTF::Thread goes away!
243     threadGlobalData().destroy();
244 
245     // Send the last WorkerThread Ref to be Deref&#39;ed on the main thread.
246     callOnMainThread([protectedThis = WTFMove(protectedThis)] { });
247 
248     // The thread object may be already destroyed from notification now, don&#39;t try to access &quot;this&quot;.
249     protector-&gt;detach();
250 }
251 
252 void WorkerThread::startRunningDebuggerTasks()
253 {
254     ASSERT(!m_pausedForDebugger);
255     m_pausedForDebugger = true;
256 
257     MessageQueueWaitResult result;
258     do {
259         result = m_runLoop.runInDebuggerMode(*m_workerGlobalScope);
260     } while (result != MessageQueueTerminated &amp;&amp; m_pausedForDebugger);
261 }
262 
263 void WorkerThread::stopRunningDebuggerTasks()
264 {
265     m_pausedForDebugger = false;
266 }
267 
268 void WorkerThread::runEventLoop()
269 {
270     // Does not return until terminated.
271     m_runLoop.run(m_workerGlobalScope.get());
272 }
273 
274 void WorkerThread::suspend()
275 {
276     m_isSuspended = true;
277     runLoop().postTask([&amp;](ScriptExecutionContext&amp;) {
278 #if ENABLE(INDEXED_DATABASE)
279         if (m_workerGlobalScope)
280             m_workerGlobalScope-&gt;suspend();
281 #endif
282 
283         m_suspensionSemaphore.wait();
284 
285 #if ENABLE(INDEXED_DATABASE)
286         if (m_workerGlobalScope)
287             m_workerGlobalScope-&gt;resume();
288 #endif
289     });
290 }
291 
292 void WorkerThread::resume()
293 {
294     ASSERT(m_isSuspended);
295     m_isSuspended = false;
296     m_suspensionSemaphore.signal();
297 }
298 
299 void WorkerThread::stop(WTF::Function&lt;void()&gt;&amp;&amp; stoppedCallback)
300 {
301     // Mutex protection is necessary to ensure that m_workerGlobalScope isn&#39;t changed by
302     // WorkerThread::workerThread() while we&#39;re accessing it. Note also that stop() can
303     // be called before m_workerGlobalScope is fully created.
304     auto locker = Locker&lt;Lock&gt;::tryLock(m_threadCreationAndWorkerGlobalScopeMutex);
305     if (!locker) {
306         // The thread is still starting, spin the runloop and try again to avoid deadlocks if the worker thread
307         // needs to interact with the main thread during startup.
308         callOnMainThread([this, stoppedCallback = WTFMove(stoppedCallback)]() mutable {
309             stop(WTFMove(stoppedCallback));
310         });
311         return;
312     }
313 
314     // If the thread is suspended, resume it now so that we can dispatch the cleanup tasks below.
315     if (m_isSuspended)
316         resume();
317 
318     ASSERT(!m_stoppedCallback);
319     m_stoppedCallback = WTFMove(stoppedCallback);
320 
321     // Ensure that tasks are being handled by thread event loop. If script execution weren&#39;t forbidden, a while(1) loop in JS could keep the thread alive forever.
322     if (m_workerGlobalScope) {
323         m_workerGlobalScope-&gt;script()-&gt;scheduleExecutionTermination();
324 
325         m_runLoop.postTaskAndTerminate({ ScriptExecutionContext::Task::CleanupTask, [] (ScriptExecutionContext&amp; context ) {
326             WorkerGlobalScope&amp; workerGlobalScope = downcast&lt;WorkerGlobalScope&gt;(context);
327 
328             workerGlobalScope.prepareForTermination();
329 
330             // Stick a shutdown command at the end of the queue, so that we deal
331             // with all the cleanup tasks the databases post first.
332             workerGlobalScope.postTask({ ScriptExecutionContext::Task::CleanupTask, [] (ScriptExecutionContext&amp; context) {
333                 WorkerGlobalScope&amp; workerGlobalScope = downcast&lt;WorkerGlobalScope&gt;(context);
334                 // It&#39;s not safe to call clearScript until all the cleanup tasks posted by functions initiated by WorkerThreadShutdownStartTask have completed.
335                 workerGlobalScope.clearScript();
336             } });
337 
338         } });
339         return;
340     }
341     m_runLoop.terminate();
342 }
343 
344 void WorkerThread::releaseFastMallocFreeMemoryInAllThreads()
345 {
346     LockHolder lock(workerThreadsMutex());
347     for (auto* workerThread : workerThreads(lock)) {
348         workerThread-&gt;runLoop().postTask([] (ScriptExecutionContext&amp;) {
349             WTF::releaseFastMallocFreeMemory();
350         });
351     }
352 }
353 
354 IDBClient::IDBConnectionProxy* WorkerThread::idbConnectionProxy()
355 {
356 #if ENABLE(INDEXED_DATABASE)
357     return m_idbConnectionProxy.get();
358 #else
359     return nullptr;
360 #endif
361 }
362 
363 SocketProvider* WorkerThread::socketProvider()
364 {
365     return m_socketProvider.get();
366 }
367 
368 } // namespace WebCore
    </pre>
  </body>
</html>
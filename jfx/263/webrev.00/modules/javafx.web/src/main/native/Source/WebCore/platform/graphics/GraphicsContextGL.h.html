<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContextGL.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(GRAPHICS_CONTEXT_GL)
  29 
  30 #include &quot;GraphicsContextGLAttributes.h&quot;
  31 #include &quot;GraphicsTypesGL.h&quot;
  32 #include &quot;Image.h&quot;
  33 #include &quot;IntRect.h&quot;
  34 #include &quot;IntSize.h&quot;
  35 #include &quot;PlatformLayer.h&quot;
  36 #include &lt;wtf/RefCounted.h&gt;
  37 #include &lt;wtf/text/WTFString.h&gt;
  38 
  39 #if OS(WINDOWS)
  40 // Defined in winerror.h
  41 #ifdef NO_ERROR
  42 #undef NO_ERROR
  43 #endif
  44 #endif
  45 
  46 typedef void* PlatformGraphicsContextGL;
  47 typedef void* PlatformGraphicsContextGLDisplay;
  48 typedef void* PlatformGraphicsContextGLSurface;
  49 typedef void* PlatformGraphicsContextGLConfig;
  50 
  51 namespace WebCore {
  52 class ExtensionsGL;
  53 class HostWindow;
  54 class ImageBuffer;
  55 class ImageData;
  56 
  57 class GraphicsContextGL : public RefCounted&lt;GraphicsContextGL&gt; {
  58 public:
  59     enum {
  60         // WebGL 1 constants.
  61         DEPTH_BUFFER_BIT = 0x00000100,
  62         STENCIL_BUFFER_BIT = 0x00000400,
  63         COLOR_BUFFER_BIT = 0x00004000,
  64         POINTS = 0x0000,
  65         LINES = 0x0001,
  66         LINE_LOOP = 0x0002,
  67         LINE_STRIP = 0x0003,
  68         TRIANGLES = 0x0004,
  69         TRIANGLE_STRIP = 0x0005,
  70         TRIANGLE_FAN = 0x0006,
  71         ZERO = 0,
  72         ONE = 1,
  73         SRC_COLOR = 0x0300,
  74         ONE_MINUS_SRC_COLOR = 0x0301,
  75         SRC_ALPHA = 0x0302,
  76         ONE_MINUS_SRC_ALPHA = 0x0303,
  77         DST_ALPHA = 0x0304,
  78         ONE_MINUS_DST_ALPHA = 0x0305,
  79         DST_COLOR = 0x0306,
  80         ONE_MINUS_DST_COLOR = 0x0307,
  81         SRC_ALPHA_SATURATE = 0x0308,
  82         FUNC_ADD = 0x8006,
  83         BLEND_EQUATION = 0x8009,
  84         BLEND_EQUATION_RGB = 0x8009,
  85         BLEND_EQUATION_ALPHA = 0x883D,
  86         FUNC_SUBTRACT = 0x800A,
  87         FUNC_REVERSE_SUBTRACT = 0x800B,
  88         BLEND_DST_RGB = 0x80C8,
  89         BLEND_SRC_RGB = 0x80C9,
  90         BLEND_DST_ALPHA = 0x80CA,
  91         BLEND_SRC_ALPHA = 0x80CB,
  92         CONSTANT_COLOR = 0x8001,
  93         ONE_MINUS_CONSTANT_COLOR = 0x8002,
  94         CONSTANT_ALPHA = 0x8003,
  95         ONE_MINUS_CONSTANT_ALPHA = 0x8004,
  96         BLEND_COLOR = 0x8005,
  97         ARRAY_BUFFER = 0x8892,
  98         ELEMENT_ARRAY_BUFFER = 0x8893,
  99         ARRAY_BUFFER_BINDING = 0x8894,
 100         ELEMENT_ARRAY_BUFFER_BINDING = 0x8895,
 101         STREAM_DRAW = 0x88E0,
 102         STATIC_DRAW = 0x88E4,
 103         DYNAMIC_DRAW = 0x88E8,
 104         BUFFER_SIZE = 0x8764,
 105         BUFFER_USAGE = 0x8765,
 106         CURRENT_VERTEX_ATTRIB = 0x8626,
 107         FRONT = 0x0404,
 108         BACK = 0x0405,
 109         FRONT_AND_BACK = 0x0408,
 110         TEXTURE_2D = 0x0DE1,
 111         CULL_FACE = 0x0B44,
 112         BLEND = 0x0BE2,
 113         DITHER = 0x0BD0,
 114         STENCIL_TEST = 0x0B90,
 115         DEPTH_TEST = 0x0B71,
 116         SCISSOR_TEST = 0x0C11,
 117         POLYGON_OFFSET_FILL = 0x8037,
 118         SAMPLE_ALPHA_TO_COVERAGE = 0x809E,
 119         SAMPLE_COVERAGE = 0x80A0,
 120         NO_ERROR = 0,
 121         INVALID_ENUM = 0x0500,
 122         INVALID_VALUE = 0x0501,
 123         INVALID_OPERATION = 0x0502,
 124         OUT_OF_MEMORY = 0x0505,
 125         CW = 0x0900,
 126         CCW = 0x0901,
 127         LINE_WIDTH = 0x0B21,
 128         ALIASED_POINT_SIZE_RANGE = 0x846D,
 129         ALIASED_LINE_WIDTH_RANGE = 0x846E,
 130         CULL_FACE_MODE = 0x0B45,
 131         FRONT_FACE = 0x0B46,
 132         DEPTH_RANGE = 0x0B70,
 133         DEPTH_WRITEMASK = 0x0B72,
 134         DEPTH_CLEAR_VALUE = 0x0B73,
 135         DEPTH_FUNC = 0x0B74,
 136         STENCIL_CLEAR_VALUE = 0x0B91,
 137         STENCIL_FUNC = 0x0B92,
 138         STENCIL_FAIL = 0x0B94,
 139         STENCIL_PASS_DEPTH_FAIL = 0x0B95,
 140         STENCIL_PASS_DEPTH_PASS = 0x0B96,
 141         STENCIL_REF = 0x0B97,
 142         STENCIL_VALUE_MASK = 0x0B93,
 143         STENCIL_WRITEMASK = 0x0B98,
 144         STENCIL_BACK_FUNC = 0x8800,
 145         STENCIL_BACK_FAIL = 0x8801,
 146         STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802,
 147         STENCIL_BACK_PASS_DEPTH_PASS = 0x8803,
 148         STENCIL_BACK_REF = 0x8CA3,
 149         STENCIL_BACK_VALUE_MASK = 0x8CA4,
 150         STENCIL_BACK_WRITEMASK = 0x8CA5,
 151         VIEWPORT = 0x0BA2,
 152         SCISSOR_BOX = 0x0C10,
 153         COLOR_CLEAR_VALUE = 0x0C22,
 154         COLOR_WRITEMASK = 0x0C23,
 155         UNPACK_ALIGNMENT = 0x0CF5,
 156         PACK_ALIGNMENT = 0x0D05,
 157         MAX_TEXTURE_SIZE = 0x0D33,
 158         MAX_VIEWPORT_DIMS = 0x0D3A,
 159         SUBPIXEL_BITS = 0x0D50,
 160         RED_BITS = 0x0D52,
 161         GREEN_BITS = 0x0D53,
 162         BLUE_BITS = 0x0D54,
 163         ALPHA_BITS = 0x0D55,
 164         DEPTH_BITS = 0x0D56,
 165         STENCIL_BITS = 0x0D57,
 166         POLYGON_OFFSET_UNITS = 0x2A00,
 167         POLYGON_OFFSET_FACTOR = 0x8038,
 168         TEXTURE_BINDING_2D = 0x8069,
 169         SAMPLE_BUFFERS = 0x80A8,
 170         SAMPLES = 0x80A9,
 171         SAMPLE_COVERAGE_VALUE = 0x80AA,
 172         SAMPLE_COVERAGE_INVERT = 0x80AB,
 173         NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2,
 174         COMPRESSED_TEXTURE_FORMATS = 0x86A3,
 175         DONT_CARE = 0x1100,
 176         FASTEST = 0x1101,
 177         NICEST = 0x1102,
 178         GENERATE_MIPMAP_HINT = 0x8192,
 179         BYTE = 0x1400,
 180         UNSIGNED_BYTE = 0x1401,
 181         SHORT = 0x1402,
 182         UNSIGNED_SHORT = 0x1403,
 183         INT = 0x1404,
 184         UNSIGNED_INT = 0x1405,
 185         FLOAT = 0x1406,
 186         HALF_FLOAT_OES = 0x8D61,
 187         FIXED = 0x140C,
 188         DEPTH_COMPONENT = 0x1902,
 189         ALPHA = 0x1906,
 190         RGB = 0x1907,
 191         RGBA = 0x1908,
 192         BGRA = 0x80E1,
 193         LUMINANCE = 0x1909,
 194         LUMINANCE_ALPHA = 0x190A,
 195         UNSIGNED_SHORT_4_4_4_4 = 0x8033,
 196         UNSIGNED_SHORT_5_5_5_1 = 0x8034,
 197         UNSIGNED_SHORT_5_6_5 = 0x8363,
 198         FRAGMENT_SHADER = 0x8B30,
 199         VERTEX_SHADER = 0x8B31,
 200         MAX_VERTEX_ATTRIBS = 0x8869,
 201         MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB,
 202         MAX_VARYING_VECTORS = 0x8DFC,
 203         MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D,
 204         MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C,
 205         MAX_TEXTURE_IMAGE_UNITS = 0x8872,
 206         MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD,
 207         SHADER_TYPE = 0x8B4F,
 208         DELETE_STATUS = 0x8B80,
 209         LINK_STATUS = 0x8B82,
 210         VALIDATE_STATUS = 0x8B83,
 211         ATTACHED_SHADERS = 0x8B85,
 212         ACTIVE_UNIFORMS = 0x8B86,
 213         ACTIVE_UNIFORM_MAX_LENGTH = 0x8B87,
 214         ACTIVE_ATTRIBUTES = 0x8B89,
 215         ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8B8A,
 216         SHADING_LANGUAGE_VERSION = 0x8B8C,
 217         CURRENT_PROGRAM = 0x8B8D,
 218         NEVER = 0x0200,
 219         LESS = 0x0201,
 220         EQUAL = 0x0202,
 221         LEQUAL = 0x0203,
 222         GREATER = 0x0204,
 223         NOTEQUAL = 0x0205,
 224         GEQUAL = 0x0206,
 225         ALWAYS = 0x0207,
 226         KEEP = 0x1E00,
 227         REPLACE = 0x1E01,
 228         INCR = 0x1E02,
 229         DECR = 0x1E03,
 230         INVERT = 0x150A,
 231         INCR_WRAP = 0x8507,
 232         DECR_WRAP = 0x8508,
 233         VENDOR = 0x1F00,
 234         RENDERER = 0x1F01,
 235         VERSION = 0x1F02,
 236         EXTENSIONS = 0x1F03,
 237         NEAREST = 0x2600,
 238         LINEAR = 0x2601,
 239         NEAREST_MIPMAP_NEAREST = 0x2700,
 240         LINEAR_MIPMAP_NEAREST = 0x2701,
 241         NEAREST_MIPMAP_LINEAR = 0x2702,
 242         LINEAR_MIPMAP_LINEAR = 0x2703,
 243         TEXTURE_MAG_FILTER = 0x2800,
 244         TEXTURE_MIN_FILTER = 0x2801,
 245         TEXTURE_WRAP_S = 0x2802,
 246         TEXTURE_WRAP_T = 0x2803,
 247         TEXTURE = 0x1702,
 248         TEXTURE_CUBE_MAP = 0x8513,
 249         TEXTURE_BINDING_CUBE_MAP = 0x8514,
 250         TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515,
 251         TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516,
 252         TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517,
 253         TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518,
 254         TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519,
 255         TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A,
 256         MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C,
 257         TEXTURE0 = 0x84C0,
 258         TEXTURE1 = 0x84C1,
 259         TEXTURE2 = 0x84C2,
 260         TEXTURE3 = 0x84C3,
 261         TEXTURE4 = 0x84C4,
 262         TEXTURE5 = 0x84C5,
 263         TEXTURE6 = 0x84C6,
 264         TEXTURE7 = 0x84C7,
 265         TEXTURE8 = 0x84C8,
 266         TEXTURE9 = 0x84C9,
 267         TEXTURE10 = 0x84CA,
 268         TEXTURE11 = 0x84CB,
 269         TEXTURE12 = 0x84CC,
 270         TEXTURE13 = 0x84CD,
 271         TEXTURE14 = 0x84CE,
 272         TEXTURE15 = 0x84CF,
 273         TEXTURE16 = 0x84D0,
 274         TEXTURE17 = 0x84D1,
 275         TEXTURE18 = 0x84D2,
 276         TEXTURE19 = 0x84D3,
 277         TEXTURE20 = 0x84D4,
 278         TEXTURE21 = 0x84D5,
 279         TEXTURE22 = 0x84D6,
 280         TEXTURE23 = 0x84D7,
 281         TEXTURE24 = 0x84D8,
 282         TEXTURE25 = 0x84D9,
 283         TEXTURE26 = 0x84DA,
 284         TEXTURE27 = 0x84DB,
 285         TEXTURE28 = 0x84DC,
 286         TEXTURE29 = 0x84DD,
 287         TEXTURE30 = 0x84DE,
 288         TEXTURE31 = 0x84DF,
 289         ACTIVE_TEXTURE = 0x84E0,
 290         REPEAT = 0x2901,
 291         CLAMP_TO_EDGE = 0x812F,
 292         MIRRORED_REPEAT = 0x8370,
 293         FLOAT_VEC2 = 0x8B50,
 294         FLOAT_VEC3 = 0x8B51,
 295         FLOAT_VEC4 = 0x8B52,
 296         INT_VEC2 = 0x8B53,
 297         INT_VEC3 = 0x8B54,
 298         INT_VEC4 = 0x8B55,
 299         BOOL = 0x8B56,
 300         BOOL_VEC2 = 0x8B57,
 301         BOOL_VEC3 = 0x8B58,
 302         BOOL_VEC4 = 0x8B59,
 303         FLOAT_MAT2 = 0x8B5A,
 304         FLOAT_MAT3 = 0x8B5B,
 305         FLOAT_MAT4 = 0x8B5C,
 306         SAMPLER_2D = 0x8B5E,
 307         SAMPLER_CUBE = 0x8B60,
 308         VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622,
 309         VERTEX_ATTRIB_ARRAY_SIZE = 0x8623,
 310         VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624,
 311         VERTEX_ATTRIB_ARRAY_TYPE = 0x8625,
 312         VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A,
 313         VERTEX_ATTRIB_ARRAY_POINTER = 0x8645,
 314         VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F,
 315         IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A,
 316         IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B,
 317         COMPILE_STATUS = 0x8B81,
 318         INFO_LOG_LENGTH = 0x8B84,
 319         SHADER_SOURCE_LENGTH = 0x8B88,
 320         SHADER_COMPILER = 0x8DFA,
 321         SHADER_BINARY_FORMATS = 0x8DF8,
 322         NUM_SHADER_BINARY_FORMATS = 0x8DF9,
 323         LOW_FLOAT = 0x8DF0,
 324         MEDIUM_FLOAT = 0x8DF1,
 325         HIGH_FLOAT = 0x8DF2,
 326         LOW_INT = 0x8DF3,
 327         MEDIUM_INT = 0x8DF4,
 328         HIGH_INT = 0x8DF5,
 329         FRAMEBUFFER = 0x8D40,
 330         RENDERBUFFER = 0x8D41,
 331         RGBA4 = 0x8056,
 332         RGB5_A1 = 0x8057,
 333         RGB565 = 0x8D62,
 334         DEPTH_COMPONENT16 = 0x81A5,
 335         STENCIL_INDEX = 0x1901,
 336         STENCIL_INDEX8 = 0x8D48,
 337         RENDERBUFFER_WIDTH = 0x8D42,
 338         RENDERBUFFER_HEIGHT = 0x8D43,
 339         RENDERBUFFER_INTERNAL_FORMAT = 0x8D44,
 340         RENDERBUFFER_RED_SIZE = 0x8D50,
 341         RENDERBUFFER_GREEN_SIZE = 0x8D51,
 342         RENDERBUFFER_BLUE_SIZE = 0x8D52,
 343         RENDERBUFFER_ALPHA_SIZE = 0x8D53,
 344         RENDERBUFFER_DEPTH_SIZE = 0x8D54,
 345         RENDERBUFFER_STENCIL_SIZE = 0x8D55,
 346         FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0,
 347         FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1,
 348         FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2,
 349         FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3,
 350         COLOR_ATTACHMENT0 = 0x8CE0,
 351         DEPTH_ATTACHMENT = 0x8D00,
 352         STENCIL_ATTACHMENT = 0x8D20,
 353         NONE = 0,
 354         FRAMEBUFFER_COMPLETE = 0x8CD5,
 355         FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6,
 356         FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7,
 357         FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9,
 358         FRAMEBUFFER_UNSUPPORTED = 0x8CDD,
 359         FRAMEBUFFER_BINDING = 0x8CA6,
 360         RENDERBUFFER_BINDING = 0x8CA7,
 361         MAX_RENDERBUFFER_SIZE = 0x84E8,
 362         INVALID_FRAMEBUFFER_OPERATION = 0x0506,
 363 
 364         // WebGL-specific enums
 365         UNPACK_FLIP_Y_WEBGL = 0x9240,
 366         UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241,
 367         CONTEXT_LOST_WEBGL = 0x9242,
 368         UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243,
 369         BROWSER_DEFAULT_WEBGL = 0x9244,
 370         VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 0x88FE,
 371 
 372         // WebGL2 constants
 373         READ_BUFFER = 0x0C02,
 374         UNPACK_ROW_LENGTH = 0x0CF2,
 375         UNPACK_SKIP_ROWS = 0x0CF3,
 376         UNPACK_SKIP_PIXELS = 0x0CF4,
 377         PACK_ROW_LENGTH = 0x0D02,
 378         PACK_SKIP_ROWS = 0x0D03,
 379         PACK_SKIP_PIXELS = 0x0D04,
 380         COLOR = 0x1800,
 381         DEPTH = 0x1801,
 382         STENCIL = 0x1802,
 383         RED = 0x1903,
 384         RGB8 = 0x8051,
 385         RGBA8 = 0x8058,
 386         RGB10_A2 = 0x8059,
 387         TEXTURE_BINDING_3D = 0x806A,
 388         UNPACK_SKIP_IMAGES = 0x806D,
 389         UNPACK_IMAGE_HEIGHT = 0x806E,
 390         TEXTURE_3D = 0x806F,
 391         TEXTURE_WRAP_R = 0x8072,
 392         MAX_3D_TEXTURE_SIZE = 0x8073,
 393         UNSIGNED_INT_2_10_10_10_REV = 0x8368,
 394         MAX_ELEMENTS_VERTICES = 0x80E8,
 395         MAX_ELEMENTS_INDICES = 0x80E9,
 396         TEXTURE_MIN_LOD = 0x813A,
 397         TEXTURE_MAX_LOD = 0x813B,
 398         TEXTURE_BASE_LEVEL = 0x813C,
 399         TEXTURE_MAX_LEVEL = 0x813D,
 400         MIN = 0x8007,
 401         MAX = 0x8008,
 402         DEPTH_COMPONENT24 = 0x81A6,
 403         MAX_TEXTURE_LOD_BIAS = 0x84FD,
 404         TEXTURE_COMPARE_MODE = 0x884C,
 405         TEXTURE_COMPARE_FUNC = 0x884D,
 406         CURRENT_QUERY = 0x8865,
 407         QUERY_RESULT = 0x8866,
 408         QUERY_RESULT_AVAILABLE = 0x8867,
 409         STREAM_READ = 0x88E1,
 410         STREAM_COPY = 0x88E2,
 411         STATIC_READ = 0x88E5,
 412         STATIC_COPY = 0x88E6,
 413         DYNAMIC_READ = 0x88E9,
 414         DYNAMIC_COPY = 0x88EA,
 415         MAX_DRAW_BUFFERS = 0x8824,
 416         DRAW_BUFFER0 = 0x8825,
 417         DRAW_BUFFER1 = 0x8826,
 418         DRAW_BUFFER2 = 0x8827,
 419         DRAW_BUFFER3 = 0x8828,
 420         DRAW_BUFFER4 = 0x8829,
 421         DRAW_BUFFER5 = 0x882A,
 422         DRAW_BUFFER6 = 0x882B,
 423         DRAW_BUFFER7 = 0x882C,
 424         DRAW_BUFFER8 = 0x882D,
 425         DRAW_BUFFER9 = 0x882E,
 426         DRAW_BUFFER10 = 0x882F,
 427         DRAW_BUFFER11 = 0x8830,
 428         DRAW_BUFFER12 = 0x8831,
 429         DRAW_BUFFER13 = 0x8832,
 430         DRAW_BUFFER14 = 0x8833,
 431         DRAW_BUFFER15 = 0x8834,
 432         MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49,
 433         MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A,
 434         SAMPLER_3D = 0x8B5F,
 435         SAMPLER_2D_SHADOW = 0x8B62,
 436         FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B,
 437         PIXEL_PACK_BUFFER = 0x88EB,
 438         PIXEL_UNPACK_BUFFER = 0x88EC,
 439         PIXEL_PACK_BUFFER_BINDING = 0x88ED,
 440         PIXEL_UNPACK_BUFFER_BINDING = 0x88EF,
 441         FLOAT_MAT2x3 = 0x8B65,
 442         FLOAT_MAT2x4 = 0x8B66,
 443         FLOAT_MAT3x2 = 0x8B67,
 444         FLOAT_MAT3x4 = 0x8B68,
 445         FLOAT_MAT4x2 = 0x8B69,
 446         FLOAT_MAT4x3 = 0x8B6A,
 447         SRGB = 0x8C40,
 448         SRGB8 = 0x8C41,
 449         SRGB_ALPHA = 0x8C42,
 450         SRGB8_ALPHA8 = 0x8C43,
 451         COMPARE_REF_TO_TEXTURE = 0x884E,
 452         RGBA32F = 0x8814,
 453         RGB32F = 0x8815,
 454         RGBA16F = 0x881A,
 455         RGB16F = 0x881B,
 456         VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD,
 457         MAX_ARRAY_TEXTURE_LAYERS = 0x88FF,
 458         MIN_PROGRAM_TEXEL_OFFSET = 0x8904,
 459         MAX_PROGRAM_TEXEL_OFFSET = 0x8905,
 460         MAX_VARYING_COMPONENTS = 0x8B4B,
 461         TEXTURE_2D_ARRAY = 0x8C1A,
 462         TEXTURE_BINDING_2D_ARRAY = 0x8C1D,
 463         R11F_G11F_B10F = 0x8C3A,
 464         UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B,
 465         RGB9_E5 = 0x8C3D,
 466         UNSIGNED_INT_5_9_9_9_REV = 0x8C3E,
 467         TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = 0x8C76,
 468         TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F,
 469         MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 0x8C80,
 470         TRANSFORM_FEEDBACK_VARYINGS = 0x8C83,
 471         TRANSFORM_FEEDBACK_BUFFER_START = 0x8C84,
 472         TRANSFORM_FEEDBACK_BUFFER_SIZE = 0x8C85,
 473         TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88,
 474         RASTERIZER_DISCARD = 0x8C89,
 475         MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A,
 476         MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 0x8C8B,
 477         INTERLEAVED_ATTRIBS = 0x8C8C,
 478         SEPARATE_ATTRIBS = 0x8C8D,
 479         TRANSFORM_FEEDBACK_BUFFER = 0x8C8E,
 480         TRANSFORM_FEEDBACK_BUFFER_BINDING = 0x8C8F,
 481         RGBA32UI = 0x8D70,
 482         RGB32UI = 0x8D71,
 483         RGBA16UI = 0x8D76,
 484         RGB16UI = 0x8D77,
 485         RGBA8UI = 0x8D7C,
 486         RGB8UI = 0x8D7D,
 487         RGBA32I = 0x8D82,
 488         RGB32I = 0x8D83,
 489         RGBA16I = 0x8D88,
 490         RGB16I = 0x8D89,
 491         RGBA8I = 0x8D8E,
 492         RGB8I = 0x8D8F,
 493         RED_INTEGER = 0x8D94,
 494         RGB_INTEGER = 0x8D98,
 495         RGBA_INTEGER = 0x8D99,
 496         SAMPLER_2D_ARRAY = 0x8DC1,
 497         SAMPLER_2D_ARRAY_SHADOW = 0x8DC4,
 498         SAMPLER_CUBE_SHADOW = 0x8DC5,
 499         UNSIGNED_INT_VEC2 = 0x8DC6,
 500         UNSIGNED_INT_VEC3 = 0x8DC7,
 501         UNSIGNED_INT_VEC4 = 0x8DC8,
 502         INT_SAMPLER_2D = 0x8DCA,
 503         INT_SAMPLER_3D = 0x8DCB,
 504         INT_SAMPLER_CUBE = 0x8DCC,
 505         INT_SAMPLER_2D_ARRAY = 0x8DCF,
 506         UNSIGNED_INT_SAMPLER_2D = 0x8DD2,
 507         UNSIGNED_INT_SAMPLER_3D = 0x8DD3,
 508         UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4,
 509         UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7,
 510         DEPTH_COMPONENT32F = 0x8CAC,
 511         DEPTH32F_STENCIL8 = 0x8CAD,
 512         FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD,
 513         FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210,
 514         FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211,
 515         FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212,
 516         FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213,
 517         FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214,
 518         FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215,
 519         FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216,
 520         FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217,
 521         FRAMEBUFFER_DEFAULT = 0x8218,
 522         DEPTH_STENCIL_ATTACHMENT = 0x821A,
 523         DEPTH_STENCIL = 0x84F9,
 524         UNSIGNED_INT_24_8 = 0x84FA,
 525         DEPTH24_STENCIL8 = 0x88F0,
 526         UNSIGNED_NORMALIZED = 0x8C17,
 527         DRAW_FRAMEBUFFER_BINDING = 0x8CA6, /* Same as FRAMEBUFFER_BINDING */
 528         READ_FRAMEBUFFER = 0x8CA8,
 529         DRAW_FRAMEBUFFER = 0x8CA9,
 530         READ_FRAMEBUFFER_BINDING = 0x8CAA,
 531         RENDERBUFFER_SAMPLES = 0x8CAB,
 532         FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4,
 533         MAX_COLOR_ATTACHMENTS = 0x8CDF,
 534         COLOR_ATTACHMENT1 = 0x8CE1,
 535         COLOR_ATTACHMENT2 = 0x8CE2,
 536         COLOR_ATTACHMENT3 = 0x8CE3,
 537         COLOR_ATTACHMENT4 = 0x8CE4,
 538         COLOR_ATTACHMENT5 = 0x8CE5,
 539         COLOR_ATTACHMENT6 = 0x8CE6,
 540         COLOR_ATTACHMENT7 = 0x8CE7,
 541         COLOR_ATTACHMENT8 = 0x8CE8,
 542         COLOR_ATTACHMENT9 = 0x8CE9,
 543         COLOR_ATTACHMENT10 = 0x8CEA,
 544         COLOR_ATTACHMENT11 = 0x8CEB,
 545         COLOR_ATTACHMENT12 = 0x8CEC,
 546         COLOR_ATTACHMENT13 = 0x8CED,
 547         COLOR_ATTACHMENT14 = 0x8CEE,
 548         COLOR_ATTACHMENT15 = 0x8CEF,
 549         FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56,
 550         MAX_SAMPLES = 0x8D57,
 551         HALF_FLOAT = 0x140B,
 552         RG = 0x8227,
 553         RG_INTEGER = 0x8228,
 554         R8 = 0x8229,
 555         RG8 = 0x822B,
 556         R16F = 0x822D,
 557         R32F = 0x822E,
 558         RG16F = 0x822F,
 559         RG32F = 0x8230,
 560         R8I = 0x8231,
 561         R8UI = 0x8232,
 562         R16I = 0x8233,
 563         R16UI = 0x8234,
 564         R32I = 0x8235,
 565         R32UI = 0x8236,
 566         RG8I = 0x8237,
 567         RG8UI = 0x8238,
 568         RG16I = 0x8239,
 569         RG16UI = 0x823A,
 570         RG32I = 0x823B,
 571         RG32UI = 0x823C,
 572         VERTEX_ARRAY_BINDING = 0x85B5,
 573         R8_SNORM = 0x8F94,
 574         RG8_SNORM = 0x8F95,
 575         RGB8_SNORM = 0x8F96,
 576         RGBA8_SNORM = 0x8F97,
 577         SIGNED_NORMALIZED = 0x8F9C,
 578         COPY_READ_BUFFER = 0x8F36,
 579         COPY_WRITE_BUFFER = 0x8F37,
 580         COPY_READ_BUFFER_BINDING = 0x8F36, /* Same as COPY_READ_BUFFER */
 581         COPY_WRITE_BUFFER_BINDING = 0x8F37, /* Same as COPY_WRITE_BUFFER */
 582         UNIFORM_BUFFER = 0x8A11,
 583         UNIFORM_BUFFER_BINDING = 0x8A28,
 584         UNIFORM_BUFFER_START = 0x8A29,
 585         UNIFORM_BUFFER_SIZE = 0x8A2A,
 586         MAX_VERTEX_UNIFORM_BLOCKS = 0x8A2B,
 587         MAX_FRAGMENT_UNIFORM_BLOCKS = 0x8A2D,
 588         MAX_COMBINED_UNIFORM_BLOCKS = 0x8A2E,
 589         MAX_UNIFORM_BUFFER_BINDINGS = 0x8A2F,
 590         MAX_UNIFORM_BLOCK_SIZE = 0x8A30,
 591         MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31,
 592         MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33,
 593         UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34,
 594         ACTIVE_UNIFORM_BLOCKS = 0x8A36,
 595         UNIFORM_TYPE = 0x8A37,
 596         UNIFORM_SIZE = 0x8A38,
 597         UNIFORM_BLOCK_INDEX = 0x8A3A,
 598         UNIFORM_OFFSET = 0x8A3B,
 599         UNIFORM_ARRAY_STRIDE = 0x8A3C,
 600         UNIFORM_MATRIX_STRIDE = 0x8A3D,
 601         UNIFORM_IS_ROW_MAJOR = 0x8A3E,
 602         UNIFORM_BLOCK_BINDING = 0x8A3F,
 603         UNIFORM_BLOCK_DATA_SIZE = 0x8A40,
 604         UNIFORM_BLOCK_ACTIVE_UNIFORMS = 0x8A42,
 605         UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43,
 606         UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44,
 607         UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46,
 608         INVALID_INDEX = 0xFFFFFFFF,
 609         MAX_VERTEX_OUTPUT_COMPONENTS = 0x9122,
 610         MAX_FRAGMENT_INPUT_COMPONENTS = 0x9125,
 611         MAX_SERVER_WAIT_TIMEOUT = 0x9111,
 612         OBJECT_TYPE = 0x9112,
 613         SYNC_CONDITION = 0x9113,
 614         SYNC_STATUS = 0x9114,
 615         SYNC_FLAGS = 0x9115,
 616         SYNC_FENCE = 0x9116,
 617         SYNC_GPU_COMMANDS_COMPLETE = 0x9117,
 618         UNSIGNALED = 0x9118,
 619         SIGNALED = 0x9119,
 620         ALREADY_SIGNALED = 0x911A,
 621         TIMEOUT_EXPIRED = 0x911B,
 622         CONDITION_SATISFIED = 0x911C,
 623 #if PLATFORM(WIN)
 624         WAIT_FAILED_WIN = 0x911D,
 625 #else
 626         WAIT_FAILED = 0x911D,
 627 #endif
 628         SYNC_FLUSH_COMMANDS_BIT = 0x00000001,
 629         VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE,
 630         ANY_SAMPLES_PASSED = 0x8C2F,
 631         ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A,
 632         SAMPLER_BINDING = 0x8919,
 633         RGB10_A2UI = 0x906F,
 634         TEXTURE_SWIZZLE_R = 0x8E42,
 635         TEXTURE_SWIZZLE_G = 0x8E43,
 636         TEXTURE_SWIZZLE_B = 0x8E44,
 637         TEXTURE_SWIZZLE_A = 0x8E45,
 638         GREEN = 0x1904,
 639         BLUE = 0x1905,
 640         INT_2_10_10_10_REV = 0x8D9F,
 641         TRANSFORM_FEEDBACK = 0x8E22,
 642         TRANSFORM_FEEDBACK_PAUSED = 0x8E23,
 643         TRANSFORM_FEEDBACK_ACTIVE = 0x8E24,
 644         TRANSFORM_FEEDBACK_BINDING = 0x8E25,
 645         COMPRESSED_R11_EAC = 0x9270,
 646         COMPRESSED_SIGNED_R11_EAC = 0x9271,
 647         COMPRESSED_RG11_EAC = 0x9272,
 648         COMPRESSED_SIGNED_RG11_EAC = 0x9273,
 649         COMPRESSED_RGB8_ETC2 = 0x9274,
 650         COMPRESSED_SRGB8_ETC2 = 0x9275,
 651         COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276,
 652         COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277,
 653         COMPRESSED_RGBA8_ETC2_EAC = 0x9278,
 654         COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279,
 655         TEXTURE_IMMUTABLE_FORMAT = 0x912F,
 656         MAX_ELEMENT_INDEX = 0x8D6B,
 657         NUM_SAMPLE_COUNTS = 0x9380,
 658         TEXTURE_IMMUTABLE_LEVELS = 0x82DF,
 659         PRIMITIVE_RESTART_FIXED_INDEX = 0x8D69,
 660         PRIMITIVE_RESTART = 0x8F9D,
 661 
 662         // OpenGL ES 3 constants.
 663         MAP_READ_BIT = 0x0001,
 664 
 665         // WebGL-specific.
 666         MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 0x9247,
 667 
 668         // Necessary desktop OpenGL constants.
 669         TEXTURE_RECTANGLE_ARB = 0x84F5
 670     };
 671 
 672     enum class DataFormat : uint8_t {
 673         RGBA8 = 0,
 674         RGBA16Little,
 675         RGBA16Big,
 676         RGBA16F,
 677         RGBA32F,
 678         RGB8,
 679         RGB16Little,
 680         RGB16Big,
 681         RGB16F,
 682         RGB32F,
 683         BGR8,
 684         BGRA8,
 685         BGRA16Little,
 686         BGRA16Big,
 687         ARGB8,
 688         ARGB16Little,
 689         ARGB16Big,
 690         ABGR8,
 691         RGBA5551,
 692         RGBA4444,
 693         RGB565,
 694         R8,
 695         R16Little,
 696         R16Big,
 697         R16F,
 698         R32F,
 699         RA8,
 700         RA16Little,
 701         RA16Big,
 702         RA16F,
 703         RA32F,
 704         AR8,
 705         AR16Little,
 706         AR16Big,
 707         A8,
 708         A16Little,
 709         A16Big,
 710         A16F,
 711         A32F,
 712         NumFormats
 713     };
 714 
 715     enum class Destination : uint8_t {
 716         Offscreen,
 717         DirectlyToHostWindow,
 718     };
 719 
 720     enum class ChannelBits : uint8_t {
 721         Red = 1,
 722         Green = 2,
 723         Blue = 4,
 724         Alpha = 8,
 725         Depth = 16,
 726         Stencil = 32,
 727         RGB = Red | Green | Blue,
 728         RGBA = RGB | Alpha,
 729         DepthStencil = Depth | Stencil,
 730     };
 731 
 732     // Possible alpha operations that may need to occur during
 733     // pixel packing. FIXME: kAlphaDoUnmultiply is lossy and must
 734     // be removed.
 735     enum AlphaOp : uint8_t {
 736         DoNothing,
 737         DoPremultiply,
 738         DoUnmultiply,
 739     };
 740 
 741     enum class DOMSource : uint8_t {
 742         Image,
 743         Canvas,
 744         Video,
 745         DOMSourceNone,
 746     };
 747 
 748 #if USE(ANGLE)
 749     enum {
 750         // These constants are redefined here from ANGLE&#39;s OpenGL ES headers to
 751         // provide a single place where multiple portions of platform code can
 752         // reference them.
 753 #if PLATFORM(MAC)
 754         IOSurfaceTextureTarget = TEXTURE_RECTANGLE_ARB, // also GL_TEXTURE_RECTANGLE_ANGLE
 755         EGLIOSurfaceTextureTarget = 0x345B, // EGL_TEXTURE_RECTANGLE_ANGLE
 756 #else
 757         IOSurfaceTextureTarget = TEXTURE_2D,
 758         EGLIOSurfaceTextureTarget = 0x305F, // EGL_TEXTURE_2D
 759 #endif // PLATFORM(MAC)
 760     };
 761 #endif // USE(ANGLE)
 762 
 763     virtual PlatformGraphicsContextGL platformGraphicsContextGL() const = 0;
 764     virtual PlatformGLObject platformTexture() const = 0;
 765     virtual PlatformLayer* platformLayer() const = 0;
 766 
 767     ALWAYS_INLINE static bool hasAlpha(DataFormat format)
 768     {
 769         switch (format) {
 770         case DataFormat::A8:
 771         case DataFormat::A16F:
 772         case DataFormat::A32F:
 773         case DataFormat::RA8:
 774         case DataFormat::AR8:
 775         case DataFormat::RA16F:
 776         case DataFormat::RA32F:
 777         case DataFormat::RGBA8:
 778         case DataFormat::BGRA8:
 779         case DataFormat::ARGB8:
 780         case DataFormat::ABGR8:
 781         case DataFormat::RGBA16F:
 782         case DataFormat::RGBA32F:
 783         case DataFormat::RGBA4444:
 784         case DataFormat::RGBA5551:
 785             return true;
 786         default:
 787             return false;
 788         }
 789     }
 790 
 791     ALWAYS_INLINE static bool hasColor(DataFormat format)
 792     {
 793         switch (format) {
 794         case DataFormat::RGBA8:
 795         case DataFormat::RGBA16F:
 796         case DataFormat::RGBA32F:
 797         case DataFormat::RGB8:
 798         case DataFormat::RGB16F:
 799         case DataFormat::RGB32F:
 800         case DataFormat::BGR8:
 801         case DataFormat::BGRA8:
 802         case DataFormat::ARGB8:
 803         case DataFormat::ABGR8:
 804         case DataFormat::RGBA5551:
 805         case DataFormat::RGBA4444:
 806         case DataFormat::RGB565:
 807         case DataFormat::R8:
 808         case DataFormat::R16F:
 809         case DataFormat::R32F:
 810         case DataFormat::RA8:
 811         case DataFormat::RA16F:
 812         case DataFormat::RA32F:
 813         case DataFormat::AR8:
 814             return true;
 815         default:
 816             return false;
 817         }
 818     }
 819 
 820     // Check if the format is one of the formats from the ImageData or DOM elements.
 821     // The formats from ImageData is always RGBA8.
 822     // The formats from DOM elements vary with Graphics ports. It can only be RGBA8 or BGRA8 for non-CG port while a little more for CG port.
 823     static ALWAYS_INLINE bool srcFormatComesFromDOMElementOrImageData(DataFormat SrcFormat)
 824     {
 825 #if USE(CG)
 826 #if CPU(BIG_ENDIAN)
 827     return SrcFormat == DataFormat::RGBA8 || SrcFormat == DataFormat::ARGB8 || SrcFormat == DataFormat::RGB8
 828         || SrcFormat == DataFormat::RA8 || SrcFormat == DataFormat::AR8 || SrcFormat == DataFormat::R8 || SrcFormat == DataFormat::A8;
 829 #else
 830     // That LITTLE_ENDIAN case has more possible formats than BIG_ENDIAN case is because some decoded image data is actually big endian
 831     // even on little endian architectures.
 832     return SrcFormat == DataFormat::BGRA8 || SrcFormat == DataFormat::ABGR8 || SrcFormat == DataFormat::BGR8
 833         || SrcFormat == DataFormat::RGBA8 || SrcFormat == DataFormat::ARGB8 || SrcFormat == DataFormat::RGB8
 834         || SrcFormat == DataFormat::R8 || SrcFormat == DataFormat::A8
 835         || SrcFormat == DataFormat::RA8 || SrcFormat == DataFormat::AR8;
 836 #endif
 837 #else
 838     return SrcFormat == DataFormat::BGRA8 || SrcFormat == DataFormat::RGBA8;
 839 #endif
 840     }
 841 
 842     struct ActiveInfo {
 843         String name;
 844         GCGLenum type;
 845         GCGLint size;
 846     };
 847 
 848     GraphicsContextGL(GraphicsContextGLAttributes, Destination = Destination::Offscreen, GraphicsContextGL* sharedContext = nullptr);
 849     virtual ~GraphicsContextGL() = default;
 850 
 851     // ========== WebGL 1 entry points.
 852 
 853     virtual void activeTexture(GCGLenum texture) = 0;
 854     virtual void attachShader(PlatformGLObject program, PlatformGLObject shader) = 0;
 855     virtual void bindAttribLocation(PlatformGLObject, GCGLuint index, const String&amp; name) = 0;
 856     virtual void bindBuffer(GCGLenum target, PlatformGLObject) = 0;
 857     virtual void bindFramebuffer(GCGLenum target, PlatformGLObject) = 0;
 858     virtual void bindRenderbuffer(GCGLenum target, PlatformGLObject) = 0;
 859     virtual void bindTexture(GCGLenum target, PlatformGLObject) = 0;
 860     virtual void blendColor(GCGLclampf red, GCGLclampf green, GCGLclampf blue, GCGLclampf alpha) = 0;
 861     virtual void blendEquation(GCGLenum mode) = 0;
 862     virtual void blendEquationSeparate(GCGLenum modeRGB, GCGLenum modeAlpha) = 0;
 863     virtual void blendFunc(GCGLenum sfactor, GCGLenum dfactor) = 0;
 864     virtual void blendFuncSeparate(GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha) = 0;
 865 
 866     virtual GCGLenum checkFramebufferStatus(GCGLenum target) = 0;
 867     virtual void clear(GCGLbitfield mask) = 0;
 868     virtual void clearColor(GCGLclampf red, GCGLclampf green, GCGLclampf blue, GCGLclampf alpha) = 0;
 869     virtual void clearDepth(GCGLclampf depth) = 0;
 870     virtual void clearStencil(GCGLint s) = 0;
 871     virtual void colorMask(GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha) = 0;
 872     virtual void compileShader(PlatformGLObject) = 0;
 873 
 874     virtual void copyTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLint border) = 0;
 875     virtual void copyTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height) = 0;
 876 
 877     virtual PlatformGLObject createBuffer() = 0;
 878     virtual PlatformGLObject createFramebuffer() = 0;
 879     virtual PlatformGLObject createProgram() = 0;
 880     virtual PlatformGLObject createRenderbuffer() = 0;
 881     virtual PlatformGLObject createShader(GCGLenum) = 0;
 882     virtual PlatformGLObject createTexture() = 0;
 883 
 884     virtual void cullFace(GCGLenum mode) = 0;
 885 
 886     virtual void deleteBuffer(PlatformGLObject) = 0;
 887     virtual void deleteFramebuffer(PlatformGLObject) = 0;
 888     virtual void deleteProgram(PlatformGLObject) = 0;
 889     virtual void deleteRenderbuffer(PlatformGLObject) = 0;
 890     virtual void deleteShader(PlatformGLObject) = 0;
 891     virtual void deleteTexture(PlatformGLObject) = 0;
 892 
 893     virtual void depthFunc(GCGLenum func) = 0;
 894     virtual void depthMask(GCGLboolean flag) = 0;
 895     virtual void depthRange(GCGLclampf zNear, GCGLclampf zFar) = 0;
 896     virtual void detachShader(PlatformGLObject, PlatformGLObject) = 0;
 897     virtual void disable(GCGLenum cap) = 0;
 898     virtual void disableVertexAttribArray(GCGLuint index) = 0;
 899     virtual void drawArrays(GCGLenum mode, GCGLint first, GCGLsizei count) = 0;
 900     virtual void drawElements(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLintptr offset) = 0;
 901 
 902     virtual void enable(GCGLenum cap) = 0;
 903     virtual void enableVertexAttribArray(GCGLuint index) = 0;
 904     virtual void finish() = 0;
 905     virtual void flush() = 0;
 906     virtual void framebufferRenderbuffer(GCGLenum target, GCGLenum attachment, GCGLenum renderbuffertarget, PlatformGLObject) = 0;
 907     virtual void framebufferTexture2D(GCGLenum target, GCGLenum attachment, GCGLenum textarget, PlatformGLObject, GCGLint level) = 0;
 908     virtual void frontFace(GCGLenum mode) = 0;
 909 
 910     virtual void generateMipmap(GCGLenum target) = 0;
 911 
 912     virtual bool getActiveAttrib(PlatformGLObject program, GCGLuint index, ActiveInfo&amp;) = 0;
 913     virtual bool getActiveUniform(PlatformGLObject program, GCGLuint index, ActiveInfo&amp;) = 0;
 914     virtual void getAttachedShaders(PlatformGLObject program, GCGLsizei maxCount, GCGLsizei* count, PlatformGLObject* shaders) = 0;
 915 
 916     virtual GCGLint getAttribLocation(PlatformGLObject, const String&amp; name) = 0;
 917 
 918     virtual void getBufferParameteriv(GCGLenum target, GCGLenum pname, GCGLint* value) = 0;
 919 
 920     // getParameter
 921     virtual String getString(GCGLenum name) = 0;
 922     virtual void getFloatv(GCGLenum pname, GCGLfloat* value) = 0;
 923     virtual void getIntegerv(GCGLenum pname, GCGLint* value) = 0;
 924     virtual void getInteger64v(GCGLenum pname, GCGLint64* value) = 0;
 925     virtual void getProgramiv(PlatformGLObject program, GCGLenum pname, GCGLint* value) = 0;
 926     virtual void getBooleanv(GCGLenum pname, GCGLboolean* value) = 0;
 927 
 928     virtual GCGLenum getError() = 0;
 929 
 930     // getFramebufferAttachmentParameter
 931     virtual void getFramebufferAttachmentParameteriv(GCGLenum target, GCGLenum attachment, GCGLenum pname, GCGLint* value) = 0;
 932 
 933     // getProgramParameter
 934     virtual String getProgramInfoLog(PlatformGLObject) = 0;
 935 
 936     // getRenderbufferParameter
 937     virtual void getRenderbufferParameteriv(GCGLenum target, GCGLenum pname, GCGLint* value) = 0;
 938 
 939     // getShaderParameter
 940     virtual void getShaderiv(PlatformGLObject, GCGLenum pname, GCGLint* value) = 0;
 941 
 942     virtual String getShaderInfoLog(PlatformGLObject) = 0;
 943     virtual void getShaderPrecisionFormat(GCGLenum shaderType, GCGLenum precisionType, GCGLint* range, GCGLint* precision) = 0;
 944 
 945     virtual String getShaderSource(PlatformGLObject) = 0;
 946 
 947     // getTexParameter
 948     virtual void getTexParameterfv(GCGLenum target, GCGLenum pname, GCGLfloat* value) = 0;
 949     virtual void getTexParameteriv(GCGLenum target, GCGLenum pname, GCGLint* value) = 0;
 950 
 951     // getUniform
 952     virtual void getUniformfv(PlatformGLObject program, GCGLint location, GCGLfloat* value) = 0;
 953     virtual void getUniformiv(PlatformGLObject program, GCGLint location, GCGLint* value) = 0;
 954 
 955     virtual GCGLint getUniformLocation(PlatformGLObject, const String&amp; name) = 0;
 956 
 957     // getVertexAttrib
 958     virtual void getVertexAttribfv(GCGLuint index, GCGLenum pname, GCGLfloat* value) = 0;
 959     virtual void getVertexAttribiv(GCGLuint index, GCGLenum pname, GCGLint* value) = 0;
 960 
 961     virtual GCGLsizeiptr getVertexAttribOffset(GCGLuint index, GCGLenum pname) = 0;
 962 
 963     virtual void hint(GCGLenum target, GCGLenum mode) = 0;
 964     virtual GCGLboolean isBuffer(PlatformGLObject) = 0;
 965     virtual GCGLboolean isEnabled(GCGLenum cap) = 0;
 966     virtual GCGLboolean isFramebuffer(PlatformGLObject) = 0;
 967     virtual GCGLboolean isProgram(PlatformGLObject) = 0;
 968     virtual GCGLboolean isRenderbuffer(PlatformGLObject) = 0;
 969     virtual GCGLboolean isShader(PlatformGLObject) = 0;
 970     virtual GCGLboolean isTexture(PlatformGLObject) = 0;
 971     virtual void lineWidth(GCGLfloat) = 0;
 972     virtual void linkProgram(PlatformGLObject) = 0;
 973     virtual void pixelStorei(GCGLenum pname, GCGLint param) = 0;
 974     virtual void polygonOffset(GCGLfloat factor, GCGLfloat units) = 0;
 975 
 976     virtual void renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height) = 0;
 977     virtual void sampleCoverage(GCGLclampf value, GCGLboolean invert) = 0;
 978     virtual void scissor(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height) = 0;
 979 
 980     virtual void shaderSource(PlatformGLObject, const String&amp; string) = 0;
 981 
 982     virtual void stencilFunc(GCGLenum func, GCGLint ref, GCGLuint mask) = 0;
 983     virtual void stencilFuncSeparate(GCGLenum face, GCGLenum func, GCGLint ref, GCGLuint mask) = 0;
 984     virtual void stencilMask(GCGLuint mask) = 0;
 985     virtual void stencilMaskSeparate(GCGLenum face, GCGLuint mask) = 0;
 986     virtual void stencilOp(GCGLenum fail, GCGLenum zfail, GCGLenum zpass) = 0;
 987     virtual void stencilOpSeparate(GCGLenum face, GCGLenum fail, GCGLenum zfail, GCGLenum zpass) = 0;
 988 
 989     virtual void texParameterf(GCGLenum target, GCGLenum pname, GCGLfloat param) = 0;
 990     virtual void texParameteri(GCGLenum target, GCGLenum pname, GCGLint param) = 0;
 991 
 992     virtual void uniform1f(GCGLint location, GCGLfloat x) = 0;
 993     virtual void uniform1fv(GCGLint location, GCGLsizei, const GCGLfloat* v) = 0;
 994     virtual void uniform1i(GCGLint location, GCGLint x) = 0;
 995     virtual void uniform1iv(GCGLint location, GCGLsizei, const GCGLint* v) = 0;
 996     virtual void uniform2f(GCGLint location, GCGLfloat x, GCGLfloat y) = 0;
 997     virtual void uniform2fv(GCGLint location, GCGLsizei, const GCGLfloat* v) = 0;
 998     virtual void uniform2i(GCGLint location, GCGLint x, GCGLint y) = 0;
 999     virtual void uniform2iv(GCGLint location, GCGLsizei, const GCGLint* v) = 0;
1000     virtual void uniform3f(GCGLint location, GCGLfloat x, GCGLfloat y, GCGLfloat z) = 0;
1001     virtual void uniform3fv(GCGLint location, GCGLsizei, const GCGLfloat* v) = 0;
1002     virtual void uniform3i(GCGLint location, GCGLint x, GCGLint y, GCGLint z) = 0;
1003     virtual void uniform3iv(GCGLint location, GCGLsizei, const GCGLint* v) = 0;
1004     virtual void uniform4f(GCGLint location, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w) = 0;
1005     virtual void uniform4fv(GCGLint location, GCGLsizei, const GCGLfloat* v) = 0;
1006     virtual void uniform4i(GCGLint location, GCGLint x, GCGLint y, GCGLint z, GCGLint w) = 0;
1007     virtual void uniform4iv(GCGLint location, GCGLsizei, const GCGLint* v) = 0;
1008     virtual void uniformMatrix2fv(GCGLint location, GCGLsizei, GCGLboolean transpose, const GCGLfloat* value) = 0;
1009     virtual void uniformMatrix3fv(GCGLint location, GCGLsizei, GCGLboolean transpose, const GCGLfloat* value) = 0;
1010     virtual void uniformMatrix4fv(GCGLint location, GCGLsizei, GCGLboolean transpose, const GCGLfloat* value) = 0;
1011 
1012     virtual void useProgram(PlatformGLObject) = 0;
1013     virtual void validateProgram(PlatformGLObject) = 0;
1014 
1015     virtual void vertexAttrib1f(GCGLuint index, GCGLfloat x) = 0;
1016     virtual void vertexAttrib1fv(GCGLuint index, const GCGLfloat* values) = 0;
1017     virtual void vertexAttrib2f(GCGLuint index, GCGLfloat x, GCGLfloat y) = 0;
1018     virtual void vertexAttrib2fv(GCGLuint index, const GCGLfloat* values) = 0;
1019     virtual void vertexAttrib3f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z) = 0;
1020     virtual void vertexAttrib3fv(GCGLuint index, const GCGLfloat* values) = 0;
1021     virtual void vertexAttrib4f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w) = 0;
1022     virtual void vertexAttrib4fv(GCGLuint index, const GCGLfloat* values) = 0;
1023 
1024     virtual void vertexAttribPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLboolean normalized, GCGLsizei stride, GCGLintptr offset) = 0;
1025 
1026     virtual void viewport(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height) = 0;
1027 
1028     virtual void bufferData(GCGLenum target, GCGLsizeiptr size, GCGLenum usage) = 0;
1029     virtual void bufferData(GCGLenum target, GCGLsizeiptr size, const void* data, GCGLenum usage) = 0;
1030     virtual void bufferSubData(GCGLenum target, GCGLintptr offset, GCGLsizeiptr size, const void* data) = 0;
1031 
1032     virtual void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, const void* data) = 0;
1033     virtual void compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLsizei imageSize, const void* data) = 0;
1034 
1035     virtual void readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, void* data) = 0;
1036 
1037     virtual bool texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels) = 0;
1038     virtual void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, const void* pixels) = 0;
1039 
1040     virtual void drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount) = 0;
1041     virtual void drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLintptr offset, GCGLsizei primcount) = 0;
1042     virtual void vertexAttribDivisor(GCGLuint index, GCGLuint divisor) = 0;
1043 
1044     GraphicsContextGLAttributes contextAttributes() const { return m_attrs; }
1045     void setContextAttributes(const GraphicsContextGLAttributes&amp; attrs) { m_attrs = attrs; }
1046 
1047     // VertexArrayOject calls
1048     virtual PlatformGLObject createVertexArray() = 0;
1049     virtual void deleteVertexArray(PlatformGLObject) = 0;
1050     virtual GCGLboolean isVertexArray(PlatformGLObject) = 0;
1051     virtual void bindVertexArray(PlatformGLObject) = 0;
1052 
1053 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
1054     virtual void primitiveRestartIndex(GCGLuint) = 0;
1055 #endif
1056 
1057     // Support for extensions. Returns a non-null object, though not
1058     // all methods it contains may necessarily be supported on the
1059     // current hardware. Must call ExtensionsGL::supports() to
1060     // determine this.
1061     virtual ExtensionsGL&amp; getExtensions() = 0;
1062 
1063     // ========== WebGL 2 entry points.
1064 
1065     virtual void bufferData(GCGLenum target, const void* data, GCGLenum usage, GCGLuint srcOffset, GCGLuint length) = 0;
1066     virtual void bufferSubData(GCGLenum target, GCGLintptr dstByteOffset, const void* srcData, GCGLuint srcOffset, GCGLuint length) = 0;
1067 
1068     virtual void copyBufferSubData(GCGLenum readTarget, GCGLenum writeTarget, GCGLintptr readOffset, GCGLintptr writeOffset, GCGLsizeiptr size) = 0;
1069     virtual void getBufferSubData(GCGLenum target, GCGLintptr srcByteOffset, const void* dstData, GCGLuint dstOffset, GCGLuint length) = 0;
1070     virtual void* mapBufferRange(GCGLenum target, GCGLintptr offset, GCGLsizeiptr length, GCGLbitfield access) = 0;
1071     virtual GCGLboolean unmapBuffer(GCGLenum target) = 0;
1072 
1073     virtual void blitFramebuffer(GCGLint srcX0, GCGLint srcY0, GCGLint srcX1, GCGLint srcY1, GCGLint dstX0, GCGLint dstY0, GCGLint dstX1, GCGLint dstY1, GCGLbitfield mask, GCGLenum filter) = 0;
1074     virtual void framebufferTextureLayer(GCGLenum target, GCGLenum attachment, PlatformGLObject texture, GCGLint level, GCGLint layer) = 0;
1075     virtual void invalidateFramebuffer(GCGLenum target, const Vector&lt;GCGLenum&gt;&amp; attachments) = 0;
1076     virtual void invalidateSubFramebuffer(GCGLenum target, const Vector&lt;GCGLenum&gt;&amp; attachments, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height) = 0;
1077     virtual void readBuffer(GCGLenum src) = 0;
1078 
1079     // getInternalFormatParameter
1080     virtual void getInternalformativ(GCGLenum target, GCGLenum internalformat, GCGLenum pname, GCGLsizei bufSize, GCGLint* params) = 0;
1081     virtual void renderbufferStorageMultisample(GCGLenum target, GCGLsizei samples, GCGLenum internalformat, GCGLsizei width, GCGLsizei height) = 0;
1082 
1083     virtual void texStorage2D(GCGLenum target, GCGLsizei levels, GCGLenum internalformat, GCGLsizei width, GCGLsizei height) = 0;
1084     virtual void texStorage3D(GCGLenum target, GCGLsizei levels, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth) = 0;
1085 
1086     virtual void texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, GCGLintptr pboOffset) = 0;
1087     virtual void texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels) = 0;
1088     virtual void texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, const void* srcData, GCGLuint srcOffset) = 0;
1089 
1090     virtual void texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, GCGLintptr pboOffset) = 0;
1091     virtual void texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, const void* srcData, GCGLuint srcOffset) = 0;
1092 
1093     virtual void copyTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height) = 0;
1094 
1095     virtual void compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLsizei imageSize, GCGLintptr offset) = 0;
1096     virtual void compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride) = 0;
1097     virtual void compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLsizei imageSize, GCGLintptr offset) = 0;
1098     virtual void compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride) = 0;
1099 
1100     virtual GCGLint getFragDataLocation(PlatformGLObject program, const String&amp; name) = 0;
1101 
1102     virtual void uniform1ui(GCGLint location, GCGLuint v0) = 0;
1103     virtual void uniform2ui(GCGLint location, GCGLuint v0, GCGLuint v1) = 0;
1104     virtual void uniform3ui(GCGLint location, GCGLuint v0, GCGLuint v1, GCGLuint v2) = 0;
1105     virtual void uniform4ui(GCGLint location, GCGLuint v0, GCGLuint v1, GCGLuint v2, GCGLuint v3) = 0;
1106     virtual void uniform1uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1107     virtual void uniform2uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1108     virtual void uniform3uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1109     virtual void uniform4uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1110     virtual void uniformMatrix2x3fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1111     virtual void uniformMatrix3x2fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1112     virtual void uniformMatrix2x4fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1113     virtual void uniformMatrix4x2fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1114     virtual void uniformMatrix3x4fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1115     virtual void uniformMatrix4x3fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1116     virtual void vertexAttribI4i(GCGLuint index, GCGLint x, GCGLint y, GCGLint z, GCGLint w) = 0;
1117     virtual void vertexAttribI4iv(GCGLuint index, const GCGLint* values) = 0;
1118     virtual void vertexAttribI4ui(GCGLuint index, GCGLuint x, GCGLuint y, GCGLuint z, GCGLuint w) = 0;
1119     virtual void vertexAttribI4uiv(GCGLuint index, const GCGLuint* values) = 0;
1120     virtual void vertexAttribIPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLsizei stride, GCGLintptr offset) = 0;
1121 
1122     virtual void drawRangeElements(GCGLenum mode, GCGLuint start, GCGLuint end, GCGLsizei count, GCGLenum type, GCGLintptr offset) = 0;
1123 
1124     virtual void drawBuffers(const Vector&lt;GCGLenum&gt;&amp; buffers) = 0;
1125     virtual void clearBufferiv(GCGLenum buffer, GCGLint drawbuffer, const GCGLint* values, GCGLuint srcOffset) = 0;
1126     virtual void clearBufferuiv(GCGLenum buffer, GCGLint drawbuffer, const GCGLuint* values, GCGLuint srcOffset) = 0;
1127     virtual void clearBufferfv(GCGLenum buffer, GCGLint drawbuffer, const GCGLfloat* values, GCGLuint srcOffset) = 0;
1128     virtual void clearBufferfi(GCGLenum buffer, GCGLint drawbuffer, GCGLfloat depth, GCGLint stencil) = 0;
1129 
1130     virtual PlatformGLObject createQuery() = 0;
1131     virtual void deleteQuery(PlatformGLObject query) = 0;
1132     virtual GCGLboolean isQuery(PlatformGLObject query) = 0;
1133     virtual void beginQuery(GCGLenum target, PlatformGLObject query) = 0;
1134     virtual void endQuery(GCGLenum target) = 0;
1135     virtual PlatformGLObject getQuery(GCGLenum target, GCGLenum pname) = 0;
1136     // getQueryParameter
1137     virtual void getQueryObjectuiv(PlatformGLObject query, GCGLenum pname, GCGLuint* value) = 0;
1138 
1139     virtual PlatformGLObject createSampler() = 0;
1140     virtual void deleteSampler(PlatformGLObject sampler) = 0;
1141     virtual GCGLboolean isSampler(PlatformGLObject sampler) = 0;
1142     virtual void bindSampler(GCGLuint unit, PlatformGLObject sampler) = 0;
1143     virtual void samplerParameteri(PlatformGLObject sampler, GCGLenum pname, GCGLint param) = 0;
1144     virtual void samplerParameterf(PlatformGLObject sampler, GCGLenum pname, GCGLfloat param) = 0;
1145     // getSamplerParameter
1146     virtual void getSamplerParameterfv(PlatformGLObject sampler, GCGLenum pname, GCGLfloat* value) = 0;
1147     virtual void getSamplerParameteriv(PlatformGLObject sampler, GCGLenum pname, GCGLint* value) = 0;
1148 
1149     virtual PlatformGLObject fenceSync(GCGLenum condition, GCGLbitfield flags) = 0;
1150     virtual GCGLboolean isSync(PlatformGLObject sync) = 0;
1151     virtual void deleteSync(PlatformGLObject sync) = 0;
1152     virtual GCGLenum clientWaitSync(PlatformGLObject sync, GCGLbitfield flags, GCGLuint64 timeout) = 0;
1153     virtual void waitSync(PlatformGLObject sync, GCGLbitfield flags, GCGLint64 timeout) = 0;
1154     // getSyncParameter
1155     virtual void getSynciv(PlatformGLObject sync, GCGLenum pname, GCGLsizei bufSize, GCGLint* value) = 0;
1156 
1157     virtual PlatformGLObject createTransformFeedback() = 0;
1158     virtual void deleteTransformFeedback(PlatformGLObject id) = 0;
1159     virtual GCGLboolean isTransformFeedback(PlatformGLObject id) = 0;
1160     virtual void bindTransformFeedback(GCGLenum target, PlatformGLObject id) = 0;
1161     virtual void beginTransformFeedback(GCGLenum primitiveMode) = 0;
1162     virtual void endTransformFeedback() = 0;
1163     virtual void transformFeedbackVaryings(PlatformGLObject program, const Vector&lt;String&gt;&amp; varyings, GCGLenum bufferMode) = 0;
1164     virtual void getTransformFeedbackVarying(PlatformGLObject program, GCGLuint index, ActiveInfo&amp;) = 0;
1165     virtual void pauseTransformFeedback() = 0;
1166     virtual void resumeTransformFeedback() = 0;
1167 
1168     virtual void bindBufferBase(GCGLenum target, GCGLuint index, PlatformGLObject buffer) = 0;
1169     virtual void bindBufferRange(GCGLenum target, GCGLuint index, PlatformGLObject buffer, GCGLintptr offset, GCGLsizeiptr size) = 0;
1170     // getIndexedParameter -&gt; use getParameter calls above.
1171     virtual Vector&lt;GCGLuint&gt; getUniformIndices(PlatformGLObject program, const Vector&lt;String&gt;&amp; uniformNames) = 0;
1172     virtual void getActiveUniforms(PlatformGLObject program, const Vector&lt;GCGLuint&gt;&amp; uniformIndices, GCGLenum pname, Vector&lt;GCGLint&gt;&amp; params) = 0;
1173 
1174     virtual GCGLuint getUniformBlockIndex(PlatformGLObject program, const String&amp; uniformBlockName) = 0;
1175     // getActiveUniformBlockParameter
1176     virtual void getActiveUniformBlockiv(PlatformGLObject program, GCGLuint uniformBlockIndex, GCGLenum pname, GCGLint* params) = 0;
1177     virtual String getActiveUniformBlockName(PlatformGLObject program, GCGLuint uniformBlockIndex) = 0;
1178     virtual void uniformBlockBinding(PlatformGLObject program, GCGLuint uniformBlockIndex, GCGLuint uniformBlockBinding) = 0;
1179 
1180     virtual void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, GCGLintptr pboOffset) = 0;
1181     virtual void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, const void* srcData, GCGLuint srcOffset) = 0;
1182 
1183     virtual void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, GCGLintptr offset) = 0;
1184     virtual void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride) = 0;
1185 
1186     virtual void compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLsizei imageSize, GCGLintptr offset) = 0;
1187     virtual void compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride) = 0;
1188 
1189     virtual void uniform1fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1190     virtual void uniform2fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1191     virtual void uniform3fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1192     virtual void uniform4fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1193 
1194     virtual void uniform1iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1195     virtual void uniform2iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1196     virtual void uniform3iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1197     virtual void uniform4iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1198 
1199     virtual void uniformMatrix2fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1200     virtual void uniformMatrix3fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1201     virtual void uniformMatrix4fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) = 0;
1202 
1203     virtual void readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, GCGLintptr offset) = 0;
1204     virtual void readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, const void* dstData, GCGLuint dstOffset) = 0;
1205 
1206     // ========== Non-WebGL based entry points.
1207 
1208     static unsigned getClearBitsByAttachmentType(GCGLenum);
1209     static unsigned getClearBitsByFormat(GCGLenum);
1210 
1211     static uint8_t getChannelBitsByFormat(GCGLenum);
1212 
1213     Destination destination() const { return m_destination; }
1214 
1215 private:
1216     GraphicsContextGLAttributes m_attrs;
1217     Destination m_destination;
1218 };
1219 
1220 } // namespace WebCore
1221 
1222 #endif
    </pre>
  </body>
</html>
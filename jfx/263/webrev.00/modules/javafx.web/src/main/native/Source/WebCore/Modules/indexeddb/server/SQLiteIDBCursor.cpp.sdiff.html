<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBCursor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SQLiteIDBBackingStore.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteIDBCursor.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBCursor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SQLiteIDBCursor.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBCursorInfo.h&quot;
 32 #include &quot;IDBGetResult.h&quot;
 33 #include &quot;IDBSerialization.h&quot;
 34 #include &quot;Logging.h&quot;
 35 #include &quot;SQLiteIDBBackingStore.h&quot;
 36 #include &quot;SQLiteIDBTransaction.h&quot;
 37 #include &quot;SQLiteStatement.h&quot;
 38 #include &quot;SQLiteTransaction.h&quot;
 39 #include &lt;sqlite3.h&gt;
 40 #include &lt;wtf/text/StringBuilder.h&gt;
 41 
 42 namespace WebCore {
 43 namespace IDBServer {
 44 
<span class="line-modified"> 45 static const size_t prefetchLimit = 8;</span>

 46 
 47 std::unique_ptr&lt;SQLiteIDBCursor&gt; SQLiteIDBCursor::maybeCreate(SQLiteIDBTransaction&amp; transaction, const IDBCursorInfo&amp; info)
 48 {
 49     auto cursor = makeUnique&lt;SQLiteIDBCursor&gt;(transaction, info);
 50 
 51     if (!cursor-&gt;establishStatement())
 52         return nullptr;
 53 
 54     if (!cursor-&gt;advance(1))
 55         return nullptr;
 56 
 57     return cursor;
 58 }
 59 
 60 std::unique_ptr&lt;SQLiteIDBCursor&gt; SQLiteIDBCursor::maybeCreateBackingStoreCursor(SQLiteIDBTransaction&amp; transaction, const uint64_t objectStoreID, const uint64_t indexID, const IDBKeyRangeData&amp; range)
 61 {
 62     auto cursor = makeUnique&lt;SQLiteIDBCursor&gt;(transaction, objectStoreID, indexID, range);
 63 
 64     if (!cursor-&gt;establishStatement())
 65         return nullptr;
</pre>
<hr />
<pre>
 84 
 85 SQLiteIDBCursor::SQLiteIDBCursor(SQLiteIDBTransaction&amp; transaction, const uint64_t objectStoreID, const uint64_t indexID, const IDBKeyRangeData&amp; range)
 86     : m_transaction(&amp;transaction)
 87     , m_cursorIdentifier(transaction.transactionIdentifier())
 88     , m_objectStoreID(objectStoreID)
 89     , m_indexID(indexID ? indexID : IDBIndexInfo::InvalidId)
 90     , m_cursorDirection(IndexedDB::CursorDirection::Next)
 91     , m_cursorType(IndexedDB::CursorType::KeyAndValue)
 92     , m_keyRange(range)
 93     , m_backingStoreCursor(true)
 94 {
 95     ASSERT(m_objectStoreID);
 96 }
 97 
 98 SQLiteIDBCursor::~SQLiteIDBCursor()
 99 {
100     if (m_backingStoreCursor)
101         m_transaction-&gt;closeCursor(*this);
102 }
103 
<span class="line-modified">104 void SQLiteIDBCursor::currentData(IDBGetResult&amp; result, const Optional&lt;IDBKeyPath&gt;&amp; keyPath)</span>
105 {
106     ASSERT(!m_fetchedRecords.isEmpty());
107 
108     auto&amp; currentRecord = m_fetchedRecords.first();
109     if (currentRecord.completed) {
110         ASSERT(!currentRecord.errored);
111         result = { };
112         return;
113     }
114 
<span class="line-modified">115     result = { currentRecord.record.key, currentRecord.record.primaryKey, currentRecord.record.value ? *currentRecord.record.value : IDBValue(), keyPath};</span>





































116 }
117 
118 static String buildIndexStatement(const IDBKeyRangeData&amp; keyRange, IndexedDB::CursorDirection cursorDirection)
119 {
120     StringBuilder builder;
121 
<span class="line-modified">122     builder.appendLiteral(&quot;SELECT rowid, key, value FROM IndexRecords WHERE indexID = ? AND objectStoreID = ? AND key &quot;);</span>
123     if (!keyRange.lowerKey.isNull() &amp;&amp; !keyRange.lowerOpen)
124         builder.appendLiteral(&quot;&gt;=&quot;);
125     else
126         builder.append(&#39;&gt;&#39;);
127 
128     builder.appendLiteral(&quot; CAST(? AS TEXT) AND key &quot;);
129     if (!keyRange.upperKey.isNull() &amp;&amp; !keyRange.upperOpen)
130         builder.appendLiteral(&quot;&lt;=&quot;);
131     else
132         builder.append(&#39;&lt;&#39;);
133 
134     builder.appendLiteral(&quot; CAST(? AS TEXT) ORDER BY key&quot;);
135     if (cursorDirection == IndexedDB::CursorDirection::Prev || cursorDirection == IndexedDB::CursorDirection::Prevunique)
136         builder.appendLiteral(&quot; DESC&quot;);
137 
138     builder.appendLiteral(&quot;, value&quot;);
139     if (cursorDirection == IndexedDB::CursorDirection::Prev)
140         builder.appendLiteral(&quot; DESC&quot;);
141 
142     builder.append(&#39;;&#39;);
</pre>
<hr />
<pre>
200     ASSERT(m_transaction-&gt;sqliteTransaction());
201 
202     m_statement = makeUnique&lt;SQLiteStatement&gt;(m_transaction-&gt;sqliteTransaction()-&gt;database(), sql);
203 
204     if (m_statement-&gt;prepare() != SQLITE_OK) {
205         LOG_ERROR(&quot;Could not create cursor statement (prepare/id) - &#39;%s&#39;&quot;, m_transaction-&gt;sqliteTransaction()-&gt;database().lastErrorMsg());
206         return false;
207     }
208 
209     return bindArguments();
210 }
211 
212 void SQLiteIDBCursor::objectStoreRecordsChanged()
213 {
214     if (m_statementNeedsReset)
215         return;
216 
217     ASSERT(!m_fetchedRecords.isEmpty());
218 
219     m_currentKeyForUniqueness = m_fetchedRecords.first().record.key;
<span class="line-modified">220 </span>
<span class="line-modified">221     if (m_cursorDirection != IndexedDB::CursorDirection::Nextunique &amp;&amp; m_cursorDirection != IndexedDB::CursorDirection::Prevunique) {</span>
<span class="line-removed">222         if (!m_fetchedRecords.last().isTerminalRecord())</span>
<span class="line-removed">223             fetch(ShouldFetchForSameKey::Yes);</span>
<span class="line-removed">224 </span>
<span class="line-removed">225         while (m_fetchedRecords.last().record.key != m_fetchedRecords.first().record.key)</span>
<span class="line-removed">226             m_fetchedRecords.removeLast();</span>
<span class="line-removed">227     } else</span>
<span class="line-removed">228         m_fetchedRecords.clear();</span>
229 
230     // If ObjectStore or Index contents changed, we need to reset the statement and bind new parameters to it.
231     // This is to pick up any changes that might exist.
<span class="line-removed">232     // We also need to throw away any fetched records as they may no longer be valid.</span>
<span class="line-removed">233 </span>
234     m_statementNeedsReset = true;
235 
<span class="line-modified">236     if (m_cursorDirection == IndexedDB::CursorDirection::Next || m_cursorDirection == IndexedDB::CursorDirection::Nextunique) {</span>
237         m_currentLowerKey = m_currentKeyForUniqueness;
238         if (!m_keyRange.lowerOpen) {
239             m_keyRange.lowerOpen = true;
240             m_keyRange.lowerKey = m_currentLowerKey;
241             m_statement = nullptr;
242         }
243     } else {
244         m_currentUpperKey = m_currentKeyForUniqueness;
245         if (!m_keyRange.upperOpen) {
246             m_keyRange.upperOpen = true;
247             m_keyRange.upperKey = m_currentUpperKey;
248             m_statement = nullptr;
249         }
250     }






251 }
252 
253 void SQLiteIDBCursor::resetAndRebindStatement()
254 {
255     ASSERT(!m_currentLowerKey.isNull());
256     ASSERT(!m_currentUpperKey.isNull());
257     ASSERT(m_transaction-&gt;sqliteTransaction());
258     ASSERT(m_statementNeedsReset);
259 
260     m_statementNeedsReset = false;
261 
262     if (!m_statement &amp;&amp; !establishStatement()) {
263         LOG_ERROR(&quot;Unable to establish new statement for cursor iteration&quot;);
264         return;
265     }
266 
267     if (m_statement-&gt;reset() != SQLITE_OK) {
268         LOG_ERROR(&quot;Could not reset cursor statement to respond to object store changes&quot;);
269         return;
270     }
271 
272     bindArguments();
273 }
274 
275 bool SQLiteIDBCursor::bindArguments()
276 {
277     LOG(IndexedDB, &quot;Cursor is binding lower key &#39;%s&#39; and upper key &#39;%s&#39;&quot;, m_currentLowerKey.loggingString().utf8().data(), m_currentUpperKey.loggingString().utf8().data());
278 
279     int currentBindArgument = 1;
280 
281     if (m_statement-&gt;bindInt64(currentBindArgument++, m_boundID) != SQLITE_OK) {
282         LOG_ERROR(&quot;Could not bind id argument (bound ID)&quot;);
283         return false;
284     }
285 
<span class="line-removed">286     if (m_indexID != IDBIndexInfo::InvalidId &amp;&amp; m_statement-&gt;bindInt64(currentBindArgument++, m_objectStoreID) != SQLITE_OK) {</span>
<span class="line-removed">287         LOG_ERROR(&quot;Could not bind object store id argument for an index cursor&quot;);</span>
<span class="line-removed">288         return false;</span>
<span class="line-removed">289     }</span>
<span class="line-removed">290 </span>
291     RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(m_currentLowerKey);
292     if (m_statement-&gt;bindBlob(currentBindArgument++, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {
293         LOG_ERROR(&quot;Could not create cursor statement (lower key)&quot;);
294         return false;
295     }
296 
297     buffer = serializeIDBKeyData(m_currentUpperKey);
298     if (m_statement-&gt;bindBlob(currentBindArgument++, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {
299         LOG_ERROR(&quot;Could not create cursor statement (upper key)&quot;);
300         return false;
301     }
302 
303     return true;
304 }
305 
<span class="line-modified">306 bool SQLiteIDBCursor::prefetch()</span>














































307 {
<span class="line-modified">308     LOG(IndexedDB, &quot;SQLiteIDBCursor::prefetch() - Cursor already has %zu fetched records&quot;, m_fetchedRecords.size());</span>
309 
<span class="line-modified">310     if (m_fetchedRecords.isEmpty() || m_fetchedRecords.size() &gt;= prefetchLimit || m_fetchedRecords.last().isTerminalRecord())</span>
311         return false;
312 
313     m_currentKeyForUniqueness = m_fetchedRecords.last().record.key;
<span class="line-removed">314     fetch();</span>
315 
<span class="line-modified">316     return m_fetchedRecords.size() &lt; prefetchLimit;</span>
















317 }
318 
319 bool SQLiteIDBCursor::advance(uint64_t count)
320 {
321     LOG(IndexedDB, &quot;SQLiteIDBCursor::advance() - Count %&quot; PRIu64 &quot;, %zu fetched records&quot;, count, m_fetchedRecords.size());
322     ASSERT(count);
323 
324     if (!m_fetchedRecords.isEmpty() &amp;&amp; m_fetchedRecords.first().isTerminalRecord()) {
325         LOG_ERROR(&quot;Attempt to advance a completed cursor&quot;);
326         return false;
327     }
328 
329     if (!m_fetchedRecords.isEmpty())
330         m_currentKeyForUniqueness = m_fetchedRecords.last().record.key;
331 
332     // Drop already-fetched records up to `count` to see if we&#39;ve already fetched the record we&#39;re looking for.
333     bool hadCurrentRecord = !m_fetchedRecords.isEmpty();
334     for (; count &amp;&amp; !m_fetchedRecords.isEmpty(); --count) {
335         if (m_fetchedRecords.first().isTerminalRecord())
336             break;
337 


338         m_fetchedRecords.removeFirst();
339     }
340 
341     // If we still have any records left, the first record is our new current record.
342     if (!m_fetchedRecords.isEmpty())
343         return true;
344 
345     ASSERT(m_fetchedRecords.isEmpty());
346 
347     // If we started out with a current record, we burnt a count on removing it.
348     // Replace that count now.
349     if (hadCurrentRecord)
350         ++count;
351 
352     for (; count; --count) {
353         if (!m_fetchedRecords.isEmpty()) {
354             ASSERT(m_fetchedRecords.size() == 1);
355             m_currentKeyForUniqueness = m_fetchedRecords.first().record.key;



356             m_fetchedRecords.removeFirst();
357         }
358 
359         if (!fetch())
360             return false;
361 
362         ASSERT(!m_fetchedRecords.isEmpty());
363         ASSERT(!m_fetchedRecords.first().errored);
364         if (m_fetchedRecords.first().completed)
365             break;
366     }
367 
368     return true;
369 }
370 
<span class="line-modified">371 bool SQLiteIDBCursor::fetch(ShouldFetchForSameKey shouldFetchForSameKey)</span>
372 {
373     ASSERT(m_fetchedRecords.isEmpty() || !m_fetchedRecords.last().isTerminalRecord());
374 
375     m_fetchedRecords.append({ });
376 
<span class="line-modified">377     bool isUnique = m_cursorDirection == IndexedDB::CursorDirection::Nextunique || m_cursorDirection == IndexedDB::CursorDirection::Prevunique || shouldFetchForSameKey == ShouldFetchForSameKey::Yes;</span>
<span class="line-modified">378     if (!isUnique)</span>
<span class="line-modified">379         return fetchNextRecord(m_fetchedRecords.last());</span>




380 
381     while (fetchNextRecord(m_fetchedRecords.last())) {


382         if (m_currentKeyForUniqueness.compare(m_fetchedRecords.last().record.key))
383             return true;
384 
385         if (m_fetchedRecords.last().completed)
386             return false;
387 
<span class="line-modified">388         if (shouldFetchForSameKey == ShouldFetchForSameKey::Yes)</span>
<span class="line-removed">389             m_fetchedRecords.append({ });</span>
390     }
391 
392     return false;
393 }
394 
395 bool SQLiteIDBCursor::fetchNextRecord(SQLiteCursorRecord&amp; record)
396 {
<span class="line-modified">397     if (m_statementNeedsReset)</span>

398         resetAndRebindStatement();

399 
400     FetchResult result;
401     do {
402         result = internalFetchNextRecord(record);
403     } while (result == FetchResult::ShouldFetchAgain);
404 
405     return result == FetchResult::Success;
406 }
407 
408 void SQLiteIDBCursor::markAsErrored(SQLiteCursorRecord&amp; record)
409 {
410     record.record = { };
411     record.completed = true;
412     record.errored = true;
413     record.rowID = 0;
414 }
415 
416 SQLiteIDBCursor::FetchResult SQLiteIDBCursor::internalFetchNextRecord(SQLiteCursorRecord&amp; record)
417 {
418     ASSERT(m_transaction-&gt;sqliteTransaction());
419     ASSERT(m_statement);
420     ASSERT(!m_fetchedRecords.isEmpty());
421     ASSERT(!m_fetchedRecords.last().isTerminalRecord());
422 
<span class="line-modified">423     record.record.value = nullptr;</span>



424 
<span class="line-modified">425     int result = m_statement-&gt;step();</span>
<span class="line-modified">426     if (result == SQLITE_DONE) {</span>
<span class="line-modified">427         // When a cursor reaches its end, that is indicated by having undefined keys/values</span>
<span class="line-removed">428         record = { };</span>
<span class="line-removed">429         record.completed = true;</span>
430 
<span class="line-modified">431         return FetchResult::Success;</span>




432     }
433 
<span class="line-modified">434     if (result != SQLITE_ROW) {</span>
<span class="line-modified">435         LOG_ERROR(&quot;Error advancing cursor - (%i) %s&quot;, result, m_transaction-&gt;sqliteTransaction()-&gt;database().lastErrorMsg());</span>
<span class="line-modified">436         markAsErrored(record);</span>
<span class="line-modified">437         return FetchResult::Failure;</span>









438     }
439 
<span class="line-modified">440     record.rowID = m_statement-&gt;getColumnInt64(0);</span>
441     ASSERT(record.rowID);
442 
443     Vector&lt;uint8_t&gt; keyData;
<span class="line-modified">444     m_statement-&gt;getColumnBlobAsVector(1, keyData);</span>
445 
446     if (!deserializeIDBKeyData(keyData.data(), keyData.size(), record.record.key)) {
447         LOG_ERROR(&quot;Unable to deserialize key data from database while advancing cursor&quot;);
448         markAsErrored(record);
449         return FetchResult::Failure;
450     }
451 
<span class="line-modified">452     m_statement-&gt;getColumnBlobAsVector(2, keyData);</span>
453 
454     // The primaryKey of an ObjectStore cursor is the same as its key.
455     if (m_indexID == IDBIndexInfo::InvalidId) {
456         record.record.primaryKey = record.record.key;
457 
458         Vector&lt;String&gt; blobURLs, blobFilePaths;
459         auto error = m_transaction-&gt;backingStore().getBlobRecordsForObjectStoreRecord(record.rowID, blobURLs, blobFilePaths);
460         if (!error.isNull()) {
461             LOG_ERROR(&quot;Unable to fetch blob records from database while advancing cursor&quot;);
462             markAsErrored(record);
463             return FetchResult::Failure;
464         }
465 
466         if (m_cursorType == IndexedDB::CursorType::KeyAndValue)
<span class="line-modified">467             record.record.value = makeUnique&lt;IDBValue&gt;(ThreadSafeDataBuffer::create(WTFMove(keyData)), blobURLs, blobFilePaths);</span>
468     } else {
469         if (!deserializeIDBKeyData(keyData.data(), keyData.size(), record.record.primaryKey)) {
470             LOG_ERROR(&quot;Unable to deserialize value data from database while advancing index cursor&quot;);
471             markAsErrored(record);
472             return FetchResult::Failure;
473         }
474 
<span class="line-modified">475         SQLiteStatement objectStoreStatement(m_statement-&gt;database(), &quot;SELECT value FROM Records WHERE key = CAST(? AS TEXT) and objectStoreID = ?;&quot;);</span>




476 
<span class="line-modified">477         if (objectStoreStatement.prepare() != SQLITE_OK</span>
<span class="line-modified">478             || objectStoreStatement.bindBlob(1, keyData.data(), keyData.size()) != SQLITE_OK</span>
<span class="line-modified">479             || objectStoreStatement.bindInt64(2, m_objectStoreID) != SQLITE_OK) {</span>
<span class="line-modified">480             LOG_ERROR(&quot;Could not create index cursor statement into object store records (%i) &#39;%s&#39;&quot;, m_statement-&gt;database().lastError(), m_statement-&gt;database().lastErrorMsg());</span>
481             markAsErrored(record);
482             return FetchResult::Failure;
483         }
484 
<span class="line-modified">485         int result = objectStoreStatement.step();</span>
486 
487         if (result == SQLITE_ROW) {
<span class="line-modified">488             objectStoreStatement.getColumnBlobAsVector(0, keyData);</span>
<span class="line-modified">489             record.record.value = makeUnique&lt;IDBValue&gt;(ThreadSafeDataBuffer::create(WTFMove(keyData)));</span>
490         } else if (result == SQLITE_DONE) {
491             // This indicates that the record we&#39;re trying to retrieve has been removed from the object store.
492             // Skip over it.
493             return FetchResult::ShouldFetchAgain;
494         } else {
<span class="line-modified">495             LOG_ERROR(&quot;Could not step index cursor statement into object store records (%i) &#39;%s&#39;&quot;, m_statement-&gt;database().lastError(), m_statement-&gt;database().lastErrorMsg());</span>
496             markAsErrored(record);
497             return FetchResult::Failure;
498 
499         }
500     }
501 
502     return FetchResult::Success;
503 }
504 
505 bool SQLiteIDBCursor::iterate(const IDBKeyData&amp; targetKey, const IDBKeyData&amp; targetPrimaryKey)
506 {
507     ASSERT(m_transaction-&gt;sqliteTransaction());
508     ASSERT(m_statement);
509 
510     bool result = advance(1);
511     ASSERT(!m_fetchedRecords.isEmpty());
512 
513     // Iterating with no key is equivalent to advancing 1 step.
514     if (targetKey.isNull() || !result)
515         return result;
</pre>
<hr />
<pre>
542 
543             result = advance(1);
544         }
545     }
546 
547     return result;
548 }
549 
550 const IDBKeyData&amp; SQLiteIDBCursor::currentKey() const
551 {
552     ASSERT(!m_fetchedRecords.isEmpty());
553     return m_fetchedRecords.first().record.key;
554 }
555 
556 const IDBKeyData&amp; SQLiteIDBCursor::currentPrimaryKey() const
557 {
558     ASSERT(!m_fetchedRecords.isEmpty());
559     return m_fetchedRecords.first().record.primaryKey;
560 }
561 
<span class="line-modified">562 IDBValue* SQLiteIDBCursor::currentValue() const</span>
563 {
564     ASSERT(!m_fetchedRecords.isEmpty());
<span class="line-modified">565     return m_fetchedRecords.first().record.value.get();</span>
566 }
567 
568 bool SQLiteIDBCursor::didComplete() const
569 {
570     ASSERT(!m_fetchedRecords.isEmpty());
571     return m_fetchedRecords.first().completed;
572 }
573 
574 bool SQLiteIDBCursor::didError() const
575 {
576     ASSERT(!m_fetchedRecords.isEmpty());
577     return m_fetchedRecords.first().errored;
578 }
579 
580 int64_t SQLiteIDBCursor::currentRecordRowID() const
581 {
582     ASSERT(!m_fetchedRecords.isEmpty());
583     return m_fetchedRecords.first().rowID;
584 }
585 
</pre>
</td>
<td>
<hr />
<pre>
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SQLiteIDBCursor.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBCursorInfo.h&quot;
 32 #include &quot;IDBGetResult.h&quot;
 33 #include &quot;IDBSerialization.h&quot;
 34 #include &quot;Logging.h&quot;
 35 #include &quot;SQLiteIDBBackingStore.h&quot;
 36 #include &quot;SQLiteIDBTransaction.h&quot;
 37 #include &quot;SQLiteStatement.h&quot;
 38 #include &quot;SQLiteTransaction.h&quot;
 39 #include &lt;sqlite3.h&gt;
 40 #include &lt;wtf/text/StringBuilder.h&gt;
 41 
 42 namespace WebCore {
 43 namespace IDBServer {
 44 
<span class="line-modified"> 45 static const size_t prefetchLimit = 256;</span>
<span class="line-added"> 46 static const size_t prefetchSizeLimit = 1 * MB;</span>
 47 
 48 std::unique_ptr&lt;SQLiteIDBCursor&gt; SQLiteIDBCursor::maybeCreate(SQLiteIDBTransaction&amp; transaction, const IDBCursorInfo&amp; info)
 49 {
 50     auto cursor = makeUnique&lt;SQLiteIDBCursor&gt;(transaction, info);
 51 
 52     if (!cursor-&gt;establishStatement())
 53         return nullptr;
 54 
 55     if (!cursor-&gt;advance(1))
 56         return nullptr;
 57 
 58     return cursor;
 59 }
 60 
 61 std::unique_ptr&lt;SQLiteIDBCursor&gt; SQLiteIDBCursor::maybeCreateBackingStoreCursor(SQLiteIDBTransaction&amp; transaction, const uint64_t objectStoreID, const uint64_t indexID, const IDBKeyRangeData&amp; range)
 62 {
 63     auto cursor = makeUnique&lt;SQLiteIDBCursor&gt;(transaction, objectStoreID, indexID, range);
 64 
 65     if (!cursor-&gt;establishStatement())
 66         return nullptr;
</pre>
<hr />
<pre>
 85 
 86 SQLiteIDBCursor::SQLiteIDBCursor(SQLiteIDBTransaction&amp; transaction, const uint64_t objectStoreID, const uint64_t indexID, const IDBKeyRangeData&amp; range)
 87     : m_transaction(&amp;transaction)
 88     , m_cursorIdentifier(transaction.transactionIdentifier())
 89     , m_objectStoreID(objectStoreID)
 90     , m_indexID(indexID ? indexID : IDBIndexInfo::InvalidId)
 91     , m_cursorDirection(IndexedDB::CursorDirection::Next)
 92     , m_cursorType(IndexedDB::CursorType::KeyAndValue)
 93     , m_keyRange(range)
 94     , m_backingStoreCursor(true)
 95 {
 96     ASSERT(m_objectStoreID);
 97 }
 98 
 99 SQLiteIDBCursor::~SQLiteIDBCursor()
100 {
101     if (m_backingStoreCursor)
102         m_transaction-&gt;closeCursor(*this);
103 }
104 
<span class="line-modified">105 void SQLiteIDBCursor::currentData(IDBGetResult&amp; result, const Optional&lt;IDBKeyPath&gt;&amp; keyPath, ShouldIncludePrefetchedRecords shouldIncludePrefetchedRecords)</span>
106 {
107     ASSERT(!m_fetchedRecords.isEmpty());
108 
109     auto&amp; currentRecord = m_fetchedRecords.first();
110     if (currentRecord.completed) {
111         ASSERT(!currentRecord.errored);
112         result = { };
113         return;
114     }
115 
<span class="line-modified">116     if (shouldIncludePrefetchedRecords == ShouldIncludePrefetchedRecords::No) {</span>
<span class="line-added">117         result = { currentRecord.record.key, currentRecord.record.primaryKey, IDBValue(currentRecord.record.value), keyPath };</span>
<span class="line-added">118         return;</span>
<span class="line-added">119     }</span>
<span class="line-added">120 </span>
<span class="line-added">121     Vector&lt;IDBCursorRecord&gt; prefetchedRecords;</span>
<span class="line-added">122     prefetchedRecords.reserveCapacity(m_fetchedRecords.size());</span>
<span class="line-added">123     for (auto&amp; record : m_fetchedRecords) {</span>
<span class="line-added">124         if (record.isTerminalRecord())</span>
<span class="line-added">125             break;</span>
<span class="line-added">126 </span>
<span class="line-added">127         prefetchedRecords.append(record.record);</span>
<span class="line-added">128     }</span>
<span class="line-added">129 </span>
<span class="line-added">130     // First record will be returned as current record.</span>
<span class="line-added">131     if (!prefetchedRecords.isEmpty())</span>
<span class="line-added">132         prefetchedRecords.remove(0);</span>
<span class="line-added">133 </span>
<span class="line-added">134     result = { currentRecord.record.key, currentRecord.record.primaryKey, IDBValue(currentRecord.record.value), keyPath, WTFMove(prefetchedRecords) };</span>
<span class="line-added">135 }</span>
<span class="line-added">136 </span>
<span class="line-added">137 static String buildPreIndexStatement(bool isDirectionNext)</span>
<span class="line-added">138 {</span>
<span class="line-added">139     StringBuilder builder;</span>
<span class="line-added">140 </span>
<span class="line-added">141     builder.appendLiteral(&quot;SELECT rowid, key, value FROM IndexRecords WHERE indexID = ? AND key = CAST(? AS TEXT) AND value &quot;);</span>
<span class="line-added">142     if (isDirectionNext)</span>
<span class="line-added">143         builder.append(&#39;&gt;&#39;);</span>
<span class="line-added">144     else</span>
<span class="line-added">145         builder.append(&#39;&lt;&#39;);</span>
<span class="line-added">146 </span>
<span class="line-added">147     builder.appendLiteral(&quot; CAST(? AS TEXT) ORDER BY value&quot;);</span>
<span class="line-added">148     if (!isDirectionNext)</span>
<span class="line-added">149         builder.appendLiteral(&quot; DESC&quot;);</span>
<span class="line-added">150 </span>
<span class="line-added">151     builder.append(&#39;;&#39;);</span>
<span class="line-added">152 </span>
<span class="line-added">153     return builder.toString();</span>
154 }
155 
156 static String buildIndexStatement(const IDBKeyRangeData&amp; keyRange, IndexedDB::CursorDirection cursorDirection)
157 {
158     StringBuilder builder;
159 
<span class="line-modified">160     builder.appendLiteral(&quot;SELECT rowid, key, value FROM IndexRecords WHERE indexID = ? AND key &quot;);</span>
161     if (!keyRange.lowerKey.isNull() &amp;&amp; !keyRange.lowerOpen)
162         builder.appendLiteral(&quot;&gt;=&quot;);
163     else
164         builder.append(&#39;&gt;&#39;);
165 
166     builder.appendLiteral(&quot; CAST(? AS TEXT) AND key &quot;);
167     if (!keyRange.upperKey.isNull() &amp;&amp; !keyRange.upperOpen)
168         builder.appendLiteral(&quot;&lt;=&quot;);
169     else
170         builder.append(&#39;&lt;&#39;);
171 
172     builder.appendLiteral(&quot; CAST(? AS TEXT) ORDER BY key&quot;);
173     if (cursorDirection == IndexedDB::CursorDirection::Prev || cursorDirection == IndexedDB::CursorDirection::Prevunique)
174         builder.appendLiteral(&quot; DESC&quot;);
175 
176     builder.appendLiteral(&quot;, value&quot;);
177     if (cursorDirection == IndexedDB::CursorDirection::Prev)
178         builder.appendLiteral(&quot; DESC&quot;);
179 
180     builder.append(&#39;;&#39;);
</pre>
<hr />
<pre>
238     ASSERT(m_transaction-&gt;sqliteTransaction());
239 
240     m_statement = makeUnique&lt;SQLiteStatement&gt;(m_transaction-&gt;sqliteTransaction()-&gt;database(), sql);
241 
242     if (m_statement-&gt;prepare() != SQLITE_OK) {
243         LOG_ERROR(&quot;Could not create cursor statement (prepare/id) - &#39;%s&#39;&quot;, m_transaction-&gt;sqliteTransaction()-&gt;database().lastErrorMsg());
244         return false;
245     }
246 
247     return bindArguments();
248 }
249 
250 void SQLiteIDBCursor::objectStoreRecordsChanged()
251 {
252     if (m_statementNeedsReset)
253         return;
254 
255     ASSERT(!m_fetchedRecords.isEmpty());
256 
257     m_currentKeyForUniqueness = m_fetchedRecords.first().record.key;
<span class="line-modified">258     if (m_indexID != IDBIndexInfo::InvalidId)</span>
<span class="line-modified">259         m_currentIndexRecordValue = m_fetchedRecords.first().record.primaryKey;</span>







260 
261     // If ObjectStore or Index contents changed, we need to reset the statement and bind new parameters to it.
262     // This is to pick up any changes that might exist.


263     m_statementNeedsReset = true;
264 
<span class="line-modified">265     if (isDirectionNext()) {</span>
266         m_currentLowerKey = m_currentKeyForUniqueness;
267         if (!m_keyRange.lowerOpen) {
268             m_keyRange.lowerOpen = true;
269             m_keyRange.lowerKey = m_currentLowerKey;
270             m_statement = nullptr;
271         }
272     } else {
273         m_currentUpperKey = m_currentKeyForUniqueness;
274         if (!m_keyRange.upperOpen) {
275             m_keyRange.upperOpen = true;
276             m_keyRange.upperKey = m_currentUpperKey;
277             m_statement = nullptr;
278         }
279     }
<span class="line-added">280 </span>
<span class="line-added">281     // We also need to throw away any fetched records as they may no longer be valid.</span>
<span class="line-added">282     m_fetchedRecords.clear();</span>
<span class="line-added">283     m_fetchedRecordsSize = 0;</span>
<span class="line-added">284 </span>
<span class="line-added">285     m_prefetchCount = 0;</span>
286 }
287 
288 void SQLiteIDBCursor::resetAndRebindStatement()
289 {
290     ASSERT(!m_currentLowerKey.isNull());
291     ASSERT(!m_currentUpperKey.isNull());
292     ASSERT(m_transaction-&gt;sqliteTransaction());
293     ASSERT(m_statementNeedsReset);
294 
295     m_statementNeedsReset = false;
296 
297     if (!m_statement &amp;&amp; !establishStatement()) {
298         LOG_ERROR(&quot;Unable to establish new statement for cursor iteration&quot;);
299         return;
300     }
301 
302     if (m_statement-&gt;reset() != SQLITE_OK) {
303         LOG_ERROR(&quot;Could not reset cursor statement to respond to object store changes&quot;);
304         return;
305     }
306 
307     bindArguments();
308 }
309 
310 bool SQLiteIDBCursor::bindArguments()
311 {
312     LOG(IndexedDB, &quot;Cursor is binding lower key &#39;%s&#39; and upper key &#39;%s&#39;&quot;, m_currentLowerKey.loggingString().utf8().data(), m_currentUpperKey.loggingString().utf8().data());
313 
314     int currentBindArgument = 1;
315 
316     if (m_statement-&gt;bindInt64(currentBindArgument++, m_boundID) != SQLITE_OK) {
317         LOG_ERROR(&quot;Could not bind id argument (bound ID)&quot;);
318         return false;
319     }
320 





321     RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(m_currentLowerKey);
322     if (m_statement-&gt;bindBlob(currentBindArgument++, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {
323         LOG_ERROR(&quot;Could not create cursor statement (lower key)&quot;);
324         return false;
325     }
326 
327     buffer = serializeIDBKeyData(m_currentUpperKey);
328     if (m_statement-&gt;bindBlob(currentBindArgument++, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {
329         LOG_ERROR(&quot;Could not create cursor statement (upper key)&quot;);
330         return false;
331     }
332 
333     return true;
334 }
335 
<span class="line-modified">336 bool SQLiteIDBCursor::resetAndRebindPreIndexStatementIfNecessary()</span>
<span class="line-added">337 {</span>
<span class="line-added">338     if (m_indexID == IDBIndexInfo::InvalidId)</span>
<span class="line-added">339         return true;</span>
<span class="line-added">340 </span>
<span class="line-added">341     if (m_currentIndexRecordValue.isNull())</span>
<span class="line-added">342         return true;</span>
<span class="line-added">343 </span>
<span class="line-added">344     auto&amp; database = m_transaction-&gt;sqliteTransaction()-&gt;database();</span>
<span class="line-added">345     if (!m_preIndexStatement) {</span>
<span class="line-added">346         m_preIndexStatement = makeUnique&lt;SQLiteStatement&gt;(database, buildPreIndexStatement(isDirectionNext()));</span>
<span class="line-added">347 </span>
<span class="line-added">348         if (m_preIndexStatement-&gt;prepare() != SQLITE_OK) {</span>
<span class="line-added">349             LOG_ERROR(&quot;Could not prepare pre statement - &#39;%s&#39;&quot;, database.lastErrorMsg());</span>
<span class="line-added">350             return false;</span>
<span class="line-added">351         }</span>
<span class="line-added">352     }</span>
<span class="line-added">353 </span>
<span class="line-added">354     if (m_preIndexStatement-&gt;reset() != SQLITE_OK) {</span>
<span class="line-added">355         LOG_ERROR(&quot;Could not reset pre statement - &#39;%s&#39;&quot;, database.lastErrorMsg());</span>
<span class="line-added">356         return false;</span>
<span class="line-added">357     }</span>
<span class="line-added">358 </span>
<span class="line-added">359     auto key = isDirectionNext() ? m_currentLowerKey : m_currentUpperKey;</span>
<span class="line-added">360     int currentBindArgument = 1;</span>
<span class="line-added">361 </span>
<span class="line-added">362     if (m_preIndexStatement-&gt;bindInt64(currentBindArgument++, m_boundID) != SQLITE_OK) {</span>
<span class="line-added">363         LOG_ERROR(&quot;Could not bind id argument to pre statement (bound ID)&quot;);</span>
<span class="line-added">364         return false;</span>
<span class="line-added">365     }</span>
<span class="line-added">366 </span>
<span class="line-added">367     RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(key);</span>
<span class="line-added">368     if (m_preIndexStatement-&gt;bindBlob(currentBindArgument++, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {</span>
<span class="line-added">369         LOG_ERROR(&quot;Could not bind id argument to pre statement (key)&quot;);</span>
<span class="line-added">370         return false;</span>
<span class="line-added">371     }</span>
<span class="line-added">372 </span>
<span class="line-added">373     buffer = serializeIDBKeyData(m_currentIndexRecordValue);</span>
<span class="line-added">374     if (m_preIndexStatement-&gt;bindBlob(currentBindArgument++, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {</span>
<span class="line-added">375         LOG_ERROR(&quot;Could not bind id argument to pre statement (value)&quot;);</span>
<span class="line-added">376         return false;</span>
<span class="line-added">377     }</span>
<span class="line-added">378 </span>
<span class="line-added">379     return true;</span>
<span class="line-added">380 }</span>
<span class="line-added">381 </span>
<span class="line-added">382 bool SQLiteIDBCursor::prefetchOneRecord()</span>
383 {
<span class="line-modified">384     LOG(IndexedDB, &quot;SQLiteIDBCursor::prefetchOneRecord() - Cursor already has %zu fetched records&quot;, m_fetchedRecords.size());</span>
385 
<span class="line-modified">386     if (m_fetchedRecordsSize &gt;= prefetchSizeLimit || m_fetchedRecords.isEmpty() || m_fetchedRecords.size() &gt;= prefetchLimit || m_fetchedRecords.last().isTerminalRecord())</span>
387         return false;
388 
389     m_currentKeyForUniqueness = m_fetchedRecords.last().record.key;

390 
<span class="line-modified">391     return fetch() &amp;&amp; m_fetchedRecords.size() &lt; prefetchLimit &amp;&amp; m_fetchedRecordsSize &lt; prefetchSizeLimit;</span>
<span class="line-added">392 }</span>
<span class="line-added">393 </span>
<span class="line-added">394 void SQLiteIDBCursor::increaseCountToPrefetch()</span>
<span class="line-added">395 {</span>
<span class="line-added">396     m_prefetchCount = m_prefetchCount ? m_prefetchCount * 2 : 1;</span>
<span class="line-added">397 }</span>
<span class="line-added">398 </span>
<span class="line-added">399 bool SQLiteIDBCursor::prefetch()</span>
<span class="line-added">400 {</span>
<span class="line-added">401     for (unsigned i = 0; i &lt; m_prefetchCount; ++i) {</span>
<span class="line-added">402         if (!prefetchOneRecord())</span>
<span class="line-added">403             return false;</span>
<span class="line-added">404     }</span>
<span class="line-added">405 </span>
<span class="line-added">406     increaseCountToPrefetch();</span>
<span class="line-added">407     return true;</span>
408 }
409 
410 bool SQLiteIDBCursor::advance(uint64_t count)
411 {
412     LOG(IndexedDB, &quot;SQLiteIDBCursor::advance() - Count %&quot; PRIu64 &quot;, %zu fetched records&quot;, count, m_fetchedRecords.size());
413     ASSERT(count);
414 
415     if (!m_fetchedRecords.isEmpty() &amp;&amp; m_fetchedRecords.first().isTerminalRecord()) {
416         LOG_ERROR(&quot;Attempt to advance a completed cursor&quot;);
417         return false;
418     }
419 
420     if (!m_fetchedRecords.isEmpty())
421         m_currentKeyForUniqueness = m_fetchedRecords.last().record.key;
422 
423     // Drop already-fetched records up to `count` to see if we&#39;ve already fetched the record we&#39;re looking for.
424     bool hadCurrentRecord = !m_fetchedRecords.isEmpty();
425     for (; count &amp;&amp; !m_fetchedRecords.isEmpty(); --count) {
426         if (m_fetchedRecords.first().isTerminalRecord())
427             break;
428 
<span class="line-added">429         ASSERT(m_fetchedRecordsSize &gt;= m_fetchedRecords.first().record.size());</span>
<span class="line-added">430         m_fetchedRecordsSize -= m_fetchedRecords.first().record.size();</span>
431         m_fetchedRecords.removeFirst();
432     }
433 
434     // If we still have any records left, the first record is our new current record.
435     if (!m_fetchedRecords.isEmpty())
436         return true;
437 
438     ASSERT(m_fetchedRecords.isEmpty());
439 
440     // If we started out with a current record, we burnt a count on removing it.
441     // Replace that count now.
442     if (hadCurrentRecord)
443         ++count;
444 
445     for (; count; --count) {
446         if (!m_fetchedRecords.isEmpty()) {
447             ASSERT(m_fetchedRecords.size() == 1);
448             m_currentKeyForUniqueness = m_fetchedRecords.first().record.key;
<span class="line-added">449 </span>
<span class="line-added">450             ASSERT(m_fetchedRecordsSize &gt;= m_fetchedRecords.first().record.size());</span>
<span class="line-added">451             m_fetchedRecordsSize -= m_fetchedRecords.first().record.size();</span>
452             m_fetchedRecords.removeFirst();
453         }
454 
455         if (!fetch())
456             return false;
457 
458         ASSERT(!m_fetchedRecords.isEmpty());
459         ASSERT(!m_fetchedRecords.first().errored);
460         if (m_fetchedRecords.first().completed)
461             break;
462     }
463 
464     return true;
465 }
466 
<span class="line-modified">467 bool SQLiteIDBCursor::fetch()</span>
468 {
469     ASSERT(m_fetchedRecords.isEmpty() || !m_fetchedRecords.last().isTerminalRecord());
470 
471     m_fetchedRecords.append({ });
472 
<span class="line-modified">473     bool isUnique = m_cursorDirection == IndexedDB::CursorDirection::Nextunique || m_cursorDirection == IndexedDB::CursorDirection::Prevunique;</span>
<span class="line-modified">474     if (!isUnique) {</span>
<span class="line-modified">475         bool fetchSucceeded = fetchNextRecord(m_fetchedRecords.last());</span>
<span class="line-added">476         if (fetchSucceeded)</span>
<span class="line-added">477             m_fetchedRecordsSize += m_fetchedRecords.last().record.size();</span>
<span class="line-added">478         return fetchSucceeded;</span>
<span class="line-added">479     }</span>
480 
481     while (fetchNextRecord(m_fetchedRecords.last())) {
<span class="line-added">482         m_fetchedRecordsSize += m_fetchedRecords.last().record.size();</span>
<span class="line-added">483 </span>
484         if (m_currentKeyForUniqueness.compare(m_fetchedRecords.last().record.key))
485             return true;
486 
487         if (m_fetchedRecords.last().completed)
488             return false;
489 
<span class="line-modified">490         m_fetchedRecordsSize -= m_fetchedRecords.last().record.size();</span>

491     }
492 
493     return false;
494 }
495 
496 bool SQLiteIDBCursor::fetchNextRecord(SQLiteCursorRecord&amp; record)
497 {
<span class="line-modified">498     if (m_statementNeedsReset) {</span>
<span class="line-added">499         resetAndRebindPreIndexStatementIfNecessary();</span>
500         resetAndRebindStatement();
<span class="line-added">501     }</span>
502 
503     FetchResult result;
504     do {
505         result = internalFetchNextRecord(record);
506     } while (result == FetchResult::ShouldFetchAgain);
507 
508     return result == FetchResult::Success;
509 }
510 
511 void SQLiteIDBCursor::markAsErrored(SQLiteCursorRecord&amp; record)
512 {
513     record.record = { };
514     record.completed = true;
515     record.errored = true;
516     record.rowID = 0;
517 }
518 
519 SQLiteIDBCursor::FetchResult SQLiteIDBCursor::internalFetchNextRecord(SQLiteCursorRecord&amp; record)
520 {
521     ASSERT(m_transaction-&gt;sqliteTransaction());
522     ASSERT(m_statement);
523     ASSERT(!m_fetchedRecords.isEmpty());
524     ASSERT(!m_fetchedRecords.last().isTerminalRecord());
525 
<span class="line-modified">526     record.record.value = { };</span>
<span class="line-added">527 </span>
<span class="line-added">528     auto&amp; database = m_transaction-&gt;sqliteTransaction()-&gt;database();</span>
<span class="line-added">529     SQLiteStatement* statement = nullptr;</span>
530 
<span class="line-modified">531     int result;</span>
<span class="line-modified">532     if (m_preIndexStatement) {</span>
<span class="line-modified">533         ASSERT(m_indexID != IDBIndexInfo::InvalidId);</span>


534 
<span class="line-modified">535         result = m_preIndexStatement-&gt;step();</span>
<span class="line-added">536         if (result == SQLITE_ROW)</span>
<span class="line-added">537             statement = m_preIndexStatement.get();</span>
<span class="line-added">538         else if (result != SQLITE_DONE)</span>
<span class="line-added">539             LOG_ERROR(&quot;Error advancing with pre statement - (%i) %s&quot;, result, database.lastErrorMsg());</span>
540     }
541 
<span class="line-modified">542     if (!statement) {</span>
<span class="line-modified">543         result = m_statement-&gt;step();</span>
<span class="line-modified">544         if (result == SQLITE_DONE) {</span>
<span class="line-modified">545             record = { };</span>
<span class="line-added">546             record.completed = true;</span>
<span class="line-added">547             return FetchResult::Success;</span>
<span class="line-added">548         }</span>
<span class="line-added">549         if (result != SQLITE_ROW) {</span>
<span class="line-added">550             LOG_ERROR(&quot;Error advancing cursor - (%i) %s&quot;, result, database.lastErrorMsg());</span>
<span class="line-added">551             markAsErrored(record);</span>
<span class="line-added">552             return FetchResult::Failure;</span>
<span class="line-added">553         }</span>
<span class="line-added">554         statement = m_statement.get();</span>
555     }
556 
<span class="line-modified">557     record.rowID = statement-&gt;getColumnInt64(0);</span>
558     ASSERT(record.rowID);
559 
560     Vector&lt;uint8_t&gt; keyData;
<span class="line-modified">561     statement-&gt;getColumnBlobAsVector(1, keyData);</span>
562 
563     if (!deserializeIDBKeyData(keyData.data(), keyData.size(), record.record.key)) {
564         LOG_ERROR(&quot;Unable to deserialize key data from database while advancing cursor&quot;);
565         markAsErrored(record);
566         return FetchResult::Failure;
567     }
568 
<span class="line-modified">569     statement-&gt;getColumnBlobAsVector(2, keyData);</span>
570 
571     // The primaryKey of an ObjectStore cursor is the same as its key.
572     if (m_indexID == IDBIndexInfo::InvalidId) {
573         record.record.primaryKey = record.record.key;
574 
575         Vector&lt;String&gt; blobURLs, blobFilePaths;
576         auto error = m_transaction-&gt;backingStore().getBlobRecordsForObjectStoreRecord(record.rowID, blobURLs, blobFilePaths);
577         if (!error.isNull()) {
578             LOG_ERROR(&quot;Unable to fetch blob records from database while advancing cursor&quot;);
579             markAsErrored(record);
580             return FetchResult::Failure;
581         }
582 
583         if (m_cursorType == IndexedDB::CursorType::KeyAndValue)
<span class="line-modified">584             record.record.value = { ThreadSafeDataBuffer::create(WTFMove(keyData)), blobURLs, blobFilePaths };</span>
585     } else {
586         if (!deserializeIDBKeyData(keyData.data(), keyData.size(), record.record.primaryKey)) {
587             LOG_ERROR(&quot;Unable to deserialize value data from database while advancing index cursor&quot;);
588             markAsErrored(record);
589             return FetchResult::Failure;
590         }
591 
<span class="line-modified">592         if (!m_cachedObjectStoreStatement || m_cachedObjectStoreStatement-&gt;reset() != SQLITE_OK) {</span>
<span class="line-added">593             m_cachedObjectStoreStatement = makeUnique&lt;SQLiteStatement&gt;(database, &quot;SELECT value FROM Records WHERE key = CAST(? AS TEXT) and objectStoreID = ?;&quot;);</span>
<span class="line-added">594             if (m_cachedObjectStoreStatement-&gt;prepare() != SQLITE_OK)</span>
<span class="line-added">595                 m_cachedObjectStoreStatement = nullptr;</span>
<span class="line-added">596         }</span>
597 
<span class="line-modified">598         if (!m_cachedObjectStoreStatement</span>
<span class="line-modified">599             || m_cachedObjectStoreStatement-&gt;bindBlob(1, keyData.data(), keyData.size()) != SQLITE_OK</span>
<span class="line-modified">600             || m_cachedObjectStoreStatement-&gt;bindInt64(2, m_objectStoreID) != SQLITE_OK) {</span>
<span class="line-modified">601             LOG_ERROR(&quot;Could not create index cursor statement into object store records (%i) &#39;%s&#39;&quot;, database.lastError(), database.lastErrorMsg());</span>
602             markAsErrored(record);
603             return FetchResult::Failure;
604         }
605 
<span class="line-modified">606         int result = m_cachedObjectStoreStatement-&gt;step();</span>
607 
608         if (result == SQLITE_ROW) {
<span class="line-modified">609             m_cachedObjectStoreStatement-&gt;getColumnBlobAsVector(0, keyData);</span>
<span class="line-modified">610             record.record.value = { ThreadSafeDataBuffer::create(WTFMove(keyData)) };</span>
611         } else if (result == SQLITE_DONE) {
612             // This indicates that the record we&#39;re trying to retrieve has been removed from the object store.
613             // Skip over it.
614             return FetchResult::ShouldFetchAgain;
615         } else {
<span class="line-modified">616             LOG_ERROR(&quot;Could not step index cursor statement into object store records (%i) &#39;%s&#39;&quot;, database.lastError(), database.lastErrorMsg());</span>
617             markAsErrored(record);
618             return FetchResult::Failure;
619 
620         }
621     }
622 
623     return FetchResult::Success;
624 }
625 
626 bool SQLiteIDBCursor::iterate(const IDBKeyData&amp; targetKey, const IDBKeyData&amp; targetPrimaryKey)
627 {
628     ASSERT(m_transaction-&gt;sqliteTransaction());
629     ASSERT(m_statement);
630 
631     bool result = advance(1);
632     ASSERT(!m_fetchedRecords.isEmpty());
633 
634     // Iterating with no key is equivalent to advancing 1 step.
635     if (targetKey.isNull() || !result)
636         return result;
</pre>
<hr />
<pre>
663 
664             result = advance(1);
665         }
666     }
667 
668     return result;
669 }
670 
671 const IDBKeyData&amp; SQLiteIDBCursor::currentKey() const
672 {
673     ASSERT(!m_fetchedRecords.isEmpty());
674     return m_fetchedRecords.first().record.key;
675 }
676 
677 const IDBKeyData&amp; SQLiteIDBCursor::currentPrimaryKey() const
678 {
679     ASSERT(!m_fetchedRecords.isEmpty());
680     return m_fetchedRecords.first().record.primaryKey;
681 }
682 
<span class="line-modified">683 const IDBValue&amp; SQLiteIDBCursor::currentValue() const</span>
684 {
685     ASSERT(!m_fetchedRecords.isEmpty());
<span class="line-modified">686     return m_fetchedRecords.first().record.value;</span>
687 }
688 
689 bool SQLiteIDBCursor::didComplete() const
690 {
691     ASSERT(!m_fetchedRecords.isEmpty());
692     return m_fetchedRecords.first().completed;
693 }
694 
695 bool SQLiteIDBCursor::didError() const
696 {
697     ASSERT(!m_fetchedRecords.isEmpty());
698     return m_fetchedRecords.first().errored;
699 }
700 
701 int64_t SQLiteIDBCursor::currentRecordRowID() const
702 {
703     ASSERT(!m_fetchedRecords.isEmpty());
704     return m_fetchedRecords.first().rowID;
705 }
706 
</pre>
</td>
</tr>
</table>
<center><a href="SQLiteIDBBackingStore.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteIDBCursor.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
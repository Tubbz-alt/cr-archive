<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeDumper.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeBasicBlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeDumper.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeDumper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 24  * THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;BytecodeDumper.h&quot;
 29 
 30 #include &quot;ArithProfile.h&quot;


 31 #include &quot;BytecodeStructs.h&quot;
 32 #include &quot;CallLinkStatus.h&quot;
 33 #include &quot;CodeBlock.h&quot;
 34 #include &quot;Error.h&quot;
 35 #include &quot;HeapInlines.h&quot;
 36 #include &quot;InterpreterInlines.h&quot;
 37 #include &quot;PolymorphicAccess.h&quot;
 38 #include &quot;PutByIdFlags.h&quot;
 39 #include &quot;StructureInlines.h&quot;
 40 #include &quot;ToThisStatus.h&quot;
<span class="line-modified"> 41 #include &quot;UnlinkedCodeBlock.h&quot;</span>
 42 #include &quot;UnlinkedMetadataTableInlines.h&quot;





 43 
 44 namespace JSC {
 45 
<span class="line-modified"> 46 template&lt;class Block&gt;</span>
<span class="line-removed"> 47 VM&amp; BytecodeDumper&lt;Block&gt;::vm() const</span>
 48 {
<span class="line-modified"> 49     return block()-&gt;vm();</span>
 50 }
 51 
<span class="line-modified"> 52 template&lt;class Block&gt;</span>
<span class="line-removed"> 53 const Identifier&amp; BytecodeDumper&lt;Block&gt;::identifier(int index) const</span>
 54 {
<span class="line-modified"> 55     return block()-&gt;identifier(index);</span>

 56 }
 57 
<span class="line-modified"> 58 static ALWAYS_INLINE bool isConstantRegisterIndex(int index)</span>
 59 {
<span class="line-modified"> 60     return index &gt;= FirstConstantRegisterIndex;</span>










 61 }
 62 






 63 template&lt;class Block&gt;
<span class="line-modified"> 64 CString BytecodeDumper&lt;Block&gt;::registerName(int r) const</span>
 65 {
<span class="line-modified"> 66     if (isConstantRegisterIndex(r))</span>
 67         return constantName(r);
 68 
<span class="line-modified"> 69     return toCString(VirtualRegister(r));</span>
 70 }
 71 
<span class="line-modified"> 72 template&lt;class Block&gt;</span>
<span class="line-modified"> 73 CString BytecodeDumper&lt;Block&gt;::constantName(int index) const</span>
 74 {
<span class="line-modified"> 75     JSValue value = block()-&gt;getConstant(index);</span>
<span class="line-removed"> 76     return toCString(value, &quot;(&quot;, VirtualRegister(index), &quot;)&quot;);</span>
 77 }
 78 
 79 template&lt;class Block&gt;
<span class="line-modified"> 80 void BytecodeDumper&lt;Block&gt;::printLocationAndOp(InstructionStream::Offset location, const char* op)</span>
 81 {
<span class="line-modified"> 82     m_currentLocation = location;</span>
<span class="line-modified"> 83     m_out.printf(&quot;[%4u] %-18s &quot;, location, op);</span>
 84 }
 85 
 86 template&lt;class Block&gt;
 87 void BytecodeDumper&lt;Block&gt;::dumpBytecode(const InstructionStream::Ref&amp; it, const ICStatusMap&amp;)
 88 {
 89     ::JSC::dumpBytecode(this, it.offset(), it.ptr());
<span class="line-modified"> 90     m_out.print(&quot;\n&quot;);</span>
 91 }
 92 
 93 template&lt;class Block&gt;
 94 void BytecodeDumper&lt;Block&gt;::dumpBytecode(Block* block, PrintStream&amp; out, const InstructionStream::Ref&amp; it, const ICStatusMap&amp; statusMap)
 95 {
 96     BytecodeDumper dumper(block, out);
 97     dumper.dumpBytecode(it, statusMap);
 98 }
 99 
100 template&lt;class Block&gt;
<span class="line-modified">101 void BytecodeDumper&lt;Block&gt;::dumpIdentifiers()</span>
102 {
<span class="line-modified">103     if (size_t count = block()-&gt;numberOfIdentifiers()) {</span>
<span class="line-modified">104         m_out.printf(&quot;\nIdentifiers:\n&quot;);</span>












105         size_t i = 0;
106         do {
<span class="line-modified">107             m_out.print(&quot;  id&quot;, static_cast&lt;unsigned&gt;(i), &quot; = &quot;, identifier(i), &quot;\n&quot;);</span>
108             ++i;
109         } while (i != count);
110     }
111 }
112 
113 template&lt;class Block&gt;
<span class="line-modified">114 void BytecodeDumper&lt;Block&gt;::dumpConstants()</span>
115 {
<span class="line-modified">116     if (!block()-&gt;constantRegisters().isEmpty()) {</span>
<span class="line-modified">117         m_out.printf(&quot;\nConstants:\n&quot;);</span>
118         size_t i = 0;
<span class="line-modified">119         for (const auto&amp; constant : block()-&gt;constantRegisters()) {</span>
120             const char* sourceCodeRepresentationDescription = nullptr;
<span class="line-modified">121             switch (block()-&gt;constantsSourceCodeRepresentation()[i]) {</span>
122             case SourceCodeRepresentation::Double:
123                 sourceCodeRepresentationDescription = &quot;: in source as double&quot;;
124                 break;
125             case SourceCodeRepresentation::Integer:
126                 sourceCodeRepresentationDescription = &quot;: in source as integer&quot;;
127                 break;
128             case SourceCodeRepresentation::Other:
129                 sourceCodeRepresentationDescription = &quot;&quot;;
130                 break;



131             }
<span class="line-modified">132             m_out.printf(&quot;   k%u = %s%s\n&quot;, static_cast&lt;unsigned&gt;(i), toCString(constant.get()).data(), sourceCodeRepresentationDescription);</span>
133             ++i;
134         }
135     }
136 }
137 
138 template&lt;class Block&gt;
<span class="line-modified">139 void BytecodeDumper&lt;Block&gt;::dumpExceptionHandlers()</span>
140 {
<span class="line-modified">141     if (unsigned count = block()-&gt;numberOfExceptionHandlers()) {</span>
<span class="line-modified">142         m_out.printf(&quot;\nException Handlers:\n&quot;);</span>
143         unsigned i = 0;
144         do {
<span class="line-modified">145             const auto&amp; handler = block()-&gt;exceptionHandler(i);</span>
<span class="line-modified">146             m_out.printf(&quot;\t %d: { start: [%4d] end: [%4d] target: [%4d] } %s\n&quot;, i + 1, handler.start, handler.end, handler.target, handler.typeName());</span>
147             ++i;
148         } while (i &lt; count);
149     }
150 }
151 
152 template&lt;class Block&gt;
<span class="line-modified">153 void BytecodeDumper&lt;Block&gt;::dumpSwitchJumpTables()</span>
154 {
<span class="line-modified">155     if (unsigned count = block()-&gt;numberOfSwitchJumpTables()) {</span>
<span class="line-modified">156         m_out.printf(&quot;Switch Jump Tables:\n&quot;);</span>
157         unsigned i = 0;
158         do {
<span class="line-modified">159             m_out.printf(&quot;  %1d = {\n&quot;, i);</span>
<span class="line-modified">160             const auto&amp; switchJumpTable = block()-&gt;switchJumpTable(i);</span>
161             int entry = 0;
162             auto end = switchJumpTable.branchOffsets.end();
163             for (auto iter = switchJumpTable.branchOffsets.begin(); iter != end; ++iter, ++entry) {
164                 if (!*iter)
165                     continue;
<span class="line-modified">166                 m_out.printf(&quot;\t\t%4d =&gt; %04d\n&quot;, entry + switchJumpTable.min, *iter);</span>
167             }
<span class="line-modified">168             m_out.printf(&quot;      }\n&quot;);</span>
169             ++i;
170         } while (i &lt; count);
171     }
172 }
173 
174 template&lt;class Block&gt;
<span class="line-modified">175 void BytecodeDumper&lt;Block&gt;::dumpStringSwitchJumpTables()</span>
176 {
<span class="line-modified">177     if (unsigned count = block()-&gt;numberOfStringSwitchJumpTables()) {</span>
<span class="line-modified">178         m_out.printf(&quot;\nString Switch Jump Tables:\n&quot;);</span>
179         unsigned i = 0;
180         do {
<span class="line-modified">181             m_out.printf(&quot;  %1d = {\n&quot;, i);</span>
<span class="line-modified">182             const auto&amp; stringSwitchJumpTable = block()-&gt;stringSwitchJumpTable(i);</span>
183             auto end = stringSwitchJumpTable.offsetTable.end();
184             for (auto iter = stringSwitchJumpTable.offsetTable.begin(); iter != end; ++iter)
<span class="line-modified">185                 m_out.printf(&quot;\t\t\&quot;%s\&quot; =&gt; %04d\n&quot;, iter-&gt;key-&gt;utf8().data(), iter-&gt;value.branchOffset);</span>
<span class="line-modified">186             m_out.printf(&quot;      }\n&quot;);</span>
187             ++i;
188         } while (i &lt; count);
189     }
190 }
191 
192 template&lt;class Block&gt;
<span class="line-modified">193 void BytecodeDumper&lt;Block&gt;::dumpBlock(Block* block, const InstructionStream&amp; instructions, PrintStream&amp; out, const ICStatusMap&amp; statusMap)</span>
194 {
195     size_t instructionCount = 0;
196     size_t wide16InstructionCount = 0;
197     size_t wide32InstructionCount = 0;
198     size_t instructionWithMetadataCount = 0;
199 
200     for (const auto&amp; instruction : instructions) {
201         if (instruction-&gt;isWide16())
202             ++wide16InstructionCount;
203         else if (instruction-&gt;isWide32())
204             ++wide32InstructionCount;
205         if (instruction-&gt;hasMetadata())
206             ++instructionWithMetadataCount;
207         ++instructionCount;
208     }
209 
210     out.print(*block);
211     out.printf(
212         &quot;: %lu instructions (%lu 16-bit instructions, %lu 32-bit instructions, %lu instructions with metadata); %lu bytes (%lu metadata bytes); %d parameter(s); %d callee register(s); %d variable(s)&quot;,
213         static_cast&lt;unsigned long&gt;(instructionCount),
214         static_cast&lt;unsigned long&gt;(wide16InstructionCount),
215         static_cast&lt;unsigned long&gt;(wide32InstructionCount),
216         static_cast&lt;unsigned long&gt;(instructionWithMetadataCount),
217         static_cast&lt;unsigned long&gt;(instructions.sizeInBytes() + block-&gt;metadataSizeInBytes()),
218         static_cast&lt;unsigned long&gt;(block-&gt;metadataSizeInBytes()),
219         block-&gt;numParameters(), block-&gt;numCalleeLocals(), block-&gt;numVars());
220     out.print(&quot;; scope at &quot;, block-&gt;scopeRegister());
221     out.printf(&quot;\n&quot;);
222 
<span class="line-modified">223     BytecodeDumper&lt;Block&gt; dumper(block, out);</span>
224     for (const auto&amp; it : instructions)
225         dumper.dumpBytecode(it, statusMap);
226 
227     dumper.dumpIdentifiers();
228     dumper.dumpConstants();
229     dumper.dumpExceptionHandlers();
230     dumper.dumpSwitchJumpTables();
231     dumper.dumpStringSwitchJumpTables();
232 
233     out.printf(&quot;\n&quot;);
234 }
235 
<span class="line-removed">236 template class BytecodeDumper&lt;UnlinkedCodeBlock&gt;;</span>
237 template class BytecodeDumper&lt;CodeBlock&gt;;

































































































238 

239 }
</pre>
</td>
<td>
<hr />
<pre>
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 24  * THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;BytecodeDumper.h&quot;
 29 
 30 #include &quot;ArithProfile.h&quot;
<span class="line-added"> 31 #include &quot;B3Type.h&quot;</span>
<span class="line-added"> 32 #include &quot;BytecodeGenerator.h&quot;</span>
 33 #include &quot;BytecodeStructs.h&quot;
 34 #include &quot;CallLinkStatus.h&quot;
 35 #include &quot;CodeBlock.h&quot;
 36 #include &quot;Error.h&quot;
 37 #include &quot;HeapInlines.h&quot;
 38 #include &quot;InterpreterInlines.h&quot;
 39 #include &quot;PolymorphicAccess.h&quot;
 40 #include &quot;PutByIdFlags.h&quot;
 41 #include &quot;StructureInlines.h&quot;
 42 #include &quot;ToThisStatus.h&quot;
<span class="line-modified"> 43 #include &quot;UnlinkedCodeBlockGenerator.h&quot;</span>
 44 #include &quot;UnlinkedMetadataTableInlines.h&quot;
<span class="line-added"> 45 #include &quot;WasmFunctionCodeBlock.h&quot;</span>
<span class="line-added"> 46 #include &quot;WasmGeneratorTraits.h&quot;</span>
<span class="line-added"> 47 #include &quot;WasmModuleInformation.h&quot;</span>
<span class="line-added"> 48 #include &quot;WasmOps.h&quot;</span>
<span class="line-added"> 49 #include &quot;WasmSignatureInlines.h&quot;</span>
 50 
 51 namespace JSC {
 52 
<span class="line-modified"> 53 static ALWAYS_INLINE bool isConstantRegisterIndex(int index)</span>

 54 {
<span class="line-modified"> 55     return index &gt;= FirstConstantRegisterIndex;</span>
 56 }
 57 
<span class="line-modified"> 58 void BytecodeDumperBase::printLocationAndOp(InstructionStream::Offset location, const char* op)</span>

 59 {
<span class="line-modified"> 60     m_currentLocation = location;</span>
<span class="line-added"> 61     m_out.printf(&quot;[%4u] %-18s &quot;, location, op);</span>
 62 }
 63 
<span class="line-modified"> 64 void BytecodeDumperBase::dumpValue(VirtualRegister reg)</span>
 65 {
<span class="line-modified"> 66     m_out.printf(&quot;%s&quot;, registerName(reg).data());</span>
<span class="line-added"> 67 }</span>
<span class="line-added"> 68 </span>
<span class="line-added"> 69 template&lt;typename Traits&gt;</span>
<span class="line-added"> 70 void BytecodeDumperBase::dumpValue(GenericBoundLabel&lt;Traits&gt; label)</span>
<span class="line-added"> 71 {</span>
<span class="line-added"> 72     int target = label.target();</span>
<span class="line-added"> 73     if (!target)</span>
<span class="line-added"> 74         target = outOfLineJumpOffset(m_currentLocation);</span>
<span class="line-added"> 75     InstructionStream::Offset targetOffset = target + m_currentLocation;</span>
<span class="line-added"> 76     m_out.print(target, &quot;(-&gt;&quot;, targetOffset, &quot;)&quot;);</span>
 77 }
 78 
<span class="line-added"> 79 template void BytecodeDumperBase::dumpValue(GenericBoundLabel&lt;JSGeneratorTraits&gt;);</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added"> 82 template void BytecodeDumperBase::dumpValue(GenericBoundLabel&lt;Wasm::GeneratorTraits&gt;);</span>
<span class="line-added"> 83 #endif // ENABLE(WEBASSEMBLY)</span>
<span class="line-added"> 84 </span>
 85 template&lt;class Block&gt;
<span class="line-modified"> 86 CString BytecodeDumper&lt;Block&gt;::registerName(VirtualRegister r) const</span>
 87 {
<span class="line-modified"> 88     if (r.isConstant())</span>
 89         return constantName(r);
 90 
<span class="line-modified"> 91     return toCString(r);</span>
 92 }
 93 
<span class="line-modified"> 94 template &lt;class Block&gt;</span>
<span class="line-modified"> 95 int BytecodeDumper&lt;Block&gt;::outOfLineJumpOffset(InstructionStream::Offset offset) const</span>
 96 {
<span class="line-modified"> 97     return m_block-&gt;outOfLineJumpOffset(offset);</span>

 98 }
 99 
100 template&lt;class Block&gt;
<span class="line-modified">101 CString BytecodeDumper&lt;Block&gt;::constantName(VirtualRegister reg) const</span>
102 {
<span class="line-modified">103     auto value = block()-&gt;getConstant(reg);</span>
<span class="line-modified">104     return toCString(value, &quot;(&quot;, reg, &quot;)&quot;);</span>
105 }
106 
107 template&lt;class Block&gt;
108 void BytecodeDumper&lt;Block&gt;::dumpBytecode(const InstructionStream::Ref&amp; it, const ICStatusMap&amp;)
109 {
110     ::JSC::dumpBytecode(this, it.offset(), it.ptr());
<span class="line-modified">111     this-&gt;m_out.print(&quot;\n&quot;);</span>
112 }
113 
114 template&lt;class Block&gt;
115 void BytecodeDumper&lt;Block&gt;::dumpBytecode(Block* block, PrintStream&amp; out, const InstructionStream::Ref&amp; it, const ICStatusMap&amp; statusMap)
116 {
117     BytecodeDumper dumper(block, out);
118     dumper.dumpBytecode(it, statusMap);
119 }
120 
121 template&lt;class Block&gt;
<span class="line-modified">122 VM&amp; CodeBlockBytecodeDumper&lt;Block&gt;::vm() const</span>
123 {
<span class="line-modified">124     return this-&gt;block()-&gt;vm();</span>
<span class="line-modified">125 }</span>
<span class="line-added">126 </span>
<span class="line-added">127 template&lt;class Block&gt;</span>
<span class="line-added">128 const Identifier&amp; CodeBlockBytecodeDumper&lt;Block&gt;::identifier(int index) const</span>
<span class="line-added">129 {</span>
<span class="line-added">130     return this-&gt;block()-&gt;identifier(index);</span>
<span class="line-added">131 }</span>
<span class="line-added">132 </span>
<span class="line-added">133 template&lt;class Block&gt;</span>
<span class="line-added">134 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpIdentifiers()</span>
<span class="line-added">135 {</span>
<span class="line-added">136     if (size_t count = this-&gt;block()-&gt;numberOfIdentifiers()) {</span>
<span class="line-added">137         this-&gt;m_out.printf(&quot;\nIdentifiers:\n&quot;);</span>
138         size_t i = 0;
139         do {
<span class="line-modified">140             this-&gt;m_out.print(&quot;  id&quot;, static_cast&lt;unsigned&gt;(i), &quot; = &quot;, identifier(i), &quot;\n&quot;);</span>
141             ++i;
142         } while (i != count);
143     }
144 }
145 
146 template&lt;class Block&gt;
<span class="line-modified">147 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpConstants()</span>
148 {
<span class="line-modified">149     if (!this-&gt;block()-&gt;constantRegisters().isEmpty()) {</span>
<span class="line-modified">150         this-&gt;m_out.printf(&quot;\nConstants:\n&quot;);</span>
151         size_t i = 0;
<span class="line-modified">152         for (const auto&amp; constant : this-&gt;block()-&gt;constantRegisters()) {</span>
153             const char* sourceCodeRepresentationDescription = nullptr;
<span class="line-modified">154             switch (this-&gt;block()-&gt;constantsSourceCodeRepresentation()[i]) {</span>
155             case SourceCodeRepresentation::Double:
156                 sourceCodeRepresentationDescription = &quot;: in source as double&quot;;
157                 break;
158             case SourceCodeRepresentation::Integer:
159                 sourceCodeRepresentationDescription = &quot;: in source as integer&quot;;
160                 break;
161             case SourceCodeRepresentation::Other:
162                 sourceCodeRepresentationDescription = &quot;&quot;;
163                 break;
<span class="line-added">164             case SourceCodeRepresentation::LinkTimeConstant:</span>
<span class="line-added">165                 sourceCodeRepresentationDescription = &quot;: in source as linke-time-constant&quot;;</span>
<span class="line-added">166                 break;</span>
167             }
<span class="line-modified">168             this-&gt;m_out.printf(&quot;   k%u = %s%s\n&quot;, static_cast&lt;unsigned&gt;(i), toCString(constant.get()).data(), sourceCodeRepresentationDescription);</span>
169             ++i;
170         }
171     }
172 }
173 
174 template&lt;class Block&gt;
<span class="line-modified">175 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpExceptionHandlers()</span>
176 {
<span class="line-modified">177     if (unsigned count = this-&gt;block()-&gt;numberOfExceptionHandlers()) {</span>
<span class="line-modified">178         this-&gt;m_out.printf(&quot;\nException Handlers:\n&quot;);</span>
179         unsigned i = 0;
180         do {
<span class="line-modified">181             const auto&amp; handler = this-&gt;block()-&gt;exceptionHandler(i);</span>
<span class="line-modified">182             this-&gt;m_out.printf(&quot;\t %d: { start: [%4d] end: [%4d] target: [%4d] } %s\n&quot;, i + 1, handler.start, handler.end, handler.target, handler.typeName());</span>
183             ++i;
184         } while (i &lt; count);
185     }
186 }
187 
188 template&lt;class Block&gt;
<span class="line-modified">189 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpSwitchJumpTables()</span>
190 {
<span class="line-modified">191     if (unsigned count = this-&gt;block()-&gt;numberOfSwitchJumpTables()) {</span>
<span class="line-modified">192         this-&gt;m_out.printf(&quot;Switch Jump Tables:\n&quot;);</span>
193         unsigned i = 0;
194         do {
<span class="line-modified">195             this-&gt;m_out.printf(&quot;  %1d = {\n&quot;, i);</span>
<span class="line-modified">196             const auto&amp; switchJumpTable = this-&gt;block()-&gt;switchJumpTable(i);</span>
197             int entry = 0;
198             auto end = switchJumpTable.branchOffsets.end();
199             for (auto iter = switchJumpTable.branchOffsets.begin(); iter != end; ++iter, ++entry) {
200                 if (!*iter)
201                     continue;
<span class="line-modified">202                 this-&gt;m_out.printf(&quot;\t\t%4d =&gt; %04d\n&quot;, entry + switchJumpTable.min, *iter);</span>
203             }
<span class="line-modified">204             this-&gt;m_out.printf(&quot;      }\n&quot;);</span>
205             ++i;
206         } while (i &lt; count);
207     }
208 }
209 
210 template&lt;class Block&gt;
<span class="line-modified">211 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpStringSwitchJumpTables()</span>
212 {
<span class="line-modified">213     if (unsigned count = this-&gt;block()-&gt;numberOfStringSwitchJumpTables()) {</span>
<span class="line-modified">214         this-&gt;m_out.printf(&quot;\nString Switch Jump Tables:\n&quot;);</span>
215         unsigned i = 0;
216         do {
<span class="line-modified">217             this-&gt;m_out.printf(&quot;  %1d = {\n&quot;, i);</span>
<span class="line-modified">218             const auto&amp; stringSwitchJumpTable = this-&gt;block()-&gt;stringSwitchJumpTable(i);</span>
219             auto end = stringSwitchJumpTable.offsetTable.end();
220             for (auto iter = stringSwitchJumpTable.offsetTable.begin(); iter != end; ++iter)
<span class="line-modified">221                 this-&gt;m_out.printf(&quot;\t\t\&quot;%s\&quot; =&gt; %04d\n&quot;, iter-&gt;key-&gt;utf8().data(), iter-&gt;value.branchOffset);</span>
<span class="line-modified">222             this-&gt;m_out.printf(&quot;      }\n&quot;);</span>
223             ++i;
224         } while (i &lt; count);
225     }
226 }
227 
228 template&lt;class Block&gt;
<span class="line-modified">229 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpBlock(Block* block, const InstructionStream&amp; instructions, PrintStream&amp; out, const ICStatusMap&amp; statusMap)</span>
230 {
231     size_t instructionCount = 0;
232     size_t wide16InstructionCount = 0;
233     size_t wide32InstructionCount = 0;
234     size_t instructionWithMetadataCount = 0;
235 
236     for (const auto&amp; instruction : instructions) {
237         if (instruction-&gt;isWide16())
238             ++wide16InstructionCount;
239         else if (instruction-&gt;isWide32())
240             ++wide32InstructionCount;
241         if (instruction-&gt;hasMetadata())
242             ++instructionWithMetadataCount;
243         ++instructionCount;
244     }
245 
246     out.print(*block);
247     out.printf(
248         &quot;: %lu instructions (%lu 16-bit instructions, %lu 32-bit instructions, %lu instructions with metadata); %lu bytes (%lu metadata bytes); %d parameter(s); %d callee register(s); %d variable(s)&quot;,
249         static_cast&lt;unsigned long&gt;(instructionCount),
250         static_cast&lt;unsigned long&gt;(wide16InstructionCount),
251         static_cast&lt;unsigned long&gt;(wide32InstructionCount),
252         static_cast&lt;unsigned long&gt;(instructionWithMetadataCount),
253         static_cast&lt;unsigned long&gt;(instructions.sizeInBytes() + block-&gt;metadataSizeInBytes()),
254         static_cast&lt;unsigned long&gt;(block-&gt;metadataSizeInBytes()),
255         block-&gt;numParameters(), block-&gt;numCalleeLocals(), block-&gt;numVars());
256     out.print(&quot;; scope at &quot;, block-&gt;scopeRegister());
257     out.printf(&quot;\n&quot;);
258 
<span class="line-modified">259     CodeBlockBytecodeDumper&lt;Block&gt; dumper(block, out);</span>
260     for (const auto&amp; it : instructions)
261         dumper.dumpBytecode(it, statusMap);
262 
263     dumper.dumpIdentifiers();
264     dumper.dumpConstants();
265     dumper.dumpExceptionHandlers();
266     dumper.dumpSwitchJumpTables();
267     dumper.dumpStringSwitchJumpTables();
268 
269     out.printf(&quot;\n&quot;);
270 }
271 

272 template class BytecodeDumper&lt;CodeBlock&gt;;
<span class="line-added">273 template class CodeBlockBytecodeDumper&lt;UnlinkedCodeBlockGenerator&gt;;</span>
<span class="line-added">274 template class CodeBlockBytecodeDumper&lt;CodeBlock&gt;;</span>
<span class="line-added">275 </span>
<span class="line-added">276 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">277 </span>
<span class="line-added">278 namespace Wasm {</span>
<span class="line-added">279 </span>
<span class="line-added">280 void BytecodeDumper::dumpBlock(FunctionCodeBlock* block, const ModuleInformation&amp; moduleInformation, PrintStream&amp; out)</span>
<span class="line-added">281 {</span>
<span class="line-added">282     size_t instructionCount = 0;</span>
<span class="line-added">283     size_t wide16InstructionCount = 0;</span>
<span class="line-added">284     size_t wide32InstructionCount = 0;</span>
<span class="line-added">285 </span>
<span class="line-added">286     for (auto it = block-&gt;instructions().begin(); it != block-&gt;instructions().end(); it += it-&gt;size&lt;WasmOpcodeTraits&gt;()) {</span>
<span class="line-added">287         if (it-&gt;isWide16())</span>
<span class="line-added">288             ++wide16InstructionCount;</span>
<span class="line-added">289         else if (it-&gt;isWide32())</span>
<span class="line-added">290             ++wide32InstructionCount;</span>
<span class="line-added">291         ++instructionCount;</span>
<span class="line-added">292     }</span>
<span class="line-added">293 </span>
<span class="line-added">294     size_t functionIndexSpace = moduleInformation.importFunctionCount() + block-&gt;functionIndex();</span>
<span class="line-added">295     out.print(makeString(IndexOrName(functionIndexSpace, moduleInformation.nameSection-&gt;get(functionIndexSpace))));</span>
<span class="line-added">296 </span>
<span class="line-added">297     const auto&amp; function = moduleInformation.functions[block-&gt;functionIndex()];</span>
<span class="line-added">298     SignatureIndex signatureIndex = moduleInformation.internalFunctionSignatureIndices[block-&gt;functionIndex()];</span>
<span class="line-added">299     const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-added">300     out.print(&quot; : &quot;, signature, &quot;\n&quot;);</span>
<span class="line-added">301     out.print(&quot;wasm size: &quot;, function.data.size(), &quot; bytes\n&quot;);</span>
<span class="line-added">302 </span>
<span class="line-added">303     out.printf(</span>
<span class="line-added">304         &quot;bytecode: %lu instructions (%lu 16-bit instructions, %lu 32-bit instructions); %lu bytes; %d parameter(s); %d local(s); %d callee register(s)\n&quot;,</span>
<span class="line-added">305         static_cast&lt;unsigned long&gt;(instructionCount),</span>
<span class="line-added">306         static_cast&lt;unsigned long&gt;(wide16InstructionCount),</span>
<span class="line-added">307         static_cast&lt;unsigned long&gt;(wide32InstructionCount),</span>
<span class="line-added">308         static_cast&lt;unsigned long&gt;(block-&gt;instructions().sizeInBytes()),</span>
<span class="line-added">309         block-&gt;numArguments(),</span>
<span class="line-added">310         block-&gt;numVars(),</span>
<span class="line-added">311         block-&gt;numCalleeLocals());</span>
<span class="line-added">312 </span>
<span class="line-added">313     BytecodeDumper dumper(block, out);</span>
<span class="line-added">314     for (auto it = block-&gt;instructions().begin(); it != block-&gt;instructions().end(); it += it-&gt;size&lt;WasmOpcodeTraits&gt;()) {</span>
<span class="line-added">315         dumpWasm(&amp;dumper, it.offset(), it.ptr());</span>
<span class="line-added">316         out.print(&quot;\n&quot;);</span>
<span class="line-added">317     }</span>
<span class="line-added">318 </span>
<span class="line-added">319     dumper.dumpConstants();</span>
<span class="line-added">320 </span>
<span class="line-added">321     out.printf(&quot;\n&quot;);</span>
<span class="line-added">322 }</span>
<span class="line-added">323 </span>
<span class="line-added">324 void BytecodeDumper::dumpConstants()</span>
<span class="line-added">325 {</span>
<span class="line-added">326     FunctionCodeBlock* block = this-&gt;block();</span>
<span class="line-added">327     if (!block-&gt;constants().isEmpty()) {</span>
<span class="line-added">328         this-&gt;m_out.printf(&quot;\nConstants:\n&quot;);</span>
<span class="line-added">329         unsigned i = 0;</span>
<span class="line-added">330         for (const auto&amp; constant : block-&gt;constants()) {</span>
<span class="line-added">331             Type type = block-&gt;constantTypes()[i];</span>
<span class="line-added">332             this-&gt;m_out.print(&quot;   const&quot;, i, &quot; : &quot;, type, &quot; = &quot;, formatConstant(type, constant), &quot;\n&quot;);</span>
<span class="line-added">333             ++i;</span>
<span class="line-added">334         }</span>
<span class="line-added">335     }</span>
<span class="line-added">336 }</span>
<span class="line-added">337 </span>
<span class="line-added">338 CString BytecodeDumper::constantName(VirtualRegister index) const</span>
<span class="line-added">339 {</span>
<span class="line-added">340     FunctionCodeBlock* block = this-&gt;block();</span>
<span class="line-added">341     auto value = formatConstant(block-&gt;getConstantType(index), block-&gt;getConstant(index));</span>
<span class="line-added">342     return toCString(value, &quot;(&quot;, VirtualRegister(index), &quot;)&quot;);</span>
<span class="line-added">343 }</span>
<span class="line-added">344 </span>
<span class="line-added">345 CString BytecodeDumper::formatConstant(Type type, uint64_t constant) const</span>
<span class="line-added">346 {</span>
<span class="line-added">347     switch (type) {</span>
<span class="line-added">348     case Type::I32:</span>
<span class="line-added">349         return toCString(static_cast&lt;int32_t&gt;(constant));</span>
<span class="line-added">350     case Type::I64:</span>
<span class="line-added">351         return toCString(constant);</span>
<span class="line-added">352     case Type::F32:</span>
<span class="line-added">353         return toCString(bitwise_cast&lt;float&gt;(static_cast&lt;int32_t&gt;(constant)));</span>
<span class="line-added">354         break;</span>
<span class="line-added">355     case Type::F64:</span>
<span class="line-added">356         return toCString(bitwise_cast&lt;double&gt;(constant));</span>
<span class="line-added">357         break;</span>
<span class="line-added">358     case Type::Anyref:</span>
<span class="line-added">359     case Type::Funcref:</span>
<span class="line-added">360         if (JSValue::decode(constant) == jsNull())</span>
<span class="line-added">361             return &quot;null&quot;;</span>
<span class="line-added">362         return toCString(RawPointer(bitwise_cast&lt;void*&gt;(constant)));</span>
<span class="line-added">363     default:</span>
<span class="line-added">364         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">365         return &quot;&quot;;</span>
<span class="line-added">366     }</span>
<span class="line-added">367 }</span>
<span class="line-added">368 </span>
<span class="line-added">369 } // namespace Wasm</span>
370 
<span class="line-added">371 #endif // ENABLE(WEBASSEMBLY)</span>
372 }
</pre>
</td>
</tr>
</table>
<center><a href="BytecodeBasicBlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeDumper.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
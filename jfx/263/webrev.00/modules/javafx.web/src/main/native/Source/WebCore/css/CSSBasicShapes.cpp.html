<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/CSSBasicShapes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Adobe Systems Incorporated. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1. Redistributions of source code must retain the above
  9  *    copyright notice, this list of conditions and the following
 10  *    disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials
 14  *    provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 19  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 27  * SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;CSSBasicShapes.h&quot;
 32 
 33 #include &quot;CSSMarkup.h&quot;
 34 #include &quot;CSSPrimitiveValueMappings.h&quot;
 35 #include &quot;CSSValuePool.h&quot;
 36 #include &quot;Pair.h&quot;
 37 #include &quot;SVGPathByteStream.h&quot;
 38 #include &quot;SVGPathUtilities.h&quot;
 39 #include &lt;wtf/text/StringBuilder.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 static String serializePositionOffset(const Pair&amp; offset, const Pair&amp; other)
 44 {
 45     if ((offset.first()-&gt;valueID() == CSSValueLeft &amp;&amp; other.first()-&gt;valueID() == CSSValueTop)
 46         || (offset.first()-&gt;valueID() == CSSValueTop &amp;&amp; other.first()-&gt;valueID() == CSSValueLeft))
 47         return offset.second()-&gt;cssText();
 48     return offset.cssText();
 49 }
 50 
 51 static Ref&lt;CSSPrimitiveValue&gt; buildSerializablePositionOffset(CSSPrimitiveValue* offset, CSSValueID defaultSide)
 52 {
 53     CSSValueID side = defaultSide;
 54     RefPtr&lt;CSSPrimitiveValue&gt; amount;
 55 
 56     if (!offset)
 57         side = CSSValueCenter;
 58     else if (offset-&gt;isValueID())
 59         side = offset-&gt;valueID();
 60     else if (Pair* pair = offset-&gt;pairValue()) {
 61         side = pair-&gt;first()-&gt;valueID();
 62         amount = pair-&gt;second();
 63     } else
 64         amount = offset;
 65 
 66     auto&amp; cssValuePool = CSSValuePool::singleton();
 67     if (!amount)
 68         amount = cssValuePool.createValue(Length(side == CSSValueCenter ? 50 : 0, Percent));
 69 
 70     if (side == CSSValueCenter)
 71         side = defaultSide;
 72     else if ((side == CSSValueRight || side == CSSValueBottom)
 73         &amp;&amp; amount-&gt;isPercentage()) {
 74         side = defaultSide;
 75         amount = cssValuePool.createValue(Length(100 - amount-&gt;floatValue(), Percent));
 76     } else if (amount-&gt;isLength() &amp;&amp; !amount-&gt;floatValue()) {
 77         if (side == CSSValueRight || side == CSSValueBottom)
 78             amount = cssValuePool.createValue(Length(100, Percent));
 79         else
 80             amount = cssValuePool.createValue(Length(0, Percent));
 81         side = defaultSide;
 82     }
 83 
 84     return cssValuePool.createValue(Pair::create(cssValuePool.createValue(side), WTFMove(amount)));
 85 }
 86 
 87 static String buildCircleString(const String&amp; radius, const String&amp; centerX, const String&amp; centerY)
 88 {
 89     StringBuilder result;
 90     result.appendLiteral(&quot;circle(&quot;);
 91     if (!radius.isNull())
 92         result.append(radius);
 93     if (!centerX.isNull() || !centerY.isNull()) {
 94         if (!radius.isNull())
 95             result.append(&#39; &#39;);
 96         result.append(&quot;at &quot;, centerX, &#39; &#39;, centerY);
 97     }
 98     result.append(&#39;)&#39;);
 99     return result.toString();
100 }
101 
102 String CSSBasicShapeCircle::cssText() const
103 {
104     Ref&lt;CSSPrimitiveValue&gt; normalizedCX = buildSerializablePositionOffset(m_centerX.get(), CSSValueLeft);
105     Ref&lt;CSSPrimitiveValue&gt; normalizedCY = buildSerializablePositionOffset(m_centerY.get(), CSSValueTop);
106 
107     String radius;
108     if (m_radius &amp;&amp; m_radius-&gt;valueID() != CSSValueClosestSide)
109         radius = m_radius-&gt;cssText();
110 
111     return buildCircleString(radius,
112         serializePositionOffset(*normalizedCX-&gt;pairValue(), *normalizedCY-&gt;pairValue()),
113         serializePositionOffset(*normalizedCY-&gt;pairValue(), *normalizedCX-&gt;pairValue()));
114 }
115 
116 bool CSSBasicShapeCircle::equals(const CSSBasicShape&amp; shape) const
117 {
118     if (!is&lt;CSSBasicShapeCircle&gt;(shape))
119         return false;
120 
121     const CSSBasicShapeCircle&amp; other = downcast&lt;CSSBasicShapeCircle&gt;(shape);
122     return compareCSSValuePtr(m_centerX, other.m_centerX)
123         &amp;&amp; compareCSSValuePtr(m_centerY, other.m_centerY)
124         &amp;&amp; compareCSSValuePtr(m_radius, other.m_radius);
125 }
126 
127 static String buildEllipseString(const String&amp; radiusX, const String&amp; radiusY, const String&amp; centerX, const String&amp; centerY)
128 {
129     StringBuilder result;
130     result.appendLiteral(&quot;ellipse(&quot;);
131     bool needsSeparator = false;
132     if (!radiusX.isNull()) {
133         result.append(radiusX);
134         needsSeparator = true;
135     }
136     if (!radiusY.isNull()) {
137         if (needsSeparator)
138             result.append(&#39; &#39;);
139         result.append(radiusY);
140         needsSeparator = true;
141     }
142     if (!centerX.isNull() || !centerY.isNull()) {
143         if (needsSeparator)
144             result.append(&#39; &#39;);
145         result.append(&quot;at &quot;, centerX, &#39; &#39;, centerY);
146     }
147     result.append(&#39;)&#39;);
148     return result.toString();
149 }
150 
151 String CSSBasicShapeEllipse::cssText() const
152 {
153     Ref&lt;CSSPrimitiveValue&gt; normalizedCX = buildSerializablePositionOffset(m_centerX.get(), CSSValueLeft);
154     Ref&lt;CSSPrimitiveValue&gt; normalizedCY = buildSerializablePositionOffset(m_centerY.get(), CSSValueTop);
155 
156     String radiusX;
157     String radiusY;
158     if (m_radiusX) {
159         ASSERT(m_radiusY);
160         bool radiusXClosestSide = m_radiusX-&gt;valueID() == CSSValueClosestSide;
161         bool radiusYClosestSide = m_radiusY-&gt;valueID() == CSSValueClosestSide;
162         if (!radiusXClosestSide || !radiusYClosestSide) {
163             radiusX = m_radiusX-&gt;cssText();
164             radiusY = m_radiusY-&gt;cssText();
165         }
166     }
167     return buildEllipseString(radiusX, radiusY,
168         serializePositionOffset(*normalizedCX-&gt;pairValue(), *normalizedCY-&gt;pairValue()),
169         serializePositionOffset(*normalizedCY-&gt;pairValue(), *normalizedCX-&gt;pairValue()));
170 }
171 
172 bool CSSBasicShapeEllipse::equals(const CSSBasicShape&amp; shape) const
173 {
174     if (!is&lt;CSSBasicShapeEllipse&gt;(shape))
175         return false;
176 
177     const CSSBasicShapeEllipse&amp; other = downcast&lt;CSSBasicShapeEllipse&gt;(shape);
178     return compareCSSValuePtr(m_centerX, other.m_centerX)
179         &amp;&amp; compareCSSValuePtr(m_centerY, other.m_centerY)
180         &amp;&amp; compareCSSValuePtr(m_radiusX, other.m_radiusX)
181         &amp;&amp; compareCSSValuePtr(m_radiusY, other.m_radiusY);
182 }
183 
184 CSSBasicShapePath::CSSBasicShapePath(std::unique_ptr&lt;SVGPathByteStream&gt;&amp;&amp; pathData)
185     : m_byteStream(WTFMove(pathData))
186 {
187 }
188 
189 static String buildPathString(const WindRule&amp; windRule, const String&amp; path, const String&amp; box)
190 {
191     StringBuilder result;
192     if (windRule == WindRule::EvenOdd)
193         result.appendLiteral(&quot;path(evenodd, &quot;);
194     else
195         result.appendLiteral(&quot;path(&quot;);
196 
197     serializeString(path, result);
198     result.append(&#39;)&#39;);
199 
200     if (box.length()) {
201         result.append(&#39; &#39;);
202         result.append(box);
203     }
204 
205     return result.toString();
206 }
207 
208 String CSSBasicShapePath::cssText() const
209 {
210     String pathString;
211     buildStringFromByteStream(*m_byteStream, pathString, UnalteredParsing);
212 
213     return buildPathString(m_windRule, pathString, m_referenceBox ? m_referenceBox-&gt;cssText() : String());
214 }
215 
216 bool CSSBasicShapePath::equals(const CSSBasicShape&amp; otherShape) const
217 {
218     if (!is&lt;CSSBasicShapePath&gt;(otherShape))
219         return false;
220 
221     auto&amp; otherShapePath = downcast&lt;CSSBasicShapePath&gt;(otherShape);
222     return windRule() == otherShapePath.windRule() &amp;&amp; pathData() == otherShapePath.pathData();
223 }
224 
225 static String buildPolygonString(const WindRule&amp; windRule, const Vector&lt;String&gt;&amp; points)
226 {
227     ASSERT(!(points.size() % 2));
228 
229     StringBuilder result;
230     char evenOddOpening[] = &quot;polygon(evenodd, &quot;;
231     char nonZeroOpening[] = &quot;polygon(&quot;;
232     char commaSeparator[] = &quot;, &quot;;
233     COMPILE_ASSERT(sizeof(evenOddOpening) &gt;= sizeof(nonZeroOpening), polygon_evenodd_is_longest_string_opening);
234 
235     // Compute the required capacity in advance to reduce allocations.
236     size_t length = sizeof(evenOddOpening) - 1;
237     for (size_t i = 0; i &lt; points.size(); i += 2) {
238         if (i)
239             length += (sizeof(commaSeparator) - 1);
240         // add length of two strings, plus one for the space separator.
241         length += points[i].length() + 1 + points[i + 1].length();
242     }
243 
244     result.reserveCapacity(length);
245 
246     if (windRule == WindRule::EvenOdd)
247         result.appendLiteral(evenOddOpening);
248     else
249         result.appendLiteral(nonZeroOpening);
250 
251     for (size_t i = 0; i &lt; points.size(); i += 2) {
252         if (i)
253             result.appendLiteral(commaSeparator);
254         result.append(points[i], &#39; &#39;, points[i + 1]);
255     }
256 
257     result.append(&#39;)&#39;);
258 
259     return result.toString();
260 }
261 
262 String CSSBasicShapePolygon::cssText() const
263 {
264     Vector&lt;String&gt; points;
265     points.reserveInitialCapacity(m_values.size());
266 
267     for (auto&amp; shapeValue : m_values)
268         points.uncheckedAppend(shapeValue-&gt;cssText());
269 
270     return buildPolygonString(m_windRule, points);
271 }
272 
273 bool CSSBasicShapePolygon::equals(const CSSBasicShape&amp; shape) const
274 {
275     if (!is&lt;CSSBasicShapePolygon&gt;(shape))
276         return false;
277 
278     return compareCSSValueVector&lt;CSSPrimitiveValue&gt;(m_values, downcast&lt;CSSBasicShapePolygon&gt;(shape).m_values);
279 }
280 
281 static bool buildInsetRadii(Vector&lt;String&gt;&amp; radii, const String&amp; topLeftRadius, const String&amp; topRightRadius, const String&amp; bottomRightRadius, const String&amp; bottomLeftRadius)
282 {
283     bool showBottomLeft = topRightRadius != bottomLeftRadius;
284     bool showBottomRight = showBottomLeft || (bottomRightRadius != topLeftRadius);
285     bool showTopRight = showBottomRight || (topRightRadius != topLeftRadius);
286 
287     radii.append(topLeftRadius);
288     if (showTopRight)
289         radii.append(topRightRadius);
290     if (showBottomRight)
291         radii.append(bottomRightRadius);
292     if (showBottomLeft)
293         radii.append(bottomLeftRadius);
294 
295     return radii.size() == 1 &amp;&amp; radii[0] == &quot;0px&quot;;
296 }
297 
298 static String buildInsetString(const String&amp; top, const String&amp; right, const String&amp; bottom, const String&amp; left,
299     const String&amp; topLeftRadiusWidth, const String&amp; topLeftRadiusHeight,
300     const String&amp; topRightRadiusWidth, const String&amp; topRightRadiusHeight,
301     const String&amp; bottomRightRadiusWidth, const String&amp; bottomRightRadiusHeight,
302     const String&amp; bottomLeftRadiusWidth, const String&amp; bottomLeftRadiusHeight)
303 {
304     StringBuilder result;
305     result.append(&quot;inset(&quot;, top);
306 
307     bool showLeftArg = !left.isNull() &amp;&amp; left != right;
308     bool showBottomArg = !bottom.isNull() &amp;&amp; (bottom != top || showLeftArg);
309     bool showRightArg = !right.isNull() &amp;&amp; (right != top || showBottomArg);
310     if (showRightArg)
311         result.append(&#39; &#39;, right);
312     if (showBottomArg)
313         result.append(&#39; &#39;, bottom);
314     if (showLeftArg)
315         result.append(&#39; &#39;, left);
316 
317     if (!topLeftRadiusWidth.isNull() &amp;&amp; !topLeftRadiusHeight.isNull()) {
318         Vector&lt;String&gt; horizontalRadii;
319         bool areDefaultCornerRadii = buildInsetRadii(horizontalRadii, topLeftRadiusWidth, topRightRadiusWidth, bottomRightRadiusWidth, bottomLeftRadiusWidth);
320 
321         Vector&lt;String&gt; verticalRadii;
322         areDefaultCornerRadii &amp;= buildInsetRadii(verticalRadii, topLeftRadiusHeight, topRightRadiusHeight, bottomRightRadiusHeight, bottomLeftRadiusHeight);
323 
324         if (!areDefaultCornerRadii) {
325             result.appendLiteral(&quot; round&quot;);
326 
327             for (auto&amp; radius : horizontalRadii)
328                 result.append(&#39; &#39;, radius);
329 
330             if (verticalRadii.size() != horizontalRadii.size()
331                 || !WTF::VectorComparer&lt;false, String&gt;::compare(verticalRadii.data(), horizontalRadii.data(), verticalRadii.size())) {
332                 result.appendLiteral(&quot; /&quot;);
333                 for (auto&amp; radius : verticalRadii)
334                     result.append(&#39; &#39;, radius);
335             }
336         }
337     }
338     result.append(&#39;)&#39;);
339     return result.toString();
340 }
341 
342 static inline void updateCornerRadiusWidthAndHeight(CSSPrimitiveValue* corner, String&amp; width, String&amp; height)
343 {
344     if (!corner)
345         return;
346 
347     Pair* radius = corner-&gt;pairValue();
348     width = radius-&gt;first() ? radius-&gt;first()-&gt;cssText() : &quot;0&quot;_str;
349     if (radius-&gt;second())
350         height = radius-&gt;second()-&gt;cssText();
351 }
352 
353 String CSSBasicShapeInset::cssText() const
354 {
355     String topLeftRadiusWidth;
356     String topLeftRadiusHeight;
357     String topRightRadiusWidth;
358     String topRightRadiusHeight;
359     String bottomRightRadiusWidth;
360     String bottomRightRadiusHeight;
361     String bottomLeftRadiusWidth;
362     String bottomLeftRadiusHeight;
363 
364     updateCornerRadiusWidthAndHeight(topLeftRadius(), topLeftRadiusWidth, topLeftRadiusHeight);
365     updateCornerRadiusWidthAndHeight(topRightRadius(), topRightRadiusWidth, topRightRadiusHeight);
366     updateCornerRadiusWidthAndHeight(bottomRightRadius(), bottomRightRadiusWidth, bottomRightRadiusHeight);
367     updateCornerRadiusWidthAndHeight(bottomLeftRadius(), bottomLeftRadiusWidth, bottomLeftRadiusHeight);
368 
369     return buildInsetString(m_top ? m_top-&gt;cssText() : String(),
370         m_right ? m_right-&gt;cssText() : String(),
371         m_bottom ? m_bottom-&gt;cssText() : String(),
372         m_left ? m_left-&gt;cssText() : String(),
373         topLeftRadiusWidth,
374         topLeftRadiusHeight,
375         topRightRadiusWidth,
376         topRightRadiusHeight,
377         bottomRightRadiusWidth,
378         bottomRightRadiusHeight,
379         bottomLeftRadiusWidth,
380         bottomLeftRadiusHeight);
381 }
382 
383 bool CSSBasicShapeInset::equals(const CSSBasicShape&amp; shape) const
384 {
385     if (!is&lt;CSSBasicShapeInset&gt;(shape))
386         return false;
387 
388     const CSSBasicShapeInset&amp; other = downcast&lt;CSSBasicShapeInset&gt;(shape);
389     return compareCSSValuePtr(m_top, other.m_top)
390         &amp;&amp; compareCSSValuePtr(m_right, other.m_right)
391         &amp;&amp; compareCSSValuePtr(m_bottom, other.m_bottom)
392         &amp;&amp; compareCSSValuePtr(m_left, other.m_left)
393         &amp;&amp; compareCSSValuePtr(m_topLeftRadius, other.m_topLeftRadius)
394         &amp;&amp; compareCSSValuePtr(m_topRightRadius, other.m_topRightRadius)
395         &amp;&amp; compareCSSValuePtr(m_bottomRightRadius, other.m_bottomRightRadius)
396         &amp;&amp; compareCSSValuePtr(m_bottomLeftRadius, other.m_bottomLeftRadius);
397 }
398 
399 } // namespace WebCore
400 
    </pre>
  </body>
</html>
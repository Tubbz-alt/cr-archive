<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorCanvas.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2017 Apple Inc.  All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;InspectorCanvas.h&quot;
  28 
  29 #include &quot;AffineTransform.h&quot;
  30 #include &quot;CachedImage.h&quot;
  31 #include &quot;CanvasGradient.h&quot;
  32 #include &quot;CanvasPattern.h&quot;
  33 #include &quot;CanvasRenderingContext.h&quot;
  34 #include &quot;CanvasRenderingContext2D.h&quot;
  35 #include &quot;Document.h&quot;
  36 #include &quot;Element.h&quot;
  37 #include &quot;FloatPoint.h&quot;
  38 #include &quot;Gradient.h&quot;
  39 #include &quot;HTMLCanvasElement.h&quot;
  40 #include &quot;HTMLImageElement.h&quot;
  41 #include &quot;HTMLVideoElement.h&quot;
  42 #include &quot;Image.h&quot;
  43 #include &quot;ImageBitmap.h&quot;
  44 #include &quot;ImageBitmapRenderingContext.h&quot;
  45 #include &quot;ImageBuffer.h&quot;
  46 #include &quot;ImageData.h&quot;
  47 #include &quot;InspectorDOMAgent.h&quot;
  48 #include &quot;JSCanvasDirection.h&quot;
  49 #include &quot;JSCanvasFillRule.h&quot;
  50 #include &quot;JSCanvasLineCap.h&quot;
  51 #include &quot;JSCanvasLineJoin.h&quot;
  52 #include &quot;JSCanvasRenderingContext2D.h&quot;
  53 #include &quot;JSCanvasTextAlign.h&quot;
  54 #include &quot;JSCanvasTextBaseline.h&quot;
  55 #include &quot;JSExecState.h&quot;
  56 #include &quot;JSImageBitmapRenderingContext.h&quot;
  57 #include &quot;JSImageSmoothingQuality.h&quot;
  58 #include &quot;Path2D.h&quot;
  59 #include &quot;Pattern.h&quot;
  60 #include &quot;RecordingSwizzleTypes.h&quot;
  61 #include &quot;SVGPathUtilities.h&quot;
  62 #include &quot;StringAdaptors.h&quot;
  63 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
  64 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  65 #include &lt;wtf/Function.h&gt;
  66 
  67 #if ENABLE(CSS_TYPED_OM)
  68 #include &quot;TypedOMCSSImageValue.h&quot;
  69 #endif
  70 
  71 #if ENABLE(WEBGL)
  72 #include &quot;JSWebGLRenderingContext.h&quot;
  73 #include &quot;WebGLRenderingContext.h&quot;
  74 #endif
  75 
  76 #if ENABLE(WEBGL2)
  77 #include &quot;JSWebGL2RenderingContext.h&quot;
  78 #include &quot;WebGL2RenderingContext.h&quot;
  79 #endif
  80 
  81 #if ENABLE(WEBGPU)
  82 #include &quot;GPUCanvasContext.h&quot;
  83 #include &quot;JSWebGPUDevice.h&quot;
  84 #include &quot;WebGPUDevice.h&quot;
  85 #endif
  86 
  87 namespace WebCore {
  88 
  89 using namespace Inspector;
  90 
  91 #if ENABLE(WEBGPU)
  92 static HTMLCanvasElement* canvasIfContextMatchesDevice(CanvasRenderingContext&amp; context, WebGPUDevice&amp; device)
  93 {
  94     if (is&lt;GPUCanvasContext&gt;(context)) {
  95         auto&amp; contextGPU = downcast&lt;GPUCanvasContext&gt;(context);
  96         if (auto* webGPUSwapChain = contextGPU.swapChain()) {
  97             if (auto* gpuSwapChain = webGPUSwapChain-&gt;swapChain()) {
  98                 if (gpuSwapChain == device.device().swapChain()) {
  99                     if (is&lt;HTMLCanvasElement&gt;(contextGPU.canvasBase()))
 100                         return &amp;downcast&lt;HTMLCanvasElement&gt;(contextGPU.canvasBase());
 101                 }
 102             }
 103         }
 104     }
 105     return nullptr;
 106 }
 107 #endif
 108 
 109 Ref&lt;InspectorCanvas&gt; InspectorCanvas::create(CanvasRenderingContext&amp; context)
 110 {
 111     return adoptRef(*new InspectorCanvas(context));
 112 }
 113 
 114 #if ENABLE(WEBGPU)
 115 Ref&lt;InspectorCanvas&gt; InspectorCanvas::create(WebGPUDevice&amp; device)
 116 {
 117     return adoptRef(*new InspectorCanvas(device));
 118 }
 119 #endif
 120 
 121 InspectorCanvas::InspectorCanvas(CanvasRenderingContext&amp; context)
 122     : m_identifier(&quot;canvas:&quot; + IdentifiersFactory::createIdentifier())
 123     , m_context(context)
 124 {
 125 #if ENABLE(WEBGPU)
 126     // The actual &quot;context&quot; for WebGPU is the `WebGPUDevice`, not the &lt;canvas&gt;.
 127     ASSERT(!is&lt;GPUCanvasContext&gt;(context));
 128 #endif
 129 }
 130 
 131 #if ENABLE(WEBGPU)
 132 InspectorCanvas::InspectorCanvas(WebGPUDevice&amp; device)
 133     : m_identifier(&quot;canvas:&quot; + IdentifiersFactory::createIdentifier())
 134     , m_context(device)
 135 {
 136 }
 137 #endif
 138 
 139 CanvasRenderingContext* InspectorCanvas::canvasContext() const
 140 {
 141     if (auto* contextWrapper = WTF::get_if&lt;std::reference_wrapper&lt;CanvasRenderingContext&gt;&gt;(m_context))
 142         return &amp;contextWrapper-&gt;get();
 143     return nullptr;
 144 }
 145 
 146 HTMLCanvasElement* InspectorCanvas::canvasElement() const
 147 {
 148     return WTF::switchOn(m_context,
 149         [] (std::reference_wrapper&lt;CanvasRenderingContext&gt; contextWrapper) -&gt; HTMLCanvasElement* {
 150             auto&amp; context = contextWrapper.get();
 151             if (is&lt;HTMLCanvasElement&gt;(context.canvasBase()))
 152                 return &amp;downcast&lt;HTMLCanvasElement&gt;(context.canvasBase());
 153             return nullptr;
 154         },
 155 #if ENABLE(WEBGPU)
 156         [&amp;] (std::reference_wrapper&lt;WebGPUDevice&gt; deviceWrapper) -&gt; HTMLCanvasElement* {
 157             auto&amp; device = deviceWrapper.get();
 158             {
 159                 LockHolder lock(CanvasRenderingContext::instancesMutex());
 160                 for (auto* canvasRenderingContext : CanvasRenderingContext::instances(lock)) {
 161                     if (auto* canvasElement = canvasIfContextMatchesDevice(*canvasRenderingContext, device))
 162                         return canvasElement;
 163                 }
 164             }
 165             return nullptr;
 166         },
 167 #endif
 168         [] (Monostate) {
 169             ASSERT_NOT_REACHED();
 170             return nullptr;
 171         }
 172     );
 173     return nullptr;
 174 }
 175 
 176 #if ENABLE(WEBGPU)
 177 WebGPUDevice* InspectorCanvas::deviceContext() const
 178 {
 179     if (auto* deviceWrapper = WTF::get_if&lt;std::reference_wrapper&lt;WebGPUDevice&gt;&gt;(m_context))
 180         return &amp;deviceWrapper-&gt;get();
 181     return nullptr;
 182 }
 183 
 184 bool InspectorCanvas::isDeviceForCanvasContext(CanvasRenderingContext&amp; context) const
 185 {
 186     if (auto* device = deviceContext())
 187         return canvasIfContextMatchesDevice(context, *device);
 188     return false;
 189 }
 190 #endif
 191 
 192 ScriptExecutionContext* InspectorCanvas::scriptExecutionContext() const
 193 {
 194     return WTF::switchOn(m_context,
 195         [] (std::reference_wrapper&lt;CanvasRenderingContext&gt; contextWrapper) {
 196             auto&amp; context = contextWrapper.get();
 197             return context.canvasBase().scriptExecutionContext();
 198         },
 199 #if ENABLE(WEBGPU)
 200         [] (std::reference_wrapper&lt;WebGPUDevice&gt; deviceWrapper) {
 201             auto&amp; device = deviceWrapper.get();
 202             return device.scriptExecutionContext();
 203         },
 204 #endif
 205         [] (Monostate) {
 206             ASSERT_NOT_REACHED();
 207             return nullptr;
 208         }
 209     );
 210 }
 211 
 212 JSC::JSValue InspectorCanvas::resolveContext(JSC::JSGlobalObject* exec) const
 213 {
 214     JSC::JSLockHolder lock(exec);
 215 
 216     auto* globalObject = deprecatedGlobalObjectForPrototype(exec);
 217 
 218     return WTF::switchOn(m_context,
 219         [&amp;] (std::reference_wrapper&lt;CanvasRenderingContext&gt; contextWrapper) {
 220             auto&amp; context = contextWrapper.get();
 221             if (is&lt;CanvasRenderingContext2D&gt;(context))
 222                 return toJS(exec, globalObject, downcast&lt;CanvasRenderingContext2D&gt;(context));
 223             if (is&lt;ImageBitmapRenderingContext&gt;(context))
 224                 return toJS(exec, globalObject, downcast&lt;ImageBitmapRenderingContext&gt;(context));
 225 #if ENABLE(WEBGL)
 226             if (is&lt;WebGLRenderingContext&gt;(context))
 227                 return toJS(exec, globalObject, downcast&lt;WebGLRenderingContext&gt;(context));
 228 #endif
 229 #if ENABLE(WEBGL2)
 230             if (is&lt;WebGL2RenderingContext&gt;(context))
 231                 return toJS(exec, globalObject, downcast&lt;WebGL2RenderingContext&gt;(context));
 232 #endif
 233             return JSC::JSValue();
 234         },
 235 #if ENABLE(WEBGPU)
 236         [&amp;] (std::reference_wrapper&lt;WebGPUDevice&gt; deviceWrapper) {
 237             return toJS(exec, globalObject, deviceWrapper.get());
 238         },
 239 #endif
 240         [] (Monostate) {
 241             ASSERT_NOT_REACHED();
 242             return JSC::JSValue();
 243         }
 244     );
 245 }
 246 
 247 HashSet&lt;Element*&gt; InspectorCanvas::clientNodes() const
 248 {
 249     return WTF::switchOn(m_context,
 250         [] (std::reference_wrapper&lt;CanvasRenderingContext&gt; contextWrapper) {
 251             auto&amp; context = contextWrapper.get();
 252             return context.canvasBase().cssCanvasClients();
 253         },
 254 #if ENABLE(WEBGPU)
 255         [&amp;] (std::reference_wrapper&lt;WebGPUDevice&gt; deviceWrapper) {
 256             auto&amp; device = deviceWrapper.get();
 257 
 258             HashSet&lt;Element*&gt; canvasElementClients;
 259             {
 260                 LockHolder lock(CanvasRenderingContext::instancesMutex());
 261                 for (auto* canvasRenderingContext : CanvasRenderingContext::instances(lock)) {
 262                     if (auto* canvasElement = canvasIfContextMatchesDevice(*canvasRenderingContext, device))
 263                         canvasElementClients.add(canvasElement);
 264                 }
 265             }
 266             return canvasElementClients;
 267         },
 268 #endif
 269         [] (Monostate) {
 270             ASSERT_NOT_REACHED();
 271             return HashSet&lt;Element*&gt;();
 272         }
 273     );
 274 }
 275 
 276 void InspectorCanvas::canvasChanged()
 277 {
 278     auto* context = canvasContext();
 279     ASSERT(context);
 280 
 281     if (!context-&gt;callTracingActive())
 282         return;
 283 
 284     // Since 2D contexts are able to be fully reproduced in the frontend, we don&#39;t need snapshots.
 285     if (is&lt;CanvasRenderingContext2D&gt;(context))
 286         return;
 287 
 288     m_contentChanged = true;
 289 }
 290 
 291 void InspectorCanvas::resetRecordingData()
 292 {
 293     m_initialState = nullptr;
 294     m_frames = nullptr;
 295     m_currentActions = nullptr;
 296     m_serializedDuplicateData = nullptr;
 297     m_indexedDuplicateData.clear();
 298     m_recordingName = { };
 299     m_bufferLimit = 100 * 1024 * 1024;
 300     m_bufferUsed = 0;
 301     m_frameCount = WTF::nullopt;
 302     m_framesCaptured = 0;
 303     m_contentChanged = false;
 304 
 305     auto* context = canvasContext();
 306     ASSERT(context);
 307     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice
 308 
 309     context-&gt;setCallTracingActive(false);
 310 }
 311 
 312 bool InspectorCanvas::hasRecordingData() const
 313 {
 314     return m_bufferUsed &gt; 0;
 315 }
 316 
 317 bool InspectorCanvas::currentFrameHasData() const
 318 {
 319     return !!m_frames;
 320 }
 321 
 322 static bool shouldSnapshotBitmapRendererAction(const String&amp; name)
 323 {
 324     return name == &quot;transferFromImageBitmap&quot;;
 325 }
 326 
 327 #if ENABLE(WEBGL)
 328 static bool shouldSnapshotWebGLAction(const String&amp; name)
 329 {
 330     return name == &quot;clear&quot;
 331         || name == &quot;drawArrays&quot;
 332         || name == &quot;drawElements&quot;;
 333 }
 334 #endif
 335 
 336 #if ENABLE(WEBGL2)
 337 static bool shouldSnapshotWebGL2Action(const String&amp; name)
 338 {
 339     return name == &quot;clear&quot;
 340         || name == &quot;drawArrays&quot;
 341         || name == &quot;drawArraysInstanced&quot;
 342         || name == &quot;drawElements&quot;
 343         || name == &quot;drawElementsInstanced&quot;;
 344 }
 345 #endif
 346 
 347 void InspectorCanvas::recordAction(const String&amp; name, std::initializer_list&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)
 348 {
 349     if (!m_initialState) {
 350         // We should only construct the initial state for the first action of the recording.
 351         ASSERT(!m_frames &amp;&amp; !m_currentActions);
 352 
 353         m_initialState = buildInitialState();
 354         m_bufferUsed += m_initialState-&gt;memoryCost();
 355     }
 356 
 357     if (!m_frames)
 358         m_frames = JSON::ArrayOf&lt;Inspector::Protocol::Recording::Frame&gt;::create();
 359 
 360     if (!m_currentActions) {
 361         m_currentActions = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 362 
 363         auto frame = Inspector::Protocol::Recording::Frame::create()
 364             .setActions(m_currentActions)
 365             .release();
 366 
 367         m_frames-&gt;addItem(WTFMove(frame));
 368         ++m_framesCaptured;
 369 
 370         m_currentFrameStartTime = MonotonicTime::now();
 371     }
 372 
 373     appendActionSnapshotIfNeeded();
 374 
 375     m_lastRecordedAction = buildAction(name, WTFMove(parameters));
 376     m_bufferUsed += m_lastRecordedAction-&gt;memoryCost();
 377     m_currentActions-&gt;addItem(m_lastRecordedAction.get());
 378 
 379     auto* context = canvasContext();
 380     ASSERT(context);
 381     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice
 382 
 383     if (is&lt;ImageBitmapRenderingContext&gt;(context) &amp;&amp; shouldSnapshotBitmapRendererAction(name))
 384         m_contentChanged = true;
 385 #if ENABLE(WEBGL)
 386     else if (is&lt;WebGLRenderingContext&gt;(context) &amp;&amp; shouldSnapshotWebGLAction(name))
 387         m_contentChanged = true;
 388 #endif
 389 #if ENABLE(WEBGL2)
 390     else if (is&lt;WebGL2RenderingContext&gt;(context) &amp;&amp; shouldSnapshotWebGL2Action(name))
 391         m_contentChanged = true;
 392 #endif
 393 }
 394 
 395 void InspectorCanvas::finalizeFrame()
 396 {
 397     appendActionSnapshotIfNeeded();
 398 
 399     if (m_frames &amp;&amp; m_frames-&gt;length() &amp;&amp; !std::isnan(m_currentFrameStartTime)) {
 400         auto currentFrame = static_cast&lt;Inspector::Protocol::Recording::Frame*&gt;(m_frames-&gt;get(m_frames-&gt;length() - 1).get());
 401         currentFrame-&gt;setDuration((MonotonicTime::now() - m_currentFrameStartTime).milliseconds());
 402 
 403         m_currentFrameStartTime = MonotonicTime::nan();
 404     }
 405 
 406     m_currentActions = nullptr;
 407 }
 408 
 409 void InspectorCanvas::markCurrentFrameIncomplete()
 410 {
 411     if (!m_currentActions || !m_frames || !m_frames-&gt;length())
 412         return;
 413 
 414     static_cast&lt;Inspector::Protocol::Recording::Frame*&gt;(m_frames-&gt;get(m_frames-&gt;length() - 1).get())-&gt;setIncomplete(true);
 415 }
 416 
 417 void InspectorCanvas::setBufferLimit(long memoryLimit)
 418 {
 419     m_bufferLimit = std::min&lt;long&gt;(memoryLimit, std::numeric_limits&lt;int&gt;::max());
 420 }
 421 
 422 bool InspectorCanvas::hasBufferSpace() const
 423 {
 424     return m_bufferUsed &lt; m_bufferLimit;
 425 }
 426 
 427 void InspectorCanvas::setFrameCount(long frameCount)
 428 {
 429     if (frameCount &gt; 0)
 430         m_frameCount = std::min&lt;long&gt;(frameCount, std::numeric_limits&lt;int&gt;::max());
 431     else
 432         m_frameCount = WTF::nullopt;
 433 }
 434 
 435 bool InspectorCanvas::overFrameCount() const
 436 {
 437     return m_frameCount &amp;&amp; m_framesCaptured &gt;= m_frameCount.value();
 438 }
 439 
 440 Ref&lt;Inspector::Protocol::Canvas::Canvas&gt; InspectorCanvas::buildObjectForCanvas(bool captureBacktrace)
 441 {
 442     using ContextTypeType = Optional&lt;Inspector::Protocol::Canvas::ContextType&gt;;
 443     auto contextType = WTF::switchOn(m_context,
 444         [] (std::reference_wrapper&lt;CanvasRenderingContext&gt; contextWrapper) -&gt; ContextTypeType {
 445             auto&amp; context = contextWrapper.get();
 446             if (is&lt;CanvasRenderingContext2D&gt;(context))
 447                 return Inspector::Protocol::Canvas::ContextType::Canvas2D;
 448             if (is&lt;ImageBitmapRenderingContext&gt;(context))
 449                 return Inspector::Protocol::Canvas::ContextType::BitmapRenderer;
 450 #if ENABLE(WEBGL)
 451             if (is&lt;WebGLRenderingContext&gt;(context))
 452                 return Inspector::Protocol::Canvas::ContextType::WebGL;
 453 #endif
 454 #if ENABLE(WEBGL2)
 455             if (is&lt;WebGL2RenderingContext&gt;(context))
 456                 return Inspector::Protocol::Canvas::ContextType::WebGL2;
 457 #endif
 458             return WTF::nullopt;
 459         },
 460 #if ENABLE(WEBGPU)
 461         [] (std::reference_wrapper&lt;WebGPUDevice&gt;) {
 462             return Inspector::Protocol::Canvas::ContextType::WebGPU;
 463         },
 464 #endif
 465         [] (Monostate) {
 466             ASSERT_NOT_REACHED();
 467             return WTF::nullopt;
 468         }
 469     );
 470     if (!contextType) {
 471         ASSERT_NOT_REACHED();
 472         contextType = Inspector::Protocol::Canvas::ContextType::Canvas2D;
 473     }
 474 
 475     auto canvas = Inspector::Protocol::Canvas::Canvas::create()
 476         .setCanvasId(m_identifier)
 477         .setContextType(contextType.value())
 478         .release();
 479 
 480     if (auto* node = canvasElement()) {
 481         String cssCanvasName = node-&gt;document().nameForCSSCanvasElement(*node);
 482         if (!cssCanvasName.isEmpty())
 483             canvas-&gt;setCssCanvasName(cssCanvasName);
 484 
 485         // FIXME: &lt;https://webkit.org/b/178282&gt; Web Inspector: send a DOM node with each Canvas payload and eliminate Canvas.requestNode
 486     }
 487 
 488     using ContextAttributesType = RefPtr&lt;Inspector::Protocol::Canvas::ContextAttributes&gt;;
 489     auto contextAttributes = WTF::switchOn(m_context,
 490         [] (std::reference_wrapper&lt;CanvasRenderingContext&gt; contextWrapper) -&gt; ContextAttributesType {
 491             auto&amp; context = contextWrapper.get();
 492             if (is&lt;ImageBitmapRenderingContext&gt;(context)) {
 493                 auto contextAttributesPayload = Inspector::Protocol::Canvas::ContextAttributes::create()
 494                     .release();
 495                 contextAttributesPayload-&gt;setAlpha(downcast&lt;ImageBitmapRenderingContext&gt;(context).hasAlpha());
 496                 return contextAttributesPayload;
 497             }
 498 
 499 #if ENABLE(WEBGL)
 500             if (is&lt;WebGLRenderingContextBase&gt;(context)) {
 501                 if (const auto&amp; attributes = downcast&lt;WebGLRenderingContextBase&gt;(context).getContextAttributes()) {
 502                     auto contextAttributesPayload = Inspector::Protocol::Canvas::ContextAttributes::create()
 503                         .release();
 504                     contextAttributesPayload-&gt;setAlpha(attributes-&gt;alpha);
 505                     contextAttributesPayload-&gt;setDepth(attributes-&gt;depth);
 506                     contextAttributesPayload-&gt;setStencil(attributes-&gt;stencil);
 507                     contextAttributesPayload-&gt;setAntialias(attributes-&gt;antialias);
 508                     contextAttributesPayload-&gt;setPremultipliedAlpha(attributes-&gt;premultipliedAlpha);
 509                     contextAttributesPayload-&gt;setPreserveDrawingBuffer(attributes-&gt;preserveDrawingBuffer);
 510                     switch (attributes-&gt;powerPreference) {
 511                     case WebGLPowerPreference::Default:
 512                         contextAttributesPayload-&gt;setPowerPreference(&quot;default&quot;);
 513                         break;
 514                     case WebGLPowerPreference::LowPower:
 515                         contextAttributesPayload-&gt;setPowerPreference(&quot;low-power&quot;);
 516                         break;
 517                     case WebGLPowerPreference::HighPerformance:
 518                         contextAttributesPayload-&gt;setPowerPreference(&quot;high-performance&quot;);
 519                         break;
 520                     }
 521                     contextAttributesPayload-&gt;setFailIfMajorPerformanceCaveat(attributes-&gt;failIfMajorPerformanceCaveat);
 522                     return contextAttributesPayload;
 523                 }
 524             }
 525 #endif
 526             return nullptr;
 527         },
 528 #if ENABLE(WEBGPU)
 529         [] (std::reference_wrapper&lt;WebGPUDevice&gt; deviceWrapper) -&gt; ContextAttributesType {
 530             auto&amp; device = deviceWrapper.get();
 531             if (const auto&amp; options = device.adapter().options()) {
 532                 auto contextAttributesPayload = Inspector::Protocol::Canvas::ContextAttributes::create()
 533                     .release();
 534                 if (const auto&amp; powerPreference = options-&gt;powerPreference) {
 535                     switch (powerPreference.value()) {
 536                     case GPUPowerPreference::LowPower:
 537                         contextAttributesPayload-&gt;setPowerPreference(&quot;low-power&quot;);
 538                         break;
 539 
 540                     case GPUPowerPreference::HighPerformance:
 541                         contextAttributesPayload-&gt;setPowerPreference(&quot;high-performance&quot;);
 542                         break;
 543                     }
 544                 }
 545                 return WTFMove(contextAttributesPayload);
 546             }
 547             return nullptr;
 548         },
 549 #endif
 550         [] (Monostate) {
 551             ASSERT_NOT_REACHED();
 552             return nullptr;
 553         }
 554     );
 555     if (contextAttributes)
 556         canvas-&gt;setContextAttributes(WTFMove(contextAttributes));
 557 
 558     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
 559 
 560     if (auto* node = canvasElement()) {
 561         if (size_t memoryCost = node-&gt;memoryCost())
 562             canvas-&gt;setMemoryCost(memoryCost);
 563     }
 564 
 565     if (captureBacktrace) {
 566         auto stackTrace = Inspector::createScriptCallStack(JSExecState::currentState(), Inspector::ScriptCallStack::maxCallStackSizeToCapture);
 567         canvas-&gt;setBacktrace(stackTrace-&gt;buildInspectorArray());
 568     }
 569 
 570     return canvas;
 571 }
 572 
 573 Ref&lt;Inspector::Protocol::Recording::Recording&gt; InspectorCanvas::releaseObjectForRecording()
 574 {
 575     ASSERT(!m_currentActions);
 576     ASSERT(!m_lastRecordedAction);
 577     ASSERT(!m_frames);
 578 
 579     auto* context = canvasContext();
 580     ASSERT(context);
 581     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice
 582 
 583     Inspector::Protocol::Recording::Type type;
 584     if (is&lt;CanvasRenderingContext2D&gt;(context))
 585         type = Inspector::Protocol::Recording::Type::Canvas2D;
 586     else if (is&lt;ImageBitmapRenderingContext&gt;(context))
 587         type = Inspector::Protocol::Recording::Type::CanvasBitmapRenderer;
 588 #if ENABLE(WEBGL)
 589     else if (is&lt;WebGLRenderingContext&gt;(context))
 590         type = Inspector::Protocol::Recording::Type::CanvasWebGL;
 591 #endif
 592 #if ENABLE(WEBGL2)
 593     else if (is&lt;WebGL2RenderingContext&gt;(context))
 594         type = Inspector::Protocol::Recording::Type::CanvasWebGL2;
 595 #endif
 596     else {
 597         ASSERT_NOT_REACHED();
 598         type = Inspector::Protocol::Recording::Type::Canvas2D;
 599     }
 600 
 601     auto recording = Inspector::Protocol::Recording::Recording::create()
 602         .setVersion(Inspector::Protocol::Recording::VERSION)
 603         .setType(type)
 604         .setInitialState(m_initialState.releaseNonNull())
 605         .setData(m_serializedDuplicateData.releaseNonNull())
 606         .release();
 607 
 608     if (!m_recordingName.isEmpty())
 609         recording-&gt;setName(m_recordingName);
 610 
 611     resetRecordingData();
 612 
 613     return recording;
 614 }
 615 
 616 String InspectorCanvas::getCanvasContentAsDataURL(ErrorString&amp; errorString)
 617 {
 618     auto* node = canvasElement();
 619     if (!node) {
 620         errorString = &quot;Missing HTMLCanvasElement of canvas for given canvasId&quot;_s;
 621         return emptyString();
 622     }
 623 
 624 #if ENABLE(WEBGL)
 625     auto* context = node-&gt;renderingContext();
 626     if (is&lt;WebGLRenderingContextBase&gt;(context))
 627         downcast&lt;WebGLRenderingContextBase&gt;(*context).setPreventBufferClearForInspector(true);
 628 #endif
 629 
 630     ExceptionOr&lt;UncachedString&gt; result = node-&gt;toDataURL(&quot;image/png&quot;_s);
 631 
 632 #if ENABLE(WEBGL)
 633     if (is&lt;WebGLRenderingContextBase&gt;(context))
 634         downcast&lt;WebGLRenderingContextBase&gt;(*context).setPreventBufferClearForInspector(false);
 635 #endif
 636 
 637     if (result.hasException()) {
 638         errorString = result.releaseException().releaseMessage();
 639         return emptyString();
 640     }
 641 
 642     return result.releaseReturnValue().string;
 643 }
 644 
 645 void InspectorCanvas::appendActionSnapshotIfNeeded()
 646 {
 647     if (!m_lastRecordedAction)
 648         return;
 649 
 650     if (m_contentChanged) {
 651         m_bufferUsed -= m_lastRecordedAction-&gt;memoryCost();
 652 
 653         ErrorString ignored;
 654         m_lastRecordedAction-&gt;addItem(indexForData(getCanvasContentAsDataURL(ignored)));
 655 
 656         m_bufferUsed += m_lastRecordedAction-&gt;memoryCost();
 657     }
 658 
 659     m_lastRecordedAction = nullptr;
 660     m_contentChanged = false;
 661 }
 662 
 663 int InspectorCanvas::indexForData(DuplicateDataVariant data)
 664 {
 665     size_t index = m_indexedDuplicateData.findMatching([&amp;] (auto item) {
 666         if (data == item)
 667             return true;
 668 
 669         auto traceA = WTF::get_if&lt;RefPtr&lt;ScriptCallStack&gt;&gt;(data);
 670         auto traceB = WTF::get_if&lt;RefPtr&lt;ScriptCallStack&gt;&gt;(item);
 671         if (traceA &amp;&amp; *traceA &amp;&amp; traceB &amp;&amp; *traceB)
 672             return (*traceA)-&gt;isEqual((*traceB).get());
 673 
 674         return false;
 675     });
 676     if (index != notFound) {
 677         ASSERT(index &lt; static_cast&lt;size_t&gt;(std::numeric_limits&lt;int&gt;::max()));
 678         return static_cast&lt;int&gt;(index);
 679     }
 680 
 681     if (!m_serializedDuplicateData)
 682         m_serializedDuplicateData = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 683 
 684     RefPtr&lt;JSON::Value&gt; item;
 685     WTF::switchOn(data,
 686         [&amp;] (const RefPtr&lt;HTMLImageElement&gt;&amp; imageElement) {
 687             String dataURL = &quot;data:,&quot;_s;
 688 
 689             if (CachedImage* cachedImage = imageElement-&gt;cachedImage()) {
 690                 Image* image = cachedImage-&gt;image();
 691                 if (image &amp;&amp; image != &amp;Image::nullImage()) {
 692                     std::unique_ptr&lt;ImageBuffer&gt; imageBuffer = ImageBuffer::create(image-&gt;size(), RenderingMode::Unaccelerated);
 693                     imageBuffer-&gt;context().drawImage(*image, FloatPoint(0, 0));
 694                     dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;);
 695                 }
 696             }
 697 
 698             index = indexForData(dataURL);
 699         },
 700 #if ENABLE(VIDEO)
 701         [&amp;] (RefPtr&lt;HTMLVideoElement&gt;&amp; videoElement) {
 702             String dataURL = &quot;data:,&quot;_s;
 703 
 704             unsigned videoWidth = videoElement-&gt;videoWidth();
 705             unsigned videoHeight = videoElement-&gt;videoHeight();
 706             std::unique_ptr&lt;ImageBuffer&gt; imageBuffer = ImageBuffer::create(FloatSize(videoWidth, videoHeight), RenderingMode::Unaccelerated);
 707             if (imageBuffer) {
 708                 videoElement-&gt;paintCurrentFrameInContext(imageBuffer-&gt;context(), FloatRect(0, 0, videoWidth, videoHeight));
 709                 dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;);
 710             }
 711 
 712             index = indexForData(dataURL);
 713         },
 714 #endif
 715         [&amp;] (RefPtr&lt;HTMLCanvasElement&gt;&amp; canvasElement) {
 716             String dataURL = &quot;data:,&quot;_s;
 717 
 718             ExceptionOr&lt;UncachedString&gt; result = canvasElement-&gt;toDataURL(&quot;image/png&quot;_s);
 719             if (!result.hasException())
 720                 dataURL = result.releaseReturnValue().string;
 721 
 722             index = indexForData(dataURL);
 723         },
 724         [&amp;] (const RefPtr&lt;CanvasGradient&gt;&amp; canvasGradient) { item = buildArrayForCanvasGradient(*canvasGradient); },
 725         [&amp;] (const RefPtr&lt;CanvasPattern&gt;&amp; canvasPattern) { item = buildArrayForCanvasPattern(*canvasPattern); },
 726         [&amp;] (const RefPtr&lt;ImageData&gt;&amp; imageData) { item = buildArrayForImageData(*imageData); },
 727         [&amp;] (RefPtr&lt;ImageBitmap&gt;&amp; imageBitmap) {
 728             index = indexForData(imageBitmap-&gt;buffer()-&gt;toDataURL(&quot;image/png&quot;));
 729         },
 730         [&amp;] (const RefPtr&lt;ScriptCallStack&gt;&amp; scriptCallStack) {
 731             auto array = JSON::ArrayOf&lt;double&gt;::create();
 732             for (size_t i = 0; i &lt; scriptCallStack-&gt;size(); ++i)
 733                 array-&gt;addItem(indexForData(scriptCallStack-&gt;at(i)));
 734             item = WTFMove(array);
 735         },
 736 #if ENABLE(CSS_TYPED_OM)
 737         [&amp;] (const RefPtr&lt;TypedOMCSSImageValue&gt;&amp; cssImageValue) {
 738             String dataURL = &quot;data:,&quot;_s;
 739 
 740             if (auto* cachedImage = cssImageValue-&gt;image()) {
 741                 auto* image = cachedImage-&gt;image();
 742                 if (image &amp;&amp; image != &amp;Image::nullImage()) {
 743                     auto imageBuffer = ImageBuffer::create(image-&gt;size(), RenderingMode::Unaccelerated);
 744                     imageBuffer-&gt;context().drawImage(*image, FloatPoint(0, 0));
 745                     dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;);
 746                 }
 747             }
 748 
 749             index = indexForData(dataURL);
 750         },
 751 #endif
 752         [&amp;] (const ScriptCallFrame&amp; scriptCallFrame) {
 753             auto array = JSON::ArrayOf&lt;double&gt;::create();
 754             array-&gt;addItem(indexForData(scriptCallFrame.functionName()));
 755             array-&gt;addItem(indexForData(scriptCallFrame.sourceURL()));
 756             array-&gt;addItem(static_cast&lt;int&gt;(scriptCallFrame.lineNumber()));
 757             array-&gt;addItem(static_cast&lt;int&gt;(scriptCallFrame.columnNumber()));
 758             item = WTFMove(array);
 759         },
 760 #if ENABLE(OFFSCREEN_CANVAS)
 761         [&amp;] (const RefPtr&lt;OffscreenCanvas&gt; offscreenCanvas) {
 762             String dataURL = &quot;data:,&quot;_s;
 763 
 764             if (offscreenCanvas-&gt;originClean() &amp;&amp; offscreenCanvas-&gt;hasCreatedImageBuffer()) {
 765                 if (auto *buffer = offscreenCanvas-&gt;buffer())
 766                     dataURL = buffer-&gt;toDataURL(&quot;image/png&quot;);
 767             }
 768 
 769             index = indexForData(dataURL);
 770         },
 771 #endif
 772         [&amp;] (const String&amp; value) { item = JSON::Value::create(value); }
 773     );
 774 
 775     if (item) {
 776         m_bufferUsed += item-&gt;memoryCost();
 777         m_serializedDuplicateData-&gt;addItem(WTFMove(item));
 778 
 779         m_indexedDuplicateData.append(data);
 780         index = m_indexedDuplicateData.size() - 1;
 781     }
 782 
 783     ASSERT(index &lt; static_cast&lt;size_t&gt;(std::numeric_limits&lt;int&gt;::max()));
 784     return static_cast&lt;int&gt;(index);
 785 }
 786 
 787 String InspectorCanvas::stringIndexForKey(const String&amp; key)
 788 {
 789     return String::number(indexForData(key));
 790 }
 791 
 792 static Ref&lt;JSON::ArrayOf&lt;double&gt;&gt; buildArrayForAffineTransform(const AffineTransform&amp; affineTransform)
 793 {
 794     auto array = JSON::ArrayOf&lt;double&gt;::create();
 795     array-&gt;addItem(affineTransform.a());
 796     array-&gt;addItem(affineTransform.b());
 797     array-&gt;addItem(affineTransform.c());
 798     array-&gt;addItem(affineTransform.d());
 799     array-&gt;addItem(affineTransform.e());
 800     array-&gt;addItem(affineTransform.f());
 801     return array;
 802 }
 803 
 804 template&lt;typename T&gt; static Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; buildArrayForVector(const Vector&lt;T&gt;&amp; vector)
 805 {
 806     auto array = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 807     for (auto&amp; item : vector)
 808         array-&gt;addItem(item);
 809     return array;
 810 }
 811 
 812 Ref&lt;Inspector::Protocol::Recording::InitialState&gt; InspectorCanvas::buildInitialState()
 813 {
 814     auto* context = canvasContext();
 815     ASSERT(context);
 816     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice
 817 
 818     auto initialStatePayload = Inspector::Protocol::Recording::InitialState::create().release();
 819 
 820     auto attributesPayload = JSON::Object::create();
 821     attributesPayload-&gt;setInteger(&quot;width&quot;_s, context-&gt;canvasBase().width());
 822     attributesPayload-&gt;setInteger(&quot;height&quot;_s, context-&gt;canvasBase().height());
 823 
 824     auto statesPayload = JSON::ArrayOf&lt;JSON::Object&gt;::create();
 825 
 826     auto parametersPayload = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 827 
 828     if (is&lt;CanvasRenderingContext2D&gt;(context)) {
 829         auto&amp; context2d = downcast&lt;CanvasRenderingContext2D&gt;(*context);
 830         for (auto&amp; state : context2d.stateStack()) {
 831             auto statePayload = JSON::Object::create();
 832 
 833             statePayload-&gt;setArray(stringIndexForKey(&quot;setTransform&quot;_s), buildArrayForAffineTransform(state.transform));
 834             statePayload-&gt;setDouble(stringIndexForKey(&quot;globalAlpha&quot;_s), context2d.globalAlpha());
 835             statePayload-&gt;setInteger(stringIndexForKey(&quot;globalCompositeOperation&quot;_s), indexForData(context2d.globalCompositeOperation()));
 836             statePayload-&gt;setDouble(stringIndexForKey(&quot;lineWidth&quot;_s), context2d.lineWidth());
 837             statePayload-&gt;setInteger(stringIndexForKey(&quot;lineCap&quot;_s), indexForData(convertEnumerationToString(context2d.lineCap())));
 838             statePayload-&gt;setInteger(stringIndexForKey(&quot;lineJoin&quot;_s), indexForData(convertEnumerationToString(context2d.lineJoin())));
 839             statePayload-&gt;setDouble(stringIndexForKey(&quot;miterLimit&quot;_s), context2d.miterLimit());
 840             statePayload-&gt;setDouble(stringIndexForKey(&quot;shadowOffsetX&quot;_s), context2d.shadowOffsetX());
 841             statePayload-&gt;setDouble(stringIndexForKey(&quot;shadowOffsetY&quot;_s), context2d.shadowOffsetY());
 842             statePayload-&gt;setDouble(stringIndexForKey(&quot;shadowBlur&quot;_s), context2d.shadowBlur());
 843             statePayload-&gt;setInteger(stringIndexForKey(&quot;shadowColor&quot;_s), indexForData(context2d.shadowColor()));
 844 
 845             // The parameter to `setLineDash` is itself an array, so we need to wrap the parameters
 846             // list in an array to allow spreading.
 847             auto setLineDash = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 848             setLineDash-&gt;addItem(buildArrayForVector(state.lineDash));
 849             statePayload-&gt;setArray(stringIndexForKey(&quot;setLineDash&quot;_s), WTFMove(setLineDash));
 850 
 851             statePayload-&gt;setDouble(stringIndexForKey(&quot;lineDashOffset&quot;_s), context2d.lineDashOffset());
 852             statePayload-&gt;setInteger(stringIndexForKey(&quot;font&quot;_s), indexForData(context2d.font()));
 853             statePayload-&gt;setInteger(stringIndexForKey(&quot;textAlign&quot;_s), indexForData(convertEnumerationToString(context2d.textAlign())));
 854             statePayload-&gt;setInteger(stringIndexForKey(&quot;textBaseline&quot;_s), indexForData(convertEnumerationToString(context2d.textBaseline())));
 855             statePayload-&gt;setInteger(stringIndexForKey(&quot;direction&quot;_s), indexForData(convertEnumerationToString(context2d.direction())));
 856 
 857             int strokeStyleIndex;
 858             if (auto canvasGradient = state.strokeStyle.canvasGradient())
 859                 strokeStyleIndex = indexForData(canvasGradient);
 860             else if (auto canvasPattern = state.strokeStyle.canvasPattern())
 861                 strokeStyleIndex = indexForData(canvasPattern);
 862             else
 863                 strokeStyleIndex = indexForData(state.strokeStyle.color());
 864             statePayload-&gt;setInteger(stringIndexForKey(&quot;strokeStyle&quot;_s), strokeStyleIndex);
 865 
 866             int fillStyleIndex;
 867             if (auto canvasGradient = state.fillStyle.canvasGradient())
 868                 fillStyleIndex = indexForData(canvasGradient);
 869             else if (auto canvasPattern = state.fillStyle.canvasPattern())
 870                 fillStyleIndex = indexForData(canvasPattern);
 871             else
 872                 fillStyleIndex = indexForData(state.fillStyle.color());
 873             statePayload-&gt;setInteger(stringIndexForKey(&quot;fillStyle&quot;_s), fillStyleIndex);
 874 
 875             statePayload-&gt;setBoolean(stringIndexForKey(&quot;imageSmoothingEnabled&quot;_s), context2d.imageSmoothingEnabled());
 876             statePayload-&gt;setInteger(stringIndexForKey(&quot;imageSmoothingQuality&quot;_s), indexForData(convertEnumerationToString(context2d.imageSmoothingQuality())));
 877 
 878             auto setPath = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 879             setPath-&gt;addItem(indexForData(buildStringFromPath(context2d.getPath()-&gt;path())));
 880             statePayload-&gt;setArray(stringIndexForKey(&quot;setPath&quot;_s), WTFMove(setPath));
 881 
 882             statesPayload-&gt;addItem(WTFMove(statePayload));
 883         }
 884     }
 885 #if ENABLE(WEBGL)
 886     else if (is&lt;WebGLRenderingContextBase&gt;(context)) {
 887         auto&amp; contextWebGLBase = downcast&lt;WebGLRenderingContextBase&gt;(*context);
 888         if (Optional&lt;WebGLContextAttributes&gt; webGLContextAttributes = contextWebGLBase.getContextAttributes()) {
 889             auto webGLContextAttributesPayload = JSON::Object::create();
 890             webGLContextAttributesPayload-&gt;setBoolean(&quot;alpha&quot;_s, webGLContextAttributes-&gt;alpha);
 891             webGLContextAttributesPayload-&gt;setBoolean(&quot;depth&quot;_s, webGLContextAttributes-&gt;depth);
 892             webGLContextAttributesPayload-&gt;setBoolean(&quot;stencil&quot;_s, webGLContextAttributes-&gt;stencil);
 893             webGLContextAttributesPayload-&gt;setBoolean(&quot;antialias&quot;_s, webGLContextAttributes-&gt;antialias);
 894             webGLContextAttributesPayload-&gt;setBoolean(&quot;premultipliedAlpha&quot;_s, webGLContextAttributes-&gt;premultipliedAlpha);
 895             webGLContextAttributesPayload-&gt;setBoolean(&quot;preserveDrawingBuffer&quot;_s, webGLContextAttributes-&gt;preserveDrawingBuffer);
 896             webGLContextAttributesPayload-&gt;setBoolean(&quot;failIfMajorPerformanceCaveat&quot;_s, webGLContextAttributes-&gt;failIfMajorPerformanceCaveat);
 897             parametersPayload-&gt;addItem(WTFMove(webGLContextAttributesPayload));
 898         }
 899     }
 900 #endif
 901 
 902     initialStatePayload-&gt;setAttributes(WTFMove(attributesPayload));
 903 
 904     if (statesPayload-&gt;length())
 905         initialStatePayload-&gt;setStates(WTFMove(statesPayload));
 906 
 907     if (parametersPayload-&gt;length())
 908         initialStatePayload-&gt;setParameters(WTFMove(parametersPayload));
 909 
 910     ErrorString ignored;
 911     initialStatePayload-&gt;setContent(getCanvasContentAsDataURL(ignored));
 912 
 913     return initialStatePayload;
 914 }
 915 
 916 Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildAction(const String&amp; name, std::initializer_list&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)
 917 {
 918     auto action = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 919     action-&gt;addItem(indexForData(name));
 920 
 921     auto parametersData = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 922     auto swizzleTypes = JSON::ArrayOf&lt;int&gt;::create();
 923 
 924     auto addParameter = [&amp;parametersData, &amp;swizzleTypes] (auto value, RecordingSwizzleTypes swizzleType) {
 925         parametersData-&gt;addItem(value);
 926         swizzleTypes-&gt;addItem(static_cast&lt;int&gt;(swizzleType));
 927     };
 928 
 929     // Declared before it&#39;s initialized so it can be used recursively.
 930     Function&lt;void(const RecordCanvasActionVariant&amp;)&gt; parseParameter;
 931     parseParameter = [&amp;] (const auto&amp; parameter) {
 932         WTF::switchOn(parameter,
 933             [&amp;] (CanvasDirection value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
 934             [&amp;] (CanvasFillRule value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
 935             [&amp;] (CanvasLineCap value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
 936             [&amp;] (CanvasLineJoin value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
 937             [&amp;] (CanvasTextAlign value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
 938             [&amp;] (CanvasTextBaseline value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
 939             [&amp;] (ImageSmoothingQuality value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
 940             [&amp;] (const DOMMatrix2DInit&amp; value) {
 941                 auto array = JSON::ArrayOf&lt;double&gt;::create();
 942                 array-&gt;addItem(value.a.valueOr(1));
 943                 array-&gt;addItem(value.b.valueOr(0));
 944                 array-&gt;addItem(value.c.valueOr(0));
 945                 array-&gt;addItem(value.d.valueOr(1));
 946                 array-&gt;addItem(value.e.valueOr(0));
 947                 array-&gt;addItem(value.f.valueOr(0));
 948                 addParameter(array.ptr(), RecordingSwizzleTypes::DOMMatrix);
 949             },
 950             [&amp;] (const Element* value) {
 951                 if (value) {
 952                     // Elements are not serializable, so add a string as a placeholder since the actual
 953                     // element cannot be reconstructed in the frontend.
 954                     addParameter(indexForData(&quot;Element&quot;), RecordingSwizzleTypes::None);
 955                 }
 956             },
 957             [&amp;] (HTMLImageElement* value) {
 958                 if (value)
 959                     addParameter(indexForData(value), RecordingSwizzleTypes::Image); },
 960             [&amp;] (ImageBitmap* value) {
 961                 if (value)
 962                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap); },
 963             [&amp;] (ImageData* value) {
 964                 if (value)
 965                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageData); },
 966             [&amp;] (const Path2D* value) {
 967                 if (value)
 968                     addParameter(indexForData(buildStringFromPath(value-&gt;path())), RecordingSwizzleTypes::Path2D); },
 969 #if ENABLE(WEBGL)
 970             // FIXME: &lt;https://webkit.org/b/176009&gt; Web Inspector: send data for WebGL objects during a recording instead of a placeholder string
 971             [&amp;] (const WebGLBuffer* value) {
 972                 if (value)
 973                     addParameter(0, RecordingSwizzleTypes::WebGLBuffer);
 974             },
 975             [&amp;] (const WebGLFramebuffer* value) {
 976                 if (value)
 977                     addParameter(0, RecordingSwizzleTypes::WebGLFramebuffer);
 978             },
 979             [&amp;] (const WebGLProgram* value) {
 980                 if (value)
 981                     addParameter(0, RecordingSwizzleTypes::WebGLProgram);
 982             },
 983             [&amp;] (const WebGLQuery* value) {
 984                 if (value)
 985                     addParameter(0, RecordingSwizzleTypes::WebGLQuery);
 986             },
 987             [&amp;] (const WebGLRenderbuffer* value) {
 988                 if (value)
 989                     addParameter(0, RecordingSwizzleTypes::WebGLRenderbuffer);
 990             },
 991             [&amp;] (const WebGLSampler* value) {
 992                 if (value)
 993                     addParameter(0, RecordingSwizzleTypes::WebGLSampler);
 994             },
 995             [&amp;] (const WebGLShader* value) {
 996                 if (value)
 997                     addParameter(0, RecordingSwizzleTypes::WebGLShader);
 998             },
 999             [&amp;] (const WebGLSync* value) {
1000                 if (value)
1001                     addParameter(0, RecordingSwizzleTypes::WebGLSync);
1002             },
1003             [&amp;] (const WebGLTexture* value) {
1004                 if (value)
1005                     addParameter(0, RecordingSwizzleTypes::WebGLTexture);
1006             },
1007             [&amp;] (const WebGLTransformFeedback* value) {
1008                 if (value)
1009                     addParameter(0, RecordingSwizzleTypes::WebGLTransformFeedback);
1010             },
1011             [&amp;] (const WebGLUniformLocation* value) {
1012                 if (value)
1013                     addParameter(0, RecordingSwizzleTypes::WebGLUniformLocation);
1014             },
1015             [&amp;] (const WebGLVertexArrayObject* value) {
1016                 if (value)
1017                     addParameter(0, RecordingSwizzleTypes::WebGLVertexArrayObject);
1018             },
1019 #endif
1020             [&amp;] (const RefPtr&lt;ArrayBuffer&gt;&amp; value) {
1021                 if (value)
1022                     addParameter(0, RecordingSwizzleTypes::TypedArray);
1023             },
1024             [&amp;] (const RefPtr&lt;ArrayBufferView&gt;&amp; value) {
1025                 if (value)
1026                     addParameter(0, RecordingSwizzleTypes::TypedArray);
1027             },
1028             [&amp;] (const RefPtr&lt;CanvasGradient&gt;&amp; value) {
1029                 if (value)
1030                     addParameter(indexForData(value), RecordingSwizzleTypes::CanvasGradient);
1031             },
1032             [&amp;] (const RefPtr&lt;CanvasPattern&gt;&amp; value) {
1033                 if (value)
1034                     addParameter(indexForData(value), RecordingSwizzleTypes::CanvasPattern);
1035             },
1036             [&amp;] (const RefPtr&lt;Float32Array&gt;&amp; value) {
1037                 if (value)
1038                     addParameter(0, RecordingSwizzleTypes::TypedArray);
1039             },
1040             [&amp;] (const RefPtr&lt;HTMLCanvasElement&gt;&amp; value) {
1041                 if (value)
1042                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
1043             },
1044             [&amp;] (const RefPtr&lt;HTMLImageElement&gt;&amp; value) {
1045                 if (value)
1046                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
1047             },
1048 #if ENABLE(OFFSCREEN_CANVAS)
1049             [&amp;] (const RefPtr&lt;OffscreenCanvas&gt;&amp; value) {
1050                 if (value)
1051                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
1052             },
1053 #endif
1054 #if ENABLE(VIDEO)
1055             [&amp;] (const RefPtr&lt;HTMLVideoElement&gt;&amp; value) {
1056                 if (value)
1057                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
1058             },
1059 #endif
1060 #if ENABLE(CSS_TYPED_OM)
1061             [&amp;] (const RefPtr&lt;TypedOMCSSImageValue&gt;&amp; value) {
1062                 if (value)
1063                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
1064             },
1065 #endif
1066             [&amp;] (const RefPtr&lt;ImageBitmap&gt;&amp; value) {
1067                 if (value)
1068                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap);
1069             },
1070             [&amp;] (const RefPtr&lt;ImageData&gt;&amp; value) {
1071                 if (value)
1072                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageData);
1073             },
1074             [&amp;] (const RefPtr&lt;Int32Array&gt;&amp; value) {
1075                 if (value)
1076                     addParameter(0, RecordingSwizzleTypes::TypedArray);
1077             },
1078             [&amp;] (const RefPtr&lt;Uint32Array&gt;&amp; value) {
1079                 if (value)
1080                     addParameter(0, RecordingSwizzleTypes::TypedArray);
1081             },
1082             [&amp;] (const CanvasImageSource&amp; value) {
1083                 WTF::visit(parseParameter, value);
1084             },
1085             [&amp;] (const CanvasRenderingContext2DBase::StyleVariant&amp; value) {
1086                 WTF::visit(parseParameter, value);
1087             },
1088 #if ENABLE(WEBGL)
1089             [&amp;] (const WebGLRenderingContextBase::BufferDataSource&amp; value) {
1090                 WTF::visit(parseParameter, value);
1091             },
1092             [&amp;] (const Optional&lt;WebGLRenderingContextBase::BufferDataSource&gt;&amp; value) {
1093                 if (value)
1094                     parseParameter(value.value());
1095             },
1096             [&amp;] (const WebGLRenderingContextBase::TexImageSource&amp; value) {
1097                 WTF::visit(parseParameter, value);
1098             },
1099             [&amp;] (const Optional&lt;WebGLRenderingContextBase::TexImageSource&gt;&amp; value) {
1100                 if (value)
1101                     parseParameter(value.value());
1102             },
1103 #endif
1104             [&amp;] (const Vector&lt;String&gt;&amp; value) {
1105                 auto deduplicated = value.map([&amp;] (const String&amp; item) {
1106                     return indexForData(item);
1107                 });
1108                 addParameter(buildArrayForVector(deduplicated).ptr(), RecordingSwizzleTypes::String);
1109             },
1110             [&amp;] (const Vector&lt;float&gt;&amp; value) { addParameter(buildArrayForVector(value).ptr(), RecordingSwizzleTypes::Array); },
1111             [&amp;] (const Vector&lt;uint32_t&gt;&amp; value) {
1112                 auto mapped = value.map([&amp;] (uint32_t item) {
1113                     return static_cast&lt;double&gt;(item);
1114                 });
1115                 addParameter(buildArrayForVector(mapped).ptr(), RecordingSwizzleTypes::Array);
1116             },
1117             [&amp;] (const Vector&lt;int32_t&gt;&amp; value) { addParameter(buildArrayForVector(value).ptr(), RecordingSwizzleTypes::Array); },
1118 #if ENABLE(WEBGL)
1119             [&amp;] (const WebGLRenderingContextBase::Float32List::VariantType&amp; value) {
1120                 WTF::visit(parseParameter, value);
1121             },
1122             [&amp;] (const WebGLRenderingContextBase::Int32List::VariantType&amp; value) {
1123                 WTF::visit(parseParameter, value);
1124             },
1125 #endif
1126 #if ENABLE(WEBGL2)
1127             [&amp;] (const WebGL2RenderingContext::Uint32List::VariantType&amp; value) {
1128                 WTF::visit(parseParameter, value);
1129             },
1130 #endif
1131             [&amp;] (const String&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::String); },
1132             [&amp;] (double value) { addParameter(value, RecordingSwizzleTypes::Number); },
1133             [&amp;] (float value) { addParameter(value, RecordingSwizzleTypes::Number); },
1134             [&amp;] (const Optional&lt;float&gt;&amp; value) {
1135                 if (value)
1136                     parseParameter(value.value());
1137             },
1138             [&amp;] (uint64_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
1139             [&amp;] (int64_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
1140             [&amp;] (uint32_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
1141             [&amp;] (int32_t value) { addParameter(value, RecordingSwizzleTypes::Number); },
1142             [&amp;] (uint8_t value) { addParameter(static_cast&lt;int&gt;(value), RecordingSwizzleTypes::Number); },
1143             [&amp;] (bool value) { addParameter(value, RecordingSwizzleTypes::Boolean); }
1144         );
1145     };
1146     for (auto&amp; parameter : parameters)
1147         parseParameter(parameter);
1148 
1149     action-&gt;addItem(WTFMove(parametersData));
1150     action-&gt;addItem(WTFMove(swizzleTypes));
1151 
1152     auto trace = Inspector::createScriptCallStack(JSExecState::currentState(), Inspector::ScriptCallStack::maxCallStackSizeToCapture);
1153     action-&gt;addItem(indexForData(trace.ptr()));
1154 
1155     return action;
1156 }
1157 
1158 Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildArrayForCanvasGradient(const CanvasGradient&amp; canvasGradient)
1159 {
1160     const auto&amp; gradient = canvasGradient.gradient();
1161 
1162     String type = gradient.type() == Gradient::Type::Radial ? &quot;radial-gradient&quot;_s : gradient.type() == Gradient::Type::Linear ? &quot;linear-gradient&quot;_s : &quot;conic-gradient&quot;_s;
1163 
1164     auto parameters = JSON::ArrayOf&lt;float&gt;::create();
1165     WTF::switchOn(gradient.data(),
1166         [&amp;parameters] (const Gradient::LinearData&amp; data) {
1167             parameters-&gt;addItem(data.point0.x());
1168             parameters-&gt;addItem(data.point0.y());
1169             parameters-&gt;addItem(data.point1.x());
1170             parameters-&gt;addItem(data.point1.y());
1171         },
1172         [&amp;parameters] (const Gradient::RadialData&amp; data) {
1173             parameters-&gt;addItem(data.point0.x());
1174             parameters-&gt;addItem(data.point0.y());
1175             parameters-&gt;addItem(data.startRadius);
1176             parameters-&gt;addItem(data.point1.x());
1177             parameters-&gt;addItem(data.point1.y());
1178             parameters-&gt;addItem(data.endRadius);
1179         },
1180         [&amp;parameters] (const Gradient::ConicData&amp; data) {
1181             parameters-&gt;addItem(data.point0.x());
1182             parameters-&gt;addItem(data.point0.y());
1183             parameters-&gt;addItem(data.angleRadians);
1184         }
1185     );
1186 
1187     auto stops = JSON::ArrayOf&lt;JSON::Value&gt;::create();
1188     for (auto&amp; colorStop : gradient.stops()) {
1189         auto stop = JSON::ArrayOf&lt;JSON::Value&gt;::create();
1190         stop-&gt;addItem(colorStop.offset);
1191         stop-&gt;addItem(indexForData(colorStop.color.cssText()));
1192         stops-&gt;addItem(WTFMove(stop));
1193     }
1194 
1195     auto array = JSON::ArrayOf&lt;JSON::Value&gt;::create();
1196     array-&gt;addItem(indexForData(type));
1197     array-&gt;addItem(WTFMove(parameters));
1198     array-&gt;addItem(WTFMove(stops));
1199     return array;
1200 }
1201 
1202 Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildArrayForCanvasPattern(const CanvasPattern&amp; canvasPattern)
1203 {
1204     Image&amp; tileImage = canvasPattern.pattern().tileImage();
1205     auto imageBuffer = ImageBuffer::create(tileImage.size(), RenderingMode::Unaccelerated);
1206     imageBuffer-&gt;context().drawImage(tileImage, FloatPoint(0, 0));
1207 
1208     String repeat;
1209     bool repeatX = canvasPattern.pattern().repeatX();
1210     bool repeatY = canvasPattern.pattern().repeatY();
1211     if (repeatX &amp;&amp; repeatY)
1212         repeat = &quot;repeat&quot;_s;
1213     else if (repeatX &amp;&amp; !repeatY)
1214         repeat = &quot;repeat-x&quot;_s;
1215     else if (!repeatX &amp;&amp; repeatY)
1216         repeat = &quot;repeat-y&quot;_s;
1217     else
1218         repeat = &quot;no-repeat&quot;_s;
1219 
1220     auto array = JSON::ArrayOf&lt;JSON::Value&gt;::create();
1221     array-&gt;addItem(indexForData(imageBuffer-&gt;toDataURL(&quot;image/png&quot;)));
1222     array-&gt;addItem(indexForData(repeat));
1223     return array;
1224 }
1225 
1226 Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildArrayForImageData(const ImageData&amp; imageData)
1227 {
1228     auto data = JSON::ArrayOf&lt;int&gt;::create();
1229     for (size_t i = 0; i &lt; imageData.data()-&gt;length(); ++i)
1230         data-&gt;addItem(imageData.data()-&gt;item(i));
1231 
1232     auto array = JSON::ArrayOf&lt;JSON::Value&gt;::create();
1233     array-&gt;addItem(WTFMove(data));
1234     array-&gt;addItem(imageData.width());
1235     array-&gt;addItem(imageData.height());
1236     return array;
1237 }
1238 
1239 } // namespace WebCore
1240 
    </pre>
  </body>
</html>
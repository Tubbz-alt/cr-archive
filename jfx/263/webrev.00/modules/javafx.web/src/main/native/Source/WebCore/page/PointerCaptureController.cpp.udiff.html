<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/page/PointerCaptureController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PlugInClient.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PointerCaptureController.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/PointerCaptureController.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -30,10 +30,11 @@</span>
  #include &quot;Document.h&quot;
  #include &quot;Element.h&quot;
  #include &quot;EventHandler.h&quot;
  #include &quot;EventNames.h&quot;
  #include &quot;EventTarget.h&quot;
<span class="udiff-line-added">+ #include &quot;HitTestResult.h&quot;</span>
  #include &quot;Page.h&quot;
  #include &quot;PointerEvent.h&quot;
  #include &lt;wtf/CheckedArithmetic.h&gt;
  
  #if ENABLE(POINTER_LOCK)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -147,24 +148,24 @@</span>
              // at the document.
              ASSERT(WTF::isInBounds&lt;PointerID&gt;(keyAndValue.key));
              auto pointerId = static_cast&lt;PointerID&gt;(keyAndValue.key);
              auto pointerType = capturingData.pointerType;
              releasePointerCapture(&amp;element, pointerId);
<span class="udiff-line-modified-removed">-             element.document().enqueueDocumentEvent(PointerEvent::create(eventNames().lostpointercaptureEvent, pointerId, pointerType));</span>
<span class="udiff-line-modified-added">+             // FIXME: Spec doesn&#39;t specify which task source to use.</span>
<span class="udiff-line-added">+             element.document().queueTaskToDispatchEvent(TaskSource::UserInteraction, PointerEvent::create(eventNames().lostpointercaptureEvent, pointerId, pointerType));</span>
              return;
          }
      }
  }
  
  void PointerCaptureController::reset()
  {
      m_activePointerIdsToCapturingData.clear();
<span class="udiff-line-modified-removed">- #if !ENABLE(TOUCH_EVENTS)</span>
<span class="udiff-line-modified-added">+ </span>
      CapturingData capturingData;
      capturingData.pointerType = PointerEvent::mousePointerType();
      m_activePointerIdsToCapturingData.add(mousePointerID, capturingData);
<span class="udiff-line-removed">- #endif</span>
  }
  
  void PointerCaptureController::touchWithIdentifierWasRemoved(PointerID pointerId)
  {
      m_activePointerIdsToCapturingData.remove(pointerId);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -181,20 +182,28 @@</span>
      auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
      return iterator != m_activePointerIdsToCapturingData.end() &amp;&amp; iterator-&gt;value.preventsCompatibilityMouseEvents;
  }
  
  #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
<span class="udiff-line-added">+ static bool hierarchyHasCapturingEventListeners(Element* target, const AtomString&amp; eventName)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     for (ContainerNode* curr = target; curr; curr = curr-&gt;parentInComposedTree()) {</span>
<span class="udiff-line-added">+         if (curr-&gt;hasCapturingEventListeners(eventName))</span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void PointerCaptureController::dispatchEventForTouchAtIndex(EventTarget&amp; target, const PlatformTouchEvent&amp; platformTouchEvent, unsigned index, bool isPrimary, WindowProxy&amp; view)
  {
<span class="udiff-line-modified-removed">-     auto dispatchOverOrOutEvent = [&amp;](const String&amp; type) {</span>
<span class="udiff-line-modified-removed">-         dispatchEvent(PointerEvent::create(type, platformTouchEvent, index, isPrimary, view), &amp;target);</span>
<span class="udiff-line-modified-added">+     ASSERT(is&lt;Element&gt;(target));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     auto dispatchOverOrOutEvent = [&amp;](const String&amp; type, EventTarget* target) {</span>
<span class="udiff-line-added">+         dispatchEvent(PointerEvent::create(type, platformTouchEvent, index, isPrimary, view), target);</span>
      };
  
      auto dispatchEnterOrLeaveEvent = [&amp;](const String&amp; type) {
<span class="udiff-line-removed">-         if (!is&lt;Element&gt;(&amp;target))</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">- </span>
          auto* targetElement = &amp;downcast&lt;Element&gt;(target);
  
          bool hasCapturingListenerInHierarchy = false;
          for (ContainerNode* curr = targetElement; curr; curr = curr-&gt;parentInComposedTree()) {
              if (curr-&gt;hasCapturingEventListeners(type)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -218,26 +227,78 @@</span>
          }
      };
  
      auto pointerEvent = PointerEvent::create(platformTouchEvent, index, isPrimary, view);
  
<span class="udiff-line-added">+     auto&amp; capturingData = ensureCapturingDataForPointerEvent(pointerEvent);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Check if the target changed, which would require dispatching boundary events.</span>
<span class="udiff-line-added">+     RefPtr&lt;Element&gt; previousTarget = capturingData.previousTarget;</span>
<span class="udiff-line-added">+     RefPtr&lt;Element&gt; currentTarget = downcast&lt;Element&gt;(&amp;target);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     capturingData.previousTarget = currentTarget;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (pointerEvent-&gt;type() == eventNames().pointermoveEvent &amp;&amp; previousTarget != currentTarget) {</span>
<span class="udiff-line-added">+         // The pointerenter and pointerleave events are only dispatched if there is a capturing event listener on an ancestor</span>
<span class="udiff-line-added">+         // or a normal event listener on the element itself since those events do not bubble.</span>
<span class="udiff-line-added">+         // This optimization is necessary since these events can cause O(n^2) capturing event-handler checks. This follows the</span>
<span class="udiff-line-added">+         // code for similar mouse events in EventHandler::updateMouseEventTargetNode().</span>
<span class="udiff-line-added">+         bool hasCapturingPointerEnterListener = hierarchyHasCapturingEventListeners(currentTarget.get(), eventNames().pointerenterEvent);</span>
<span class="udiff-line-added">+         bool hasCapturingPointerLeaveListener = hierarchyHasCapturingEventListeners(previousTarget.get(), eventNames().pointerleaveEvent);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Vector&lt;Ref&lt;Element&gt;, 32&gt; leftElementsChain;</span>
<span class="udiff-line-added">+         for (Element* element = previousTarget.get(); element; element = element-&gt;parentElementInComposedTree())</span>
<span class="udiff-line-added">+             leftElementsChain.append(*element);</span>
<span class="udiff-line-added">+         Vector&lt;Ref&lt;Element&gt;, 32&gt; enteredElementsChain;</span>
<span class="udiff-line-added">+         for (Element* element = currentTarget.get(); element; element = element-&gt;parentElementInComposedTree())</span>
<span class="udiff-line-added">+             enteredElementsChain.append(*element);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (!leftElementsChain.isEmpty() &amp;&amp; !enteredElementsChain.isEmpty() &amp;&amp; leftElementsChain.last().ptr() == enteredElementsChain.last().ptr()) {</span>
<span class="udiff-line-added">+             size_t minHeight = std::min(leftElementsChain.size(), enteredElementsChain.size());</span>
<span class="udiff-line-added">+             size_t i;</span>
<span class="udiff-line-added">+             for (i = 0; i &lt; minHeight; ++i) {</span>
<span class="udiff-line-added">+                 if (leftElementsChain[leftElementsChain.size() - i - 1].ptr() != enteredElementsChain[enteredElementsChain.size() - i - 1].ptr())</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             leftElementsChain.shrink(leftElementsChain.size() - i);</span>
<span class="udiff-line-added">+             enteredElementsChain.shrink(enteredElementsChain.size() - i);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (previousTarget)</span>
<span class="udiff-line-added">+             dispatchOverOrOutEvent(eventNames().pointeroutEvent, previousTarget.get());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         for (auto&amp; chain : leftElementsChain) {</span>
<span class="udiff-line-added">+             if (hasCapturingPointerLeaveListener || chain-&gt;hasEventListeners(eventNames().pointerleaveEvent))</span>
<span class="udiff-line-added">+                 dispatchEvent(PointerEvent::create(eventNames().pointerleaveEvent, platformTouchEvent, index, isPrimary, view), chain.ptr());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (currentTarget)</span>
<span class="udiff-line-added">+             dispatchOverOrOutEvent(eventNames().pointeroverEvent, currentTarget.get());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         for (auto&amp; chain : WTF::makeReversedRange(enteredElementsChain)) {</span>
<span class="udiff-line-added">+             if (hasCapturingPointerEnterListener || chain-&gt;hasEventListeners(eventNames().pointerenterEvent))</span>
<span class="udiff-line-added">+                 dispatchEvent(PointerEvent::create(eventNames().pointerenterEvent, platformTouchEvent, index, isPrimary, view), chain.ptr());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      if (pointerEvent-&gt;type() == eventNames().pointerdownEvent) {
          // https://w3c.github.io/pointerevents/#the-pointerdown-event
          // For input devices that do not support hover, a user agent MUST also fire a pointer event named pointerover followed by a pointer event named
          // pointerenter prior to dispatching the pointerdown event.
<span class="udiff-line-modified-removed">-         dispatchOverOrOutEvent(eventNames().pointeroverEvent);</span>
<span class="udiff-line-modified-added">+         dispatchOverOrOutEvent(eventNames().pointeroverEvent, currentTarget.get());</span>
          dispatchEnterOrLeaveEvent(eventNames().pointerenterEvent);
      }
  
      dispatchEvent(pointerEvent, &amp;target);
  
      if (pointerEvent-&gt;type() == eventNames().pointerupEvent) {
          // https://w3c.github.io/pointerevents/#the-pointerup-event
          // For input devices that do not support hover, a user agent MUST also fire a pointer event named pointerout followed by a
          // pointer event named pointerleave after dispatching the pointerup event.
<span class="udiff-line-modified-removed">-         dispatchOverOrOutEvent(eventNames().pointeroutEvent);</span>
<span class="udiff-line-modified-added">+         dispatchOverOrOutEvent(eventNames().pointeroutEvent, currentTarget.get());</span>
          dispatchEnterOrLeaveEvent(eventNames().pointerleaveEvent);
<span class="udiff-line-added">+         capturingData.previousTarget = nullptr;</span>
      }
  }
  #endif
  
  RefPtr&lt;PointerEvent&gt; PointerCaptureController::pointerEventForMouseEvent(const MouseEvent&amp; mouseEvent)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -323,17 +384,24 @@</span>
      // Direct manipulation devices should behave exactly as if setPointerCapture was called on the target element just before the invocation of any
      // pointerdown listeners. The hasPointerCapture API may be used (eg. within any pointerdown listener) to determine whether this has occurred. If
      // releasePointerCapture is not called for the pointer before the next pointer event is fired, then a gotpointercapture event will be dispatched
      // to the target (as normal) indicating that capture is active.
  
<span class="udiff-line-modified-removed">-     CapturingData capturingData;</span>
<span class="udiff-line-removed">-     capturingData.pointerType = event.pointerType();</span>
<span class="udiff-line-modified-added">+     auto&amp; capturingData = ensureCapturingDataForPointerEvent(event);</span>
      capturingData.pointerIsPressed = true;
<span class="udiff-line-removed">-     m_activePointerIdsToCapturingData.set(pointerId, capturingData);</span>
      setPointerCapture(downcast&lt;Element&gt;(target), pointerId);
  }
  
<span class="udiff-line-added">+ PointerCaptureController::CapturingData&amp; PointerCaptureController::ensureCapturingDataForPointerEvent(const PointerEvent&amp; event)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return m_activePointerIdsToCapturingData.ensure(event.pointerId(), [&amp;event] {</span>
<span class="udiff-line-added">+         CapturingData capturingData;</span>
<span class="udiff-line-added">+         capturingData.pointerType = event.pointerType();</span>
<span class="udiff-line-added">+         return capturingData;</span>
<span class="udiff-line-added">+     }).iterator-&gt;value;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void PointerCaptureController::pointerEventWasDispatched(const PointerEvent&amp; event)
  {
      auto iterator = m_activePointerIdsToCapturingData.find(event.pointerId());
      if (iterator != m_activePointerIdsToCapturingData.end()) {
          auto&amp; capturingData = iterator-&gt;value;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -388,10 +456,14 @@</span>
          return;
  
      capturingData.pendingTargetOverride = nullptr;
      capturingData.cancelled = true;
  
<span class="udiff-line-added">+ #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
<span class="udiff-line-added">+     capturingData.previousTarget = nullptr;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
      auto&amp; target = capturingData.targetOverride;
      if (!target)
          target = m_page.mainFrame().eventHandler().hitTestResultAtPoint(documentPoint, HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent | HitTestRequest::AllowChildFrameContent).innerNonSharedElement();
  
      if (!target)
</pre>
<center><a href="PlugInClient.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PointerCaptureController.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
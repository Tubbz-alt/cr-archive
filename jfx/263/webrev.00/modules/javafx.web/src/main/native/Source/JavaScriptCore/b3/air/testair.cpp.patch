diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/testair.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/testair.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/testair.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/testair.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -36,12 +36,14 @@
 #include "B3PatchpointSpecial.h"
 #include "CCallHelpers.h"
 #include "InitializeThreading.h"
 #include "JSCInlines.h"
 #include "LinkBuffer.h"
+#include "ProbeContext.h"
 #include "PureNaN.h"
 #include <cmath>
+#include <regex>
 #include <string>
 #include <wtf/Lock.h>
 #include <wtf/NumberOfCores.h>
 #include <wtf/StdMap.h>
 #include <wtf/Threading.h>
@@ -2061,10 +2063,166 @@
 
     int32_t r = compileAndRun<int32_t>(proc, a);
     CHECK(r == a + b);
 }
 
+inline Vector<String> matchAll(const CString& source, std::regex regex)
+{
+    Vector<String> matches;
+    std::smatch match;
+    for (std::string str = source.data(); std::regex_search(str, match, regex); str = match.suffix()) {
+        ASSERT(match.size() == 1);
+        matches.append(match[0].str().c_str());
+    }
+    return matches;
+}
+
+void testElideSimpleMove()
+{
+    for (unsigned tmpCount = 1; tmpCount < 100; tmpCount++) {
+        B3::Procedure proc;
+        Code& code = proc.code();
+
+        BasicBlock* root = code.addBlock();
+
+        Tmp tmp = code.newTmp(B3::GP);
+        root->append(Move, nullptr, Tmp(GPRInfo::argumentGPR0), tmp);
+        for (unsigned i = 0; i < tmpCount; i++) {
+            Tmp newTmp = code.newTmp(B3::GP);
+            root->append(Move, nullptr, tmp, newTmp);
+            tmp = newTmp;
+        }
+        root->append(Move, nullptr, tmp, Tmp(GPRInfo::returnValueGPR));
+        root->append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));
+
+        auto compilation = compile(proc);
+        CString disassembly = compilation->disassembly();
+        std::regex findRRMove(isARM64() ? "mov r\\d+, r\\d+\\n" : "mov %\\w+, %\\w+\\n");
+        auto result = matchAll(disassembly, findRRMove);
+        // sp -> fp; arg0 -> ret0; fp -> sp
+        // fp -> sp only happens in O0 because we don't actually need to move the stack in general.
+        CHECK(result.size() == 2 + !Options::defaultB3OptLevel());
+    }
+}
+
+void testElideHandlesEarlyClobber()
+{
+    B3::Procedure proc;
+    Code& code = proc.code();
+
+    BasicBlock* root = code.addBlock();
+
+    const unsigned tmpCount = RegisterSet::allGPRs().numberOfSetRegisters() * 2;
+    Vector<Tmp> tmps(tmpCount);
+    for (unsigned i = 0; i < tmpCount; ++i) {
+        tmps[i] = code.newTmp(B3::GP);
+        root->append(Move, nullptr, Arg::imm(i), tmps[i]);
+    }
+
+    RegisterSet registers = RegisterSet::allGPRs();
+    registers.exclude(RegisterSet::reservedHardwareRegisters());
+    registers.exclude(RegisterSet::stackRegisters());
+    Reg firstCalleeSave;
+    Reg lastCalleeSave;
+    auto* patch = proc.add<B3::PatchpointValue>(B3::Int32, B3::Origin());
+    patch->clobberEarly(registers);
+    for (Reg reg : registers) {
+        if (!firstCalleeSave)
+            firstCalleeSave = reg;
+        lastCalleeSave = reg;
+    }
+    ASSERT(firstCalleeSave != lastCalleeSave);
+    patch->earlyClobbered().clear(firstCalleeSave);
+    patch->resultConstraints.append({ B3::ValueRep::reg(firstCalleeSave) });
+    patch->earlyClobbered().clear(lastCalleeSave);
+    patch->clobber(RegisterSet(lastCalleeSave));
+
+    patch->setGenerator([=] (CCallHelpers& jit, const JSC::B3::StackmapGenerationParams&) {
+        jit.probe([=] (Probe::Context& context) {
+            for (Reg reg : registers)
+                context.gpr(reg.gpr()) = 0;
+        });
+    });
+
+    Inst inst(Patch, patch, Arg::special(code.addSpecial(WTF::makeUnique<JSC::B3::PatchpointSpecial>())));
+    inst.args.append(Tmp(firstCalleeSave));
+    root->appendInst(WTFMove(inst));
+
+    Tmp result = code.newTmp(B3::GP);
+    root->append(Move, nullptr, tmps[0], result);
+    for (Tmp tmp : tmps)
+        root->append(Add32, nullptr, tmp, result);
+
+    root->append(Move, nullptr, result, Tmp(GPRInfo::returnValueGPR));
+    root->append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));
+
+    auto runResult = compileAndRun<uint32_t>(proc);
+    CHECK(runResult == (tmpCount * (tmpCount - 1)) / 2);
+}
+
+void testElideMoveThenRealloc()
+{
+    RegisterSet registers = RegisterSet::allGPRs();
+    registers.exclude(RegisterSet::stackRegisters());
+    registers.exclude(RegisterSet::reservedHardwareRegisters());
+
+    for (Reg reg : registers) {
+        B3::Procedure proc;
+        Code& code = proc.code();
+
+        BasicBlock* root = code.addBlock();
+        BasicBlock* taken = code.addBlock();
+        BasicBlock* notTaken = code.addBlock();
+        BasicBlock* notTakenReturn = code.addBlock();
+        BasicBlock* ret = code.addBlock();
+        BasicBlock* continuation = code.addBlock();
+
+        Tmp tmp = code.newTmp(B3::GP);
+        {
+            root->append(Move, nullptr, Arg::imm(1), Tmp(reg));
+
+            root->append(BranchTest32, nullptr, Arg::resCond(MacroAssembler::NonZero), Tmp(reg), Arg::bitImm(-1));
+            root->setSuccessors(taken, notTaken);
+        }
+
+        {
+            taken->append(Jump, nullptr);
+            taken->setSuccessors(continuation);
+        }
+
+        {
+            notTaken->append(BranchTest32, nullptr, Arg::resCond(MacroAssembler::NonZero), Tmp(reg), Arg::bitImm(-1));
+            notTaken->setSuccessors(continuation, notTakenReturn);
+        }
+
+        {
+            tmp = code.newTmp(B3::GP);
+            continuation->append(Move, nullptr, Arg::imm(42), tmp);
+            continuation->append(BranchTest32, nullptr, Arg::resCond(MacroAssembler::NonZero), tmp, Arg::bitImm(-1));
+            continuation->setSuccessors(ret, notTakenReturn);
+        }
+
+        {
+            tmp = code.newTmp(B3::GP);
+            ret->append(Move, nullptr, Arg::imm(42), tmp);
+            ret->append(Move, nullptr, tmp, Tmp(reg));
+            ret->append(Move, nullptr, Tmp(reg), Tmp(GPRInfo::returnValueGPR));
+            ret->append(Add32, nullptr, Tmp(reg), Tmp(reg));
+            ret->append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));
+        }
+
+        {
+            notTakenReturn->append(Move, nullptr, Tmp(reg), Tmp(GPRInfo::returnValueGPR));
+            notTakenReturn->append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));
+        }
+
+        code.resetReachability();
+        auto runResult = compileAndRun<uint32_t>(proc);
+        CHECK(runResult == static_cast<unsigned>(42 + (42 * (reg == GPRInfo::returnValueGPR))));
+    }
+}
+
 #define PREFIX "O", Options::defaultB3OptLevel(), ": "
 
 #define RUN(test) do {                                 \
         if (!shouldRun(#test))                         \
             break;                                     \
@@ -2149,10 +2307,14 @@
     RUN(testArgumentRegPinned3());
 
     RUN(testLea32());
     RUN(testLea64());
 
+    RUN(testElideSimpleMove());
+    RUN(testElideHandlesEarlyClobber());
+    RUN(testElideMoveThenRealloc());
+
     if (tasks.isEmpty())
         usage();
 
     Lock lock;
 

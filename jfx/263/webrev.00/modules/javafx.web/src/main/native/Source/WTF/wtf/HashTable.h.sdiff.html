<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/HashTable.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HashTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HashTraits.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/HashTable.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2005, 2006, 2007, 2008, 2011, 2012, 2015 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2008 David Levin &lt;levin@chromium.org&gt;
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public License
  16  * along with this library; see the file COPYING.LIB.  If not, write to
  17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  18  * Boston, MA 02110-1301, USA.
  19  *
  20  */
  21 
  22 #pragma once
  23 
  24 #include &lt;atomic&gt;
  25 #include &lt;iterator&gt;
  26 #include &lt;mutex&gt;
  27 #include &lt;string.h&gt;
  28 #include &lt;type_traits&gt;
  29 #include &lt;utility&gt;
  30 #include &lt;wtf/Assertions.h&gt;

  31 #include &lt;wtf/FastMalloc.h&gt;
  32 #include &lt;wtf/HashTraits.h&gt;
  33 #include &lt;wtf/Lock.h&gt;
  34 #include &lt;wtf/MathExtras.h&gt;
  35 #include &lt;wtf/RandomNumber.h&gt;
  36 #include &lt;wtf/StdLibExtras.h&gt;
  37 #include &lt;wtf/ValueCheck.h&gt;
  38 
  39 #define DUMP_HASHTABLE_STATS 0
  40 #define DUMP_HASHTABLE_STATS_PER_TABLE 0
  41 
  42 #if DUMP_HASHTABLE_STATS_PER_TABLE
  43 #include &lt;wtf/DataLog.h&gt;
  44 #endif
  45 
  46 namespace WTF {
  47 


  48 // Enables internal WTF consistency checks that are invoked automatically. Non-WTF callers can call checkTableConsistency() even if internal checks are disabled.
  49 #define CHECK_HASHTABLE_CONSISTENCY 0
  50 
  51 #ifdef NDEBUG
  52 #define CHECK_HASHTABLE_ITERATORS 0
  53 #define CHECK_HASHTABLE_USE_AFTER_DESTRUCTION 0
  54 #else
  55 #define CHECK_HASHTABLE_ITERATORS 1
  56 #define CHECK_HASHTABLE_USE_AFTER_DESTRUCTION 1
  57 #endif
  58 
  59 #if DUMP_HASHTABLE_STATS
  60 
  61     struct HashTableStats {
  62         // The following variables are all atomically incremented when modified.
  63         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numAccesses;
  64         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numRehashes;
  65         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numRemoves;
  66         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numReinserts;
  67 
</pre>
<hr />
<pre>
 283 
 284     template&lt;typename ValueTraits, typename HashFunctions&gt; class IdentityHashTranslator {
 285     public:
 286         template&lt;typename T&gt; static unsigned hash(const T&amp; key) { return HashFunctions::hash(key); }
 287         template&lt;typename T, typename U&gt; static bool equal(const T&amp; a, const U&amp; b) { return HashFunctions::equal(a, b); }
 288         template&lt;typename T, typename U, typename V&gt; static void translate(T&amp; location, const U&amp;, V&amp;&amp; value)
 289         {
 290             ValueTraits::assignToEmpty(location, std::forward&lt;V&gt;(value));
 291         }
 292     };
 293 
 294     template&lt;typename IteratorType&gt; struct HashTableAddResult {
 295         HashTableAddResult() : isNewEntry(false) { }
 296         HashTableAddResult(IteratorType iter, bool isNewEntry) : iterator(iter), isNewEntry(isNewEntry) { }
 297         IteratorType iterator;
 298         bool isNewEntry;
 299 
 300         explicit operator bool() const { return isNewEntry; }
 301     };
 302 









































 303     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 304     class HashTable {
 305     public:
 306         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 307         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 308         typedef Traits ValueTraits;
 309         typedef Key KeyType;
 310         typedef Value ValueType;
 311         typedef IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType;
 312         typedef HashTableAddResult&lt;iterator&gt; AddResult;
 313 


 314 #if DUMP_HASHTABLE_STATS_PER_TABLE
 315         struct Stats {
 316             WTF_MAKE_STRUCT_FAST_ALLOCATED;
 317 
 318             Stats()
 319                 : numAccesses(0)
 320                 , numRehashes(0)
 321                 , numRemoves(0)
 322                 , numReinserts(0)
 323                 , maxCollisions(0)
 324                 , numCollisions(0)
 325                 , collisionGraph()
 326             {
 327             }
 328 
 329             unsigned numAccesses;
 330             unsigned numRehashes;
 331             unsigned numRemoves;
 332             unsigned numReinserts;
 333 
</pre>
<hr />
<pre>
 364 
 365 #if PLATFORM(JAVA)
 366 #if CHECK_HASHTABLE_ITERATORS
 367             // does the same as invalidateIterators() but without
 368             // taking a lock since the destructor may be invoked
 369             // during atexit() handler which may lead to crash
 370             const_iterator* next;
 371             for (const_iterator* p = m_iterators; p; p = next) {
 372                 next = p-&gt;m_next;
 373                 p-&gt;m_table = 0;
 374                 p-&gt;m_next = 0;
 375                 p-&gt;m_previous = 0;
 376             }
 377             m_iterators = 0;
 378 #endif
 379 #else
 380             invalidateIterators();
 381 #endif
 382 
 383             if (m_table)
<span class="line-modified"> 384                 deallocateTable(m_table, m_tableSize);</span>
 385 #if CHECK_HASHTABLE_USE_AFTER_DESTRUCTION
 386             m_table = (ValueType*)(uintptr_t)0xbbadbeef;
 387 #endif
 388         }
 389 
 390         HashTable(const HashTable&amp;);
 391         void swap(HashTable&amp;);
 392         HashTable&amp; operator=(const HashTable&amp;);
 393 
 394         HashTable(HashTable&amp;&amp;);
 395         HashTable&amp; operator=(HashTable&amp;&amp;);
 396 
 397         // When the hash table is empty, just return the same iterator for end as for begin.
 398         // This is more efficient because we don&#39;t have to skip all the empty and deleted
 399         // buckets, and iterating an empty table is a common case that&#39;s worth optimizing.
 400         iterator begin() { return isEmpty() ? end() : makeIterator(m_table); }
<span class="line-modified"> 401         iterator end() { return makeKnownGoodIterator(m_table + m_tableSize); }</span>
 402         const_iterator begin() const { return isEmpty() ? end() : makeConstIterator(m_table); }
<span class="line-modified"> 403         const_iterator end() const { return makeKnownGoodConstIterator(m_table + m_tableSize); }</span>
 404 
 405         iterator random()
 406         {
 407             if (isEmpty())
 408                 return end();
 409 
 410             while (1) {
<span class="line-modified"> 411                 auto&amp; bucket = m_table[weakRandomUint32() &amp; m_tableSizeMask];</span>
 412                 if (!isEmptyOrDeletedBucket(bucket))
 413                     return makeKnownGoodIterator(&amp;bucket);
 414             };
 415         }
 416 
 417         const_iterator random() const { return static_cast&lt;const_iterator&gt;(const_cast&lt;HashTable*&gt;(this)-&gt;random()); }
 418 
<span class="line-modified"> 419         unsigned size() const { return m_keyCount; }</span>
<span class="line-modified"> 420         unsigned capacity() const { return m_tableSize; }</span>
<span class="line-modified"> 421         bool isEmpty() const { return !m_keyCount; }</span>
 422 
 423         void reserveInitialCapacity(unsigned keyCount)
 424         {
 425             ASSERT(!m_table);
<span class="line-modified"> 426             ASSERT(!m_tableSize);</span>
<span class="line-removed"> 427             ASSERT(!m_deletedCount);</span>
 428 
 429             unsigned minimumTableSize = KeyTraits::minimumTableSize;
 430             unsigned newTableSize = std::max(minimumTableSize, computeBestTableSize(keyCount));
 431 
<span class="line-removed"> 432             m_tableSize = newTableSize;</span>
<span class="line-removed"> 433             m_tableSizeMask = newTableSize - 1;</span>
 434             m_table = allocateTable(newTableSize);




 435         }
 436 
 437         AddResult add(const ValueType&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); }
 438         AddResult add(ValueType&amp;&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); }
 439 
 440         // A special version of add() that finds the object by hashing and comparing
 441         // with some other type, to avoid the cost of type conversion if the object is already
 442         // in the table.
 443         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult add(T&amp;&amp; key, Extra&amp;&amp;);
 444         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp;);
 445 
 446         iterator find(const KeyType&amp; key) { return find&lt;IdentityTranslatorType&gt;(key); }
 447         const_iterator find(const KeyType&amp; key) const { return find&lt;IdentityTranslatorType&gt;(key); }
 448         bool contains(const KeyType&amp; key) const { return contains&lt;IdentityTranslatorType&gt;(key); }
 449 
 450         template&lt;typename HashTranslator, typename T&gt; iterator find(const T&amp;);
 451         template&lt;typename HashTranslator, typename T&gt; const_iterator find(const T&amp;) const;
 452         template&lt;typename HashTranslator, typename T&gt; bool contains(const T&amp;) const;
 453 
 454         void remove(const KeyType&amp;);
 455         void remove(iterator);
 456         void removeWithoutEntryConsistencyCheck(iterator);
 457         void removeWithoutEntryConsistencyCheck(const_iterator);
 458         template&lt;typename Functor&gt;
 459         bool removeIf(const Functor&amp;);
 460         void clear();
 461 
 462         static bool isEmptyBucket(const ValueType&amp; value) { return isHashTraitsEmptyValue&lt;KeyTraits&gt;(Extractor::extract(value)); }
 463         static bool isReleasedWeakBucket(const ValueType&amp; value) { return isHashTraitsReleasedWeakValue&lt;KeyTraits&gt;(Extractor::extract(value)); }
 464         static bool isDeletedBucket(const ValueType&amp; value) { return KeyTraits::isDeletedValue(Extractor::extract(value)); }
 465         static bool isEmptyOrDeletedBucket(const ValueType&amp; value) { return isEmptyBucket(value) || isDeletedBucket(value); }
 466 
 467         ValueType* lookup(const Key&amp; key) { return lookup&lt;IdentityTranslatorType&gt;(key); }
 468         template&lt;typename HashTranslator, typename T&gt; ValueType* lookup(const T&amp;);
 469         template&lt;typename HashTranslator, typename T&gt; ValueType* inlineLookup(const T&amp;);
 470 
<span class="line-modified"> 471 #if !ASSERT_DISABLED</span>
 472         void checkTableConsistency() const;
 473 #else
 474         static void checkTableConsistency() { }
 475 #endif
 476 #if CHECK_HASHTABLE_CONSISTENCY
 477         void internalCheckTableConsistency() const { checkTableConsistency(); }
 478         void internalCheckTableConsistencyExceptSize() const { checkTableConsistencyExceptSize(); }
 479 #else
 480         static void internalCheckTableConsistencyExceptSize() { }
 481         static void internalCheckTableConsistency() { }
 482 #endif
 483 
 484     private:
 485         static ValueType* allocateTable(unsigned size);
<span class="line-modified"> 486         static void deallocateTable(ValueType* table, unsigned size);</span>
 487 
 488         typedef std::pair&lt;ValueType*, bool&gt; LookupType;
 489         typedef std::pair&lt;LookupType, unsigned&gt; FullLookupType;
 490 
 491         LookupType lookupForWriting(const Key&amp; key) { return lookupForWriting&lt;IdentityTranslatorType&gt;(key); };
 492         template&lt;typename HashTranslator, typename T&gt; FullLookupType fullLookupForWriting(const T&amp;);
 493         template&lt;typename HashTranslator, typename T&gt; LookupType lookupForWriting(const T&amp;);
 494 
 495         template&lt;typename HashTranslator, typename T, typename Extra&gt; void addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp;);
 496 
 497         template&lt;typename HashTranslator, typename T&gt; void checkKey(const T&amp;);
 498 
 499         void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);
 500         void removeAndInvalidate(ValueType*);
 501         void remove(ValueType*);
 502 
 503         static constexpr unsigned computeBestTableSize(unsigned keyCount);
<span class="line-modified"> 504         bool shouldExpand() const { return (m_keyCount + m_deletedCount) * m_maxLoad &gt;= m_tableSize; }</span>
<span class="line-modified"> 505         bool mustRehashInPlace() const { return m_keyCount * m_minLoad &lt; m_tableSize * 2; }</span>
<span class="line-modified"> 506         bool shouldShrink() const { return m_keyCount * m_minLoad &lt; m_tableSize &amp;&amp; m_tableSize &gt; KeyTraits::minimumTableSize; }</span>
 507         ValueType* expand(ValueType* entry = nullptr);
<span class="line-modified"> 508         void shrink() { rehash(m_tableSize / 2, nullptr); }</span>
 509         void shrinkToBestSize();
 510 
 511         void deleteReleasedWeakBuckets();
 512 
 513         ValueType* rehash(unsigned newTableSize, ValueType* entry);
 514         ValueType* reinsert(ValueType&amp;&amp;);
 515 
 516         static void initializeBucket(ValueType&amp; bucket);
 517         static void deleteBucket(ValueType&amp; bucket) { hashTraitsDeleteBucket&lt;Traits&gt;(bucket); }
 518 
 519         FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)
 520             { return FullLookupType(LookupType(position, found), hash); }
 521 
<span class="line-modified"> 522         iterator makeIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize); }</span>
<span class="line-modified"> 523         const_iterator makeConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize); }</span>
<span class="line-modified"> 524         iterator makeKnownGoodIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }</span>
<span class="line-modified"> 525         const_iterator makeKnownGoodConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }</span>
 526 
<span class="line-modified"> 527 #if !ASSERT_DISABLED</span>
 528         void checkTableConsistencyExceptSize() const;
 529 #else
 530         static void checkTableConsistencyExceptSize() { }
 531 #endif
 532 
 533 #if CHECK_HASHTABLE_ITERATORS
 534         void invalidateIterators();
 535 #else
 536         static void invalidateIterators() { }
 537 #endif
 538 
<span class="line-modified"> 539         static const unsigned m_maxLoad = 2;</span>
<span class="line-modified"> 540         static const unsigned m_minLoad = 6;</span>
<span class="line-modified"> 541 </span>
<span class="line-modified"> 542         ValueType* m_table;</span>
<span class="line-modified"> 543         unsigned m_tableSize;</span>
<span class="line-modified"> 544         unsigned m_tableSizeMask;</span>
<span class="line-modified"> 545         unsigned m_keyCount;</span>
<span class="line-modified"> 546         unsigned m_deletedCount;</span>

















 547 
 548 #if CHECK_HASHTABLE_ITERATORS
 549     public:
 550         // All access to m_iterators should be guarded with m_mutex.
 551         mutable const_iterator* m_iterators;
 552         // Use std::unique_ptr so HashTable can still be memmove&#39;d or memcpy&#39;ed.
 553         mutable std::unique_ptr&lt;Lock&gt; m_mutex;
 554 #endif
 555 
 556 #if DUMP_HASHTABLE_STATS_PER_TABLE
 557     public:
 558         mutable std::unique_ptr&lt;Stats&gt; m_stats;
 559 #endif
 560     };
 561 
<span class="line-removed"> 562     // Set all the bits to one after the most significant bit: 00110101010 -&gt; 00111111111.</span>
<span class="line-removed"> 563     template&lt;unsigned size&gt; struct OneifyLowBits;</span>
<span class="line-removed"> 564     template&lt;&gt;</span>
<span class="line-removed"> 565     struct OneifyLowBits&lt;0&gt; {</span>
<span class="line-removed"> 566         static const unsigned value = 0;</span>
<span class="line-removed"> 567     };</span>
<span class="line-removed"> 568     template&lt;unsigned number&gt;</span>
<span class="line-removed"> 569     struct OneifyLowBits {</span>
<span class="line-removed"> 570         static const unsigned value = number | OneifyLowBits&lt;(number &gt;&gt; 1)&gt;::value;</span>
<span class="line-removed"> 571     };</span>
<span class="line-removed"> 572     // Compute the first power of two integer that is an upper bound of the parameter &#39;number&#39;.</span>
<span class="line-removed"> 573     template&lt;unsigned number&gt;</span>
<span class="line-removed"> 574     struct UpperPowerOfTwoBound {</span>
<span class="line-removed"> 575         static const unsigned value = (OneifyLowBits&lt;number - 1&gt;::value + 1) * 2;</span>
<span class="line-removed"> 576     };</span>
<span class="line-removed"> 577 </span>
<span class="line-removed"> 578     // Because power of two numbers are the limit of maxLoad, their capacity is twice the</span>
<span class="line-removed"> 579     // UpperPowerOfTwoBound, or 4 times their values.</span>
<span class="line-removed"> 580     template&lt;unsigned size, bool isPowerOfTwo&gt; struct HashTableCapacityForSizeSplitter;</span>
<span class="line-removed"> 581     template&lt;unsigned size&gt;</span>
<span class="line-removed"> 582     struct HashTableCapacityForSizeSplitter&lt;size, true&gt; {</span>
<span class="line-removed"> 583         static const unsigned value = size * 4;</span>
<span class="line-removed"> 584     };</span>
<span class="line-removed"> 585     template&lt;unsigned size&gt;</span>
<span class="line-removed"> 586     struct HashTableCapacityForSizeSplitter&lt;size, false&gt; {</span>
<span class="line-removed"> 587         static const unsigned value = UpperPowerOfTwoBound&lt;size&gt;::value;</span>
<span class="line-removed"> 588     };</span>
<span class="line-removed"> 589 </span>
<span class="line-removed"> 590     // HashTableCapacityForSize computes the upper power of two capacity to hold the size parameter.</span>
<span class="line-removed"> 591     // This is done at compile time to initialize the HashTraits.</span>
<span class="line-removed"> 592     template&lt;unsigned size&gt;</span>
<span class="line-removed"> 593     struct HashTableCapacityForSize {</span>
<span class="line-removed"> 594         static const unsigned value = HashTableCapacityForSizeSplitter&lt;size, !(size &amp; (size - 1))&gt;::value;</span>
<span class="line-removed"> 595         COMPILE_ASSERT(size &gt; 0, HashTableNonZeroMinimumCapacity);</span>
<span class="line-removed"> 596         COMPILE_ASSERT(!static_cast&lt;unsigned&gt;(value &gt;&gt; 31), HashTableNoCapacityOverflow);</span>
<span class="line-removed"> 597         COMPILE_ASSERT(value &gt; (2 * size), HashTableCapacityHoldsContentSize);</span>
<span class="line-removed"> 598     };</span>
<span class="line-removed"> 599 </span>
 600     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 601     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable()
<span class="line-modified"> 602         : m_table(0)</span>
<span class="line-removed"> 603         , m_tableSize(0)</span>
<span class="line-removed"> 604         , m_tableSizeMask(0)</span>
<span class="line-removed"> 605         , m_keyCount(0)</span>
<span class="line-removed"> 606         , m_deletedCount(0)</span>
 607 #if CHECK_HASHTABLE_ITERATORS
 608         , m_iterators(0)
 609         , m_mutex(makeUnique&lt;Lock&gt;())
 610 #endif
 611 #if DUMP_HASHTABLE_STATS_PER_TABLE
 612         , m_stats(makeUnique&lt;Stats&gt;())
 613 #endif
 614     {
 615     }
 616 
 617     inline unsigned doubleHash(unsigned key)
 618     {
 619         key = ~key + (key &gt;&gt; 23);
 620         key ^= (key &lt;&lt; 12);
 621         key ^= (key &gt;&gt; 7);
 622         key ^= (key &lt;&lt; 2);
 623         key ^= (key &gt;&gt; 20);
 624         return key;
 625     }
 626 
<span class="line-modified"> 627 #if ASSERT_DISABLED</span>
 628 
 629     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 630     template&lt;typename HashTranslator, typename T&gt;
 631     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp;)
 632     {
 633     }
 634 
<span class="line-modified"> 635 #else</span>
 636 
 637     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 638     template&lt;typename HashTranslator, typename T&gt;
 639     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp; key)
 640     {
 641         if (!HashFunctions::safeToCompareToEmptyOrDeleted)
 642             return;
 643         ASSERT(!HashTranslator::equal(KeyTraits::emptyValue(), key));
 644         typename std::aligned_storage&lt;sizeof(ValueType), std::alignment_of&lt;ValueType&gt;::value&gt;::type deletedValueBuffer;
 645         ValueType* deletedValuePtr = reinterpret_cast_ptr&lt;ValueType*&gt;(&amp;deletedValueBuffer);
 646         ValueType&amp; deletedValue = *deletedValuePtr;
 647         Traits::constructDeletedValue(deletedValue);
 648         ASSERT(!HashTranslator::equal(Extractor::extract(deletedValue), key));
 649     }
 650 
<span class="line-modified"> 651 #endif</span>
 652 
 653     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 654     template&lt;typename HashTranslator, typename T&gt;
 655     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::lookup(const T&amp; key) -&gt; ValueType*
 656     {
 657         return inlineLookup&lt;HashTranslator&gt;(key);
 658     }
 659 
 660     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 661     template&lt;typename HashTranslator, typename T&gt;
 662     ALWAYS_INLINE auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::inlineLookup(const T&amp; key) -&gt; ValueType*
 663     {
 664         checkKey&lt;HashTranslator&gt;(key);
 665 
 666         unsigned k = 0;
<span class="line-removed"> 667         unsigned sizeMask = m_tableSizeMask;</span>
 668         ValueType* table = m_table;




 669         unsigned h = HashTranslator::hash(key);
 670         unsigned i = h &amp; sizeMask;
 671 
<span class="line-removed"> 672         if (!table)</span>
<span class="line-removed"> 673             return 0;</span>
<span class="line-removed"> 674 </span>
 675 #if DUMP_HASHTABLE_STATS
 676         ++HashTableStats::numAccesses;
 677         unsigned probeCount = 0;
 678 #endif
 679 
 680 #if DUMP_HASHTABLE_STATS_PER_TABLE
 681         ++m_stats-&gt;numAccesses;
 682 #endif
 683 
 684         while (1) {
 685             ValueType* entry = table + i;
 686 
 687             // we count on the compiler to optimize out this branch
 688             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 689                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 690                     return entry;
 691 
 692                 if (isEmptyBucket(*entry))
 693                     return 0;
 694             } else {
</pre>
<hr />
<pre>
 705 
 706 #if DUMP_HASHTABLE_STATS_PER_TABLE
 707             m_stats-&gt;recordCollisionAtCount(probeCount);
 708 #endif
 709 
 710             if (k == 0)
 711                 k = 1 | doubleHash(h);
 712             i = (i + k) &amp; sizeMask;
 713         }
 714     }
 715 
 716     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 717     template&lt;typename HashTranslator, typename T&gt;
 718     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::lookupForWriting(const T&amp; key) -&gt; LookupType
 719     {
 720         ASSERT(m_table);
 721         checkKey&lt;HashTranslator&gt;(key);
 722 
 723         unsigned k = 0;
 724         ValueType* table = m_table;
<span class="line-modified"> 725         unsigned sizeMask = m_tableSizeMask;</span>
 726         unsigned h = HashTranslator::hash(key);
 727         unsigned i = h &amp; sizeMask;
 728 
 729 #if DUMP_HASHTABLE_STATS
 730         ++HashTableStats::numAccesses;
 731         unsigned probeCount = 0;
 732 #endif
 733 
 734 #if DUMP_HASHTABLE_STATS_PER_TABLE
 735         ++m_stats-&gt;numAccesses;
 736 #endif
 737 
 738         ValueType* deletedEntry = 0;
 739 
 740         while (1) {
 741             ValueType* entry = table + i;
 742 
 743             // we count on the compiler to optimize out this branch
 744             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 745                 if (isEmptyBucket(*entry))
</pre>
<hr />
<pre>
 766 
 767 #if DUMP_HASHTABLE_STATS_PER_TABLE
 768             m_stats-&gt;recordCollisionAtCount(probeCount);
 769 #endif
 770 
 771             if (k == 0)
 772                 k = 1 | doubleHash(h);
 773             i = (i + k) &amp; sizeMask;
 774         }
 775     }
 776 
 777     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 778     template&lt;typename HashTranslator, typename T&gt;
 779     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::fullLookupForWriting(const T&amp; key) -&gt; FullLookupType
 780     {
 781         ASSERT(m_table);
 782         checkKey&lt;HashTranslator&gt;(key);
 783 
 784         unsigned k = 0;
 785         ValueType* table = m_table;
<span class="line-modified"> 786         unsigned sizeMask = m_tableSizeMask;</span>
 787         unsigned h = HashTranslator::hash(key);
 788         unsigned i = h &amp; sizeMask;
 789 
 790 #if DUMP_HASHTABLE_STATS
 791         ++HashTableStats::numAccesses;
 792         unsigned probeCount = 0;
 793 #endif
 794 
 795 #if DUMP_HASHTABLE_STATS_PER_TABLE
 796         ++m_stats-&gt;numAccesses;
 797 #endif
 798 
 799         ValueType* deletedEntry = 0;
 800 
 801         while (1) {
 802             ValueType* entry = table + i;
 803 
 804             // we count on the compiler to optimize out this branch
 805             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 806                 if (isEmptyBucket(*entry))
</pre>
<hr />
<pre>
 832             if (k == 0)
 833                 k = 1 | doubleHash(h);
 834             i = (i + k) &amp; sizeMask;
 835         }
 836     }
 837 
 838     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 839     template&lt;typename HashTranslator, typename T, typename Extra&gt;
 840     ALWAYS_INLINE void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp; extra)
 841     {
 842         ASSERT(m_table);
 843 
 844         checkKey&lt;HashTranslator&gt;(key);
 845 
 846         invalidateIterators();
 847 
 848         internalCheckTableConsistency();
 849 
 850         unsigned k = 0;
 851         ValueType* table = m_table;
<span class="line-modified"> 852         unsigned sizeMask = m_tableSizeMask;</span>
 853         unsigned h = HashTranslator::hash(key);
 854         unsigned i = h &amp; sizeMask;
 855 
 856 #if DUMP_HASHTABLE_STATS
 857         ++HashTableStats::numAccesses;
 858         unsigned probeCount = 0;
 859 #endif
 860 
 861 #if DUMP_HASHTABLE_STATS_PER_TABLE
 862         ++m_stats-&gt;numAccesses;
 863 #endif
 864 
 865         ValueType* entry;
 866         while (1) {
 867             entry = table + i;
 868 
 869             if (isEmptyBucket(*entry))
 870                 break;
 871 
 872 #if DUMP_HASHTABLE_STATS
</pre>
<hr />
<pre>
 913         HashTableBucketInitializer&lt;Traits::emptyValueIsZero&gt;::template initialize&lt;Traits&gt;(bucket);
 914     }
 915 
 916     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 917     template&lt;typename HashTranslator, typename T, typename Extra&gt;
 918     ALWAYS_INLINE auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::add(T&amp;&amp; key, Extra&amp;&amp; extra) -&gt; AddResult
 919     {
 920         checkKey&lt;HashTranslator&gt;(key);
 921 
 922         invalidateIterators();
 923 
 924         if (!m_table)
 925             expand(nullptr);
 926 
 927         internalCheckTableConsistency();
 928 
 929         ASSERT(m_table);
 930 
 931         unsigned k = 0;
 932         ValueType* table = m_table;
<span class="line-modified"> 933         unsigned sizeMask = m_tableSizeMask;</span>
 934         unsigned h = HashTranslator::hash(key);
 935         unsigned i = h &amp; sizeMask;
 936 
 937 #if DUMP_HASHTABLE_STATS
 938         ++HashTableStats::numAccesses;
 939         unsigned probeCount = 0;
 940 #endif
 941 
 942 #if DUMP_HASHTABLE_STATS_PER_TABLE
 943         ++m_stats-&gt;numAccesses;
 944 #endif
 945 
 946         ValueType* deletedEntry = 0;
 947         ValueType* entry;
 948         while (1) {
 949             entry = table + i;
 950 
 951             // we count on the compiler to optimize out this branch
 952             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 953                 if (isEmptyBucket(*entry))
</pre>
<hr />
<pre>
 967                 else if (HashTranslator::equal(Extractor::extract(*entry), key))
 968                     return AddResult(makeKnownGoodIterator(entry), false);
 969             }
 970 #if DUMP_HASHTABLE_STATS
 971             ++probeCount;
 972             HashTableStats::recordCollisionAtCount(probeCount);
 973 #endif
 974 
 975 #if DUMP_HASHTABLE_STATS_PER_TABLE
 976             m_stats-&gt;recordCollisionAtCount(probeCount);
 977 #endif
 978 
 979             if (k == 0)
 980                 k = 1 | doubleHash(h);
 981             i = (i + k) &amp; sizeMask;
 982         }
 983 
 984         if (deletedEntry) {
 985             initializeBucket(*deletedEntry);
 986             entry = deletedEntry;
<span class="line-modified"> 987             --m_deletedCount;</span>
 988         }
 989 
 990         HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra));
<span class="line-modified"> 991         ++m_keyCount;</span>
 992 
 993         if (shouldExpand())
 994             entry = expand(entry);
 995 
 996         internalCheckTableConsistency();
 997 
 998         return AddResult(makeKnownGoodIterator(entry), true);
 999     }
1000 
1001     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1002     template&lt;typename HashTranslator, typename T, typename Extra&gt;
1003     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp; extra) -&gt; AddResult
1004     {
1005         checkKey&lt;HashTranslator&gt;(key);
1006 
1007         invalidateIterators();
1008 
1009         if (!m_table)
1010             expand();
1011 
1012         internalCheckTableConsistency();
1013 
1014         FullLookupType lookupResult = fullLookupForWriting&lt;HashTranslator&gt;(key);
1015 
1016         ValueType* entry = lookupResult.first.first;
1017         bool found = lookupResult.first.second;
1018         unsigned h = lookupResult.second;
1019 
1020         if (found)
1021             return AddResult(makeKnownGoodIterator(entry), false);
1022 
1023         if (isDeletedBucket(*entry)) {
1024             initializeBucket(*entry);
<span class="line-modified">1025             --m_deletedCount;</span>
1026         }
1027 
1028         HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra), h);
<span class="line-modified">1029         ++m_keyCount;</span>
1030 
1031         if (shouldExpand())
1032             entry = expand(entry);
1033 
1034         internalCheckTableConsistency();
1035 
1036         return AddResult(makeKnownGoodIterator(entry), true);
1037     }
1038 
1039     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1040     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::reinsert(ValueType&amp;&amp; entry) -&gt; ValueType*
1041     {
1042         ASSERT(m_table);
1043         ASSERT(!lookupForWriting(Extractor::extract(entry)).second);
1044         ASSERT(!isDeletedBucket(*(lookupForWriting(Extractor::extract(entry)).first)));
1045 #if DUMP_HASHTABLE_STATS
1046         ++HashTableStats::numReinserts;
1047 #endif
1048 #if DUMP_HASHTABLE_STATS_PER_TABLE
1049         ++m_stats-&gt;numReinserts;
</pre>
<hr />
<pre>
1103 
1104     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1105     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeAndInvalidate(ValueType* pos)
1106     {
1107         invalidateIterators();
1108         internalCheckTableConsistency();
1109         remove(pos);
1110     }
1111 
1112     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1113     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(ValueType* pos)
1114     {
1115 #if DUMP_HASHTABLE_STATS
1116         ++HashTableStats::numRemoves;
1117 #endif
1118 #if DUMP_HASHTABLE_STATS_PER_TABLE
1119         ++m_stats-&gt;numRemoves;
1120 #endif
1121 
1122         deleteBucket(*pos);
<span class="line-modified">1123         ++m_deletedCount;</span>
<span class="line-modified">1124         --m_keyCount;</span>
1125 
1126         if (shouldShrink())
1127             shrink();
1128 
1129         internalCheckTableConsistency();
1130     }
1131 
1132     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1133     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(iterator it)
1134     {
1135         if (it == end())
1136             return;
1137 
1138         removeAndInvalidate(const_cast&lt;ValueType*&gt;(it.m_iterator.m_position));
1139     }
1140 
1141     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1142     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeWithoutEntryConsistencyCheck(iterator it)
1143     {
1144         if (it == end())
</pre>
<hr />
<pre>
1155 
1156         removeAndInvalidateWithoutEntryConsistencyCheck(const_cast&lt;ValueType*&gt;(it.m_position));
1157     }
1158 
1159     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1160     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(const KeyType&amp; key)
1161     {
1162         remove(find(key));
1163     }
1164 
1165     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1166     template&lt;typename Functor&gt;
1167     inline bool HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeIf(const Functor&amp; functor)
1168     {
1169         // We must use local copies in case &quot;functor&quot; or &quot;deleteBucket&quot;
1170         // make a function call, which prevents the compiler from keeping
1171         // the values in register.
1172         unsigned removedBucketCount = 0;
1173         ValueType* table = m_table;
1174 
<span class="line-modified">1175         for (unsigned i = m_tableSize; i--;) {</span>
1176             ValueType&amp; bucket = table[i];
1177             if (isEmptyOrDeletedBucket(bucket))
1178                 continue;
1179 
1180             if (!functor(bucket))
1181                 continue;
1182 
1183             deleteBucket(bucket);
1184             ++removedBucketCount;
1185         }
<span class="line-modified">1186         m_deletedCount += removedBucketCount;</span>
<span class="line-modified">1187         m_keyCount -= removedBucketCount;</span>


1188 
1189         if (shouldShrink())
1190             shrinkToBestSize();
1191 
1192         internalCheckTableConsistency();
1193         return removedBucketCount;
1194     }
1195 
1196     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1197     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::allocateTable(unsigned size) -&gt; ValueType*
1198     {


1199         // would use a template member function with explicit specializations here, but
1200         // gcc doesn&#39;t appear to support that
1201         if (Traits::emptyValueIsZero)
<span class="line-modified">1202             return static_cast&lt;ValueType*&gt;(fastZeroedMalloc(size * sizeof(ValueType)));</span>
<span class="line-modified">1203         ValueType* result = static_cast&lt;ValueType*&gt;(fastMalloc(size * sizeof(ValueType)));</span>

1204         for (unsigned i = 0; i &lt; size; i++)
1205             initializeBucket(result[i]);
1206         return result;
1207     }
1208 
1209     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
<span class="line-modified">1210     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deallocateTable(ValueType* table, unsigned size)</span>
1211     {

1212         for (unsigned i = 0; i &lt; size; ++i) {
1213             if (!isDeletedBucket(table[i]))
1214                 table[i].~ValueType();
1215         }
<span class="line-modified">1216         fastFree(table);</span>
1217     }
1218 
1219     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1220     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::expand(ValueType* entry) -&gt; ValueType*
1221     {
1222         if (KeyTraits::hasIsReleasedWeakValueFunction)
1223             deleteReleasedWeakBuckets();
1224 
1225         unsigned newSize;
<span class="line-modified">1226         if (m_tableSize == 0)</span>

1227             newSize = KeyTraits::minimumTableSize;
1228         else if (mustRehashInPlace())
<span class="line-modified">1229             newSize = m_tableSize;</span>
1230         else
<span class="line-modified">1231             newSize = m_tableSize * 2;</span>
1232 
1233         return rehash(newSize, entry);
1234     }
1235 
1236     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1237     constexpr unsigned HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::computeBestTableSize(unsigned keyCount)
1238     {
<span class="line-modified">1239         unsigned bestTableSize = WTF::roundUpToPowerOfTwo(keyCount) * 2;</span>
1240 
<span class="line-modified">1241         // With maxLoad at 1/2 and minLoad at 1/6, our average load is 2/6.</span>
<span class="line-removed">1242         // If we are getting halfway between 2/6 and 1/2 (past 5/12), we double the size to avoid being too close to</span>
<span class="line-removed">1243         // loadMax and bring the ratio close to 2/6. This give us a load in the bounds [3/12, 5/12).</span>
<span class="line-removed">1244         bool aboveThreeQuarterLoad = keyCount * 12 &gt;= bestTableSize * 5;</span>
<span class="line-removed">1245         if (aboveThreeQuarterLoad)</span>
1246             bestTableSize *= 2;
1247 























1248         unsigned minimumTableSize = KeyTraits::minimumTableSize;
1249         return std::max(bestTableSize, minimumTableSize);
1250     }
1251 
1252     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1253     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::shrinkToBestSize()
1254     {
1255         unsigned minimumTableSize = KeyTraits::minimumTableSize;
<span class="line-modified">1256         rehash(std::max(minimumTableSize, computeBestTableSize(m_keyCount)), nullptr);</span>
1257     }
1258 
1259     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1260     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deleteReleasedWeakBuckets()
1261     {
<span class="line-modified">1262         for (unsigned i = 0; i &lt; m_tableSize; ++i) {</span>

1263             auto&amp; entry = m_table[i];
1264             if (isReleasedWeakBucket(entry)) {
1265                 deleteBucket(entry);
<span class="line-modified">1266                 ++m_deletedCount;</span>
<span class="line-modified">1267                 --m_keyCount;</span>
1268             }
1269         }
1270     }
1271 
1272     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1273     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::rehash(unsigned newTableSize, ValueType* entry) -&gt; ValueType*
1274     {
1275         internalCheckTableConsistencyExceptSize();
1276 
<span class="line-modified">1277         unsigned oldTableSize = m_tableSize;</span>
1278         ValueType* oldTable = m_table;
1279 
1280 #if DUMP_HASHTABLE_STATS
1281         if (oldTableSize != 0)
1282             ++HashTableStats::numRehashes;
1283 #endif
1284 
1285 #if DUMP_HASHTABLE_STATS_PER_TABLE
1286         if (oldTableSize != 0)
1287             ++m_stats-&gt;numRehashes;
1288 #endif
1289 
<span class="line-modified">1290         m_tableSize = newTableSize;</span>
<span class="line-removed">1291         m_tableSizeMask = newTableSize - 1;</span>
1292         m_table = allocateTable(newTableSize);




1293 
1294         Value* newEntry = nullptr;
1295         for (unsigned i = 0; i != oldTableSize; ++i) {
1296             auto&amp; oldEntry = oldTable[i];
1297             if (isDeletedBucket(oldEntry)) {
1298                 ASSERT(std::addressof(oldEntry) != entry);
1299                 continue;
1300             }
1301 
1302             if (isEmptyBucket(oldEntry)) {
1303                 ASSERT(std::addressof(oldEntry) != entry);
1304                 oldTable[i].~ValueType();
1305                 continue;
1306             }
1307 
1308             if (isReleasedWeakBucket(oldEntry)) {
1309                 ASSERT(std::addressof(oldEntry) != entry);
1310                 oldEntry.~ValueType();
<span class="line-modified">1311                 --m_keyCount;</span>
1312                 continue;
1313             }
1314 
1315             Value* reinsertedEntry = reinsert(WTFMove(oldEntry));
1316             oldEntry.~ValueType();
1317             if (std::addressof(oldEntry) == entry) {
1318                 ASSERT(!newEntry);
1319                 newEntry = reinsertedEntry;
1320             }
1321         }
1322 
<span class="line-modified">1323         m_deletedCount = 0;</span>
<span class="line-modified">1324 </span>
<span class="line-removed">1325         fastFree(oldTable);</span>
1326 
1327         internalCheckTableConsistency();
1328         return newEntry;
1329     }
1330 
1331     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1332     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::clear()
1333     {
1334         invalidateIterators();
1335         if (!m_table)
1336             return;
1337 
<span class="line-modified">1338         deallocateTable(m_table, m_tableSize);</span>
<span class="line-modified">1339         m_table = 0;</span>
<span class="line-removed">1340         m_tableSize = 0;</span>
<span class="line-removed">1341         m_tableSizeMask = 0;</span>
<span class="line-removed">1342         m_keyCount = 0;</span>
<span class="line-removed">1343         m_deletedCount = 0;</span>
1344     }
1345 
1346     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1347     HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(const HashTable&amp; other)
1348         : m_table(nullptr)
<span class="line-removed">1349         , m_tableSize(0)</span>
<span class="line-removed">1350         , m_tableSizeMask(0)</span>
<span class="line-removed">1351         , m_keyCount(0)</span>
<span class="line-removed">1352         , m_deletedCount(0)</span>
1353 #if CHECK_HASHTABLE_ITERATORS
1354         , m_iterators(nullptr)
1355         , m_mutex(makeUnique&lt;Lock&gt;())
1356 #endif
1357 #if DUMP_HASHTABLE_STATS_PER_TABLE
1358         , m_stats(makeUnique&lt;Stats&gt;(*other.m_stats))
1359 #endif
1360     {
1361         unsigned otherKeyCount = other.size();
1362         if (!otherKeyCount)
1363             return;
1364 
<span class="line-modified">1365         m_tableSize = computeBestTableSize(otherKeyCount);</span>
<span class="line-modified">1366         m_tableSizeMask = m_tableSize - 1;</span>
<span class="line-modified">1367         m_keyCount = otherKeyCount;</span>
<span class="line-modified">1368         m_table = allocateTable(m_tableSize);</span>


1369 
1370         for (const auto&amp; otherValue : other)
1371             addUniqueForInitialization&lt;IdentityTranslatorType&gt;(Extractor::extract(otherValue), otherValue);
1372     }
1373 
1374     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1375     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::swap(HashTable&amp; other)
1376     {
1377         invalidateIterators();
1378         other.invalidateIterators();
1379 
1380         std::swap(m_table, other.m_table);
<span class="line-removed">1381         std::swap(m_tableSize, other.m_tableSize);</span>
<span class="line-removed">1382         std::swap(m_tableSizeMask, other.m_tableSizeMask);</span>
<span class="line-removed">1383         std::swap(m_keyCount, other.m_keyCount);</span>
<span class="line-removed">1384         std::swap(m_deletedCount, other.m_deletedCount);</span>
1385 
1386 #if DUMP_HASHTABLE_STATS_PER_TABLE
1387         m_stats.swap(other.m_stats);
1388 #endif
1389     }
1390 
1391     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1392     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::operator=(const HashTable&amp; other) -&gt; HashTable&amp;
1393     {
1394         HashTable tmp(other);
1395         swap(tmp);
1396         return *this;
1397     }
1398 
1399     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1400     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(HashTable&amp;&amp; other)
1401 #if CHECK_HASHTABLE_ITERATORS
1402         : m_iterators(nullptr)
1403         , m_mutex(makeUnique&lt;Lock&gt;())
1404 #endif
1405     {
1406         other.invalidateIterators();
1407 
<span class="line-modified">1408         m_table = other.m_table;</span>
<span class="line-removed">1409         m_tableSize = other.m_tableSize;</span>
<span class="line-removed">1410         m_tableSizeMask = other.m_tableSizeMask;</span>
<span class="line-removed">1411         m_keyCount = other.m_keyCount;</span>
<span class="line-removed">1412         m_deletedCount = other.m_deletedCount;</span>
<span class="line-removed">1413 </span>
<span class="line-removed">1414         other.m_table = nullptr;</span>
<span class="line-removed">1415         other.m_tableSize = 0;</span>
<span class="line-removed">1416         other.m_tableSizeMask = 0;</span>
<span class="line-removed">1417         other.m_keyCount = 0;</span>
<span class="line-removed">1418         other.m_deletedCount = 0;</span>
1419 
1420 #if DUMP_HASHTABLE_STATS_PER_TABLE
1421         m_stats = WTFMove(other.m_stats);
1422         other.m_stats = nullptr;
1423 #endif
1424     }
1425 
1426     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1427     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::operator=(HashTable&amp;&amp; other) -&gt; HashTable&amp;
1428     {
1429         HashTable temp = WTFMove(other);
1430         swap(temp);
1431         return *this;
1432     }
1433 
<span class="line-modified">1434 #if !ASSERT_DISABLED</span>
1435 
1436     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1437     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkTableConsistency() const
1438     {
1439         checkTableConsistencyExceptSize();
1440         ASSERT(!m_table || !shouldExpand());
1441         ASSERT(!shouldShrink());
1442     }
1443 
1444     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1445     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkTableConsistencyExceptSize() const
1446     {
1447         if (!m_table)
1448             return;
1449 
1450         unsigned count = 0;
1451         unsigned deletedCount = 0;
<span class="line-modified">1452         for (unsigned j = 0; j &lt; m_tableSize; ++j) {</span>

1453             ValueType* entry = m_table + j;
1454             if (isEmptyBucket(*entry))
1455                 continue;
1456 
1457             if (isDeletedBucket(*entry)) {
1458                 ++deletedCount;
1459                 continue;
1460             }
1461 
1462             auto&amp; key = Extractor::extract(*entry);
1463             const_iterator it = find(key);
1464             ASSERT(entry == it.m_position);
1465             ++count;
1466 
1467             ValueCheck&lt;Key&gt;::checkConsistency(key);
1468         }
1469 
<span class="line-modified">1470         ASSERT(count == m_keyCount);</span>
<span class="line-modified">1471         ASSERT(deletedCount == m_deletedCount);</span>
<span class="line-modified">1472         ASSERT(m_tableSize &gt;= KeyTraits::minimumTableSize);</span>
<span class="line-modified">1473         ASSERT(m_tableSizeMask);</span>
<span class="line-modified">1474         ASSERT(m_tableSize == m_tableSizeMask + 1);</span>
1475     }
1476 
<span class="line-modified">1477 #endif // ASSERT_DISABLED</span>
1478 
1479 #if CHECK_HASHTABLE_ITERATORS
1480 
1481     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1482     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::invalidateIterators()
1483     {
1484         std::lock_guard&lt;Lock&gt; lock(*m_mutex);
1485         const_iterator* next;
1486         for (const_iterator* p = m_iterators; p; p = next) {
1487             next = p-&gt;m_next;
1488             p-&gt;m_table = 0;
1489             p-&gt;m_next = 0;
1490             p-&gt;m_previous = 0;
1491         }
1492         m_iterators = 0;
1493     }
1494 
1495     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1496     void addIterator(const HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;* table,
1497         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;* it)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2005-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2008 David Levin &lt;levin@chromium.org&gt;
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public License
  16  * along with this library; see the file COPYING.LIB.  If not, write to
  17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  18  * Boston, MA 02110-1301, USA.
  19  *
  20  */
  21 
  22 #pragma once
  23 
  24 #include &lt;atomic&gt;
  25 #include &lt;iterator&gt;
  26 #include &lt;mutex&gt;
  27 #include &lt;string.h&gt;
  28 #include &lt;type_traits&gt;
  29 #include &lt;utility&gt;
  30 #include &lt;wtf/Assertions.h&gt;
<span class="line-added">  31 #include &lt;wtf/DebugHeap.h&gt;</span>
  32 #include &lt;wtf/FastMalloc.h&gt;
  33 #include &lt;wtf/HashTraits.h&gt;
  34 #include &lt;wtf/Lock.h&gt;
  35 #include &lt;wtf/MathExtras.h&gt;
  36 #include &lt;wtf/RandomNumber.h&gt;
  37 #include &lt;wtf/StdLibExtras.h&gt;
  38 #include &lt;wtf/ValueCheck.h&gt;
  39 
  40 #define DUMP_HASHTABLE_STATS 0
  41 #define DUMP_HASHTABLE_STATS_PER_TABLE 0
  42 
  43 #if DUMP_HASHTABLE_STATS_PER_TABLE
  44 #include &lt;wtf/DataLog.h&gt;
  45 #endif
  46 
  47 namespace WTF {
  48 
<span class="line-added">  49 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(HashTable);</span>
<span class="line-added">  50 </span>
  51 // Enables internal WTF consistency checks that are invoked automatically. Non-WTF callers can call checkTableConsistency() even if internal checks are disabled.
  52 #define CHECK_HASHTABLE_CONSISTENCY 0
  53 
  54 #ifdef NDEBUG
  55 #define CHECK_HASHTABLE_ITERATORS 0
  56 #define CHECK_HASHTABLE_USE_AFTER_DESTRUCTION 0
  57 #else
  58 #define CHECK_HASHTABLE_ITERATORS 1
  59 #define CHECK_HASHTABLE_USE_AFTER_DESTRUCTION 1
  60 #endif
  61 
  62 #if DUMP_HASHTABLE_STATS
  63 
  64     struct HashTableStats {
  65         // The following variables are all atomically incremented when modified.
  66         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numAccesses;
  67         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numRehashes;
  68         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numRemoves;
  69         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numReinserts;
  70 
</pre>
<hr />
<pre>
 286 
 287     template&lt;typename ValueTraits, typename HashFunctions&gt; class IdentityHashTranslator {
 288     public:
 289         template&lt;typename T&gt; static unsigned hash(const T&amp; key) { return HashFunctions::hash(key); }
 290         template&lt;typename T, typename U&gt; static bool equal(const T&amp; a, const U&amp; b) { return HashFunctions::equal(a, b); }
 291         template&lt;typename T, typename U, typename V&gt; static void translate(T&amp; location, const U&amp;, V&amp;&amp; value)
 292         {
 293             ValueTraits::assignToEmpty(location, std::forward&lt;V&gt;(value));
 294         }
 295     };
 296 
 297     template&lt;typename IteratorType&gt; struct HashTableAddResult {
 298         HashTableAddResult() : isNewEntry(false) { }
 299         HashTableAddResult(IteratorType iter, bool isNewEntry) : iterator(iter), isNewEntry(isNewEntry) { }
 300         IteratorType iterator;
 301         bool isNewEntry;
 302 
 303         explicit operator bool() const { return isNewEntry; }
 304     };
 305 
<span class="line-added"> 306     // HashTableCapacityForSize computes the upper power of two capacity to hold the size parameter.</span>
<span class="line-added"> 307     // This is done at compile time to initialize the HashTraits.</span>
<span class="line-added"> 308     template&lt;unsigned size&gt;</span>
<span class="line-added"> 309     struct HashTableCapacityForSize {</span>
<span class="line-added"> 310         // Load-factor for small table is 75%.</span>
<span class="line-added"> 311         static constexpr unsigned smallMaxLoadNumerator = 3;</span>
<span class="line-added"> 312         static constexpr unsigned smallMaxLoadDenominator = 4;</span>
<span class="line-added"> 313         // Load-factor for large table is 50%.</span>
<span class="line-added"> 314         static constexpr unsigned largeMaxLoadNumerator = 1;</span>
<span class="line-added"> 315         static constexpr unsigned largeMaxLoadDenominator = 2;</span>
<span class="line-added"> 316         static constexpr unsigned maxSmallTableCapacity = 1024;</span>
<span class="line-added"> 317         static constexpr unsigned minLoad = 6;</span>
<span class="line-added"> 318 </span>
<span class="line-added"> 319         static constexpr bool shouldExpand(uint64_t keyAndDeleteCount, uint64_t tableSize)</span>
<span class="line-added"> 320         {</span>
<span class="line-added"> 321             if (tableSize &lt;= maxSmallTableCapacity)</span>
<span class="line-added"> 322                 return keyAndDeleteCount * smallMaxLoadDenominator &gt;= tableSize * smallMaxLoadNumerator;</span>
<span class="line-added"> 323             return keyAndDeleteCount * largeMaxLoadDenominator &gt;= tableSize * largeMaxLoadNumerator;</span>
<span class="line-added"> 324         }</span>
<span class="line-added"> 325 </span>
<span class="line-added"> 326         static constexpr unsigned capacityForSize(uint32_t sizeArg)</span>
<span class="line-added"> 327         {</span>
<span class="line-added"> 328             if (!sizeArg)</span>
<span class="line-added"> 329                 return 0;</span>
<span class="line-added"> 330             constexpr unsigned maxCapacity = 1U &lt;&lt; 31;</span>
<span class="line-added"> 331             UNUSED_PARAM(maxCapacity);</span>
<span class="line-added"> 332             ASSERT_UNDER_CONSTEXPR_CONTEXT(sizeArg &lt;= maxCapacity);</span>
<span class="line-added"> 333             uint32_t capacity = roundUpToPowerOfTwo(sizeArg);</span>
<span class="line-added"> 334             ASSERT_UNDER_CONSTEXPR_CONTEXT(capacity &lt;= maxCapacity);</span>
<span class="line-added"> 335             if (shouldExpand(sizeArg, capacity)) {</span>
<span class="line-added"> 336                 ASSERT_UNDER_CONSTEXPR_CONTEXT((static_cast&lt;uint64_t&gt;(capacity) * 2) &lt;= maxCapacity);</span>
<span class="line-added"> 337                 return capacity * 2;</span>
<span class="line-added"> 338             }</span>
<span class="line-added"> 339             return capacity;</span>
<span class="line-added"> 340         }</span>
<span class="line-added"> 341 </span>
<span class="line-added"> 342         static constexpr unsigned value = capacityForSize(size);</span>
<span class="line-added"> 343         static_assert(size &gt; 0, &quot;HashTableNonZeroMinimumCapacity&quot;);</span>
<span class="line-added"> 344         static_assert(!static_cast&lt;unsigned&gt;(value &gt;&gt; 31), &quot;HashTableNoCapacityOverflow&quot;);</span>
<span class="line-added"> 345     };</span>
<span class="line-added"> 346 </span>
 347     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 348     class HashTable {
 349     public:
 350         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 351         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 352         typedef Traits ValueTraits;
 353         typedef Key KeyType;
 354         typedef Value ValueType;
 355         typedef IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType;
 356         typedef HashTableAddResult&lt;iterator&gt; AddResult;
 357 
<span class="line-added"> 358         using HashTableSizePolicy = HashTableCapacityForSize&lt;1&gt;;</span>
<span class="line-added"> 359 </span>
 360 #if DUMP_HASHTABLE_STATS_PER_TABLE
 361         struct Stats {
 362             WTF_MAKE_STRUCT_FAST_ALLOCATED;
 363 
 364             Stats()
 365                 : numAccesses(0)
 366                 , numRehashes(0)
 367                 , numRemoves(0)
 368                 , numReinserts(0)
 369                 , maxCollisions(0)
 370                 , numCollisions(0)
 371                 , collisionGraph()
 372             {
 373             }
 374 
 375             unsigned numAccesses;
 376             unsigned numRehashes;
 377             unsigned numRemoves;
 378             unsigned numReinserts;
 379 
</pre>
<hr />
<pre>
 410 
 411 #if PLATFORM(JAVA)
 412 #if CHECK_HASHTABLE_ITERATORS
 413             // does the same as invalidateIterators() but without
 414             // taking a lock since the destructor may be invoked
 415             // during atexit() handler which may lead to crash
 416             const_iterator* next;
 417             for (const_iterator* p = m_iterators; p; p = next) {
 418                 next = p-&gt;m_next;
 419                 p-&gt;m_table = 0;
 420                 p-&gt;m_next = 0;
 421                 p-&gt;m_previous = 0;
 422             }
 423             m_iterators = 0;
 424 #endif
 425 #else
 426             invalidateIterators();
 427 #endif
 428 
 429             if (m_table)
<span class="line-modified"> 430                 deallocateTable(m_table);</span>
 431 #if CHECK_HASHTABLE_USE_AFTER_DESTRUCTION
 432             m_table = (ValueType*)(uintptr_t)0xbbadbeef;
 433 #endif
 434         }
 435 
 436         HashTable(const HashTable&amp;);
 437         void swap(HashTable&amp;);
 438         HashTable&amp; operator=(const HashTable&amp;);
 439 
 440         HashTable(HashTable&amp;&amp;);
 441         HashTable&amp; operator=(HashTable&amp;&amp;);
 442 
 443         // When the hash table is empty, just return the same iterator for end as for begin.
 444         // This is more efficient because we don&#39;t have to skip all the empty and deleted
 445         // buckets, and iterating an empty table is a common case that&#39;s worth optimizing.
 446         iterator begin() { return isEmpty() ? end() : makeIterator(m_table); }
<span class="line-modified"> 447         iterator end() { return makeKnownGoodIterator(m_table + tableSize()); }</span>
 448         const_iterator begin() const { return isEmpty() ? end() : makeConstIterator(m_table); }
<span class="line-modified"> 449         const_iterator end() const { return makeKnownGoodConstIterator(m_table + tableSize()); }</span>
 450 
 451         iterator random()
 452         {
 453             if (isEmpty())
 454                 return end();
 455 
 456             while (1) {
<span class="line-modified"> 457                 auto&amp; bucket = m_table[weakRandomUint32() &amp; tableSizeMask()];</span>
 458                 if (!isEmptyOrDeletedBucket(bucket))
 459                     return makeKnownGoodIterator(&amp;bucket);
 460             };
 461         }
 462 
 463         const_iterator random() const { return static_cast&lt;const_iterator&gt;(const_cast&lt;HashTable*&gt;(this)-&gt;random()); }
 464 
<span class="line-modified"> 465         unsigned size() const { return keyCount(); }</span>
<span class="line-modified"> 466         unsigned capacity() const { return tableSize(); }</span>
<span class="line-modified"> 467         bool isEmpty() const { return !keyCount(); }</span>
 468 
 469         void reserveInitialCapacity(unsigned keyCount)
 470         {
 471             ASSERT(!m_table);
<span class="line-modified"> 472             ASSERT(!tableSize());</span>

 473 
 474             unsigned minimumTableSize = KeyTraits::minimumTableSize;
 475             unsigned newTableSize = std::max(minimumTableSize, computeBestTableSize(keyCount));
 476 


 477             m_table = allocateTable(newTableSize);
<span class="line-added"> 478             setTableSize(newTableSize);</span>
<span class="line-added"> 479             setTableSizeMask(newTableSize - 1);</span>
<span class="line-added"> 480             setDeletedCount(0);</span>
<span class="line-added"> 481             setKeyCount(0);</span>
 482         }
 483 
 484         AddResult add(const ValueType&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); }
 485         AddResult add(ValueType&amp;&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); }
 486 
 487         // A special version of add() that finds the object by hashing and comparing
 488         // with some other type, to avoid the cost of type conversion if the object is already
 489         // in the table.
 490         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult add(T&amp;&amp; key, Extra&amp;&amp;);
 491         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp;);
 492 
 493         iterator find(const KeyType&amp; key) { return find&lt;IdentityTranslatorType&gt;(key); }
 494         const_iterator find(const KeyType&amp; key) const { return find&lt;IdentityTranslatorType&gt;(key); }
 495         bool contains(const KeyType&amp; key) const { return contains&lt;IdentityTranslatorType&gt;(key); }
 496 
 497         template&lt;typename HashTranslator, typename T&gt; iterator find(const T&amp;);
 498         template&lt;typename HashTranslator, typename T&gt; const_iterator find(const T&amp;) const;
 499         template&lt;typename HashTranslator, typename T&gt; bool contains(const T&amp;) const;
 500 
 501         void remove(const KeyType&amp;);
 502         void remove(iterator);
 503         void removeWithoutEntryConsistencyCheck(iterator);
 504         void removeWithoutEntryConsistencyCheck(const_iterator);
 505         template&lt;typename Functor&gt;
 506         bool removeIf(const Functor&amp;);
 507         void clear();
 508 
 509         static bool isEmptyBucket(const ValueType&amp; value) { return isHashTraitsEmptyValue&lt;KeyTraits&gt;(Extractor::extract(value)); }
 510         static bool isReleasedWeakBucket(const ValueType&amp; value) { return isHashTraitsReleasedWeakValue&lt;KeyTraits&gt;(Extractor::extract(value)); }
 511         static bool isDeletedBucket(const ValueType&amp; value) { return KeyTraits::isDeletedValue(Extractor::extract(value)); }
 512         static bool isEmptyOrDeletedBucket(const ValueType&amp; value) { return isEmptyBucket(value) || isDeletedBucket(value); }
 513 
 514         ValueType* lookup(const Key&amp; key) { return lookup&lt;IdentityTranslatorType&gt;(key); }
 515         template&lt;typename HashTranslator, typename T&gt; ValueType* lookup(const T&amp;);
 516         template&lt;typename HashTranslator, typename T&gt; ValueType* inlineLookup(const T&amp;);
 517 
<span class="line-modified"> 518 #if ASSERT_ENABLED</span>
 519         void checkTableConsistency() const;
 520 #else
 521         static void checkTableConsistency() { }
 522 #endif
 523 #if CHECK_HASHTABLE_CONSISTENCY
 524         void internalCheckTableConsistency() const { checkTableConsistency(); }
 525         void internalCheckTableConsistencyExceptSize() const { checkTableConsistencyExceptSize(); }
 526 #else
 527         static void internalCheckTableConsistencyExceptSize() { }
 528         static void internalCheckTableConsistency() { }
 529 #endif
 530 
 531     private:
 532         static ValueType* allocateTable(unsigned size);
<span class="line-modified"> 533         static void deallocateTable(ValueType* table);</span>
 534 
 535         typedef std::pair&lt;ValueType*, bool&gt; LookupType;
 536         typedef std::pair&lt;LookupType, unsigned&gt; FullLookupType;
 537 
 538         LookupType lookupForWriting(const Key&amp; key) { return lookupForWriting&lt;IdentityTranslatorType&gt;(key); };
 539         template&lt;typename HashTranslator, typename T&gt; FullLookupType fullLookupForWriting(const T&amp;);
 540         template&lt;typename HashTranslator, typename T&gt; LookupType lookupForWriting(const T&amp;);
 541 
 542         template&lt;typename HashTranslator, typename T, typename Extra&gt; void addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp;);
 543 
 544         template&lt;typename HashTranslator, typename T&gt; void checkKey(const T&amp;);
 545 
 546         void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);
 547         void removeAndInvalidate(ValueType*);
 548         void remove(ValueType*);
 549 
 550         static constexpr unsigned computeBestTableSize(unsigned keyCount);
<span class="line-modified"> 551         bool shouldExpand() const { return HashTableSizePolicy::shouldExpand(keyCount() + deletedCount(), tableSize()); }</span>
<span class="line-modified"> 552         bool mustRehashInPlace() const { return keyCount() * minLoad &lt; tableSize() * 2; }</span>
<span class="line-modified"> 553         bool shouldShrink() const { return keyCount() * minLoad &lt; tableSize() &amp;&amp; tableSize() &gt; KeyTraits::minimumTableSize; }</span>
 554         ValueType* expand(ValueType* entry = nullptr);
<span class="line-modified"> 555         void shrink() { rehash(tableSize() / 2, nullptr); }</span>
 556         void shrinkToBestSize();
 557 
 558         void deleteReleasedWeakBuckets();
 559 
 560         ValueType* rehash(unsigned newTableSize, ValueType* entry);
 561         ValueType* reinsert(ValueType&amp;&amp;);
 562 
 563         static void initializeBucket(ValueType&amp; bucket);
 564         static void deleteBucket(ValueType&amp; bucket) { hashTraitsDeleteBucket&lt;Traits&gt;(bucket); }
 565 
 566         FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)
 567             { return FullLookupType(LookupType(position, found), hash); }
 568 
<span class="line-modified"> 569         iterator makeIterator(ValueType* pos) { return iterator(this, pos, m_table + tableSize()); }</span>
<span class="line-modified"> 570         const_iterator makeConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + tableSize()); }</span>
<span class="line-modified"> 571         iterator makeKnownGoodIterator(ValueType* pos) { return iterator(this, pos, m_table + tableSize(), HashItemKnownGood); }</span>
<span class="line-modified"> 572         const_iterator makeKnownGoodConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + tableSize(), HashItemKnownGood); }</span>
 573 
<span class="line-modified"> 574 #if ASSERT_ENABLED</span>
 575         void checkTableConsistencyExceptSize() const;
 576 #else
 577         static void checkTableConsistencyExceptSize() { }
 578 #endif
 579 
 580 #if CHECK_HASHTABLE_ITERATORS
 581         void invalidateIterators();
 582 #else
 583         static void invalidateIterators() { }
 584 #endif
 585 
<span class="line-modified"> 586         // Load-factor for small table is 75%.</span>
<span class="line-modified"> 587         static constexpr unsigned smallMaxLoadNumerator = HashTableSizePolicy::smallMaxLoadNumerator;</span>
<span class="line-modified"> 588         static constexpr unsigned smallMaxLoadDenominator = HashTableSizePolicy::smallMaxLoadDenominator;</span>
<span class="line-modified"> 589         // Load-factor for large table is 50%.</span>
<span class="line-modified"> 590         static constexpr unsigned largeMaxLoadNumerator = HashTableSizePolicy::largeMaxLoadNumerator;</span>
<span class="line-modified"> 591         static constexpr unsigned largeMaxLoadDenominator = HashTableSizePolicy::largeMaxLoadDenominator;</span>
<span class="line-modified"> 592         static constexpr unsigned maxSmallTableCapacity = HashTableSizePolicy::maxSmallTableCapacity;</span>
<span class="line-modified"> 593         static constexpr unsigned minLoad = HashTableSizePolicy::minLoad;</span>
<span class="line-added"> 594 </span>
<span class="line-added"> 595         static constexpr int tableSizeOffset = -1;</span>
<span class="line-added"> 596         static constexpr int tableSizeMaskOffset = -2;</span>
<span class="line-added"> 597         static constexpr int keyCountOffset = -3;</span>
<span class="line-added"> 598         static constexpr int deletedCountOffset = -4;</span>
<span class="line-added"> 599         static constexpr unsigned metadataSize = 4 * sizeof(unsigned);</span>
<span class="line-added"> 600 </span>
<span class="line-added"> 601         unsigned tableSize() const { return m_table ? reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[tableSizeOffset] : 0; }</span>
<span class="line-added"> 602         void setTableSize(unsigned size) const { ASSERT(m_table); reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[tableSizeOffset] = size; }</span>
<span class="line-added"> 603         unsigned tableSizeMask() const { ASSERT(m_table); return m_table ? reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[tableSizeMaskOffset] : 0; }</span>
<span class="line-added"> 604         void setTableSizeMask(unsigned mask) { ASSERT(m_table); reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[tableSizeMaskOffset] = mask; }</span>
<span class="line-added"> 605         unsigned keyCount() const { return m_table ? reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[keyCountOffset] : 0; }</span>
<span class="line-added"> 606         void setKeyCount(unsigned count) const { ASSERT(m_table); reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[keyCountOffset] = count; }</span>
<span class="line-added"> 607         unsigned deletedCount() const { ASSERT(m_table); return reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[deletedCountOffset]; }</span>
<span class="line-added"> 608         void setDeletedCount(unsigned count) const { ASSERT(m_table); reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[deletedCountOffset] = count; }</span>
<span class="line-added"> 609 </span>
<span class="line-added"> 610         ValueType* m_table { nullptr };</span>
 611 
 612 #if CHECK_HASHTABLE_ITERATORS
 613     public:
 614         // All access to m_iterators should be guarded with m_mutex.
 615         mutable const_iterator* m_iterators;
 616         // Use std::unique_ptr so HashTable can still be memmove&#39;d or memcpy&#39;ed.
 617         mutable std::unique_ptr&lt;Lock&gt; m_mutex;
 618 #endif
 619 
 620 #if DUMP_HASHTABLE_STATS_PER_TABLE
 621     public:
 622         mutable std::unique_ptr&lt;Stats&gt; m_stats;
 623 #endif
 624     };
 625 






































 626     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 627     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable()
<span class="line-modified"> 628         : m_table(nullptr)</span>




 629 #if CHECK_HASHTABLE_ITERATORS
 630         , m_iterators(0)
 631         , m_mutex(makeUnique&lt;Lock&gt;())
 632 #endif
 633 #if DUMP_HASHTABLE_STATS_PER_TABLE
 634         , m_stats(makeUnique&lt;Stats&gt;())
 635 #endif
 636     {
 637     }
 638 
 639     inline unsigned doubleHash(unsigned key)
 640     {
 641         key = ~key + (key &gt;&gt; 23);
 642         key ^= (key &lt;&lt; 12);
 643         key ^= (key &gt;&gt; 7);
 644         key ^= (key &lt;&lt; 2);
 645         key ^= (key &gt;&gt; 20);
 646         return key;
 647     }
 648 
<span class="line-modified"> 649 #if !ASSERT_ENABLED</span>
 650 
 651     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 652     template&lt;typename HashTranslator, typename T&gt;
 653     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp;)
 654     {
 655     }
 656 
<span class="line-modified"> 657 #else // ASSERT_ENABLED</span>
 658 
 659     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 660     template&lt;typename HashTranslator, typename T&gt;
 661     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp; key)
 662     {
 663         if (!HashFunctions::safeToCompareToEmptyOrDeleted)
 664             return;
 665         ASSERT(!HashTranslator::equal(KeyTraits::emptyValue(), key));
 666         typename std::aligned_storage&lt;sizeof(ValueType), std::alignment_of&lt;ValueType&gt;::value&gt;::type deletedValueBuffer;
 667         ValueType* deletedValuePtr = reinterpret_cast_ptr&lt;ValueType*&gt;(&amp;deletedValueBuffer);
 668         ValueType&amp; deletedValue = *deletedValuePtr;
 669         Traits::constructDeletedValue(deletedValue);
 670         ASSERT(!HashTranslator::equal(Extractor::extract(deletedValue), key));
 671     }
 672 
<span class="line-modified"> 673 #endif // ASSERT_ENABLED</span>
 674 
 675     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 676     template&lt;typename HashTranslator, typename T&gt;
 677     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::lookup(const T&amp; key) -&gt; ValueType*
 678     {
 679         return inlineLookup&lt;HashTranslator&gt;(key);
 680     }
 681 
 682     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 683     template&lt;typename HashTranslator, typename T&gt;
 684     ALWAYS_INLINE auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::inlineLookup(const T&amp; key) -&gt; ValueType*
 685     {
 686         checkKey&lt;HashTranslator&gt;(key);
 687 
 688         unsigned k = 0;

 689         ValueType* table = m_table;
<span class="line-added"> 690         if (!table)</span>
<span class="line-added"> 691             return nullptr;</span>
<span class="line-added"> 692 </span>
<span class="line-added"> 693         unsigned sizeMask = tableSizeMask();</span>
 694         unsigned h = HashTranslator::hash(key);
 695         unsigned i = h &amp; sizeMask;
 696 



 697 #if DUMP_HASHTABLE_STATS
 698         ++HashTableStats::numAccesses;
 699         unsigned probeCount = 0;
 700 #endif
 701 
 702 #if DUMP_HASHTABLE_STATS_PER_TABLE
 703         ++m_stats-&gt;numAccesses;
 704 #endif
 705 
 706         while (1) {
 707             ValueType* entry = table + i;
 708 
 709             // we count on the compiler to optimize out this branch
 710             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 711                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 712                     return entry;
 713 
 714                 if (isEmptyBucket(*entry))
 715                     return 0;
 716             } else {
</pre>
<hr />
<pre>
 727 
 728 #if DUMP_HASHTABLE_STATS_PER_TABLE
 729             m_stats-&gt;recordCollisionAtCount(probeCount);
 730 #endif
 731 
 732             if (k == 0)
 733                 k = 1 | doubleHash(h);
 734             i = (i + k) &amp; sizeMask;
 735         }
 736     }
 737 
 738     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 739     template&lt;typename HashTranslator, typename T&gt;
 740     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::lookupForWriting(const T&amp; key) -&gt; LookupType
 741     {
 742         ASSERT(m_table);
 743         checkKey&lt;HashTranslator&gt;(key);
 744 
 745         unsigned k = 0;
 746         ValueType* table = m_table;
<span class="line-modified"> 747         unsigned sizeMask = tableSizeMask();</span>
 748         unsigned h = HashTranslator::hash(key);
 749         unsigned i = h &amp; sizeMask;
 750 
 751 #if DUMP_HASHTABLE_STATS
 752         ++HashTableStats::numAccesses;
 753         unsigned probeCount = 0;
 754 #endif
 755 
 756 #if DUMP_HASHTABLE_STATS_PER_TABLE
 757         ++m_stats-&gt;numAccesses;
 758 #endif
 759 
 760         ValueType* deletedEntry = 0;
 761 
 762         while (1) {
 763             ValueType* entry = table + i;
 764 
 765             // we count on the compiler to optimize out this branch
 766             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 767                 if (isEmptyBucket(*entry))
</pre>
<hr />
<pre>
 788 
 789 #if DUMP_HASHTABLE_STATS_PER_TABLE
 790             m_stats-&gt;recordCollisionAtCount(probeCount);
 791 #endif
 792 
 793             if (k == 0)
 794                 k = 1 | doubleHash(h);
 795             i = (i + k) &amp; sizeMask;
 796         }
 797     }
 798 
 799     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 800     template&lt;typename HashTranslator, typename T&gt;
 801     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::fullLookupForWriting(const T&amp; key) -&gt; FullLookupType
 802     {
 803         ASSERT(m_table);
 804         checkKey&lt;HashTranslator&gt;(key);
 805 
 806         unsigned k = 0;
 807         ValueType* table = m_table;
<span class="line-modified"> 808         unsigned sizeMask = tableSizeMask();</span>
 809         unsigned h = HashTranslator::hash(key);
 810         unsigned i = h &amp; sizeMask;
 811 
 812 #if DUMP_HASHTABLE_STATS
 813         ++HashTableStats::numAccesses;
 814         unsigned probeCount = 0;
 815 #endif
 816 
 817 #if DUMP_HASHTABLE_STATS_PER_TABLE
 818         ++m_stats-&gt;numAccesses;
 819 #endif
 820 
 821         ValueType* deletedEntry = 0;
 822 
 823         while (1) {
 824             ValueType* entry = table + i;
 825 
 826             // we count on the compiler to optimize out this branch
 827             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 828                 if (isEmptyBucket(*entry))
</pre>
<hr />
<pre>
 854             if (k == 0)
 855                 k = 1 | doubleHash(h);
 856             i = (i + k) &amp; sizeMask;
 857         }
 858     }
 859 
 860     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 861     template&lt;typename HashTranslator, typename T, typename Extra&gt;
 862     ALWAYS_INLINE void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp; extra)
 863     {
 864         ASSERT(m_table);
 865 
 866         checkKey&lt;HashTranslator&gt;(key);
 867 
 868         invalidateIterators();
 869 
 870         internalCheckTableConsistency();
 871 
 872         unsigned k = 0;
 873         ValueType* table = m_table;
<span class="line-modified"> 874         unsigned sizeMask = tableSizeMask();</span>
 875         unsigned h = HashTranslator::hash(key);
 876         unsigned i = h &amp; sizeMask;
 877 
 878 #if DUMP_HASHTABLE_STATS
 879         ++HashTableStats::numAccesses;
 880         unsigned probeCount = 0;
 881 #endif
 882 
 883 #if DUMP_HASHTABLE_STATS_PER_TABLE
 884         ++m_stats-&gt;numAccesses;
 885 #endif
 886 
 887         ValueType* entry;
 888         while (1) {
 889             entry = table + i;
 890 
 891             if (isEmptyBucket(*entry))
 892                 break;
 893 
 894 #if DUMP_HASHTABLE_STATS
</pre>
<hr />
<pre>
 935         HashTableBucketInitializer&lt;Traits::emptyValueIsZero&gt;::template initialize&lt;Traits&gt;(bucket);
 936     }
 937 
 938     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 939     template&lt;typename HashTranslator, typename T, typename Extra&gt;
 940     ALWAYS_INLINE auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::add(T&amp;&amp; key, Extra&amp;&amp; extra) -&gt; AddResult
 941     {
 942         checkKey&lt;HashTranslator&gt;(key);
 943 
 944         invalidateIterators();
 945 
 946         if (!m_table)
 947             expand(nullptr);
 948 
 949         internalCheckTableConsistency();
 950 
 951         ASSERT(m_table);
 952 
 953         unsigned k = 0;
 954         ValueType* table = m_table;
<span class="line-modified"> 955         unsigned sizeMask = tableSizeMask();</span>
 956         unsigned h = HashTranslator::hash(key);
 957         unsigned i = h &amp; sizeMask;
 958 
 959 #if DUMP_HASHTABLE_STATS
 960         ++HashTableStats::numAccesses;
 961         unsigned probeCount = 0;
 962 #endif
 963 
 964 #if DUMP_HASHTABLE_STATS_PER_TABLE
 965         ++m_stats-&gt;numAccesses;
 966 #endif
 967 
 968         ValueType* deletedEntry = 0;
 969         ValueType* entry;
 970         while (1) {
 971             entry = table + i;
 972 
 973             // we count on the compiler to optimize out this branch
 974             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 975                 if (isEmptyBucket(*entry))
</pre>
<hr />
<pre>
 989                 else if (HashTranslator::equal(Extractor::extract(*entry), key))
 990                     return AddResult(makeKnownGoodIterator(entry), false);
 991             }
 992 #if DUMP_HASHTABLE_STATS
 993             ++probeCount;
 994             HashTableStats::recordCollisionAtCount(probeCount);
 995 #endif
 996 
 997 #if DUMP_HASHTABLE_STATS_PER_TABLE
 998             m_stats-&gt;recordCollisionAtCount(probeCount);
 999 #endif
1000 
1001             if (k == 0)
1002                 k = 1 | doubleHash(h);
1003             i = (i + k) &amp; sizeMask;
1004         }
1005 
1006         if (deletedEntry) {
1007             initializeBucket(*deletedEntry);
1008             entry = deletedEntry;
<span class="line-modified">1009             setDeletedCount(deletedCount() - 1);</span>
1010         }
1011 
1012         HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra));
<span class="line-modified">1013         setKeyCount(keyCount() + 1);</span>
1014 
1015         if (shouldExpand())
1016             entry = expand(entry);
1017 
1018         internalCheckTableConsistency();
1019 
1020         return AddResult(makeKnownGoodIterator(entry), true);
1021     }
1022 
1023     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1024     template&lt;typename HashTranslator, typename T, typename Extra&gt;
1025     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp; extra) -&gt; AddResult
1026     {
1027         checkKey&lt;HashTranslator&gt;(key);
1028 
1029         invalidateIterators();
1030 
1031         if (!m_table)
1032             expand();
1033 
1034         internalCheckTableConsistency();
1035 
1036         FullLookupType lookupResult = fullLookupForWriting&lt;HashTranslator&gt;(key);
1037 
1038         ValueType* entry = lookupResult.first.first;
1039         bool found = lookupResult.first.second;
1040         unsigned h = lookupResult.second;
1041 
1042         if (found)
1043             return AddResult(makeKnownGoodIterator(entry), false);
1044 
1045         if (isDeletedBucket(*entry)) {
1046             initializeBucket(*entry);
<span class="line-modified">1047             setDeletedCount(deletedCount() - 1);</span>
1048         }
1049 
1050         HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra), h);
<span class="line-modified">1051         setKeyCount(keyCount() + 1);</span>
1052 
1053         if (shouldExpand())
1054             entry = expand(entry);
1055 
1056         internalCheckTableConsistency();
1057 
1058         return AddResult(makeKnownGoodIterator(entry), true);
1059     }
1060 
1061     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1062     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::reinsert(ValueType&amp;&amp; entry) -&gt; ValueType*
1063     {
1064         ASSERT(m_table);
1065         ASSERT(!lookupForWriting(Extractor::extract(entry)).second);
1066         ASSERT(!isDeletedBucket(*(lookupForWriting(Extractor::extract(entry)).first)));
1067 #if DUMP_HASHTABLE_STATS
1068         ++HashTableStats::numReinserts;
1069 #endif
1070 #if DUMP_HASHTABLE_STATS_PER_TABLE
1071         ++m_stats-&gt;numReinserts;
</pre>
<hr />
<pre>
1125 
1126     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1127     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeAndInvalidate(ValueType* pos)
1128     {
1129         invalidateIterators();
1130         internalCheckTableConsistency();
1131         remove(pos);
1132     }
1133 
1134     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1135     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(ValueType* pos)
1136     {
1137 #if DUMP_HASHTABLE_STATS
1138         ++HashTableStats::numRemoves;
1139 #endif
1140 #if DUMP_HASHTABLE_STATS_PER_TABLE
1141         ++m_stats-&gt;numRemoves;
1142 #endif
1143 
1144         deleteBucket(*pos);
<span class="line-modified">1145         setDeletedCount(deletedCount() + 1);</span>
<span class="line-modified">1146         setKeyCount(keyCount() - 1);</span>
1147 
1148         if (shouldShrink())
1149             shrink();
1150 
1151         internalCheckTableConsistency();
1152     }
1153 
1154     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1155     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(iterator it)
1156     {
1157         if (it == end())
1158             return;
1159 
1160         removeAndInvalidate(const_cast&lt;ValueType*&gt;(it.m_iterator.m_position));
1161     }
1162 
1163     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1164     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeWithoutEntryConsistencyCheck(iterator it)
1165     {
1166         if (it == end())
</pre>
<hr />
<pre>
1177 
1178         removeAndInvalidateWithoutEntryConsistencyCheck(const_cast&lt;ValueType*&gt;(it.m_position));
1179     }
1180 
1181     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1182     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(const KeyType&amp; key)
1183     {
1184         remove(find(key));
1185     }
1186 
1187     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1188     template&lt;typename Functor&gt;
1189     inline bool HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeIf(const Functor&amp; functor)
1190     {
1191         // We must use local copies in case &quot;functor&quot; or &quot;deleteBucket&quot;
1192         // make a function call, which prevents the compiler from keeping
1193         // the values in register.
1194         unsigned removedBucketCount = 0;
1195         ValueType* table = m_table;
1196 
<span class="line-modified">1197         for (unsigned i = tableSize(); i--;) {</span>
1198             ValueType&amp; bucket = table[i];
1199             if (isEmptyOrDeletedBucket(bucket))
1200                 continue;
1201 
1202             if (!functor(bucket))
1203                 continue;
1204 
1205             deleteBucket(bucket);
1206             ++removedBucketCount;
1207         }
<span class="line-modified">1208         if (removedBucketCount) {</span>
<span class="line-modified">1209             setDeletedCount(deletedCount() + removedBucketCount);</span>
<span class="line-added">1210             setKeyCount(keyCount() - removedBucketCount);</span>
<span class="line-added">1211         }</span>
1212 
1213         if (shouldShrink())
1214             shrinkToBestSize();
1215 
1216         internalCheckTableConsistency();
1217         return removedBucketCount;
1218     }
1219 
1220     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1221     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::allocateTable(unsigned size) -&gt; ValueType*
1222     {
<span class="line-added">1223         static_assert(!(metadataSize % alignof(ValueType)));</span>
<span class="line-added">1224 </span>
1225         // would use a template member function with explicit specializations here, but
1226         // gcc doesn&#39;t appear to support that
1227         if (Traits::emptyValueIsZero)
<span class="line-modified">1228             return reinterpret_cast_ptr&lt;ValueType*&gt;(static_cast&lt;char*&gt;(HashTableMalloc::zeroedMalloc(metadataSize + size * sizeof(ValueType))) + metadataSize);</span>
<span class="line-modified">1229 </span>
<span class="line-added">1230         ValueType* result = reinterpret_cast_ptr&lt;ValueType*&gt;(static_cast&lt;char*&gt;(HashTableMalloc::malloc(metadataSize + size * sizeof(ValueType))) + metadataSize);</span>
1231         for (unsigned i = 0; i &lt; size; i++)
1232             initializeBucket(result[i]);
1233         return result;
1234     }
1235 
1236     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
<span class="line-modified">1237     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deallocateTable(ValueType* table)</span>
1238     {
<span class="line-added">1239         unsigned size = reinterpret_cast_ptr&lt;unsigned*&gt;(table)[tableSizeOffset];</span>
1240         for (unsigned i = 0; i &lt; size; ++i) {
1241             if (!isDeletedBucket(table[i]))
1242                 table[i].~ValueType();
1243         }
<span class="line-modified">1244         HashTableMalloc::free(reinterpret_cast&lt;char*&gt;(table) - metadataSize);</span>
1245     }
1246 
1247     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1248     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::expand(ValueType* entry) -&gt; ValueType*
1249     {
1250         if (KeyTraits::hasIsReleasedWeakValueFunction)
1251             deleteReleasedWeakBuckets();
1252 
1253         unsigned newSize;
<span class="line-modified">1254         unsigned oldSize = tableSize();</span>
<span class="line-added">1255         if (!oldSize)</span>
1256             newSize = KeyTraits::minimumTableSize;
1257         else if (mustRehashInPlace())
<span class="line-modified">1258             newSize = oldSize;</span>
1259         else
<span class="line-modified">1260             newSize = oldSize * 2;</span>
1261 
1262         return rehash(newSize, entry);
1263     }
1264 
1265     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1266     constexpr unsigned HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::computeBestTableSize(unsigned keyCount)
1267     {
<span class="line-modified">1268         unsigned bestTableSize = WTF::roundUpToPowerOfTwo(keyCount);</span>
1269 
<span class="line-modified">1270         if (HashTableSizePolicy::shouldExpand(keyCount, bestTableSize))</span>




1271             bestTableSize *= 2;
1272 
<span class="line-added">1273         auto aboveThresholdForEagerExpansion = [](double loadFactor, unsigned keyCount, unsigned tableSize)</span>
<span class="line-added">1274         {</span>
<span class="line-added">1275             // Here is the rationale behind this calculation, using 3/4 load-factor.</span>
<span class="line-added">1276             // With maxLoad at 3/4 and minLoad at 1/6, our average load is 11/24.</span>
<span class="line-added">1277             // If we are getting half-way between 11/24 and 3/4, we double the size</span>
<span class="line-added">1278             // to avoid being too close to loadMax and bring the ratio close to 11/24. This</span>
<span class="line-added">1279             // give us a load in the bounds [9/24, 15/24).</span>
<span class="line-added">1280             double maxLoadRatio = loadFactor;</span>
<span class="line-added">1281             double minLoadRatio = 1.0 / minLoad;</span>
<span class="line-added">1282             double averageLoadRatio = (maxLoadRatio + minLoadRatio) / 2;</span>
<span class="line-added">1283             double halfWayBetweenAverageAndMaxLoadRatio = (averageLoadRatio + maxLoadRatio) / 2;</span>
<span class="line-added">1284             return keyCount &gt;= tableSize * halfWayBetweenAverageAndMaxLoadRatio;</span>
<span class="line-added">1285         };</span>
<span class="line-added">1286 </span>
<span class="line-added">1287         if (bestTableSize &lt;= maxSmallTableCapacity) {</span>
<span class="line-added">1288             constexpr double smallLoadFactor = static_cast&lt;double&gt;(smallMaxLoadNumerator) / smallMaxLoadDenominator;</span>
<span class="line-added">1289             if (aboveThresholdForEagerExpansion(smallLoadFactor, keyCount, bestTableSize))</span>
<span class="line-added">1290                 bestTableSize *= 2;</span>
<span class="line-added">1291         } else {</span>
<span class="line-added">1292             constexpr double largeLoadFactor = static_cast&lt;double&gt;(largeMaxLoadNumerator) / largeMaxLoadDenominator;</span>
<span class="line-added">1293             if (aboveThresholdForEagerExpansion(largeLoadFactor, keyCount, bestTableSize))</span>
<span class="line-added">1294                 bestTableSize *= 2;</span>
<span class="line-added">1295         }</span>
1296         unsigned minimumTableSize = KeyTraits::minimumTableSize;
1297         return std::max(bestTableSize, minimumTableSize);
1298     }
1299 
1300     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1301     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::shrinkToBestSize()
1302     {
1303         unsigned minimumTableSize = KeyTraits::minimumTableSize;
<span class="line-modified">1304         rehash(std::max(minimumTableSize, computeBestTableSize(keyCount())), nullptr);</span>
1305     }
1306 
1307     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1308     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deleteReleasedWeakBuckets()
1309     {
<span class="line-modified">1310         unsigned tableSize = this-&gt;tableSize();</span>
<span class="line-added">1311         for (unsigned i = 0; i &lt; tableSize; ++i) {</span>
1312             auto&amp; entry = m_table[i];
1313             if (isReleasedWeakBucket(entry)) {
1314                 deleteBucket(entry);
<span class="line-modified">1315                 setDeletedCount(deletedCount() + 1);</span>
<span class="line-modified">1316                 setKeyCount(keyCount() - 1);</span>
1317             }
1318         }
1319     }
1320 
1321     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1322     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::rehash(unsigned newTableSize, ValueType* entry) -&gt; ValueType*
1323     {
1324         internalCheckTableConsistencyExceptSize();
1325 
<span class="line-modified">1326         unsigned oldTableSize = tableSize();</span>
1327         ValueType* oldTable = m_table;
1328 
1329 #if DUMP_HASHTABLE_STATS
1330         if (oldTableSize != 0)
1331             ++HashTableStats::numRehashes;
1332 #endif
1333 
1334 #if DUMP_HASHTABLE_STATS_PER_TABLE
1335         if (oldTableSize != 0)
1336             ++m_stats-&gt;numRehashes;
1337 #endif
1338 
<span class="line-modified">1339         unsigned oldKeyCount = keyCount();</span>

1340         m_table = allocateTable(newTableSize);
<span class="line-added">1341         setTableSize(newTableSize);</span>
<span class="line-added">1342         setTableSizeMask(newTableSize - 1);</span>
<span class="line-added">1343         setDeletedCount(0);</span>
<span class="line-added">1344         setKeyCount(oldKeyCount);</span>
1345 
1346         Value* newEntry = nullptr;
1347         for (unsigned i = 0; i != oldTableSize; ++i) {
1348             auto&amp; oldEntry = oldTable[i];
1349             if (isDeletedBucket(oldEntry)) {
1350                 ASSERT(std::addressof(oldEntry) != entry);
1351                 continue;
1352             }
1353 
1354             if (isEmptyBucket(oldEntry)) {
1355                 ASSERT(std::addressof(oldEntry) != entry);
1356                 oldTable[i].~ValueType();
1357                 continue;
1358             }
1359 
1360             if (isReleasedWeakBucket(oldEntry)) {
1361                 ASSERT(std::addressof(oldEntry) != entry);
1362                 oldEntry.~ValueType();
<span class="line-modified">1363                 setKeyCount(keyCount() - 1);</span>
1364                 continue;
1365             }
1366 
1367             Value* reinsertedEntry = reinsert(WTFMove(oldEntry));
1368             oldEntry.~ValueType();
1369             if (std::addressof(oldEntry) == entry) {
1370                 ASSERT(!newEntry);
1371                 newEntry = reinsertedEntry;
1372             }
1373         }
1374 
<span class="line-modified">1375         if (oldTable)</span>
<span class="line-modified">1376             HashTableMalloc::free(reinterpret_cast&lt;char*&gt;(oldTable) - metadataSize);</span>

1377 
1378         internalCheckTableConsistency();
1379         return newEntry;
1380     }
1381 
1382     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1383     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::clear()
1384     {
1385         invalidateIterators();
1386         if (!m_table)
1387             return;
1388 
<span class="line-modified">1389         deallocateTable(m_table);</span>
<span class="line-modified">1390         m_table = nullptr;</span>




1391     }
1392 
1393     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1394     HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(const HashTable&amp; other)
1395         : m_table(nullptr)




1396 #if CHECK_HASHTABLE_ITERATORS
1397         , m_iterators(nullptr)
1398         , m_mutex(makeUnique&lt;Lock&gt;())
1399 #endif
1400 #if DUMP_HASHTABLE_STATS_PER_TABLE
1401         , m_stats(makeUnique&lt;Stats&gt;(*other.m_stats))
1402 #endif
1403     {
1404         unsigned otherKeyCount = other.size();
1405         if (!otherKeyCount)
1406             return;
1407 
<span class="line-modified">1408         unsigned bestTableSize = computeBestTableSize(otherKeyCount);</span>
<span class="line-modified">1409         m_table = allocateTable(bestTableSize);</span>
<span class="line-modified">1410         setTableSize(bestTableSize);</span>
<span class="line-modified">1411         setTableSizeMask(bestTableSize - 1);</span>
<span class="line-added">1412         setKeyCount(otherKeyCount);</span>
<span class="line-added">1413         setDeletedCount(0);</span>
1414 
1415         for (const auto&amp; otherValue : other)
1416             addUniqueForInitialization&lt;IdentityTranslatorType&gt;(Extractor::extract(otherValue), otherValue);
1417     }
1418 
1419     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1420     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::swap(HashTable&amp; other)
1421     {
1422         invalidateIterators();
1423         other.invalidateIterators();
1424 
1425         std::swap(m_table, other.m_table);




1426 
1427 #if DUMP_HASHTABLE_STATS_PER_TABLE
1428         m_stats.swap(other.m_stats);
1429 #endif
1430     }
1431 
1432     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1433     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::operator=(const HashTable&amp; other) -&gt; HashTable&amp;
1434     {
1435         HashTable tmp(other);
1436         swap(tmp);
1437         return *this;
1438     }
1439 
1440     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1441     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(HashTable&amp;&amp; other)
1442 #if CHECK_HASHTABLE_ITERATORS
1443         : m_iterators(nullptr)
1444         , m_mutex(makeUnique&lt;Lock&gt;())
1445 #endif
1446     {
1447         other.invalidateIterators();
1448 
<span class="line-modified">1449         m_table = std::exchange(other.m_table, nullptr);</span>










1450 
1451 #if DUMP_HASHTABLE_STATS_PER_TABLE
1452         m_stats = WTFMove(other.m_stats);
1453         other.m_stats = nullptr;
1454 #endif
1455     }
1456 
1457     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1458     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::operator=(HashTable&amp;&amp; other) -&gt; HashTable&amp;
1459     {
1460         HashTable temp = WTFMove(other);
1461         swap(temp);
1462         return *this;
1463     }
1464 
<span class="line-modified">1465 #if ASSERT_ENABLED</span>
1466 
1467     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1468     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkTableConsistency() const
1469     {
1470         checkTableConsistencyExceptSize();
1471         ASSERT(!m_table || !shouldExpand());
1472         ASSERT(!shouldShrink());
1473     }
1474 
1475     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1476     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkTableConsistencyExceptSize() const
1477     {
1478         if (!m_table)
1479             return;
1480 
1481         unsigned count = 0;
1482         unsigned deletedCount = 0;
<span class="line-modified">1483         unsigned tableSize = this-&gt;tableSize();</span>
<span class="line-added">1484         for (unsigned j = 0; j &lt; tableSize; ++j) {</span>
1485             ValueType* entry = m_table + j;
1486             if (isEmptyBucket(*entry))
1487                 continue;
1488 
1489             if (isDeletedBucket(*entry)) {
1490                 ++deletedCount;
1491                 continue;
1492             }
1493 
1494             auto&amp; key = Extractor::extract(*entry);
1495             const_iterator it = find(key);
1496             ASSERT(entry == it.m_position);
1497             ++count;
1498 
1499             ValueCheck&lt;Key&gt;::checkConsistency(key);
1500         }
1501 
<span class="line-modified">1502         ASSERT(count == keyCount());</span>
<span class="line-modified">1503         ASSERT(deletedCount == this-&gt;deletedCount());</span>
<span class="line-modified">1504         ASSERT(this-&gt;tableSize() &gt;= KeyTraits::minimumTableSize);</span>
<span class="line-modified">1505         ASSERT(tableSizeMask());</span>
<span class="line-modified">1506         ASSERT(this-&gt;tableSize() == tableSizeMask() + 1);</span>
1507     }
1508 
<span class="line-modified">1509 #endif // ASSERT_ENABLED</span>
1510 
1511 #if CHECK_HASHTABLE_ITERATORS
1512 
1513     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1514     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::invalidateIterators()
1515     {
1516         std::lock_guard&lt;Lock&gt; lock(*m_mutex);
1517         const_iterator* next;
1518         for (const_iterator* p = m_iterators; p; p = next) {
1519             next = p-&gt;m_next;
1520             p-&gt;m_table = 0;
1521             p-&gt;m_next = 0;
1522             p-&gt;m_previous = 0;
1523         }
1524         m_iterators = 0;
1525     }
1526 
1527     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1528     void addIterator(const HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;* table,
1529         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;* it)
</pre>
</td>
</tr>
</table>
<center><a href="HashTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HashTraits.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.h b/modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2006-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2006-2020 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -173,13 +173,11 @@
     void updateDragStateAfterEditDragIfNeeded(Element& rootEditableElement);
     RefPtr<Element> draggedElement() const;
 #endif
 
     void scheduleHoverStateUpdate();
-#if ENABLE(CURSOR_SUPPORT)
     void scheduleCursorUpdate();
-#endif
 
     void setResizingFrameSet(HTMLFrameSetElement*);
 
     void resizeLayerDestroyed();
 
@@ -220,18 +218,20 @@
     void platformNotifyIfEndGesture(const PlatformWheelEvent&, const WeakPtr<ScrollableArea>&);
 
 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS)
     using TouchArray = Vector<RefPtr<Touch>>;
     using EventTargetTouchMap = HashMap<EventTarget*, TouchArray*>;
+    using EventTargetTouchArrayMap = HashMap<Ref<EventTarget>, std::unique_ptr<TouchArray>>;
 #endif
 
 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
     using EventTargetSet = HashSet<RefPtr<EventTarget>>;
 #endif
 
 #if ENABLE(IOS_TOUCH_EVENTS)
     bool dispatchTouchEvent(const PlatformTouchEvent&, const AtomString&, const EventTargetTouchMap&, float, float);
+    bool dispatchTouchEvent(const PlatformTouchEvent&, const AtomString&, const EventTargetTouchArrayMap&, float, float);
     bool dispatchSimulatedTouchEvent(IntPoint location);
     Frame* touchEventTargetSubframe() const { return m_touchEventTargetSubframe.get(); }
     const TouchArray& touches() const { return m_touches; }
 #endif
 
@@ -246,11 +246,11 @@
     void defaultTouchEventHandler(Node&, TouchEvent&);
     WEBCORE_EXPORT void dispatchSyntheticMouseOut(const PlatformMouseEvent&);
     WEBCORE_EXPORT void dispatchSyntheticMouseMove(const PlatformMouseEvent&);
 #endif
 
-#if ENABLE(CONTEXT_MENUS)
+#if ENABLE(CONTEXT_MENU_EVENT)
     WEBCORE_EXPORT bool sendContextMenuEvent(const PlatformMouseEvent&);
     WEBCORE_EXPORT bool sendContextMenuEventForKey();
 #endif
 
     void setMouseDownMayStartAutoscroll() { m_mouseDownMayStartAutoscroll = true; }
@@ -339,14 +339,14 @@
 #endif
 
 #if PLATFORM(IOS_FAMILY)
     WEBCORE_EXPORT void startSelectionAutoscroll(RenderObject* renderer, const FloatPoint& positionInWindow);
     WEBCORE_EXPORT void cancelSelectionAutoscroll();
-    IntPoint m_targetAutoscrollPositionInWindow;
-    bool m_isAutoscrolling { false };
 #endif
 
+    WEBCORE_EXPORT Optional<Cursor> selectCursor(const HitTestResult&, bool shiftKey);
+
 private:
 #if ENABLE(DRAG_SUPPORT)
     static DragState& dragState();
     static const Seconds TextDragDelay;
 #endif
@@ -373,18 +373,14 @@
 
     WEBCORE_EXPORT bool handleMouseReleaseEvent(const MouseEventWithHitTestResults&);
 
     bool internalKeyEvent(const PlatformKeyboardEvent&);
 
-    Optional<Cursor> selectCursor(const HitTestResult&, bool shiftKey);
     void updateCursor(FrameView&, const HitTestResult&, bool shiftKey);
 
     void hoverTimerFired();
-
-#if ENABLE(CURSOR_SUPPORT)
     void cursorUpdateTimerFired();
-#endif
 
     bool logicalScrollOverflow(ScrollLogicalDirection, ScrollGranularity, Node* startingNode = nullptr);
 
     bool shouldSwapScrollDirection(const HitTestResult&, const PlatformWheelEvent&) const;
 
@@ -428,11 +424,12 @@
     bool handleMouseUp(const MouseEventWithHitTestResults&);
 
 #if ENABLE(DRAG_SUPPORT)
     void clearDragState();
 
-    void dispatchDragSrcEvent(const AtomString& eventType, const PlatformMouseEvent&);
+    static bool shouldDispatchEventsToDragSourceElement();
+    void dispatchEventToDragSourceElement(const AtomString& eventType, const PlatformMouseEvent&);
     bool dispatchDragStartEventOnSourceElement(DataTransfer&);
 
     bool dragHysteresisExceeded(const FloatPoint&) const;
     bool dragHysteresisExceeded(const IntPoint&) const;
 #endif
@@ -501,10 +498,12 @@
     void clearOrScheduleClearingLatchedStateIfNeeded(const PlatformWheelEvent&);
     void clearLatchedState();
 
     bool shouldSendMouseEventsToInactiveWindows() const;
 
+    bool canMouseDownStartSelect(const MouseEventWithHitTestResults&);
+
     Frame& m_frame;
 
     bool m_mousePressed { false };
     bool m_capturesDragging { false };
     RefPtr<Node> m_mousePressNode;
@@ -523,14 +522,11 @@
 #if ENABLE(DRAG_SUPPORT)
     LayoutPoint m_dragStartPosition;
 #endif
 
     Timer m_hoverTimer;
-
-#if ENABLE(CURSOR_SUPPORT)
     Timer m_cursorUpdateTimer;
-#endif
 
 #if PLATFORM(MAC)
     Timer m_pendingMomentumWheelEventsTimer;
 #endif
 
@@ -628,10 +624,12 @@
     bool m_didStartDrag { false };
     bool m_isHandlingWheelEvent { false };
 
 #if PLATFORM(IOS_FAMILY)
     bool m_shouldAllowMouseDownToStartDrag { false };
+    IntPoint m_targetAutoscrollPositionInWindow;
+    bool m_isAutoscrolling { false };
 #endif
 
 #if ENABLE(CURSOR_VISIBILITY)
     Timer m_autoHideCursorTimer;
 #endif

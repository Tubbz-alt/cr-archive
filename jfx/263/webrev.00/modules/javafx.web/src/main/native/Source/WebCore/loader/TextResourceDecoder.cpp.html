<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/TextResourceDecoder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2     Copyright (C) 1999 Lars Knoll (knoll@mpi-hd.mpg.de)
  3     Copyright (C) 2003-2017 Apple Inc. All rights reserved.
  4     Copyright (C) 2005, 2006, 2007 Alexey Proskuryakov (ap@nypop.com)
  5 
  6     This library is free software; you can redistribute it and/or
  7     modify it under the terms of the GNU Library General Public
  8     License as published by the Free Software Foundation; either
  9     version 2 of the License, or (at your option) any later version.
 10 
 11     This library is distributed in the hope that it will be useful,
 12     but WITHOUT ANY WARRANTY; without even the implied warranty of
 13     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14     Library General Public License for more details.
 15 
 16     You should have received a copy of the GNU Library General Public License
 17     along with this library; see the file COPYING.LIB.  If not, write to
 18     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19     Boston, MA 02110-1301, USA.
 20 */
 21 
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;TextResourceDecoder.h&quot;
 25 
 26 #include &quot;HTMLMetaCharsetParser.h&quot;
 27 #include &quot;HTMLNames.h&quot;
 28 #include &quot;MIMETypeRegistry.h&quot;
 29 #include &quot;TextCodec.h&quot;
 30 #include &quot;TextEncoding.h&quot;
 31 #include &quot;TextEncodingDetector.h&quot;
 32 #include &quot;TextEncodingRegistry.h&quot;
 33 #include &lt;wtf/ASCIICType.h&gt;
 34 
 35 
 36 namespace WebCore {
 37 
 38 using namespace HTMLNames;
 39 
 40 static constexpr bool bytesEqual(const char* p, char b)
 41 {
 42     return *p == b;
 43 }
 44 
 45 template&lt;typename... T&gt;
 46 static constexpr bool bytesEqual(const char* p, char b, T... bs)
 47 {
 48     return *p == b &amp;&amp; bytesEqual(p + 1, bs...);
 49 }
 50 
 51 // You might think we should put these find functions elsewhere, perhaps with the
 52 // similar functions that operate on UChar, but arguably only the decoder has
 53 // a reason to process strings of char rather than UChar.
 54 
 55 static int find(const char* subject, size_t subjectLength, const char* target)
 56 {
 57     size_t targetLength = strlen(target);
 58     if (targetLength &gt; subjectLength)
 59         return -1;
 60     for (size_t i = 0; i &lt;= subjectLength - targetLength; ++i) {
 61         bool match = true;
 62         for (size_t j = 0; j &lt; targetLength; ++j) {
 63             if (subject[i + j] != target[j]) {
 64                 match = false;
 65                 break;
 66             }
 67         }
 68         if (match)
 69             return i;
 70     }
 71     return -1;
 72 }
 73 
 74 static TextEncoding findTextEncoding(const char* encodingName, int length)
 75 {
 76     Vector&lt;char, 64&gt; buffer(length + 1);
 77     memcpy(buffer.data(), encodingName, length);
 78     buffer[length] = &#39;\0&#39;;
 79     return buffer.data();
 80 }
 81 
 82 class KanjiCode {
 83 public:
 84     enum Type { ASCII, JIS, EUC, SJIS, UTF16, UTF8 };
 85     static enum Type judge(const char* str, int length);
 86     static const int ESC = 0x1b;
 87     static const unsigned char sjisMap[256];
 88     static int ISkanji(int code)
 89     {
 90         if (code &gt;= 0x100)
 91             return 0;
 92         return sjisMap[code &amp; 0xff] &amp; 1;
 93     }
 94     static int ISkana(int code)
 95     {
 96         if (code &gt;= 0x100)
 97             return 0;
 98         return sjisMap[code &amp; 0xff] &amp; 2;
 99     }
100 };
101 
102 const unsigned char KanjiCode::sjisMap[256] = {
103     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
104     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
105     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
106     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
107     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
108     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
109     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
110     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
111     0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
112     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
113     0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
114     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
115     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
116     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
117     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
118     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0
119 };
120 
121 /*
122  * EUC-JP is
123  *     [0xa1 - 0xfe][0xa1 - 0xfe]
124  *     0x8e[0xa1 - 0xfe](SS2)
125  *     0x8f[0xa1 - 0xfe][0xa1 - 0xfe](SS3)
126  *
127  * Shift_Jis is
128  *     [0x81 - 0x9f, 0xe0 - 0xef(0xfe?)][0x40 - 0x7e, 0x80 - 0xfc]
129  *
130  * Shift_Jis Hankaku Kana is
131  *     [0xa1 - 0xdf]
132  */
133 
134 /*
135  * KanjiCode::judge() is based on judge_jcode() from jvim
136  *     http://hp.vector.co.jp/authors/VA003457/vim/
137  *
138  * Special Thanks to Kenichi Tsuchida
139  */
140 
141 enum KanjiCode::Type KanjiCode::judge(const char* str, int size)
142 {
143     enum Type code;
144     int i;
145     int bfr = false;            /* Kana Moji */
146     int bfk = 0;                /* EUC Kana */
147     int sjis = 0;
148     int euc = 0;
149 
150     const unsigned char* ptr = reinterpret_cast&lt;const unsigned char*&gt;(str);
151 
152     code = ASCII;
153 
154     i = 0;
155     while (i &lt; size) {
156         if (ptr[i] == ESC &amp;&amp; (size - i &gt;= 3)) {
157             if (bytesEqual(str + i + 1, &#39;$&#39;, &#39;B&#39;)
158                     || bytesEqual(str + i + 1, &#39;(&#39;, &#39;B&#39;)
159                     || bytesEqual(str + i + 1, &#39;$&#39;, &#39;@&#39;)
160                     || bytesEqual(str + i + 1, &#39;(&#39;, &#39;J&#39;)) {
161                 code = JIS;
162                 goto breakBreak;
163             }
164             if (bytesEqual(str + i + 1, &#39;(&#39;, &#39;I&#39;) || bytesEqual(str + i + 1, &#39;)&#39;, &#39;I&#39;)) {
165                 code = JIS;
166                 i += 3;
167             } else {
168                 i++;
169             }
170             bfr = false;
171             bfk = 0;
172         } else {
173             if (ptr[i] &lt; 0x20) {
174                 bfr = false;
175                 bfk = 0;
176                 /* ?? check kudokuten ?? &amp;&amp; ?? hiragana ?? */
177                 if ((i &gt;= 2) &amp;&amp; (ptr[i - 2] == 0x81)
178                         &amp;&amp; (0x41 &lt;= ptr[i - 1] &amp;&amp; ptr[i - 1] &lt;= 0x49)) {
179                     code = SJIS;
180                     sjis += 100;        /* kudokuten */
181                 } else if ((i &gt;= 2) &amp;&amp; (ptr[i - 2] == 0xa1)
182                         &amp;&amp; (0xa2 &lt;= ptr[i - 1] &amp;&amp; ptr[i - 1] &lt;= 0xaa)) {
183                     code = EUC;
184                     euc += 100;         /* kudokuten */
185                 } else if ((i &gt;= 2) &amp;&amp; (ptr[i - 2] == 0x82) &amp;&amp; (0xa0 &lt;= ptr[i - 1])) {
186                     sjis += 40;         /* hiragana */
187                 } else if ((i &gt;= 2) &amp;&amp; (ptr[i - 2] == 0xa4) &amp;&amp; (0xa0 &lt;= ptr[i - 1])) {
188                     euc += 40;          /* hiragana */
189                 }
190             } else {
191                 /* ?? check hiragana or katana ?? */
192                 if ((size - i &gt; 1) &amp;&amp; (ptr[i] == 0x82) &amp;&amp; (0xa0 &lt;= ptr[i + 1])) {
193                     sjis++;     /* hiragana */
194                 } else if ((size - i &gt; 1) &amp;&amp; (ptr[i] == 0x83)
195                          &amp;&amp; (0x40 &lt;= ptr[i + 1] &amp;&amp; ptr[i + 1] &lt;= 0x9f)) {
196                     sjis++;     /* katakana */
197                 } else if ((size - i &gt; 1) &amp;&amp; (ptr[i] == 0xa4) &amp;&amp; (0xa0 &lt;= ptr[i + 1])) {
198                     euc++;      /* hiragana */
199                 } else if ((size - i &gt; 1) &amp;&amp; (ptr[i] == 0xa5) &amp;&amp; (0xa0 &lt;= ptr[i + 1])) {
200                     euc++;      /* katakana */
201                 }
202                 if (bfr) {
203                     if ((i &gt;= 1) &amp;&amp; (0x40 &lt;= ptr[i] &amp;&amp; ptr[i] &lt;= 0xa0) &amp;&amp; ISkanji(ptr[i - 1])) {
204                         code = SJIS;
205                         goto breakBreak;
206                     } else if ((i &gt;= 1) &amp;&amp; (0x81 &lt;= ptr[i - 1] &amp;&amp; ptr[i - 1] &lt;= 0x9f) &amp;&amp; ((0x40 &lt;= ptr[i] &amp;&amp; ptr[i] &lt; 0x7e) || (0x7e &lt; ptr[i] &amp;&amp; ptr[i] &lt;= 0xfc))) {
207                         code = SJIS;
208                         goto breakBreak;
209                     } else if ((i &gt;= 1) &amp;&amp; (0xfd &lt;= ptr[i] &amp;&amp; ptr[i] &lt;= 0xfe) &amp;&amp; (0xa1 &lt;= ptr[i - 1] &amp;&amp; ptr[i - 1] &lt;= 0xfe)) {
210                         code = EUC;
211                         goto breakBreak;
212                     } else if ((i &gt;= 1) &amp;&amp; (0xfd &lt;= ptr[i - 1] &amp;&amp; ptr[i - 1] &lt;= 0xfe) &amp;&amp; (0xa1 &lt;= ptr[i] &amp;&amp; ptr[i] &lt;= 0xfe)) {
213                         code = EUC;
214                         goto breakBreak;
215                     } else if ((i &gt;= 1) &amp;&amp; (ptr[i] &lt; 0xa0 || 0xdf &lt; ptr[i]) &amp;&amp; (0x8e == ptr[i - 1])) {
216                         code = SJIS;
217                         goto breakBreak;
218                     } else if (ptr[i] &lt;= 0x7f) {
219                         code = SJIS;
220                         goto breakBreak;
221                     } else {
222                         if (0xa1 &lt;= ptr[i] &amp;&amp; ptr[i] &lt;= 0xa6) {
223                             euc++;      /* sjis hankaku kana kigo */
224                         } else if (0xa1 &lt;= ptr[i] &amp;&amp; ptr[i] &lt;= 0xdf) {
225                             ;           /* sjis hankaku kana */
226                         } else if (0xa1 &lt;= ptr[i] &amp;&amp; ptr[i] &lt;= 0xfe) {
227                             euc++;
228                         } else if (0x8e == ptr[i]) {
229                             euc++;
230                         } else if (0x20 &lt;= ptr[i] &amp;&amp; ptr[i] &lt;= 0x7f) {
231                             sjis++;
232                         }
233                         bfr = false;
234                         bfk = 0;
235                     }
236                 } else if (0x8e == ptr[i]) {
237                     if (size - i &lt;= 1) {
238                         ;
239                     } else if (0xa1 &lt;= ptr[i + 1] &amp;&amp; ptr[i + 1] &lt;= 0xdf) {
240                         /* EUC KANA or SJIS KANJI */
241                         if (bfk == 1) {
242                             euc += 100;
243                         }
244                         bfk++;
245                         i++;
246                     } else {
247                         /* SJIS only */
248                         code = SJIS;
249                         goto breakBreak;
250                     }
251                 } else if (0x81 &lt;= ptr[i] &amp;&amp; ptr[i] &lt;= 0x9f) {
252                     /* SJIS only */
253                     code = SJIS;
254                     if ((size - i &gt;= 1)
255                             &amp;&amp; ((0x40 &lt;= ptr[i + 1] &amp;&amp; ptr[i + 1] &lt;= 0x7e)
256                             || (0x80 &lt;= ptr[i + 1] &amp;&amp; ptr[i + 1] &lt;= 0xfc))) {
257                         goto breakBreak;
258                     }
259                 } else if (0xfd &lt;= ptr[i] &amp;&amp; ptr[i] &lt;= 0xfe) {
260                     /* EUC only */
261                     code = EUC;
262                     if ((size - i &gt;= 1)
263                             &amp;&amp; (0xa1 &lt;= ptr[i + 1] &amp;&amp; ptr[i + 1] &lt;= 0xfe)) {
264                         goto breakBreak;
265                     }
266                 } else if (ptr[i] &lt;= 0x7f) {
267                     ;
268                 } else {
269                     bfr = true;
270                     bfk = 0;
271                 }
272             }
273             i++;
274         }
275     }
276     if (code == ASCII) {
277         if (sjis &gt; euc) {
278             code = SJIS;
279         } else if (sjis &lt; euc) {
280             code = EUC;
281         }
282     }
283 breakBreak:
284     return (code);
285 }
286 
287 TextResourceDecoder::ContentType TextResourceDecoder::determineContentType(const String&amp; mimeType)
288 {
289     if (equalLettersIgnoringASCIICase(mimeType, &quot;text/css&quot;))
290         return CSS;
291     if (equalLettersIgnoringASCIICase(mimeType, &quot;text/html&quot;))
292         return HTML;
293     if (MIMETypeRegistry::isXMLMIMEType(mimeType))
294         return XML;
295     return PlainText;
296 }
297 
298 const TextEncoding&amp; TextResourceDecoder::defaultEncoding(ContentType contentType, const TextEncoding&amp; specifiedDefaultEncoding)
299 {
300     // Despite 8.5 &quot;Text/xml with Omitted Charset&quot; of RFC 3023, we assume UTF-8 instead of US-ASCII
301     // for text/xml. This matches Firefox.
302     if (contentType == XML)
303         return UTF8Encoding();
304     if (!specifiedDefaultEncoding.isValid())
305         return Latin1Encoding();
306     return specifiedDefaultEncoding;
307 }
308 
309 inline TextResourceDecoder::TextResourceDecoder(const String&amp; mimeType, const TextEncoding&amp; specifiedDefaultEncoding, bool usesEncodingDetector)
310     : m_contentType(determineContentType(mimeType))
311     , m_encoding(defaultEncoding(m_contentType, specifiedDefaultEncoding))
312     , m_usesEncodingDetector(usesEncodingDetector)
313 {
314 }
315 
316 Ref&lt;TextResourceDecoder&gt; TextResourceDecoder::create(const String&amp; mimeType, const TextEncoding&amp; defaultEncoding, bool usesEncodingDetector)
317 {
318     return adoptRef(*new TextResourceDecoder(mimeType, defaultEncoding, usesEncodingDetector));
319 }
320 
321 TextResourceDecoder::~TextResourceDecoder() = default;
322 
323 void TextResourceDecoder::setEncoding(const TextEncoding&amp; encoding, EncodingSource source)
324 {
325     // In case the encoding didn&#39;t exist, we keep the old one (helps some sites specifying invalid encodings).
326     if (!encoding.isValid())
327         return;
328 
329     // When encoding comes from meta tag (i.e. it cannot be XML files sent via XHR),
330     // treat x-user-defined as windows-1252 (bug 18270)
331     if (source == EncodingFromMetaTag &amp;&amp; equalLettersIgnoringASCIICase(encoding.name(), &quot;x-user-defined&quot;))
332         m_encoding = &quot;windows-1252&quot;;
333     else if (source == EncodingFromMetaTag || source == EncodingFromXMLHeader || source == EncodingFromCSSCharset)
334         m_encoding = encoding.closestByteBasedEquivalent();
335     else
336         m_encoding = encoding;
337 
338     m_codec = nullptr;
339     m_source = source;
340 }
341 
342 bool TextResourceDecoder::hasEqualEncodingForCharset(const String&amp; charset) const
343 {
344     return defaultEncoding(m_contentType, charset) == m_encoding;
345 }
346 
347 // Returns the position of the encoding string.
348 static int findXMLEncoding(const char* str, int len, int&amp; encodingLength)
349 {
350     int pos = find(str, len, &quot;encoding&quot;);
351     if (pos == -1)
352         return -1;
353     pos += 8;
354 
355     // Skip spaces and stray control characters.
356     while (pos &lt; len &amp;&amp; str[pos] &lt;= &#39; &#39;)
357         ++pos;
358 
359     // Skip equals sign.
360     if (pos &gt;= len || str[pos] != &#39;=&#39;)
361         return -1;
362     ++pos;
363 
364     // Skip spaces and stray control characters.
365     while (pos &lt; len &amp;&amp; str[pos] &lt;= &#39; &#39;)
366         ++pos;
367 
368     // Skip quotation mark.
369     if (pos &gt;= len)
370         return - 1;
371     char quoteMark = str[pos];
372     if (quoteMark != &#39;&quot;&#39; &amp;&amp; quoteMark != &#39;\&#39;&#39;)
373         return -1;
374     ++pos;
375 
376     // Find the trailing quotation mark.
377     int end = pos;
378     while (end &lt; len &amp;&amp; str[end] != quoteMark)
379         ++end;
380     if (end &gt;= len)
381         return -1;
382 
383     encodingLength = end - pos;
384     return pos;
385 }
386 
387 size_t TextResourceDecoder::checkForBOM(const char* data, size_t len)
388 {
389     // Check for UTF-16 or UTF-8 BOM mark at the beginning, which is a sure sign of a Unicode encoding.
390     // We let it override even a user-chosen encoding.
391     const size_t maximumBOMLength = 3;
392 
393     ASSERT(!m_checkedForBOM);
394 
395     size_t lengthOfBOM = 0;
396 
397     size_t bufferLength = m_buffer.size();
398 
399     size_t buf1Len = bufferLength;
400     size_t buf2Len = len;
401     const unsigned char* buf1 = reinterpret_cast&lt;const unsigned char*&gt;(m_buffer.data());
402     const unsigned char* buf2 = reinterpret_cast&lt;const unsigned char*&gt;(data);
403     unsigned char c1 = buf1Len ? (static_cast&lt;void&gt;(--buf1Len), *buf1++) : buf2Len ? (static_cast&lt;void&gt;(--buf2Len), *buf2++) : 0;
404     unsigned char c2 = buf1Len ? (static_cast&lt;void&gt;(--buf1Len), *buf1++) : buf2Len ? (static_cast&lt;void&gt;(--buf2Len), *buf2++) : 0;
405     unsigned char c3 = buf1Len ? (static_cast&lt;void&gt;(--buf1Len), *buf1++) : buf2Len ? (static_cast&lt;void&gt;(--buf2Len), *buf2++) : 0;
406 
407     // Check for the BOM.
408     if (c1 == 0xFF &amp;&amp; c2 == 0xFE) {
409         ASSERT(UTF16LittleEndianEncoding().isValid());
410         setEncoding(UTF16LittleEndianEncoding(), AutoDetectedEncoding);
411         lengthOfBOM = 2;
412     } else if (c1 == 0xFE &amp;&amp; c2 == 0xFF) {
413         ASSERT(UTF16BigEndianEncoding().isValid());
414         setEncoding(UTF16BigEndianEncoding(), AutoDetectedEncoding);
415         lengthOfBOM = 2;
416     } else if (c1 == 0xEF &amp;&amp; c2 == 0xBB &amp;&amp; c3 == 0xBF) {
417         ASSERT(UTF8Encoding().isValid());
418         setEncoding(UTF8Encoding(), AutoDetectedEncoding);
419         lengthOfBOM = 3;
420     }
421 
422     if (lengthOfBOM || bufferLength + len &gt;= maximumBOMLength)
423         m_checkedForBOM = true;
424 
425     ASSERT(lengthOfBOM &lt;= maximumBOMLength);
426     return lengthOfBOM;
427 }
428 
429 bool TextResourceDecoder::checkForCSSCharset(const char* data, size_t len, bool&amp; movedDataToBuffer)
430 {
431     if (m_source != DefaultEncoding &amp;&amp; m_source != EncodingFromParentFrame) {
432         m_checkedForCSSCharset = true;
433         return true;
434     }
435 
436     size_t oldSize = m_buffer.size();
437     m_buffer.grow(oldSize + len);
438     memcpy(m_buffer.data() + oldSize, data, len);
439 
440     movedDataToBuffer = true;
441 
442     if (m_buffer.size() &lt;= 13) // strlen(&#39;@charset &quot;x&quot;;&#39;) == 13
443         return false;
444 
445     const char* dataStart = m_buffer.data();
446     const char* dataEnd = dataStart + m_buffer.size();
447 
448     if (bytesEqual(dataStart, &#39;@&#39;, &#39;c&#39;, &#39;h&#39;, &#39;a&#39;, &#39;r&#39;, &#39;s&#39;, &#39;e&#39;, &#39;t&#39;, &#39; &#39;, &#39;&quot;&#39;)) {
449         dataStart += 10;
450         const char* pos = dataStart;
451 
452         while (pos &lt; dataEnd &amp;&amp; *pos != &#39;&quot;&#39;)
453             ++pos;
454         if (pos == dataEnd)
455             return false;
456 
457         int encodingNameLength = pos - dataStart;
458 
459         ++pos;
460         if (pos == dataEnd)
461             return false;
462 
463         if (*pos == &#39;;&#39;)
464             setEncoding(findTextEncoding(dataStart, encodingNameLength), EncodingFromCSSCharset);
465     }
466 
467     m_checkedForCSSCharset = true;
468     return true;
469 }
470 
471 bool TextResourceDecoder::checkForHeadCharset(const char* data, size_t len, bool&amp; movedDataToBuffer)
472 {
473     if (m_source != DefaultEncoding &amp;&amp; m_source != EncodingFromParentFrame) {
474         m_checkedForHeadCharset = true;
475         return true;
476     }
477 
478     // This is not completely efficient, since the function might go
479     // through the HTML head several times.
480 
481     size_t oldSize = m_buffer.size();
482     m_buffer.grow(oldSize + len);
483     memcpy(m_buffer.data() + oldSize, data, len);
484 
485     movedDataToBuffer = true;
486 
487     // Continue with checking for an HTML meta tag if we were already doing so.
488     if (m_charsetParser)
489         return checkForMetaCharset(data, len);
490 
491     const char* ptr = m_buffer.data();
492     const char* pEnd = ptr + m_buffer.size();
493 
494     // Is there enough data available to check for XML declaration?
495     if (m_buffer.size() &lt; 8)
496         return false;
497 
498     // Handle XML declaration, which can have encoding in it. This encoding is honored even for HTML documents.
499     // It is an error for an XML declaration not to be at the start of an XML document, and it is ignored in HTML documents in such case.
500     if (bytesEqual(ptr, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) {
501         const char* xmlDeclarationEnd = ptr;
502         while (xmlDeclarationEnd != pEnd &amp;&amp; *xmlDeclarationEnd != &#39;&gt;&#39;)
503             ++xmlDeclarationEnd;
504         if (xmlDeclarationEnd == pEnd)
505             return false;
506         // No need for +1, because we have an extra &quot;?&quot; to lose at the end of XML declaration.
507         int len = 0;
508         int pos = findXMLEncoding(ptr, xmlDeclarationEnd - ptr, len);
509         if (pos != -1)
510             setEncoding(findTextEncoding(ptr + pos, len), EncodingFromXMLHeader);
511         // continue looking for a charset - it may be specified in an HTTP-Equiv meta
512     } else if (bytesEqual(ptr, &#39;&lt;&#39;, 0, &#39;?&#39;, 0, &#39;x&#39;, 0)) {
513         setEncoding(UTF16LittleEndianEncoding(), AutoDetectedEncoding);
514         return true;
515     } else if (bytesEqual(ptr, 0, &#39;&lt;&#39;, 0, &#39;?&#39;, 0, &#39;x&#39;)) {
516         setEncoding(UTF16BigEndianEncoding(), AutoDetectedEncoding);
517         return true;
518     }
519 
520     // The HTTP-EQUIV meta has no effect on XHTML.
521     if (m_contentType == XML)
522         return true;
523 
524     m_charsetParser = makeUnique&lt;HTMLMetaCharsetParser&gt;();
525     return checkForMetaCharset(data, len);
526 }
527 
528 bool TextResourceDecoder::checkForMetaCharset(const char* data, size_t length)
529 {
530     if (!m_charsetParser-&gt;checkForMetaCharset(data, length))
531         return false;
532 
533     setEncoding(m_charsetParser-&gt;encoding(), EncodingFromMetaTag);
534     m_charsetParser = nullptr;
535     m_checkedForHeadCharset = true;
536     return true;
537 }
538 
539 void TextResourceDecoder::detectJapaneseEncoding(const char* data, size_t len)
540 {
541     switch (KanjiCode::judge(data, len)) {
542         case KanjiCode::JIS:
543             setEncoding(&quot;ISO-2022-JP&quot;, AutoDetectedEncoding);
544             break;
545         case KanjiCode::EUC:
546             setEncoding(&quot;EUC-JP&quot;, AutoDetectedEncoding);
547             break;
548         case KanjiCode::SJIS:
549             setEncoding(&quot;Shift_JIS&quot;, AutoDetectedEncoding);
550             break;
551         case KanjiCode::ASCII:
552         case KanjiCode::UTF16:
553         case KanjiCode::UTF8:
554             break;
555     }
556 }
557 
558 // We use the encoding detector in two cases:
559 //   1. Encoding detector is turned ON and no other encoding source is
560 //      available (that is, it&#39;s DefaultEncoding).
561 //   2. Encoding detector is turned ON and the encoding is set to
562 //      the encoding of the parent frame, which is also auto-detected.
563 //   Note that condition #2 is NOT satisfied unless parent-child frame
564 //   relationship is compliant to the same-origin policy. If they&#39;re from
565 //   different domains, |m_source| would not be set to EncodingFromParentFrame
566 //   in the first place.
567 bool TextResourceDecoder::shouldAutoDetect() const
568 {
569     return m_usesEncodingDetector
570         &amp;&amp; (m_source == DefaultEncoding || (m_source == EncodingFromParentFrame &amp;&amp; m_parentFrameAutoDetectedEncoding));
571 }
572 
573 String TextResourceDecoder::decode(const char* data, size_t length)
574 {
575     size_t lengthOfBOM = 0;
576     if (!m_checkedForBOM)
577         lengthOfBOM = checkForBOM(data, length);
578 
579     bool movedDataToBuffer = false;
580 
581     if (m_contentType == CSS &amp;&amp; !m_checkedForCSSCharset)
582         if (!checkForCSSCharset(data, length, movedDataToBuffer))
583             return emptyString();
584 
585     if ((m_contentType == HTML || m_contentType == XML) &amp;&amp; !m_checkedForHeadCharset) // HTML and XML
586         if (!checkForHeadCharset(data, length, movedDataToBuffer))
587             return emptyString();
588 
589     // FIXME: It is wrong to change the encoding downstream after we have already done some decoding.
590     if (shouldAutoDetect()) {
591         if (m_encoding.isJapanese())
592             detectJapaneseEncoding(data, length); // FIXME: We should use detectTextEncoding() for all languages.
593         else {
594             TextEncoding detectedEncoding;
595             if (detectTextEncoding(data, length, m_parentFrameAutoDetectedEncoding, &amp;detectedEncoding))
596                 setEncoding(detectedEncoding, AutoDetectedEncoding);
597         }
598     }
599 
600     ASSERT(m_encoding.isValid());
601 
602     if (!m_codec)
603         m_codec = newTextCodec(m_encoding);
604 
605     if (m_buffer.isEmpty())
606         return m_codec-&gt;decode(data + lengthOfBOM, length - lengthOfBOM, false, m_contentType == XML, m_sawError);
607 
608     if (!movedDataToBuffer) {
609         size_t oldSize = m_buffer.size();
610         m_buffer.grow(oldSize + length);
611         memcpy(m_buffer.data() + oldSize, data, length);
612     }
613 
614     String result = m_codec-&gt;decode(m_buffer.data() + lengthOfBOM, m_buffer.size() - lengthOfBOM, false, m_contentType == XML &amp;&amp; !m_useLenientXMLDecoding, m_sawError);
615     m_buffer.clear();
616     return result;
617 }
618 
619 String TextResourceDecoder::flush()
620 {
621     // If we can not identify the encoding even after a document is completely
622     // loaded, we need to detect the encoding if other conditions for
623     // autodetection is satisfied.
624     if (m_buffer.size() &amp;&amp; shouldAutoDetect()
625         &amp;&amp; ((!m_checkedForHeadCharset &amp;&amp; (m_contentType == HTML || m_contentType == XML)) || (!m_checkedForCSSCharset &amp;&amp; (m_contentType == CSS)))) {
626         TextEncoding detectedEncoding;
627         if (detectTextEncoding(m_buffer.data(), m_buffer.size(), m_parentFrameAutoDetectedEncoding, &amp;detectedEncoding))
628             setEncoding(detectedEncoding, AutoDetectedEncoding);
629     }
630 
631     if (!m_codec)
632         m_codec = newTextCodec(m_encoding);
633 
634     String result = m_codec-&gt;decode(m_buffer.data(), m_buffer.size(), true, m_contentType == XML &amp;&amp; !m_useLenientXMLDecoding, m_sawError);
635     m_buffer.clear();
636     m_codec = nullptr;
637     m_checkedForBOM = false; // Skip BOM again when re-decoding.
638     return result;
639 }
640 
641 String TextResourceDecoder::decodeAndFlush(const char* data, size_t length)
642 {
643     String decoded = decode(data, length);
644     return decoded + flush();
645 }
646 
647 const TextEncoding* TextResourceDecoder::encodingForURLParsing()
648 {
649     // For UTF-{7,16,32}, we want to use UTF-8 for the query part as
650     // we do when submitting a form. A form with GET method
651     // has its contents added to a URL as query params and it makes sense
652     // to be consistent.
653     auto&amp; encoding = m_encoding.encodingForFormSubmissionOrURLParsing();
654     if (encoding == UTF8Encoding())
655         return nullptr;
656     return &amp;encoding;
657 }
658 
659 }
    </pre>
  </body>
</html>
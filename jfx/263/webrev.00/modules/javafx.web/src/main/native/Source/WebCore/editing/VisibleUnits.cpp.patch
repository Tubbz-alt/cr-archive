diff a/modules/javafx.web/src/main/native/Source/WebCore/editing/VisibleUnits.cpp b/modules/javafx.web/src/main/native/Source/WebCore/editing/VisibleUnits.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/editing/VisibleUnits.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/editing/VisibleUnits.cpp
@@ -822,20 +822,20 @@
         if (!startNode)
             return VisiblePosition();
     } else {
         // Generated content (e.g. list markers and CSS :before and :after pseudoelements) have no corresponding DOM element,
         // and so cannot be represented by a VisiblePosition. Use whatever follows instead.
-        startBox = rootBox->firstLeafChild();
+        startBox = rootBox->firstLeafDescendant();
         while (true) {
             if (!startBox)
                 return VisiblePosition();
 
             startNode = startBox->renderer().nonPseudoNode();
             if (startNode)
                 break;
 
-            startBox = startBox->nextLeafChild();
+            startBox = startBox->nextLeafOnLine();
         }
     }
 
     return is<Text>(*startNode) ? Position(downcast<Text>(startNode), downcast<InlineTextBox>(*startBox).start())
         : positionBeforeNode(startNode);
@@ -896,20 +896,20 @@
         if (!endNode)
             return VisiblePosition();
     } else {
         // Generated content (e.g. list markers and CSS :before and :after pseudoelements) have no corresponding DOM element,
         // and so cannot be represented by a VisiblePosition. Use whatever precedes instead.
-        endBox = rootBox->lastLeafChild();
+        endBox = rootBox->lastLeafDescendant();
         while (true) {
             if (!endBox)
                 return VisiblePosition();
 
             endNode = endBox->renderer().nonPseudoNode();
             if (endNode)
                 break;
 
-            endBox = endBox->prevLeafChild();
+            endBox = endBox->previousLeafOnLine();
         }
     }
 
     Position pos;
     if (is<HTMLBRElement>(*endNode))
@@ -1044,11 +1044,11 @@
     visiblePosition.getInlineBoxAndOffset(box, ignoredCaretOffset);
     if (box) {
         root = box->root().prevRootBox();
         // We want to skip zero height boxes.
         // This could happen in case it is a TrailingFloatsRootInlineBox.
-        if (!root || !root->logicalHeight() || !root->firstLeafChild())
+        if (!root || !root->logicalHeight() || !root->firstLeafDescendant())
             root = nullptr;
     }
 
     if (!root) {
         Position position = previousRootInlineBoxCandidatePosition(node, visiblePosition, editableType);
@@ -1099,11 +1099,11 @@
     visiblePosition.getInlineBoxAndOffset(box, ignoredCaretOffset);
     if (box) {
         root = box->root().nextRootBox();
         // We want to skip zero height boxes.
         // This could happen in case it is a TrailingFloatsRootInlineBox.
-        if (!root || !root->logicalHeight() || !root->firstLeafChild())
+        if (!root || !root->logicalHeight() || !root->firstLeafDescendant())
             root = nullptr;
     }
 
     if (!root) {
         // FIXME: We need do the same in previousLinePosition.
@@ -1589,11 +1589,11 @@
         // Note that "Left" and "Right" in this context apparently mean "upstream/previous" and "downstream/next".
         boundary = useDownstream ? endOfWord(vp, LeftWordIfOnBoundary) : startOfWord(vp, RightWordIfOnBoundary);
         break;
 
     case SentenceGranularity:
-        boundary = useDownstream ? endOfSentence(vp) : startOfSentence(vp);
+        boundary = useDownstream ? endOfSentence(previousSentencePosition(vp)) : startOfSentence(nextSentencePosition(vp));
         break;
 
     case LineGranularity:
         // Affinity has to be set to get right boundary of the line.
         boundary = vp;
@@ -1774,11 +1774,12 @@
     }
 
     if (result == vp)
         return VisiblePosition();
 
-    ASSERT(useDownstream ? (result > vp) : (result < vp));
+    // Positions can only be compared if they are in the same tree scope.
+    ASSERT_IMPLIES(areVisiblePositionsInSameTreeScope(result, vp), useDownstream ? (result > vp) : (result < vp));
 
     return result;
 }
 
 static VisiblePosition nextLineBoundaryInDirection(const VisiblePosition& vp, SelectionDirection direction)
@@ -1795,22 +1796,18 @@
     }
 
     return result;
 }
 
-static VisiblePosition nextParagraphBoundaryInDirection(const VisiblePosition& vp, SelectionDirection direction)
+static VisiblePosition nextParagraphBoundaryInDirection(const VisiblePosition& position, SelectionDirection direction)
 {
-    bool useDownstream = directionIsDownstream(direction);
-    bool withinUnitOfGranularity = withinTextUnitOfGranularity(vp, ParagraphGranularity, direction);
-    VisiblePosition result;
-
-    if (!withinUnitOfGranularity)
-        result =  useDownstream ? startOfParagraph(nextParagraphPosition(vp, vp.lineDirectionPointForBlockDirectionNavigation())) : endOfParagraph(previousParagraphPosition(vp, vp.lineDirectionPointForBlockDirectionNavigation()));
-    else
-        result = useDownstream ? endOfParagraph(vp) : startOfParagraph(vp);
-
-    return result;
+    auto useDownstream = directionIsDownstream(direction);
+    auto lineDirection = position.lineDirectionPointForBlockDirectionNavigation();
+    if (atBoundaryOfGranularity(position, ParagraphGranularity, direction))
+        return useDownstream ? startOfParagraph(nextParagraphPosition(position, lineDirection)) : endOfParagraph(previousParagraphPosition(position, lineDirection));
+    ASSERT(withinTextUnitOfGranularity(position, ParagraphGranularity, direction));
+    return useDownstream ? endOfParagraph(position) : startOfParagraph(position);
 }
 
 static VisiblePosition nextDocumentBoundaryInDirection(const VisiblePosition& vp, SelectionDirection direction)
 {
     return directionIsDownstream(direction) ? endOfDocument(vp) : startOfDocument(vp);
@@ -1967,37 +1964,27 @@
 
     if (!range) {
         // We could be at the start of a word, try forward.
         range = enclosingTextUnitOfGranularity(position, WordGranularity, DirectionForward);
     }
+
     if (range)
         return range;
 
     VisiblePosition currentPosition = position;
     do {
         currentPosition = positionOfNextBoundaryOfGranularity(currentPosition, WordGranularity, DirectionBackward);
     } while (currentPosition.isNotNull() && !atBoundaryOfGranularity(currentPosition, WordGranularity, DirectionBackward));
 
-    // If the position is an empty paragraph and at the end of the document
-    // the word iterator could not pass the paragraph boundary, therefore iterating to
-    // the previous line is required.
-    if (currentPosition.isNull() && isEndOfDocument(position)) {
-        VisiblePosition previousLinePosition = positionOfNextBoundaryOfGranularity(position, LineGranularity, DirectionBackward);
-        if (previousLinePosition.isNotNull()) {
-            currentPosition = positionOfNextBoundaryOfGranularity(previousLinePosition, WordGranularity, DirectionBackward);
-            if (currentPosition.isNull())
-                currentPosition = previousLinePosition;
-        }
-    }
-
     if (currentPosition.isNull())
         currentPosition = positionOfNextBoundaryOfGranularity(position, WordGranularity, DirectionForward);
 
     if (currentPosition.isNotNull()) {
         range = Range::create(position.deepEquivalent().deprecatedNode()->document(), currentPosition, position);
         ASSERT(range);
     }
+
     return range;
 }
 
 VisiblePosition closestWordBoundaryForPosition(const VisiblePosition& position)
 {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="VM.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMEntryScope.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #pragma once
  30 
  31 #include &quot;CallData.h&quot;
  32 #include &quot;CodeSpecializationKind.h&quot;
  33 #include &quot;CompleteSubspace.h&quot;
  34 #include &quot;ConcurrentJSLock.h&quot;
  35 #include &quot;ControlFlowProfiler.h&quot;
  36 #include &quot;DateInstanceCache.h&quot;
  37 #include &quot;DeleteAllCodeEffort.h&quot;
  38 #include &quot;ExceptionEventLocation.h&quot;
  39 #include &quot;ExecutableAllocator.h&quot;
  40 #include &quot;FunctionHasExecutedCache.h&quot;
  41 #include &quot;FuzzerAgent.h&quot;
  42 #include &quot;Heap.h&quot;

  43 #include &quot;Intrinsic.h&quot;
  44 #include &quot;IsoCellSet.h&quot;
  45 #include &quot;IsoSubspace.h&quot;
  46 #include &quot;JITThunks.h&quot;
  47 #include &quot;JSCJSValue.h&quot;
  48 #include &quot;JSLock.h&quot;
  49 #include &quot;MacroAssemblerCodeRef.h&quot;
  50 #include &quot;Microtask.h&quot;
  51 #include &quot;NumericStrings.h&quot;
  52 #include &quot;SmallStrings.h&quot;
  53 #include &quot;Strong.h&quot;
  54 #include &quot;StructureCache.h&quot;
  55 #include &quot;SubspaceAccess.h&quot;
  56 #include &quot;VMTraps.h&quot;
  57 #include &quot;WasmContext.h&quot;
  58 #include &quot;Watchpoint.h&quot;
  59 #include &lt;wtf/BumpPointerAllocator.h&gt;
  60 #include &lt;wtf/CheckedArithmetic.h&gt;
  61 #include &lt;wtf/DateMath.h&gt;
  62 #include &lt;wtf/Deque.h&gt;
</pre>
<hr />
<pre>
  68 #include &lt;wtf/SetForScope.h&gt;
  69 #include &lt;wtf/StackBounds.h&gt;
  70 #include &lt;wtf/StackPointer.h&gt;
  71 #include &lt;wtf/Stopwatch.h&gt;
  72 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
  73 #include &lt;wtf/ThreadSpecific.h&gt;
  74 #include &lt;wtf/UniqueArray.h&gt;
  75 #include &lt;wtf/text/SymbolRegistry.h&gt;
  76 #include &lt;wtf/text/WTFString.h&gt;
  77 #if ENABLE(REGEXP_TRACING)
  78 #include &lt;wtf/ListHashSet.h&gt;
  79 #endif
  80 
  81 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
  82 #include &lt;wtf/StackTrace.h&gt;
  83 #endif
  84 
  85 // Enable the Objective-C API for platforms with a modern runtime. This has to match exactly what we
  86 // have in JSBase.h.
  87 #if !defined(JSC_OBJC_API_ENABLED)
<span class="line-modified">  88 #if (defined(__clang__) &amp;&amp; defined(__APPLE__) &amp;&amp; ((defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; !defined(__i386__)) || (defined(TARGET_OS_IPHONE) &amp;&amp; TARGET_OS_IPHONE)))</span>
  89 #define JSC_OBJC_API_ENABLED 1
  90 #else
  91 #define JSC_OBJC_API_ENABLED 0
  92 #endif
  93 #endif
  94 
  95 namespace WTF {
  96 class SimpleStats;
  97 } // namespace WTF
  98 using WTF::SimpleStats;
  99 
 100 namespace JSC {
 101 
 102 class BuiltinExecutables;
 103 class BytecodeIntrinsicRegistry;


 104 class CodeBlock;
 105 class CodeCache;
 106 class CommonIdentifiers;
 107 class CompactVariableMap;

 108 class CustomGetterSetter;
 109 class DOMAttributeGetterSetter;
<span class="line-modified"> 110 class ExecState;</span>

 111 class Exception;
 112 class ExceptionScope;
 113 class FastMallocAlignedMemoryAllocator;
 114 class GigacageAlignedMemoryAllocator;
 115 class HandleStack;
 116 class TypeProfiler;
 117 class TypeProfilerLog;
 118 class HasOwnPropertyCache;
 119 class HeapProfiler;
 120 class Identifier;
 121 class Interpreter;









 122 class JSCustomGetterSetterFunction;
 123 class JSDestructibleObjectHeapCellType;
 124 class JSGlobalObject;





 125 class JSObject;
 126 class JSPromise;
 127 class JSPropertyNameEnumerator;
 128 class JSRunLoopTimer;
<span class="line-modified"> 129 class JSStringHeapCellType;</span>
<span class="line-modified"> 130 class JSWebAssemblyCodeBlockHeapCellType;</span>


 131 class JSWebAssemblyInstance;



 132 class LLIntOffsetsExtractor;
 133 class NativeExecutable;
<span class="line-modified"> 134 class PromiseDeferredTimer;</span>

 135 class RegExp;
 136 class RegExpCache;
 137 class Register;
 138 class RegisterAtOffsetList;
 139 #if ENABLE(SAMPLING_PROFILER)
 140 class SamplingProfiler;
 141 #endif
 142 class ShadowChicken;
 143 class ScriptExecutable;
 144 class SourceProvider;
 145 class SourceProviderCache;
 146 class StackFrame;
 147 class Structure;
 148 #if ENABLE(REGEXP_TRACING)
 149 class RegExp;
 150 #endif
 151 class Symbol;
 152 class TypedArrayController;
 153 class UnlinkedCodeBlock;
 154 class UnlinkedEvalCodeBlock;
 155 class UnlinkedFunctionExecutable;
 156 class UnlinkedProgramCodeBlock;
 157 class UnlinkedModuleProgramCodeBlock;
 158 class VirtualRegister;
 159 class VMEntryScope;

 160 class Watchdog;
 161 class Watchpoint;
 162 class WatchpointSet;
<span class="line-modified"> 163 class WebAssemblyFunctionHeapCellType;</span>





 164 
 165 #if ENABLE(FTL_JIT)
 166 namespace FTL {
 167 class Thunks;
 168 }
 169 #endif // ENABLE(FTL_JIT)
 170 namespace Profiler {
 171 class Database;
 172 }
 173 namespace DOMJIT {
 174 class Signature;
 175 }
 176 
 177 struct EntryFrame;
 178 struct HashTable;
 179 struct Instruction;
 180 struct ValueProfile;
 181 
<span class="line-removed"> 182 typedef ExecState CallFrame;</span>
<span class="line-removed"> 183 </span>
 184 struct LocalTimeOffsetCache {
 185     LocalTimeOffsetCache()
 186         : start(0.0)
 187         , end(-1.0)
 188         , increment(0.0)
 189     {
 190     }
 191 
 192     void reset()
 193     {
 194         offset = LocalTimeOffset();
 195         start = 0.0;
 196         end = -1.0;
 197         increment = 0.0;
 198     }
 199 
 200     LocalTimeOffset offset;
 201     double start;
 202     double end;
 203     double increment;
</pre>
<hr />
<pre>
 205 
 206 class QueuedTask {
 207     WTF_MAKE_NONCOPYABLE(QueuedTask);
 208     WTF_MAKE_FAST_ALLOCATED;
 209 public:
 210     void run();
 211 
 212     QueuedTask(VM&amp; vm, JSGlobalObject* globalObject, Ref&lt;Microtask&gt;&amp;&amp; microtask)
 213         : m_globalObject(vm, globalObject)
 214         , m_microtask(WTFMove(microtask))
 215     {
 216     }
 217 
 218 private:
 219     Strong&lt;JSGlobalObject&gt; m_globalObject;
 220     Ref&lt;Microtask&gt; m_microtask;
 221 };
 222 
 223 class ConservativeRoots;
 224 


 225 #if COMPILER(MSVC)
 226 #pragma warning(push)
 227 #pragma warning(disable: 4200) // Disable &quot;zero-sized array in struct/union&quot; warning
 228 #endif
 229 struct ScratchBuffer {
 230     ScratchBuffer()
 231     {
 232         u.m_activeLength = 0;
 233     }
 234 
 235     static ScratchBuffer* create(size_t size)
 236     {
<span class="line-modified"> 237         ScratchBuffer* result = new (fastMalloc(ScratchBuffer::allocationSize(size))) ScratchBuffer;</span>
<span class="line-removed"> 238 </span>
 239         return result;
 240     }
 241 
 242     static size_t allocationSize(Checked&lt;size_t&gt; bufferSize) { return (sizeof(ScratchBuffer) + bufferSize).unsafeGet(); }
 243     void setActiveLength(size_t activeLength) { u.m_activeLength = activeLength; }
 244     size_t activeLength() const { return u.m_activeLength; };
 245     size_t* addressOfActiveLength() { return &amp;u.m_activeLength; };
 246     void* dataBuffer() { return m_buffer; }
 247 
 248     union {
 249         size_t m_activeLength;
 250         double pad; // Make sure m_buffer is double aligned.
 251     } u;
 252 #if CPU(MIPS) &amp;&amp; (defined WTF_MIPS_ARCH_REV &amp;&amp; WTF_MIPS_ARCH_REV == 2)
 253     alignas(8) void* m_buffer[0];
 254 #else
 255     void* m_buffer[0];
 256 #endif
 257 };
 258 #if COMPILER(MSVC)
</pre>
<hr />
<pre>
 281     JS_EXPORT_PRIVATE static VM&amp; sharedInstance();
 282 
 283     JS_EXPORT_PRIVATE static Ref&lt;VM&gt; create(HeapType = SmallHeap);
 284     static Ref&lt;VM&gt; createContextGroup(HeapType = SmallHeap);
 285     JS_EXPORT_PRIVATE ~VM();
 286 
 287     Watchdog&amp; ensureWatchdog();
 288     Watchdog* watchdog() { return m_watchdog.get(); }
 289 
 290     HeapProfiler* heapProfiler() const { return m_heapProfiler.get(); }
 291     JS_EXPORT_PRIVATE HeapProfiler&amp; ensureHeapProfiler();
 292 
 293 #if ENABLE(SAMPLING_PROFILER)
 294     SamplingProfiler* samplingProfiler() { return m_samplingProfiler.get(); }
 295     JS_EXPORT_PRIVATE SamplingProfiler&amp; ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp;);
 296 #endif
 297 
 298     FuzzerAgent* fuzzerAgent() const { return m_fuzzerAgent.get(); }
 299     void setFuzzerAgent(std::unique_ptr&lt;FuzzerAgent&gt;&amp;&amp; fuzzerAgent)
 300     {

 301         m_fuzzerAgent = WTFMove(fuzzerAgent);
 302     }
 303 
 304     static unsigned numberOfIDs() { return s_numberOfIDs.load(); }
 305     unsigned id() const { return m_id; }
 306     bool isEntered() const { return !!entryScope; }
 307 
 308     inline CallFrame* topJSCallFrame() const;
 309 
 310     // Global object in which execution began.
<span class="line-modified"> 311     JS_EXPORT_PRIVATE JSGlobalObject* vmEntryGlobalObject(const CallFrame*) const;</span>



 312 
 313 private:
 314     unsigned nextID();
 315 
 316     static Atomic&lt;unsigned&gt; s_numberOfIDs;
 317 
 318     unsigned m_id;
 319     RefPtr&lt;JSLock&gt; m_apiLock;
 320 #if USE(CF)
 321     // These need to be initialized before heap below.
 322     RetainPtr&lt;CFRunLoopRef&gt; m_runLoop;
 323 #endif
 324 



 325 public:
 326     Heap heap;
 327 
 328     std::unique_ptr&lt;FastMallocAlignedMemoryAllocator&gt; fastMallocAllocator;
 329     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; primitiveGigacageAllocator;
 330     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; jsValueGigacageAllocator;
 331 
 332     std::unique_ptr&lt;HeapCellType&gt; auxiliaryHeapCellType;
 333     std::unique_ptr&lt;HeapCellType&gt; immutableButterflyHeapCellType;
 334     std::unique_ptr&lt;HeapCellType&gt; cellHeapCellType;
 335     std::unique_ptr&lt;HeapCellType&gt; destructibleCellHeapCellType;
<span class="line-modified"> 336     std::unique_ptr&lt;JSStringHeapCellType&gt; stringHeapCellType;</span>













 337     std::unique_ptr&lt;JSDestructibleObjectHeapCellType&gt; destructibleObjectHeapCellType;















 338 #if ENABLE(WEBASSEMBLY)
<span class="line-modified"> 339     std::unique_ptr&lt;JSWebAssemblyCodeBlockHeapCellType&gt; webAssemblyCodeBlockHeapCellType;</span>
<span class="line-modified"> 340     std::unique_ptr&lt;WebAssemblyFunctionHeapCellType&gt; webAssemblyFunctionHeapCellType;</span>






 341 #endif
 342 
 343     CompleteSubspace primitiveGigacageAuxiliarySpace; // Typed arrays, strings, bitvectors, etc go here.
 344     CompleteSubspace jsValueGigacageAuxiliarySpace; // Butterflies, arrays of JSValues, etc go here.
 345     CompleteSubspace immutableButterflyJSValueGigacageAuxiliarySpace; // JSImmutableButterfly goes here.
 346 
 347     // We make cross-cutting assumptions about typed arrays being in the primitive Gigacage and butterflies
 348     // being in the JSValue gigacage. For some types, it&#39;s super obvious where they should go, and so we
 349     // can hardcode that fact. But sometimes it&#39;s not clear, so we abstract it by having a Gigacage::Kind
 350     // constant somewhere.
 351     // FIXME: Maybe it would be better if everyone abstracted this?
 352     // https://bugs.webkit.org/show_bug.cgi?id=175248
 353     ALWAYS_INLINE CompleteSubspace&amp; gigacageAuxiliarySpace(Gigacage::Kind kind)
 354     {
 355         switch (kind) {
<span class="line-removed"> 356         case Gigacage::ReservedForFlagsAndNotABasePtr:</span>
<span class="line-removed"> 357             RELEASE_ASSERT_NOT_REACHED();</span>
 358         case Gigacage::Primitive:
 359             return primitiveGigacageAuxiliarySpace;
 360         case Gigacage::JSValue:
 361             return jsValueGigacageAuxiliarySpace;


 362         }
 363         RELEASE_ASSERT_NOT_REACHED();
 364         return primitiveGigacageAuxiliarySpace;
 365     }
 366 
 367     // Whenever possible, use subspaceFor&lt;CellType&gt;(vm) to get one of these subspaces.
 368     CompleteSubspace cellSpace;
<span class="line-modified"> 369     CompleteSubspace jsValueGigacageCellSpace; // FIXME: This space is problematic because we have things in here like DirectArguments and ScopedArguments; those should be split into JSValueOOB cells and JSValueStrict auxiliaries. https://bugs.webkit.org/show_bug.cgi?id=182858</span>
<span class="line-removed"> 370     CompleteSubspace destructibleCellSpace;</span>
<span class="line-removed"> 371     CompleteSubspace stringSpace;</span>
 372     CompleteSubspace destructibleObjectSpace;
<span class="line-removed"> 373     CompleteSubspace eagerlySweptDestructibleObjectSpace;</span>
 374 







 375     IsoSubspace executableToCodeBlockEdgeSpace;
 376     IsoSubspace functionSpace;


 377     IsoSubspace internalFunctionSpace;

 378     IsoSubspace nativeExecutableSpace;



 379     IsoSubspace propertyTableSpace;








 380     IsoSubspace structureRareDataSpace;
 381     IsoSubspace structureSpace;
 382     IsoSubspace symbolTableSpace;
 383 
 384 #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(name) \
 385     template&lt;SubspaceAccess mode&gt; \
 386     IsoSubspace* name() \
 387     { \
 388         if (m_##name || mode == SubspaceAccess::Concurrently) \
 389             return m_##name.get(); \
 390         return name##Slow(); \
 391     } \
<span class="line-modified"> 392     IsoSubspace* name##Slow(); \</span>
 393     std::unique_ptr&lt;IsoSubspace&gt; m_##name;
 394 
 395 
 396 #if JSC_OBJC_API_ENABLED

 397     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(objCCallbackFunctionSpace)
 398 #endif












 399     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(boundFunctionSpace)


 400     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackFunctionSpace)

 401     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(customGetterSetterFunctionSpace)


 402     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(errorInstanceSpace)













 403     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(nativeStdFunctionSpace)

 404     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(proxyRevokeSpace)




















 405     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakObjectRefSpace)
 406     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakSetSpace)
 407     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakMapSpace)







 408 #if ENABLE(WEBASSEMBLY)

 409     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyCodeBlockSpace)
 410     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyFunctionSpace)






 411     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyWrapperFunctionSpace)
 412 #endif
 413 
 414 #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER
 415 
 416     IsoCellSet executableToCodeBlockEdgesWithConstraints;
 417     IsoCellSet executableToCodeBlockEdgesWithFinalizers;
 418 
 419 #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(name) \
 420     template&lt;SubspaceAccess mode&gt; \
 421     IsoSubspace* name() \
 422     { \
 423         if (auto* spaceAndSet = m_##name.get()) \
 424             return &amp;spaceAndSet-&gt;space; \
 425         if (mode == SubspaceAccess::Concurrently) \
 426             return nullptr; \
 427         return name##Slow(); \
 428     } \
 429     IsoSubspace* name##Slow(); \
 430     std::unique_ptr&lt;SpaceAndSet&gt; m_##name;
</pre>
<hr />
<pre>
 466     SpaceAndSet functionExecutableSpace;
 467     SpaceAndSet programExecutableSpace;
 468 
 469     template&lt;typename Func&gt;
 470     void forEachScriptExecutableSpace(const Func&amp; func)
 471     {
 472         if (m_evalExecutableSpace)
 473             func(*m_evalExecutableSpace);
 474         func(functionExecutableSpace);
 475         if (m_moduleProgramExecutableSpace)
 476             func(*m_moduleProgramExecutableSpace);
 477         func(programExecutableSpace);
 478     }
 479 
 480     SpaceAndSet unlinkedFunctionExecutableSpace;
 481 
 482 #undef DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER
 483 
 484     VMType vmType;
 485     ClientData* clientData;
<span class="line-modified"> 486     EntryFrame* topEntryFrame;</span>
 487     // NOTE: When throwing an exception while rolling back the call frame, this may be equal to
 488     // topEntryFrame.
 489     // FIXME: This should be a void*, because it might not point to a CallFrame.
 490     // https://bugs.webkit.org/show_bug.cgi?id=160441
<span class="line-modified"> 491     ExecState* topCallFrame { nullptr };</span>
 492 #if ENABLE(WEBASSEMBLY)
 493     Wasm::Context wasmContext;
 494 #endif
 495     Strong&lt;Structure&gt; structureStructure;
 496     Strong&lt;Structure&gt; structureRareDataStructure;
 497     Strong&lt;Structure&gt; terminatedExecutionErrorStructure;
 498     Strong&lt;Structure&gt; stringStructure;
 499     Strong&lt;Structure&gt; propertyNameEnumeratorStructure;

 500     Strong&lt;Structure&gt; customGetterSetterStructure;
 501     Strong&lt;Structure&gt; domAttributeGetterSetterStructure;
 502     Strong&lt;Structure&gt; scopedArgumentsTableStructure;
 503     Strong&lt;Structure&gt; apiWrapperStructure;
 504     Strong&lt;Structure&gt; nativeExecutableStructure;
 505     Strong&lt;Structure&gt; evalExecutableStructure;
 506     Strong&lt;Structure&gt; programExecutableStructure;
 507     Strong&lt;Structure&gt; functionExecutableStructure;
 508 #if ENABLE(WEBASSEMBLY)
 509     Strong&lt;Structure&gt; webAssemblyCodeBlockStructure;
 510 #endif
 511     Strong&lt;Structure&gt; moduleProgramExecutableStructure;
 512     Strong&lt;Structure&gt; regExpStructure;
 513     Strong&lt;Structure&gt; symbolStructure;
 514     Strong&lt;Structure&gt; symbolTableStructure;
<span class="line-removed"> 515     Strong&lt;Structure&gt; fixedArrayStructure;</span>
 516     Strong&lt;Structure&gt; immutableButterflyStructures[NumberOfCopyOnWriteIndexingModes];
 517     Strong&lt;Structure&gt; sourceCodeStructure;
 518     Strong&lt;Structure&gt; scriptFetcherStructure;
 519     Strong&lt;Structure&gt; scriptFetchParametersStructure;
 520     Strong&lt;Structure&gt; structureChainStructure;
 521     Strong&lt;Structure&gt; sparseArrayValueMapStructure;
 522     Strong&lt;Structure&gt; templateObjectDescriptorStructure;
<span class="line-removed"> 523     Strong&lt;Structure&gt; arrayBufferNeuteringWatchpointStructure;</span>
 524     Strong&lt;Structure&gt; unlinkedFunctionExecutableStructure;
 525     Strong&lt;Structure&gt; unlinkedProgramCodeBlockStructure;
 526     Strong&lt;Structure&gt; unlinkedEvalCodeBlockStructure;
 527     Strong&lt;Structure&gt; unlinkedFunctionCodeBlockStructure;
 528     Strong&lt;Structure&gt; unlinkedModuleProgramCodeBlockStructure;
 529     Strong&lt;Structure&gt; propertyTableStructure;
 530     Strong&lt;Structure&gt; functionRareDataStructure;
 531     Strong&lt;Structure&gt; exceptionStructure;
<span class="line-removed"> 532     Strong&lt;Structure&gt; promiseDeferredStructure;</span>
<span class="line-removed"> 533     Strong&lt;Structure&gt; internalPromiseDeferredStructure;</span>
<span class="line-removed"> 534     Strong&lt;Structure&gt; nativeStdFunctionCellStructure;</span>
 535     Strong&lt;Structure&gt; programCodeBlockStructure;
 536     Strong&lt;Structure&gt; moduleProgramCodeBlockStructure;
 537     Strong&lt;Structure&gt; evalCodeBlockStructure;
 538     Strong&lt;Structure&gt; functionCodeBlockStructure;
 539     Strong&lt;Structure&gt; hashMapBucketSetStructure;
 540     Strong&lt;Structure&gt; hashMapBucketMapStructure;
 541     Strong&lt;Structure&gt; bigIntStructure;
 542     Strong&lt;Structure&gt; executableToCodeBlockEdgeStructure;
 543 
 544     Strong&lt;Structure&gt; m_setIteratorStructure;
 545     Strong&lt;Structure&gt; m_mapIteratorStructure;
 546 
 547     Strong&lt;JSPropertyNameEnumerator&gt; m_emptyPropertyNameEnumerator;
 548 
 549     Strong&lt;JSCell&gt; m_sentinelSetBucket;
 550     Strong&lt;JSCell&gt; m_sentinelMapBucket;
 551 
<span class="line-modified"> 552     Ref&lt;PromiseDeferredTimer&gt; promiseDeferredTimer;</span>





 553 
 554     JSCell* currentlyDestructingCallbackObject;
 555     const ClassInfo* currentlyDestructingCallbackObjectClassInfo { nullptr };
 556 
 557     AtomStringTable* m_atomStringTable;
 558     WTF::SymbolRegistry m_symbolRegistry;
 559     CommonIdentifiers* propertyNames;
 560     const ArgList* emptyList;
 561     SmallStrings smallStrings;
 562     NumericStrings numericStrings;
 563     DateInstanceCache dateInstanceCache;
 564     std::unique_ptr&lt;SimpleStats&gt; machineCodeBytesPerBytecodeWordForBaselineJIT;
 565     WeakGCMap&lt;std::pair&lt;CustomGetterSetter*, int&gt;, JSCustomGetterSetterFunction&gt; customGetterSetterFunctionMap;
 566     WeakGCMap&lt;StringImpl*, JSString, PtrHash&lt;StringImpl*&gt;&gt; stringCache;
 567     Strong&lt;JSString&gt; lastCachedString;
 568 
 569     AtomStringTable* atomStringTable() const { return m_atomStringTable; }
 570     WTF::SymbolRegistry&amp; symbolRegistry() { return m_symbolRegistry; }
 571 


 572     Structure* setIteratorStructure()
 573     {
 574         if (LIKELY(m_setIteratorStructure))
 575             return m_setIteratorStructure.get();
 576         return setIteratorStructureSlow();
 577     }
 578 
 579     Structure* mapIteratorStructure()
 580     {
 581         if (LIKELY(m_mapIteratorStructure))
 582             return m_mapIteratorStructure.get();
 583         return mapIteratorStructureSlow();
 584     }
 585 
 586     JSCell* sentinelSetBucket()
 587     {
 588         if (LIKELY(m_sentinelSetBucket))
 589             return m_sentinelSetBucket.get();
 590         return sentinelSetBucketSlow();
 591     }
</pre>
<hr />
<pre>
 636     private:
 637         VM&amp; m_vm;
 638         DeletePropertyMode m_previousMode;
 639     };
 640 
 641     static JS_EXPORT_PRIVATE bool canUseAssembler();
 642     static bool isInMiniMode()
 643     {
 644         return !canUseJIT() || Options::forceMiniVMMode();
 645     }
 646 
 647     static bool useUnlinkedCodeBlockJettisoning()
 648     {
 649         return Options::useUnlinkedCodeBlockJettisoning() || isInMiniMode();
 650     }
 651 
 652     static void computeCanUseJIT();
 653     ALWAYS_INLINE static bool canUseJIT()
 654     {
 655 #if ENABLE(JIT)
<span class="line-modified"> 656 #if !ASSERT_DISABLED</span>
<span class="line-removed"> 657         RELEASE_ASSERT(s_canUseJITIsSet);</span>
<span class="line-removed"> 658 #endif</span>
 659         return s_canUseJIT;
 660 #else
 661         return false;
 662 #endif
 663     }
 664 
 665     SourceProviderCache* addSourceProviderCache(SourceProvider*);
 666     void clearSourceProviderCaches();
 667 
 668     StructureCache structureCache;
 669 
 670     typedef HashMap&lt;RefPtr&lt;SourceProvider&gt;, RefPtr&lt;SourceProviderCache&gt;&gt; SourceProviderCacheMap;
 671     SourceProviderCacheMap sourceProviderCacheMap;
 672     Interpreter* interpreter;
 673 #if ENABLE(JIT)
 674     std::unique_ptr&lt;JITThunks&gt; jitStubs;
 675     MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; getCTIStub(ThunkGenerator generator)
 676     {
 677         return jitStubs-&gt;ctiStub(*this, generator);
 678     }
 679 
 680 #endif // ENABLE(JIT)
 681 #if ENABLE(FTL_JIT)
 682     std::unique_ptr&lt;FTL::Thunks&gt; ftlThunks;
 683 #endif
 684     NativeExecutable* getHostFunction(NativeFunction, NativeFunction constructor, const String&amp; name);
 685     NativeExecutable* getHostFunction(NativeFunction, Intrinsic, NativeFunction constructor, const DOMJIT::Signature*, const String&amp; name);
 686 


 687     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; getCTIInternalFunctionTrampolineFor(CodeSpecializationKind);
 688 
 689     static ptrdiff_t exceptionOffset()
 690     {
 691         return OBJECT_OFFSETOF(VM, m_exception);
 692     }
 693 
 694     static ptrdiff_t callFrameForCatchOffset()
 695     {
 696         return OBJECT_OFFSETOF(VM, callFrameForCatch);
 697     }
 698 
 699     static ptrdiff_t topEntryFrameOffset()
 700     {
 701         return OBJECT_OFFSETOF(VM, topEntryFrame);
 702     }
 703 
 704     static ptrdiff_t offsetOfHeapBarrierThreshold()
 705     {
 706         return OBJECT_OFFSETOF(VM, heap) + OBJECT_OFFSETOF(Heap, m_barrierThreshold);
 707     }
 708 
 709     static ptrdiff_t offsetOfHeapMutatorShouldBeFenced()
 710     {
 711         return OBJECT_OFFSETOF(VM, heap) + OBJECT_OFFSETOF(Heap, m_mutatorShouldBeFenced);
 712     }
 713 
 714     void restorePreviousException(Exception* exception) { setException(exception); }
 715 
 716     void clearLastException() { m_lastException = nullptr; }
 717 
<span class="line-modified"> 718     ExecState** addressOfCallFrameForCatch() { return &amp;callFrameForCatch; }</span>
 719 
 720     JSCell** addressOfException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_exception); }
 721 
 722     Exception* lastException() const { return m_lastException; }
 723     JSCell** addressOfLastException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_lastException); }
 724 
 725     // This should only be used for test or assertion code that wants to inspect
 726     // the pending exception without interfering with Throw/CatchScopes.
 727     Exception* exceptionForInspection() const { return m_exception; }
 728 
 729     void setFailNextNewCodeBlock() { m_failNextNewCodeBlock = true; }
 730     bool getAndClearFailNextNewCodeBlock()
 731     {
 732         bool result = m_failNextNewCodeBlock;
 733         m_failNextNewCodeBlock = false;
 734         return result;
 735     }
 736 
 737     ALWAYS_INLINE Structure* getStructure(StructureID id)
 738     {
</pre>
<hr />
<pre>
 760     inline bool isSafeToRecurseSoft() const;
 761     bool isSafeToRecurse() const
 762     {
 763         return isSafeToRecurse(m_stackLimit);
 764     }
 765 
 766     void** addressOfLastStackTop() { return &amp;m_lastStackTop; }
 767     void* lastStackTop() { return m_lastStackTop; }
 768     void setLastStackTop(void*);
 769 
 770     void firePrimitiveGigacageEnabledIfNecessary()
 771     {
 772         if (m_needToFirePrimitiveGigacageEnabled) {
 773             m_needToFirePrimitiveGigacageEnabled = false;
 774             m_primitiveGigacageEnabled.fireAll(*this, &quot;Primitive gigacage disabled asynchronously&quot;);
 775         }
 776     }
 777 
 778     JSValue hostCallReturnValue;
 779     unsigned varargsLength;
<span class="line-modified"> 780     ExecState* newCallFrameReturnValue;</span>
<span class="line-modified"> 781     ExecState* callFrameForCatch;</span>
 782     void* targetMachinePCForThrow;
 783     const Instruction* targetInterpreterPCForThrow;
 784     uint32_t osrExitIndex;
 785     void* osrExitJumpDestination;
 786     bool isExecutingInRegExpJIT { false };
 787 
 788     // The threading protocol here is as follows:
 789     // - You can call scratchBufferForSize from any thread.
 790     // - You can only set the ScratchBuffer&#39;s activeLength from the main thread.
 791     // - You can only write to entries in the ScratchBuffer from the main thread.
 792     ScratchBuffer* scratchBufferForSize(size_t size);
 793     void clearScratchBuffers();
 794 
 795     EncodedJSValue* exceptionFuzzingBuffer(size_t size)
 796     {
 797         ASSERT(Options::useExceptionFuzz());
 798         if (!m_exceptionFuzzBuffer)
<span class="line-modified"> 799             m_exceptionFuzzBuffer = MallocPtr&lt;EncodedJSValue&gt;::malloc(size);</span>
 800         return m_exceptionFuzzBuffer.get();
 801     }
 802 
 803     void gatherScratchBufferRoots(ConservativeRoots&amp;);
 804 





 805     VMEntryScope* entryScope;
 806 
 807     JSObject* stringRecursionCheckFirstObject { nullptr };
 808     HashSet&lt;JSObject*&gt; stringRecursionCheckVisitedObjects;
 809 
 810     LocalTimeOffsetCache utcTimeOffsetCache;
 811     LocalTimeOffsetCache localTimeOffsetCache;
 812 
 813     String cachedDateString;
 814     double cachedDateStringValue;
 815 
 816     std::unique_ptr&lt;Profiler::Database&gt; m_perBytecodeProfiler;
 817     RefPtr&lt;TypedArrayController&gt; m_typedArrayController;
 818     RegExpCache* m_regExpCache;
 819     BumpPointerAllocator m_regExpAllocator;
 820     ConcurrentJSLock m_regExpAllocatorLock;
 821 
 822 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 823     static constexpr size_t patternContextBufferSize = 8192; // Space allocated to save nested parenthesis context
 824     UniqueArray&lt;char&gt; m_regExpPatternContexBuffer;
</pre>
<hr />
<pre>
 850 
 851     bool isCollectorBusyOnCurrentThread() { return heap.isCurrentThreadBusy(); }
 852 
 853 #if ENABLE(GC_VALIDATION)
 854     bool isInitializingObject() const;
 855     void setInitializingObjectClass(const ClassInfo*);
 856 #endif
 857 
 858     bool currentThreadIsHoldingAPILock() const { return m_apiLock-&gt;currentThreadIsHoldingLock(); }
 859 
 860     JSLock&amp; apiLock() { return *m_apiLock; }
 861     CodeCache* codeCache() { return m_codeCache.get(); }
 862 
 863     JS_EXPORT_PRIVATE void whenIdle(Function&lt;void()&gt;&amp;&amp;);
 864 
 865     JS_EXPORT_PRIVATE void deleteAllCode(DeleteAllCodeEffort);
 866     JS_EXPORT_PRIVATE void deleteAllLinkedCode(DeleteAllCodeEffort);
 867 
 868     void shrinkFootprintWhenIdle();
 869 
<span class="line-modified"> 870     WatchpointSet* ensureWatchpointSetForImpureProperty(const Identifier&amp;);</span>
<span class="line-removed"> 871     void registerWatchpointForImpureProperty(const Identifier&amp;, Watchpoint*);</span>
 872 
 873     // FIXME: Use AtomString once it got merged with Identifier.
<span class="line-modified"> 874     JS_EXPORT_PRIVATE void addImpureProperty(const String&amp;);</span>
 875 
 876     InlineWatchpointSet&amp; primitiveGigacageEnabled() { return m_primitiveGigacageEnabled; }
 877 
 878     BuiltinExecutables* builtinExecutables() { return m_builtinExecutables.get(); }
 879 
 880     bool enableTypeProfiler();
 881     bool disableTypeProfiler();
 882     TypeProfilerLog* typeProfilerLog() { return m_typeProfilerLog.get(); }
 883     TypeProfiler* typeProfiler() { return m_typeProfiler.get(); }
 884     JS_EXPORT_PRIVATE void dumpTypeProfilerData();
 885 
 886     FunctionHasExecutedCache* functionHasExecutedCache() { return &amp;m_functionHasExecutedCache; }
 887 
 888     ControlFlowProfiler* controlFlowProfiler() { return m_controlFlowProfiler.get(); }
 889     bool enableControlFlowProfiler();
 890     bool disableControlFlowProfiler();
 891 
 892     void queueMicrotask(JSGlobalObject&amp;, Ref&lt;Microtask&gt;&amp;&amp;);
 893     JS_EXPORT_PRIVATE void drainMicrotasks();
 894     void setOnEachMicrotaskTick(WTF::Function&lt;void(VM&amp;)&gt;&amp;&amp; func) { m_onEachMicrotaskTick = WTFMove(func); }
</pre>
<hr />
<pre>
 896     uintptr_t currentWeakRefVersion() const { return m_currentWeakRefVersion; }
 897 
 898     void setGlobalConstRedeclarationShouldThrow(bool globalConstRedeclarationThrow) { m_globalConstRedeclarationShouldThrow = globalConstRedeclarationThrow; }
 899     ALWAYS_INLINE bool globalConstRedeclarationShouldThrow() const { return m_globalConstRedeclarationShouldThrow; }
 900 
 901     void setShouldBuildPCToCodeOriginMapping() { m_shouldBuildPCToCodeOriginMapping = true; }
 902     bool shouldBuilderPCToCodeOriginMapping() const { return m_shouldBuildPCToCodeOriginMapping; }
 903 
 904     BytecodeIntrinsicRegistry&amp; bytecodeIntrinsicRegistry() { return *m_bytecodeIntrinsicRegistry; }
 905 
 906     ShadowChicken* shadowChicken() { return m_shadowChicken.get(); }
 907     void ensureShadowChicken();
 908 
 909     template&lt;typename Func&gt;
 910     void logEvent(CodeBlock*, const char* summary, const Func&amp; func);
 911 
 912     Optional&lt;RefPtr&lt;Thread&gt;&gt; ownerThread() const { return m_apiLock-&gt;ownerThread(); }
 913 
 914     VMTraps&amp; traps() { return m_traps; }
 915 
<span class="line-modified"> 916     void handleTraps(ExecState* exec, VMTraps::Mask mask = VMTraps::Mask::allEventTypes()) { m_traps.handleTraps(exec, mask); }</span>
 917 
 918     bool needTrapHandling() { return m_traps.needTrapHandling(); }
 919     bool needTrapHandling(VMTraps::Mask mask) { return m_traps.needTrapHandling(mask); }
 920     void* needTrapHandlingAddress() { return m_traps.needTrapHandlingAddress(); }
 921 
 922     void notifyNeedDebuggerBreak() { m_traps.fireTrap(VMTraps::NeedDebuggerBreak); }

 923     void notifyNeedTermination() { m_traps.fireTrap(VMTraps::NeedTermination); }
 924     void notifyNeedWatchdogCheck() { m_traps.fireTrap(VMTraps::NeedWatchdogCheck); }
 925 
 926     void promiseRejected(JSPromise*);
 927 
 928 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 929     StackTrace* nativeStackTraceOfLastThrow() const { return m_nativeStackTraceOfLastThrow.get(); }
 930     Thread* throwingThread() const { return m_throwingThread.get(); }
 931     bool needExceptionCheck() const { return m_needExceptionCheck; }
 932 #endif
 933 
 934 #if USE(CF)
 935     CFRunLoopRef runLoop() const { return m_runLoop.get(); }
 936     JS_EXPORT_PRIVATE void setRunLoop(CFRunLoopRef);
 937 #endif // USE(CF)
 938 
 939     static void setCrashOnVMCreation(bool);
 940 
 941     class DeferExceptionScope {
 942     public:
</pre>
<hr />
<pre>
 951         SetForScope&lt;Exception*&gt; m_savedLastException;
 952     };
 953 
 954 private:
 955     friend class LLIntOffsetsExtractor;
 956 
 957     VM(VMType, HeapType);
 958     static VM*&amp; sharedInstanceInternal();
 959     void createNativeThunk();
 960 
 961     JS_EXPORT_PRIVATE Structure* setIteratorStructureSlow();
 962     JS_EXPORT_PRIVATE Structure* mapIteratorStructureSlow();
 963     JSCell* sentinelSetBucketSlow();
 964     JSCell* sentinelMapBucketSlow();
 965     JSPropertyNameEnumerator* emptyPropertyNameEnumeratorSlow();
 966 
 967     void updateStackLimits();
 968 
 969     bool isSafeToRecurse(void* stackLimit) const
 970     {
<span class="line-removed"> 971         ASSERT(Thread::current().stack().isGrowingDownward());</span>
 972         void* curr = currentStackPointer();
 973         return curr &gt;= stackLimit;
 974     }
 975 
 976     void setException(Exception* exception)
 977     {
 978         m_exception = exception;
 979         m_lastException = exception;
 980     }
 981     Exception* exception() const
 982     {
 983 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 984         m_needExceptionCheck = false;
 985 #endif
 986         return m_exception;
 987     }
 988     void clearException()
 989     {
 990 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 991         m_needExceptionCheck = false;
 992         m_nativeStackTraceOfLastThrow = nullptr;
 993         m_throwingThread = nullptr;
 994 #endif
 995         m_exception = nullptr;
 996     }
 997 
 998 #if ENABLE(C_LOOP)
 999     bool ensureStackCapacityForCLoop(Register* newTopOfStack);
1000     bool isSafeToRecurseSoftCLoop() const;
1001 #endif // ENABLE(C_LOOP)
1002 
<span class="line-modified">1003     JS_EXPORT_PRIVATE Exception* throwException(ExecState*, Exception*);</span>
<span class="line-modified">1004     JS_EXPORT_PRIVATE Exception* throwException(ExecState*, JSValue);</span>
<span class="line-modified">1005     JS_EXPORT_PRIVATE Exception* throwException(ExecState*, JSObject*);</span>
1006 
1007 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1008     void verifyExceptionCheckNeedIsSatisfied(unsigned depth, ExceptionEventLocation&amp;);
1009 #endif
1010 
1011     static void primitiveGigacageDisabledCallback(void*);
1012     void primitiveGigacageDisabled();
1013 
1014     void callPromiseRejectionCallback(Strong&lt;JSPromise&gt;&amp;);
1015     void didExhaustMicrotaskQueue();
1016 
1017 #if ENABLE(GC_VALIDATION)
1018     const ClassInfo* m_initializingObjectClass;
1019 #endif
1020 
1021     void* m_stackPointerAtVMEntry;
1022     size_t m_currentSoftReservedZoneSize;
1023     void* m_stackLimit { nullptr };
1024     void* m_softStackLimit { nullptr };
1025 #if ENABLE(C_LOOP)
</pre>
<hr />
<pre>
1028     void* m_lastStackTop { nullptr };
1029 
1030     Exception* m_exception { nullptr };
1031     Exception* m_lastException { nullptr };
1032 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1033     ExceptionScope* m_topExceptionScope { nullptr };
1034     ExceptionEventLocation m_simulatedThrowPointLocation;
1035     unsigned m_simulatedThrowPointRecursionDepth { 0 };
1036     mutable bool m_needExceptionCheck { false };
1037     std::unique_ptr&lt;StackTrace&gt; m_nativeStackTraceOfLastThrow;
1038     std::unique_ptr&lt;StackTrace&gt; m_nativeStackTraceOfLastSimulatedThrow;
1039     RefPtr&lt;Thread&gt; m_throwingThread;
1040 #endif
1041 
1042     bool m_failNextNewCodeBlock { false };
1043     DeletePropertyMode m_deletePropertyMode { DeletePropertyMode::Default };
1044     bool m_globalConstRedeclarationShouldThrow { true };
1045     bool m_shouldBuildPCToCodeOriginMapping { false };
1046     std::unique_ptr&lt;CodeCache&gt; m_codeCache;
1047     std::unique_ptr&lt;BuiltinExecutables&gt; m_builtinExecutables;
<span class="line-modified">1048     HashMap&lt;String, RefPtr&lt;WatchpointSet&gt;&gt; m_impurePropertyWatchpointSets;</span>
1049     std::unique_ptr&lt;TypeProfiler&gt; m_typeProfiler;
1050     std::unique_ptr&lt;TypeProfilerLog&gt; m_typeProfilerLog;
1051     unsigned m_typeProfilerEnabledCount;
1052     bool m_needToFirePrimitiveGigacageEnabled { false };
1053     Lock m_scratchBufferLock;
1054     Vector&lt;ScratchBuffer*&gt; m_scratchBuffers;
1055     size_t m_sizeOfLastScratchBuffer { 0 };

1056     InlineWatchpointSet m_primitiveGigacageEnabled;
1057     FunctionHasExecutedCache m_functionHasExecutedCache;
1058     std::unique_ptr&lt;ControlFlowProfiler&gt; m_controlFlowProfiler;
1059     unsigned m_controlFlowProfilerEnabledCount;
1060     Deque&lt;std::unique_ptr&lt;QueuedTask&gt;&gt; m_microtaskQueue;
<span class="line-modified">1061     MallocPtr&lt;EncodedJSValue&gt; m_exceptionFuzzBuffer;</span>
1062     VMTraps m_traps;
1063     RefPtr&lt;Watchdog&gt; m_watchdog;
1064     std::unique_ptr&lt;HeapProfiler&gt; m_heapProfiler;
1065 #if ENABLE(SAMPLING_PROFILER)
1066     RefPtr&lt;SamplingProfiler&gt; m_samplingProfiler;
1067 #endif
1068     std::unique_ptr&lt;FuzzerAgent&gt; m_fuzzerAgent;
1069     std::unique_ptr&lt;ShadowChicken&gt; m_shadowChicken;
1070     std::unique_ptr&lt;BytecodeIntrinsicRegistry&gt; m_bytecodeIntrinsicRegistry;
1071 
1072     // FIXME: We should remove handled promises from this list at GC flip. &lt;https://webkit.org/b/201005&gt;
1073     Vector&lt;Strong&lt;JSPromise&gt;&gt; m_aboutToBeNotifiedRejectedPromises;
1074 
1075     WTF::Function&lt;void(VM&amp;)&gt; m_onEachMicrotaskTick;
1076     uintptr_t m_currentWeakRefVersion { 0 };
1077 
1078 #if ENABLE(JIT)
<span class="line-modified">1079 #if !ASSERT_DISABLED</span>
1080     JS_EXPORT_PRIVATE static bool s_canUseJITIsSet;
1081 #endif
1082     JS_EXPORT_PRIVATE static bool s_canUseJIT;
1083 #endif
1084 
1085     VM* m_prev; // Required by DoublyLinkedListNode.
1086     VM* m_next; // Required by DoublyLinkedListNode.
1087 
1088     // Friends for exception checking purpose only.
1089     friend class Heap;
1090     friend class CatchScope;
1091     friend class ExceptionScope;

1092     friend class ThrowScope;
1093     friend class VMTraps;
1094     friend class WTF::DoublyLinkedListNode&lt;VM&gt;;
1095 };
1096 
1097 #if ENABLE(GC_VALIDATION)
1098 inline bool VM::isInitializingObject() const
1099 {
1100     return !!m_initializingObjectClass;
1101 }
1102 
1103 inline void VM::setInitializingObjectClass(const ClassInfo* initializingObjectClass)
1104 {
1105     m_initializingObjectClass = initializingObjectClass;
1106 }
1107 #endif
1108 
1109 inline Heap* WeakSet::heap() const
1110 {
<span class="line-modified">1111     return &amp;m_vm.heap;</span>
1112 }
1113 
1114 #if !ENABLE(C_LOOP)
1115 extern &quot;C&quot; void sanitizeStackForVMImpl(VM*);
1116 #endif
1117 
1118 JS_EXPORT_PRIVATE void sanitizeStackForVM(VM&amp;);
1119 void logSanitizeStack(VM&amp;);
1120 
1121 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2020 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #pragma once
  30 
  31 #include &quot;CallData.h&quot;
  32 #include &quot;CodeSpecializationKind.h&quot;
  33 #include &quot;CompleteSubspace.h&quot;
  34 #include &quot;ConcurrentJSLock.h&quot;
  35 #include &quot;ControlFlowProfiler.h&quot;
  36 #include &quot;DateInstanceCache.h&quot;
  37 #include &quot;DeleteAllCodeEffort.h&quot;
  38 #include &quot;ExceptionEventLocation.h&quot;
  39 #include &quot;ExecutableAllocator.h&quot;
  40 #include &quot;FunctionHasExecutedCache.h&quot;
  41 #include &quot;FuzzerAgent.h&quot;
  42 #include &quot;Heap.h&quot;
<span class="line-added">  43 #include &quot;Integrity.h&quot;</span>
  44 #include &quot;Intrinsic.h&quot;
  45 #include &quot;IsoCellSet.h&quot;
  46 #include &quot;IsoSubspace.h&quot;
  47 #include &quot;JITThunks.h&quot;
  48 #include &quot;JSCJSValue.h&quot;
  49 #include &quot;JSLock.h&quot;
  50 #include &quot;MacroAssemblerCodeRef.h&quot;
  51 #include &quot;Microtask.h&quot;
  52 #include &quot;NumericStrings.h&quot;
  53 #include &quot;SmallStrings.h&quot;
  54 #include &quot;Strong.h&quot;
  55 #include &quot;StructureCache.h&quot;
  56 #include &quot;SubspaceAccess.h&quot;
  57 #include &quot;VMTraps.h&quot;
  58 #include &quot;WasmContext.h&quot;
  59 #include &quot;Watchpoint.h&quot;
  60 #include &lt;wtf/BumpPointerAllocator.h&gt;
  61 #include &lt;wtf/CheckedArithmetic.h&gt;
  62 #include &lt;wtf/DateMath.h&gt;
  63 #include &lt;wtf/Deque.h&gt;
</pre>
<hr />
<pre>
  69 #include &lt;wtf/SetForScope.h&gt;
  70 #include &lt;wtf/StackBounds.h&gt;
  71 #include &lt;wtf/StackPointer.h&gt;
  72 #include &lt;wtf/Stopwatch.h&gt;
  73 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
  74 #include &lt;wtf/ThreadSpecific.h&gt;
  75 #include &lt;wtf/UniqueArray.h&gt;
  76 #include &lt;wtf/text/SymbolRegistry.h&gt;
  77 #include &lt;wtf/text/WTFString.h&gt;
  78 #if ENABLE(REGEXP_TRACING)
  79 #include &lt;wtf/ListHashSet.h&gt;
  80 #endif
  81 
  82 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
  83 #include &lt;wtf/StackTrace.h&gt;
  84 #endif
  85 
  86 // Enable the Objective-C API for platforms with a modern runtime. This has to match exactly what we
  87 // have in JSBase.h.
  88 #if !defined(JSC_OBJC_API_ENABLED)
<span class="line-modified">  89 #if (defined(__clang__) &amp;&amp; defined(__APPLE__) &amp;&amp; (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) || (defined(TARGET_OS_IPHONE) &amp;&amp; TARGET_OS_IPHONE)))</span>
  90 #define JSC_OBJC_API_ENABLED 1
  91 #else
  92 #define JSC_OBJC_API_ENABLED 0
  93 #endif
  94 #endif
  95 
  96 namespace WTF {
  97 class SimpleStats;
  98 } // namespace WTF
  99 using WTF::SimpleStats;
 100 
 101 namespace JSC {
 102 
 103 class BuiltinExecutables;
 104 class BytecodeIntrinsicRegistry;
<span class="line-added"> 105 class CallFrame;</span>
<span class="line-added"> 106 struct CheckpointOSRExitSideState;</span>
 107 class CodeBlock;
 108 class CodeCache;
 109 class CommonIdentifiers;
 110 class CompactVariableMap;
<span class="line-added"> 111 class ConservativeRoots;</span>
 112 class CustomGetterSetter;
 113 class DOMAttributeGetterSetter;
<span class="line-modified"> 114 class DateInstance;</span>
<span class="line-added"> 115 class ErrorInstance;</span>
 116 class Exception;
 117 class ExceptionScope;
 118 class FastMallocAlignedMemoryAllocator;
 119 class GigacageAlignedMemoryAllocator;
 120 class HandleStack;
 121 class TypeProfiler;
 122 class TypeProfilerLog;
 123 class HasOwnPropertyCache;
 124 class HeapProfiler;
 125 class Identifier;
 126 class Interpreter;
<span class="line-added"> 127 class IntlCollator;</span>
<span class="line-added"> 128 class IntlDateTimeFormat;</span>
<span class="line-added"> 129 class IntlNumberFormat;</span>
<span class="line-added"> 130 class IntlPluralRules;</span>
<span class="line-added"> 131 class JSAPIGlobalObject;</span>
<span class="line-added"> 132 class JSAPIWrapperGlobalObject;</span>
<span class="line-added"> 133 class JSAPIWrapperObject;</span>
<span class="line-added"> 134 class JSCCallbackFunction;</span>
<span class="line-added"> 135 class JSCallbackConstructor;</span>
 136 class JSCustomGetterSetterFunction;
 137 class JSDestructibleObjectHeapCellType;
 138 class JSGlobalObject;
<span class="line-added"> 139 class JSGlobalLexicalEnvironment;</span>
<span class="line-added"> 140 class JSModuleNamespaceObject;</span>
<span class="line-added"> 141 class JSModuleRecord;</span>
<span class="line-added"> 142 class JSNativeStdFunction;</span>
<span class="line-added"> 143 class JSNonFinalObject;</span>
 144 class JSObject;
 145 class JSPromise;
 146 class JSPropertyNameEnumerator;
 147 class JSRunLoopTimer;
<span class="line-modified"> 148 class JSWeakMap;</span>
<span class="line-modified"> 149 class JSWeakSet;</span>
<span class="line-added"> 150 class JSWebAssemblyCodeBlock;</span>
<span class="line-added"> 151 class JSWebAssemblyGlobal;</span>
 152 class JSWebAssemblyInstance;
<span class="line-added"> 153 class JSWebAssemblyMemory;</span>
<span class="line-added"> 154 class JSWebAssemblyModule;</span>
<span class="line-added"> 155 class JSWebAssemblyTable;</span>
 156 class LLIntOffsetsExtractor;
 157 class NativeExecutable;
<span class="line-modified"> 158 class ObjCCallbackFunction;</span>
<span class="line-added"> 159 class PromiseTimer;</span>
 160 class RegExp;
 161 class RegExpCache;
 162 class Register;
 163 class RegisterAtOffsetList;
 164 #if ENABLE(SAMPLING_PROFILER)
 165 class SamplingProfiler;
 166 #endif
 167 class ShadowChicken;
 168 class ScriptExecutable;
 169 class SourceProvider;
 170 class SourceProviderCache;
 171 class StackFrame;
 172 class Structure;
 173 #if ENABLE(REGEXP_TRACING)
 174 class RegExp;
 175 #endif
 176 class Symbol;
 177 class TypedArrayController;
 178 class UnlinkedCodeBlock;
 179 class UnlinkedEvalCodeBlock;
 180 class UnlinkedFunctionExecutable;
 181 class UnlinkedProgramCodeBlock;
 182 class UnlinkedModuleProgramCodeBlock;
 183 class VirtualRegister;
 184 class VMEntryScope;
<span class="line-added"> 185 class TopLevelGlobalObjectScope;</span>
 186 class Watchdog;
 187 class Watchpoint;
 188 class WatchpointSet;
<span class="line-modified"> 189 class WebAssemblyFunction;</span>
<span class="line-added"> 190 class WebAssemblyModuleRecord;</span>
<span class="line-added"> 191 </span>
<span class="line-added"> 192 class IsoHeapCellType;</span>
<span class="line-added"> 193 template&lt;typename CellType&gt; class IsoInlinedHeapCellType;</span>
<span class="line-added"> 194 template&lt;typename Parent&gt; class JSCallbackObject;</span>
 195 
 196 #if ENABLE(FTL_JIT)
 197 namespace FTL {
 198 class Thunks;
 199 }
 200 #endif // ENABLE(FTL_JIT)
 201 namespace Profiler {
 202 class Database;
 203 }
 204 namespace DOMJIT {
 205 class Signature;
 206 }
 207 
 208 struct EntryFrame;
 209 struct HashTable;
 210 struct Instruction;
 211 struct ValueProfile;
 212 


 213 struct LocalTimeOffsetCache {
 214     LocalTimeOffsetCache()
 215         : start(0.0)
 216         , end(-1.0)
 217         , increment(0.0)
 218     {
 219     }
 220 
 221     void reset()
 222     {
 223         offset = LocalTimeOffset();
 224         start = 0.0;
 225         end = -1.0;
 226         increment = 0.0;
 227     }
 228 
 229     LocalTimeOffset offset;
 230     double start;
 231     double end;
 232     double increment;
</pre>
<hr />
<pre>
 234 
 235 class QueuedTask {
 236     WTF_MAKE_NONCOPYABLE(QueuedTask);
 237     WTF_MAKE_FAST_ALLOCATED;
 238 public:
 239     void run();
 240 
 241     QueuedTask(VM&amp; vm, JSGlobalObject* globalObject, Ref&lt;Microtask&gt;&amp;&amp; microtask)
 242         : m_globalObject(vm, globalObject)
 243         , m_microtask(WTFMove(microtask))
 244     {
 245     }
 246 
 247 private:
 248     Strong&lt;JSGlobalObject&gt; m_globalObject;
 249     Ref&lt;Microtask&gt; m_microtask;
 250 };
 251 
 252 class ConservativeRoots;
 253 
<span class="line-added"> 254 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(VM);</span>
<span class="line-added"> 255 </span>
 256 #if COMPILER(MSVC)
 257 #pragma warning(push)
 258 #pragma warning(disable: 4200) // Disable &quot;zero-sized array in struct/union&quot; warning
 259 #endif
 260 struct ScratchBuffer {
 261     ScratchBuffer()
 262     {
 263         u.m_activeLength = 0;
 264     }
 265 
 266     static ScratchBuffer* create(size_t size)
 267     {
<span class="line-modified"> 268         ScratchBuffer* result = new (VMMalloc::malloc(ScratchBuffer::allocationSize(size))) ScratchBuffer;</span>

 269         return result;
 270     }
 271 
 272     static size_t allocationSize(Checked&lt;size_t&gt; bufferSize) { return (sizeof(ScratchBuffer) + bufferSize).unsafeGet(); }
 273     void setActiveLength(size_t activeLength) { u.m_activeLength = activeLength; }
 274     size_t activeLength() const { return u.m_activeLength; };
 275     size_t* addressOfActiveLength() { return &amp;u.m_activeLength; };
 276     void* dataBuffer() { return m_buffer; }
 277 
 278     union {
 279         size_t m_activeLength;
 280         double pad; // Make sure m_buffer is double aligned.
 281     } u;
 282 #if CPU(MIPS) &amp;&amp; (defined WTF_MIPS_ARCH_REV &amp;&amp; WTF_MIPS_ARCH_REV == 2)
 283     alignas(8) void* m_buffer[0];
 284 #else
 285     void* m_buffer[0];
 286 #endif
 287 };
 288 #if COMPILER(MSVC)
</pre>
<hr />
<pre>
 311     JS_EXPORT_PRIVATE static VM&amp; sharedInstance();
 312 
 313     JS_EXPORT_PRIVATE static Ref&lt;VM&gt; create(HeapType = SmallHeap);
 314     static Ref&lt;VM&gt; createContextGroup(HeapType = SmallHeap);
 315     JS_EXPORT_PRIVATE ~VM();
 316 
 317     Watchdog&amp; ensureWatchdog();
 318     Watchdog* watchdog() { return m_watchdog.get(); }
 319 
 320     HeapProfiler* heapProfiler() const { return m_heapProfiler.get(); }
 321     JS_EXPORT_PRIVATE HeapProfiler&amp; ensureHeapProfiler();
 322 
 323 #if ENABLE(SAMPLING_PROFILER)
 324     SamplingProfiler* samplingProfiler() { return m_samplingProfiler.get(); }
 325     JS_EXPORT_PRIVATE SamplingProfiler&amp; ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp;);
 326 #endif
 327 
 328     FuzzerAgent* fuzzerAgent() const { return m_fuzzerAgent.get(); }
 329     void setFuzzerAgent(std::unique_ptr&lt;FuzzerAgent&gt;&amp;&amp; fuzzerAgent)
 330     {
<span class="line-added"> 331         RELEASE_ASSERT_WITH_MESSAGE(!m_fuzzerAgent, &quot;Only one FuzzerAgent can be specified at a time.&quot;);</span>
 332         m_fuzzerAgent = WTFMove(fuzzerAgent);
 333     }
 334 
 335     static unsigned numberOfIDs() { return s_numberOfIDs.load(); }
 336     unsigned id() const { return m_id; }
 337     bool isEntered() const { return !!entryScope; }
 338 
 339     inline CallFrame* topJSCallFrame() const;
 340 
 341     // Global object in which execution began.
<span class="line-modified"> 342     JS_EXPORT_PRIVATE JSGlobalObject* deprecatedVMEntryGlobalObject(JSGlobalObject*) const;</span>
<span class="line-added"> 343 </span>
<span class="line-added"> 344     WeakRandom&amp; random() { return m_random; }</span>
<span class="line-added"> 345     Integrity::Random&amp; integrityRandom() { return m_integrityRandom; }</span>
 346 
 347 private:
 348     unsigned nextID();
 349 
 350     static Atomic&lt;unsigned&gt; s_numberOfIDs;
 351 
 352     unsigned m_id;
 353     RefPtr&lt;JSLock&gt; m_apiLock;
 354 #if USE(CF)
 355     // These need to be initialized before heap below.
 356     RetainPtr&lt;CFRunLoopRef&gt; m_runLoop;
 357 #endif
 358 
<span class="line-added"> 359     WeakRandom m_random;</span>
<span class="line-added"> 360     Integrity::Random m_integrityRandom;</span>
<span class="line-added"> 361 </span>
 362 public:
 363     Heap heap;
 364 
 365     std::unique_ptr&lt;FastMallocAlignedMemoryAllocator&gt; fastMallocAllocator;
 366     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; primitiveGigacageAllocator;
 367     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; jsValueGigacageAllocator;
 368 
 369     std::unique_ptr&lt;HeapCellType&gt; auxiliaryHeapCellType;
 370     std::unique_ptr&lt;HeapCellType&gt; immutableButterflyHeapCellType;
 371     std::unique_ptr&lt;HeapCellType&gt; cellHeapCellType;
 372     std::unique_ptr&lt;HeapCellType&gt; destructibleCellHeapCellType;
<span class="line-modified"> 373     std::unique_ptr&lt;IsoHeapCellType&gt; apiGlobalObjectHeapCellType;</span>
<span class="line-added"> 374     std::unique_ptr&lt;IsoHeapCellType&gt; callbackConstructorHeapCellType;</span>
<span class="line-added"> 375     std::unique_ptr&lt;IsoHeapCellType&gt; callbackGlobalObjectHeapCellType;</span>
<span class="line-added"> 376     std::unique_ptr&lt;IsoHeapCellType&gt; callbackObjectHeapCellType;</span>
<span class="line-added"> 377     std::unique_ptr&lt;IsoHeapCellType&gt; dateInstanceHeapCellType;</span>
<span class="line-added"> 378     std::unique_ptr&lt;IsoHeapCellType&gt; errorInstanceHeapCellType;</span>
<span class="line-added"> 379     std::unique_ptr&lt;IsoHeapCellType&gt; globalLexicalEnvironmentHeapCellType;</span>
<span class="line-added"> 380     std::unique_ptr&lt;IsoHeapCellType&gt; globalObjectHeapCellType;</span>
<span class="line-added"> 381     std::unique_ptr&lt;IsoHeapCellType&gt; jsModuleRecordHeapCellType;</span>
<span class="line-added"> 382     std::unique_ptr&lt;IsoHeapCellType&gt; moduleNamespaceObjectHeapCellType;</span>
<span class="line-added"> 383     std::unique_ptr&lt;IsoHeapCellType&gt; nativeStdFunctionHeapCellType;</span>
<span class="line-added"> 384     std::unique_ptr&lt;IsoInlinedHeapCellType&lt;JSString&gt;&gt; stringHeapCellType;</span>
<span class="line-added"> 385     std::unique_ptr&lt;IsoHeapCellType&gt; weakMapHeapCellType;</span>
<span class="line-added"> 386     std::unique_ptr&lt;IsoHeapCellType&gt; weakSetHeapCellType;</span>
 387     std::unique_ptr&lt;JSDestructibleObjectHeapCellType&gt; destructibleObjectHeapCellType;
<span class="line-added"> 388 #if JSC_OBJC_API_ENABLED</span>
<span class="line-added"> 389     std::unique_ptr&lt;IsoHeapCellType&gt; apiWrapperObjectHeapCellType;</span>
<span class="line-added"> 390     std::unique_ptr&lt;IsoHeapCellType&gt; objCCallbackFunctionHeapCellType;</span>
<span class="line-added"> 391 #endif</span>
<span class="line-added"> 392 #ifdef JSC_GLIB_API_ENABLED</span>
<span class="line-added"> 393     std::unique_ptr&lt;IsoHeapCellType&gt; apiWrapperObjectHeapCellType;</span>
<span class="line-added"> 394     std::unique_ptr&lt;IsoHeapCellType&gt; callbackAPIWrapperGlobalObjectHeapCellType;</span>
<span class="line-added"> 395     std::unique_ptr&lt;IsoHeapCellType&gt; jscCallbackFunctionHeapCellType;</span>
<span class="line-added"> 396 #endif</span>
<span class="line-added"> 397 #if ENABLE(INTL)</span>
<span class="line-added"> 398     std::unique_ptr&lt;IsoHeapCellType&gt; intlCollatorHeapCellType;</span>
<span class="line-added"> 399     std::unique_ptr&lt;IsoHeapCellType&gt; intlDateTimeFormatHeapCellType;</span>
<span class="line-added"> 400     std::unique_ptr&lt;IsoHeapCellType&gt; intlNumberFormatHeapCellType;</span>
<span class="line-added"> 401     std::unique_ptr&lt;IsoHeapCellType&gt; intlPluralRulesHeapCellType;</span>
<span class="line-added"> 402 #endif</span>
 403 #if ENABLE(WEBASSEMBLY)
<span class="line-modified"> 404     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyCodeBlockHeapCellType;</span>
<span class="line-modified"> 405     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyFunctionHeapCellType;</span>
<span class="line-added"> 406     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyGlobalHeapCellType;</span>
<span class="line-added"> 407     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyInstanceHeapCellType;</span>
<span class="line-added"> 408     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyMemoryHeapCellType;</span>
<span class="line-added"> 409     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyModuleHeapCellType;</span>
<span class="line-added"> 410     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyModuleRecordHeapCellType;</span>
<span class="line-added"> 411     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyTableHeapCellType;</span>
 412 #endif
 413 
 414     CompleteSubspace primitiveGigacageAuxiliarySpace; // Typed arrays, strings, bitvectors, etc go here.
 415     CompleteSubspace jsValueGigacageAuxiliarySpace; // Butterflies, arrays of JSValues, etc go here.
 416     CompleteSubspace immutableButterflyJSValueGigacageAuxiliarySpace; // JSImmutableButterfly goes here.
 417 
 418     // We make cross-cutting assumptions about typed arrays being in the primitive Gigacage and butterflies
 419     // being in the JSValue gigacage. For some types, it&#39;s super obvious where they should go, and so we
 420     // can hardcode that fact. But sometimes it&#39;s not clear, so we abstract it by having a Gigacage::Kind
 421     // constant somewhere.
 422     // FIXME: Maybe it would be better if everyone abstracted this?
 423     // https://bugs.webkit.org/show_bug.cgi?id=175248
 424     ALWAYS_INLINE CompleteSubspace&amp; gigacageAuxiliarySpace(Gigacage::Kind kind)
 425     {
 426         switch (kind) {


 427         case Gigacage::Primitive:
 428             return primitiveGigacageAuxiliarySpace;
 429         case Gigacage::JSValue:
 430             return jsValueGigacageAuxiliarySpace;
<span class="line-added"> 431         case Gigacage::NumberOfKinds:</span>
<span class="line-added"> 432             break;</span>
 433         }
 434         RELEASE_ASSERT_NOT_REACHED();
 435         return primitiveGigacageAuxiliarySpace;
 436     }
 437 
 438     // Whenever possible, use subspaceFor&lt;CellType&gt;(vm) to get one of these subspaces.
 439     CompleteSubspace cellSpace;
<span class="line-modified"> 440     CompleteSubspace variableSizedCellSpace; // FIXME: This space is problematic because we have things in here like DirectArguments and ScopedArguments; those should be split into JSValueOOB cells and JSValueStrict auxiliaries. https://bugs.webkit.org/show_bug.cgi?id=182858</span>


 441     CompleteSubspace destructibleObjectSpace;

 442 
<span class="line-added"> 443     IsoSubspace bigIntSpace;</span>
<span class="line-added"> 444     IsoSubspace calleeSpace;</span>
<span class="line-added"> 445     IsoSubspace clonedArgumentsSpace;</span>
<span class="line-added"> 446     IsoSubspace customGetterSetterSpace;</span>
<span class="line-added"> 447     IsoSubspace dateInstanceSpace;</span>
<span class="line-added"> 448     IsoSubspace domAttributeGetterSetterSpace;</span>
<span class="line-added"> 449     IsoSubspace exceptionSpace;</span>
 450     IsoSubspace executableToCodeBlockEdgeSpace;
 451     IsoSubspace functionSpace;
<span class="line-added"> 452     IsoSubspace getterSetterSpace;</span>
<span class="line-added"> 453     IsoSubspace globalLexicalEnvironmentSpace;</span>
 454     IsoSubspace internalFunctionSpace;
<span class="line-added"> 455     IsoSubspace jsProxySpace;</span>
 456     IsoSubspace nativeExecutableSpace;
<span class="line-added"> 457     IsoSubspace numberObjectSpace;</span>
<span class="line-added"> 458     IsoSubspace promiseSpace;</span>
<span class="line-added"> 459     IsoSubspace propertyNameEnumeratorSpace;</span>
 460     IsoSubspace propertyTableSpace;
<span class="line-added"> 461     IsoSubspace regExpSpace;</span>
<span class="line-added"> 462     IsoSubspace regExpObjectSpace;</span>
<span class="line-added"> 463     IsoSubspace ropeStringSpace;</span>
<span class="line-added"> 464     IsoSubspace scopedArgumentsSpace;</span>
<span class="line-added"> 465     IsoSubspace sparseArrayValueMapSpace;</span>
<span class="line-added"> 466     IsoSubspace stringSpace;</span>
<span class="line-added"> 467     IsoSubspace stringObjectSpace;</span>
<span class="line-added"> 468     IsoSubspace structureChainSpace;</span>
 469     IsoSubspace structureRareDataSpace;
 470     IsoSubspace structureSpace;
 471     IsoSubspace symbolTableSpace;
 472 
 473 #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(name) \
 474     template&lt;SubspaceAccess mode&gt; \
 475     IsoSubspace* name() \
 476     { \
 477         if (m_##name || mode == SubspaceAccess::Concurrently) \
 478             return m_##name.get(); \
 479         return name##Slow(); \
 480     } \
<span class="line-modified"> 481     JS_EXPORT_PRIVATE IsoSubspace* name##Slow(); \</span>
 482     std::unique_ptr&lt;IsoSubspace&gt; m_##name;
 483 
 484 
 485 #if JSC_OBJC_API_ENABLED
<span class="line-added"> 486     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(apiWrapperObjectSpace)</span>
 487     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(objCCallbackFunctionSpace)
 488 #endif
<span class="line-added"> 489 #ifdef JSC_GLIB_API_ENABLED</span>
<span class="line-added"> 490     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(apiWrapperObjectSpace)</span>
<span class="line-added"> 491     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(jscCallbackFunctionSpace)</span>
<span class="line-added"> 492     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackAPIWrapperGlobalObjectSpace)</span>
<span class="line-added"> 493 #endif</span>
<span class="line-added"> 494     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(apiGlobalObjectSpace)</span>
<span class="line-added"> 495     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(apiValueWrapperSpace)</span>
<span class="line-added"> 496     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(arrayBufferSpace)</span>
<span class="line-added"> 497     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(arrayIteratorSpace)</span>
<span class="line-added"> 498     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(asyncGeneratorSpace)</span>
<span class="line-added"> 499     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(bigIntObjectSpace)</span>
<span class="line-added"> 500     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(booleanObjectSpace)</span>
 501     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(boundFunctionSpace)
<span class="line-added"> 502     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackConstructorSpace)</span>
<span class="line-added"> 503     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackGlobalObjectSpace)</span>
 504     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackFunctionSpace)
<span class="line-added"> 505     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackObjectSpace)</span>
 506     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(customGetterSetterFunctionSpace)
<span class="line-added"> 507     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(dataViewSpace)</span>
<span class="line-added"> 508     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(debuggerScopeSpace)</span>
 509     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(errorInstanceSpace)
<span class="line-added"> 510     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(float32ArraySpace)</span>
<span class="line-added"> 511     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(float64ArraySpace)</span>
<span class="line-added"> 512     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(functionRareDataSpace)</span>
<span class="line-added"> 513     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(generatorSpace)</span>
<span class="line-added"> 514     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(globalObjectSpace)</span>
<span class="line-added"> 515     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(int8ArraySpace)</span>
<span class="line-added"> 516     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(int16ArraySpace)</span>
<span class="line-added"> 517     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(int32ArraySpace)</span>
<span class="line-added"> 518     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(jsModuleRecordSpace)</span>
<span class="line-added"> 519     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(mapBucketSpace)</span>
<span class="line-added"> 520     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(mapIteratorSpace)</span>
<span class="line-added"> 521     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(mapSpace)</span>
<span class="line-added"> 522     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(moduleNamespaceObjectSpace)</span>
 523     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(nativeStdFunctionSpace)
<span class="line-added"> 524     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(proxyObjectSpace)</span>
 525     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(proxyRevokeSpace)
<span class="line-added"> 526     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(scopedArgumentsTableSpace)</span>
<span class="line-added"> 527     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(scriptFetchParametersSpace)</span>
<span class="line-added"> 528     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(scriptFetcherSpace)</span>
<span class="line-added"> 529     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(setBucketSpace)</span>
<span class="line-added"> 530     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(setIteratorSpace)</span>
<span class="line-added"> 531     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(setSpace)</span>
<span class="line-added"> 532     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(strictEvalActivationSpace)</span>
<span class="line-added"> 533     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(stringIteratorSpace)</span>
<span class="line-added"> 534     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(sourceCodeSpace)</span>
<span class="line-added"> 535     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(symbolSpace)</span>
<span class="line-added"> 536     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(symbolObjectSpace)</span>
<span class="line-added"> 537     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(templateObjectDescriptorSpace)</span>
<span class="line-added"> 538     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(uint8ArraySpace)</span>
<span class="line-added"> 539     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(uint8ClampedArraySpace)</span>
<span class="line-added"> 540     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(uint16ArraySpace)</span>
<span class="line-added"> 541     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(uint32ArraySpace)</span>
<span class="line-added"> 542     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(unlinkedEvalCodeBlockSpace)</span>
<span class="line-added"> 543     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(unlinkedFunctionCodeBlockSpace)</span>
<span class="line-added"> 544     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(unlinkedModuleProgramCodeBlockSpace)</span>
<span class="line-added"> 545     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(unlinkedProgramCodeBlockSpace)</span>
 546     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakObjectRefSpace)
 547     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakSetSpace)
 548     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakMapSpace)
<span class="line-added"> 549     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(withScopeSpace)</span>
<span class="line-added"> 550 #if ENABLE(INTL)</span>
<span class="line-added"> 551     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(intlCollatorSpace)</span>
<span class="line-added"> 552     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(intlDateTimeFormatSpace)</span>
<span class="line-added"> 553     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(intlNumberFormatSpace)</span>
<span class="line-added"> 554     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(intlPluralRulesSpace)</span>
<span class="line-added"> 555 #endif</span>
 556 #if ENABLE(WEBASSEMBLY)
<span class="line-added"> 557     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(jsToWasmICCalleeSpace)</span>
 558     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyCodeBlockSpace)
 559     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyFunctionSpace)
<span class="line-added"> 560     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyGlobalSpace)</span>
<span class="line-added"> 561     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyInstanceSpace)</span>
<span class="line-added"> 562     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyMemorySpace)</span>
<span class="line-added"> 563     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyModuleSpace)</span>
<span class="line-added"> 564     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyModuleRecordSpace)</span>
<span class="line-added"> 565     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyTableSpace)</span>
 566     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyWrapperFunctionSpace)
 567 #endif
 568 
 569 #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER
 570 
 571     IsoCellSet executableToCodeBlockEdgesWithConstraints;
 572     IsoCellSet executableToCodeBlockEdgesWithFinalizers;
 573 
 574 #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(name) \
 575     template&lt;SubspaceAccess mode&gt; \
 576     IsoSubspace* name() \
 577     { \
 578         if (auto* spaceAndSet = m_##name.get()) \
 579             return &amp;spaceAndSet-&gt;space; \
 580         if (mode == SubspaceAccess::Concurrently) \
 581             return nullptr; \
 582         return name##Slow(); \
 583     } \
 584     IsoSubspace* name##Slow(); \
 585     std::unique_ptr&lt;SpaceAndSet&gt; m_##name;
</pre>
<hr />
<pre>
 621     SpaceAndSet functionExecutableSpace;
 622     SpaceAndSet programExecutableSpace;
 623 
 624     template&lt;typename Func&gt;
 625     void forEachScriptExecutableSpace(const Func&amp; func)
 626     {
 627         if (m_evalExecutableSpace)
 628             func(*m_evalExecutableSpace);
 629         func(functionExecutableSpace);
 630         if (m_moduleProgramExecutableSpace)
 631             func(*m_moduleProgramExecutableSpace);
 632         func(programExecutableSpace);
 633     }
 634 
 635     SpaceAndSet unlinkedFunctionExecutableSpace;
 636 
 637 #undef DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER
 638 
 639     VMType vmType;
 640     ClientData* clientData;
<span class="line-modified"> 641     EntryFrame* topEntryFrame { nullptr };</span>
 642     // NOTE: When throwing an exception while rolling back the call frame, this may be equal to
 643     // topEntryFrame.
 644     // FIXME: This should be a void*, because it might not point to a CallFrame.
 645     // https://bugs.webkit.org/show_bug.cgi?id=160441
<span class="line-modified"> 646     CallFrame* topCallFrame { nullptr };</span>
 647 #if ENABLE(WEBASSEMBLY)
 648     Wasm::Context wasmContext;
 649 #endif
 650     Strong&lt;Structure&gt; structureStructure;
 651     Strong&lt;Structure&gt; structureRareDataStructure;
 652     Strong&lt;Structure&gt; terminatedExecutionErrorStructure;
 653     Strong&lt;Structure&gt; stringStructure;
 654     Strong&lt;Structure&gt; propertyNameEnumeratorStructure;
<span class="line-added"> 655     Strong&lt;Structure&gt; getterSetterStructure;</span>
 656     Strong&lt;Structure&gt; customGetterSetterStructure;
 657     Strong&lt;Structure&gt; domAttributeGetterSetterStructure;
 658     Strong&lt;Structure&gt; scopedArgumentsTableStructure;
 659     Strong&lt;Structure&gt; apiWrapperStructure;
 660     Strong&lt;Structure&gt; nativeExecutableStructure;
 661     Strong&lt;Structure&gt; evalExecutableStructure;
 662     Strong&lt;Structure&gt; programExecutableStructure;
 663     Strong&lt;Structure&gt; functionExecutableStructure;
 664 #if ENABLE(WEBASSEMBLY)
 665     Strong&lt;Structure&gt; webAssemblyCodeBlockStructure;
 666 #endif
 667     Strong&lt;Structure&gt; moduleProgramExecutableStructure;
 668     Strong&lt;Structure&gt; regExpStructure;
 669     Strong&lt;Structure&gt; symbolStructure;
 670     Strong&lt;Structure&gt; symbolTableStructure;

 671     Strong&lt;Structure&gt; immutableButterflyStructures[NumberOfCopyOnWriteIndexingModes];
 672     Strong&lt;Structure&gt; sourceCodeStructure;
 673     Strong&lt;Structure&gt; scriptFetcherStructure;
 674     Strong&lt;Structure&gt; scriptFetchParametersStructure;
 675     Strong&lt;Structure&gt; structureChainStructure;
 676     Strong&lt;Structure&gt; sparseArrayValueMapStructure;
 677     Strong&lt;Structure&gt; templateObjectDescriptorStructure;

 678     Strong&lt;Structure&gt; unlinkedFunctionExecutableStructure;
 679     Strong&lt;Structure&gt; unlinkedProgramCodeBlockStructure;
 680     Strong&lt;Structure&gt; unlinkedEvalCodeBlockStructure;
 681     Strong&lt;Structure&gt; unlinkedFunctionCodeBlockStructure;
 682     Strong&lt;Structure&gt; unlinkedModuleProgramCodeBlockStructure;
 683     Strong&lt;Structure&gt; propertyTableStructure;
 684     Strong&lt;Structure&gt; functionRareDataStructure;
 685     Strong&lt;Structure&gt; exceptionStructure;



 686     Strong&lt;Structure&gt; programCodeBlockStructure;
 687     Strong&lt;Structure&gt; moduleProgramCodeBlockStructure;
 688     Strong&lt;Structure&gt; evalCodeBlockStructure;
 689     Strong&lt;Structure&gt; functionCodeBlockStructure;
 690     Strong&lt;Structure&gt; hashMapBucketSetStructure;
 691     Strong&lt;Structure&gt; hashMapBucketMapStructure;
 692     Strong&lt;Structure&gt; bigIntStructure;
 693     Strong&lt;Structure&gt; executableToCodeBlockEdgeStructure;
 694 
 695     Strong&lt;Structure&gt; m_setIteratorStructure;
 696     Strong&lt;Structure&gt; m_mapIteratorStructure;
 697 
 698     Strong&lt;JSPropertyNameEnumerator&gt; m_emptyPropertyNameEnumerator;
 699 
 700     Strong&lt;JSCell&gt; m_sentinelSetBucket;
 701     Strong&lt;JSCell&gt; m_sentinelMapBucket;
 702 
<span class="line-modified"> 703     Weak&lt;NativeExecutable&gt; m_fastBoundExecutable;</span>
<span class="line-added"> 704     Weak&lt;NativeExecutable&gt; m_fastCanConstructBoundExecutable;</span>
<span class="line-added"> 705     Weak&lt;NativeExecutable&gt; m_slowBoundExecutable;</span>
<span class="line-added"> 706     Weak&lt;NativeExecutable&gt; m_slowCanConstructBoundExecutable;</span>
<span class="line-added"> 707 </span>
<span class="line-added"> 708     Ref&lt;PromiseTimer&gt; promiseTimer;</span>
 709 
 710     JSCell* currentlyDestructingCallbackObject;
 711     const ClassInfo* currentlyDestructingCallbackObjectClassInfo { nullptr };
 712 
 713     AtomStringTable* m_atomStringTable;
 714     WTF::SymbolRegistry m_symbolRegistry;
 715     CommonIdentifiers* propertyNames;
 716     const ArgList* emptyList;
 717     SmallStrings smallStrings;
 718     NumericStrings numericStrings;
 719     DateInstanceCache dateInstanceCache;
 720     std::unique_ptr&lt;SimpleStats&gt; machineCodeBytesPerBytecodeWordForBaselineJIT;
 721     WeakGCMap&lt;std::pair&lt;CustomGetterSetter*, int&gt;, JSCustomGetterSetterFunction&gt; customGetterSetterFunctionMap;
 722     WeakGCMap&lt;StringImpl*, JSString, PtrHash&lt;StringImpl*&gt;&gt; stringCache;
 723     Strong&lt;JSString&gt; lastCachedString;
 724 
 725     AtomStringTable* atomStringTable() const { return m_atomStringTable; }
 726     WTF::SymbolRegistry&amp; symbolRegistry() { return m_symbolRegistry; }
 727 
<span class="line-added"> 728     Strong&lt;JSBigInt&gt; bigIntConstantOne;</span>
<span class="line-added"> 729 </span>
 730     Structure* setIteratorStructure()
 731     {
 732         if (LIKELY(m_setIteratorStructure))
 733             return m_setIteratorStructure.get();
 734         return setIteratorStructureSlow();
 735     }
 736 
 737     Structure* mapIteratorStructure()
 738     {
 739         if (LIKELY(m_mapIteratorStructure))
 740             return m_mapIteratorStructure.get();
 741         return mapIteratorStructureSlow();
 742     }
 743 
 744     JSCell* sentinelSetBucket()
 745     {
 746         if (LIKELY(m_sentinelSetBucket))
 747             return m_sentinelSetBucket.get();
 748         return sentinelSetBucketSlow();
 749     }
</pre>
<hr />
<pre>
 794     private:
 795         VM&amp; m_vm;
 796         DeletePropertyMode m_previousMode;
 797     };
 798 
 799     static JS_EXPORT_PRIVATE bool canUseAssembler();
 800     static bool isInMiniMode()
 801     {
 802         return !canUseJIT() || Options::forceMiniVMMode();
 803     }
 804 
 805     static bool useUnlinkedCodeBlockJettisoning()
 806     {
 807         return Options::useUnlinkedCodeBlockJettisoning() || isInMiniMode();
 808     }
 809 
 810     static void computeCanUseJIT();
 811     ALWAYS_INLINE static bool canUseJIT()
 812     {
 813 #if ENABLE(JIT)
<span class="line-modified"> 814         ASSERT(s_canUseJITIsSet);</span>


 815         return s_canUseJIT;
 816 #else
 817         return false;
 818 #endif
 819     }
 820 
 821     SourceProviderCache* addSourceProviderCache(SourceProvider*);
 822     void clearSourceProviderCaches();
 823 
 824     StructureCache structureCache;
 825 
 826     typedef HashMap&lt;RefPtr&lt;SourceProvider&gt;, RefPtr&lt;SourceProviderCache&gt;&gt; SourceProviderCacheMap;
 827     SourceProviderCacheMap sourceProviderCacheMap;
 828     Interpreter* interpreter;
 829 #if ENABLE(JIT)
 830     std::unique_ptr&lt;JITThunks&gt; jitStubs;
 831     MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; getCTIStub(ThunkGenerator generator)
 832     {
 833         return jitStubs-&gt;ctiStub(*this, generator);
 834     }
 835 
 836 #endif // ENABLE(JIT)
 837 #if ENABLE(FTL_JIT)
 838     std::unique_ptr&lt;FTL::Thunks&gt; ftlThunks;
 839 #endif
 840     NativeExecutable* getHostFunction(NativeFunction, NativeFunction constructor, const String&amp; name);
 841     NativeExecutable* getHostFunction(NativeFunction, Intrinsic, NativeFunction constructor, const DOMJIT::Signature*, const String&amp; name);
 842 
<span class="line-added"> 843     NativeExecutable* getBoundFunction(bool isJSFunction, bool canConstruct);</span>
<span class="line-added"> 844 </span>
 845     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; getCTIInternalFunctionTrampolineFor(CodeSpecializationKind);
 846 
 847     static ptrdiff_t exceptionOffset()
 848     {
 849         return OBJECT_OFFSETOF(VM, m_exception);
 850     }
 851 
 852     static ptrdiff_t callFrameForCatchOffset()
 853     {
 854         return OBJECT_OFFSETOF(VM, callFrameForCatch);
 855     }
 856 
 857     static ptrdiff_t topEntryFrameOffset()
 858     {
 859         return OBJECT_OFFSETOF(VM, topEntryFrame);
 860     }
 861 
 862     static ptrdiff_t offsetOfHeapBarrierThreshold()
 863     {
 864         return OBJECT_OFFSETOF(VM, heap) + OBJECT_OFFSETOF(Heap, m_barrierThreshold);
 865     }
 866 
 867     static ptrdiff_t offsetOfHeapMutatorShouldBeFenced()
 868     {
 869         return OBJECT_OFFSETOF(VM, heap) + OBJECT_OFFSETOF(Heap, m_mutatorShouldBeFenced);
 870     }
 871 
 872     void restorePreviousException(Exception* exception) { setException(exception); }
 873 
 874     void clearLastException() { m_lastException = nullptr; }
 875 
<span class="line-modified"> 876     CallFrame** addressOfCallFrameForCatch() { return &amp;callFrameForCatch; }</span>
 877 
 878     JSCell** addressOfException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_exception); }
 879 
 880     Exception* lastException() const { return m_lastException; }
 881     JSCell** addressOfLastException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_lastException); }
 882 
 883     // This should only be used for test or assertion code that wants to inspect
 884     // the pending exception without interfering with Throw/CatchScopes.
 885     Exception* exceptionForInspection() const { return m_exception; }
 886 
 887     void setFailNextNewCodeBlock() { m_failNextNewCodeBlock = true; }
 888     bool getAndClearFailNextNewCodeBlock()
 889     {
 890         bool result = m_failNextNewCodeBlock;
 891         m_failNextNewCodeBlock = false;
 892         return result;
 893     }
 894 
 895     ALWAYS_INLINE Structure* getStructure(StructureID id)
 896     {
</pre>
<hr />
<pre>
 918     inline bool isSafeToRecurseSoft() const;
 919     bool isSafeToRecurse() const
 920     {
 921         return isSafeToRecurse(m_stackLimit);
 922     }
 923 
 924     void** addressOfLastStackTop() { return &amp;m_lastStackTop; }
 925     void* lastStackTop() { return m_lastStackTop; }
 926     void setLastStackTop(void*);
 927 
 928     void firePrimitiveGigacageEnabledIfNecessary()
 929     {
 930         if (m_needToFirePrimitiveGigacageEnabled) {
 931             m_needToFirePrimitiveGigacageEnabled = false;
 932             m_primitiveGigacageEnabled.fireAll(*this, &quot;Primitive gigacage disabled asynchronously&quot;);
 933         }
 934     }
 935 
 936     JSValue hostCallReturnValue;
 937     unsigned varargsLength;
<span class="line-modified"> 938     CallFrame* newCallFrameReturnValue;</span>
<span class="line-modified"> 939     CallFrame* callFrameForCatch;</span>
 940     void* targetMachinePCForThrow;
 941     const Instruction* targetInterpreterPCForThrow;
 942     uint32_t osrExitIndex;
 943     void* osrExitJumpDestination;
 944     bool isExecutingInRegExpJIT { false };
 945 
 946     // The threading protocol here is as follows:
 947     // - You can call scratchBufferForSize from any thread.
 948     // - You can only set the ScratchBuffer&#39;s activeLength from the main thread.
 949     // - You can only write to entries in the ScratchBuffer from the main thread.
 950     ScratchBuffer* scratchBufferForSize(size_t size);
 951     void clearScratchBuffers();
 952 
 953     EncodedJSValue* exceptionFuzzingBuffer(size_t size)
 954     {
 955         ASSERT(Options::useExceptionFuzz());
 956         if (!m_exceptionFuzzBuffer)
<span class="line-modified"> 957             m_exceptionFuzzBuffer = MallocPtr&lt;EncodedJSValue, VMMalloc&gt;::malloc(size);</span>
 958         return m_exceptionFuzzBuffer.get();
 959     }
 960 
 961     void gatherScratchBufferRoots(ConservativeRoots&amp;);
 962 
<span class="line-added"> 963     void addCheckpointOSRSideState(CallFrame*, std::unique_ptr&lt;CheckpointOSRExitSideState&gt;&amp;&amp;);</span>
<span class="line-added"> 964     std::unique_ptr&lt;CheckpointOSRExitSideState&gt; findCheckpointOSRSideState(CallFrame*);</span>
<span class="line-added"> 965     bool hasCheckpointOSRSideState() const { return m_checkpointSideState.size(); }</span>
<span class="line-added"> 966     void scanSideState(ConservativeRoots&amp;) const;</span>
<span class="line-added"> 967 </span>
 968     VMEntryScope* entryScope;
 969 
 970     JSObject* stringRecursionCheckFirstObject { nullptr };
 971     HashSet&lt;JSObject*&gt; stringRecursionCheckVisitedObjects;
 972 
 973     LocalTimeOffsetCache utcTimeOffsetCache;
 974     LocalTimeOffsetCache localTimeOffsetCache;
 975 
 976     String cachedDateString;
 977     double cachedDateStringValue;
 978 
 979     std::unique_ptr&lt;Profiler::Database&gt; m_perBytecodeProfiler;
 980     RefPtr&lt;TypedArrayController&gt; m_typedArrayController;
 981     RegExpCache* m_regExpCache;
 982     BumpPointerAllocator m_regExpAllocator;
 983     ConcurrentJSLock m_regExpAllocatorLock;
 984 
 985 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 986     static constexpr size_t patternContextBufferSize = 8192; // Space allocated to save nested parenthesis context
 987     UniqueArray&lt;char&gt; m_regExpPatternContexBuffer;
</pre>
<hr />
<pre>
1013 
1014     bool isCollectorBusyOnCurrentThread() { return heap.isCurrentThreadBusy(); }
1015 
1016 #if ENABLE(GC_VALIDATION)
1017     bool isInitializingObject() const;
1018     void setInitializingObjectClass(const ClassInfo*);
1019 #endif
1020 
1021     bool currentThreadIsHoldingAPILock() const { return m_apiLock-&gt;currentThreadIsHoldingLock(); }
1022 
1023     JSLock&amp; apiLock() { return *m_apiLock; }
1024     CodeCache* codeCache() { return m_codeCache.get(); }
1025 
1026     JS_EXPORT_PRIVATE void whenIdle(Function&lt;void()&gt;&amp;&amp;);
1027 
1028     JS_EXPORT_PRIVATE void deleteAllCode(DeleteAllCodeEffort);
1029     JS_EXPORT_PRIVATE void deleteAllLinkedCode(DeleteAllCodeEffort);
1030 
1031     void shrinkFootprintWhenIdle();
1032 
<span class="line-modified">1033     WatchpointSet* ensureWatchpointSetForImpureProperty(UniquedStringImpl*);</span>

1034 
1035     // FIXME: Use AtomString once it got merged with Identifier.
<span class="line-modified">1036     JS_EXPORT_PRIVATE void addImpureProperty(UniquedStringImpl*);</span>
1037 
1038     InlineWatchpointSet&amp; primitiveGigacageEnabled() { return m_primitiveGigacageEnabled; }
1039 
1040     BuiltinExecutables* builtinExecutables() { return m_builtinExecutables.get(); }
1041 
1042     bool enableTypeProfiler();
1043     bool disableTypeProfiler();
1044     TypeProfilerLog* typeProfilerLog() { return m_typeProfilerLog.get(); }
1045     TypeProfiler* typeProfiler() { return m_typeProfiler.get(); }
1046     JS_EXPORT_PRIVATE void dumpTypeProfilerData();
1047 
1048     FunctionHasExecutedCache* functionHasExecutedCache() { return &amp;m_functionHasExecutedCache; }
1049 
1050     ControlFlowProfiler* controlFlowProfiler() { return m_controlFlowProfiler.get(); }
1051     bool enableControlFlowProfiler();
1052     bool disableControlFlowProfiler();
1053 
1054     void queueMicrotask(JSGlobalObject&amp;, Ref&lt;Microtask&gt;&amp;&amp;);
1055     JS_EXPORT_PRIVATE void drainMicrotasks();
1056     void setOnEachMicrotaskTick(WTF::Function&lt;void(VM&amp;)&gt;&amp;&amp; func) { m_onEachMicrotaskTick = WTFMove(func); }
</pre>
<hr />
<pre>
1058     uintptr_t currentWeakRefVersion() const { return m_currentWeakRefVersion; }
1059 
1060     void setGlobalConstRedeclarationShouldThrow(bool globalConstRedeclarationThrow) { m_globalConstRedeclarationShouldThrow = globalConstRedeclarationThrow; }
1061     ALWAYS_INLINE bool globalConstRedeclarationShouldThrow() const { return m_globalConstRedeclarationShouldThrow; }
1062 
1063     void setShouldBuildPCToCodeOriginMapping() { m_shouldBuildPCToCodeOriginMapping = true; }
1064     bool shouldBuilderPCToCodeOriginMapping() const { return m_shouldBuildPCToCodeOriginMapping; }
1065 
1066     BytecodeIntrinsicRegistry&amp; bytecodeIntrinsicRegistry() { return *m_bytecodeIntrinsicRegistry; }
1067 
1068     ShadowChicken* shadowChicken() { return m_shadowChicken.get(); }
1069     void ensureShadowChicken();
1070 
1071     template&lt;typename Func&gt;
1072     void logEvent(CodeBlock*, const char* summary, const Func&amp; func);
1073 
1074     Optional&lt;RefPtr&lt;Thread&gt;&gt; ownerThread() const { return m_apiLock-&gt;ownerThread(); }
1075 
1076     VMTraps&amp; traps() { return m_traps; }
1077 
<span class="line-modified">1078     void handleTraps(JSGlobalObject* globalObject, CallFrame* callFrame, VMTraps::Mask mask = VMTraps::Mask::allEventTypes()) { m_traps.handleTraps(globalObject, callFrame, mask); }</span>
1079 
1080     bool needTrapHandling() { return m_traps.needTrapHandling(); }
1081     bool needTrapHandling(VMTraps::Mask mask) { return m_traps.needTrapHandling(mask); }
1082     void* needTrapHandlingAddress() { return m_traps.needTrapHandlingAddress(); }
1083 
1084     void notifyNeedDebuggerBreak() { m_traps.fireTrap(VMTraps::NeedDebuggerBreak); }
<span class="line-added">1085     void notifyNeedShellTimeoutCheck() { m_traps.fireTrap(VMTraps::NeedShellTimeoutCheck); }</span>
1086     void notifyNeedTermination() { m_traps.fireTrap(VMTraps::NeedTermination); }
1087     void notifyNeedWatchdogCheck() { m_traps.fireTrap(VMTraps::NeedWatchdogCheck); }
1088 
1089     void promiseRejected(JSPromise*);
1090 
1091 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1092     StackTrace* nativeStackTraceOfLastThrow() const { return m_nativeStackTraceOfLastThrow.get(); }
1093     Thread* throwingThread() const { return m_throwingThread.get(); }
1094     bool needExceptionCheck() const { return m_needExceptionCheck; }
1095 #endif
1096 
1097 #if USE(CF)
1098     CFRunLoopRef runLoop() const { return m_runLoop.get(); }
1099     JS_EXPORT_PRIVATE void setRunLoop(CFRunLoopRef);
1100 #endif // USE(CF)
1101 
1102     static void setCrashOnVMCreation(bool);
1103 
1104     class DeferExceptionScope {
1105     public:
</pre>
<hr />
<pre>
1114         SetForScope&lt;Exception*&gt; m_savedLastException;
1115     };
1116 
1117 private:
1118     friend class LLIntOffsetsExtractor;
1119 
1120     VM(VMType, HeapType);
1121     static VM*&amp; sharedInstanceInternal();
1122     void createNativeThunk();
1123 
1124     JS_EXPORT_PRIVATE Structure* setIteratorStructureSlow();
1125     JS_EXPORT_PRIVATE Structure* mapIteratorStructureSlow();
1126     JSCell* sentinelSetBucketSlow();
1127     JSCell* sentinelMapBucketSlow();
1128     JSPropertyNameEnumerator* emptyPropertyNameEnumeratorSlow();
1129 
1130     void updateStackLimits();
1131 
1132     bool isSafeToRecurse(void* stackLimit) const
1133     {

1134         void* curr = currentStackPointer();
1135         return curr &gt;= stackLimit;
1136     }
1137 
1138     void setException(Exception* exception)
1139     {
1140         m_exception = exception;
1141         m_lastException = exception;
1142     }
1143     Exception* exception() const
1144     {
1145 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1146         m_needExceptionCheck = false;
1147 #endif
1148         return m_exception;
1149     }
1150     void clearException()
1151     {
1152 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1153         m_needExceptionCheck = false;
1154         m_nativeStackTraceOfLastThrow = nullptr;
1155         m_throwingThread = nullptr;
1156 #endif
1157         m_exception = nullptr;
1158     }
1159 
1160 #if ENABLE(C_LOOP)
1161     bool ensureStackCapacityForCLoop(Register* newTopOfStack);
1162     bool isSafeToRecurseSoftCLoop() const;
1163 #endif // ENABLE(C_LOOP)
1164 
<span class="line-modified">1165     JS_EXPORT_PRIVATE Exception* throwException(JSGlobalObject*, Exception*);</span>
<span class="line-modified">1166     JS_EXPORT_PRIVATE Exception* throwException(JSGlobalObject*, JSValue);</span>
<span class="line-modified">1167     JS_EXPORT_PRIVATE Exception* throwException(JSGlobalObject*, JSObject*);</span>
1168 
1169 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1170     void verifyExceptionCheckNeedIsSatisfied(unsigned depth, ExceptionEventLocation&amp;);
1171 #endif
1172 
1173     static void primitiveGigacageDisabledCallback(void*);
1174     void primitiveGigacageDisabled();
1175 
1176     void callPromiseRejectionCallback(Strong&lt;JSPromise&gt;&amp;);
1177     void didExhaustMicrotaskQueue();
1178 
1179 #if ENABLE(GC_VALIDATION)
1180     const ClassInfo* m_initializingObjectClass;
1181 #endif
1182 
1183     void* m_stackPointerAtVMEntry;
1184     size_t m_currentSoftReservedZoneSize;
1185     void* m_stackLimit { nullptr };
1186     void* m_softStackLimit { nullptr };
1187 #if ENABLE(C_LOOP)
</pre>
<hr />
<pre>
1190     void* m_lastStackTop { nullptr };
1191 
1192     Exception* m_exception { nullptr };
1193     Exception* m_lastException { nullptr };
1194 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1195     ExceptionScope* m_topExceptionScope { nullptr };
1196     ExceptionEventLocation m_simulatedThrowPointLocation;
1197     unsigned m_simulatedThrowPointRecursionDepth { 0 };
1198     mutable bool m_needExceptionCheck { false };
1199     std::unique_ptr&lt;StackTrace&gt; m_nativeStackTraceOfLastThrow;
1200     std::unique_ptr&lt;StackTrace&gt; m_nativeStackTraceOfLastSimulatedThrow;
1201     RefPtr&lt;Thread&gt; m_throwingThread;
1202 #endif
1203 
1204     bool m_failNextNewCodeBlock { false };
1205     DeletePropertyMode m_deletePropertyMode { DeletePropertyMode::Default };
1206     bool m_globalConstRedeclarationShouldThrow { true };
1207     bool m_shouldBuildPCToCodeOriginMapping { false };
1208     std::unique_ptr&lt;CodeCache&gt; m_codeCache;
1209     std::unique_ptr&lt;BuiltinExecutables&gt; m_builtinExecutables;
<span class="line-modified">1210     HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, RefPtr&lt;WatchpointSet&gt;&gt; m_impurePropertyWatchpointSets;</span>
1211     std::unique_ptr&lt;TypeProfiler&gt; m_typeProfiler;
1212     std::unique_ptr&lt;TypeProfilerLog&gt; m_typeProfilerLog;
1213     unsigned m_typeProfilerEnabledCount;
1214     bool m_needToFirePrimitiveGigacageEnabled { false };
1215     Lock m_scratchBufferLock;
1216     Vector&lt;ScratchBuffer*&gt; m_scratchBuffers;
1217     size_t m_sizeOfLastScratchBuffer { 0 };
<span class="line-added">1218     HashMap&lt;CallFrame*, std::unique_ptr&lt;CheckpointOSRExitSideState&gt;&gt; m_checkpointSideState;</span>
1219     InlineWatchpointSet m_primitiveGigacageEnabled;
1220     FunctionHasExecutedCache m_functionHasExecutedCache;
1221     std::unique_ptr&lt;ControlFlowProfiler&gt; m_controlFlowProfiler;
1222     unsigned m_controlFlowProfilerEnabledCount;
1223     Deque&lt;std::unique_ptr&lt;QueuedTask&gt;&gt; m_microtaskQueue;
<span class="line-modified">1224     MallocPtr&lt;EncodedJSValue, VMMalloc&gt; m_exceptionFuzzBuffer;</span>
1225     VMTraps m_traps;
1226     RefPtr&lt;Watchdog&gt; m_watchdog;
1227     std::unique_ptr&lt;HeapProfiler&gt; m_heapProfiler;
1228 #if ENABLE(SAMPLING_PROFILER)
1229     RefPtr&lt;SamplingProfiler&gt; m_samplingProfiler;
1230 #endif
1231     std::unique_ptr&lt;FuzzerAgent&gt; m_fuzzerAgent;
1232     std::unique_ptr&lt;ShadowChicken&gt; m_shadowChicken;
1233     std::unique_ptr&lt;BytecodeIntrinsicRegistry&gt; m_bytecodeIntrinsicRegistry;
1234 
1235     // FIXME: We should remove handled promises from this list at GC flip. &lt;https://webkit.org/b/201005&gt;
1236     Vector&lt;Strong&lt;JSPromise&gt;&gt; m_aboutToBeNotifiedRejectedPromises;
1237 
1238     WTF::Function&lt;void(VM&amp;)&gt; m_onEachMicrotaskTick;
1239     uintptr_t m_currentWeakRefVersion { 0 };
1240 
1241 #if ENABLE(JIT)
<span class="line-modified">1242 #if ASSERT_ENABLED</span>
1243     JS_EXPORT_PRIVATE static bool s_canUseJITIsSet;
1244 #endif
1245     JS_EXPORT_PRIVATE static bool s_canUseJIT;
1246 #endif
1247 
1248     VM* m_prev; // Required by DoublyLinkedListNode.
1249     VM* m_next; // Required by DoublyLinkedListNode.
1250 
1251     // Friends for exception checking purpose only.
1252     friend class Heap;
1253     friend class CatchScope;
1254     friend class ExceptionScope;
<span class="line-added">1255     friend class JSDollarVMHelper;</span>
1256     friend class ThrowScope;
1257     friend class VMTraps;
1258     friend class WTF::DoublyLinkedListNode&lt;VM&gt;;
1259 };
1260 
1261 #if ENABLE(GC_VALIDATION)
1262 inline bool VM::isInitializingObject() const
1263 {
1264     return !!m_initializingObjectClass;
1265 }
1266 
1267 inline void VM::setInitializingObjectClass(const ClassInfo* initializingObjectClass)
1268 {
1269     m_initializingObjectClass = initializingObjectClass;
1270 }
1271 #endif
1272 
1273 inline Heap* WeakSet::heap() const
1274 {
<span class="line-modified">1275     return &amp;m_vm-&gt;heap;</span>
1276 }
1277 
1278 #if !ENABLE(C_LOOP)
1279 extern &quot;C&quot; void sanitizeStackForVMImpl(VM*);
1280 #endif
1281 
1282 JS_EXPORT_PRIVATE void sanitizeStackForVM(VM&amp;);
1283 void logSanitizeStack(VM&amp;);
1284 
1285 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="VM.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMEntryScope.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
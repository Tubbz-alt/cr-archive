<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmLLIntPlan.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmLLIntPlan.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;B3Compilation.h&quot;
 32 #include &quot;BytecodeDumper.h&quot;
 33 #include &quot;CalleeBits.h&quot;
 34 #include &quot;JSToWasm.h&quot;
 35 #include &quot;LLIntThunks.h&quot;
 36 #include &quot;LinkBuffer.h&quot;
 37 #include &quot;WasmCallee.h&quot;
 38 #include &quot;WasmLLIntGenerator.h&quot;
 39 #include &quot;WasmSignatureInlines.h&quot;
 40 
 41 namespace JSC { namespace Wasm {
 42 
 43 namespace WasmLLIntPlanInternal {
 44 static const bool verbose = false;
 45 }
 46 
 47 LLIntPlan::LLIntPlan(Context* context, Vector&lt;uint8_t&gt;&amp;&amp; source, AsyncWork work, CompletionTask&amp;&amp; task)
 48     : Base(context, WTFMove(source), work, WTFMove(task))
 49 {
 50     if (parseAndValidateModule(m_source.data(), m_source.size()))
 51         prepare();
 52 }
 53 
 54 LLIntPlan::LLIntPlan(Context* context, Ref&lt;ModuleInformation&gt; info, const Ref&lt;LLIntCallee&gt;* callees, CompletionTask&amp;&amp; task)
 55     : Base(context, WTFMove(info), AsyncWork::FullCompile, WTFMove(task))
 56     , m_callees(callees)
 57 {
 58     ASSERT(m_callees || !m_moduleInformation-&gt;functions.size());
 59     prepare();
 60     m_currentIndex = m_moduleInformation-&gt;functions.size();
 61 }
 62 
 63 bool LLIntPlan::prepareImpl()
 64 {
 65     const auto&amp; functions = m_moduleInformation-&gt;functions;
 66     if (!tryReserveCapacity(m_wasmInternalFunctions, functions.size(), &quot; WebAssembly functions&quot;))
 67         return false;
 68 
 69     m_wasmInternalFunctions.resize(functions.size());
 70 
 71     return true;
 72 }
 73 
 74 void LLIntPlan::compileFunction(uint32_t functionIndex)
 75 {
 76     const auto&amp; function = m_moduleInformation-&gt;functions[functionIndex];
 77     SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];
 78     const Signature&amp; signature = SignatureInformation::get(signatureIndex);
 79     unsigned functionIndexSpace = m_wasmToWasmExitStubs.size() + functionIndex;
 80     ASSERT_UNUSED(functionIndexSpace, m_moduleInformation-&gt;signatureIndexFromFunctionIndexSpace(functionIndexSpace) == signatureIndex);
 81 
 82     m_unlinkedWasmToWasmCalls[functionIndex] = Vector&lt;UnlinkedWasmToWasmCall&gt;();
 83     Expected&lt;std::unique_ptr&lt;FunctionCodeBlock&gt;, String&gt; parseAndCompileResult = parseAndCompileBytecode(function.data.data(), function.data.size(), signature, m_moduleInformation.get(), functionIndex);
 84 
 85     if (UNLIKELY(!parseAndCompileResult)) {
 86         auto locker = holdLock(m_lock);
 87         if (!m_errorMessage) {
 88             // Multiple compiles could fail simultaneously. We arbitrarily choose the first.
 89             fail(locker, makeString(parseAndCompileResult.error(), &quot;, in function at index &quot;, String::number(functionIndex))); // FIXME make this an Expected.
 90         }
 91         m_currentIndex = m_moduleInformation-&gt;functions.size();
 92         return;
 93     }
 94 
 95     m_wasmInternalFunctions[functionIndex] = WTFMove(*parseAndCompileResult);
 96 }
 97 
 98 void LLIntPlan::didCompleteCompilation(const AbstractLocker&amp; locker)
 99 {
100     unsigned functionCount = m_wasmInternalFunctions.size();
101     if (!m_callees &amp;&amp; functionCount) {
102         // LLInt entrypoint thunks generation
103         CCallHelpers jit;
104         m_calleesVector.resize(functionCount);
105         Vector&lt;CCallHelpers::Label&gt; entrypoints(functionCount);
106         Vector&lt;CCallHelpers::Jump&gt; jumps(functionCount);
107         for (unsigned i = 0; i &lt; functionCount; ++i) {
108             size_t functionIndexSpace = i + m_moduleInformation-&gt;importFunctionCount();
109 
110             if (UNLIKELY(Options::dumpGeneratedWasmBytecodes()))
111                 BytecodeDumper::dumpBlock(m_wasmInternalFunctions[i].get(), m_moduleInformation, WTF::dataFile());
112 
113             m_calleesVector[i] = LLIntCallee::create(WTFMove(m_wasmInternalFunctions[i]), functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace));
114             entrypoints[i] = jit.label();
115 #if CPU(X86_64)
116             CCallHelpers::Address calleeSlot(CCallHelpers::stackPointerRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register)) - sizeof(CPURegister));
117 #elif CPU(ARM64)
118             CCallHelpers::Address calleeSlot(CCallHelpers::stackPointerRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register)) - sizeof(CallerFrameAndPC));
119 #else
120 #error Unsupported architecture.
121 #endif
122             jit.storePtr(CCallHelpers::TrustedImmPtr(CalleeBits::boxWasm(m_calleesVector[i].ptr())), calleeSlot);
123             jumps[i] = jit.jump();
124         }
125 
126         LinkBuffer linkBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);
127         if (UNLIKELY(linkBuffer.didFailToAllocate())) {
128             Base::fail(locker, &quot;Out of executable memory in Wasm LLInt entry thunks&quot;);
129             return;
130         }
131 
132         for (unsigned i = 0; i &lt; functionCount; ++i) {
133             m_calleesVector[i]-&gt;setEntrypoint(linkBuffer.locationOf&lt;WasmEntryPtrTag&gt;(entrypoints[i]));
134             linkBuffer.link&lt;JITThunkPtrTag&gt;(jumps[i], CodeLocationLabel&lt;JITThunkPtrTag&gt;(LLInt::wasmFunctionEntryThunk().code()));
135         }
136 
137         m_entryThunks = FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;Wasm LLInt entry thunks&quot;);
138         m_callees = m_calleesVector.data();
139     }
140 
141     if (m_asyncWork == AsyncWork::Validation)
142         return;
143 
144     for (uint32_t functionIndex = 0; functionIndex &lt; m_moduleInformation-&gt;functions.size(); functionIndex++) {
145         if (m_exportedFunctionIndices.contains(functionIndex) || m_moduleInformation-&gt;referencedFunctions().contains(functionIndex)) {
146             SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];
147             const Signature&amp; signature = SignatureInformation::get(signatureIndex);
148             CCallHelpers jit;
149             // The LLInt always bounds checks
150             MemoryMode mode = MemoryMode::BoundsChecking;
151             std::unique_ptr&lt;InternalFunction&gt; function = createJSToWasmWrapper(jit, signature, &amp;m_unlinkedWasmToWasmCalls[functionIndex], m_moduleInformation.get(), mode, functionIndex);
152 
153             LinkBuffer linkBuffer(jit, nullptr, JITCompilationCanFail);
154             if (UNLIKELY(linkBuffer.didFailToAllocate())) {
155                 Base::fail(locker, makeString(&quot;Out of executable memory in function entrypoint at index &quot;, String::number(functionIndex)));
156                 return;
157             }
158 
159             function-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(
160                 FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;Embedder-&gt;WebAssembly entrypoint[%i] %s&quot;, functionIndex, signature.toString().ascii().data()),
161                 nullptr);
162 
163             Ref&lt;EmbedderEntrypointCallee&gt; callee = EmbedderEntrypointCallee::create(WTFMove(function-&gt;entrypoint));
164             // FIXME: remove this repatchPointer - just pass in the callee directly
165             // https://bugs.webkit.org/show_bug.cgi?id=166462
166             if (function-&gt;calleeMoveLocation)
167                 MacroAssembler::repatchPointer(function-&gt;calleeMoveLocation, CalleeBits::boxWasm(callee.ptr()));
168 
169             auto result = m_embedderCallees.add(functionIndex, WTFMove(callee));
170             ASSERT_UNUSED(result, result.isNewEntry);
171         }
172     }
173 
174     for (auto&amp; unlinked : m_unlinkedWasmToWasmCalls) {
175         for (auto&amp; call : unlinked) {
176             MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; executableAddress;
177             if (m_moduleInformation-&gt;isImportedFunctionFromFunctionIndexSpace(call.functionIndexSpace)) {
178                 // FIXME: imports could have been linked in B3, instead of generating a patchpoint. This condition should be replaced by a RELEASE_ASSERT.
179                 // https://bugs.webkit.org/show_bug.cgi?id=166462
180                 executableAddress = m_wasmToWasmExitStubs.at(call.functionIndexSpace).code();
181             } else
182                 executableAddress = m_callees[call.functionIndexSpace - m_moduleInformation-&gt;importFunctionCount()]-&gt;entrypoint();
183             MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(executableAddress));
184         }
185     }
186 }
187 
188 void LLIntPlan::work(CompilationEffort effort)
189 {
190     switch (m_state) {
191     case State::Prepared:
192         compileFunctions(effort);
193         break;
194     case State::Compiled:
195         break;
196     default:
197         break;
198     }
199 }
200 
201 bool LLIntPlan::didReceiveFunctionData(unsigned, const FunctionData&amp;)
202 {
203     // Validation is done inline by the parser
204     return true;
205 }
206 
207 } } // namespace JSC::Wasm
208 
209 #endif // ENABLE(WEBASSEMBLY)
    </pre>
  </body>
</html>
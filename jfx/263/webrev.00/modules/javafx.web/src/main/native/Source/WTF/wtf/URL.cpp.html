<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/URL.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   3  * Copyright (C) 2012 Research In Motion Limited. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &lt;wtf/URL.h&gt;
  29 
  30 #include &quot;URLParser.h&quot;
  31 #include &lt;stdio.h&gt;
  32 #include &lt;unicode/uidna.h&gt;
  33 #include &lt;wtf/HashMap.h&gt;
  34 #include &lt;wtf/NeverDestroyed.h&gt;
  35 #include &lt;wtf/StdLibExtras.h&gt;
  36 #include &lt;wtf/UUID.h&gt;
  37 #include &lt;wtf/text/CString.h&gt;
  38 #include &lt;wtf/text/StringBuilder.h&gt;
  39 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  40 #include &lt;wtf/text/StringHash.h&gt;
  41 #include &lt;wtf/text/TextStream.h&gt;
  42 
  43 namespace WTF {
  44 
  45 typedef Vector&lt;char, 512&gt; CharBuffer;
  46 typedef Vector&lt;UChar, 512&gt; UCharBuffer;
  47 
  48 static constexpr unsigned invalidPortNumber = 0xFFFF;
  49 
  50 // Copies the source to the destination, assuming all the source characters are
  51 // ASCII. The destination buffer must be large enough. Null characters are allowed
  52 // in the source string, and no attempt is made to null-terminate the result.
  53 static void copyASCII(const String&amp; string, char* dest)
  54 {
  55     if (string.isEmpty())
  56         return;
  57 
  58     if (string.is8Bit())
  59         memcpy(dest, string.characters8(), string.length());
  60     else {
  61         const UChar* src = string.characters16();
  62         size_t length = string.length();
  63         for (size_t i = 0; i &lt; length; i++)
  64             dest[i] = static_cast&lt;char&gt;(src[i]);
  65     }
  66 }
  67 
  68 void URL::invalidate()
  69 {
  70     m_isValid = false;
  71     m_protocolIsInHTTPFamily = false;
  72     m_cannotBeABaseURL = false;
  73     m_schemeEnd = 0;
  74     m_userStart = 0;
  75     m_userEnd = 0;
  76     m_passwordEnd = 0;
  77     m_hostEnd = 0;
  78     m_portLength = 0;
  79     m_pathEnd = 0;
  80     m_pathAfterLastSlash = 0;
  81     m_queryEnd = 0;
  82 }
  83 
  84 URL::URL(const URL&amp; base, const String&amp; relative, const URLTextEncoding* encoding)
  85 {
  86     URLParser parser(relative, base, encoding);
  87     *this = parser.result();
  88 }
  89 
  90 static bool shouldTrimFromURL(UChar c)
  91 {
  92     // Browsers ignore leading/trailing whitespace and control
  93     // characters from URLs.  Note that c is an *unsigned* char here
  94     // so this comparison should only catch control characters.
  95     return c &lt;= &#39; &#39;;
  96 }
  97 
  98 URL URL::isolatedCopy() const
  99 {
 100     URL result = *this;
 101     result.m_string = result.m_string.isolatedCopy();
 102     return result;
 103 }
 104 
 105 String URL::lastPathComponent() const
 106 {
 107     if (!hasPath())
 108         return String();
 109 
 110     unsigned end = m_pathEnd - 1;
 111     if (m_string[end] == &#39;/&#39;)
 112         --end;
 113 
 114     size_t start = m_string.reverseFind(&#39;/&#39;, end);
 115     if (start &lt; static_cast&lt;unsigned&gt;(m_hostEnd + m_portLength))
 116         return String();
 117     ++start;
 118 
 119     return m_string.substring(start, end - start + 1);
 120 }
 121 
 122 StringView URL::protocol() const
 123 {
 124     return StringView(m_string).substring(0, m_schemeEnd);
 125 }
 126 
 127 StringView URL::host() const
 128 {
 129     unsigned start = hostStart();
 130     return StringView(m_string).substring(start, m_hostEnd - start);
 131 }
 132 
 133 Optional&lt;uint16_t&gt; URL::port() const
 134 {
 135     if (!m_portLength)
 136         return WTF::nullopt;
 137 
 138     bool ok = false;
 139     unsigned number;
 140     if (m_string.is8Bit())
 141         number = charactersToUIntStrict(m_string.characters8() + m_hostEnd + 1, m_portLength - 1, &amp;ok);
 142     else
 143         number = charactersToUIntStrict(m_string.characters16() + m_hostEnd + 1, m_portLength - 1, &amp;ok);
 144     if (!ok || number &gt; std::numeric_limits&lt;uint16_t&gt;::max())
 145         return WTF::nullopt;
 146     return number;
 147 }
 148 
 149 String URL::hostAndPort() const
 150 {
 151     if (auto port = this-&gt;port())
 152         return makeString(host(), &#39;:&#39;, static_cast&lt;unsigned&gt;(port.value()));
 153     return host().toString();
 154 }
 155 
 156 String URL::protocolHostAndPort() const
 157 {
 158     String result = m_string.substring(0, m_hostEnd + m_portLength);
 159 
 160     if (m_passwordEnd - m_userStart &gt; 0) {
 161         const int allowForTrailingAtSign = 1;
 162         result.remove(m_userStart, m_passwordEnd - m_userStart + allowForTrailingAtSign);
 163     }
 164 
 165     return result;
 166 }
 167 
 168 static String decodeEscapeSequencesFromParsedURL(StringView input)
 169 {
 170     auto inputLength = input.length();
 171     if (!inputLength)
 172         return emptyString();
 173     Vector&lt;LChar&gt; percentDecoded;
 174     percentDecoded.reserveInitialCapacity(inputLength);
 175     for (unsigned i = 0; i &lt; inputLength; ++i) {
 176         if (input[i] == &#39;%&#39;
 177             &amp;&amp; inputLength &gt; 2
 178             &amp;&amp; i &lt; inputLength - 2
 179             &amp;&amp; isASCIIHexDigit(input[i + 1])
 180             &amp;&amp; isASCIIHexDigit(input[i + 2])) {
 181             percentDecoded.uncheckedAppend(toASCIIHexValue(input[i + 1], input[i + 2]));
 182             i += 2;
 183         } else
 184             percentDecoded.uncheckedAppend(input[i]);
 185     }
 186     return String::fromUTF8(percentDecoded.data(), percentDecoded.size());
 187 }
 188 
 189 String URL::user() const
 190 {
 191     return decodeEscapeSequencesFromParsedURL(StringView(m_string).substring(m_userStart, m_userEnd - m_userStart));
 192 }
 193 
 194 String URL::pass() const
 195 {
 196     if (m_passwordEnd == m_userEnd)
 197         return String();
 198 
 199     return decodeEscapeSequencesFromParsedURL(StringView(m_string).substring(m_userEnd + 1, m_passwordEnd - m_userEnd - 1));
 200 }
 201 
 202 String URL::encodedUser() const
 203 {
 204     return m_string.substring(m_userStart, m_userEnd - m_userStart);
 205 }
 206 
 207 String URL::encodedPass() const
 208 {
 209     if (m_passwordEnd == m_userEnd)
 210         return String();
 211 
 212     return m_string.substring(m_userEnd + 1, m_passwordEnd - m_userEnd - 1);
 213 }
 214 
 215 String URL::fragmentIdentifier() const
 216 {
 217     if (!hasFragmentIdentifier())
 218         return String();
 219 
 220     return m_string.substring(m_queryEnd + 1);
 221 }
 222 
 223 bool URL::hasFragmentIdentifier() const
 224 {
 225     return m_isValid &amp;&amp; m_string.length() != m_queryEnd;
 226 }
 227 
 228 String URL::baseAsString() const
 229 {
 230     return m_string.left(m_pathAfterLastSlash);
 231 }
 232 
 233 #if !USE(CF) || PLATFORM(JAVA)
 234 
 235 String URL::fileSystemPath() const
 236 {
 237     if (!isValid() || !isLocalFile())
 238         return String();
 239 
 240     return decodeEscapeSequencesFromParsedURL(StringView(path()));
 241 }
 242 
 243 #endif
 244 
 245 #ifdef NDEBUG
 246 
 247 static inline void assertProtocolIsGood(StringView)
 248 {
 249 }
 250 
 251 #else
 252 
 253 static void assertProtocolIsGood(StringView protocol)
 254 {
 255     // FIXME: We probably don&#39;t need this function any more.
 256     // The isASCIIAlphaCaselessEqual function asserts that passed-in characters
 257     // are ones it can handle; the older code did not and relied on these checks.
 258     for (auto character : protocol.codeUnits()) {
 259         ASSERT(isASCII(character));
 260         ASSERT(character &gt; &#39; &#39;);
 261         ASSERT(!isASCIIUpper(character));
 262         ASSERT(toASCIILowerUnchecked(character) == character);
 263     }
 264 }
 265 
 266 #endif
 267 
 268 static Lock defaultPortForProtocolMapForTestingLock;
 269 
 270 using DefaultPortForProtocolMapForTesting = HashMap&lt;String, uint16_t&gt;;
 271 static DefaultPortForProtocolMapForTesting*&amp; defaultPortForProtocolMapForTesting()
 272 {
 273     static DefaultPortForProtocolMapForTesting* defaultPortForProtocolMap;
 274     return defaultPortForProtocolMap;
 275 }
 276 
 277 static DefaultPortForProtocolMapForTesting&amp; ensureDefaultPortForProtocolMapForTesting()
 278 {
 279     DefaultPortForProtocolMapForTesting*&amp; defaultPortForProtocolMap = defaultPortForProtocolMapForTesting();
 280     if (!defaultPortForProtocolMap)
 281         defaultPortForProtocolMap = new DefaultPortForProtocolMapForTesting;
 282     return *defaultPortForProtocolMap;
 283 }
 284 
 285 void registerDefaultPortForProtocolForTesting(uint16_t port, const String&amp; protocol)
 286 {
 287     auto locker = holdLock(defaultPortForProtocolMapForTestingLock);
 288     ensureDefaultPortForProtocolMapForTesting().add(protocol, port);
 289 }
 290 
 291 void clearDefaultPortForProtocolMapForTesting()
 292 {
 293     auto locker = holdLock(defaultPortForProtocolMapForTestingLock);
 294     if (auto* map = defaultPortForProtocolMapForTesting())
 295         map-&gt;clear();
 296 }
 297 
 298 Optional&lt;uint16_t&gt; defaultPortForProtocol(StringView protocol)
 299 {
 300     if (auto* overrideMap = defaultPortForProtocolMapForTesting()) {
 301         auto locker = holdLock(defaultPortForProtocolMapForTestingLock);
 302         ASSERT(overrideMap); // No need to null check again here since overrideMap cannot become null after being non-null.
 303         auto iterator = overrideMap-&gt;find(protocol.toStringWithoutCopying());
 304         if (iterator != overrideMap-&gt;end())
 305             return iterator-&gt;value;
 306     }
 307     return URLParser::defaultPortForProtocol(protocol);
 308 }
 309 
 310 bool isDefaultPortForProtocol(uint16_t port, StringView protocol)
 311 {
 312     return defaultPortForProtocol(protocol) == port;
 313 }
 314 
 315 bool URL::protocolIs(const char* protocol) const
 316 {
 317     assertProtocolIsGood(StringView { protocol });
 318 
 319     // JavaScript URLs are &quot;valid&quot; and should be executed even if URL decides they are invalid.
 320     // The free function protocolIsJavaScript() should be used instead.
 321     ASSERT(!equalLettersIgnoringASCIICase(StringView(protocol), &quot;javascript&quot;));
 322 
 323     if (!m_isValid)
 324         return false;
 325 
 326     // Do the comparison without making a new string object.
 327     for (unsigned i = 0; i &lt; m_schemeEnd; ++i) {
 328         if (!protocol[i] || !isASCIIAlphaCaselessEqual(m_string[i], protocol[i]))
 329             return false;
 330     }
 331     return !protocol[m_schemeEnd]; // We should have consumed all characters in the argument.
 332 }
 333 
 334 bool URL::protocolIs(StringView protocol) const
 335 {
 336     assertProtocolIsGood(protocol);
 337 
 338     if (!m_isValid)
 339         return false;
 340 
 341     if (m_schemeEnd != protocol.length())
 342         return false;
 343 
 344     // Do the comparison without making a new string object.
 345     for (unsigned i = 0; i &lt; m_schemeEnd; ++i) {
 346         if (!isASCIIAlphaCaselessEqual(m_string[i], protocol[i]))
 347             return false;
 348     }
 349     return true;
 350 }
 351 
 352 String URL::query() const
 353 {
 354     if (m_queryEnd == m_pathEnd)
 355         return String();
 356 
 357     return m_string.substring(m_pathEnd + 1, m_queryEnd - (m_pathEnd + 1));
 358 }
 359 
 360 String URL::path() const
 361 {
 362     unsigned portEnd = m_hostEnd + m_portLength;
 363     return m_string.substring(portEnd, m_pathEnd - portEnd);
 364 }
 365 
 366 bool URL::setProtocol(const String&amp; s)
 367 {
 368     // Firefox and IE remove everything after the first &#39;:&#39;.
 369     size_t separatorPosition = s.find(&#39;:&#39;);
 370     String newProtocol = s.substring(0, separatorPosition);
 371     auto canonicalized = URLParser::maybeCanonicalizeScheme(newProtocol);
 372     if (!canonicalized)
 373         return false;
 374 
 375     if (!m_isValid) {
 376         URLParser parser(makeString(*canonicalized, &quot;:&quot;, m_string));
 377         *this = parser.result();
 378         return true;
 379     }
 380 
 381     if ((m_passwordEnd != m_userStart || port()) &amp;&amp; *canonicalized == &quot;file&quot;)
 382         return true;
 383 
 384     if (isLocalFile() &amp;&amp; host().isEmpty())
 385         return true;
 386 
 387     URLParser parser(makeString(*canonicalized, m_string.substring(m_schemeEnd)));
 388     *this = parser.result();
 389     return true;
 390 }
 391 
 392 static bool isAllASCII(StringView string)
 393 {
 394     if (string.is8Bit())
 395         return charactersAreAllASCII(string.characters8(), string.length());
 396     return charactersAreAllASCII(string.characters16(), string.length());
 397 }
 398 
 399 // Appends the punycoded hostname identified by the given string and length to
 400 // the output buffer. The result will not be null terminated.
 401 // Return value of false means error in encoding.
 402 static bool appendEncodedHostname(UCharBuffer&amp; buffer, StringView string)
 403 {
 404     // Needs to be big enough to hold an IDN-encoded name.
 405     // For host names bigger than this, we won&#39;t do IDN encoding, which is almost certainly OK.
 406     const unsigned hostnameBufferLength = 2048;
 407 
 408     if (string.length() &gt; hostnameBufferLength || isAllASCII(string)) {
 409         append(buffer, string);
 410         return true;
 411     }
 412 
 413     UChar hostnameBuffer[hostnameBufferLength];
 414     UErrorCode error = U_ZERO_ERROR;
 415     UIDNAInfo processingDetails = UIDNA_INFO_INITIALIZER;
 416     int32_t numCharactersConverted = uidna_nameToASCII(&amp;URLParser::internationalDomainNameTranscoder(),
 417         string.upconvertedCharacters(), string.length(), hostnameBuffer, hostnameBufferLength, &amp;processingDetails, &amp;error);
 418 
 419     if (U_SUCCESS(error) &amp;&amp; !processingDetails.errors) {
 420         buffer.append(hostnameBuffer, numCharactersConverted);
 421         return true;
 422     }
 423     return false;
 424 }
 425 
 426 unsigned URL::hostStart() const
 427 {
 428     return (m_passwordEnd == m_userStart) ? m_passwordEnd : m_passwordEnd + 1;
 429 }
 430 
 431 void URL::setHost(const String&amp; s)
 432 {
 433     if (!m_isValid)
 434         return;
 435 
 436     auto colonIndex = s.find(&#39;:&#39;);
 437     if (colonIndex != notFound)
 438         return;
 439 
 440     UCharBuffer encodedHostName;
 441     if (!appendEncodedHostname(encodedHostName, s))
 442         return;
 443 
 444     bool slashSlashNeeded = m_userStart == static_cast&lt;unsigned&gt;(m_schemeEnd + 1);
 445 
 446     StringBuilder builder;
 447     builder.append(m_string.left(hostStart()));
 448     if (slashSlashNeeded)
 449         builder.appendLiteral(&quot;//&quot;);
 450     builder.append(StringView(encodedHostName.data(), encodedHostName.size()));
 451     builder.append(m_string.substring(m_hostEnd));
 452 
 453     URLParser parser(builder.toString());
 454     *this = parser.result();
 455 }
 456 
 457 void URL::removePort()
 458 {
 459     if (!m_portLength)
 460         return;
 461     URLParser parser(makeString(StringView(m_string).left(m_hostEnd), StringView(m_string).substring(m_hostEnd + m_portLength)));
 462     *this = parser.result();
 463 }
 464 
 465 void URL::setPort(unsigned short i)
 466 {
 467     if (!m_isValid)
 468         return;
 469 
 470     bool colonNeeded = !m_portLength;
 471     unsigned portStart = (colonNeeded ? m_hostEnd : m_hostEnd + 1);
 472 
 473     URLParser parser(makeString(StringView(m_string).left(portStart), (colonNeeded ? &quot;:&quot; : &quot;&quot;), static_cast&lt;unsigned&gt;(i), StringView(m_string).substring(m_hostEnd + m_portLength)));
 474     *this = parser.result();
 475 }
 476 
 477 void URL::removeHostAndPort()
 478 {
 479     if (!m_isValid)
 480         return;
 481     if (!host().isEmpty())
 482         setHost({ });
 483     removePort();
 484 }
 485 
 486 void URL::setHostAndPort(const String&amp; hostAndPort)
 487 {
 488     if (!m_isValid)
 489         return;
 490 
 491     StringView hostName(hostAndPort);
 492     StringView port;
 493 
 494     auto colonIndex = hostName.find(&#39;:&#39;);
 495     if (colonIndex != notFound) {
 496         port = hostName.substring(colonIndex + 1);
 497         bool ok;
 498         int portInt = port.toIntStrict(ok);
 499         if (!ok || portInt &lt; 0)
 500             return;
 501         hostName = hostName.substring(0, colonIndex);
 502     }
 503 
 504     if (hostName.isEmpty())
 505         return;
 506 
 507     UCharBuffer encodedHostName;
 508     if (!appendEncodedHostname(encodedHostName, hostName))
 509         return;
 510 
 511     bool slashSlashNeeded = m_userStart == static_cast&lt;unsigned&gt;(m_schemeEnd + 1);
 512 
 513     StringBuilder builder;
 514     builder.append(m_string.left(hostStart()));
 515     if (slashSlashNeeded)
 516         builder.appendLiteral(&quot;//&quot;);
 517     builder.append(StringView(encodedHostName.data(), encodedHostName.size()));
 518     if (!port.isEmpty()) {
 519         builder.appendLiteral(&quot;:&quot;);
 520         builder.append(port);
 521     }
 522     builder.append(StringView(m_string).substring(m_hostEnd + m_portLength));
 523 
 524     URLParser parser(builder.toString());
 525     *this = parser.result();
 526 }
 527 
 528 static String percentEncodeCharacters(const String&amp; input, bool(*shouldEncode)(UChar))
 529 {
 530     auto encode = [shouldEncode] (const String&amp; input) {
 531         CString utf8 = input.utf8();
 532         auto* data = utf8.data();
 533         StringBuilder builder;
 534         auto length = utf8.length();
 535         for (unsigned j = 0; j &lt; length; j++) {
 536             auto c = data[j];
 537             if (shouldEncode(c)) {
 538                 builder.append(&#39;%&#39;);
 539                 builder.append(upperNibbleToASCIIHexDigit(c));
 540                 builder.append(lowerNibbleToASCIIHexDigit(c));
 541             } else
 542                 builder.append(c);
 543         }
 544         return builder.toString();
 545     };
 546 
 547     for (size_t i = 0; i &lt; input.length(); ++i) {
 548         if (UNLIKELY(shouldEncode(input[i])))
 549             return encode(input);
 550     }
 551     return input;
 552 }
 553 
 554 void URL::setUser(const String&amp; user)
 555 {
 556     if (!m_isValid)
 557         return;
 558 
 559     // FIXME: Non-ASCII characters must be encoded and escaped to match parse() expectations,
 560     // and to avoid changing more than just the user login.
 561 
 562     unsigned end = m_userEnd;
 563     if (!user.isEmpty()) {
 564         String u = percentEncodeCharacters(user, URLParser::isInUserInfoEncodeSet);
 565         if (m_userStart == static_cast&lt;unsigned&gt;(m_schemeEnd + 1))
 566             u = &quot;//&quot; + u;
 567         // Add &#39;@&#39; if we didn&#39;t have one before.
 568         if (end == m_hostEnd || (end == m_passwordEnd &amp;&amp; m_string[end] != &#39;@&#39;))
 569             u.append(&#39;@&#39;);
 570         URLParser parser(makeString(StringView(m_string).left(m_userStart), u, StringView(m_string).substring(end)));
 571         *this = parser.result();
 572     } else {
 573         // Remove &#39;@&#39; if we now have neither user nor password.
 574         if (m_userEnd == m_passwordEnd &amp;&amp; end != m_hostEnd &amp;&amp; m_string[end] == &#39;@&#39;)
 575             end += 1;
 576         // We don&#39;t want to parse in the extremely common case where we are not going to make a change.
 577         if (m_userStart != end) {
 578             URLParser parser(makeString(StringView(m_string).left(m_userStart), StringView(m_string).substring(end)));
 579             *this = parser.result();
 580         }
 581     }
 582 }
 583 
 584 void URL::setPass(const String&amp; password)
 585 {
 586     if (!m_isValid)
 587         return;
 588 
 589     unsigned end = m_passwordEnd;
 590     if (!password.isEmpty()) {
 591         String p = &quot;:&quot; + percentEncodeCharacters(password, URLParser::isInUserInfoEncodeSet) + &quot;@&quot;;
 592         if (m_userEnd == static_cast&lt;unsigned&gt;(m_schemeEnd + 1))
 593             p = &quot;//&quot; + p;
 594         // Eat the existing &#39;@&#39; since we are going to add our own.
 595         if (end != m_hostEnd &amp;&amp; m_string[end] == &#39;@&#39;)
 596             end += 1;
 597         URLParser parser(makeString(StringView(m_string).left(m_userEnd), p, StringView(m_string).substring(end)));
 598         *this = parser.result();
 599     } else {
 600         // Remove &#39;@&#39; if we now have neither user nor password.
 601         if (m_userStart == m_userEnd &amp;&amp; end != m_hostEnd &amp;&amp; m_string[end] == &#39;@&#39;)
 602             end += 1;
 603         // We don&#39;t want to parse in the extremely common case where we are not going to make a change.
 604         if (m_userEnd != end) {
 605             URLParser parser(makeString(StringView(m_string).left(m_userEnd), StringView(m_string).substring(end)));
 606             *this = parser.result();
 607         }
 608     }
 609 }
 610 
 611 void URL::setFragmentIdentifier(StringView identifier)
 612 {
 613     if (!m_isValid)
 614         return;
 615 
 616     // FIXME: Optimize the case where the identifier already happens to be equal to what was passed?
 617     // FIXME: Is it correct to do this without encoding and escaping non-ASCII characters?
 618     *this = URLParser { makeString(StringView { m_string }.substring(0, m_queryEnd), &#39;#&#39;, identifier) }.result();
 619 }
 620 
 621 void URL::removeFragmentIdentifier()
 622 {
 623     if (!m_isValid) {
 624         ASSERT(!m_queryEnd);
 625         return;
 626     }
 627     if (m_isValid &amp;&amp; m_string.length() &gt; m_queryEnd)
 628         m_string = m_string.left(m_queryEnd);
 629 }
 630 
 631 void URL::removeQueryAndFragmentIdentifier()
 632 {
 633     if (!m_isValid)
 634         return;
 635 
 636     m_string = m_string.left(m_pathEnd);
 637     m_queryEnd = m_pathEnd;
 638 }
 639 
 640 void URL::setQuery(const String&amp; query)
 641 {
 642     if (!m_isValid)
 643         return;
 644 
 645     // FIXME: &#39;#&#39; and non-ASCII characters must be encoded and escaped.
 646     // Usually, the query is encoded using document encoding, not UTF-8, but we don&#39;t have
 647     // access to the document in this function.
 648     // https://webkit.org/b/161176
 649     if ((query.isEmpty() || query[0] != &#39;?&#39;) &amp;&amp; !query.isNull()) {
 650         URLParser parser(makeString(StringView(m_string).left(m_pathEnd), &quot;?&quot;, query, StringView(m_string).substring(m_queryEnd)));
 651         *this = parser.result();
 652     } else {
 653         URLParser parser(makeString(StringView(m_string).left(m_pathEnd), query, StringView(m_string).substring(m_queryEnd)));
 654         *this = parser.result();
 655     }
 656 
 657 }
 658 
 659 void URL::setPath(const String&amp; s)
 660 {
 661     if (!m_isValid)
 662         return;
 663 
 664     String path = s;
 665     if (path.isEmpty() || path[0] != &#39;/&#39;)
 666         path = &quot;/&quot; + path;
 667 
 668     auto questionMarkOrNumberSign = [] (UChar character) {
 669         return character == &#39;?&#39; || character == &#39;#&#39;;
 670     };
 671     URLParser parser(makeString(StringView(m_string).left(m_hostEnd + m_portLength), percentEncodeCharacters(path, questionMarkOrNumberSign), StringView(m_string).substring(m_pathEnd)));
 672     *this = parser.result();
 673 }
 674 
 675 bool equalIgnoringFragmentIdentifier(const URL&amp; a, const URL&amp; b)
 676 {
 677     if (a.m_queryEnd != b.m_queryEnd)
 678         return false;
 679     unsigned queryLength = a.m_queryEnd;
 680     for (unsigned i = 0; i &lt; queryLength; ++i)
 681         if (a.string()[i] != b.string()[i])
 682             return false;
 683     return true;
 684 }
 685 
 686 bool equalIgnoringQueryAndFragment(const URL&amp; a, const URL&amp; b)
 687 {
 688     if (a.pathEnd() != b.pathEnd())
 689         return false;
 690     unsigned pathEnd = a.pathEnd();
 691     for (unsigned i = 0; i &lt; pathEnd; ++i) {
 692         if (a.string()[i] != b.string()[i])
 693             return false;
 694     }
 695     return true;
 696 }
 697 
 698 bool protocolHostAndPortAreEqual(const URL&amp; a, const URL&amp; b)
 699 {
 700     if (a.m_schemeEnd != b.m_schemeEnd)
 701         return false;
 702 
 703     unsigned hostStartA = a.hostStart();
 704     unsigned hostLengthA = a.m_hostEnd - hostStartA;
 705     unsigned hostStartB = b.hostStart();
 706     unsigned hostLengthB = b.m_hostEnd - b.hostStart();
 707     if (hostLengthA != hostLengthB)
 708         return false;
 709 
 710     // Check the scheme
 711     for (unsigned i = 0; i &lt; a.m_schemeEnd; ++i) {
 712         if (a.string()[i] != b.string()[i])
 713             return false;
 714     }
 715 
 716     // And the host
 717     for (unsigned i = 0; i &lt; hostLengthA; ++i) {
 718         if (a.string()[hostStartA + i] != b.string()[hostStartB + i])
 719             return false;
 720     }
 721 
 722     if (a.port() != b.port())
 723         return false;
 724 
 725     return true;
 726 }
 727 
 728 bool hostsAreEqual(const URL&amp; a, const URL&amp; b)
 729 {
 730     unsigned hostStartA = a.hostStart();
 731     unsigned hostLengthA = a.m_hostEnd - hostStartA;
 732     unsigned hostStartB = b.hostStart();
 733     unsigned hostLengthB = b.m_hostEnd - hostStartB;
 734     if (hostLengthA != hostLengthB)
 735         return false;
 736 
 737     for (unsigned i = 0; i &lt; hostLengthA; ++i) {
 738         if (a.string()[hostStartA + i] != b.string()[hostStartB + i])
 739             return false;
 740     }
 741 
 742     return true;
 743 }
 744 
 745 bool URL::isMatchingDomain(const String&amp; domain) const
 746 {
 747     if (isNull())
 748         return false;
 749 
 750     if (domain.isEmpty())
 751         return true;
 752 
 753     if (!protocolIsInHTTPFamily())
 754         return false;
 755 
 756     auto host = this-&gt;host();
 757     if (!host.endsWith(domain))
 758         return false;
 759 
 760     return host.length() == domain.length() || host[host.length() - domain.length() - 1] == &#39;.&#39;;
 761 }
 762 
 763 String encodeWithURLEscapeSequences(const String&amp; input)
 764 {
 765     return percentEncodeCharacters(input, URLParser::isInUserInfoEncodeSet);
 766 }
 767 
 768 bool URL::isHierarchical() const
 769 {
 770     if (!m_isValid)
 771         return false;
 772     ASSERT(m_string[m_schemeEnd] == &#39;:&#39;);
 773     return m_string[m_schemeEnd + 1] == &#39;/&#39;;
 774 }
 775 
 776 void URL::copyToBuffer(Vector&lt;char, 512&gt;&amp; buffer) const
 777 {
 778     // FIXME: This throws away the high bytes of all the characters in the string!
 779     // That&#39;s fine for a valid URL, which is all ASCII, but not for invalid URLs.
 780     buffer.resize(m_string.length());
 781     copyASCII(m_string, buffer.data());
 782 }
 783 
 784 template&lt;typename StringClass&gt;
 785 bool protocolIsInternal(const StringClass&amp; url, const char* protocol)
 786 {
 787     // Do the comparison without making a new string object.
 788     assertProtocolIsGood(StringView { protocol });
 789     bool isLeading = true;
 790     for (unsigned i = 0, j = 0; url[i]; ++i) {
 791         // Skip leading whitespace and control characters.
 792         if (isLeading &amp;&amp; shouldTrimFromURL(url[i]))
 793             continue;
 794         isLeading = false;
 795 
 796         // Skip any tabs and newlines.
 797         if (url[i] == &#39;\t&#39; || url[i] == &#39;\r&#39; || url[i] == &#39;\n&#39;)
 798             continue;
 799 
 800         if (!protocol[j])
 801             return url[i] == &#39;:&#39;;
 802         if (!isASCIIAlphaCaselessEqual(url[i], protocol[j]))
 803             return false;
 804 
 805         ++j;
 806     }
 807 
 808     return false;
 809 }
 810 
 811 bool protocolIs(const String&amp; url, const char* protocol)
 812 {
 813     return protocolIsInternal(url, protocol);
 814 }
 815 
 816 inline bool URL::protocolIs(const String&amp; string, const char* protocol)
 817 {
 818     return WTF::protocolIsInternal(string, protocol);
 819 }
 820 
 821 #ifndef NDEBUG
 822 
 823 void URL::print() const
 824 {
 825     printf(&quot;%s\n&quot;, m_string.utf8().data());
 826 }
 827 
 828 #endif
 829 
 830 String URL::strippedForUseAsReferrer() const
 831 {
 832     URL referrer(*this);
 833     referrer.setUser(String());
 834     referrer.setPass(String());
 835     referrer.removeFragmentIdentifier();
 836     return referrer.string();
 837 }
 838 
 839 bool URL::isLocalFile() const
 840 {
 841     // Including feed here might be a bad idea since drag and drop uses this check
 842     // and including feed would allow feeds to potentially let someone&#39;s blog
 843     // read the contents of the clipboard on a drag, even without a drop.
 844     // Likewise with using the FrameLoader::shouldTreatURLAsLocal() function.
 845     return protocolIs(&quot;file&quot;);
 846 }
 847 
 848 bool protocolIsJavaScript(const String&amp; url)
 849 {
 850     return protocolIsInternal(url, &quot;javascript&quot;);
 851 }
 852 
 853 bool protocolIsJavaScript(StringView url)
 854 {
 855     return protocolIsInternal(url, &quot;javascript&quot;);
 856 }
 857 
 858 bool protocolIsInHTTPFamily(const String&amp; url)
 859 {
 860     auto length = url.length();
 861     // Do the comparison without making a new string object.
 862     return length &gt;= 5
 863         &amp;&amp; isASCIIAlphaCaselessEqual(url[0], &#39;h&#39;)
 864         &amp;&amp; isASCIIAlphaCaselessEqual(url[1], &#39;t&#39;)
 865         &amp;&amp; isASCIIAlphaCaselessEqual(url[2], &#39;t&#39;)
 866         &amp;&amp; isASCIIAlphaCaselessEqual(url[3], &#39;p&#39;)
 867         &amp;&amp; (url[4] == &#39;:&#39; || (isASCIIAlphaCaselessEqual(url[4], &#39;s&#39;) &amp;&amp; length &gt;= 6 &amp;&amp; url[5] == &#39;:&#39;));
 868 }
 869 
 870 const URL&amp; blankURL()
 871 {
 872     static NeverDestroyed&lt;URL&gt; staticBlankURL(URL(), &quot;about:blank&quot;);
 873     return staticBlankURL;
 874 }
 875 
 876 bool URL::protocolIsAbout() const
 877 {
 878     return protocolIs(&quot;about&quot;);
 879 }
 880 
 881 bool portAllowed(const URL&amp; url)
 882 {
 883     Optional&lt;uint16_t&gt; port = url.port();
 884 
 885     // Since most URLs don&#39;t have a port, return early for the &quot;no port&quot; case.
 886     if (!port)
 887         return true;
 888 
 889     // This blocked port list matches the port blocking that Mozilla implements.
 890     // See http://www.mozilla.org/projects/netlib/PortBanning.html for more information.
 891     static const uint16_t blockedPortList[] = {
 892         1,    // tcpmux
 893         7,    // echo
 894         9,    // discard
 895         11,   // systat
 896         13,   // daytime
 897         15,   // netstat
 898         17,   // qotd
 899         19,   // chargen
 900         20,   // FTP-data
 901         21,   // FTP-control
 902         22,   // SSH
 903         23,   // telnet
 904         25,   // SMTP
 905         37,   // time
 906         42,   // name
 907         43,   // nicname
 908         53,   // domain
 909         77,   // priv-rjs
 910         79,   // finger
 911         87,   // ttylink
 912         95,   // supdup
 913         101,  // hostriame
 914         102,  // iso-tsap
 915         103,  // gppitnp
 916         104,  // acr-nema
 917         109,  // POP2
 918         110,  // POP3
 919         111,  // sunrpc
 920         113,  // auth
 921         115,  // SFTP
 922         117,  // uucp-path
 923         119,  // nntp
 924         123,  // NTP
 925         135,  // loc-srv / epmap
 926         139,  // netbios
 927         143,  // IMAP2
 928         179,  // BGP
 929         389,  // LDAP
 930         427,  // SLP (Also used by Apple Filing Protocol)
 931         465,  // SMTP+SSL
 932         512,  // print / exec
 933         513,  // login
 934         514,  // shell
 935         515,  // printer
 936         526,  // tempo
 937         530,  // courier
 938         531,  // Chat
 939         532,  // netnews
 940         540,  // UUCP
 941         548,  // afpovertcp [Apple addition]
 942         556,  // remotefs
 943         563,  // NNTP+SSL
 944         587,  // ESMTP
 945         601,  // syslog-conn
 946         636,  // LDAP+SSL
 947         993,  // IMAP+SSL
 948         995,  // POP3+SSL
 949         2049, // NFS
 950         3659, // apple-sasl / PasswordServer [Apple addition]
 951         4045, // lockd
 952         4190, // ManageSieve [Apple addition]
 953         6000, // X11
 954         6665, // Alternate IRC [Apple addition]
 955         6666, // Alternate IRC [Apple addition]
 956         6667, // Standard IRC [Apple addition]
 957         6668, // Alternate IRC [Apple addition]
 958         6669, // Alternate IRC [Apple addition]
 959         6679, // Alternate IRC SSL [Apple addition]
 960         6697, // IRC+SSL [Apple addition]
 961         invalidPortNumber, // Used to block all invalid port numbers
 962     };
 963 
 964     // If the port is not in the blocked port list, allow it.
 965     ASSERT(std::is_sorted(std::begin(blockedPortList), std::end(blockedPortList)));
 966     if (!std::binary_search(std::begin(blockedPortList), std::end(blockedPortList), port.value()))
 967         return true;
 968 
 969     // Allow ports 21 and 22 for FTP URLs, as Mozilla does.
 970     if ((port.value() == 21 || port.value() == 22) &amp;&amp; url.protocolIs(&quot;ftp&quot;))
 971         return true;
 972 
 973     // Allow any port number in a file URL, since the port number is ignored.
 974     if (url.protocolIs(&quot;file&quot;))
 975         return true;
 976 
 977     return false;
 978 }
 979 
 980 String mimeTypeFromDataURL(const String&amp; url)
 981 {
 982     ASSERT(protocolIsInternal(url, &quot;data&quot;));
 983 
 984     // FIXME: What&#39;s the right behavior when the URL has a comma first, but a semicolon later?
 985     // Currently this code will break at the semicolon in that case. Not sure that&#39;s correct.
 986     auto index = url.find(&#39;;&#39;, 5);
 987     if (index == notFound)
 988         index = url.find(&#39;,&#39;, 5);
 989     if (index == notFound) {
 990         // FIXME: There was an old comment here that made it sound like this should be returning text/plain.
 991         // But we have been returning empty string here for some time, so not changing its behavior at this time.
 992         return emptyString();
 993     }
 994     if (index == 5)
 995         return &quot;text/plain&quot;_s;
 996     ASSERT(index &gt;= 5);
 997     return url.substring(5, index - 5).convertToASCIILowercase();
 998 }
 999 
1000 String URL::stringCenterEllipsizedToLength(unsigned length) const
1001 {
1002     if (string().length() &lt;= length)
1003         return string();
1004 
1005     return string().left(length / 2 - 1) + &quot;...&quot; + string().right(length / 2 - 2);
1006 }
1007 
1008 URL URL::fakeURLWithRelativePart(const String&amp; relativePart)
1009 {
1010     return URL(URL(), &quot;webkit-fake-url://&quot; + createCanonicalUUIDString() + &#39;/&#39; + relativePart);
1011 }
1012 
1013 URL URL::fileURLWithFileSystemPath(const String&amp; filePath)
1014 {
1015     return URL(URL(), &quot;file:///&quot; + filePath);
1016 }
1017 
1018 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const URL&amp; url)
1019 {
1020     ts &lt;&lt; url.string();
1021     return ts;
1022 }
1023 
1024 #if !PLATFORM(COCOA) &amp;&amp; !USE(SOUP)
1025 static bool isIPv4Address(StringView string)
1026 {
1027     auto count = 0;
1028 
1029     for (const auto octet : string.splitAllowingEmptyEntries(&#39;.&#39;)) {
1030         if (count &gt;= 4)
1031             return false;
1032 
1033         const auto length = octet.length();
1034         if (!length || length &gt; 3)
1035             return false;
1036 
1037         auto value = 0;
1038         for (auto i = 0u; i &lt; length; ++i) {
1039             const auto digit = octet[i];
1040 
1041             // Prohibit leading zeroes.
1042             if (digit &gt; &#39;9&#39; || digit &lt; (!i &amp;&amp; length &gt; 1 ? &#39;1&#39; : &#39;0&#39;))
1043                 return false;
1044 
1045             value = 10 * value + (digit - &#39;0&#39;);
1046         }
1047 
1048         if (value &gt; 255)
1049             return false;
1050 
1051         count++;
1052     }
1053 
1054     return (count == 4);
1055 }
1056 
1057 static bool isIPv6Address(StringView string)
1058 {
1059     enum SkipState { None, WillSkip, Skipping, Skipped, Final };
1060     auto skipState = None;
1061     auto count = 0;
1062 
1063     for (const auto hextet : string.splitAllowingEmptyEntries(&#39;:&#39;)) {
1064         if (count &gt;= 8 || skipState == Final)
1065             return false;
1066 
1067         const auto length = hextet.length();
1068         if (!length) {
1069             // :: may be used anywhere to skip 1 to 8 hextets, but only once.
1070             if (skipState == Skipped)
1071                 return false;
1072 
1073             if (skipState == None)
1074                 skipState = !count ? WillSkip : Skipping;
1075             else if (skipState == WillSkip)
1076                 skipState = Skipping;
1077             else
1078                 skipState = Final;
1079             continue;
1080         }
1081 
1082         if (skipState == WillSkip)
1083             return false;
1084 
1085         if (skipState == Skipping)
1086             skipState = Skipped;
1087 
1088         if (length &gt; 4) {
1089             // An IPv4 address may be used in place of the final two hextets.
1090             if ((skipState == None &amp;&amp; count != 6) || (skipState == Skipped &amp;&amp; count &gt;= 6) || !isIPv4Address(hextet))
1091                 return false;
1092 
1093             skipState = Final;
1094             continue;
1095         }
1096 
1097         for (const auto codeUnit : hextet.codeUnits()) {
1098             // IPv6 allows leading zeroes.
1099             if (!isASCIIHexDigit(codeUnit))
1100                 return false;
1101         }
1102 
1103         count++;
1104     }
1105 
1106     return (count == 8 &amp;&amp; skipState == None) || skipState == Skipped || skipState == Final;
1107 }
1108 
1109 bool URL::hostIsIPAddress(StringView host)
1110 {
1111     if (host.find(&#39;:&#39;) == notFound)
1112         return isIPv4Address(host);
1113 
1114     return isIPv6Address(host);
1115 }
1116 #endif
1117 
1118 } // namespace WTF
    </pre>
  </body>
</html>
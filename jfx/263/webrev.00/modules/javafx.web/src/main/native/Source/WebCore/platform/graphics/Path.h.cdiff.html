<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Path.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PathTraversalState.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 48,10 ***</span>
<span class="line-new-header">--- 48,14 ---</span>
  interface ID2D1PathGeometry;
  interface ID2D1GeometrySink;
  
  typedef ID2D1GeometryGroup PlatformPath;
  
<span class="line-added">+ namespace WebCore {</span>
<span class="line-added">+ class PlatformContextDirect2D;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #elif USE(CAIRO)
  
  namespace WebCore {
  class CairoPath;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,151 ***</span>
  class TextStream;
  }
  
  namespace WebCore {
  
<span class="line-modified">!     class AffineTransform;</span>
<span class="line-modified">!     class FloatPoint;</span>
<span class="line-modified">!     class FloatRoundedRect;</span>
<span class="line-modified">!     class FloatSize;</span>
<span class="line-modified">!     class GraphicsContext;</span>
<span class="line-modified">!     class PathTraversalState;</span>
<span class="line-modified">!     class RoundedRect;</span>
<span class="line-modified">!     class StrokeStyleApplier;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     enum PathElementType {</span>
<span class="line-modified">!         PathElementMoveToPoint, // The points member will contain 1 value.</span>
<span class="line-modified">!         PathElementAddLineToPoint, // The points member will contain 1 value.</span>
<span class="line-modified">!         PathElementAddQuadCurveToPoint, // The points member will contain 2 values.</span>
<span class="line-modified">!         PathElementAddCurveToPoint, // The points member will contain 3 values.</span>
<span class="line-modified">!         PathElementCloseSubpath // The points member will contain no values.</span>
      };
  
<span class="line-modified">!     // The points in the structure are the same as those that would be used with the</span>
<span class="line-modified">!     // add... method. For example, a line returns the endpoint, while a cubic returns</span>
<span class="line-modified">!     // two tangent points and the endpoint.</span>
<span class="line-removed">-     struct PathElement {</span>
<span class="line-removed">-         PathElementType type;</span>
<span class="line-removed">-         FloatPoint* points;</span>
<span class="line-removed">-     };</span>
  
<span class="line-modified">!     using PathApplierFunction = WTF::Function&lt;void (const PathElement&amp;)&gt;;</span>
  
<span class="line-modified">!     class Path {</span>
<span class="line-modified">!         WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-modified">!     public:</span>
<span class="line-modified">!         WEBCORE_EXPORT Path();</span>
  #if USE(CG)
<span class="line-modified">!         Path(RetainPtr&lt;CGMutablePathRef&gt;);</span>
  #endif
<span class="line-modified">!         WEBCORE_EXPORT ~Path();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         WEBCORE_EXPORT Path(const Path&amp;);</span>
<span class="line-modified">!         WEBCORE_EXPORT Path(Path&amp;&amp;);</span>
<span class="line-modified">!         WEBCORE_EXPORT Path&amp; operator=(const Path&amp;);</span>
<span class="line-modified">!         WEBCORE_EXPORT Path&amp; operator=(Path&amp;&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         static Path polygonPathFromPoints(const Vector&lt;FloatPoint&gt;&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         bool contains(const FloatPoint&amp;, WindRule = WindRule::NonZero) const;</span>
<span class="line-modified">!         bool strokeContains(StrokeStyleApplier*, const FloatPoint&amp;) const;</span>
<span class="line-modified">!         // fastBoundingRect() should equal or contain boundingRect(); boundingRect()</span>
<span class="line-modified">!         // should perfectly bound the points within the path.</span>
<span class="line-modified">!         FloatRect boundingRect() const;</span>
<span class="line-modified">!         WEBCORE_EXPORT FloatRect fastBoundingRect() const;</span>
<span class="line-modified">!         FloatRect strokeBoundingRect(StrokeStyleApplier* = 0) const;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         float length() const;</span>
<span class="line-modified">!         PathTraversalState traversalStateAtLength(float length, bool&amp; success) const;</span>
<span class="line-modified">!         FloatPoint pointAtLength(float length, bool&amp; success) const;</span>
<span class="line-modified">!         float normalAngleAtLength(float length, bool&amp; success) const;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         WEBCORE_EXPORT void clear();</span>
<span class="line-modified">!         bool isNull() const { return !m_path; }</span>
<span class="line-modified">!         bool isEmpty() const;</span>
<span class="line-modified">!         // Gets the current point of the current path, which is conceptually the final point reached by the path so far.</span>
<span class="line-modified">!         // Note the Path can be empty (isEmpty() == true) and still have a current point.</span>
<span class="line-modified">!         bool hasCurrentPoint() const;</span>
<span class="line-modified">!         FloatPoint currentPoint() const;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         WEBCORE_EXPORT void moveTo(const FloatPoint&amp;);</span>
<span class="line-modified">!         WEBCORE_EXPORT void addLineTo(const FloatPoint&amp;);</span>
<span class="line-modified">!         WEBCORE_EXPORT void addQuadCurveTo(const FloatPoint&amp; controlPoint, const FloatPoint&amp; endPoint);</span>
<span class="line-modified">!         WEBCORE_EXPORT void addBezierCurveTo(const FloatPoint&amp; controlPoint1, const FloatPoint&amp; controlPoint2, const FloatPoint&amp; endPoint);</span>
<span class="line-modified">!         void addArcTo(const FloatPoint&amp;, const FloatPoint&amp;, float radius);</span>
<span class="line-modified">!         WEBCORE_EXPORT void closeSubpath();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         void addArc(const FloatPoint&amp;, float radius, float startAngle, float endAngle, bool anticlockwise);</span>
<span class="line-modified">!         void addRect(const FloatRect&amp;);</span>
<span class="line-modified">!         void addEllipse(FloatPoint, float radiusX, float radiusY, float rotation, float startAngle, float endAngle, bool anticlockwise);</span>
<span class="line-modified">!         void addEllipse(const FloatRect&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         enum RoundedRectStrategy {</span>
<span class="line-modified">!             PreferNativeRoundedRect,</span>
<span class="line-modified">!             PreferBezierRoundedRect</span>
<span class="line-modified">!         };</span>
<span class="line-modified">! </span>
<span class="line-modified">!         WEBCORE_EXPORT void addRoundedRect(const FloatRect&amp;, const FloatSize&amp; roundingRadii, RoundedRectStrategy = PreferNativeRoundedRect);</span>
<span class="line-modified">!         WEBCORE_EXPORT void addRoundedRect(const FloatRoundedRect&amp;, RoundedRectStrategy = PreferNativeRoundedRect);</span>
<span class="line-modified">!         void addRoundedRect(const RoundedRect&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         void addPath(const Path&amp;, const AffineTransform&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         void translate(const FloatSize&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // To keep Path() cheap, it does not allocate a PlatformPath immediately</span>
<span class="line-removed">-         // meaning Path::platformPath() can return null.</span>
  #if USE(DIRECT2D)
<span class="line-modified">!         PlatformPathPtr platformPath() const { return m_path.get(); }</span>
  #else
<span class="line-modified">!         PlatformPathPtr platformPath() const { return m_path; }</span>
  #endif
<span class="line-modified">!         // ensurePlatformPath() will allocate a PlatformPath if it has not yet been and will never return null.</span>
<span class="line-modified">!         WEBCORE_EXPORT PlatformPathPtr ensurePlatformPath();</span>
  
<span class="line-modified">!         WEBCORE_EXPORT void apply(const PathApplierFunction&amp;) const;</span>
<span class="line-modified">!         void transform(const AffineTransform&amp;);</span>
  
<span class="line-modified">!         static float circleControlPoint()</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             // Approximation of control point positions on a bezier to simulate a quarter of a circle.</span>
<span class="line-modified">!             // This is 1-kappa, where kappa = 4 * (sqrt(2) - 1) / 3</span>
<span class="line-modified">!             return 0.447715;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         void addBeziersForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);</span>
  
  #if USE(CG) || USE(DIRECT2D)
<span class="line-modified">!         void platformAddPathForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);</span>
  #endif
  
  #if USE(DIRECT2D)
<span class="line-modified">!         ID2D1GeometrySink* activePath() const { return m_activePath.get(); }</span>
<span class="line-modified">!         void appendGeometry(ID2D1Geometry*);</span>
<span class="line-modified">!         void createGeometryWithFillMode(WindRule, COMPtr&lt;ID2D1GeometryGroup&gt;&amp;) const;</span>
<span class="line-modified">!         void drawDidComplete();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         HRESULT initializePathState();</span>
<span class="line-removed">-         void openFigureAtCurrentPointIfNecessary();</span>
<span class="line-removed">-         void closeAnyOpenGeometries();</span>
  #endif
  
  #ifndef NDEBUG
<span class="line-modified">!         void dump() const;</span>
  #endif
  
<span class="line-modified">!     private:</span>
  #if USE(DIRECT2D)
<span class="line-modified">!         COMPtr&lt;ID2D1GeometryGroup&gt; m_path;</span>
<span class="line-modified">!         COMPtr&lt;ID2D1PathGeometry&gt; m_activePathGeometry;</span>
<span class="line-modified">!         COMPtr&lt;ID2D1GeometrySink&gt; m_activePath;</span>
<span class="line-modified">!         size_t m_openFigureCount { 0 };</span>
  #else
<span class="line-modified">!         PlatformPathPtr m_path { nullptr };</span>
  #endif
<span class="line-modified">!     };</span>
  
  WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Path&amp;);
  
  }
  
  #endif
<span class="line-new-header">--- 89,252 ---</span>
  class TextStream;
  }
  
  namespace WebCore {
  
<span class="line-modified">! class AffineTransform;</span>
<span class="line-modified">! class FloatPoint;</span>
<span class="line-modified">! class FloatRoundedRect;</span>
<span class="line-modified">! class FloatSize;</span>
<span class="line-modified">! class GraphicsContext;</span>
<span class="line-modified">! class PathTraversalState;</span>
<span class="line-modified">! class RoundedRect;</span>
<span class="line-modified">! class StrokeStyleApplier;</span>
<span class="line-modified">! </span>
<span class="line-modified">! // The points in the structure are the same as those that would be used with the</span>
<span class="line-modified">! // add... method. For example, a line returns the endpoint, while a cubic returns</span>
<span class="line-modified">! // two tangent points and the endpoint.</span>
<span class="line-modified">! struct PathElement {</span>
<span class="line-modified">!     enum class Type : uint8_t {</span>
<span class="line-modified">!         MoveToPoint, // The points member will contain 1 value.</span>
<span class="line-added">+         AddLineToPoint, // The points member will contain 1 value.</span>
<span class="line-added">+         AddQuadCurveToPoint, // The points member will contain 2 values.</span>
<span class="line-added">+         AddCurveToPoint, // The points member will contain 3 values.</span>
<span class="line-added">+         CloseSubpath // The points member will contain no values.</span>
      };
  
<span class="line-modified">!     FloatPoint points[3];</span>
<span class="line-modified">!     Type type;</span>
<span class="line-modified">! };</span>
  
<span class="line-modified">! using PathApplierFunction = WTF::Function&lt;void(const PathElement&amp;)&gt;;</span>
  
<span class="line-modified">! class Path {</span>
<span class="line-modified">!     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-modified">! public:</span>
<span class="line-modified">!     WEBCORE_EXPORT Path();</span>
  #if USE(CG)
<span class="line-modified">!     Path(RetainPtr&lt;CGMutablePathRef&gt;);</span>
  #endif
<span class="line-modified">!     WEBCORE_EXPORT ~Path();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     WEBCORE_EXPORT Path(const Path&amp;);</span>
<span class="line-modified">!     WEBCORE_EXPORT Path(Path&amp;&amp;);</span>
<span class="line-modified">!     WEBCORE_EXPORT Path&amp; operator=(const Path&amp;);</span>
<span class="line-modified">!     WEBCORE_EXPORT Path&amp; operator=(Path&amp;&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     static Path polygonPathFromPoints(const Vector&lt;FloatPoint&gt;&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     bool contains(const FloatPoint&amp;, WindRule = WindRule::NonZero) const;</span>
<span class="line-modified">!     bool strokeContains(StrokeStyleApplier&amp;, const FloatPoint&amp;) const;</span>
<span class="line-modified">!     // fastBoundingRect() should equal or contain boundingRect(); boundingRect()</span>
<span class="line-modified">!     // should perfectly bound the points within the path.</span>
<span class="line-modified">!     FloatRect boundingRect() const;</span>
<span class="line-modified">!     WEBCORE_EXPORT FloatRect fastBoundingRect() const;</span>
<span class="line-modified">!     FloatRect strokeBoundingRect(StrokeStyleApplier* = 0) const;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     float length() const;</span>
<span class="line-modified">!     PathTraversalState traversalStateAtLength(float length) const;</span>
<span class="line-modified">!     FloatPoint pointAtLength(float length) const;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     WEBCORE_EXPORT void clear();</span>
<span class="line-modified">!     bool isNull() const { return !m_path; }</span>
<span class="line-modified">!     bool isEmpty() const;</span>
<span class="line-modified">!     // Gets the current point of the current path, which is conceptually the final point reached by the path so far.</span>
<span class="line-modified">!     // Note the Path can be empty (isEmpty() == true) and still have a current point.</span>
<span class="line-modified">!     bool hasCurrentPoint() const;</span>
<span class="line-modified">!     FloatPoint currentPoint() const;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     WEBCORE_EXPORT void moveTo(const FloatPoint&amp;);</span>
<span class="line-modified">!     WEBCORE_EXPORT void addLineTo(const FloatPoint&amp;);</span>
<span class="line-modified">!     WEBCORE_EXPORT void addQuadCurveTo(const FloatPoint&amp; controlPoint, const FloatPoint&amp; endPoint);</span>
<span class="line-modified">!     WEBCORE_EXPORT void addBezierCurveTo(const FloatPoint&amp; controlPoint1, const FloatPoint&amp; controlPoint2, const FloatPoint&amp; endPoint);</span>
<span class="line-modified">!     void addArcTo(const FloatPoint&amp;, const FloatPoint&amp;, float radius);</span>
<span class="line-modified">!     WEBCORE_EXPORT void closeSubpath();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     void addArc(const FloatPoint&amp;, float radius, float startAngle, float endAngle, bool anticlockwise);</span>
<span class="line-modified">!     void addRect(const FloatRect&amp;);</span>
<span class="line-modified">!     void addEllipse(FloatPoint, float radiusX, float radiusY, float rotation, float startAngle, float endAngle, bool anticlockwise);</span>
<span class="line-modified">!     void addEllipse(const FloatRect&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     enum class RoundedRectStrategy : uint8_t {</span>
<span class="line-modified">!         PreferNative,</span>
<span class="line-modified">!         PreferBezier</span>
<span class="line-modified">!     };</span>
<span class="line-modified">! </span>
<span class="line-modified">!     WEBCORE_EXPORT void addRoundedRect(const FloatRect&amp;, const FloatSize&amp; roundingRadii, RoundedRectStrategy = RoundedRectStrategy::PreferNative);</span>
<span class="line-modified">!     WEBCORE_EXPORT void addRoundedRect(const FloatRoundedRect&amp;, RoundedRectStrategy = RoundedRectStrategy::PreferNative);</span>
<span class="line-modified">!     void addRoundedRect(const RoundedRect&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     void addPath(const Path&amp;, const AffineTransform&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     void translate(const FloatSize&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // To keep Path() cheap, it does not allocate a PlatformPath immediately</span>
<span class="line-modified">!     // meaning Path::platformPath() can return null.</span>
  #if USE(DIRECT2D)
<span class="line-modified">!     FloatRect fastBoundingRectForStroke(const PlatformContextDirect2D&amp;) const;</span>
<span class="line-added">+     PlatformPathPtr platformPath() const { return m_path.get(); }</span>
  #else
<span class="line-modified">!     PlatformPathPtr platformPath() const { return m_path; }</span>
  #endif
<span class="line-modified">!     // ensurePlatformPath() will allocate a PlatformPath if it has not yet been and will never return null.</span>
<span class="line-modified">!     WEBCORE_EXPORT PlatformPathPtr ensurePlatformPath();</span>
  
<span class="line-modified">!     WEBCORE_EXPORT void apply(const PathApplierFunction&amp;) const;</span>
<span class="line-modified">!     void transform(const AffineTransform&amp;);</span>
  
<span class="line-modified">!     static float circleControlPoint()</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         // Approximation of control point positions on a bezier to simulate a quarter of a circle.</span>
<span class="line-modified">!         // This is 1-kappa, where kappa = 4 * (sqrt(2) - 1) / 3</span>
<span class="line-modified">!         return 0.447715;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     void addBeziersForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);</span>
  
  #if USE(CG) || USE(DIRECT2D)
<span class="line-modified">!     void platformAddPathForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);</span>
  #endif
  
  #if USE(DIRECT2D)
<span class="line-modified">!     void appendGeometry(ID2D1Geometry*);</span>
<span class="line-modified">!     void createGeometryWithFillMode(WindRule, COMPtr&lt;ID2D1GeometryGroup&gt;&amp;) const;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     void openFigureAtCurrentPointIfNecessary();</span>
<span class="line-modified">!     void closeAnyOpenGeometries(unsigned figureEndStyle) const;</span>
<span class="line-modified">!     void clearGeometries();</span>
  #endif
  
  #ifndef NDEBUG
<span class="line-modified">!     void dump() const;</span>
  #endif
  
<span class="line-modified">!     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Path&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
  #if USE(DIRECT2D)
<span class="line-modified">!     Vector&lt;ID2D1Geometry*&gt; m_geometries;</span>
<span class="line-modified">!     COMPtr&lt;ID2D1GeometryGroup&gt; m_path;</span>
<span class="line-modified">!     mutable COMPtr&lt;ID2D1GeometrySink&gt; m_activePath;</span>
<span class="line-modified">!     mutable bool m_figureIsOpened { false };</span>
  #else
<span class="line-modified">!     PlatformPathPtr m_path { nullptr };</span>
  #endif
<span class="line-modified">! };</span>
  
  WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Path&amp;);
  
<span class="line-added">+ template&lt;class Encoder&gt; void Path::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     uint64_t numPoints = 0;</span>
<span class="line-added">+     apply([&amp;numPoints](const PathElement&amp;) {</span>
<span class="line-added">+         ++numPoints;</span>
<span class="line-added">+     });</span>
<span class="line-added">+ </span>
<span class="line-added">+     encoder &lt;&lt; numPoints;</span>
<span class="line-added">+ </span>
<span class="line-added">+     apply([&amp;](auto&amp; element) {</span>
<span class="line-added">+         encoder.encodeEnum(element.type);</span>
<span class="line-added">+ </span>
<span class="line-added">+         switch (element.type) {</span>
<span class="line-added">+         case PathElement::Type::MoveToPoint:</span>
<span class="line-added">+             encoder &lt;&lt; element.points[0];</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case PathElement::Type::AddLineToPoint:</span>
<span class="line-added">+             encoder &lt;&lt; element.points[0];</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case PathElement::Type::AddQuadCurveToPoint:</span>
<span class="line-added">+             encoder &lt;&lt; element.points[0];</span>
<span class="line-added">+             encoder &lt;&lt; element.points[1];</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case PathElement::Type::AddCurveToPoint:</span>
<span class="line-added">+             encoder &lt;&lt; element.points[0];</span>
<span class="line-added">+             encoder &lt;&lt; element.points[1];</span>
<span class="line-added">+             encoder &lt;&lt; element.points[2];</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case PathElement::Type::CloseSubpath:</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt; Optional&lt;Path&gt; Path::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Path path;</span>
<span class="line-added">+     uint64_t numPoints;</span>
<span class="line-added">+     if (!decoder.decode(numPoints))</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     path.clear();</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (uint64_t i = 0; i &lt; numPoints; ++i) {</span>
<span class="line-added">+         PathElement::Type elementType;</span>
<span class="line-added">+         if (!decoder.decodeEnum(elementType))</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         switch (elementType) {</span>
<span class="line-added">+         case PathElement::Type::MoveToPoint: {</span>
<span class="line-added">+             FloatPoint point;</span>
<span class="line-added">+             if (!decoder.decode(point))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+             path.moveTo(point);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case PathElement::Type::AddLineToPoint: {</span>
<span class="line-added">+             FloatPoint point;</span>
<span class="line-added">+             if (!decoder.decode(point))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+             path.addLineTo(point);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case PathElement::Type::AddQuadCurveToPoint: {</span>
<span class="line-added">+             FloatPoint controlPoint;</span>
<span class="line-added">+             if (!decoder.decode(controlPoint))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             FloatPoint endPoint;</span>
<span class="line-added">+             if (!decoder.decode(endPoint))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             path.addQuadCurveTo(controlPoint, endPoint);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case PathElement::Type::AddCurveToPoint: {</span>
<span class="line-added">+             FloatPoint controlPoint1;</span>
<span class="line-added">+             if (!decoder.decode(controlPoint1))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             FloatPoint controlPoint2;</span>
<span class="line-added">+             if (!decoder.decode(controlPoint2))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             FloatPoint endPoint;</span>
<span class="line-added">+             if (!decoder.decode(endPoint))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             path.addBezierCurveTo(controlPoint1, controlPoint2, endPoint);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case PathElement::Type::CloseSubpath:</span>
<span class="line-added">+             path.closeSubpath();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return path;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  }
  
  #endif
</pre>
<center><a href="Path.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PathTraversalState.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
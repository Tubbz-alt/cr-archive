<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFlexibleBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions are
  6  * met:
  7  *
  8  *     * Redistributions of source code must retain the above copyright
  9  * notice, this list of conditions and the following disclaimer.
 10  *     * Redistributions in binary form must reproduce the above
 11  * copyright notice, this list of conditions and the following disclaimer
 12  * in the documentation and/or other materials provided with the
 13  * distribution.
 14  *     * Neither the name of Google Inc. nor the names of its
 15  * contributors may be used to endorse or promote products derived from
 16  * this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #pragma once
 32 
 33 #include &quot;OrderIterator.h&quot;
 34 #include &quot;RenderBlock.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 class FlexItem;
 39 
 40 class RenderFlexibleBox : public RenderBlock {
 41     WTF_MAKE_ISO_ALLOCATED(RenderFlexibleBox);
 42 public:
 43     RenderFlexibleBox(Element&amp;, RenderStyle&amp;&amp;);
 44     RenderFlexibleBox(Document&amp;, RenderStyle&amp;&amp;);
 45     virtual ~RenderFlexibleBox();
 46 
 47     bool isFlexibleBox() const override { return true; }
 48 
 49     const char* renderName() const override;
 50 
 51     bool avoidsFloats() const final { return true; }
 52     bool canDropAnonymousBlockChild() const final { return false; }
 53     void layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight = 0_lu) final;
 54 
 55     int baselinePosition(FontBaseline, bool firstLine, LineDirectionMode, LinePositionMode = PositionOnContainingLine) const override;
 56     Optional&lt;int&gt; firstLineBaseline() const override;
 57     Optional&lt;int&gt; inlineBlockBaseline(LineDirectionMode) const override;
 58 
 59     void styleDidChange(StyleDifference, const RenderStyle*) override;
 60     void paintChildren(PaintInfo&amp; forSelf, const LayoutPoint&amp;, PaintInfo&amp; forChild, bool usePrintRect) override;
 61 
 62     bool isHorizontalFlow() const;
 63 
 64     const OrderIterator&amp; orderIterator() const { return m_orderIterator; }
 65 
 66     bool isTopLayoutOverflowAllowed() const override;
 67     bool isLeftLayoutOverflowAllowed() const override;
 68 
 69     virtual bool isFlexibleBoxImpl() const { return false; };
 70 
 71     Optional&lt;LayoutUnit&gt; crossSizeForPercentageResolution(const RenderBox&amp;);
 72     Optional&lt;LayoutUnit&gt; mainSizeForPercentageResolution(const RenderBox&amp;);
 73     Optional&lt;LayoutUnit&gt; childLogicalHeightForPercentageResolution(const RenderBox&amp;);
 74 
 75     void clearCachedMainSizeForChild(const RenderBox&amp; child);
 76 
 77     LayoutUnit cachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child) const;
 78     void setCachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child, LayoutUnit);
 79     void clearCachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child);
 80 
 81     LayoutUnit staticMainAxisPositionForPositionedChild(const RenderBox&amp;);
 82     LayoutUnit staticCrossAxisPositionForPositionedChild(const RenderBox&amp;);
 83 
 84     LayoutUnit staticInlinePositionForPositionedChild(const RenderBox&amp;);
 85     LayoutUnit staticBlockPositionForPositionedChild(const RenderBox&amp;);
 86 
 87     // Returns true if the position changed. In that case, the child will have to
 88     // be laid out again.
 89     bool setStaticPositionForPositionedLayout(const RenderBox&amp;);
 90 
 91 protected:
 92     void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const override;
 93     void computePreferredLogicalWidths() override;
 94 
<a name="1" id="anc1"></a>

 95 private:
 96     enum FlexSign {
 97         PositiveFlexibility,
 98         NegativeFlexibility,
 99     };
100 
101     enum ChildLayoutType { LayoutIfNeeded, ForceLayout, NeverLayout };
102 
103     enum class SizeDefiniteness { Definite, Indefinite, Unknown };
104 
105     // Use an inline capacity of 8, since flexbox containers usually have less than 8 children.
106     typedef Vector&lt;LayoutRect, 8&gt; ChildFrameRects;
107 
108     struct LineContext;
109 
110     bool hasOrthogonalFlow(const RenderBox&amp; child) const;
111     bool isColumnFlow() const;
112     bool isLeftToRightFlow() const;
113     bool isMultiline() const;
114     Length flexBasisForChild(const RenderBox&amp; child) const;
115     LayoutUnit crossAxisExtentForChild(const RenderBox&amp; child) const;
116     LayoutUnit crossAxisIntrinsicExtentForChild(const RenderBox&amp; child) const;
117     LayoutUnit childIntrinsicLogicalHeight(const RenderBox&amp; child) const;
118     LayoutUnit childIntrinsicLogicalWidth(const RenderBox&amp; child) const;
119     LayoutUnit mainAxisExtentForChild(const RenderBox&amp; child) const;
120     LayoutUnit mainAxisContentExtentForChildIncludingScrollbar(const RenderBox&amp; child) const;
121     LayoutUnit crossAxisExtent() const;
122     LayoutUnit mainAxisExtent() const;
123     LayoutUnit crossAxisContentExtent() const;
124     LayoutUnit mainAxisContentExtent(LayoutUnit contentLogicalHeight);
125     Optional&lt;LayoutUnit&gt; computeMainAxisExtentForChild(const RenderBox&amp; child, SizeType, const Length&amp; size);
126     WritingMode transformedWritingMode() const;
127     LayoutUnit flowAwareBorderStart() const;
128     LayoutUnit flowAwareBorderEnd() const;
129     LayoutUnit flowAwareBorderBefore() const;
130     LayoutUnit flowAwareBorderAfter() const;
131     LayoutUnit flowAwarePaddingStart() const;
132     LayoutUnit flowAwarePaddingEnd() const;
133     LayoutUnit flowAwarePaddingBefore() const;
134     LayoutUnit flowAwarePaddingAfter() const;
135     LayoutUnit flowAwareMarginStartForChild(const RenderBox&amp; child) const;
136     LayoutUnit flowAwareMarginEndForChild(const RenderBox&amp; child) const;
137     LayoutUnit flowAwareMarginBeforeForChild(const RenderBox&amp; child) const;
138     LayoutUnit crossAxisMarginExtentForChild(const RenderBox&amp; child) const;
139     LayoutUnit crossAxisScrollbarExtent() const;
140     LayoutUnit crossAxisScrollbarExtentForChild(const RenderBox&amp; child) const;
141     LayoutPoint flowAwareLocationForChild(const RenderBox&amp; child) const;
142     bool useChildAspectRatio(const RenderBox&amp; child) const;
143     LayoutUnit computeMainSizeFromAspectRatioUsing(const RenderBox&amp; child, Length crossSizeLength) const;
144     void setFlowAwareLocationForChild(RenderBox&amp; child, const LayoutPoint&amp;);
145     LayoutUnit computeInnerFlexBaseSizeForChild(RenderBox&amp; child, LayoutUnit mainAxisBorderAndPadding, bool relayoutChildren);
146     void adjustAlignmentForChild(RenderBox&amp; child, LayoutUnit);
147     ItemPosition alignmentForChild(const RenderBox&amp; child) const;
148     bool mainAxisLengthIsDefinite(const RenderBox&amp; child, const Length&amp; flexBasis) const;
149     bool crossAxisLengthIsDefinite(const RenderBox&amp; child, const Length&amp; flexBasis) const;
150     bool needToStretchChildLogicalHeight(const RenderBox&amp; child) const;
151     bool childHasIntrinsicMainAxisSize(const RenderBox&amp; child) const;
152     Overflow mainAxisOverflowForChild(const RenderBox&amp; child) const;
153     Overflow crossAxisOverflowForChild(const RenderBox&amp; child) const;
154     void cacheChildMainSize(const RenderBox&amp; child);
155 
156     void layoutFlexItems(bool relayoutChildren);
157     LayoutUnit autoMarginOffsetInMainAxis(const Vector&lt;FlexItem&gt;&amp;, LayoutUnit&amp; availableFreeSpace);
158     void updateAutoMarginsInMainAxis(RenderBox&amp; child, LayoutUnit autoMarginOffset);
159     bool hasAutoMarginsInCrossAxis(const RenderBox&amp; child) const;
160     bool updateAutoMarginsInCrossAxis(RenderBox&amp; child, LayoutUnit availableAlignmentSpace);
161     void repositionLogicalHeightDependentFlexItems(Vector&lt;LineContext&gt;&amp;);
162     LayoutUnit clientLogicalBottomAfterRepositioning();
163 
164     LayoutUnit availableAlignmentSpaceForChild(LayoutUnit lineCrossAxisExtent, const RenderBox&amp; child);
165     LayoutUnit marginBoxAscentForChild(const RenderBox&amp; child);
166 
167     LayoutUnit computeChildMarginValue(Length margin);
168     void prepareOrderIteratorAndMargins();
169     LayoutUnit adjustChildSizeForMinAndMax(const RenderBox&amp; child, LayoutUnit childSize);
170     LayoutUnit adjustChildSizeForAspectRatioCrossAxisMinAndMax(const RenderBox&amp; child, LayoutUnit childSize);
171     FlexItem constructFlexItem(RenderBox&amp;, bool relayoutChildren);
172 
173     void freezeInflexibleItems(FlexSign, Vector&lt;FlexItem&gt;&amp; children, LayoutUnit&amp; remainingFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink);
174     bool resolveFlexibleLengths(FlexSign, Vector&lt;FlexItem&gt;&amp;, LayoutUnit initialFreeSpace, LayoutUnit&amp; remainingFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink);
175     void freezeViolations(Vector&lt;FlexItem*&gt;&amp;, LayoutUnit&amp; availableFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink);
176 
177     void resetAutoMarginsAndLogicalTopInCrossAxis(RenderBox&amp; child);
178     void setOverrideMainAxisContentSizeForChild(RenderBox&amp; child, LayoutUnit childPreferredSize);
179     void prepareChildForPositionedLayout(RenderBox&amp; child);
180     void layoutAndPlaceChildren(LayoutUnit&amp; crossAxisOffset, Vector&lt;FlexItem&gt;&amp;, LayoutUnit availableFreeSpace, bool relayoutChildren, Vector&lt;LineContext&gt;&amp;);
181     void layoutColumnReverse(const Vector&lt;FlexItem&gt;&amp;, LayoutUnit crossAxisOffset, LayoutUnit availableFreeSpace);
182     void alignFlexLines(Vector&lt;LineContext&gt;&amp;);
183     void alignChildren(const Vector&lt;LineContext&gt;&amp;);
184     void applyStretchAlignmentToChild(RenderBox&amp; child, LayoutUnit lineCrossAxisExtent);
185     void flipForRightToLeftColumn(const Vector&lt;LineContext&gt;&amp; lineContexts);
186     void flipForWrapReverse(const Vector&lt;LineContext&gt;&amp;, LayoutUnit crossAxisStartEdge);
187 
188     void appendChildFrameRects(ChildFrameRects&amp;);
189     void repaintChildrenDuringLayoutIfMoved(const ChildFrameRects&amp;);
190 
<a name="2" id="anc2"></a>

191     // This is used to cache the preferred size for orthogonal flow children so we
192     // don&#39;t have to relayout to get it
193     HashMap&lt;const RenderBox*, LayoutUnit&gt; m_intrinsicSizeAlongMainAxis;
194 
195     // This is used to cache the intrinsic size on the cross axis to avoid
196     // relayouts when stretching.
197     HashMap&lt;const RenderBox*, LayoutUnit&gt; m_intrinsicContentLogicalHeights;
198 
199     // This set is used to keep track of which children we laid out in this
200     // current layout iteration. We need it because the ones in this set may
201     // need an additional layout pass for correct stretch alignment handling, as
202     // the first layout likely did not use the correct value for percentage
203     // sizing of children.
204     HashSet&lt;const RenderBox*&gt; m_relaidOutChildren;
205 
206     mutable OrderIterator m_orderIterator { *this };
207     int m_numberOfInFlowChildrenOnFirstLine { -1 };
208 
209     // This is SizeIsUnknown outside of layoutBlock()
210     mutable SizeDefiniteness m_hasDefiniteHeight { SizeDefiniteness::Unknown };
211     bool m_inLayout { false };
<a name="3" id="anc3"></a>
212 };
213 
214 } // namespace WebCore
215 
216 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderFlexibleBox, isFlexibleBox())
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
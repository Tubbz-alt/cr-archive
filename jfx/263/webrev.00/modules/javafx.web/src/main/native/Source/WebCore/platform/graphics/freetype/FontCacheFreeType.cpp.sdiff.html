<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/freetype/FontCacheFreeType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../filters/SourceGraphic.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FontCustomPlatformDataFreeType.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/freetype/FontCacheFreeType.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
255             return nullptr;
256 
257         FcConfigSubstitute(nullptr, pattern.get(), FcMatchPattern);
258         cairo_ft_font_options_substitute(getDefaultCairoFontOptions(), pattern.get());
259         FcDefaultSubstitute(pattern.get());
260 
261         return makeUnique&lt;CachedFontSet&gt;(WTFMove(pattern));
262     });
263 
264     if (!addResult.iterator-&gt;value)
265         return nullptr;
266 
267     RefPtr&lt;FcPattern&gt; resultPattern = addResult.iterator-&gt;value-&gt;bestForCharacters(characters, length);
268     if (!resultPattern)
269         return nullptr;
270 
271     bool fixedWidth, syntheticBold, syntheticOblique;
272     getFontPropertiesFromPattern(resultPattern.get(), description, fixedWidth, syntheticBold, syntheticOblique);
273 
274     RefPtr&lt;cairo_font_face_t&gt; fontFace = adoptRef(cairo_ft_font_face_create_for_pattern(resultPattern.get()));
<span class="line-modified">275     FontPlatformData alternateFontData(fontFace.get(), resultPattern.get(), description.computedPixelSize(), fixedWidth, syntheticBold, syntheticOblique, description.orientation());</span>
276     return fontForPlatformData(alternateFontData);
277 }
278 
279 void FontCache::platformPurgeInactiveFontData()
280 {
281     systemFallbackCache().clear();
282 }
283 
284 static Vector&lt;String&gt; patternToFamilies(FcPattern&amp; pattern)
285 {
286     char* patternChars = reinterpret_cast&lt;char*&gt;(FcPatternFormat(&amp;pattern, reinterpret_cast&lt;const FcChar8*&gt;(&quot;%{family}&quot;)));
287     String patternString = String::fromUTF8(patternChars);
288     free(patternChars);
289 
290     return patternString.split(&#39;,&#39;);
291 }
292 
293 Vector&lt;String&gt; FontCache::systemFontFamilies()
294 {
295     RefPtr&lt;FcPattern&gt; scalablesOnlyPattern = adoptRef(FcPatternCreate());
</pre>
<hr />
<pre>
483         if (family == familyB)
484             return true;
485     }
486     return false;
487 }
488 
489 static inline bool isCommonlyUsedGenericFamily(const String&amp; familyNameString)
490 {
491     return equalLettersIgnoringASCIICase(familyNameString, &quot;sans&quot;)
492         || equalLettersIgnoringASCIICase(familyNameString, &quot;sans-serif&quot;)
493         || equalLettersIgnoringASCIICase(familyNameString, &quot;serif&quot;)
494         || equalLettersIgnoringASCIICase(familyNameString, &quot;monospace&quot;)
495         || equalLettersIgnoringASCIICase(familyNameString, &quot;fantasy&quot;)
496 #if PLATFORM(GTK)
497         || equalLettersIgnoringASCIICase(familyNameString, &quot;-webkit-system-font&quot;)
498         || equalLettersIgnoringASCIICase(familyNameString, &quot;-webkit-system-ui&quot;)
499 #endif
500         || equalLettersIgnoringASCIICase(familyNameString, &quot;cursive&quot;);
501 }
502 
<span class="line-modified">503 std::unique_ptr&lt;FontPlatformData&gt; FontCache::createFontPlatformData(const FontDescription&amp; fontDescription, const AtomString&amp; family, const FontFeatureSettings*, const FontVariantSettings*, FontSelectionSpecifiedCapabilities)</span>
504 {
505     // The CSS font matching algorithm (http://www.w3.org/TR/css3-fonts/#font-matching-algorithm)
506     // says that we must find an exact match for font family, slant (italic or oblique can be used)
507     // and font weight (we only match bold/non-bold here).
508     RefPtr&lt;FcPattern&gt; pattern = adoptRef(FcPatternCreate());
509     // Never choose unscalable fonts, as they pixelate when displayed at different sizes.
510     FcPatternAddBool(pattern.get(), FC_SCALABLE, FcTrue);
511 #if ENABLE(VARIATION_FONTS)
512     FcPatternAddBool(pattern.get(), FC_VARIABLE, FcDontCare);
513 #endif
514     String familyNameString(getFamilyNameStringFromFamily(family));
515     if (!FcPatternAddString(pattern.get(), FC_FAMILY, reinterpret_cast&lt;const FcChar8*&gt;(familyNameString.utf8().data())))
516         return nullptr;
517 
518     if (!configurePatternForFontDescription(pattern.get(), fontDescription))
519         return nullptr;
520 
521     // The strategy is originally from Skia (src/ports/SkFontHost_fontconfig.cpp):
522     //
523     // We do not normally allow fontconfig to substitute one font family for another, since this
</pre>
<hr />
<pre>
562         return nullptr;
563 
564     bool fixedWidth, syntheticBold, syntheticOblique;
565     getFontPropertiesFromPattern(resultPattern.get(), fontDescription, fixedWidth, syntheticBold, syntheticOblique);
566 
567     RefPtr&lt;cairo_font_face_t&gt; fontFace = adoptRef(cairo_ft_font_face_create_for_pattern(resultPattern.get()));
568 #if ENABLE(VARIATION_FONTS)
569     // Cairo doesn&#39;t have API to get the FT_Face of an unscaled font, so we need to
570     // create a temporary scaled font to get the FT_Face.
571     CairoUniquePtr&lt;cairo_font_options_t&gt; options(cairo_font_options_copy(getDefaultCairoFontOptions()));
572     cairo_matrix_t matrix;
573     cairo_matrix_init_identity(&amp;matrix);
574     RefPtr&lt;cairo_scaled_font_t&gt; scaledFont = adoptRef(cairo_scaled_font_create(fontFace.get(), &amp;matrix, &amp;matrix, options.get()));
575     CairoFtFaceLocker cairoFtFaceLocker(scaledFont.get());
576     if (FT_Face freeTypeFace = cairoFtFaceLocker.ftFace()) {
577         auto variants = buildVariationSettings(freeTypeFace, fontDescription);
578         if (!variants.isEmpty())
579             FcPatternAddString(resultPattern.get(), FC_FONT_VARIATIONS, reinterpret_cast&lt;const FcChar8*&gt;(variants.utf8().data()));
580     }
581 #endif
<span class="line-modified">582     auto platformData = makeUnique&lt;FontPlatformData&gt;(fontFace.get(), resultPattern.get(), fontDescription.computedPixelSize(), fixedWidth, syntheticBold, syntheticOblique, fontDescription.orientation());</span>
583     // Verify that this font has an encoding compatible with Fontconfig. Fontconfig currently
584     // supports three encodings in FcFreeTypeCharIndex: Unicode, Symbol and AppleRoman.
585     // If this font doesn&#39;t have one of these three encodings, don&#39;t select it.
586     if (!platformData-&gt;hasCompatibleCharmap())
587         return nullptr;
588 
589     return platformData;
590 }
591 
592 const AtomString&amp; FontCache::platformAlternateFamilyName(const AtomString&amp;)
593 {
594     return nullAtom();
595 }
596 
597 #if ENABLE(VARIATION_FONTS)
598 struct VariationDefaults {
599     float defaultValue;
600     float minimumValue;
601     float maximumValue;
602 };
</pre>
<hr />
<pre>
634     auto applyVariation = [&amp;](const FontTag&amp; tag, float value) {
635         auto iterator = defaultValues.find(tag);
636         if (iterator == defaultValues.end())
637             return;
638         float valueToApply = clampTo(value, iterator-&gt;value.minimumValue, iterator-&gt;value.maximumValue);
639         variationsToBeApplied.set(tag, valueToApply);
640     };
641 
642     for (auto&amp; variation : variations)
643         applyVariation(variation.tag(), variation.value());
644 
645     StringBuilder builder;
646     for (auto&amp; variation : variationsToBeApplied) {
647         if (!builder.isEmpty())
648             builder.append(&#39;,&#39;);
649         builder.append(variation.key[0]);
650         builder.append(variation.key[1]);
651         builder.append(variation.key[2]);
652         builder.append(variation.key[3]);
653         builder.append(&#39;=&#39;);
<span class="line-modified">654         builder.appendFixedPrecisionNumber(variation.value);</span>
655     }
656     return builder.toString();
657 }
658 #endif // ENABLE(VARIATION_FONTS)
659 
660 }
</pre>
</td>
<td>
<hr />
<pre>
255             return nullptr;
256 
257         FcConfigSubstitute(nullptr, pattern.get(), FcMatchPattern);
258         cairo_ft_font_options_substitute(getDefaultCairoFontOptions(), pattern.get());
259         FcDefaultSubstitute(pattern.get());
260 
261         return makeUnique&lt;CachedFontSet&gt;(WTFMove(pattern));
262     });
263 
264     if (!addResult.iterator-&gt;value)
265         return nullptr;
266 
267     RefPtr&lt;FcPattern&gt; resultPattern = addResult.iterator-&gt;value-&gt;bestForCharacters(characters, length);
268     if (!resultPattern)
269         return nullptr;
270 
271     bool fixedWidth, syntheticBold, syntheticOblique;
272     getFontPropertiesFromPattern(resultPattern.get(), description, fixedWidth, syntheticBold, syntheticOblique);
273 
274     RefPtr&lt;cairo_font_face_t&gt; fontFace = adoptRef(cairo_ft_font_face_create_for_pattern(resultPattern.get()));
<span class="line-modified">275     FontPlatformData alternateFontData(fontFace.get(), WTFMove(resultPattern), description.computedPixelSize(), fixedWidth, syntheticBold, syntheticOblique, description.orientation());</span>
276     return fontForPlatformData(alternateFontData);
277 }
278 
279 void FontCache::platformPurgeInactiveFontData()
280 {
281     systemFallbackCache().clear();
282 }
283 
284 static Vector&lt;String&gt; patternToFamilies(FcPattern&amp; pattern)
285 {
286     char* patternChars = reinterpret_cast&lt;char*&gt;(FcPatternFormat(&amp;pattern, reinterpret_cast&lt;const FcChar8*&gt;(&quot;%{family}&quot;)));
287     String patternString = String::fromUTF8(patternChars);
288     free(patternChars);
289 
290     return patternString.split(&#39;,&#39;);
291 }
292 
293 Vector&lt;String&gt; FontCache::systemFontFamilies()
294 {
295     RefPtr&lt;FcPattern&gt; scalablesOnlyPattern = adoptRef(FcPatternCreate());
</pre>
<hr />
<pre>
483         if (family == familyB)
484             return true;
485     }
486     return false;
487 }
488 
489 static inline bool isCommonlyUsedGenericFamily(const String&amp; familyNameString)
490 {
491     return equalLettersIgnoringASCIICase(familyNameString, &quot;sans&quot;)
492         || equalLettersIgnoringASCIICase(familyNameString, &quot;sans-serif&quot;)
493         || equalLettersIgnoringASCIICase(familyNameString, &quot;serif&quot;)
494         || equalLettersIgnoringASCIICase(familyNameString, &quot;monospace&quot;)
495         || equalLettersIgnoringASCIICase(familyNameString, &quot;fantasy&quot;)
496 #if PLATFORM(GTK)
497         || equalLettersIgnoringASCIICase(familyNameString, &quot;-webkit-system-font&quot;)
498         || equalLettersIgnoringASCIICase(familyNameString, &quot;-webkit-system-ui&quot;)
499 #endif
500         || equalLettersIgnoringASCIICase(familyNameString, &quot;cursive&quot;);
501 }
502 
<span class="line-modified">503 std::unique_ptr&lt;FontPlatformData&gt; FontCache::createFontPlatformData(const FontDescription&amp; fontDescription, const AtomString&amp; family, const FontFeatureSettings*, FontSelectionSpecifiedCapabilities)</span>
504 {
505     // The CSS font matching algorithm (http://www.w3.org/TR/css3-fonts/#font-matching-algorithm)
506     // says that we must find an exact match for font family, slant (italic or oblique can be used)
507     // and font weight (we only match bold/non-bold here).
508     RefPtr&lt;FcPattern&gt; pattern = adoptRef(FcPatternCreate());
509     // Never choose unscalable fonts, as they pixelate when displayed at different sizes.
510     FcPatternAddBool(pattern.get(), FC_SCALABLE, FcTrue);
511 #if ENABLE(VARIATION_FONTS)
512     FcPatternAddBool(pattern.get(), FC_VARIABLE, FcDontCare);
513 #endif
514     String familyNameString(getFamilyNameStringFromFamily(family));
515     if (!FcPatternAddString(pattern.get(), FC_FAMILY, reinterpret_cast&lt;const FcChar8*&gt;(familyNameString.utf8().data())))
516         return nullptr;
517 
518     if (!configurePatternForFontDescription(pattern.get(), fontDescription))
519         return nullptr;
520 
521     // The strategy is originally from Skia (src/ports/SkFontHost_fontconfig.cpp):
522     //
523     // We do not normally allow fontconfig to substitute one font family for another, since this
</pre>
<hr />
<pre>
562         return nullptr;
563 
564     bool fixedWidth, syntheticBold, syntheticOblique;
565     getFontPropertiesFromPattern(resultPattern.get(), fontDescription, fixedWidth, syntheticBold, syntheticOblique);
566 
567     RefPtr&lt;cairo_font_face_t&gt; fontFace = adoptRef(cairo_ft_font_face_create_for_pattern(resultPattern.get()));
568 #if ENABLE(VARIATION_FONTS)
569     // Cairo doesn&#39;t have API to get the FT_Face of an unscaled font, so we need to
570     // create a temporary scaled font to get the FT_Face.
571     CairoUniquePtr&lt;cairo_font_options_t&gt; options(cairo_font_options_copy(getDefaultCairoFontOptions()));
572     cairo_matrix_t matrix;
573     cairo_matrix_init_identity(&amp;matrix);
574     RefPtr&lt;cairo_scaled_font_t&gt; scaledFont = adoptRef(cairo_scaled_font_create(fontFace.get(), &amp;matrix, &amp;matrix, options.get()));
575     CairoFtFaceLocker cairoFtFaceLocker(scaledFont.get());
576     if (FT_Face freeTypeFace = cairoFtFaceLocker.ftFace()) {
577         auto variants = buildVariationSettings(freeTypeFace, fontDescription);
578         if (!variants.isEmpty())
579             FcPatternAddString(resultPattern.get(), FC_FONT_VARIATIONS, reinterpret_cast&lt;const FcChar8*&gt;(variants.utf8().data()));
580     }
581 #endif
<span class="line-modified">582     auto platformData = makeUnique&lt;FontPlatformData&gt;(fontFace.get(), WTFMove(resultPattern), fontDescription.computedPixelSize(), fixedWidth, syntheticBold, syntheticOblique, fontDescription.orientation());</span>
583     // Verify that this font has an encoding compatible with Fontconfig. Fontconfig currently
584     // supports three encodings in FcFreeTypeCharIndex: Unicode, Symbol and AppleRoman.
585     // If this font doesn&#39;t have one of these three encodings, don&#39;t select it.
586     if (!platformData-&gt;hasCompatibleCharmap())
587         return nullptr;
588 
589     return platformData;
590 }
591 
592 const AtomString&amp; FontCache::platformAlternateFamilyName(const AtomString&amp;)
593 {
594     return nullAtom();
595 }
596 
597 #if ENABLE(VARIATION_FONTS)
598 struct VariationDefaults {
599     float defaultValue;
600     float minimumValue;
601     float maximumValue;
602 };
</pre>
<hr />
<pre>
634     auto applyVariation = [&amp;](const FontTag&amp; tag, float value) {
635         auto iterator = defaultValues.find(tag);
636         if (iterator == defaultValues.end())
637             return;
638         float valueToApply = clampTo(value, iterator-&gt;value.minimumValue, iterator-&gt;value.maximumValue);
639         variationsToBeApplied.set(tag, valueToApply);
640     };
641 
642     for (auto&amp; variation : variations)
643         applyVariation(variation.tag(), variation.value());
644 
645     StringBuilder builder;
646     for (auto&amp; variation : variationsToBeApplied) {
647         if (!builder.isEmpty())
648             builder.append(&#39;,&#39;);
649         builder.append(variation.key[0]);
650         builder.append(variation.key[1]);
651         builder.append(variation.key[2]);
652         builder.append(variation.key[3]);
653         builder.append(&#39;=&#39;);
<span class="line-modified">654         builder.append(FormattedNumber::fixedPrecision(variation.value));</span>
655     }
656     return builder.toString();
657 }
658 #endif // ENABLE(VARIATION_FONTS)
659 
660 }
</pre>
</td>
</tr>
</table>
<center><a href="../filters/SourceGraphic.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FontCustomPlatformDataFreeType.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
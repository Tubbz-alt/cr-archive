<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGCapabilities.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGClobbersExitState.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,11 ***</span>
  #include &quot;DFGLazyNode.h&quot;
  #include &quot;DFGPureValue.h&quot;
  #include &quot;DOMJITCallDOMGetterSnippet.h&quot;
  #include &quot;DOMJITSignature.h&quot;
  #include &quot;InlineCallFrame.h&quot;
<span class="line-removed">- #include &quot;JSFixedArray.h&quot;</span>
  #include &quot;JSImmutableButterfly.h&quot;
  
  namespace JSC { namespace DFG {
  
  template&lt;typename ReadFunctor, typename WriteFunctor, typename DefFunctor&gt;
<span class="line-new-header">--- 33,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,13 ***</span>
      // by calls into the runtime. For debugging we might replace the implementation of any node with a call
      // to the runtime, and that call may walk stack. Therefore, each node must read() anything that a stack
      // scan would read. That&#39;s what this does.
      for (InlineCallFrame* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame()) {
          if (inlineCallFrame-&gt;isClosureCall)
<span class="line-modified">!             read(AbstractHeap(Stack, inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee));</span>
          if (inlineCallFrame-&gt;isVarargs())
<span class="line-modified">!             read(AbstractHeap(Stack, inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount));</span>
      }
  
      // We don&#39;t want to specifically account which nodes can read from the scope
      // when the debugger is enabled. It&#39;s helpful to just claim all nodes do.
      // Specifically, if a node allocates, this may call into the debugger&#39;s machinery.
<span class="line-new-header">--- 109,13 ---</span>
      // by calls into the runtime. For debugging we might replace the implementation of any node with a call
      // to the runtime, and that call may walk stack. Therefore, each node must read() anything that a stack
      // scan would read. That&#39;s what this does.
      for (InlineCallFrame* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame()) {
          if (inlineCallFrame-&gt;isClosureCall)
<span class="line-modified">!             read(AbstractHeap(Stack, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee)));</span>
          if (inlineCallFrame-&gt;isVarargs())
<span class="line-modified">!             read(AbstractHeap(Stack, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis)));</span>
      }
  
      // We don&#39;t want to specifically account which nodes can read from the scope
      // when the debugger is enabled. It&#39;s helpful to just claim all nodes do.
      // Specifically, if a node allocates, this may call into the debugger&#39;s machinery.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,10 ***</span>
<span class="line-new-header">--- 165,11 ---</span>
      case ArithPow:
      case GetScope:
      case SkipScope:
      case GetGlobalObject:
      case StringCharCodeAt:
<span class="line-added">+     case StringCodePointAt:</span>
      case CompareStrictEq:
      case SameValue:
      case IsEmpty:
      case IsUndefined:
      case IsUndefinedOrNull:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 279,11 ***</span>
  
      case ArithBitAnd:
      case ArithBitOr:
      case ArithBitXor:
      case ArithBitLShift:
<span class="line-modified">!     case BitRShift:</span>
      case BitURShift:
          if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
              read(World);
              write(Heap);
              return;
<span class="line-new-header">--- 279,11 ---</span>
  
      case ArithBitAnd:
      case ArithBitOr:
      case ArithBitXor:
      case ArithBitLShift:
<span class="line-modified">!     case ArithBitRShift:</span>
      case BitURShift:
          if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
              read(World);
              write(Heap);
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,20 ***</span>
  
      case AssertNotEmpty:
          write(SideState);
          return;
  
<span class="line-modified">!     case CheckStringIdent:</span>
<span class="line-modified">!         def(PureValue(CheckStringIdent, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1()), node-&gt;uidOperand()));</span>
          return;
  
      case ConstantStoragePointer:
          def(PureValue(node, node-&gt;storagePointer()));
          return;
  
      case KillStack:
<span class="line-modified">!         write(AbstractHeap(Stack, node-&gt;unlinkedLocal()));</span>
          return;
  
      case MovHint:
      case ZombieHint:
      case ExitOK:
<span class="line-new-header">--- 430,20 ---</span>
  
      case AssertNotEmpty:
          write(SideState);
          return;
  
<span class="line-modified">!     case CheckIdent:</span>
<span class="line-modified">!         def(PureValue(CheckIdent, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1()), node-&gt;uidOperand()));</span>
          return;
  
      case ConstantStoragePointer:
          def(PureValue(node, node-&gt;storagePointer()));
          return;
  
      case KillStack:
<span class="line-modified">!         write(AbstractHeap(Stack, node-&gt;unlinkedOperand()));</span>
          return;
  
      case MovHint:
      case ZombieHint:
      case ExitOK:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 468,11 ***</span>
      case ProfileType:
      case ProfileControlFlow:
      case PutHint:
      case InitializeEntrypointArguments:
      case FilterCallLinkStatus:
<span class="line-modified">!     case FilterGetByIdStatus:</span>
      case FilterPutByIdStatus:
      case FilterInByIdStatus:
          write(SideState);
          return;
  
<span class="line-new-header">--- 468,11 ---</span>
      case ProfileType:
      case ProfileControlFlow:
      case PutHint:
      case InitializeEntrypointArguments:
      case FilterCallLinkStatus:
<span class="line-modified">!     case FilterGetByStatus:</span>
      case FilterPutByIdStatus:
      case FilterInByIdStatus:
          write(SideState);
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 495,11 ***</span>
          write(SideState);
          def(HeapLocation(InvalidationPointLoc, Watchpoint_fire), LazyNode(node));
          return;
  
      case Flush:
<span class="line-modified">!         read(AbstractHeap(Stack, node-&gt;local()));</span>
          write(SideState);
          return;
  
      case NotifyWrite:
          write(Watchpoint_fire);
<span class="line-new-header">--- 495,11 ---</span>
          write(SideState);
          def(HeapLocation(InvalidationPointLoc, Watchpoint_fire), LazyNode(node));
          return;
  
      case Flush:
<span class="line-modified">!         read(AbstractHeap(Stack, node-&gt;operand()));</span>
          write(SideState);
          return;
  
      case NotifyWrite:
          write(Watchpoint_fire);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 522,10 ***</span>
<span class="line-new-header">--- 522,11 ---</span>
      }
  
      case CreateDirectArguments:
      case CreateScopedArguments:
      case CreateClonedArguments:
<span class="line-added">+     case CreateArgumentsButterfly:</span>
          read(Stack);
          read(HeapObjectCount);
          write(HeapObjectCount);
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 646,10 ***</span>
<span class="line-new-header">--- 647,11 ---</span>
      case TailCallVarargsInlinedCaller:
      case TailCallForwardVarargsInlinedCaller:
      case ConstructVarargs:
      case ConstructForwardVarargs:
      case ToPrimitive:
<span class="line-added">+     case ToPropertyKey:</span>
      case InByVal:
      case InById:
      case HasOwnProperty:
      case ValueNegate:
      case SetFunctionName:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 662,29 ***</span>
<span class="line-new-header">--- 664,51 ---</span>
      case HasStructureProperty:
      case GetPropertyEnumerator:
      case GetDirectPname:
      case InstanceOfCustom:
      case ToNumber:
<span class="line-added">+     case ToNumeric:</span>
      case NumberToStringWithRadix:
      case CreateThis:
<span class="line-added">+     case CreatePromise:</span>
<span class="line-added">+     case CreateGenerator:</span>
<span class="line-added">+     case CreateAsyncGenerator:</span>
      case InstanceOf:
      case StringValueOf:
      case ObjectKeys:
          read(World);
          write(Heap);
          return;
  
<span class="line-added">+     case Inc:</span>
<span class="line-added">+     case Dec:</span>
<span class="line-added">+         switch (node-&gt;child1().useKind()) {</span>
<span class="line-added">+         case Int32Use:</span>
<span class="line-added">+         case Int52RepUse:</span>
<span class="line-added">+         case DoubleRepUse:</span>
<span class="line-added">+         case BigIntUse:</span>
<span class="line-added">+             def(PureValue(node));</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         case UntypedUse:</span>
<span class="line-added">+             read(World);</span>
<span class="line-added">+             write(Heap);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             DFG_CRASH(graph, node, &quot;Bad use kind&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
      case ValueBitAnd:
      case ValueBitXor:
      case ValueBitOr:
      case ValueAdd:
      case ValueSub:
      case ValueMul:
      case ValueDiv:
      case ValueMod:
      case ValuePow:
      case ValueBitLShift:
<span class="line-added">+     case ValueBitRShift:</span>
          if (node-&gt;isBinaryUseKind(BigIntUse)) {
              def(PureValue(node));
              return;
          }
          read(World);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 714,11 ***</span>
      }
  
      case CallEval:
          ASSERT(!node-&gt;origin.semantic.inlineCallFrame());
          read(AbstractHeap(Stack, graph.m_codeBlock-&gt;scopeRegister()));
<span class="line-modified">!         read(AbstractHeap(Stack, virtualRegisterForArgument(0)));</span>
          read(World);
          write(Heap);
          return;
  
      case Throw:
<span class="line-new-header">--- 738,11 ---</span>
      }
  
      case CallEval:
          ASSERT(!node-&gt;origin.semantic.inlineCallFrame());
          read(AbstractHeap(Stack, graph.m_codeBlock-&gt;scopeRegister()));
<span class="line-modified">!         read(AbstractHeap(Stack, virtualRegisterForArgumentIncludingThis(0)));</span>
          read(World);
          write(Heap);
          return;
  
      case Throw:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 740,75 ***</span>
          read(GetterSetter_setter);
          def(HeapLocation(SetterLoc, GetterSetter_setter, node-&gt;child1()), LazyNode(node));
          return;
  
      case GetCallee:
<span class="line-modified">!         read(AbstractHeap(Stack, CallFrameSlot::callee));</span>
<span class="line-modified">!         def(HeapLocation(StackLoc, AbstractHeap(Stack, CallFrameSlot::callee)), LazyNode(node));</span>
          return;
  
      case SetCallee:
<span class="line-modified">!         write(AbstractHeap(Stack, CallFrameSlot::callee));</span>
          return;
  
      case GetArgumentCountIncludingThis: {
<span class="line-modified">!         auto heap = AbstractHeap(Stack, remapOperand(node-&gt;argumentsInlineCallFrame(), VirtualRegister(CallFrameSlot::argumentCount)));</span>
          read(heap);
          def(HeapLocation(StackPayloadLoc, heap), LazyNode(node));
          return;
      }
  
      case SetArgumentCountIncludingThis:
<span class="line-modified">!         write(AbstractHeap(Stack, CallFrameSlot::argumentCount));</span>
          return;
  
      case GetRestLength:
          read(Stack);
          return;
  
      case GetLocal:
<span class="line-modified">!         read(AbstractHeap(Stack, node-&gt;local()));</span>
<span class="line-modified">!         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;local())), LazyNode(node));</span>
          return;
  
      case SetLocal:
<span class="line-modified">!         write(AbstractHeap(Stack, node-&gt;local()));</span>
<span class="line-modified">!         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;local())), LazyNode(node-&gt;child1().node()));</span>
          return;
  
      case GetStack: {
<span class="line-modified">!         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;local);</span>
          read(heap);
          def(HeapLocation(StackLoc, heap), LazyNode(node));
          return;
      }
  
      case PutStack: {
<span class="line-modified">!         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;local);</span>
          write(heap);
          def(HeapLocation(StackLoc, heap), LazyNode(node-&gt;child1().node()));
          return;
      }
  
      case LoadVarargs: {
          read(World);
          write(Heap);
          LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">!         write(AbstractHeap(Stack, data-&gt;count.offset()));</span>
          for (unsigned i = data-&gt;limit; i--;)
<span class="line-modified">!             write(AbstractHeap(Stack, data-&gt;start.offset() + static_cast&lt;int&gt;(i)));</span>
          return;
      }
  
      case ForwardVarargs: {
          // We could be way more precise here.
          read(Stack);
  
          LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">!         write(AbstractHeap(Stack, data-&gt;count.offset()));</span>
          for (unsigned i = data-&gt;limit; i--;)
<span class="line-modified">!             write(AbstractHeap(Stack, data-&gt;start.offset() + static_cast&lt;int&gt;(i)));</span>
          return;
      }
  
      case GetByVal: {
          ArrayMode mode = node-&gt;arrayMode();
<span class="line-new-header">--- 764,81 ---</span>
          read(GetterSetter_setter);
          def(HeapLocation(SetterLoc, GetterSetter_setter, node-&gt;child1()), LazyNode(node));
          return;
  
      case GetCallee:
<span class="line-modified">!         read(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee)));</span>
<span class="line-modified">!         def(HeapLocation(StackLoc, AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee))), LazyNode(node));</span>
          return;
  
      case SetCallee:
<span class="line-modified">!         write(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee)));</span>
          return;
  
      case GetArgumentCountIncludingThis: {
<span class="line-modified">!         auto heap = AbstractHeap(Stack, remapOperand(node-&gt;argumentsInlineCallFrame(), VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
          read(heap);
          def(HeapLocation(StackPayloadLoc, heap), LazyNode(node));
          return;
      }
  
      case SetArgumentCountIncludingThis:
<span class="line-modified">!         write(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
          return;
  
      case GetRestLength:
          read(Stack);
          return;
  
      case GetLocal:
<span class="line-modified">!         read(AbstractHeap(Stack, node-&gt;operand()));</span>
<span class="line-modified">!         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;operand())), LazyNode(node));</span>
          return;
  
      case SetLocal:
<span class="line-modified">!         write(AbstractHeap(Stack, node-&gt;operand()));</span>
<span class="line-modified">!         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;operand())), LazyNode(node-&gt;child1().node()));</span>
          return;
  
      case GetStack: {
<span class="line-modified">!         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;operand);</span>
          read(heap);
          def(HeapLocation(StackLoc, heap), LazyNode(node));
          return;
      }
  
      case PutStack: {
<span class="line-modified">!         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;operand);</span>
          write(heap);
          def(HeapLocation(StackLoc, heap), LazyNode(node-&gt;child1().node()));
          return;
      }
  
<span class="line-added">+     case VarargsLength: {</span>
<span class="line-added">+         read(World);</span>
<span class="line-added">+         write(Heap);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case LoadVarargs: {
          read(World);
          write(Heap);
          LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">!         write(AbstractHeap(Stack, data-&gt;count));</span>
          for (unsigned i = data-&gt;limit; i--;)
<span class="line-modified">!             write(AbstractHeap(Stack, data-&gt;start + static_cast&lt;int&gt;(i)));</span>
          return;
      }
  
      case ForwardVarargs: {
          // We could be way more precise here.
          read(Stack);
  
          LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">!         write(AbstractHeap(Stack, data-&gt;count));</span>
          for (unsigned i = data-&gt;limit; i--;)
<span class="line-modified">!             write(AbstractHeap(Stack, data-&gt;start + static_cast&lt;int&gt;(i)));</span>
          return;
      }
  
      case GetByVal: {
          ArrayMode mode = node-&gt;arrayMode();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1016,12 ***</span>
                  write(Heap);
                  return;
              }
              read(Butterfly_publicLength);
              read(Butterfly_vectorLength);
<span class="line-modified">!             read(ArrayStorageProperties);</span>
<span class="line-modified">!             write(ArrayStorageProperties);</span>
              if (node-&gt;arrayMode().mayStoreToHole())
                  write(Butterfly_publicLength);
              return;
  
          case Array::SlowPutArrayStorage:
<span class="line-new-header">--- 1046,12 ---</span>
                  write(Heap);
                  return;
              }
              read(Butterfly_publicLength);
              read(Butterfly_vectorLength);
<span class="line-modified">!             read(IndexedArrayStorageProperties);</span>
<span class="line-modified">!             write(IndexedArrayStorageProperties);</span>
              if (node-&gt;arrayMode().mayStoreToHole())
                  write(Butterfly_publicLength);
              return;
  
          case Array::SlowPutArrayStorage:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1030,12 ***</span>
                  write(Heap);
                  return;
              }
              read(Butterfly_publicLength);
              read(Butterfly_vectorLength);
<span class="line-modified">!             read(ArrayStorageProperties);</span>
<span class="line-modified">!             write(ArrayStorageProperties);</span>
              return;
  
          case Array::Int8Array:
          case Array::Int16Array:
          case Array::Int32Array:
<span class="line-new-header">--- 1060,12 ---</span>
                  write(Heap);
                  return;
              }
              read(Butterfly_publicLength);
              read(Butterfly_vectorLength);
<span class="line-modified">!             read(IndexedArrayStorageProperties);</span>
<span class="line-modified">!             write(IndexedArrayStorageProperties);</span>
              return;
  
          case Array::Int8Array:
          case Array::Int16Array:
          case Array::Int32Array:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1064,16 ***</span>
      case CheckStructureOrEmpty:
      case CheckStructure:
          read(JSCell_structureID);
          return;
  
      case CheckArray:
          read(JSCell_indexingType);
<span class="line-removed">-         read(JSCell_typeInfoType);</span>
          read(JSCell_structureID);
          return;
  
      case CheckTypeInfoFlags:
          read(JSCell_typeInfoFlags);
          def(HeapLocation(CheckTypeInfoFlagsLoc, JSCell_typeInfoFlags, node-&gt;child1()), LazyNode(node));
          return;
  
<span class="line-new-header">--- 1094,20 ---</span>
      case CheckStructureOrEmpty:
      case CheckStructure:
          read(JSCell_structureID);
          return;
  
<span class="line-added">+     case CheckArrayOrEmpty:</span>
      case CheckArray:
          read(JSCell_indexingType);
          read(JSCell_structureID);
          return;
  
<span class="line-added">+     case CheckNeutered:</span>
<span class="line-added">+         read(MiscFields);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      case CheckTypeInfoFlags:
          read(JSCell_typeInfoFlags);
          def(HeapLocation(CheckTypeInfoFlagsLoc, JSCell_typeInfoFlags, node-&gt;child1()), LazyNode(node));
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1094,11 ***</span>
          return;
  
      case PutStructure:
          read(JSObject_butterfly);
          write(JSCell_structureID);
<span class="line-removed">-         write(JSCell_typeInfoType);</span>
          write(JSCell_typeInfoFlags);
          write(JSCell_indexingType);
          return;
  
      case AllocatePropertyStorage:
<span class="line-new-header">--- 1128,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1314,10 ***</span>
<span class="line-new-header">--- 1347,24 ---</span>
      case PutClosureVar:
          write(AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()));
          def(HeapLocation(ClosureVariableLoc, AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()), node-&gt;child1()), LazyNode(node-&gt;child2().node()));
          return;
  
<span class="line-added">+     case GetInternalField: {</span>
<span class="line-added">+         AbstractHeap heap(JSInternalFields, node-&gt;internalFieldIndex());</span>
<span class="line-added">+         read(heap);</span>
<span class="line-added">+         def(HeapLocation(InternalFieldObjectLoc, heap, node-&gt;child1()), LazyNode(node));</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case PutInternalField: {</span>
<span class="line-added">+         AbstractHeap heap(JSInternalFields, node-&gt;internalFieldIndex());</span>
<span class="line-added">+         write(heap);</span>
<span class="line-added">+         def(HeapLocation(InternalFieldObjectLoc, heap, node-&gt;child1()), LazyNode(node-&gt;child2().node()));</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case GetRegExpObjectLastIndex:
          read(RegExpObject_lastIndex);
          def(HeapLocation(RegExpObjectLastIndexLoc, RegExpObject_lastIndex, node-&gt;child1()), LazyNode(node));
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1381,12 ***</span>
              DFG_CRASH(graph, node, &quot;Bad use kind&quot;);
          }
          break;
  
      case NewArrayWithSpread: {
<span class="line-removed">-         // This also reads from JSFixedArray&#39;s data store, but we don&#39;t have any way of describing that yet.</span>
          read(HeapObjectCount);
          for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
              Node* child = graph.varArgChild(node, i).node();
              if (child-&gt;op() == PhantomSpread) {
                  read(Stack);
                  break;
<span class="line-new-header">--- 1428,12 ---</span>
              DFG_CRASH(graph, node, &quot;Bad use kind&quot;);
          }
          break;
  
      case NewArrayWithSpread: {
          read(HeapObjectCount);
<span class="line-added">+         // This appears to read nothing because it&#39;s only reading immutable butterfly data.</span>
          for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
              Node* child = graph.varArgChild(node, i).node();
              if (child-&gt;op() == PhantomSpread) {
                  read(Stack);
                  break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1547,19 ***</span>
<span class="line-new-header">--- 1594,25 ---</span>
              return;
          }
      }
  
      case NewObject:
<span class="line-added">+     case NewPromise:</span>
<span class="line-added">+     case NewGenerator:</span>
<span class="line-added">+     case NewAsyncGenerator:</span>
<span class="line-added">+     case NewArrayIterator:</span>
      case NewRegexp:
      case NewSymbol:
      case NewStringObject:
      case PhantomNewObject:
      case MaterializeNewObject:
      case PhantomNewFunction:
      case PhantomNewGeneratorFunction:
      case PhantomNewAsyncFunction:
      case PhantomNewAsyncGeneratorFunction:
<span class="line-added">+     case PhantomNewArrayIterator:</span>
<span class="line-added">+     case MaterializeNewInternalFieldObject:</span>
      case PhantomCreateActivation:
      case MaterializeCreateActivation:
      case PhantomNewRegexp:
          read(HeapObjectCount);
          write(HeapObjectCount);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1789,10 ***</span>
<span class="line-new-header">--- 1842,17 ---</span>
          return;
  
      case NumberToStringWithValidRadixConstant:
          def(PureValue(node, node-&gt;validRadixConstant()));
          return;
<span class="line-added">+ </span>
<span class="line-added">+     case DateGetTime:</span>
<span class="line-added">+     case DateGetInt32OrNaN: {</span>
<span class="line-added">+         read(JSDateFields);</span>
<span class="line-added">+         def(HeapLocation(DateFieldLoc, AbstractHeap(JSDateFields, static_cast&lt;uint64_t&gt;(node-&gt;intrinsic())), node-&gt;child1()), LazyNode(node));</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
  
      case DataViewGetFloat:
      case DataViewGetInt: {
          read(MiscFields);
          read(TypedArrayProperties);
</pre>
<center><a href="DFGCapabilities.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGClobbersExitState.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
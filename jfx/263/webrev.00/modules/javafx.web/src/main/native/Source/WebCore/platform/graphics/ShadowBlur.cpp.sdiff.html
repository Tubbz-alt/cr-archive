<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ShadowBlur.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RoundedRect.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TrackPrivateBase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ShadowBlur.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 44 enum {
 45     LeftLobe = 0,
 46     RightLobe = 1
 47 };
 48 
 49 #if USE(CG)
 50 static inline int roundUpToMultipleOf32(int d)
 51 {
 52     return (1 + (d &gt;&gt; 5)) &lt;&lt; 5;
 53 }
 54 
 55 // ShadowBlur needs a scratch image as the buffer for the blur filter.
 56 // Instead of creating and destroying the buffer for every operation,
 57 // we create a buffer which will be automatically purged via a timer.
 58 class ScratchBuffer {
 59     WTF_MAKE_FAST_ALLOCATED;
 60 public:
 61     ScratchBuffer()
 62         : m_purgeTimer(*this, &amp;ScratchBuffer::clearScratchBuffer)
 63         , m_lastWasInset(false)
<span class="line-modified"> 64 #if !ASSERT_DISABLED</span>
 65         , m_bufferInUse(false)
 66 #endif
 67     {
 68     }
 69 
 70     ImageBuffer* getScratchBuffer(const IntSize&amp; size)
 71     {
 72         ASSERT(!m_bufferInUse);
<span class="line-modified"> 73 #if !ASSERT_DISABLED</span>
 74         m_bufferInUse = true;
 75 #endif
 76         // We do not need to recreate the buffer if the current buffer is large enough.
 77         if (m_imageBuffer &amp;&amp; m_imageBuffer-&gt;logicalSize().width() &gt;= size.width() &amp;&amp; m_imageBuffer-&gt;logicalSize().height() &gt;= size.height())
 78             return m_imageBuffer.get();
 79 
 80         // Round to the nearest 32 pixels so we do not grow the buffer for similar sized requests.
 81         IntSize roundedSize(roundUpToMultipleOf32(size.width()), roundUpToMultipleOf32(size.height()));
 82 
 83         clearScratchBuffer();
 84 
 85         // ShadowBlur is not used with accelerated drawing, so it&#39;s OK to make an unconditionally unaccelerated buffer.
<span class="line-modified"> 86         m_imageBuffer = ImageBuffer::create(roundedSize, Unaccelerated, 1);</span>
 87         return m_imageBuffer.get();
 88     }
 89 
 90     bool setCachedShadowValues(const FloatSize&amp; radius, const Color&amp; color, const FloatRect&amp; shadowRect, const FloatRoundedRect::Radii&amp; radii, const FloatSize&amp; layerSize)
 91     {
 92         if (!m_lastWasInset &amp;&amp; m_lastRadius == radius &amp;&amp; m_lastColor == color &amp;&amp; m_lastShadowRect == shadowRect &amp;&amp;  m_lastRadii == radii &amp;&amp; m_lastLayerSize == layerSize)
 93             return false;
 94 
 95         m_lastWasInset = false;
 96         m_lastRadius = radius;
 97         m_lastColor = color;
 98         m_lastShadowRect = shadowRect;
 99         m_lastRadii = radii;
100         m_lastLayerSize = layerSize;
101 
102         return true;
103     }
104 
105     bool setCachedInsetShadowValues(const FloatSize&amp; radius, const Color&amp; color, const FloatRect&amp; bounds, const FloatRect&amp; shadowRect, const FloatRoundedRect::Radii&amp; radii)
106     {
107         if (m_lastWasInset &amp;&amp; m_lastRadius == radius &amp;&amp; m_lastColor == color &amp;&amp; m_lastInsetBounds == bounds &amp;&amp; shadowRect == m_lastShadowRect &amp;&amp; radii == m_lastRadii)
108             return false;
109 
110         m_lastWasInset = true;
111         m_lastInsetBounds = bounds;
112         m_lastRadius = radius;
113         m_lastColor = color;
114         m_lastShadowRect = shadowRect;
115         m_lastRadii = radii;
116 
117         return true;
118     }
119 
120     void scheduleScratchBufferPurge()
121     {
<span class="line-modified">122 #if !ASSERT_DISABLED</span>
123         m_bufferInUse = false;
124 #endif
125         if (m_purgeTimer.isActive())
126             m_purgeTimer.stop();
127 
128         const Seconds scratchBufferPurgeInterval { 2_s };
129         m_purgeTimer.startOneShot(scratchBufferPurgeInterval);
130     }
131 
132     static ScratchBuffer&amp; singleton();
133 
134 private:
135     void clearScratchBuffer()
136     {
137         m_imageBuffer = nullptr;
138         m_lastRadius = FloatSize();
139         m_lastLayerSize = FloatSize();
140     }
141 
142     std::unique_ptr&lt;ImageBuffer&gt; m_imageBuffer;
143     Timer m_purgeTimer;
144 
145     FloatRect m_lastInsetBounds;
146     FloatRect m_lastShadowRect;
147     FloatRoundedRect::Radii m_lastRadii;
148     Color m_lastColor;
149     FloatSize m_lastRadius;
150     bool m_lastWasInset;
151     FloatSize m_lastLayerSize;
152 
<span class="line-modified">153 #if !ASSERT_DISABLED</span>
154     bool m_bufferInUse;
155 #endif
156 };
157 
158 ScratchBuffer&amp; ScratchBuffer::singleton()
159 {
160     static NeverDestroyed&lt;ScratchBuffer&gt; scratchBuffer;
161     return scratchBuffer;
162 }
163 
164 static float radiusToLegacyRadius(float radius)
165 {
166     return radius &gt; 8 ? 8 + 4 * sqrt((radius - 8) / 2) : radius;
167 }
168 #endif
169 
170 static const int templateSideLength = 1;
171 
172 ShadowBlur::ShadowBlur() = default;
173 
</pre>
<hr />
<pre>
576     // https://bugs.webkit.org/show_bug.cgi?id=45042
577     if (!transform.preservesAxisAlignment() || m_type != BlurShadow)
578         canUseTilingTechnique = false;
579 
580     IntSize edgeSize = blurredEdgeSize();
581     IntSize templateSize = this-&gt;templateSize(edgeSize, holeRect.radii());
582     const FloatRect&amp; hRect = holeRect.rect();
583 
584     if (templateSize.width() &gt; hRect.width() || templateSize.height() &gt; hRect.height()
585         || (templateSize.width() * templateSize.height() &gt; hRect.width() * hRect.height()))
586         canUseTilingTechnique = false;
587 
588     if (canUseTilingTechnique)
589         drawInsetShadowWithTiling(transform, fullRect, holeRect, templateSize, edgeSize, drawImage, fillRectWithHole);
590     else
591         drawInsetShadowWithoutTiling(transform, fullRect, holeRect, *layerImageProperties, drawBuffer);
592 }
593 
594 void ShadowBlur::drawRectShadowWithoutTiling(const AffineTransform&amp;, const FloatRoundedRect&amp; shadowedRect, const LayerImageProperties&amp; layerImageProperties, const DrawBufferCallback&amp; drawBuffer)
595 {
<span class="line-modified">596     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), Unaccelerated, 1);</span>
597     if (!layerImage)
598         return;
599 
600     GraphicsContext&amp; shadowContext = layerImage-&gt;context();
601     GraphicsContextStateSaver stateSaver(shadowContext);
602     shadowContext.setFillColor(Color::black);
603 
604     {
605         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
606         GraphicsContextStateSaver stateSaver(shadowContext);
607         shadowContext.translate(layerImageProperties.layerContextTranslation);
608         shadowContext.setFillColor(Color::black);
609         if (shadowedRect.radii().isZero())
610             shadowContext.fillRect(shadowedRect.rect());
611         else {
612             Path path;
613             path.addRoundedRect(shadowedRect);
614             shadowContext.fillPath(path);
615         }
616 
617         blurShadowBuffer(*layerImage, expandedIntSize(layerImageProperties.layerSize));
618     }
619     drawBuffer(*layerImage, layerImageProperties.layerOrigin, layerImageProperties.layerSize);
620 }
621 
622 void ShadowBlur::drawInsetShadowWithoutTiling(const AffineTransform&amp;, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const LayerImageProperties&amp; layerImageProperties, const DrawBufferCallback&amp; drawBuffer)
623 {
<span class="line-modified">624     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), Unaccelerated, 1);</span>
625     if (!layerImage)
626         return;
627 
628     {
629         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
630         GraphicsContextStateSaver stateSaver(shadowContext);
631         shadowContext.translate(layerImageProperties.layerContextTranslation);
632 
633         Path path;
634         path.addRect(fullRect);
635         if (holeRect.radii().isZero())
636             path.addRect(holeRect.rect());
637         else
638             path.addRoundedRect(holeRect);
639 
640         shadowContext.setFillRule(WindRule::EvenOdd);
641         shadowContext.setFillColor(Color::black);
642         shadowContext.fillPath(path);
643 
644         blurShadowBuffer(*layerImage, expandedIntSize(layerImageProperties.layerSize));
</pre>
<hr />
<pre>
668        -----------
669         4 |   | 5
670        -----------
671         6 | 7 | 8
672 
673      The corners are directly copied from the template rectangle to the
674      real one and the side tiles are 1 pixel width, we use them as
675      tiles to cover the destination side. The corner tiles are bigger
676      than just the side of the rounded corner, we need to increase it
677      because the modifications caused by the corner over the blur
678      effect. We fill the central or outer part with solid color to complete
679      the shadow.
680  */
681 
682 void ShadowBlur::drawRectShadowWithTiling(const AffineTransform&amp; transform, const FloatRoundedRect&amp; shadowedRect, const IntSize&amp; templateSize, const IntSize&amp; edgeSize, const DrawImageCallback&amp; drawImage, const FillRectCallback&amp; fillRect, const LayerImageProperties&amp; layerImageProperties)
683 {
684 #if USE(CG)
685     auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);
686 #else
687     UNUSED_PARAM(layerImageProperties);
<span class="line-modified">688     auto layerImageBuffer = ImageBuffer::create(templateSize, Unaccelerated, 1);</span>
689     auto* layerImage = layerImageBuffer.get();
690 #endif
691 
692     if (!layerImage)
693         return;
694 
695     FloatRect templateShadow = FloatRect(edgeSize.width(), edgeSize.height(), templateSize.width() - 2 * edgeSize.width(), templateSize.height() - 2 * edgeSize.height());
696 
697     bool redrawNeeded = true;
698 #if USE(CG)
699     // Only redraw in the scratch buffer if its cached contents don&#39;t match our needs
700     redrawNeeded = ScratchBuffer::singleton().setCachedShadowValues(m_blurRadius, m_color, templateShadow, shadowedRect.radii(), layerImageProperties.layerSize);
701 #endif
702 
703     if (redrawNeeded) {
704         // Draw shadow into the ImageBuffer.
705         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
706         GraphicsContextStateSaver shadowStateSaver(shadowContext);
707 
708         shadowContext.clearRect(FloatRect(0, 0, templateSize.width(), templateSize.height()));
</pre>
<hr />
<pre>
722     if (shadowsIgnoreTransforms())
723         offset.scale(1 / transform.xScale(), 1 / transform.yScale());
724 
725     FloatRect shadowBounds = shadowedRect.rect();
726     shadowBounds.move(offset);
727     shadowBounds.inflateX(edgeSize.width());
728     shadowBounds.inflateY(edgeSize.height());
729 
730     drawLayerPiecesAndFillCenter(*layerImage, shadowBounds, shadowedRect.radii(), edgeSize, templateSize, drawImage, fillRect);
731 
732 #if USE(CG)
733     ScratchBuffer::singleton().scheduleScratchBufferPurge();
734 #endif
735 }
736 
737 void ShadowBlur::drawInsetShadowWithTiling(const AffineTransform&amp; transform, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const IntSize&amp; templateSize, const IntSize&amp; edgeSize, const DrawImageCallback&amp; drawImage, const FillRectWithHoleCallback&amp; fillRectWithHole)
738 {
739 #if USE(CG)
740     auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);
741 #else
<span class="line-modified">742     auto layerImageBuffer = ImageBuffer::create(templateSize, Unaccelerated, 1);</span>
743     auto* layerImage = layerImageBuffer.get();
744 #endif
745 
746     if (!layerImage)
747         return;
748 
749     // Draw the rectangle with hole.
750     FloatRect templateBounds(0, 0, templateSize.width(), templateSize.height());
751     FloatRect templateHole = FloatRect(edgeSize.width(), edgeSize.height(), templateSize.width() - 2 * edgeSize.width(), templateSize.height() - 2 * edgeSize.height());
752 
753     bool redrawNeeded = true;
754 #if USE(CG)
755     // Only redraw in the scratch buffer if its cached contents don&#39;t match our needs
756     redrawNeeded = ScratchBuffer::singleton().setCachedInsetShadowValues(m_blurRadius, m_color, templateBounds, templateHole, holeRect.radii());
757 #endif
758 
759     if (redrawNeeded) {
760         // Draw shadow into a new ImageBuffer.
761         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
762         GraphicsContextStateSaver shadowStateSaver(shadowContext);
</pre>
<hr />
<pre>
882 {
883     if (m_type != BlurShadow)
884         return;
885 
886     IntRect blurRect(IntPoint(), templateSize);
887     auto layerData = layerImage.getUnmultipliedImageData(blurRect);
888     if (!layerData)
889         return;
890 
891     blurLayerImage(layerData-&gt;data(), blurRect.size(), blurRect.width() * 4);
892     layerImage.putByteArray(*layerData, AlphaPremultiplication::Unpremultiplied, blurRect.size(), blurRect, { });
893 }
894 
895 void ShadowBlur::blurAndColorShadowBuffer(ImageBuffer&amp; layerImage, const IntSize&amp; templateSize)
896 {
897     blurShadowBuffer(layerImage, templateSize);
898 
899     // Mask the image with the shadow color.
900     GraphicsContext&amp; shadowContext = layerImage.context();
901     GraphicsContextStateSaver stateSaver(shadowContext);
<span class="line-modified">902     shadowContext.setCompositeOperation(CompositeSourceIn);</span>
903     shadowContext.setFillColor(m_color);
904     shadowContext.fillRect(FloatRect(0, 0, templateSize.width(), templateSize.height()));
905 }
906 
907 void ShadowBlur::drawShadowLayer(const AffineTransform&amp; transform, const IntRect&amp; clipBounds, const FloatRect&amp; layerArea, const DrawShadowCallback&amp; drawShadow, const DrawBufferCallback&amp; drawBuffer)
908 {
909     auto layerImageProperties = calculateLayerBoundingRect(transform, layerArea, clipBounds);
910     if (!layerImageProperties)
911         return;
912 
913     adjustBlurRadius(transform);
914 
<span class="line-modified">915     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties-&gt;layerSize), Unaccelerated, 1);</span>
916     if (!layerImage)
917         return;
918 
919     {
920         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
921         GraphicsContextStateSaver stateSaver(shadowContext);
922         shadowContext.translate(layerImageProperties-&gt;layerContextTranslation);
923         drawShadow(shadowContext);
924     }
925 
926     blurAndColorShadowBuffer(*layerImage, expandedIntSize(layerImageProperties-&gt;layerSize));
927     drawBuffer(*layerImage, layerImageProperties-&gt;layerOrigin, layerImageProperties-&gt;layerSize);
928 }
929 
930 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 44 enum {
 45     LeftLobe = 0,
 46     RightLobe = 1
 47 };
 48 
 49 #if USE(CG)
 50 static inline int roundUpToMultipleOf32(int d)
 51 {
 52     return (1 + (d &gt;&gt; 5)) &lt;&lt; 5;
 53 }
 54 
 55 // ShadowBlur needs a scratch image as the buffer for the blur filter.
 56 // Instead of creating and destroying the buffer for every operation,
 57 // we create a buffer which will be automatically purged via a timer.
 58 class ScratchBuffer {
 59     WTF_MAKE_FAST_ALLOCATED;
 60 public:
 61     ScratchBuffer()
 62         : m_purgeTimer(*this, &amp;ScratchBuffer::clearScratchBuffer)
 63         , m_lastWasInset(false)
<span class="line-modified"> 64 #if ASSERT_ENABLED</span>
 65         , m_bufferInUse(false)
 66 #endif
 67     {
 68     }
 69 
 70     ImageBuffer* getScratchBuffer(const IntSize&amp; size)
 71     {
 72         ASSERT(!m_bufferInUse);
<span class="line-modified"> 73 #if ASSERT_ENABLED</span>
 74         m_bufferInUse = true;
 75 #endif
 76         // We do not need to recreate the buffer if the current buffer is large enough.
 77         if (m_imageBuffer &amp;&amp; m_imageBuffer-&gt;logicalSize().width() &gt;= size.width() &amp;&amp; m_imageBuffer-&gt;logicalSize().height() &gt;= size.height())
 78             return m_imageBuffer.get();
 79 
 80         // Round to the nearest 32 pixels so we do not grow the buffer for similar sized requests.
 81         IntSize roundedSize(roundUpToMultipleOf32(size.width()), roundUpToMultipleOf32(size.height()));
 82 
 83         clearScratchBuffer();
 84 
 85         // ShadowBlur is not used with accelerated drawing, so it&#39;s OK to make an unconditionally unaccelerated buffer.
<span class="line-modified"> 86         m_imageBuffer = ImageBuffer::create(roundedSize, RenderingMode::Unaccelerated, 1);</span>
 87         return m_imageBuffer.get();
 88     }
 89 
 90     bool setCachedShadowValues(const FloatSize&amp; radius, const Color&amp; color, const FloatRect&amp; shadowRect, const FloatRoundedRect::Radii&amp; radii, const FloatSize&amp; layerSize)
 91     {
 92         if (!m_lastWasInset &amp;&amp; m_lastRadius == radius &amp;&amp; m_lastColor == color &amp;&amp; m_lastShadowRect == shadowRect &amp;&amp;  m_lastRadii == radii &amp;&amp; m_lastLayerSize == layerSize)
 93             return false;
 94 
 95         m_lastWasInset = false;
 96         m_lastRadius = radius;
 97         m_lastColor = color;
 98         m_lastShadowRect = shadowRect;
 99         m_lastRadii = radii;
100         m_lastLayerSize = layerSize;
101 
102         return true;
103     }
104 
105     bool setCachedInsetShadowValues(const FloatSize&amp; radius, const Color&amp; color, const FloatRect&amp; bounds, const FloatRect&amp; shadowRect, const FloatRoundedRect::Radii&amp; radii)
106     {
107         if (m_lastWasInset &amp;&amp; m_lastRadius == radius &amp;&amp; m_lastColor == color &amp;&amp; m_lastInsetBounds == bounds &amp;&amp; shadowRect == m_lastShadowRect &amp;&amp; radii == m_lastRadii)
108             return false;
109 
110         m_lastWasInset = true;
111         m_lastInsetBounds = bounds;
112         m_lastRadius = radius;
113         m_lastColor = color;
114         m_lastShadowRect = shadowRect;
115         m_lastRadii = radii;
116 
117         return true;
118     }
119 
120     void scheduleScratchBufferPurge()
121     {
<span class="line-modified">122 #if ASSERT_ENABLED</span>
123         m_bufferInUse = false;
124 #endif
125         if (m_purgeTimer.isActive())
126             m_purgeTimer.stop();
127 
128         const Seconds scratchBufferPurgeInterval { 2_s };
129         m_purgeTimer.startOneShot(scratchBufferPurgeInterval);
130     }
131 
132     static ScratchBuffer&amp; singleton();
133 
134 private:
135     void clearScratchBuffer()
136     {
137         m_imageBuffer = nullptr;
138         m_lastRadius = FloatSize();
139         m_lastLayerSize = FloatSize();
140     }
141 
142     std::unique_ptr&lt;ImageBuffer&gt; m_imageBuffer;
143     Timer m_purgeTimer;
144 
145     FloatRect m_lastInsetBounds;
146     FloatRect m_lastShadowRect;
147     FloatRoundedRect::Radii m_lastRadii;
148     Color m_lastColor;
149     FloatSize m_lastRadius;
150     bool m_lastWasInset;
151     FloatSize m_lastLayerSize;
152 
<span class="line-modified">153 #if ASSERT_ENABLED</span>
154     bool m_bufferInUse;
155 #endif
156 };
157 
158 ScratchBuffer&amp; ScratchBuffer::singleton()
159 {
160     static NeverDestroyed&lt;ScratchBuffer&gt; scratchBuffer;
161     return scratchBuffer;
162 }
163 
164 static float radiusToLegacyRadius(float radius)
165 {
166     return radius &gt; 8 ? 8 + 4 * sqrt((radius - 8) / 2) : radius;
167 }
168 #endif
169 
170 static const int templateSideLength = 1;
171 
172 ShadowBlur::ShadowBlur() = default;
173 
</pre>
<hr />
<pre>
576     // https://bugs.webkit.org/show_bug.cgi?id=45042
577     if (!transform.preservesAxisAlignment() || m_type != BlurShadow)
578         canUseTilingTechnique = false;
579 
580     IntSize edgeSize = blurredEdgeSize();
581     IntSize templateSize = this-&gt;templateSize(edgeSize, holeRect.radii());
582     const FloatRect&amp; hRect = holeRect.rect();
583 
584     if (templateSize.width() &gt; hRect.width() || templateSize.height() &gt; hRect.height()
585         || (templateSize.width() * templateSize.height() &gt; hRect.width() * hRect.height()))
586         canUseTilingTechnique = false;
587 
588     if (canUseTilingTechnique)
589         drawInsetShadowWithTiling(transform, fullRect, holeRect, templateSize, edgeSize, drawImage, fillRectWithHole);
590     else
591         drawInsetShadowWithoutTiling(transform, fullRect, holeRect, *layerImageProperties, drawBuffer);
592 }
593 
594 void ShadowBlur::drawRectShadowWithoutTiling(const AffineTransform&amp;, const FloatRoundedRect&amp; shadowedRect, const LayerImageProperties&amp; layerImageProperties, const DrawBufferCallback&amp; drawBuffer)
595 {
<span class="line-modified">596     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), RenderingMode::Unaccelerated, 1);</span>
597     if (!layerImage)
598         return;
599 
600     GraphicsContext&amp; shadowContext = layerImage-&gt;context();
601     GraphicsContextStateSaver stateSaver(shadowContext);
602     shadowContext.setFillColor(Color::black);
603 
604     {
605         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
606         GraphicsContextStateSaver stateSaver(shadowContext);
607         shadowContext.translate(layerImageProperties.layerContextTranslation);
608         shadowContext.setFillColor(Color::black);
609         if (shadowedRect.radii().isZero())
610             shadowContext.fillRect(shadowedRect.rect());
611         else {
612             Path path;
613             path.addRoundedRect(shadowedRect);
614             shadowContext.fillPath(path);
615         }
616 
617         blurShadowBuffer(*layerImage, expandedIntSize(layerImageProperties.layerSize));
618     }
619     drawBuffer(*layerImage, layerImageProperties.layerOrigin, layerImageProperties.layerSize);
620 }
621 
622 void ShadowBlur::drawInsetShadowWithoutTiling(const AffineTransform&amp;, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const LayerImageProperties&amp; layerImageProperties, const DrawBufferCallback&amp; drawBuffer)
623 {
<span class="line-modified">624     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), RenderingMode::Unaccelerated, 1);</span>
625     if (!layerImage)
626         return;
627 
628     {
629         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
630         GraphicsContextStateSaver stateSaver(shadowContext);
631         shadowContext.translate(layerImageProperties.layerContextTranslation);
632 
633         Path path;
634         path.addRect(fullRect);
635         if (holeRect.radii().isZero())
636             path.addRect(holeRect.rect());
637         else
638             path.addRoundedRect(holeRect);
639 
640         shadowContext.setFillRule(WindRule::EvenOdd);
641         shadowContext.setFillColor(Color::black);
642         shadowContext.fillPath(path);
643 
644         blurShadowBuffer(*layerImage, expandedIntSize(layerImageProperties.layerSize));
</pre>
<hr />
<pre>
668        -----------
669         4 |   | 5
670        -----------
671         6 | 7 | 8
672 
673      The corners are directly copied from the template rectangle to the
674      real one and the side tiles are 1 pixel width, we use them as
675      tiles to cover the destination side. The corner tiles are bigger
676      than just the side of the rounded corner, we need to increase it
677      because the modifications caused by the corner over the blur
678      effect. We fill the central or outer part with solid color to complete
679      the shadow.
680  */
681 
682 void ShadowBlur::drawRectShadowWithTiling(const AffineTransform&amp; transform, const FloatRoundedRect&amp; shadowedRect, const IntSize&amp; templateSize, const IntSize&amp; edgeSize, const DrawImageCallback&amp; drawImage, const FillRectCallback&amp; fillRect, const LayerImageProperties&amp; layerImageProperties)
683 {
684 #if USE(CG)
685     auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);
686 #else
687     UNUSED_PARAM(layerImageProperties);
<span class="line-modified">688     auto layerImageBuffer = ImageBuffer::create(templateSize, RenderingMode::Unaccelerated, 1);</span>
689     auto* layerImage = layerImageBuffer.get();
690 #endif
691 
692     if (!layerImage)
693         return;
694 
695     FloatRect templateShadow = FloatRect(edgeSize.width(), edgeSize.height(), templateSize.width() - 2 * edgeSize.width(), templateSize.height() - 2 * edgeSize.height());
696 
697     bool redrawNeeded = true;
698 #if USE(CG)
699     // Only redraw in the scratch buffer if its cached contents don&#39;t match our needs
700     redrawNeeded = ScratchBuffer::singleton().setCachedShadowValues(m_blurRadius, m_color, templateShadow, shadowedRect.radii(), layerImageProperties.layerSize);
701 #endif
702 
703     if (redrawNeeded) {
704         // Draw shadow into the ImageBuffer.
705         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
706         GraphicsContextStateSaver shadowStateSaver(shadowContext);
707 
708         shadowContext.clearRect(FloatRect(0, 0, templateSize.width(), templateSize.height()));
</pre>
<hr />
<pre>
722     if (shadowsIgnoreTransforms())
723         offset.scale(1 / transform.xScale(), 1 / transform.yScale());
724 
725     FloatRect shadowBounds = shadowedRect.rect();
726     shadowBounds.move(offset);
727     shadowBounds.inflateX(edgeSize.width());
728     shadowBounds.inflateY(edgeSize.height());
729 
730     drawLayerPiecesAndFillCenter(*layerImage, shadowBounds, shadowedRect.radii(), edgeSize, templateSize, drawImage, fillRect);
731 
732 #if USE(CG)
733     ScratchBuffer::singleton().scheduleScratchBufferPurge();
734 #endif
735 }
736 
737 void ShadowBlur::drawInsetShadowWithTiling(const AffineTransform&amp; transform, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const IntSize&amp; templateSize, const IntSize&amp; edgeSize, const DrawImageCallback&amp; drawImage, const FillRectWithHoleCallback&amp; fillRectWithHole)
738 {
739 #if USE(CG)
740     auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);
741 #else
<span class="line-modified">742     auto layerImageBuffer = ImageBuffer::create(templateSize, RenderingMode::Unaccelerated, 1);</span>
743     auto* layerImage = layerImageBuffer.get();
744 #endif
745 
746     if (!layerImage)
747         return;
748 
749     // Draw the rectangle with hole.
750     FloatRect templateBounds(0, 0, templateSize.width(), templateSize.height());
751     FloatRect templateHole = FloatRect(edgeSize.width(), edgeSize.height(), templateSize.width() - 2 * edgeSize.width(), templateSize.height() - 2 * edgeSize.height());
752 
753     bool redrawNeeded = true;
754 #if USE(CG)
755     // Only redraw in the scratch buffer if its cached contents don&#39;t match our needs
756     redrawNeeded = ScratchBuffer::singleton().setCachedInsetShadowValues(m_blurRadius, m_color, templateBounds, templateHole, holeRect.radii());
757 #endif
758 
759     if (redrawNeeded) {
760         // Draw shadow into a new ImageBuffer.
761         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
762         GraphicsContextStateSaver shadowStateSaver(shadowContext);
</pre>
<hr />
<pre>
882 {
883     if (m_type != BlurShadow)
884         return;
885 
886     IntRect blurRect(IntPoint(), templateSize);
887     auto layerData = layerImage.getUnmultipliedImageData(blurRect);
888     if (!layerData)
889         return;
890 
891     blurLayerImage(layerData-&gt;data(), blurRect.size(), blurRect.width() * 4);
892     layerImage.putByteArray(*layerData, AlphaPremultiplication::Unpremultiplied, blurRect.size(), blurRect, { });
893 }
894 
895 void ShadowBlur::blurAndColorShadowBuffer(ImageBuffer&amp; layerImage, const IntSize&amp; templateSize)
896 {
897     blurShadowBuffer(layerImage, templateSize);
898 
899     // Mask the image with the shadow color.
900     GraphicsContext&amp; shadowContext = layerImage.context();
901     GraphicsContextStateSaver stateSaver(shadowContext);
<span class="line-modified">902     shadowContext.setCompositeOperation(CompositeOperator::SourceIn);</span>
903     shadowContext.setFillColor(m_color);
904     shadowContext.fillRect(FloatRect(0, 0, templateSize.width(), templateSize.height()));
905 }
906 
907 void ShadowBlur::drawShadowLayer(const AffineTransform&amp; transform, const IntRect&amp; clipBounds, const FloatRect&amp; layerArea, const DrawShadowCallback&amp; drawShadow, const DrawBufferCallback&amp; drawBuffer)
908 {
909     auto layerImageProperties = calculateLayerBoundingRect(transform, layerArea, clipBounds);
910     if (!layerImageProperties)
911         return;
912 
913     adjustBlurRadius(transform);
914 
<span class="line-modified">915     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties-&gt;layerSize), RenderingMode::Unaccelerated, 1);</span>
916     if (!layerImage)
917         return;
918 
919     {
920         GraphicsContext&amp; shadowContext = layerImage-&gt;context();
921         GraphicsContextStateSaver stateSaver(shadowContext);
922         shadowContext.translate(layerImageProperties-&gt;layerContextTranslation);
923         drawShadow(shadowContext);
924     }
925 
926     blurAndColorShadowBuffer(*layerImage, expandedIntSize(layerImageProperties-&gt;layerSize));
927     drawBuffer(*layerImage, layerImageProperties-&gt;layerOrigin, layerImageProperties-&gt;layerSize);
928 }
929 
930 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="RoundedRect.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TrackPrivateBase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
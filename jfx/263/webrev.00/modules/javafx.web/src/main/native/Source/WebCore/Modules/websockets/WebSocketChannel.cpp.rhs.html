<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/websockets/WebSocketChannel.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011, 2012 Google Inc.  All rights reserved.
  3  * Copyright (C) 2018 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;WebSocketChannel.h&quot;
 34 
 35 #include &quot;Blob.h&quot;
 36 #include &quot;ContentRuleListResults.h&quot;
 37 #include &quot;CookieJar.h&quot;
 38 #include &quot;Document.h&quot;
 39 #include &quot;FileError.h&quot;
 40 #include &quot;FileReaderLoader.h&quot;
 41 #include &quot;Frame.h&quot;
 42 #include &quot;FrameLoader.h&quot;
 43 #include &quot;InspectorInstrumentation.h&quot;
 44 #include &quot;Logging.h&quot;
 45 #include &quot;NetworkingContext.h&quot;
 46 #include &quot;Page.h&quot;
 47 #include &quot;ProgressTracker.h&quot;
 48 #include &quot;ResourceRequest.h&quot;
 49 #include &quot;ScriptExecutionContext.h&quot;
 50 #include &quot;SocketProvider.h&quot;
 51 #include &quot;SocketStreamError.h&quot;
 52 #include &quot;SocketStreamHandle.h&quot;
 53 #include &quot;UserContentProvider.h&quot;
 54 #include &quot;WebSocketChannelClient.h&quot;
 55 #include &quot;WebSocketHandshake.h&quot;
 56 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 57 #include &lt;wtf/FastMalloc.h&gt;
 58 #include &lt;wtf/HashMap.h&gt;
 59 #include &lt;wtf/text/CString.h&gt;
 60 #include &lt;wtf/text/StringHash.h&gt;
 61 
 62 namespace WebCore {
 63 
 64 const Seconds TCPMaximumSegmentLifetime { 2_min };
 65 
 66 WebSocketChannel::WebSocketChannel(Document&amp; document, WebSocketChannelClient&amp; client, SocketProvider&amp; provider)
 67     : m_document(makeWeakPtr(document))
 68     , m_client(makeWeakPtr(client))
 69     , m_resumeTimer(*this, &amp;WebSocketChannel::resumeTimerFired)
 70     , m_closingTimer(*this, &amp;WebSocketChannel::closingTimerFired)
 71     , m_socketProvider(provider)
 72 {
 73     if (Page* page = document.page())
 74         m_identifier = page-&gt;progress().createUniqueIdentifier();
 75 
 76     LOG(Network, &quot;WebSocketChannel %p ctor, identifier %u&quot;, this, m_identifier);
 77 }
 78 
 79 WebSocketChannel::~WebSocketChannel()
 80 {
 81     LOG(Network, &quot;WebSocketChannel %p dtor&quot;, this);
 82 }
 83 
 84 WebSocketChannel::ConnectStatus WebSocketChannel::connect(const URL&amp; requestedURL, const String&amp; protocol)
 85 {
 86     LOG(Network, &quot;WebSocketChannel %p connect()&quot;, this);
 87 
 88     auto validatedURL = validateURL(*m_document, requestedURL);
 89     if (!validatedURL)
 90         return ConnectStatus::KO;
 91     ASSERT(!m_handle);
 92     ASSERT(!m_suspended);
 93 
 94     if (validatedURL-&gt;url != requestedURL &amp;&amp; m_client)
 95         m_client-&gt;didUpgradeURL();
 96 
 97     m_allowCookies = validatedURL-&gt;areCookiesAllowed;
 98     String userAgent = m_document-&gt;userAgent(m_document-&gt;url());
 99     String clientOrigin = m_document-&gt;securityOrigin().toString();
100     m_handshake = makeUnique&lt;WebSocketHandshake&gt;(validatedURL-&gt;url, protocol, userAgent, clientOrigin, m_allowCookies);
101     m_handshake-&gt;reset();
102     if (m_deflateFramer.canDeflate())
103         m_handshake-&gt;addExtensionProcessor(m_deflateFramer.createExtensionProcessor());
104     if (m_identifier)
105         InspectorInstrumentation::didCreateWebSocket(m_document.get(), m_identifier, validatedURL-&gt;url);
106 
107     if (Frame* frame = m_document-&gt;frame()) {
108         ref();
109         Page* page = frame-&gt;page();
110         PAL::SessionID sessionID = page ? page-&gt;sessionID() : PAL::SessionID::defaultSessionID();
111         String partition = m_document-&gt;domainForCachePartition();
112         // m_handle = m_socketProvider-&gt;createSocketStreamHandle(m_handshake-&gt;url(), *this, sessionID, partition, frame-&gt;loader().networkingContext());
113         // JDK-8094172: JavaFX needs Page instance
114         m_handle = m_socketProvider-&gt;createSocketStreamHandle(m_handshake-&gt;url(), *this, sessionID, page, partition, frame-&gt;loader().networkingContext());
115     }
116     return ConnectStatus::OK;
117 }
118 
119 Document* WebSocketChannel::document()
120 {
121     return m_document.get();
122 }
123 
124 String WebSocketChannel::subprotocol()
125 {
126     LOG(Network, &quot;WebSocketChannel %p subprotocol()&quot;, this);
127     if (!m_handshake || m_handshake-&gt;mode() != WebSocketHandshake::Connected)
128         return emptyString();
129     String serverProtocol = m_handshake-&gt;serverWebSocketProtocol();
130     if (serverProtocol.isNull())
131         return emptyString();
132     return serverProtocol;
133 }
134 
135 String WebSocketChannel::extensions()
136 {
137     LOG(Network, &quot;WebSocketChannel %p extensions()&quot;, this);
138     if (!m_handshake || m_handshake-&gt;mode() != WebSocketHandshake::Connected)
139         return emptyString();
140     String extensions = m_handshake-&gt;acceptedExtensions();
141     if (extensions.isNull())
142         return emptyString();
143     return extensions;
144 }
145 
146 ThreadableWebSocketChannel::SendResult WebSocketChannel::send(const String&amp; message)
147 {
148     LOG(Network, &quot;WebSocketChannel %p send() Sending String &#39;%s&#39;&quot;, this, message.utf8().data());
149     CString utf8 = message.utf8(StrictConversionReplacingUnpairedSurrogatesWithFFFD);
150     enqueueTextFrame(utf8);
151     processOutgoingFrameQueue();
152     // According to WebSocket API specification, WebSocket.send() should return void instead
153     // of boolean. However, our implementation still returns boolean due to compatibility
154     // concern (see bug 65850).
155     // m_channel-&gt;send() may happen later, thus it&#39;s not always possible to know whether
156     // the message has been sent to the socket successfully. In this case, we have no choice
157     // but to return true.
158     return ThreadableWebSocketChannel::SendSuccess;
159 }
160 
161 ThreadableWebSocketChannel::SendResult WebSocketChannel::send(const ArrayBuffer&amp; binaryData, unsigned byteOffset, unsigned byteLength)
162 {
163     LOG(Network, &quot;WebSocketChannel %p send() Sending ArrayBuffer %p byteOffset=%u byteLength=%u&quot;, this, &amp;binaryData, byteOffset, byteLength);
164     enqueueRawFrame(WebSocketFrame::OpCodeBinary, static_cast&lt;const char*&gt;(binaryData.data()) + byteOffset, byteLength);
165     processOutgoingFrameQueue();
166     return ThreadableWebSocketChannel::SendSuccess;
167 }
168 
169 ThreadableWebSocketChannel::SendResult WebSocketChannel::send(Blob&amp; binaryData)
170 {
171     LOG(Network, &quot;WebSocketChannel %p send() Sending Blob &#39;%s&#39;&quot;, this, binaryData.url().string().utf8().data());
172     enqueueBlobFrame(WebSocketFrame::OpCodeBinary, binaryData);
173     processOutgoingFrameQueue();
174     return ThreadableWebSocketChannel::SendSuccess;
175 }
176 
177 bool WebSocketChannel::send(const char* data, int length)
178 {
179     LOG(Network, &quot;WebSocketChannel %p send() Sending char* data=%p length=%d&quot;, this, data, length);
180     enqueueRawFrame(WebSocketFrame::OpCodeBinary, data, length);
181     processOutgoingFrameQueue();
182     return true;
183 }
184 
185 unsigned WebSocketChannel::bufferedAmount() const
186 {
187     LOG(Network, &quot;WebSocketChannel %p bufferedAmount()&quot;, this);
188     ASSERT(m_handle);
189     ASSERT(!m_suspended);
190     return m_handle-&gt;bufferedAmount();
191 }
192 
193 void WebSocketChannel::close(int code, const String&amp; reason)
194 {
195     LOG(Network, &quot;WebSocketChannel %p close() code=%d reason=&#39;%s&#39;&quot;, this, code, reason.utf8().data());
196     ASSERT(!m_suspended);
197     if (!m_handle)
198         return;
199     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // An attempt to send closing handshake may fail, which will get the channel closed and dereferenced.
200     startClosingHandshake(code, reason);
201     if (m_closing &amp;&amp; !m_closingTimer.isActive())
202         m_closingTimer.startOneShot(TCPMaximumSegmentLifetime * 2);
203 }
204 
205 void WebSocketChannel::fail(const String&amp; reason)
206 {
<a name="1" id="anc1"></a><span class="line-modified">207     RELEASE_LOG(Network, &quot;WebSocketChannel %p fail() reason=&#39;%s&#39;&quot;, this, reason.utf8().data());</span>
208     ASSERT(!m_suspended);
209     if (m_document) {
210         InspectorInstrumentation::didReceiveWebSocketFrameError(m_document.get(), m_identifier, reason);
211 
212         String consoleMessage;
213         if (m_handshake)
214             consoleMessage = makeString(&quot;WebSocket connection to &#39;&quot;, m_handshake-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; failed: &quot;, reason);
215         else
216             consoleMessage = makeString(&quot;WebSocket connection failed: &quot;, reason);
217 
218         m_document-&gt;addConsoleMessage(MessageSource::Network, MessageLevel::Error, consoleMessage);
219     }
220 
221     // Hybi-10 specification explicitly states we must not continue to handle incoming data
222     // once the WebSocket connection is failed (section 7.1.7).
223     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
224     m_shouldDiscardReceivedData = true;
225     if (!m_buffer.isEmpty())
226         skipBuffer(m_buffer.size()); // Save memory.
227     m_deflateFramer.didFail();
228     m_hasContinuousFrame = false;
229     m_continuousFrameData.clear();
230     if (m_client)
231         m_client-&gt;didReceiveMessageError();
232 
233     if (m_handle &amp;&amp; !m_closed)
234         m_handle-&gt;disconnect(); // Will call didCloseSocketStream() but maybe not synchronously.
235 }
236 
237 void WebSocketChannel::disconnect()
238 {
239     LOG(Network, &quot;WebSocketChannel %p disconnect()&quot;, this);
240     if (m_identifier &amp;&amp; m_document)
241         InspectorInstrumentation::didCloseWebSocket(m_document.get(), m_identifier);
242     m_client = nullptr;
243     m_document = nullptr;
244     if (m_handle)
245         m_handle-&gt;disconnect();
246 }
247 
248 void WebSocketChannel::suspend()
249 {
250     m_suspended = true;
251 }
252 
253 void WebSocketChannel::resume()
254 {
255     m_suspended = false;
256     if ((!m_buffer.isEmpty() || m_closed) &amp;&amp; m_client &amp;&amp; !m_resumeTimer.isActive())
257         m_resumeTimer.startOneShot(0_s);
258 }
259 
260 void WebSocketChannel::didOpenSocketStream(SocketStreamHandle&amp; handle)
261 {
262     LOG(Network, &quot;WebSocketChannel %p didOpenSocketStream()&quot;, this);
263     ASSERT(&amp;handle == m_handle);
264     if (!m_document)
265         return;
266     if (m_identifier &amp;&amp; UNLIKELY(InspectorInstrumentation::hasFrontends())) {
267         auto cookieRequestHeaderFieldValue = [document = m_document] (const URL&amp; url) -&gt; String {
268             if (!document || !document-&gt;page())
269                 return { };
270             return document-&gt;page()-&gt;cookieJar().cookieRequestHeaderFieldValue(*document, url);
271         };
272         InspectorInstrumentation::willSendWebSocketHandshakeRequest(m_document.get(), m_identifier, m_handshake-&gt;clientHandshakeRequest(WTFMove(cookieRequestHeaderFieldValue)));
273     }
274     auto handshakeMessage = m_handshake-&gt;clientHandshakeMessage();
275     Optional&lt;CookieRequestHeaderFieldProxy&gt; cookieRequestHeaderFieldProxy;
276     if (m_allowCookies)
277         cookieRequestHeaderFieldProxy = CookieJar::cookieRequestHeaderFieldProxy(*m_document, m_handshake-&gt;httpURLForAuthenticationAndCookies());
278     handle.sendHandshake(WTFMove(handshakeMessage), WTFMove(cookieRequestHeaderFieldProxy), [this, protectedThis = makeRef(*this)] (bool success, bool didAccessSecureCookies) {
279         if (!success)
280             fail(&quot;Failed to send WebSocket handshake.&quot;);
281 
282         if (didAccessSecureCookies &amp;&amp; m_document)
283             m_document-&gt;setSecureCookiesAccessed();
284     });
285 }
286 
287 void WebSocketChannel::didCloseSocketStream(SocketStreamHandle&amp; handle)
288 {
289     LOG(Network, &quot;WebSocketChannel %p didCloseSocketStream()&quot;, this);
290     if (m_identifier &amp;&amp; m_document)
291         InspectorInstrumentation::didCloseWebSocket(m_document.get(), m_identifier);
292     ASSERT_UNUSED(handle, &amp;handle == m_handle || !m_handle);
293     m_closed = true;
294     if (m_closingTimer.isActive())
295         m_closingTimer.stop();
296     if (m_outgoingFrameQueueStatus != OutgoingFrameQueueClosed)
297         abortOutgoingFrameQueue();
298     if (m_handle) {
299         m_unhandledBufferedAmount = m_handle-&gt;bufferedAmount();
300         if (m_suspended)
301             return;
302         WebSocketChannelClient* client = m_client.get();
303         m_client = nullptr;
304         m_document = nullptr;
305         m_handle = nullptr;
306         if (client)
307             client-&gt;didClose(m_unhandledBufferedAmount, m_receivedClosingHandshake ? WebSocketChannelClient::ClosingHandshakeComplete : WebSocketChannelClient::ClosingHandshakeIncomplete, m_closeEventCode, m_closeEventReason);
308     }
309     deref();
310 }
311 
312 void WebSocketChannel::didReceiveSocketStreamData(SocketStreamHandle&amp; handle, const char* data, size_t length)
313 {
314     LOG(Network, &quot;WebSocketChannel %p didReceiveSocketStreamData() Received %zu bytes&quot;, this, length);
315     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
316     ASSERT(&amp;handle == m_handle);
317     if (!m_document) {
318         return;
319     }
320     if (!length) {
321         handle.disconnect();
322         return;
323     }
324     if (!m_client) {
325         m_shouldDiscardReceivedData = true;
326         handle.disconnect();
327         return;
328     }
329     if (m_shouldDiscardReceivedData)
330         return;
331     if (!appendToBuffer(data, length)) {
332         m_shouldDiscardReceivedData = true;
333         fail(&quot;Ran out of memory while receiving WebSocket data.&quot;);
334         return;
335     }
336     while (!m_suspended &amp;&amp; m_client &amp;&amp; !m_buffer.isEmpty()) {
337         if (!processBuffer())
338             break;
339     }
340 }
341 
342 void WebSocketChannel::didFailToReceiveSocketStreamData(SocketStreamHandle&amp; handle)
343 {
344     handle.disconnect();
345 }
346 
347 void WebSocketChannel::didUpdateBufferedAmount(SocketStreamHandle&amp;, size_t bufferedAmount)
348 {
349     if (m_client)
350         m_client-&gt;didUpdateBufferedAmount(bufferedAmount);
351 }
352 
353 void WebSocketChannel::didFailSocketStream(SocketStreamHandle&amp; handle, const SocketStreamError&amp; error)
354 {
355     LOG(Network, &quot;WebSocketChannel %p didFailSocketStream()&quot;, this);
356     ASSERT(&amp;handle == m_handle || !m_handle);
357     if (m_document) {
358         String message;
359         if (error.isNull())
360             message = &quot;WebSocket network error&quot;_s;
361         else if (error.localizedDescription().isNull())
362             message = makeString(&quot;WebSocket network error: error code &quot;, error.errorCode());
363         else
364             message = &quot;WebSocket network error: &quot; + error.localizedDescription();
365         InspectorInstrumentation::didReceiveWebSocketFrameError(m_document.get(), m_identifier, message);
366         m_document-&gt;addConsoleMessage(MessageSource::Network, MessageLevel::Error, message);
<a name="2" id="anc2"></a><span class="line-added">367         LOG_ERROR(&quot;%s&quot;, message.utf8().data());</span>
368     }
369     m_shouldDiscardReceivedData = true;
370     if (m_client)
371         m_client-&gt;didReceiveMessageError();
372     handle.disconnect();
373 }
374 
375 void WebSocketChannel::didStartLoading()
376 {
377     LOG(Network, &quot;WebSocketChannel %p didStartLoading()&quot;, this);
378     ASSERT(m_blobLoader);
379     ASSERT(m_blobLoaderStatus == BlobLoaderStarted);
380 }
381 
382 void WebSocketChannel::didReceiveData()
383 {
384     LOG(Network, &quot;WebSocketChannel %p didReceiveData()&quot;, this);
385     ASSERT(m_blobLoader);
386     ASSERT(m_blobLoaderStatus == BlobLoaderStarted);
387 }
388 
389 void WebSocketChannel::didFinishLoading()
390 {
391     LOG(Network, &quot;WebSocketChannel %p didFinishLoading()&quot;, this);
392     ASSERT(m_blobLoader);
393     ASSERT(m_blobLoaderStatus == BlobLoaderStarted);
394     m_blobLoaderStatus = BlobLoaderFinished;
395     processOutgoingFrameQueue();
396     deref();
397 }
398 
399 void WebSocketChannel::didFail(int errorCode)
400 {
401     LOG(Network, &quot;WebSocketChannel %p didFail() errorCode=%d&quot;, this, errorCode);
402     ASSERT(m_blobLoader);
403     ASSERT(m_blobLoaderStatus == BlobLoaderStarted);
404     m_blobLoader = nullptr;
405     m_blobLoaderStatus = BlobLoaderFailed;
406     fail(makeString(&quot;Failed to load Blob: error code = &quot;, errorCode)); // FIXME: Generate human-friendly reason message.
407     deref();
408 }
409 
410 bool WebSocketChannel::appendToBuffer(const char* data, size_t len)
411 {
412     size_t newBufferSize = m_buffer.size() + len;
413     if (newBufferSize &lt; m_buffer.size()) {
414         LOG(Network, &quot;WebSocketChannel %p appendToBuffer() Buffer overflow (%u bytes already in receive buffer and appending %u bytes)&quot;, this, static_cast&lt;unsigned&gt;(m_buffer.size()), static_cast&lt;unsigned&gt;(len));
415         return false;
416     }
417     m_buffer.append(data, len);
418     return true;
419 }
420 
421 void WebSocketChannel::skipBuffer(size_t len)
422 {
423     ASSERT_WITH_SECURITY_IMPLICATION(len &lt;= m_buffer.size());
424     memmove(m_buffer.data(), m_buffer.data() + len, m_buffer.size() - len);
425     m_buffer.shrink(m_buffer.size() - len);
426 }
427 
428 bool WebSocketChannel::processBuffer()
429 {
430     ASSERT(!m_suspended);
431     ASSERT(m_client);
432     ASSERT(!m_buffer.isEmpty());
433     LOG(Network, &quot;WebSocketChannel %p processBuffer() Receive buffer has %u bytes&quot;, this, static_cast&lt;unsigned&gt;(m_buffer.size()));
434 
435     if (m_shouldDiscardReceivedData)
436         return false;
437 
438     if (m_receivedClosingHandshake) {
439         skipBuffer(m_buffer.size());
440         return false;
441     }
442 
443     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
444 
445     if (m_handshake-&gt;mode() == WebSocketHandshake::Incomplete) {
446         int headerLength = m_handshake-&gt;readServerHandshake(m_buffer.data(), m_buffer.size());
447         if (headerLength &lt;= 0)
448             return false;
449         if (m_handshake-&gt;mode() == WebSocketHandshake::Connected) {
450             if (m_identifier)
451                 InspectorInstrumentation::didReceiveWebSocketHandshakeResponse(m_document.get(), m_identifier, m_handshake-&gt;serverHandshakeResponse());
452             String serverSetCookie = m_handshake-&gt;serverSetCookie();
453             if (!serverSetCookie.isEmpty()) {
454                 if (m_document &amp;&amp; m_document-&gt;page() &amp;&amp; m_document-&gt;page()-&gt;cookieJar().cookiesEnabled(*m_document))
455                     m_document-&gt;page()-&gt;cookieJar().setCookies(*m_document, m_handshake-&gt;httpURLForAuthenticationAndCookies(), serverSetCookie);
456             }
457             LOG(Network, &quot;WebSocketChannel %p Connected&quot;, this);
458             skipBuffer(headerLength);
459             m_client-&gt;didConnect();
460             LOG(Network, &quot;WebSocketChannel %p %u bytes remaining in m_buffer&quot;, this, static_cast&lt;unsigned&gt;(m_buffer.size()));
461             return !m_buffer.isEmpty();
462         }
463         ASSERT(m_handshake-&gt;mode() == WebSocketHandshake::Failed);
464         LOG(Network, &quot;WebSocketChannel %p Connection failed&quot;, this);
465         skipBuffer(headerLength);
466         m_shouldDiscardReceivedData = true;
467         fail(m_handshake-&gt;failureReason());
468         return false;
469     }
470     if (m_handshake-&gt;mode() != WebSocketHandshake::Connected)
471         return false;
472 
473     return processFrame();
474 }
475 
476 void WebSocketChannel::resumeTimerFired()
477 {
478     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
479     while (!m_suspended &amp;&amp; m_client &amp;&amp; !m_buffer.isEmpty())
480         if (!processBuffer())
481             break;
482     if (!m_suspended &amp;&amp; m_client &amp;&amp; m_closed &amp;&amp; m_handle)
483         didCloseSocketStream(*m_handle);
484 }
485 
486 void WebSocketChannel::startClosingHandshake(int code, const String&amp; reason)
487 {
488     LOG(Network, &quot;WebSocketChannel %p startClosingHandshake() code=%d m_receivedClosingHandshake=%d&quot;, this, m_closing, m_receivedClosingHandshake);
489     ASSERT(!m_closed);
490     if (m_closing)
491         return;
492     ASSERT(m_handle);
493 
494     Vector&lt;char&gt; buf;
495     if (!m_receivedClosingHandshake &amp;&amp; code != CloseEventCodeNotSpecified) {
496         unsigned char highByte = code &gt;&gt; 8;
497         unsigned char lowByte = code;
498         buf.append(static_cast&lt;char&gt;(highByte));
499         buf.append(static_cast&lt;char&gt;(lowByte));
500         auto reasonUTF8 = reason.utf8();
501         buf.append(reasonUTF8.data(), reasonUTF8.length());
502     }
503     enqueueRawFrame(WebSocketFrame::OpCodeClose, buf.data(), buf.size());
504     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // An attempt to send closing handshake may fail, which will get the channel closed and dereferenced.
505     processOutgoingFrameQueue();
506 
507     if (m_closed) {
508         // The channel got closed because processOutgoingFrameQueue() failed.
509         return;
510     }
511 
512     m_closing = true;
513     if (m_client)
514         m_client-&gt;didStartClosingHandshake();
515 }
516 
517 void WebSocketChannel::closingTimerFired()
518 {
519     LOG(Network, &quot;WebSocketChannel %p closingTimerFired()&quot;, this);
520     if (m_handle)
521         m_handle-&gt;disconnect();
522 }
523 
524 
525 bool WebSocketChannel::processFrame()
526 {
527     ASSERT(!m_buffer.isEmpty());
528 
529     WebSocketFrame frame;
530     const char* frameEnd;
531     String errorString;
532     WebSocketFrame::ParseFrameResult result = WebSocketFrame::parseFrame(m_buffer.data(), m_buffer.size(), frame, frameEnd, errorString);
533     if (result == WebSocketFrame::FrameIncomplete)
534         return false;
535     if (result == WebSocketFrame::FrameError) {
536         fail(errorString);
537         return false;
538     }
539 
540     ASSERT(m_buffer.data() &lt; frameEnd);
541     ASSERT(frameEnd &lt;= m_buffer.data() + m_buffer.size());
542 
543     auto inflateResult = m_deflateFramer.inflate(frame);
544     if (!inflateResult-&gt;succeeded()) {
545         fail(inflateResult-&gt;failureReason());
546         return false;
547     }
548 
549     // Validate the frame data.
550     if (WebSocketFrame::isReservedOpCode(frame.opCode)) {
551         fail(makeString(&quot;Unrecognized frame opcode: &quot;, static_cast&lt;unsigned&gt;(frame.opCode)));
552         return false;
553     }
554 
555     if (frame.reserved2 || frame.reserved3) {
556         fail(makeString(&quot;One or more reserved bits are on: reserved2 = &quot;, static_cast&lt;unsigned&gt;(frame.reserved2), &quot;, reserved3 = &quot;, static_cast&lt;unsigned&gt;(frame.reserved3)));
557         return false;
558     }
559 
560     if (frame.masked) {
561         fail(&quot;A server must not mask any frames that it sends to the client.&quot;);
562         return false;
563     }
564 
565     // All control frames must not be fragmented.
566     if (WebSocketFrame::isControlOpCode(frame.opCode) &amp;&amp; !frame.final) {
567         fail(makeString(&quot;Received fragmented control frame: opcode = &quot;, static_cast&lt;unsigned&gt;(frame.opCode)));
568         return false;
569     }
570 
571     // All control frames must have a payload of 125 bytes or less, which means the frame must not contain
572     // the &quot;extended payload length&quot; field.
573     if (WebSocketFrame::isControlOpCode(frame.opCode) &amp;&amp; WebSocketFrame::needsExtendedLengthField(frame.payloadLength)) {
574         fail(makeString(&quot;Received control frame having too long payload: &quot;, frame.payloadLength, &quot; bytes&quot;));
575         return false;
576     }
577 
578     // A new data frame is received before the previous continuous frame finishes.
579     // Note that control frames are allowed to come in the middle of continuous frames.
580     if (m_hasContinuousFrame &amp;&amp; frame.opCode != WebSocketFrame::OpCodeContinuation &amp;&amp; !WebSocketFrame::isControlOpCode(frame.opCode)) {
581         fail(&quot;Received new data frame but previous continuous frame is unfinished.&quot;);
582         return false;
583     }
584 
585     InspectorInstrumentation::didReceiveWebSocketFrame(m_document.get(), m_identifier, frame);
586 
587     switch (frame.opCode) {
588     case WebSocketFrame::OpCodeContinuation:
589         // An unexpected continuation frame is received without any leading frame.
590         if (!m_hasContinuousFrame) {
591             fail(&quot;Received unexpected continuation frame.&quot;);
592             return false;
593         }
594         m_continuousFrameData.append(frame.payload, frame.payloadLength);
595         skipBuffer(frameEnd - m_buffer.data());
596         if (frame.final) {
597             // onmessage handler may eventually call the other methods of this channel,
598             // so we should pretend that we have finished to read this frame and
599             // make sure that the member variables are in a consistent state before
600             // the handler is invoked.
601             Vector&lt;uint8_t&gt; continuousFrameData = WTFMove(m_continuousFrameData);
602             m_hasContinuousFrame = false;
603             if (m_continuousFrameOpCode == WebSocketFrame::OpCodeText) {
604                 String message;
605                 if (continuousFrameData.size())
606                     message = String::fromUTF8(continuousFrameData.data(), continuousFrameData.size());
607                 else
608                     message = emptyString();
609                 if (message.isNull())
610                     fail(&quot;Could not decode a text frame as UTF-8.&quot;);
611                 else
612                     m_client-&gt;didReceiveMessage(message);
613             } else if (m_continuousFrameOpCode == WebSocketFrame::OpCodeBinary)
614                 m_client-&gt;didReceiveBinaryData(WTFMove(continuousFrameData));
615         }
616         break;
617 
618     case WebSocketFrame::OpCodeText:
619         if (frame.final) {
620             String message;
621             if (frame.payloadLength)
622                 message = String::fromUTF8(frame.payload, frame.payloadLength);
623             else
624                 message = emptyString();
625             skipBuffer(frameEnd - m_buffer.data());
626             if (message.isNull())
627                 fail(&quot;Could not decode a text frame as UTF-8.&quot;);
628             else
629                 m_client-&gt;didReceiveMessage(message);
630         } else {
631             m_hasContinuousFrame = true;
632             m_continuousFrameOpCode = WebSocketFrame::OpCodeText;
633             ASSERT(m_continuousFrameData.isEmpty());
634             m_continuousFrameData.append(frame.payload, frame.payloadLength);
635             skipBuffer(frameEnd - m_buffer.data());
636         }
637         break;
638 
639     case WebSocketFrame::OpCodeBinary:
640         if (frame.final) {
641             Vector&lt;uint8_t&gt; binaryData(frame.payloadLength);
642             memcpy(binaryData.data(), frame.payload, frame.payloadLength);
643             skipBuffer(frameEnd - m_buffer.data());
644             m_client-&gt;didReceiveBinaryData(WTFMove(binaryData));
645         } else {
646             m_hasContinuousFrame = true;
647             m_continuousFrameOpCode = WebSocketFrame::OpCodeBinary;
648             ASSERT(m_continuousFrameData.isEmpty());
649             m_continuousFrameData.append(frame.payload, frame.payloadLength);
650             skipBuffer(frameEnd - m_buffer.data());
651         }
652         break;
653 
654     case WebSocketFrame::OpCodeClose:
655         if (!frame.payloadLength)
656             m_closeEventCode = CloseEventCodeNoStatusRcvd;
657         else if (frame.payloadLength == 1) {
658             m_closeEventCode = CloseEventCodeAbnormalClosure;
659             fail(&quot;Received a broken close frame containing an invalid size body.&quot;);
660             return false;
661         } else {
662             unsigned char highByte = static_cast&lt;unsigned char&gt;(frame.payload[0]);
663             unsigned char lowByte = static_cast&lt;unsigned char&gt;(frame.payload[1]);
664             m_closeEventCode = highByte &lt;&lt; 8 | lowByte;
665             if (m_closeEventCode == CloseEventCodeNoStatusRcvd || m_closeEventCode == CloseEventCodeAbnormalClosure || m_closeEventCode == CloseEventCodeTLSHandshake) {
666                 m_closeEventCode = CloseEventCodeAbnormalClosure;
667                 fail(&quot;Received a broken close frame containing a reserved status code.&quot;);
668                 return false;
669             }
670         }
671         if (frame.payloadLength &gt;= 3)
672             m_closeEventReason = String::fromUTF8(&amp;frame.payload[2], frame.payloadLength - 2);
673         else
674             m_closeEventReason = emptyString();
675         skipBuffer(frameEnd - m_buffer.data());
676         m_receivedClosingHandshake = true;
677         startClosingHandshake(m_closeEventCode, m_closeEventReason);
678         if (m_closing) {
679             if (m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen)
680                 m_outgoingFrameQueueStatus = OutgoingFrameQueueClosing;
681             processOutgoingFrameQueue();
682         }
683         break;
684 
685     case WebSocketFrame::OpCodePing:
686         enqueueRawFrame(WebSocketFrame::OpCodePong, frame.payload, frame.payloadLength);
687         skipBuffer(frameEnd - m_buffer.data());
688         processOutgoingFrameQueue();
689         break;
690 
691     case WebSocketFrame::OpCodePong:
692         // A server may send a pong in response to our ping, or an unsolicited pong which is not associated with
693         // any specific ping. Either way, there&#39;s nothing to do on receipt of pong.
694         skipBuffer(frameEnd - m_buffer.data());
695         break;
696 
697     default:
698         ASSERT_NOT_REACHED();
699         skipBuffer(frameEnd - m_buffer.data());
700         break;
701     }
702 
703     return !m_buffer.isEmpty();
704 }
705 
706 void WebSocketChannel::enqueueTextFrame(const CString&amp; string)
707 {
708     ASSERT(m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen);
709     auto frame = makeUnique&lt;QueuedFrame&gt;();
710     frame-&gt;opCode = WebSocketFrame::OpCodeText;
711     frame-&gt;frameType = QueuedFrameTypeString;
712     frame-&gt;stringData = string;
713     m_outgoingFrameQueue.append(WTFMove(frame));
714 }
715 
716 void WebSocketChannel::enqueueRawFrame(WebSocketFrame::OpCode opCode, const char* data, size_t dataLength)
717 {
718     ASSERT(m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen);
719     auto frame = makeUnique&lt;QueuedFrame&gt;();
720     frame-&gt;opCode = opCode;
721     frame-&gt;frameType = QueuedFrameTypeVector;
722     frame-&gt;vectorData.resize(dataLength);
723     if (dataLength)
724         memcpy(frame-&gt;vectorData.data(), data, dataLength);
725     m_outgoingFrameQueue.append(WTFMove(frame));
726 }
727 
728 void WebSocketChannel::enqueueBlobFrame(WebSocketFrame::OpCode opCode, Blob&amp; blob)
729 {
730     ASSERT(m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen);
731     auto frame = makeUnique&lt;QueuedFrame&gt;();
732     frame-&gt;opCode = opCode;
733     frame-&gt;frameType = QueuedFrameTypeBlob;
734     frame-&gt;blobData = &amp;blob;
735     m_outgoingFrameQueue.append(WTFMove(frame));
736 }
737 
738 void WebSocketChannel::processOutgoingFrameQueue()
739 {
740     if (m_outgoingFrameQueueStatus == OutgoingFrameQueueClosed)
741         return;
742 
743     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // Any call to fail() will get the channel closed and dereferenced.
744 
745     while (!m_outgoingFrameQueue.isEmpty()) {
746         auto frame = m_outgoingFrameQueue.takeFirst();
747         switch (frame-&gt;frameType) {
748         case QueuedFrameTypeString: {
749             sendFrame(frame-&gt;opCode, frame-&gt;stringData.data(), frame-&gt;stringData.length(), [this, protectedThis = makeRef(*this)] (bool success) {
750                 if (!success)
751                     fail(&quot;Failed to send WebSocket frame.&quot;);
752             });
753             break;
754         }
755 
756         case QueuedFrameTypeVector:
757             sendFrame(frame-&gt;opCode, frame-&gt;vectorData.data(), frame-&gt;vectorData.size(), [this, protectedThis = makeRef(*this)] (bool success) {
758                 if (!success)
759                     fail(&quot;Failed to send WebSocket frame.&quot;);
760             });
761             break;
762 
763         case QueuedFrameTypeBlob: {
764             switch (m_blobLoaderStatus) {
765             case BlobLoaderNotStarted:
766                 ref(); // Will be derefed after didFinishLoading() or didFail().
767                 ASSERT(!m_blobLoader);
768                 ASSERT(frame-&gt;blobData);
769                 m_blobLoader = makeUnique&lt;FileReaderLoader&gt;(FileReaderLoader::ReadAsArrayBuffer, this);
770                 m_blobLoaderStatus = BlobLoaderStarted;
771                 m_blobLoader-&gt;start(m_document.get(), *frame-&gt;blobData);
772                 m_outgoingFrameQueue.prepend(WTFMove(frame));
773                 return;
774 
775             case BlobLoaderStarted:
776             case BlobLoaderFailed:
777                 m_outgoingFrameQueue.prepend(WTFMove(frame));
778                 return;
779 
780             case BlobLoaderFinished: {
781                 RefPtr&lt;ArrayBuffer&gt; result = m_blobLoader-&gt;arrayBufferResult();
782                 m_blobLoader = nullptr;
783                 m_blobLoaderStatus = BlobLoaderNotStarted;
784                 sendFrame(frame-&gt;opCode, static_cast&lt;const char*&gt;(result-&gt;data()), result-&gt;byteLength(), [this, protectedThis = makeRef(*this)] (bool success) {
785                     if (!success)
786                         fail(&quot;Failed to send WebSocket frame.&quot;);
787                 });
788                 break;
789             }
790             }
791             break;
792         }
793 
794         default:
795             ASSERT_NOT_REACHED();
796             break;
797         }
798     }
799 
800     ASSERT(m_outgoingFrameQueue.isEmpty());
801     if (m_outgoingFrameQueueStatus == OutgoingFrameQueueClosing) {
802         m_outgoingFrameQueueStatus = OutgoingFrameQueueClosed;
803         m_handle-&gt;close();
804     }
805 }
806 
807 void WebSocketChannel::abortOutgoingFrameQueue()
808 {
809     m_outgoingFrameQueue.clear();
810     m_outgoingFrameQueueStatus = OutgoingFrameQueueClosed;
811     if (m_blobLoaderStatus == BlobLoaderStarted) {
812         m_blobLoader-&gt;cancel();
813         didFail(FileError::ABORT_ERR);
814     }
815 }
816 
817 void WebSocketChannel::sendFrame(WebSocketFrame::OpCode opCode, const char* data, size_t dataLength, WTF::Function&lt;void(bool)&gt; completionHandler)
818 {
819     ASSERT(m_handle);
820     ASSERT(!m_suspended);
821 
822     WebSocketFrame frame(opCode, true, false, true, data, dataLength);
823     InspectorInstrumentation::didSendWebSocketFrame(m_document.get(), m_identifier, frame);
824 
825     auto deflateResult = m_deflateFramer.deflate(frame);
826     if (!deflateResult-&gt;succeeded()) {
827         fail(deflateResult-&gt;failureReason());
828         return completionHandler(false);
829     }
830 
831     Vector&lt;char&gt; frameData;
832     frame.makeFrameData(frameData);
833 
834     m_handle-&gt;sendData(frameData.data(), frameData.size(), WTFMove(completionHandler));
835 }
836 
837 ResourceRequest WebSocketChannel::clientHandshakeRequest(Function&lt;String(const URL&amp;)&gt;&amp;&amp; cookieRequestHeaderFieldValue)
838 {
839     return m_handshake-&gt;clientHandshakeRequest(WTFMove(cookieRequestHeaderFieldValue));
840 }
841 
842 const ResourceResponse&amp; WebSocketChannel::serverHandshakeResponse() const
843 {
844     return m_handshake-&gt;serverHandshakeResponse();
845 }
846 
847 WebSocketHandshake::Mode WebSocketChannel::handshakeMode() const
848 {
849     return m_handshake-&gt;mode();
850 }
851 
852 } // namespace WebCore
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
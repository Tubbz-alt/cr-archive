<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBoundFunction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSBigInt.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBoundFunction.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBoundFunction.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,125 ***</span>
  
  namespace JSC {
  
  const ClassInfo JSBoundFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSBoundFunction) };
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL boundThisNoArgsFunctionCall(ExecState* exec)</span>
  {
<span class="line-modified">!     JSBoundFunction* boundFunction = jsCast&lt;JSBoundFunction*&gt;(exec-&gt;jsCallee());</span>
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i)</span>
<span class="line-modified">!         args.append(exec-&gt;uncheckedArgument(i));</span>
      RELEASE_ASSERT(!args.hasOverflowed());
  
      JSFunction* targetFunction = jsCast&lt;JSFunction*&gt;(boundFunction-&gt;targetFunction());
      ExecutableBase* executable = targetFunction-&gt;executable();
      if (executable-&gt;hasJITCodeForCall()) {
          // Force the executable to cache its arity entrypoint.
          executable-&gt;entrypointFor(CodeForCall, MustCheckArity);
      }
      CallData callData;
<span class="line-modified">!     CallType callType = getCallData(exec-&gt;vm(), targetFunction, callData);</span>
      ASSERT(callType != CallType::None);
<span class="line-modified">!     return JSValue::encode(call(exec, targetFunction, callType, callData, boundFunction-&gt;boundThis(), args));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL boundFunctionCall(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSBoundFunction* boundFunction = jsCast&lt;JSBoundFunction*&gt;(exec-&gt;jsCallee());</span>
  
<span class="line-modified">!     JSArray* boundArgs = boundFunction-&gt;boundArgs();</span>
  
      MarkedArgumentBuffer args;
      if (boundArgs) {
<span class="line-modified">!         for (unsigned i = 0; i &lt; boundArgs-&gt;length(); ++i)</span>
<span class="line-modified">!             args.append(boundArgs-&gt;getIndexQuickly(i));</span>
      }
<span class="line-modified">!     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i)</span>
<span class="line-modified">!         args.append(exec-&gt;uncheckedArgument(i));</span>
      if (UNLIKELY(args.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return encodedJSValue();
      }
  
      JSObject* targetFunction = boundFunction-&gt;targetFunction();
      CallData callData;
      CallType callType = getCallData(vm, targetFunction, callData);
      ASSERT(callType != CallType::None);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, targetFunction, callType, callData, boundFunction-&gt;boundThis(), args)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL boundThisNoArgsFunctionConstruct(ExecState* exec)</span>
  {
<span class="line-modified">!     JSBoundFunction* boundFunction = jsCast&lt;JSBoundFunction*&gt;(exec-&gt;jsCallee());</span>
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i)</span>
<span class="line-modified">!         args.append(exec-&gt;uncheckedArgument(i));</span>
      RELEASE_ASSERT(!args.hasOverflowed());
  
      JSFunction* targetFunction = jsCast&lt;JSFunction*&gt;(boundFunction-&gt;targetFunction());
      ConstructData constructData;
<span class="line-modified">!     ConstructType constructType = getConstructData(exec-&gt;vm(), targetFunction, constructData);</span>
      ASSERT(constructType != ConstructType::None);
<span class="line-modified">!     return JSValue::encode(construct(exec, targetFunction, constructType, constructData, args));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL boundFunctionConstruct(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSBoundFunction* boundFunction = jsCast&lt;JSBoundFunction*&gt;(exec-&gt;jsCallee());</span>
  
<span class="line-modified">!     JSArray* boundArgs = boundFunction-&gt;boundArgs();</span>
  
      MarkedArgumentBuffer args;
      if (boundArgs) {
<span class="line-modified">!         for (unsigned i = 0; i &lt; boundArgs-&gt;length(); ++i)</span>
<span class="line-modified">!             args.append(boundArgs-&gt;getIndexQuickly(i));</span>
      }
<span class="line-modified">!     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i)</span>
<span class="line-modified">!         args.append(exec-&gt;uncheckedArgument(i));</span>
      if (UNLIKELY(args.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return encodedJSValue();
      }
  
      JSObject* targetFunction = boundFunction-&gt;targetFunction();
      ConstructData constructData;
      ConstructType constructType = getConstructData(vm, targetFunction, constructData);
      ASSERT(constructType != ConstructType::None);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(construct(exec, targetFunction, constructType, constructData, args)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL isBoundFunction(ExecState* exec)</span>
  {
<span class="line-modified">!     return JSValue::encode(JSValue(static_cast&lt;bool&gt;(jsDynamicCast&lt;JSBoundFunction*&gt;(exec-&gt;vm(), exec-&gt;uncheckedArgument(0)))));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL hasInstanceBoundFunction(ExecState* exec)</span>
  {
<span class="line-modified">!     JSBoundFunction* boundObject = jsCast&lt;JSBoundFunction*&gt;(exec-&gt;uncheckedArgument(0));</span>
<span class="line-modified">!     JSValue value = exec-&gt;uncheckedArgument(1);</span>
  
<span class="line-modified">!     return JSValue::encode(jsBoolean(boundObject-&gt;targetFunction()-&gt;hasInstance(exec, value)));</span>
  }
  
<span class="line-modified">! inline Structure* getBoundFunctionStructure(VM&amp; vm, ExecState* exec, JSGlobalObject* globalObject, JSObject* targetFunction)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue prototype = targetFunction-&gt;getPrototype(vm, exec);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      JSFunction* targetJSFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, targetFunction);
  
      // We only cache the structure of the bound function if the bindee is a JSFunction since there
      // isn&#39;t any good place to put the structure on Internal Functions.
      if (targetJSFunction) {
<span class="line-modified">!         Structure* structure = targetJSFunction-&gt;rareData(vm)-&gt;getBoundFunctionStructure();</span>
          if (structure &amp;&amp; structure-&gt;storedPrototype() == prototype &amp;&amp; structure-&gt;globalObject() == globalObject)
              return structure;
      }
  
      Structure* result = globalObject-&gt;boundFunctionStructure();
<span class="line-new-header">--- 33,141 ---</span>
  
  namespace JSC {
  
  const ClassInfo JSBoundFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSBoundFunction) };
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL boundThisNoArgsFunctionCall(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     JSBoundFunction* boundFunction = jsCast&lt;JSBoundFunction*&gt;(callFrame-&gt;jsCallee());</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSImmutableButterfly* boundArgs = boundFunction-&gt;boundArgs();</span>
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     if (boundArgs) {</span>
<span class="line-modified">!         // Starts with 1 since the first one is |this|.</span>
<span class="line-added">+         for (unsigned i = 1; i &lt; boundArgs-&gt;length(); ++i)</span>
<span class="line-added">+             args.append(boundArgs-&gt;get(i));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i)</span>
<span class="line-added">+         args.append(callFrame-&gt;uncheckedArgument(i));</span>
      RELEASE_ASSERT(!args.hasOverflowed());
  
      JSFunction* targetFunction = jsCast&lt;JSFunction*&gt;(boundFunction-&gt;targetFunction());
      ExecutableBase* executable = targetFunction-&gt;executable();
      if (executable-&gt;hasJITCodeForCall()) {
          // Force the executable to cache its arity entrypoint.
          executable-&gt;entrypointFor(CodeForCall, MustCheckArity);
      }
      CallData callData;
<span class="line-modified">!     CallType callType = getCallData(globalObject-&gt;vm(), targetFunction, callData);</span>
      ASSERT(callType != CallType::None);
<span class="line-modified">!     return JSValue::encode(call(globalObject, targetFunction, callType, callData, boundFunction-&gt;boundThis(), args));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL boundFunctionCall(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSBoundFunction* boundFunction = jsCast&lt;JSBoundFunction*&gt;(callFrame-&gt;jsCallee());</span>
  
<span class="line-modified">!     JSImmutableButterfly* boundArgs = boundFunction-&gt;boundArgs();</span>
  
      MarkedArgumentBuffer args;
      if (boundArgs) {
<span class="line-modified">!         // Starts with 1 since the first one is |this|.</span>
<span class="line-modified">!         for (unsigned i = 1; i &lt; boundArgs-&gt;length(); ++i)</span>
<span class="line-added">+             args.append(boundArgs-&gt;get(i));</span>
      }
<span class="line-modified">!     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i)</span>
<span class="line-modified">!         args.append(callFrame-&gt;uncheckedArgument(i));</span>
      if (UNLIKELY(args.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return encodedJSValue();
      }
  
      JSObject* targetFunction = boundFunction-&gt;targetFunction();
      CallData callData;
      CallType callType = getCallData(vm, targetFunction, callData);
      ASSERT(callType != CallType::None);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(call(globalObject, targetFunction, callType, callData, boundFunction-&gt;boundThis(), args)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL boundThisNoArgsFunctionConstruct(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     JSBoundFunction* boundFunction = jsCast&lt;JSBoundFunction*&gt;(callFrame-&gt;jsCallee());</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSImmutableButterfly* boundArgs = boundFunction-&gt;boundArgs();</span>
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     if (boundArgs) {</span>
<span class="line-modified">!         // Starts with 1 since the first one is |this|.</span>
<span class="line-added">+         for (unsigned i = 1; i &lt; boundArgs-&gt;length(); ++i)</span>
<span class="line-added">+             args.append(boundArgs-&gt;get(i));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i)</span>
<span class="line-added">+         args.append(callFrame-&gt;uncheckedArgument(i));</span>
      RELEASE_ASSERT(!args.hasOverflowed());
  
      JSFunction* targetFunction = jsCast&lt;JSFunction*&gt;(boundFunction-&gt;targetFunction());
      ConstructData constructData;
<span class="line-modified">!     ConstructType constructType = getConstructData(globalObject-&gt;vm(), targetFunction, constructData);</span>
      ASSERT(constructType != ConstructType::None);
<span class="line-modified">!     return JSValue::encode(construct(globalObject, targetFunction, constructType, constructData, args));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL boundFunctionConstruct(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSBoundFunction* boundFunction = jsCast&lt;JSBoundFunction*&gt;(callFrame-&gt;jsCallee());</span>
  
<span class="line-modified">!     JSImmutableButterfly* boundArgs = boundFunction-&gt;boundArgs();</span>
  
      MarkedArgumentBuffer args;
      if (boundArgs) {
<span class="line-modified">!         // Starts with 1 since the first one is |this|.</span>
<span class="line-modified">!         for (unsigned i = 1; i &lt; boundArgs-&gt;length(); ++i)</span>
<span class="line-added">+             args.append(boundArgs-&gt;get(i));</span>
      }
<span class="line-modified">!     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i)</span>
<span class="line-modified">!         args.append(callFrame-&gt;uncheckedArgument(i));</span>
      if (UNLIKELY(args.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return encodedJSValue();
      }
  
      JSObject* targetFunction = boundFunction-&gt;targetFunction();
      ConstructData constructData;
      ConstructType constructType = getConstructData(vm, targetFunction, constructData);
      ASSERT(constructType != ConstructType::None);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(construct(globalObject, targetFunction, constructType, constructData, args)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL isBoundFunction(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return JSValue::encode(JSValue(static_cast&lt;bool&gt;(jsDynamicCast&lt;JSBoundFunction*&gt;(globalObject-&gt;vm(), callFrame-&gt;uncheckedArgument(0)))));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL hasInstanceBoundFunction(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     JSBoundFunction* boundObject = jsCast&lt;JSBoundFunction*&gt;(callFrame-&gt;uncheckedArgument(0));</span>
<span class="line-modified">!     JSValue value = callFrame-&gt;uncheckedArgument(1);</span>
  
<span class="line-modified">!     return JSValue::encode(jsBoolean(boundObject-&gt;targetFunction()-&gt;hasInstance(globalObject, value)));</span>
  }
  
<span class="line-modified">! inline Structure* getBoundFunctionStructure(VM&amp; vm, JSGlobalObject* globalObject, JSObject* targetFunction)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue prototype = targetFunction-&gt;getPrototype(vm, globalObject);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      JSFunction* targetJSFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, targetFunction);
  
      // We only cache the structure of the bound function if the bindee is a JSFunction since there
      // isn&#39;t any good place to put the structure on Internal Functions.
      if (targetJSFunction) {
<span class="line-modified">!         Structure* structure = targetJSFunction-&gt;ensureRareData(vm)-&gt;getBoundFunctionStructure();</span>
          if (structure &amp;&amp; structure-&gt;storedPrototype() == prototype &amp;&amp; structure-&gt;globalObject() == globalObject)
              return structure;
      }
  
      Structure* result = globalObject-&gt;boundFunctionStructure();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 164,59 ***</span>
          ASSERT_WITH_SECURITY_IMPLICATION(result-&gt;globalObject() == globalObject);
      } else
          result = Structure::create(vm, globalObject, prototype, result-&gt;typeInfo(), result-&gt;classInfo());
  
      if (targetJSFunction)
<span class="line-modified">!         targetJSFunction-&gt;rareData(vm)-&gt;setBoundFunctionStructure(vm, result);</span>
  
      return result;
  }
  
<span class="line-modified">! JSBoundFunction* JSBoundFunction::create(VM&amp; vm, ExecState* exec, JSGlobalObject* globalObject, JSObject* targetFunction, JSValue boundThis, JSArray* boundArgs, int length, const String&amp; name)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      ConstructData constructData;
      ConstructType constructType = JSC::getConstructData(vm, targetFunction, constructData);
      bool canConstruct = constructType != ConstructType::None;
  
<span class="line-modified">!     bool slowCase = boundArgs || !getJSFunction(targetFunction);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     NativeExecutable* executable = vm.getHostFunction(</span>
<span class="line-removed">-         slowCase ? boundFunctionCall : boundThisNoArgsFunctionCall,</span>
<span class="line-removed">-         slowCase ? NoIntrinsic : BoundThisNoArgsFunctionCallIntrinsic,</span>
<span class="line-removed">-         canConstruct ? (slowCase ? boundFunctionConstruct : boundThisNoArgsFunctionConstruct) : callHostFunctionAsConstructor, nullptr,</span>
<span class="line-removed">-         name);</span>
<span class="line-removed">-     Structure* structure = getBoundFunctionStructure(vm, exec, globalObject, targetFunction);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     JSBoundFunction* function = new (NotNull, allocateCell&lt;JSBoundFunction&gt;(vm.heap)) JSBoundFunction(vm, globalObject, structure, targetFunction, boundThis, boundArgs);</span>
  
      function-&gt;finishCreation(vm, executable, length);
      return function;
  }
  
<span class="line-modified">! bool JSBoundFunction::customHasInstance(JSObject* object, ExecState* exec, JSValue value)</span>
  {
<span class="line-modified">!     return jsCast&lt;JSBoundFunction*&gt;(object)-&gt;m_targetFunction-&gt;hasInstance(exec, value);</span>
  }
  
<span class="line-modified">! JSBoundFunction::JSBoundFunction(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure, JSObject* targetFunction, JSValue boundThis, JSArray* boundArgs)</span>
<span class="line-modified">!     : Base(vm, globalObject, structure)</span>
      , m_targetFunction(vm, this, targetFunction)
      , m_boundThis(vm, this, boundThis)
<span class="line-modified">!     , m_boundArgs(vm, this, boundArgs, WriteBarrier&lt;JSArray&gt;::MayBeNull)</span>
  {
  }
  
<span class="line-modified">! JSArray* JSBoundFunction::boundArgsCopy(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSArray* result = constructEmptyArray(exec, nullptr, globalObject(vm));</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     for (unsigned i = 0; i &lt; m_boundArgs-&gt;length(); ++i) {</span>
<span class="line-modified">!         result-&gt;push(exec, m_boundArgs-&gt;getIndexQuickly(i));</span>
<span class="line-modified">!         RETURN_IF_EXCEPTION(scope, nullptr);</span>
      }
      return result;
  }
  
  void JSBoundFunction::finishCreation(VM&amp; vm, NativeExecutable* executable, int length)
<span class="line-new-header">--- 180,66 ---</span>
          ASSERT_WITH_SECURITY_IMPLICATION(result-&gt;globalObject() == globalObject);
      } else
          result = Structure::create(vm, globalObject, prototype, result-&gt;typeInfo(), result-&gt;classInfo());
  
      if (targetJSFunction)
<span class="line-modified">!         targetJSFunction-&gt;ensureRareData(vm)-&gt;setBoundFunctionStructure(vm, result);</span>
  
      return result;
  }
  
<span class="line-modified">! JSBoundFunction* JSBoundFunction::create(VM&amp; vm, JSGlobalObject* globalObject, JSObject* targetFunction, JSValue boundThis, JSImmutableButterfly* boundArgs, int length, JSString* nameMayBeNull)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-added">+ </span>
<span class="line-added">+     if (nameMayBeNull) {</span>
<span class="line-added">+         nameMayBeNull-&gt;value(globalObject); // Resolving rope.</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool isJSFunction = getJSFunction(targetFunction);</span>
      ConstructData constructData;
      ConstructType constructType = JSC::getConstructData(vm, targetFunction, constructData);
      bool canConstruct = constructType != ConstructType::None;
  
<span class="line-modified">!     NativeExecutable* executable = vm.getBoundFunction(isJSFunction, canConstruct);</span>
<span class="line-modified">!     Structure* structure = getBoundFunctionStructure(vm, globalObject, targetFunction);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     JSBoundFunction* function = new (NotNull, allocateCell&lt;JSBoundFunction&gt;(vm.heap)) JSBoundFunction(vm, executable, globalObject, structure, targetFunction, boundThis, boundArgs, nameMayBeNull, length);</span>
  
      function-&gt;finishCreation(vm, executable, length);
      return function;
  }
  
<span class="line-modified">! bool JSBoundFunction::customHasInstance(JSObject* object, JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="line-modified">!     return jsCast&lt;JSBoundFunction*&gt;(object)-&gt;m_targetFunction-&gt;hasInstance(globalObject, value);</span>
  }
  
<span class="line-modified">! JSBoundFunction::JSBoundFunction(VM&amp; vm, NativeExecutable* executable, JSGlobalObject* globalObject, Structure* structure, JSObject* targetFunction, JSValue boundThis, JSImmutableButterfly* boundArgs, JSString* nameMayBeNull, int length)</span>
<span class="line-modified">!     : Base(vm, executable, globalObject, structure)</span>
      , m_targetFunction(vm, this, targetFunction)
      , m_boundThis(vm, this, boundThis)
<span class="line-modified">!     , m_boundArgs(vm, this, boundArgs, WriteBarrier&lt;JSImmutableButterfly&gt;::MayBeNull)</span>
<span class="line-added">+     , m_nameMayBeNull(vm, this, nameMayBeNull, WriteBarrier&lt;JSString&gt;::MayBeNull)</span>
<span class="line-added">+     , m_length(length)</span>
  {
<span class="line-added">+     ASSERT(!m_nameMayBeNull || !m_nameMayBeNull-&gt;isRope());</span>
  }
  
<span class="line-modified">! JSArray* JSBoundFunction::boundArgsCopy(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSArray* result = constructEmptyArray(this-&gt;globalObject(), nullptr);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     if (m_boundArgs) {</span>
<span class="line-modified">!         // Starts with 1 since the first one is bound |this|.</span>
<span class="line-modified">!         for (unsigned i = 1; i &lt; m_boundArgs-&gt;length(); ++i) {</span>
<span class="line-added">+             result-&gt;push(globalObject, m_boundArgs-&gt;get(i));</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added">+         }</span>
      }
      return result;
  }
  
  void JSBoundFunction::finishCreation(VM&amp; vm, NativeExecutable* executable, int length)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,8 ***</span>
<span class="line-new-header">--- 256,9 ---</span>
      Base::visitChildren(thisObject, visitor);
  
      visitor.append(thisObject-&gt;m_targetFunction);
      visitor.append(thisObject-&gt;m_boundThis);
      visitor.append(thisObject-&gt;m_boundArgs);
<span class="line-added">+     visitor.append(thisObject-&gt;m_nameMayBeNull);</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="JSBigInt.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBoundFunction.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
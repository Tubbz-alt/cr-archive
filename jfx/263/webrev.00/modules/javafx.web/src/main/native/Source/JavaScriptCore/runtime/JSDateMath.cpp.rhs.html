<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSDateMath.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
  3  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.
  4  * Copyright (C) 2009 Google Inc. All rights reserved.
  5  * Copyright (C) 2007-2009 Torch Mobile, Inc.
  6  * Copyright (C) 2010 &amp;yet, LLC. (nate@andyet.net)
  7  *
  8  * The Original Code is Mozilla Communicator client code, released
  9  * March 31, 1998.
 10  *
 11  * The Initial Developer of the Original Code is
 12  * Netscape Communications Corporation.
 13  * Portions created by the Initial Developer are Copyright (C) 1998
 14  * the Initial Developer. All Rights Reserved.
 15  *
 16  * This library is free software; you can redistribute it and/or
 17  * modify it under the terms of the GNU Lesser General Public
 18  * License as published by the Free Software Foundation; either
 19  * version 2.1 of the License, or (at your option) any later version.
 20  *
 21  * This library is distributed in the hope that it will be useful,
 22  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 23  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 24  * Lesser General Public License for more details.
 25  *
 26  * You should have received a copy of the GNU Lesser General Public
 27  * License along with this library; if not, write to the Free Software
 28  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 29  *
 30  * Alternatively, the contents of this file may be used under the terms
 31  * of either the Mozilla Public License Version 1.1, found at
 32  * http://www.mozilla.org/MPL/ (the &quot;MPL&quot;) or the GNU General Public
 33  * License Version 2.0, found at http://www.fsf.org/copyleft/gpl.html
 34  * (the &quot;GPL&quot;), in which case the provisions of the MPL or the GPL are
 35  * applicable instead of those above.  If you wish to allow use of your
 36  * version of this file only under the terms of one of those two
 37  * licenses (the MPL or the GPL) and not to allow others to use your
 38  * version of this file under the LGPL, indicate your decision by
 39  * deletingthe provisions above and replace them with the notice and
 40  * other provisions required by the MPL or the GPL, as the case may be.
 41  * If you do not delete the provisions above, a recipient may use your
 42  * version of this file under any of the LGPL, the MPL or the GPL.
 43 
 44  * Copyright 2006-2008 the V8 project authors. All rights reserved.
 45  * Redistribution and use in source and binary forms, with or without
 46  * modification, are permitted provided that the following conditions are
 47  * met:
 48  *
 49  *     * Redistributions of source code must retain the above copyright
 50  *       notice, this list of conditions and the following disclaimer.
 51  *     * Redistributions in binary form must reproduce the above
 52  *       copyright notice, this list of conditions and the following
 53  *       disclaimer in the documentation and/or other materials provided
 54  *       with the distribution.
 55  *     * Neither the name of Google Inc. nor the names of its
 56  *       contributors may be used to endorse or promote products derived
 57  *       from this software without specific prior written permission.
 58  *
 59  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 60  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 61  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 62  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 63  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 64  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 65  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 66  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 67  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 68  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 69  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 70  */
 71 
 72 #include &quot;config.h&quot;
 73 #include &quot;JSDateMath.h&quot;
 74 
 75 #include &quot;JSObject.h&quot;
 76 #include &quot;JSScope.h&quot;
 77 #include &quot;JSCInlines.h&quot;
 78 
 79 #include &lt;algorithm&gt;
 80 #include &lt;limits.h&gt;
 81 #include &lt;limits&gt;
 82 #include &lt;stdint.h&gt;
 83 #include &lt;time.h&gt;
 84 #include &lt;wtf/ASCIICType.h&gt;
 85 #include &lt;wtf/Assertions.h&gt;
 86 #include &lt;wtf/MathExtras.h&gt;
 87 #include &lt;wtf/StdLibExtras.h&gt;
 88 
 89 #if HAVE(ERRNO_H)
 90 #include &lt;errno.h&gt;
 91 #endif
 92 
 93 #if HAVE(SYS_TIME_H)
 94 #include &lt;sys/time.h&gt;
 95 #endif
 96 
 97 #if HAVE(SYS_TIMEB_H)
 98 #include &lt;sys/timeb.h&gt;
 99 #endif
100 
101 namespace JSC {
102 
<a name="1" id="anc1"></a>























103 // Get the combined UTC + DST offset for the time passed in.
104 //
105 // NOTE: The implementation relies on the fact that no time zones have
106 // more than one daylight savings offset change per month.
107 // If this function is called with NaN it returns NaN.
108 static LocalTimeOffset localTimeOffset(VM&amp; vm, double ms, WTF::TimeType inputTimeType = WTF::UTCTime)
109 {
110     LocalTimeOffsetCache&amp; cache = inputTimeType == WTF::LocalTime
111         ? vm.localTimeOffsetCache : vm.utcTimeOffsetCache;
112 
113     double start = cache.start;
114     double end = cache.end;
115 
116     if (start &lt;= ms) {
117         // If the time fits in the cached interval, return the cached offset.
118         if (ms &lt;= end)
119             return cache.offset;
120 
121         // Compute a possible new interval end.
122         double newEnd = end + cache.increment;
123 
124         if (ms &lt;= newEnd) {
125             LocalTimeOffset endOffset = calculateLocalTimeOffset(newEnd, inputTimeType);
126             if (cache.offset == endOffset) {
127                 // If the offset at the end of the new interval still matches
128                 // the offset in the cache, we grow the cached time interval
129                 // and return the offset.
130                 cache.end = newEnd;
<a name="2" id="anc2"></a><span class="line-modified">131                 cache.increment = WTF::msPerMonth;</span>
132                 return endOffset;
133             }
134             LocalTimeOffset offset = calculateLocalTimeOffset(ms, inputTimeType);
135             if (offset == endOffset) {
136                 // The offset at the given time is equal to the offset at the
137                 // new end of the interval, so that means that we&#39;ve just skipped
138                 // the point in time where the DST offset change occurred. Updated
139                 // the interval to reflect this and reset the increment.
140                 cache.start = ms;
141                 cache.end = newEnd;
<a name="3" id="anc3"></a><span class="line-modified">142                 cache.increment = WTF::msPerMonth;</span>
143             } else {
144                 // The interval contains a DST offset change and the given time is
145                 // before it. Adjust the increment to avoid a linear search for
146                 // the offset change point and change the end of the interval.
147                 cache.increment /= 3;
148                 cache.end = ms;
149             }
150             // Update the offset in the cache and return it.
151             cache.offset = offset;
152             return offset;
153         }
154     }
155 
156     // Compute the DST offset for the time and shrink the cache interval
157     // to only contain the time. This allows fast repeated DST offset
158     // computations for the same time.
159     LocalTimeOffset offset = calculateLocalTimeOffset(ms, inputTimeType);
160     cache.offset = offset;
161     cache.start = ms;
162     cache.end = ms;
<a name="4" id="anc4"></a><span class="line-modified">163     cache.increment = WTF::msPerMonth;</span>
164     return offset;
165 }
166 
<a name="5" id="anc5"></a><span class="line-added">167 static inline double timeToMS(double hour, double min, double sec, double ms)</span>
<span class="line-added">168 {</span>
<span class="line-added">169     return (((hour * WTF::minutesPerHour + min) * WTF::secondsPerMinute + sec) * WTF::msPerSecond + ms);</span>
<span class="line-added">170 }</span>
<span class="line-added">171 </span>
172 double gregorianDateTimeToMS(VM&amp; vm, const GregorianDateTime&amp; t, double milliSeconds, WTF::TimeType inputTimeType)
173 {
174     double day = dateToDaysFrom1970(t.year(), t.month(), t.monthDay());
175     double ms = timeToMS(t.hour(), t.minute(), t.second(), milliSeconds);
176     double localTimeResult = (day * WTF::msPerDay) + ms;
177 
<a name="6" id="anc6"></a><span class="line-modified">178     double localToUTCTimeOffset = inputTimeType == WTF::LocalTime</span>
179         ? localTimeOffset(vm, localTimeResult, inputTimeType).offset : 0;
180 
181     return localTimeResult - localToUTCTimeOffset;
182 }
183 
184 // input is UTC
185 void msToGregorianDateTime(VM&amp; vm, double ms, WTF::TimeType outputTimeType, GregorianDateTime&amp; tm)
186 {
187     LocalTimeOffset localTime;
188     if (outputTimeType == WTF::LocalTime) {
189         localTime = localTimeOffset(vm, ms);
190         ms += localTime.offset;
191     }
<a name="7" id="anc7"></a><span class="line-modified">192     tm = GregorianDateTime(ms, localTime);</span>











193 }
194 
<a name="8" id="anc8"></a><span class="line-modified">195 static double parseDate(VM&amp; vm, const char* dateString)</span>
196 {
<a name="9" id="anc9"></a><span class="line-modified">197     bool isLocalTime;</span>
<span class="line-modified">198     double value = WTF::parseES5DateFromNullTerminatedCharacters(dateString, isLocalTime);</span>
<span class="line-modified">199     if (std::isnan(value))</span>
<span class="line-modified">200         value = WTF::parseDateFromNullTerminatedCharacters(dateString, isLocalTime);</span>

201 
<a name="10" id="anc10"></a><span class="line-modified">202     if (isLocalTime)</span>
<span class="line-modified">203         value -= localTimeOffset(vm, value, WTF::LocalTime).offset;</span>

204 
<a name="11" id="anc11"></a><span class="line-modified">205     return value;</span>
206 }
207 
<a name="12" id="anc12"></a><span class="line-modified">208 double parseDate(JSGlobalObject* globalObject, VM&amp; vm, const String&amp; date)</span>
209 {
210     auto scope = DECLARE_THROW_SCOPE(vm);
211 
212     if (date == vm.cachedDateString)
213         return vm.cachedDateStringValue;
214     auto expectedString = date.tryGetUtf8();
215     if (!expectedString) {
216         if (expectedString.error() == UTF8ConversionError::OutOfMemory)
<a name="13" id="anc13"></a><span class="line-modified">217             throwOutOfMemoryError(globalObject, scope);</span>
218         // https://tc39.github.io/ecma262/#sec-date-objects section 20.3.3.2 states that:
219         // &quot;Unrecognizable Strings or dates containing illegal element values in the
220         // format String shall cause Date.parse to return NaN.&quot;
221         return std::numeric_limits&lt;double&gt;::quiet_NaN();
222     }
223 
224     auto dateUtf8 = expectedString.value();
<a name="14" id="anc14"></a><span class="line-modified">225     double value = parseDate(vm, dateUtf8.data());</span>


226     vm.cachedDateString = date;
227     vm.cachedDateStringValue = value;
228     return value;
229 }
230 
231 } // namespace JSC
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
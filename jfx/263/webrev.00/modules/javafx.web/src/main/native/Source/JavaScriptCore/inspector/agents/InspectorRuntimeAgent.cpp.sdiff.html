<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorRuntimeAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorHeapAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorRuntimeAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorRuntimeAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2015 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2011 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</pre>
<hr />
<pre>
 39 #include &quot;InjectedScriptHost.h&quot;
 40 #include &quot;InjectedScriptManager.h&quot;
 41 #include &quot;InspectorFrontendRouter.h&quot;
 42 #include &quot;JSLock.h&quot;
 43 #include &quot;ParserError.h&quot;
 44 #include &quot;ScriptDebugServer.h&quot;
 45 #include &quot;SourceCode.h&quot;
 46 #include &quot;TypeProfiler.h&quot;
 47 #include &quot;TypeProfilerLog.h&quot;
 48 #include &lt;wtf/JSONValues.h&gt;
 49 
 50 namespace Inspector {
 51 
 52 using namespace JSC;
 53 
 54 static bool asBool(const bool* b)
 55 {
 56     return b &amp;&amp; *b;
 57 }
 58 







 59 InspectorRuntimeAgent::InspectorRuntimeAgent(AgentContext&amp; context)
 60     : InspectorAgentBase(&quot;Runtime&quot;_s)
 61     , m_injectedScriptManager(context.injectedScriptManager)
 62     , m_scriptDebugServer(context.environment.scriptDebugServer())
 63     , m_vm(context.environment.vm())
 64 {
 65 }
 66 
 67 InspectorRuntimeAgent::~InspectorRuntimeAgent()
 68 {
 69 }
 70 
 71 static ScriptDebugServer::PauseOnExceptionsState setPauseOnExceptionsState(ScriptDebugServer&amp; scriptDebugServer, ScriptDebugServer::PauseOnExceptionsState newState)
 72 {
 73     auto presentState = scriptDebugServer.pauseOnExceptionsState();
 74     if (presentState != newState)
 75         scriptDebugServer.setPauseOnExceptionsState(newState);
 76     return presentState;
 77 }
 78 
</pre>
<hr />
<pre>
131         setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
132     }
133 }
134 
135 void InspectorRuntimeAgent::awaitPromise(const String&amp; promiseObjectId, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, Ref&lt;AwaitPromiseCallback&gt;&amp;&amp; callback)
136 {
137     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(promiseObjectId);
138     if (injectedScript.hasNoValue()) {
139         callback-&gt;sendFailure(&quot;Missing injected script for given promiseObjectId&quot;_s);
140         return;
141     }
142 
143     injectedScript.awaitPromise(promiseObjectId, asBool(returnByValue), asBool(generatePreview), asBool(saveResult), [callback = WTFMove(callback)] (ErrorString&amp; errorString, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp;&amp; result, Optional&lt;bool&gt;&amp; wasThrown, Optional&lt;int&gt;&amp; savedResultIndex) {
144         if (!errorString.isEmpty())
145             callback-&gt;sendFailure(errorString);
146         else
147             callback-&gt;sendSuccess(WTFMove(result), wasThrown, savedResultIndex);
148     });
149 }
150 
<span class="line-modified">151 void InspectorRuntimeAgent::callFunctionOn(ErrorString&amp; errorString, const String&amp; objectId, const String&amp; expression, const JSON::Array* optionalArguments, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown)</span>
152 {
153     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
154     if (injectedScript.hasNoValue()) {
155         errorString = &quot;Missing injected script for given objectId&quot;_s;
156         return;
157     }
158 
159     String arguments;
160     if (optionalArguments)
161         arguments = optionalArguments-&gt;toJSONString();
162 
163     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = ScriptDebugServer::DontPauseOnExceptions;
164     if (asBool(doNotPauseOnExceptionsAndMuteConsole))
165         previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
166     if (asBool(doNotPauseOnExceptionsAndMuteConsole))
167         muteConsole();
168 
169     injectedScript.callFunctionOn(errorString, objectId, expression, arguments, asBool(returnByValue), asBool(generatePreview), result, wasThrown);
170 
171     if (asBool(doNotPauseOnExceptionsAndMuteConsole)) {
</pre>
<hr />
<pre>
174     }
175 }
176 
177 void InspectorRuntimeAgent::getPreview(ErrorString&amp; errorString, const String&amp; objectId, RefPtr&lt;Protocol::Runtime::ObjectPreview&gt;&amp; preview)
178 {
179     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
180     if (injectedScript.hasNoValue()) {
181         errorString = &quot;Missing injected script for given objectId&quot;_s;
182         return;
183     }
184 
185     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
186     muteConsole();
187 
188     injectedScript.getPreview(errorString, objectId, preview);
189 
190     unmuteConsole();
191     setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
192 }
193 
<span class="line-modified">194 void InspectorRuntimeAgent::getProperties(ErrorString&amp; errorString, const String&amp; objectId, const bool* ownProperties, const bool* generatePreview, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::PropertyDescriptor&gt;&gt;&amp; result, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::InternalPropertyDescriptor&gt;&gt;&amp; internalProperties)</span>
195 {
196     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
197     if (injectedScript.hasNoValue()) {
198         errorString = &quot;Missing injected script for given objectId&quot;_s;
199         return;
200     }
201 












202     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
203     muteConsole();
204 
<span class="line-modified">205     injectedScript.getProperties(errorString, objectId, asBool(ownProperties), asBool(generatePreview), result);</span>
<span class="line-modified">206     injectedScript.getInternalProperties(errorString, objectId, asBool(generatePreview), internalProperties);</span>



207 
208     unmuteConsole();
209     setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
210 }
211 
<span class="line-modified">212 void InspectorRuntimeAgent::getDisplayableProperties(ErrorString&amp; errorString, const String&amp; objectId, const bool* generatePreview, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::PropertyDescriptor&gt;&gt;&amp; result, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::InternalPropertyDescriptor&gt;&gt;&amp; internalProperties)</span>
213 {
214     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
215     if (injectedScript.hasNoValue()) {
216         errorString = &quot;Missing injected script for given objectId&quot;_s;
217         return;
218     }
219 












220     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
221     muteConsole();
222 
<span class="line-modified">223     injectedScript.getDisplayableProperties(errorString, objectId, asBool(generatePreview), result);</span>
<span class="line-modified">224     injectedScript.getInternalProperties(errorString, objectId, asBool(generatePreview), internalProperties);</span>



225 
226     unmuteConsole();
227     setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
228 }
229 
<span class="line-modified">230 void InspectorRuntimeAgent::getCollectionEntries(ErrorString&amp; errorString, const String&amp; objectId, const String* objectGroup, const int* startIndex, const int* numberToFetch, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::CollectionEntry&gt;&gt;&amp; entries)</span>
231 {
232     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
233     if (injectedScript.hasNoValue()) {
234         errorString = &quot;Missing injected script for given objectId&quot;_s;
235         return;
236     }
237 
<span class="line-modified">238     int start = startIndex &amp;&amp; *startIndex &gt;= 0 ? *startIndex : 0;</span>
<span class="line-modified">239     int fetch = numberToFetch &amp;&amp; *numberToFetch &gt;= 0 ? *numberToFetch : 0;</span>









240 
<span class="line-modified">241     injectedScript.getCollectionEntries(errorString, objectId, objectGroup ? *objectGroup : String(), start, fetch, entries);</span>
242 }
243 
244 void InspectorRuntimeAgent::saveResult(ErrorString&amp; errorString, const JSON::Object&amp; callArgument, const int* executionContextId, Optional&lt;int&gt;&amp; savedResultIndex)
245 {
246     InjectedScript injectedScript;
247 
248     String objectId;
249     if (callArgument.getString(&quot;objectId&quot;_s, objectId)) {
250         injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
251         if (injectedScript.hasNoValue()) {
252             errorString = &quot;Missing injected script for given objectId&quot;_s;
253             return;
254         }
255     } else {
256         injectedScript = injectedScriptForEval(errorString, executionContextId);
257         if (injectedScript.hasNoValue())
258             return;
259     }
260 
261     injectedScript.saveResult(errorString, callArgument.toJSONString(), savedResultIndex);
</pre>
<hr />
<pre>
266     Optional&lt;String&gt; savedResultAlias;
267     if (alias &amp;&amp; !alias-&gt;isEmpty())
268         savedResultAlias = *alias;
269     m_injectedScriptManager.injectedScriptHost().setSavedResultAlias(savedResultAlias);
270 }
271 
272 void InspectorRuntimeAgent::releaseObject(ErrorString&amp;, const String&amp; objectId)
273 {
274     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
275     if (!injectedScript.hasNoValue())
276         injectedScript.releaseObject(objectId);
277 }
278 
279 void InspectorRuntimeAgent::releaseObjectGroup(ErrorString&amp;, const String&amp; objectGroup)
280 {
281     m_injectedScriptManager.releaseObjectGroup(objectGroup);
282 }
283 
284 void InspectorRuntimeAgent::getRuntimeTypesForVariablesAtOffsets(ErrorString&amp; errorString, const JSON::Array&amp; locations, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::TypeDescription&gt;&gt;&amp; typeDescriptions)
285 {
<span class="line-modified">286     static const bool verbose = false;</span>
287 
288     typeDescriptions = JSON::ArrayOf&lt;Protocol::Runtime::TypeDescription&gt;::create();
289     if (!m_vm.typeProfiler()) {
290         errorString = &quot;VM has no type information&quot;_s;
291         return;
292     }
293 
294     MonotonicTime start = MonotonicTime::now();
295     m_vm.typeProfilerLog()-&gt;processLogEntries(m_vm, &quot;User Query&quot;_s);
296 
297     for (size_t i = 0; i &lt; locations.length(); i++) {
298         RefPtr&lt;JSON::Value&gt; value = locations.get(i);
299         RefPtr&lt;JSON::Object&gt; location;
300         if (!value-&gt;asObject(location)) {
301             errorString = &quot;Unexpected non-object item in locations&quot;_s;
302             return;
303         }
304 
305         int descriptor;
306         String sourceIDAsString;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2011 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</pre>
<hr />
<pre>
 39 #include &quot;InjectedScriptHost.h&quot;
 40 #include &quot;InjectedScriptManager.h&quot;
 41 #include &quot;InspectorFrontendRouter.h&quot;
 42 #include &quot;JSLock.h&quot;
 43 #include &quot;ParserError.h&quot;
 44 #include &quot;ScriptDebugServer.h&quot;
 45 #include &quot;SourceCode.h&quot;
 46 #include &quot;TypeProfiler.h&quot;
 47 #include &quot;TypeProfilerLog.h&quot;
 48 #include &lt;wtf/JSONValues.h&gt;
 49 
 50 namespace Inspector {
 51 
 52 using namespace JSC;
 53 
 54 static bool asBool(const bool* b)
 55 {
 56     return b &amp;&amp; *b;
 57 }
 58 
<span class="line-added"> 59 static int asInt(const int* i)</span>
<span class="line-added"> 60 {</span>
<span class="line-added"> 61     if (i)</span>
<span class="line-added"> 62         return *i;</span>
<span class="line-added"> 63     return 0;</span>
<span class="line-added"> 64 }</span>
<span class="line-added"> 65 </span>
 66 InspectorRuntimeAgent::InspectorRuntimeAgent(AgentContext&amp; context)
 67     : InspectorAgentBase(&quot;Runtime&quot;_s)
 68     , m_injectedScriptManager(context.injectedScriptManager)
 69     , m_scriptDebugServer(context.environment.scriptDebugServer())
 70     , m_vm(context.environment.vm())
 71 {
 72 }
 73 
 74 InspectorRuntimeAgent::~InspectorRuntimeAgent()
 75 {
 76 }
 77 
 78 static ScriptDebugServer::PauseOnExceptionsState setPauseOnExceptionsState(ScriptDebugServer&amp; scriptDebugServer, ScriptDebugServer::PauseOnExceptionsState newState)
 79 {
 80     auto presentState = scriptDebugServer.pauseOnExceptionsState();
 81     if (presentState != newState)
 82         scriptDebugServer.setPauseOnExceptionsState(newState);
 83     return presentState;
 84 }
 85 
</pre>
<hr />
<pre>
138         setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
139     }
140 }
141 
142 void InspectorRuntimeAgent::awaitPromise(const String&amp; promiseObjectId, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, Ref&lt;AwaitPromiseCallback&gt;&amp;&amp; callback)
143 {
144     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(promiseObjectId);
145     if (injectedScript.hasNoValue()) {
146         callback-&gt;sendFailure(&quot;Missing injected script for given promiseObjectId&quot;_s);
147         return;
148     }
149 
150     injectedScript.awaitPromise(promiseObjectId, asBool(returnByValue), asBool(generatePreview), asBool(saveResult), [callback = WTFMove(callback)] (ErrorString&amp; errorString, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp;&amp; result, Optional&lt;bool&gt;&amp; wasThrown, Optional&lt;int&gt;&amp; savedResultIndex) {
151         if (!errorString.isEmpty())
152             callback-&gt;sendFailure(errorString);
153         else
154             callback-&gt;sendSuccess(WTFMove(result), wasThrown, savedResultIndex);
155     });
156 }
157 
<span class="line-modified">158 void InspectorRuntimeAgent::callFunctionOn(ErrorString&amp; errorString, const String&amp; objectId, const String&amp; expression, const JSON::Array* optionalArguments, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, const bool* /* emulateUserGesture */, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown)</span>
159 {
160     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
161     if (injectedScript.hasNoValue()) {
162         errorString = &quot;Missing injected script for given objectId&quot;_s;
163         return;
164     }
165 
166     String arguments;
167     if (optionalArguments)
168         arguments = optionalArguments-&gt;toJSONString();
169 
170     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = ScriptDebugServer::DontPauseOnExceptions;
171     if (asBool(doNotPauseOnExceptionsAndMuteConsole))
172         previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
173     if (asBool(doNotPauseOnExceptionsAndMuteConsole))
174         muteConsole();
175 
176     injectedScript.callFunctionOn(errorString, objectId, expression, arguments, asBool(returnByValue), asBool(generatePreview), result, wasThrown);
177 
178     if (asBool(doNotPauseOnExceptionsAndMuteConsole)) {
</pre>
<hr />
<pre>
181     }
182 }
183 
184 void InspectorRuntimeAgent::getPreview(ErrorString&amp; errorString, const String&amp; objectId, RefPtr&lt;Protocol::Runtime::ObjectPreview&gt;&amp; preview)
185 {
186     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
187     if (injectedScript.hasNoValue()) {
188         errorString = &quot;Missing injected script for given objectId&quot;_s;
189         return;
190     }
191 
192     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
193     muteConsole();
194 
195     injectedScript.getPreview(errorString, objectId, preview);
196 
197     unmuteConsole();
198     setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
199 }
200 
<span class="line-modified">201 void InspectorRuntimeAgent::getProperties(ErrorString&amp; errorString, const String&amp; objectId, const bool* ownProperties, const int* fetchStart, const int* fetchCount, const bool* generatePreview, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::PropertyDescriptor&gt;&gt;&amp; properties, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::InternalPropertyDescriptor&gt;&gt;&amp; internalProperties)</span>
202 {
203     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
204     if (injectedScript.hasNoValue()) {
205         errorString = &quot;Missing injected script for given objectId&quot;_s;
206         return;
207     }
208 
<span class="line-added">209     int start = asInt(fetchStart);</span>
<span class="line-added">210     if (start &lt; 0) {</span>
<span class="line-added">211         errorString = &quot;fetchStart cannot be negative&quot;_s;</span>
<span class="line-added">212         return;</span>
<span class="line-added">213     }</span>
<span class="line-added">214 </span>
<span class="line-added">215     int count = asInt(fetchCount);</span>
<span class="line-added">216     if (count &lt; 0) {</span>
<span class="line-added">217         errorString = &quot;fetchCount cannot be negative&quot;_s;</span>
<span class="line-added">218         return;</span>
<span class="line-added">219     }</span>
<span class="line-added">220 </span>
221     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
222     muteConsole();
223 
<span class="line-modified">224     injectedScript.getProperties(errorString, objectId, asBool(ownProperties), start, count, asBool(generatePreview), properties);</span>
<span class="line-modified">225 </span>
<span class="line-added">226     // Only include internal properties for the first fetch.</span>
<span class="line-added">227     if (!start)</span>
<span class="line-added">228         injectedScript.getInternalProperties(errorString, objectId, asBool(generatePreview), internalProperties);</span>
229 
230     unmuteConsole();
231     setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
232 }
233 
<span class="line-modified">234 void InspectorRuntimeAgent::getDisplayableProperties(ErrorString&amp; errorString, const String&amp; objectId, const int* fetchStart, const int* fetchCount, const bool* generatePreview, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::PropertyDescriptor&gt;&gt;&amp; properties, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::InternalPropertyDescriptor&gt;&gt;&amp; internalProperties)</span>
235 {
236     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
237     if (injectedScript.hasNoValue()) {
238         errorString = &quot;Missing injected script for given objectId&quot;_s;
239         return;
240     }
241 
<span class="line-added">242     int start = asInt(fetchStart);</span>
<span class="line-added">243     if (start &lt; 0) {</span>
<span class="line-added">244         errorString = &quot;fetchStart cannot be negative&quot;_s;</span>
<span class="line-added">245         return;</span>
<span class="line-added">246     }</span>
<span class="line-added">247 </span>
<span class="line-added">248     int count = asInt(fetchCount);</span>
<span class="line-added">249     if (count &lt; 0) {</span>
<span class="line-added">250         errorString = &quot;fetchCount cannot be negative&quot;_s;</span>
<span class="line-added">251         return;</span>
<span class="line-added">252     }</span>
<span class="line-added">253 </span>
254     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
255     muteConsole();
256 
<span class="line-modified">257     injectedScript.getDisplayableProperties(errorString, objectId, start, count, asBool(generatePreview), properties);</span>
<span class="line-modified">258 </span>
<span class="line-added">259     // Only include internal properties for the first fetch.</span>
<span class="line-added">260     if (!start)</span>
<span class="line-added">261         injectedScript.getInternalProperties(errorString, objectId, asBool(generatePreview), internalProperties);</span>
262 
263     unmuteConsole();
264     setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
265 }
266 
<span class="line-modified">267 void InspectorRuntimeAgent::getCollectionEntries(ErrorString&amp; errorString, const String&amp; objectId, const String* objectGroup, const int* fetchStart, const int* fetchCount, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::CollectionEntry&gt;&gt;&amp; entries)</span>
268 {
269     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
270     if (injectedScript.hasNoValue()) {
271         errorString = &quot;Missing injected script for given objectId&quot;_s;
272         return;
273     }
274 
<span class="line-modified">275     int start = asInt(fetchStart);</span>
<span class="line-modified">276     if (start &lt; 0) {</span>
<span class="line-added">277         errorString = &quot;fetchStart cannot be negative&quot;_s;</span>
<span class="line-added">278         return;</span>
<span class="line-added">279     }</span>
<span class="line-added">280 </span>
<span class="line-added">281     int count = asInt(fetchCount);</span>
<span class="line-added">282     if (count &lt; 0) {</span>
<span class="line-added">283         errorString = &quot;fetchCount cannot be negative&quot;_s;</span>
<span class="line-added">284         return;</span>
<span class="line-added">285     }</span>
286 
<span class="line-modified">287     injectedScript.getCollectionEntries(errorString, objectId, objectGroup ? *objectGroup : String(), start, count, entries);</span>
288 }
289 
290 void InspectorRuntimeAgent::saveResult(ErrorString&amp; errorString, const JSON::Object&amp; callArgument, const int* executionContextId, Optional&lt;int&gt;&amp; savedResultIndex)
291 {
292     InjectedScript injectedScript;
293 
294     String objectId;
295     if (callArgument.getString(&quot;objectId&quot;_s, objectId)) {
296         injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
297         if (injectedScript.hasNoValue()) {
298             errorString = &quot;Missing injected script for given objectId&quot;_s;
299             return;
300         }
301     } else {
302         injectedScript = injectedScriptForEval(errorString, executionContextId);
303         if (injectedScript.hasNoValue())
304             return;
305     }
306 
307     injectedScript.saveResult(errorString, callArgument.toJSONString(), savedResultIndex);
</pre>
<hr />
<pre>
312     Optional&lt;String&gt; savedResultAlias;
313     if (alias &amp;&amp; !alias-&gt;isEmpty())
314         savedResultAlias = *alias;
315     m_injectedScriptManager.injectedScriptHost().setSavedResultAlias(savedResultAlias);
316 }
317 
318 void InspectorRuntimeAgent::releaseObject(ErrorString&amp;, const String&amp; objectId)
319 {
320     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
321     if (!injectedScript.hasNoValue())
322         injectedScript.releaseObject(objectId);
323 }
324 
325 void InspectorRuntimeAgent::releaseObjectGroup(ErrorString&amp;, const String&amp; objectGroup)
326 {
327     m_injectedScriptManager.releaseObjectGroup(objectGroup);
328 }
329 
330 void InspectorRuntimeAgent::getRuntimeTypesForVariablesAtOffsets(ErrorString&amp; errorString, const JSON::Array&amp; locations, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Runtime::TypeDescription&gt;&gt;&amp; typeDescriptions)
331 {
<span class="line-modified">332     static constexpr bool verbose = false;</span>
333 
334     typeDescriptions = JSON::ArrayOf&lt;Protocol::Runtime::TypeDescription&gt;::create();
335     if (!m_vm.typeProfiler()) {
336         errorString = &quot;VM has no type information&quot;_s;
337         return;
338     }
339 
340     MonotonicTime start = MonotonicTime::now();
341     m_vm.typeProfilerLog()-&gt;processLogEntries(m_vm, &quot;User Query&quot;_s);
342 
343     for (size_t i = 0; i &lt; locations.length(); i++) {
344         RefPtr&lt;JSON::Value&gt; value = locations.get(i);
345         RefPtr&lt;JSON::Object&gt; location;
346         if (!value-&gt;asObject(location)) {
347             errorString = &quot;Unexpected non-object item in locations&quot;_s;
348             return;
349         }
350 
351         int descriptor;
352         String sourceIDAsString;
</pre>
</td>
</tr>
</table>
<center><a href="InspectorHeapAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorRuntimeAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
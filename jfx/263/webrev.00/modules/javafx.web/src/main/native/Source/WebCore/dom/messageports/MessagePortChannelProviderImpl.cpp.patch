diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannelProviderImpl.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannelProviderImpl.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannelProviderImpl.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannelProviderImpl.cpp
@@ -25,18 +25,25 @@
 
 #include "config.h"
 #include "MessagePortChannelProviderImpl.h"
 
 #include "MessagePort.h"
-#include <wtf/CompletionHandler.h>
 #include <wtf/MainThread.h>
 #include <wtf/RunLoop.h>
 
 namespace WebCore {
 
+static inline MessagePortChannelRegistry::CheckProcessLocalPortForActivityCallback checkActivityCallback()
+{
+    return [](auto& messagePortIdentifier, auto, auto&& callback) {
+        ASSERT(isMainThread());
+        callback(MessagePort::isExistingMessagePortLocallyReachable(messagePortIdentifier) ? MessagePortChannelProvider::HasActivity::Yes : MessagePortChannelProvider::HasActivity::No);
+    };
+}
+
 MessagePortChannelProviderImpl::MessagePortChannelProviderImpl()
-    : m_registry(*this)
+    : m_registry(checkActivityCallback())
 {
 }
 
 MessagePortChannelProviderImpl::~MessagePortChannelProviderImpl()
 {
@@ -85,24 +92,24 @@
         if (registry->didPostMessageToRemote(WTFMove(message), remoteTarget))
             MessagePort::notifyMessageAvailable(remoteTarget);
     });
 }
 
-void MessagePortChannelProviderImpl::takeAllMessagesForPort(const MessagePortIdentifier& port, Function<void(Vector<MessageWithMessagePorts>&&, Function<void()>&&)>&& outerCallback)
+void MessagePortChannelProviderImpl::takeAllMessagesForPort(const MessagePortIdentifier& port, CompletionHandler<void(Vector<MessageWithMessagePorts>&&, Function<void()>&&)>&& outerCallback)
 {
     // It is the responsibility of outerCallback to get itself to the appropriate thread (e.g. WebWorker thread)
-    auto callback = [outerCallback = WTFMove(outerCallback)](Vector<MessageWithMessagePorts>&& messages, Function<void()>&& messageDeliveryCallback) {
+    auto callback = [outerCallback = WTFMove(outerCallback)](Vector<MessageWithMessagePorts>&& messages, Function<void()>&& messageDeliveryCallback) mutable {
         ASSERT(isMainThread());
         outerCallback(WTFMove(messages), WTFMove(messageDeliveryCallback));
     };
 
     performActionOnMainThread([registry = &m_registry, port, callback = WTFMove(callback)]() mutable {
         registry->takeAllMessagesForPort(port, WTFMove(callback));
     });
 }
 
-void MessagePortChannelProviderImpl::checkRemotePortForActivity(const MessagePortIdentifier& remoteTarget, Function<void(HasActivity)>&& outerCallback)
+void MessagePortChannelProviderImpl::checkRemotePortForActivity(const MessagePortIdentifier& remoteTarget, CompletionHandler<void(HasActivity)>&& outerCallback)
 {
     auto callback = Function<void(HasActivity)> { [outerCallback = WTFMove(outerCallback)](HasActivity hasActivity) mutable {
         ASSERT(isMainThread());
         outerCallback(hasActivity);
     } };
@@ -110,14 +117,6 @@
     performActionOnMainThread([registry = &m_registry, remoteTarget, callback = WTFMove(callback)]() mutable {
         registry->checkRemotePortForActivity(remoteTarget, WTFMove(callback));
     });
 }
 
-void MessagePortChannelProviderImpl::checkProcessLocalPortForActivity(const MessagePortIdentifier& identifier, ProcessIdentifier, CompletionHandler<void(HasActivity)>&& callback)
-{
-    ASSERT(isMainThread());
-
-    callback(MessagePort::isExistingMessagePortLocallyReachable(identifier) ? HasActivity::Yes : HasActivity::No);
-}
-
-
 } // namespace WebCore

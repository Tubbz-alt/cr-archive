<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/fileapi/FileReader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2010 Google Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions are
  6  * met:
  7  *
  8  *     * Redistributions of source code must retain the above copyright
  9  * notice, this list of conditions and the following disclaimer.
 10  *     * Redistributions in binary form must reproduce the above
 11  * copyright notice, this list of conditions and the following disclaimer
 12  * in the documentation and/or other materials provided with the
 13  * distribution.
 14  *     * Neither the name of Google Inc. nor the names of its
 15  * contributors may be used to endorse or promote products derived from
 16  * this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;FileReader.h&quot;
 33 
<a name="1" id="anc1"></a><span class="line-added"> 34 #include &quot;EventLoop.h&quot;</span>
 35 #include &quot;EventNames.h&quot;
 36 #include &quot;File.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;ProgressEvent.h&quot;
 39 #include &quot;ScriptExecutionContext.h&quot;
 40 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 41 #include &lt;wtf/IsoMallocInlines.h&gt;
 42 #include &lt;wtf/text/CString.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 WTF_MAKE_ISO_ALLOCATED_IMPL(FileReader);
 47 
 48 // Fire the progress event at least every 50ms.
 49 static const auto progressNotificationInterval = 50_ms;
 50 
 51 Ref&lt;FileReader&gt; FileReader::create(ScriptExecutionContext&amp; context)
 52 {
 53     auto fileReader = adoptRef(*new FileReader(context));
 54     fileReader-&gt;suspendIfNeeded();
 55     return fileReader;
 56 }
 57 
 58 FileReader::FileReader(ScriptExecutionContext&amp; context)
 59     : ActiveDOMObject(&amp;context)
 60 {
 61 }
 62 
 63 FileReader::~FileReader()
 64 {
 65     if (m_loader)
 66         m_loader-&gt;cancel();
 67 }
 68 
<a name="2" id="anc2"></a>




 69 const char* FileReader::activeDOMObjectName() const
 70 {
 71     return &quot;FileReader&quot;;
 72 }
 73 
 74 void FileReader::stop()
 75 {
<a name="3" id="anc3"></a><span class="line-added"> 76     m_pendingTasks.clear();</span>
 77     if (m_loader) {
 78         m_loader-&gt;cancel();
 79         m_loader = nullptr;
 80     }
 81     m_state = DONE;
<a name="4" id="anc4"></a><span class="line-modified"> 82 }</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 bool FileReader::hasPendingActivity() const</span>
<span class="line-added"> 85 {</span>
<span class="line-added"> 86     return m_state == LOADING || ActiveDOMObject::hasPendingActivity();</span>
 87 }
 88 
 89 ExceptionOr&lt;void&gt; FileReader::readAsArrayBuffer(Blob* blob)
 90 {
 91     if (!blob)
 92         return { };
 93 
 94     LOG(FileAPI, &quot;FileReader: reading as array buffer: %s %s\n&quot;, blob-&gt;url().string().utf8().data(), is&lt;File&gt;(*blob) ? downcast&lt;File&gt;(*blob).path().utf8().data() : &quot;&quot;);
 95 
 96     return readInternal(*blob, FileReaderLoader::ReadAsArrayBuffer);
 97 }
 98 
 99 ExceptionOr&lt;void&gt; FileReader::readAsBinaryString(Blob* blob)
100 {
101     if (!blob)
102         return { };
103 
104     LOG(FileAPI, &quot;FileReader: reading as binary: %s %s\n&quot;, blob-&gt;url().string().utf8().data(), is&lt;File&gt;(*blob) ? downcast&lt;File&gt;(*blob).path().utf8().data() : &quot;&quot;);
105 
106     return readInternal(*blob, FileReaderLoader::ReadAsBinaryString);
107 }
108 
109 ExceptionOr&lt;void&gt; FileReader::readAsText(Blob* blob, const String&amp; encoding)
110 {
111     if (!blob)
112         return { };
113 
114     LOG(FileAPI, &quot;FileReader: reading as text: %s %s\n&quot;, blob-&gt;url().string().utf8().data(), is&lt;File&gt;(*blob) ? downcast&lt;File&gt;(*blob).path().utf8().data() : &quot;&quot;);
115 
116     m_encoding = encoding;
117     return readInternal(*blob, FileReaderLoader::ReadAsText);
118 }
119 
120 ExceptionOr&lt;void&gt; FileReader::readAsDataURL(Blob* blob)
121 {
122     if (!blob)
123         return { };
124 
125     LOG(FileAPI, &quot;FileReader: reading as data URL: %s %s\n&quot;, blob-&gt;url().string().utf8().data(), is&lt;File&gt;(*blob) ? downcast&lt;File&gt;(*blob).path().utf8().data() : &quot;&quot;);
126 
127     return readInternal(*blob, FileReaderLoader::ReadAsDataURL);
128 }
129 
130 ExceptionOr&lt;void&gt; FileReader::readInternal(Blob&amp; blob, FileReaderLoader::ReadType type)
131 {
132     // If multiple concurrent read methods are called on the same FileReader, InvalidStateError should be thrown when the state is LOADING.
133     if (m_state == LOADING)
134         return Exception { InvalidStateError };
135 
<a name="5" id="anc5"></a>

136     m_blob = &amp;blob;
137     m_readType = type;
138     m_state = LOADING;
139     m_error = nullptr;
140 
141     m_loader = makeUnique&lt;FileReaderLoader&gt;(m_readType, static_cast&lt;FileReaderLoaderClient*&gt;(this));
142     m_loader-&gt;setEncoding(m_encoding);
143     m_loader-&gt;setDataType(m_blob-&gt;type());
144     m_loader-&gt;start(scriptExecutionContext(), blob);
145 
146     return { };
147 }
148 
149 void FileReader::abort()
150 {
151     LOG(FileAPI, &quot;FileReader: aborting\n&quot;);
152 
153     if (m_aborting || m_state != LOADING)
154         return;
155     m_aborting = true;
156 
157     // Schedule to have the abort done later since abort() might be called from the event handler and we do not want the resource loading code to be in the stack.
<a name="6" id="anc6"></a><span class="line-modified">158     m_pendingTasks.clear();</span>
<span class="line-modified">159     enqueueTask([this] {</span>


160         ASSERT(m_state != DONE);
161 
162         stop();
163         m_aborting = false;
164 
165         m_error = FileError::create(FileError::ABORT_ERR);
166 
167         fireEvent(eventNames().errorEvent);
168         fireEvent(eventNames().abortEvent);
169         fireEvent(eventNames().loadendEvent);
170     });
171 }
172 
173 void FileReader::didStartLoading()
174 {
<a name="7" id="anc7"></a><span class="line-modified">175     enqueueTask([this] {</span>
<span class="line-added">176         fireEvent(eventNames().loadstartEvent);</span>
<span class="line-added">177     });</span>
178 }
179 
180 void FileReader::didReceiveData()
181 {
<a name="8" id="anc8"></a><span class="line-modified">182     enqueueTask([this] {</span>
<span class="line-modified">183         auto now = MonotonicTime::now();</span>
<span class="line-modified">184         if (std::isnan(m_lastProgressNotificationTime)) {</span>
<span class="line-modified">185             m_lastProgressNotificationTime = now;</span>
<span class="line-modified">186             return;</span>
<span class="line-modified">187         }</span>
<span class="line-modified">188         if (now - m_lastProgressNotificationTime &gt; progressNotificationInterval) {</span>
<span class="line-modified">189             fireEvent(eventNames().progressEvent);</span>
<span class="line-modified">190             m_lastProgressNotificationTime = now;</span>
<span class="line-added">191         }</span>
<span class="line-added">192     });</span>
193 }
194 
195 void FileReader::didFinishLoading()
196 {
197     if (m_aborting)
198         return;
199 
<a name="9" id="anc9"></a><span class="line-modified">200     enqueueTask([this] {</span>
<span class="line-modified">201         ASSERT(m_state != DONE);</span>
<span class="line-modified">202         m_state = DONE;</span>



203 
<a name="10" id="anc10"></a><span class="line-modified">204         fireEvent(eventNames().progressEvent);</span>
<span class="line-added">205         fireEvent(eventNames().loadEvent);</span>
<span class="line-added">206         fireEvent(eventNames().loadendEvent);</span>
<span class="line-added">207     });</span>
208 }
209 
210 void FileReader::didFail(int errorCode)
211 {
212     // If we&#39;re aborting, do not proceed with normal error handling since it is covered in aborting code.
213     if (m_aborting)
214         return;
215 
<a name="11" id="anc11"></a><span class="line-modified">216     enqueueTask([this, errorCode] {</span>
<span class="line-modified">217         ASSERT(m_state != DONE);</span>
<span class="line-modified">218         m_state = DONE;</span>



219 
<a name="12" id="anc12"></a><span class="line-modified">220         m_error = FileError::create(static_cast&lt;FileError::ErrorCode&gt;(errorCode));</span>
<span class="line-added">221         fireEvent(eventNames().errorEvent);</span>
<span class="line-added">222         fireEvent(eventNames().loadendEvent);</span>
<span class="line-added">223     });</span>
224 }
225 
226 void FileReader::fireEvent(const AtomString&amp; type)
227 {
<a name="13" id="anc13"></a><span class="line-added">228     RELEASE_ASSERT(isAllowedToRunScript());</span>
229     dispatchEvent(ProgressEvent::create(type, true, m_loader ? m_loader-&gt;bytesLoaded() : 0, m_loader ? m_loader-&gt;totalBytes() : 0));
230 }
231 
232 Optional&lt;Variant&lt;String, RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&gt; FileReader::result() const
233 {
234     if (!m_loader || m_error)
235         return WTF::nullopt;
236     if (m_readType == FileReaderLoader::ReadAsArrayBuffer) {
237         auto result = m_loader-&gt;arrayBufferResult();
238         if (!result)
239             return WTF::nullopt;
240         return { result };
241     }
242     String result = m_loader-&gt;stringResult();
243     if (result.isNull())
244         return WTF::nullopt;
245     return { WTFMove(result) };
246 }
247 
<a name="14" id="anc14"></a><span class="line-added">248 void FileReader::enqueueTask(Function&lt;void()&gt;&amp;&amp; task)</span>
<span class="line-added">249 {</span>
<span class="line-added">250     auto* context = scriptExecutionContext();</span>
<span class="line-added">251     if (!context)</span>
<span class="line-added">252         return;</span>
<span class="line-added">253 </span>
<span class="line-added">254     static uint64_t taskIdentifierSeed = 0;</span>
<span class="line-added">255     uint64_t taskIdentifier = ++taskIdentifierSeed;</span>
<span class="line-added">256     m_pendingTasks.add(taskIdentifier, WTFMove(task));</span>
<span class="line-added">257     context-&gt;eventLoop().queueTask(TaskSource::FileReading, [this, protectedThis = makeRef(*this), pendingActivity = makePendingActivity(*this), taskIdentifier] {</span>
<span class="line-added">258         auto task = m_pendingTasks.take(taskIdentifier);</span>
<span class="line-added">259         if (task)</span>
<span class="line-added">260             task();</span>
<span class="line-added">261     });</span>
<span class="line-added">262 }</span>
<span class="line-added">263 </span>
264 } // namespace WebCore
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
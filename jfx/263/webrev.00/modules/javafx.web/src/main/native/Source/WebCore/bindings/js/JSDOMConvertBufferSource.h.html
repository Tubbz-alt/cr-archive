<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertBufferSource.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;BufferSource.h&quot;
 29 #include &quot;IDLTypes.h&quot;
 30 #include &quot;JSDOMConvertBase.h&quot;
 31 #include &quot;JSDOMWrapperCache.h&quot;
 32 #include &lt;JavaScriptCore/JSTypedArrays.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 struct IDLInt8Array : IDLTypedArray&lt;JSC::Int8Array&gt; { };
 37 struct IDLInt16Array : IDLTypedArray&lt;JSC::Int16Array&gt; { };
 38 struct IDLInt32Array : IDLTypedArray&lt;JSC::Int32Array&gt; { };
 39 struct IDLUint8Array : IDLTypedArray&lt;JSC::Uint8Array&gt; { };
 40 struct IDLUint16Array : IDLTypedArray&lt;JSC::Uint16Array&gt; { };
 41 struct IDLUint32Array : IDLTypedArray&lt;JSC::Uint32Array&gt; { };
 42 struct IDLUint8ClampedArray : IDLTypedArray&lt;JSC::Uint8ClampedArray&gt; { };
 43 struct IDLFloat32Array : IDLTypedArray&lt;JSC::Float32Array&gt; { };
 44 struct IDLFloat64Array : IDLTypedArray&lt;JSC::Float64Array&gt; { };
 45 
 46 inline RefPtr&lt;JSC::Int8Array&gt; toPossiblySharedInt8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Int8Adaptor&gt;(vm, value); }
 47 inline RefPtr&lt;JSC::Int16Array&gt; toPossiblySharedInt16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Int16Adaptor&gt;(vm, value); }
 48 inline RefPtr&lt;JSC::Int32Array&gt; toPossiblySharedInt32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Int32Adaptor&gt;(vm, value); }
 49 inline RefPtr&lt;JSC::Uint8Array&gt; toPossiblySharedUint8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint8Adaptor&gt;(vm, value); }
 50 inline RefPtr&lt;JSC::Uint8ClampedArray&gt; toPossiblySharedUint8ClampedArray(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint8ClampedAdaptor&gt;(vm, value); }
 51 inline RefPtr&lt;JSC::Uint16Array&gt; toPossiblySharedUint16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint16Adaptor&gt;(vm, value); }
 52 inline RefPtr&lt;JSC::Uint32Array&gt; toPossiblySharedUint32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint32Adaptor&gt;(vm, value); }
 53 inline RefPtr&lt;JSC::Float32Array&gt; toPossiblySharedFloat32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Float32Adaptor&gt;(vm, value); }
 54 inline RefPtr&lt;JSC::Float64Array&gt; toPossiblySharedFloat64Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Float64Adaptor&gt;(vm, value); }
 55 
 56 inline RefPtr&lt;JSC::Int8Array&gt; toUnsharedInt8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Int8Adaptor&gt;(vm, value); }
 57 inline RefPtr&lt;JSC::Int16Array&gt; toUnsharedInt16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Int16Adaptor&gt;(vm, value); }
 58 inline RefPtr&lt;JSC::Int32Array&gt; toUnsharedInt32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Int32Adaptor&gt;(vm, value); }
 59 inline RefPtr&lt;JSC::Uint8Array&gt; toUnsharedUint8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint8Adaptor&gt;(vm, value); }
 60 inline RefPtr&lt;JSC::Uint8ClampedArray&gt; toUnsharedUint8ClampedArray(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint8ClampedAdaptor&gt;(vm, value); }
 61 inline RefPtr&lt;JSC::Uint16Array&gt; toUnsharedUint16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint16Adaptor&gt;(vm, value); }
 62 inline RefPtr&lt;JSC::Uint32Array&gt; toUnsharedUint32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint32Adaptor&gt;(vm, value); }
 63 inline RefPtr&lt;JSC::Float32Array&gt; toUnsharedFloat32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Float32Adaptor&gt;(vm, value); }
 64 inline RefPtr&lt;JSC::Float64Array&gt; toUnsharedFloat64Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Float64Adaptor&gt;(vm, value); }
 65 
 66 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, JSC::ArrayBuffer&amp; buffer)
 67 {
 68     if (auto result = getCachedWrapper(globalObject-&gt;world(), buffer))
 69         return result;
 70 
 71     // The JSArrayBuffer::create function will register the wrapper in finishCreation.
 72     return JSC::JSArrayBuffer::create(JSC::getVM(lexicalGlobalObject), globalObject-&gt;arrayBufferStructure(buffer.sharingMode()), &amp;buffer);
 73 }
 74 
 75 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSGlobalObject* globalObject, JSC::ArrayBufferView&amp; view)
 76 {
 77     return view.wrap(lexicalGlobalObject, globalObject);
 78 }
 79 
 80 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, JSC::ArrayBuffer* buffer)
 81 {
 82     if (!buffer)
 83         return JSC::jsNull();
 84     return toJS(lexicalGlobalObject, globalObject, *buffer);
 85 }
 86 
 87 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSGlobalObject* globalObject, JSC::ArrayBufferView* view)
 88 {
 89     if (!view)
 90         return JSC::jsNull();
 91     return toJS(lexicalGlobalObject, globalObject, *view);
 92 }
 93 
 94 inline RefPtr&lt;JSC::ArrayBufferView&gt; toPossiblySharedArrayBufferView(JSC::VM&amp; vm, JSC::JSValue value)
 95 {
 96     auto* wrapper = JSC::jsDynamicCast&lt;JSC::JSArrayBufferView*&gt;(vm, value);
 97     if (!wrapper)
 98         return nullptr;
 99     return wrapper-&gt;possiblySharedImpl();
100 }
101 
102 inline RefPtr&lt;JSC::ArrayBufferView&gt; toUnsharedArrayBufferView(JSC::VM&amp; vm, JSC::JSValue value)
103 {
104     auto result = toPossiblySharedArrayBufferView(vm, value);
105     if (!result || result-&gt;isShared())
106         return nullptr;
107     return result;
108 }
109 
110 namespace Detail {
111 
112 template&lt;typename BufferSourceType&gt;
113 struct BufferSourceConverter {
114     using WrapperType = typename Converter&lt;BufferSourceType&gt;::WrapperType;
115     using ReturnType = typename Converter&lt;BufferSourceType&gt;::ReturnType;
116 
117     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
118     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())
119     {
120         auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);
121         auto scope = DECLARE_THROW_SCOPE(vm);
122         ReturnType object = WrapperType::toWrapped(vm, value);
123         if (UNLIKELY(!object))
124             exceptionThrower(lexicalGlobalObject, scope);
125         return object;
126     }
127 };
128 
129 }
130 
131 template&lt;&gt; struct Converter&lt;IDLArrayBuffer&gt; : DefaultConverter&lt;IDLArrayBuffer&gt; {
132     using WrapperType = JSC::JSArrayBuffer;
133     using ReturnType = JSC::ArrayBuffer*;
134 
135     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
136     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())
137     {
138         return Detail::BufferSourceConverter&lt;IDLArrayBuffer&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));
139     }
140 };
141 
142 template&lt;&gt; struct JSConverter&lt;IDLArrayBuffer&gt; {
143     static constexpr bool needsState = true;
144     static constexpr bool needsGlobalObject = true;
145 
146     template &lt;typename U&gt;
147     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)
148     {
149         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));
150     }
151 };
152 
153 template&lt;&gt; struct Converter&lt;IDLDataView&gt; : DefaultConverter&lt;IDLDataView&gt; {
154     using WrapperType = JSC::JSDataView;
155     using ReturnType = RefPtr&lt;JSC::DataView&gt;;
156 
157     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
158     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())
159     {
160         return Detail::BufferSourceConverter&lt;IDLDataView&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));
161     }
162 };
163 
164 template&lt;&gt; struct JSConverter&lt;IDLDataView&gt; {
165     static constexpr bool needsState = true;
166     static constexpr bool needsGlobalObject = true;
167 
168     template &lt;typename U&gt;
169     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)
170     {
171         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));
172     }
173 };
174 
175 template&lt;&gt; struct Converter&lt;IDLInt8Array&gt; : DefaultConverter&lt;IDLInt8Array&gt; {
176     using WrapperType = JSC::JSInt8Array;
177     using ReturnType = RefPtr&lt;JSC::Int8Array&gt;;
178 
179     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
180     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())
181     {
182         return Detail::BufferSourceConverter&lt;IDLInt8Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));
183     }
184 };
185 
186 template&lt;&gt; struct JSConverter&lt;IDLInt8Array&gt; {
187     static constexpr bool needsState = true;
188     static constexpr bool needsGlobalObject = true;
189 
190     template &lt;typename U&gt;
191     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)
192     {
193         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));
194     }
195 };
196 
197 template&lt;&gt; struct Converter&lt;IDLInt16Array&gt; : DefaultConverter&lt;IDLInt16Array&gt; {
198     using WrapperType = JSC::JSInt16Array;
199     using ReturnType = RefPtr&lt;JSC::Int16Array&gt;;
200 
201     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
202     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())
203     {
204         return Detail::BufferSourceConverter&lt;IDLInt16Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));
205     }
206 };
207 
208 template&lt;&gt; struct JSConverter&lt;IDLInt16Array&gt; {
209     static constexpr bool needsState = true;
210     static constexpr bool needsGlobalObject = true;
211 
212     template &lt;typename U&gt;
213     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)
214     {
215         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));
216     }
217 };
218 
219 template&lt;&gt; struct Converter&lt;IDLInt32Array&gt; : DefaultConverter&lt;IDLInt32Array&gt; {
220     using WrapperType = JSC::JSInt32Array;
221     using ReturnType = RefPtr&lt;JSC::Int32Array&gt;;
222 
223     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
224     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())
225     {
226         return Detail::BufferSourceConverter&lt;IDLInt32Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));
227     }
228 };
229 
230 template&lt;&gt; struct JSConverter&lt;IDLInt32Array&gt; {
231     static constexpr bool needsState = true;
232     static constexpr bool needsGlobalObject = true;
233 
234     template &lt;typename U&gt;
235     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)
236     {
237         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));
238     }
239 };
240 
241 template&lt;&gt; struct Converter&lt;IDLUint8Array&gt; : DefaultConverter&lt;IDLUint8Array&gt; {
242     using WrapperType = JSC::JSUint8Array;
243     using ReturnType = RefPtr&lt;JSC::Uint8Array&gt;;
244 
245     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
246     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())
247     {
248         return Detail::BufferSourceConverter&lt;IDLUint8Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));
249     }
250 };
251 
252 template&lt;&gt; struct JSConverter&lt;IDLUint8Array&gt; {
253     static constexpr bool needsState = true;
254     static constexpr bool needsGlobalObject = true;
255 
256     template &lt;typename U&gt;
257     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)
258     {
259         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));
260     }
261 };
262 
263 template&lt;&gt; struct Converter&lt;IDLUint16Array&gt; : DefaultConverter&lt;IDLUint16Array&gt; {
264     using WrapperType = JSC::JSUint16Array;
265     using ReturnType = RefPtr&lt;JSC::Uint16Array&gt;;
266 
267     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
268     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())
269     {
270         return Detail::BufferSourceConverter&lt;IDLUint16Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));
271     }
272 };
273 
274 template&lt;&gt; struct JSConverter&lt;IDLUint16Array&gt; {
275     static constexpr bool needsState = true;
276     static constexpr bool needsGlobalObject = true;
277 
278     template &lt;typename U&gt;
279     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)
280     {
281         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));
282     }
283 };
284 
285 template&lt;&gt; struct Converter&lt;IDLUint32Array&gt; : DefaultConverter&lt;IDLUint32Array&gt; {
286     using WrapperType = JSC::JSUint32Array;
287     using ReturnType = RefPtr&lt;JSC::Uint32Array&gt;;
288 
289     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
290     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())
291     {
292         return Detail::BufferSourceConverter&lt;IDLUint32Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));
293     }
294 };
295 
296 template&lt;&gt; struct JSConverter&lt;IDLUint32Array&gt; {
297     static constexpr bool needsState = true;
298     static constexpr bool needsGlobalObject = true;
299 
300     template &lt;typename U&gt;
301     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)
302     {
303         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));
304     }
305 };
306 
307 template&lt;&gt; struct Converter&lt;IDLUint8ClampedArray&gt; : DefaultConverter&lt;IDLUint8ClampedArray&gt; {
308     using WrapperType = JSC::JSUint8ClampedArray;
309     using ReturnType = RefPtr&lt;JSC::Uint8ClampedArray&gt;;
310 
311     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
312     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())
313     {
314         return Detail::BufferSourceConverter&lt;IDLUint8ClampedArray&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));
315     }
316 };
317 
318 template&lt;&gt; struct JSConverter&lt;IDLUint8ClampedArray&gt; {
319     static constexpr bool needsState = true;
320     static constexpr bool needsGlobalObject = true;
321 
322     template &lt;typename U&gt;
323     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)
324     {
325         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));
326     }
327 };
328 
329 template&lt;&gt; struct Converter&lt;IDLFloat32Array&gt; : DefaultConverter&lt;IDLFloat32Array&gt; {
330     using WrapperType = JSC::JSFloat32Array;
331     using ReturnType = RefPtr&lt;JSC::Float32Array&gt;;
332 
333     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
334     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())
335     {
336         return Detail::BufferSourceConverter&lt;IDLFloat32Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));
337     }
338 };
339 
340 template&lt;&gt; struct JSConverter&lt;IDLFloat32Array&gt; {
341     static constexpr bool needsState = true;
342     static constexpr bool needsGlobalObject = true;
343 
344     template &lt;typename U&gt;
345     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)
346     {
347         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));
348     }
349 };
350 
351 template&lt;&gt; struct Converter&lt;IDLFloat64Array&gt; : DefaultConverter&lt;IDLFloat64Array&gt; {
352     using WrapperType = JSC::JSFloat64Array;
353     using ReturnType = RefPtr&lt;JSC::Float64Array&gt;;
354 
355     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
356     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())
357     {
358         return Detail::BufferSourceConverter&lt;IDLFloat64Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));
359     }
360 };
361 
362 template&lt;&gt; struct JSConverter&lt;IDLFloat64Array&gt; {
363     static constexpr bool needsState = true;
364     static constexpr bool needsGlobalObject = true;
365 
366     template &lt;typename U&gt;
367     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)
368     {
369         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));
370     }
371 };
372 
373 template&lt;&gt; struct Converter&lt;IDLArrayBufferView&gt; : DefaultConverter&lt;IDLArrayBufferView&gt; {
374     using WrapperType = JSC::JSArrayBufferView;
375     using ReturnType = RefPtr&lt;JSC::ArrayBufferView&gt;;
376 
377     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
378     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())
379     {
380         return Detail::BufferSourceConverter&lt;IDLArrayBufferView&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));
381     }
382 };
383 
384 template&lt;&gt; struct JSConverter&lt;IDLArrayBufferView&gt; {
385     static constexpr bool needsState = true;
386     static constexpr bool needsGlobalObject = true;
387 
388     template &lt;typename U&gt;
389     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)
390     {
391         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));
392     }
393 };
394 
395 } // namespace WebCore
    </pre>
  </body>
</html>
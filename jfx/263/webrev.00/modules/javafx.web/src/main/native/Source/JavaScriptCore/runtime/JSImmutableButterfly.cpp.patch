diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSImmutableButterfly.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSImmutableButterfly.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSImmutableButterfly.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSImmutableButterfly.cpp
@@ -24,10 +24,11 @@
  */
 
 #include "config.h"
 #include "JSImmutableButterfly.h"
 
+#include "ButterflyInlines.h"
 #include "CodeBlock.h"
 
 namespace JSC {
 
 const ClassInfo JSImmutableButterfly::s_info = { "Immutable Butterfly", nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSImmutableButterfly) };
@@ -43,17 +44,17 @@
 
     Butterfly* butterfly = jsCast<JSImmutableButterfly*>(cell)->toButterfly();
     visitor.appendValuesHidden(butterfly->contiguous().data(), butterfly->publicLength());
 }
 
-void JSImmutableButterfly::copyToArguments(ExecState* exec, VirtualRegister firstElementDest, unsigned offset, unsigned length)
+void JSImmutableButterfly::copyToArguments(JSGlobalObject*, JSValue* firstElementDest, unsigned offset, unsigned length)
 {
     for (unsigned i = 0; i < length; ++i) {
         if ((i + offset) < publicLength())
-            exec->r(firstElementDest + i) = get(i + offset);
+            firstElementDest[i] = get(i + offset);
         else
-            exec->r(firstElementDest + i) = jsUndefined();
+            firstElementDest[i] = jsUndefined();
     }
 }
 
 static_assert(JSImmutableButterfly::offsetOfData() == sizeof(JSImmutableButterfly), "m_header needs to be adjacent to Data");
 

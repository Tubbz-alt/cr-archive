diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LowLevelInterpreter.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LowLevelInterpreter.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LowLevelInterpreter.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LowLevelInterpreter.cpp
@@ -142,11 +142,10 @@
     ALWAYS_INLINE intptr_t* ip() const { return bitwise_cast<intptr_t*>(m_value); }
     ALWAYS_INLINE int8_t* i8p() const { return bitwise_cast<int8_t*>(m_value); }
     ALWAYS_INLINE void* vp() const { return bitwise_cast<void*>(m_value); }
     ALWAYS_INLINE const void* cvp() const { return bitwise_cast<const void*>(m_value); }
     ALWAYS_INLINE CallFrame* callFrame() const { return bitwise_cast<CallFrame*>(m_value); }
-    ALWAYS_INLINE ExecState* execState() const { return bitwise_cast<ExecState*>(m_value); }
     ALWAYS_INLINE const void* instruction() const { return bitwise_cast<const void*>(m_value); }
     ALWAYS_INLINE VM* vm() const { return bitwise_cast<VM*>(m_value); }
     ALWAYS_INLINE JSCell* cell() const { return bitwise_cast<JSCell*>(m_value); }
     ALWAYS_INLINE ProtoCallFrame* protoCallFrame() const { return bitwise_cast<ProtoCallFrame*>(m_value); }
     ALWAYS_INLINE NativeFunction nativeFunc() const { return bitwise_cast<NativeFunction>(m_value); }
@@ -155,11 +154,11 @@
     ALWAYS_INLINE uint64_t u64() const { return m_value; }
     ALWAYS_INLINE EncodedJSValue encodedJSValue() const { return bitwise_cast<EncodedJSValue>(m_value); }
 #endif
     ALWAYS_INLINE Opcode opcode() const { return bitwise_cast<Opcode>(m_value); }
 
-    operator ExecState*() { return bitwise_cast<ExecState*>(m_value); }
+    operator CallFrame*() { return bitwise_cast<CallFrame*>(m_value); }
     operator const Instruction*() { return bitwise_cast<const Instruction*>(m_value); }
     operator JSCell*() { return bitwise_cast<JSCell*>(m_value); }
     operator ProtoCallFrame*() { return bitwise_cast<ProtoCallFrame*>(m_value); }
     operator Register*() { return bitwise_cast<Register*>(m_value); }
     operator VM*() { return bitwise_cast<VM*>(m_value); }
@@ -279,11 +278,11 @@
 
         // Note: we can only set the exceptionInstructions after we have
         // initialized the opcodeMap above. This is because getCodePtr()
         // can depend on the opcodeMap.
         uint8_t* exceptionInstructions = reinterpret_cast<uint8_t*>(LLInt::exceptionInstructions());
-        for (int i = 0; i < maxOpcodeLength + 1; ++i)
+        for (unsigned i = 0; i < maxOpcodeLength + 1; ++i)
             exceptionInstructions[i] = llint_throw_from_slow_path_trampoline;
 
         return JSValue();
     }
 
@@ -314,12 +313,13 @@
     // 2. 32 bit result values will be in the low 32-bit of t0.
     // 3. 64 bit result values will be in t0.
 
     CLoopRegister t0, t1, t2, t3, t5, sp, cfr, lr, pc;
 #if USE(JSVALUE64)
-    CLoopRegister pcBase, tagTypeNumber, tagMask;
+    CLoopRegister numberTag, notCellMask;
 #endif
+    CLoopRegister pcBase;
     CLoopRegister metadataTable;
     CLoopDoubleRegister d0, d1;
 
     struct StackPointerScope {
         StackPointerScope(CLoopStack& stack)
@@ -354,12 +354,12 @@
     t2 = protoCallFrame;
 
 #if USE(JSVALUE64)
     // For the ASM llint, JITStubs takes care of this initialization. We do
     // it explicitly here for the C loop:
-    tagTypeNumber = 0xFFFF000000000000;
-    tagMask = 0xFFFF000000000002;
+    numberTag = JSValue::NumberTag;
+    notCellMask = JSValue::NotCellMask;
 #endif // USE(JSVALUE64)
 
     // Interpreter variables for value passing between opcodes and/or helpers:
     NativeFunction nativeFunc = nullptr;
     JSValue functionReturnValue;
@@ -381,22 +381,10 @@
 #define RECORD_OPCODE_STATS(__opcode) OpcodeStats::recordInstruction(__opcode)
 #else
 #define RECORD_OPCODE_STATS(__opcode)
 #endif
 
-#if USE(JSVALUE32_64)
-#define FETCH_OPCODE() *pc.i8p
-#else // USE(JSVALUE64)
-#define FETCH_OPCODE() *bitwise_cast<OpcodeID*>(pcBase.i8p + pc.i)
-#endif // USE(JSVALUE64)
-
-#define NEXT_INSTRUCTION() \
-    do {                         \
-        opcode = FETCH_OPCODE(); \
-        DISPATCH_OPCODE();       \
-    } while (false)
-
 #if ENABLE(COMPUTED_GOTO_OPCODES)
 
     //========================================================================
     // Loop dispatch mechanism using computed goto statements:
 
@@ -483,11 +471,10 @@
         UNUSED_LABEL(__opcode);
         FOR_EACH_OPCODE_ID(LLINT_OPCODE_ENTRY);
     #undef LLINT_OPCODE_ENTRY
 #endif
 
-    #undef NEXT_INSTRUCTION
     #undef DEFINE_OPCODE
     #undef CHECK_FOR_TIMEOUT
     #undef CAST
 
     return JSValue(); // to suppress a compiler warning.
@@ -503,11 +490,11 @@
 
 // These are for building an interpreter from generated assembly code:
 #define OFFLINE_ASM_BEGIN   asm (
 #define OFFLINE_ASM_END     );
 
-#if USE(LLINT_EMBEDDED_OPCODE_ID)
+#if ENABLE(LLINT_EMBEDDED_OPCODE_ID)
 #define EMBED_OPCODE_ID_IF_NEEDED(__opcode) ".int " __opcode##_value_string "\n"
 #else
 #define EMBED_OPCODE_ID_IF_NEEDED(__opcode)
 #endif
 

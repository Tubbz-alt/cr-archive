<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/FileInputType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FeaturePolicy.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FileListCreator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/FileInputType.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
158     ASSERT(fileList);
159 
160     auto name = element()-&gt;name();
161 
162     if (!multipart) {
163         // Send only the basenames.
164         // 4.10.16.4 and 4.10.16.6 sections in HTML5.
165 
166         // Unlike the multipart case, we have no special handling for the empty
167         // fileList because Netscape doesn&#39;t support for non-multipart
168         // submission of file inputs, and Firefox doesn&#39;t add &quot;name=&quot; query
169         // parameter.
170         for (auto&amp; file : fileList-&gt;files())
171             formData.append(name, file-&gt;name());
172         return true;
173     }
174 
175     // If no filename at all is entered, return successful but empty.
176     // Null would be more logical, but Netscape posts an empty file. Argh.
177     if (fileList-&gt;isEmpty()) {
<span class="line-modified">178         formData.append(name, File::create(element()-&gt;document().sessionID(), emptyString()));</span>
179         return true;
180     }
181 
182 
183     for (auto&amp; file : fileList-&gt;files())
184         formData.append(name, file.get());
185     return true;
186 }
187 
188 bool FileInputType::valueMissing(const String&amp; value) const
189 {
190     ASSERT(element());
191     return element()-&gt;isRequired() &amp;&amp; value.isEmpty();
192 }
193 
194 String FileInputType::valueMissingText() const
195 {
196     ASSERT(element());
197     return element()-&gt;multiple() ? validationMessageValueMissingForMultipleFileText() : validationMessageValueMissingForFileText();
198 }
</pre>
<hr />
<pre>
382 
383     m_fileList = files.releaseNonNull();
384 
385     protectedInputElement-&gt;setFormControlValueMatchesRenderer(true);
386     protectedInputElement-&gt;updateValidity();
387 
388     if (shouldRequestIcon == RequestIcon::Yes) {
389         Vector&lt;String&gt; paths;
390         paths.reserveInitialCapacity(length);
391         for (auto&amp; file : m_fileList-&gt;files())
392             paths.uncheckedAppend(file-&gt;path());
393         requestIcon(paths);
394     }
395 
396     if (protectedInputElement-&gt;renderer())
397         protectedInputElement-&gt;renderer()-&gt;repaint();
398 
399     if (pathsChanged) {
400         // This call may cause destruction of this instance.
401         // input instance is safe since it is ref-counted.

402         protectedInputElement-&gt;dispatchChangeEvent();
403     }
404     protectedInputElement-&gt;setChangedSinceLastFormControlChangeEvent(false);
405 }
406 
407 void FileInputType::filesChosen(const Vector&lt;FileChooserFileInfo&gt;&amp; paths, const String&amp; displayString, Icon* icon)
408 {
409     if (!displayString.isEmpty())
410         m_displayString = displayString;
411 
412     if (m_fileListCreator)
413         m_fileListCreator-&gt;cancel();
414 
415     auto shouldResolveDirectories = allowsDirectories() ? FileListCreator::ShouldResolveDirectories::Yes : FileListCreator::ShouldResolveDirectories::No;
416     auto shouldRequestIcon = icon ? RequestIcon::Yes : RequestIcon::No;
<span class="line-modified">417     m_fileListCreator = FileListCreator::create(element()-&gt;document().sessionID(), paths, shouldResolveDirectories, [this, shouldRequestIcon](Ref&lt;FileList&gt;&amp;&amp; fileList) {</span>
418         setFiles(WTFMove(fileList), shouldRequestIcon);
419         m_fileListCreator = nullptr;
420     });
421 
422     if (icon &amp;&amp; !m_fileList-&gt;isEmpty())
423         iconLoaded(icon);
424 }
425 
426 String FileInputType::displayString() const
427 {
428     return m_displayString;
429 }
430 
431 void FileInputType::iconLoaded(RefPtr&lt;Icon&gt;&amp;&amp; icon)
432 {
433     if (m_icon == icon)
434         return;
435 
436     m_icon = WTFMove(icon);
437     ASSERT(element());
</pre>
</td>
<td>
<hr />
<pre>
158     ASSERT(fileList);
159 
160     auto name = element()-&gt;name();
161 
162     if (!multipart) {
163         // Send only the basenames.
164         // 4.10.16.4 and 4.10.16.6 sections in HTML5.
165 
166         // Unlike the multipart case, we have no special handling for the empty
167         // fileList because Netscape doesn&#39;t support for non-multipart
168         // submission of file inputs, and Firefox doesn&#39;t add &quot;name=&quot; query
169         // parameter.
170         for (auto&amp; file : fileList-&gt;files())
171             formData.append(name, file-&gt;name());
172         return true;
173     }
174 
175     // If no filename at all is entered, return successful but empty.
176     // Null would be more logical, but Netscape posts an empty file. Argh.
177     if (fileList-&gt;isEmpty()) {
<span class="line-modified">178         formData.append(name, File::create(emptyString()));</span>
179         return true;
180     }
181 
182 
183     for (auto&amp; file : fileList-&gt;files())
184         formData.append(name, file.get());
185     return true;
186 }
187 
188 bool FileInputType::valueMissing(const String&amp; value) const
189 {
190     ASSERT(element());
191     return element()-&gt;isRequired() &amp;&amp; value.isEmpty();
192 }
193 
194 String FileInputType::valueMissingText() const
195 {
196     ASSERT(element());
197     return element()-&gt;multiple() ? validationMessageValueMissingForMultipleFileText() : validationMessageValueMissingForFileText();
198 }
</pre>
<hr />
<pre>
382 
383     m_fileList = files.releaseNonNull();
384 
385     protectedInputElement-&gt;setFormControlValueMatchesRenderer(true);
386     protectedInputElement-&gt;updateValidity();
387 
388     if (shouldRequestIcon == RequestIcon::Yes) {
389         Vector&lt;String&gt; paths;
390         paths.reserveInitialCapacity(length);
391         for (auto&amp; file : m_fileList-&gt;files())
392             paths.uncheckedAppend(file-&gt;path());
393         requestIcon(paths);
394     }
395 
396     if (protectedInputElement-&gt;renderer())
397         protectedInputElement-&gt;renderer()-&gt;repaint();
398 
399     if (pathsChanged) {
400         // This call may cause destruction of this instance.
401         // input instance is safe since it is ref-counted.
<span class="line-added">402         protectedInputElement-&gt;dispatchInputEvent();</span>
403         protectedInputElement-&gt;dispatchChangeEvent();
404     }
405     protectedInputElement-&gt;setChangedSinceLastFormControlChangeEvent(false);
406 }
407 
408 void FileInputType::filesChosen(const Vector&lt;FileChooserFileInfo&gt;&amp; paths, const String&amp; displayString, Icon* icon)
409 {
410     if (!displayString.isEmpty())
411         m_displayString = displayString;
412 
413     if (m_fileListCreator)
414         m_fileListCreator-&gt;cancel();
415 
416     auto shouldResolveDirectories = allowsDirectories() ? FileListCreator::ShouldResolveDirectories::Yes : FileListCreator::ShouldResolveDirectories::No;
417     auto shouldRequestIcon = icon ? RequestIcon::Yes : RequestIcon::No;
<span class="line-modified">418     m_fileListCreator = FileListCreator::create(paths, shouldResolveDirectories, [this, shouldRequestIcon](Ref&lt;FileList&gt;&amp;&amp; fileList) {</span>
419         setFiles(WTFMove(fileList), shouldRequestIcon);
420         m_fileListCreator = nullptr;
421     });
422 
423     if (icon &amp;&amp; !m_fileList-&gt;isEmpty())
424         iconLoaded(icon);
425 }
426 
427 String FileInputType::displayString() const
428 {
429     return m_displayString;
430 }
431 
432 void FileInputType::iconLoaded(RefPtr&lt;Icon&gt;&amp;&amp; icon)
433 {
434     if (m_icon == icon)
435         return;
436 
437     m_icon = WTFMove(icon);
438     ASSERT(element());
</pre>
</td>
</tr>
</table>
<center><a href="FeaturePolicy.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FileListCreator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
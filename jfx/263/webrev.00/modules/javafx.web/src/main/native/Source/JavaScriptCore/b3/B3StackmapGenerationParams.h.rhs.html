<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3StackmapGenerationParams.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015-2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;AirGenerationContext.h&quot;
 31 #include &quot;B3ValueRep.h&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 32 #include &quot;MacroAssembler.h&quot;</span>
 33 #include &quot;RegisterSet.h&quot;
 34 #include &lt;wtf/Box.h&gt;
 35 
<a name="2" id="anc2"></a><span class="line-modified"> 36 namespace JSC {</span>
<span class="line-added"> 37 </span>
<span class="line-added"> 38 class CCallHelpers;</span>
<span class="line-added"> 39 </span>
<span class="line-added"> 40 namespace B3 {</span>
 41 
 42 class CheckSpecial;
 43 class PatchpointSpecial;
 44 class Procedure;
 45 class StackmapValue;
 46 
 47 // NOTE: It&#39;s possible to capture StackmapGenerationParams by value, but not all of the methods will
 48 // work if you do that.
 49 class StackmapGenerationParams {
 50 public:
 51     // This is the stackmap value that we&#39;re generating.
 52     StackmapValue* value() const { return m_value; }
 53 
 54     // This tells you the actual value representations that were chosen. This is usually different
 55     // from the constraints we supplied.
 56     const Vector&lt;ValueRep&gt;&amp; reps() const { return m_reps; };
 57 
 58     // Usually we wish to access the reps. We make this easy by making ourselves appear to be a
 59     // collection of reps.
 60     unsigned size() const { return m_reps.size(); }
 61     const ValueRep&amp; at(unsigned index) const { return m_reps[index]; }
 62     const ValueRep&amp; operator[](unsigned index) const { return at(index); }
 63     Vector&lt;ValueRep&gt;::const_iterator begin() const { return m_reps.begin(); }
 64     Vector&lt;ValueRep&gt;::const_iterator end() const { return m_reps.end(); }
 65 
 66     // This tells you the registers that were used.
 67     // NOTE: This will report bogus information if you did proc.setNeedsUsedRegisters(false).
 68     const RegisterSet&amp; usedRegisters() const;
 69 
 70     // This is a useful helper if you want to do register allocation inside of a patchpoint. The
 71     // usedRegisters() set is not directly useful for this purpose because:
 72     //
 73     // - You can only use callee-save registers for scratch if they were saved in the prologue. So,
 74     //   if a register is callee-save, it&#39;s not enough that it&#39;s not in usedRegisters().
 75     //
 76     // - Scratch registers are going to be in usedRegisters() at the patchpoint. So, if you want to
 77     //   find one of your requested scratch registers using usedRegisters(), you&#39;ll have a bad time.
 78     //
 79     // This gives you the used register set that&#39;s useful for allocating scratch registers. This set
 80     // is defined as:
 81     //
 82     //     (usedRegisters() | (RegisterSet::calleeSaveRegisters() - proc.calleeSaveRegisters()))
 83     //     - gpScratchRegisters - fpScratchRegisters
 84     //
 85     // I.e. it is like usedRegisters() but also includes unsaved callee-saves and excludes scratch
 86     // registers.
 87     //
 88     // NOTE: This will report bogus information if you did proc.setNeedsUsedRegisters(false).
 89     JS_EXPORT_PRIVATE RegisterSet unavailableRegisters() const;
 90 
 91     GPRReg gpScratch(unsigned index) const { return m_gpScratch[index]; }
 92     FPRReg fpScratch(unsigned index) const { return m_fpScratch[index]; }
 93 
 94     // This is computed lazily, so it won&#39;t work if you capture StackmapGenerationParams by value.
 95     // These labels will get populated before any late paths or link tasks execute.
<a name="3" id="anc3"></a><span class="line-modified"> 96     JS_EXPORT_PRIVATE Vector&lt;Box&lt;MacroAssembler::Label&gt;&gt; successorLabels() const;</span>
 97 
 98     // This is computed lazily, so it won&#39;t work if you capture StackmapGenerationParams by value.
 99     // Returns true if the successor at the given index is going to be emitted right after the
100     // patchpoint.
101     JS_EXPORT_PRIVATE bool fallsThroughToSuccessor(unsigned successorIndex) const;
102 
<a name="4" id="anc4"></a><span class="line-modified">103     // These are provided for convenience; they mean that you don&#39;t have to capture them if you don&#39;t want to.</span>
104     JS_EXPORT_PRIVATE Procedure&amp; proc() const;
<a name="5" id="anc5"></a><span class="line-added">105     JS_EXPORT_PRIVATE Air::Code&amp; code() const;</span>
106 
107     // The Air::GenerationContext gives you even more power.
108     Air::GenerationContext&amp; context() const { return m_context; };
109 
110     template&lt;typename Functor&gt;
111     void addLatePath(const Functor&amp; functor) const
112     {
113         context().latePaths.append(
114             createSharedTask&lt;Air::GenerationContext::LatePathFunction&gt;(
115                 [=] (CCallHelpers&amp; jit, Air::GenerationContext&amp;) {
116                     functor(jit);
117                 }));
118     }
119 
120 private:
121     friend class CheckSpecial;
122     friend class PatchpointSpecial;
123 
124     StackmapGenerationParams(StackmapValue*, const Vector&lt;ValueRep&gt;&amp; reps, Air::GenerationContext&amp;);
125 
126     StackmapValue* m_value;
127     Vector&lt;ValueRep&gt; m_reps;
128     Vector&lt;GPRReg&gt; m_gpScratch;
129     Vector&lt;FPRReg&gt; m_fpScratch;
130     Air::GenerationContext&amp; m_context;
131 };
132 
133 } } // namespace JSC::B3
134 
135 #endif // ENABLE(B3_JIT)
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
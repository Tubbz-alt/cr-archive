<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSScope.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012-2017 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSScope.h&quot;
 28 
 29 #include &quot;AbstractModuleRecord.h&quot;
 30 #include &quot;Exception.h&quot;
 31 #include &quot;JSGlobalObject.h&quot;
 32 #include &quot;JSLexicalEnvironment.h&quot;
 33 #include &quot;JSModuleEnvironment.h&quot;
 34 #include &quot;JSWithScope.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 #include &quot;VariableEnvironment.h&quot;
 37 
 38 namespace JSC {
 39 
 40 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSScope);
 41 
 42 const ClassInfo JSScope::s_info = { &quot;Scope&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSScope) };
 43 
 44 void JSScope::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 45 {
 46     JSScope* thisObject = jsCast&lt;JSScope*&gt;(cell);
 47     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 48     Base::visitChildren(thisObject, visitor);
 49     visitor.append(thisObject-&gt;m_next);
 50 }
 51 
 52 // Returns true if we found enough information to terminate optimization.
<a name="1" id="anc1"></a><span class="line-modified"> 53 static inline bool abstractAccess(JSGlobalObject* globalObject, JSScope* scope, const Identifier&amp; ident, GetOrPut getOrPut, size_t depth, bool&amp; needsVarInjectionChecks, ResolveOp&amp; op, InitializationMode initializationMode)</span>
 54 {
<a name="2" id="anc2"></a><span class="line-modified"> 55     VM&amp; vm = globalObject-&gt;vm();</span>
 56     auto throwScope = DECLARE_THROW_SCOPE(vm);
 57 
 58     if (scope-&gt;isJSLexicalEnvironment()) {
 59         JSLexicalEnvironment* lexicalEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
 60 
 61         SymbolTable* symbolTable = lexicalEnvironment-&gt;symbolTable();
 62         {
 63             ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
 64             auto iter = symbolTable-&gt;find(locker, ident.impl());
 65             if (iter != symbolTable-&gt;end(locker)) {
 66                 SymbolTableEntry&amp; entry = iter-&gt;value;
 67                 ASSERT(!entry.isNull());
 68                 if (entry.isReadOnly() &amp;&amp; getOrPut == Put) {
 69                     // We know the property will be at this lexical environment scope, but we don&#39;t know how to cache it.
 70                     op = ResolveOp(Dynamic, 0, 0, 0, 0, 0);
 71                     return true;
 72                 }
 73 
 74                 op = ResolveOp(makeType(ClosureVar, needsVarInjectionChecks), depth, 0, lexicalEnvironment, entry.watchpointSet(), entry.scopeOffset().offset());
 75                 return true;
 76             }
 77         }
 78 
 79         if (scope-&gt;type() == ModuleEnvironmentType) {
 80             JSModuleEnvironment* moduleEnvironment = jsCast&lt;JSModuleEnvironment*&gt;(scope);
 81             AbstractModuleRecord* moduleRecord = moduleEnvironment-&gt;moduleRecord();
<a name="3" id="anc3"></a><span class="line-modified"> 82             AbstractModuleRecord::Resolution resolution = moduleRecord-&gt;resolveImport(globalObject, ident);</span>
 83             RETURN_IF_EXCEPTION(throwScope, false);
 84             if (resolution.type == AbstractModuleRecord::Resolution::Type::Resolved) {
 85                 AbstractModuleRecord* importedRecord = resolution.moduleRecord;
 86                 JSModuleEnvironment* importedEnvironment = importedRecord-&gt;moduleEnvironment();
 87                 SymbolTable* symbolTable = importedEnvironment-&gt;symbolTable();
 88                 ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
 89                 auto iter = symbolTable-&gt;find(locker, resolution.localName.impl());
 90                 ASSERT(iter != symbolTable-&gt;end(locker));
 91                 SymbolTableEntry&amp; entry = iter-&gt;value;
 92                 ASSERT(!entry.isNull());
 93                 op = ResolveOp(makeType(ModuleVar, needsVarInjectionChecks), depth, 0, importedEnvironment, entry.watchpointSet(), entry.scopeOffset().offset(), resolution.localName.impl());
 94                 return true;
 95             }
 96         }
 97 
 98         if (symbolTable-&gt;usesNonStrictEval())
 99             needsVarInjectionChecks = true;
100         return false;
101     }
102 
103     if (scope-&gt;isGlobalLexicalEnvironment()) {
104         JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(scope);
105         SymbolTable* symbolTable = globalLexicalEnvironment-&gt;symbolTable();
106         ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
107         auto iter = symbolTable-&gt;find(locker, ident.impl());
108         if (iter != symbolTable-&gt;end(locker)) {
109             SymbolTableEntry&amp; entry = iter-&gt;value;
110             ASSERT(!entry.isNull());
111             if (getOrPut == Put &amp;&amp; entry.isReadOnly() &amp;&amp; !isInitialization(initializationMode)) {
112                 // We know the property will be at global lexical environment, but we don&#39;t know how to cache it.
113                 op = ResolveOp(Dynamic, 0, 0, 0, 0, 0);
114                 return true;
115             }
116 
117             // We can force const Initialization to always go down the fast path. It is provably impossible to construct
118             // a program that needs a var injection check here. You can convince yourself of this as follows:
119             // Any other let/const/class would be a duplicate of this in the global scope, so we would never get here in that situation.
120             // Also, if we had an eval in the global scope that defined a const, it would also be a duplicate of this const, and so it would
121             // also throw an error. Therefore, we&#39;re *the only* thing that can assign to this &quot;const&quot; slot for the first (and only) time. Also,
122             // we will never have a Dynamic ResolveType here because if we were inside a &quot;with&quot; statement, that would mean the &quot;const&quot; definition
123             // isn&#39;t a global, it would be a local to the &quot;with&quot; block.
124             // We still need to make the slow path correct for when we need to fire a watchpoint.
125             ResolveType resolveType = initializationMode == InitializationMode::ConstInitialization ? GlobalLexicalVar : makeType(GlobalLexicalVar, needsVarInjectionChecks);
126             op = ResolveOp(
127                 resolveType, depth, 0, 0, entry.watchpointSet(),
128                 reinterpret_cast&lt;uintptr_t&gt;(globalLexicalEnvironment-&gt;variableAt(entry.scopeOffset()).slot()));
129             return true;
130         }
131 
132         return false;
133     }
134 
135     if (scope-&gt;isGlobalObject()) {
136         JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(scope);
137         {
138             SymbolTable* symbolTable = globalObject-&gt;symbolTable();
139             ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
140             auto iter = symbolTable-&gt;find(locker, ident.impl());
141             if (iter != symbolTable-&gt;end(locker)) {
142                 SymbolTableEntry&amp; entry = iter-&gt;value;
143                 ASSERT(!entry.isNull());
144                 if (getOrPut == Put &amp;&amp; entry.isReadOnly()) {
145                     // We know the property will be at global scope, but we don&#39;t know how to cache it.
146                     op = ResolveOp(Dynamic, 0, 0, 0, 0, 0);
147                     return true;
148                 }
149 
150                 op = ResolveOp(
151                     makeType(GlobalVar, needsVarInjectionChecks), depth, 0, 0, entry.watchpointSet(),
152                     reinterpret_cast&lt;uintptr_t&gt;(globalObject-&gt;variableAt(entry.scopeOffset()).slot()));
153                 return true;
154             }
155         }
156 
157         PropertySlot slot(globalObject, PropertySlot::InternalMethodType::VMInquiry);
<a name="4" id="anc4"></a><span class="line-modified">158         bool hasOwnProperty = globalObject-&gt;getOwnPropertySlot(globalObject, globalObject, ident, slot);</span>
159         if (!hasOwnProperty) {
160             op = ResolveOp(makeType(UnresolvedProperty, needsVarInjectionChecks), 0, 0, 0, 0, 0);
161             return true;
162         }
163 
164         Structure* structure = globalObject-&gt;structure(vm);
165         if (!slot.isCacheableValue()
166             || !structure-&gt;propertyAccessesAreCacheable()
167             || (structure-&gt;hasReadOnlyOrGetterSetterPropertiesExcludingProto() &amp;&amp; getOrPut == Put)) {
168             // We know the property will be at global scope, but we don&#39;t know how to cache it.
169             ASSERT(!scope-&gt;next());
170             op = ResolveOp(makeType(GlobalProperty, needsVarInjectionChecks), 0, 0, 0, 0, 0);
171             return true;
172         }
173 
174 
175         WatchpointState state = structure-&gt;ensurePropertyReplacementWatchpointSet(vm, slot.cachedOffset())-&gt;state();
176         if (state == IsWatched &amp;&amp; getOrPut == Put) {
177             // The field exists, but because the replacement watchpoint is still intact. This is
178             // kind of dangerous. We have two options:
179             // 1) Invalidate the watchpoint set. That would work, but it&#39;s possible that this code
180             //    path never executes - in which case this would be unwise.
181             // 2) Have the invalidation happen at run-time. All we have to do is leave the code
182             //    uncached. The only downside is slightly more work when this does execute.
183             // We go with option (2) here because it seems less evil.
184             op = ResolveOp(makeType(GlobalProperty, needsVarInjectionChecks), depth, 0, 0, 0, 0);
185         } else
186             op = ResolveOp(makeType(GlobalProperty, needsVarInjectionChecks), depth, structure, 0, 0, slot.cachedOffset());
187         return true;
188     }
189 
190     op = ResolveOp(Dynamic, 0, 0, 0, 0, 0);
191     return true;
192 }
193 
194 JSObject* JSScope::objectAtScope(JSScope* scope)
195 {
196     JSObject* object = scope;
197     if (object-&gt;type() == WithScopeType)
198         return jsCast&lt;JSWithScope*&gt;(object)-&gt;object();
199 
200     return object;
201 }
202 
203 // When an exception occurs, the result of isUnscopable becomes false.
<a name="5" id="anc5"></a><span class="line-modified">204 static inline bool isUnscopable(JSGlobalObject* globalObject, JSScope* scope, JSObject* object, const Identifier&amp; ident)</span>
205 {
<a name="6" id="anc6"></a><span class="line-modified">206     VM&amp; vm = globalObject-&gt;vm();</span>
207     auto throwScope = DECLARE_THROW_SCOPE(vm);
208     if (scope-&gt;type() != WithScopeType)
209         return false;
210 
<a name="7" id="anc7"></a><span class="line-modified">211     JSValue unscopables = object-&gt;get(globalObject, vm.propertyNames-&gt;unscopablesSymbol);</span>
212     RETURN_IF_EXCEPTION(throwScope, false);
213     if (!unscopables.isObject())
214         return false;
<a name="8" id="anc8"></a><span class="line-modified">215     JSValue blocked = jsCast&lt;JSObject*&gt;(unscopables)-&gt;get(globalObject, ident);</span>
216     RETURN_IF_EXCEPTION(throwScope, false);
217 
<a name="9" id="anc9"></a><span class="line-modified">218     return blocked.toBoolean(globalObject);</span>
219 }
220 
221 template&lt;typename ReturnPredicateFunctor, typename SkipPredicateFunctor&gt;
<a name="10" id="anc10"></a><span class="line-modified">222 ALWAYS_INLINE JSObject* JSScope::resolve(JSGlobalObject* globalObject, JSScope* scope, const Identifier&amp; ident, ReturnPredicateFunctor returnPredicate, SkipPredicateFunctor skipPredicate)</span>
223 {
<a name="11" id="anc11"></a><span class="line-modified">224     VM&amp; vm = globalObject-&gt;vm();</span>
225     auto throwScope = DECLARE_THROW_SCOPE(vm);
226     ScopeChainIterator end = scope-&gt;end();
227     ScopeChainIterator it = scope-&gt;begin();
228     while (1) {
229         JSScope* scope = it.scope();
230         JSObject* object = it.get();
231 
232         // Global scope.
233         if (++it == end) {
234             JSScope* globalScopeExtension = scope-&gt;globalObject(vm)-&gt;globalScopeExtension();
235             if (UNLIKELY(globalScopeExtension)) {
<a name="12" id="anc12"></a><span class="line-modified">236                 bool hasProperty = object-&gt;hasProperty(globalObject, ident);</span>
237                 RETURN_IF_EXCEPTION(throwScope, nullptr);
238                 if (hasProperty)
239                     return object;
240                 JSObject* extensionScopeObject = JSScope::objectAtScope(globalScopeExtension);
<a name="13" id="anc13"></a><span class="line-modified">241                 hasProperty = extensionScopeObject-&gt;hasProperty(globalObject, ident);</span>
242                 RETURN_IF_EXCEPTION(throwScope, nullptr);
243                 if (hasProperty)
244                     return extensionScopeObject;
245             }
246             return object;
247         }
248 
249         if (skipPredicate(scope))
250             continue;
251 
<a name="14" id="anc14"></a><span class="line-modified">252         bool hasProperty = object-&gt;hasProperty(globalObject, ident);</span>
253         RETURN_IF_EXCEPTION(throwScope, nullptr);
254         if (hasProperty) {
<a name="15" id="anc15"></a><span class="line-modified">255             bool unscopable = isUnscopable(globalObject, scope, object, ident);</span>
256             EXCEPTION_ASSERT(!throwScope.exception() || !unscopable);
257             if (!unscopable)
258                 return object;
259         }
260 
261         if (returnPredicate(scope))
262             return object;
263     }
264 }
265 
<a name="16" id="anc16"></a><span class="line-modified">266 JSValue JSScope::resolveScopeForHoistingFuncDeclInEval(JSGlobalObject* globalObject, JSScope* scope, const Identifier&amp; ident)</span>
267 {
<a name="17" id="anc17"></a><span class="line-modified">268     VM&amp; vm = globalObject-&gt;vm();</span>
269     auto throwScope = DECLARE_THROW_SCOPE(vm);
270 
271     auto returnPredicate = [&amp;] (JSScope* scope) -&gt; bool {
272         return scope-&gt;isVarScope();
273     };
274     auto skipPredicate = [&amp;] (JSScope* scope) -&gt; bool {
275         return scope-&gt;isWithScope();
276     };
<a name="18" id="anc18"></a><span class="line-modified">277     JSObject* object = resolve(globalObject, scope, ident, returnPredicate, skipPredicate);</span>
278     RETURN_IF_EXCEPTION(throwScope, { });
279 
280     bool result = false;
281     if (JSScope* scope = jsDynamicCast&lt;JSScope*&gt;(vm, object)) {
282         if (SymbolTable* scopeSymbolTable = scope-&gt;symbolTable(vm)) {
283             result = scope-&gt;isGlobalObject()
<a name="19" id="anc19"></a><span class="line-modified">284                 ? JSObject::isExtensible(object, globalObject)</span>
285                 : scopeSymbolTable-&gt;scopeType() == SymbolTable::ScopeType::VarScope;
286         }
287     }
288 
289     return result ? JSValue(object) : jsUndefined();
290 }
291 
<a name="20" id="anc20"></a><span class="line-modified">292 JSObject* JSScope::resolve(JSGlobalObject* globalObject, JSScope* scope, const Identifier&amp; ident)</span>
293 {
294     auto predicate1 = [&amp;] (JSScope*) -&gt; bool {
295         return false;
296     };
297     auto predicate2 = [&amp;] (JSScope*) -&gt; bool {
298         return false;
299     };
<a name="21" id="anc21"></a><span class="line-modified">300     return resolve(globalObject, scope, ident, predicate1, predicate2);</span>
301 }
302 
<a name="22" id="anc22"></a><span class="line-modified">303 ResolveOp JSScope::abstractResolve(JSGlobalObject* globalObject, size_t depthOffset, JSScope* scope, const Identifier&amp; ident, GetOrPut getOrPut, ResolveType unlinkedType, InitializationMode initializationMode)</span>
304 {
<a name="23" id="anc23"></a><span class="line-modified">305     VM&amp; vm = globalObject-&gt;vm();</span>
306     auto throwScope = DECLARE_THROW_SCOPE(vm);
307 
308     ResolveOp op(Dynamic, 0, 0, 0, 0, 0);
309     if (unlinkedType == Dynamic)
310         return op;
311 
312     bool needsVarInjectionChecks = JSC::needsVarInjectionChecks(unlinkedType);
313     size_t depth = depthOffset;
314     for (; scope; scope = scope-&gt;next()) {
<a name="24" id="anc24"></a><span class="line-modified">315         bool success = abstractAccess(globalObject, scope, ident, getOrPut, depth, needsVarInjectionChecks, op, initializationMode);</span>
316         RETURN_IF_EXCEPTION(throwScope, ResolveOp(Dynamic, 0, 0, 0, 0, 0));
317         if (success)
318             break;
319         ++depth;
320     }
321 
322     return op;
323 }
324 
325 void JSScope::collectClosureVariablesUnderTDZ(JSScope* scope, VariableEnvironment&amp; result)
326 {
327     for (; scope; scope = scope-&gt;next()) {
328         if (!scope-&gt;isLexicalScope() &amp;&amp; !scope-&gt;isCatchScope())
329             continue;
330 
331         if (scope-&gt;isModuleScope()) {
332             AbstractModuleRecord* moduleRecord = jsCast&lt;JSModuleEnvironment*&gt;(scope)-&gt;moduleRecord();
333             for (const auto&amp; pair : moduleRecord-&gt;importEntries())
334                 result.add(pair.key);
335         }
336 
337         SymbolTable* symbolTable = jsCast&lt;JSSymbolTableObject*&gt;(scope)-&gt;symbolTable();
338         ASSERT(symbolTable-&gt;scopeType() == SymbolTable::ScopeType::LexicalScope || symbolTable-&gt;scopeType() == SymbolTable::ScopeType::CatchScope);
339         ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
340         for (auto end = symbolTable-&gt;end(locker), iter = symbolTable-&gt;begin(locker); iter != end; ++iter)
341             result.add(iter-&gt;key);
342     }
343 }
344 
345 bool JSScope::isVarScope()
346 {
347     if (type() != LexicalEnvironmentType)
348         return false;
349     return jsCast&lt;JSLexicalEnvironment*&gt;(this)-&gt;symbolTable()-&gt;scopeType() == SymbolTable::ScopeType::VarScope;
350 }
351 
352 bool JSScope::isLexicalScope()
353 {
354     if (!isJSLexicalEnvironment())
355         return false;
356     return jsCast&lt;JSLexicalEnvironment*&gt;(this)-&gt;symbolTable()-&gt;scopeType() == SymbolTable::ScopeType::LexicalScope;
357 }
358 
359 bool JSScope::isModuleScope()
360 {
361     return type() == ModuleEnvironmentType;
362 }
363 
364 bool JSScope::isCatchScope()
365 {
366     if (type() != LexicalEnvironmentType)
367         return false;
368     return jsCast&lt;JSLexicalEnvironment*&gt;(this)-&gt;symbolTable()-&gt;scopeType() == SymbolTable::ScopeType::CatchScope;
369 }
370 
371 bool JSScope::isFunctionNameScopeObject()
372 {
373     if (type() != LexicalEnvironmentType)
374         return false;
375     return jsCast&lt;JSLexicalEnvironment*&gt;(this)-&gt;symbolTable()-&gt;scopeType() == SymbolTable::ScopeType::FunctionNameScope;
376 }
377 
378 bool JSScope::isNestedLexicalScope()
379 {
380     if (!isJSLexicalEnvironment())
381         return false;
382     return jsCast&lt;JSLexicalEnvironment*&gt;(this)-&gt;symbolTable()-&gt;isNestedLexicalScope();
383 }
384 
385 JSScope* JSScope::constantScopeForCodeBlock(ResolveType type, CodeBlock* codeBlock)
386 {
387     switch (type) {
388     case GlobalProperty:
389     case GlobalVar:
390     case GlobalPropertyWithVarInjectionChecks:
391     case GlobalVarWithVarInjectionChecks:
392         return codeBlock-&gt;globalObject();
393     case GlobalLexicalVarWithVarInjectionChecks:
394     case GlobalLexicalVar:
395         return codeBlock-&gt;globalObject()-&gt;globalLexicalEnvironment();
396     default:
397         return nullptr;
398     }
399 
400     RELEASE_ASSERT_NOT_REACHED();
401     return nullptr;
402 }
403 
404 SymbolTable* JSScope::symbolTable(VM&amp; vm)
405 {
406     if (JSSymbolTableObject* symbolTableObject = jsDynamicCast&lt;JSSymbolTableObject*&gt;(vm, this))
407         return symbolTableObject-&gt;symbolTable();
408 
409     return nullptr;
410 }
411 
<a name="25" id="anc25"></a><span class="line-modified">412 JSValue JSScope::toThis(JSCell*, JSGlobalObject* globalObject, ECMAMode ecmaMode)</span>
413 {
414     if (ecmaMode == StrictMode)
415         return jsUndefined();
<a name="26" id="anc26"></a><span class="line-modified">416     return globalObject-&gt;globalThis();</span>
417 }
418 
419 } // namespace JSC
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
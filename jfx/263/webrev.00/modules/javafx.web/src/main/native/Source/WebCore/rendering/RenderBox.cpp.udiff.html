<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBlockFlow.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -565,31 +565,37 @@</span>
  int RenderBox::scrollTop() const
  {
      return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().y() : 0;
  }
  
<span class="udiff-line-modified-removed">- static void setupWheelEventTestTrigger(RenderLayer&amp; layer)</span>
<span class="udiff-line-modified-added">+ void RenderBox::resetLogicalHeightBeforeLayoutIfNeeded()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (shouldResetLogicalHeightBeforeLayout() || (is&lt;RenderBlock&gt;(parent()) &amp;&amp; downcast&lt;RenderBlock&gt;(*parent()).shouldResetChildLogicalHeightBeforeLayout(*this)))</span>
<span class="udiff-line-added">+         setLogicalHeight(0_lu);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void setupWheelEventMonitor(RenderLayer&amp; layer)</span>
  {
      Page&amp; page = layer.renderer().page();
<span class="udiff-line-modified-removed">-     if (!page.expectsWheelEventTriggers())</span>
<span class="udiff-line-modified-added">+     if (!page.isMonitoringWheelEvents())</span>
          return;
<span class="udiff-line-modified-removed">-     layer.scrollAnimator().setWheelEventTestTrigger(page.testTrigger());</span>
<span class="udiff-line-modified-added">+     layer.scrollAnimator().setWheelEventTestMonitor(page.wheelEventTestMonitor());</span>
  }
  
  void RenderBox::setScrollLeft(int newLeft, ScrollType scrollType, ScrollClamping clamping)
  {
      if (!hasOverflowClip() || !layer())
          return;
<span class="udiff-line-modified-removed">-     setupWheelEventTestTrigger(*layer());</span>
<span class="udiff-line-modified-added">+     setupWheelEventMonitor(*layer());</span>
      layer()-&gt;scrollToXPosition(newLeft, scrollType, clamping);
  }
  
  void RenderBox::setScrollTop(int newTop, ScrollType scrollType, ScrollClamping clamping)
  {
      if (!hasOverflowClip() || !layer())
          return;
<span class="udiff-line-modified-removed">-     setupWheelEventTestTrigger(*layer());</span>
<span class="udiff-line-modified-added">+     setupWheelEventMonitor(*layer());</span>
      layer()-&gt;scrollToYPosition(newTop, scrollType, clamping);
  }
  
  void RenderBox::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -724,11 +730,11 @@</span>
  
  int RenderBox::reflectionOffset() const
  {
      if (!style().boxReflect())
          return 0;
<span class="udiff-line-modified-removed">-     if (style().boxReflect()-&gt;direction() == ReflectionLeft || style().boxReflect()-&gt;direction() == ReflectionRight)</span>
<span class="udiff-line-modified-added">+     if (style().boxReflect()-&gt;direction() == ReflectionDirection::Left || style().boxReflect()-&gt;direction() == ReflectionDirection::Right)</span>
          return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().width());
      return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().height());
  }
  
  LayoutRect RenderBox::reflectedRect(const LayoutRect&amp; r) const
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -737,22 +743,22 @@</span>
          return LayoutRect();
  
      LayoutRect box = borderBoxRect();
      LayoutRect result = r;
      switch (style().boxReflect()-&gt;direction()) {
<span class="udiff-line-modified-removed">-         case ReflectionBelow:</span>
<span class="udiff-line-modified-removed">-             result.setY(box.maxY() + reflectionOffset() + (box.maxY() - r.maxY()));</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-removed">-         case ReflectionAbove:</span>
<span class="udiff-line-modified-removed">-             result.setY(box.y() - reflectionOffset() - box.height() + (box.maxY() - r.maxY()));</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-removed">-         case ReflectionLeft:</span>
<span class="udiff-line-modified-removed">-             result.setX(box.x() - reflectionOffset() - box.width() + (box.maxX() - r.maxX()));</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-removed">-         case ReflectionRight:</span>
<span class="udiff-line-modified-removed">-             result.setX(box.maxX() + reflectionOffset() + (box.maxX() - r.maxX()));</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-added">+     case ReflectionDirection::Below:</span>
<span class="udiff-line-modified-added">+         result.setY(box.maxY() + reflectionOffset() + (box.maxY() - r.maxY()));</span>
<span class="udiff-line-modified-added">+         break;</span>
<span class="udiff-line-modified-added">+     case ReflectionDirection::Above:</span>
<span class="udiff-line-modified-added">+         result.setY(box.y() - reflectionOffset() - box.height() + (box.maxY() - r.maxY()));</span>
<span class="udiff-line-modified-added">+         break;</span>
<span class="udiff-line-modified-added">+     case ReflectionDirection::Left:</span>
<span class="udiff-line-modified-added">+         result.setX(box.x() - reflectionOffset() - box.width() + (box.maxX() - r.maxX()));</span>
<span class="udiff-line-modified-added">+         break;</span>
<span class="udiff-line-modified-added">+     case ReflectionDirection::Right:</span>
<span class="udiff-line-modified-added">+         result.setX(box.maxX() + reflectionOffset() + (box.maxX() - r.maxX()));</span>
<span class="udiff-line-modified-added">+         break;</span>
      }
      return result;
  }
  
  bool RenderBox::fixedElementLaysOutRelativeToFrame(const FrameView&amp; frameView) const
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1319,11 +1325,11 @@</span>
      BackgroundBleedAvoidance bleedAvoidance = determineBackgroundBleedAvoidance(paintInfo.context());
  
      // FIXME: Should eventually give the theme control over whether the box shadow should paint, since controls could have
      // custom shadows of their own.
      if (!boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
<span class="udiff-line-modified-removed">-         paintBoxShadow(paintInfo, paintRect, style(), Normal);</span>
<span class="udiff-line-modified-added">+         paintBoxShadow(paintInfo, paintRect, style(), ShadowStyle::Normal);</span>
  
      GraphicsContextStateSaver stateSaver(paintInfo.context(), false);
      if (bleedAvoidance == BackgroundBleedUseTransparencyLayer) {
          // To avoid the background color bleeding out behind the border, we&#39;ll render background and border
          // into a transparency layer, and then clip that in one go (which requires setting up the clip before
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1350,11 +1356,11 @@</span>
          paintBackground(paintInfo, paintRect, bleedAvoidance);
  
          if (style().hasAppearance())
              theme().paintDecorations(*this, paintInfo, paintRect);
      }
<span class="udiff-line-modified-removed">-     paintBoxShadow(paintInfo, paintRect, style(), Inset);</span>
<span class="udiff-line-modified-added">+     paintBoxShadow(paintInfo, paintRect, style(), ShadowStyle::Inset);</span>
  
      // The theme will tell us whether or not we should also paint the CSS border.
      if (bleedAvoidance != BackgroundBleedBackgroundOverBorder &amp;&amp; (!style().hasAppearance() || (borderOrBackgroundPaintingIsNeeded &amp;&amp; theme().paintBorderOnly(*this, paintInfo, paintRect))) &amp;&amp; style().hasVisibleBorderDecoration())
          paintBorder(paintInfo, paintRect, style(), bleedAvoidance);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1474,11 +1480,11 @@</span>
          return false;
      if (RenderLayer* childLayer = childBox.layer()) {
          if (childLayer-&gt;isComposited())
              return false;
          // FIXME: Deal with z-index.
<span class="udiff-line-modified-removed">-         if (!childStyle.hasAutoZIndex())</span>
<span class="udiff-line-modified-added">+         if (!childStyle.hasAutoUsedZIndex())</span>
              return false;
          if (childLayer-&gt;hasTransform() || childLayer-&gt;isTransparent() || childLayer-&gt;hasFilter())
              return false;
          if (!childBox.scrollPosition().isZero())
              return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1581,11 +1587,11 @@</span>
  {
      // Figure out if we need to push a transparency layer to render our mask.
      bool pushTransparencyLayer = false;
      bool compositedMask = hasLayer() &amp;&amp; layer()-&gt;hasCompositedMask();
      bool flattenCompositingLayers = paintInfo.paintBehavior.contains(PaintBehavior::FlattenCompositingLayers);
<span class="udiff-line-modified-removed">-     CompositeOperator compositeOp = CompositeSourceOver;</span>
<span class="udiff-line-modified-added">+     CompositeOperator compositeOp = CompositeOperator::SourceOver;</span>
  
      bool allMaskImagesLoaded = true;
  
      if (!compositedMask || flattenCompositingLayers) {
          pushTransparencyLayer = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1594,13 +1600,13 @@</span>
          if (auto* maskBoxImage = style().maskBoxImage().image())
              allMaskImagesLoaded &amp;= maskBoxImage-&gt;isLoaded();
  
          allMaskImagesLoaded &amp;= style().maskLayers().imagesAreLoaded();
  
<span class="udiff-line-modified-removed">-         paintInfo.context().setCompositeOperation(CompositeDestinationIn);</span>
<span class="udiff-line-modified-added">+         paintInfo.context().setCompositeOperation(CompositeOperator::DestinationIn);</span>
          paintInfo.context().beginTransparencyLayer(1);
<span class="udiff-line-modified-removed">-         compositeOp = CompositeSourceOver;</span>
<span class="udiff-line-modified-added">+         compositeOp = CompositeOperator::SourceOver;</span>
      }
  
      if (allMaskImagesLoaded) {
          paintFillLayers(paintInfo, Color(), style().maskLayers(), paintRect, BackgroundBleedNone, compositeOp);
          paintNinePieceImage(paintInfo.context(), paintRect, style(), style().maskBoxImage(), compositeOp);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1700,13 +1706,16 @@</span>
          return;
      }
  
      ShapeValue* shapeOutsideValue = style().shapeOutside();
      if (!view().frameView().layoutContext().isInRenderTreeLayout() &amp;&amp; isFloating() &amp;&amp; shapeOutsideValue &amp;&amp; shapeOutsideValue-&gt;image() &amp;&amp; shapeOutsideValue-&gt;image()-&gt;data() == image) {
<span class="udiff-line-modified-removed">-         ShapeOutsideInfo::ensureInfo(*this).markShapeAsDirty();</span>
<span class="udiff-line-modified-removed">-         markShapeOutsideDependentsForLayout();</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+         ShapeOutsideInfo&amp; info = ShapeOutsideInfo::ensureInfo(*this);</span>
<span class="udiff-line-modified-added">+         if (!info.isComputingShape()) {</span>
<span class="udiff-line-modified-added">+             info.markShapeAsDirty();</span>
<span class="udiff-line-added">+             markShapeOutsideDependentsForLayout();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+      }</span>
  
      bool didFullRepaint = repaintLayerRectsForImage(image, style().backgroundLayers(), true);
      if (!didFullRepaint)
          repaintLayerRectsForImage(image, style().maskLayers(), false);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4779,11 +4788,11 @@</span>
          // If we are relatively positioned or if we have a transform, then we have to convert
          // this rectangle into physical coordinates, apply relative positioning and transforms
          // to it, and then convert it back.
          flipForWritingMode(rect);
  
<span class="udiff-line-modified-removed">-         if (hasTransform)</span>
<span class="udiff-line-modified-added">+         if (hasTransform &amp;&amp; hasLayer())</span>
              rect = layer()-&gt;currentTransform().mapRect(rect);
  
          if (isInFlowPositioned())
              rect.move(offsetForInFlowPosition());
  
</pre>
<center><a href="RenderBlockFlow.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCellInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCellInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCellInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCellInlines.h
@@ -27,11 +27,11 @@
 
 #include "AllocatorForMode.h"
 #include "AllocatorInlines.h"
 #include "CompleteSubspaceInlines.h"
 #include "CPU.h"
-#include "CallFrame.h"
+#include "CallFrameInlines.h"
 #include "DeferGC.h"
 #include "FreeListInlines.h"
 #include "Handle.h"
 #include "HeapInlines.h"
 #include "IsoSubspaceInlines.h"
@@ -136,26 +136,16 @@
 
 inline void JSCell::visitOutputConstraints(JSCell*, SlotVisitor&)
 {
 }
 
-ALWAYS_INLINE VM& ExecState::vm() const
+ALWAYS_INLINE VM& CallFrame::deprecatedVM() const
 {
     JSCell* callee = this->callee().asCell();
     ASSERT(callee);
     ASSERT(&callee->vm());
-    ASSERT(!callee->isLargeAllocation());
-    // This is an important optimization since we access this so often.
-    return callee->markedBlock().vm();
-}
-
-template<typename CellType, SubspaceAccess>
-CompleteSubspace* JSCell::subspaceFor(VM& vm)
-{
-    if (CellType::needsDestruction)
-        return &vm.destructibleCellSpace;
-    return &vm.cellSpace;
+    return callee->vm();
 }
 
 template<typename Type>
 inline Allocator allocatorForNonVirtualConcurrently(VM& vm, size_t allocationSize, AllocatorForMode mode)
 {
@@ -300,11 +290,11 @@
 }
 
 inline const MethodTable* JSCell::methodTable(VM& vm) const
 {
     Structure* structure = this->structure(vm);
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     if (Structure* rootStructure = structure->structure(vm))
         ASSERT(rootStructure == rootStructure->structure(vm));
 #endif
     return &structure->classInfo()->methodTable;
 }
@@ -345,17 +335,17 @@
     // to allow the GC thread or JIT threads to pass this assertion.
     ASSERT(vm.heap.mutatorState() != MutatorState::Sweeping || !vm.currentThreadIsHoldingAPILock());
     return structure(vm)->classInfo();
 }
 
-inline bool JSCell::toBoolean(ExecState* exec) const
+inline bool JSCell::toBoolean(JSGlobalObject* globalObject) const
 {
     if (isString())
         return static_cast<const JSString*>(this)->toBoolean();
     if (isBigInt())
         return static_cast<const JSBigInt*>(this)->toBoolean();
-    return !structure(exec->vm())->masqueradesAsUndefined(exec->lexicalGlobalObject());
+    return !structure(getVM(globalObject))->masqueradesAsUndefined(globalObject);
 }
 
 inline TriState JSCell::pureToBoolean() const
 {
     if (isString())
@@ -407,26 +397,26 @@
         m_flags |= static_cast<TypeInfo::InlineTypeFlags>(TypeInfoPerCellBit);
     else
         m_flags &= ~static_cast<TypeInfo::InlineTypeFlags>(TypeInfoPerCellBit);
 }
 
-inline JSObject* JSCell::toObject(ExecState* exec, JSGlobalObject* globalObject) const
+inline JSObject* JSCell::toObject(JSGlobalObject* globalObject) const
 {
     if (isObject())
         return jsCast<JSObject*>(const_cast<JSCell*>(this));
-    return toObjectSlow(exec, globalObject);
+    return toObjectSlow(globalObject);
 }
 
-ALWAYS_INLINE bool JSCell::putInline(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
+ALWAYS_INLINE bool JSCell::putInline(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
 {
-    auto putMethod = methodTable(exec->vm())->put;
+    auto putMethod = methodTable(getVM(globalObject))->put;
     if (LIKELY(putMethod == JSObject::put))
-        return JSObject::putInlineForJSObject(asObject(this), exec, propertyName, value, slot);
-    return putMethod(this, exec, propertyName, value, slot);
+        return JSObject::putInlineForJSObject(asObject(this), globalObject, propertyName, value, slot);
+    return putMethod(this, globalObject, propertyName, value, slot);
 }
 
-inline bool isWebAssemblyToJSCallee(const JSCell* cell)
+inline bool isWebAssemblyModule(const JSCell* cell)
 {
-    return cell->type() == WebAssemblyToJSCalleeType;
+    return cell->type() == WebAssemblyModuleType;
 }
 
 } // namespace JSC

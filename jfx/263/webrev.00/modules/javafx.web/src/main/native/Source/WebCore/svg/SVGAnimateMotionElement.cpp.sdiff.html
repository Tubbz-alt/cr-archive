<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimateMotionElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGAnimateElementBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGAnimateMotionElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimateMotionElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
122 void SVGAnimateMotionElement::updateAnimationPath()
123 {
124     m_animationPath = Path();
125     bool foundMPath = false;
126 
127     for (auto&amp; mPath : childrenOfType&lt;SVGMPathElement&gt;(*this)) {
128         auto pathElement = mPath.pathElement();
129         if (pathElement) {
130             m_animationPath = pathFromGraphicsElement(pathElement.get());
131             foundMPath = true;
132             break;
133         }
134     }
135 
136     if (!foundMPath &amp;&amp; hasAttributeWithoutSynchronization(SVGNames::pathAttr))
137         m_animationPath = m_path;
138 
139     updateAnimationMode();
140 }
141 
<span class="line-modified">142 void SVGAnimateMotionElement::resetAnimatedType()</span>
143 {
144     if (!hasValidAttributeType())
145         return;
146     auto targetElement = makeRefPtr(this-&gt;targetElement());
147     if (!targetElement)
148         return;
149     if (AffineTransform* transform = targetElement-&gt;supplementalTransform())
150         transform-&gt;makeIdentity();
151 }
152 
<span class="line-modified">153 void SVGAnimateMotionElement::clearAnimatedType(SVGElement* targetElement)</span>
154 {
155     if (!targetElement)
156         return;
157     if (AffineTransform* transform = targetElement-&gt;supplementalTransform())
158         transform-&gt;makeIdentity();

159 }
160 
161 bool SVGAnimateMotionElement::calculateToAtEndOfDurationValue(const String&amp; toAtEndOfDurationString)
162 {
163     parsePoint(toAtEndOfDurationString, m_toPointAtEndOfDuration);
164     m_hasToPointAtEndOfDuration = true;
165     return true;
166 }
167 
168 bool SVGAnimateMotionElement::calculateFromAndToValues(const String&amp; fromString, const String&amp; toString)
169 {
170     m_hasToPointAtEndOfDuration = false;
171     parsePoint(fromString, m_fromPoint);
172     parsePoint(toString, m_toPoint);
173     return true;
174 }
175 
176 bool SVGAnimateMotionElement::calculateFromAndByValues(const String&amp; fromString, const String&amp; byString)
177 {
178     m_hasToPointAtEndOfDuration = false;
179     if (animationMode() == AnimationMode::By &amp;&amp; !isAdditive())
180         return false;
181     parsePoint(fromString, m_fromPoint);
182     FloatPoint byPoint;
183     parsePoint(byString, byPoint);
184     m_toPoint = FloatPoint(m_fromPoint.x() + byPoint.x(), m_fromPoint.y() + byPoint.y());
185     return true;
186 }
187 
188 void SVGAnimateMotionElement::buildTransformForProgress(AffineTransform* transform, float percentage)
189 {
190     ASSERT(!m_animationPath.isEmpty());
191 
<span class="line-removed">192     bool success = false;</span>
193     float positionOnPath = m_animationPath.length() * percentage;
<span class="line-modified">194     auto traversalState(m_animationPath.traversalStateAtLength(positionOnPath, success));</span>
<span class="line-modified">195     if (!success)</span>
196         return;
197 
198     FloatPoint position = traversalState.current();
199     float angle = traversalState.normalAngle();
200 
201     transform-&gt;translate(position);
202     RotateMode rotateMode = this-&gt;rotateMode();
203     if (rotateMode != RotateAuto &amp;&amp; rotateMode != RotateAutoReverse)
204         return;
205     if (rotateMode == RotateAutoReverse)
206         angle += 180;
207     transform-&gt;rotate(angle);
208 }
209 
<span class="line-modified">210 void SVGAnimateMotionElement::calculateAnimatedValue(float percentage, unsigned repeatCount, SVGSMILElement*)</span>
211 {
212     auto targetElement = makeRefPtr(this-&gt;targetElement());
213     if (!targetElement)
214         return;

215     AffineTransform* transform = targetElement-&gt;supplementalTransform();
216     if (!transform)
217         return;
218 
<span class="line-removed">219     if (RenderObject* targetRenderer = targetElement-&gt;renderer())</span>
<span class="line-removed">220         targetRenderer-&gt;setNeedsTransformUpdate();</span>
<span class="line-removed">221 </span>
222     if (!isAdditive())
223         transform-&gt;makeIdentity();
224 
225     if (animationMode() != AnimationMode::Path) {
226         FloatPoint toPointAtEndOfDuration = m_toPoint;
227         if (isAccumulated() &amp;&amp; repeatCount &amp;&amp; m_hasToPointAtEndOfDuration)
228             toPointAtEndOfDuration = m_toPointAtEndOfDuration;
229 
230         float animatedX = 0;
231         animateAdditiveNumber(percentage, repeatCount, m_fromPoint.x(), m_toPoint.x(), toPointAtEndOfDuration.x(), animatedX);
232 
233         float animatedY = 0;
234         animateAdditiveNumber(percentage, repeatCount, m_fromPoint.y(), m_toPoint.y(), toPointAtEndOfDuration.y(), animatedY);
235 
236         transform-&gt;translate(animatedX, animatedY);
237         return;
238     }
239 
240     buildTransformForProgress(transform, percentage);
241 
242     // Handle accumulate=&quot;sum&quot;.
243     if (isAccumulated() &amp;&amp; repeatCount) {
244         for (unsigned i = 0; i &lt; repeatCount; ++i)
245             buildTransformForProgress(transform, 1);
246     }
247 }
248 
249 void SVGAnimateMotionElement::applyResultsToTarget()
250 {
251     // We accumulate to the target element transform list so there is not much to do here.
252     auto targetElement = makeRefPtr(this-&gt;targetElement());
253     if (!targetElement)
254         return;
255 
<span class="line-modified">256     if (RenderElement* renderer = targetElement-&gt;renderer())</span>

257         RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);

258 
259     AffineTransform* targetSupplementalTransform = targetElement-&gt;supplementalTransform();
260     if (!targetSupplementalTransform)
261         return;
262 
263     // ...except in case where we have additional instances in &lt;use&gt; trees.
264     for (auto* instance : targetElement-&gt;instances()) {
265         AffineTransform* transform = instance-&gt;supplementalTransform();
266         if (!transform || *transform == *targetSupplementalTransform)
267             continue;
268         *transform = *targetSupplementalTransform;
269         if (RenderElement* renderer = instance-&gt;renderer()) {
270             renderer-&gt;setNeedsTransformUpdate();
271             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
272         }
273     }
274 }
275 
276 Optional&lt;float&gt; SVGAnimateMotionElement::calculateDistance(const String&amp; fromString, const String&amp; toString)
277 {
278     FloatPoint from;
279     FloatPoint to;
280     if (!parsePoint(fromString, from))
281         return { };
282     if (!parsePoint(toString, to))
283         return { };
284     FloatSize diff = to - from;
<span class="line-modified">285     return sqrtf(diff.width() * diff.width() + diff.height() * diff.height());</span>
286 }
287 
288 void SVGAnimateMotionElement::updateAnimationMode()
289 {
290     if (!m_animationPath.isEmpty())
291         setAnimationMode(AnimationMode::Path);
292     else
293         SVGAnimationElement::updateAnimationMode();
294 }
295 
296 }
</pre>
</td>
<td>
<hr />
<pre>
122 void SVGAnimateMotionElement::updateAnimationPath()
123 {
124     m_animationPath = Path();
125     bool foundMPath = false;
126 
127     for (auto&amp; mPath : childrenOfType&lt;SVGMPathElement&gt;(*this)) {
128         auto pathElement = mPath.pathElement();
129         if (pathElement) {
130             m_animationPath = pathFromGraphicsElement(pathElement.get());
131             foundMPath = true;
132             break;
133         }
134     }
135 
136     if (!foundMPath &amp;&amp; hasAttributeWithoutSynchronization(SVGNames::pathAttr))
137         m_animationPath = m_path;
138 
139     updateAnimationMode();
140 }
141 
<span class="line-modified">142 void SVGAnimateMotionElement::startAnimation()</span>
143 {
144     if (!hasValidAttributeType())
145         return;
146     auto targetElement = makeRefPtr(this-&gt;targetElement());
147     if (!targetElement)
148         return;
149     if (AffineTransform* transform = targetElement-&gt;supplementalTransform())
150         transform-&gt;makeIdentity();
151 }
152 
<span class="line-modified">153 void SVGAnimateMotionElement::stopAnimation(SVGElement* targetElement)</span>
154 {
155     if (!targetElement)
156         return;
157     if (AffineTransform* transform = targetElement-&gt;supplementalTransform())
158         transform-&gt;makeIdentity();
<span class="line-added">159     applyResultsToTarget();</span>
160 }
161 
162 bool SVGAnimateMotionElement::calculateToAtEndOfDurationValue(const String&amp; toAtEndOfDurationString)
163 {
164     parsePoint(toAtEndOfDurationString, m_toPointAtEndOfDuration);
165     m_hasToPointAtEndOfDuration = true;
166     return true;
167 }
168 
169 bool SVGAnimateMotionElement::calculateFromAndToValues(const String&amp; fromString, const String&amp; toString)
170 {
171     m_hasToPointAtEndOfDuration = false;
172     parsePoint(fromString, m_fromPoint);
173     parsePoint(toString, m_toPoint);
174     return true;
175 }
176 
177 bool SVGAnimateMotionElement::calculateFromAndByValues(const String&amp; fromString, const String&amp; byString)
178 {
179     m_hasToPointAtEndOfDuration = false;
180     if (animationMode() == AnimationMode::By &amp;&amp; !isAdditive())
181         return false;
182     parsePoint(fromString, m_fromPoint);
183     FloatPoint byPoint;
184     parsePoint(byString, byPoint);
185     m_toPoint = FloatPoint(m_fromPoint.x() + byPoint.x(), m_fromPoint.y() + byPoint.y());
186     return true;
187 }
188 
189 void SVGAnimateMotionElement::buildTransformForProgress(AffineTransform* transform, float percentage)
190 {
191     ASSERT(!m_animationPath.isEmpty());
192 

193     float positionOnPath = m_animationPath.length() * percentage;
<span class="line-modified">194     auto traversalState(m_animationPath.traversalStateAtLength(positionOnPath));</span>
<span class="line-modified">195     if (!traversalState.success())</span>
196         return;
197 
198     FloatPoint position = traversalState.current();
199     float angle = traversalState.normalAngle();
200 
201     transform-&gt;translate(position);
202     RotateMode rotateMode = this-&gt;rotateMode();
203     if (rotateMode != RotateAuto &amp;&amp; rotateMode != RotateAutoReverse)
204         return;
205     if (rotateMode == RotateAutoReverse)
206         angle += 180;
207     transform-&gt;rotate(angle);
208 }
209 
<span class="line-modified">210 void SVGAnimateMotionElement::calculateAnimatedValue(float percentage, unsigned repeatCount)</span>
211 {
212     auto targetElement = makeRefPtr(this-&gt;targetElement());
213     if (!targetElement)
214         return;
<span class="line-added">215 </span>
216     AffineTransform* transform = targetElement-&gt;supplementalTransform();
217     if (!transform)
218         return;
219 



220     if (!isAdditive())
221         transform-&gt;makeIdentity();
222 
223     if (animationMode() != AnimationMode::Path) {
224         FloatPoint toPointAtEndOfDuration = m_toPoint;
225         if (isAccumulated() &amp;&amp; repeatCount &amp;&amp; m_hasToPointAtEndOfDuration)
226             toPointAtEndOfDuration = m_toPointAtEndOfDuration;
227 
228         float animatedX = 0;
229         animateAdditiveNumber(percentage, repeatCount, m_fromPoint.x(), m_toPoint.x(), toPointAtEndOfDuration.x(), animatedX);
230 
231         float animatedY = 0;
232         animateAdditiveNumber(percentage, repeatCount, m_fromPoint.y(), m_toPoint.y(), toPointAtEndOfDuration.y(), animatedY);
233 
234         transform-&gt;translate(animatedX, animatedY);
235         return;
236     }
237 
238     buildTransformForProgress(transform, percentage);
239 
240     // Handle accumulate=&quot;sum&quot;.
241     if (isAccumulated() &amp;&amp; repeatCount) {
242         for (unsigned i = 0; i &lt; repeatCount; ++i)
243             buildTransformForProgress(transform, 1);
244     }
245 }
246 
247 void SVGAnimateMotionElement::applyResultsToTarget()
248 {
249     // We accumulate to the target element transform list so there is not much to do here.
250     auto targetElement = makeRefPtr(this-&gt;targetElement());
251     if (!targetElement)
252         return;
253 
<span class="line-modified">254     if (RenderElement* renderer = targetElement-&gt;renderer()) {</span>
<span class="line-added">255         renderer-&gt;setNeedsTransformUpdate();</span>
256         RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
<span class="line-added">257     }</span>
258 
259     AffineTransform* targetSupplementalTransform = targetElement-&gt;supplementalTransform();
260     if (!targetSupplementalTransform)
261         return;
262 
263     // ...except in case where we have additional instances in &lt;use&gt; trees.
264     for (auto* instance : targetElement-&gt;instances()) {
265         AffineTransform* transform = instance-&gt;supplementalTransform();
266         if (!transform || *transform == *targetSupplementalTransform)
267             continue;
268         *transform = *targetSupplementalTransform;
269         if (RenderElement* renderer = instance-&gt;renderer()) {
270             renderer-&gt;setNeedsTransformUpdate();
271             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
272         }
273     }
274 }
275 
276 Optional&lt;float&gt; SVGAnimateMotionElement::calculateDistance(const String&amp; fromString, const String&amp; toString)
277 {
278     FloatPoint from;
279     FloatPoint to;
280     if (!parsePoint(fromString, from))
281         return { };
282     if (!parsePoint(toString, to))
283         return { };
284     FloatSize diff = to - from;
<span class="line-modified">285     return std::hypot(diff.width(), diff.height());</span>
286 }
287 
288 void SVGAnimateMotionElement::updateAnimationMode()
289 {
290     if (!m_animationPath.isEmpty())
291         setAnimationMode(AnimationMode::Path);
292     else
293         SVGAnimationElement::updateAnimationMode();
294 }
295 
296 }
</pre>
</td>
</tr>
</table>
<center><a href="SVGAnimateElementBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGAnimateMotionElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
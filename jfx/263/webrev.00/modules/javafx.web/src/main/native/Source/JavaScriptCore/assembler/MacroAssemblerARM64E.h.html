<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerARM64E.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(ASSEMBLER) &amp;&amp; CPU(ARM64E)
 29 
 30 // We need to include this before MacroAssemblerARM64.h because MacroAssemblerARM64
 31 // will be defined in terms of ARM64EAssembler for ARM64E.
 32 #include &quot;ARM64EAssembler.h&quot;
 33 #include &quot;JSCPtrTag.h&quot;
 34 #include &quot;MacroAssemblerARM64.h&quot;
 35 
 36 namespace JSC {
 37 
 38 using Assembler = TARGET_ASSEMBLER;
 39 
 40 class MacroAssemblerARM64E : public MacroAssemblerARM64 {
 41 public:
 42     static constexpr unsigned numberOfPACBits = 25;
 43     static constexpr uintptr_t nonPACBitsMask = (1ull &lt;&lt; (64 - numberOfPACBits)) - 1;
 44 
 45     ALWAYS_INLINE void tagReturnAddress()
 46     {
 47         tagPtr(ARM64Registers::sp, ARM64Registers::lr);
 48     }
 49 
 50     ALWAYS_INLINE void untagReturnAddress()
 51     {
 52         untagPtr(ARM64Registers::sp, ARM64Registers::lr);
 53     }
 54 
 55     ALWAYS_INLINE void tagPtr(PtrTag tag, RegisterID target)
 56     {
 57         auto tagGPR = getCachedDataTempRegisterIDAndInvalidate();
 58         move(TrustedImm64(tag), tagGPR);
 59         m_assembler.pacib(target, tagGPR);
 60     }
 61 
 62     ALWAYS_INLINE void tagPtr(RegisterID tag, RegisterID target)
 63     {
 64         if (target == ARM64Registers::lr &amp;&amp; tag == ARM64Registers::sp) {
 65             m_assembler.pacibsp();
 66             return;
 67         }
 68         m_assembler.pacib(target, tag);
 69     }
 70 
 71     ALWAYS_INLINE void untagPtr(PtrTag tag, RegisterID target)
 72     {
 73         auto tagGPR = getCachedDataTempRegisterIDAndInvalidate();
 74         move(TrustedImm64(tag), tagGPR);
 75         m_assembler.autib(target, tagGPR);
 76     }
 77 
 78     ALWAYS_INLINE void untagPtr(RegisterID tag, RegisterID target)
 79     {
 80         m_assembler.autib(target, tag);
 81     }
 82 
 83     ALWAYS_INLINE void removePtrTag(RegisterID target)
 84     {
 85         m_assembler.xpaci(target);
 86     }
 87 
 88     ALWAYS_INLINE void tagArrayPtr(RegisterID length, RegisterID target)
 89     {
 90         m_assembler.pacdb(target, length);
 91     }
 92 
 93     ALWAYS_INLINE void untagArrayPtr(RegisterID length, RegisterID target)
 94     {
 95         m_assembler.autdb(target, length);
 96     }
 97 
 98     ALWAYS_INLINE void untagArrayPtr(Address length, RegisterID target)
 99     {
100         auto lengthGPR = getCachedDataTempRegisterIDAndInvalidate();
101         load32(length, lengthGPR);
102         m_assembler.autdb(target, lengthGPR);
103     }
104 
105     ALWAYS_INLINE void removeArrayPtrTag(RegisterID target)
106     {
107         m_assembler.xpacd(target);
108     }
109 
110     static constexpr RegisterID InvalidGPR  = static_cast&lt;RegisterID&gt;(-1);
111 
112     enum class CallSignatureType {
113         CFunctionCall,
114         OtherCall
115     };
116 
117     template&lt;CallSignatureType type&gt;
118     ALWAYS_INLINE Call callTrustedPtr(RegisterID tagGPR = InvalidGPR)
119     {
120         ASSERT(tagGPR != dataTempRegister);
121         AssemblerLabel pointerLabel = m_assembler.label();
122         moveWithFixedWidth(TrustedImmPtr(nullptr), getCachedDataTempRegisterIDAndInvalidate());
123         invalidateAllTempRegisters();
124         if (type == CallSignatureType::CFunctionCall)
125             m_assembler.blraaz(dataTempRegister);
126         else
127             m_assembler.blrab(dataTempRegister, tagGPR);
128         AssemblerLabel callLabel = m_assembler.label();
129         ASSERT_UNUSED(pointerLabel, ARM64Assembler::getDifferenceBetweenLabels(callLabel, pointerLabel) == REPATCH_OFFSET_CALL_TO_POINTER);
130         return Call(callLabel, Call::Linkable);
131     }
132 
133     ALWAYS_INLINE Call call(PtrTag tag)
134     {
135         if (tag == NoPtrTag)
136             return MacroAssemblerARM64::call(tag);
137         if (tag == CFunctionPtrTag)
138             return callTrustedPtr&lt;CallSignatureType::CFunctionCall&gt;();
139         move(TrustedImm64(tag), ARM64Registers::lr);
140         return callTrustedPtr&lt;CallSignatureType::OtherCall&gt;(ARM64Registers::lr);
141     }
142 
143     ALWAYS_INLINE Call call(RegisterID tagGPR)
144     {
145         return callTrustedPtr&lt;CallSignatureType::OtherCall&gt;(tagGPR);
146     }
147 
148     template&lt;CallSignatureType type&gt;
149     ALWAYS_INLINE Call callRegister(RegisterID targetGPR, RegisterID tagGPR = InvalidGPR)
150     {
151         ASSERT(tagGPR != targetGPR);
152         invalidateAllTempRegisters();
153         if (type == CallSignatureType::CFunctionCall)
154             m_assembler.blraaz(targetGPR);
155         else
156             m_assembler.blrab(targetGPR, tagGPR);
157         return Call(m_assembler.label(), Call::None);
158     }
159 
160     ALWAYS_INLINE Call call(RegisterID targetGPR, PtrTag tag)
161     {
162         if (tag == NoPtrTag)
163             return MacroAssemblerARM64::call(targetGPR, tag);
164         if (tag == CFunctionPtrTag)
165             return callRegister&lt;CallSignatureType::CFunctionCall&gt;(targetGPR);
166         move(TrustedImm64(tag), ARM64Registers::lr);
167         return callRegister&lt;CallSignatureType::OtherCall&gt;(targetGPR, ARM64Registers::lr);
168     }
169 
170     ALWAYS_INLINE Call call(RegisterID targetGPR, RegisterID tagGPR)
171     {
172         return callRegister&lt;CallSignatureType::OtherCall&gt;(targetGPR, tagGPR);
173     }
174 
175     ALWAYS_INLINE Call call(Address address, PtrTag tag)
176     {
177         if (tag == NoPtrTag)
178             return MacroAssemblerARM64::call(address, tag);
179 
180         load64(address, getCachedDataTempRegisterIDAndInvalidate());
181         return call(dataTempRegister, tag);
182     }
183 
184     ALWAYS_INLINE Call call(Address address, RegisterID tag)
185     {
186         ASSERT(tag != dataTempRegister);
187         load64(address, getCachedDataTempRegisterIDAndInvalidate());
188         return call(dataTempRegister, tag);
189     }
190 
191     ALWAYS_INLINE void callOperation(const FunctionPtr&lt;OperationPtrTag&gt; operation)
192     {
193         auto tmp = getCachedDataTempRegisterIDAndInvalidate();
194         move(TrustedImmPtr(operation.executableAddress()), tmp);
195         call(tmp, OperationPtrTag);
196     }
197 
198     ALWAYS_INLINE Jump jump() { return MacroAssemblerARM64::jump(); }
199 
200     void farJump(RegisterID target, PtrTag tag)
201     {
202         if (tag == NoPtrTag)
203             return MacroAssemblerARM64::farJump(target, tag);
204 
205         ASSERT(tag != CFunctionPtrTag);
206         RegisterID diversityGPR = getCachedDataTempRegisterIDAndInvalidate();
207         move(TrustedImm64(tag), diversityGPR);
208         farJump(target, diversityGPR);
209     }
210 
211     void farJump(RegisterID target, RegisterID tag)
212     {
213         ASSERT(tag != target);
214         m_assembler.brab(target, tag);
215     }
216 
217     void farJump(Address address, PtrTag tag)
218     {
219         if (tag == NoPtrTag)
220             return MacroAssemblerARM64::farJump(address, tag);
221 
222         ASSERT(tag != CFunctionPtrTag);
223         RegisterID targetGPR = getCachedDataTempRegisterIDAndInvalidate();
224         RegisterID diversityGPR = getCachedMemoryTempRegisterIDAndInvalidate();
225         load64(address, targetGPR);
226         move(TrustedImm64(tag), diversityGPR);
227         m_assembler.brab(targetGPR, diversityGPR);
228     }
229 
230     void farJump(Address address, RegisterID tag)
231     {
232         RegisterID targetGPR = getCachedDataTempRegisterIDAndInvalidate();
233         ASSERT(tag != targetGPR);
234         load64(address, targetGPR);
235         m_assembler.brab(targetGPR, tag);
236     }
237 
238     void farJump(BaseIndex address, PtrTag tag)
239     {
240         if (tag == NoPtrTag)
241             return MacroAssemblerARM64::farJump(address, tag);
242 
243         ASSERT(tag != CFunctionPtrTag);
244         RegisterID targetGPR = getCachedDataTempRegisterIDAndInvalidate();
245         RegisterID diversityGPR = getCachedMemoryTempRegisterIDAndInvalidate();
246         load64(address, targetGPR);
247         move(TrustedImm64(tag), diversityGPR);
248         m_assembler.brab(targetGPR, diversityGPR);
249     }
250 
251     void farJump(BaseIndex address, RegisterID tag)
252     {
253         RegisterID targetGPR = getCachedDataTempRegisterIDAndInvalidate();
254         ASSERT(tag != targetGPR);
255         load64(address, targetGPR);
256         m_assembler.brab(targetGPR, tag);
257     }
258 
259     void farJump(AbsoluteAddress address, PtrTag tag)
260     {
261         if (tag == NoPtrTag)
262             return MacroAssemblerARM64::farJump(address, tag);
263 
264         RegisterID targetGPR = getCachedDataTempRegisterIDAndInvalidate();
265         RegisterID diversityGPR = getCachedMemoryTempRegisterIDAndInvalidate();
266         move(TrustedImmPtr(address.m_ptr), targetGPR);
267         load64(Address(targetGPR), targetGPR);
268         move(TrustedImm64(tag), diversityGPR);
269         m_assembler.brab(targetGPR, diversityGPR);
270     }
271 
272     void farJump(AbsoluteAddress address, RegisterID tag)
273     {
274         RegisterID targetGPR = getCachedDataTempRegisterIDAndInvalidate();
275         ASSERT(tag != targetGPR);
276         move(TrustedImmPtr(address.m_ptr), targetGPR);
277         load64(Address(targetGPR), targetGPR);
278         m_assembler.brab(targetGPR, tag);
279     }
280 
281     ALWAYS_INLINE void ret()
282     {
283         m_assembler.retab();
284     }
285 };
286 
287 } // namespace JSC
288 
289 #endif // ENABLE(ASSEMBLER) &amp;&amp; CPU(ARM64E)
    </pre>
  </body>
</html>
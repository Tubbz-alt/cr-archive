<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/DateMath.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DataLog.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DateMath.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/DateMath.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.</span>
   4  * Copyright (C) 2009 Google Inc. All rights reserved.
   5  * Copyright (C) 2007-2009 Torch Mobile, Inc.
   6  * Copyright (C) 2010 &amp;yet, LLC. (nate@andyet.net)
   7  *
   8  * The Original Code is Mozilla Communicator client code, released
   9  * March 31, 1998.
  10  *
  11  * The Initial Developer of the Original Code is
  12  * Netscape Communications Corporation.
  13  * Portions created by the Initial Developer are Copyright (C) 1998
  14  * the Initial Developer. All Rights Reserved.
  15  *
  16  * This library is free software; you can redistribute it and/or
  17  * modify it under the terms of the GNU Lesser General Public
  18  * License as published by the Free Software Foundation; either
  19  * version 2.1 of the License, or (at your option) any later version.
  20  *
  21  * This library is distributed in the hope that it will be useful,
  22  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  23  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
</pre>
<hr />
<pre>
  92 #endif
  93 
  94 #if HAVE(SYS_TIME_H)
  95 #include &lt;sys/time.h&gt;
  96 #endif
  97 
  98 #if HAVE(SYS_TIMEB_H)
  99 #include &lt;sys/timeb.h&gt;
 100 #endif
 101 
 102 namespace WTF {
 103 
 104 // FIXME: Should this function go into StringCommon.h or some other header?
 105 template&lt;unsigned length&gt; inline bool startsWithLettersIgnoringASCIICase(const char* string, const char (&amp;lowercaseLetters)[length])
 106 {
 107     return equalLettersIgnoringASCIICase(string, lowercaseLetters, length - 1);
 108 }
 109 
 110 /* Constants */
 111 
<span class="line-modified"> 112 static const double maxUnixTime = 2145859200.0; // 12/31/2037</span>
<span class="line-modified"> 113 // ECMAScript asks not to support for a date of which total</span>
<span class="line-modified"> 114 // millisecond value is larger than the following value.</span>
<span class="line-removed"> 115 // See 15.9.1.14 of ECMA-262 5th edition.</span>
<span class="line-removed"> 116 static const double maxECMAScriptTime = 8.64E15;</span>
 117 
 118 // Day of year for the first day of each month, where index 0 is January, and day 0 is January 1.
 119 // First for non-leap years, then for leap years.
<span class="line-modified"> 120 static const int firstDayOfMonth[2][12] = {</span>
 121     {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334},
 122     {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335}
 123 };
 124 
 125 #if !OS(WINDOWS) || HAVE(TM_GMTOFF)
 126 static inline void getLocalTime(const time_t* localTime, struct tm* localTM)
 127 {
 128 #if HAVE(LOCALTIME_R)
 129     localtime_r(localTime, localTM);
 130 #else
 131     localtime_s(localTime, localTM);
 132 #endif
 133 }
 134 #endif
 135 
<span class="line-removed"> 136 bool isLeapYear(int year)</span>
<span class="line-removed"> 137 {</span>
<span class="line-removed"> 138     if (year % 4 != 0)</span>
<span class="line-removed"> 139         return false;</span>
<span class="line-removed"> 140     if (year % 400 == 0)</span>
<span class="line-removed"> 141         return true;</span>
<span class="line-removed"> 142     if (year % 100 == 0)</span>
<span class="line-removed"> 143         return false;</span>
<span class="line-removed"> 144     return true;</span>
<span class="line-removed"> 145 }</span>
<span class="line-removed"> 146 </span>
<span class="line-removed"> 147 static inline int daysInYear(int year)</span>
<span class="line-removed"> 148 {</span>
<span class="line-removed"> 149     return 365 + isLeapYear(year);</span>
<span class="line-removed"> 150 }</span>
<span class="line-removed"> 151 </span>
<span class="line-removed"> 152 static inline double daysFrom1970ToYear(int year)</span>
<span class="line-removed"> 153 {</span>
<span class="line-removed"> 154     // The Gregorian Calendar rules for leap years:</span>
<span class="line-removed"> 155     // Every fourth year is a leap year.  2004, 2008, and 2012 are leap years.</span>
<span class="line-removed"> 156     // However, every hundredth year is not a leap year.  1900 and 2100 are not leap years.</span>
<span class="line-removed"> 157     // Every four hundred years, there&#39;s a leap year after all.  2000 and 2400 are leap years.</span>
<span class="line-removed"> 158 </span>
<span class="line-removed"> 159     static const int leapDaysBefore1971By4Rule = 1970 / 4;</span>
<span class="line-removed"> 160     static const int excludedLeapDaysBefore1971By100Rule = 1970 / 100;</span>
<span class="line-removed"> 161     static const int leapDaysBefore1971By400Rule = 1970 / 400;</span>
<span class="line-removed"> 162 </span>
<span class="line-removed"> 163     const double yearMinusOne = year - 1;</span>
<span class="line-removed"> 164     const double yearsToAddBy4Rule = floor(yearMinusOne / 4.0) - leapDaysBefore1971By4Rule;</span>
<span class="line-removed"> 165     const double yearsToExcludeBy100Rule = floor(yearMinusOne / 100.0) - excludedLeapDaysBefore1971By100Rule;</span>
<span class="line-removed"> 166     const double yearsToAddBy400Rule = floor(yearMinusOne / 400.0) - leapDaysBefore1971By400Rule;</span>
<span class="line-removed"> 167 </span>
<span class="line-removed"> 168     return 365.0 * (year - 1970.0) + yearsToAddBy4Rule - yearsToExcludeBy100Rule + yearsToAddBy400Rule;</span>
<span class="line-removed"> 169 }</span>
<span class="line-removed"> 170 </span>
<span class="line-removed"> 171 double msToDays(double ms)</span>
<span class="line-removed"> 172 {</span>
<span class="line-removed"> 173     return floor(ms / msPerDay);</span>
<span class="line-removed"> 174 }</span>
<span class="line-removed"> 175 </span>
 176 static void appendTwoDigitNumber(StringBuilder&amp; builder, int number)
 177 {
 178     ASSERT(number &gt;= 0);
 179     ASSERT(number &lt; 100);
 180     builder.append(static_cast&lt;LChar&gt;(&#39;0&#39; + number / 10));
 181     builder.append(static_cast&lt;LChar&gt;(&#39;0&#39; + number % 10));
 182 }
 183 
<span class="line-removed"> 184 int msToYear(double ms)</span>
<span class="line-removed"> 185 {</span>
<span class="line-removed"> 186     int approxYear = static_cast&lt;int&gt;(floor(ms / (msPerDay * 365.2425)) + 1970);</span>
<span class="line-removed"> 187     double msFromApproxYearTo1970 = msPerDay * daysFrom1970ToYear(approxYear);</span>
<span class="line-removed"> 188     if (msFromApproxYearTo1970 &gt; ms)</span>
<span class="line-removed"> 189         return approxYear - 1;</span>
<span class="line-removed"> 190     if (msFromApproxYearTo1970 + msPerDay * daysInYear(approxYear) &lt;= ms)</span>
<span class="line-removed"> 191         return approxYear + 1;</span>
<span class="line-removed"> 192     return approxYear;</span>
<span class="line-removed"> 193 }</span>
<span class="line-removed"> 194 </span>
<span class="line-removed"> 195 int dayInYear(double ms, int year)</span>
<span class="line-removed"> 196 {</span>
<span class="line-removed"> 197     return static_cast&lt;int&gt;(msToDays(ms) - daysFrom1970ToYear(year));</span>
<span class="line-removed"> 198 }</span>
<span class="line-removed"> 199 </span>
 200 static inline double msToMilliseconds(double ms)
 201 {
 202     double result = fmod(ms, msPerDay);
 203     if (result &lt; 0)
 204         result += msPerDay;
 205     return result;
 206 }
 207 
<span class="line-removed"> 208 int msToMinutes(double ms)</span>
<span class="line-removed"> 209 {</span>
<span class="line-removed"> 210     double result = fmod(floor(ms / msPerMinute), minutesPerHour);</span>
<span class="line-removed"> 211     if (result &lt; 0)</span>
<span class="line-removed"> 212         result += minutesPerHour;</span>
<span class="line-removed"> 213     return static_cast&lt;int&gt;(result);</span>
<span class="line-removed"> 214 }</span>
<span class="line-removed"> 215 </span>
<span class="line-removed"> 216 int msToHours(double ms)</span>
<span class="line-removed"> 217 {</span>
<span class="line-removed"> 218     double result = fmod(floor(ms/msPerHour), hoursPerDay);</span>
<span class="line-removed"> 219     if (result &lt; 0)</span>
<span class="line-removed"> 220         result += hoursPerDay;</span>
<span class="line-removed"> 221     return static_cast&lt;int&gt;(result);</span>
<span class="line-removed"> 222 }</span>
<span class="line-removed"> 223 </span>
<span class="line-removed"> 224 int monthFromDayInYear(int dayInYear, bool leapYear)</span>
<span class="line-removed"> 225 {</span>
<span class="line-removed"> 226     const int d = dayInYear;</span>
<span class="line-removed"> 227     int step;</span>
<span class="line-removed"> 228 </span>
<span class="line-removed"> 229     if (d &lt; (step = 31))</span>
<span class="line-removed"> 230         return 0;</span>
<span class="line-removed"> 231     step += (leapYear ? 29 : 28);</span>
<span class="line-removed"> 232     if (d &lt; step)</span>
<span class="line-removed"> 233         return 1;</span>
<span class="line-removed"> 234     if (d &lt; (step += 31))</span>
<span class="line-removed"> 235         return 2;</span>
<span class="line-removed"> 236     if (d &lt; (step += 30))</span>
<span class="line-removed"> 237         return 3;</span>
<span class="line-removed"> 238     if (d &lt; (step += 31))</span>
<span class="line-removed"> 239         return 4;</span>
<span class="line-removed"> 240     if (d &lt; (step += 30))</span>
<span class="line-removed"> 241         return 5;</span>
<span class="line-removed"> 242     if (d &lt; (step += 31))</span>
<span class="line-removed"> 243         return 6;</span>
<span class="line-removed"> 244     if (d &lt; (step += 31))</span>
<span class="line-removed"> 245         return 7;</span>
<span class="line-removed"> 246     if (d &lt; (step += 30))</span>
<span class="line-removed"> 247         return 8;</span>
<span class="line-removed"> 248     if (d &lt; (step += 31))</span>
<span class="line-removed"> 249         return 9;</span>
<span class="line-removed"> 250     if (d &lt; (step += 30))</span>
<span class="line-removed"> 251         return 10;</span>
<span class="line-removed"> 252     return 11;</span>
<span class="line-removed"> 253 }</span>
<span class="line-removed"> 254 </span>
<span class="line-removed"> 255 static inline bool checkMonth(int dayInYear, int&amp; startDayOfThisMonth, int&amp; startDayOfNextMonth, int daysInThisMonth)</span>
<span class="line-removed"> 256 {</span>
<span class="line-removed"> 257     startDayOfThisMonth = startDayOfNextMonth;</span>
<span class="line-removed"> 258     startDayOfNextMonth += daysInThisMonth;</span>
<span class="line-removed"> 259     return (dayInYear &lt;= startDayOfNextMonth);</span>
<span class="line-removed"> 260 }</span>
<span class="line-removed"> 261 </span>
<span class="line-removed"> 262 int dayInMonthFromDayInYear(int dayInYear, bool leapYear)</span>
<span class="line-removed"> 263 {</span>
<span class="line-removed"> 264     const int d = dayInYear;</span>
<span class="line-removed"> 265     int step;</span>
<span class="line-removed"> 266     int next = 30;</span>
<span class="line-removed"> 267 </span>
<span class="line-removed"> 268     if (d &lt;= next)</span>
<span class="line-removed"> 269         return d + 1;</span>
<span class="line-removed"> 270     const int daysInFeb = (leapYear ? 29 : 28);</span>
<span class="line-removed"> 271     if (checkMonth(d, step, next, daysInFeb))</span>
<span class="line-removed"> 272         return d - step;</span>
<span class="line-removed"> 273     if (checkMonth(d, step, next, 31))</span>
<span class="line-removed"> 274         return d - step;</span>
<span class="line-removed"> 275     if (checkMonth(d, step, next, 30))</span>
<span class="line-removed"> 276         return d - step;</span>
<span class="line-removed"> 277     if (checkMonth(d, step, next, 31))</span>
<span class="line-removed"> 278         return d - step;</span>
<span class="line-removed"> 279     if (checkMonth(d, step, next, 30))</span>
<span class="line-removed"> 280         return d - step;</span>
<span class="line-removed"> 281     if (checkMonth(d, step, next, 31))</span>
<span class="line-removed"> 282         return d - step;</span>
<span class="line-removed"> 283     if (checkMonth(d, step, next, 31))</span>
<span class="line-removed"> 284         return d - step;</span>
<span class="line-removed"> 285     if (checkMonth(d, step, next, 30))</span>
<span class="line-removed"> 286         return d - step;</span>
<span class="line-removed"> 287     if (checkMonth(d, step, next, 31))</span>
<span class="line-removed"> 288         return d - step;</span>
<span class="line-removed"> 289     if (checkMonth(d, step, next, 30))</span>
<span class="line-removed"> 290         return d - step;</span>
<span class="line-removed"> 291     step = next;</span>
<span class="line-removed"> 292     return d - step;</span>
<span class="line-removed"> 293 }</span>
<span class="line-removed"> 294 </span>
<span class="line-removed"> 295 int dayInYear(int year, int month, int day)</span>
<span class="line-removed"> 296 {</span>
<span class="line-removed"> 297     return firstDayOfMonth[isLeapYear(year)][month] + day - 1;</span>
<span class="line-removed"> 298 }</span>
<span class="line-removed"> 299 </span>
<span class="line-removed"> 300 double dateToDaysFrom1970(int year, int month, int day)</span>
<span class="line-removed"> 301 {</span>
<span class="line-removed"> 302     year += month / 12;</span>
<span class="line-removed"> 303 </span>
<span class="line-removed"> 304     month %= 12;</span>
<span class="line-removed"> 305     if (month &lt; 0) {</span>
<span class="line-removed"> 306         month += 12;</span>
<span class="line-removed"> 307         --year;</span>
<span class="line-removed"> 308     }</span>
<span class="line-removed"> 309 </span>
<span class="line-removed"> 310     double yearday = floor(daysFrom1970ToYear(year));</span>
<span class="line-removed"> 311     ASSERT((year &gt;= 1970 &amp;&amp; yearday &gt;= 0) || (year &lt; 1970 &amp;&amp; yearday &lt; 0));</span>
<span class="line-removed"> 312     return yearday + dayInYear(year, month, day);</span>
<span class="line-removed"> 313 }</span>
<span class="line-removed"> 314 </span>
 315 // There is a hard limit at 2038 that we currently do not have a workaround
 316 // for (rdar://problem/5052975).
 317 static inline int maximumYearForDST()
 318 {
 319     return 2037;
 320 }
 321 
 322 static inline int minimumYearForDST()
 323 {
 324     // Because of the 2038 issue (see maximumYearForDST) if the current year is
 325     // greater than the max year minus 27 (2010), we want to use the max year
 326     // minus 27 instead, to ensure there is a range of 28 years that all years
 327     // can map to.
 328     return std::min(msToYear(jsCurrentTime()), maximumYearForDST() - 27) ;
 329 }
 330 
 331 /*
 332  * Find an equivalent year for the one given, where equivalence is deterined by
 333  * the two years having the same leapness and the first day of the year, falling
 334  * on the same day of the week.
</pre>
<hr />
<pre>
 417     // Get the difference between this time zone and UTC on the 1st of January of this year.
 418     localt.tm_sec = 0;
 419     localt.tm_min = 0;
 420     localt.tm_hour = 0;
 421     localt.tm_mday = 1;
 422     localt.tm_mon = 0;
 423     // Not setting localt.tm_year!
 424     localt.tm_wday = 0;
 425     localt.tm_yday = 0;
 426     localt.tm_isdst = 0;
 427 #if HAVE(TM_GMTOFF)
 428     localt.tm_gmtoff = 0;
 429 #endif
 430 #if HAVE(TM_ZONE)
 431     localt.tm_zone = 0;
 432 #endif
 433 
 434 #if HAVE(TIMEGM)
 435     time_t utcOffset = timegm(&amp;localt) - mktime(&amp;localt);
 436 #else
<span class="line-modified"> 437     // Using a canned date of 01/01/2009 on platforms with weaker date-handling foo.</span>
<span class="line-modified"> 438     localt.tm_year = 109;</span>
<span class="line-modified"> 439     time_t utcOffset = 1230768000 - mktime(&amp;localt);</span>
 440 #endif
 441 
 442     return static_cast&lt;int32_t&gt;(utcOffset * 1000);
 443 #endif
 444 }
 445 
 446 #if !HAVE(TM_GMTOFF)
 447 
 448 #if OS(WINDOWS)
 449 // Code taken from http://support.microsoft.com/kb/167296
 450 static void UnixTimeToFileTime(time_t t, LPFILETIME pft)
 451 {
 452     // Note that LONGLONG is a 64-bit value
 453     LONGLONG ll;
 454 
 455     ll = Int32x32To64(t, 10000000) + 116444736000000000;
 456     pft-&gt;dwLowDateTime = (DWORD)ll;
 457     pft-&gt;dwHighDateTime = ll &gt;&gt; 32;
 458 }
 459 #endif
</pre>
<hr />
<pre>
 525     double localTimeSeconds = ms / msPerSecond;
 526     if (localTimeSeconds &gt; maxUnixTime)
 527         localTimeSeconds = maxUnixTime;
 528     else if (localTimeSeconds &lt; 0) // Go ahead a day to make localtime work (does not work with 0).
 529         localTimeSeconds += secondsPerDay;
 530     // FIXME: time_t has a potential problem in 2038.
 531     time_t localTime = static_cast&lt;time_t&gt;(localTimeSeconds);
 532 
 533 #if HAVE(TM_GMTOFF)
 534     tm localTM;
 535     getLocalTime(&amp;localTime, &amp;localTM);
 536     return LocalTimeOffset(localTM.tm_isdst, localTM.tm_gmtoff * msPerSecond);
 537 #else
 538     double dstOffset = calculateDSTOffset(localTime, localToUTCTimeOffset);
 539     return LocalTimeOffset(dstOffset, localToUTCTimeOffset + dstOffset);
 540 #endif
 541 }
 542 
 543 void initializeDates()
 544 {
<span class="line-modified"> 545 #if !ASSERT_DISABLED</span>
 546     static bool alreadyInitialized;
 547     ASSERT(!alreadyInitialized);
 548     alreadyInitialized = true;
 549 #endif
 550 
 551     equivalentYearForDST(2000); // Need to call once to initialize a static used in this function.
 552 }
 553 
 554 static inline double ymdhmsToSeconds(int year, long mon, long day, long hour, long minute, double second)
 555 {
 556     int mday = firstDayOfMonth[isLeapYear(year)][mon - 1];
 557     double ydays = daysFrom1970ToYear(year);
 558 
 559     double dateSeconds = second + minute * secondsPerMinute + hour * secondsPerHour + (mday + day - 1 + ydays) * secondsPerDay;
 560 
 561     // Clamp to EcmaScript standard (ecma262/#sec-time-values-and-time-range) of
 562     //  +/- 100,000,000 days from 01 January, 1970.
 563     if (dateSeconds &lt; -8640000000000.0 || dateSeconds &gt; 8640000000000.0)
 564         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 565 
</pre>
<hr />
<pre>
 666         return 0;
 667     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;month))
 668         return 0;
 669     if ((postParsePosition - currentPosition) != 2)
 670         return 0;
 671 
 672     // Check for presence of -DD portion.
 673     if (*postParsePosition != &#39;-&#39;)
 674         return postParsePosition;
 675     currentPosition = postParsePosition + 1;
 676 
 677     if (!isASCIIDigit(*currentPosition))
 678         return 0;
 679     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;day))
 680         return 0;
 681     if ((postParsePosition - currentPosition) != 2)
 682         return 0;
 683     return postParsePosition;
 684 }
 685 
<span class="line-modified"> 686 // Parses a time with the format HH:mm[:ss[.sss]][Z|(+|-)00:00].</span>
 687 // Fractional seconds parsing is lenient, allows any number of digits.
 688 // Returns 0 if a parse error occurs, else returns the end of the parsed portion of the string.
<span class="line-modified"> 689 static char* parseES5TimePortion(char* currentPosition, long&amp; hours, long&amp; minutes, double&amp; seconds, long&amp; timeZoneSeconds)</span>
 690 {


 691     char* postParsePosition;
 692     if (!isASCIIDigit(*currentPosition))
 693         return 0;
 694     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;hours))
 695         return 0;
 696     if (*postParsePosition != &#39;:&#39; || (postParsePosition - currentPosition) != 2)
 697         return 0;
 698     currentPosition = postParsePosition + 1;
 699 
 700     if (!isASCIIDigit(*currentPosition))
 701         return 0;
 702     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;minutes))
 703         return 0;
 704     if ((postParsePosition - currentPosition) != 2)
 705         return 0;
 706     currentPosition = postParsePosition;
 707 
 708     // Seconds are optional.
 709     if (*currentPosition == &#39;:&#39;) {
 710         ++currentPosition;
</pre>
<hr />
<pre>
 723             // In ECMA-262-5 it&#39;s a bit unclear if &#39;.&#39; can be present without milliseconds, but
 724             // a reasonable interpretation guided by the given examples and RFC 3339 says &quot;no&quot;.
 725             // We check the next character to avoid reading +/- timezone hours after an invalid decimal.
 726             if (!isASCIIDigit(*currentPosition))
 727                 return 0;
 728 
 729             // We are more lenient than ES5 by accepting more or less than 3 fraction digits.
 730             long fracSeconds;
 731             if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;fracSeconds))
 732                 return 0;
 733 
 734             long numFracDigits = postParsePosition - currentPosition;
 735             seconds += fracSeconds * pow(10.0, static_cast&lt;double&gt;(-numFracDigits));
 736         }
 737         currentPosition = postParsePosition;
 738     }
 739 
 740     if (*currentPosition == &#39;Z&#39;)
 741         return currentPosition + 1;
 742 

 743     bool tzNegative;
 744     if (*currentPosition == &#39;-&#39;)
 745         tzNegative = true;
 746     else if (*currentPosition == &#39;+&#39;)
 747         tzNegative = false;
<span class="line-modified"> 748     else</span>
<span class="line-modified"> 749         return currentPosition; // no timezone</span>


 750     ++currentPosition;
 751 
<span class="line-modified"> 752     long tzHours;</span>
<span class="line-modified"> 753     long tzHoursAbs;</span>
<span class="line-modified"> 754     long tzMinutes;</span>
 755 
 756     if (!isASCIIDigit(*currentPosition))
 757         return 0;
 758     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;tzHours))
 759         return 0;
<span class="line-modified"> 760     if (*postParsePosition != &#39;:&#39; || (postParsePosition - currentPosition) != 2)</span>
<span class="line-modified"> 761         return 0;</span>
<span class="line-modified"> 762     tzHoursAbs = labs(tzHours);</span>
<span class="line-modified"> 763     currentPosition = postParsePosition + 1;</span>













 764 
<span class="line-modified"> 765     if (!isASCIIDigit(*currentPosition))</span>
<span class="line-modified"> 766         return 0;</span>
<span class="line-modified"> 767     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;tzMinutes))</span>
<span class="line-modified"> 768         return 0;</span>
<span class="line-modified"> 769     if ((postParsePosition - currentPosition) != 2)</span>
<span class="line-modified"> 770         return 0;</span>

 771     currentPosition = postParsePosition;
 772 
 773     if (tzHoursAbs &gt; 24)
 774         return 0;
 775     if (tzMinutes &lt; 0 || tzMinutes &gt; 59)
 776         return 0;
 777 
 778     timeZoneSeconds = 60 * (tzMinutes + (60 * tzHoursAbs));
 779     if (tzNegative)
 780         timeZoneSeconds = -timeZoneSeconds;
 781 
 782     return currentPosition;
 783 }
 784 
<span class="line-modified"> 785 double parseES5DateFromNullTerminatedCharacters(const char* dateString)</span>
 786 {


 787     // This parses a date of the form defined in ecma262/#sec-date-time-string-format
 788     // (similar to RFC 3339 / ISO 8601: YYYY-MM-DDTHH:mm:ss[.sss]Z).
 789     // In most cases it is intentionally strict (e.g. correct field widths, no stray whitespace).
 790 
 791     static const long daysPerMonth[12] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
 792 
 793     // The year must be present, but the other fields may be omitted - see ES5.1 15.9.1.15.
 794     int year = 0;
 795     long month = 1;
 796     long day = 1;
 797     long hours = 0;
 798     long minutes = 0;
 799     double seconds = 0;
 800     long timeZoneSeconds = 0;
 801 
 802     // Parse the date YYYY[-MM[-DD]]
 803     char* currentPosition = parseES5DatePortion(dateString, year, month, day);
 804     if (!currentPosition)
 805         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 806     // Look for a time portion.

 807     if (*currentPosition == &#39;T&#39;) {
<span class="line-modified"> 808         // Parse the time HH:mm[:ss[.sss]][Z|(+|-)00:00]</span>
<span class="line-modified"> 809         currentPosition = parseES5TimePortion(currentPosition + 1, hours, minutes, seconds, timeZoneSeconds);</span>
 810         if (!currentPosition)
 811             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 812     }
 813     // Check that we have parsed all characters in the string.
 814     if (*currentPosition)
 815         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 816 
 817     // A few of these checks could be done inline above, but since many of them are interrelated
 818     // we would be sacrificing readability to &quot;optimize&quot; the (presumably less common) failure path.
 819     if (month &lt; 1 || month &gt; 12)
 820         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 821     if (day &lt; 1 || day &gt; daysPerMonth[month - 1])
 822         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 823     if (month == 2 &amp;&amp; day &gt; 28 &amp;&amp; !isLeapYear(year))
 824         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 825     if (hours &lt; 0 || hours &gt; 24)
 826         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 827     if (hours == 24 &amp;&amp; (minutes || seconds))
 828         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 829     if (minutes &lt; 0 || minutes &gt; 59)
 830         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 831     if (seconds &lt; 0 || seconds &gt;= 61)
 832         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 833     if (seconds &gt; 60) {
 834         // Discard leap seconds by clamping to the end of a minute.
 835         seconds = 60;
 836     }
 837 
 838     double dateSeconds = ymdhmsToSeconds(year, month, day, hours, minutes, seconds) - timeZoneSeconds;
 839     return dateSeconds * msPerSecond;
 840 }
 841 
 842 // Odd case where &#39;exec&#39; is allowed to be 0, to accomodate a caller in WebCore.
<span class="line-modified"> 843 double parseDateFromNullTerminatedCharacters(const char* dateString, bool&amp; haveTZ, int&amp; offset)</span>
 844 {
<span class="line-modified"> 845     haveTZ = false;</span>
<span class="line-modified"> 846     offset = 0;</span>
 847 
 848     // This parses a date in the form:
 849     //     Tuesday, 09-Nov-99 23:12:40 GMT
 850     // or
 851     //     Sat, 01-Jan-2000 08:00:00 GMT
 852     // or
 853     //     Sat, 01 Jan 2000 08:00:00 GMT
 854     // or
 855     //     01 Jan 99 22:00 +0100    (exceptions in rfc822/rfc2822)
 856     // ### non RFC formats, added for Javascript:
 857     //     [Wednesday] January 09 1999 23:12:40 GMT
 858     //     [Wednesday] January 09 23:12:40 GMT 1999
 859     //
 860     // We ignore the weekday.
 861 
 862     // Skip leading space
 863     skipSpacesAndComments(dateString);
 864 
 865     long month = -1;
 866     const char *wordStart = dateString;
</pre>
<hr />
<pre>
1044                 skipSpacesAndComments(dateString);
1045             }
1046         }
1047     }
1048 
1049     // The year may be after the time but before the time zone.
1050     if (isASCIIDigit(*dateString) &amp;&amp; !year) {
1051         int result = 0;
1052         if (!parseInt(dateString, &amp;newPosStr, 10, &amp;result))
1053             return std::numeric_limits&lt;double&gt;::quiet_NaN();
1054         year = result;
1055         dateString = newPosStr;
1056         skipSpacesAndComments(dateString);
1057     }
1058 
1059     // Don&#39;t fail if the time zone is missing.
1060     // Some websites omit the time zone (4275206).
1061     if (*dateString) {
1062         if (startsWithLettersIgnoringASCIICase(dateString, &quot;gmt&quot;) || startsWithLettersIgnoringASCIICase(dateString, &quot;utc&quot;)) {
1063             dateString += 3;
<span class="line-modified">1064             haveTZ = true;</span>
1065         }
1066 
1067         if (*dateString == &#39;+&#39; || *dateString == &#39;-&#39;) {
1068             int o;
1069             if (!parseInt(dateString, &amp;newPosStr, 10, &amp;o))
1070                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
1071             dateString = newPosStr;
1072 
1073             if (o &lt; -9959 || o &gt; 9959)
1074                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
1075 
1076             int sgn = (o &lt; 0) ? -1 : 1;
1077             o = abs(o);
1078             if (*dateString != &#39;:&#39;) {
1079                 if (o &gt;= 24)
1080                     offset = ((o / 100) * 60 + (o % 100)) * sgn;
1081                 else
1082                     offset = o * 60 * sgn;
1083             } else { // GMT+05:00
1084                 ++dateString; // skip the &#39;:&#39;
1085                 int o2;
1086                 if (!parseInt(dateString, &amp;newPosStr, 10, &amp;o2))
1087                     return std::numeric_limits&lt;double&gt;::quiet_NaN();
1088                 dateString = newPosStr;
1089                 offset = (o * 60 + o2) * sgn;
1090             }
<span class="line-modified">1091             haveTZ = true;</span>
1092         } else {
1093             for (auto&amp; knownZone : knownZones) {
1094                 // Since the passed-in length is used for both strings, the following checks that
1095                 // dateString has the time zone name as a prefix, not that it is equal.
1096                 auto length = strlen(knownZone.tzName);
1097                 if (equalLettersIgnoringASCIICase(dateString, knownZone.tzName, length)) {
1098                     offset = knownZone.tzOffset;
1099                     dateString += length;
<span class="line-modified">1100                     haveTZ = true;</span>
1101                     break;
1102                 }
1103             }
1104         }
1105     }
1106 
1107     skipSpacesAndComments(dateString);
1108 
1109     if (*dateString &amp;&amp; !year) {
1110         int result = 0;
1111         if (!parseInt(dateString, &amp;newPosStr, 10, &amp;result))
1112             return std::numeric_limits&lt;double&gt;::quiet_NaN();
1113         year = result;
1114         dateString = newPosStr;
1115         skipSpacesAndComments(dateString);
1116     }
1117 
1118     // Trailing garbage
1119     if (*dateString)
1120         return std::numeric_limits&lt;double&gt;::quiet_NaN();
</pre>
<hr />
<pre>
1124         int yearValue = year.value();
1125         if (yearValue &gt;= 0 &amp;&amp; yearValue &lt; 100) {
1126             if (yearValue &lt; 50)
1127                 yearValue += 2000;
1128             else
1129                 yearValue += 1900;
1130         }
1131         year = yearValue;
1132     } else {
1133         // We select 2000 as default value. This is because of the following reasons.
1134         // 1. Year 2000 was used for the initial value of the variable `year`. While it won&#39;t be posed to users in WebKit,
1135         //    V8 used this 2000 as its default value. (As of April 2017, V8 is using the year 2001 and Spider Monkey is
1136         //    not doing this kind of fallback.)
1137         // 2. It is a leap year. When using `new Date(&quot;Feb 29&quot;)`, we assume that people want to save month and day.
1138         //    Leap year can save user inputs if they is valid. If we use the current year instead, the current year
1139         //    may not be a leap year. In that case, `new Date(&quot;Feb 29&quot;).getMonth()` becomes 2 (March).
1140         year = 2000;
1141     }
1142     ASSERT(year);
1143 
<span class="line-modified">1144     return ymdhmsToSeconds(year.value(), month + 1, day, hour, minute, second) * msPerSecond;</span>

1145 }
1146 
1147 double parseDateFromNullTerminatedCharacters(const char* dateString)
1148 {
<span class="line-modified">1149     bool haveTZ;</span>
<span class="line-modified">1150     int offset;</span>
<span class="line-removed">1151     double ms = parseDateFromNullTerminatedCharacters(dateString, haveTZ, offset);</span>
<span class="line-removed">1152     if (std::isnan(ms))</span>
<span class="line-removed">1153         return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-removed">1154 </span>
<span class="line-removed">1155     // fall back to local timezone</span>
<span class="line-removed">1156     if (!haveTZ)</span>
<span class="line-removed">1157         offset = calculateLocalTimeOffset(ms, LocalTime).offset / msPerMinute; // ms value is in local time milliseconds.</span>
1158 
<span class="line-modified">1159     return ms - (offset * msPerMinute);</span>
<span class="line-modified">1160 }</span>
1161 
<span class="line-modified">1162 double timeClip(double t)</span>
<span class="line-removed">1163 {</span>
<span class="line-removed">1164     if (std::abs(t) &gt; maxECMAScriptTime)</span>
<span class="line-removed">1165         return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-removed">1166     return std::trunc(t) + 0.0;</span>
1167 }
1168 
1169 // See http://tools.ietf.org/html/rfc2822#section-3.3 for more information.
1170 String makeRFC2822DateString(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset)
1171 {
1172     StringBuilder stringBuilder;
1173     stringBuilder.append(weekdayName[dayOfWeek], &quot;, &quot;, day, &#39; &#39;, monthName[month], &#39; &#39;, year, &#39; &#39;);
1174 
1175     appendTwoDigitNumber(stringBuilder, hours);
1176     stringBuilder.append(&#39;:&#39;);
1177     appendTwoDigitNumber(stringBuilder, minutes);
1178     stringBuilder.append(&#39;:&#39;);
1179     appendTwoDigitNumber(stringBuilder, seconds);
1180     stringBuilder.append(&#39; &#39;);
1181 
1182     stringBuilder.append(utcOffset &gt; 0 ? &#39;+&#39; : &#39;-&#39;);
1183     int absoluteUTCOffset = abs(utcOffset);
1184     appendTwoDigitNumber(stringBuilder, absoluteUTCOffset / 60);
1185     appendTwoDigitNumber(stringBuilder, absoluteUTCOffset % 60);
1186 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
   4  * Copyright (C) 2009 Google Inc. All rights reserved.
   5  * Copyright (C) 2007-2009 Torch Mobile, Inc.
   6  * Copyright (C) 2010 &amp;yet, LLC. (nate@andyet.net)
   7  *
   8  * The Original Code is Mozilla Communicator client code, released
   9  * March 31, 1998.
  10  *
  11  * The Initial Developer of the Original Code is
  12  * Netscape Communications Corporation.
  13  * Portions created by the Initial Developer are Copyright (C) 1998
  14  * the Initial Developer. All Rights Reserved.
  15  *
  16  * This library is free software; you can redistribute it and/or
  17  * modify it under the terms of the GNU Lesser General Public
  18  * License as published by the Free Software Foundation; either
  19  * version 2.1 of the License, or (at your option) any later version.
  20  *
  21  * This library is distributed in the hope that it will be useful,
  22  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  23  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
</pre>
<hr />
<pre>
  92 #endif
  93 
  94 #if HAVE(SYS_TIME_H)
  95 #include &lt;sys/time.h&gt;
  96 #endif
  97 
  98 #if HAVE(SYS_TIMEB_H)
  99 #include &lt;sys/timeb.h&gt;
 100 #endif
 101 
 102 namespace WTF {
 103 
 104 // FIXME: Should this function go into StringCommon.h or some other header?
 105 template&lt;unsigned length&gt; inline bool startsWithLettersIgnoringASCIICase(const char* string, const char (&amp;lowercaseLetters)[length])
 106 {
 107     return equalLettersIgnoringASCIICase(string, lowercaseLetters, length - 1);
 108 }
 109 
 110 /* Constants */
 111 
<span class="line-modified"> 112 const char* const weekdayName[7] = { &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot; };</span>
<span class="line-modified"> 113 const char* const monthName[12] = { &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot; };</span>
<span class="line-modified"> 114 const char* const monthFullName[12] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; };</span>


 115 
 116 // Day of year for the first day of each month, where index 0 is January, and day 0 is January 1.
 117 // First for non-leap years, then for leap years.
<span class="line-modified"> 118 const int firstDayOfMonth[2][12] = {</span>
 119     {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334},
 120     {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335}
 121 };
 122 
 123 #if !OS(WINDOWS) || HAVE(TM_GMTOFF)
 124 static inline void getLocalTime(const time_t* localTime, struct tm* localTM)
 125 {
 126 #if HAVE(LOCALTIME_R)
 127     localtime_r(localTime, localTM);
 128 #else
 129     localtime_s(localTime, localTM);
 130 #endif
 131 }
 132 #endif
 133 








































 134 static void appendTwoDigitNumber(StringBuilder&amp; builder, int number)
 135 {
 136     ASSERT(number &gt;= 0);
 137     ASSERT(number &lt; 100);
 138     builder.append(static_cast&lt;LChar&gt;(&#39;0&#39; + number / 10));
 139     builder.append(static_cast&lt;LChar&gt;(&#39;0&#39; + number % 10));
 140 }
 141 
















 142 static inline double msToMilliseconds(double ms)
 143 {
 144     double result = fmod(ms, msPerDay);
 145     if (result &lt; 0)
 146         result += msPerDay;
 147     return result;
 148 }
 149 











































































































 150 // There is a hard limit at 2038 that we currently do not have a workaround
 151 // for (rdar://problem/5052975).
 152 static inline int maximumYearForDST()
 153 {
 154     return 2037;
 155 }
 156 
 157 static inline int minimumYearForDST()
 158 {
 159     // Because of the 2038 issue (see maximumYearForDST) if the current year is
 160     // greater than the max year minus 27 (2010), we want to use the max year
 161     // minus 27 instead, to ensure there is a range of 28 years that all years
 162     // can map to.
 163     return std::min(msToYear(jsCurrentTime()), maximumYearForDST() - 27) ;
 164 }
 165 
 166 /*
 167  * Find an equivalent year for the one given, where equivalence is deterined by
 168  * the two years having the same leapness and the first day of the year, falling
 169  * on the same day of the week.
</pre>
<hr />
<pre>
 252     // Get the difference between this time zone and UTC on the 1st of January of this year.
 253     localt.tm_sec = 0;
 254     localt.tm_min = 0;
 255     localt.tm_hour = 0;
 256     localt.tm_mday = 1;
 257     localt.tm_mon = 0;
 258     // Not setting localt.tm_year!
 259     localt.tm_wday = 0;
 260     localt.tm_yday = 0;
 261     localt.tm_isdst = 0;
 262 #if HAVE(TM_GMTOFF)
 263     localt.tm_gmtoff = 0;
 264 #endif
 265 #if HAVE(TM_ZONE)
 266     localt.tm_zone = 0;
 267 #endif
 268 
 269 #if HAVE(TIMEGM)
 270     time_t utcOffset = timegm(&amp;localt) - mktime(&amp;localt);
 271 #else
<span class="line-modified"> 272     // Using a canned date of 01/01/2019 on platforms with weaker date-handling foo.</span>
<span class="line-modified"> 273     localt.tm_year = 119;</span>
<span class="line-modified"> 274     time_t utcOffset = 1546300800 - mktime(&amp;localt);</span>
 275 #endif
 276 
 277     return static_cast&lt;int32_t&gt;(utcOffset * 1000);
 278 #endif
 279 }
 280 
 281 #if !HAVE(TM_GMTOFF)
 282 
 283 #if OS(WINDOWS)
 284 // Code taken from http://support.microsoft.com/kb/167296
 285 static void UnixTimeToFileTime(time_t t, LPFILETIME pft)
 286 {
 287     // Note that LONGLONG is a 64-bit value
 288     LONGLONG ll;
 289 
 290     ll = Int32x32To64(t, 10000000) + 116444736000000000;
 291     pft-&gt;dwLowDateTime = (DWORD)ll;
 292     pft-&gt;dwHighDateTime = ll &gt;&gt; 32;
 293 }
 294 #endif
</pre>
<hr />
<pre>
 360     double localTimeSeconds = ms / msPerSecond;
 361     if (localTimeSeconds &gt; maxUnixTime)
 362         localTimeSeconds = maxUnixTime;
 363     else if (localTimeSeconds &lt; 0) // Go ahead a day to make localtime work (does not work with 0).
 364         localTimeSeconds += secondsPerDay;
 365     // FIXME: time_t has a potential problem in 2038.
 366     time_t localTime = static_cast&lt;time_t&gt;(localTimeSeconds);
 367 
 368 #if HAVE(TM_GMTOFF)
 369     tm localTM;
 370     getLocalTime(&amp;localTime, &amp;localTM);
 371     return LocalTimeOffset(localTM.tm_isdst, localTM.tm_gmtoff * msPerSecond);
 372 #else
 373     double dstOffset = calculateDSTOffset(localTime, localToUTCTimeOffset);
 374     return LocalTimeOffset(dstOffset, localToUTCTimeOffset + dstOffset);
 375 #endif
 376 }
 377 
 378 void initializeDates()
 379 {
<span class="line-modified"> 380 #if ASSERT_ENABLED</span>
 381     static bool alreadyInitialized;
 382     ASSERT(!alreadyInitialized);
 383     alreadyInitialized = true;
 384 #endif
 385 
 386     equivalentYearForDST(2000); // Need to call once to initialize a static used in this function.
 387 }
 388 
 389 static inline double ymdhmsToSeconds(int year, long mon, long day, long hour, long minute, double second)
 390 {
 391     int mday = firstDayOfMonth[isLeapYear(year)][mon - 1];
 392     double ydays = daysFrom1970ToYear(year);
 393 
 394     double dateSeconds = second + minute * secondsPerMinute + hour * secondsPerHour + (mday + day - 1 + ydays) * secondsPerDay;
 395 
 396     // Clamp to EcmaScript standard (ecma262/#sec-time-values-and-time-range) of
 397     //  +/- 100,000,000 days from 01 January, 1970.
 398     if (dateSeconds &lt; -8640000000000.0 || dateSeconds &gt; 8640000000000.0)
 399         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 400 
</pre>
<hr />
<pre>
 501         return 0;
 502     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;month))
 503         return 0;
 504     if ((postParsePosition - currentPosition) != 2)
 505         return 0;
 506 
 507     // Check for presence of -DD portion.
 508     if (*postParsePosition != &#39;-&#39;)
 509         return postParsePosition;
 510     currentPosition = postParsePosition + 1;
 511 
 512     if (!isASCIIDigit(*currentPosition))
 513         return 0;
 514     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;day))
 515         return 0;
 516     if ((postParsePosition - currentPosition) != 2)
 517         return 0;
 518     return postParsePosition;
 519 }
 520 
<span class="line-modified"> 521 // Parses a time with the format HH:mm[:ss[.sss]][Z|(+|-)(00:00|0000|00)].</span>
 522 // Fractional seconds parsing is lenient, allows any number of digits.
 523 // Returns 0 if a parse error occurs, else returns the end of the parsed portion of the string.
<span class="line-modified"> 524 static char* parseES5TimePortion(char* currentPosition, long&amp; hours, long&amp; minutes, double&amp; seconds, bool&amp; isLocalTime, long&amp; timeZoneSeconds)</span>
 525 {
<span class="line-added"> 526     isLocalTime = false;</span>
<span class="line-added"> 527 </span>
 528     char* postParsePosition;
 529     if (!isASCIIDigit(*currentPosition))
 530         return 0;
 531     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;hours))
 532         return 0;
 533     if (*postParsePosition != &#39;:&#39; || (postParsePosition - currentPosition) != 2)
 534         return 0;
 535     currentPosition = postParsePosition + 1;
 536 
 537     if (!isASCIIDigit(*currentPosition))
 538         return 0;
 539     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;minutes))
 540         return 0;
 541     if ((postParsePosition - currentPosition) != 2)
 542         return 0;
 543     currentPosition = postParsePosition;
 544 
 545     // Seconds are optional.
 546     if (*currentPosition == &#39;:&#39;) {
 547         ++currentPosition;
</pre>
<hr />
<pre>
 560             // In ECMA-262-5 it&#39;s a bit unclear if &#39;.&#39; can be present without milliseconds, but
 561             // a reasonable interpretation guided by the given examples and RFC 3339 says &quot;no&quot;.
 562             // We check the next character to avoid reading +/- timezone hours after an invalid decimal.
 563             if (!isASCIIDigit(*currentPosition))
 564                 return 0;
 565 
 566             // We are more lenient than ES5 by accepting more or less than 3 fraction digits.
 567             long fracSeconds;
 568             if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;fracSeconds))
 569                 return 0;
 570 
 571             long numFracDigits = postParsePosition - currentPosition;
 572             seconds += fracSeconds * pow(10.0, static_cast&lt;double&gt;(-numFracDigits));
 573         }
 574         currentPosition = postParsePosition;
 575     }
 576 
 577     if (*currentPosition == &#39;Z&#39;)
 578         return currentPosition + 1;
 579 
<span class="line-added"> 580     // Parse (+|-)(00:00|0000|00).</span>
 581     bool tzNegative;
 582     if (*currentPosition == &#39;-&#39;)
 583         tzNegative = true;
 584     else if (*currentPosition == &#39;+&#39;)
 585         tzNegative = false;
<span class="line-modified"> 586     else {</span>
<span class="line-modified"> 587         isLocalTime = true;</span>
<span class="line-added"> 588         return currentPosition;</span>
<span class="line-added"> 589     }</span>
 590     ++currentPosition;
 591 
<span class="line-modified"> 592     long tzHours = 0;</span>
<span class="line-modified"> 593     long tzHoursAbs = 0;</span>
<span class="line-modified"> 594     long tzMinutes = 0;</span>
 595 
 596     if (!isASCIIDigit(*currentPosition))
 597         return 0;
 598     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;tzHours))
 599         return 0;
<span class="line-modified"> 600     if (*postParsePosition != &#39;:&#39;) {</span>
<span class="line-modified"> 601         if ((postParsePosition - currentPosition) == 2) {</span>
<span class="line-modified"> 602             // &quot;00&quot; case.</span>
<span class="line-modified"> 603             tzHoursAbs = labs(tzHours);</span>
<span class="line-added"> 604         } else if ((postParsePosition - currentPosition) == 4) {</span>
<span class="line-added"> 605             // &quot;0000&quot; case.</span>
<span class="line-added"> 606             tzHoursAbs = labs(tzHours);</span>
<span class="line-added"> 607             tzMinutes = tzHoursAbs % 100;</span>
<span class="line-added"> 608             tzHoursAbs = tzHoursAbs / 100;</span>
<span class="line-added"> 609         } else</span>
<span class="line-added"> 610             return 0;</span>
<span class="line-added"> 611     } else {</span>
<span class="line-added"> 612         // &quot;00:00&quot; case.</span>
<span class="line-added"> 613         if ((postParsePosition - currentPosition) != 2)</span>
<span class="line-added"> 614             return 0;</span>
<span class="line-added"> 615         tzHoursAbs = labs(tzHours);</span>
<span class="line-added"> 616         currentPosition = postParsePosition + 1; // Skip &quot;:&quot;.</span>
 617 
<span class="line-modified"> 618         if (!isASCIIDigit(*currentPosition))</span>
<span class="line-modified"> 619             return 0;</span>
<span class="line-modified"> 620         if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;tzMinutes))</span>
<span class="line-modified"> 621             return 0;</span>
<span class="line-modified"> 622         if ((postParsePosition - currentPosition) != 2)</span>
<span class="line-modified"> 623             return 0;</span>
<span class="line-added"> 624     }</span>
 625     currentPosition = postParsePosition;
 626 
 627     if (tzHoursAbs &gt; 24)
 628         return 0;
 629     if (tzMinutes &lt; 0 || tzMinutes &gt; 59)
 630         return 0;
 631 
 632     timeZoneSeconds = 60 * (tzMinutes + (60 * tzHoursAbs));
 633     if (tzNegative)
 634         timeZoneSeconds = -timeZoneSeconds;
 635 
 636     return currentPosition;
 637 }
 638 
<span class="line-modified"> 639 double parseES5DateFromNullTerminatedCharacters(const char* dateString, bool&amp; isLocalTime)</span>
 640 {
<span class="line-added"> 641     isLocalTime = false;</span>
<span class="line-added"> 642 </span>
 643     // This parses a date of the form defined in ecma262/#sec-date-time-string-format
 644     // (similar to RFC 3339 / ISO 8601: YYYY-MM-DDTHH:mm:ss[.sss]Z).
 645     // In most cases it is intentionally strict (e.g. correct field widths, no stray whitespace).
 646 
 647     static const long daysPerMonth[12] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
 648 
 649     // The year must be present, but the other fields may be omitted - see ES5.1 15.9.1.15.
 650     int year = 0;
 651     long month = 1;
 652     long day = 1;
 653     long hours = 0;
 654     long minutes = 0;
 655     double seconds = 0;
 656     long timeZoneSeconds = 0;
 657 
 658     // Parse the date YYYY[-MM[-DD]]
 659     char* currentPosition = parseES5DatePortion(dateString, year, month, day);
 660     if (!currentPosition)
 661         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 662     // Look for a time portion.
<span class="line-added"> 663     // Note: As of ES2016, when a UTC offset is missing, date-time forms are local time while date-only forms are UTC.</span>
 664     if (*currentPosition == &#39;T&#39;) {
<span class="line-modified"> 665         // Parse the time HH:mm[:ss[.sss]][Z|(+|-)(00:00|0000|00)]</span>
<span class="line-modified"> 666         currentPosition = parseES5TimePortion(currentPosition + 1, hours, minutes, seconds, isLocalTime, timeZoneSeconds);</span>
 667         if (!currentPosition)
 668             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 669     }
 670     // Check that we have parsed all characters in the string.
 671     if (*currentPosition)
 672         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 673 
 674     // A few of these checks could be done inline above, but since many of them are interrelated
 675     // we would be sacrificing readability to &quot;optimize&quot; the (presumably less common) failure path.
 676     if (month &lt; 1 || month &gt; 12)
 677         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 678     if (day &lt; 1 || day &gt; daysPerMonth[month - 1])
 679         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 680     if (month == 2 &amp;&amp; day &gt; 28 &amp;&amp; !isLeapYear(year))
 681         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 682     if (hours &lt; 0 || hours &gt; 24)
 683         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 684     if (hours == 24 &amp;&amp; (minutes || seconds))
 685         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 686     if (minutes &lt; 0 || minutes &gt; 59)
 687         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 688     if (seconds &lt; 0 || seconds &gt;= 61)
 689         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 690     if (seconds &gt; 60) {
 691         // Discard leap seconds by clamping to the end of a minute.
 692         seconds = 60;
 693     }
 694 
 695     double dateSeconds = ymdhmsToSeconds(year, month, day, hours, minutes, seconds) - timeZoneSeconds;
 696     return dateSeconds * msPerSecond;
 697 }
 698 
 699 // Odd case where &#39;exec&#39; is allowed to be 0, to accomodate a caller in WebCore.
<span class="line-modified"> 700 double parseDateFromNullTerminatedCharacters(const char* dateString, bool&amp; isLocalTime)</span>
 701 {
<span class="line-modified"> 702     isLocalTime = true;</span>
<span class="line-modified"> 703     int offset = 0;</span>
 704 
 705     // This parses a date in the form:
 706     //     Tuesday, 09-Nov-99 23:12:40 GMT
 707     // or
 708     //     Sat, 01-Jan-2000 08:00:00 GMT
 709     // or
 710     //     Sat, 01 Jan 2000 08:00:00 GMT
 711     // or
 712     //     01 Jan 99 22:00 +0100    (exceptions in rfc822/rfc2822)
 713     // ### non RFC formats, added for Javascript:
 714     //     [Wednesday] January 09 1999 23:12:40 GMT
 715     //     [Wednesday] January 09 23:12:40 GMT 1999
 716     //
 717     // We ignore the weekday.
 718 
 719     // Skip leading space
 720     skipSpacesAndComments(dateString);
 721 
 722     long month = -1;
 723     const char *wordStart = dateString;
</pre>
<hr />
<pre>
 901                 skipSpacesAndComments(dateString);
 902             }
 903         }
 904     }
 905 
 906     // The year may be after the time but before the time zone.
 907     if (isASCIIDigit(*dateString) &amp;&amp; !year) {
 908         int result = 0;
 909         if (!parseInt(dateString, &amp;newPosStr, 10, &amp;result))
 910             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 911         year = result;
 912         dateString = newPosStr;
 913         skipSpacesAndComments(dateString);
 914     }
 915 
 916     // Don&#39;t fail if the time zone is missing.
 917     // Some websites omit the time zone (4275206).
 918     if (*dateString) {
 919         if (startsWithLettersIgnoringASCIICase(dateString, &quot;gmt&quot;) || startsWithLettersIgnoringASCIICase(dateString, &quot;utc&quot;)) {
 920             dateString += 3;
<span class="line-modified"> 921             isLocalTime = false;</span>
 922         }
 923 
 924         if (*dateString == &#39;+&#39; || *dateString == &#39;-&#39;) {
 925             int o;
 926             if (!parseInt(dateString, &amp;newPosStr, 10, &amp;o))
 927                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 928             dateString = newPosStr;
 929 
 930             if (o &lt; -9959 || o &gt; 9959)
 931                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 932 
 933             int sgn = (o &lt; 0) ? -1 : 1;
 934             o = abs(o);
 935             if (*dateString != &#39;:&#39;) {
 936                 if (o &gt;= 24)
 937                     offset = ((o / 100) * 60 + (o % 100)) * sgn;
 938                 else
 939                     offset = o * 60 * sgn;
 940             } else { // GMT+05:00
 941                 ++dateString; // skip the &#39;:&#39;
 942                 int o2;
 943                 if (!parseInt(dateString, &amp;newPosStr, 10, &amp;o2))
 944                     return std::numeric_limits&lt;double&gt;::quiet_NaN();
 945                 dateString = newPosStr;
 946                 offset = (o * 60 + o2) * sgn;
 947             }
<span class="line-modified"> 948             isLocalTime = false;</span>
 949         } else {
 950             for (auto&amp; knownZone : knownZones) {
 951                 // Since the passed-in length is used for both strings, the following checks that
 952                 // dateString has the time zone name as a prefix, not that it is equal.
 953                 auto length = strlen(knownZone.tzName);
 954                 if (equalLettersIgnoringASCIICase(dateString, knownZone.tzName, length)) {
 955                     offset = knownZone.tzOffset;
 956                     dateString += length;
<span class="line-modified"> 957                     isLocalTime = false;</span>
 958                     break;
 959                 }
 960             }
 961         }
 962     }
 963 
 964     skipSpacesAndComments(dateString);
 965 
 966     if (*dateString &amp;&amp; !year) {
 967         int result = 0;
 968         if (!parseInt(dateString, &amp;newPosStr, 10, &amp;result))
 969             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 970         year = result;
 971         dateString = newPosStr;
 972         skipSpacesAndComments(dateString);
 973     }
 974 
 975     // Trailing garbage
 976     if (*dateString)
 977         return std::numeric_limits&lt;double&gt;::quiet_NaN();
</pre>
<hr />
<pre>
 981         int yearValue = year.value();
 982         if (yearValue &gt;= 0 &amp;&amp; yearValue &lt; 100) {
 983             if (yearValue &lt; 50)
 984                 yearValue += 2000;
 985             else
 986                 yearValue += 1900;
 987         }
 988         year = yearValue;
 989     } else {
 990         // We select 2000 as default value. This is because of the following reasons.
 991         // 1. Year 2000 was used for the initial value of the variable `year`. While it won&#39;t be posed to users in WebKit,
 992         //    V8 used this 2000 as its default value. (As of April 2017, V8 is using the year 2001 and Spider Monkey is
 993         //    not doing this kind of fallback.)
 994         // 2. It is a leap year. When using `new Date(&quot;Feb 29&quot;)`, we assume that people want to save month and day.
 995         //    Leap year can save user inputs if they is valid. If we use the current year instead, the current year
 996         //    may not be a leap year. In that case, `new Date(&quot;Feb 29&quot;).getMonth()` becomes 2 (March).
 997         year = 2000;
 998     }
 999     ASSERT(year);
1000 
<span class="line-modified">1001     double dateSeconds = ymdhmsToSeconds(year.value(), month + 1, day, hour, minute, second) - offset * secondsPerMinute;</span>
<span class="line-added">1002     return dateSeconds * msPerSecond;</span>
1003 }
1004 
1005 double parseDateFromNullTerminatedCharacters(const char* dateString)
1006 {
<span class="line-modified">1007     bool isLocalTime;</span>
<span class="line-modified">1008     double value = parseDateFromNullTerminatedCharacters(dateString, isLocalTime);</span>







1009 
<span class="line-modified">1010     if (isLocalTime)</span>
<span class="line-modified">1011         value -= calculateLocalTimeOffset(value, LocalTime).offset;</span>
1012 
<span class="line-modified">1013     return value;</span>




1014 }
1015 
1016 // See http://tools.ietf.org/html/rfc2822#section-3.3 for more information.
1017 String makeRFC2822DateString(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset)
1018 {
1019     StringBuilder stringBuilder;
1020     stringBuilder.append(weekdayName[dayOfWeek], &quot;, &quot;, day, &#39; &#39;, monthName[month], &#39; &#39;, year, &#39; &#39;);
1021 
1022     appendTwoDigitNumber(stringBuilder, hours);
1023     stringBuilder.append(&#39;:&#39;);
1024     appendTwoDigitNumber(stringBuilder, minutes);
1025     stringBuilder.append(&#39;:&#39;);
1026     appendTwoDigitNumber(stringBuilder, seconds);
1027     stringBuilder.append(&#39; &#39;);
1028 
1029     stringBuilder.append(utcOffset &gt; 0 ? &#39;+&#39; : &#39;-&#39;);
1030     int absoluteUTCOffset = abs(utcOffset);
1031     appendTwoDigitNumber(stringBuilder, absoluteUTCOffset / 60);
1032     appendTwoDigitNumber(stringBuilder, absoluteUTCOffset % 60);
1033 
</pre>
</td>
</tr>
</table>
<center><a href="DataLog.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DateMath.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedTypes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CachedBytecode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallData.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedTypes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,11 ***</span>
  
  #include &quot;config.h&quot;
  #include &quot;CachedTypes.h&quot;
  
  #include &quot;BytecodeCacheError.h&quot;
<span class="line-removed">- #include &quot;BytecodeCacheVersion.h&quot;</span>
  #include &quot;BytecodeLivenessAnalysis.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSTemplateObjectDescriptor.h&quot;
  #include &quot;ScopedArgumentsTable.h&quot;
<span class="line-new-header">--- 25,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 39,11 ***</span>
<span class="line-new-header">--- 38,13 ---</span>
  #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  #include &quot;UnlinkedMetadataTableInlines.h&quot;
  #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  #include &quot;UnlinkedProgramCodeBlock.h&quot;
  #include &lt;wtf/FastMalloc.h&gt;
<span class="line-added">+ #include &lt;wtf/MallocPtr.h&gt;</span>
  #include &lt;wtf/Optional.h&gt;
<span class="line-added">+ #include &lt;wtf/Packed.h&gt;</span>
  #include &lt;wtf/UUID.h&gt;
  #include &lt;wtf/text/AtomStringImpl.h&gt;
  
  namespace JSC {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,10 ***</span>
<span class="line-new-header">--- 64,15 ---</span>
  };
  
  template&lt;typename T&gt;
  using SourceType = typename SourceTypeImpl&lt;T&gt;::type;
  
<span class="line-added">+ static constexpr unsigned jscBytecodeCacheVersion()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return StringHasher::computeHash(__TIMESTAMP__);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class Encoder {
      WTF_MAKE_NONCOPYABLE(Encoder);
      WTF_FORBID_HEAP_ALLOCATION;
  
  public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,11 ***</span>
          if (FileSystem::isHandleValid(m_fd)) {
              return releaseMapped(error);
          }
  
          size_t size = m_baseOffset + m_currentPage-&gt;size();
<span class="line-modified">!         MallocPtr&lt;uint8_t&gt; buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);</span>
          unsigned offset = 0;
          for (const auto&amp; page : m_pages) {
              memcpy(buffer.get() + offset, page.buffer(), page.size());
              offset += page.size();
          }
<span class="line-new-header">--- 161,11 ---</span>
          if (FileSystem::isHandleValid(m_fd)) {
              return releaseMapped(error);
          }
  
          size_t size = m_baseOffset + m_currentPage-&gt;size();
<span class="line-modified">!         MallocPtr&lt;uint8_t, VMMalloc&gt; buffer = MallocPtr&lt;uint8_t, VMMalloc&gt;::malloc(size);</span>
          unsigned offset = 0;
          for (const auto&amp; page : m_pages) {
              memcpy(buffer.get() + offset, page.buffer(), page.size());
              offset += page.size();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 200,14 ***</span>
      }
  
      class Page {
      public:
          Page(size_t size)
<span class="line-modified">!             : m_offset(0)</span>
              , m_capacity(size)
          {
<span class="line-removed">-             m_buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);</span>
          }
  
          bool malloc(size_t size, ptrdiff_t&amp; result)
          {
              size_t alignment = std::min(alignof(std::max_align_t), static_cast&lt;size_t&gt;(WTF::roundUpToPowerOfTwo(size)));
<span class="line-new-header">--- 206,13 ---</span>
      }
  
      class Page {
      public:
          Page(size_t size)
<span class="line-modified">!             : m_buffer(MallocPtr&lt;uint8_t, VMMalloc&gt;::malloc(size))</span>
              , m_capacity(size)
          {
          }
  
          bool malloc(size_t size, ptrdiff_t&amp; result)
          {
              size_t alignment = std::min(alignof(std::max_align_t), static_cast&lt;size_t&gt;(WTF::roundUpToPowerOfTwo(size)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 242,12 ***</span>
              RELEASE_ASSERT(static_cast&lt;size_t&gt;(size) &lt;= m_capacity);
              m_offset = size;
          }
  
      private:
<span class="line-modified">!         MallocPtr&lt;uint8_t&gt; m_buffer;</span>
<span class="line-modified">!         ptrdiff_t m_offset;</span>
          size_t m_capacity;
      };
  
      void allocateNewPage(size_t size = 0)
      {
<span class="line-new-header">--- 247,12 ---</span>
              RELEASE_ASSERT(static_cast&lt;size_t&gt;(size) &lt;= m_capacity);
              m_offset = size;
          }
  
      private:
<span class="line-modified">!         MallocPtr&lt;uint8_t, VMMalloc&gt; m_buffer;</span>
<span class="line-modified">!         ptrdiff_t m_offset { 0 };</span>
          size_t m_capacity;
      };
  
      void allocateNewPage(size_t size = 0)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 463,11 ***</span>
      constexpr static ptrdiff_t s_invalidOffset = std::numeric_limits&lt;ptrdiff_t&gt;::max();
  };
  
  template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
  class CachedPtr : public VariableLengthObject&lt;Source*&gt; {
<span class="line-modified">!     template&lt;typename, typename&gt;</span>
      friend class CachedRefPtr;
  
      friend struct CachedPtrOffsets;
  
  public:
<span class="line-new-header">--- 468,11 ---</span>
      constexpr static ptrdiff_t s_invalidOffset = std::numeric_limits&lt;ptrdiff_t&gt;::max();
  };
  
  template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
  class CachedPtr : public VariableLengthObject&lt;Source*&gt; {
<span class="line-modified">!     template&lt;typename, typename, typename&gt;</span>
      friend class CachedRefPtr;
  
      friend struct CachedPtrOffsets;
  
  public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 526,24 ***</span>
  ptrdiff_t CachedPtrOffsets::offsetOffset()
  {
      return OBJECT_OFFSETOF(CachedPtr&lt;void&gt;, m_offset);
  }
  
<span class="line-modified">! template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;</span>
<span class="line-modified">! class CachedRefPtr : public CachedObject&lt;RefPtr&lt;Source&gt;&gt; {</span>
  public:
      void encode(Encoder&amp; encoder, const Source* src)
      {
          m_ptr.encode(encoder, src);
      }
  
<span class="line-modified">!     void encode(Encoder&amp; encoder, const RefPtr&lt;Source&gt; src)</span>
      {
          encode(encoder, src.get());
      }
  
<span class="line-modified">!     RefPtr&lt;Source&gt; decode(Decoder&amp; decoder) const</span>
      {
          bool isNewAllocation;
          Source* decodedPtr = m_ptr.decode(decoder, isNewAllocation);
          if (!decodedPtr)
              return nullptr;
<span class="line-new-header">--- 531,24 ---</span>
  ptrdiff_t CachedPtrOffsets::offsetOffset()
  {
      return OBJECT_OFFSETOF(CachedPtr&lt;void&gt;, m_offset);
  }
  
<span class="line-modified">! template&lt;typename T, typename Source = SourceType&lt;T&gt;, typename PtrTraits = DumbPtrTraits&lt;Source&gt;&gt;</span>
<span class="line-modified">! class CachedRefPtr : public CachedObject&lt;RefPtr&lt;Source, PtrTraits&gt;&gt; {</span>
  public:
      void encode(Encoder&amp; encoder, const Source* src)
      {
          m_ptr.encode(encoder, src);
      }
  
<span class="line-modified">!     void encode(Encoder&amp; encoder, const RefPtr&lt;Source, PtrTraits&gt; src)</span>
      {
          encode(encoder, src.get());
      }
  
<span class="line-modified">!     RefPtr&lt;Source, PtrTraits&gt; decode(Decoder&amp; decoder) const</span>
      {
          bool isNewAllocation;
          Source* decodedPtr = m_ptr.decode(decoder, isNewAllocation);
          if (!decodedPtr)
              return nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 554,11 ***</span>
          }
          refIfNotNull(decodedPtr);
          return adoptRef(decodedPtr);
      }
  
<span class="line-modified">!     void decode(Decoder&amp; decoder, RefPtr&lt;Source&gt;&amp; src) const</span>
      {
          src = decode(decoder);
      }
  
  private:
<span class="line-new-header">--- 559,11 ---</span>
          }
          refIfNotNull(decodedPtr);
          return adoptRef(decodedPtr);
      }
  
<span class="line-modified">!     void decode(Decoder&amp; decoder, RefPtr&lt;Source, PtrTraits&gt;&amp; src) const</span>
      {
          src = decode(decoder);
      }
  
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 591,34 ***</span>
  ptrdiff_t CachedWriteBarrierOffsets::ptrOffset()
  {
      return OBJECT_OFFSETOF(CachedWriteBarrier&lt;void&gt;, m_ptr);
  }
  
<span class="line-modified">! template&lt;typename T, size_t InlineCapacity = 0, typename OverflowHandler = CrashOnOverflow&gt;</span>
<span class="line-modified">! class CachedVector : public VariableLengthObject&lt;Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&gt; {</span>
  public:
<span class="line-modified">!     void encode(Encoder&amp; encoder, const Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector)</span>
      {
          m_size = vector.size();
          if (!m_size)
              return;
          T* buffer = this-&gt;template allocate&lt;T&gt;(encoder, m_size);
          for (unsigned i = 0; i &lt; m_size; ++i)
              ::JSC::encode(encoder, buffer[i], vector[i]);
      }
  
      template&lt;typename... Args&gt;
<span class="line-modified">!     void decode(Decoder&amp; decoder, Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector, Args... args) const</span>
      {
          if (!m_size)
              return;
          vector.resizeToFit(m_size);
          const T* buffer = this-&gt;template buffer&lt;T&gt;();
          for (unsigned i = 0; i &lt; m_size; ++i)
              ::JSC::decode(decoder, buffer[i], vector[i], args...);
      }
  
  private:
      unsigned m_size;
  };
  
  template&lt;typename First, typename Second&gt;
<span class="line-new-header">--- 596,56 ---</span>
  ptrdiff_t CachedWriteBarrierOffsets::ptrOffset()
  {
      return OBJECT_OFFSETOF(CachedWriteBarrier&lt;void&gt;, m_ptr);
  }
  
<span class="line-modified">! template&lt;typename T, size_t InlineCapacity = 0, typename OverflowHandler = CrashOnOverflow, typename Malloc = WTF::VectorMalloc&gt;</span>
<span class="line-modified">! class CachedVector : public VariableLengthObject&lt;Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler, 16, Malloc&gt;&gt; {</span>
  public:
<span class="line-modified">!     void encode(Encoder&amp; encoder, const Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler, 16, Malloc&gt;&amp; vector)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         m_size = vector.size();</span>
<span class="line-added">+         if (!m_size)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         T* buffer = this-&gt;template allocate&lt;T&gt;(encoder, m_size);</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; m_size; ++i)</span>
<span class="line-added">+             ::JSC::encode(encoder, buffer[i], vector[i]);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void encode(Encoder&amp; encoder, const RefCountedArray&lt;SourceType&lt;T&gt;&gt;&amp; vector)</span>
      {
          m_size = vector.size();
          if (!m_size)
              return;
          T* buffer = this-&gt;template allocate&lt;T&gt;(encoder, m_size);
          for (unsigned i = 0; i &lt; m_size; ++i)
              ::JSC::encode(encoder, buffer[i], vector[i]);
      }
  
      template&lt;typename... Args&gt;
<span class="line-modified">!     void decode(Decoder&amp; decoder, Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler, 16, Malloc&gt;&amp; vector, Args... args) const</span>
      {
          if (!m_size)
              return;
          vector.resizeToFit(m_size);
          const T* buffer = this-&gt;template buffer&lt;T&gt;();
          for (unsigned i = 0; i &lt; m_size; ++i)
              ::JSC::decode(decoder, buffer[i], vector[i], args...);
      }
  
<span class="line-added">+     template&lt;typename... Args&gt;</span>
<span class="line-added">+     void decode(Decoder&amp; decoder, RefCountedArray&lt;SourceType&lt;T&gt;&gt;&amp; vector, Args... args) const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (!m_size)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         vector = RefCountedArray&lt;SourceType&lt;T&gt;&gt;(m_size);</span>
<span class="line-added">+         const T* buffer = this-&gt;template buffer&lt;T&gt;();</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; m_size; ++i)</span>
<span class="line-added">+             ::JSC::decode(decoder, buffer[i], vector[i], args...);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  private:
      unsigned m_size;
  };
  
  template&lt;typename First, typename Second&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 931,10 ***</span>
<span class="line-new-header">--- 958,11 ---</span>
          m_expressionInfoFatPositions.encode(encoder, rareData.m_expressionInfoFatPositions);
          m_typeProfilerInfoMap.encode(encoder, rareData.m_typeProfilerInfoMap);
          m_opProfileControlFlowBytecodeOffsets.encode(encoder, rareData.m_opProfileControlFlowBytecodeOffsets);
          m_bitVectors.encode(encoder, rareData.m_bitVectors);
          m_constantIdentifierSets.encode(encoder, rareData.m_constantIdentifierSets);
<span class="line-added">+         m_needsClassFieldInitializer = rareData.m_needsClassFieldInitializer;</span>
      }
  
      UnlinkedCodeBlock::RareData* decode(Decoder&amp; decoder) const
      {
          UnlinkedCodeBlock::RareData* rareData = new UnlinkedCodeBlock::RareData { };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 944,10 ***</span>
<span class="line-new-header">--- 972,11 ---</span>
          m_expressionInfoFatPositions.decode(decoder, rareData-&gt;m_expressionInfoFatPositions);
          m_typeProfilerInfoMap.decode(decoder, rareData-&gt;m_typeProfilerInfoMap);
          m_opProfileControlFlowBytecodeOffsets.decode(decoder, rareData-&gt;m_opProfileControlFlowBytecodeOffsets);
          m_bitVectors.decode(decoder, rareData-&gt;m_bitVectors);
          m_constantIdentifierSets.decode(decoder, rareData-&gt;m_constantIdentifierSets);
<span class="line-added">+         rareData-&gt;m_needsClassFieldInitializer = m_needsClassFieldInitializer;</span>
          return rareData;
      }
  
  private:
      CachedVector&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 956,10 ***</span>
<span class="line-new-header">--- 985,11 ---</span>
      CachedVector&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;
      CachedHashMap&lt;unsigned, UnlinkedCodeBlock::RareData::TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
      CachedVector&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;
      CachedVector&lt;CachedBitVector&gt; m_bitVectors;
      CachedVector&lt;CachedConstantIdentifierSetEntry&gt; m_constantIdentifierSets;
<span class="line-added">+     unsigned m_needsClassFieldInitializer : 1;</span>
  };
  
  class CachedVariableEnvironment : public CachedObject&lt;VariableEnvironment&gt; {
  public:
      void encode(Encoder&amp; encoder, const VariableEnvironment&amp; env)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 974,11 ***</span>
          m_map.decode(decoder, env.m_map);
      }
  
  private:
      bool m_isEverythingCaptured;
<span class="line-modified">!     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, VariableEnvironmentEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntryHashTraits&gt; m_map;</span>
  };
  
  class CachedCompactVariableEnvironment : public CachedObject&lt;CompactVariableEnvironment&gt; {
  public:
      void encode(Encoder&amp; encoder, const CompactVariableEnvironment&amp; env)
<span class="line-new-header">--- 1004,11 ---</span>
          m_map.decode(decoder, env.m_map);
      }
  
  private:
      bool m_isEverythingCaptured;
<span class="line-modified">!     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl, UniquedStringImpl, WTF::PackedPtrTraits&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntryHashTraits&gt; m_map;</span>
  };
  
  class CachedCompactVariableEnvironment : public CachedObject&lt;CompactVariableEnvironment&gt; {
  public:
      void encode(Encoder&amp; encoder, const CompactVariableEnvironment&amp; env)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1003,11 ***</span>
          decode(decoder, *env);
          return env;
      }
  
  private:
<span class="line-modified">!     CachedVector&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;&gt; m_variables;</span>
      CachedVector&lt;VariableEnvironmentEntry&gt; m_variableMetadata;
      unsigned m_hash;
      bool m_isEverythingCaptured;
  };
  
<span class="line-new-header">--- 1033,11 ---</span>
          decode(decoder, *env);
          return env;
      }
  
  private:
<span class="line-modified">!     CachedVector&lt;CachedRefPtr&lt;CachedUniquedStringImpl, UniquedStringImpl, WTF::PackedPtrTraits&lt;UniquedStringImpl&gt;&gt;&gt; m_variables;</span>
      CachedVector&lt;VariableEnvironmentEntry&gt; m_variableMetadata;
      unsigned m_hash;
      bool m_isEverythingCaptured;
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1356,17 ***</span>
          m_instructions.encode(encoder, stream.m_instructions);
      }
  
      InstructionStream* decode(Decoder&amp; decoder) const
      {
<span class="line-modified">!         Vector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; instructionsVector;</span>
          m_instructions.decode(decoder, instructionsVector);
          return new InstructionStream(WTFMove(instructionsVector));
      }
  
  private:
<span class="line-modified">!     CachedVector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; m_instructions;</span>
  };
  
  class CachedMetadataTable : public CachedObject&lt;UnlinkedMetadataTable&gt; {
  public:
      void encode(Encoder&amp;, const UnlinkedMetadataTable&amp; metadataTable)
<span class="line-new-header">--- 1386,17 ---</span>
          m_instructions.encode(encoder, stream.m_instructions);
      }
  
      InstructionStream* decode(Decoder&amp; decoder) const
      {
<span class="line-modified">!         Vector&lt;uint8_t, 0, UnsafeVectorOverflow, 16, InstructionStreamMalloc&gt; instructionsVector;</span>
          m_instructions.decode(decoder, instructionsVector);
          return new InstructionStream(WTFMove(instructionsVector));
      }
  
  private:
<span class="line-modified">!     CachedVector&lt;uint8_t, 0, UnsafeVectorOverflow, InstructionStreamMalloc&gt; m_instructions;</span>
  };
  
  class CachedMetadataTable : public CachedObject&lt;UnlinkedMetadataTable&gt; {
  public:
      void encode(Encoder&amp;, const UnlinkedMetadataTable&amp; metadataTable)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1695,10 ***</span>
<span class="line-new-header">--- 1725,11 ---</span>
      unsigned constructorKind() const { return m_constructorKind; }
      unsigned functionMode() const { return m_functionMode; }
      unsigned scriptMode() const { return m_scriptMode; }
      unsigned superBinding() const { return m_superBinding; }
      unsigned derivedContextType() const { return m_derivedContextType; }
<span class="line-added">+     unsigned needsClassFieldInitializer() const { return m_needsClassFieldInitializer; }</span>
  
      Identifier name(Decoder&amp; decoder) const { return m_name.decode(decoder); }
      Identifier ecmaName(Decoder&amp; decoder) const { return m_ecmaName.decode(decoder); }
  
      UnlinkedFunctionExecutable::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1728,10 ***</span>
<span class="line-new-header">--- 1759,11 ---</span>
      unsigned m_parameterCount;
      SourceParseMode m_sourceParseMode;
      unsigned m_constructorKind : 2;
      unsigned m_functionMode : 2; // FunctionMode
      unsigned m_derivedContextType: 2;
<span class="line-added">+     unsigned m_needsClassFieldInitializer : 1;</span>
  
      CachedPtr&lt;CachedFunctionExecutableRareData&gt; m_rareData;
  
      CachedIdentifier m_name;
      CachedIdentifier m_ecmaName;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1764,12 ***</span>
      InstructionStream* instructions(Decoder&amp; decoder) const { return m_instructions.decode(decoder); }
  
      VirtualRegister thisRegister() const { return m_thisRegister; }
      VirtualRegister scopeRegister() const { return m_scopeRegister; }
  
<span class="line-modified">!     String sourceURLDirective(Decoder&amp; decoder) const { return m_sourceURLDirective.decode(decoder); }</span>
<span class="line-modified">!     String sourceMappingURLDirective(Decoder&amp; decoder) const { return m_sourceMappingURLDirective.decode(decoder); }</span>
  
      Ref&lt;UnlinkedMetadataTable&gt; metadata(Decoder&amp; decoder) const { return m_metadata.decode(decoder); }
  
      unsigned usesEval() const { return m_usesEval; }
      unsigned isStrictMode() const { return m_isStrictMode; }
<span class="line-new-header">--- 1796,12 ---</span>
      InstructionStream* instructions(Decoder&amp; decoder) const { return m_instructions.decode(decoder); }
  
      VirtualRegister thisRegister() const { return m_thisRegister; }
      VirtualRegister scopeRegister() const { return m_scopeRegister; }
  
<span class="line-modified">!     RefPtr&lt;StringImpl&gt; sourceURLDirective(Decoder&amp; decoder) const { return m_sourceURLDirective.decode(decoder); }</span>
<span class="line-modified">!     RefPtr&lt;StringImpl&gt; sourceMappingURLDirective(Decoder&amp; decoder) const { return m_sourceMappingURLDirective.decode(decoder); }</span>
  
      Ref&lt;UnlinkedMetadataTable&gt; metadata(Decoder&amp; decoder) const { return m_metadata.decode(decoder); }
  
      unsigned usesEval() const { return m_usesEval; }
      unsigned isStrictMode() const { return m_isStrictMode; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1780,12 ***</span>
<span class="line-new-header">--- 1812,14 ---</span>
      unsigned scriptMode() const { return m_scriptMode; }
      unsigned isArrowFunctionContext() const { return m_isArrowFunctionContext; }
      unsigned isClassContext() const { return m_isClassContext; }
      unsigned constructorKind() const { return m_constructorKind; }
      unsigned derivedContextType() const { return m_derivedContextType; }
<span class="line-added">+     unsigned needsClassFieldInitializer() const { return m_needsClassFieldInitializer; }</span>
      unsigned evalContextType() const { return m_evalContextType; }
      unsigned hasTailCalls() const { return m_hasTailCalls; }
<span class="line-added">+     unsigned hasCheckpoints() const { return m_hasCheckpoints; }</span>
      unsigned lineCount() const { return m_lineCount; }
      unsigned endColumn() const { return m_endColumn; }
  
      int numVars() const { return m_numVars; }
      int numCalleeLocals() const { return m_numCalleeLocals; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1799,11 ***</span>
      UnlinkedCodeBlock::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }
  
  private:
      VirtualRegister m_thisRegister;
      VirtualRegister m_scopeRegister;
<span class="line-removed">-     std::array&lt;unsigned, LinkTimeConstantCount&gt; m_linkTimeConstants;</span>
  
      unsigned m_usesEval : 1;
      unsigned m_isStrictMode : 1;
      unsigned m_isConstructor : 1;
      unsigned m_hasCapturedVariables : 1;
<span class="line-new-header">--- 1833,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1812,13 ***</span>
<span class="line-new-header">--- 1845,15 ---</span>
      unsigned m_scriptMode: 1;
      unsigned m_isArrowFunctionContext : 1;
      unsigned m_isClassContext : 1;
      unsigned m_constructorKind : 2;
      unsigned m_derivedContextType : 2;
<span class="line-added">+     unsigned m_needsClassFieldInitializer : 1;</span>
      unsigned m_evalContextType : 2;
      unsigned m_hasTailCalls : 1;
      unsigned m_codeType : 2;
<span class="line-added">+     unsigned m_hasCheckpoints : 1;</span>
  
      CodeFeatures m_features;
      SourceParseMode m_parseMode;
      OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1831,16 ***</span>
  
      CachedMetadataTable m_metadata;
  
      CachedPtr&lt;CachedCodeBlockRareData&gt; m_rareData;
  
<span class="line-modified">!     CachedString m_sourceURLDirective;</span>
<span class="line-modified">!     CachedString m_sourceMappingURLDirective;</span>
  
      CachedPtr&lt;CachedInstructionStream&gt; m_instructions;
      CachedVector&lt;InstructionStream::Offset&gt; m_jumpTargets;
<span class="line-removed">-     CachedVector&lt;InstructionStream::Offset&gt; m_propertyAccessInstructions;</span>
      CachedVector&lt;CachedJSValue&gt; m_constantRegisters;
      CachedVector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;
      CachedVector&lt;ExpressionRangeInfo&gt; m_expressionInfo;
      CachedHashMap&lt;InstructionStream::Offset, int&gt; m_outOfLineJumpTargets;
  
<span class="line-new-header">--- 1866,15 ---</span>
  
      CachedMetadataTable m_metadata;
  
      CachedPtr&lt;CachedCodeBlockRareData&gt; m_rareData;
  
<span class="line-modified">!     CachedRefPtr&lt;CachedStringImpl&gt; m_sourceURLDirective;</span>
<span class="line-modified">!     CachedRefPtr&lt;CachedStringImpl&gt; m_sourceMappingURLDirective;</span>
  
      CachedPtr&lt;CachedInstructionStream&gt; m_instructions;
      CachedVector&lt;InstructionStream::Offset&gt; m_jumpTargets;
      CachedVector&lt;CachedJSValue&gt; m_constantRegisters;
      CachedVector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;
      CachedVector&lt;ExpressionRangeInfo&gt; m_expressionInfo;
      CachedHashMap&lt;InstructionStream::Offset, int&gt; m_outOfLineJumpTargets;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2014,10 ***</span>
<span class="line-new-header">--- 2048,11 ---</span>
      , m_evalContextType(cachedCodeBlock.evalContextType())
      , m_codeType(cachedCodeBlock.codeType())
  
      , m_didOptimize(static_cast&lt;unsigned&gt;(MixedTriState))
      , m_age(0)
<span class="line-added">+     , m_hasCheckpoints(cachedCodeBlock.hasCheckpoints())</span>
  
      , m_features(cachedCodeBlock.features())
      , m_parseMode(cachedCodeBlock.parseMode())
      , m_codeGenerationMode(cachedCodeBlock.codeGenerationMode())
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2038,14 ***</span>
  }
  
  template&lt;typename CodeBlockType&gt;
  ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::decode(Decoder&amp; decoder, UnlinkedCodeBlock&amp; codeBlock) const
  {
<span class="line-removed">-     for (unsigned i = LinkTimeConstantCount; i--;)</span>
<span class="line-removed">-         codeBlock.m_linkTimeConstants[i] = m_linkTimeConstants[i];</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_propertyAccessInstructions.decode(decoder, codeBlock.m_propertyAccessInstructions);</span>
      m_constantRegisters.decode(decoder, codeBlock.m_constantRegisters, &amp;codeBlock);
      m_constantsSourceCodeRepresentation.decode(decoder, codeBlock.m_constantsSourceCodeRepresentation);
      m_expressionInfo.decode(decoder, codeBlock.m_expressionInfo);
      m_outOfLineJumpTargets.decode(decoder, codeBlock.m_outOfLineJumpTargets);
      m_jumpTargets.decode(decoder, codeBlock.m_jumpTargets);
<span class="line-new-header">--- 2073,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2095,10 ***</span>
<span class="line-new-header">--- 2126,11 ---</span>
      m_constructorKind = executable.m_constructorKind;
      m_functionMode = executable.m_functionMode;
      m_scriptMode = executable.m_scriptMode;
      m_superBinding = executable.m_superBinding;
      m_derivedContextType = executable.m_derivedContextType;
<span class="line-added">+     m_needsClassFieldInitializer = executable.m_needsClassFieldInitializer;</span>
  
      m_rareData.encode(encoder, executable.m_rareData.get());
  
      m_name.encode(encoder, executable.name());
      m_ecmaName.encode(encoder, executable.ecmaName());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2142,10 ***</span>
<span class="line-new-header">--- 2174,11 ---</span>
      , m_sourceParseMode(cachedExecutable.sourceParseMode())
      , m_constructorKind(cachedExecutable.constructorKind())
      , m_functionMode(cachedExecutable.functionMode())
      , m_derivedContextType(cachedExecutable.derivedContextType())
      , m_isGeneratedFromCache(true)
<span class="line-added">+     , m_needsClassFieldInitializer(cachedExecutable.needsClassFieldInitializer())</span>
      , m_unlinkedCodeBlockForCall()
      , m_unlinkedCodeBlockForConstruct()
  
      , m_name(cachedExecutable.name(decoder))
      , m_ecmaName(cachedExecutable.ecmaName(decoder))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2206,22 ***</span>
      m_numParameters = codeBlock.m_numParameters;
      m_features = codeBlock.m_features;
      m_parseMode = codeBlock.m_parseMode;
      m_codeGenerationMode = codeBlock.m_codeGenerationMode;
      m_codeType = codeBlock.m_codeType;
<span class="line-modified">! </span>
<span class="line-removed">-     for (unsigned i = LinkTimeConstantCount; i--;)</span>
<span class="line-removed">-         m_linkTimeConstants[i] = codeBlock.m_linkTimeConstants[i];</span>
  
      m_metadata.encode(encoder, codeBlock.m_metadata.get());
      m_rareData.encode(encoder, codeBlock.m_rareData.get());
  
<span class="line-modified">!     m_sourceURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());</span>
<span class="line-modified">!     m_sourceMappingURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());</span>
  
      m_instructions.encode(encoder, codeBlock.m_instructions.get());
<span class="line-removed">-     m_propertyAccessInstructions.encode(encoder, codeBlock.m_propertyAccessInstructions);</span>
      m_constantRegisters.encode(encoder, codeBlock.m_constantRegisters);
      m_constantsSourceCodeRepresentation.encode(encoder, codeBlock.m_constantsSourceCodeRepresentation);
      m_expressionInfo.encode(encoder, codeBlock.m_expressionInfo);
      m_jumpTargets.encode(encoder, codeBlock.m_jumpTargets);
      m_outOfLineJumpTargets.encode(encoder, codeBlock.m_outOfLineJumpTargets);
<span class="line-new-header">--- 2239,19 ---</span>
      m_numParameters = codeBlock.m_numParameters;
      m_features = codeBlock.m_features;
      m_parseMode = codeBlock.m_parseMode;
      m_codeGenerationMode = codeBlock.m_codeGenerationMode;
      m_codeType = codeBlock.m_codeType;
<span class="line-modified">!     m_hasCheckpoints = codeBlock.m_hasCheckpoints;</span>
  
      m_metadata.encode(encoder, codeBlock.m_metadata.get());
      m_rareData.encode(encoder, codeBlock.m_rareData.get());
  
<span class="line-modified">!     m_sourceURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.get());</span>
<span class="line-modified">!     m_sourceMappingURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.get());</span>
  
      m_instructions.encode(encoder, codeBlock.m_instructions.get());
      m_constantRegisters.encode(encoder, codeBlock.m_constantRegisters);
      m_constantsSourceCodeRepresentation.encode(encoder, codeBlock.m_constantsSourceCodeRepresentation);
      m_expressionInfo.encode(encoder, codeBlock.m_expressionInfo);
      m_jumpTargets.encode(encoder, codeBlock.m_jumpTargets);
      m_outOfLineJumpTargets.encode(encoder, codeBlock.m_outOfLineJumpTargets);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2273,19 ***</span>
  
      CachedCodeBlockTag tag() const { return m_tag; }
  
      bool isUpToDate(Decoder&amp; decoder) const
      {
<span class="line-modified">!         if (m_cacheVersion != JSC_BYTECODE_CACHE_VERSION)</span>
              return false;
          if (m_bootSessionUUID.decode(decoder) != bootSessionUUIDString())
              return false;
          return true;
      }
  
  private:
<span class="line-modified">!     uint32_t m_cacheVersion { JSC_BYTECODE_CACHE_VERSION };</span>
      CachedString m_bootSessionUUID;
      CachedCodeBlockTag m_tag;
  };
  
  template&lt;typename UnlinkedCodeBlockType&gt;
<span class="line-new-header">--- 2303,19 ---</span>
  
      CachedCodeBlockTag tag() const { return m_tag; }
  
      bool isUpToDate(Decoder&amp; decoder) const
      {
<span class="line-modified">!         if (m_cacheVersion != jscBytecodeCacheVersion())</span>
              return false;
          if (m_bootSessionUUID.decode(decoder) != bootSessionUUIDString())
              return false;
          return true;
      }
  
  private:
<span class="line-modified">!     uint32_t m_cacheVersion { jscBytecodeCacheVersion() };</span>
      CachedString m_bootSessionUUID;
      CachedCodeBlockTag m_tag;
  };
  
  template&lt;typename UnlinkedCodeBlockType&gt;
</pre>
<center><a href="CachedBytecode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallData.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.h
@@ -30,14 +30,14 @@
 #include <wtf/ASCIICType.h>
 #include <wtf/Vector.h>
 
 namespace JSC {
 
-enum LexerFlags {
-    LexerFlagsIgnoreReservedWords = 1,
-    LexerFlagsDontBuildStrings = 2,
-    LexexFlagsDontBuildKeywords = 4
+enum class LexerFlags : uint8_t {
+    IgnoreReservedWords = 1 << 0,
+    DontBuildStrings = 1 << 1,
+    DontBuildKeywords = 1 << 2
 };
 
 enum class LexerEscapeParseMode { Template, String };
 
 struct ParsedUnicodeEscapeValue;
@@ -62,12 +62,12 @@
     // Functions to set up parsing.
     void setCode(const SourceCode&, ParserArena*);
     void setIsReparsingFunction() { m_isReparsingFunction = true; }
     bool isReparsingFunction() const { return m_isReparsingFunction; }
 
-    JSTokenType lex(JSToken*, unsigned, bool strictMode);
-    JSTokenType lexWithoutClearingLineTerminator(JSToken*, unsigned, bool strictMode);
+    JSTokenType lex(JSToken*, OptionSet<LexerFlags>, bool strictMode);
+    JSTokenType lexWithoutClearingLineTerminator(JSToken*, OptionSet<LexerFlags>, bool strictMode);
     bool nextTokenIsColon();
     int lineNumber() const { return m_lineNumber; }
     ALWAYS_INLINE int currentOffset() const { return offsetFromSourcePtr(m_code); }
     ALWAYS_INLINE int currentLineStartOffset() const { return offsetFromSourcePtr(m_lineStart); }
     ALWAYS_INLINE JSTextPosition currentPosition() const
@@ -107,18 +107,19 @@
         else
             m_current = 0;
     }
     void setLineNumber(int line)
     {
+        ASSERT(line >= 0);
         m_lineNumber = line;
     }
     void setHasLineTerminatorBeforeToken(bool terminator)
     {
         m_hasLineTerminatorBeforeToken = terminator;
     }
 
-    JSTokenType lexExpectIdentifier(JSToken*, unsigned, bool strictMode);
+    JSTokenType lexExpectIdentifier(JSToken*, OptionSet<LexerFlags>, bool strictMode);
 
     ALWAYS_INLINE StringView getToken(const JSToken& token)
     {
         SourceProvider* sourceProvider = m_source->provider();
         ASSERT_WITH_MESSAGE(token.m_location.startOffset <= token.m_location.endOffset, "Calling this function with the baked token.");
@@ -162,12 +163,12 @@
 
     ALWAYS_INLINE void skipWhitespace();
 
     template <int shiftAmount> void internalShift();
     template <bool shouldCreateIdentifier> ALWAYS_INLINE JSTokenType parseKeyword(JSTokenData*);
-    template <bool shouldBuildIdentifiers> ALWAYS_INLINE JSTokenType parseIdentifier(JSTokenData*, unsigned lexerFlags, bool strictMode);
-    template <bool shouldBuildIdentifiers> NEVER_INLINE JSTokenType parseIdentifierSlowCase(JSTokenData*, unsigned lexerFlags, bool strictMode);
+    template <bool shouldBuildIdentifiers> ALWAYS_INLINE JSTokenType parseIdentifier(JSTokenData*, OptionSet<LexerFlags>, bool strictMode);
+    template <bool shouldBuildIdentifiers> NEVER_INLINE JSTokenType parseIdentifierSlowCase(JSTokenData*, OptionSet<LexerFlags>, bool strictMode);
     enum StringParseResult {
         StringParsedSuccessfully,
         StringUnterminated,
         StringCannotBeParsed
     };
@@ -193,11 +194,11 @@
     template <unsigned length>
     ALWAYS_INLINE bool consume(const char (&input)[length]);
 
     void fillTokenInfo(JSToken*, JSTokenType, int lineNumber, int endOffset, int lineStartOffset, JSTextPosition endPosition);
 
-    static const size_t initialReadBufferCapacity = 32;
+    static constexpr size_t initialReadBufferCapacity = 32;
 
     int m_lineNumber;
     int m_lastLineNumber;
 
     Vector<LChar> m_buffer8;
@@ -331,22 +332,22 @@
 ALWAYS_INLINE const Identifier* Lexer<T>::makeLCharIdentifier(const UChar* characters, size_t length)
 {
     return &m_arena->makeIdentifierLCharFromUChar(m_vm, characters, length);
 }
 
-#if ASSERT_DISABLED
-ALWAYS_INLINE bool isSafeBuiltinIdentifier(VM&, const Identifier*) { return true; }
-#else
+#if ASSERT_ENABLED
 bool isSafeBuiltinIdentifier(VM&, const Identifier*);
-#endif
+#else
+ALWAYS_INLINE bool isSafeBuiltinIdentifier(VM&, const Identifier*) { return true; }
+#endif // ASSERT_ENABLED
 
 template <typename T>
-ALWAYS_INLINE JSTokenType Lexer<T>::lexExpectIdentifier(JSToken* tokenRecord, unsigned lexerFlags, bool strictMode)
+ALWAYS_INLINE JSTokenType Lexer<T>::lexExpectIdentifier(JSToken* tokenRecord, OptionSet<LexerFlags> lexerFlags, bool strictMode)
 {
     JSTokenData* tokenData = &tokenRecord->m_data;
     JSTokenLocation* tokenLocation = &tokenRecord->m_location;
-    ASSERT((lexerFlags & LexerFlagsIgnoreReservedWords));
+    ASSERT(lexerFlags.contains(LexerFlags::IgnoreReservedWords));
     const T* start = m_code;
     const T* ptr = start;
     const T* end = m_codeEnd;
     JSTextPosition startPosition = currentPosition();
     if (ptr >= end) {
@@ -372,12 +373,12 @@
 
     m_code = ptr;
     ASSERT(currentOffset() >= currentLineStartOffset());
 
     // Create the identifier if needed
-    if (lexerFlags & LexexFlagsDontBuildKeywords
-#if !ASSERT_DISABLED
+    if (lexerFlags.contains(LexerFlags::DontBuildKeywords)
+#if ASSERT_ENABLED
         && !m_parsingBuiltinFunction
 #endif
         )
         tokenData->ident = 0;
     else
@@ -388,11 +389,11 @@
     tokenLocation->startOffset = offsetFromSourcePtr(start);
     tokenLocation->endOffset = currentOffset();
     ASSERT(tokenLocation->startOffset >= tokenLocation->lineStartOffset);
     tokenRecord->m_startPosition = startPosition;
     tokenRecord->m_endPosition = currentPosition();
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     if (m_parsingBuiltinFunction) {
         if (!isSafeBuiltinIdentifier(m_vm, tokenData->ident))
             return ERRORTOK;
     }
 #endif
@@ -403,11 +404,11 @@
 slowCase:
     return lex(tokenRecord, lexerFlags, strictMode);
 }
 
 template <typename T>
-ALWAYS_INLINE JSTokenType Lexer<T>::lex(JSToken* tokenRecord, unsigned lexerFlags, bool strictMode)
+ALWAYS_INLINE JSTokenType Lexer<T>::lex(JSToken* tokenRecord, OptionSet<LexerFlags> lexerFlags, bool strictMode)
 {
     m_hasLineTerminatorBeforeToken = false;
     return lexWithoutClearingLineTerminator(tokenRecord, lexerFlags, strictMode);
 }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSafeToExecute.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSSALoweringPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSafepoint.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSafeToExecute.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DFGGraph.h&quot;
 31 
 32 namespace JSC { namespace DFG {
 33 






 34 template&lt;typename AbstractStateType&gt;
 35 class SafeToExecuteEdge {
 36 public:
 37     SafeToExecuteEdge(AbstractStateType&amp; state)
 38         : m_state(state)
 39     {
 40     }
 41 
 42     void operator()(Node*, Edge edge)
 43     {
 44         m_maySeeEmptyChild |= !!(m_state.forNode(edge).m_type &amp; SpecEmpty);
 45 
 46         switch (edge.useKind()) {
 47         case UntypedUse:
 48         case Int32Use:
 49         case DoubleRepUse:
 50         case DoubleRepRealUse:
 51         case Int52RepUse:
 52         case NumberUse:
 53         case RealNumberUse:
 54         case BooleanUse:
 55         case CellUse:
 56         case CellOrOtherUse:
 57         case ObjectUse:
 58         case ArrayUse:
 59         case FunctionUse:
 60         case FinalObjectUse:
 61         case RegExpObjectUse:

 62         case ProxyObjectUse:
 63         case DerivedArrayUse:

 64         case MapObjectUse:
 65         case SetObjectUse:
 66         case WeakMapObjectUse:
 67         case WeakSetObjectUse:
 68         case DataViewObjectUse:
 69         case ObjectOrOtherUse:
 70         case StringIdentUse:
 71         case StringUse:
 72         case StringOrOtherUse:
 73         case SymbolUse:
 74         case BigIntUse:
 75         case StringObjectUse:
 76         case StringOrStringObjectUse:
 77         case NotStringVarUse:
 78         case NotSymbolUse:
 79         case NotCellUse:
 80         case OtherUse:
 81         case MiscUse:
 82         case AnyIntUse:
 83         case DoubleRepAnyIntUse:
</pre>
<hr />
<pre>
142 template&lt;typename AbstractStateType&gt;
143 bool safeToExecute(AbstractStateType&amp; state, Graph&amp; graph, Node* node, bool ignoreEmptyChildren = false)
144 {
145     SafeToExecuteEdge&lt;AbstractStateType&gt; safeToExecuteEdge(state);
146     DFG_NODE_DO_TO_CHILDREN(graph, node, safeToExecuteEdge);
147     if (!safeToExecuteEdge.result())
148         return false;
149 
150     if (!ignoreEmptyChildren &amp;&amp; safeToExecuteEdge.maySeeEmptyChild()) {
151         // We conservatively assume if the empty value flows into a node,
152         // it might not be able to handle it (e.g, crash). In general, the bytecode generator
153         // emits code in such a way that most node types don&#39;t need to worry about the empty value
154         // because they will never see it. However, code motion has to consider the empty
155         // value so it does not insert/move nodes to a place where they will crash. E.g, the
156         // type check hoisting phase needs to insert CheckStructureOrEmpty instead of CheckStructure
157         // for hoisted structure checks because it can not guarantee that a particular local is not
158         // the empty value.
159         switch (node-&gt;op()) {
160         case CheckNotEmpty:
161         case CheckStructureOrEmpty:

162             break;
163         default:
164             return false;
165         }
166     }
167 
<span class="line-modified">168     // NOTE: This tends to lie when it comes to effectful nodes, because it knows that they aren&#39;t going to</span>
<span class="line-modified">169     // get hoisted anyway.</span>


170 
171     switch (node-&gt;op()) {


172     case JSConstant:
173     case DoubleConstant:
174     case Int52Constant:
175     case LazyJSConstant:
176     case Identity:
177     case IdentityWithProfile:
<span class="line-removed">178     case ToThis:</span>
<span class="line-removed">179     case CreateThis:</span>
<span class="line-removed">180     case ObjectCreate:</span>
<span class="line-removed">181     case ObjectKeys:</span>
182     case GetCallee:
<span class="line-removed">183     case SetCallee:</span>
184     case GetArgumentCountIncludingThis:
<span class="line-removed">185     case SetArgumentCountIncludingThis:</span>
186     case GetRestLength:
187     case GetLocal:
<span class="line-removed">188     case SetLocal:</span>
<span class="line-removed">189     case PutStack:</span>
<span class="line-removed">190     case KillStack:</span>
191     case GetStack:
<span class="line-removed">192     case MovHint:</span>
<span class="line-removed">193     case ZombieHint:</span>
194     case ExitOK:
195     case Phantom:
<span class="line-removed">196     case Upsilon:</span>
<span class="line-removed">197     case Phi:</span>
<span class="line-removed">198     case Flush:</span>
<span class="line-removed">199     case PhantomLocal:</span>
<span class="line-removed">200     case SetArgumentDefinitely:</span>
<span class="line-removed">201     case SetArgumentMaybe:</span>
202     case ArithBitNot:
203     case ArithBitAnd:
204     case ArithBitOr:
205     case ArithBitXor:
206     case ArithBitLShift:
<span class="line-modified">207     case BitRShift:</span>
208     case BitURShift:
209     case ValueToInt32:
210     case UInt32ToNumber:
211     case DoubleAsInt32:
212     case ArithAdd:
213     case ArithClz32:
214     case ArithSub:
215     case ArithNegate:
216     case ArithMul:
217     case ArithIMul:
218     case ArithDiv:
219     case ArithMod:
220     case ArithAbs:
221     case ArithMin:
222     case ArithMax:
223     case ArithPow:
224     case ArithRandom:
225     case ArithSqrt:
226     case ArithFRound:
227     case ArithRound:
228     case ArithFloor:
229     case ArithCeil:
230     case ArithTrunc:
231     case ArithUnary:
<span class="line-modified">232     case ValueBitAnd:</span>
<span class="line-removed">233     case ValueBitXor:</span>
<span class="line-removed">234     case ValueBitOr:</span>
<span class="line-removed">235     case ValueBitNot:</span>
<span class="line-removed">236     case ValueBitLShift:</span>
<span class="line-removed">237     case ValueNegate:</span>
<span class="line-removed">238     case ValueAdd:</span>
<span class="line-removed">239     case ValueSub:</span>
<span class="line-removed">240     case ValueMul:</span>
<span class="line-removed">241     case ValueDiv:</span>
<span class="line-removed">242     case ValueMod:</span>
<span class="line-removed">243     case ValuePow:</span>
<span class="line-removed">244     case TryGetById:</span>
<span class="line-removed">245     case DeleteById:</span>
<span class="line-removed">246     case DeleteByVal:</span>
<span class="line-removed">247     case GetById:</span>
<span class="line-removed">248     case GetByIdWithThis:</span>
<span class="line-removed">249     case GetByValWithThis:</span>
<span class="line-removed">250     case GetByIdFlush:</span>
<span class="line-removed">251     case GetByIdDirect:</span>
<span class="line-removed">252     case GetByIdDirectFlush:</span>
<span class="line-removed">253     case PutById:</span>
<span class="line-removed">254     case PutByIdFlush:</span>
<span class="line-removed">255     case PutByIdWithThis:</span>
<span class="line-removed">256     case PutByValWithThis:</span>
<span class="line-removed">257     case PutByIdDirect:</span>
<span class="line-removed">258     case PutGetterById:</span>
<span class="line-removed">259     case PutSetterById:</span>
<span class="line-removed">260     case PutGetterSetterById:</span>
<span class="line-removed">261     case PutGetterByVal:</span>
<span class="line-removed">262     case PutSetterByVal:</span>
<span class="line-removed">263     case DefineDataProperty:</span>
<span class="line-removed">264     case DefineAccessorProperty:</span>
265     case CheckStructure:
266     case CheckStructureOrEmpty:
267     case GetExecutable:
<span class="line-removed">268     case GetButterfly:</span>
269     case CallDOMGetter:
270     case CallDOM:
271     case CheckSubClass:
272     case CheckArray:
<span class="line-modified">273     case Arrayify:</span>
<span class="line-removed">274     case ArrayifyToStructure:</span>
275     case GetScope:
276     case SkipScope:
277     case GetGlobalObject:
278     case GetGlobalThis:
279     case GetClosureVar:
<span class="line-removed">280     case PutClosureVar:</span>
281     case GetGlobalVar:
282     case GetGlobalLexicalVariable:
<span class="line-removed">283     case PutGlobalVariable:</span>
284     case CheckCell:
<span class="line-removed">285     case CheckBadCell:</span>
286     case CheckNotEmpty:
287     case AssertNotEmpty:
<span class="line-modified">288     case CheckStringIdent:</span>
<span class="line-removed">289     case RegExpExec:</span>
<span class="line-removed">290     case RegExpExecNonGlobalOrSticky:</span>
<span class="line-removed">291     case RegExpTest:</span>
<span class="line-removed">292     case RegExpMatchFast:</span>
<span class="line-removed">293     case RegExpMatchFastGlobal:</span>
294     case CompareLess:
295     case CompareLessEq:
296     case CompareGreater:
297     case CompareGreaterEq:
298     case CompareBelow:
299     case CompareBelowEq:
300     case CompareEq:
301     case CompareStrictEq:
302     case CompareEqPtr:
303     case SameValue:
<span class="line-removed">304     case Call:</span>
<span class="line-removed">305     case DirectCall:</span>
<span class="line-removed">306     case TailCallInlinedCaller:</span>
<span class="line-removed">307     case DirectTailCallInlinedCaller:</span>
<span class="line-removed">308     case Construct:</span>
<span class="line-removed">309     case DirectConstruct:</span>
<span class="line-removed">310     case CallVarargs:</span>
<span class="line-removed">311     case CallEval:</span>
<span class="line-removed">312     case TailCallVarargsInlinedCaller:</span>
<span class="line-removed">313     case TailCallForwardVarargsInlinedCaller:</span>
<span class="line-removed">314     case ConstructVarargs:</span>
<span class="line-removed">315     case LoadVarargs:</span>
<span class="line-removed">316     case CallForwardVarargs:</span>
<span class="line-removed">317     case ConstructForwardVarargs:</span>
<span class="line-removed">318     case NewObject:</span>
<span class="line-removed">319     case NewArray:</span>
<span class="line-removed">320     case NewArrayWithSize:</span>
<span class="line-removed">321     case NewArrayBuffer:</span>
<span class="line-removed">322     case NewArrayWithSpread:</span>
<span class="line-removed">323     case Spread:</span>
<span class="line-removed">324     case NewRegexp:</span>
<span class="line-removed">325     case NewSymbol:</span>
<span class="line-removed">326     case ProfileType:</span>
<span class="line-removed">327     case ProfileControlFlow:</span>
328     case CheckTypeInfoFlags:
329     case ParseInt:
330     case OverridesHasInstance:
<span class="line-removed">331     case InstanceOf:</span>
<span class="line-removed">332     case InstanceOfCustom:</span>
333     case IsEmpty:
334     case IsUndefined:
335     case IsUndefinedOrNull:
336     case IsBoolean:
337     case IsNumber:
338     case NumberIsInteger:
339     case IsObject:
340     case IsObjectOrNull:
341     case IsFunction:
342     case IsCellWithType:
343     case IsTypedArrayView:
344     case TypeOf:
345     case LogicalNot:
<span class="line-removed">346     case CallObjectConstructor:</span>
<span class="line-removed">347     case ToPrimitive:</span>
348     case ToString:
<span class="line-removed">349     case ToNumber:</span>
<span class="line-removed">350     case ToObject:</span>
<span class="line-removed">351     case NumberToStringWithRadix:</span>
352     case NumberToStringWithValidRadixConstant:
<span class="line-removed">353     case SetFunctionName:</span>
354     case StrCat:
355     case CallStringConstructor:
<span class="line-removed">356     case NewStringObject:</span>
357     case MakeRope:
<span class="line-removed">358     case InByVal:</span>
<span class="line-removed">359     case InById:</span>
<span class="line-removed">360     case HasOwnProperty:</span>
<span class="line-removed">361     case PushWithScope:</span>
<span class="line-removed">362     case CreateActivation:</span>
<span class="line-removed">363     case CreateDirectArguments:</span>
<span class="line-removed">364     case CreateScopedArguments:</span>
<span class="line-removed">365     case CreateClonedArguments:</span>
366     case GetFromArguments:
367     case GetArgument:
<span class="line-removed">368     case PutToArguments:</span>
<span class="line-removed">369     case NewFunction:</span>
<span class="line-removed">370     case NewGeneratorFunction:</span>
<span class="line-removed">371     case NewAsyncGeneratorFunction:</span>
<span class="line-removed">372     case NewAsyncFunction:</span>
<span class="line-removed">373     case Jump:</span>
<span class="line-removed">374     case Branch:</span>
<span class="line-removed">375     case Switch:</span>
<span class="line-removed">376     case EntrySwitch:</span>
<span class="line-removed">377     case Return:</span>
<span class="line-removed">378     case TailCall:</span>
<span class="line-removed">379     case DirectTailCall:</span>
<span class="line-removed">380     case TailCallVarargs:</span>
<span class="line-removed">381     case TailCallForwardVarargs:</span>
<span class="line-removed">382     case Throw:</span>
<span class="line-removed">383     case ThrowStaticError:</span>
<span class="line-removed">384     case CountExecution:</span>
<span class="line-removed">385     case SuperSamplerBegin:</span>
<span class="line-removed">386     case SuperSamplerEnd:</span>
<span class="line-removed">387     case ForceOSRExit:</span>
<span class="line-removed">388     case CPUIntrinsic:</span>
<span class="line-removed">389     case CheckTraps:</span>
<span class="line-removed">390     case LogShadowChickenPrologue:</span>
<span class="line-removed">391     case LogShadowChickenTail:</span>
392     case StringFromCharCode:
<span class="line-removed">393     case NewTypedArray:</span>
<span class="line-removed">394     case Unreachable:</span>
395     case ExtractOSREntryLocal:
396     case ExtractCatchLocal:
<span class="line-removed">397     case ClearCatchLocals:</span>
<span class="line-removed">398     case CheckTierUpInLoop:</span>
<span class="line-removed">399     case CheckTierUpAtReturn:</span>
<span class="line-removed">400     case CheckTierUpAndOSREnter:</span>
<span class="line-removed">401     case LoopHint:</span>
<span class="line-removed">402     case InvalidationPoint:</span>
<span class="line-removed">403     case NotifyWrite:</span>
404     case CheckInBounds:
405     case ConstantStoragePointer:
406     case Check:
407     case CheckVarargs:
<span class="line-removed">408     case MultiPutByOffset:</span>
409     case ValueRep:
410     case DoubleRep:
411     case Int52Rep:
412     case BooleanToNumber:
413     case FiatInt52:
<span class="line-removed">414     case GetGetter:</span>
<span class="line-removed">415     case GetSetter:</span>
<span class="line-removed">416     case GetEnumerableLength:</span>
<span class="line-removed">417     case HasGenericProperty:</span>
<span class="line-removed">418     case HasStructureProperty:</span>
419     case HasIndexedProperty:
<span class="line-removed">420     case GetDirectPname:</span>
<span class="line-removed">421     case GetPropertyEnumerator:</span>
422     case GetEnumeratorStructurePname:
423     case GetEnumeratorGenericPname:
424     case ToIndexString:
<span class="line-removed">425     case PhantomNewObject:</span>
<span class="line-removed">426     case PhantomNewFunction:</span>
<span class="line-removed">427     case PhantomNewGeneratorFunction:</span>
<span class="line-removed">428     case PhantomNewAsyncGeneratorFunction:</span>
<span class="line-removed">429     case PhantomNewAsyncFunction:</span>
<span class="line-removed">430     case PhantomCreateActivation:</span>
<span class="line-removed">431     case PhantomNewRegexp:</span>
<span class="line-removed">432     case PutHint:</span>
433     case CheckStructureImmediate:
<span class="line-removed">434     case MaterializeNewObject:</span>
<span class="line-removed">435     case MaterializeCreateActivation:</span>
<span class="line-removed">436     case PhantomDirectArguments:</span>
<span class="line-removed">437     case PhantomCreateRest:</span>
<span class="line-removed">438     case PhantomSpread:</span>
<span class="line-removed">439     case PhantomNewArrayWithSpread:</span>
<span class="line-removed">440     case PhantomNewArrayBuffer:</span>
<span class="line-removed">441     case PhantomClonedArguments:</span>
442     case GetMyArgumentByVal:
443     case GetMyArgumentByValOutOfBounds:
<span class="line-removed">444     case ForwardVarargs:</span>
<span class="line-removed">445     case CreateRest:</span>
446     case GetPrototypeOf:
447     case StringReplace:
448     case StringReplaceRegExp:
449     case GetRegExpObjectLastIndex:
<span class="line-removed">450     case SetRegExpObjectLastIndex:</span>
<span class="line-removed">451     case RecordRegExpCachedResult:</span>
<span class="line-removed">452     case GetDynamicVar:</span>
<span class="line-removed">453     case PutDynamicVar:</span>
<span class="line-removed">454     case ResolveScopeForHoistingFuncDeclInEval:</span>
<span class="line-removed">455     case ResolveScope:</span>
456     case MapHash:
457     case NormalizeMapKey:
<span class="line-removed">458     case StringValueOf:</span>
459     case StringSlice:
460     case ToLowerCase:
461     case GetMapBucket:
462     case GetMapBucketHead:
463     case GetMapBucketNext:
464     case LoadKeyFromMapBucket:
465     case LoadValueFromMapBucket:
466     case ExtractValueFromWeakMapGet:
467     case WeakMapGet:
<span class="line-removed">468     case WeakSetAdd:</span>
<span class="line-removed">469     case WeakMapSet:</span>
<span class="line-removed">470     case AtomicsAdd:</span>
<span class="line-removed">471     case AtomicsAnd:</span>
<span class="line-removed">472     case AtomicsCompareExchange:</span>
<span class="line-removed">473     case AtomicsExchange:</span>
<span class="line-removed">474     case AtomicsLoad:</span>
<span class="line-removed">475     case AtomicsOr:</span>
<span class="line-removed">476     case AtomicsStore:</span>
<span class="line-removed">477     case AtomicsSub:</span>
<span class="line-removed">478     case AtomicsXor:</span>
479     case AtomicsIsLockFree:
<span class="line-removed">480     case InitializeEntrypointArguments:</span>
481     case MatchStructure:


482     case DataViewGetInt:
483     case DataViewGetFloat:
484         return true;
485 



486     case ArraySlice:
487     case ArrayIndexOf: {
488         // You could plausibly move this code around as long as you proved the
489         // incoming array base structure is an original array at the hoisted location.
490         // Instead of doing that extra work, we just conservatively return false.
491         return false;
492     }
493 











494     case BottomValue:
495         // If in doubt, assume that this isn&#39;t safe to execute, just because we have no way of
496         // compiling this node.
497         return false;
498 
499     case StoreBarrier:
500     case FencedStoreBarrier:
501     case PutStructure:
502     case NukeStructureAndSetButterfly:
503         // We conservatively assume that these cannot be put anywhere, which forces the compiler to
504         // keep them exactly where they were. This is sort of overkill since the clobberize effects
505         // already force these things to be ordered precisely. I&#39;m just not confident enough in my
506         // effect based memory model to rely solely on that right now.
507         return false;
508 
509     case FilterCallLinkStatus:
<span class="line-modified">510     case FilterGetByIdStatus:</span>
511     case FilterPutByIdStatus:
512     case FilterInByIdStatus:
513         // We don&#39;t want these to be moved anywhere other than where we put them, since we want them
514         // to capture &quot;profiling&quot; at the point in control flow here the user put them.
515         return false;
516 
517     case GetByVal:
518     case GetIndexedPropertyStorage:
519     case GetArrayLength:
520     case GetVectorLength:
521     case ArrayPop:
522     case StringCharAt:
523     case StringCharCodeAt:

524         return node-&gt;arrayMode().alreadyChecked(graph, node, state.forNode(graph.child(node, 0)));
525 
526     case ArrayPush:
527         return node-&gt;arrayMode().alreadyChecked(graph, node, state.forNode(graph.varArgChild(node, 1)));
528 

529     case GetTypedArrayByteOffset:
530         return !(state.forNode(node-&gt;child1()).m_type &amp; ~(SpecTypedArrayView));
531 
532     case PutByValDirect:
533     case PutByVal:
534     case PutByValAlias:
535         return node-&gt;arrayMode().modeForPut().alreadyChecked(
536             graph, node, state.forNode(graph.varArgChild(node, 0)));
537 
538     case AllocatePropertyStorage:
539     case ReallocatePropertyStorage:
540         return state.forNode(node-&gt;child1()).m_structure.isSubsetOf(
541             RegisteredStructureSet(node-&gt;transition()-&gt;previous));
542 























543     case GetByOffset:
<span class="line-removed">544     case GetGetterSetterByOffset:</span>
545     case PutByOffset: {




546         StorageAccessData&amp; data = node-&gt;storageAccessData();
547         PropertyOffset offset = data.offset;
548         // Graph::isSafeToLoad() is all about proofs derived from PropertyConditions. Those don&#39;t
549         // know anything about inferred types. But if we have a proof derived from watching a
550         // structure that has a type proof, then the next case below will deal with it.
551         if (state.structureClobberState() == StructuresAreWatched) {
552             if (JSObject* knownBase = node-&gt;child2()-&gt;dynamicCastConstant&lt;JSObject*&gt;(graph.m_vm)) {
553                 if (graph.isSafeToLoad(knownBase, offset))
554                     return true;
555             }
556         }
557 
558         StructureAbstractValue&amp; value = state.forNode(node-&gt;child2()).m_structure;
559         if (value.isInfinite())
560             return false;
561         for (unsigned i = value.size(); i--;) {
562             Structure* thisStructure = value[i].get();


563             if (!thisStructure-&gt;isValidOffset(offset))
564                 return false;
565         }
566         return true;
567     }
568 
569     case MultiGetByOffset: {
570         // We can&#39;t always guarantee that the MultiGetByOffset is safe to execute if it
571         // contains loads from prototypes. If the load requires a check in IR, which is rare, then
572         // we currently claim that we don&#39;t know if it&#39;s safe to execute because finding that
573         // check in the abstract state would be hard. If the load requires watchpoints, we just
574         // check if we&#39;re not in a clobbered state (i.e. in between a side effect and an
575         // invalidation point).
576         for (const MultiGetByOffsetCase&amp; getCase : node-&gt;multiGetByOffsetData().cases) {
577             GetByOffsetMethod method = getCase.method();
578             switch (method.kind()) {
579             case GetByOffsetMethod::Invalid:
580                 RELEASE_ASSERT_NOT_REACHED();
581                 break;
582             case GetByOffsetMethod::Constant: // OK because constants are always safe to execute.
583             case GetByOffsetMethod::Load: // OK because the MultiGetByOffset has its own checks for loading from self.
584                 break;
585             case GetByOffsetMethod::LoadFromPrototype:
586                 // Only OK if the state isn&#39;t clobbered. That&#39;s almost always the case.
587                 if (state.structureClobberState() != StructuresAreWatched)
588                     return false;
589                 if (!graph.isSafeToLoad(method.prototype()-&gt;cast&lt;JSObject*&gt;(), method.offset()))
590                     return false;
591                 break;
592             }
593         }
594         return true;
595     }
596 




















































































































































































597     case DataViewSet:
<span class="line-removed">598         return false;</span>
<span class="line-removed">599 </span>
600     case SetAdd:
601     case MapSet:
602         return false;
603 




















604     case LastNodeType:
605         RELEASE_ASSERT_NOT_REACHED();
606         return false;
607     }
608 
609     RELEASE_ASSERT_NOT_REACHED();
610     return false;
611 }
612 
613 } } // namespace JSC::DFG
614 
615 #endif // ENABLE(DFG_JIT)
</pre>
</td>
<td>
<hr />
<pre>
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DFGGraph.h&quot;
 31 
 32 namespace JSC { namespace DFG {
 33 
<span class="line-added"> 34 // This phase is used to determine if a node can safely run at a new location.</span>
<span class="line-added"> 35 // It is important to note that returning false does not mean it&#39;s definitely</span>
<span class="line-added"> 36 // wrong to run the node at the new location. In other words, returning false</span>
<span class="line-added"> 37 // does not imply moving the node would be invalid only that this phase could</span>
<span class="line-added"> 38 // not prove it is valid. Thus, it is always ok to return false.</span>
<span class="line-added"> 39 </span>
 40 template&lt;typename AbstractStateType&gt;
 41 class SafeToExecuteEdge {
 42 public:
 43     SafeToExecuteEdge(AbstractStateType&amp; state)
 44         : m_state(state)
 45     {
 46     }
 47 
 48     void operator()(Node*, Edge edge)
 49     {
 50         m_maySeeEmptyChild |= !!(m_state.forNode(edge).m_type &amp; SpecEmpty);
 51 
 52         switch (edge.useKind()) {
 53         case UntypedUse:
 54         case Int32Use:
 55         case DoubleRepUse:
 56         case DoubleRepRealUse:
 57         case Int52RepUse:
 58         case NumberUse:
 59         case RealNumberUse:
 60         case BooleanUse:
 61         case CellUse:
 62         case CellOrOtherUse:
 63         case ObjectUse:
 64         case ArrayUse:
 65         case FunctionUse:
 66         case FinalObjectUse:
 67         case RegExpObjectUse:
<span class="line-added"> 68         case PromiseObjectUse:</span>
 69         case ProxyObjectUse:
 70         case DerivedArrayUse:
<span class="line-added"> 71         case DateObjectUse:</span>
 72         case MapObjectUse:
 73         case SetObjectUse:
 74         case WeakMapObjectUse:
 75         case WeakSetObjectUse:
 76         case DataViewObjectUse:
 77         case ObjectOrOtherUse:
 78         case StringIdentUse:
 79         case StringUse:
 80         case StringOrOtherUse:
 81         case SymbolUse:
 82         case BigIntUse:
 83         case StringObjectUse:
 84         case StringOrStringObjectUse:
 85         case NotStringVarUse:
 86         case NotSymbolUse:
 87         case NotCellUse:
 88         case OtherUse:
 89         case MiscUse:
 90         case AnyIntUse:
 91         case DoubleRepAnyIntUse:
</pre>
<hr />
<pre>
150 template&lt;typename AbstractStateType&gt;
151 bool safeToExecute(AbstractStateType&amp; state, Graph&amp; graph, Node* node, bool ignoreEmptyChildren = false)
152 {
153     SafeToExecuteEdge&lt;AbstractStateType&gt; safeToExecuteEdge(state);
154     DFG_NODE_DO_TO_CHILDREN(graph, node, safeToExecuteEdge);
155     if (!safeToExecuteEdge.result())
156         return false;
157 
158     if (!ignoreEmptyChildren &amp;&amp; safeToExecuteEdge.maySeeEmptyChild()) {
159         // We conservatively assume if the empty value flows into a node,
160         // it might not be able to handle it (e.g, crash). In general, the bytecode generator
161         // emits code in such a way that most node types don&#39;t need to worry about the empty value
162         // because they will never see it. However, code motion has to consider the empty
163         // value so it does not insert/move nodes to a place where they will crash. E.g, the
164         // type check hoisting phase needs to insert CheckStructureOrEmpty instead of CheckStructure
165         // for hoisted structure checks because it can not guarantee that a particular local is not
166         // the empty value.
167         switch (node-&gt;op()) {
168         case CheckNotEmpty:
169         case CheckStructureOrEmpty:
<span class="line-added">170         case CheckArrayOrEmpty:</span>
171             break;
172         default:
173             return false;
174         }
175     }
176 
<span class="line-modified">177     // NOTE: This can lie when it comes to effectful nodes, because it knows that they aren&#39;t going to</span>
<span class="line-modified">178     // get hoisted anyway. Sometimes this is convenient so we can avoid branching on some internal</span>
<span class="line-added">179     // state of the node (like what some child&#39;s UseKind might be). However, nodes that are obviously</span>
<span class="line-added">180     // always effectful, we return false for, to make auditing the &quot;return true&quot; cases easier.</span>
181 
182     switch (node-&gt;op()) {
<span class="line-added">183     // FIXME: Audit these:</span>
<span class="line-added">184     // https://bugs.webkit.org/show_bug.cgi?id=207075</span>
185     case JSConstant:
186     case DoubleConstant:
187     case Int52Constant:
188     case LazyJSConstant:
189     case Identity:
190     case IdentityWithProfile:




191     case GetCallee:

192     case GetArgumentCountIncludingThis:

193     case GetRestLength:
194     case GetLocal:



195     case GetStack:


196     case ExitOK:
197     case Phantom:






198     case ArithBitNot:
199     case ArithBitAnd:
200     case ArithBitOr:
201     case ArithBitXor:
202     case ArithBitLShift:
<span class="line-modified">203     case ArithBitRShift:</span>
204     case BitURShift:
205     case ValueToInt32:
206     case UInt32ToNumber:
207     case DoubleAsInt32:
208     case ArithAdd:
209     case ArithClz32:
210     case ArithSub:
211     case ArithNegate:
212     case ArithMul:
213     case ArithIMul:
214     case ArithDiv:
215     case ArithMod:
216     case ArithAbs:
217     case ArithMin:
218     case ArithMax:
219     case ArithPow:
220     case ArithRandom:
221     case ArithSqrt:
222     case ArithFRound:
223     case ArithRound:
224     case ArithFloor:
225     case ArithCeil:
226     case ArithTrunc:
227     case ArithUnary:
<span class="line-modified">228     case TryGetById: // FIXME: Audit this: https://bugs.webkit.org/show_bug.cgi?id=163834</span>
































229     case CheckStructure:
230     case CheckStructureOrEmpty:
231     case GetExecutable:

232     case CallDOMGetter:
233     case CallDOM:
234     case CheckSubClass:
235     case CheckArray:
<span class="line-modified">236     case CheckArrayOrEmpty:</span>

237     case GetScope:
238     case SkipScope:
239     case GetGlobalObject:
240     case GetGlobalThis:
241     case GetClosureVar:

242     case GetGlobalVar:
243     case GetGlobalLexicalVariable:

244     case CheckCell:

245     case CheckNotEmpty:
246     case AssertNotEmpty:
<span class="line-modified">247     case CheckIdent:</span>





248     case CompareLess:
249     case CompareLessEq:
250     case CompareGreater:
251     case CompareGreaterEq:
252     case CompareBelow:
253     case CompareBelowEq:
254     case CompareEq:
255     case CompareStrictEq:
256     case CompareEqPtr:
257     case SameValue:
























258     case CheckTypeInfoFlags:
259     case ParseInt:
260     case OverridesHasInstance:


261     case IsEmpty:
262     case IsUndefined:
263     case IsUndefinedOrNull:
264     case IsBoolean:
265     case IsNumber:
266     case NumberIsInteger:
267     case IsObject:
268     case IsObjectOrNull:
269     case IsFunction:
270     case IsCellWithType:
271     case IsTypedArrayView:
272     case TypeOf:
273     case LogicalNot:


274     case ToString:



275     case NumberToStringWithValidRadixConstant:

276     case StrCat:
277     case CallStringConstructor:

278     case MakeRope:








279     case GetFromArguments:
280     case GetArgument:
























281     case StringFromCharCode:


282     case ExtractOSREntryLocal:
283     case ExtractCatchLocal:







284     case CheckInBounds:
285     case ConstantStoragePointer:
286     case Check:
287     case CheckVarargs:

288     case ValueRep:
289     case DoubleRep:
290     case Int52Rep:
291     case BooleanToNumber:
292     case FiatInt52:





293     case HasIndexedProperty:


294     case GetEnumeratorStructurePname:
295     case GetEnumeratorGenericPname:
296     case ToIndexString:








297     case CheckStructureImmediate:








298     case GetMyArgumentByVal:
299     case GetMyArgumentByValOutOfBounds:


300     case GetPrototypeOf:
301     case StringReplace:
302     case StringReplaceRegExp:
303     case GetRegExpObjectLastIndex:






304     case MapHash:
305     case NormalizeMapKey:

306     case StringSlice:
307     case ToLowerCase:
308     case GetMapBucket:
309     case GetMapBucketHead:
310     case GetMapBucketNext:
311     case LoadKeyFromMapBucket:
312     case LoadValueFromMapBucket:
313     case ExtractValueFromWeakMapGet:
314     case WeakMapGet:











315     case AtomicsIsLockFree:

316     case MatchStructure:
<span class="line-added">317     case DateGetInt32OrNaN:</span>
<span class="line-added">318     case DateGetTime:</span>
319     case DataViewGetInt:
320     case DataViewGetFloat:
321         return true;
322 
<span class="line-added">323     case GetButterfly:</span>
<span class="line-added">324         return state.forNode(node-&gt;child1()).isType(SpecObject);</span>
<span class="line-added">325 </span>
326     case ArraySlice:
327     case ArrayIndexOf: {
328         // You could plausibly move this code around as long as you proved the
329         // incoming array base structure is an original array at the hoisted location.
330         // Instead of doing that extra work, we just conservatively return false.
331         return false;
332     }
333 
<span class="line-added">334     case GetGetter:</span>
<span class="line-added">335     case GetSetter: {</span>
<span class="line-added">336         if (!state.forNode(node-&gt;child1()).isType(SpecCell))</span>
<span class="line-added">337             return false;</span>
<span class="line-added">338         StructureAbstractValue&amp; value = state.forNode(node-&gt;child1()).m_structure;</span>
<span class="line-added">339         if (value.isInfinite() || value.size() != 1)</span>
<span class="line-added">340             return false;</span>
<span class="line-added">341 </span>
<span class="line-added">342         return value[0].get() == graph.m_vm.getterSetterStructure;</span>
<span class="line-added">343     }</span>
<span class="line-added">344 </span>
345     case BottomValue:
346         // If in doubt, assume that this isn&#39;t safe to execute, just because we have no way of
347         // compiling this node.
348         return false;
349 
350     case StoreBarrier:
351     case FencedStoreBarrier:
352     case PutStructure:
353     case NukeStructureAndSetButterfly:
354         // We conservatively assume that these cannot be put anywhere, which forces the compiler to
355         // keep them exactly where they were. This is sort of overkill since the clobberize effects
356         // already force these things to be ordered precisely. I&#39;m just not confident enough in my
357         // effect based memory model to rely solely on that right now.
358         return false;
359 
360     case FilterCallLinkStatus:
<span class="line-modified">361     case FilterGetByStatus:</span>
362     case FilterPutByIdStatus:
363     case FilterInByIdStatus:
364         // We don&#39;t want these to be moved anywhere other than where we put them, since we want them
365         // to capture &quot;profiling&quot; at the point in control flow here the user put them.
366         return false;
367 
368     case GetByVal:
369     case GetIndexedPropertyStorage:
370     case GetArrayLength:
371     case GetVectorLength:
372     case ArrayPop:
373     case StringCharAt:
374     case StringCharCodeAt:
<span class="line-added">375     case StringCodePointAt:</span>
376         return node-&gt;arrayMode().alreadyChecked(graph, node, state.forNode(graph.child(node, 0)));
377 
378     case ArrayPush:
379         return node-&gt;arrayMode().alreadyChecked(graph, node, state.forNode(graph.varArgChild(node, 1)));
380 
<span class="line-added">381     case CheckNeutered:</span>
382     case GetTypedArrayByteOffset:
383         return !(state.forNode(node-&gt;child1()).m_type &amp; ~(SpecTypedArrayView));
384 
385     case PutByValDirect:
386     case PutByVal:
387     case PutByValAlias:
388         return node-&gt;arrayMode().modeForPut().alreadyChecked(
389             graph, node, state.forNode(graph.varArgChild(node, 0)));
390 
391     case AllocatePropertyStorage:
392     case ReallocatePropertyStorage:
393         return state.forNode(node-&gt;child1()).m_structure.isSubsetOf(
394             RegisteredStructureSet(node-&gt;transition()-&gt;previous));
395 
<span class="line-added">396     case GetGetterSetterByOffset: {</span>
<span class="line-added">397         // If it&#39;s an inline property, we need to make sure it&#39;s a cell before trusting what the structure set tells us.</span>
<span class="line-added">398         if (node-&gt;child1().node() == node-&gt;child2().node() &amp;&amp; !state.forNode(node-&gt;child2()).isType(SpecCell))</span>
<span class="line-added">399             return false;</span>
<span class="line-added">400 </span>
<span class="line-added">401         StorageAccessData&amp; data = node-&gt;storageAccessData();</span>
<span class="line-added">402         auto* uid = graph.identifiers()[data.identifierNumber];</span>
<span class="line-added">403         PropertyOffset desiredOffset = data.offset;</span>
<span class="line-added">404         StructureAbstractValue&amp; value = state.forNode(node-&gt;child2()).m_structure;</span>
<span class="line-added">405         if (value.isInfinite())</span>
<span class="line-added">406             return false;</span>
<span class="line-added">407         for (unsigned i = value.size(); i--;) {</span>
<span class="line-added">408             Structure* thisStructure = value[i].get();</span>
<span class="line-added">409             if (thisStructure-&gt;isUncacheableDictionary())</span>
<span class="line-added">410                 return false;</span>
<span class="line-added">411             unsigned attributes = 0;</span>
<span class="line-added">412             PropertyOffset checkOffset = thisStructure-&gt;getConcurrently(uid, attributes);</span>
<span class="line-added">413             if (checkOffset != desiredOffset || !(attributes &amp; PropertyAttribute::Accessor))</span>
<span class="line-added">414                 return false;</span>
<span class="line-added">415         }</span>
<span class="line-added">416         return true;</span>
<span class="line-added">417     }</span>
<span class="line-added">418 </span>
419     case GetByOffset:

420     case PutByOffset: {
<span class="line-added">421         // If it&#39;s an inline property, we need to make sure it&#39;s a cell before trusting what the structure set tells us.</span>
<span class="line-added">422         if (node-&gt;child1().node() == node-&gt;child2().node() &amp;&amp; !state.forNode(node-&gt;child2()).isType(SpecCell))</span>
<span class="line-added">423             return false;</span>
<span class="line-added">424 </span>
425         StorageAccessData&amp; data = node-&gt;storageAccessData();
426         PropertyOffset offset = data.offset;
427         // Graph::isSafeToLoad() is all about proofs derived from PropertyConditions. Those don&#39;t
428         // know anything about inferred types. But if we have a proof derived from watching a
429         // structure that has a type proof, then the next case below will deal with it.
430         if (state.structureClobberState() == StructuresAreWatched) {
431             if (JSObject* knownBase = node-&gt;child2()-&gt;dynamicCastConstant&lt;JSObject*&gt;(graph.m_vm)) {
432                 if (graph.isSafeToLoad(knownBase, offset))
433                     return true;
434             }
435         }
436 
437         StructureAbstractValue&amp; value = state.forNode(node-&gt;child2()).m_structure;
438         if (value.isInfinite())
439             return false;
440         for (unsigned i = value.size(); i--;) {
441             Structure* thisStructure = value[i].get();
<span class="line-added">442             if (thisStructure-&gt;isUncacheableDictionary())</span>
<span class="line-added">443                 return false;</span>
444             if (!thisStructure-&gt;isValidOffset(offset))
445                 return false;
446         }
447         return true;
448     }
449 
450     case MultiGetByOffset: {
451         // We can&#39;t always guarantee that the MultiGetByOffset is safe to execute if it
452         // contains loads from prototypes. If the load requires a check in IR, which is rare, then
453         // we currently claim that we don&#39;t know if it&#39;s safe to execute because finding that
454         // check in the abstract state would be hard. If the load requires watchpoints, we just
455         // check if we&#39;re not in a clobbered state (i.e. in between a side effect and an
456         // invalidation point).
457         for (const MultiGetByOffsetCase&amp; getCase : node-&gt;multiGetByOffsetData().cases) {
458             GetByOffsetMethod method = getCase.method();
459             switch (method.kind()) {
460             case GetByOffsetMethod::Invalid:
461                 RELEASE_ASSERT_NOT_REACHED();
462                 break;
463             case GetByOffsetMethod::Constant: // OK because constants are always safe to execute.
464             case GetByOffsetMethod::Load: // OK because the MultiGetByOffset has its own checks for loading from self.
465                 break;
466             case GetByOffsetMethod::LoadFromPrototype:
467                 // Only OK if the state isn&#39;t clobbered. That&#39;s almost always the case.
468                 if (state.structureClobberState() != StructuresAreWatched)
469                     return false;
470                 if (!graph.isSafeToLoad(method.prototype()-&gt;cast&lt;JSObject*&gt;(), method.offset()))
471                     return false;
472                 break;
473             }
474         }
475         return true;
476     }
477 
<span class="line-added">478     case ToThis:</span>
<span class="line-added">479     case CreateThis:</span>
<span class="line-added">480     case CreatePromise:</span>
<span class="line-added">481     case CreateGenerator:</span>
<span class="line-added">482     case CreateAsyncGenerator:</span>
<span class="line-added">483     case ObjectCreate:</span>
<span class="line-added">484     case ObjectKeys:</span>
<span class="line-added">485     case SetLocal:</span>
<span class="line-added">486     case SetCallee:</span>
<span class="line-added">487     case PutStack:</span>
<span class="line-added">488     case KillStack:</span>
<span class="line-added">489     case MovHint:</span>
<span class="line-added">490     case ZombieHint:</span>
<span class="line-added">491     case Upsilon:</span>
<span class="line-added">492     case Phi:</span>
<span class="line-added">493     case Flush:</span>
<span class="line-added">494     case SetArgumentDefinitely:</span>
<span class="line-added">495     case SetArgumentMaybe:</span>
<span class="line-added">496     case SetArgumentCountIncludingThis:</span>
<span class="line-added">497     case PhantomLocal:</span>
<span class="line-added">498     case DeleteById:</span>
<span class="line-added">499     case DeleteByVal:</span>
<span class="line-added">500     case GetById:</span>
<span class="line-added">501     case GetByIdWithThis:</span>
<span class="line-added">502     case GetByValWithThis:</span>
<span class="line-added">503     case GetByIdFlush:</span>
<span class="line-added">504     case GetByIdDirect:</span>
<span class="line-added">505     case GetByIdDirectFlush:</span>
<span class="line-added">506     case PutById:</span>
<span class="line-added">507     case PutByIdFlush:</span>
<span class="line-added">508     case PutByIdWithThis:</span>
<span class="line-added">509     case PutByValWithThis:</span>
<span class="line-added">510     case PutByIdDirect:</span>
<span class="line-added">511     case PutGetterById:</span>
<span class="line-added">512     case PutSetterById:</span>
<span class="line-added">513     case PutGetterSetterById:</span>
<span class="line-added">514     case PutGetterByVal:</span>
<span class="line-added">515     case PutSetterByVal:</span>
<span class="line-added">516     case DefineDataProperty:</span>
<span class="line-added">517     case DefineAccessorProperty:</span>
<span class="line-added">518     case Arrayify:</span>
<span class="line-added">519     case ArrayifyToStructure:</span>
<span class="line-added">520     case PutClosureVar:</span>
<span class="line-added">521     case PutGlobalVariable:</span>
<span class="line-added">522     case CheckBadCell:</span>
<span class="line-added">523     case RegExpExec:</span>
<span class="line-added">524     case RegExpExecNonGlobalOrSticky:</span>
<span class="line-added">525     case RegExpTest:</span>
<span class="line-added">526     case RegExpMatchFast:</span>
<span class="line-added">527     case RegExpMatchFastGlobal:</span>
<span class="line-added">528     case Call:</span>
<span class="line-added">529     case DirectCall:</span>
<span class="line-added">530     case TailCallInlinedCaller:</span>
<span class="line-added">531     case DirectTailCallInlinedCaller:</span>
<span class="line-added">532     case Construct:</span>
<span class="line-added">533     case DirectConstruct:</span>
<span class="line-added">534     case CallVarargs:</span>
<span class="line-added">535     case CallEval:</span>
<span class="line-added">536     case TailCallVarargsInlinedCaller:</span>
<span class="line-added">537     case TailCallForwardVarargsInlinedCaller:</span>
<span class="line-added">538     case ConstructVarargs:</span>
<span class="line-added">539     case VarargsLength:</span>
<span class="line-added">540     case LoadVarargs:</span>
<span class="line-added">541     case CallForwardVarargs:</span>
<span class="line-added">542     case ConstructForwardVarargs:</span>
<span class="line-added">543     case NewObject:</span>
<span class="line-added">544     case NewPromise:</span>
<span class="line-added">545     case NewGenerator:</span>
<span class="line-added">546     case NewAsyncGenerator:</span>
<span class="line-added">547     case NewArray:</span>
<span class="line-added">548     case NewArrayWithSize:</span>
<span class="line-added">549     case NewArrayBuffer:</span>
<span class="line-added">550     case NewArrayWithSpread:</span>
<span class="line-added">551     case NewArrayIterator:</span>
<span class="line-added">552     case Spread:</span>
<span class="line-added">553     case NewRegexp:</span>
<span class="line-added">554     case NewSymbol:</span>
<span class="line-added">555     case ProfileType:</span>
<span class="line-added">556     case ProfileControlFlow:</span>
<span class="line-added">557     case InstanceOf:</span>
<span class="line-added">558     case InstanceOfCustom:</span>
<span class="line-added">559     case CallObjectConstructor:</span>
<span class="line-added">560     case ToPrimitive:</span>
<span class="line-added">561     case ToPropertyKey:</span>
<span class="line-added">562     case ToNumber:</span>
<span class="line-added">563     case ToNumeric:</span>
<span class="line-added">564     case ToObject:</span>
<span class="line-added">565     case NumberToStringWithRadix:</span>
<span class="line-added">566     case SetFunctionName:</span>
<span class="line-added">567     case NewStringObject:</span>
<span class="line-added">568     case InByVal:</span>
<span class="line-added">569     case InById:</span>
<span class="line-added">570     case HasOwnProperty:</span>
<span class="line-added">571     case PushWithScope:</span>
<span class="line-added">572     case CreateActivation:</span>
<span class="line-added">573     case CreateDirectArguments:</span>
<span class="line-added">574     case CreateScopedArguments:</span>
<span class="line-added">575     case CreateClonedArguments:</span>
<span class="line-added">576     case CreateArgumentsButterfly:</span>
<span class="line-added">577     case PutToArguments:</span>
<span class="line-added">578     case NewFunction:</span>
<span class="line-added">579     case NewGeneratorFunction:</span>
<span class="line-added">580     case NewAsyncGeneratorFunction:</span>
<span class="line-added">581     case NewAsyncFunction:</span>
<span class="line-added">582     case Jump:</span>
<span class="line-added">583     case Branch:</span>
<span class="line-added">584     case Switch:</span>
<span class="line-added">585     case EntrySwitch:</span>
<span class="line-added">586     case Return:</span>
<span class="line-added">587     case TailCall:</span>
<span class="line-added">588     case DirectTailCall:</span>
<span class="line-added">589     case TailCallVarargs:</span>
<span class="line-added">590     case TailCallForwardVarargs:</span>
<span class="line-added">591     case Throw:</span>
<span class="line-added">592     case ThrowStaticError:</span>
<span class="line-added">593     case CountExecution:</span>
<span class="line-added">594     case SuperSamplerBegin:</span>
<span class="line-added">595     case SuperSamplerEnd:</span>
<span class="line-added">596     case ForceOSRExit:</span>
<span class="line-added">597     case CPUIntrinsic:</span>
<span class="line-added">598     case CheckTraps:</span>
<span class="line-added">599     case LogShadowChickenPrologue:</span>
<span class="line-added">600     case LogShadowChickenTail:</span>
<span class="line-added">601     case NewTypedArray:</span>
<span class="line-added">602     case Unreachable:</span>
<span class="line-added">603     case ClearCatchLocals:</span>
<span class="line-added">604     case CheckTierUpInLoop:</span>
<span class="line-added">605     case CheckTierUpAtReturn:</span>
<span class="line-added">606     case CheckTierUpAndOSREnter:</span>
<span class="line-added">607     case LoopHint:</span>
<span class="line-added">608     case InvalidationPoint:</span>
<span class="line-added">609     case NotifyWrite:</span>
<span class="line-added">610     case MultiPutByOffset:</span>
<span class="line-added">611     case GetEnumerableLength:</span>
<span class="line-added">612     case HasGenericProperty:</span>
<span class="line-added">613     case HasStructureProperty:</span>
<span class="line-added">614     case GetDirectPname:</span>
<span class="line-added">615     case GetPropertyEnumerator:</span>
<span class="line-added">616     case PhantomNewObject:</span>
<span class="line-added">617     case PhantomNewFunction:</span>
<span class="line-added">618     case PhantomNewGeneratorFunction:</span>
<span class="line-added">619     case PhantomNewAsyncGeneratorFunction:</span>
<span class="line-added">620     case PhantomNewAsyncFunction:</span>
<span class="line-added">621     case PhantomNewArrayIterator:</span>
<span class="line-added">622     case PhantomCreateActivation:</span>
<span class="line-added">623     case PhantomNewRegexp:</span>
<span class="line-added">624     case PutHint:</span>
<span class="line-added">625     case MaterializeNewObject:</span>
<span class="line-added">626     case MaterializeCreateActivation:</span>
<span class="line-added">627     case MaterializeNewInternalFieldObject:</span>
<span class="line-added">628     case PhantomDirectArguments:</span>
<span class="line-added">629     case PhantomCreateRest:</span>
<span class="line-added">630     case PhantomSpread:</span>
<span class="line-added">631     case PhantomNewArrayWithSpread:</span>
<span class="line-added">632     case PhantomNewArrayBuffer:</span>
<span class="line-added">633     case PhantomClonedArguments:</span>
<span class="line-added">634     case ForwardVarargs:</span>
<span class="line-added">635     case CreateRest:</span>
<span class="line-added">636     case SetRegExpObjectLastIndex:</span>
<span class="line-added">637     case RecordRegExpCachedResult:</span>
<span class="line-added">638     case GetDynamicVar:</span>
<span class="line-added">639     case PutDynamicVar:</span>
<span class="line-added">640     case ResolveScopeForHoistingFuncDeclInEval:</span>
<span class="line-added">641     case ResolveScope:</span>
<span class="line-added">642     case StringValueOf:</span>
<span class="line-added">643     case WeakSetAdd:</span>
<span class="line-added">644     case WeakMapSet:</span>
<span class="line-added">645     case AtomicsAdd:</span>
<span class="line-added">646     case AtomicsAnd:</span>
<span class="line-added">647     case AtomicsCompareExchange:</span>
<span class="line-added">648     case AtomicsExchange:</span>
<span class="line-added">649     case AtomicsLoad:</span>
<span class="line-added">650     case AtomicsOr:</span>
<span class="line-added">651     case AtomicsStore:</span>
<span class="line-added">652     case AtomicsSub:</span>
<span class="line-added">653     case AtomicsXor:</span>
<span class="line-added">654     case InitializeEntrypointArguments:</span>
<span class="line-added">655     case ValueNegate:</span>
<span class="line-added">656     case GetInternalField:</span>
<span class="line-added">657     case PutInternalField:</span>
658     case DataViewSet:


659     case SetAdd:
660     case MapSet:
661         return false;
662 
<span class="line-added">663     case Inc:</span>
<span class="line-added">664     case Dec:</span>
<span class="line-added">665         return node-&gt;child1().useKind() != UntypedUse;</span>
<span class="line-added">666 </span>
<span class="line-added">667     case ValueBitAnd:</span>
<span class="line-added">668     case ValueBitXor:</span>
<span class="line-added">669     case ValueBitOr:</span>
<span class="line-added">670     case ValueBitLShift:</span>
<span class="line-added">671     case ValueBitRShift:</span>
<span class="line-added">672     case ValueAdd:</span>
<span class="line-added">673     case ValueSub:</span>
<span class="line-added">674     case ValueMul:</span>
<span class="line-added">675     case ValueDiv:</span>
<span class="line-added">676     case ValueMod:</span>
<span class="line-added">677     case ValuePow:</span>
<span class="line-added">678         return node-&gt;isBinaryUseKind(BigIntUse);</span>
<span class="line-added">679 </span>
<span class="line-added">680     case ValueBitNot:</span>
<span class="line-added">681         return node-&gt;child1().useKind() == BigIntUse;</span>
<span class="line-added">682 </span>
683     case LastNodeType:
684         RELEASE_ASSERT_NOT_REACHED();
685         return false;
686     }
687 
688     RELEASE_ASSERT_NOT_REACHED();
689     return false;
690 }
691 
692 } } // namespace JSC::DFG
693 
694 #endif // ENABLE(DFG_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="DFGSSALoweringPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSafepoint.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/StackBounds.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SmallPtrSet.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackBounds.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/StackBounds.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  *  Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.</span>
  3  *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Lesser General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Lesser General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Lesser General Public
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &lt;wtf/StackBounds.h&gt;
</pre>
<hr />
<pre>
 31 #include &lt;pthread.h&gt;
 32 
 33 #elif OS(WINDOWS)
 34 
 35 #include &lt;windows.h&gt;
 36 
 37 #elif OS(UNIX)
 38 
 39 #include &lt;pthread.h&gt;
 40 #if HAVE(PTHREAD_NP_H)
 41 #include &lt;pthread_np.h&gt;
 42 #endif
 43 
 44 #endif
 45 
 46 namespace WTF {
 47 
 48 #if PLATFORM(JAVA)
 49 // 16K is a safe value to guard java stack red zone
 50 #define JAVA_RED_ZONE 0x4000
<span class="line-removed"> 51 #if OS(WINDOWS)</span>
<span class="line-removed"> 52 // This is safe for the default stack sizes in all supported Windows</span>
<span class="line-removed"> 53 // configurations, but is not safe for stack sizes lower than the default.</span>
<span class="line-removed"> 54 #if CPU(X86_64)</span>
<span class="line-removed"> 55 static const ptrdiff_t estimatedStackSize = 1024 * 1024;</span>
<span class="line-removed"> 56 #else</span>
<span class="line-removed"> 57 // estimatedStackSize needs to be a little greater than 256KB to keep</span>
<span class="line-removed"> 58 // Interpreter::StackPolicy::StackPolicy happy and less than 320KB</span>
<span class="line-removed"> 59 // to play safe against the default stack size on 32 bit Windows.</span>
<span class="line-removed"> 60 static const ptrdiff_t estimatedStackSize = 272 * 1024;</span>
<span class="line-removed"> 61 #endif</span>
<span class="line-removed"> 62 #endif</span>
<span class="line-removed"> 63 #endif</span>
<span class="line-removed"> 64 </span>
<span class="line-removed"> 65 #if CPU(X86) || CPU(X86_64) || CPU(ARM) || CPU(ARM64) || CPU(MIPS)</span>
<span class="line-removed"> 66 ALWAYS_INLINE StackBounds::StackDirection StackBounds::stackDirection()</span>
<span class="line-removed"> 67 {</span>
<span class="line-removed"> 68     return StackDirection::Downward;</span>
<span class="line-removed"> 69 }</span>
<span class="line-removed"> 70 #else</span>
<span class="line-removed"> 71 static NEVER_INLINE NOT_TAIL_CALLED StackBounds::StackDirection testStackDirection2(volatile const uint8_t* pointer)</span>
<span class="line-removed"> 72 {</span>
<span class="line-removed"> 73     volatile uint8_t* stackValue = bitwise_cast&lt;uint8_t*&gt;(currentStackPointer());</span>
<span class="line-removed"> 74     return (pointer &lt; stackValue) ? StackBounds::StackDirection::Upward : StackBounds::StackDirection::Downward;</span>
<span class="line-removed"> 75 }</span>
<span class="line-removed"> 76 </span>
<span class="line-removed"> 77 static NEVER_INLINE NOT_TAIL_CALLED StackBounds::StackDirection testStackDirection()</span>
<span class="line-removed"> 78 {</span>
<span class="line-removed"> 79     NO_TAIL_CALLS();</span>
<span class="line-removed"> 80     volatile uint8_t* stackValue = bitwise_cast&lt;uint8_t*&gt;(currentStackPointer());</span>
<span class="line-removed"> 81     return testStackDirection2(stackValue);</span>
<span class="line-removed"> 82 }</span>
<span class="line-removed"> 83 </span>
<span class="line-removed"> 84 NEVER_INLINE StackBounds::StackDirection StackBounds::stackDirection()</span>
<span class="line-removed"> 85 {</span>
<span class="line-removed"> 86     static StackBounds::StackDirection result = StackBounds::StackDirection::Downward;</span>
<span class="line-removed"> 87     static std::once_flag onceKey;</span>
<span class="line-removed"> 88     std::call_once(onceKey, [] {</span>
<span class="line-removed"> 89         NO_TAIL_CALLS();</span>
<span class="line-removed"> 90         result = testStackDirection();</span>
<span class="line-removed"> 91     });</span>
<span class="line-removed"> 92     return result;</span>
<span class="line-removed"> 93 }</span>
 94 #endif
 95 
 96 #if OS(DARWIN)
 97 
 98 StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
 99 {
<span class="line-removed">100     ASSERT(stackDirection() == StackDirection::Downward);</span>
101     void* origin = pthread_get_stackaddr_np(thread);
102     rlim_t size = pthread_get_stacksize_np(thread);
103     void* bound = static_cast&lt;char*&gt;(origin) - size;
104     return StackBounds { origin, bound };
105 }
106 
107 StackBounds StackBounds::currentThreadStackBoundsInternal()
108 {
<span class="line-removed">109     ASSERT(stackDirection() == StackDirection::Downward);</span>
110     if (pthread_main_np()) {
111         // FIXME: &lt;rdar://problem/13741204&gt;
112         // pthread_get_size lies to us when we&#39;re the main thread, use get_rlimit instead
113         void* origin = pthread_get_stackaddr_np(pthread_self());
114         rlimit limit;
115         getrlimit(RLIMIT_STACK, &amp;limit);
116         rlim_t size = limit.rlim_cur;
117         void* bound = static_cast&lt;char*&gt;(origin) - size;
118 #if PLATFORM(JAVA)
119         bound = static_cast&lt;char*&gt;(bound) + JAVA_RED_ZONE;
120 #endif
121         return StackBounds { origin, bound };
122     }
123     return newThreadStackBounds(pthread_self());
124 }
125 
126 #elif OS(UNIX)
127 
128 #if OS(OPENBSD)
129 
130 StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
131 {
132     stack_t stack;
133     pthread_stackseg_np(thread, &amp;stack);
134     void* origin = stack.ss_sp;
<span class="line-modified">135     void* bound = nullptr;</span>
<span class="line-removed">136     if (stackDirection() == StackDirection::Upward)</span>
<span class="line-removed">137         bound = static_cast&lt;char*&gt;(origin) + stack.ss_size;</span>
<span class="line-removed">138     else</span>
<span class="line-removed">139         bound = static_cast&lt;char*&gt;(origin) - stack.ss_size;</span>
140     return StackBounds { origin, bound };
141 }
142 
143 #else // !OS(OPENBSD)
144 
145 StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
146 {
147     void* bound = nullptr;
148     size_t stackSize = 0;
149 
150     pthread_attr_t sattr;
151     pthread_attr_init(&amp;sattr);
152 #if HAVE(PTHREAD_NP_H) || OS(NETBSD)
153     // e.g. on FreeBSD 5.4, neundorf@kde.org
154     pthread_attr_get_np(thread, &amp;sattr);
155 #else
156     // FIXME: this function is non-portable; other POSIX systems may have different np alternatives
157     pthread_getattr_np(thread, &amp;sattr);
158 #endif
159     int rc = pthread_attr_getstack(&amp;sattr, &amp;bound, &amp;stackSize);
160     UNUSED_PARAM(rc);
161     ASSERT(bound);
162     pthread_attr_destroy(&amp;sattr);
163     void* origin = static_cast&lt;char*&gt;(bound) + stackSize;
164 #if PLATFORM(JAVA)
165     bound = static_cast&lt;char*&gt;(bound) + JAVA_RED_ZONE;
166 #endif
167     // pthread_attr_getstack&#39;s bound is the lowest accessible pointer of the stack.
<span class="line-removed">168     // If stack grows up, origin and bound in this code should be swapped.</span>
<span class="line-removed">169     if (stackDirection() == StackDirection::Upward)</span>
<span class="line-removed">170         std::swap(origin, bound);</span>
<span class="line-removed">171 </span>
172     return StackBounds { origin, bound };
173 }
174 
175 #endif // OS(OPENBSD)
176 
177 StackBounds StackBounds::currentThreadStackBoundsInternal()
178 {
179     return newThreadStackBounds(pthread_self());
180 }
181 
182 #elif OS(WINDOWS)
183 
184 StackBounds StackBounds::currentThreadStackBoundsInternal()
185 {
<span class="line-removed">186     ASSERT(stackDirection() == StackDirection::Downward);</span>
187     MEMORY_BASIC_INFORMATION stackOrigin { };
188     VirtualQuery(&amp;stackOrigin, &amp;stackOrigin, sizeof(stackOrigin));
189     // stackOrigin.AllocationBase points to the reserved stack memory base address.
190 

191     void* origin = static_cast&lt;char*&gt;(stackOrigin.BaseAddress) + stackOrigin.RegionSize;

192     // The stack on Windows consists out of three parts (uncommitted memory, a guard page and present
193     // committed memory). The 3 regions have different BaseAddresses but all have the same AllocationBase
194     // since they are all from the same VirtualAlloc. The 3 regions are laid out in memory (from high to
195     // low) as follows:
196     //
197     //    High |-------------------|  -----
198     //         | committedMemory   |    ^
199     //         |-------------------|    |
200     //         | guardPage         | reserved memory for the stack
201     //         |-------------------|    |
202     //         | uncommittedMemory |    v
203     //    Low  |-------------------|  ----- &lt;--- stackOrigin.AllocationBase
204     //
205     // See http://msdn.microsoft.com/en-us/library/ms686774%28VS.85%29.aspx for more information.
206 
<span class="line-removed">207     MEMORY_BASIC_INFORMATION uncommittedMemory;</span>
<span class="line-removed">208 </span>
<span class="line-removed">209 #if PLATFORM(JAVA)</span>
210     // look for uncommited memory block.
<span class="line-modified">211     const LPVOID theAllocBase = stackOrigin.AllocationBase;</span>
212     LPVOID a = stackOrigin.AllocationBase;
213 
214     do {
215         size_t ret = VirtualQuery(a, &amp;uncommittedMemory, sizeof(uncommittedMemory));
216         ASSERT(ret != 0);
217         a = (LPVOID)((static_cast&lt;char*&gt;(a)) + uncommittedMemory.RegionSize);
218     } while (theAllocBase == uncommittedMemory.AllocationBase &amp;&amp;
219         uncommittedMemory.State != MEM_RESERVE);
<span class="line-removed">220 #else</span>
<span class="line-removed">221     VirtualQuery(stackOrigin.AllocationBase, &amp;uncommittedMemory, sizeof(uncommittedMemory));</span>
<span class="line-removed">222     ASSERT(uncommittedMemory.State == MEM_RESERVE);</span>
<span class="line-removed">223 #endif</span>
224 
225     MEMORY_BASIC_INFORMATION guardPage;
226     VirtualQuery(static_cast&lt;char*&gt;(uncommittedMemory.BaseAddress) + uncommittedMemory.RegionSize, &amp;guardPage, sizeof(guardPage));
227     ASSERT(guardPage.Protect &amp; PAGE_GUARD);
228 
229     void* endOfStack = stackOrigin.AllocationBase;
230 
231 #ifndef NDEBUG
232     MEMORY_BASIC_INFORMATION committedMemory;
233     VirtualQuery(static_cast&lt;char*&gt;(guardPage.BaseAddress) + guardPage.RegionSize, &amp;committedMemory, sizeof(committedMemory));
234     ASSERT(committedMemory.State == MEM_COMMIT);
235 
236     void* computedEnd = static_cast&lt;char*&gt;(origin) - (uncommittedMemory.RegionSize + guardPage.RegionSize + committedMemory.RegionSize);
237 
238     ASSERT(stackOrigin.AllocationBase == uncommittedMemory.AllocationBase);
239     ASSERT(stackOrigin.AllocationBase == guardPage.AllocationBase);
240     ASSERT(stackOrigin.AllocationBase == committedMemory.AllocationBase);
241 #if !PLATFORM(JAVA)
242     ASSERT(stackOrigin.AllocationBase == uncommittedMemory.BaseAddress);
243     ASSERT(endOfStack == computedEnd);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
  3  *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Lesser General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Lesser General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Lesser General Public
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &lt;wtf/StackBounds.h&gt;
</pre>
<hr />
<pre>
 31 #include &lt;pthread.h&gt;
 32 
 33 #elif OS(WINDOWS)
 34 
 35 #include &lt;windows.h&gt;
 36 
 37 #elif OS(UNIX)
 38 
 39 #include &lt;pthread.h&gt;
 40 #if HAVE(PTHREAD_NP_H)
 41 #include &lt;pthread_np.h&gt;
 42 #endif
 43 
 44 #endif
 45 
 46 namespace WTF {
 47 
 48 #if PLATFORM(JAVA)
 49 // 16K is a safe value to guard java stack red zone
 50 #define JAVA_RED_ZONE 0x4000











































 51 #endif
 52 
 53 #if OS(DARWIN)
 54 
 55 StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
 56 {

 57     void* origin = pthread_get_stackaddr_np(thread);
 58     rlim_t size = pthread_get_stacksize_np(thread);
 59     void* bound = static_cast&lt;char*&gt;(origin) - size;
 60     return StackBounds { origin, bound };
 61 }
 62 
 63 StackBounds StackBounds::currentThreadStackBoundsInternal()
 64 {

 65     if (pthread_main_np()) {
 66         // FIXME: &lt;rdar://problem/13741204&gt;
 67         // pthread_get_size lies to us when we&#39;re the main thread, use get_rlimit instead
 68         void* origin = pthread_get_stackaddr_np(pthread_self());
 69         rlimit limit;
 70         getrlimit(RLIMIT_STACK, &amp;limit);
 71         rlim_t size = limit.rlim_cur;
 72         void* bound = static_cast&lt;char*&gt;(origin) - size;
 73 #if PLATFORM(JAVA)
 74         bound = static_cast&lt;char*&gt;(bound) + JAVA_RED_ZONE;
 75 #endif
 76         return StackBounds { origin, bound };
 77     }
 78     return newThreadStackBounds(pthread_self());
 79 }
 80 
 81 #elif OS(UNIX)
 82 
 83 #if OS(OPENBSD)
 84 
 85 StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
 86 {
 87     stack_t stack;
 88     pthread_stackseg_np(thread, &amp;stack);
 89     void* origin = stack.ss_sp;
<span class="line-modified"> 90     void* bound = static_cast&lt;char*&gt;(origin) - stack.ss_size;</span>




 91     return StackBounds { origin, bound };
 92 }
 93 
 94 #else // !OS(OPENBSD)
 95 
 96 StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
 97 {
 98     void* bound = nullptr;
 99     size_t stackSize = 0;
100 
101     pthread_attr_t sattr;
102     pthread_attr_init(&amp;sattr);
103 #if HAVE(PTHREAD_NP_H) || OS(NETBSD)
104     // e.g. on FreeBSD 5.4, neundorf@kde.org
105     pthread_attr_get_np(thread, &amp;sattr);
106 #else
107     // FIXME: this function is non-portable; other POSIX systems may have different np alternatives
108     pthread_getattr_np(thread, &amp;sattr);
109 #endif
110     int rc = pthread_attr_getstack(&amp;sattr, &amp;bound, &amp;stackSize);
111     UNUSED_PARAM(rc);
112     ASSERT(bound);
113     pthread_attr_destroy(&amp;sattr);
114     void* origin = static_cast&lt;char*&gt;(bound) + stackSize;
115 #if PLATFORM(JAVA)
116     bound = static_cast&lt;char*&gt;(bound) + JAVA_RED_ZONE;
117 #endif
118     // pthread_attr_getstack&#39;s bound is the lowest accessible pointer of the stack.




119     return StackBounds { origin, bound };
120 }
121 
122 #endif // OS(OPENBSD)
123 
124 StackBounds StackBounds::currentThreadStackBoundsInternal()
125 {
126     return newThreadStackBounds(pthread_self());
127 }
128 
129 #elif OS(WINDOWS)
130 
131 StackBounds StackBounds::currentThreadStackBoundsInternal()
132 {

133     MEMORY_BASIC_INFORMATION stackOrigin { };
134     VirtualQuery(&amp;stackOrigin, &amp;stackOrigin, sizeof(stackOrigin));
135     // stackOrigin.AllocationBase points to the reserved stack memory base address.
136 
<span class="line-added">137     const LPVOID theAllocBase = stackOrigin.AllocationBase;</span>
138     void* origin = static_cast&lt;char*&gt;(stackOrigin.BaseAddress) + stackOrigin.RegionSize;
<span class="line-added">139 </span>
140     // The stack on Windows consists out of three parts (uncommitted memory, a guard page and present
141     // committed memory). The 3 regions have different BaseAddresses but all have the same AllocationBase
142     // since they are all from the same VirtualAlloc. The 3 regions are laid out in memory (from high to
143     // low) as follows:
144     //
145     //    High |-------------------|  -----
146     //         | committedMemory   |    ^
147     //         |-------------------|    |
148     //         | guardPage         | reserved memory for the stack
149     //         |-------------------|    |
150     //         | uncommittedMemory |    v
151     //    Low  |-------------------|  ----- &lt;--- stackOrigin.AllocationBase
152     //
153     // See http://msdn.microsoft.com/en-us/library/ms686774%28VS.85%29.aspx for more information.
154 



155     // look for uncommited memory block.
<span class="line-modified">156     MEMORY_BASIC_INFORMATION uncommittedMemory;</span>
157     LPVOID a = stackOrigin.AllocationBase;
158 
159     do {
160         size_t ret = VirtualQuery(a, &amp;uncommittedMemory, sizeof(uncommittedMemory));
161         ASSERT(ret != 0);
162         a = (LPVOID)((static_cast&lt;char*&gt;(a)) + uncommittedMemory.RegionSize);
163     } while (theAllocBase == uncommittedMemory.AllocationBase &amp;&amp;
164         uncommittedMemory.State != MEM_RESERVE);




165 
166     MEMORY_BASIC_INFORMATION guardPage;
167     VirtualQuery(static_cast&lt;char*&gt;(uncommittedMemory.BaseAddress) + uncommittedMemory.RegionSize, &amp;guardPage, sizeof(guardPage));
168     ASSERT(guardPage.Protect &amp; PAGE_GUARD);
169 
170     void* endOfStack = stackOrigin.AllocationBase;
171 
172 #ifndef NDEBUG
173     MEMORY_BASIC_INFORMATION committedMemory;
174     VirtualQuery(static_cast&lt;char*&gt;(guardPage.BaseAddress) + guardPage.RegionSize, &amp;committedMemory, sizeof(committedMemory));
175     ASSERT(committedMemory.State == MEM_COMMIT);
176 
177     void* computedEnd = static_cast&lt;char*&gt;(origin) - (uncommittedMemory.RegionSize + guardPage.RegionSize + committedMemory.RegionSize);
178 
179     ASSERT(stackOrigin.AllocationBase == uncommittedMemory.AllocationBase);
180     ASSERT(stackOrigin.AllocationBase == guardPage.AllocationBase);
181     ASSERT(stackOrigin.AllocationBase == committedMemory.AllocationBase);
182 #if !PLATFORM(JAVA)
183     ASSERT(stackOrigin.AllocationBase == uncommittedMemory.BaseAddress);
184     ASSERT(endOfStack == computedEnd);
</pre>
</td>
</tr>
</table>
<center><a href="SmallPtrSet.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackBounds.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
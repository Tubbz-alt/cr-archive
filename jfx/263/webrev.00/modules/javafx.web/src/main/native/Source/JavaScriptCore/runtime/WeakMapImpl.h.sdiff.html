<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/WeakMapImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WeakMapConstructor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WeakMapPrototype.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/WeakMapImpl.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
175     ALWAYS_INLINE BucketType* buffer() const
176     {
177         return bitwise_cast&lt;BucketType*&gt;(this);
178     }
179 
180     static MallocPtr&lt;WeakMapBuffer, JSValueMalloc&gt; create(uint32_t capacity)
181     {
182         size_t allocationSize = WeakMapBuffer::allocationSize(capacity);
183         auto buffer = MallocPtr&lt;WeakMapBuffer, JSValueMalloc&gt;::malloc(allocationSize);
184         buffer-&gt;reset(capacity);
185         return buffer;
186     }
187 
188     ALWAYS_INLINE void reset(uint32_t capacity)
189     {
190         memset(this, 0, allocationSize(capacity));
191     }
192 };
193 
194 template &lt;typename WeakMapBucketType&gt;
<span class="line-modified">195 class WeakMapImpl : public JSDestructibleObject {</span>
<span class="line-modified">196     using Base = JSDestructibleObject;</span>
197     using WeakMapBufferType = WeakMapBuffer&lt;WeakMapBucketType&gt;;
198 
199 public:
200     using BucketType = WeakMapBucketType;
201 

202     static void destroy(JSCell*);
203 
204     static void visitChildren(JSCell*, SlotVisitor&amp;);
205 
206     static size_t estimatedSize(JSCell*, VM&amp;);
207 
208     WeakMapImpl(VM&amp; vm, Structure* structure)
209         : Base(vm, structure)
210     {
211     }
212 
213     static constexpr uint32_t initialCapacity = 4;
214 
215     void finishCreation(VM&amp; vm)
216     {
217         ASSERT_WITH_MESSAGE(WeakMapBucket&lt;WeakMapBucketDataKey&gt;::offsetOfKey() == WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfKey(), &quot;We assume this to be true in the DFG and FTL JIT.&quot;);
218 
219         Base::finishCreation(vm);
220 
221         auto locker = holdLock(cellLock());
</pre>
<hr />
<pre>
288     }
289 
290     static ptrdiff_t offsetOfCapacity()
291     {
292         return OBJECT_OFFSETOF(WeakMapImpl&lt;WeakMapBucketType&gt;, m_capacity);
293     }
294 
295     static constexpr bool isWeakMap()
296     {
297         return std::is_same&lt;WeakMapBucketType, JSC::WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;&gt;::value;
298     }
299 
300     static constexpr bool isWeakSet()
301     {
302         return std::is_same&lt;WeakMapBucketType, JSC::WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::value;
303     }
304 
305     template&lt;typename CellType, SubspaceAccess mode&gt;
306     static IsoSubspace* subspaceFor(VM&amp; vm)
307     {
<span class="line-modified">308         if (isWeakMap())</span>
309             return vm.weakMapSpace&lt;mode&gt;();
310         return vm.weakSetSpace&lt;mode&gt;();
311     }
312 
313     static void visitOutputConstraints(JSCell*, SlotVisitor&amp;);
314     void finalizeUnconditionally(VM&amp;);
315 
316 private:
317     ALWAYS_INLINE WeakMapBucketType* findBucket(JSObject* key)
318     {
319         return findBucket(key, jsWeakMapHash(key));
320     }
321 
322     ALWAYS_INLINE WeakMapBucketType* findBucket(JSObject* key, uint32_t hash)
323     {
324         return findBucketAlreadyHashed(key, hash);
325     }
326 
327     ALWAYS_INLINE WeakMapBucketType* buffer() const
328     {
</pre>
<hr />
<pre>
426             auto* entry = oldBuffer-&gt;buffer() + oldIndex;
427             if (entry-&gt;isEmpty() || entry-&gt;isDeleted())
428                 continue;
429 
430             uint32_t index = jsWeakMapHash(entry-&gt;key()) &amp; mask;
431             WeakMapBucketType* bucket = buffer + index;
432             while (!bucket-&gt;isEmpty()) {
433                 index = (index + 1) &amp; mask;
434                 bucket = buffer + index;
435             }
436             bucket-&gt;copyFrom(*entry);
437         }
438 
439         m_deleteCount = 0;
440 
441         checkConsistency();
442     }
443 
444     ALWAYS_INLINE void checkConsistency() const
445     {
<span class="line-modified">446         if (!ASSERT_DISABLED) {</span>
447             uint32_t size = 0;
448             auto* buffer = this-&gt;buffer();
449             for (uint32_t index = 0; index &lt; m_capacity; ++index) {
450                 auto* bucket = buffer + index;
451                 if (bucket-&gt;isEmpty() || bucket-&gt;isDeleted())
452                     continue;
453                 ++size;
454             }
455             ASSERT(size == m_keyCount);
456         }
457     }
458 
459     void makeAndSetNewBuffer(const AbstractLocker&amp;, uint32_t capacity)
460     {
461         ASSERT(!(capacity &amp; (capacity - 1)));
462 
463         m_buffer = WeakMapBufferType::create(capacity);
464         m_capacity = capacity;
465         ASSERT(m_buffer);
466         assertBufferIsEmpty();
467     }
468 
469     ALWAYS_INLINE void assertBufferIsEmpty() const
470     {
<span class="line-modified">471         if (!ASSERT_DISABLED) {</span>
472             for (unsigned i = 0; i &lt; m_capacity; i++)
473                 ASSERT((buffer() + i)-&gt;isEmpty());
474         }
475     }
476 
477     template&lt;typename Appender&gt;
478     void takeSnapshotInternal(unsigned limit, Appender);
479 
480     MallocPtr&lt;WeakMapBufferType, JSValueMalloc&gt; m_buffer;
481     uint32_t m_capacity { 0 };
482     uint32_t m_keyCount { 0 };
483     uint32_t m_deleteCount { 0 };
484 };
485 
486 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
175     ALWAYS_INLINE BucketType* buffer() const
176     {
177         return bitwise_cast&lt;BucketType*&gt;(this);
178     }
179 
180     static MallocPtr&lt;WeakMapBuffer, JSValueMalloc&gt; create(uint32_t capacity)
181     {
182         size_t allocationSize = WeakMapBuffer::allocationSize(capacity);
183         auto buffer = MallocPtr&lt;WeakMapBuffer, JSValueMalloc&gt;::malloc(allocationSize);
184         buffer-&gt;reset(capacity);
185         return buffer;
186     }
187 
188     ALWAYS_INLINE void reset(uint32_t capacity)
189     {
190         memset(this, 0, allocationSize(capacity));
191     }
192 };
193 
194 template &lt;typename WeakMapBucketType&gt;
<span class="line-modified">195 class WeakMapImpl : public JSNonFinalObject {</span>
<span class="line-modified">196     using Base = JSNonFinalObject;</span>
197     using WeakMapBufferType = WeakMapBuffer&lt;WeakMapBucketType&gt;;
198 
199 public:
200     using BucketType = WeakMapBucketType;
201 
<span class="line-added">202     static constexpr bool needsDestruction = true;</span>
203     static void destroy(JSCell*);
204 
205     static void visitChildren(JSCell*, SlotVisitor&amp;);
206 
207     static size_t estimatedSize(JSCell*, VM&amp;);
208 
209     WeakMapImpl(VM&amp; vm, Structure* structure)
210         : Base(vm, structure)
211     {
212     }
213 
214     static constexpr uint32_t initialCapacity = 4;
215 
216     void finishCreation(VM&amp; vm)
217     {
218         ASSERT_WITH_MESSAGE(WeakMapBucket&lt;WeakMapBucketDataKey&gt;::offsetOfKey() == WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfKey(), &quot;We assume this to be true in the DFG and FTL JIT.&quot;);
219 
220         Base::finishCreation(vm);
221 
222         auto locker = holdLock(cellLock());
</pre>
<hr />
<pre>
289     }
290 
291     static ptrdiff_t offsetOfCapacity()
292     {
293         return OBJECT_OFFSETOF(WeakMapImpl&lt;WeakMapBucketType&gt;, m_capacity);
294     }
295 
296     static constexpr bool isWeakMap()
297     {
298         return std::is_same&lt;WeakMapBucketType, JSC::WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;&gt;::value;
299     }
300 
301     static constexpr bool isWeakSet()
302     {
303         return std::is_same&lt;WeakMapBucketType, JSC::WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::value;
304     }
305 
306     template&lt;typename CellType, SubspaceAccess mode&gt;
307     static IsoSubspace* subspaceFor(VM&amp; vm)
308     {
<span class="line-modified">309         if constexpr (isWeakMap())</span>
310             return vm.weakMapSpace&lt;mode&gt;();
311         return vm.weakSetSpace&lt;mode&gt;();
312     }
313 
314     static void visitOutputConstraints(JSCell*, SlotVisitor&amp;);
315     void finalizeUnconditionally(VM&amp;);
316 
317 private:
318     ALWAYS_INLINE WeakMapBucketType* findBucket(JSObject* key)
319     {
320         return findBucket(key, jsWeakMapHash(key));
321     }
322 
323     ALWAYS_INLINE WeakMapBucketType* findBucket(JSObject* key, uint32_t hash)
324     {
325         return findBucketAlreadyHashed(key, hash);
326     }
327 
328     ALWAYS_INLINE WeakMapBucketType* buffer() const
329     {
</pre>
<hr />
<pre>
427             auto* entry = oldBuffer-&gt;buffer() + oldIndex;
428             if (entry-&gt;isEmpty() || entry-&gt;isDeleted())
429                 continue;
430 
431             uint32_t index = jsWeakMapHash(entry-&gt;key()) &amp; mask;
432             WeakMapBucketType* bucket = buffer + index;
433             while (!bucket-&gt;isEmpty()) {
434                 index = (index + 1) &amp; mask;
435                 bucket = buffer + index;
436             }
437             bucket-&gt;copyFrom(*entry);
438         }
439 
440         m_deleteCount = 0;
441 
442         checkConsistency();
443     }
444 
445     ALWAYS_INLINE void checkConsistency() const
446     {
<span class="line-modified">447         if (ASSERT_ENABLED) {</span>
448             uint32_t size = 0;
449             auto* buffer = this-&gt;buffer();
450             for (uint32_t index = 0; index &lt; m_capacity; ++index) {
451                 auto* bucket = buffer + index;
452                 if (bucket-&gt;isEmpty() || bucket-&gt;isDeleted())
453                     continue;
454                 ++size;
455             }
456             ASSERT(size == m_keyCount);
457         }
458     }
459 
460     void makeAndSetNewBuffer(const AbstractLocker&amp;, uint32_t capacity)
461     {
462         ASSERT(!(capacity &amp; (capacity - 1)));
463 
464         m_buffer = WeakMapBufferType::create(capacity);
465         m_capacity = capacity;
466         ASSERT(m_buffer);
467         assertBufferIsEmpty();
468     }
469 
470     ALWAYS_INLINE void assertBufferIsEmpty() const
471     {
<span class="line-modified">472         if (ASSERT_ENABLED) {</span>
473             for (unsigned i = 0; i &lt; m_capacity; i++)
474                 ASSERT((buffer() + i)-&gt;isEmpty());
475         }
476     }
477 
478     template&lt;typename Appender&gt;
479     void takeSnapshotInternal(unsigned limit, Appender);
480 
481     MallocPtr&lt;WeakMapBufferType, JSValueMalloc&gt; m_buffer;
482     uint32_t m_capacity { 0 };
483     uint32_t m_keyCount { 0 };
484     uint32_t m_deleteCount { 0 };
485 };
486 
487 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="WeakMapConstructor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WeakMapPrototype.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
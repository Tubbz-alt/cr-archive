<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TypedArrayController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VM.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;VM.h&quot;
  31 
  32 #include &quot;ArgList.h&quot;
<span class="line-modified">  33 #include &quot;ArrayBufferNeuteringWatchpointSet.h&quot;</span>

  34 #include &quot;BuiltinExecutables.h&quot;
  35 #include &quot;BytecodeIntrinsicRegistry.h&quot;


  36 #include &quot;CodeBlock.h&quot;
  37 #include &quot;CodeCache.h&quot;
  38 #include &quot;CommonIdentifiers.h&quot;
  39 #include &quot;CommonSlowPaths.h&quot;
  40 #include &quot;CustomGetterSetter.h&quot;
  41 #include &quot;DFGWorklist.h&quot;



  42 #include &quot;DirectEvalExecutable.h&quot;
  43 #include &quot;Disassembler.h&quot;
  44 #include &quot;DoublePredictionFuzzerAgent.h&quot;
  45 #include &quot;Error.h&quot;
  46 #include &quot;ErrorConstructor.h&quot;
  47 #include &quot;ErrorInstance.h&quot;
  48 #include &quot;EvalCodeBlock.h&quot;
  49 #include &quot;Exception.h&quot;
  50 #include &quot;ExecutableToCodeBlockEdge.h&quot;
  51 #include &quot;FTLThunks.h&quot;
  52 #include &quot;FastMallocAlignedMemoryAllocator.h&quot;

  53 #include &quot;FunctionCodeBlock.h&quot;
  54 #include &quot;FunctionConstructor.h&quot;
  55 #include &quot;FunctionExecutable.h&quot;
  56 #include &quot;GCActivityCallback.h&quot;
  57 #include &quot;GetterSetter.h&quot;
  58 #include &quot;GigacageAlignedMemoryAllocator.h&quot;
  59 #include &quot;HasOwnPropertyCache.h&quot;
  60 #include &quot;Heap.h&quot;
  61 #include &quot;HeapIterationScope.h&quot;
  62 #include &quot;HeapProfiler.h&quot;
  63 #include &quot;HostCallReturnValue.h&quot;
  64 #include &quot;Identifier.h&quot;
  65 #include &quot;IncrementalSweeper.h&quot;
  66 #include &quot;IndirectEvalExecutable.h&quot;
  67 #include &quot;Interpreter.h&quot;
  68 #include &quot;IntlCollatorConstructor.h&quot;
  69 #include &quot;IntlDateTimeFormatConstructor.h&quot;
  70 #include &quot;IntlNumberFormatConstructor.h&quot;
  71 #include &quot;IntlPluralRulesConstructor.h&quot;


  72 #include &quot;JITCode.h&quot;
  73 #include &quot;JITWorklist.h&quot;

  74 #include &quot;JSAPIValueWrapper.h&quot;

  75 #include &quot;JSArray.h&quot;

  76 #include &quot;JSArrayBufferConstructor.h&quot;

  77 #include &quot;JSAsyncFunction.h&quot;

  78 #include &quot;JSBigInt.h&quot;
  79 #include &quot;JSBoundFunction.h&quot;
  80 #include &quot;JSCInlines.h&quot;

  81 #include &quot;JSCallbackFunction.h&quot;


  82 #include &quot;JSCustomGetterSetterFunction.h&quot;
  83 #include &quot;JSDestructibleObjectHeapCellType.h&quot;
<span class="line-removed">  84 #include &quot;JSFixedArray.h&quot;</span>
  85 #include &quot;JSFunction.h&quot;


  86 #include &quot;JSGlobalObjectFunctions.h&quot;
  87 #include &quot;JSImmutableButterfly.h&quot;
<span class="line-modified">  88 #include &quot;JSInternalPromiseDeferred.h&quot;</span>
  89 #include &quot;JSLock.h&quot;
  90 #include &quot;JSMap.h&quot;
  91 #include &quot;JSMapIterator.h&quot;
<span class="line-modified">  92 #include &quot;JSPromiseDeferred.h&quot;</span>



  93 #include &quot;JSPropertyNameEnumerator.h&quot;

  94 #include &quot;JSScriptFetchParameters.h&quot;
  95 #include &quot;JSScriptFetcher.h&quot;
  96 #include &quot;JSSet.h&quot;
  97 #include &quot;JSSetIterator.h&quot;
  98 #include &quot;JSSourceCode.h&quot;
<span class="line-modified">  99 #include &quot;JSStringHeapCellType.h&quot;</span>
 100 #include &quot;JSTemplateObjectDescriptor.h&quot;


 101 #include &quot;JSWeakMap.h&quot;
 102 #include &quot;JSWeakObjectRef.h&quot;
 103 #include &quot;JSWeakSet.h&quot;
 104 #include &quot;JSWebAssembly.h&quot;
 105 #include &quot;JSWebAssemblyCodeBlock.h&quot;
<span class="line-modified"> 106 #include &quot;JSWebAssemblyCodeBlockHeapCellType.h&quot;</span>




 107 #include &quot;JSWithScope.h&quot;
 108 #include &quot;LLIntData.h&quot;
 109 #include &quot;Lexer.h&quot;
 110 #include &quot;Lookup.h&quot;
 111 #include &quot;MinimumReservedZoneSize.h&quot;
 112 #include &quot;ModuleProgramCodeBlock.h&quot;
 113 #include &quot;ModuleProgramExecutable.h&quot;

 114 #include &quot;NativeErrorConstructor.h&quot;
 115 #include &quot;NativeExecutable.h&quot;
<span class="line-removed"> 116 #include &quot;NativeStdFunctionCell.h&quot;</span>
 117 #include &quot;Nodes.h&quot;
<span class="line-modified"> 118 #include &quot;ObjCCallbackFunction.h&quot;</span>
 119 #include &quot;Parser.h&quot;

 120 #include &quot;ProfilerDatabase.h&quot;
 121 #include &quot;ProgramCodeBlock.h&quot;
 122 #include &quot;ProgramExecutable.h&quot;
<span class="line-modified"> 123 #include &quot;PromiseDeferredTimer.h&quot;</span>
 124 #include &quot;PropertyMapHashTable.h&quot;
 125 #include &quot;ProxyRevoke.h&quot;
 126 #include &quot;RandomizingFuzzerAgent.h&quot;
 127 #include &quot;RegExpCache.h&quot;
 128 #include &quot;RegExpObject.h&quot;
 129 #include &quot;RegisterAtOffsetList.h&quot;
 130 #include &quot;RuntimeType.h&quot;
 131 #include &quot;SamplingProfiler.h&quot;

 132 #include &quot;ShadowChicken.h&quot;
 133 #include &quot;SimpleTypedArrayController.h&quot;
 134 #include &quot;SourceProviderCache.h&quot;
 135 #include &quot;StackVisitor.h&quot;
 136 #include &quot;StrictEvalActivation.h&quot;

 137 #include &quot;StrongInlines.h&quot;

 138 #include &quot;StructureInlines.h&quot;

 139 #include &quot;TestRunnerUtils.h&quot;
 140 #include &quot;ThunkGenerators.h&quot;
 141 #include &quot;TypeProfiler.h&quot;
 142 #include &quot;TypeProfilerLog.h&quot;
 143 #include &quot;UnlinkedCodeBlock.h&quot;
 144 #include &quot;VMEntryScope.h&quot;
 145 #include &quot;VMInlines.h&quot;
 146 #include &quot;VMInspector.h&quot;
 147 #include &quot;VariableEnvironment.h&quot;
 148 #include &quot;WasmWorklist.h&quot;
 149 #include &quot;Watchdog.h&quot;
 150 #include &quot;WeakGCMapInlines.h&quot;
 151 #include &quot;WebAssemblyFunction.h&quot;
<span class="line-modified"> 152 #include &quot;WebAssemblyFunctionHeapCellType.h&quot;</span>
 153 #include &quot;WebAssemblyWrapperFunction.h&quot;

 154 #include &lt;wtf/ProcessID.h&gt;
 155 #include &lt;wtf/ReadWriteLock.h&gt;
 156 #include &lt;wtf/SimpleStats.h&gt;
 157 #include &lt;wtf/StringPrintStream.h&gt;
 158 #include &lt;wtf/Threading.h&gt;
 159 #include &lt;wtf/text/AtomStringTable.h&gt;
 160 #include &lt;wtf/text/SymbolRegistry.h&gt;
 161 
 162 #if ENABLE(C_LOOP)
 163 #include &quot;CLoopStack.h&quot;
 164 #include &quot;CLoopStackInlines.h&quot;
 165 #endif
 166 
 167 #if ENABLE(DFG_JIT)
 168 #include &quot;ConservativeRoots.h&quot;
 169 #endif
 170 
 171 #if ENABLE(REGEXP_TRACING)
 172 #include &quot;RegExp.h&quot;
 173 #endif
 174 
















 175 namespace JSC {
 176 
 177 #if ENABLE(JIT)
<span class="line-modified"> 178 #if !ASSERT_DISABLED</span>
 179 bool VM::s_canUseJITIsSet = false;
 180 #endif
 181 bool VM::s_canUseJIT = false;
 182 #endif
 183 
 184 Atomic&lt;unsigned&gt; VM::s_numberOfIDs;
 185 


 186 // Note: Platform.h will enforce that ENABLE(ASSEMBLER) is true if either
 187 // ENABLE(JIT) or ENABLE(YARR_JIT) or both are enabled. The code below
 188 // just checks for ENABLE(JIT) or ENABLE(YARR_JIT) with this premise in mind.
 189 
 190 #if ENABLE(ASSEMBLER)
 191 static bool enableAssembler()
 192 {
 193     if (!Options::useJIT())
 194         return false;
 195 
 196     char* canUseJITString = getenv(&quot;JavaScriptCoreUseJIT&quot;);
 197     if (canUseJITString &amp;&amp; !atoi(canUseJITString))
 198         return false;
 199 
 200     ExecutableAllocator::initializeUnderlyingAllocator();
 201     if (!ExecutableAllocator::singleton().isValid()) {
 202         if (Options::crashIfCantAllocateJITMemory())
 203             CRASH();
 204         return false;
 205     }
</pre>
<hr />
<pre>
 208 }
 209 #endif // ENABLE(!ASSEMBLER)
 210 
 211 bool VM::canUseAssembler()
 212 {
 213 #if ENABLE(ASSEMBLER)
 214     static std::once_flag onceKey;
 215     static bool enabled = false;
 216     std::call_once(onceKey, [] {
 217         enabled = enableAssembler();
 218     });
 219     return enabled;
 220 #else
 221     return false; // interpreter only
 222 #endif
 223 }
 224 
 225 void VM::computeCanUseJIT()
 226 {
 227 #if ENABLE(JIT)
<span class="line-modified"> 228 #if !ASSERT_DISABLED</span>
 229     RELEASE_ASSERT(!s_canUseJITIsSet);
 230     s_canUseJITIsSet = true;
 231 #endif
 232     s_canUseJIT = VM::canUseAssembler() &amp;&amp; Options::useJIT();
 233 #endif
 234 }
 235 
 236 inline unsigned VM::nextID()
 237 {
 238     for (;;) {
 239         unsigned currentNumberOfIDs = s_numberOfIDs.load();
 240         unsigned newID = currentNumberOfIDs + 1;
 241         if (s_numberOfIDs.compareExchangeWeak(currentNumberOfIDs, newID))
 242             return newID;
 243     }
 244 }
 245 
 246 static bool vmCreationShouldCrash = false;
 247 
 248 VM::VM(VMType vmType, HeapType heapType)
 249     : m_id(nextID())
 250     , m_apiLock(adoptRef(new JSLock(this)))
 251 #if USE(CF)
 252     , m_runLoop(CFRunLoopGetCurrent())
 253 #endif // USE(CF)


 254     , heap(*this, heapType)
 255     , fastMallocAllocator(makeUnique&lt;FastMallocAlignedMemoryAllocator&gt;())
 256     , primitiveGigacageAllocator(makeUnique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::Primitive))
 257     , jsValueGigacageAllocator(makeUnique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::JSValue))
 258     , auxiliaryHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::Auxiliary)))
 259     , immutableButterflyHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCellWithInteriorPointers)))
 260     , cellHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCell)))
 261     , destructibleCellHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(NeedsDestruction, HeapCell::JSCell)))
<span class="line-modified"> 262     , stringHeapCellType(makeUnique&lt;JSStringHeapCellType&gt;())</span>













 263     , destructibleObjectHeapCellType(makeUnique&lt;JSDestructibleObjectHeapCellType&gt;())















 264 #if ENABLE(WEBASSEMBLY)
<span class="line-modified"> 265     , webAssemblyCodeBlockHeapCellType(makeUnique&lt;JSWebAssemblyCodeBlockHeapCellType&gt;())</span>
<span class="line-modified"> 266     , webAssemblyFunctionHeapCellType(makeUnique&lt;WebAssemblyFunctionHeapCellType&gt;())</span>






 267 #endif
 268     , primitiveGigacageAuxiliarySpace(&quot;Primitive Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), primitiveGigacageAllocator.get()) // Hash:0x3e7cd762
 269     , jsValueGigacageAuxiliarySpace(&quot;JSValue Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x241e946
 270     , immutableButterflyJSValueGigacageAuxiliarySpace(&quot;ImmutableButterfly Gigacage JSCellWithInteriorPointers&quot;, heap, immutableButterflyHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x7a945300
 271     , cellSpace(&quot;JSCell&quot;, heap, cellHeapCellType.get(), fastMallocAllocator.get()) // Hash:0xadfb5a79
<span class="line-modified"> 272     , jsValueGigacageCellSpace(&quot;JSValue Gigacage JSCell&quot;, heap, cellHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x2f5b102b</span>
<span class="line-removed"> 273     , destructibleCellSpace(&quot;Destructible JSCell&quot;, heap, destructibleCellHeapCellType.get(), fastMallocAllocator.get()) // Hash:0xbfff3d73</span>
<span class="line-removed"> 274     , stringSpace(&quot;JSString&quot;, heap, stringHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x90cf758f</span>
 275     , destructibleObjectSpace(&quot;JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x4f5ed7a9
<span class="line-modified"> 276     , eagerlySweptDestructibleObjectSpace(&quot;Eagerly Swept JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x6ebf28e2</span>






 277     , executableToCodeBlockEdgeSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), ExecutableToCodeBlockEdge) // Hash:0x7b730b20
 278     , functionSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSFunction) // Hash:0x800fca72
<span class="line-modified"> 279     , internalFunctionSpace ISO_SUBSPACE_INIT(heap, destructibleObjectHeapCellType.get(), InternalFunction) // Hash:0xf845c464</span>



 280     , nativeExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), NativeExecutable) // Hash:0x67567f95



 281     , propertyTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), PropertyTable) // Hash:0xc6bc9f12








 282     , structureRareDataSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), StructureRareData) // Hash:0xaca4e62d
 283     , structureSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), Structure) // Hash:0x1f1bcdca
 284     , symbolTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), SymbolTable) // Hash:0xc5215afd
 285     , executableToCodeBlockEdgesWithConstraints(executableToCodeBlockEdgeSpace)
 286     , executableToCodeBlockEdgesWithFinalizers(executableToCodeBlockEdgeSpace)
 287     , codeBlockSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), CodeBlock) // Hash:0x77e66ec9
 288     , functionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), FunctionExecutable) // Hash:0x5d158f3
 289     , programExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), ProgramExecutable) // Hash:0x527c77e7
 290     , unlinkedFunctionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), UnlinkedFunctionExecutable) // Hash:0xf6b828d9
 291     , vmType(vmType)
 292     , clientData(0)
 293     , topEntryFrame(nullptr)
 294     , topCallFrame(CallFrame::noCaller())
<span class="line-modified"> 295     , promiseDeferredTimer(PromiseDeferredTimer::create(*this))</span>
 296     , m_atomStringTable(vmType == Default ? Thread::current().atomStringTable() : new AtomStringTable)
 297     , propertyNames(nullptr)
 298     , emptyList(new ArgList)
 299     , machineCodeBytesPerBytecodeWordForBaselineJIT(makeUnique&lt;SimpleStats&gt;())
 300     , customGetterSetterFunctionMap(*this)
 301     , stringCache(*this)
 302     , symbolImplToSymbolMap(*this)
 303     , structureCache(*this)
 304     , interpreter(0)
 305     , entryScope(0)
 306     , m_regExpCache(new RegExpCache(this))
 307     , m_compactVariableMap(adoptRef(*(new CompactVariableMap)))
 308 #if ENABLE(REGEXP_TRACING)
 309     , m_rtTraceList(new RTTraceList())
 310 #endif
 311 #if ENABLE(GC_VALIDATION)
 312     , m_initializingObjectClass(0)
 313 #endif
 314     , m_stackPointerAtVMEntry(0)
 315     , m_codeCache(makeUnique&lt;CodeCache&gt;())
</pre>
<hr />
<pre>
 323 
 324     interpreter = new Interpreter(*this);
 325     StackBounds stack = Thread::current().stack();
 326     updateSoftReservedZoneSize(Options::softReservedZoneSize());
 327     setLastStackTop(stack.origin());
 328 
 329     JSRunLoopTimer::Manager::shared().registerVM(*this);
 330 
 331     // Need to be careful to keep everything consistent here
 332     JSLockHolder lock(this);
 333     AtomStringTable* existingEntryAtomStringTable = Thread::current().setCurrentAtomStringTable(m_atomStringTable);
 334     structureStructure.set(*this, Structure::createStructure(*this));
 335     structureRareDataStructure.set(*this, StructureRareData::createStructure(*this, 0, jsNull()));
 336     stringStructure.set(*this, JSString::createStructure(*this, 0, jsNull()));
 337 
 338     smallStrings.initializeCommonStrings(*this);
 339 
 340     propertyNames = new CommonIdentifiers(*this);
 341     terminatedExecutionErrorStructure.set(*this, TerminatedExecutionError::createStructure(*this, 0, jsNull()));
 342     propertyNameEnumeratorStructure.set(*this, JSPropertyNameEnumerator::createStructure(*this, 0, jsNull()));

 343     customGetterSetterStructure.set(*this, CustomGetterSetter::createStructure(*this, 0, jsNull()));
 344     domAttributeGetterSetterStructure.set(*this, DOMAttributeGetterSetter::createStructure(*this, 0, jsNull()));
 345     scopedArgumentsTableStructure.set(*this, ScopedArgumentsTable::createStructure(*this, 0, jsNull()));
 346     apiWrapperStructure.set(*this, JSAPIValueWrapper::createStructure(*this, 0, jsNull()));
 347     nativeExecutableStructure.set(*this, NativeExecutable::createStructure(*this, 0, jsNull()));
 348     evalExecutableStructure.set(*this, EvalExecutable::createStructure(*this, 0, jsNull()));
 349     programExecutableStructure.set(*this, ProgramExecutable::createStructure(*this, 0, jsNull()));
 350     functionExecutableStructure.set(*this, FunctionExecutable::createStructure(*this, 0, jsNull()));
 351 #if ENABLE(WEBASSEMBLY)
 352     webAssemblyCodeBlockStructure.set(*this, JSWebAssemblyCodeBlock::createStructure(*this, 0, jsNull()));
 353 #endif
 354     moduleProgramExecutableStructure.set(*this, ModuleProgramExecutable::createStructure(*this, 0, jsNull()));
 355     regExpStructure.set(*this, RegExp::createStructure(*this, 0, jsNull()));
 356     symbolStructure.set(*this, Symbol::createStructure(*this, 0, jsNull()));
 357     symbolTableStructure.set(*this, SymbolTable::createStructure(*this, 0, jsNull()));
<span class="line-removed"> 358     fixedArrayStructure.set(*this, JSFixedArray::createStructure(*this, 0, jsNull()));</span>
 359 
 360     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithInt32) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithInt32));
 361     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithDouble) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithDouble));
 362     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithContiguous));
 363 
 364     sourceCodeStructure.set(*this, JSSourceCode::createStructure(*this, 0, jsNull()));
 365     scriptFetcherStructure.set(*this, JSScriptFetcher::createStructure(*this, 0, jsNull()));
 366     scriptFetchParametersStructure.set(*this, JSScriptFetchParameters::createStructure(*this, 0, jsNull()));
 367     structureChainStructure.set(*this, StructureChain::createStructure(*this, 0, jsNull()));
 368     sparseArrayValueMapStructure.set(*this, SparseArrayValueMap::createStructure(*this, 0, jsNull()));
 369     templateObjectDescriptorStructure.set(*this, JSTemplateObjectDescriptor::createStructure(*this, 0, jsNull()));
<span class="line-removed"> 370     arrayBufferNeuteringWatchpointStructure.set(*this, ArrayBufferNeuteringWatchpointSet::createStructure(*this));</span>
 371     unlinkedFunctionExecutableStructure.set(*this, UnlinkedFunctionExecutable::createStructure(*this, 0, jsNull()));
 372     unlinkedProgramCodeBlockStructure.set(*this, UnlinkedProgramCodeBlock::createStructure(*this, 0, jsNull()));
 373     unlinkedEvalCodeBlockStructure.set(*this, UnlinkedEvalCodeBlock::createStructure(*this, 0, jsNull()));
 374     unlinkedFunctionCodeBlockStructure.set(*this, UnlinkedFunctionCodeBlock::createStructure(*this, 0, jsNull()));
 375     unlinkedModuleProgramCodeBlockStructure.set(*this, UnlinkedModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
 376     propertyTableStructure.set(*this, PropertyTable::createStructure(*this, 0, jsNull()));
 377     functionRareDataStructure.set(*this, FunctionRareData::createStructure(*this, 0, jsNull()));
 378     exceptionStructure.set(*this, Exception::createStructure(*this, 0, jsNull()));
<span class="line-removed"> 379     promiseDeferredStructure.set(*this, JSPromiseDeferred::createStructure(*this, 0, jsNull()));</span>
<span class="line-removed"> 380     internalPromiseDeferredStructure.set(*this, JSInternalPromiseDeferred::createStructure(*this, 0, jsNull()));</span>
<span class="line-removed"> 381     nativeStdFunctionCellStructure.set(*this, NativeStdFunctionCell::createStructure(*this, 0, jsNull()));</span>
 382     programCodeBlockStructure.set(*this, ProgramCodeBlock::createStructure(*this, 0, jsNull()));
 383     moduleProgramCodeBlockStructure.set(*this, ModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
 384     evalCodeBlockStructure.set(*this, EvalCodeBlock::createStructure(*this, 0, jsNull()));
 385     functionCodeBlockStructure.set(*this, FunctionCodeBlock::createStructure(*this, 0, jsNull()));
 386     hashMapBucketSetStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKey&gt;::createStructure(*this, 0, jsNull()));
 387     hashMapBucketMapStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::createStructure(*this, 0, jsNull()));
 388     bigIntStructure.set(*this, JSBigInt::createStructure(*this, 0, jsNull()));
 389     executableToCodeBlockEdgeStructure.set(*this, ExecutableToCodeBlockEdge::createStructure(*this, nullptr, jsNull()));
 390 
 391     // Eagerly initialize constant cells since the concurrent compiler can access them.
 392     if (canUseJIT()) {
 393         sentinelMapBucket();
 394         sentinelSetBucket();
 395     }

 396 
 397     Thread::current().setCurrentAtomStringTable(existingEntryAtomStringTable);
 398 
 399 #if !ENABLE(C_LOOP)
 400     initializeHostCallReturnValue(); // This is needed to convince the linker not to drop host call return support.
 401 #endif
 402 
 403     Gigacage::addPrimitiveDisableCallback(primitiveGigacageDisabledCallback, this);
 404 
 405     heap.notifyIsSafeToCollect();
 406 
 407     LLInt::Data::performAssertions(*this);
 408 
 409     if (UNLIKELY(Options::useProfiler())) {
 410         m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(*this);
 411 
 412         StringPrintStream pathOut;
 413         const char* profilerPath = getenv(&quot;JSC_PROFILER_PATH&quot;);
 414         if (profilerPath)
 415             pathOut.print(profilerPath, &quot;/&quot;);
</pre>
<hr />
<pre>
 426     m_bytecodeIntrinsicRegistry = makeUnique&lt;BytecodeIntrinsicRegistry&gt;(*this);
 427 
 428     if (Options::useTypeProfiler())
 429         enableTypeProfiler();
 430     if (Options::useControlFlowProfiler())
 431         enableControlFlowProfiler();
 432 #if ENABLE(SAMPLING_PROFILER)
 433     if (Options::useSamplingProfiler()) {
 434         setShouldBuildPCToCodeOriginMapping();
 435         Ref&lt;Stopwatch&gt; stopwatch = Stopwatch::create();
 436         stopwatch-&gt;start();
 437         m_samplingProfiler = adoptRef(new SamplingProfiler(*this, WTFMove(stopwatch)));
 438         if (Options::samplingProfilerPath())
 439             m_samplingProfiler-&gt;registerForReportAtExit();
 440         m_samplingProfiler-&gt;start();
 441     }
 442 #endif // ENABLE(SAMPLING_PROFILER)
 443 
 444     if (Options::useRandomizingFuzzerAgent())
 445         setFuzzerAgent(makeUnique&lt;RandomizingFuzzerAgent&gt;(*this));
<span class="line-modified"> 446     else if (Options::useDoublePredictionFuzzerAgent())</span>
 447         setFuzzerAgent(makeUnique&lt;DoublePredictionFuzzerAgent&gt;(*this));








 448 
 449     if (Options::alwaysGeneratePCToCodeOriginMap())
 450         setShouldBuildPCToCodeOriginMapping();
 451 
 452     if (Options::watchdog()) {
 453         Watchdog&amp; watchdog = ensureWatchdog();
 454         watchdog.setTimeLimit(Seconds::fromMilliseconds(Options::watchdog()));
 455     }
 456 
 457 #if ENABLE(JIT)
 458     // Make sure that any stubs that the JIT is going to use are initialized in non-compilation threads.
 459     if (canUseJIT()) {
 460         jitStubs = makeUnique&lt;JITThunks&gt;();
 461 #if ENABLE(FTL_JIT)
 462         ftlThunks = makeUnique&lt;FTL::Thunks&gt;();
 463 #endif // ENABLE(FTL_JIT)
 464         getCTIInternalFunctionTrampolineFor(CodeForCall);
 465         getCTIInternalFunctionTrampolineFor(CodeForConstruct);
 466     }
 467 #endif
 468 
 469     if (Options::forceDebuggerBytecodeGeneration() || Options::alwaysUseShadowChicken())
 470         ensureShadowChicken();
 471 
 472     VMInspector::instance().add(this);



 473 }
 474 
 475 static ReadWriteLock s_destructionLock;
 476 
 477 void waitForVMDestruction()
 478 {
 479     auto locker = holdLock(s_destructionLock.write());
 480 }
 481 
 482 VM::~VM()
 483 {
 484     auto destructionLocker = holdLock(s_destructionLock.read());
 485 
 486     Gigacage::removePrimitiveDisableCallback(primitiveGigacageDisabledCallback, this);
<span class="line-modified"> 487     promiseDeferredTimer-&gt;stopRunningTasks();</span>
 488 #if ENABLE(WEBASSEMBLY)
 489     if (Wasm::Worklist* worklist = Wasm::existingWorklistOrNull())
 490         worklist-&gt;stopAllPlansForContext(wasmContext);
 491 #endif
 492     if (UNLIKELY(m_watchdog))
 493         m_watchdog-&gt;willDestroyVM(this);
 494     m_traps.willDestroyVM();
 495     VMInspector::instance().remove(this);
 496 
 497     // Never GC, ever again.
 498     heap.incrementDeferralDepth();
 499 
 500 #if ENABLE(SAMPLING_PROFILER)
 501     if (m_samplingProfiler) {
 502         m_samplingProfiler-&gt;reportDataToOptionFile();
 503         m_samplingProfiler-&gt;shutdown();
 504     }
 505 #endif // ENABLE(SAMPLING_PROFILER)
 506 
 507 #if ENABLE(JIT)
</pre>
<hr />
<pre>
 536     delete interpreter;
 537 #ifndef NDEBUG
 538     interpreter = reinterpret_cast&lt;Interpreter*&gt;(0xbbadbeef);
 539 #endif
 540 
 541     delete emptyList;
 542 
 543     delete propertyNames;
 544     if (vmType != Default)
 545         delete m_atomStringTable;
 546 
 547     delete clientData;
 548     delete m_regExpCache;
 549 
 550 #if ENABLE(REGEXP_TRACING)
 551     delete m_rtTraceList;
 552 #endif
 553 
 554 #if ENABLE(DFG_JIT)
 555     for (unsigned i = 0; i &lt; m_scratchBuffers.size(); ++i)
<span class="line-modified"> 556         fastFree(m_scratchBuffers[i]);</span>
 557 #endif
 558 }
 559 
 560 void VM::primitiveGigacageDisabledCallback(void* argument)
 561 {
 562     static_cast&lt;VM*&gt;(argument)-&gt;primitiveGigacageDisabled();
 563 }
 564 
 565 void VM::primitiveGigacageDisabled()
 566 {
 567     if (m_apiLock-&gt;currentThreadIsHoldingLock()) {
 568         m_primitiveGigacageEnabled.fireAll(*this, &quot;Primitive gigacage disabled&quot;);
 569         return;
 570     }
 571 
 572     // This is totally racy, and that&#39;s OK. The point is, it&#39;s up to the user to ensure that they pass the
 573     // uncaged buffer in a nicely synchronized manner.
 574     m_needToFirePrimitiveGigacageEnabled = true;
 575 }
 576 
</pre>
<hr />
<pre>
 623     return *m_heapProfiler;
 624 }
 625 
 626 #if ENABLE(SAMPLING_PROFILER)
 627 SamplingProfiler&amp; VM::ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp; stopwatch)
 628 {
 629     if (!m_samplingProfiler)
 630         m_samplingProfiler = adoptRef(new SamplingProfiler(*this, WTFMove(stopwatch)));
 631     return *m_samplingProfiler;
 632 }
 633 #endif // ENABLE(SAMPLING_PROFILER)
 634 
 635 #if ENABLE(JIT)
 636 static ThunkGenerator thunkGeneratorForIntrinsic(Intrinsic intrinsic)
 637 {
 638     switch (intrinsic) {
 639     case CharCodeAtIntrinsic:
 640         return charCodeAtThunkGenerator;
 641     case CharAtIntrinsic:
 642         return charAtThunkGenerator;


 643     case Clz32Intrinsic:
 644         return clz32ThunkGenerator;
 645     case FromCharCodeIntrinsic:
 646         return fromCharCodeThunkGenerator;
 647     case SqrtIntrinsic:
 648         return sqrtThunkGenerator;
 649     case AbsIntrinsic:
 650         return absThunkGenerator;
 651     case FloorIntrinsic:
 652         return floorThunkGenerator;
 653     case CeilIntrinsic:
 654         return ceilThunkGenerator;
 655     case TruncIntrinsic:
 656         return truncThunkGenerator;
 657     case RoundIntrinsic:
 658         return roundThunkGenerator;
 659     case ExpIntrinsic:
 660         return expThunkGenerator;
 661     case LogIntrinsic:
 662         return logThunkGenerator;
 663     case IMulIntrinsic:
 664         return imulThunkGenerator;
 665     case RandomIntrinsic:
 666         return randomThunkGenerator;
<span class="line-modified"> 667     case BoundThisNoArgsFunctionCallIntrinsic:</span>
<span class="line-modified"> 668         return boundThisNoArgsFunctionCallGenerator;</span>
 669     default:
 670         return nullptr;
 671     }
 672 }
 673 
 674 #endif // ENABLE(JIT)
 675 
 676 NativeExecutable* VM::getHostFunction(NativeFunction function, NativeFunction constructor, const String&amp; name)
 677 {
 678     return getHostFunction(function, NoIntrinsic, constructor, nullptr, name);
 679 }
 680 
 681 static Ref&lt;NativeJITCode&gt; jitCodeForCallTrampoline()
 682 {
 683     static NativeJITCode* result;
 684     static std::once_flag onceKey;
 685     std::call_once(onceKey, [&amp;] {
 686         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_call_trampoline), JITType::HostCallThunk, NoIntrinsic);
 687     });
 688     return makeRef(*result);
</pre>
<hr />
<pre>
 696         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_construct_trampoline), JITType::HostCallThunk, NoIntrinsic);
 697     });
 698     return makeRef(*result);
 699 }
 700 
 701 NativeExecutable* VM::getHostFunction(NativeFunction function, Intrinsic intrinsic, NativeFunction constructor, const DOMJIT::Signature* signature, const String&amp; name)
 702 {
 703 #if ENABLE(JIT)
 704     if (canUseJIT()) {
 705         return jitStubs-&gt;hostFunctionStub(
 706             *this, function, constructor,
 707             intrinsic != NoIntrinsic ? thunkGeneratorForIntrinsic(intrinsic) : 0,
 708             intrinsic, signature, name);
 709     }
 710 #endif // ENABLE(JIT)
 711     UNUSED_PARAM(intrinsic);
 712     UNUSED_PARAM(signature);
 713     return NativeExecutable::create(*this, jitCodeForCallTrampoline(), function, jitCodeForConstructTrampoline(), constructor, name);
 714 }
 715 

























 716 MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; VM::getCTIInternalFunctionTrampolineFor(CodeSpecializationKind kind)
 717 {
 718 #if ENABLE(JIT)
 719     if (canUseJIT()) {
 720         if (kind == CodeForCall)
 721             return jitStubs-&gt;ctiInternalFunctionCall(*this).retagged&lt;JSEntryPtrTag&gt;();
 722         return jitStubs-&gt;ctiInternalFunctionConstruct(*this).retagged&lt;JSEntryPtrTag&gt;();
 723     }
 724 #endif
 725     if (kind == CodeForCall)
 726         return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_call_trampoline);
 727     return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_construct_trampoline);
 728 }
 729 
 730 VM::ClientData::~ClientData()
 731 {
 732 }
 733 
 734 void VM::resetDateCache()
 735 {
</pre>
<hr />
<pre>
 776         heap.collectNow(Synchronousness::Sync, CollectionScope::Full);
 777         // FIXME: Consider stopping various automatic threads here.
 778         // https://bugs.webkit.org/show_bug.cgi?id=185447
 779         WTF::releaseFastMallocFreeMemory();
 780     });
 781 }
 782 
 783 SourceProviderCache* VM::addSourceProviderCache(SourceProvider* sourceProvider)
 784 {
 785     auto addResult = sourceProviderCacheMap.add(sourceProvider, nullptr);
 786     if (addResult.isNewEntry)
 787         addResult.iterator-&gt;value = adoptRef(new SourceProviderCache);
 788     return addResult.iterator-&gt;value.get();
 789 }
 790 
 791 void VM::clearSourceProviderCaches()
 792 {
 793     sourceProviderCacheMap.clear();
 794 }
 795 
<span class="line-modified"> 796 Exception* VM::throwException(ExecState* exec, Exception* exception)</span>
 797 {
<span class="line-modified"> 798     ASSERT(exec == topCallFrame || exec-&gt;isGlobalExec() || exec == exec-&gt;lexicalGlobalObject()-&gt;callFrameAtDebuggerEntry());</span>
<span class="line-modified"> 799     CallFrame* throwOriginFrame = exec-&gt;isGlobalExec() ? exec : topJSCallFrame();</span>

 800 
<span class="line-modified"> 801     if (Options::breakOnThrow()) {</span>
 802         CodeBlock* codeBlock = throwOriginFrame ? throwOriginFrame-&gt;codeBlock() : nullptr;
 803         dataLog(&quot;Throwing exception in call frame &quot;, RawPointer(throwOriginFrame), &quot; for code block &quot;, codeBlock, &quot;\n&quot;);
 804         CRASH();
 805     }
 806 
<span class="line-modified"> 807     interpreter-&gt;notifyDebuggerOfExceptionToBeThrown(*this, throwOriginFrame, exception);</span>
 808 
 809     setException(exception);
 810 
 811 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 812     m_nativeStackTraceOfLastThrow = StackTrace::captureStackTrace(Options::unexpectedExceptionStackTraceLimit());
 813     m_throwingThread = &amp;Thread::current();
 814 #endif
 815     return exception;
 816 }
 817 
<span class="line-modified"> 818 Exception* VM::throwException(ExecState* exec, JSValue thrownValue)</span>
 819 {
 820     VM&amp; vm = *this;
 821     Exception* exception = jsDynamicCast&lt;Exception*&gt;(vm, thrownValue);
 822     if (!exception)
 823         exception = Exception::create(*this, thrownValue);
 824 
<span class="line-modified"> 825     return throwException(exec, exception);</span>
 826 }
 827 
<span class="line-modified"> 828 Exception* VM::throwException(ExecState* exec, JSObject* error)</span>
 829 {
<span class="line-modified"> 830     return throwException(exec, JSValue(error));</span>
 831 }
 832 
 833 void VM::setStackPointerAtVMEntry(void* sp)
 834 {
 835     m_stackPointerAtVMEntry = sp;
 836     updateStackLimits();
 837 }
 838 
 839 size_t VM::updateSoftReservedZoneSize(size_t softReservedZoneSize)
 840 {
 841     size_t oldSoftReservedZoneSize = m_currentSoftReservedZoneSize;
 842     m_currentSoftReservedZoneSize = softReservedZoneSize;
 843 #if ENABLE(C_LOOP)
 844     interpreter-&gt;cloopStack().setSoftReservedZoneSize(softReservedZoneSize);
 845 #endif
 846 
 847     updateStackLimits();
 848 
 849     return oldSoftReservedZoneSize;
 850 }
</pre>
<hr />
<pre>
 857 // When using the C stack on Windows we need to precommit the needed stack space.
 858 // Otherwise we might crash later if we access uncommitted stack memory.
 859 // This can happen if we allocate stack space larger than the page guard size (4K).
 860 // The system does not get the chance to move the guard page, and commit more memory,
 861 // and we crash if uncommitted memory is accessed.
 862 // The MSVC compiler fixes this by inserting a call to the _chkstk() function,
 863 // when needed, see http://support.microsoft.com/kb/100775.
 864 // By touching every page up to the stack limit with a dummy operation,
 865 // we force the system to move the guard page, and commit memory.
 866 
 867 static void preCommitStackMemory(void* stackLimit)
 868 {
 869     const int pageSize = 4096;
 870     for (volatile char* p = reinterpret_cast&lt;char*&gt;(&amp;stackLimit); p &gt; stackLimit; p -= pageSize) {
 871         char ch = *p;
 872         *p = ch;
 873     }
 874 }
 875 #endif
 876 
<span class="line-modified"> 877 inline void VM::updateStackLimits()</span>
 878 {
 879 #if OS(WINDOWS)
 880     void* lastSoftStackLimit = m_softStackLimit;
 881 #endif
 882 
 883     const StackBounds&amp; stack = Thread::current().stack();
 884     size_t reservedZoneSize = Options::reservedZoneSize();
 885     // We should have already ensured that Options::reservedZoneSize() &gt;= minimumReserveZoneSize at
 886     // options initialization time, and the option value should not have been changed thereafter.
 887     // We don&#39;t have the ability to assert here that it hasn&#39;t changed, but we can at least assert
 888     // that the value is sane.
 889     RELEASE_ASSERT(reservedZoneSize &gt;= minimumReservedZoneSize);
 890 
 891     if (m_stackPointerAtVMEntry) {
<span class="line-removed"> 892         ASSERT(stack.isGrowingDownward());</span>
 893         char* startOfStack = reinterpret_cast&lt;char*&gt;(m_stackPointerAtVMEntry);
 894         m_softStackLimit = stack.recursionLimit(startOfStack, Options::maxPerThreadStackUsage(), m_currentSoftReservedZoneSize);
 895         m_stackLimit = stack.recursionLimit(startOfStack, Options::maxPerThreadStackUsage(), reservedZoneSize);
 896     } else {
 897         m_softStackLimit = stack.recursionLimit(m_currentSoftReservedZoneSize);
 898         m_stackLimit = stack.recursionLimit(reservedZoneSize);
 899     }
 900 
 901 #if OS(WINDOWS)
 902     // We only need to precommit stack memory dictated by the VM::m_softStackLimit limit.
 903     // This is because VM::m_softStackLimit applies to stack usage by LLINT asm or JIT
 904     // generated code which can allocate stack space that the C++ compiler does not know
 905     // about. As such, we have to precommit that stack memory manually.
 906     //
 907     // In contrast, we do not need to worry about VM::m_stackLimit because that limit is
 908     // used exclusively by C++ code, and the C++ compiler will automatically commit the
 909     // needed stack pages.
 910     if (lastSoftStackLimit != m_softStackLimit)
 911         preCommitStackMemory(m_softStackLimit);
 912 #endif
 913 }
 914 
 915 #if ENABLE(DFG_JIT)
 916 void VM::gatherScratchBufferRoots(ConservativeRoots&amp; conservativeRoots)
 917 {
 918     auto lock = holdLock(m_scratchBufferLock);
 919     for (auto* scratchBuffer : m_scratchBuffers) {
 920         if (scratchBuffer-&gt;activeLength()) {
 921             void* bufferStart = scratchBuffer-&gt;dataBuffer();
 922             conservativeRoots.add(bufferStart, static_cast&lt;void*&gt;(static_cast&lt;char*&gt;(bufferStart) + scratchBuffer-&gt;activeLength()));
 923         }
 924     }
 925 }









 926 #endif
 927 














 928 void logSanitizeStack(VM&amp; vm)
 929 {
 930     if (Options::verboseSanitizeStack() &amp;&amp; vm.topCallFrame) {
 931         int dummy;
 932         auto&amp; stackBounds = Thread::current().stack();
 933         dataLog(
 934             &quot;Sanitizing stack for VM = &quot;, RawPointer(&amp;vm), &quot; with top call frame at &quot;, RawPointer(vm.topCallFrame),
 935             &quot;, current stack pointer at &quot;, RawPointer(&amp;dummy), &quot;, in &quot;,
 936             pointerDump(vm.topCallFrame-&gt;codeBlock()), &quot;, last code origin = &quot;,
 937             vm.topCallFrame-&gt;codeOrigin(), &quot;, last stack top = &quot;, RawPointer(vm.lastStackTop()), &quot;, in stack range [&quot;, RawPointer(stackBounds.origin()), &quot;, &quot;, RawPointer(stackBounds.end()), &quot;]\n&quot;);
 938     }
 939 }
 940 
 941 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 942 char* VM::acquireRegExpPatternContexBuffer()
 943 {
 944     m_regExpPatternContextLock.lock();
 945     ASSERT(m_regExpPatternContextLock.isLocked());
 946     if (!m_regExpPatternContexBuffer)
 947         m_regExpPatternContexBuffer = makeUniqueArray&lt;char&gt;(VM::patternContextBufferSize);
</pre>
<hr />
<pre>
 975         dataLogF(&quot;----------------------------------------+----------------+----------------+----------+----------+-----------\n&quot;);
 976 
 977         unsigned reCount = 0;
 978 
 979         for (; iter != m_rtTraceList-&gt;end(); ++iter, ++reCount) {
 980             (*iter)-&gt;printTraceData();
 981             gcUnprotect(*iter);
 982         }
 983 
 984         dataLogF(&quot;%d Regular Expressions\n&quot;, reCount);
 985     }
 986 
 987     m_rtTraceList-&gt;clear();
 988 }
 989 #else
 990 void VM::dumpRegExpTrace()
 991 {
 992 }
 993 #endif
 994 
<span class="line-modified"> 995 WatchpointSet* VM::ensureWatchpointSetForImpureProperty(const Identifier&amp; propertyName)</span>
 996 {
<span class="line-modified"> 997     auto result = m_impurePropertyWatchpointSets.add(propertyName.string(), nullptr);</span>
 998     if (result.isNewEntry)
 999         result.iterator-&gt;value = adoptRef(new WatchpointSet(IsWatched));
1000     return result.iterator-&gt;value.get();
1001 }
1002 
<span class="line-modified">1003 void VM::registerWatchpointForImpureProperty(const Identifier&amp; propertyName, Watchpoint* watchpoint)</span>
<span class="line-removed">1004 {</span>
<span class="line-removed">1005     ensureWatchpointSetForImpureProperty(propertyName)-&gt;add(watchpoint);</span>
<span class="line-removed">1006 }</span>
<span class="line-removed">1007 </span>
<span class="line-removed">1008 void VM::addImpureProperty(const String&amp; propertyName)</span>
1009 {
1010     if (RefPtr&lt;WatchpointSet&gt; watchpointSet = m_impurePropertyWatchpointSets.take(propertyName))
1011         watchpointSet-&gt;fireAll(*this, &quot;Impure property added&quot;);
1012 }
1013 
1014 template&lt;typename Func&gt;
1015 static bool enableProfilerWithRespectToCount(unsigned&amp; counter, const Func&amp; doEnableWork)
1016 {
1017     bool needsToRecompile = false;
1018     if (!counter) {
1019         doEnableWork();
1020         needsToRecompile = true;
1021     }
1022     counter++;
1023 
1024     return needsToRecompile;
1025 }
1026 
1027 template&lt;typename Func&gt;
1028 static bool disableProfilerWithRespectToCount(unsigned&amp; counter, const Func&amp; doDisableWork)
</pre>
<hr />
<pre>
1088 void VM::queueMicrotask(JSGlobalObject&amp; globalObject, Ref&lt;Microtask&gt;&amp;&amp; task)
1089 {
1090     m_microtaskQueue.append(makeUnique&lt;QueuedTask&gt;(*this, &amp;globalObject, WTFMove(task)));
1091 }
1092 
1093 void VM::callPromiseRejectionCallback(Strong&lt;JSPromise&gt;&amp; promise)
1094 {
1095     JSObject* callback = promise-&gt;globalObject()-&gt;unhandledRejectionCallback();
1096     if (!callback)
1097         return;
1098 
1099     auto scope = DECLARE_CATCH_SCOPE(*this);
1100 
1101     CallData callData;
1102     CallType callType = getCallData(*this, callback, callData);
1103     ASSERT(callType != CallType::None);
1104 
1105     MarkedArgumentBuffer args;
1106     args.append(promise.get());
1107     args.append(promise-&gt;result(*this));
<span class="line-modified">1108     call(promise-&gt;globalObject()-&gt;globalExec(), callback, callType, callData, jsNull(), args);</span>
1109     scope.clearException();
1110 }
1111 
1112 void VM::didExhaustMicrotaskQueue()
1113 {
1114     auto unhandledRejections = WTFMove(m_aboutToBeNotifiedRejectedPromises);
1115     for (auto&amp; promise : unhandledRejections) {
1116         if (promise-&gt;isHandled(*this))
1117             continue;
1118 
1119         callPromiseRejectionCallback(promise);
1120     }
1121 }
1122 
1123 void VM::promiseRejected(JSPromise* promise)
1124 {
1125     m_aboutToBeNotifiedRejectedPromises.constructAndAppend(*this, promise);
1126 }
1127 
1128 void VM::drainMicrotasks()
1129 {
1130     do {
1131         while (!m_microtaskQueue.isEmpty()) {
1132             m_microtaskQueue.takeFirst()-&gt;run();
1133             if (m_onEachMicrotaskTick)
1134                 m_onEachMicrotaskTick(*this);
1135         }
1136         didExhaustMicrotaskQueue();
1137     } while (!m_microtaskQueue.isEmpty());
1138     finalizeSynchronousJSExecution();
1139 }
1140 
1141 void QueuedTask::run()
1142 {
<span class="line-modified">1143     m_microtask-&gt;run(m_globalObject-&gt;globalExec());</span>
1144 }
1145 
1146 void sanitizeStackForVM(VM&amp; vm)
1147 {
1148     logSanitizeStack(vm);
1149     if (vm.topCallFrame) {
1150         auto&amp; stackBounds = Thread::current().stack();
1151         ASSERT(vm.currentThreadIsHoldingAPILock());
1152         ASSERT_UNUSED(stackBounds, stackBounds.contains(vm.lastStackTop()));
1153     }
1154 #if ENABLE(C_LOOP)
1155     vm.interpreter-&gt;cloopStack().sanitizeStack();
1156 #else
1157     sanitizeStackForVMImpl(&amp;vm);
1158 #endif
1159 }
1160 
1161 size_t VM::committedStackByteCount()
1162 {
1163 #if !ENABLE(C_LOOP)
1164     // When using the C stack, we don&#39;t know how many stack pages are actually
1165     // committed. So, we use the current stack usage as an estimate.
<span class="line-removed">1166     ASSERT(Thread::current().stack().isGrowingDownward());</span>
1167     uint8_t* current = bitwise_cast&lt;uint8_t*&gt;(currentStackPointer());
1168     uint8_t* high = bitwise_cast&lt;uint8_t*&gt;(Thread::current().stack().origin());
1169     return high - current;
1170 #else
1171     return CLoopStack::committedByteCount();
1172 #endif
1173 }
1174 
1175 #if ENABLE(C_LOOP)
1176 bool VM::ensureStackCapacityForCLoop(Register* newTopOfStack)
1177 {
1178     return interpreter-&gt;cloopStack().ensureCapacityFor(newTopOfStack);
1179 }
1180 
1181 bool VM::isSafeToRecurseSoftCLoop() const
1182 {
1183     return interpreter-&gt;cloopStack().isSafeToRecurse();
1184 }
1185 
1186 void* VM::currentCLoopStackPointer() const
</pre>
<hr />
<pre>
1265 }
1266 
1267 void VM::ensureShadowChicken()
1268 {
1269     if (m_shadowChicken)
1270         return;
1271     m_shadowChicken = makeUnique&lt;ShadowChicken&gt;();
1272 }
1273 
1274 #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
1275     IsoSubspace* VM::name##Slow() \
1276     { \
1277         ASSERT(!m_##name); \
1278         auto space = makeUnique&lt;IsoSubspace&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \
1279         WTF::storeStoreFence(); \
1280         m_##name = WTFMove(space); \
1281         return m_##name.get(); \
1282     }
1283 
1284 







1285 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(boundFunctionSpace, cellHeapCellType.get(), JSBoundFunction) // Hash:0xd7916d41
<span class="line-modified">1286 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackFunctionSpace, destructibleObjectHeapCellType.get(), JSCallbackFunction) // Hash:0xe7648ebc</span>



1287 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(customGetterSetterFunctionSpace, cellHeapCellType.get(), JSCustomGetterSetterFunction) // Hash:0x18091000
<span class="line-modified">1288 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(errorInstanceSpace, destructibleObjectHeapCellType.get(), ErrorInstance) // Hash:0x3f40d4a</span>
<span class="line-modified">1289 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(nativeStdFunctionSpace, cellHeapCellType.get(), JSNativeStdFunction) // Hash:0x70ed61e4</span>
<span class="line-modified">1290 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(proxyRevokeSpace, destructibleObjectHeapCellType.get(), ProxyRevoke) // Hash:0xb506a939</span>
<span class="line-modified">1291 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakMapSpace, destructibleObjectHeapCellType.get(), JSWeakMap) // Hash:0x662b12a3</span>
<span class="line-modified">1292 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakSetSpace, destructibleObjectHeapCellType.get(), JSWeakSet) // Hash:0x4c781b30</span>




































1293 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakObjectRefSpace, cellHeapCellType.get(), JSWeakObjectRef) // Hash:0x8ec68f1f

1294 #if JSC_OBJC_API_ENABLED
<span class="line-modified">1295 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(objCCallbackFunctionSpace, destructibleObjectHeapCellType.get(), ObjCCallbackFunction) // Hash:0x10f610b8</span>












1296 #endif
1297 #if ENABLE(WEBASSEMBLY)

1298 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyCodeBlockSpace, webAssemblyCodeBlockHeapCellType.get(), JSWebAssemblyCodeBlock) // Hash:0x9ad995cd
1299 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyFunctionSpace, webAssemblyFunctionHeapCellType.get(), WebAssemblyFunction) // Hash:0x8b7c32db






1300 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyWrapperFunctionSpace, cellHeapCellType.get(), WebAssemblyWrapperFunction) // Hash:0xd4a5ff01
1301 #endif
1302 
1303 #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW
1304 
1305 #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
1306     IsoSubspace* VM::name##Slow() \
1307     { \
1308         ASSERT(!m_##name); \
1309         auto space = makeUnique&lt;SpaceAndSet&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \
1310         WTF::storeStoreFence(); \
1311         m_##name = WTFMove(space); \
1312         return &amp;m_##name-&gt;space; \
1313     }
1314 
1315 DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(evalExecutableSpace, destructibleCellHeapCellType.get(), EvalExecutable) // Hash:0x958e3e9d
1316 DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(moduleProgramExecutableSpace, destructibleCellHeapCellType.get(), ModuleProgramExecutable) // Hash:0x6506fa3c
1317 
1318 #undef DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW
1319 
</pre>
<hr />
<pre>
1339     return sentinel;
1340 }
1341 
1342 JSCell* VM::sentinelMapBucketSlow()
1343 {
1344     ASSERT(!m_sentinelMapBucket);
1345     auto* sentinel = JSMap::BucketType::createSentinel(*this);
1346     m_sentinelMapBucket.set(*this, sentinel);
1347     return sentinel;
1348 }
1349 
1350 JSPropertyNameEnumerator* VM::emptyPropertyNameEnumeratorSlow()
1351 {
1352     ASSERT(!m_emptyPropertyNameEnumerator);
1353     PropertyNameArray propertyNames(*this, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
1354     auto* enumerator = JSPropertyNameEnumerator::create(*this, nullptr, 0, 0, WTFMove(propertyNames));
1355     m_emptyPropertyNameEnumerator.set(*this, enumerator);
1356     return enumerator;
1357 }
1358 
<span class="line-modified">1359 JSGlobalObject* VM::vmEntryGlobalObject(const CallFrame* callFrame) const</span>
1360 {
<span class="line-modified">1361     if (callFrame &amp;&amp; callFrame-&gt;isGlobalExec()) {</span>
<span class="line-modified">1362         ASSERT(callFrame-&gt;callee().isCell() &amp;&amp; callFrame-&gt;callee().asCell()-&gt;isObject());</span>
<span class="line-modified">1363         ASSERT(callFrame == callFrame-&gt;lexicalGlobalObject()-&gt;globalExec());</span>
<span class="line-removed">1364         return callFrame-&gt;lexicalGlobalObject();</span>
<span class="line-removed">1365     }</span>
<span class="line-removed">1366     ASSERT(entryScope);</span>
<span class="line-removed">1367     return entryScope-&gt;globalObject();</span>
1368 }
1369 
1370 void VM::setCrashOnVMCreation(bool shouldCrash)
1371 {
1372     vmCreationShouldCrash = shouldCrash;
1373 }
1374 
1375 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2020 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;VM.h&quot;
  31 
  32 #include &quot;ArgList.h&quot;
<span class="line-modified">  33 #include &quot;BigIntObject.h&quot;</span>
<span class="line-added">  34 #include &quot;BooleanObject.h&quot;</span>
  35 #include &quot;BuiltinExecutables.h&quot;
  36 #include &quot;BytecodeIntrinsicRegistry.h&quot;
<span class="line-added">  37 #include &quot;CheckpointOSRExitSideState.h&quot;</span>
<span class="line-added">  38 #include &quot;ClonedArguments.h&quot;</span>
  39 #include &quot;CodeBlock.h&quot;
  40 #include &quot;CodeCache.h&quot;
  41 #include &quot;CommonIdentifiers.h&quot;
  42 #include &quot;CommonSlowPaths.h&quot;
  43 #include &quot;CustomGetterSetter.h&quot;
  44 #include &quot;DFGWorklist.h&quot;
<span class="line-added">  45 #include &quot;DOMAttributeGetterSetter.h&quot;</span>
<span class="line-added">  46 #include &quot;DateInstance.h&quot;</span>
<span class="line-added">  47 #include &quot;DebuggerScope.h&quot;</span>
  48 #include &quot;DirectEvalExecutable.h&quot;
  49 #include &quot;Disassembler.h&quot;
  50 #include &quot;DoublePredictionFuzzerAgent.h&quot;
  51 #include &quot;Error.h&quot;
  52 #include &quot;ErrorConstructor.h&quot;
  53 #include &quot;ErrorInstance.h&quot;
  54 #include &quot;EvalCodeBlock.h&quot;
  55 #include &quot;Exception.h&quot;
  56 #include &quot;ExecutableToCodeBlockEdge.h&quot;
  57 #include &quot;FTLThunks.h&quot;
  58 #include &quot;FastMallocAlignedMemoryAllocator.h&quot;
<span class="line-added">  59 #include &quot;FileBasedFuzzerAgent.h&quot;</span>
  60 #include &quot;FunctionCodeBlock.h&quot;
  61 #include &quot;FunctionConstructor.h&quot;
  62 #include &quot;FunctionExecutable.h&quot;
  63 #include &quot;GCActivityCallback.h&quot;
  64 #include &quot;GetterSetter.h&quot;
  65 #include &quot;GigacageAlignedMemoryAllocator.h&quot;
  66 #include &quot;HasOwnPropertyCache.h&quot;
  67 #include &quot;Heap.h&quot;
  68 #include &quot;HeapIterationScope.h&quot;
  69 #include &quot;HeapProfiler.h&quot;
  70 #include &quot;HostCallReturnValue.h&quot;
  71 #include &quot;Identifier.h&quot;
  72 #include &quot;IncrementalSweeper.h&quot;
  73 #include &quot;IndirectEvalExecutable.h&quot;
  74 #include &quot;Interpreter.h&quot;
  75 #include &quot;IntlCollatorConstructor.h&quot;
  76 #include &quot;IntlDateTimeFormatConstructor.h&quot;
  77 #include &quot;IntlNumberFormatConstructor.h&quot;
  78 #include &quot;IntlPluralRulesConstructor.h&quot;
<span class="line-added">  79 #include &quot;IsoHeapCellType.h&quot;</span>
<span class="line-added">  80 #include &quot;IsoInlinedHeapCellType.h&quot;</span>
  81 #include &quot;JITCode.h&quot;
  82 #include &quot;JITWorklist.h&quot;
<span class="line-added">  83 #include &quot;JSAPIGlobalObject.h&quot;</span>
  84 #include &quot;JSAPIValueWrapper.h&quot;
<span class="line-added">  85 #include &quot;JSAPIWrapperObject.h&quot;</span>
  86 #include &quot;JSArray.h&quot;
<span class="line-added">  87 #include &quot;JSArrayBuffer.h&quot;</span>
  88 #include &quot;JSArrayBufferConstructor.h&quot;
<span class="line-added">  89 #include &quot;JSArrayIterator.h&quot;</span>
  90 #include &quot;JSAsyncFunction.h&quot;
<span class="line-added">  91 #include &quot;JSAsyncGenerator.h&quot;</span>
  92 #include &quot;JSBigInt.h&quot;
  93 #include &quot;JSBoundFunction.h&quot;
  94 #include &quot;JSCInlines.h&quot;
<span class="line-added">  95 #include &quot;JSCallbackConstructor.h&quot;</span>
  96 #include &quot;JSCallbackFunction.h&quot;
<span class="line-added">  97 #include &quot;JSCallbackObject.h&quot;</span>
<span class="line-added">  98 #include &quot;JSCallee.h&quot;</span>
  99 #include &quot;JSCustomGetterSetterFunction.h&quot;
 100 #include &quot;JSDestructibleObjectHeapCellType.h&quot;

 101 #include &quot;JSFunction.h&quot;
<span class="line-added"> 102 #include &quot;JSGlobalLexicalEnvironment.h&quot;</span>
<span class="line-added"> 103 #include &quot;JSGlobalObject.h&quot;</span>
 104 #include &quot;JSGlobalObjectFunctions.h&quot;
 105 #include &quot;JSImmutableButterfly.h&quot;
<span class="line-modified"> 106 #include &quot;JSInternalPromise.h&quot;</span>
 107 #include &quot;JSLock.h&quot;
 108 #include &quot;JSMap.h&quot;
 109 #include &quot;JSMapIterator.h&quot;
<span class="line-modified"> 110 #include &quot;JSModuleNamespaceObject.h&quot;</span>
<span class="line-added"> 111 #include &quot;JSModuleRecord.h&quot;</span>
<span class="line-added"> 112 #include &quot;JSNativeStdFunction.h&quot;</span>
<span class="line-added"> 113 #include &quot;JSPromise.h&quot;</span>
 114 #include &quot;JSPropertyNameEnumerator.h&quot;
<span class="line-added"> 115 #include &quot;JSProxy.h&quot;</span>
 116 #include &quot;JSScriptFetchParameters.h&quot;
 117 #include &quot;JSScriptFetcher.h&quot;
 118 #include &quot;JSSet.h&quot;
 119 #include &quot;JSSetIterator.h&quot;
 120 #include &quot;JSSourceCode.h&quot;
<span class="line-modified"> 121 #include &quot;JSStringIterator.h&quot;</span>
 122 #include &quot;JSTemplateObjectDescriptor.h&quot;
<span class="line-added"> 123 #include &quot;JSToWasmICCallee.h&quot;</span>
<span class="line-added"> 124 #include &quot;JSTypedArrays.h&quot;</span>
 125 #include &quot;JSWeakMap.h&quot;
 126 #include &quot;JSWeakObjectRef.h&quot;
 127 #include &quot;JSWeakSet.h&quot;
 128 #include &quot;JSWebAssembly.h&quot;
 129 #include &quot;JSWebAssemblyCodeBlock.h&quot;
<span class="line-modified"> 130 #include &quot;JSWebAssemblyGlobal.h&quot;</span>
<span class="line-added"> 131 #include &quot;JSWebAssemblyInstance.h&quot;</span>
<span class="line-added"> 132 #include &quot;JSWebAssemblyMemory.h&quot;</span>
<span class="line-added"> 133 #include &quot;JSWebAssemblyModule.h&quot;</span>
<span class="line-added"> 134 #include &quot;JSWebAssemblyTable.h&quot;</span>
 135 #include &quot;JSWithScope.h&quot;
 136 #include &quot;LLIntData.h&quot;
 137 #include &quot;Lexer.h&quot;
 138 #include &quot;Lookup.h&quot;
 139 #include &quot;MinimumReservedZoneSize.h&quot;
 140 #include &quot;ModuleProgramCodeBlock.h&quot;
 141 #include &quot;ModuleProgramExecutable.h&quot;
<span class="line-added"> 142 #include &quot;NarrowingNumberPredictionFuzzerAgent.h&quot;</span>
 143 #include &quot;NativeErrorConstructor.h&quot;
 144 #include &quot;NativeExecutable.h&quot;

 145 #include &quot;Nodes.h&quot;
<span class="line-modified"> 146 #include &quot;NumberObject.h&quot;</span>
 147 #include &quot;Parser.h&quot;
<span class="line-added"> 148 #include &quot;PredictionFileCreatingFuzzerAgent.h&quot;</span>
 149 #include &quot;ProfilerDatabase.h&quot;
 150 #include &quot;ProgramCodeBlock.h&quot;
 151 #include &quot;ProgramExecutable.h&quot;
<span class="line-modified"> 152 #include &quot;PromiseTimer.h&quot;</span>
 153 #include &quot;PropertyMapHashTable.h&quot;
 154 #include &quot;ProxyRevoke.h&quot;
 155 #include &quot;RandomizingFuzzerAgent.h&quot;
 156 #include &quot;RegExpCache.h&quot;
 157 #include &quot;RegExpObject.h&quot;
 158 #include &quot;RegisterAtOffsetList.h&quot;
 159 #include &quot;RuntimeType.h&quot;
 160 #include &quot;SamplingProfiler.h&quot;
<span class="line-added"> 161 #include &quot;ScopedArguments.h&quot;</span>
 162 #include &quot;ShadowChicken.h&quot;
 163 #include &quot;SimpleTypedArrayController.h&quot;
 164 #include &quot;SourceProviderCache.h&quot;
 165 #include &quot;StackVisitor.h&quot;
 166 #include &quot;StrictEvalActivation.h&quot;
<span class="line-added"> 167 #include &quot;StringObject.h&quot;</span>
 168 #include &quot;StrongInlines.h&quot;
<span class="line-added"> 169 #include &quot;StructureChain.h&quot;</span>
 170 #include &quot;StructureInlines.h&quot;
<span class="line-added"> 171 #include &quot;SymbolObject.h&quot;</span>
 172 #include &quot;TestRunnerUtils.h&quot;
 173 #include &quot;ThunkGenerators.h&quot;
 174 #include &quot;TypeProfiler.h&quot;
 175 #include &quot;TypeProfilerLog.h&quot;
 176 #include &quot;UnlinkedCodeBlock.h&quot;
 177 #include &quot;VMEntryScope.h&quot;
 178 #include &quot;VMInlines.h&quot;
 179 #include &quot;VMInspector.h&quot;
 180 #include &quot;VariableEnvironment.h&quot;
 181 #include &quot;WasmWorklist.h&quot;
 182 #include &quot;Watchdog.h&quot;
 183 #include &quot;WeakGCMapInlines.h&quot;
 184 #include &quot;WebAssemblyFunction.h&quot;
<span class="line-modified"> 185 #include &quot;WebAssemblyModuleRecord.h&quot;</span>
 186 #include &quot;WebAssemblyWrapperFunction.h&quot;
<span class="line-added"> 187 #include &quot;WideningNumberPredictionFuzzerAgent.h&quot;</span>
 188 #include &lt;wtf/ProcessID.h&gt;
 189 #include &lt;wtf/ReadWriteLock.h&gt;
 190 #include &lt;wtf/SimpleStats.h&gt;
 191 #include &lt;wtf/StringPrintStream.h&gt;
 192 #include &lt;wtf/Threading.h&gt;
 193 #include &lt;wtf/text/AtomStringTable.h&gt;
 194 #include &lt;wtf/text/SymbolRegistry.h&gt;
 195 
 196 #if ENABLE(C_LOOP)
 197 #include &quot;CLoopStack.h&quot;
 198 #include &quot;CLoopStackInlines.h&quot;
 199 #endif
 200 
 201 #if ENABLE(DFG_JIT)
 202 #include &quot;ConservativeRoots.h&quot;
 203 #endif
 204 
 205 #if ENABLE(REGEXP_TRACING)
 206 #include &quot;RegExp.h&quot;
 207 #endif
 208 
<span class="line-added"> 209 #if JSC_OBJC_API_ENABLED</span>
<span class="line-added"> 210 #include &quot;ObjCCallbackFunction.h&quot;</span>
<span class="line-added"> 211 #endif</span>
<span class="line-added"> 212 </span>
<span class="line-added"> 213 #ifdef JSC_GLIB_API_ENABLED</span>
<span class="line-added"> 214 #include &quot;JSAPIWrapperGlobalObject.h&quot;</span>
<span class="line-added"> 215 #include &quot;JSCCallbackFunction.h&quot;</span>
<span class="line-added"> 216 #endif</span>
<span class="line-added"> 217 </span>
<span class="line-added"> 218 #if ENABLE(INTL)</span>
<span class="line-added"> 219 #include &quot;IntlCollator.h&quot;</span>
<span class="line-added"> 220 #include &quot;IntlDateTimeFormat.h&quot;</span>
<span class="line-added"> 221 #include &quot;IntlNumberFormat.h&quot;</span>
<span class="line-added"> 222 #include &quot;IntlPluralRules.h&quot;</span>
<span class="line-added"> 223 #endif</span>
<span class="line-added"> 224 </span>
 225 namespace JSC {
 226 
 227 #if ENABLE(JIT)
<span class="line-modified"> 228 #if ASSERT_ENABLED</span>
 229 bool VM::s_canUseJITIsSet = false;
 230 #endif
 231 bool VM::s_canUseJIT = false;
 232 #endif
 233 
 234 Atomic&lt;unsigned&gt; VM::s_numberOfIDs;
 235 
<span class="line-added"> 236 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(VM);</span>
<span class="line-added"> 237 </span>
 238 // Note: Platform.h will enforce that ENABLE(ASSEMBLER) is true if either
 239 // ENABLE(JIT) or ENABLE(YARR_JIT) or both are enabled. The code below
 240 // just checks for ENABLE(JIT) or ENABLE(YARR_JIT) with this premise in mind.
 241 
 242 #if ENABLE(ASSEMBLER)
 243 static bool enableAssembler()
 244 {
 245     if (!Options::useJIT())
 246         return false;
 247 
 248     char* canUseJITString = getenv(&quot;JavaScriptCoreUseJIT&quot;);
 249     if (canUseJITString &amp;&amp; !atoi(canUseJITString))
 250         return false;
 251 
 252     ExecutableAllocator::initializeUnderlyingAllocator();
 253     if (!ExecutableAllocator::singleton().isValid()) {
 254         if (Options::crashIfCantAllocateJITMemory())
 255             CRASH();
 256         return false;
 257     }
</pre>
<hr />
<pre>
 260 }
 261 #endif // ENABLE(!ASSEMBLER)
 262 
 263 bool VM::canUseAssembler()
 264 {
 265 #if ENABLE(ASSEMBLER)
 266     static std::once_flag onceKey;
 267     static bool enabled = false;
 268     std::call_once(onceKey, [] {
 269         enabled = enableAssembler();
 270     });
 271     return enabled;
 272 #else
 273     return false; // interpreter only
 274 #endif
 275 }
 276 
 277 void VM::computeCanUseJIT()
 278 {
 279 #if ENABLE(JIT)
<span class="line-modified"> 280 #if ASSERT_ENABLED</span>
 281     RELEASE_ASSERT(!s_canUseJITIsSet);
 282     s_canUseJITIsSet = true;
 283 #endif
 284     s_canUseJIT = VM::canUseAssembler() &amp;&amp; Options::useJIT();
 285 #endif
 286 }
 287 
 288 inline unsigned VM::nextID()
 289 {
 290     for (;;) {
 291         unsigned currentNumberOfIDs = s_numberOfIDs.load();
 292         unsigned newID = currentNumberOfIDs + 1;
 293         if (s_numberOfIDs.compareExchangeWeak(currentNumberOfIDs, newID))
 294             return newID;
 295     }
 296 }
 297 
 298 static bool vmCreationShouldCrash = false;
 299 
 300 VM::VM(VMType vmType, HeapType heapType)
 301     : m_id(nextID())
 302     , m_apiLock(adoptRef(new JSLock(this)))
 303 #if USE(CF)
 304     , m_runLoop(CFRunLoopGetCurrent())
 305 #endif // USE(CF)
<span class="line-added"> 306     , m_random(Options::seedOfVMRandomForFuzzer() ? Options::seedOfVMRandomForFuzzer() : cryptographicallyRandomNumber())</span>
<span class="line-added"> 307     , m_integrityRandom(*this)</span>
 308     , heap(*this, heapType)
 309     , fastMallocAllocator(makeUnique&lt;FastMallocAlignedMemoryAllocator&gt;())
 310     , primitiveGigacageAllocator(makeUnique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::Primitive))
 311     , jsValueGigacageAllocator(makeUnique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::JSValue))
 312     , auxiliaryHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::Auxiliary)))
 313     , immutableButterflyHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCellWithInteriorPointers)))
 314     , cellHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCell)))
 315     , destructibleCellHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(NeedsDestruction, HeapCell::JSCell)))
<span class="line-modified"> 316     , apiGlobalObjectHeapCellType(IsoHeapCellType::create&lt;JSAPIGlobalObject&gt;())</span>
<span class="line-added"> 317     , callbackConstructorHeapCellType(IsoHeapCellType::create&lt;JSCallbackConstructor&gt;())</span>
<span class="line-added"> 318     , callbackGlobalObjectHeapCellType(IsoHeapCellType::create&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;())</span>
<span class="line-added"> 319     , callbackObjectHeapCellType(IsoHeapCellType::create&lt;JSCallbackObject&lt;JSNonFinalObject&gt;&gt;())</span>
<span class="line-added"> 320     , dateInstanceHeapCellType(IsoHeapCellType::create&lt;DateInstance&gt;())</span>
<span class="line-added"> 321     , errorInstanceHeapCellType(IsoHeapCellType::create&lt;ErrorInstance&gt;())</span>
<span class="line-added"> 322     , globalLexicalEnvironmentHeapCellType(IsoHeapCellType::create&lt;JSGlobalLexicalEnvironment&gt;())</span>
<span class="line-added"> 323     , globalObjectHeapCellType(IsoHeapCellType::create&lt;JSGlobalObject&gt;())</span>
<span class="line-added"> 324     , jsModuleRecordHeapCellType(IsoHeapCellType::create&lt;JSModuleRecord&gt;())</span>
<span class="line-added"> 325     , moduleNamespaceObjectHeapCellType(IsoHeapCellType::create&lt;JSModuleNamespaceObject&gt;())</span>
<span class="line-added"> 326     , nativeStdFunctionHeapCellType(IsoHeapCellType::create&lt;JSNativeStdFunction&gt;())</span>
<span class="line-added"> 327     , stringHeapCellType(makeUnique&lt;IsoInlinedHeapCellType&lt;JSString&gt;&gt;())</span>
<span class="line-added"> 328     , weakMapHeapCellType(IsoHeapCellType::create&lt;JSWeakMap&gt;())</span>
<span class="line-added"> 329     , weakSetHeapCellType(IsoHeapCellType::create&lt;JSWeakSet&gt;())</span>
 330     , destructibleObjectHeapCellType(makeUnique&lt;JSDestructibleObjectHeapCellType&gt;())
<span class="line-added"> 331 #if JSC_OBJC_API_ENABLED</span>
<span class="line-added"> 332     , apiWrapperObjectHeapCellType(IsoHeapCellType::create&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;())</span>
<span class="line-added"> 333     , objCCallbackFunctionHeapCellType(IsoHeapCellType::create&lt;ObjCCallbackFunction&gt;())</span>
<span class="line-added"> 334 #endif</span>
<span class="line-added"> 335 #ifdef JSC_GLIB_API_ENABLED</span>
<span class="line-added"> 336     , apiWrapperObjectHeapCellType(IsoHeapCellType::create&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;())</span>
<span class="line-added"> 337     , callbackAPIWrapperGlobalObjectHeapCellType(IsoHeapCellType::create&lt;JSCallbackObject&lt;JSAPIWrapperGlobalObject&gt;&gt;())</span>
<span class="line-added"> 338     , jscCallbackFunctionHeapCellType(IsoHeapCellType::create&lt;JSCCallbackFunction&gt;())</span>
<span class="line-added"> 339 #endif</span>
<span class="line-added"> 340 #if ENABLE(INTL)</span>
<span class="line-added"> 341     , intlCollatorHeapCellType(IsoHeapCellType::create&lt;IntlCollator&gt;())</span>
<span class="line-added"> 342     , intlDateTimeFormatHeapCellType(IsoHeapCellType::create&lt;IntlDateTimeFormat&gt;())</span>
<span class="line-added"> 343     , intlNumberFormatHeapCellType(IsoHeapCellType::create&lt;IntlNumberFormat&gt;())</span>
<span class="line-added"> 344     , intlPluralRulesHeapCellType(IsoHeapCellType::create&lt;IntlPluralRules&gt;())</span>
<span class="line-added"> 345 #endif</span>
 346 #if ENABLE(WEBASSEMBLY)
<span class="line-modified"> 347     , webAssemblyCodeBlockHeapCellType(IsoHeapCellType::create&lt;JSWebAssemblyCodeBlock&gt;())</span>
<span class="line-modified"> 348     , webAssemblyFunctionHeapCellType(IsoHeapCellType::create&lt;WebAssemblyFunction&gt;())</span>
<span class="line-added"> 349     , webAssemblyGlobalHeapCellType(IsoHeapCellType::create&lt;JSWebAssemblyGlobal&gt;())</span>
<span class="line-added"> 350     , webAssemblyInstanceHeapCellType(IsoHeapCellType::create&lt;JSWebAssemblyInstance&gt;())</span>
<span class="line-added"> 351     , webAssemblyMemoryHeapCellType(IsoHeapCellType::create&lt;JSWebAssemblyMemory&gt;())</span>
<span class="line-added"> 352     , webAssemblyModuleHeapCellType(IsoHeapCellType::create&lt;JSWebAssemblyModule&gt;())</span>
<span class="line-added"> 353     , webAssemblyModuleRecordHeapCellType(IsoHeapCellType::create&lt;WebAssemblyModuleRecord&gt;())</span>
<span class="line-added"> 354     , webAssemblyTableHeapCellType(IsoHeapCellType::create&lt;JSWebAssemblyTable&gt;())</span>
 355 #endif
 356     , primitiveGigacageAuxiliarySpace(&quot;Primitive Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), primitiveGigacageAllocator.get()) // Hash:0x3e7cd762
 357     , jsValueGigacageAuxiliarySpace(&quot;JSValue Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x241e946
 358     , immutableButterflyJSValueGigacageAuxiliarySpace(&quot;ImmutableButterfly Gigacage JSCellWithInteriorPointers&quot;, heap, immutableButterflyHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x7a945300
 359     , cellSpace(&quot;JSCell&quot;, heap, cellHeapCellType.get(), fastMallocAllocator.get()) // Hash:0xadfb5a79
<span class="line-modified"> 360     , variableSizedCellSpace(&quot;Variable Sized JSCell&quot;, heap, cellHeapCellType.get(), fastMallocAllocator.get()) // Hash:0xbcd769cc</span>


 361     , destructibleObjectSpace(&quot;JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x4f5ed7a9
<span class="line-modified"> 362     , bigIntSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), JSBigInt)</span>
<span class="line-added"> 363     , calleeSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSCallee)</span>
<span class="line-added"> 364     , clonedArgumentsSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), ClonedArguments)</span>
<span class="line-added"> 365     , customGetterSetterSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), CustomGetterSetter)</span>
<span class="line-added"> 366     , dateInstanceSpace ISO_SUBSPACE_INIT(heap, dateInstanceHeapCellType.get(), DateInstance)</span>
<span class="line-added"> 367     , domAttributeGetterSetterSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), DOMAttributeGetterSetter)</span>
<span class="line-added"> 368     , exceptionSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), Exception)</span>
 369     , executableToCodeBlockEdgeSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), ExecutableToCodeBlockEdge) // Hash:0x7b730b20
 370     , functionSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSFunction) // Hash:0x800fca72
<span class="line-modified"> 371     , getterSetterSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), GetterSetter)</span>
<span class="line-added"> 372     , globalLexicalEnvironmentSpace ISO_SUBSPACE_INIT(heap, globalLexicalEnvironmentHeapCellType.get(), JSGlobalLexicalEnvironment)</span>
<span class="line-added"> 373     , internalFunctionSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), InternalFunction) // Hash:0xf845c464</span>
<span class="line-added"> 374     , jsProxySpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSProxy)</span>
 375     , nativeExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), NativeExecutable) // Hash:0x67567f95
<span class="line-added"> 376     , numberObjectSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), NumberObject)</span>
<span class="line-added"> 377     , promiseSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSPromise)</span>
<span class="line-added"> 378     , propertyNameEnumeratorSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSPropertyNameEnumerator)</span>
 379     , propertyTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), PropertyTable) // Hash:0xc6bc9f12
<span class="line-added"> 380     , regExpSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), RegExp)</span>
<span class="line-added"> 381     , regExpObjectSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), RegExpObject)</span>
<span class="line-added"> 382     , ropeStringSpace ISO_SUBSPACE_INIT(heap, stringHeapCellType.get(), JSRopeString)</span>
<span class="line-added"> 383     , scopedArgumentsSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), ScopedArguments)</span>
<span class="line-added"> 384     , sparseArrayValueMapSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), SparseArrayValueMap)</span>
<span class="line-added"> 385     , stringSpace ISO_SUBSPACE_INIT(heap, stringHeapCellType.get(), JSString) // Hash:0x90cf758f</span>
<span class="line-added"> 386     , stringObjectSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), StringObject)</span>
<span class="line-added"> 387     , structureChainSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), StructureChain)</span>
 388     , structureRareDataSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), StructureRareData) // Hash:0xaca4e62d
 389     , structureSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), Structure) // Hash:0x1f1bcdca
 390     , symbolTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), SymbolTable) // Hash:0xc5215afd
 391     , executableToCodeBlockEdgesWithConstraints(executableToCodeBlockEdgeSpace)
 392     , executableToCodeBlockEdgesWithFinalizers(executableToCodeBlockEdgeSpace)
 393     , codeBlockSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), CodeBlock) // Hash:0x77e66ec9
 394     , functionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), FunctionExecutable) // Hash:0x5d158f3
 395     , programExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), ProgramExecutable) // Hash:0x527c77e7
 396     , unlinkedFunctionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), UnlinkedFunctionExecutable) // Hash:0xf6b828d9
 397     , vmType(vmType)
 398     , clientData(0)
 399     , topEntryFrame(nullptr)
 400     , topCallFrame(CallFrame::noCaller())
<span class="line-modified"> 401     , promiseTimer(PromiseTimer::create(*this))</span>
 402     , m_atomStringTable(vmType == Default ? Thread::current().atomStringTable() : new AtomStringTable)
 403     , propertyNames(nullptr)
 404     , emptyList(new ArgList)
 405     , machineCodeBytesPerBytecodeWordForBaselineJIT(makeUnique&lt;SimpleStats&gt;())
 406     , customGetterSetterFunctionMap(*this)
 407     , stringCache(*this)
 408     , symbolImplToSymbolMap(*this)
 409     , structureCache(*this)
 410     , interpreter(0)
 411     , entryScope(0)
 412     , m_regExpCache(new RegExpCache(this))
 413     , m_compactVariableMap(adoptRef(*(new CompactVariableMap)))
 414 #if ENABLE(REGEXP_TRACING)
 415     , m_rtTraceList(new RTTraceList())
 416 #endif
 417 #if ENABLE(GC_VALIDATION)
 418     , m_initializingObjectClass(0)
 419 #endif
 420     , m_stackPointerAtVMEntry(0)
 421     , m_codeCache(makeUnique&lt;CodeCache&gt;())
</pre>
<hr />
<pre>
 429 
 430     interpreter = new Interpreter(*this);
 431     StackBounds stack = Thread::current().stack();
 432     updateSoftReservedZoneSize(Options::softReservedZoneSize());
 433     setLastStackTop(stack.origin());
 434 
 435     JSRunLoopTimer::Manager::shared().registerVM(*this);
 436 
 437     // Need to be careful to keep everything consistent here
 438     JSLockHolder lock(this);
 439     AtomStringTable* existingEntryAtomStringTable = Thread::current().setCurrentAtomStringTable(m_atomStringTable);
 440     structureStructure.set(*this, Structure::createStructure(*this));
 441     structureRareDataStructure.set(*this, StructureRareData::createStructure(*this, 0, jsNull()));
 442     stringStructure.set(*this, JSString::createStructure(*this, 0, jsNull()));
 443 
 444     smallStrings.initializeCommonStrings(*this);
 445 
 446     propertyNames = new CommonIdentifiers(*this);
 447     terminatedExecutionErrorStructure.set(*this, TerminatedExecutionError::createStructure(*this, 0, jsNull()));
 448     propertyNameEnumeratorStructure.set(*this, JSPropertyNameEnumerator::createStructure(*this, 0, jsNull()));
<span class="line-added"> 449     getterSetterStructure.set(*this, GetterSetter::createStructure(*this, 0, jsNull()));</span>
 450     customGetterSetterStructure.set(*this, CustomGetterSetter::createStructure(*this, 0, jsNull()));
 451     domAttributeGetterSetterStructure.set(*this, DOMAttributeGetterSetter::createStructure(*this, 0, jsNull()));
 452     scopedArgumentsTableStructure.set(*this, ScopedArgumentsTable::createStructure(*this, 0, jsNull()));
 453     apiWrapperStructure.set(*this, JSAPIValueWrapper::createStructure(*this, 0, jsNull()));
 454     nativeExecutableStructure.set(*this, NativeExecutable::createStructure(*this, 0, jsNull()));
 455     evalExecutableStructure.set(*this, EvalExecutable::createStructure(*this, 0, jsNull()));
 456     programExecutableStructure.set(*this, ProgramExecutable::createStructure(*this, 0, jsNull()));
 457     functionExecutableStructure.set(*this, FunctionExecutable::createStructure(*this, 0, jsNull()));
 458 #if ENABLE(WEBASSEMBLY)
 459     webAssemblyCodeBlockStructure.set(*this, JSWebAssemblyCodeBlock::createStructure(*this, 0, jsNull()));
 460 #endif
 461     moduleProgramExecutableStructure.set(*this, ModuleProgramExecutable::createStructure(*this, 0, jsNull()));
 462     regExpStructure.set(*this, RegExp::createStructure(*this, 0, jsNull()));
 463     symbolStructure.set(*this, Symbol::createStructure(*this, 0, jsNull()));
 464     symbolTableStructure.set(*this, SymbolTable::createStructure(*this, 0, jsNull()));

 465 
 466     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithInt32) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithInt32));
 467     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithDouble) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithDouble));
 468     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithContiguous));
 469 
 470     sourceCodeStructure.set(*this, JSSourceCode::createStructure(*this, 0, jsNull()));
 471     scriptFetcherStructure.set(*this, JSScriptFetcher::createStructure(*this, 0, jsNull()));
 472     scriptFetchParametersStructure.set(*this, JSScriptFetchParameters::createStructure(*this, 0, jsNull()));
 473     structureChainStructure.set(*this, StructureChain::createStructure(*this, 0, jsNull()));
 474     sparseArrayValueMapStructure.set(*this, SparseArrayValueMap::createStructure(*this, 0, jsNull()));
 475     templateObjectDescriptorStructure.set(*this, JSTemplateObjectDescriptor::createStructure(*this, 0, jsNull()));

 476     unlinkedFunctionExecutableStructure.set(*this, UnlinkedFunctionExecutable::createStructure(*this, 0, jsNull()));
 477     unlinkedProgramCodeBlockStructure.set(*this, UnlinkedProgramCodeBlock::createStructure(*this, 0, jsNull()));
 478     unlinkedEvalCodeBlockStructure.set(*this, UnlinkedEvalCodeBlock::createStructure(*this, 0, jsNull()));
 479     unlinkedFunctionCodeBlockStructure.set(*this, UnlinkedFunctionCodeBlock::createStructure(*this, 0, jsNull()));
 480     unlinkedModuleProgramCodeBlockStructure.set(*this, UnlinkedModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
 481     propertyTableStructure.set(*this, PropertyTable::createStructure(*this, 0, jsNull()));
 482     functionRareDataStructure.set(*this, FunctionRareData::createStructure(*this, 0, jsNull()));
 483     exceptionStructure.set(*this, Exception::createStructure(*this, 0, jsNull()));



 484     programCodeBlockStructure.set(*this, ProgramCodeBlock::createStructure(*this, 0, jsNull()));
 485     moduleProgramCodeBlockStructure.set(*this, ModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
 486     evalCodeBlockStructure.set(*this, EvalCodeBlock::createStructure(*this, 0, jsNull()));
 487     functionCodeBlockStructure.set(*this, FunctionCodeBlock::createStructure(*this, 0, jsNull()));
 488     hashMapBucketSetStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKey&gt;::createStructure(*this, 0, jsNull()));
 489     hashMapBucketMapStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::createStructure(*this, 0, jsNull()));
 490     bigIntStructure.set(*this, JSBigInt::createStructure(*this, 0, jsNull()));
 491     executableToCodeBlockEdgeStructure.set(*this, ExecutableToCodeBlockEdge::createStructure(*this, nullptr, jsNull()));
 492 
 493     // Eagerly initialize constant cells since the concurrent compiler can access them.
 494     if (canUseJIT()) {
 495         sentinelMapBucket();
 496         sentinelSetBucket();
 497     }
<span class="line-added"> 498     bigIntConstantOne.set(*this, JSBigInt::createFrom(*this, 1));</span>
 499 
 500     Thread::current().setCurrentAtomStringTable(existingEntryAtomStringTable);
 501 
 502 #if !ENABLE(C_LOOP)
 503     initializeHostCallReturnValue(); // This is needed to convince the linker not to drop host call return support.
 504 #endif
 505 
 506     Gigacage::addPrimitiveDisableCallback(primitiveGigacageDisabledCallback, this);
 507 
 508     heap.notifyIsSafeToCollect();
 509 
 510     LLInt::Data::performAssertions(*this);
 511 
 512     if (UNLIKELY(Options::useProfiler())) {
 513         m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(*this);
 514 
 515         StringPrintStream pathOut;
 516         const char* profilerPath = getenv(&quot;JSC_PROFILER_PATH&quot;);
 517         if (profilerPath)
 518             pathOut.print(profilerPath, &quot;/&quot;);
</pre>
<hr />
<pre>
 529     m_bytecodeIntrinsicRegistry = makeUnique&lt;BytecodeIntrinsicRegistry&gt;(*this);
 530 
 531     if (Options::useTypeProfiler())
 532         enableTypeProfiler();
 533     if (Options::useControlFlowProfiler())
 534         enableControlFlowProfiler();
 535 #if ENABLE(SAMPLING_PROFILER)
 536     if (Options::useSamplingProfiler()) {
 537         setShouldBuildPCToCodeOriginMapping();
 538         Ref&lt;Stopwatch&gt; stopwatch = Stopwatch::create();
 539         stopwatch-&gt;start();
 540         m_samplingProfiler = adoptRef(new SamplingProfiler(*this, WTFMove(stopwatch)));
 541         if (Options::samplingProfilerPath())
 542             m_samplingProfiler-&gt;registerForReportAtExit();
 543         m_samplingProfiler-&gt;start();
 544     }
 545 #endif // ENABLE(SAMPLING_PROFILER)
 546 
 547     if (Options::useRandomizingFuzzerAgent())
 548         setFuzzerAgent(makeUnique&lt;RandomizingFuzzerAgent&gt;(*this));
<span class="line-modified"> 549     if (Options::useDoublePredictionFuzzerAgent())</span>
 550         setFuzzerAgent(makeUnique&lt;DoublePredictionFuzzerAgent&gt;(*this));
<span class="line-added"> 551     if (Options::useFileBasedFuzzerAgent())</span>
<span class="line-added"> 552         setFuzzerAgent(makeUnique&lt;FileBasedFuzzerAgent&gt;(*this));</span>
<span class="line-added"> 553     if (Options::usePredictionFileCreatingFuzzerAgent())</span>
<span class="line-added"> 554         setFuzzerAgent(makeUnique&lt;PredictionFileCreatingFuzzerAgent&gt;(*this));</span>
<span class="line-added"> 555     if (Options::useNarrowingNumberPredictionFuzzerAgent())</span>
<span class="line-added"> 556         setFuzzerAgent(makeUnique&lt;NarrowingNumberPredictionFuzzerAgent&gt;(*this));</span>
<span class="line-added"> 557     if (Options::useWideningNumberPredictionFuzzerAgent())</span>
<span class="line-added"> 558         setFuzzerAgent(makeUnique&lt;WideningNumberPredictionFuzzerAgent&gt;(*this));</span>
 559 
 560     if (Options::alwaysGeneratePCToCodeOriginMap())
 561         setShouldBuildPCToCodeOriginMapping();
 562 
 563     if (Options::watchdog()) {
 564         Watchdog&amp; watchdog = ensureWatchdog();
 565         watchdog.setTimeLimit(Seconds::fromMilliseconds(Options::watchdog()));
 566     }
 567 
 568 #if ENABLE(JIT)
 569     // Make sure that any stubs that the JIT is going to use are initialized in non-compilation threads.
 570     if (canUseJIT()) {
 571         jitStubs = makeUnique&lt;JITThunks&gt;();
 572 #if ENABLE(FTL_JIT)
 573         ftlThunks = makeUnique&lt;FTL::Thunks&gt;();
 574 #endif // ENABLE(FTL_JIT)
 575         getCTIInternalFunctionTrampolineFor(CodeForCall);
 576         getCTIInternalFunctionTrampolineFor(CodeForConstruct);
 577     }
 578 #endif
 579 
 580     if (Options::forceDebuggerBytecodeGeneration() || Options::alwaysUseShadowChicken())
 581         ensureShadowChicken();
 582 
 583     VMInspector::instance().add(this);
<span class="line-added"> 584 </span>
<span class="line-added"> 585     if (!g_jscConfig.disabledFreezingForTesting)</span>
<span class="line-added"> 586         Config::permanentlyFreeze();</span>
 587 }
 588 
 589 static ReadWriteLock s_destructionLock;
 590 
 591 void waitForVMDestruction()
 592 {
 593     auto locker = holdLock(s_destructionLock.write());
 594 }
 595 
 596 VM::~VM()
 597 {
 598     auto destructionLocker = holdLock(s_destructionLock.read());
 599 
 600     Gigacage::removePrimitiveDisableCallback(primitiveGigacageDisabledCallback, this);
<span class="line-modified"> 601     promiseTimer-&gt;stopRunningTasks();</span>
 602 #if ENABLE(WEBASSEMBLY)
 603     if (Wasm::Worklist* worklist = Wasm::existingWorklistOrNull())
 604         worklist-&gt;stopAllPlansForContext(wasmContext);
 605 #endif
 606     if (UNLIKELY(m_watchdog))
 607         m_watchdog-&gt;willDestroyVM(this);
 608     m_traps.willDestroyVM();
 609     VMInspector::instance().remove(this);
 610 
 611     // Never GC, ever again.
 612     heap.incrementDeferralDepth();
 613 
 614 #if ENABLE(SAMPLING_PROFILER)
 615     if (m_samplingProfiler) {
 616         m_samplingProfiler-&gt;reportDataToOptionFile();
 617         m_samplingProfiler-&gt;shutdown();
 618     }
 619 #endif // ENABLE(SAMPLING_PROFILER)
 620 
 621 #if ENABLE(JIT)
</pre>
<hr />
<pre>
 650     delete interpreter;
 651 #ifndef NDEBUG
 652     interpreter = reinterpret_cast&lt;Interpreter*&gt;(0xbbadbeef);
 653 #endif
 654 
 655     delete emptyList;
 656 
 657     delete propertyNames;
 658     if (vmType != Default)
 659         delete m_atomStringTable;
 660 
 661     delete clientData;
 662     delete m_regExpCache;
 663 
 664 #if ENABLE(REGEXP_TRACING)
 665     delete m_rtTraceList;
 666 #endif
 667 
 668 #if ENABLE(DFG_JIT)
 669     for (unsigned i = 0; i &lt; m_scratchBuffers.size(); ++i)
<span class="line-modified"> 670         VMMalloc::free(m_scratchBuffers[i]);</span>
 671 #endif
 672 }
 673 
 674 void VM::primitiveGigacageDisabledCallback(void* argument)
 675 {
 676     static_cast&lt;VM*&gt;(argument)-&gt;primitiveGigacageDisabled();
 677 }
 678 
 679 void VM::primitiveGigacageDisabled()
 680 {
 681     if (m_apiLock-&gt;currentThreadIsHoldingLock()) {
 682         m_primitiveGigacageEnabled.fireAll(*this, &quot;Primitive gigacage disabled&quot;);
 683         return;
 684     }
 685 
 686     // This is totally racy, and that&#39;s OK. The point is, it&#39;s up to the user to ensure that they pass the
 687     // uncaged buffer in a nicely synchronized manner.
 688     m_needToFirePrimitiveGigacageEnabled = true;
 689 }
 690 
</pre>
<hr />
<pre>
 737     return *m_heapProfiler;
 738 }
 739 
 740 #if ENABLE(SAMPLING_PROFILER)
 741 SamplingProfiler&amp; VM::ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp; stopwatch)
 742 {
 743     if (!m_samplingProfiler)
 744         m_samplingProfiler = adoptRef(new SamplingProfiler(*this, WTFMove(stopwatch)));
 745     return *m_samplingProfiler;
 746 }
 747 #endif // ENABLE(SAMPLING_PROFILER)
 748 
 749 #if ENABLE(JIT)
 750 static ThunkGenerator thunkGeneratorForIntrinsic(Intrinsic intrinsic)
 751 {
 752     switch (intrinsic) {
 753     case CharCodeAtIntrinsic:
 754         return charCodeAtThunkGenerator;
 755     case CharAtIntrinsic:
 756         return charAtThunkGenerator;
<span class="line-added"> 757     case StringPrototypeCodePointAtIntrinsic:</span>
<span class="line-added"> 758         return stringPrototypeCodePointAtThunkGenerator;</span>
 759     case Clz32Intrinsic:
 760         return clz32ThunkGenerator;
 761     case FromCharCodeIntrinsic:
 762         return fromCharCodeThunkGenerator;
 763     case SqrtIntrinsic:
 764         return sqrtThunkGenerator;
 765     case AbsIntrinsic:
 766         return absThunkGenerator;
 767     case FloorIntrinsic:
 768         return floorThunkGenerator;
 769     case CeilIntrinsic:
 770         return ceilThunkGenerator;
 771     case TruncIntrinsic:
 772         return truncThunkGenerator;
 773     case RoundIntrinsic:
 774         return roundThunkGenerator;
 775     case ExpIntrinsic:
 776         return expThunkGenerator;
 777     case LogIntrinsic:
 778         return logThunkGenerator;
 779     case IMulIntrinsic:
 780         return imulThunkGenerator;
 781     case RandomIntrinsic:
 782         return randomThunkGenerator;
<span class="line-modified"> 783     case BoundFunctionCallIntrinsic:</span>
<span class="line-modified"> 784         return boundFunctionCallGenerator;</span>
 785     default:
 786         return nullptr;
 787     }
 788 }
 789 
 790 #endif // ENABLE(JIT)
 791 
 792 NativeExecutable* VM::getHostFunction(NativeFunction function, NativeFunction constructor, const String&amp; name)
 793 {
 794     return getHostFunction(function, NoIntrinsic, constructor, nullptr, name);
 795 }
 796 
 797 static Ref&lt;NativeJITCode&gt; jitCodeForCallTrampoline()
 798 {
 799     static NativeJITCode* result;
 800     static std::once_flag onceKey;
 801     std::call_once(onceKey, [&amp;] {
 802         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_call_trampoline), JITType::HostCallThunk, NoIntrinsic);
 803     });
 804     return makeRef(*result);
</pre>
<hr />
<pre>
 812         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_construct_trampoline), JITType::HostCallThunk, NoIntrinsic);
 813     });
 814     return makeRef(*result);
 815 }
 816 
 817 NativeExecutable* VM::getHostFunction(NativeFunction function, Intrinsic intrinsic, NativeFunction constructor, const DOMJIT::Signature* signature, const String&amp; name)
 818 {
 819 #if ENABLE(JIT)
 820     if (canUseJIT()) {
 821         return jitStubs-&gt;hostFunctionStub(
 822             *this, function, constructor,
 823             intrinsic != NoIntrinsic ? thunkGeneratorForIntrinsic(intrinsic) : 0,
 824             intrinsic, signature, name);
 825     }
 826 #endif // ENABLE(JIT)
 827     UNUSED_PARAM(intrinsic);
 828     UNUSED_PARAM(signature);
 829     return NativeExecutable::create(*this, jitCodeForCallTrampoline(), function, jitCodeForConstructTrampoline(), constructor, name);
 830 }
 831 
<span class="line-added"> 832 NativeExecutable* VM::getBoundFunction(bool isJSFunction, bool canConstruct)</span>
<span class="line-added"> 833 {</span>
<span class="line-added"> 834     bool slowCase = !isJSFunction;</span>
<span class="line-added"> 835 </span>
<span class="line-added"> 836     auto getOrCreate = [&amp;] (Weak&lt;NativeExecutable&gt;&amp; slot) -&gt; NativeExecutable* {</span>
<span class="line-added"> 837         if (auto* cached = slot.get())</span>
<span class="line-added"> 838             return cached;</span>
<span class="line-added"> 839         NativeExecutable* result = getHostFunction(</span>
<span class="line-added"> 840             slowCase ? boundFunctionCall : boundThisNoArgsFunctionCall,</span>
<span class="line-added"> 841             slowCase ? NoIntrinsic : BoundFunctionCallIntrinsic,</span>
<span class="line-added"> 842             canConstruct ? (slowCase ? boundFunctionConstruct : boundThisNoArgsFunctionConstruct) : callHostFunctionAsConstructor, nullptr, String());</span>
<span class="line-added"> 843         slot = Weak&lt;NativeExecutable&gt;(result);</span>
<span class="line-added"> 844         return result;</span>
<span class="line-added"> 845     };</span>
<span class="line-added"> 846 </span>
<span class="line-added"> 847     if (slowCase) {</span>
<span class="line-added"> 848         if (canConstruct)</span>
<span class="line-added"> 849             return getOrCreate(m_slowCanConstructBoundExecutable);</span>
<span class="line-added"> 850         return getOrCreate(m_slowBoundExecutable);</span>
<span class="line-added"> 851     }</span>
<span class="line-added"> 852     if (canConstruct)</span>
<span class="line-added"> 853         return getOrCreate(m_fastCanConstructBoundExecutable);</span>
<span class="line-added"> 854     return getOrCreate(m_fastBoundExecutable);</span>
<span class="line-added"> 855 }</span>
<span class="line-added"> 856 </span>
 857 MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; VM::getCTIInternalFunctionTrampolineFor(CodeSpecializationKind kind)
 858 {
 859 #if ENABLE(JIT)
 860     if (canUseJIT()) {
 861         if (kind == CodeForCall)
 862             return jitStubs-&gt;ctiInternalFunctionCall(*this).retagged&lt;JSEntryPtrTag&gt;();
 863         return jitStubs-&gt;ctiInternalFunctionConstruct(*this).retagged&lt;JSEntryPtrTag&gt;();
 864     }
 865 #endif
 866     if (kind == CodeForCall)
 867         return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_call_trampoline);
 868     return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_construct_trampoline);
 869 }
 870 
 871 VM::ClientData::~ClientData()
 872 {
 873 }
 874 
 875 void VM::resetDateCache()
 876 {
</pre>
<hr />
<pre>
 917         heap.collectNow(Synchronousness::Sync, CollectionScope::Full);
 918         // FIXME: Consider stopping various automatic threads here.
 919         // https://bugs.webkit.org/show_bug.cgi?id=185447
 920         WTF::releaseFastMallocFreeMemory();
 921     });
 922 }
 923 
 924 SourceProviderCache* VM::addSourceProviderCache(SourceProvider* sourceProvider)
 925 {
 926     auto addResult = sourceProviderCacheMap.add(sourceProvider, nullptr);
 927     if (addResult.isNewEntry)
 928         addResult.iterator-&gt;value = adoptRef(new SourceProviderCache);
 929     return addResult.iterator-&gt;value.get();
 930 }
 931 
 932 void VM::clearSourceProviderCaches()
 933 {
 934     sourceProviderCacheMap.clear();
 935 }
 936 
<span class="line-modified"> 937 Exception* VM::throwException(JSGlobalObject* globalObject, Exception* exception)</span>
 938 {
<span class="line-modified"> 939     CallFrame* throwOriginFrame = topJSCallFrame();</span>
<span class="line-modified"> 940     if (!throwOriginFrame)</span>
<span class="line-added"> 941         throwOriginFrame = globalObject-&gt;deprecatedCallFrameForDebugger();</span>
 942 
<span class="line-modified"> 943     if (UNLIKELY(Options::breakOnThrow())) {</span>
 944         CodeBlock* codeBlock = throwOriginFrame ? throwOriginFrame-&gt;codeBlock() : nullptr;
 945         dataLog(&quot;Throwing exception in call frame &quot;, RawPointer(throwOriginFrame), &quot; for code block &quot;, codeBlock, &quot;\n&quot;);
 946         CRASH();
 947     }
 948 
<span class="line-modified"> 949     interpreter-&gt;notifyDebuggerOfExceptionToBeThrown(*this, globalObject, throwOriginFrame, exception);</span>
 950 
 951     setException(exception);
 952 
 953 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 954     m_nativeStackTraceOfLastThrow = StackTrace::captureStackTrace(Options::unexpectedExceptionStackTraceLimit());
 955     m_throwingThread = &amp;Thread::current();
 956 #endif
 957     return exception;
 958 }
 959 
<span class="line-modified"> 960 Exception* VM::throwException(JSGlobalObject* globalObject, JSValue thrownValue)</span>
 961 {
 962     VM&amp; vm = *this;
 963     Exception* exception = jsDynamicCast&lt;Exception*&gt;(vm, thrownValue);
 964     if (!exception)
 965         exception = Exception::create(*this, thrownValue);
 966 
<span class="line-modified"> 967     return throwException(globalObject, exception);</span>
 968 }
 969 
<span class="line-modified"> 970 Exception* VM::throwException(JSGlobalObject* globalObject, JSObject* error)</span>
 971 {
<span class="line-modified"> 972     return throwException(globalObject, JSValue(error));</span>
 973 }
 974 
 975 void VM::setStackPointerAtVMEntry(void* sp)
 976 {
 977     m_stackPointerAtVMEntry = sp;
 978     updateStackLimits();
 979 }
 980 
 981 size_t VM::updateSoftReservedZoneSize(size_t softReservedZoneSize)
 982 {
 983     size_t oldSoftReservedZoneSize = m_currentSoftReservedZoneSize;
 984     m_currentSoftReservedZoneSize = softReservedZoneSize;
 985 #if ENABLE(C_LOOP)
 986     interpreter-&gt;cloopStack().setSoftReservedZoneSize(softReservedZoneSize);
 987 #endif
 988 
 989     updateStackLimits();
 990 
 991     return oldSoftReservedZoneSize;
 992 }
</pre>
<hr />
<pre>
 999 // When using the C stack on Windows we need to precommit the needed stack space.
1000 // Otherwise we might crash later if we access uncommitted stack memory.
1001 // This can happen if we allocate stack space larger than the page guard size (4K).
1002 // The system does not get the chance to move the guard page, and commit more memory,
1003 // and we crash if uncommitted memory is accessed.
1004 // The MSVC compiler fixes this by inserting a call to the _chkstk() function,
1005 // when needed, see http://support.microsoft.com/kb/100775.
1006 // By touching every page up to the stack limit with a dummy operation,
1007 // we force the system to move the guard page, and commit memory.
1008 
1009 static void preCommitStackMemory(void* stackLimit)
1010 {
1011     const int pageSize = 4096;
1012     for (volatile char* p = reinterpret_cast&lt;char*&gt;(&amp;stackLimit); p &gt; stackLimit; p -= pageSize) {
1013         char ch = *p;
1014         *p = ch;
1015     }
1016 }
1017 #endif
1018 
<span class="line-modified">1019 void VM::updateStackLimits()</span>
1020 {
1021 #if OS(WINDOWS)
1022     void* lastSoftStackLimit = m_softStackLimit;
1023 #endif
1024 
1025     const StackBounds&amp; stack = Thread::current().stack();
1026     size_t reservedZoneSize = Options::reservedZoneSize();
1027     // We should have already ensured that Options::reservedZoneSize() &gt;= minimumReserveZoneSize at
1028     // options initialization time, and the option value should not have been changed thereafter.
1029     // We don&#39;t have the ability to assert here that it hasn&#39;t changed, but we can at least assert
1030     // that the value is sane.
1031     RELEASE_ASSERT(reservedZoneSize &gt;= minimumReservedZoneSize);
1032 
1033     if (m_stackPointerAtVMEntry) {

1034         char* startOfStack = reinterpret_cast&lt;char*&gt;(m_stackPointerAtVMEntry);
1035         m_softStackLimit = stack.recursionLimit(startOfStack, Options::maxPerThreadStackUsage(), m_currentSoftReservedZoneSize);
1036         m_stackLimit = stack.recursionLimit(startOfStack, Options::maxPerThreadStackUsage(), reservedZoneSize);
1037     } else {
1038         m_softStackLimit = stack.recursionLimit(m_currentSoftReservedZoneSize);
1039         m_stackLimit = stack.recursionLimit(reservedZoneSize);
1040     }
1041 
1042 #if OS(WINDOWS)
1043     // We only need to precommit stack memory dictated by the VM::m_softStackLimit limit.
1044     // This is because VM::m_softStackLimit applies to stack usage by LLINT asm or JIT
1045     // generated code which can allocate stack space that the C++ compiler does not know
1046     // about. As such, we have to precommit that stack memory manually.
1047     //
1048     // In contrast, we do not need to worry about VM::m_stackLimit because that limit is
1049     // used exclusively by C++ code, and the C++ compiler will automatically commit the
1050     // needed stack pages.
1051     if (lastSoftStackLimit != m_softStackLimit)
1052         preCommitStackMemory(m_softStackLimit);
1053 #endif
1054 }
1055 
1056 #if ENABLE(DFG_JIT)
1057 void VM::gatherScratchBufferRoots(ConservativeRoots&amp; conservativeRoots)
1058 {
1059     auto lock = holdLock(m_scratchBufferLock);
1060     for (auto* scratchBuffer : m_scratchBuffers) {
1061         if (scratchBuffer-&gt;activeLength()) {
1062             void* bufferStart = scratchBuffer-&gt;dataBuffer();
1063             conservativeRoots.add(bufferStart, static_cast&lt;void*&gt;(static_cast&lt;char*&gt;(bufferStart) + scratchBuffer-&gt;activeLength()));
1064         }
1065     }
1066 }
<span class="line-added">1067 </span>
<span class="line-added">1068 void VM::scanSideState(ConservativeRoots&amp; roots) const</span>
<span class="line-added">1069 {</span>
<span class="line-added">1070     ASSERT(heap.worldIsStopped());</span>
<span class="line-added">1071     for (const auto&amp; iter : m_checkpointSideState) {</span>
<span class="line-added">1072         static_assert(sizeof(iter.value-&gt;tmps) / sizeof(JSValue) == maxNumCheckpointTmps);</span>
<span class="line-added">1073         roots.add(iter.value-&gt;tmps, iter.value-&gt;tmps + maxNumCheckpointTmps);</span>
<span class="line-added">1074     }</span>
<span class="line-added">1075 }</span>
1076 #endif
1077 
<span class="line-added">1078 void VM::addCheckpointOSRSideState(CallFrame* callFrame, std::unique_ptr&lt;CheckpointOSRExitSideState&gt;&amp;&amp; payload)</span>
<span class="line-added">1079 {</span>
<span class="line-added">1080     ASSERT(currentThreadIsHoldingAPILock());</span>
<span class="line-added">1081     auto addResult = m_checkpointSideState.add(callFrame, WTFMove(payload));</span>
<span class="line-added">1082     ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added">1083 }</span>
<span class="line-added">1084 </span>
<span class="line-added">1085 std::unique_ptr&lt;CheckpointOSRExitSideState&gt; VM::findCheckpointOSRSideState(CallFrame* callFrame)</span>
<span class="line-added">1086 {</span>
<span class="line-added">1087     ASSERT(currentThreadIsHoldingAPILock());</span>
<span class="line-added">1088     auto sideState = m_checkpointSideState.take(callFrame);</span>
<span class="line-added">1089     return sideState;</span>
<span class="line-added">1090 }</span>
<span class="line-added">1091 </span>
1092 void logSanitizeStack(VM&amp; vm)
1093 {
1094     if (Options::verboseSanitizeStack() &amp;&amp; vm.topCallFrame) {
1095         int dummy;
1096         auto&amp; stackBounds = Thread::current().stack();
1097         dataLog(
1098             &quot;Sanitizing stack for VM = &quot;, RawPointer(&amp;vm), &quot; with top call frame at &quot;, RawPointer(vm.topCallFrame),
1099             &quot;, current stack pointer at &quot;, RawPointer(&amp;dummy), &quot;, in &quot;,
1100             pointerDump(vm.topCallFrame-&gt;codeBlock()), &quot;, last code origin = &quot;,
1101             vm.topCallFrame-&gt;codeOrigin(), &quot;, last stack top = &quot;, RawPointer(vm.lastStackTop()), &quot;, in stack range [&quot;, RawPointer(stackBounds.origin()), &quot;, &quot;, RawPointer(stackBounds.end()), &quot;]\n&quot;);
1102     }
1103 }
1104 
1105 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
1106 char* VM::acquireRegExpPatternContexBuffer()
1107 {
1108     m_regExpPatternContextLock.lock();
1109     ASSERT(m_regExpPatternContextLock.isLocked());
1110     if (!m_regExpPatternContexBuffer)
1111         m_regExpPatternContexBuffer = makeUniqueArray&lt;char&gt;(VM::patternContextBufferSize);
</pre>
<hr />
<pre>
1139         dataLogF(&quot;----------------------------------------+----------------+----------------+----------+----------+-----------\n&quot;);
1140 
1141         unsigned reCount = 0;
1142 
1143         for (; iter != m_rtTraceList-&gt;end(); ++iter, ++reCount) {
1144             (*iter)-&gt;printTraceData();
1145             gcUnprotect(*iter);
1146         }
1147 
1148         dataLogF(&quot;%d Regular Expressions\n&quot;, reCount);
1149     }
1150 
1151     m_rtTraceList-&gt;clear();
1152 }
1153 #else
1154 void VM::dumpRegExpTrace()
1155 {
1156 }
1157 #endif
1158 
<span class="line-modified">1159 WatchpointSet* VM::ensureWatchpointSetForImpureProperty(UniquedStringImpl* propertyName)</span>
1160 {
<span class="line-modified">1161     auto result = m_impurePropertyWatchpointSets.add(propertyName, nullptr);</span>
1162     if (result.isNewEntry)
1163         result.iterator-&gt;value = adoptRef(new WatchpointSet(IsWatched));
1164     return result.iterator-&gt;value.get();
1165 }
1166 
<span class="line-modified">1167 void VM::addImpureProperty(UniquedStringImpl* propertyName)</span>





1168 {
1169     if (RefPtr&lt;WatchpointSet&gt; watchpointSet = m_impurePropertyWatchpointSets.take(propertyName))
1170         watchpointSet-&gt;fireAll(*this, &quot;Impure property added&quot;);
1171 }
1172 
1173 template&lt;typename Func&gt;
1174 static bool enableProfilerWithRespectToCount(unsigned&amp; counter, const Func&amp; doEnableWork)
1175 {
1176     bool needsToRecompile = false;
1177     if (!counter) {
1178         doEnableWork();
1179         needsToRecompile = true;
1180     }
1181     counter++;
1182 
1183     return needsToRecompile;
1184 }
1185 
1186 template&lt;typename Func&gt;
1187 static bool disableProfilerWithRespectToCount(unsigned&amp; counter, const Func&amp; doDisableWork)
</pre>
<hr />
<pre>
1247 void VM::queueMicrotask(JSGlobalObject&amp; globalObject, Ref&lt;Microtask&gt;&amp;&amp; task)
1248 {
1249     m_microtaskQueue.append(makeUnique&lt;QueuedTask&gt;(*this, &amp;globalObject, WTFMove(task)));
1250 }
1251 
1252 void VM::callPromiseRejectionCallback(Strong&lt;JSPromise&gt;&amp; promise)
1253 {
1254     JSObject* callback = promise-&gt;globalObject()-&gt;unhandledRejectionCallback();
1255     if (!callback)
1256         return;
1257 
1258     auto scope = DECLARE_CATCH_SCOPE(*this);
1259 
1260     CallData callData;
1261     CallType callType = getCallData(*this, callback, callData);
1262     ASSERT(callType != CallType::None);
1263 
1264     MarkedArgumentBuffer args;
1265     args.append(promise.get());
1266     args.append(promise-&gt;result(*this));
<span class="line-modified">1267     call(promise-&gt;globalObject(), callback, callType, callData, jsNull(), args);</span>
1268     scope.clearException();
1269 }
1270 
1271 void VM::didExhaustMicrotaskQueue()
1272 {
1273     auto unhandledRejections = WTFMove(m_aboutToBeNotifiedRejectedPromises);
1274     for (auto&amp; promise : unhandledRejections) {
1275         if (promise-&gt;isHandled(*this))
1276             continue;
1277 
1278         callPromiseRejectionCallback(promise);
1279     }
1280 }
1281 
1282 void VM::promiseRejected(JSPromise* promise)
1283 {
1284     m_aboutToBeNotifiedRejectedPromises.constructAndAppend(*this, promise);
1285 }
1286 
1287 void VM::drainMicrotasks()
1288 {
1289     do {
1290         while (!m_microtaskQueue.isEmpty()) {
1291             m_microtaskQueue.takeFirst()-&gt;run();
1292             if (m_onEachMicrotaskTick)
1293                 m_onEachMicrotaskTick(*this);
1294         }
1295         didExhaustMicrotaskQueue();
1296     } while (!m_microtaskQueue.isEmpty());
1297     finalizeSynchronousJSExecution();
1298 }
1299 
1300 void QueuedTask::run()
1301 {
<span class="line-modified">1302     m_microtask-&gt;run(m_globalObject.get());</span>
1303 }
1304 
1305 void sanitizeStackForVM(VM&amp; vm)
1306 {
1307     logSanitizeStack(vm);
1308     if (vm.topCallFrame) {
1309         auto&amp; stackBounds = Thread::current().stack();
1310         ASSERT(vm.currentThreadIsHoldingAPILock());
1311         ASSERT_UNUSED(stackBounds, stackBounds.contains(vm.lastStackTop()));
1312     }
1313 #if ENABLE(C_LOOP)
1314     vm.interpreter-&gt;cloopStack().sanitizeStack();
1315 #else
1316     sanitizeStackForVMImpl(&amp;vm);
1317 #endif
1318 }
1319 
1320 size_t VM::committedStackByteCount()
1321 {
1322 #if !ENABLE(C_LOOP)
1323     // When using the C stack, we don&#39;t know how many stack pages are actually
1324     // committed. So, we use the current stack usage as an estimate.

1325     uint8_t* current = bitwise_cast&lt;uint8_t*&gt;(currentStackPointer());
1326     uint8_t* high = bitwise_cast&lt;uint8_t*&gt;(Thread::current().stack().origin());
1327     return high - current;
1328 #else
1329     return CLoopStack::committedByteCount();
1330 #endif
1331 }
1332 
1333 #if ENABLE(C_LOOP)
1334 bool VM::ensureStackCapacityForCLoop(Register* newTopOfStack)
1335 {
1336     return interpreter-&gt;cloopStack().ensureCapacityFor(newTopOfStack);
1337 }
1338 
1339 bool VM::isSafeToRecurseSoftCLoop() const
1340 {
1341     return interpreter-&gt;cloopStack().isSafeToRecurse();
1342 }
1343 
1344 void* VM::currentCLoopStackPointer() const
</pre>
<hr />
<pre>
1423 }
1424 
1425 void VM::ensureShadowChicken()
1426 {
1427     if (m_shadowChicken)
1428         return;
1429     m_shadowChicken = makeUnique&lt;ShadowChicken&gt;();
1430 }
1431 
1432 #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
1433     IsoSubspace* VM::name##Slow() \
1434     { \
1435         ASSERT(!m_##name); \
1436         auto space = makeUnique&lt;IsoSubspace&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \
1437         WTF::storeStoreFence(); \
1438         m_##name = WTFMove(space); \
1439         return m_##name.get(); \
1440     }
1441 
1442 
<span class="line-added">1443 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(apiGlobalObjectSpace, apiGlobalObjectHeapCellType.get(), JSAPIGlobalObject)</span>
<span class="line-added">1444 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(apiValueWrapperSpace, cellHeapCellType.get(), JSAPIValueWrapper)</span>
<span class="line-added">1445 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(arrayBufferSpace, cellHeapCellType.get(), JSArrayBuffer)</span>
<span class="line-added">1446 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(arrayIteratorSpace, cellHeapCellType.get(), JSArrayIterator)</span>
<span class="line-added">1447 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(asyncGeneratorSpace, cellHeapCellType.get(), JSAsyncGenerator)</span>
<span class="line-added">1448 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(bigIntObjectSpace, cellHeapCellType.get(), BigIntObject)</span>
<span class="line-added">1449 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(booleanObjectSpace, cellHeapCellType.get(), BooleanObject)</span>
1450 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(boundFunctionSpace, cellHeapCellType.get(), JSBoundFunction) // Hash:0xd7916d41
<span class="line-modified">1451 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackConstructorSpace, callbackConstructorHeapCellType.get(), JSCallbackConstructor)</span>
<span class="line-added">1452 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackGlobalObjectSpace, callbackGlobalObjectHeapCellType.get(), JSCallbackObject&lt;JSGlobalObject&gt;)</span>
<span class="line-added">1453 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackFunctionSpace, cellHeapCellType.get(), JSCallbackFunction) // Hash:0xe7648ebc</span>
<span class="line-added">1454 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackObjectSpace, callbackObjectHeapCellType.get(), JSCallbackObject&lt;JSNonFinalObject&gt;)</span>
1455 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(customGetterSetterFunctionSpace, cellHeapCellType.get(), JSCustomGetterSetterFunction) // Hash:0x18091000
<span class="line-modified">1456 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(dataViewSpace, cellHeapCellType.get(), JSDataView)</span>
<span class="line-modified">1457 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(debuggerScopeSpace, cellHeapCellType.get(), DebuggerScope)</span>
<span class="line-modified">1458 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(errorInstanceSpace, errorInstanceHeapCellType.get(), ErrorInstance) // Hash:0x3f40d4a</span>
<span class="line-modified">1459 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(float32ArraySpace, cellHeapCellType.get(), JSFloat32Array)</span>
<span class="line-modified">1460 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(float64ArraySpace, cellHeapCellType.get(), JSFloat64Array)</span>
<span class="line-added">1461 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(functionRareDataSpace, destructibleCellHeapCellType.get(), FunctionRareData)</span>
<span class="line-added">1462 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(generatorSpace, cellHeapCellType.get(), JSGenerator)</span>
<span class="line-added">1463 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(globalObjectSpace, globalObjectHeapCellType.get(), JSGlobalObject)</span>
<span class="line-added">1464 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(jsModuleRecordSpace, jsModuleRecordHeapCellType.get(), JSModuleRecord)</span>
<span class="line-added">1465 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(int8ArraySpace, cellHeapCellType.get(), JSInt8Array)</span>
<span class="line-added">1466 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(int16ArraySpace, cellHeapCellType.get(), JSInt16Array)</span>
<span class="line-added">1467 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(int32ArraySpace, cellHeapCellType.get(), JSInt32Array)</span>
<span class="line-added">1468 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(mapBucketSpace, cellHeapCellType.get(), JSMap::BucketType)</span>
<span class="line-added">1469 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(mapIteratorSpace, cellHeapCellType.get(), JSMapIterator)</span>
<span class="line-added">1470 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(mapSpace, cellHeapCellType.get(), JSMap)</span>
<span class="line-added">1471 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(moduleNamespaceObjectSpace, moduleNamespaceObjectHeapCellType.get(), JSModuleNamespaceObject)</span>
<span class="line-added">1472 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(nativeStdFunctionSpace, nativeStdFunctionHeapCellType.get(), JSNativeStdFunction) // Hash:0x70ed61e4</span>
<span class="line-added">1473 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(proxyObjectSpace, cellHeapCellType.get(), ProxyObject)</span>
<span class="line-added">1474 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(proxyRevokeSpace, cellHeapCellType.get(), ProxyRevoke) // Hash:0xb506a939</span>
<span class="line-added">1475 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(scopedArgumentsTableSpace, destructibleCellHeapCellType.get(), ScopedArgumentsTable)</span>
<span class="line-added">1476 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(scriptFetchParametersSpace, destructibleCellHeapCellType.get(), JSScriptFetchParameters)</span>
<span class="line-added">1477 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(scriptFetcherSpace, destructibleCellHeapCellType.get(), JSScriptFetcher)</span>
<span class="line-added">1478 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(setBucketSpace, cellHeapCellType.get(), JSSet::BucketType)</span>
<span class="line-added">1479 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(setIteratorSpace, cellHeapCellType.get(), JSSetIterator)</span>
<span class="line-added">1480 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(setSpace, cellHeapCellType.get(), JSSet)</span>
<span class="line-added">1481 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(strictEvalActivationSpace, cellHeapCellType.get(), StrictEvalActivation)</span>
<span class="line-added">1482 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(stringIteratorSpace, cellHeapCellType.get(), JSStringIterator)</span>
<span class="line-added">1483 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(sourceCodeSpace, destructibleCellHeapCellType.get(), JSSourceCode)</span>
<span class="line-added">1484 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(symbolSpace, destructibleCellHeapCellType.get(), Symbol)</span>
<span class="line-added">1485 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(symbolObjectSpace, cellHeapCellType.get(), SymbolObject)</span>
<span class="line-added">1486 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(templateObjectDescriptorSpace, destructibleCellHeapCellType.get(), JSTemplateObjectDescriptor)</span>
<span class="line-added">1487 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(uint8ArraySpace, cellHeapCellType.get(), JSUint8Array)</span>
<span class="line-added">1488 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(uint8ClampedArraySpace, cellHeapCellType.get(), JSUint8ClampedArray)</span>
<span class="line-added">1489 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(uint16ArraySpace, cellHeapCellType.get(), JSUint16Array)</span>
<span class="line-added">1490 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(uint32ArraySpace, cellHeapCellType.get(), JSUint32Array)</span>
<span class="line-added">1491 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(unlinkedEvalCodeBlockSpace, destructibleCellHeapCellType.get(), UnlinkedEvalCodeBlock)</span>
<span class="line-added">1492 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(unlinkedFunctionCodeBlockSpace, destructibleCellHeapCellType.get(), UnlinkedFunctionCodeBlock)</span>
<span class="line-added">1493 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(unlinkedModuleProgramCodeBlockSpace, destructibleCellHeapCellType.get(), UnlinkedModuleProgramCodeBlock)</span>
<span class="line-added">1494 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(unlinkedProgramCodeBlockSpace, destructibleCellHeapCellType.get(), UnlinkedProgramCodeBlock)</span>
<span class="line-added">1495 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakMapSpace, weakMapHeapCellType.get(), JSWeakMap) // Hash:0x662b12a3</span>
<span class="line-added">1496 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakSetSpace, weakSetHeapCellType.get(), JSWeakSet) // Hash:0x4c781b30</span>
1497 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakObjectRefSpace, cellHeapCellType.get(), JSWeakObjectRef) // Hash:0x8ec68f1f
<span class="line-added">1498 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(withScopeSpace, cellHeapCellType.get(), JSWithScope)</span>
1499 #if JSC_OBJC_API_ENABLED
<span class="line-modified">1500 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(apiWrapperObjectSpace, apiWrapperObjectHeapCellType.get(), JSCallbackObject&lt;JSAPIWrapperObject&gt;)</span>
<span class="line-added">1501 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(objCCallbackFunctionSpace, objCCallbackFunctionHeapCellType.get(), ObjCCallbackFunction) // Hash:0x10f610b8</span>
<span class="line-added">1502 #endif</span>
<span class="line-added">1503 #ifdef JSC_GLIB_API_ENABLED</span>
<span class="line-added">1504 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(apiWrapperObjectSpace, apiWrapperObjectHeapCellType.get(), JSCallbackObject&lt;JSAPIWrapperObject&gt;)</span>
<span class="line-added">1505 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(jscCallbackFunctionSpace, jscCallbackFunctionHeapCellType.get(), JSCCallbackFunction)</span>
<span class="line-added">1506 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackAPIWrapperGlobalObjectSpace, callbackAPIWrapperGlobalObjectHeapCellType.get(), JSCallbackObject&lt;JSAPIWrapperGlobalObject&gt;)</span>
<span class="line-added">1507 #endif</span>
<span class="line-added">1508 #if ENABLE(INTL)</span>
<span class="line-added">1509 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(intlCollatorSpace, intlCollatorHeapCellType.get(), IntlCollator)</span>
<span class="line-added">1510 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(intlDateTimeFormatSpace, intlDateTimeFormatHeapCellType.get(), IntlDateTimeFormat)</span>
<span class="line-added">1511 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(intlNumberFormatSpace, intlNumberFormatHeapCellType.get(), IntlNumberFormat)</span>
<span class="line-added">1512 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(intlPluralRulesSpace, intlPluralRulesHeapCellType.get(), IntlPluralRules)</span>
1513 #endif
1514 #if ENABLE(WEBASSEMBLY)
<span class="line-added">1515 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(jsToWasmICCalleeSpace, cellHeapCellType.get(), JSToWasmICCallee)</span>
1516 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyCodeBlockSpace, webAssemblyCodeBlockHeapCellType.get(), JSWebAssemblyCodeBlock) // Hash:0x9ad995cd
1517 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyFunctionSpace, webAssemblyFunctionHeapCellType.get(), WebAssemblyFunction) // Hash:0x8b7c32db
<span class="line-added">1518 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyGlobalSpace, webAssemblyGlobalHeapCellType.get(), JSWebAssemblyGlobal)</span>
<span class="line-added">1519 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyInstanceSpace, webAssemblyInstanceHeapCellType.get(), JSWebAssemblyInstance)</span>
<span class="line-added">1520 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyMemorySpace, webAssemblyMemoryHeapCellType.get(), JSWebAssemblyMemory)</span>
<span class="line-added">1521 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyModuleSpace, webAssemblyModuleHeapCellType.get(), JSWebAssemblyModule)</span>
<span class="line-added">1522 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyModuleRecordSpace, webAssemblyModuleRecordHeapCellType.get(), WebAssemblyModuleRecord)</span>
<span class="line-added">1523 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyTableSpace, webAssemblyTableHeapCellType.get(), JSWebAssemblyTable)</span>
1524 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyWrapperFunctionSpace, cellHeapCellType.get(), WebAssemblyWrapperFunction) // Hash:0xd4a5ff01
1525 #endif
1526 
1527 #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW
1528 
1529 #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
1530     IsoSubspace* VM::name##Slow() \
1531     { \
1532         ASSERT(!m_##name); \
1533         auto space = makeUnique&lt;SpaceAndSet&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \
1534         WTF::storeStoreFence(); \
1535         m_##name = WTFMove(space); \
1536         return &amp;m_##name-&gt;space; \
1537     }
1538 
1539 DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(evalExecutableSpace, destructibleCellHeapCellType.get(), EvalExecutable) // Hash:0x958e3e9d
1540 DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(moduleProgramExecutableSpace, destructibleCellHeapCellType.get(), ModuleProgramExecutable) // Hash:0x6506fa3c
1541 
1542 #undef DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW
1543 
</pre>
<hr />
<pre>
1563     return sentinel;
1564 }
1565 
1566 JSCell* VM::sentinelMapBucketSlow()
1567 {
1568     ASSERT(!m_sentinelMapBucket);
1569     auto* sentinel = JSMap::BucketType::createSentinel(*this);
1570     m_sentinelMapBucket.set(*this, sentinel);
1571     return sentinel;
1572 }
1573 
1574 JSPropertyNameEnumerator* VM::emptyPropertyNameEnumeratorSlow()
1575 {
1576     ASSERT(!m_emptyPropertyNameEnumerator);
1577     PropertyNameArray propertyNames(*this, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
1578     auto* enumerator = JSPropertyNameEnumerator::create(*this, nullptr, 0, 0, WTFMove(propertyNames));
1579     m_emptyPropertyNameEnumerator.set(*this, enumerator);
1580     return enumerator;
1581 }
1582 
<span class="line-modified">1583 JSGlobalObject* VM::deprecatedVMEntryGlobalObject(JSGlobalObject* globalObject) const</span>
1584 {
<span class="line-modified">1585     if (entryScope)</span>
<span class="line-modified">1586         return entryScope-&gt;globalObject();</span>
<span class="line-modified">1587     return globalObject;</span>




1588 }
1589 
1590 void VM::setCrashOnVMCreation(bool shouldCrash)
1591 {
1592     vmCreationShouldCrash = shouldCrash;
1593 }
1594 
1595 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="TypedArrayController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VM.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
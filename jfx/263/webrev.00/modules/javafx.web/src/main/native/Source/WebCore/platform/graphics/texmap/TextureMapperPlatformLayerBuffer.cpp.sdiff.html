<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextureMapperLayer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperPlatformLayerBuffer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TextureMapperPlatformLayerBuffer.h&quot;
 28 
 29 #if USE(COORDINATED_GRAPHICS)
 30 
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;NotImplemented.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(RefPtr&lt;BitmapTexture&gt;&amp;&amp; texture, TextureMapperGL::Flags flags)
 37     : m_texture(WTFMove(texture))
<span class="line-modified"> 38     , m_textureID(0)</span>
 39     , m_extraFlags(flags)
 40     , m_hasManagedTexture(true)
 41 {
 42 }
 43 
 44 TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(GLuint textureID, const IntSize&amp; size, TextureMapperGL::Flags flags, GLint internalFormat)
<span class="line-modified"> 45     : m_textureID(textureID)</span>





 46     , m_size(size)
 47     , m_internalFormat(internalFormat)
 48     , m_extraFlags(flags)
 49     , m_hasManagedTexture(false)
 50 {
 51 }
 52 




 53 bool TextureMapperPlatformLayerBuffer::canReuseWithoutReset(const IntSize&amp; size, GLint internalFormat)
 54 {
 55     return m_texture &amp;&amp; (m_texture-&gt;size() == size) &amp;&amp; (static_cast&lt;BitmapTextureGL*&gt;(m_texture.get())-&gt;internalFormat() == internalFormat || internalFormat == GL_DONT_CARE);
 56 }
 57 
 58 std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; TextureMapperPlatformLayerBuffer::clone()
 59 {
<span class="line-modified"> 60     if (m_hasManagedTexture || !m_textureID) {</span>
 61         notImplemented();
 62         return nullptr;
 63     }
<span class="line-modified"> 64     auto texture = BitmapTextureGL::create(TextureMapperContextAttributes::get(), m_internalFormat);</span>
<span class="line-modified"> 65     texture-&gt;reset(m_size);</span>
<span class="line-modified"> 66     static_cast&lt;BitmapTextureGL&amp;&gt;(texture.get()).copyFromExternalTexture(m_textureID);</span>
<span class="line-modified"> 67     return makeUnique&lt;TextureMapperPlatformLayerBuffer&gt;(WTFMove(texture), m_extraFlags);</span>



















 68 }
 69 
 70 void TextureMapperPlatformLayerBuffer::paintToTextureMapper(TextureMapper&amp; textureMapper, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity)
 71 {
 72     TextureMapperGL&amp; texmapGL = static_cast&lt;TextureMapperGL&amp;&gt;(textureMapper);
 73 
 74     if (m_hasManagedTexture) {
 75         ASSERT(m_texture);
 76         BitmapTextureGL* textureGL = static_cast&lt;BitmapTextureGL*&gt;(m_texture.get());



 77         texmapGL.drawTexture(textureGL-&gt;id(), m_extraFlags | textureGL-&gt;colorConvertFlags(), textureGL-&gt;size(), targetRect, modelViewMatrix, opacity);
 78         return;
 79     }
 80 
 81     if (m_extraFlags &amp; TextureMapperGL::ShouldNotBlend) {
 82         ASSERT(!m_texture);
 83         if (m_holePunchClient)
 84             m_holePunchClient-&gt;setVideoRectangle(enclosingIntRect(modelViewMatrix.mapRect(targetRect)));
 85         texmapGL.drawSolidColor(targetRect, modelViewMatrix, Color(0, 0, 0, 0), false);
 86         return;
 87     }
 88 
<span class="line-modified"> 89     ASSERT(m_textureID);</span>
<span class="line-modified"> 90     texmapGL.drawTexture(m_textureID, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
































 91 }
 92 
 93 } // namespace WebCore
 94 
 95 #endif // USE(COORDINATED_GRAPHICS)
</pre>
</td>
<td>
<hr />
<pre>
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TextureMapperPlatformLayerBuffer.h&quot;
 28 
 29 #if USE(COORDINATED_GRAPHICS)
 30 
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;NotImplemented.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(RefPtr&lt;BitmapTexture&gt;&amp;&amp; texture, TextureMapperGL::Flags flags)
 37     : m_texture(WTFMove(texture))
<span class="line-modified"> 38     , m_variant(RGBTexture { 0 })</span>
 39     , m_extraFlags(flags)
 40     , m_hasManagedTexture(true)
 41 {
 42 }
 43 
 44 TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(GLuint textureID, const IntSize&amp; size, TextureMapperGL::Flags flags, GLint internalFormat)
<span class="line-modified"> 45     : TextureMapperPlatformLayerBuffer({ RGBTexture { textureID } }, size, flags, internalFormat)</span>
<span class="line-added"> 46 {</span>
<span class="line-added"> 47 }</span>
<span class="line-added"> 48 </span>
<span class="line-added"> 49 TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(TextureVariant&amp;&amp; variant, const IntSize&amp; size, TextureMapperGL::Flags flags, GLint internalFormat)</span>
<span class="line-added"> 50     : m_variant(WTFMove(variant))</span>
 51     , m_size(size)
 52     , m_internalFormat(internalFormat)
 53     , m_extraFlags(flags)
 54     , m_hasManagedTexture(false)
 55 {
 56 }
 57 
<span class="line-added"> 58 TextureMapperPlatformLayerBuffer::~TextureMapperPlatformLayerBuffer()</span>
<span class="line-added"> 59 {</span>
<span class="line-added"> 60 }</span>
<span class="line-added"> 61 </span>
 62 bool TextureMapperPlatformLayerBuffer::canReuseWithoutReset(const IntSize&amp; size, GLint internalFormat)
 63 {
 64     return m_texture &amp;&amp; (m_texture-&gt;size() == size) &amp;&amp; (static_cast&lt;BitmapTextureGL*&gt;(m_texture.get())-&gt;internalFormat() == internalFormat || internalFormat == GL_DONT_CARE);
 65 }
 66 
 67 std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; TextureMapperPlatformLayerBuffer::clone()
 68 {
<span class="line-modified"> 69     if (m_hasManagedTexture) {</span>
 70         notImplemented();
 71         return nullptr;
 72     }
<span class="line-modified"> 73 </span>
<span class="line-modified"> 74     return WTF::switchOn(m_variant,</span>
<span class="line-modified"> 75         [&amp;](const RGBTexture&amp; texture) mutable -&gt; std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; {</span>
<span class="line-modified"> 76             if (!texture.id) {</span>
<span class="line-added"> 77                 notImplemented();</span>
<span class="line-added"> 78                 return nullptr;</span>
<span class="line-added"> 79             }</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81             auto clonedTexture = BitmapTextureGL::create(TextureMapperContextAttributes::get(), m_internalFormat);</span>
<span class="line-added"> 82             clonedTexture-&gt;reset(m_size);</span>
<span class="line-added"> 83             static_cast&lt;BitmapTextureGL&amp;&gt;(clonedTexture.get()).copyFromExternalTexture(texture.id);</span>
<span class="line-added"> 84             return makeUnique&lt;TextureMapperPlatformLayerBuffer&gt;(WTFMove(clonedTexture), m_extraFlags);</span>
<span class="line-added"> 85         },</span>
<span class="line-added"> 86         [](const YUVTexture&amp;)</span>
<span class="line-added"> 87         {</span>
<span class="line-added"> 88             notImplemented();</span>
<span class="line-added"> 89             return nullptr;</span>
<span class="line-added"> 90         },</span>
<span class="line-added"> 91         [](const ExternalOESTexture&amp;)</span>
<span class="line-added"> 92         {</span>
<span class="line-added"> 93             notImplemented();</span>
<span class="line-added"> 94             return nullptr;</span>
<span class="line-added"> 95         });</span>
 96 }
 97 
 98 void TextureMapperPlatformLayerBuffer::paintToTextureMapper(TextureMapper&amp; textureMapper, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity)
 99 {
100     TextureMapperGL&amp; texmapGL = static_cast&lt;TextureMapperGL&amp;&gt;(textureMapper);
101 
102     if (m_hasManagedTexture) {
103         ASSERT(m_texture);
104         BitmapTextureGL* textureGL = static_cast&lt;BitmapTextureGL*&gt;(m_texture.get());
<span class="line-added">105 #if USE(ANGLE)</span>
<span class="line-added">106         textureGL-&gt;updatePendingContents(IntRect(IntPoint(), textureGL-&gt;contentSize()), IntPoint());</span>
<span class="line-added">107 #endif</span>
108         texmapGL.drawTexture(textureGL-&gt;id(), m_extraFlags | textureGL-&gt;colorConvertFlags(), textureGL-&gt;size(), targetRect, modelViewMatrix, opacity);
109         return;
110     }
111 
112     if (m_extraFlags &amp; TextureMapperGL::ShouldNotBlend) {
113         ASSERT(!m_texture);
114         if (m_holePunchClient)
115             m_holePunchClient-&gt;setVideoRectangle(enclosingIntRect(modelViewMatrix.mapRect(targetRect)));
116         texmapGL.drawSolidColor(targetRect, modelViewMatrix, Color(0, 0, 0, 0), false);
117         return;
118     }
119 
<span class="line-modified">120 #if USE(GSTREAMER_GL)</span>
<span class="line-modified">121     if (m_unmanagedBufferDataHolder)</span>
<span class="line-added">122         m_unmanagedBufferDataHolder-&gt;waitForCPUSync();</span>
<span class="line-added">123 #endif // USE(GSTREAMER_GL)</span>
<span class="line-added">124 </span>
<span class="line-added">125     WTF::switchOn(m_variant,</span>
<span class="line-added">126         [&amp;](const RGBTexture&amp; texture) {</span>
<span class="line-added">127             ASSERT(texture.id);</span>
<span class="line-added">128             texmapGL.drawTexture(texture.id, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">129         },</span>
<span class="line-added">130         [&amp;](const YUVTexture&amp; texture) {</span>
<span class="line-added">131             switch (texture.numberOfPlanes) {</span>
<span class="line-added">132             case 1:</span>
<span class="line-added">133                 ASSERT(texture.yuvPlane[0] == texture.yuvPlane[1] &amp;&amp; texture.yuvPlane[1] == texture.yuvPlane[2]);</span>
<span class="line-added">134                 ASSERT(texture.yuvPlaneOffset[0] == 2 &amp;&amp; texture.yuvPlaneOffset[1] == 1 &amp;&amp; !texture.yuvPlaneOffset[2]);</span>
<span class="line-added">135                 texmapGL.drawTexturePackedYUV(texture.planes[texture.yuvPlane[0]],</span>
<span class="line-added">136                     texture.yuvToRgbMatrix, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">137                 break;</span>
<span class="line-added">138             case 2:</span>
<span class="line-added">139                 ASSERT(!texture.yuvPlaneOffset[0]);</span>
<span class="line-added">140                 texmapGL.drawTextureSemiPlanarYUV(std::array&lt;GLuint, 2&gt; { texture.planes[texture.yuvPlane[0]], texture.planes[texture.yuvPlane[1]] }, !!texture.yuvPlaneOffset[1],</span>
<span class="line-added">141                     texture.yuvToRgbMatrix, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">142                 break;</span>
<span class="line-added">143             case 3:</span>
<span class="line-added">144                 ASSERT(!texture.yuvPlaneOffset[0] &amp;&amp; !texture.yuvPlaneOffset[1] &amp;&amp; !texture.yuvPlaneOffset[2]);</span>
<span class="line-added">145                 texmapGL.drawTexturePlanarYUV(std::array&lt;GLuint, 3&gt; { texture.planes[texture.yuvPlane[0]], texture.planes[texture.yuvPlane[1]], texture.planes[texture.yuvPlane[2]] },</span>
<span class="line-added">146                     texture.yuvToRgbMatrix, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">147                 break;</span>
<span class="line-added">148             }</span>
<span class="line-added">149         },</span>
<span class="line-added">150         [&amp;](const ExternalOESTexture&amp; texture) {</span>
<span class="line-added">151             ASSERT(texture.id);</span>
<span class="line-added">152             texmapGL.drawTextureExternalOES(texture.id, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">153         });</span>
154 }
155 
156 } // namespace WebCore
157 
158 #endif // USE(COORDINATED_GRAPHICS)
</pre>
</td>
</tr>
</table>
<center><a href="TextureMapperLayer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperPlatformLayerBuffer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBIndex.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBGetResult.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBIndex.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBIndex.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 45,44 ***</span>
      : ActiveDOMObject(&amp;context)
      , m_info(info)
      , m_originalInfo(info)
      , m_objectStore(objectStore)
  {
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
  
      suspendIfNeeded();
  }
  
  IDBIndex::~IDBIndex()
  {
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
  }
  
  const char* IDBIndex::activeDOMObjectName() const
  {
      return &quot;IDBIndex&quot;;
  }
  
<span class="line-removed">- bool IDBIndex::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool IDBIndex::hasPendingActivity() const
  {
<span class="line-modified">!     return m_objectStore.transaction().hasPendingActivity();</span>
  }
  
  const String&amp; IDBIndex::name() const
  {
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
      return m_info.name();
  }
  
  ExceptionOr&lt;void&gt; IDBIndex::setName(const String&amp; name)
  {
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
  
      if (m_deleted)
          return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index has been deleted.&quot;_s };
  
      if (m_objectStore.isDeleted())
<span class="line-new-header">--- 45,39 ---</span>
      : ActiveDOMObject(&amp;context)
      , m_info(info)
      , m_originalInfo(info)
      , m_objectStore(objectStore)
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      suspendIfNeeded();
  }
  
  IDBIndex::~IDBIndex()
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  }
  
  const char* IDBIndex::activeDOMObjectName() const
  {
      return &quot;IDBIndex&quot;;
  }
  
  bool IDBIndex::hasPendingActivity() const
  {
<span class="line-modified">!     return m_objectStore.hasPendingActivity();</span>
  }
  
  const String&amp; IDBIndex::name() const
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
      return m_info.name();
  }
  
  ExceptionOr&lt;void&gt; IDBIndex::setName(const String&amp; name)
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted)
          return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index has been deleted.&quot;_s };
  
      if (m_objectStore.isDeleted())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,35 ***</span>
      return { };
  }
  
  IDBObjectStore&amp; IDBIndex::objectStore()
  {
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
      return m_objectStore;
  }
  
  const IDBKeyPath&amp; IDBIndex::keyPath() const
  {
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
      return m_info.keyPath();
  }
  
  bool IDBIndex::unique() const
  {
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
      return m_info.unique();
  }
  
  bool IDBIndex::multiEntry() const
  {
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
      return m_info.multiEntry();
  }
  
  void IDBIndex::rollbackInfoForVersionChangeAbort()
  {
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
  
      // Only rollback to the original info if this index still exists in the rolled-back database info.
      auto* objectStoreInfo = m_objectStore.transaction().database().info().infoForExistingObjectStore(m_objectStore.info().identifier());
      if (!objectStoreInfo)
          return;
<span class="line-new-header">--- 101,35 ---</span>
      return { };
  }
  
  IDBObjectStore&amp; IDBIndex::objectStore()
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
      return m_objectStore;
  }
  
  const IDBKeyPath&amp; IDBIndex::keyPath() const
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
      return m_info.keyPath();
  }
  
  bool IDBIndex::unique() const
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
      return m_info.unique();
  }
  
  bool IDBIndex::multiEntry() const
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
      return m_info.multiEntry();
  }
  
  void IDBIndex::rollbackInfoForVersionChangeAbort()
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      // Only rollback to the original info if this index still exists in the rolled-back database info.
      auto* objectStoreInfo = m_objectStore.transaction().database().info().infoForExistingObjectStore(m_objectStore.info().identifier());
      if (!objectStoreInfo)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,14 ***</span>
  
      m_info = m_originalInfo;
      m_deleted = false;
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenCursor(ExecState&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::openCursor&quot;);
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      if (!m_objectStore.transaction().isActive())
<span class="line-new-header">--- 141,14 ---</span>
  
      m_info = m_originalInfo;
      m_deleted = false;
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::openCursor&quot;);
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      if (!m_objectStore.transaction().isActive())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 171,32 ***</span>
  
      auto info = IDBCursorInfo::indexCursor(m_objectStore.transaction(), m_objectStore.info().identifier(), m_info.identifier(), rangeData, direction, IndexedDB::CursorType::KeyAndValue);
      return m_objectStore.transaction().requestOpenCursor(execState, *this, info);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
  {
      return doOpenCursor(execState, direction, [range=WTFMove(range)]() {
          return range;
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)</span>
  {
      return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
  
          return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenKeyCursor(ExecState&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::openKeyCursor&quot;);
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      if (!m_objectStore.transaction().isActive())
<span class="line-new-header">--- 166,32 ---</span>
  
      auto info = IDBCursorInfo::indexCursor(m_objectStore.transaction(), m_objectStore.info().identifier(), m_info.identifier(), rangeData, direction, IndexedDB::CursorType::KeyAndValue);
      return m_objectStore.transaction().requestOpenCursor(execState, *this, info);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
  {
      return doOpenCursor(execState, direction, [range=WTFMove(range)]() {
          return range;
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)</span>
  {
      return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
  
          return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenKeyCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::openKeyCursor&quot;);
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      if (!m_objectStore.transaction().isActive())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,48 ***</span>
      auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
      auto info = IDBCursorInfo::indexCursor(m_objectStore.transaction(), m_objectStore.info().identifier(), m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyOnly);
      return m_objectStore.transaction().requestOpenCursor(execState, *this, info);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
  {
      return doOpenKeyCursor(execState, direction, [range=WTFMove(range)]() {
          return range;
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)</span>
  {
      return doOpenKeyCursor(execState, direction, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
  
          return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(ExecState&amp; execState, IDBKeyRange* range)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::count&quot;);
  
      return doCount(execState, range ? IDBKeyRangeData(range) : IDBKeyRangeData::allKeys());
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(ExecState&amp; execState, JSValue key)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::count&quot;);
  
      auto idbKey = scriptValueToIDBKey(execState, key);
      auto* idbKeyPointer = idbKey-&gt;isValid() ? idbKey.ptr() : nullptr;
  
      return doCount(execState, IDBKeyRangeData(idbKeyPointer));
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doCount(ExecState&amp; execState, const IDBKeyRangeData&amp; range)</span>
  {
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      auto&amp; transaction = m_objectStore.transaction();
<span class="line-new-header">--- 204,48 ---</span>
      auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
      auto info = IDBCursorInfo::indexCursor(m_objectStore.transaction(), m_objectStore.info().identifier(), m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyOnly);
      return m_objectStore.transaction().requestOpenCursor(execState, *this, info);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
  {
      return doOpenKeyCursor(execState, direction, [range=WTFMove(range)]() {
          return range;
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)</span>
  {
      return doOpenKeyCursor(execState, direction, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
  
          return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(JSGlobalObject&amp; execState, IDBKeyRange* range)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::count&quot;);
  
      return doCount(execState, range ? IDBKeyRangeData(range) : IDBKeyRangeData::allKeys());
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(JSGlobalObject&amp; execState, JSValue key)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::count&quot;);
  
      auto idbKey = scriptValueToIDBKey(execState, key);
      auto* idbKeyPointer = idbKey-&gt;isValid() ? idbKey.ptr() : nullptr;
  
      return doCount(execState, IDBKeyRangeData(idbKeyPointer));
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doCount(JSGlobalObject&amp; execState, const IDBKeyRangeData&amp; range)</span>
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      auto&amp; transaction = m_objectStore.transaction();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,31 ***</span>
          return Exception { DataError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s };
  
      return transaction.requestCount(execState, *this, range);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(ExecState&amp; execState, IDBKeyRange* range)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::get&quot;);
  
      return doGet(execState, IDBKeyRangeData(range));
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(ExecState&amp; execState, JSValue key)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::get&quot;);
  
      auto idbKey = scriptValueToIDBKey(execState, key);
      if (!idbKey-&gt;isValid())
          return doGet(execState, Exception(DataError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s));
  
      return doGet(execState, IDBKeyRangeData(idbKey.ptr()));
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGet(ExecState&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)</span>
  {
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      auto&amp; transaction = m_objectStore.transaction();
<span class="line-new-header">--- 256,31 ---</span>
          return Exception { DataError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s };
  
      return transaction.requestCount(execState, *this, range);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(JSGlobalObject&amp; execState, IDBKeyRange* range)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::get&quot;);
  
      return doGet(execState, IDBKeyRangeData(range));
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(JSGlobalObject&amp; execState, JSValue key)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::get&quot;);
  
      auto idbKey = scriptValueToIDBKey(execState, key);
      if (!idbKey-&gt;isValid())
          return doGet(execState, Exception(DataError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s));
  
      return doGet(execState, IDBKeyRangeData(idbKey.ptr()));
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGet(JSGlobalObject&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)</span>
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      auto&amp; transaction = m_objectStore.transaction();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,31 ***</span>
          return Exception { DataError };
  
      return transaction.requestGetValue(execState, *this, keyRange);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(ExecState&amp; execState, IDBKeyRange* range)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::getKey&quot;);
  
      return doGetKey(execState, IDBKeyRangeData(range));
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(ExecState&amp; execState, JSValue key)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::getKey&quot;);
  
      auto idbKey = scriptValueToIDBKey(execState, key);
      if (!idbKey-&gt;isValid())
          return doGetKey(execState, Exception(DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s));
  
      return doGetKey(execState, IDBKeyRangeData(idbKey.ptr()));
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetKey(ExecState&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)</span>
  {
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      auto&amp; transaction = m_objectStore.transaction();
<span class="line-new-header">--- 295,31 ---</span>
          return Exception { DataError };
  
      return transaction.requestGetValue(execState, *this, keyRange);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(JSGlobalObject&amp; execState, IDBKeyRange* range)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::getKey&quot;);
  
      return doGetKey(execState, IDBKeyRangeData(range));
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(JSGlobalObject&amp; execState, JSValue key)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::getKey&quot;);
  
      auto idbKey = scriptValueToIDBKey(execState, key);
      if (!idbKey-&gt;isValid())
          return doGetKey(execState, Exception(DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s));
  
      return doGetKey(execState, IDBKeyRangeData(idbKey.ptr()));
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetKey(JSGlobalObject&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)</span>
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      auto&amp; transaction = m_objectStore.transaction();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 339,14 ***</span>
          return Exception { DataError };
  
      return transaction.requestGetKey(execState, *this, keyRange);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAll(ExecState&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::getAll&quot;);
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      if (!m_objectStore.transaction().isActive())
<span class="line-new-header">--- 334,14 ---</span>
          return Exception { DataError };
  
      return transaction.requestGetKey(execState, *this, keyRange);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAll(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::getAll&quot;);
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      if (!m_objectStore.transaction().isActive())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 358,32 ***</span>
  
      auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
      return m_objectStore.transaction().requestGetAllIndexRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Values, count);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAll(execState, count, [range = WTFMove(range)]() {
          return range;
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAll(execState, count, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
  
          return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAllKeys(ExecState&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::getAllKeys&quot;);
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      if (!m_objectStore.transaction().isActive())
<span class="line-new-header">--- 353,32 ---</span>
  
      auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
      return m_objectStore.transaction().requestGetAllIndexRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Values, count);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAll(execState, count, [range = WTFMove(range)]() {
          return range;
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAll(execState, count, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
  
          return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAllKeys(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::getAllKeys&quot;);
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      if (!m_objectStore.transaction().isActive())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 395,18 ***</span>
  
      auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
      return m_objectStore.transaction().requestGetAllIndexRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Keys, count);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAllKeys(execState, count, [range = WTFMove(range)]() {
          return range;
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAllKeys(execState, count, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
<span class="line-new-header">--- 390,18 ---</span>
  
      auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
      return m_objectStore.transaction().requestGetAllIndexRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Keys, count);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAllKeys(execState, count, [range = WTFMove(range)]() {
          return range;
      });
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAllKeys(execState, count, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 415,11 ***</span>
      });
  }
  
  void IDBIndex::markAsDeleted()
  {
<span class="line-modified">!     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
  
      ASSERT(!m_deleted);
      m_deleted = true;
  }
  
<span class="line-new-header">--- 410,11 ---</span>
      });
  }
  
  void IDBIndex::markAsDeleted()
  {
<span class="line-modified">!     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      ASSERT(!m_deleted);
      m_deleted = true;
  }
  
</pre>
<center><a href="IDBGetResult.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBIndex.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
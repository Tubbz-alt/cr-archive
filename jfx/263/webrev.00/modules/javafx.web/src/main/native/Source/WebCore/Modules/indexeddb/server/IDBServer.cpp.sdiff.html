<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/IDBServer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBSerializationContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="IDBServer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/IDBServer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBRequestData.h&quot;
 32 #include &quot;IDBResultData.h&quot;
 33 #include &quot;Logging.h&quot;
 34 #include &quot;MemoryIDBBackingStore.h&quot;
 35 #include &quot;SQLiteDatabase.h&quot;
 36 #include &quot;SQLiteDatabaseTracker.h&quot;
 37 #include &quot;SQLiteFileSystem.h&quot;
 38 #include &quot;SQLiteIDBBackingStore.h&quot;
 39 #include &quot;SQLiteStatement.h&quot;
 40 #include &quot;SecurityOrigin.h&quot;
 41 #include &quot;StorageQuotaManager.h&quot;
 42 #include &lt;wtf/CrossThreadCopier.h&gt;
 43 #include &lt;wtf/Locker.h&gt;
 44 #include &lt;wtf/MainThread.h&gt;
 45 
 46 namespace WebCore {
 47 namespace IDBServer {
 48 
<span class="line-modified"> 49 Ref&lt;IDBServer&gt; IDBServer::create(PAL::SessionID sessionID, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, QuotaManagerGetter&amp;&amp; quotaManagerGetter)</span>


 50 {
<span class="line-modified"> 51     return adoptRef(*new IDBServer(sessionID, fileHandler, WTFMove(quotaManagerGetter)));</span>
<span class="line-modified"> 52 }</span>
<span class="line-removed"> 53 </span>
<span class="line-removed"> 54 Ref&lt;IDBServer&gt; IDBServer::create(PAL::SessionID sessionID, const String&amp; databaseDirectoryPath, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, QuotaManagerGetter&amp;&amp; quotaManagerGetter)</span>
<span class="line-removed"> 55 {</span>
<span class="line-removed"> 56     return adoptRef(*new IDBServer(sessionID, databaseDirectoryPath, fileHandler, WTFMove(quotaManagerGetter)));</span>
<span class="line-removed"> 57 }</span>
 58 
<span class="line-modified"> 59 IDBServer::IDBServer(PAL::SessionID sessionID, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, QuotaManagerGetter&amp;&amp; quotaManagerGetter)</span>
<span class="line-modified"> 60     : CrossThreadTaskHandler(&quot;IndexedDatabase Server&quot;, AutodrainedPoolForRunLoop::Use)</span>
<span class="line-removed"> 61     , m_sessionID(sessionID)</span>
<span class="line-removed"> 62     , m_backingStoreTemporaryFileHandler(fileHandler)</span>
<span class="line-removed"> 63     , m_quotaManagerGetter(WTFMove(quotaManagerGetter))</span>
<span class="line-removed"> 64 {</span>
 65 }
 66 
<span class="line-modified"> 67 IDBServer::IDBServer(PAL::SessionID sessionID, const String&amp; databaseDirectoryPath, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, QuotaManagerGetter&amp;&amp; quotaManagerGetter)</span>
<span class="line-removed"> 68     : CrossThreadTaskHandler(&quot;IndexedDatabase Server&quot;, AutodrainedPoolForRunLoop::Use)</span>
<span class="line-removed"> 69     , m_sessionID(sessionID)</span>
<span class="line-removed"> 70     , m_databaseDirectoryPath(databaseDirectoryPath)</span>
<span class="line-removed"> 71     , m_backingStoreTemporaryFileHandler(fileHandler)</span>
<span class="line-removed"> 72     , m_quotaManagerGetter(WTFMove(quotaManagerGetter))</span>
 73 {
<span class="line-modified"> 74     LOG(IndexedDB, &quot;IDBServer created at path %s&quot;, databaseDirectoryPath.utf8().data());</span>
<span class="line-removed"> 75     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::upgradeFilesIfNecessary));</span>
 76 }
 77 
 78 void IDBServer::registerConnection(IDBConnectionToClient&amp; connection)
 79 {

 80     ASSERT(!m_connectionMap.contains(connection.identifier()));
 81     m_connectionMap.set(connection.identifier(), &amp;connection);
 82 }
 83 
 84 void IDBServer::unregisterConnection(IDBConnectionToClient&amp; connection)
 85 {


 86     ASSERT(m_connectionMap.contains(connection.identifier()));
 87     ASSERT(m_connectionMap.get(connection.identifier()) == &amp;connection);
 88 
 89     connection.connectionToClientClosed();
 90 
 91     m_connectionMap.remove(connection.identifier());
 92 }
 93 
 94 void IDBServer::registerTransaction(UniqueIDBDatabaseTransaction&amp; transaction)
 95 {


 96     ASSERT(!m_transactions.contains(transaction.info().identifier()));
 97     m_transactions.set(transaction.info().identifier(), &amp;transaction);
 98 }
 99 
100 void IDBServer::unregisterTransaction(UniqueIDBDatabaseTransaction&amp; transaction)
101 {


102     ASSERT(m_transactions.contains(transaction.info().identifier()));
103     ASSERT(m_transactions.get(transaction.info().identifier()) == &amp;transaction);
104 
105     m_transactions.remove(transaction.info().identifier());
106 }
107 
108 void IDBServer::registerDatabaseConnection(UniqueIDBDatabaseConnection&amp; connection)
109 {
110     ASSERT(!m_databaseConnections.contains(connection.identifier()));
111     m_databaseConnections.set(connection.identifier(), &amp;connection);
112 }
113 
114 void IDBServer::unregisterDatabaseConnection(UniqueIDBDatabaseConnection&amp; connection)
115 {
116     ASSERT(m_databaseConnections.contains(connection.identifier()));
117     m_databaseConnections.remove(connection.identifier());
118 }
119 
120 UniqueIDBDatabase&amp; IDBServer::getOrCreateUniqueIDBDatabase(const IDBDatabaseIdentifier&amp; identifier)
121 {
<span class="line-modified">122     ASSERT(isMainThread());</span>
123 
124     auto uniqueIDBDatabase = m_uniqueIDBDatabaseMap.add(identifier, nullptr);
125     if (uniqueIDBDatabase.isNewEntry)
126         uniqueIDBDatabase.iterator-&gt;value = makeUnique&lt;UniqueIDBDatabase&gt;(*this, identifier);
127 
128     return *uniqueIDBDatabase.iterator-&gt;value;
129 }
130 
131 std::unique_ptr&lt;IDBBackingStore&gt; IDBServer::createBackingStore(const IDBDatabaseIdentifier&amp; identifier)
132 {
133     ASSERT(!isMainThread());
134 
135     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
136     if (databaseDirectoryPath.isEmpty())
<span class="line-modified">137         return MemoryIDBBackingStore::create(m_sessionID, identifier);</span>
138 
<span class="line-modified">139     return makeUnique&lt;SQLiteIDBBackingStore&gt;(m_sessionID, identifier, databaseDirectoryPath, m_backingStoreTemporaryFileHandler);</span>
140 }
141 
142 void IDBServer::openDatabase(const IDBRequestData&amp; requestData)
143 {
144     LOG(IndexedDB, &quot;IDBServer::openDatabase&quot;);


145 
146     auto&amp; uniqueIDBDatabase = getOrCreateUniqueIDBDatabase(requestData.databaseIdentifier());
147 
148     auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
149     if (!connection) {
150         // If the connection back to the client is gone, there&#39;s no way to open the database as
151         // well as no way to message back failure.
152         return;
153     }
154 
155     uniqueIDBDatabase.openDatabaseConnection(*connection, requestData);
156 }
157 
158 void IDBServer::deleteDatabase(const IDBRequestData&amp; requestData)
159 {
<span class="line-modified">160     LOG(IndexedDB, &quot;IDBServer::deleteDatabase - %s&quot;, requestData.databaseIdentifier().debugString().utf8().data());</span>
<span class="line-modified">161     ASSERT(isMainThread());</span>

162 
163     auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
164     if (!connection) {
165         // If the connection back to the client is gone, there&#39;s no way to delete the database as
166         // well as no way to message back failure.
167         return;
168     }
169 
170     auto* database = m_uniqueIDBDatabaseMap.get(requestData.databaseIdentifier());
171     if (!database)
172         database = &amp;getOrCreateUniqueIDBDatabase(requestData.databaseIdentifier());
173 
174     database-&gt;handleDelete(*connection, requestData);
175 }
176 
177 std::unique_ptr&lt;UniqueIDBDatabase&gt; IDBServer::closeAndTakeUniqueIDBDatabase(UniqueIDBDatabase&amp; database)
178 {
179     LOG(IndexedDB, &quot;IDBServer::closeUniqueIDBDatabase&quot;);
180     ASSERT(isMainThread());
181 
182     auto uniquePointer = m_uniqueIDBDatabaseMap.take(database.identifier());
183     ASSERT(uniquePointer);
184 
185     return uniquePointer;
186 }
187 
188 void IDBServer::abortTransaction(const IDBResourceIdentifier&amp; transactionIdentifier)
189 {
190     LOG(IndexedDB, &quot;IDBServer::abortTransaction&quot;);


191 
192     auto transaction = m_transactions.get(transactionIdentifier);
193     if (!transaction) {
194         // If there is no transaction there is nothing to abort.
195         // We also have no access to a connection over which to message failure-to-abort.
196         return;
197     }
198 
199     transaction-&gt;abort();
200 }
201 
202 void IDBServer::createObjectStore(const IDBRequestData&amp; requestData, const IDBObjectStoreInfo&amp; info)
203 {
204     LOG(IndexedDB, &quot;IDBServer::createObjectStore&quot;);


205 
206     auto transaction = m_transactions.get(requestData.transactionIdentifier());
207     if (!transaction)
208         return;
209 
210     ASSERT(transaction-&gt;isVersionChange());
211     transaction-&gt;createObjectStore(requestData, info);
212 }
213 
214 void IDBServer::deleteObjectStore(const IDBRequestData&amp; requestData, const String&amp; objectStoreName)
215 {
216     LOG(IndexedDB, &quot;IDBServer::deleteObjectStore&quot;);


217 
218     auto transaction = m_transactions.get(requestData.transactionIdentifier());
219     if (!transaction)
220         return;
221 
222     ASSERT(transaction-&gt;isVersionChange());
223     transaction-&gt;deleteObjectStore(requestData, objectStoreName);
224 }
225 
226 void IDBServer::renameObjectStore(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, const String&amp; newName)
227 {
228     LOG(IndexedDB, &quot;IDBServer::renameObjectStore&quot;);


229 
230     auto transaction = m_transactions.get(requestData.transactionIdentifier());
231     if (!transaction)
232         return;
233 
234     ASSERT(transaction-&gt;isVersionChange());
235     transaction-&gt;renameObjectStore(requestData, objectStoreIdentifier, newName);
236 }
237 
238 void IDBServer::clearObjectStore(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier)
239 {
240     LOG(IndexedDB, &quot;IDBServer::clearObjectStore&quot;);


241 
242     auto transaction = m_transactions.get(requestData.transactionIdentifier());
243     if (!transaction)
244         return;
245 
246     transaction-&gt;clearObjectStore(requestData, objectStoreIdentifier);
247 }
248 
249 void IDBServer::createIndex(const IDBRequestData&amp; requestData, const IDBIndexInfo&amp; info)
250 {
251     LOG(IndexedDB, &quot;IDBServer::createIndex&quot;);


252 
253     auto transaction = m_transactions.get(requestData.transactionIdentifier());
254     if (!transaction)
255         return;
256 
257     ASSERT(transaction-&gt;isVersionChange());
258     transaction-&gt;createIndex(requestData, info);
259 }
260 
261 void IDBServer::deleteIndex(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, const String&amp; indexName)
262 {
263     LOG(IndexedDB, &quot;IDBServer::deleteIndex&quot;);


264 
265     auto transaction = m_transactions.get(requestData.transactionIdentifier());
266     if (!transaction)
267         return;
268 
269     ASSERT(transaction-&gt;isVersionChange());
270     transaction-&gt;deleteIndex(requestData, objectStoreIdentifier, indexName);
271 }
272 
273 void IDBServer::renameIndex(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
274 {
275     LOG(IndexedDB, &quot;IDBServer::renameIndex&quot;);


276 
277     auto transaction = m_transactions.get(requestData.transactionIdentifier());
278     if (!transaction)
279         return;
280 
281     ASSERT(transaction-&gt;isVersionChange());
282     transaction-&gt;renameIndex(requestData, objectStoreIdentifier, indexIdentifier, newName);
283 }
284 
285 void IDBServer::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
286 {
287     LOG(IndexedDB, &quot;IDBServer::putOrAdd&quot;);


288 
289     auto transaction = m_transactions.get(requestData.transactionIdentifier());
290     if (!transaction)
291         return;
292 
293     transaction-&gt;putOrAdd(requestData, keyData, value, overwriteMode);
294 }
295 
296 void IDBServer::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData)
297 {
298     LOG(IndexedDB, &quot;IDBServer::getRecord&quot;);


299 
300     auto transaction = m_transactions.get(requestData.transactionIdentifier());
301     if (!transaction)
302         return;
303 
304     transaction-&gt;getRecord(requestData, getRecordData);
305 }
306 
307 void IDBServer::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData)
308 {
309     LOG(IndexedDB, &quot;IDBServer::getAllRecords&quot;);


310 
311     auto transaction = m_transactions.get(requestData.transactionIdentifier());
312     if (!transaction)
313         return;
314 
315     transaction-&gt;getAllRecords(requestData, getAllRecordsData);
316 }
317 
318 void IDBServer::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData)
319 {
320     LOG(IndexedDB, &quot;IDBServer::getCount&quot;);


321 
322     auto transaction = m_transactions.get(requestData.transactionIdentifier());
323     if (!transaction)
324         return;
325 
326     transaction-&gt;getCount(requestData, keyRangeData);
327 }
328 
329 void IDBServer::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData)
330 {
331     LOG(IndexedDB, &quot;IDBServer::deleteRecord&quot;);


332 
333     auto transaction = m_transactions.get(requestData.transactionIdentifier());
334     if (!transaction)
335         return;
336 
337     transaction-&gt;deleteRecord(requestData, keyRangeData);
338 }
339 
340 void IDBServer::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info)
341 {
342     LOG(IndexedDB, &quot;IDBServer::openCursor&quot;);


343 
344     auto transaction = m_transactions.get(requestData.transactionIdentifier());
345     if (!transaction)
346         return;
347 
348     transaction-&gt;openCursor(requestData, info);
349 }
350 
351 void IDBServer::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data)
352 {
353     LOG(IndexedDB, &quot;IDBServer::iterateCursor&quot;);


354 
355     auto transaction = m_transactions.get(requestData.transactionIdentifier());
356     if (!transaction)
357         return;
358 
359     transaction-&gt;iterateCursor(requestData, data);
360 }
361 
362 void IDBServer::establishTransaction(uint64_t databaseConnectionIdentifier, const IDBTransactionInfo&amp; info)
363 {
364     LOG(IndexedDB, &quot;IDBServer::establishTransaction&quot;);


365 
366     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
367     if (!databaseConnection)
368         return;
369 
370     databaseConnection-&gt;establishTransaction(info);
371 }
372 
373 void IDBServer::commitTransaction(const IDBResourceIdentifier&amp; transactionIdentifier)
374 {
375     LOG(IndexedDB, &quot;IDBServer::commitTransaction&quot;);


376 
377     auto transaction = m_transactions.get(transactionIdentifier);
378     if (!transaction) {
379         // If there is no transaction there is nothing to commit.
380         // We also have no access to a connection over which to message failure-to-commit.
381         return;
382     }
383 
384     transaction-&gt;commit();
385 }
386 
387 void IDBServer::didFinishHandlingVersionChangeTransaction(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
388 {
389     LOG(IndexedDB, &quot;IDBServer::didFinishHandlingVersionChangeTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());


390 
391     auto* connection = m_databaseConnections.get(databaseConnectionIdentifier);
392     if (!connection)
393         return;
394 
395     connection-&gt;didFinishHandlingVersionChange(transactionIdentifier);
396 }
397 
398 void IDBServer::databaseConnectionPendingClose(uint64_t databaseConnectionIdentifier)
399 {
400     LOG(IndexedDB, &quot;IDBServer::databaseConnectionPendingClose - %&quot; PRIu64, databaseConnectionIdentifier);


401 
402     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
403     if (!databaseConnection)
404         return;
405 
406     databaseConnection-&gt;connectionPendingCloseFromClient();
407 }
408 
409 void IDBServer::databaseConnectionClosed(uint64_t databaseConnectionIdentifier)
410 {
411     LOG(IndexedDB, &quot;IDBServer::databaseConnectionClosed - %&quot; PRIu64, databaseConnectionIdentifier);


412 
413     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
414     if (!databaseConnection)
415         return;
416 
417     databaseConnection-&gt;connectionClosedFromClient();
418 }
419 
420 void IDBServer::abortOpenAndUpgradeNeeded(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
421 {
422     LOG(IndexedDB, &quot;IDBServer::abortOpenAndUpgradeNeeded&quot;);


423 
424     auto transaction = m_transactions.get(transactionIdentifier);
425     if (transaction)
426         transaction-&gt;abortWithoutCallback();
427 
428     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
429     if (!databaseConnection)
430         return;
431 
432     databaseConnection-&gt;connectionClosedFromClient();
433 }
434 
<span class="line-modified">435 void IDBServer::didFireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; requestIdentifier)</span>
436 {
437     LOG(IndexedDB, &quot;IDBServer::didFireVersionChangeEvent&quot;);


438 
439     if (auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier))
<span class="line-modified">440         databaseConnection-&gt;didFireVersionChangeEvent(requestIdentifier);</span>
441 }
442 
443 void IDBServer::openDBRequestCancelled(const IDBRequestData&amp; requestData)
444 {
445     LOG(IndexedDB, &quot;IDBServer::openDBRequestCancelled&quot;);
<span class="line-modified">446     ASSERT(isMainThread());</span>

447 
448     auto* uniqueIDBDatabase = m_uniqueIDBDatabaseMap.get(requestData.databaseIdentifier());
449     if (!uniqueIDBDatabase)
450         return;
451 
452     uniqueIDBDatabase-&gt;openDBRequestCancelled(requestData.requestIdentifier());
453 }
454 
<span class="line-modified">455 void IDBServer::confirmDidCloseFromServer(uint64_t databaseConnectionIdentifier)</span>
456 {
<span class="line-modified">457     LOG(IndexedDB, &quot;IDBServer::confirmDidCloseFromServer&quot;);</span>
<span class="line-modified">458 </span>
<span class="line-removed">459     if (auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier))</span>
<span class="line-removed">460         databaseConnection-&gt;confirmDidCloseFromServer();</span>
<span class="line-removed">461 }</span>
<span class="line-removed">462 </span>
<span class="line-removed">463 void IDBServer::getAllDatabaseNames(uint64_t serverConnectionIdentifier, const SecurityOriginData&amp; mainFrameOrigin, const SecurityOriginData&amp; openingOrigin, uint64_t callbackID)</span>
<span class="line-removed">464 {</span>
<span class="line-removed">465     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::performGetAllDatabaseNames, serverConnectionIdentifier, mainFrameOrigin, openingOrigin, callbackID));</span>
<span class="line-removed">466 }</span>
467 
<span class="line-removed">468 void IDBServer::performGetAllDatabaseNames(uint64_t serverConnectionIdentifier, const SecurityOriginData&amp; mainFrameOrigin, const SecurityOriginData&amp; openingOrigin, uint64_t callbackID)</span>
<span class="line-removed">469 {</span>
470     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
471     String oldDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(mainFrameOrigin, openingOrigin, databaseDirectoryPath, &quot;v0&quot;);
472     Vector&lt;String&gt; files = FileSystem::listDirectory(oldDirectory, &quot;*&quot;_s);
473     Vector&lt;String&gt; databases;
474     for (auto&amp; file : files) {
475         String encodedName = FileSystem::lastComponentOfPathIgnoringTrailingSlash(file);
476         databases.append(SQLiteIDBBackingStore::databaseNameFromEncodedFilename(encodedName));
477     }
478 
479     String directory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(mainFrameOrigin, openingOrigin, databaseDirectoryPath, &quot;v1&quot;);
480     files = FileSystem::listDirectory(directory, &quot;*&quot;_s);
481     for (auto&amp; file : files) {
482         auto databaseName = SQLiteIDBBackingStore::databaseNameFromFile(SQLiteIDBBackingStore::fullDatabasePathForDirectory(file));
483         if (!databaseName.isEmpty())
484             databases.append(databaseName);
485     }
486 
<span class="line-removed">487     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didGetAllDatabaseNames, serverConnectionIdentifier, callbackID, databases));</span>
<span class="line-removed">488 }</span>
<span class="line-removed">489 </span>
<span class="line-removed">490 void IDBServer::didGetAllDatabaseNames(uint64_t serverConnectionIdentifier, uint64_t callbackID, const Vector&lt;String&gt;&amp; databaseNames)</span>
<span class="line-removed">491 {</span>
492     auto connection = m_connectionMap.get(serverConnectionIdentifier);
493     if (!connection)
494         return;
495 
<span class="line-modified">496     connection-&gt;didGetAllDatabaseNames(callbackID, databaseNames);</span>
<span class="line-removed">497 }</span>
<span class="line-removed">498 </span>
<span class="line-removed">499 void IDBServer::postDatabaseTask(CrossThreadTask&amp;&amp; task)</span>
<span class="line-removed">500 {</span>
<span class="line-removed">501     postTask(WTFMove(task));</span>
<span class="line-removed">502 }</span>
<span class="line-removed">503 </span>
<span class="line-removed">504 void IDBServer::postDatabaseTaskReply(CrossThreadTask&amp;&amp; task)</span>
<span class="line-removed">505 {</span>
<span class="line-removed">506     postTaskReply(WTFMove(task));</span>
<span class="line-removed">507 }</span>
<span class="line-removed">508 </span>
<span class="line-removed">509 static uint64_t generateDeleteCallbackID()</span>
<span class="line-removed">510 {</span>
<span class="line-removed">511     ASSERT(isMainThread());</span>
<span class="line-removed">512     static uint64_t currentID = 0;</span>
<span class="line-removed">513     return ++currentID;</span>
514 }
515 
<span class="line-modified">516 void IDBServer::closeAndDeleteDatabasesModifiedSince(WallTime modificationTime, Function&lt;void ()&gt;&amp;&amp; completionHandler)</span>
517 {
<span class="line-modified">518     uint64_t callbackID = generateDeleteCallbackID();</span>
<span class="line-modified">519     auto addResult = m_deleteDatabaseCompletionHandlers.add(callbackID, WTFMove(completionHandler));</span>
<span class="line-removed">520     ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
521 
522     // If the modification time is in the future, don&#39;t both doing anything.
<span class="line-modified">523     if (modificationTime &gt; WallTime::now()) {</span>
<span class="line-removed">524         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didPerformCloseAndDeleteDatabases, callbackID));</span>
525         return;
<span class="line-removed">526     }</span>
527 
528     HashSet&lt;UniqueIDBDatabase*&gt; openDatabases;
529     for (auto&amp; database : m_uniqueIDBDatabaseMap.values())
<span class="line-removed">530         openDatabases.add(database.get());</span>
<span class="line-removed">531 </span>
<span class="line-removed">532     for (auto&amp; database : openDatabases)</span>
533         database-&gt;immediateCloseForUserDelete();
534 
<span class="line-modified">535     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::performCloseAndDeleteDatabasesModifiedSince, modificationTime, callbackID));</span>





536 }
537 
<span class="line-modified">538 void IDBServer::closeAndDeleteDatabasesForOrigins(const Vector&lt;SecurityOriginData&gt;&amp; origins, Function&lt;void ()&gt;&amp;&amp; completionHandler)</span>
539 {
<span class="line-modified">540     uint64_t callbackID = generateDeleteCallbackID();</span>
<span class="line-modified">541     auto addResult = m_deleteDatabaseCompletionHandlers.add(callbackID, WTFMove(completionHandler));</span>
<span class="line-removed">542     ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
543 
544     HashSet&lt;UniqueIDBDatabase*&gt; openDatabases;
545     for (auto&amp; database : m_uniqueIDBDatabaseMap.values()) {
546         const auto&amp; identifier = database-&gt;identifier();
547         for (auto&amp; origin : origins) {
548             if (identifier.isRelatedToOrigin(origin)) {
549                 openDatabases.add(database.get());
550                 break;
551             }
552         }
553     }
554 
<span class="line-modified">555     for (auto&amp; database : openDatabases)</span>
556         database-&gt;immediateCloseForUserDelete();


557 
<span class="line-modified">558     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::performCloseAndDeleteDatabasesForOrigins, origins, callbackID));</span>



559 }
560 
561 static void removeAllDatabasesForFullOriginPath(const String&amp; originPath, WallTime modifiedSince)
562 {
563     LOG(IndexedDB, &quot;removeAllDatabasesForOriginPath with originPath %s&quot;, originPath.utf8().data());
564     Vector&lt;String&gt; databasePaths = FileSystem::listDirectory(originPath, &quot;*&quot;);
565 
566     for (auto&amp; databasePath : databasePaths) {
567         String databaseFile = FileSystem::pathByAppendingComponent(databasePath, &quot;IndexedDB.sqlite3&quot;);
568         if (modifiedSince &gt; -WallTime::infinity() &amp;&amp; FileSystem::fileExists(databaseFile)) {
569             auto modificationTime = FileSystem::getFileModificationTime(databaseFile);
570             if (!modificationTime)
571                 continue;
572 
573             if (modificationTime.value() &lt; modifiedSince)
574                 continue;
575         }
576 
577         // Deleting this database means we need to delete all files that represent it.
578         // This includes:
</pre>
<hr />
<pre>
632     auto directories = FileSystem::listDirectory(originPath, &quot;*&quot;_s);
633     for (auto&amp; directory : directories) {
634         String databaseIdentifier = FileSystem::lastComponentOfPathIgnoringTrailingSlash(directory);
635         if (auto securityOrigin = SecurityOriginData::fromDatabaseIdentifier(databaseIdentifier))
636             removeAllDatabasesForFullOriginPath(directory, modifiedSince);
637     }
638 
639     removeAllDatabasesForFullOriginPath(originPath, modifiedSince);
640 }
641 
642 void IDBServer::removeDatabasesModifiedSinceForVersion(WallTime modifiedSince, const String&amp; version)
643 {
644     String versionPath = FileSystem::pathByAppendingComponent(databaseDirectoryPathIsolatedCopy(), version);
645     for (auto&amp; originPath : FileSystem::listDirectory(versionPath, &quot;*&quot;)) {
646         String databaseIdentifier = FileSystem::lastComponentOfPathIgnoringTrailingSlash(originPath);
647         if (auto securityOrigin = SecurityOriginData::fromDatabaseIdentifier(databaseIdentifier))
648             removeAllDatabasesForOriginPath(originPath, modifiedSince);
649     }
650 }
651 
<span class="line-removed">652 void IDBServer::performCloseAndDeleteDatabasesModifiedSince(WallTime modifiedSince, uint64_t callbackID)</span>
<span class="line-removed">653 {</span>
<span class="line-removed">654     if (!databaseDirectoryPathIsolatedCopy().isEmpty()) {</span>
<span class="line-removed">655         removeDatabasesModifiedSinceForVersion(modifiedSince, &quot;v0&quot;);</span>
<span class="line-removed">656         removeDatabasesModifiedSinceForVersion(modifiedSince, &quot;v1&quot;);</span>
<span class="line-removed">657     }</span>
<span class="line-removed">658 </span>
<span class="line-removed">659     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didPerformCloseAndDeleteDatabases, callbackID));</span>
<span class="line-removed">660 }</span>
<span class="line-removed">661 </span>
662 void IDBServer::removeDatabasesWithOriginsForVersion(const Vector&lt;SecurityOriginData&gt; &amp;origins, const String&amp; version)
663 {
664     String versionPath = FileSystem::pathByAppendingComponent(databaseDirectoryPathIsolatedCopy(), version);
665     for (const auto&amp; origin : origins) {
666         String originPath = FileSystem::pathByAppendingComponent(versionPath, origin.databaseIdentifier());
667         removeAllDatabasesForOriginPath(originPath, -WallTime::infinity());
668 
669         for (auto&amp; topOriginPath : FileSystem::listDirectory(versionPath, &quot;*&quot;)) {
670             originPath = FileSystem::pathByAppendingComponent(topOriginPath, origin.databaseIdentifier());
671             removeAllDatabasesForOriginPath(originPath, -WallTime::infinity());
672         }
673     }
674 }
675 
<span class="line-modified">676 void IDBServer::performCloseAndDeleteDatabasesForOrigins(const Vector&lt;SecurityOriginData&gt;&amp; origins, uint64_t callbackID)</span>
<span class="line-removed">677 {</span>
<span class="line-removed">678     if (!databaseDirectoryPathIsolatedCopy().isEmpty()) {</span>
<span class="line-removed">679         removeDatabasesWithOriginsForVersion(origins, &quot;v0&quot;);</span>
<span class="line-removed">680         removeDatabasesWithOriginsForVersion(origins, &quot;v1&quot;);</span>
<span class="line-removed">681     }</span>
<span class="line-removed">682 </span>
<span class="line-removed">683     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didPerformCloseAndDeleteDatabases, callbackID));</span>
<span class="line-removed">684 }</span>
<span class="line-removed">685 </span>
<span class="line-removed">686 void IDBServer::didPerformCloseAndDeleteDatabases(uint64_t callbackID)</span>
<span class="line-removed">687 {</span>
<span class="line-removed">688     for (auto&amp; user : m_quotaUsers.values())</span>
<span class="line-removed">689         user-&gt;resetSpaceUsed();</span>
<span class="line-removed">690 </span>
<span class="line-removed">691     auto callback = m_deleteDatabaseCompletionHandlers.take(callbackID);</span>
<span class="line-removed">692     ASSERT(callback);</span>
<span class="line-removed">693     callback();</span>
<span class="line-removed">694 }</span>
<span class="line-removed">695 </span>
<span class="line-removed">696 IDBServer::QuotaUser::QuotaUser(IDBServer&amp; server, StorageQuotaManager* manager, ClientOrigin&amp;&amp; origin)</span>
<span class="line-removed">697     : m_server(server)</span>
<span class="line-removed">698     , m_manager(makeWeakPtr(manager))</span>
<span class="line-removed">699     , m_origin(WTFMove(origin))</span>
<span class="line-removed">700     , m_isInitialized(m_server.m_sessionID.isEphemeral())</span>
<span class="line-removed">701 {</span>
<span class="line-removed">702     if (manager)</span>
<span class="line-removed">703         manager-&gt;addUser(*this);</span>
<span class="line-removed">704 }</span>
<span class="line-removed">705 </span>
<span class="line-removed">706 IDBServer::QuotaUser::~QuotaUser()</span>
<span class="line-removed">707 {</span>
<span class="line-removed">708     if (m_manager)</span>
<span class="line-removed">709         m_manager-&gt;removeUser(*this);</span>
<span class="line-removed">710 }</span>
<span class="line-removed">711 </span>
<span class="line-removed">712 void IDBServer::QuotaUser::resetSpaceUsed()</span>
<span class="line-removed">713 {</span>
<span class="line-removed">714     m_spaceUsed = 0;</span>
<span class="line-removed">715     m_estimatedSpaceIncrease = 0;</span>
<span class="line-removed">716 </span>
<span class="line-removed">717     if (!m_manager)</span>
<span class="line-removed">718         return;</span>
<span class="line-removed">719 </span>
<span class="line-removed">720     if (m_server.m_sessionID.isEphemeral())</span>
<span class="line-removed">721         return;</span>
<span class="line-removed">722 </span>
<span class="line-removed">723     if (!m_isInitialized)</span>
<span class="line-removed">724         return;</span>
<span class="line-removed">725 </span>
<span class="line-removed">726     ASSERT(!m_initializationCallback);</span>
<span class="line-removed">727 </span>
<span class="line-removed">728     m_isInitialized = false;</span>
<span class="line-removed">729 </span>
<span class="line-removed">730     // Do add/remove to trigger call to whenInitialized.</span>
<span class="line-removed">731     m_manager-&gt;removeUser(*this);</span>
<span class="line-removed">732     m_manager-&gt;addUser(*this);</span>
<span class="line-removed">733 }</span>
<span class="line-removed">734 </span>
<span class="line-removed">735 void IDBServer::QuotaUser::increaseSpaceUsed(uint64_t size)</span>
<span class="line-removed">736 {</span>
<span class="line-removed">737     if (!m_isInitialized)</span>
<span class="line-removed">738         return;</span>
<span class="line-removed">739     ASSERT(m_spaceUsed + size &gt; m_spaceUsed);</span>
<span class="line-removed">740     m_spaceUsed += size;</span>
<span class="line-removed">741 }</span>
<span class="line-removed">742 void IDBServer::QuotaUser::decreaseSpaceUsed(uint64_t size)</span>
<span class="line-removed">743 {</span>
<span class="line-removed">744     if (!m_isInitialized)</span>
<span class="line-removed">745         return;</span>
<span class="line-removed">746     ASSERT(m_spaceUsed &gt;= size);</span>
<span class="line-removed">747     m_spaceUsed -= size;</span>
<span class="line-removed">748 }</span>
<span class="line-removed">749 </span>
<span class="line-removed">750 void IDBServer::QuotaUser::whenInitialized(CompletionHandler&lt;void()&gt;&amp;&amp; callback)</span>
<span class="line-removed">751 {</span>
<span class="line-removed">752     if (m_isInitialized) {</span>
<span class="line-removed">753         callback();</span>
<span class="line-removed">754         return;</span>
<span class="line-removed">755     }</span>
<span class="line-removed">756     m_initializationCallback = WTFMove(callback);</span>
<span class="line-removed">757     m_server.startComputingSpaceUsedForOrigin(m_origin);</span>
<span class="line-removed">758 }</span>
<span class="line-removed">759 </span>
<span class="line-removed">760 void IDBServer::QuotaUser::initializeSpaceUsed(uint64_t spaceUsed)</span>
<span class="line-removed">761 {</span>
<span class="line-removed">762     ASSERT(m_isInitialized || !m_estimatedSpaceIncrease);</span>
<span class="line-removed">763     m_spaceUsed = spaceUsed;</span>
<span class="line-removed">764     m_isInitialized = true;</span>
<span class="line-removed">765 </span>
<span class="line-removed">766     if (auto callback = WTFMove(m_initializationCallback))</span>
<span class="line-removed">767         callback();</span>
<span class="line-removed">768 }</span>
<span class="line-removed">769 </span>
<span class="line-removed">770 IDBServer::QuotaUser&amp; IDBServer::ensureQuotaUser(const ClientOrigin&amp; origin)</span>
<span class="line-removed">771 {</span>
<span class="line-removed">772     return *m_quotaUsers.ensure(origin, [this, &amp;origin] {</span>
<span class="line-removed">773         return makeUnique&lt;QuotaUser&gt;(*this, m_quotaManagerGetter(m_sessionID, origin), ClientOrigin { origin });</span>
<span class="line-removed">774     }).iterator-&gt;value;</span>
<span class="line-removed">775 }</span>
<span class="line-removed">776 </span>
<span class="line-removed">777 void IDBServer::startComputingSpaceUsedForOrigin(const ClientOrigin&amp; origin)</span>
<span class="line-removed">778 {</span>
<span class="line-removed">779     ASSERT(!m_sessionID.isEphemeral());</span>
<span class="line-removed">780     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::computeSpaceUsedForOrigin, origin));</span>
<span class="line-removed">781 }</span>
<span class="line-removed">782 </span>
<span class="line-removed">783 void IDBServer::computeSpaceUsedForOrigin(const ClientOrigin&amp; origin)</span>
784 {
785     ASSERT(!isMainThread());

786 
<span class="line-modified">787     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();</span>
<span class="line-removed">788     auto oldVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, databaseDirectoryPath, &quot;v0&quot;);</span>
<span class="line-removed">789     auto newVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, databaseDirectoryPath, &quot;v1&quot;);</span>
<span class="line-removed">790     auto size = SQLiteIDBBackingStore::databasesSizeForDirectory(oldVersionOriginDirectory) + SQLiteIDBBackingStore::databasesSizeForDirectory(newVersionOriginDirectory);</span>
<span class="line-removed">791 </span>
<span class="line-removed">792     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::finishComputingSpaceUsedForOrigin, origin, size));</span>
<span class="line-removed">793 }</span>
<span class="line-removed">794 </span>
<span class="line-removed">795 void IDBServer::finishComputingSpaceUsedForOrigin(const ClientOrigin&amp; origin, uint64_t spaceUsed)</span>
<span class="line-removed">796 {</span>
<span class="line-removed">797     ensureQuotaUser(origin).initializeSpaceUsed(spaceUsed);</span>
<span class="line-removed">798 }</span>
<span class="line-removed">799 </span>
<span class="line-removed">800 void IDBServer::requestSpace(const ClientOrigin&amp; origin, uint64_t taskSize, CompletionHandler&lt;void(StorageQuotaManager::Decision)&gt;&amp;&amp; callback)</span>
<span class="line-removed">801 {</span>
<span class="line-removed">802     auto* quotaManager = ensureQuotaUser(origin).manager();</span>
<span class="line-removed">803     if (!quotaManager) {</span>
<span class="line-removed">804         callback(StorageQuotaManager::Decision::Deny);</span>
<span class="line-removed">805         return;</span>
<span class="line-removed">806     }</span>
807 
<span class="line-modified">808     quotaManager-&gt;requestSpace(taskSize, WTFMove(callback));</span>
<span class="line-modified">809 }</span>


810 
<span class="line-modified">811 void IDBServer::resetSpaceUsed(const ClientOrigin&amp; origin)</span>
<span class="line-removed">812 {</span>
<span class="line-removed">813     if (auto* user = m_quotaUsers.get(origin))</span>
<span class="line-removed">814         user-&gt;resetSpaceUsed();</span>
815 }
816 
<span class="line-modified">817 void IDBServer::increaseSpaceUsed(const ClientOrigin&amp; origin, uint64_t size)</span>
818 {
<span class="line-modified">819     ensureQuotaUser(origin).increaseSpaceUsed(size);</span>
<span class="line-removed">820 }</span>
<span class="line-removed">821 </span>
<span class="line-removed">822 void IDBServer::decreaseSpaceUsed(const ClientOrigin&amp; origin, uint64_t size)</span>
<span class="line-removed">823 {</span>
<span class="line-removed">824     ensureQuotaUser(origin).decreaseSpaceUsed(size);</span>
<span class="line-removed">825 }</span>
<span class="line-removed">826 </span>
<span class="line-removed">827 void IDBServer::increasePotentialSpaceUsed(const ClientOrigin&amp; origin, uint64_t taskSize)</span>
<span class="line-removed">828 {</span>
<span class="line-removed">829     ensureQuotaUser(origin).increasePotentialSpaceUsed(taskSize);</span>
<span class="line-removed">830 }</span>
831 
<span class="line-modified">832 void IDBServer::decreasePotentialSpaceUsed(const ClientOrigin&amp; origin, uint64_t spaceUsed)</span>
<span class="line-modified">833 {</span>
<span class="line-modified">834     ensureQuotaUser(origin).decreasePotentialSpaceUsed(spaceUsed);</span>
835 }
836 
837 void IDBServer::upgradeFilesIfNecessary()
838 {
839     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
840     if (databaseDirectoryPath.isEmpty() || !FileSystem::fileExists(databaseDirectoryPath))
841         return;
842 
843     String newVersionDirectory = FileSystem::pathByAppendingComponent(databaseDirectoryPath, &quot;v1&quot;);
844     if (!FileSystem::fileExists(newVersionDirectory))
845         FileSystem::makeAllDirectories(newVersionDirectory);
846 }
847 
<span class="line-modified">848 void IDBServer::tryStop(ShouldForceStop shouldForceStop)</span>
849 {



850     // Only stop non-ephemeral IDBServers that can hold locked database files.
851     if (m_sessionID.isEphemeral())
852         return;
853 
<span class="line-removed">854     suspendAndWait();</span>
<span class="line-removed">855     if (shouldForceStop == ShouldForceStop::No &amp;&amp; SQLiteDatabaseTracker::hasTransactionInProgress()) {</span>
<span class="line-removed">856         CrossThreadTaskHandler::resume();</span>
<span class="line-removed">857         return;</span>
<span class="line-removed">858     }</span>
<span class="line-removed">859 </span>
860     for (auto&amp; database : m_uniqueIDBDatabaseMap.values())
<span class="line-modified">861         database-&gt;finishActiveTransactions();</span>
<span class="line-removed">862 }</span>
<span class="line-removed">863 </span>
<span class="line-removed">864 void IDBServer::resume()</span>
<span class="line-removed">865 {</span>
<span class="line-removed">866     if (m_sessionID.isEphemeral())</span>
<span class="line-removed">867         return;</span>
<span class="line-removed">868 </span>
<span class="line-removed">869     CrossThreadTaskHandler::resume();</span>
870 }
871 
872 } // namespace IDBServer
873 } // namespace WebCore
874 
875 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
<td>
<hr />
<pre>
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBRequestData.h&quot;
 32 #include &quot;IDBResultData.h&quot;
 33 #include &quot;Logging.h&quot;
 34 #include &quot;MemoryIDBBackingStore.h&quot;
 35 #include &quot;SQLiteDatabase.h&quot;
 36 #include &quot;SQLiteDatabaseTracker.h&quot;
 37 #include &quot;SQLiteFileSystem.h&quot;
 38 #include &quot;SQLiteIDBBackingStore.h&quot;
 39 #include &quot;SQLiteStatement.h&quot;
 40 #include &quot;SecurityOrigin.h&quot;
 41 #include &quot;StorageQuotaManager.h&quot;
 42 #include &lt;wtf/CrossThreadCopier.h&gt;
 43 #include &lt;wtf/Locker.h&gt;
 44 #include &lt;wtf/MainThread.h&gt;
 45 
 46 namespace WebCore {
 47 namespace IDBServer {
 48 
<span class="line-modified"> 49 IDBServer::IDBServer(PAL::SessionID sessionID, const String&amp; databaseDirectoryPath, StorageQuotaManagerSpaceRequester&amp;&amp; spaceRequester)</span>
<span class="line-added"> 50     : m_sessionID(sessionID)</span>
<span class="line-added"> 51     , m_spaceRequester(WTFMove(spaceRequester))</span>
 52 {
<span class="line-modified"> 53     ASSERT(!isMainThread());</span>
<span class="line-modified"> 54     ASSERT(databaseDirectoryPath.isSafeToSendToAnotherThread());</span>





 55 
<span class="line-modified"> 56     m_databaseDirectoryPath = databaseDirectoryPath;</span>
<span class="line-modified"> 57     upgradeFilesIfNecessary();</span>




 58 }
 59 
<span class="line-modified"> 60 IDBServer::~IDBServer()</span>





 61 {
<span class="line-modified"> 62     ASSERT(!isMainThread());</span>

 63 }
 64 
 65 void IDBServer::registerConnection(IDBConnectionToClient&amp; connection)
 66 {
<span class="line-added"> 67     ASSERT(!isMainThread());</span>
 68     ASSERT(!m_connectionMap.contains(connection.identifier()));
 69     m_connectionMap.set(connection.identifier(), &amp;connection);
 70 }
 71 
 72 void IDBServer::unregisterConnection(IDBConnectionToClient&amp; connection)
 73 {
<span class="line-added"> 74     ASSERT(!isMainThread());</span>
<span class="line-added"> 75     ASSERT(m_lock.isHeld());</span>
 76     ASSERT(m_connectionMap.contains(connection.identifier()));
 77     ASSERT(m_connectionMap.get(connection.identifier()) == &amp;connection);
 78 
 79     connection.connectionToClientClosed();
 80 
 81     m_connectionMap.remove(connection.identifier());
 82 }
 83 
 84 void IDBServer::registerTransaction(UniqueIDBDatabaseTransaction&amp; transaction)
 85 {
<span class="line-added"> 86     ASSERT(!isMainThread());</span>
<span class="line-added"> 87     ASSERT(m_lock.isHeld());</span>
 88     ASSERT(!m_transactions.contains(transaction.info().identifier()));
 89     m_transactions.set(transaction.info().identifier(), &amp;transaction);
 90 }
 91 
 92 void IDBServer::unregisterTransaction(UniqueIDBDatabaseTransaction&amp; transaction)
 93 {
<span class="line-added"> 94     ASSERT(!isMainThread());</span>
<span class="line-added"> 95     ASSERT(m_lock.isHeld());</span>
 96     ASSERT(m_transactions.contains(transaction.info().identifier()));
 97     ASSERT(m_transactions.get(transaction.info().identifier()) == &amp;transaction);
 98 
 99     m_transactions.remove(transaction.info().identifier());
100 }
101 
102 void IDBServer::registerDatabaseConnection(UniqueIDBDatabaseConnection&amp; connection)
103 {
104     ASSERT(!m_databaseConnections.contains(connection.identifier()));
105     m_databaseConnections.set(connection.identifier(), &amp;connection);
106 }
107 
108 void IDBServer::unregisterDatabaseConnection(UniqueIDBDatabaseConnection&amp; connection)
109 {
110     ASSERT(m_databaseConnections.contains(connection.identifier()));
111     m_databaseConnections.remove(connection.identifier());
112 }
113 
114 UniqueIDBDatabase&amp; IDBServer::getOrCreateUniqueIDBDatabase(const IDBDatabaseIdentifier&amp; identifier)
115 {
<span class="line-modified">116     ASSERT(!isMainThread());</span>
117 
118     auto uniqueIDBDatabase = m_uniqueIDBDatabaseMap.add(identifier, nullptr);
119     if (uniqueIDBDatabase.isNewEntry)
120         uniqueIDBDatabase.iterator-&gt;value = makeUnique&lt;UniqueIDBDatabase&gt;(*this, identifier);
121 
122     return *uniqueIDBDatabase.iterator-&gt;value;
123 }
124 
125 std::unique_ptr&lt;IDBBackingStore&gt; IDBServer::createBackingStore(const IDBDatabaseIdentifier&amp; identifier)
126 {
127     ASSERT(!isMainThread());
128 
129     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
130     if (databaseDirectoryPath.isEmpty())
<span class="line-modified">131         return makeUnique&lt;MemoryIDBBackingStore&gt;(m_sessionID, identifier);</span>
132 
<span class="line-modified">133     return makeUnique&lt;SQLiteIDBBackingStore&gt;(m_sessionID, identifier, databaseDirectoryPath);</span>
134 }
135 
136 void IDBServer::openDatabase(const IDBRequestData&amp; requestData)
137 {
138     LOG(IndexedDB, &quot;IDBServer::openDatabase&quot;);
<span class="line-added">139     ASSERT(!isMainThread());</span>
<span class="line-added">140     ASSERT(m_lock.isHeld());</span>
141 
142     auto&amp; uniqueIDBDatabase = getOrCreateUniqueIDBDatabase(requestData.databaseIdentifier());
143 
144     auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
145     if (!connection) {
146         // If the connection back to the client is gone, there&#39;s no way to open the database as
147         // well as no way to message back failure.
148         return;
149     }
150 
151     uniqueIDBDatabase.openDatabaseConnection(*connection, requestData);
152 }
153 
154 void IDBServer::deleteDatabase(const IDBRequestData&amp; requestData)
155 {
<span class="line-modified">156     LOG(IndexedDB, &quot;IDBServer::deleteDatabase - %s&quot;, requestData.databaseIdentifier().loggingString().utf8().data());</span>
<span class="line-modified">157     ASSERT(!isMainThread());</span>
<span class="line-added">158     ASSERT(m_lock.isHeld());</span>
159 
160     auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
161     if (!connection) {
162         // If the connection back to the client is gone, there&#39;s no way to delete the database as
163         // well as no way to message back failure.
164         return;
165     }
166 
167     auto* database = m_uniqueIDBDatabaseMap.get(requestData.databaseIdentifier());
168     if (!database)
169         database = &amp;getOrCreateUniqueIDBDatabase(requestData.databaseIdentifier());
170 
171     database-&gt;handleDelete(*connection, requestData);
172 }
173 
174 std::unique_ptr&lt;UniqueIDBDatabase&gt; IDBServer::closeAndTakeUniqueIDBDatabase(UniqueIDBDatabase&amp; database)
175 {
176     LOG(IndexedDB, &quot;IDBServer::closeUniqueIDBDatabase&quot;);
177     ASSERT(isMainThread());
178 
179     auto uniquePointer = m_uniqueIDBDatabaseMap.take(database.identifier());
180     ASSERT(uniquePointer);
181 
182     return uniquePointer;
183 }
184 
185 void IDBServer::abortTransaction(const IDBResourceIdentifier&amp; transactionIdentifier)
186 {
187     LOG(IndexedDB, &quot;IDBServer::abortTransaction&quot;);
<span class="line-added">188     ASSERT(!isMainThread());</span>
<span class="line-added">189     ASSERT(m_lock.isHeld());</span>
190 
191     auto transaction = m_transactions.get(transactionIdentifier);
192     if (!transaction) {
193         // If there is no transaction there is nothing to abort.
194         // We also have no access to a connection over which to message failure-to-abort.
195         return;
196     }
197 
198     transaction-&gt;abort();
199 }
200 
201 void IDBServer::createObjectStore(const IDBRequestData&amp; requestData, const IDBObjectStoreInfo&amp; info)
202 {
203     LOG(IndexedDB, &quot;IDBServer::createObjectStore&quot;);
<span class="line-added">204     ASSERT(!isMainThread());</span>
<span class="line-added">205     ASSERT(m_lock.isHeld());</span>
206 
207     auto transaction = m_transactions.get(requestData.transactionIdentifier());
208     if (!transaction)
209         return;
210 
211     ASSERT(transaction-&gt;isVersionChange());
212     transaction-&gt;createObjectStore(requestData, info);
213 }
214 
215 void IDBServer::deleteObjectStore(const IDBRequestData&amp; requestData, const String&amp; objectStoreName)
216 {
217     LOG(IndexedDB, &quot;IDBServer::deleteObjectStore&quot;);
<span class="line-added">218     ASSERT(!isMainThread());</span>
<span class="line-added">219     ASSERT(m_lock.isHeld());</span>
220 
221     auto transaction = m_transactions.get(requestData.transactionIdentifier());
222     if (!transaction)
223         return;
224 
225     ASSERT(transaction-&gt;isVersionChange());
226     transaction-&gt;deleteObjectStore(requestData, objectStoreName);
227 }
228 
229 void IDBServer::renameObjectStore(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, const String&amp; newName)
230 {
231     LOG(IndexedDB, &quot;IDBServer::renameObjectStore&quot;);
<span class="line-added">232     ASSERT(!isMainThread());</span>
<span class="line-added">233     ASSERT(m_lock.isHeld());</span>
234 
235     auto transaction = m_transactions.get(requestData.transactionIdentifier());
236     if (!transaction)
237         return;
238 
239     ASSERT(transaction-&gt;isVersionChange());
240     transaction-&gt;renameObjectStore(requestData, objectStoreIdentifier, newName);
241 }
242 
243 void IDBServer::clearObjectStore(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier)
244 {
245     LOG(IndexedDB, &quot;IDBServer::clearObjectStore&quot;);
<span class="line-added">246     ASSERT(!isMainThread());</span>
<span class="line-added">247     ASSERT(m_lock.isHeld());</span>
248 
249     auto transaction = m_transactions.get(requestData.transactionIdentifier());
250     if (!transaction)
251         return;
252 
253     transaction-&gt;clearObjectStore(requestData, objectStoreIdentifier);
254 }
255 
256 void IDBServer::createIndex(const IDBRequestData&amp; requestData, const IDBIndexInfo&amp; info)
257 {
258     LOG(IndexedDB, &quot;IDBServer::createIndex&quot;);
<span class="line-added">259     ASSERT(!isMainThread());</span>
<span class="line-added">260     ASSERT(m_lock.isHeld());</span>
261 
262     auto transaction = m_transactions.get(requestData.transactionIdentifier());
263     if (!transaction)
264         return;
265 
266     ASSERT(transaction-&gt;isVersionChange());
267     transaction-&gt;createIndex(requestData, info);
268 }
269 
270 void IDBServer::deleteIndex(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, const String&amp; indexName)
271 {
272     LOG(IndexedDB, &quot;IDBServer::deleteIndex&quot;);
<span class="line-added">273     ASSERT(!isMainThread());</span>
<span class="line-added">274     ASSERT(m_lock.isHeld());</span>
275 
276     auto transaction = m_transactions.get(requestData.transactionIdentifier());
277     if (!transaction)
278         return;
279 
280     ASSERT(transaction-&gt;isVersionChange());
281     transaction-&gt;deleteIndex(requestData, objectStoreIdentifier, indexName);
282 }
283 
284 void IDBServer::renameIndex(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
285 {
286     LOG(IndexedDB, &quot;IDBServer::renameIndex&quot;);
<span class="line-added">287     ASSERT(!isMainThread());</span>
<span class="line-added">288     ASSERT(m_lock.isHeld());</span>
289 
290     auto transaction = m_transactions.get(requestData.transactionIdentifier());
291     if (!transaction)
292         return;
293 
294     ASSERT(transaction-&gt;isVersionChange());
295     transaction-&gt;renameIndex(requestData, objectStoreIdentifier, indexIdentifier, newName);
296 }
297 
298 void IDBServer::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
299 {
300     LOG(IndexedDB, &quot;IDBServer::putOrAdd&quot;);
<span class="line-added">301     ASSERT(!isMainThread());</span>
<span class="line-added">302     ASSERT(m_lock.isHeld());</span>
303 
304     auto transaction = m_transactions.get(requestData.transactionIdentifier());
305     if (!transaction)
306         return;
307 
308     transaction-&gt;putOrAdd(requestData, keyData, value, overwriteMode);
309 }
310 
311 void IDBServer::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData)
312 {
313     LOG(IndexedDB, &quot;IDBServer::getRecord&quot;);
<span class="line-added">314     ASSERT(!isMainThread());</span>
<span class="line-added">315     ASSERT(m_lock.isHeld());</span>
316 
317     auto transaction = m_transactions.get(requestData.transactionIdentifier());
318     if (!transaction)
319         return;
320 
321     transaction-&gt;getRecord(requestData, getRecordData);
322 }
323 
324 void IDBServer::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData)
325 {
326     LOG(IndexedDB, &quot;IDBServer::getAllRecords&quot;);
<span class="line-added">327     ASSERT(!isMainThread());</span>
<span class="line-added">328     ASSERT(m_lock.isHeld());</span>
329 
330     auto transaction = m_transactions.get(requestData.transactionIdentifier());
331     if (!transaction)
332         return;
333 
334     transaction-&gt;getAllRecords(requestData, getAllRecordsData);
335 }
336 
337 void IDBServer::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData)
338 {
339     LOG(IndexedDB, &quot;IDBServer::getCount&quot;);
<span class="line-added">340     ASSERT(!isMainThread());</span>
<span class="line-added">341     ASSERT(m_lock.isHeld());</span>
342 
343     auto transaction = m_transactions.get(requestData.transactionIdentifier());
344     if (!transaction)
345         return;
346 
347     transaction-&gt;getCount(requestData, keyRangeData);
348 }
349 
350 void IDBServer::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData)
351 {
352     LOG(IndexedDB, &quot;IDBServer::deleteRecord&quot;);
<span class="line-added">353     ASSERT(!isMainThread());</span>
<span class="line-added">354     ASSERT(m_lock.isHeld());</span>
355 
356     auto transaction = m_transactions.get(requestData.transactionIdentifier());
357     if (!transaction)
358         return;
359 
360     transaction-&gt;deleteRecord(requestData, keyRangeData);
361 }
362 
363 void IDBServer::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info)
364 {
365     LOG(IndexedDB, &quot;IDBServer::openCursor&quot;);
<span class="line-added">366     ASSERT(!isMainThread());</span>
<span class="line-added">367     ASSERT(m_lock.isHeld());</span>
368 
369     auto transaction = m_transactions.get(requestData.transactionIdentifier());
370     if (!transaction)
371         return;
372 
373     transaction-&gt;openCursor(requestData, info);
374 }
375 
376 void IDBServer::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data)
377 {
378     LOG(IndexedDB, &quot;IDBServer::iterateCursor&quot;);
<span class="line-added">379     ASSERT(!isMainThread());</span>
<span class="line-added">380     ASSERT(m_lock.isHeld());</span>
381 
382     auto transaction = m_transactions.get(requestData.transactionIdentifier());
383     if (!transaction)
384         return;
385 
386     transaction-&gt;iterateCursor(requestData, data);
387 }
388 
389 void IDBServer::establishTransaction(uint64_t databaseConnectionIdentifier, const IDBTransactionInfo&amp; info)
390 {
391     LOG(IndexedDB, &quot;IDBServer::establishTransaction&quot;);
<span class="line-added">392     ASSERT(!isMainThread());</span>
<span class="line-added">393     ASSERT(m_lock.isHeld());</span>
394 
395     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
396     if (!databaseConnection)
397         return;
398 
399     databaseConnection-&gt;establishTransaction(info);
400 }
401 
402 void IDBServer::commitTransaction(const IDBResourceIdentifier&amp; transactionIdentifier)
403 {
404     LOG(IndexedDB, &quot;IDBServer::commitTransaction&quot;);
<span class="line-added">405     ASSERT(!isMainThread());</span>
<span class="line-added">406     ASSERT(m_lock.isHeld());</span>
407 
408     auto transaction = m_transactions.get(transactionIdentifier);
409     if (!transaction) {
410         // If there is no transaction there is nothing to commit.
411         // We also have no access to a connection over which to message failure-to-commit.
412         return;
413     }
414 
415     transaction-&gt;commit();
416 }
417 
418 void IDBServer::didFinishHandlingVersionChangeTransaction(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
419 {
420     LOG(IndexedDB, &quot;IDBServer::didFinishHandlingVersionChangeTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
<span class="line-added">421     ASSERT(!isMainThread());</span>
<span class="line-added">422     ASSERT(m_lock.isHeld());</span>
423 
424     auto* connection = m_databaseConnections.get(databaseConnectionIdentifier);
425     if (!connection)
426         return;
427 
428     connection-&gt;didFinishHandlingVersionChange(transactionIdentifier);
429 }
430 
431 void IDBServer::databaseConnectionPendingClose(uint64_t databaseConnectionIdentifier)
432 {
433     LOG(IndexedDB, &quot;IDBServer::databaseConnectionPendingClose - %&quot; PRIu64, databaseConnectionIdentifier);
<span class="line-added">434     ASSERT(!isMainThread());</span>
<span class="line-added">435     ASSERT(m_lock.isHeld());</span>
436 
437     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
438     if (!databaseConnection)
439         return;
440 
441     databaseConnection-&gt;connectionPendingCloseFromClient();
442 }
443 
444 void IDBServer::databaseConnectionClosed(uint64_t databaseConnectionIdentifier)
445 {
446     LOG(IndexedDB, &quot;IDBServer::databaseConnectionClosed - %&quot; PRIu64, databaseConnectionIdentifier);
<span class="line-added">447     ASSERT(!isMainThread());</span>
<span class="line-added">448     ASSERT(m_lock.isHeld());</span>
449 
450     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
451     if (!databaseConnection)
452         return;
453 
454     databaseConnection-&gt;connectionClosedFromClient();
455 }
456 
457 void IDBServer::abortOpenAndUpgradeNeeded(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
458 {
459     LOG(IndexedDB, &quot;IDBServer::abortOpenAndUpgradeNeeded&quot;);
<span class="line-added">460     ASSERT(!isMainThread());</span>
<span class="line-added">461     ASSERT(m_lock.isHeld());</span>
462 
463     auto transaction = m_transactions.get(transactionIdentifier);
464     if (transaction)
465         transaction-&gt;abortWithoutCallback();
466 
467     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
468     if (!databaseConnection)
469         return;
470 
471     databaseConnection-&gt;connectionClosedFromClient();
472 }
473 
<span class="line-modified">474 void IDBServer::didFireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; requestIdentifier, IndexedDB::ConnectionClosedOnBehalfOfServer connectionClosed)</span>
475 {
476     LOG(IndexedDB, &quot;IDBServer::didFireVersionChangeEvent&quot;);
<span class="line-added">477     ASSERT(!isMainThread());</span>
<span class="line-added">478     ASSERT(m_lock.isHeld());</span>
479 
480     if (auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier))
<span class="line-modified">481         databaseConnection-&gt;didFireVersionChangeEvent(requestIdentifier, connectionClosed);</span>
482 }
483 
484 void IDBServer::openDBRequestCancelled(const IDBRequestData&amp; requestData)
485 {
486     LOG(IndexedDB, &quot;IDBServer::openDBRequestCancelled&quot;);
<span class="line-modified">487     ASSERT(!isMainThread());</span>
<span class="line-added">488     ASSERT(m_lock.isHeld());</span>
489 
490     auto* uniqueIDBDatabase = m_uniqueIDBDatabaseMap.get(requestData.databaseIdentifier());
491     if (!uniqueIDBDatabase)
492         return;
493 
494     uniqueIDBDatabase-&gt;openDBRequestCancelled(requestData.requestIdentifier());
495 }
496 
<span class="line-modified">497 void IDBServer::getAllDatabaseNames(IDBConnectionIdentifier serverConnectionIdentifier, const SecurityOriginData&amp; mainFrameOrigin, const SecurityOriginData&amp; openingOrigin, uint64_t callbackID)</span>
498 {
<span class="line-modified">499     ASSERT(!isMainThread());</span>
<span class="line-modified">500     ASSERT(m_lock.isHeld());</span>








501 


502     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
503     String oldDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(mainFrameOrigin, openingOrigin, databaseDirectoryPath, &quot;v0&quot;);
504     Vector&lt;String&gt; files = FileSystem::listDirectory(oldDirectory, &quot;*&quot;_s);
505     Vector&lt;String&gt; databases;
506     for (auto&amp; file : files) {
507         String encodedName = FileSystem::lastComponentOfPathIgnoringTrailingSlash(file);
508         databases.append(SQLiteIDBBackingStore::databaseNameFromEncodedFilename(encodedName));
509     }
510 
511     String directory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(mainFrameOrigin, openingOrigin, databaseDirectoryPath, &quot;v1&quot;);
512     files = FileSystem::listDirectory(directory, &quot;*&quot;_s);
513     for (auto&amp; file : files) {
514         auto databaseName = SQLiteIDBBackingStore::databaseNameFromFile(SQLiteIDBBackingStore::fullDatabasePathForDirectory(file));
515         if (!databaseName.isEmpty())
516             databases.append(databaseName);
517     }
518 





519     auto connection = m_connectionMap.get(serverConnectionIdentifier);
520     if (!connection)
521         return;
522 
<span class="line-modified">523     connection-&gt;didGetAllDatabaseNames(callbackID, databases);</span>

















524 }
525 
<span class="line-modified">526 void IDBServer::closeAndDeleteDatabasesModifiedSince(WallTime modificationTime)</span>
527 {
<span class="line-modified">528     ASSERT(!isMainThread());</span>
<span class="line-modified">529     ASSERT(m_lock.isHeld());</span>

530 
531     // If the modification time is in the future, don&#39;t both doing anything.
<span class="line-modified">532     if (modificationTime &gt; WallTime::now())</span>

533         return;

534 
535     HashSet&lt;UniqueIDBDatabase*&gt; openDatabases;
536     for (auto&amp; database : m_uniqueIDBDatabaseMap.values())



537         database-&gt;immediateCloseForUserDelete();
538 
<span class="line-modified">539     m_uniqueIDBDatabaseMap.clear();</span>
<span class="line-added">540 </span>
<span class="line-added">541     if (!m_databaseDirectoryPath.isEmpty()) {</span>
<span class="line-added">542         removeDatabasesModifiedSinceForVersion(modificationTime, &quot;v0&quot;);</span>
<span class="line-added">543         removeDatabasesModifiedSinceForVersion(modificationTime, &quot;v1&quot;);</span>
<span class="line-added">544     }</span>
545 }
546 
<span class="line-modified">547 void IDBServer::closeAndDeleteDatabasesForOrigins(const Vector&lt;SecurityOriginData&gt;&amp; origins)</span>
548 {
<span class="line-modified">549     ASSERT(!isMainThread());</span>
<span class="line-modified">550     ASSERT(m_lock.isHeld());</span>

551 
552     HashSet&lt;UniqueIDBDatabase*&gt; openDatabases;
553     for (auto&amp; database : m_uniqueIDBDatabaseMap.values()) {
554         const auto&amp; identifier = database-&gt;identifier();
555         for (auto&amp; origin : origins) {
556             if (identifier.isRelatedToOrigin(origin)) {
557                 openDatabases.add(database.get());
558                 break;
559             }
560         }
561     }
562 
<span class="line-modified">563     for (auto&amp; database : openDatabases) {</span>
564         database-&gt;immediateCloseForUserDelete();
<span class="line-added">565         m_uniqueIDBDatabaseMap.remove(database-&gt;identifier());</span>
<span class="line-added">566     }</span>
567 
<span class="line-modified">568     if (!m_databaseDirectoryPath.isEmpty()) {</span>
<span class="line-added">569         removeDatabasesWithOriginsForVersion(origins, &quot;v0&quot;);</span>
<span class="line-added">570         removeDatabasesWithOriginsForVersion(origins, &quot;v1&quot;);</span>
<span class="line-added">571     }</span>
572 }
573 
574 static void removeAllDatabasesForFullOriginPath(const String&amp; originPath, WallTime modifiedSince)
575 {
576     LOG(IndexedDB, &quot;removeAllDatabasesForOriginPath with originPath %s&quot;, originPath.utf8().data());
577     Vector&lt;String&gt; databasePaths = FileSystem::listDirectory(originPath, &quot;*&quot;);
578 
579     for (auto&amp; databasePath : databasePaths) {
580         String databaseFile = FileSystem::pathByAppendingComponent(databasePath, &quot;IndexedDB.sqlite3&quot;);
581         if (modifiedSince &gt; -WallTime::infinity() &amp;&amp; FileSystem::fileExists(databaseFile)) {
582             auto modificationTime = FileSystem::getFileModificationTime(databaseFile);
583             if (!modificationTime)
584                 continue;
585 
586             if (modificationTime.value() &lt; modifiedSince)
587                 continue;
588         }
589 
590         // Deleting this database means we need to delete all files that represent it.
591         // This includes:
</pre>
<hr />
<pre>
645     auto directories = FileSystem::listDirectory(originPath, &quot;*&quot;_s);
646     for (auto&amp; directory : directories) {
647         String databaseIdentifier = FileSystem::lastComponentOfPathIgnoringTrailingSlash(directory);
648         if (auto securityOrigin = SecurityOriginData::fromDatabaseIdentifier(databaseIdentifier))
649             removeAllDatabasesForFullOriginPath(directory, modifiedSince);
650     }
651 
652     removeAllDatabasesForFullOriginPath(originPath, modifiedSince);
653 }
654 
655 void IDBServer::removeDatabasesModifiedSinceForVersion(WallTime modifiedSince, const String&amp; version)
656 {
657     String versionPath = FileSystem::pathByAppendingComponent(databaseDirectoryPathIsolatedCopy(), version);
658     for (auto&amp; originPath : FileSystem::listDirectory(versionPath, &quot;*&quot;)) {
659         String databaseIdentifier = FileSystem::lastComponentOfPathIgnoringTrailingSlash(originPath);
660         if (auto securityOrigin = SecurityOriginData::fromDatabaseIdentifier(databaseIdentifier))
661             removeAllDatabasesForOriginPath(originPath, modifiedSince);
662     }
663 }
664 










665 void IDBServer::removeDatabasesWithOriginsForVersion(const Vector&lt;SecurityOriginData&gt; &amp;origins, const String&amp; version)
666 {
667     String versionPath = FileSystem::pathByAppendingComponent(databaseDirectoryPathIsolatedCopy(), version);
668     for (const auto&amp; origin : origins) {
669         String originPath = FileSystem::pathByAppendingComponent(versionPath, origin.databaseIdentifier());
670         removeAllDatabasesForOriginPath(originPath, -WallTime::infinity());
671 
672         for (auto&amp; topOriginPath : FileSystem::listDirectory(versionPath, &quot;*&quot;)) {
673             originPath = FileSystem::pathByAppendingComponent(topOriginPath, origin.databaseIdentifier());
674             removeAllDatabasesForOriginPath(originPath, -WallTime::infinity());
675         }
676     }
677 }
678 
<span class="line-modified">679 StorageQuotaManager::Decision IDBServer::requestSpace(const ClientOrigin&amp; origin, uint64_t taskSize)</span>











































































































680 {
681     ASSERT(!isMainThread());
<span class="line-added">682     ASSERT(m_lock.isHeld());</span>
683 
<span class="line-modified">684     StorageQuotaManager::Decision result = StorageQuotaManager::Decision::Deny;</span>



















685 
<span class="line-modified">686     // Release lock because space requesting could be blocked.</span>
<span class="line-modified">687     m_lock.unlock();</span>
<span class="line-added">688     result = m_spaceRequester(origin, taskSize);</span>
<span class="line-added">689     m_lock.lock();</span>
690 
<span class="line-modified">691     return result;</span>



692 }
693 
<span class="line-modified">694 uint64_t IDBServer::diskUsage(const String&amp; rootDirectory, const ClientOrigin&amp; origin)</span>
695 {
<span class="line-modified">696     ASSERT(!isMainThread());</span>











697 
<span class="line-modified">698     auto oldVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, rootDirectory, &quot;v0&quot;_str);</span>
<span class="line-modified">699     auto newVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, rootDirectory, &quot;v1&quot;_str);</span>
<span class="line-modified">700     return SQLiteIDBBackingStore::databasesSizeForDirectory(oldVersionOriginDirectory) + SQLiteIDBBackingStore::databasesSizeForDirectory(newVersionOriginDirectory);</span>
701 }
702 
703 void IDBServer::upgradeFilesIfNecessary()
704 {
705     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
706     if (databaseDirectoryPath.isEmpty() || !FileSystem::fileExists(databaseDirectoryPath))
707         return;
708 
709     String newVersionDirectory = FileSystem::pathByAppendingComponent(databaseDirectoryPath, &quot;v1&quot;);
710     if (!FileSystem::fileExists(newVersionDirectory))
711         FileSystem::makeAllDirectories(newVersionDirectory);
712 }
713 
<span class="line-modified">714 void IDBServer::stopDatabaseActivitiesOnMainThread()</span>
715 {
<span class="line-added">716     ASSERT(isMainThread());</span>
<span class="line-added">717     ASSERT(m_lock.isHeld());</span>
<span class="line-added">718 </span>
719     // Only stop non-ephemeral IDBServers that can hold locked database files.
720     if (m_sessionID.isEphemeral())
721         return;
722 






723     for (auto&amp; database : m_uniqueIDBDatabaseMap.values())
<span class="line-modified">724         database-&gt;abortActiveTransactions();</span>








725 }
726 
727 } // namespace IDBServer
728 } // namespace WebCore
729 
730 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
</tr>
</table>
<center><a href="IDBSerializationContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="IDBServer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FEDropShadow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 #include &quot;FEDropShadow.h&quot;
 22 
 23 #include &quot;FEGaussianBlur.h&quot;
 24 #include &quot;Filter.h&quot;
 25 #include &quot;GraphicsContext.h&quot;
 26 #include &quot;ShadowBlur.h&quot;
 27 #include &lt;JavaScriptCore/Uint8ClampedArray.h&gt;
 28 #include &lt;wtf/MathExtras.h&gt;
 29 #include &lt;wtf/text/TextStream.h&gt;
 30 
 31 namespace WebCore {
 32 
 33 FEDropShadow::FEDropShadow(Filter&amp; filter, float stdX, float stdY, float dx, float dy, const Color&amp; shadowColor, float shadowOpacity)
 34     : FilterEffect(filter)
 35     , m_stdX(stdX)
 36     , m_stdY(stdY)
 37     , m_dx(dx)
 38     , m_dy(dy)
 39     , m_shadowColor(shadowColor)
 40     , m_shadowOpacity(shadowOpacity)
 41 {
 42 }
 43 
 44 Ref&lt;FEDropShadow&gt; FEDropShadow::create(Filter&amp; filter, float stdX, float stdY, float dx, float dy, const Color&amp; shadowColor, float shadowOpacity)
 45 {
 46     return adoptRef(*new FEDropShadow(filter, stdX, stdY, dx, dy, shadowColor, shadowOpacity));
 47 }
 48 
 49 void FEDropShadow::determineAbsolutePaintRect()
 50 {
 51     Filter&amp; filter = this-&gt;filter();
 52 
 53     FloatRect absolutePaintRect = inputEffect(0)-&gt;absolutePaintRect();
 54     FloatRect absoluteOffsetPaintRect(absolutePaintRect);
 55     absoluteOffsetPaintRect.move(filter.scaledByFilterResolution({ m_dx, m_dy }));
 56     absolutePaintRect.unite(absoluteOffsetPaintRect);
 57 
 58     IntSize kernelSize = FEGaussianBlur::calculateKernelSize(filter, { m_stdX, m_stdY });
 59 
 60     // We take the half kernel size and multiply it with three, because we run box blur three times.
 61     absolutePaintRect.inflateX(3 * kernelSize.width() * 0.5f);
 62     absolutePaintRect.inflateY(3 * kernelSize.height() * 0.5f);
 63 
 64     if (clipsToBounds())
 65         absolutePaintRect.intersect(maxEffectRect());
 66     else
 67         absolutePaintRect.unite(maxEffectRect());
 68 
 69     setAbsolutePaintRect(enclosingIntRect(absolutePaintRect));
 70 }
 71 
 72 void FEDropShadow::platformApplySoftware()
 73 {
 74     FilterEffect* in = inputEffect(0);
 75 
 76     ImageBuffer* resultImage = createImageBufferResult();
 77     if (!resultImage)
 78         return;
 79 
 80     Filter&amp; filter = this-&gt;filter();
 81 
 82     FloatSize blurRadius = 2 * filter.scaledByFilterResolution({ m_stdX, m_stdY });
 83     blurRadius.scale(filter.filterScale());
 84     FloatSize offset = filter.scaledByFilterResolution({ m_dx, m_dy });
 85 
 86     FloatRect drawingRegion = drawingRegionOfInputImage(in-&gt;absolutePaintRect());
 87     FloatRect drawingRegionWithOffset(drawingRegion);
 88     drawingRegionWithOffset.move(offset);
 89 
 90     ImageBuffer* sourceImage = in-&gt;imageBufferResult();
 91     if (!sourceImage)
 92         return;
 93 
 94     GraphicsContext&amp; resultContext = resultImage-&gt;context();
 95     resultContext.setAlpha(m_shadowOpacity);
 96     resultContext.drawImageBuffer(*sourceImage, drawingRegionWithOffset);
 97     resultContext.setAlpha(1);
 98 
 99     ShadowBlur contextShadow(blurRadius, offset, m_shadowColor);
100 
101     // TODO: Direct pixel access to ImageBuffer would avoid copying the ImageData.
102     IntRect shadowArea(IntPoint(), resultImage-&gt;internalSize());
103     auto srcPixelArray = resultImage-&gt;getPremultipliedImageData(shadowArea, nullptr, ImageBuffer::BackingStoreCoordinateSystem);
104     if (!srcPixelArray)
105         return;
106 
107     contextShadow.blurLayerImage(srcPixelArray-&gt;data(), shadowArea.size(), 4 * shadowArea.size().width());
108 
109     resultImage-&gt;putByteArray(*srcPixelArray, AlphaPremultiplication::Premultiplied, shadowArea.size(), shadowArea, IntPoint(), ImageBuffer::BackingStoreCoordinateSystem);
110 
111     resultContext.setCompositeOperation(CompositeOperator::SourceIn);
112     resultContext.fillRect(FloatRect(FloatPoint(), absolutePaintRect().size()), m_shadowColor);
113     resultContext.setCompositeOperation(CompositeOperator::DestinationOver);
114 
115     resultImage-&gt;context().drawImageBuffer(*sourceImage, drawingRegion);
116 }
117 
118 IntOutsets FEDropShadow::outsets() const
119 {
120     IntSize outsetSize = FEGaussianBlur::calculateOutsetSize({ m_stdX, m_stdY });
121     return {
122         std::max&lt;int&gt;(0, outsetSize.height() - m_dy),
123         std::max&lt;int&gt;(0, outsetSize.width() + m_dx),
124         std::max&lt;int&gt;(0, outsetSize.height() + m_dy),
125         std::max&lt;int&gt;(0, outsetSize.width() - m_dx)
126     };
127 }
128 
129 TextStream&amp; FEDropShadow::externalRepresentation(TextStream&amp; ts, RepresentationType representation) const
130 {
131     ts &lt;&lt; indent &lt;&lt;&quot;[feDropShadow&quot;;
132     FilterEffect::externalRepresentation(ts, representation);
133     ts &lt;&lt; &quot; stdDeviation=\&quot;&quot; &lt;&lt; m_stdX &lt;&lt; &quot;, &quot; &lt;&lt; m_stdY &lt;&lt; &quot;\&quot; dx=\&quot;&quot; &lt;&lt; m_dx &lt;&lt; &quot;\&quot; dy=\&quot;&quot; &lt;&lt; m_dy &lt;&lt; &quot;\&quot; flood-color=\&quot;&quot; &lt;&lt; m_shadowColor.nameForRenderTreeAsText() &lt;&lt;&quot;\&quot; flood-opacity=\&quot;&quot; &lt;&lt; m_shadowOpacity &lt;&lt; &quot;]\n&quot;;
134 
135     TextStream::IndentScope indentScope(ts);
136     inputEffect(0)-&gt;externalRepresentation(ts, representation);
137     return ts;
138 }
139 
140 } // namespace WebCore
    </pre>
  </body>
</html>
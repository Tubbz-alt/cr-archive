<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;OffscreenCanvas.h&quot;
 28 
<a name="1" id="anc1"></a><span class="line-added"> 29 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 30 </span>
<span class="line-added"> 31 #include &quot;CSSValuePool.h&quot;</span>
 32 #include &quot;CanvasRenderingContext.h&quot;
 33 #include &quot;ImageBitmap.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 34 #include &quot;JSBlob.h&quot;</span>
<span class="line-added"> 35 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
<span class="line-added"> 36 #include &quot;MIMETypeRegistry.h&quot;</span>
<span class="line-added"> 37 #include &quot;OffscreenCanvasRenderingContext2D.h&quot;</span>
 38 #include &quot;WebGLRenderingContext.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 39 #include &quot;WorkerGlobalScope.h&quot;</span>
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 WTF_MAKE_ISO_ALLOCATED_IMPL(OffscreenCanvas);
 45 
<a name="4" id="anc4"></a><span class="line-added"> 46 DetachedOffscreenCanvas::DetachedOffscreenCanvas(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer, const IntSize&amp; size, bool originClean)</span>
<span class="line-added"> 47     : m_buffer(WTFMove(buffer))</span>
<span class="line-added"> 48     , m_size(size)</span>
<span class="line-added"> 49     , m_originClean(originClean)</span>
<span class="line-added"> 50 {</span>
<span class="line-added"> 51 }</span>
<span class="line-added"> 52 </span>
<span class="line-added"> 53 std::unique_ptr&lt;ImageBuffer&gt; DetachedOffscreenCanvas::takeImageBuffer()</span>
<span class="line-added"> 54 {</span>
<span class="line-added"> 55     return WTFMove(m_buffer);</span>
<span class="line-added"> 56 }</span>
<span class="line-added"> 57 </span>
 58 Ref&lt;OffscreenCanvas&gt; OffscreenCanvas::create(ScriptExecutionContext&amp; context, unsigned width, unsigned height)
 59 {
 60     return adoptRef(*new OffscreenCanvas(context, width, height));
 61 }
 62 
<a name="5" id="anc5"></a><span class="line-added"> 63 Ref&lt;OffscreenCanvas&gt; OffscreenCanvas::create(ScriptExecutionContext&amp; context, std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&amp;&amp; detachedCanvas)</span>
<span class="line-added"> 64 {</span>
<span class="line-added"> 65     Ref&lt;OffscreenCanvas&gt; clone = adoptRef(*new OffscreenCanvas(context, detachedCanvas-&gt;size().width(), detachedCanvas-&gt;size().height()));</span>
<span class="line-added"> 66     clone-&gt;setImageBuffer(detachedCanvas-&gt;takeImageBuffer());</span>
<span class="line-added"> 67     if (!detachedCanvas-&gt;originClean())</span>
<span class="line-added"> 68         clone-&gt;setOriginTainted();</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70     return clone;</span>
<span class="line-added"> 71 }</span>
<span class="line-added"> 72 </span>
 73 OffscreenCanvas::OffscreenCanvas(ScriptExecutionContext&amp; context, unsigned width, unsigned height)
<a name="6" id="anc6"></a><span class="line-modified"> 74     : CanvasBase(IntSize(width, height))</span>
<span class="line-modified"> 75     , ContextDestructionObserver(&amp;context)</span>
 76 {
 77 }
 78 
 79 OffscreenCanvas::~OffscreenCanvas()
 80 {
 81     notifyObserversCanvasDestroyed();
 82 
<a name="7" id="anc7"></a><span class="line-modified"> 83     m_context = nullptr; // Ensure this goes away before the ImageBuffer.</span>
<span class="line-added"> 84     setImageBuffer(nullptr);</span>
 85 }
 86 
 87 unsigned OffscreenCanvas::width() const
 88 {
<a name="8" id="anc8"></a><span class="line-modified"> 89     if (m_detached)</span>
<span class="line-modified"> 90         return 0;</span>
<span class="line-modified"> 91     return CanvasBase::width();</span>



 92 }
 93 
 94 unsigned OffscreenCanvas::height() const
 95 {
<a name="9" id="anc9"></a><span class="line-modified"> 96     if (m_detached)</span>
<span class="line-added"> 97         return 0;</span>
<span class="line-added"> 98     return CanvasBase::height();</span>
 99 }
100 
<a name="10" id="anc10"></a><span class="line-modified">101 void OffscreenCanvas::setWidth(unsigned newWidth)</span>
102 {
<a name="11" id="anc11"></a><span class="line-modified">103     if (m_detached)</span>
<span class="line-added">104         return;</span>
<span class="line-added">105     setSize(IntSize(newWidth, height()));</span>
106 }
107 
<a name="12" id="anc12"></a><span class="line-modified">108 void OffscreenCanvas::setHeight(unsigned newHeight)</span>
109 {
<a name="13" id="anc13"></a><span class="line-modified">110     if (m_detached)</span>
<span class="line-added">111         return;</span>
<span class="line-added">112     setSize(IntSize(width(), newHeight));</span>
113 }
114 
115 void OffscreenCanvas::setSize(const IntSize&amp; newSize)
116 {
<a name="14" id="anc14"></a><span class="line-modified">117     CanvasBase::setSize(newSize);</span>
<span class="line-added">118     reset();</span>
119 }
120 
<a name="15" id="anc15"></a><span class="line-modified">121 ExceptionOr&lt;OffscreenRenderingContext&gt; OffscreenCanvas::getContext(JSC::JSGlobalObject&amp; state, RenderingContextType contextType, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>

122 {
<a name="16" id="anc16"></a><span class="line-modified">123     if (m_detached)</span>
<span class="line-modified">124         return Exception { InvalidStateError };</span>
<span class="line-added">125 </span>
<span class="line-added">126     if (contextType == RenderingContextType::_2d) {</span>
<span class="line-added">127         if (m_context) {</span>
<span class="line-added">128             if (!is&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context))</span>
<span class="line-added">129                 return Exception { InvalidStateError };</span>
<span class="line-added">130             return { RefPtr&lt;OffscreenCanvasRenderingContext2D&gt; { &amp;downcast&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context) } };</span>
<span class="line-added">131         }</span>
<span class="line-added">132 </span>
<span class="line-added">133         m_context = makeUnique&lt;OffscreenCanvasRenderingContext2D&gt;(*this);</span>
<span class="line-added">134         if (!m_context)</span>
<span class="line-added">135             return { RefPtr&lt;OffscreenCanvasRenderingContext2D&gt; { nullptr } };</span>
136 
<a name="17" id="anc17"></a><span class="line-added">137         return { RefPtr&lt;OffscreenCanvasRenderingContext2D&gt; { &amp;downcast&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context) } };</span>
<span class="line-added">138     }</span>
<span class="line-added">139 #if ENABLE(WEBGL)</span>
140     if (contextType == RenderingContextType::Webgl) {
<a name="18" id="anc18"></a><span class="line-added">141         if (m_context) {</span>
<span class="line-added">142             if (!is&lt;WebGLRenderingContext&gt;(*m_context))</span>
<span class="line-added">143                 return Exception { InvalidStateError };</span>
<span class="line-added">144             return { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };</span>
<span class="line-added">145         }</span>
<span class="line-added">146 </span>
147         auto scope = DECLARE_THROW_SCOPE(state.vm());
148         auto attributes = convert&lt;IDLDictionary&lt;WebGLContextAttributes&gt;&gt;(state, !arguments.isEmpty() ? arguments[0].get() : JSC::jsUndefined());
149         RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
150 
151         m_context = WebGLRenderingContextBase::create(*this, attributes, &quot;webgl&quot;);
152         if (!m_context)
<a name="19" id="anc19"></a><span class="line-modified">153             return { RefPtr&lt;WebGLRenderingContext&gt; { nullptr } };</span>
154 
155         return { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };
156     }
<a name="20" id="anc20"></a><span class="line-added">157 #endif</span>
158 
<a name="21" id="anc21"></a><span class="line-modified">159     return Exception { NotSupportedError };</span>
160 }
<a name="22" id="anc22"></a>
161 
<a name="23" id="anc23"></a><span class="line-modified">162 ExceptionOr&lt;RefPtr&lt;ImageBitmap&gt;&gt; OffscreenCanvas::transferToImageBitmap()</span>
163 {
<a name="24" id="anc24"></a><span class="line-modified">164     if (m_detached || !m_context)</span>
<span class="line-modified">165         return Exception { InvalidStateError };</span>
<span class="line-added">166 </span>
<span class="line-added">167     if (is&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context)) {</span>
<span class="line-added">168         if (!width() || !height())</span>
<span class="line-added">169             return { RefPtr&lt;ImageBitmap&gt; { nullptr } };</span>
<span class="line-added">170 </span>
<span class="line-added">171         if (!m_hasCreatedImageBuffer)</span>
<span class="line-added">172             return { ImageBitmap::create({ ImageBuffer::create(size(), RenderingMode::Unaccelerated), true }) };</span>
<span class="line-added">173 </span>
<span class="line-added">174         auto buffer = takeImageBuffer();</span>
<span class="line-added">175         if (!buffer)</span>
<span class="line-added">176             return { RefPtr&lt;ImageBitmap&gt; { nullptr } };</span>
<span class="line-added">177 </span>
<span class="line-added">178         return { ImageBitmap::create({ WTFMove(buffer), originClean() }) };</span>
<span class="line-added">179     }</span>
180 
181 #if ENABLE(WEBGL)
<a name="25" id="anc25"></a><span class="line-modified">182     if (is&lt;WebGLRenderingContext&gt;(*m_context)) {</span>
<span class="line-added">183         auto webGLContext = &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context);</span>
<span class="line-added">184 </span>
<span class="line-added">185         // FIXME: We&#39;re supposed to create an ImageBitmap using the backing</span>
<span class="line-added">186         // store from this canvas (or its context), but for now we&#39;ll just</span>
<span class="line-added">187         // create a new bitmap and paint into it.</span>
<span class="line-added">188 </span>
<span class="line-added">189         auto imageBitmap = ImageBitmap::create(size());</span>
<span class="line-added">190         if (!imageBitmap-&gt;buffer())</span>
<span class="line-added">191             return { RefPtr&lt;ImageBitmap&gt; { nullptr } };</span>
<span class="line-added">192 </span>
<span class="line-added">193         auto* gc3d = webGLContext-&gt;graphicsContextGL();</span>
<span class="line-added">194         gc3d-&gt;paintRenderingResultsToCanvas(imageBitmap-&gt;buffer());</span>
<span class="line-added">195 </span>
<span class="line-added">196         // FIXME: The transfer algorithm requires that the canvas effectively</span>
<span class="line-added">197         // creates a new backing store. Since we&#39;re not doing that yet, we</span>
<span class="line-added">198         // need to erase what&#39;s there.</span>
<span class="line-added">199 </span>
<span class="line-added">200         GCGLfloat clearColor[4];</span>
<span class="line-added">201         gc3d-&gt;getFloatv(GraphicsContextGL::COLOR_CLEAR_VALUE, clearColor);</span>
<span class="line-added">202         gc3d-&gt;clearColor(0, 0, 0, 0);</span>
<span class="line-added">203         gc3d-&gt;clear(GraphicsContextGL::COLOR_BUFFER_BIT | GraphicsContextGL::DEPTH_BUFFER_BIT | GraphicsContextGL::STENCIL_BUFFER_BIT);</span>
<span class="line-added">204         gc3d-&gt;clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);</span>
<span class="line-added">205 </span>
<span class="line-added">206         return { WTFMove(imageBitmap) };</span>
<span class="line-added">207     }</span>
<span class="line-added">208 #endif</span>
<span class="line-added">209 </span>
<span class="line-added">210     return Exception { NotSupportedError };</span>
<span class="line-added">211 }</span>
<span class="line-added">212 </span>
<span class="line-added">213 static String toEncodingMimeType(const String&amp; mimeType)</span>
<span class="line-added">214 {</span>
<span class="line-added">215     if (!MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(mimeType))</span>
<span class="line-added">216         return &quot;image/png&quot;_s;</span>
<span class="line-added">217     return mimeType.convertToASCIILowercase();</span>
<span class="line-added">218 }</span>
<span class="line-added">219 </span>
<span class="line-added">220 static Optional&lt;double&gt; qualityFromDouble(double qualityNumber)</span>
<span class="line-added">221 {</span>
<span class="line-added">222     if (!(qualityNumber &gt;= 0 &amp;&amp; qualityNumber &lt;= 1))</span>
<span class="line-added">223         return WTF::nullopt;</span>
<span class="line-added">224 </span>
<span class="line-added">225     return qualityNumber;</span>
<span class="line-added">226 }</span>
<span class="line-added">227 </span>
<span class="line-added">228 void OffscreenCanvas::convertToBlob(ImageEncodeOptions&amp;&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
<span class="line-added">229 {</span>
<span class="line-added">230     if (!originClean()) {</span>
<span class="line-added">231         promise-&gt;reject(SecurityError);</span>
<span class="line-added">232         return;</span>
<span class="line-added">233     }</span>
<span class="line-added">234     if (size().isEmpty()) {</span>
<span class="line-added">235         promise-&gt;reject(IndexSizeError);</span>
<span class="line-added">236         return;</span>
<span class="line-added">237     }</span>
<span class="line-added">238     if (m_detached || !buffer()) {</span>
<span class="line-added">239         promise-&gt;reject(InvalidStateError);</span>
<span class="line-added">240         return;</span>
<span class="line-added">241     }</span>
<span class="line-added">242 </span>
<span class="line-added">243     makeRenderingResultsAvailable();</span>
<span class="line-added">244 </span>
<span class="line-added">245     auto encodingMIMEType = toEncodingMimeType(options.type);</span>
<span class="line-added">246     auto quality = qualityFromDouble(options.quality);</span>
<span class="line-added">247 </span>
<span class="line-added">248     Vector&lt;uint8_t&gt; blobData = buffer()-&gt;toData(encodingMIMEType, quality);</span>
<span class="line-added">249     if (blobData.isEmpty()) {</span>
<span class="line-added">250         promise-&gt;reject(EncodingError);</span>
<span class="line-added">251         return;</span>
<span class="line-added">252     }</span>
<span class="line-added">253 </span>
<span class="line-added">254     Ref&lt;Blob&gt; blob = Blob::create(WTFMove(blobData), encodingMIMEType);</span>
<span class="line-added">255     promise-&gt;resolveWithNewlyCreated&lt;IDLInterface&lt;Blob&gt;&gt;(WTFMove(blob));</span>
<span class="line-added">256 }</span>
<span class="line-added">257 </span>
<span class="line-added">258 void OffscreenCanvas::didDraw(const FloatRect&amp; rect)</span>
<span class="line-added">259 {</span>
<span class="line-added">260     notifyObserversCanvasChanged(rect);</span>
<span class="line-added">261 }</span>
<span class="line-added">262 </span>
<span class="line-added">263 SecurityOrigin* OffscreenCanvas::securityOrigin() const</span>
<span class="line-added">264 {</span>
<span class="line-added">265     auto&amp; context = *canvasBaseScriptExecutionContext();</span>
<span class="line-added">266     if (is&lt;WorkerGlobalScope&gt;(context))</span>
<span class="line-added">267         return &amp;downcast&lt;WorkerGlobalScope&gt;(context).topOrigin();</span>
<span class="line-added">268 </span>
<span class="line-added">269     return &amp;downcast&lt;Document&gt;(context).securityOrigin();</span>
<span class="line-added">270 }</span>
<span class="line-added">271 </span>
<span class="line-added">272 bool OffscreenCanvas::canDetach() const</span>
<span class="line-added">273 {</span>
<span class="line-added">274     return !m_detached &amp;&amp; !m_context;</span>
<span class="line-added">275 }</span>
<span class="line-added">276 </span>
<span class="line-added">277 std::unique_ptr&lt;DetachedOffscreenCanvas&gt; OffscreenCanvas::detach()</span>
<span class="line-added">278 {</span>
<span class="line-added">279     if (!canDetach())</span>
280         return nullptr;
281 
<a name="26" id="anc26"></a><span class="line-modified">282     m_detached = true;</span>
<span class="line-added">283 </span>
<span class="line-added">284     return makeUnique&lt;DetachedOffscreenCanvas&gt;(takeImageBuffer(), size(), originClean());</span>
<span class="line-added">285 }</span>
<span class="line-added">286 </span>
<span class="line-added">287 CSSValuePool&amp; OffscreenCanvas::cssValuePool()</span>
<span class="line-added">288 {</span>
<span class="line-added">289     auto* context = canvasBaseScriptExecutionContext();</span>
<span class="line-added">290     if (context-&gt;isWorkerGlobalScope())</span>
<span class="line-added">291         return downcast&lt;WorkerGlobalScope&gt;(*context).cssValuePool();</span>
<span class="line-added">292 </span>
<span class="line-added">293     ASSERT(context-&gt;isDocument());</span>
<span class="line-added">294     return CSSValuePool::singleton();</span>
<span class="line-added">295 }</span>
<span class="line-added">296 </span>
<span class="line-added">297 void OffscreenCanvas::createImageBuffer() const</span>
<span class="line-added">298 {</span>
<span class="line-added">299     m_hasCreatedImageBuffer = true;</span>
<span class="line-added">300 </span>
<span class="line-added">301     if (!width() || !height())</span>
<span class="line-added">302         return;</span>
303 
<a name="27" id="anc27"></a><span class="line-modified">304     setImageBuffer(ImageBuffer::create(size(), RenderingMode::Unaccelerated));</span>
<span class="line-modified">305 }</span>
<span class="line-modified">306 </span>
<span class="line-added">307 std::unique_ptr&lt;ImageBuffer&gt; OffscreenCanvas::takeImageBuffer() const</span>
<span class="line-added">308 {</span>
<span class="line-added">309     if (!m_detached)</span>
<span class="line-added">310         m_hasCreatedImageBuffer = true;</span>
311 
<a name="28" id="anc28"></a><span class="line-modified">312     // This function is primarily for use with transferToImageBitmap, which</span>
<span class="line-modified">313     // requires that the canvas bitmap refer to a new, blank bitmap of the same</span>
<span class="line-added">314     // size after the existing bitmap is taken. In the case of a zero-size</span>
<span class="line-added">315     // bitmap, our buffer is null, so returning early here is valid.</span>
<span class="line-added">316     if (size().isEmpty())</span>
317         return nullptr;
318 
<a name="29" id="anc29"></a><span class="line-modified">319     return setImageBuffer(m_detached ? nullptr : ImageBuffer::create(size(), RenderingMode::Unaccelerated));</span>
<span class="line-modified">320 }</span>
321 
<a name="30" id="anc30"></a><span class="line-modified">322 void OffscreenCanvas::reset()</span>
<span class="line-modified">323 {</span>
<span class="line-modified">324     resetGraphicsContextState();</span>
<span class="line-added">325     if (is&lt;OffscreenCanvasRenderingContext2D&gt;(m_context.get()))</span>
<span class="line-added">326         downcast&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context).reset();</span>
327 
<a name="31" id="anc31"></a><span class="line-modified">328     m_hasCreatedImageBuffer = false;</span>
<span class="line-modified">329     setImageBuffer(nullptr);</span>



330 
<a name="32" id="anc32"></a><span class="line-modified">331     notifyObserversCanvasResized();</span>



332 }
333 
334 }
<a name="33" id="anc33"></a><span class="line-added">335 </span>
<span class="line-added">336 #endif</span>
<a name="34" id="anc34"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="34" type="hidden" />
</body>
</html>
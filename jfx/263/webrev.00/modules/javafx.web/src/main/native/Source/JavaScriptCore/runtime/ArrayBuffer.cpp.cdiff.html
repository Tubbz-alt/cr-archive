<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArgList.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayBuffer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,28 ***</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;ArrayBuffer.h&quot;
  
<span class="line-removed">- #include &quot;ArrayBufferNeuteringWatchpointSet.h&quot;</span>
  #include &quot;JSArrayBufferView.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &lt;wtf/Gigacage.h&gt;
  
  namespace JSC {
  
  SharedArrayBufferContents::SharedArrayBufferContents(void* data, unsigned size, ArrayBufferDestructorFunction&amp;&amp; destructor)
      : m_data(data, size)
      , m_destructor(WTFMove(destructor))
      , m_sizeInBytes(size)
  {
  }
  
  SharedArrayBufferContents::~SharedArrayBufferContents()
  {
<span class="line-modified">!     // FIXME: we shouldn&#39;t use getUnsafe here https://bugs.webkit.org/show_bug.cgi?id=197698</span>
<span class="line-modified">!     m_destructor(m_data.getUnsafe());</span>
  }
  
  ArrayBufferContents::ArrayBufferContents()
  {
      reset();
<span class="line-new-header">--- 24,39 ---</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;ArrayBuffer.h&quot;
  
  #include &quot;JSArrayBufferView.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &lt;wtf/Gigacage.h&gt;
  
  namespace JSC {
  
<span class="line-added">+ Ref&lt;SharedTask&lt;void(void*)&gt;&gt; ArrayBuffer::primitiveGigacageDestructor()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static LazyNeverDestroyed&lt;Ref&lt;SharedTask&lt;void(void*)&gt;&gt;&gt; destructor;</span>
<span class="line-added">+     static std::once_flag onceKey;</span>
<span class="line-added">+     std::call_once(onceKey, [&amp;] {</span>
<span class="line-added">+         destructor.construct(createSharedTask&lt;void(void*)&gt;([] (void* p) { Gigacage::free(Gigacage::Primitive, p); }));</span>
<span class="line-added">+     });</span>
<span class="line-added">+     return destructor.get().copyRef();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  SharedArrayBufferContents::SharedArrayBufferContents(void* data, unsigned size, ArrayBufferDestructorFunction&amp;&amp; destructor)
      : m_data(data, size)
      , m_destructor(WTFMove(destructor))
      , m_sizeInBytes(size)
  {
  }
  
  SharedArrayBufferContents::~SharedArrayBufferContents()
  {
<span class="line-modified">!     if (m_destructor) {</span>
<span class="line-modified">!         // FIXME: we shouldn&#39;t use getUnsafe here https://bugs.webkit.org/show_bug.cgi?id=197698</span>
<span class="line-added">+         m_destructor-&gt;run(m_data.getUnsafe());</span>
<span class="line-added">+     }</span>
  }
  
  ArrayBufferContents::ArrayBufferContents()
  {
      reset();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 82,19 ***</span>
      reset();
  }
  
  void ArrayBufferContents::destroy()
  {
<span class="line-modified">!     // FIXME: We shouldn&#39;t use getUnsafe here: https://bugs.webkit.org/show_bug.cgi?id=197698</span>
<span class="line-modified">!     m_destructor(m_data.getUnsafe());</span>
  }
  
  void ArrayBufferContents::reset()
  {
<span class="line-removed">-     m_destructor = [] (void*) { };</span>
<span class="line-removed">-     m_shared = nullptr;</span>
      m_data = nullptr;
      m_sizeInBytes = 0;
  }
  
  void ArrayBufferContents::tryAllocate(unsigned numElements, unsigned elementByteSize, InitializationPolicy policy)
  {
<span class="line-new-header">--- 93,21 ---</span>
      reset();
  }
  
  void ArrayBufferContents::destroy()
  {
<span class="line-modified">!     if (m_destructor) {</span>
<span class="line-modified">!         // FIXME: We shouldn&#39;t use getUnsafe here: https://bugs.webkit.org/show_bug.cgi?id=197698</span>
<span class="line-added">+         m_destructor-&gt;run(m_data.getUnsafe());</span>
<span class="line-added">+     }</span>
  }
  
  void ArrayBufferContents::reset()
  {
      m_data = nullptr;
<span class="line-added">+     m_destructor = nullptr;</span>
<span class="line-added">+     m_shared = nullptr;</span>
      m_sizeInBytes = 0;
  }
  
  void ArrayBufferContents::tryAllocate(unsigned numElements, unsigned elementByteSize, InitializationPolicy policy)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,17 ***</span>
      if (policy == ZeroInitialize)
          memset(data, 0, allocationSize);
  
      m_sizeInBytes = sizeInBytes;
      RELEASE_ASSERT(m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
<span class="line-modified">!     m_destructor = [] (void* p) { Gigacage::free(Gigacage::Primitive, p); };</span>
  }
  
  void ArrayBufferContents::makeShared()
  {
      m_shared = adoptRef(new SharedArrayBufferContents(data(), sizeInBytes(), WTFMove(m_destructor)));
<span class="line-modified">!     m_destructor = [] (void*) { };</span>
  }
  
  void ArrayBufferContents::transferTo(ArrayBufferContents&amp; other)
  {
      other.clear();
<span class="line-new-header">--- 134,17 ---</span>
      if (policy == ZeroInitialize)
          memset(data, 0, allocationSize);
  
      m_sizeInBytes = sizeInBytes;
      RELEASE_ASSERT(m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
<span class="line-modified">!     m_destructor = ArrayBuffer::primitiveGigacageDestructor();</span>
  }
  
  void ArrayBufferContents::makeShared()
  {
      m_shared = adoptRef(new SharedArrayBufferContents(data(), sizeInBytes(), WTFMove(m_destructor)));
<span class="line-modified">!     m_destructor = nullptr;</span>
  }
  
  void ArrayBufferContents::transferTo(ArrayBufferContents&amp; other)
  {
      other.clear();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 156,13 ***</span>
  
  void ArrayBufferContents::shareWith(ArrayBufferContents&amp; other)
  {
      ASSERT(!other.m_data);
      ASSERT(m_shared);
<span class="line-removed">-     other.m_destructor = [] (void*) { };</span>
<span class="line-removed">-     other.m_shared = m_shared;</span>
      other.m_data = m_data;
      other.m_sizeInBytes = m_sizeInBytes;
      RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
  }
  
  Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(unsigned numElements, unsigned elementByteSize)
<span class="line-new-header">--- 169,13 ---</span>
  
  void ArrayBufferContents::shareWith(ArrayBufferContents&amp; other)
  {
      ASSERT(!other.m_data);
      ASSERT(m_shared);
      other.m_data = m_data;
<span class="line-added">+     other.m_destructor = nullptr;</span>
<span class="line-added">+     other.m_shared = m_shared;</span>
      other.m_sizeInBytes = m_sizeInBytes;
      RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
  }
  
  Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(unsigned numElements, unsigned elementByteSize)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 195,11 ***</span>
  // Current this is only used from:
  // - JSGenericTypedArrayView&lt;&gt;::slowDownAndWasteMemory. But in that case, the memory should have already come
  //   from the cage.
  Ref&lt;ArrayBuffer&gt; ArrayBuffer::createAdopted(const void* data, unsigned byteLength)
  {
<span class="line-modified">!     return createFromBytes(data, byteLength, [] (void* p) { Gigacage::free(Gigacage::Primitive, p); });</span>
  }
  
  // FIXME: We cannot use this except if the memory comes from the cage.
  // Currently this is only used from:
  // - The C API. We could support that by either having the system switch to a mode where typed arrays are no
<span class="line-new-header">--- 208,11 ---</span>
  // Current this is only used from:
  // - JSGenericTypedArrayView&lt;&gt;::slowDownAndWasteMemory. But in that case, the memory should have already come
  //   from the cage.
  Ref&lt;ArrayBuffer&gt; ArrayBuffer::createAdopted(const void* data, unsigned byteLength)
  {
<span class="line-modified">!     return createFromBytes(data, byteLength, ArrayBuffer::primitiveGigacageDestructor());</span>
  }
  
  // FIXME: We cannot use this except if the memory comes from the cage.
  // Currently this is only used from:
  // - The C API. We could support that by either having the system switch to a mode where typed arrays are no
</pre>
<hr />
<pre>
<span class="line-old-header">*** 293,25 ***</span>
      if (index &lt; 0)
          index = currentLength + index;
      return clampValue(index, 0, currentLength);
  }
  
<span class="line-modified">! Ref&lt;ArrayBuffer&gt; ArrayBuffer::slice(double begin, double end) const</span>
  {
      return sliceImpl(clampIndex(begin), clampIndex(end));
  }
  
<span class="line-modified">! Ref&lt;ArrayBuffer&gt; ArrayBuffer::slice(double begin) const</span>
  {
      return sliceImpl(clampIndex(begin), byteLength());
  }
  
<span class="line-modified">! Ref&lt;ArrayBuffer&gt; ArrayBuffer::sliceImpl(unsigned begin, unsigned end) const</span>
  {
      unsigned size = begin &lt;= end ? end - begin : 0;
<span class="line-modified">!     auto result = ArrayBuffer::create(static_cast&lt;const char*&gt;(data()) + begin, size);</span>
<span class="line-modified">!     result-&gt;setSharingMode(sharingMode());</span>
      return result;
  }
  
  void ArrayBuffer::makeShared()
  {
<span class="line-new-header">--- 306,26 ---</span>
      if (index &lt; 0)
          index = currentLength + index;
      return clampValue(index, 0, currentLength);
  }
  
<span class="line-modified">! RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::slice(double begin, double end) const</span>
  {
      return sliceImpl(clampIndex(begin), clampIndex(end));
  }
  
<span class="line-modified">! RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::slice(double begin) const</span>
  {
      return sliceImpl(clampIndex(begin), byteLength());
  }
  
<span class="line-modified">! RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::sliceImpl(unsigned begin, unsigned end) const</span>
  {
      unsigned size = begin &lt;= end ? end - begin : 0;
<span class="line-modified">!     auto result = ArrayBuffer::tryCreate(static_cast&lt;const char*&gt;(data()) + begin, size);</span>
<span class="line-modified">!     if (result)</span>
<span class="line-added">+         result-&gt;setSharingMode(sharingMode());</span>
      return result;
  }
  
  void ArrayBuffer::makeShared()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 367,32 ***</span>
              return false;
          return true;
      }
  
      m_contents.transferTo(result);
<span class="line-modified">!     notifyIncommingReferencesOfTransfer(vm);</span>
      return true;
  }
  
  // We allow neutering wasm memory ArrayBuffers even though they are locked.
  void ArrayBuffer::neuter(VM&amp; vm)
  {
      ASSERT(isWasmMemory());
      ArrayBufferContents unused;
      m_contents.transferTo(unused);
<span class="line-modified">!     notifyIncommingReferencesOfTransfer(vm);</span>
  }
  
<span class="line-modified">! void ArrayBuffer::notifyIncommingReferencesOfTransfer(VM&amp; vm)</span>
  {
      for (size_t i = numberOfIncomingReferences(); i--;) {
          JSCell* cell = incomingReferenceAt(i);
          if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, cell))
              view-&gt;neuter();
<span class="line-removed">-         else if (ArrayBufferNeuteringWatchpointSet* watchpoint = jsDynamicCast&lt;ArrayBufferNeuteringWatchpointSet*&gt;(vm, cell))</span>
<span class="line-removed">-             watchpoint-&gt;fireAll();</span>
      }
  }
  
  ASCIILiteral errorMesasgeForTransfer(ArrayBuffer* buffer)
  {
      ASSERT(buffer-&gt;isLocked());
<span class="line-new-header">--- 381,31 ---</span>
              return false;
          return true;
      }
  
      m_contents.transferTo(result);
<span class="line-modified">!     notifyNeutering(vm);</span>
      return true;
  }
  
  // We allow neutering wasm memory ArrayBuffers even though they are locked.
  void ArrayBuffer::neuter(VM&amp; vm)
  {
      ASSERT(isWasmMemory());
      ArrayBufferContents unused;
      m_contents.transferTo(unused);
<span class="line-modified">!     notifyNeutering(vm);</span>
  }
  
<span class="line-modified">! void ArrayBuffer::notifyNeutering(VM&amp; vm)</span>
  {
      for (size_t i = numberOfIncomingReferences(); i--;) {
          JSCell* cell = incomingReferenceAt(i);
          if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, cell))
              view-&gt;neuter();
      }
<span class="line-added">+     m_neuteringWatchpointSet.fireAll(vm, &quot;Array buffer was neutered&quot;);</span>
  }
  
  ASCIILiteral errorMesasgeForTransfer(ArrayBuffer* buffer)
  {
      ASSERT(buffer-&gt;isLocked());
</pre>
<center><a href="ArgList.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayBuffer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ProxyObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ProxyConstructor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProxyObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ProxyObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  34 #include &quot;ObjectConstructor.h&quot;
  35 #include &quot;SlotVisitorInlines.h&quot;
  36 #include &quot;StructureInlines.h&quot;
  37 #include &quot;VMInlines.h&quot;
  38 #include &lt;wtf/NoTailCalls.h&gt;
  39 
  40 // Note that we use NO_TAIL_CALLS() throughout this file because we rely on the machine stack
  41 // growing larger for throwing OOM errors for when we have an effectively cyclic prototype chain.
  42 
  43 namespace JSC {
  44 
  45 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(ProxyObject);
  46 
  47 const ClassInfo ProxyObject::s_info = { &quot;ProxyObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ProxyObject) };
  48 
  49 ProxyObject::ProxyObject(VM&amp; vm, Structure* structure)
  50     : Base(vm, structure)
  51 {
  52 }
  53 
<span class="line-modified">  54 String ProxyObject::toStringName(const JSObject* object, ExecState* exec)</span>
  55 {
<span class="line-modified">  56     VM&amp; vm = exec-&gt;vm();</span>
  57     auto scope = DECLARE_THROW_SCOPE(vm);
  58     const ProxyObject* proxy = jsCast&lt;const ProxyObject*&gt;(object);
  59     while (proxy) {
  60         const JSObject* target = proxy-&gt;target();
<span class="line-modified">  61         bool targetIsArray = isArray(exec, target);</span>
  62         if (UNLIKELY(scope.exception()))
  63             break;
  64         if (targetIsArray)
<span class="line-modified">  65             RELEASE_AND_RETURN(scope, target-&gt;classInfo(vm)-&gt;methodTable.toStringName(target, exec));</span>
  66 
  67         proxy = jsDynamicCast&lt;const ProxyObject*&gt;(vm, target);
  68     }
  69     return &quot;Object&quot;_s;
  70 }
  71 
  72 Structure* ProxyObject::structureForTarget(JSGlobalObject* globalObject, JSValue target)
  73 {
  74     if (!target.isObject())
  75         return globalObject-&gt;proxyObjectStructure();
  76 
  77     JSObject* targetAsObject = jsCast&lt;JSObject*&gt;(target);
  78     CallData ignoredCallData;
  79     VM&amp; vm = globalObject-&gt;vm();
  80     bool isCallable = targetAsObject-&gt;methodTable(vm)-&gt;getCallData(targetAsObject, ignoredCallData) != CallType::None;
  81     return isCallable ? globalObject-&gt;callableProxyObjectStructure() : globalObject-&gt;proxyObjectStructure();
  82 }
  83 
<span class="line-modified">  84 void ProxyObject::finishCreation(VM&amp; vm, ExecState* exec, JSValue target, JSValue handler)</span>
  85 {
  86     auto scope = DECLARE_THROW_SCOPE(vm);
  87     Base::finishCreation(vm);
  88     ASSERT(type() == ProxyObjectType);
  89     if (!target.isObject()) {
<span class="line-modified">  90         throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;target&#39; should be an Object&quot;_s);</span>
  91         return;
  92     }
  93     if (ProxyObject* targetAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, target)) {
  94         if (targetAsProxy-&gt;isRevoked()) {
<span class="line-modified">  95             throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;target&#39; shouldn&#39;t be a revoked Proxy&quot;_s);</span>
  96             return;
  97         }
  98     }
  99     if (!handler.isObject()) {
<span class="line-modified"> 100         throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;handler&#39; should be an Object&quot;_s);</span>
 101         return;
 102     }
 103     if (ProxyObject* handlerAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, handler)) {
 104         if (handlerAsProxy-&gt;isRevoked()) {
<span class="line-modified"> 105             throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;handler&#39; shouldn&#39;t be a revoked Proxy&quot;_s);</span>
 106             return;
 107         }
 108     }
 109 
 110     JSObject* targetAsObject = jsCast&lt;JSObject*&gt;(target);
 111 
 112     CallData ignoredCallData;
 113     m_isCallable = targetAsObject-&gt;methodTable(vm)-&gt;getCallData(targetAsObject, ignoredCallData) != CallType::None;
 114     if (m_isCallable) {
 115         TypeInfo info = structure(vm)-&gt;typeInfo();
 116         RELEASE_ASSERT(info.implementsHasInstance() &amp;&amp; info.implementsDefaultHasInstance());
 117     }
 118 
 119     m_isConstructible = jsCast&lt;JSObject*&gt;(target)-&gt;isConstructor(vm);
 120 
 121     m_target.set(vm, this, targetAsObject);
 122     m_handler.set(vm, this, handler);
 123 }
 124 
 125 static const ASCIILiteral s_proxyAlreadyRevokedErrorMessage { &quot;Proxy has already been revoked. No more operations are allowed to be performed on it&quot;_s };
 126 
<span class="line-modified"> 127 static JSValue performProxyGet(ExecState* exec, ProxyObject* proxyObject, JSValue receiver, PropertyName propertyName)</span>
 128 {
 129     NO_TAIL_CALLS();
 130 
<span class="line-modified"> 131     VM&amp; vm = exec-&gt;vm();</span>
 132     auto scope = DECLARE_THROW_SCOPE(vm);
 133     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 134         throwStackOverflowError(exec, scope);</span>
 135         return { };
 136     }
 137 
 138     JSObject* target = proxyObject-&gt;target();
 139 
 140     auto performDefaultGet = [&amp;] {
 141         scope.release();
 142         PropertySlot slot(receiver, PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 143         bool hasProperty = target-&gt;getPropertySlot(exec, propertyName, slot);</span>
 144         EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
 145         if (hasProperty)
<span class="line-modified"> 146             RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));</span>
 147 
 148         return jsUndefined();
 149     };
 150 
 151     if (propertyName.isPrivateName())
 152         return jsUndefined();
 153 
 154     JSValue handlerValue = proxyObject-&gt;handler();
 155     if (handlerValue.isNull())
<span class="line-modified"> 156         return throwTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 157 
 158     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 159     CallData callData;
 160     CallType callType;
<span class="line-modified"> 161     JSValue getHandler = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;get, &quot;&#39;get&#39; property of a Proxy&#39;s handler object should be callable&quot;_s);</span>
 162     RETURN_IF_EXCEPTION(scope, { });
 163 
 164     if (getHandler.isUndefined())
 165         return performDefaultGet();
 166 
 167     MarkedArgumentBuffer arguments;
 168     arguments.append(target);
 169     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
 170     arguments.append(receiver);
 171     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 172     JSValue trapResult = call(exec, getHandler, callType, callData, handler, arguments);</span>
 173     RETURN_IF_EXCEPTION(scope, { });
 174 
 175     PropertyDescriptor descriptor;
<span class="line-modified"> 176     bool result = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);</span>
 177     EXCEPTION_ASSERT(!scope.exception() || !result);
 178     if (result) {
 179         if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
<span class="line-modified"> 180             if (!sameValue(exec, descriptor.value(), trapResult))</span>
<span class="line-modified"> 181                 return throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable and non-writable property should be the same value as the target&#39;s property&quot;_s);</span>


 182         } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.getter().isUndefined()) {
 183             if (!trapResult.isUndefined())
<span class="line-modified"> 184                 return throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable accessor property without a getter should be undefined&quot;_s);</span>
 185         }
 186     }
 187 
 188     RETURN_IF_EXCEPTION(scope, { });
 189 
 190     return trapResult;
 191 }
 192 
<span class="line-modified"> 193 bool ProxyObject::performGet(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
 194 {
 195     NO_TAIL_CALLS();
 196 
<span class="line-modified"> 197     VM&amp; vm = exec-&gt;vm();</span>
 198     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 199     JSValue result = performProxyGet(exec, this, slot.thisValue(), propertyName);</span>
 200     RETURN_IF_EXCEPTION(scope, false);
 201     unsigned ignoredAttributes = 0;
 202     slot.setValue(this, ignoredAttributes, result);
 203     return true;
 204 }
 205 
<span class="line-modified"> 206 bool ProxyObject::performInternalMethodGetOwnProperty(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
 207 {
 208     NO_TAIL_CALLS();
 209 
<span class="line-modified"> 210     VM&amp; vm = exec-&gt;vm();</span>
 211     auto scope = DECLARE_THROW_SCOPE(vm);
 212     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 213         throwStackOverflowError(exec, scope);</span>
 214         return false;
 215     }
 216     JSObject* target = this-&gt;target();
 217 
 218     auto performDefaultGetOwnProperty = [&amp;] {
<span class="line-modified"> 219         return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);</span>
 220     };
 221 
 222     if (propertyName.isPrivateName())
 223         return false;
 224 
 225     JSValue handlerValue = this-&gt;handler();
 226     if (handlerValue.isNull()) {
<span class="line-modified"> 227         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 228         return false;
 229     }
 230 
 231     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 232     CallData callData;
 233     CallType callType;
<span class="line-modified"> 234     JSValue getOwnPropertyDescriptorMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;getOwnPropertyDescriptor&quot;), &quot;&#39;getOwnPropertyDescriptor&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 235     RETURN_IF_EXCEPTION(scope, false);
 236     if (getOwnPropertyDescriptorMethod.isUndefined())
 237         RELEASE_AND_RETURN(scope, performDefaultGetOwnProperty());
 238 
 239     MarkedArgumentBuffer arguments;
 240     arguments.append(target);
 241     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
 242     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 243     JSValue trapResult = call(exec, getOwnPropertyDescriptorMethod, callType, callData, handler, arguments);</span>
 244     RETURN_IF_EXCEPTION(scope, false);
 245 
 246     if (!trapResult.isUndefined() &amp;&amp; !trapResult.isObject()) {
<span class="line-modified"> 247         throwVMTypeError(exec, scope, &quot;result of &#39;getOwnPropertyDescriptor&#39; call should either be an Object or undefined&quot;_s);</span>
 248         return false;
 249     }
 250 
 251     PropertyDescriptor targetPropertyDescriptor;
<span class="line-modified"> 252     bool isTargetPropertyDescriptorDefined = target-&gt;getOwnPropertyDescriptor(exec, propertyName, targetPropertyDescriptor);</span>
 253     RETURN_IF_EXCEPTION(scope, false);
 254 
 255     if (trapResult.isUndefined()) {
 256         if (!isTargetPropertyDescriptorDefined)
 257             return false;
 258         if (!targetPropertyDescriptor.configurable()) {
<span class="line-modified"> 259             throwVMTypeError(exec, scope, &quot;When the result of &#39;getOwnPropertyDescriptor&#39; is undefined the target must be configurable&quot;_s);</span>
 260             return false;
 261         }
<span class="line-modified"> 262         // FIXME: this doesn&#39;t work if &#39;target&#39; is another Proxy. We don&#39;t have isExtensible implemented in a way that fits w/ Proxys.</span>
<span class="line-removed"> 263         // https://bugs.webkit.org/show_bug.cgi?id=154375</span>
<span class="line-removed"> 264         bool isExtensible = target-&gt;isExtensible(exec);</span>
 265         RETURN_IF_EXCEPTION(scope, false);
 266         if (!isExtensible) {
<span class="line-modified"> 267             // FIXME: Come up with a test for this error. I&#39;m not sure how to because</span>
<span class="line-removed"> 268             // Object.seal(o) will make all fields [[Configurable]] false.</span>
<span class="line-removed"> 269             // https://bugs.webkit.org/show_bug.cgi?id=154376</span>
<span class="line-removed"> 270             throwVMTypeError(exec, scope, &quot;When &#39;getOwnPropertyDescriptor&#39; returns undefined, the &#39;target&#39; of a Proxy should be extensible&quot;_s);</span>
 271             return false;
 272         }
 273 
 274         return false;
 275     }
 276 
<span class="line-modified"> 277     bool isExtensible = target-&gt;isExtensible(exec);</span>
 278     RETURN_IF_EXCEPTION(scope, false);
 279     PropertyDescriptor trapResultAsDescriptor;
<span class="line-modified"> 280     toPropertyDescriptor(exec, trapResult, trapResultAsDescriptor);</span>
 281     RETURN_IF_EXCEPTION(scope, false);
 282     bool throwException = false;
<span class="line-modified"> 283     bool valid = validateAndApplyPropertyDescriptor(exec, nullptr, propertyName, isExtensible,</span>
 284         trapResultAsDescriptor, isTargetPropertyDescriptorDefined, targetPropertyDescriptor, throwException);
 285     RETURN_IF_EXCEPTION(scope, false);
 286     if (!valid) {
<span class="line-modified"> 287         throwVMTypeError(exec, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; fails the IsCompatiblePropertyDescriptor test&quot;_s);</span>
 288         return false;
 289     }
 290 
 291     if (!trapResultAsDescriptor.configurable()) {
 292         if (!isTargetPropertyDescriptorDefined || targetPropertyDescriptor.configurable()) {
<span class="line-modified"> 293             throwVMTypeError(exec, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; can&#39;t be non-configurable when the &#39;target&#39; doesn&#39;t have it as an own property or if it is a configurable own property on &#39;target&#39;&quot;_s);</span>
 294             return false;
 295         }
 296         if (trapResultAsDescriptor.writablePresent() &amp;&amp; !trapResultAsDescriptor.writable() &amp;&amp; targetPropertyDescriptor.writable()) {
<span class="line-modified"> 297             throwVMTypeError(exec, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; can&#39;t be non-configurable and non-writable when the target&#39;s property is writable&quot;_s);</span>
 298             return false;
 299         }
 300     }
 301 
 302     if (trapResultAsDescriptor.isAccessorDescriptor()) {
<span class="line-modified"> 303         GetterSetter* getterSetter = trapResultAsDescriptor.slowGetterSetter(exec);</span>
 304         RETURN_IF_EXCEPTION(scope, false);
 305         slot.setGetterSlot(this, trapResultAsDescriptor.attributes(), getterSetter);
 306     } else if (trapResultAsDescriptor.isDataDescriptor() &amp;&amp; !trapResultAsDescriptor.value().isEmpty())
 307         slot.setValue(this, trapResultAsDescriptor.attributes(), trapResultAsDescriptor.value());
 308     else
 309         slot.setValue(this, trapResultAsDescriptor.attributes(), jsUndefined()); // We use undefined because it&#39;s the default value in object properties.
 310 
 311     return true;
 312 }
 313 
<span class="line-modified"> 314 bool ProxyObject::performHasProperty(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
 315 {
 316     NO_TAIL_CALLS();
 317 
<span class="line-modified"> 318     VM&amp; vm = exec-&gt;vm();</span>
 319     auto scope = DECLARE_THROW_SCOPE(vm);
 320     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 321         throwStackOverflowError(exec, scope);</span>
 322         return false;
 323     }
 324     JSObject* target = this-&gt;target();
 325     slot.setValue(this, static_cast&lt;unsigned&gt;(PropertyAttribute::None), jsUndefined()); // Nobody should rely on our value, but be safe and protect against any bad actors reading our value.
 326 
 327     auto performDefaultHasProperty = [&amp;] {
<span class="line-modified"> 328         return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);</span>
 329     };
 330 
 331     if (propertyName.isPrivateName())
 332         return false;
 333 
 334     JSValue handlerValue = this-&gt;handler();
 335     if (handlerValue.isNull()) {
<span class="line-modified"> 336         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 337         return false;
 338     }
 339 
 340     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 341     CallData callData;
 342     CallType callType;
<span class="line-modified"> 343     JSValue hasMethod = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;has, &quot;&#39;has&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 344     RETURN_IF_EXCEPTION(scope, false);
 345     if (hasMethod.isUndefined())
 346         RELEASE_AND_RETURN(scope, performDefaultHasProperty());
 347 
 348     MarkedArgumentBuffer arguments;
 349     arguments.append(target);
 350     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
 351     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 352     JSValue trapResult = call(exec, hasMethod, callType, callData, handler, arguments);</span>
 353     RETURN_IF_EXCEPTION(scope, false);
 354 
<span class="line-modified"> 355     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
 356     RETURN_IF_EXCEPTION(scope, false);
 357 
 358     if (!trapResultAsBool) {
 359         PropertyDescriptor descriptor;
<span class="line-modified"> 360         bool isPropertyDescriptorDefined = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);</span>
 361         RETURN_IF_EXCEPTION(scope, false);
 362         if (isPropertyDescriptorDefined) {
 363             if (!descriptor.configurable()) {
<span class="line-modified"> 364                 throwVMTypeError(exec, scope, &quot;Proxy &#39;has&#39; must return &#39;true&#39; for non-configurable properties&quot;_s);</span>
 365                 return false;
 366             }
<span class="line-modified"> 367             bool isExtensible = target-&gt;isExtensible(exec);</span>
 368             RETURN_IF_EXCEPTION(scope, false);
 369             if (!isExtensible) {
<span class="line-modified"> 370                 throwVMTypeError(exec, scope, &quot;Proxy &#39;has&#39; must return &#39;true&#39; for a non-extensible &#39;target&#39; object with a configurable property&quot;_s);</span>
 371                 return false;
 372             }
 373         }
 374     }
 375 
 376     return trapResultAsBool;
 377 }
 378 
<span class="line-modified"> 379 bool ProxyObject::getOwnPropertySlotCommon(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
 380 {
 381     slot.disableCaching();
 382     slot.setIsTaintedByOpaqueObject();
 383 
 384     if (slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry)
 385         return false;
 386 
<span class="line-modified"> 387     VM&amp; vm = exec-&gt;vm();</span>
 388     auto scope = DECLARE_THROW_SCOPE(vm);
 389     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 390         throwStackOverflowError(exec, scope);</span>
 391         return false;
 392     }
 393     switch (slot.internalMethodType()) {
 394     case PropertySlot::InternalMethodType::Get:
<span class="line-modified"> 395         RELEASE_AND_RETURN(scope, performGet(exec, propertyName, slot));</span>
 396     case PropertySlot::InternalMethodType::GetOwnProperty:
<span class="line-modified"> 397         RELEASE_AND_RETURN(scope, performInternalMethodGetOwnProperty(exec, propertyName, slot));</span>
 398     case PropertySlot::InternalMethodType::HasProperty:
<span class="line-modified"> 399         RELEASE_AND_RETURN(scope, performHasProperty(exec, propertyName, slot));</span>
 400     default:
 401         return false;
 402     }
 403 
 404     RELEASE_ASSERT_NOT_REACHED();
 405     return false;
 406 }
 407 
<span class="line-modified"> 408 bool ProxyObject::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
 409 {
 410     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified"> 411     return thisObject-&gt;getOwnPropertySlotCommon(exec, propertyName, slot);</span>
 412 }
 413 
<span class="line-modified"> 414 bool ProxyObject::getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)</span>
 415 {
<span class="line-modified"> 416     VM&amp; vm = exec-&gt;vm();</span>
 417     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
 418     Identifier ident = Identifier::from(vm, propertyName);
<span class="line-modified"> 419     return thisObject-&gt;getOwnPropertySlotCommon(exec, ident.impl(), slot);</span>
 420 }
 421 
 422 template &lt;typename PerformDefaultPutFunction&gt;
<span class="line-modified"> 423 bool ProxyObject::performPut(ExecState* exec, JSValue putValue, JSValue thisValue, PropertyName propertyName, PerformDefaultPutFunction performDefaultPut, bool shouldThrow)</span>
 424 {
 425     NO_TAIL_CALLS();
 426 
<span class="line-modified"> 427     VM&amp; vm = exec-&gt;vm();</span>
 428     auto scope = DECLARE_THROW_SCOPE(vm);
 429     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 430         throwStackOverflowError(exec, scope);</span>
 431         return false;
 432     }
 433 
 434     if (propertyName.isPrivateName())
 435         return false;
 436 
 437     JSValue handlerValue = this-&gt;handler();
 438     if (handlerValue.isNull()) {
<span class="line-modified"> 439         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 440         return false;
 441     }
 442 
 443     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 444     CallData callData;
 445     CallType callType;
<span class="line-modified"> 446     JSValue setMethod = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;set, &quot;&#39;set&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 447     RETURN_IF_EXCEPTION(scope, false);
 448     JSObject* target = this-&gt;target();
 449     if (setMethod.isUndefined())
 450         RELEASE_AND_RETURN(scope, performDefaultPut());
 451 
 452     MarkedArgumentBuffer arguments;
 453     arguments.append(target);
 454     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
 455     arguments.append(putValue);
 456     arguments.append(thisValue);
 457     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 458     JSValue trapResult = call(exec, setMethod, callType, callData, handler, arguments);</span>
 459     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified"> 460     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
 461     RETURN_IF_EXCEPTION(scope, false);
 462     if (!trapResultAsBool) {
 463         if (shouldThrow)
<span class="line-modified"> 464             throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s &#39;set&#39; trap returned falsy value for property &#39;&quot;, String(propertyName.uid()), &quot;&#39;&quot;));</span>
 465         return false;
 466     }
 467 
 468     PropertyDescriptor descriptor;
<span class="line-modified"> 469     bool hasProperty = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);</span>
 470     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
 471     if (hasProperty) {
 472         if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
<span class="line-modified"> 473             if (!sameValue(exec, descriptor.value(), putValue)) {</span>
<span class="line-modified"> 474                 throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;set&#39; on a non-configurable and non-writable property on &#39;target&#39; should either return false or be the same value already on the &#39;target&#39;&quot;_s);</span>


 475                 return false;
 476             }
 477         } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.setter().isUndefined()) {
<span class="line-modified"> 478             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;set&#39; method on a non-configurable accessor property without a setter should return false&quot;_s);</span>
 479             return false;
 480         }
 481     }
 482     return true;
 483 }
 484 
<span class="line-modified"> 485 bool ProxyObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
 486 {
<span class="line-modified"> 487     VM&amp; vm = exec-&gt;vm();</span>
 488     slot.disableCaching();
 489 
 490     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
 491     auto performDefaultPut = [&amp;] () {
 492         JSObject* target = jsCast&lt;JSObject*&gt;(thisObject-&gt;target());
<span class="line-modified"> 493         return target-&gt;methodTable(vm)-&gt;put(target, exec, propertyName, value, slot);</span>
 494     };
<span class="line-modified"> 495     return thisObject-&gt;performPut(exec, value, slot.thisValue(), propertyName, performDefaultPut, slot.isStrictMode());</span>
 496 }
 497 
<span class="line-modified"> 498 bool ProxyObject::putByIndexCommon(ExecState* exec, JSValue thisValue, unsigned propertyName, JSValue putValue, bool shouldThrow)</span>
 499 {
<span class="line-modified"> 500     VM&amp; vm = exec-&gt;vm();</span>
 501     auto scope = DECLARE_THROW_SCOPE(vm);
 502     Identifier ident = Identifier::from(vm, propertyName);
 503     RETURN_IF_EXCEPTION(scope, false);
 504     auto performDefaultPut = [&amp;] () {
 505         JSObject* target = this-&gt;target();
 506         bool isStrictMode = shouldThrow;
 507         PutPropertySlot slot(thisValue, isStrictMode); // We must preserve the &quot;this&quot; target of the putByIndex.
<span class="line-modified"> 508         return target-&gt;methodTable(vm)-&gt;put(target, exec, ident.impl(), putValue, slot);</span>
 509     };
<span class="line-modified"> 510     RELEASE_AND_RETURN(scope, performPut(exec, putValue, thisValue, ident.impl(), performDefaultPut, shouldThrow));</span>
 511 }
 512 
<span class="line-modified"> 513 bool ProxyObject::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)</span>
 514 {
 515     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
<span class="line-modified"> 516     return thisObject-&gt;putByIndexCommon(exec, thisObject, propertyName, value, shouldThrow);</span>
 517 }
 518 
<span class="line-modified"> 519 static EncodedJSValue JSC_HOST_CALL performProxyCall(ExecState* exec)</span>
 520 {
 521     NO_TAIL_CALLS();
 522 
<span class="line-modified"> 523     VM&amp; vm = exec-&gt;vm();</span>
 524     auto scope = DECLARE_THROW_SCOPE(vm);
 525     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 526         throwStackOverflowError(exec, scope);</span>
 527         return encodedJSValue();
 528     }
<span class="line-modified"> 529     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(exec-&gt;jsCallee());</span>
 530     JSValue handlerValue = proxy-&gt;handler();
 531     if (handlerValue.isNull())
<span class="line-modified"> 532         return throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 533 
 534     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 535     CallData callData;
 536     CallType callType;
<span class="line-modified"> 537     JSValue applyMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;apply&quot;), &quot;&#39;apply&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 538     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 539     JSObject* target = proxy-&gt;target();
 540     if (applyMethod.isUndefined()) {
 541         CallData callData;
 542         CallType callType = target-&gt;methodTable(vm)-&gt;getCallData(target, callData);
 543         RELEASE_ASSERT(callType != CallType::None);
<span class="line-modified"> 544         RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, target, callType, callData, exec-&gt;thisValue(), ArgList(exec))));</span>
 545     }
 546 
<span class="line-modified"> 547     JSArray* argArray = constructArray(exec, static_cast&lt;ArrayAllocationProfile*&gt;(nullptr), ArgList(exec));</span>
 548     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 549     MarkedArgumentBuffer arguments;
 550     arguments.append(target);
<span class="line-modified"> 551     arguments.append(exec-&gt;thisValue().toThis(exec, ECMAMode::StrictMode));</span>
 552     arguments.append(argArray);
 553     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 554     RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, applyMethod, callType, callData, handler, arguments)));</span>
 555 }
 556 
 557 CallType ProxyObject::getCallData(JSCell* cell, CallData&amp; callData)
 558 {
 559     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(cell);
 560     if (!proxy-&gt;m_isCallable) {
 561         callData.js.functionExecutable = nullptr;
 562         callData.js.scope = nullptr;
 563         return CallType::None;
 564     }
 565 
 566     callData.native.function = performProxyCall;
 567     return CallType::Host;
 568 }
 569 
<span class="line-modified"> 570 static EncodedJSValue JSC_HOST_CALL performProxyConstruct(ExecState* exec)</span>
 571 {
 572     NO_TAIL_CALLS();
 573 
<span class="line-modified"> 574     VM&amp; vm = exec-&gt;vm();</span>
 575     auto scope = DECLARE_THROW_SCOPE(vm);
 576     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 577         throwStackOverflowError(exec, scope);</span>
 578         return encodedJSValue();
 579     }
<span class="line-modified"> 580     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(exec-&gt;jsCallee());</span>
 581     JSValue handlerValue = proxy-&gt;handler();
 582     if (handlerValue.isNull())
<span class="line-modified"> 583         return throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 584 
 585     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 586     CallData callData;
 587     CallType callType;
<span class="line-modified"> 588     JSValue constructMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;construct&quot;), &quot;&#39;construct&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 589     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 590     JSObject* target = proxy-&gt;target();
 591     if (constructMethod.isUndefined()) {
 592         ConstructData constructData;
 593         ConstructType constructType = target-&gt;methodTable(vm)-&gt;getConstructData(target, constructData);
 594         RELEASE_ASSERT(constructType != ConstructType::None);
<span class="line-modified"> 595         RELEASE_AND_RETURN(scope, JSValue::encode(construct(exec, target, constructType, constructData, ArgList(exec), exec-&gt;newTarget())));</span>
 596     }
 597 
<span class="line-modified"> 598     JSArray* argArray = constructArray(exec, static_cast&lt;ArrayAllocationProfile*&gt;(nullptr), ArgList(exec));</span>
 599     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 600     MarkedArgumentBuffer arguments;
 601     arguments.append(target);
 602     arguments.append(argArray);
<span class="line-modified"> 603     arguments.append(exec-&gt;newTarget());</span>
 604     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 605     JSValue result = call(exec, constructMethod, callType, callData, handler, arguments);</span>
 606     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 607     if (!result.isObject())
<span class="line-modified"> 608         return throwVMTypeError(exec, scope, &quot;Result from Proxy handler&#39;s &#39;construct&#39; method should be an object&quot;_s);</span>
 609     return JSValue::encode(result);
 610 }
 611 
 612 ConstructType ProxyObject::getConstructData(JSCell* cell, ConstructData&amp; constructData)
 613 {
 614     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(cell);
 615     if (!proxy-&gt;m_isConstructible) {
 616         constructData.js.functionExecutable = nullptr;
 617         constructData.js.scope = nullptr;
 618         return ConstructType::None;
 619     }
 620 
 621     constructData.native.function = performProxyConstruct;
 622     return ConstructType::Host;
 623 }
 624 
 625 template &lt;typename DefaultDeleteFunction&gt;
<span class="line-modified"> 626 bool ProxyObject::performDelete(ExecState* exec, PropertyName propertyName, DefaultDeleteFunction performDefaultDelete)</span>
 627 {
 628     NO_TAIL_CALLS();
 629 
<span class="line-modified"> 630     VM&amp; vm = exec-&gt;vm();</span>
 631     auto scope = DECLARE_THROW_SCOPE(vm);
 632     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 633         throwStackOverflowError(exec, scope);</span>
 634         return false;
 635     }
 636 
 637     if (propertyName.isPrivateName())
 638         return false;
 639 
 640     JSValue handlerValue = this-&gt;handler();
 641     if (handlerValue.isNull()) {
<span class="line-modified"> 642         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 643         return false;
 644     }
 645 
 646     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 647     CallData callData;
 648     CallType callType;
<span class="line-modified"> 649     JSValue deletePropertyMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;deleteProperty&quot;), &quot;&#39;deleteProperty&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 650     RETURN_IF_EXCEPTION(scope, false);
 651     JSObject* target = this-&gt;target();
 652     if (deletePropertyMethod.isUndefined())
 653         RELEASE_AND_RETURN(scope, performDefaultDelete());
 654 
 655     MarkedArgumentBuffer arguments;
 656     arguments.append(target);
 657     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
 658     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 659     JSValue trapResult = call(exec, deletePropertyMethod, callType, callData, handler, arguments);</span>
 660     RETURN_IF_EXCEPTION(scope, false);
 661 
<span class="line-modified"> 662     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
 663     RETURN_IF_EXCEPTION(scope, false);
 664 
 665     if (!trapResultAsBool)
 666         return false;
 667 
 668     PropertyDescriptor descriptor;
<span class="line-modified"> 669     bool result = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);</span>
 670     EXCEPTION_ASSERT(!scope.exception() || !result);
 671     if (result) {
 672         if (!descriptor.configurable()) {
<span class="line-modified"> 673             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target&#39;s property is not configurable&quot;_s);</span>
 674             return false;
 675         }
<span class="line-modified"> 676         bool targetIsExtensible = target-&gt;isExtensible(exec);</span>
 677         RETURN_IF_EXCEPTION(scope, false);
 678         if (!targetIsExtensible) {
<span class="line-modified"> 679             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target has property and is not extensible&quot;_s);</span>
 680             return false;
 681         }
 682     }
 683 
 684     RETURN_IF_EXCEPTION(scope, false);
 685 
 686     return true;
 687 }
 688 
<span class="line-modified"> 689 bool ProxyObject::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
 690 {
 691     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
 692     auto performDefaultDelete = [&amp;] () -&gt; bool {
 693         JSObject* target = thisObject-&gt;target();
<span class="line-modified"> 694         return target-&gt;methodTable(exec-&gt;vm())-&gt;deleteProperty(target, exec, propertyName);</span>
 695     };
<span class="line-modified"> 696     return thisObject-&gt;performDelete(exec, propertyName, performDefaultDelete);</span>
 697 }
 698 
<span class="line-modified"> 699 bool ProxyObject::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned propertyName)</span>
 700 {
<span class="line-modified"> 701     VM&amp; vm = exec-&gt;vm();</span>
 702     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
 703     Identifier ident = Identifier::from(vm, propertyName);
 704     auto performDefaultDelete = [&amp;] () -&gt; bool {
 705         JSObject* target = thisObject-&gt;target();
<span class="line-modified"> 706         return target-&gt;methodTable(vm)-&gt;deletePropertyByIndex(target, exec, propertyName);</span>
 707     };
<span class="line-modified"> 708     return thisObject-&gt;performDelete(exec, ident.impl(), performDefaultDelete);</span>
 709 }
 710 
<span class="line-modified"> 711 bool ProxyObject::performPreventExtensions(ExecState* exec)</span>
 712 {
 713     NO_TAIL_CALLS();
 714 
<span class="line-modified"> 715     VM&amp; vm = exec-&gt;vm();</span>
 716     auto scope = DECLARE_THROW_SCOPE(vm);
 717     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 718         throwStackOverflowError(exec, scope);</span>
 719         return false;
 720     }
 721 
 722     JSValue handlerValue = this-&gt;handler();
 723     if (handlerValue.isNull()) {
<span class="line-modified"> 724         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 725         return false;
 726     }
 727 
 728     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 729     CallData callData;
 730     CallType callType;
<span class="line-modified"> 731     JSValue preventExtensionsMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;preventExtensions&quot;), &quot;&#39;preventExtensions&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 732     RETURN_IF_EXCEPTION(scope, false);
 733     JSObject* target = this-&gt;target();
 734     if (preventExtensionsMethod.isUndefined())
<span class="line-modified"> 735         RELEASE_AND_RETURN(scope, target-&gt;methodTable(vm)-&gt;preventExtensions(target, exec));</span>
 736 
 737     MarkedArgumentBuffer arguments;
 738     arguments.append(target);
 739     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 740     JSValue trapResult = call(exec, preventExtensionsMethod, callType, callData, handler, arguments);</span>
 741     RETURN_IF_EXCEPTION(scope, false);
 742 
<span class="line-modified"> 743     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
 744     RETURN_IF_EXCEPTION(scope, false);
 745 
 746     if (trapResultAsBool) {
<span class="line-modified"> 747         bool targetIsExtensible = target-&gt;isExtensible(exec);</span>
 748         RETURN_IF_EXCEPTION(scope, false);
 749         if (targetIsExtensible) {
<span class="line-modified"> 750             throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;preventExtensions&#39; trap returned true even though its target is extensible. It should have returned false&quot;_s);</span>
 751             return false;
 752         }
 753     }
 754 
 755     return trapResultAsBool;
 756 }
 757 
<span class="line-modified"> 758 bool ProxyObject::preventExtensions(JSObject* object, ExecState* exec)</span>
 759 {
<span class="line-modified"> 760     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performPreventExtensions(exec);</span>
 761 }
 762 
<span class="line-modified"> 763 bool ProxyObject::performIsExtensible(ExecState* exec)</span>
 764 {
 765     NO_TAIL_CALLS();
 766 
<span class="line-modified"> 767     VM&amp; vm = exec-&gt;vm();</span>
 768     auto scope = DECLARE_THROW_SCOPE(vm);
 769     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 770         throwStackOverflowError(exec, scope);</span>
 771         return false;
 772     }
 773 
 774     JSValue handlerValue = this-&gt;handler();
 775     if (handlerValue.isNull()) {
<span class="line-modified"> 776         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 777         return false;
 778     }
 779 
 780     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 781     CallData callData;
 782     CallType callType;
<span class="line-modified"> 783     JSValue isExtensibleMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;isExtensible&quot;), &quot;&#39;isExtensible&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 784     RETURN_IF_EXCEPTION(scope, false);
 785 
 786     JSObject* target = this-&gt;target();
 787     if (isExtensibleMethod.isUndefined())
<span class="line-modified"> 788         RELEASE_AND_RETURN(scope, target-&gt;isExtensible(exec));</span>
 789 
 790     MarkedArgumentBuffer arguments;
 791     arguments.append(target);
 792     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 793     JSValue trapResult = call(exec, isExtensibleMethod, callType, callData, handler, arguments);</span>
 794     RETURN_IF_EXCEPTION(scope, false);
 795 
<span class="line-modified"> 796     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
 797     RETURN_IF_EXCEPTION(scope, false);
 798 
<span class="line-modified"> 799     bool isTargetExtensible = target-&gt;isExtensible(exec);</span>
 800     RETURN_IF_EXCEPTION(scope, false);
 801 
 802     if (trapResultAsBool != isTargetExtensible) {
 803         if (isTargetExtensible) {
 804             ASSERT(!trapResultAsBool);
<span class="line-modified"> 805             throwVMTypeError(exec, scope, &quot;Proxy object&#39;s &#39;isExtensible&#39; trap returned false when the target is extensible. It should have returned true&quot;_s);</span>
 806         } else {
 807             ASSERT(!isTargetExtensible);
 808             ASSERT(trapResultAsBool);
<span class="line-modified"> 809             throwVMTypeError(exec, scope, &quot;Proxy object&#39;s &#39;isExtensible&#39; trap returned true when the target is non-extensible. It should have returned false&quot;_s);</span>
 810         }
 811     }
 812 
 813     return trapResultAsBool;
 814 }
 815 
<span class="line-modified"> 816 bool ProxyObject::isExtensible(JSObject* object, ExecState* exec)</span>
 817 {
<span class="line-modified"> 818     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performIsExtensible(exec);</span>
 819 }
 820 
<span class="line-modified"> 821 bool ProxyObject::performDefineOwnProperty(ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
 822 {
 823     NO_TAIL_CALLS();
 824 
<span class="line-modified"> 825     VM&amp; vm = exec-&gt;vm();</span>
 826     auto scope = DECLARE_THROW_SCOPE(vm);
 827     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 828         throwStackOverflowError(exec, scope);</span>
 829         return false;
 830     }
 831 
 832     JSObject* target = this-&gt;target();
 833     auto performDefaultDefineOwnProperty = [&amp;] {
<span class="line-modified"> 834         RELEASE_AND_RETURN(scope, target-&gt;methodTable(vm)-&gt;defineOwnProperty(target, exec, propertyName, descriptor, shouldThrow));</span>
 835     };
 836 
 837     if (propertyName.isPrivateName())
 838         return false;
 839 
 840     JSValue handlerValue = this-&gt;handler();
 841     if (handlerValue.isNull()) {
<span class="line-modified"> 842         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 843         return false;
 844     }
 845 
 846     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 847     CallData callData;
 848     CallType callType;
<span class="line-modified"> 849     JSValue definePropertyMethod = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;defineProperty, &quot;&#39;defineProperty&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 850     RETURN_IF_EXCEPTION(scope, false);
 851 
 852     if (definePropertyMethod.isUndefined())
 853         return performDefaultDefineOwnProperty();
 854 
<span class="line-modified"> 855     JSObject* descriptorObject = constructObjectFromPropertyDescriptor(exec, descriptor);</span>
 856     RETURN_IF_EXCEPTION(scope, false);
 857 
 858     MarkedArgumentBuffer arguments;
 859     arguments.append(target);
 860     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
 861     arguments.append(descriptorObject);
 862     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 863     JSValue trapResult = call(exec, definePropertyMethod, callType, callData, handler, arguments);</span>
 864     RETURN_IF_EXCEPTION(scope, false);
 865 
<span class="line-modified"> 866     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
 867     RETURN_IF_EXCEPTION(scope, false);
 868 
 869     if (!trapResultAsBool)
 870         return false;
 871 
 872     PropertyDescriptor targetDescriptor;
<span class="line-modified"> 873     bool isTargetDescriptorDefined = target-&gt;getOwnPropertyDescriptor(exec, propertyName, targetDescriptor);</span>
 874     RETURN_IF_EXCEPTION(scope, false);
 875 
<span class="line-modified"> 876     bool targetIsExtensible = target-&gt;isExtensible(exec);</span>
 877     RETURN_IF_EXCEPTION(scope, false);
 878     bool settingConfigurableToFalse = descriptor.configurablePresent() &amp;&amp; !descriptor.configurable();
 879 
 880     if (!isTargetDescriptorDefined) {
 881         if (!targetIsExtensible) {
<span class="line-modified"> 882             throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true even though getOwnPropertyDescriptor of the Proxy&#39;s target returned undefined and the target is non-extensible&quot;_s);</span>
 883             return false;
 884         }
 885         if (settingConfigurableToFalse) {
<span class="line-modified"> 886             throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true for a non-configurable field even though getOwnPropertyDescriptor of the Proxy&#39;s target returned undefined&quot;_s);</span>
 887             return false;
 888         }
 889 
 890         return true;
 891     }
 892 
 893     ASSERT(isTargetDescriptorDefined);
 894     bool isCurrentDefined = isTargetDescriptorDefined;
 895     const PropertyDescriptor&amp; current = targetDescriptor;
 896     bool throwException = false;
<span class="line-modified"> 897     bool isCompatibleDescriptor = validateAndApplyPropertyDescriptor(exec, nullptr, propertyName, targetIsExtensible, descriptor, isCurrentDefined, current, throwException);</span>
 898     RETURN_IF_EXCEPTION(scope, false);
 899     if (!isCompatibleDescriptor) {
<span class="line-modified"> 900         throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a property on its target that is compatible with the trap&#39;s input descriptor&quot;_s);</span>
 901         return false;
 902     }
 903     if (settingConfigurableToFalse &amp;&amp; targetDescriptor.configurable()) {
<span class="line-modified"> 904         throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a non-configurable property on its target even though the input descriptor to the trap said it must do so&quot;_s);</span>
 905         return false;
 906     }
 907     if (targetDescriptor.isDataDescriptor() &amp;&amp; !targetDescriptor.configurable() &amp;&amp; targetDescriptor.writable()) {
 908         if (descriptor.writablePresent() &amp;&amp; !descriptor.writable()) {
<span class="line-modified"> 909             throwTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true for a non-writable input descriptor when the target&#39;s property is non-configurable and writable&quot;_s);</span>
 910             return false;
 911         }
 912     }
 913 
 914     return true;
 915 }
 916 
<span class="line-modified"> 917 bool ProxyObject::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
 918 {
 919     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified"> 920     return thisObject-&gt;performDefineOwnProperty(exec, propertyName, descriptor, shouldThrow);</span>
 921 }
 922 
<span class="line-modified"> 923 void ProxyObject::performGetOwnPropertyNames(ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode enumerationMode)</span>
 924 {
 925     NO_TAIL_CALLS();
 926 
<span class="line-modified"> 927     VM&amp; vm = exec-&gt;vm();</span>
 928     auto scope = DECLARE_THROW_SCOPE(vm);
 929     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 930         throwStackOverflowError(exec, scope);</span>
 931         return;
 932     }
 933     JSValue handlerValue = this-&gt;handler();
 934     if (handlerValue.isNull()) {
<span class="line-modified"> 935         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 936         return;
 937     }
 938 
 939     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 940     CallData callData;
 941     CallType callType;
<span class="line-modified"> 942     JSValue ownKeysMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;ownKeys&quot;), &quot;&#39;ownKeys&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 943     RETURN_IF_EXCEPTION(scope, void());
 944     JSObject* target = this-&gt;target();

 945     if (ownKeysMethod.isUndefined()) {
 946         scope.release();
<span class="line-modified"> 947         target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, propertyNames, enumerationMode);</span>
 948         return;
 949     }
 950 
 951     MarkedArgumentBuffer arguments;
 952     arguments.append(target);
 953     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 954     JSValue arrayLikeObject = call(exec, ownKeysMethod, callType, callData, handler, arguments);</span>
 955     RETURN_IF_EXCEPTION(scope, void());
 956 
<span class="line-removed"> 957     PropertyNameArray trapResult(vm, propertyNames.propertyNameMode(), propertyNames.privateSymbolMode());</span>
 958     HashSet&lt;UniquedStringImpl*&gt; uncheckedResultKeys;
 959     {
<span class="line-removed"> 960         HashSet&lt;RefPtr&lt;UniquedStringImpl&gt;&gt; seenKeys;</span>
<span class="line-removed"> 961 </span>
 962         RuntimeTypeMask resultFilter = 0;
 963         switch (propertyNames.propertyNameMode()) {
 964         case PropertyNameMode::Symbols:
 965             resultFilter = TypeSymbol;
 966             break;
 967         case PropertyNameMode::Strings:
 968             resultFilter = TypeString;
 969             break;
 970         case PropertyNameMode::StringsAndSymbols:
 971             resultFilter = TypeSymbol | TypeString;
 972             break;
 973         }
 974         ASSERT(resultFilter);
 975 
 976         auto addPropName = [&amp;] (JSValue value, RuntimeType type) -&gt; bool {
<span class="line-modified"> 977             static const bool doExitEarly = true;</span>
<span class="line-modified"> 978             static const bool dontExitEarly = false;</span>
 979 
<span class="line-modified"> 980             Identifier ident = value.toPropertyKey(exec);</span>
 981             RETURN_IF_EXCEPTION(scope, doExitEarly);
 982 
<span class="line-modified"> 983             // If trapResult contains any duplicate entries, throw a TypeError exception.</span>
<span class="line-modified"> 984             //</span>
<span class="line-removed"> 985             // Per spec[1], filtering by type should occur _after_ [[OwnPropertyKeys]], so duplicates</span>
<span class="line-removed"> 986             // are tracked in a separate hashtable from uncheckedResultKeys (which only contain the</span>
<span class="line-removed"> 987             // keys filtered by type).</span>
<span class="line-removed"> 988             //</span>
<span class="line-removed"> 989             // [1] Per https://tc39.github.io/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeysmust not contain any duplicate names&quot;_s);</span>
<span class="line-removed"> 990             if (!seenKeys.add(ident.impl()).isNewEntry) {</span>
<span class="line-removed"> 991                 throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; trap result must not contain any duplicate names&quot;_s);</span>
 992                 return doExitEarly;
 993             }
 994 
<span class="line-modified"> 995             if (!(type &amp; resultFilter))</span>
<span class="line-modified"> 996                 return dontExitEarly;</span>
 997 
<span class="line-removed"> 998             uncheckedResultKeys.add(ident.impl());</span>
<span class="line-removed"> 999             trapResult.add(ident.impl());</span>
1000             return dontExitEarly;
1001         };
1002 
1003         RuntimeTypeMask dontThrowAnExceptionTypeFilter = TypeString | TypeSymbol;
<span class="line-modified">1004         createListFromArrayLike(exec, arrayLikeObject, dontThrowAnExceptionTypeFilter, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an object&quot;_s, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an array-like object containing only Strings and Symbols&quot;_s, addPropName);</span>
1005         RETURN_IF_EXCEPTION(scope, void());
1006     }
1007 
<span class="line-modified">1008     bool targetIsExensible = target-&gt;isExtensible(exec);</span>
1009     RETURN_IF_EXCEPTION(scope, void());
1010 
<span class="line-modified">1011     PropertyNameArray targetKeys(vm, propertyNames.propertyNameMode(), propertyNames.privateSymbolMode());</span>
<span class="line-modified">1012     target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, targetKeys, enumerationMode);</span>
1013     RETURN_IF_EXCEPTION(scope, void());
1014     Vector&lt;UniquedStringImpl*&gt; targetConfigurableKeys;
1015     Vector&lt;UniquedStringImpl*&gt; targetNonConfigurableKeys;
1016     for (const Identifier&amp; ident : targetKeys) {
1017         PropertyDescriptor descriptor;
<span class="line-modified">1018         bool isPropertyDefined = target-&gt;getOwnPropertyDescriptor(exec, ident.impl(), descriptor);</span>
1019         RETURN_IF_EXCEPTION(scope, void());
1020         if (isPropertyDefined &amp;&amp; !descriptor.configurable())
1021             targetNonConfigurableKeys.append(ident.impl());
1022         else
1023             targetConfigurableKeys.append(ident.impl());
1024     }
1025 
1026     enum ContainedIn { IsContainedIn, IsNotContainedIn };
1027     auto removeIfContainedInUncheckedResultKeys = [&amp;] (UniquedStringImpl* impl) -&gt; ContainedIn {
1028         auto iter = uncheckedResultKeys.find(impl);
1029         if (iter == uncheckedResultKeys.end())
1030             return IsNotContainedIn;
1031 
1032         uncheckedResultKeys.remove(iter);
1033         return IsContainedIn;
1034     };
1035 
1036     for (UniquedStringImpl* impl : targetNonConfigurableKeys) {
1037         if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {
<span class="line-modified">1038             throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s &#39;target&#39; has the non-configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));</span>
1039             return;
1040         }
1041     }
1042 
1043     if (!targetIsExensible) {
1044         for (UniquedStringImpl* impl : targetConfigurableKeys) {
1045             if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {
<span class="line-modified">1046                 throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s non-extensible &#39;target&#39; has configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));</span>
1047                 return;
1048             }
1049         }
1050 
1051         if (uncheckedResultKeys.size()) {
<span class="line-modified">1052             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method returned a key that was not present in its non-extensible target&quot;_s);</span>
1053             return;
1054         }
1055     }

1056 
<span class="line-modified">1057     if (!enumerationMode.includeDontEnumProperties()) {</span>
<span class="line-modified">1058         // Filtering DontEnum properties is observable in proxies and must occur following the invariant checks above.</span>
<span class="line-modified">1059         for (auto propertyName : trapResult) {</span>
<span class="line-modified">1060             PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);</span>
<span class="line-modified">1061             auto result = getOwnPropertySlotCommon(exec, propertyName, slot);</span>
<span class="line-modified">1062             RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-modified">1063             if (!result)</span>
<span class="line-modified">1064                 continue;</span>
<span class="line-modified">1065             if (slot.attributes() &amp; PropertyAttribute::DontEnum)</span>
<span class="line-modified">1066                 continue;</span>
<span class="line-modified">1067             propertyNames.add(propertyName.impl());</span>
<span class="line-modified">1068         }</span>
<span class="line-modified">1069     } else {</span>
<span class="line-modified">1070         for (auto propertyName : trapResult)</span>
<span class="line-modified">1071             propertyNames.add(propertyName.impl());</span>



1072     }
1073 }
1074 
<span class="line-modified">1075 void ProxyObject::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
1076 {
1077     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified">1078     thisObject-&gt;performGetOwnPropertyNames(exec, propertyNameArray, enumerationMode);</span>



1079 }
1080 
<span class="line-modified">1081 void ProxyObject::getPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
1082 {
1083     NO_TAIL_CALLS();
<span class="line-modified">1084     JSObject::getPropertyNames(object, exec, propertyNameArray, enumerationMode);</span>
1085 }
1086 
<span class="line-modified">1087 void ProxyObject::getOwnNonIndexPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode)</span>
1088 {
1089     RELEASE_ASSERT_NOT_REACHED();
1090 }
1091 
<span class="line-modified">1092 void ProxyObject::getStructurePropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode)</span>
1093 {
1094     // We should always go down the getOwnPropertyNames path.
1095     RELEASE_ASSERT_NOT_REACHED();
1096 }
1097 
<span class="line-modified">1098 void ProxyObject::getGenericPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode)</span>
1099 {
1100     RELEASE_ASSERT_NOT_REACHED();
1101 }
1102 
<span class="line-modified">1103 bool ProxyObject::performSetPrototype(ExecState* exec, JSValue prototype, bool shouldThrowIfCantSet)</span>
1104 {
1105     NO_TAIL_CALLS();
1106 
1107     ASSERT(prototype.isObject() || prototype.isNull());
1108 
<span class="line-modified">1109     VM&amp; vm = exec-&gt;vm();</span>
1110     auto scope = DECLARE_THROW_SCOPE(vm);
1111     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">1112         throwStackOverflowError(exec, scope);</span>
1113         return false;
1114     }
1115 
1116     JSValue handlerValue = this-&gt;handler();
1117     if (handlerValue.isNull()) {
<span class="line-modified">1118         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
1119         return false;
1120     }
1121 
1122     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
1123     CallData callData;
1124     CallType callType;
<span class="line-modified">1125     JSValue setPrototypeOfMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;setPrototypeOf&quot;), &quot;&#39;setPrototypeOf&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
1126     RETURN_IF_EXCEPTION(scope, false);
1127 
1128     JSObject* target = this-&gt;target();
1129     if (setPrototypeOfMethod.isUndefined())
<span class="line-modified">1130         RELEASE_AND_RETURN(scope, target-&gt;setPrototype(vm, exec, prototype, shouldThrowIfCantSet));</span>
1131 
1132     MarkedArgumentBuffer arguments;
1133     arguments.append(target);
1134     arguments.append(prototype);
1135     ASSERT(!arguments.hasOverflowed());
<span class="line-modified">1136     JSValue trapResult = call(exec, setPrototypeOfMethod, callType, callData, handler, arguments);</span>
1137     RETURN_IF_EXCEPTION(scope, false);
1138 
<span class="line-modified">1139     bool trapResultAsBool = trapResult.toBoolean(exec);</span>
1140     RETURN_IF_EXCEPTION(scope, false);
1141 
1142     if (!trapResultAsBool) {
1143         if (shouldThrowIfCantSet)
<span class="line-modified">1144             throwVMTypeError(exec, scope, &quot;Proxy &#39;setPrototypeOf&#39; returned false indicating it could not set the prototype value. The operation was expected to succeed&quot;_s);</span>
1145         return false;
1146     }
1147 
<span class="line-modified">1148     bool targetIsExtensible = target-&gt;isExtensible(exec);</span>
1149     RETURN_IF_EXCEPTION(scope, false);
1150     if (targetIsExtensible)
1151         return true;
1152 
<span class="line-modified">1153     JSValue targetPrototype = target-&gt;getPrototype(vm, exec);</span>


1154     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">1155     if (!sameValue(exec, prototype, targetPrototype)) {</span>
<span class="line-modified">1156         throwVMTypeError(exec, scope, &quot;Proxy &#39;setPrototypeOf&#39; trap returned true when its target is non-extensible and the new prototype value is not the same as the current prototype value. It should have returned false&quot;_s);</span>
1157         return false;
1158     }
1159 
1160     return true;
1161 }
1162 
<span class="line-modified">1163 bool ProxyObject::setPrototype(JSObject* object, ExecState* exec, JSValue prototype, bool shouldThrowIfCantSet)</span>
1164 {
<span class="line-modified">1165     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performSetPrototype(exec, prototype, shouldThrowIfCantSet);</span>
1166 }
1167 
<span class="line-modified">1168 JSValue ProxyObject::performGetPrototype(ExecState* exec)</span>
1169 {
1170     NO_TAIL_CALLS();
1171 
<span class="line-modified">1172     VM&amp; vm = exec-&gt;vm();</span>
1173     auto scope = DECLARE_THROW_SCOPE(vm);
1174     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">1175         throwStackOverflowError(exec, scope);</span>
1176         return { };
1177     }
1178 
1179     JSValue handlerValue = this-&gt;handler();
1180     if (handlerValue.isNull()) {
<span class="line-modified">1181         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);</span>
1182         return { };
1183     }
1184 
1185     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
1186     CallData callData;
1187     CallType callType;
<span class="line-modified">1188     JSValue getPrototypeOfMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;getPrototypeOf&quot;), &quot;&#39;getPrototypeOf&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
1189     RETURN_IF_EXCEPTION(scope, { });
1190 
1191     JSObject* target = this-&gt;target();
1192     if (getPrototypeOfMethod.isUndefined())
<span class="line-modified">1193         RELEASE_AND_RETURN(scope, target-&gt;getPrototype(vm, exec));</span>
1194 
1195     MarkedArgumentBuffer arguments;
1196     arguments.append(target);
1197     ASSERT(!arguments.hasOverflowed());
<span class="line-modified">1198     JSValue trapResult = call(exec, getPrototypeOfMethod, callType, callData, handler, arguments);</span>
1199     RETURN_IF_EXCEPTION(scope, { });
1200 
1201     if (!trapResult.isObject() &amp;&amp; !trapResult.isNull()) {
<span class="line-modified">1202         throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;getPrototypeOf&#39; trap should either return an object or null&quot;_s);</span>
1203         return { };
1204     }
1205 
<span class="line-modified">1206     bool targetIsExtensible = target-&gt;isExtensible(exec);</span>
1207     RETURN_IF_EXCEPTION(scope, { });
1208     if (targetIsExtensible)
1209         return trapResult;
1210 
<span class="line-modified">1211     JSValue targetPrototype = target-&gt;getPrototype(vm, exec);</span>


1212     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">1213     if (!sameValue(exec, targetPrototype, trapResult)) {</span>
<span class="line-modified">1214         throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;getPrototypeOf&#39; trap for a non-extensible target should return the same value as the target&#39;s prototype&quot;_s);</span>
1215         return { };
1216     }
1217 
1218     return trapResult;
1219 }
1220 
<span class="line-modified">1221 JSValue ProxyObject::getPrototype(JSObject* object, ExecState* exec)</span>
1222 {
<span class="line-modified">1223     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performGetPrototype(exec);</span>
1224 }
1225 
1226 void ProxyObject::revoke(VM&amp; vm)
1227 {
1228     // This should only ever be called once and we should strictly transition from Object to null.
1229     RELEASE_ASSERT(!m_handler.get().isNull() &amp;&amp; m_handler.get().isObject());
1230     m_handler.set(vm, this, jsNull());
1231 }
1232 
1233 bool ProxyObject::isRevoked() const
1234 {
1235     return handler().isNull();
1236 }
1237 
1238 void ProxyObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
1239 {
1240     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
1241     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
1242     Base::visitChildren(thisObject, visitor);
1243 
</pre>
</td>
<td>
<hr />
<pre>
  34 #include &quot;ObjectConstructor.h&quot;
  35 #include &quot;SlotVisitorInlines.h&quot;
  36 #include &quot;StructureInlines.h&quot;
  37 #include &quot;VMInlines.h&quot;
  38 #include &lt;wtf/NoTailCalls.h&gt;
  39 
  40 // Note that we use NO_TAIL_CALLS() throughout this file because we rely on the machine stack
  41 // growing larger for throwing OOM errors for when we have an effectively cyclic prototype chain.
  42 
  43 namespace JSC {
  44 
  45 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(ProxyObject);
  46 
  47 const ClassInfo ProxyObject::s_info = { &quot;ProxyObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ProxyObject) };
  48 
  49 ProxyObject::ProxyObject(VM&amp; vm, Structure* structure)
  50     : Base(vm, structure)
  51 {
  52 }
  53 
<span class="line-modified">  54 String ProxyObject::toStringName(const JSObject* object, JSGlobalObject* globalObject)</span>
  55 {
<span class="line-modified">  56     VM&amp; vm = globalObject-&gt;vm();</span>
  57     auto scope = DECLARE_THROW_SCOPE(vm);
  58     const ProxyObject* proxy = jsCast&lt;const ProxyObject*&gt;(object);
  59     while (proxy) {
  60         const JSObject* target = proxy-&gt;target();
<span class="line-modified">  61         bool targetIsArray = isArray(globalObject, target);</span>
  62         if (UNLIKELY(scope.exception()))
  63             break;
  64         if (targetIsArray)
<span class="line-modified">  65             RELEASE_AND_RETURN(scope, target-&gt;classInfo(vm)-&gt;methodTable.toStringName(target, globalObject));</span>
  66 
  67         proxy = jsDynamicCast&lt;const ProxyObject*&gt;(vm, target);
  68     }
  69     return &quot;Object&quot;_s;
  70 }
  71 
  72 Structure* ProxyObject::structureForTarget(JSGlobalObject* globalObject, JSValue target)
  73 {
  74     if (!target.isObject())
  75         return globalObject-&gt;proxyObjectStructure();
  76 
  77     JSObject* targetAsObject = jsCast&lt;JSObject*&gt;(target);
  78     CallData ignoredCallData;
  79     VM&amp; vm = globalObject-&gt;vm();
  80     bool isCallable = targetAsObject-&gt;methodTable(vm)-&gt;getCallData(targetAsObject, ignoredCallData) != CallType::None;
  81     return isCallable ? globalObject-&gt;callableProxyObjectStructure() : globalObject-&gt;proxyObjectStructure();
  82 }
  83 
<span class="line-modified">  84 void ProxyObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject, JSValue target, JSValue handler)</span>
  85 {
  86     auto scope = DECLARE_THROW_SCOPE(vm);
  87     Base::finishCreation(vm);
  88     ASSERT(type() == ProxyObjectType);
  89     if (!target.isObject()) {
<span class="line-modified">  90         throwTypeError(globalObject, scope, &quot;A Proxy&#39;s &#39;target&#39; should be an Object&quot;_s);</span>
  91         return;
  92     }
  93     if (ProxyObject* targetAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, target)) {
  94         if (targetAsProxy-&gt;isRevoked()) {
<span class="line-modified">  95             throwTypeError(globalObject, scope, &quot;A Proxy&#39;s &#39;target&#39; shouldn&#39;t be a revoked Proxy&quot;_s);</span>
  96             return;
  97         }
  98     }
  99     if (!handler.isObject()) {
<span class="line-modified"> 100         throwTypeError(globalObject, scope, &quot;A Proxy&#39;s &#39;handler&#39; should be an Object&quot;_s);</span>
 101         return;
 102     }
 103     if (ProxyObject* handlerAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, handler)) {
 104         if (handlerAsProxy-&gt;isRevoked()) {
<span class="line-modified"> 105             throwTypeError(globalObject, scope, &quot;A Proxy&#39;s &#39;handler&#39; shouldn&#39;t be a revoked Proxy&quot;_s);</span>
 106             return;
 107         }
 108     }
 109 
 110     JSObject* targetAsObject = jsCast&lt;JSObject*&gt;(target);
 111 
 112     CallData ignoredCallData;
 113     m_isCallable = targetAsObject-&gt;methodTable(vm)-&gt;getCallData(targetAsObject, ignoredCallData) != CallType::None;
 114     if (m_isCallable) {
 115         TypeInfo info = structure(vm)-&gt;typeInfo();
 116         RELEASE_ASSERT(info.implementsHasInstance() &amp;&amp; info.implementsDefaultHasInstance());
 117     }
 118 
 119     m_isConstructible = jsCast&lt;JSObject*&gt;(target)-&gt;isConstructor(vm);
 120 
 121     m_target.set(vm, this, targetAsObject);
 122     m_handler.set(vm, this, handler);
 123 }
 124 
 125 static const ASCIILiteral s_proxyAlreadyRevokedErrorMessage { &quot;Proxy has already been revoked. No more operations are allowed to be performed on it&quot;_s };
 126 
<span class="line-modified"> 127 static JSValue performProxyGet(JSGlobalObject* globalObject, ProxyObject* proxyObject, JSValue receiver, PropertyName propertyName)</span>
 128 {
 129     NO_TAIL_CALLS();
 130 
<span class="line-modified"> 131     VM&amp; vm = globalObject-&gt;vm();</span>
 132     auto scope = DECLARE_THROW_SCOPE(vm);
 133     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 134         throwStackOverflowError(globalObject, scope);</span>
 135         return { };
 136     }
 137 
 138     JSObject* target = proxyObject-&gt;target();
 139 
 140     auto performDefaultGet = [&amp;] {
 141         scope.release();
 142         PropertySlot slot(receiver, PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 143         bool hasProperty = target-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
 144         EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
 145         if (hasProperty)
<span class="line-modified"> 146             RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));</span>
 147 
 148         return jsUndefined();
 149     };
 150 
 151     if (propertyName.isPrivateName())
 152         return jsUndefined();
 153 
 154     JSValue handlerValue = proxyObject-&gt;handler();
 155     if (handlerValue.isNull())
<span class="line-modified"> 156         return throwTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 157 
 158     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 159     CallData callData;
 160     CallType callType;
<span class="line-modified"> 161     JSValue getHandler = handler-&gt;getMethod(globalObject, callData, callType, vm.propertyNames-&gt;get, &quot;&#39;get&#39; property of a Proxy&#39;s handler object should be callable&quot;_s);</span>
 162     RETURN_IF_EXCEPTION(scope, { });
 163 
 164     if (getHandler.isUndefined())
 165         return performDefaultGet();
 166 
 167     MarkedArgumentBuffer arguments;
 168     arguments.append(target);
 169     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
 170     arguments.append(receiver);
 171     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 172     JSValue trapResult = call(globalObject, getHandler, callType, callData, handler, arguments);</span>
 173     RETURN_IF_EXCEPTION(scope, { });
 174 
 175     PropertyDescriptor descriptor;
<span class="line-modified"> 176     bool result = target-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor);</span>
 177     EXCEPTION_ASSERT(!scope.exception() || !result);
 178     if (result) {
 179         if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
<span class="line-modified"> 180             bool isSame = sameValue(globalObject, descriptor.value(), trapResult);</span>
<span class="line-modified"> 181             RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added"> 182             if (!isSame)</span>
<span class="line-added"> 183                 return throwTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable and non-writable property should be the same value as the target&#39;s property&quot;_s);</span>
 184         } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.getter().isUndefined()) {
 185             if (!trapResult.isUndefined())
<span class="line-modified"> 186                 return throwTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable accessor property without a getter should be undefined&quot;_s);</span>
 187         }
 188     }
 189 
 190     RETURN_IF_EXCEPTION(scope, { });
 191 
 192     return trapResult;
 193 }
 194 
<span class="line-modified"> 195 bool ProxyObject::performGet(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
 196 {
 197     NO_TAIL_CALLS();
 198 
<span class="line-modified"> 199     VM&amp; vm = globalObject-&gt;vm();</span>
 200     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 201     JSValue result = performProxyGet(globalObject, this, slot.thisValue(), propertyName);</span>
 202     RETURN_IF_EXCEPTION(scope, false);
 203     unsigned ignoredAttributes = 0;
 204     slot.setValue(this, ignoredAttributes, result);
 205     return true;
 206 }
 207 
<span class="line-modified"> 208 bool ProxyObject::performInternalMethodGetOwnProperty(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
 209 {
 210     NO_TAIL_CALLS();
 211 
<span class="line-modified"> 212     VM&amp; vm = globalObject-&gt;vm();</span>
 213     auto scope = DECLARE_THROW_SCOPE(vm);
 214     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 215         throwStackOverflowError(globalObject, scope);</span>
 216         return false;
 217     }
 218     JSObject* target = this-&gt;target();
 219 
 220     auto performDefaultGetOwnProperty = [&amp;] {
<span class="line-modified"> 221         return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, globalObject, propertyName, slot);</span>
 222     };
 223 
 224     if (propertyName.isPrivateName())
 225         return false;
 226 
 227     JSValue handlerValue = this-&gt;handler();
 228     if (handlerValue.isNull()) {
<span class="line-modified"> 229         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 230         return false;
 231     }
 232 
 233     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 234     CallData callData;
 235     CallType callType;
<span class="line-modified"> 236     JSValue getOwnPropertyDescriptorMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;getOwnPropertyDescriptor&quot;), &quot;&#39;getOwnPropertyDescriptor&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 237     RETURN_IF_EXCEPTION(scope, false);
 238     if (getOwnPropertyDescriptorMethod.isUndefined())
 239         RELEASE_AND_RETURN(scope, performDefaultGetOwnProperty());
 240 
 241     MarkedArgumentBuffer arguments;
 242     arguments.append(target);
 243     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
 244     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 245     JSValue trapResult = call(globalObject, getOwnPropertyDescriptorMethod, callType, callData, handler, arguments);</span>
 246     RETURN_IF_EXCEPTION(scope, false);
 247 
 248     if (!trapResult.isUndefined() &amp;&amp; !trapResult.isObject()) {
<span class="line-modified"> 249         throwVMTypeError(globalObject, scope, &quot;result of &#39;getOwnPropertyDescriptor&#39; call should either be an Object or undefined&quot;_s);</span>
 250         return false;
 251     }
 252 
 253     PropertyDescriptor targetPropertyDescriptor;
<span class="line-modified"> 254     bool isTargetPropertyDescriptorDefined = target-&gt;getOwnPropertyDescriptor(globalObject, propertyName, targetPropertyDescriptor);</span>
 255     RETURN_IF_EXCEPTION(scope, false);
 256 
 257     if (trapResult.isUndefined()) {
 258         if (!isTargetPropertyDescriptorDefined)
 259             return false;
 260         if (!targetPropertyDescriptor.configurable()) {
<span class="line-modified"> 261             throwVMTypeError(globalObject, scope, &quot;When the result of &#39;getOwnPropertyDescriptor&#39; is undefined the target must be configurable&quot;_s);</span>
 262             return false;
 263         }
<span class="line-modified"> 264         bool isExtensible = target-&gt;isExtensible(globalObject);</span>


 265         RETURN_IF_EXCEPTION(scope, false);
 266         if (!isExtensible) {
<span class="line-modified"> 267             throwVMTypeError(globalObject, scope, &quot;When &#39;getOwnPropertyDescriptor&#39; returns undefined, the &#39;target&#39; of a Proxy should be extensible&quot;_s);</span>



 268             return false;
 269         }
 270 
 271         return false;
 272     }
 273 
<span class="line-modified"> 274     bool isExtensible = target-&gt;isExtensible(globalObject);</span>
 275     RETURN_IF_EXCEPTION(scope, false);
 276     PropertyDescriptor trapResultAsDescriptor;
<span class="line-modified"> 277     toPropertyDescriptor(globalObject, trapResult, trapResultAsDescriptor);</span>
 278     RETURN_IF_EXCEPTION(scope, false);
 279     bool throwException = false;
<span class="line-modified"> 280     bool valid = validateAndApplyPropertyDescriptor(globalObject, nullptr, propertyName, isExtensible,</span>
 281         trapResultAsDescriptor, isTargetPropertyDescriptorDefined, targetPropertyDescriptor, throwException);
 282     RETURN_IF_EXCEPTION(scope, false);
 283     if (!valid) {
<span class="line-modified"> 284         throwVMTypeError(globalObject, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; fails the IsCompatiblePropertyDescriptor test&quot;_s);</span>
 285         return false;
 286     }
 287 
 288     if (!trapResultAsDescriptor.configurable()) {
 289         if (!isTargetPropertyDescriptorDefined || targetPropertyDescriptor.configurable()) {
<span class="line-modified"> 290             throwVMTypeError(globalObject, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; can&#39;t be non-configurable when the &#39;target&#39; doesn&#39;t have it as an own property or if it is a configurable own property on &#39;target&#39;&quot;_s);</span>
 291             return false;
 292         }
 293         if (trapResultAsDescriptor.writablePresent() &amp;&amp; !trapResultAsDescriptor.writable() &amp;&amp; targetPropertyDescriptor.writable()) {
<span class="line-modified"> 294             throwVMTypeError(globalObject, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; can&#39;t be non-configurable and non-writable when the target&#39;s property is writable&quot;_s);</span>
 295             return false;
 296         }
 297     }
 298 
 299     if (trapResultAsDescriptor.isAccessorDescriptor()) {
<span class="line-modified"> 300         GetterSetter* getterSetter = trapResultAsDescriptor.slowGetterSetter(globalObject);</span>
 301         RETURN_IF_EXCEPTION(scope, false);
 302         slot.setGetterSlot(this, trapResultAsDescriptor.attributes(), getterSetter);
 303     } else if (trapResultAsDescriptor.isDataDescriptor() &amp;&amp; !trapResultAsDescriptor.value().isEmpty())
 304         slot.setValue(this, trapResultAsDescriptor.attributes(), trapResultAsDescriptor.value());
 305     else
 306         slot.setValue(this, trapResultAsDescriptor.attributes(), jsUndefined()); // We use undefined because it&#39;s the default value in object properties.
 307 
 308     return true;
 309 }
 310 
<span class="line-modified"> 311 bool ProxyObject::performHasProperty(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
 312 {
 313     NO_TAIL_CALLS();
 314 
<span class="line-modified"> 315     VM&amp; vm = globalObject-&gt;vm();</span>
 316     auto scope = DECLARE_THROW_SCOPE(vm);
 317     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 318         throwStackOverflowError(globalObject, scope);</span>
 319         return false;
 320     }
 321     JSObject* target = this-&gt;target();
 322     slot.setValue(this, static_cast&lt;unsigned&gt;(PropertyAttribute::None), jsUndefined()); // Nobody should rely on our value, but be safe and protect against any bad actors reading our value.
 323 
 324     auto performDefaultHasProperty = [&amp;] {
<span class="line-modified"> 325         return target-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
 326     };
 327 
 328     if (propertyName.isPrivateName())
 329         return false;
 330 
 331     JSValue handlerValue = this-&gt;handler();
 332     if (handlerValue.isNull()) {
<span class="line-modified"> 333         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 334         return false;
 335     }
 336 
 337     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 338     CallData callData;
 339     CallType callType;
<span class="line-modified"> 340     JSValue hasMethod = handler-&gt;getMethod(globalObject, callData, callType, vm.propertyNames-&gt;has, &quot;&#39;has&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 341     RETURN_IF_EXCEPTION(scope, false);
 342     if (hasMethod.isUndefined())
 343         RELEASE_AND_RETURN(scope, performDefaultHasProperty());
 344 
 345     MarkedArgumentBuffer arguments;
 346     arguments.append(target);
 347     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
 348     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 349     JSValue trapResult = call(globalObject, hasMethod, callType, callData, handler, arguments);</span>
 350     RETURN_IF_EXCEPTION(scope, false);
 351 
<span class="line-modified"> 352     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
 353     RETURN_IF_EXCEPTION(scope, false);
 354 
 355     if (!trapResultAsBool) {
 356         PropertyDescriptor descriptor;
<span class="line-modified"> 357         bool isPropertyDescriptorDefined = target-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor);</span>
 358         RETURN_IF_EXCEPTION(scope, false);
 359         if (isPropertyDescriptorDefined) {
 360             if (!descriptor.configurable()) {
<span class="line-modified"> 361                 throwVMTypeError(globalObject, scope, &quot;Proxy &#39;has&#39; must return &#39;true&#39; for non-configurable properties&quot;_s);</span>
 362                 return false;
 363             }
<span class="line-modified"> 364             bool isExtensible = target-&gt;isExtensible(globalObject);</span>
 365             RETURN_IF_EXCEPTION(scope, false);
 366             if (!isExtensible) {
<span class="line-modified"> 367                 throwVMTypeError(globalObject, scope, &quot;Proxy &#39;has&#39; must return &#39;true&#39; for a non-extensible &#39;target&#39; object with a configurable property&quot;_s);</span>
 368                 return false;
 369             }
 370         }
 371     }
 372 
 373     return trapResultAsBool;
 374 }
 375 
<span class="line-modified"> 376 bool ProxyObject::getOwnPropertySlotCommon(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
 377 {
 378     slot.disableCaching();
 379     slot.setIsTaintedByOpaqueObject();
 380 
 381     if (slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry)
 382         return false;
 383 
<span class="line-modified"> 384     VM&amp; vm = globalObject-&gt;vm();</span>
 385     auto scope = DECLARE_THROW_SCOPE(vm);
 386     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 387         throwStackOverflowError(globalObject, scope);</span>
 388         return false;
 389     }
 390     switch (slot.internalMethodType()) {
 391     case PropertySlot::InternalMethodType::Get:
<span class="line-modified"> 392         RELEASE_AND_RETURN(scope, performGet(globalObject, propertyName, slot));</span>
 393     case PropertySlot::InternalMethodType::GetOwnProperty:
<span class="line-modified"> 394         RELEASE_AND_RETURN(scope, performInternalMethodGetOwnProperty(globalObject, propertyName, slot));</span>
 395     case PropertySlot::InternalMethodType::HasProperty:
<span class="line-modified"> 396         RELEASE_AND_RETURN(scope, performHasProperty(globalObject, propertyName, slot));</span>
 397     default:
 398         return false;
 399     }
 400 
 401     RELEASE_ASSERT_NOT_REACHED();
 402     return false;
 403 }
 404 
<span class="line-modified"> 405 bool ProxyObject::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
 406 {
 407     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified"> 408     return thisObject-&gt;getOwnPropertySlotCommon(globalObject, propertyName, slot);</span>
 409 }
 410 
<span class="line-modified"> 411 bool ProxyObject::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* globalObject, unsigned propertyName, PropertySlot&amp; slot)</span>
 412 {
<span class="line-modified"> 413     VM&amp; vm = globalObject-&gt;vm();</span>
 414     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
 415     Identifier ident = Identifier::from(vm, propertyName);
<span class="line-modified"> 416     return thisObject-&gt;getOwnPropertySlotCommon(globalObject, ident.impl(), slot);</span>
 417 }
 418 
 419 template &lt;typename PerformDefaultPutFunction&gt;
<span class="line-modified"> 420 bool ProxyObject::performPut(JSGlobalObject* globalObject, JSValue putValue, JSValue thisValue, PropertyName propertyName, PerformDefaultPutFunction performDefaultPut, bool shouldThrow)</span>
 421 {
 422     NO_TAIL_CALLS();
 423 
<span class="line-modified"> 424     VM&amp; vm = globalObject-&gt;vm();</span>
 425     auto scope = DECLARE_THROW_SCOPE(vm);
 426     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 427         throwStackOverflowError(globalObject, scope);</span>
 428         return false;
 429     }
 430 
 431     if (propertyName.isPrivateName())
 432         return false;
 433 
 434     JSValue handlerValue = this-&gt;handler();
 435     if (handlerValue.isNull()) {
<span class="line-modified"> 436         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 437         return false;
 438     }
 439 
 440     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 441     CallData callData;
 442     CallType callType;
<span class="line-modified"> 443     JSValue setMethod = handler-&gt;getMethod(globalObject, callData, callType, vm.propertyNames-&gt;set, &quot;&#39;set&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 444     RETURN_IF_EXCEPTION(scope, false);
 445     JSObject* target = this-&gt;target();
 446     if (setMethod.isUndefined())
 447         RELEASE_AND_RETURN(scope, performDefaultPut());
 448 
 449     MarkedArgumentBuffer arguments;
 450     arguments.append(target);
 451     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
 452     arguments.append(putValue);
 453     arguments.append(thisValue);
 454     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 455     JSValue trapResult = call(globalObject, setMethod, callType, callData, handler, arguments);</span>
 456     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified"> 457     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
 458     RETURN_IF_EXCEPTION(scope, false);
 459     if (!trapResultAsBool) {
 460         if (shouldThrow)
<span class="line-modified"> 461             throwVMTypeError(globalObject, scope, makeString(&quot;Proxy object&#39;s &#39;set&#39; trap returned falsy value for property &#39;&quot;, String(propertyName.uid()), &quot;&#39;&quot;));</span>
 462         return false;
 463     }
 464 
 465     PropertyDescriptor descriptor;
<span class="line-modified"> 466     bool hasProperty = target-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor);</span>
 467     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
 468     if (hasProperty) {
 469         if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
<span class="line-modified"> 470             bool isSame = sameValue(globalObject, descriptor.value(), putValue);</span>
<span class="line-modified"> 471             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added"> 472             if (!isSame) {</span>
<span class="line-added"> 473                 throwVMTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;set&#39; on a non-configurable and non-writable property on &#39;target&#39; should either return false or be the same value already on the &#39;target&#39;&quot;_s);</span>
 474                 return false;
 475             }
 476         } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.setter().isUndefined()) {
<span class="line-modified"> 477             throwVMTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;set&#39; method on a non-configurable accessor property without a setter should return false&quot;_s);</span>
 478             return false;
 479         }
 480     }
 481     return true;
 482 }
 483 
<span class="line-modified"> 484 bool ProxyObject::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
 485 {
<span class="line-modified"> 486     VM&amp; vm = globalObject-&gt;vm();</span>
 487     slot.disableCaching();
 488 
 489     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
 490     auto performDefaultPut = [&amp;] () {
 491         JSObject* target = jsCast&lt;JSObject*&gt;(thisObject-&gt;target());
<span class="line-modified"> 492         return target-&gt;methodTable(vm)-&gt;put(target, globalObject, propertyName, value, slot);</span>
 493     };
<span class="line-modified"> 494     return thisObject-&gt;performPut(globalObject, value, slot.thisValue(), propertyName, performDefaultPut, slot.isStrictMode());</span>
 495 }
 496 
<span class="line-modified"> 497 bool ProxyObject::putByIndexCommon(JSGlobalObject* globalObject, JSValue thisValue, unsigned propertyName, JSValue putValue, bool shouldThrow)</span>
 498 {
<span class="line-modified"> 499     VM&amp; vm = globalObject-&gt;vm();</span>
 500     auto scope = DECLARE_THROW_SCOPE(vm);
 501     Identifier ident = Identifier::from(vm, propertyName);
 502     RETURN_IF_EXCEPTION(scope, false);
 503     auto performDefaultPut = [&amp;] () {
 504         JSObject* target = this-&gt;target();
 505         bool isStrictMode = shouldThrow;
 506         PutPropertySlot slot(thisValue, isStrictMode); // We must preserve the &quot;this&quot; target of the putByIndex.
<span class="line-modified"> 507         return target-&gt;methodTable(vm)-&gt;put(target, globalObject, ident.impl(), putValue, slot);</span>
 508     };
<span class="line-modified"> 509     RELEASE_AND_RETURN(scope, performPut(globalObject, putValue, thisValue, ident.impl(), performDefaultPut, shouldThrow));</span>
 510 }
 511 
<span class="line-modified"> 512 bool ProxyObject::putByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool shouldThrow)</span>
 513 {
 514     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
<span class="line-modified"> 515     return thisObject-&gt;putByIndexCommon(globalObject, thisObject, propertyName, value, shouldThrow);</span>
 516 }
 517 
<span class="line-modified"> 518 static EncodedJSValue JSC_HOST_CALL performProxyCall(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 519 {
 520     NO_TAIL_CALLS();
 521 
<span class="line-modified"> 522     VM&amp; vm = globalObject-&gt;vm();</span>
 523     auto scope = DECLARE_THROW_SCOPE(vm);
 524     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 525         throwStackOverflowError(globalObject, scope);</span>
 526         return encodedJSValue();
 527     }
<span class="line-modified"> 528     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(callFrame-&gt;jsCallee());</span>
 529     JSValue handlerValue = proxy-&gt;handler();
 530     if (handlerValue.isNull())
<span class="line-modified"> 531         return throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 532 
 533     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 534     CallData callData;
 535     CallType callType;
<span class="line-modified"> 536     JSValue applyMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;apply&quot;), &quot;&#39;apply&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 537     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 538     JSObject* target = proxy-&gt;target();
 539     if (applyMethod.isUndefined()) {
 540         CallData callData;
 541         CallType callType = target-&gt;methodTable(vm)-&gt;getCallData(target, callData);
 542         RELEASE_ASSERT(callType != CallType::None);
<span class="line-modified"> 543         RELEASE_AND_RETURN(scope, JSValue::encode(call(globalObject, target, callType, callData, callFrame-&gt;thisValue(), ArgList(callFrame))));</span>
 544     }
 545 
<span class="line-modified"> 546     JSArray* argArray = constructArray(globalObject, static_cast&lt;ArrayAllocationProfile*&gt;(nullptr), ArgList(callFrame));</span>
 547     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 548     MarkedArgumentBuffer arguments;
 549     arguments.append(target);
<span class="line-modified"> 550     arguments.append(callFrame-&gt;thisValue().toThis(globalObject, ECMAMode::StrictMode));</span>
 551     arguments.append(argArray);
 552     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 553     RELEASE_AND_RETURN(scope, JSValue::encode(call(globalObject, applyMethod, callType, callData, handler, arguments)));</span>
 554 }
 555 
 556 CallType ProxyObject::getCallData(JSCell* cell, CallData&amp; callData)
 557 {
 558     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(cell);
 559     if (!proxy-&gt;m_isCallable) {
 560         callData.js.functionExecutable = nullptr;
 561         callData.js.scope = nullptr;
 562         return CallType::None;
 563     }
 564 
 565     callData.native.function = performProxyCall;
 566     return CallType::Host;
 567 }
 568 
<span class="line-modified"> 569 static EncodedJSValue JSC_HOST_CALL performProxyConstruct(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 570 {
 571     NO_TAIL_CALLS();
 572 
<span class="line-modified"> 573     VM&amp; vm = globalObject-&gt;vm();</span>
 574     auto scope = DECLARE_THROW_SCOPE(vm);
 575     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 576         throwStackOverflowError(globalObject, scope);</span>
 577         return encodedJSValue();
 578     }
<span class="line-modified"> 579     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(callFrame-&gt;jsCallee());</span>
 580     JSValue handlerValue = proxy-&gt;handler();
 581     if (handlerValue.isNull())
<span class="line-modified"> 582         return throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 583 
 584     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 585     CallData callData;
 586     CallType callType;
<span class="line-modified"> 587     JSValue constructMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;construct&quot;), &quot;&#39;construct&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 588     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 589     JSObject* target = proxy-&gt;target();
 590     if (constructMethod.isUndefined()) {
 591         ConstructData constructData;
 592         ConstructType constructType = target-&gt;methodTable(vm)-&gt;getConstructData(target, constructData);
 593         RELEASE_ASSERT(constructType != ConstructType::None);
<span class="line-modified"> 594         RELEASE_AND_RETURN(scope, JSValue::encode(construct(globalObject, target, constructType, constructData, ArgList(callFrame), callFrame-&gt;newTarget())));</span>
 595     }
 596 
<span class="line-modified"> 597     JSArray* argArray = constructArray(globalObject, static_cast&lt;ArrayAllocationProfile*&gt;(nullptr), ArgList(callFrame));</span>
 598     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 599     MarkedArgumentBuffer arguments;
 600     arguments.append(target);
 601     arguments.append(argArray);
<span class="line-modified"> 602     arguments.append(callFrame-&gt;newTarget());</span>
 603     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 604     JSValue result = call(globalObject, constructMethod, callType, callData, handler, arguments);</span>
 605     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 606     if (!result.isObject())
<span class="line-modified"> 607         return throwVMTypeError(globalObject, scope, &quot;Result from Proxy handler&#39;s &#39;construct&#39; method should be an object&quot;_s);</span>
 608     return JSValue::encode(result);
 609 }
 610 
 611 ConstructType ProxyObject::getConstructData(JSCell* cell, ConstructData&amp; constructData)
 612 {
 613     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(cell);
 614     if (!proxy-&gt;m_isConstructible) {
 615         constructData.js.functionExecutable = nullptr;
 616         constructData.js.scope = nullptr;
 617         return ConstructType::None;
 618     }
 619 
 620     constructData.native.function = performProxyConstruct;
 621     return ConstructType::Host;
 622 }
 623 
 624 template &lt;typename DefaultDeleteFunction&gt;
<span class="line-modified"> 625 bool ProxyObject::performDelete(JSGlobalObject* globalObject, PropertyName propertyName, DefaultDeleteFunction performDefaultDelete)</span>
 626 {
 627     NO_TAIL_CALLS();
 628 
<span class="line-modified"> 629     VM&amp; vm = globalObject-&gt;vm();</span>
 630     auto scope = DECLARE_THROW_SCOPE(vm);
 631     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 632         throwStackOverflowError(globalObject, scope);</span>
 633         return false;
 634     }
 635 
 636     if (propertyName.isPrivateName())
 637         return false;
 638 
 639     JSValue handlerValue = this-&gt;handler();
 640     if (handlerValue.isNull()) {
<span class="line-modified"> 641         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 642         return false;
 643     }
 644 
 645     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 646     CallData callData;
 647     CallType callType;
<span class="line-modified"> 648     JSValue deletePropertyMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;deleteProperty&quot;), &quot;&#39;deleteProperty&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 649     RETURN_IF_EXCEPTION(scope, false);
 650     JSObject* target = this-&gt;target();
 651     if (deletePropertyMethod.isUndefined())
 652         RELEASE_AND_RETURN(scope, performDefaultDelete());
 653 
 654     MarkedArgumentBuffer arguments;
 655     arguments.append(target);
 656     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
 657     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 658     JSValue trapResult = call(globalObject, deletePropertyMethod, callType, callData, handler, arguments);</span>
 659     RETURN_IF_EXCEPTION(scope, false);
 660 
<span class="line-modified"> 661     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
 662     RETURN_IF_EXCEPTION(scope, false);
 663 
 664     if (!trapResultAsBool)
 665         return false;
 666 
 667     PropertyDescriptor descriptor;
<span class="line-modified"> 668     bool result = target-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor);</span>
 669     EXCEPTION_ASSERT(!scope.exception() || !result);
 670     if (result) {
 671         if (!descriptor.configurable()) {
<span class="line-modified"> 672             throwVMTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target&#39;s property is not configurable&quot;_s);</span>
 673             return false;
 674         }
<span class="line-modified"> 675         bool targetIsExtensible = target-&gt;isExtensible(globalObject);</span>
 676         RETURN_IF_EXCEPTION(scope, false);
 677         if (!targetIsExtensible) {
<span class="line-modified"> 678             throwVMTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target has property and is not extensible&quot;_s);</span>
 679             return false;
 680         }
 681     }
 682 
 683     RETURN_IF_EXCEPTION(scope, false);
 684 
 685     return true;
 686 }
 687 
<span class="line-modified"> 688 bool ProxyObject::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
 689 {
 690     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
 691     auto performDefaultDelete = [&amp;] () -&gt; bool {
 692         JSObject* target = thisObject-&gt;target();
<span class="line-modified"> 693         return target-&gt;methodTable(globalObject-&gt;vm())-&gt;deleteProperty(target, globalObject, propertyName);</span>
 694     };
<span class="line-modified"> 695     return thisObject-&gt;performDelete(globalObject, propertyName, performDefaultDelete);</span>
 696 }
 697 
<span class="line-modified"> 698 bool ProxyObject::deletePropertyByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName)</span>
 699 {
<span class="line-modified"> 700     VM&amp; vm = globalObject-&gt;vm();</span>
 701     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
 702     Identifier ident = Identifier::from(vm, propertyName);
 703     auto performDefaultDelete = [&amp;] () -&gt; bool {
 704         JSObject* target = thisObject-&gt;target();
<span class="line-modified"> 705         return target-&gt;methodTable(vm)-&gt;deletePropertyByIndex(target, globalObject, propertyName);</span>
 706     };
<span class="line-modified"> 707     return thisObject-&gt;performDelete(globalObject, ident.impl(), performDefaultDelete);</span>
 708 }
 709 
<span class="line-modified"> 710 bool ProxyObject::performPreventExtensions(JSGlobalObject* globalObject)</span>
 711 {
 712     NO_TAIL_CALLS();
 713 
<span class="line-modified"> 714     VM&amp; vm = globalObject-&gt;vm();</span>
 715     auto scope = DECLARE_THROW_SCOPE(vm);
 716     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 717         throwStackOverflowError(globalObject, scope);</span>
 718         return false;
 719     }
 720 
 721     JSValue handlerValue = this-&gt;handler();
 722     if (handlerValue.isNull()) {
<span class="line-modified"> 723         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 724         return false;
 725     }
 726 
 727     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 728     CallData callData;
 729     CallType callType;
<span class="line-modified"> 730     JSValue preventExtensionsMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;preventExtensions&quot;), &quot;&#39;preventExtensions&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 731     RETURN_IF_EXCEPTION(scope, false);
 732     JSObject* target = this-&gt;target();
 733     if (preventExtensionsMethod.isUndefined())
<span class="line-modified"> 734         RELEASE_AND_RETURN(scope, target-&gt;methodTable(vm)-&gt;preventExtensions(target, globalObject));</span>
 735 
 736     MarkedArgumentBuffer arguments;
 737     arguments.append(target);
 738     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 739     JSValue trapResult = call(globalObject, preventExtensionsMethod, callType, callData, handler, arguments);</span>
 740     RETURN_IF_EXCEPTION(scope, false);
 741 
<span class="line-modified"> 742     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
 743     RETURN_IF_EXCEPTION(scope, false);
 744 
 745     if (trapResultAsBool) {
<span class="line-modified"> 746         bool targetIsExtensible = target-&gt;isExtensible(globalObject);</span>
 747         RETURN_IF_EXCEPTION(scope, false);
 748         if (targetIsExtensible) {
<span class="line-modified"> 749             throwVMTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;preventExtensions&#39; trap returned true even though its target is extensible. It should have returned false&quot;_s);</span>
 750             return false;
 751         }
 752     }
 753 
 754     return trapResultAsBool;
 755 }
 756 
<span class="line-modified"> 757 bool ProxyObject::preventExtensions(JSObject* object, JSGlobalObject* globalObject)</span>
 758 {
<span class="line-modified"> 759     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performPreventExtensions(globalObject);</span>
 760 }
 761 
<span class="line-modified"> 762 bool ProxyObject::performIsExtensible(JSGlobalObject* globalObject)</span>
 763 {
 764     NO_TAIL_CALLS();
 765 
<span class="line-modified"> 766     VM&amp; vm = globalObject-&gt;vm();</span>
 767     auto scope = DECLARE_THROW_SCOPE(vm);
 768     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 769         throwStackOverflowError(globalObject, scope);</span>
 770         return false;
 771     }
 772 
 773     JSValue handlerValue = this-&gt;handler();
 774     if (handlerValue.isNull()) {
<span class="line-modified"> 775         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 776         return false;
 777     }
 778 
 779     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 780     CallData callData;
 781     CallType callType;
<span class="line-modified"> 782     JSValue isExtensibleMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;isExtensible&quot;), &quot;&#39;isExtensible&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 783     RETURN_IF_EXCEPTION(scope, false);
 784 
 785     JSObject* target = this-&gt;target();
 786     if (isExtensibleMethod.isUndefined())
<span class="line-modified"> 787         RELEASE_AND_RETURN(scope, target-&gt;isExtensible(globalObject));</span>
 788 
 789     MarkedArgumentBuffer arguments;
 790     arguments.append(target);
 791     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 792     JSValue trapResult = call(globalObject, isExtensibleMethod, callType, callData, handler, arguments);</span>
 793     RETURN_IF_EXCEPTION(scope, false);
 794 
<span class="line-modified"> 795     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
 796     RETURN_IF_EXCEPTION(scope, false);
 797 
<span class="line-modified"> 798     bool isTargetExtensible = target-&gt;isExtensible(globalObject);</span>
 799     RETURN_IF_EXCEPTION(scope, false);
 800 
 801     if (trapResultAsBool != isTargetExtensible) {
 802         if (isTargetExtensible) {
 803             ASSERT(!trapResultAsBool);
<span class="line-modified"> 804             throwVMTypeError(globalObject, scope, &quot;Proxy object&#39;s &#39;isExtensible&#39; trap returned false when the target is extensible. It should have returned true&quot;_s);</span>
 805         } else {
 806             ASSERT(!isTargetExtensible);
 807             ASSERT(trapResultAsBool);
<span class="line-modified"> 808             throwVMTypeError(globalObject, scope, &quot;Proxy object&#39;s &#39;isExtensible&#39; trap returned true when the target is non-extensible. It should have returned false&quot;_s);</span>
 809         }
 810     }
 811 
 812     return trapResultAsBool;
 813 }
 814 
<span class="line-modified"> 815 bool ProxyObject::isExtensible(JSObject* object, JSGlobalObject* globalObject)</span>
 816 {
<span class="line-modified"> 817     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performIsExtensible(globalObject);</span>
 818 }
 819 
<span class="line-modified"> 820 bool ProxyObject::performDefineOwnProperty(JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
 821 {
 822     NO_TAIL_CALLS();
 823 
<span class="line-modified"> 824     VM&amp; vm = globalObject-&gt;vm();</span>
 825     auto scope = DECLARE_THROW_SCOPE(vm);
 826     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 827         throwStackOverflowError(globalObject, scope);</span>
 828         return false;
 829     }
 830 
 831     JSObject* target = this-&gt;target();
 832     auto performDefaultDefineOwnProperty = [&amp;] {
<span class="line-modified"> 833         RELEASE_AND_RETURN(scope, target-&gt;methodTable(vm)-&gt;defineOwnProperty(target, globalObject, propertyName, descriptor, shouldThrow));</span>
 834     };
 835 
 836     if (propertyName.isPrivateName())
 837         return false;
 838 
 839     JSValue handlerValue = this-&gt;handler();
 840     if (handlerValue.isNull()) {
<span class="line-modified"> 841         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 842         return false;
 843     }
 844 
 845     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 846     CallData callData;
 847     CallType callType;
<span class="line-modified"> 848     JSValue definePropertyMethod = handler-&gt;getMethod(globalObject, callData, callType, vm.propertyNames-&gt;defineProperty, &quot;&#39;defineProperty&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 849     RETURN_IF_EXCEPTION(scope, false);
 850 
 851     if (definePropertyMethod.isUndefined())
 852         return performDefaultDefineOwnProperty();
 853 
<span class="line-modified"> 854     JSObject* descriptorObject = constructObjectFromPropertyDescriptor(globalObject, descriptor);</span>
 855     RETURN_IF_EXCEPTION(scope, false);
 856 
 857     MarkedArgumentBuffer arguments;
 858     arguments.append(target);
 859     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));
 860     arguments.append(descriptorObject);
 861     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 862     JSValue trapResult = call(globalObject, definePropertyMethod, callType, callData, handler, arguments);</span>
 863     RETURN_IF_EXCEPTION(scope, false);
 864 
<span class="line-modified"> 865     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
 866     RETURN_IF_EXCEPTION(scope, false);
 867 
 868     if (!trapResultAsBool)
 869         return false;
 870 
 871     PropertyDescriptor targetDescriptor;
<span class="line-modified"> 872     bool isTargetDescriptorDefined = target-&gt;getOwnPropertyDescriptor(globalObject, propertyName, targetDescriptor);</span>
 873     RETURN_IF_EXCEPTION(scope, false);
 874 
<span class="line-modified"> 875     bool targetIsExtensible = target-&gt;isExtensible(globalObject);</span>
 876     RETURN_IF_EXCEPTION(scope, false);
 877     bool settingConfigurableToFalse = descriptor.configurablePresent() &amp;&amp; !descriptor.configurable();
 878 
 879     if (!isTargetDescriptorDefined) {
 880         if (!targetIsExtensible) {
<span class="line-modified"> 881             throwVMTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true even though getOwnPropertyDescriptor of the Proxy&#39;s target returned undefined and the target is non-extensible&quot;_s);</span>
 882             return false;
 883         }
 884         if (settingConfigurableToFalse) {
<span class="line-modified"> 885             throwVMTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true for a non-configurable field even though getOwnPropertyDescriptor of the Proxy&#39;s target returned undefined&quot;_s);</span>
 886             return false;
 887         }
 888 
 889         return true;
 890     }
 891 
 892     ASSERT(isTargetDescriptorDefined);
 893     bool isCurrentDefined = isTargetDescriptorDefined;
 894     const PropertyDescriptor&amp; current = targetDescriptor;
 895     bool throwException = false;
<span class="line-modified"> 896     bool isCompatibleDescriptor = validateAndApplyPropertyDescriptor(globalObject, nullptr, propertyName, targetIsExtensible, descriptor, isCurrentDefined, current, throwException);</span>
 897     RETURN_IF_EXCEPTION(scope, false);
 898     if (!isCompatibleDescriptor) {
<span class="line-modified"> 899         throwVMTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a property on its target that is compatible with the trap&#39;s input descriptor&quot;_s);</span>
 900         return false;
 901     }
 902     if (settingConfigurableToFalse &amp;&amp; targetDescriptor.configurable()) {
<span class="line-modified"> 903         throwVMTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a non-configurable property on its target even though the input descriptor to the trap said it must do so&quot;_s);</span>
 904         return false;
 905     }
 906     if (targetDescriptor.isDataDescriptor() &amp;&amp; !targetDescriptor.configurable() &amp;&amp; targetDescriptor.writable()) {
 907         if (descriptor.writablePresent() &amp;&amp; !descriptor.writable()) {
<span class="line-modified"> 908             throwTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true for a non-writable input descriptor when the target&#39;s property is non-configurable and writable&quot;_s);</span>
 909             return false;
 910         }
 911     }
 912 
 913     return true;
 914 }
 915 
<span class="line-modified"> 916 bool ProxyObject::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
 917 {
 918     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified"> 919     return thisObject-&gt;performDefineOwnProperty(globalObject, propertyName, descriptor, shouldThrow);</span>
 920 }
 921 
<span class="line-modified"> 922 void ProxyObject::performGetOwnPropertyNames(JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames)</span>
 923 {
 924     NO_TAIL_CALLS();
 925 
<span class="line-modified"> 926     VM&amp; vm = globalObject-&gt;vm();</span>
 927     auto scope = DECLARE_THROW_SCOPE(vm);
 928     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified"> 929         throwStackOverflowError(globalObject, scope);</span>
 930         return;
 931     }
 932     JSValue handlerValue = this-&gt;handler();
 933     if (handlerValue.isNull()) {
<span class="line-modified"> 934         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
 935         return;
 936     }
 937 
 938     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 939     CallData callData;
 940     CallType callType;
<span class="line-modified"> 941     JSValue ownKeysMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;ownKeys&quot;), &quot;&#39;ownKeys&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 942     RETURN_IF_EXCEPTION(scope, void());
 943     JSObject* target = this-&gt;target();
<span class="line-added"> 944     EnumerationMode enumerationMode(DontEnumPropertiesMode::Include);</span>
 945     if (ownKeysMethod.isUndefined()) {
 946         scope.release();
<span class="line-modified"> 947         target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, globalObject, propertyNames, enumerationMode);</span>
 948         return;
 949     }
 950 
 951     MarkedArgumentBuffer arguments;
 952     arguments.append(target);
 953     ASSERT(!arguments.hasOverflowed());
<span class="line-modified"> 954     JSValue trapResult = call(globalObject, ownKeysMethod, callType, callData, handler, arguments);</span>
 955     RETURN_IF_EXCEPTION(scope, void());
 956 

 957     HashSet&lt;UniquedStringImpl*&gt; uncheckedResultKeys;
 958     {


 959         RuntimeTypeMask resultFilter = 0;
 960         switch (propertyNames.propertyNameMode()) {
 961         case PropertyNameMode::Symbols:
 962             resultFilter = TypeSymbol;
 963             break;
 964         case PropertyNameMode::Strings:
 965             resultFilter = TypeString;
 966             break;
 967         case PropertyNameMode::StringsAndSymbols:
 968             resultFilter = TypeSymbol | TypeString;
 969             break;
 970         }
 971         ASSERT(resultFilter);
 972 
 973         auto addPropName = [&amp;] (JSValue value, RuntimeType type) -&gt; bool {
<span class="line-modified"> 974             static constexpr bool doExitEarly = true;</span>
<span class="line-modified"> 975             static constexpr bool dontExitEarly = false;</span>
 976 
<span class="line-modified"> 977             Identifier ident = value.toPropertyKey(globalObject);</span>
 978             RETURN_IF_EXCEPTION(scope, doExitEarly);
 979 
<span class="line-modified"> 980             if (!uncheckedResultKeys.add(ident.impl()).isNewEntry) {</span>
<span class="line-modified"> 981                 throwTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; trap result must not contain any duplicate names&quot;_s);</span>







 982                 return doExitEarly;
 983             }
 984 
<span class="line-modified"> 985             if (type &amp; resultFilter)</span>
<span class="line-modified"> 986                 propertyNames.add(ident.impl());</span>
 987 


 988             return dontExitEarly;
 989         };
 990 
 991         RuntimeTypeMask dontThrowAnExceptionTypeFilter = TypeString | TypeSymbol;
<span class="line-modified"> 992         createListFromArrayLike(globalObject, trapResult, dontThrowAnExceptionTypeFilter, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an object&quot;_s, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an array-like object containing only Strings and Symbols&quot;_s, addPropName);</span>
 993         RETURN_IF_EXCEPTION(scope, void());
 994     }
 995 
<span class="line-modified"> 996     bool targetIsExensible = target-&gt;isExtensible(globalObject);</span>
 997     RETURN_IF_EXCEPTION(scope, void());
 998 
<span class="line-modified"> 999     PropertyNameArray targetKeys(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);</span>
<span class="line-modified">1000     target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, globalObject, targetKeys, enumerationMode);</span>
1001     RETURN_IF_EXCEPTION(scope, void());
1002     Vector&lt;UniquedStringImpl*&gt; targetConfigurableKeys;
1003     Vector&lt;UniquedStringImpl*&gt; targetNonConfigurableKeys;
1004     for (const Identifier&amp; ident : targetKeys) {
1005         PropertyDescriptor descriptor;
<span class="line-modified">1006         bool isPropertyDefined = target-&gt;getOwnPropertyDescriptor(globalObject, ident.impl(), descriptor);</span>
1007         RETURN_IF_EXCEPTION(scope, void());
1008         if (isPropertyDefined &amp;&amp; !descriptor.configurable())
1009             targetNonConfigurableKeys.append(ident.impl());
1010         else
1011             targetConfigurableKeys.append(ident.impl());
1012     }
1013 
1014     enum ContainedIn { IsContainedIn, IsNotContainedIn };
1015     auto removeIfContainedInUncheckedResultKeys = [&amp;] (UniquedStringImpl* impl) -&gt; ContainedIn {
1016         auto iter = uncheckedResultKeys.find(impl);
1017         if (iter == uncheckedResultKeys.end())
1018             return IsNotContainedIn;
1019 
1020         uncheckedResultKeys.remove(iter);
1021         return IsContainedIn;
1022     };
1023 
1024     for (UniquedStringImpl* impl : targetNonConfigurableKeys) {
1025         if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {
<span class="line-modified">1026             throwVMTypeError(globalObject, scope, makeString(&quot;Proxy object&#39;s &#39;target&#39; has the non-configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));</span>
1027             return;
1028         }
1029     }
1030 
1031     if (!targetIsExensible) {
1032         for (UniquedStringImpl* impl : targetConfigurableKeys) {
1033             if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {
<span class="line-modified">1034                 throwVMTypeError(globalObject, scope, makeString(&quot;Proxy object&#39;s non-extensible &#39;target&#39; has configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));</span>
1035                 return;
1036             }
1037         }
1038 
1039         if (uncheckedResultKeys.size()) {
<span class="line-modified">1040             throwVMTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method returned a key that was not present in its non-extensible target&quot;_s);</span>
1041             return;
1042         }
1043     }
<span class="line-added">1044 }</span>
1045 
<span class="line-modified">1046 void ProxyObject::performGetOwnEnumerablePropertyNames(JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames)</span>
<span class="line-modified">1047 {</span>
<span class="line-modified">1048     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1049     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-modified">1050 </span>
<span class="line-modified">1051     PropertyNameArray unfilteredNames(vm, propertyNames.propertyNameMode(), propertyNames.privateSymbolMode());</span>
<span class="line-modified">1052     performGetOwnPropertyNames(globalObject, unfilteredNames);</span>
<span class="line-modified">1053     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-modified">1054     // Filtering DontEnum properties is observable in proxies and must occur after the invariant checks pass.</span>
<span class="line-modified">1055     for (const auto&amp; propertyName : unfilteredNames) {</span>
<span class="line-modified">1056         PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);</span>
<span class="line-modified">1057         auto isPropertyDefined = getOwnPropertySlotCommon(globalObject, propertyName, slot);</span>
<span class="line-modified">1058         RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-modified">1059         if (!isPropertyDefined)</span>
<span class="line-modified">1060             continue;</span>
<span class="line-added">1061         if (slot.attributes() &amp; PropertyAttribute::DontEnum)</span>
<span class="line-added">1062             continue;</span>
<span class="line-added">1063         propertyNames.add(propertyName.impl());</span>
1064     }
1065 }
1066 
<span class="line-modified">1067 void ProxyObject::getOwnPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
1068 {
1069     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified">1070     if (enumerationMode.includeDontEnumProperties())</span>
<span class="line-added">1071         thisObject-&gt;performGetOwnPropertyNames(globalObject, propertyNameArray);</span>
<span class="line-added">1072     else</span>
<span class="line-added">1073         thisObject-&gt;performGetOwnEnumerablePropertyNames(globalObject, propertyNameArray);</span>
1074 }
1075 
<span class="line-modified">1076 void ProxyObject::getPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
1077 {
1078     NO_TAIL_CALLS();
<span class="line-modified">1079     JSObject::getPropertyNames(object, globalObject, propertyNameArray, enumerationMode);</span>
1080 }
1081 
<span class="line-modified">1082 void ProxyObject::getOwnNonIndexPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode)</span>
1083 {
1084     RELEASE_ASSERT_NOT_REACHED();
1085 }
1086 
<span class="line-modified">1087 void ProxyObject::getStructurePropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode)</span>
1088 {
1089     // We should always go down the getOwnPropertyNames path.
1090     RELEASE_ASSERT_NOT_REACHED();
1091 }
1092 
<span class="line-modified">1093 void ProxyObject::getGenericPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode)</span>
1094 {
1095     RELEASE_ASSERT_NOT_REACHED();
1096 }
1097 
<span class="line-modified">1098 bool ProxyObject::performSetPrototype(JSGlobalObject* globalObject, JSValue prototype, bool shouldThrowIfCantSet)</span>
1099 {
1100     NO_TAIL_CALLS();
1101 
1102     ASSERT(prototype.isObject() || prototype.isNull());
1103 
<span class="line-modified">1104     VM&amp; vm = globalObject-&gt;vm();</span>
1105     auto scope = DECLARE_THROW_SCOPE(vm);
1106     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">1107         throwStackOverflowError(globalObject, scope);</span>
1108         return false;
1109     }
1110 
1111     JSValue handlerValue = this-&gt;handler();
1112     if (handlerValue.isNull()) {
<span class="line-modified">1113         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
1114         return false;
1115     }
1116 
1117     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
1118     CallData callData;
1119     CallType callType;
<span class="line-modified">1120     JSValue setPrototypeOfMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;setPrototypeOf&quot;), &quot;&#39;setPrototypeOf&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
1121     RETURN_IF_EXCEPTION(scope, false);
1122 
1123     JSObject* target = this-&gt;target();
1124     if (setPrototypeOfMethod.isUndefined())
<span class="line-modified">1125         RELEASE_AND_RETURN(scope, target-&gt;setPrototype(vm, globalObject, prototype, shouldThrowIfCantSet));</span>
1126 
1127     MarkedArgumentBuffer arguments;
1128     arguments.append(target);
1129     arguments.append(prototype);
1130     ASSERT(!arguments.hasOverflowed());
<span class="line-modified">1131     JSValue trapResult = call(globalObject, setPrototypeOfMethod, callType, callData, handler, arguments);</span>
1132     RETURN_IF_EXCEPTION(scope, false);
1133 
<span class="line-modified">1134     bool trapResultAsBool = trapResult.toBoolean(globalObject);</span>
1135     RETURN_IF_EXCEPTION(scope, false);
1136 
1137     if (!trapResultAsBool) {
1138         if (shouldThrowIfCantSet)
<span class="line-modified">1139             throwVMTypeError(globalObject, scope, &quot;Proxy &#39;setPrototypeOf&#39; returned false indicating it could not set the prototype value. The operation was expected to succeed&quot;_s);</span>
1140         return false;
1141     }
1142 
<span class="line-modified">1143     bool targetIsExtensible = target-&gt;isExtensible(globalObject);</span>
1144     RETURN_IF_EXCEPTION(scope, false);
1145     if (targetIsExtensible)
1146         return true;
1147 
<span class="line-modified">1148     JSValue targetPrototype = target-&gt;getPrototype(vm, globalObject);</span>
<span class="line-added">1149     RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">1150     bool isSame = sameValue(globalObject, prototype, targetPrototype);</span>
1151     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">1152     if (!isSame) {</span>
<span class="line-modified">1153         throwVMTypeError(globalObject, scope, &quot;Proxy &#39;setPrototypeOf&#39; trap returned true when its target is non-extensible and the new prototype value is not the same as the current prototype value. It should have returned false&quot;_s);</span>
1154         return false;
1155     }
1156 
1157     return true;
1158 }
1159 
<span class="line-modified">1160 bool ProxyObject::setPrototype(JSObject* object, JSGlobalObject* globalObject, JSValue prototype, bool shouldThrowIfCantSet)</span>
1161 {
<span class="line-modified">1162     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performSetPrototype(globalObject, prototype, shouldThrowIfCantSet);</span>
1163 }
1164 
<span class="line-modified">1165 JSValue ProxyObject::performGetPrototype(JSGlobalObject* globalObject)</span>
1166 {
1167     NO_TAIL_CALLS();
1168 
<span class="line-modified">1169     VM&amp; vm = globalObject-&gt;vm();</span>
1170     auto scope = DECLARE_THROW_SCOPE(vm);
1171     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
<span class="line-modified">1172         throwStackOverflowError(globalObject, scope);</span>
1173         return { };
1174     }
1175 
1176     JSValue handlerValue = this-&gt;handler();
1177     if (handlerValue.isNull()) {
<span class="line-modified">1178         throwVMTypeError(globalObject, scope, s_proxyAlreadyRevokedErrorMessage);</span>
1179         return { };
1180     }
1181 
1182     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
1183     CallData callData;
1184     CallType callType;
<span class="line-modified">1185     JSValue getPrototypeOfMethod = handler-&gt;getMethod(globalObject, callData, callType, makeIdentifier(vm, &quot;getPrototypeOf&quot;), &quot;&#39;getPrototypeOf&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
1186     RETURN_IF_EXCEPTION(scope, { });
1187 
1188     JSObject* target = this-&gt;target();
1189     if (getPrototypeOfMethod.isUndefined())
<span class="line-modified">1190         RELEASE_AND_RETURN(scope, target-&gt;getPrototype(vm, globalObject));</span>
1191 
1192     MarkedArgumentBuffer arguments;
1193     arguments.append(target);
1194     ASSERT(!arguments.hasOverflowed());
<span class="line-modified">1195     JSValue trapResult = call(globalObject, getPrototypeOfMethod, callType, callData, handler, arguments);</span>
1196     RETURN_IF_EXCEPTION(scope, { });
1197 
1198     if (!trapResult.isObject() &amp;&amp; !trapResult.isNull()) {
<span class="line-modified">1199         throwVMTypeError(globalObject, scope, &quot;Proxy handler&#39;s &#39;getPrototypeOf&#39; trap should either return an object or null&quot;_s);</span>
1200         return { };
1201     }
1202 
<span class="line-modified">1203     bool targetIsExtensible = target-&gt;isExtensible(globalObject);</span>
1204     RETURN_IF_EXCEPTION(scope, { });
1205     if (targetIsExtensible)
1206         return trapResult;
1207 
<span class="line-modified">1208     JSValue targetPrototype = target-&gt;getPrototype(vm, globalObject);</span>
<span class="line-added">1209     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">1210     bool isSame = sameValue(globalObject, targetPrototype, trapResult);</span>
1211     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">1212     if (!isSame) {</span>
<span class="line-modified">1213         throwVMTypeError(globalObject, scope, &quot;Proxy&#39;s &#39;getPrototypeOf&#39; trap for a non-extensible target should return the same value as the target&#39;s prototype&quot;_s);</span>
1214         return { };
1215     }
1216 
1217     return trapResult;
1218 }
1219 
<span class="line-modified">1220 JSValue ProxyObject::getPrototype(JSObject* object, JSGlobalObject* globalObject)</span>
1221 {
<span class="line-modified">1222     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performGetPrototype(globalObject);</span>
1223 }
1224 
1225 void ProxyObject::revoke(VM&amp; vm)
1226 {
1227     // This should only ever be called once and we should strictly transition from Object to null.
1228     RELEASE_ASSERT(!m_handler.get().isNull() &amp;&amp; m_handler.get().isObject());
1229     m_handler.set(vm, this, jsNull());
1230 }
1231 
1232 bool ProxyObject::isRevoked() const
1233 {
1234     return handler().isNull();
1235 }
1236 
1237 void ProxyObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
1238 {
1239     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
1240     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
1241     Base::visitChildren(thisObject, visitor);
1242 
</pre>
</td>
</tr>
</table>
<center><a href="ProxyConstructor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProxyObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
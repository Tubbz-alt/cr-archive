<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/opengl/GraphicsContextGLOpenGL.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2009, 2014-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(GRAPHICS_CONTEXT_GL)
 29 
 30 #include &quot;ANGLEWebKitBridge.h&quot;
 31 #include &quot;GraphicsContextGL.h&quot;
 32 #include &lt;memory&gt;
 33 #include &lt;wtf/HashCountedSet.h&gt;
 34 #include &lt;wtf/HashMap.h&gt;
 35 #include &lt;wtf/ListHashSet.h&gt;
 36 #include &lt;wtf/RetainPtr.h&gt;
 37 #include &lt;wtf/UniqueArray.h&gt;
 38 
 39 #if USE(CA)
 40 #include &quot;PlatformCALayer.h&quot;
 41 #endif
 42 
 43 // FIXME: Find a better way to avoid the name confliction for NO_ERROR.
 44 #if PLATFORM(WIN)
 45 #undef NO_ERROR
 46 #elif PLATFORM(GTK)
 47 // This define is from the X11 headers, but it&#39;s used below, so we must undefine it.
 48 #undef VERSION
 49 #endif
 50 
 51 #if PLATFORM(COCOA)
 52 #if USE(OPENGL_ES)
 53 #include &lt;OpenGLES/ES2/gl.h&gt;
 54 #ifdef __OBJC__
 55 #import &lt;OpenGLES/EAGL.h&gt;
 56 #endif // __OBJC__
 57 #endif // USE(OPENGL_ES)
 58 OBJC_CLASS CALayer;
 59 OBJC_CLASS WebGLLayer;
 60 typedef struct __IOSurface* IOSurfaceRef;
 61 #endif // PLATFORM(COCOA)
 62 
 63 #if USE(NICOSIA)
 64 namespace Nicosia {
 65 class GC3DLayer;
 66 }
 67 #endif
 68 
 69 namespace WebCore {
 70 class ExtensionsGL;
 71 #if USE(ANGLE)
 72 class ExtensionsGLANGLE;
 73 #elif !PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
 74 class ExtensionsGLOpenGLES;
 75 #elif USE(OPENGL) || (PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES))
 76 class ExtensionsGLOpenGL;
 77 #endif
 78 class HostWindow;
 79 class ImageBuffer;
 80 class ImageData;
 81 #if USE(TEXTURE_MAPPER)
 82 class TextureMapperGC3DPlatformLayer;
 83 #endif
 84 
 85 typedef WTF::HashMap&lt;CString, uint64_t&gt; ShaderNameHash;
 86 
 87 class GraphicsContextGLOpenGLPrivate;
 88 
 89 class GraphicsContextGLOpenGL : public GraphicsContextGL {
 90 public:
 91     class Client {
 92     public:
 93         virtual ~Client() { }
 94         virtual void didComposite() = 0;
 95         virtual void forceContextLost() = 0;
 96         virtual void recycleContext() = 0;
 97         virtual void dispatchContextChangedNotification() = 0;
 98     };
 99 
100     static RefPtr&lt;GraphicsContextGLOpenGL&gt; create(GraphicsContextGLAttributes, HostWindow*, Destination = Destination::Offscreen);
101     virtual ~GraphicsContextGLOpenGL();
102 
103 #if PLATFORM(COCOA)
104     static Ref&lt;GraphicsContextGLOpenGL&gt; createShared(GraphicsContextGLOpenGL&amp; sharedContext);
105 #endif
106 
107 #if PLATFORM(COCOA)
108     PlatformGraphicsContextGL platformGraphicsContextGL() const override { return m_contextObj; }
109     PlatformGLObject platformTexture() const override { return m_texture; }
110     CALayer* platformLayer() const override { return reinterpret_cast&lt;CALayer*&gt;(m_webGLLayer.get()); }
111 #if USE(ANGLE)
112     PlatformGraphicsContextGLDisplay platformDisplay() const { return m_displayObj; }
113     PlatformGraphicsContextGLConfig platformConfig() const { return m_configObj; }
114 #endif // USE(ANGLE)
115 #else
116     PlatformGraphicsContextGL platformGraphicsContextGL() const final;
117     PlatformGLObject platformTexture() const final;
118     PlatformLayer* platformLayer() const final;
119 #endif
120 
121     bool makeContextCurrent();
122 
123     void addClient(Client&amp; client) { m_clients.add(&amp;client); }
124     void removeClient(Client&amp; client) { m_clients.remove(&amp;client); }
125 
126     // With multisampling on, blit from multisampleFBO to regular FBO.
127     void prepareTexture();
128 
129     // Equivalent to ::glTexImage2D(). Allows pixels==0 with no allocation.
130     void texImage2DDirect(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels);
131 
132     // Get an attribute location without checking the name -&gt; mangledname mapping.
133     int getAttribLocationDirect(PlatformGLObject program, const String&amp; name);
134 
135     // Compile a shader without going through ANGLE.
136     void compileShaderDirect(PlatformGLObject);
137 
138     // Helper to texImage2D with pixel==0 case: pixels are initialized to 0.
139     // Return true if no GL error is synthesized.
140     // By default, alignment is 4, the OpenGL default setting.
141     bool texImage2DResourceSafe(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, GCGLint alignment = 4);
142 
143     bool isGLES2Compliant() const;
144 
145     //----------------------------------------------------------------------
146     // Helpers for texture uploading and pixel readback.
147     //
148 
149     // Computes the components per pixel and bytes per component
150     // for the given format and type combination. Returns false if
151     // either was an invalid enum.
152     static bool computeFormatAndTypeParameters(GCGLenum format,
153         GCGLenum type,
154         unsigned* componentsPerPixel,
155         unsigned* bytesPerComponent);
156 
157     // Computes the image size in bytes. If paddingInBytes is not null, padding
158     // is also calculated in return. Returns NO_ERROR if succeed, otherwise
159     // return the suggested GL error indicating the cause of the failure:
160     //   INVALID_VALUE if width/height is negative or overflow happens.
161     //   INVALID_ENUM if format/type is illegal.
162     static GCGLenum computeImageSizeInBytes(GCGLenum format,
163         GCGLenum type,
164         GCGLsizei width,
165         GCGLsizei height,
166         GCGLint alignment,
167         unsigned* imageSizeInBytes,
168         unsigned* paddingInBytes);
169 
170     static bool possibleFormatAndTypeForInternalFormat(GCGLenum internalFormat, GCGLenum&amp; format, GCGLenum&amp; type);
171 
172     // Extracts the contents of the given ImageData into the passed Vector,
173     // packing the pixel data according to the given format and type,
174     // and obeying the flipY and premultiplyAlpha flags. Returns true
175     // upon success.
176     static bool extractImageData(ImageData*,
177         GCGLenum format,
178         GCGLenum type,
179         bool flipY,
180         bool premultiplyAlpha,
181         Vector&lt;uint8_t&gt;&amp; data);
182 
183     // Helper function which extracts the user-supplied texture
184     // data, applying the flipY and premultiplyAlpha parameters.
185     // If the data is not tightly packed according to the passed
186     // unpackAlignment, the output data will be tightly packed.
187     // Returns true if successful, false if any error occurred.
188     static bool extractTextureData(unsigned width, unsigned height,
189         GCGLenum format, GCGLenum type,
190         unsigned unpackAlignment,
191         bool flipY, bool premultiplyAlpha,
192         const void* pixels,
193         Vector&lt;uint8_t&gt;&amp; data);
194 
195     //----------------------------------------------------------------------
196     // Entry points for WebGL.
197     //
198 
199     void activeTexture(GCGLenum texture) final;
200     void attachShader(PlatformGLObject program, PlatformGLObject shader) final;
201     void bindAttribLocation(PlatformGLObject, GCGLuint index, const String&amp; name) final;
202     void bindBuffer(GCGLenum target, PlatformGLObject) final;
203     void bindFramebuffer(GCGLenum target, PlatformGLObject) final;
204     void bindRenderbuffer(GCGLenum target, PlatformGLObject) final;
205     void bindTexture(GCGLenum target, PlatformGLObject) final;
206     void blendColor(GCGLclampf red, GCGLclampf green, GCGLclampf blue, GCGLclampf alpha) final;
207     void blendEquation(GCGLenum mode) final;
208     void blendEquationSeparate(GCGLenum modeRGB, GCGLenum modeAlpha) final;
209     void blendFunc(GCGLenum sfactor, GCGLenum dfactor) final;
210     void blendFuncSeparate(GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha) final;
211 
212     void bufferData(GCGLenum target, GCGLsizeiptr size, GCGLenum usage) final;
213     void bufferData(GCGLenum target, GCGLsizeiptr size, const void* data, GCGLenum usage) final;
214     void bufferSubData(GCGLenum target, GCGLintptr offset, GCGLsizeiptr size, const void* data) final;
215 
216     GCGLenum checkFramebufferStatus(GCGLenum target) final;
217     void clear(GCGLbitfield mask) final;
218     void clearColor(GCGLclampf red, GCGLclampf green, GCGLclampf blue, GCGLclampf alpha) final;
219     void clearDepth(GCGLclampf depth) final;
220     void clearStencil(GCGLint s) final;
221     void colorMask(GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha) final;
222     void compileShader(PlatformGLObject) final;
223 
224     void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, const void* data) final;
225     void compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLsizei imageSize, const void* data) final;
226     void copyTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLint border) final;
227     void copyTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height) final;
228     void cullFace(GCGLenum mode) final;
229     void depthFunc(GCGLenum func) final;
230     void depthMask(GCGLboolean flag) final;
231     void depthRange(GCGLclampf zNear, GCGLclampf zFar) final;
232     void detachShader(PlatformGLObject, PlatformGLObject) final;
233     void disable(GCGLenum cap) final;
234     void disableVertexAttribArray(GCGLuint index) final;
235     void drawArrays(GCGLenum mode, GCGLint first, GCGLsizei count) final;
236     void drawElements(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLintptr offset) final;
237 
238     void enable(GCGLenum cap) final;
239     void enableVertexAttribArray(GCGLuint index) final;
240     void finish() final;
241     void flush() final;
242     void framebufferRenderbuffer(GCGLenum target, GCGLenum attachment, GCGLenum renderbuffertarget, PlatformGLObject) final;
243     void framebufferTexture2D(GCGLenum target, GCGLenum attachment, GCGLenum textarget, PlatformGLObject, GCGLint level) final;
244     void frontFace(GCGLenum mode) final;
245     void generateMipmap(GCGLenum target) final;
246 
247     bool getActiveAttrib(PlatformGLObject program, GCGLuint index, ActiveInfo&amp;) final;
248     bool getActiveAttribImpl(PlatformGLObject program, GCGLuint index, ActiveInfo&amp;);
249     bool getActiveUniform(PlatformGLObject program, GCGLuint index, ActiveInfo&amp;) final;
250     bool getActiveUniformImpl(PlatformGLObject program, GCGLuint index, ActiveInfo&amp;);
251     void getAttachedShaders(PlatformGLObject program, GCGLsizei maxCount, GCGLsizei* count, PlatformGLObject* shaders) final;
252     GCGLint getAttribLocation(PlatformGLObject, const String&amp; name) final;
253     void getBooleanv(GCGLenum pname, GCGLboolean* value) final;
254     void getBufferParameteriv(GCGLenum target, GCGLenum pname, GCGLint* value) final;
255     GCGLenum getError() final;
256     void getFloatv(GCGLenum pname, GCGLfloat* value) final;
257     void getFramebufferAttachmentParameteriv(GCGLenum target, GCGLenum attachment, GCGLenum pname, GCGLint* value) final;
258     void getIntegerv(GCGLenum pname, GCGLint* value) final;
259     void getInteger64v(GCGLenum pname, GCGLint64* value) final;
260     void getProgramiv(PlatformGLObject program, GCGLenum pname, GCGLint* value) final;
261 #if !USE(ANGLE)
262     void getNonBuiltInActiveSymbolCount(PlatformGLObject program, GCGLenum pname, GCGLint* value);
263 #endif // !USE(ANGLE)
264     String getProgramInfoLog(PlatformGLObject) final;
265     String getUnmangledInfoLog(PlatformGLObject[2], GCGLsizei, const String&amp;);
266     void getRenderbufferParameteriv(GCGLenum target, GCGLenum pname, GCGLint* value) final;
267     void getShaderiv(PlatformGLObject, GCGLenum pname, GCGLint* value) final;
268     String getShaderInfoLog(PlatformGLObject) final;
269     void getShaderPrecisionFormat(GCGLenum shaderType, GCGLenum precisionType, GCGLint* range, GCGLint* precision) final;
270     String getShaderSource(PlatformGLObject) final;
271     String getString(GCGLenum name) final;
272     void getTexParameterfv(GCGLenum target, GCGLenum pname, GCGLfloat* value) final;
273     void getTexParameteriv(GCGLenum target, GCGLenum pname, GCGLint* value) final;
274     void getUniformfv(PlatformGLObject program, GCGLint location, GCGLfloat* value) final;
275     void getUniformiv(PlatformGLObject program, GCGLint location, GCGLint* value) final;
276     GCGLint getUniformLocation(PlatformGLObject, const String&amp; name) final;
277     void getVertexAttribfv(GCGLuint index, GCGLenum pname, GCGLfloat* value) final;
278     void getVertexAttribiv(GCGLuint index, GCGLenum pname, GCGLint* value) final;
279     GCGLsizeiptr getVertexAttribOffset(GCGLuint index, GCGLenum pname) final;
280 
281     void hint(GCGLenum target, GCGLenum mode) final;
282     GCGLboolean isBuffer(PlatformGLObject) final;
283     GCGLboolean isEnabled(GCGLenum cap) final;
284     GCGLboolean isFramebuffer(PlatformGLObject) final;
285     GCGLboolean isProgram(PlatformGLObject) final;
286     GCGLboolean isRenderbuffer(PlatformGLObject) final;
287     GCGLboolean isShader(PlatformGLObject) final;
288     GCGLboolean isTexture(PlatformGLObject) final;
289     void lineWidth(GCGLfloat) final;
290     void linkProgram(PlatformGLObject) final;
291     void pixelStorei(GCGLenum pname, GCGLint param) final;
292     void polygonOffset(GCGLfloat factor, GCGLfloat units) final;
293 
294     void readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, void* data) final;
295 
296     void releaseShaderCompiler();
297 
298     void renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height) final;
299     void sampleCoverage(GCGLclampf value, GCGLboolean invert) final;
300     void scissor(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height) final;
301     void shaderSource(PlatformGLObject, const String&amp; string) final;
302     void stencilFunc(GCGLenum func, GCGLint ref, GCGLuint mask) final;
303     void stencilFuncSeparate(GCGLenum face, GCGLenum func, GCGLint ref, GCGLuint mask) final;
304     void stencilMask(GCGLuint mask) final;
305     void stencilMaskSeparate(GCGLenum face, GCGLuint mask) final;
306     void stencilOp(GCGLenum fail, GCGLenum zfail, GCGLenum zpass) final;
307     void stencilOpSeparate(GCGLenum face, GCGLenum fail, GCGLenum zfail, GCGLenum zpass) final;
308 
309     bool texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels) final;
310     void texParameterf(GCGLenum target, GCGLenum pname, GCGLfloat param) final;
311     void texParameteri(GCGLenum target, GCGLenum pname, GCGLint param) final;
312     void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, const void* pixels) final;
313 
314     void uniform1f(GCGLint location, GCGLfloat x) final;
315     void uniform1fv(GCGLint location, GCGLsizei, const GCGLfloat* v) final;
316     void uniform1i(GCGLint location, GCGLint x) final;
317     void uniform1iv(GCGLint location, GCGLsizei, const GCGLint* v) final;
318     void uniform2f(GCGLint location, GCGLfloat x, GCGLfloat y) final;
319     void uniform2fv(GCGLint location, GCGLsizei, const GCGLfloat* v) final;
320     void uniform2i(GCGLint location, GCGLint x, GCGLint y) final;
321     void uniform2iv(GCGLint location, GCGLsizei, const GCGLint* v) final;
322     void uniform3f(GCGLint location, GCGLfloat x, GCGLfloat y, GCGLfloat z) final;
323     void uniform3fv(GCGLint location, GCGLsizei, const GCGLfloat* v) final;
324     void uniform3i(GCGLint location, GCGLint x, GCGLint y, GCGLint z) final;
325     void uniform3iv(GCGLint location, GCGLsizei, const GCGLint* v) final;
326     void uniform4f(GCGLint location, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w) final;
327     void uniform4fv(GCGLint location, GCGLsizei, const GCGLfloat* v) final;
328     void uniform4i(GCGLint location, GCGLint x, GCGLint y, GCGLint z, GCGLint w) final;
329     void uniform4iv(GCGLint location, GCGLsizei, const GCGLint* v) final;
330     void uniformMatrix2fv(GCGLint location, GCGLsizei, GCGLboolean transpose, const GCGLfloat* value) final;
331     void uniformMatrix3fv(GCGLint location, GCGLsizei, GCGLboolean transpose, const GCGLfloat* value) final;
332     void uniformMatrix4fv(GCGLint location, GCGLsizei, GCGLboolean transpose, const GCGLfloat* value) final;
333 
334     void useProgram(PlatformGLObject) final;
335     void validateProgram(PlatformGLObject) final;
336 #if !USE(ANGLE)
337     bool checkVaryingsPacking(PlatformGLObject vertexShader, PlatformGLObject fragmentShader) const;
338     bool precisionsMatch(PlatformGLObject vertexShader, PlatformGLObject fragmentShader) const;
339 #endif
340 
341     void vertexAttrib1f(GCGLuint index, GCGLfloat x) final;
342     void vertexAttrib1fv(GCGLuint index, const GCGLfloat* values) final;
343     void vertexAttrib2f(GCGLuint index, GCGLfloat x, GCGLfloat y) final;
344     void vertexAttrib2fv(GCGLuint index, const GCGLfloat* values) final;
345     void vertexAttrib3f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z) final;
346     void vertexAttrib3fv(GCGLuint index, const GCGLfloat* values) final;
347     void vertexAttrib4f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w) final;
348     void vertexAttrib4fv(GCGLuint index, const GCGLfloat* values) final;
349     void vertexAttribPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLboolean normalized, GCGLsizei stride, GCGLintptr offset) final;
350 
351     void viewport(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height) final;
352 
353     void reshape(int width, int height);
354 
355     void drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount) final;
356     void drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLintptr offset, GCGLsizei primcount) final;
357     void vertexAttribDivisor(GCGLuint index, GCGLuint divisor) final;
358 
359     // VertexArrayOject calls
360     PlatformGLObject createVertexArray() final;
361     void deleteVertexArray(PlatformGLObject) final;
362     GCGLboolean isVertexArray(PlatformGLObject) final;
363     void bindVertexArray(PlatformGLObject) final;
364 
365     // ========== WebGL2 entry points.
366 
367     void bufferData(GCGLenum target, const void* data, GCGLenum usage, GCGLuint srcOffset, GCGLuint length) final;
368     void bufferSubData(GCGLenum target, GCGLintptr dstByteOffset, const void* srcData, GCGLuint srcOffset, GCGLuint length) final;
369 
370     void copyBufferSubData(GCGLenum readTarget, GCGLenum writeTarget, GCGLintptr readOffset, GCGLintptr writeOffset, GCGLsizeiptr size) final;
371     void getBufferSubData(GCGLenum target, GCGLintptr srcByteOffset, const void* dstData, GCGLuint dstOffset, GCGLuint length) final;
372     void* mapBufferRange(GCGLenum target, GCGLintptr offset, GCGLsizeiptr length, GCGLbitfield access) final;
373     GCGLboolean unmapBuffer(GCGLenum target) final;
374 
375     void blitFramebuffer(GCGLint srcX0, GCGLint srcY0, GCGLint srcX1, GCGLint srcY1, GCGLint dstX0, GCGLint dstY0, GCGLint dstX1, GCGLint dstY1, GCGLbitfield mask, GCGLenum filter) final;
376     void framebufferTextureLayer(GCGLenum target, GCGLenum attachment, PlatformGLObject texture, GCGLint level, GCGLint layer) final;
377     void invalidateFramebuffer(GCGLenum target, const Vector&lt;GCGLenum&gt;&amp; attachments) final;
378     void invalidateSubFramebuffer(GCGLenum target, const Vector&lt;GCGLenum&gt;&amp; attachments, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height) final;
379     void readBuffer(GCGLenum src) final;
380 
381     // getInternalFormatParameter
382     void getInternalformativ(GCGLenum target, GCGLenum internalformat, GCGLenum pname, GCGLsizei bufSize, GCGLint* params) final;
383     void renderbufferStorageMultisample(GCGLenum target, GCGLsizei samples, GCGLenum internalformat, GCGLsizei width, GCGLsizei height) final;
384 
385     void texStorage2D(GCGLenum target, GCGLsizei levels, GCGLenum internalformat, GCGLsizei width, GCGLsizei height) final;
386     void texStorage3D(GCGLenum target, GCGLsizei levels, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth) final;
387 
388     void texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, GCGLintptr pboOffset) final;
389     void texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels) final;
390     void texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, const void* srcData, GCGLuint srcOffset) final;
391 
392     void texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, GCGLintptr pboOffset) final;
393     void texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, const void* srcData, GCGLuint srcOffset) final;
394 
395     void copyTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height) final;
396 
397     void compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLsizei imageSize, GCGLintptr offset) final;
398     void compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride) final;
399     void compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLsizei imageSize, GCGLintptr offset) final;
400     void compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride) final;
401 
402     GCGLint getFragDataLocation(PlatformGLObject program, const String&amp; name) final;
403 
404     void uniform1ui(GCGLint location, GCGLuint v0) final;
405     void uniform2ui(GCGLint location, GCGLuint v0, GCGLuint v1) final;
406     void uniform3ui(GCGLint location, GCGLuint v0, GCGLuint v1, GCGLuint v2) final;
407     void uniform4ui(GCGLint location, GCGLuint v0, GCGLuint v1, GCGLuint v2, GCGLuint v3) final;
408     void uniform1uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength) final;
409     void uniform2uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength) final;
410     void uniform3uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength) final;
411     void uniform4uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength) final;
412     void uniformMatrix2x3fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) final;
413     void uniformMatrix3x2fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) final;
414     void uniformMatrix2x4fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) final;
415     void uniformMatrix4x2fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) final;
416     void uniformMatrix3x4fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) final;
417     void uniformMatrix4x3fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) final;
418     void vertexAttribI4i(GCGLuint index, GCGLint x, GCGLint y, GCGLint z, GCGLint w) final;
419     void vertexAttribI4iv(GCGLuint index, const GCGLint* values) final;
420     void vertexAttribI4ui(GCGLuint index, GCGLuint x, GCGLuint y, GCGLuint z, GCGLuint w) final;
421     void vertexAttribI4uiv(GCGLuint index, const GCGLuint* values) final;
422     void vertexAttribIPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLsizei stride, GCGLintptr offset) final;
423 
424     void drawRangeElements(GCGLenum mode, GCGLuint start, GCGLuint end, GCGLsizei count, GCGLenum type, GCGLintptr offset) final;
425 
426     void drawBuffers(const Vector&lt;GCGLenum&gt;&amp; buffers) final;
427     void clearBufferiv(GCGLenum buffer, GCGLint drawbuffer, const GCGLint* values, GCGLuint srcOffset) final;
428     void clearBufferuiv(GCGLenum buffer, GCGLint drawbuffer, const GCGLuint* values, GCGLuint srcOffset) final;
429     void clearBufferfv(GCGLenum buffer, GCGLint drawbuffer, const GCGLfloat* values, GCGLuint srcOffset) final;
430     void clearBufferfi(GCGLenum buffer, GCGLint drawbuffer, GCGLfloat depth, GCGLint stencil) final;
431 
432     PlatformGLObject createQuery() final;
433     void deleteQuery(PlatformGLObject query) final;
434     GCGLboolean isQuery(PlatformGLObject query) final;
435     void beginQuery(GCGLenum target, PlatformGLObject query) final;
436     void endQuery(GCGLenum target) final;
437     PlatformGLObject getQuery(GCGLenum target, GCGLenum pname) final;
438     // getQueryParameter
439     void getQueryObjectuiv(PlatformGLObject query, GCGLenum pname, GCGLuint* value) final;
440 
441     PlatformGLObject createSampler() final;
442     void deleteSampler(PlatformGLObject sampler) final;
443     GCGLboolean isSampler(PlatformGLObject sampler) final;
444     void bindSampler(GCGLuint unit, PlatformGLObject sampler) final;
445     void samplerParameteri(PlatformGLObject sampler, GCGLenum pname, GCGLint param) final;
446     void samplerParameterf(PlatformGLObject sampler, GCGLenum pname, GCGLfloat param) final;
447     // getSamplerParameter
448     void getSamplerParameterfv(PlatformGLObject sampler, GCGLenum pname, GCGLfloat* value) final;
449     void getSamplerParameteriv(PlatformGLObject sampler, GCGLenum pname, GCGLint* value) final;
450 
451     PlatformGLObject fenceSync(GCGLenum condition, GCGLbitfield flags) final;
452     GCGLboolean isSync(PlatformGLObject sync) final;
453     void deleteSync(PlatformGLObject sync) final;
454     GCGLenum clientWaitSync(PlatformGLObject sync, GCGLbitfield flags, GCGLuint64 timeout) final;
455     void waitSync(PlatformGLObject sync, GCGLbitfield flags, GCGLint64 timeout) final;
456     // getSyncParameter
457     // FIXME - this can be implemented at the WebGL level if we signal the WebGLSync object.
458     void getSynciv(PlatformGLObject sync, GCGLenum pname, GCGLsizei bufSize, GCGLint *value) final;
459 
460     PlatformGLObject createTransformFeedback() final;
461     void deleteTransformFeedback(PlatformGLObject id) final;
462     GCGLboolean isTransformFeedback(PlatformGLObject id) final;
463     void bindTransformFeedback(GCGLenum target, PlatformGLObject id) final;
464     void beginTransformFeedback(GCGLenum primitiveMode) final;
465     void endTransformFeedback() final;
466     void transformFeedbackVaryings(PlatformGLObject program, const Vector&lt;String&gt;&amp; varyings, GCGLenum bufferMode) final;
467     void getTransformFeedbackVarying(PlatformGLObject program, GCGLuint index, ActiveInfo&amp;) final;
468     void pauseTransformFeedback() final;
469     void resumeTransformFeedback() final;
470 
471     void bindBufferBase(GCGLenum target, GCGLuint index, PlatformGLObject buffer) final;
472     void bindBufferRange(GCGLenum target, GCGLuint index, PlatformGLObject buffer, GCGLintptr offset, GCGLsizeiptr size) final;
473     // getIndexedParameter -&gt; use getParameter calls above.
474     Vector&lt;GCGLuint&gt; getUniformIndices(PlatformGLObject program, const Vector&lt;String&gt;&amp; uniformNames) final;
475     void getActiveUniforms(PlatformGLObject program, const Vector&lt;GCGLuint&gt;&amp; uniformIndices, GCGLenum pname, Vector&lt;GCGLint&gt;&amp; params) final;
476 
477     GCGLuint getUniformBlockIndex(PlatformGLObject program, const String&amp; uniformBlockName) final;
478     // getActiveUniformBlockParameter
479     void getActiveUniformBlockiv(PlatformGLObject program, GCGLuint uniformBlockIndex, GCGLenum pname, GCGLint* params) final;
480     String getActiveUniformBlockName(PlatformGLObject program, GCGLuint uniformBlockIndex) final;
481     void uniformBlockBinding(PlatformGLObject program, GCGLuint uniformBlockIndex, GCGLuint uniformBlockBinding) final;
482 
483     void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, GCGLintptr pboOffset) final;
484     void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, const void* srcData, GCGLuint srcOffset) final;
485 
486     void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, GCGLintptr offset) final;
487     void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride) final;
488 
489     void compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLsizei imageSize, GCGLintptr offset) final;
490     void compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride) final;
491 
492     void uniform1fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) final;
493     void uniform2fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) final;
494     void uniform3fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) final;
495     void uniform4fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) final;
496 
497     void uniform1iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength) final;
498     void uniform2iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength) final;
499     void uniform3iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength) final;
500     void uniform4iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength) final;
501 
502     void uniformMatrix2fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) final;
503     void uniformMatrix3fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) final;
504     void uniformMatrix4fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength) final;
505 
506     void readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, GCGLintptr offset) final;
507     void readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, const void* dstData, GCGLuint dstOffset) final;
508 
509     // Helper methods.
510 
511     void paintToCanvas(const unsigned char* imagePixels, const IntSize&amp; imageSize, const IntSize&amp; canvasSize, GraphicsContext&amp;);
512 
513     void markContextChanged();
514     void markLayerComposited();
515     bool layerComposited() const;
516     void forceContextLost();
517     void recycleContext();
518 
519     void dispatchContextChangedNotification();
520     void simulateContextChanged();
521 
522     void paintRenderingResultsToCanvas(ImageBuffer*);
523     RefPtr&lt;ImageData&gt; paintRenderingResultsToImageData();
524     bool paintCompositedResultsToCanvas(ImageBuffer*);
525 
526 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
527     void primitiveRestartIndex(GCGLuint) final;
528 #endif
529 
530 #if PLATFORM(COCOA)
531     bool texImageIOSurface2D(GCGLenum target, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, IOSurfaceRef, GCGLuint plane);
532 
533 #if USE(OPENGL_ES)
534     void presentRenderbuffer();
535 #endif
536 
537 #if USE(OPENGL) || USE(ANGLE)
538     void allocateIOSurfaceBackingStore(IntSize);
539     void updateFramebufferTextureBackingStoreFromLayer();
540 #if PLATFORM(MAC) || PLATFORM(MACCATALYST)
541     void updateCGLContext();
542 #endif
543 #endif
544 #endif // PLATFORM(COCOA)
545 
546     void setContextVisibility(bool);
547 
548     GraphicsContextGLPowerPreference powerPreferenceUsedForCreation() const { return m_powerPreferenceUsedForCreation; }
549 
550     // Support for buffer creation and deletion
551     PlatformGLObject createBuffer() final;
552     PlatformGLObject createFramebuffer() final;
553     PlatformGLObject createProgram() final;
554     PlatformGLObject createRenderbuffer() final;
555     PlatformGLObject createShader(GCGLenum) final;
556     PlatformGLObject createTexture() final;
557 
558     void deleteBuffer(PlatformGLObject) final;
559     void deleteFramebuffer(PlatformGLObject) final;
560     void deleteProgram(PlatformGLObject) final;
561     void deleteRenderbuffer(PlatformGLObject) final;
562     void deleteShader(PlatformGLObject) final;
563     void deleteTexture(PlatformGLObject) final;
564 
565     // Synthesizes an OpenGL error which will be returned from a
566     // later call to getError. This is used to emulate OpenGL ES
567     // 2.0 behavior on the desktop and to enforce additional error
568     // checking mandated by WebGL.
569     //
570     // Per the behavior of glGetError, this stores at most one
571     // instance of any given error, and returns them from calls to
572     // getError in the order they were added.
573     void synthesizeGLError(GCGLenum error);
574 
575     // Read real OpenGL errors, and move them to the synthetic
576     // error list. Return true if at least one error is moved.
577     bool moveErrorsToSyntheticErrorList();
578 
579     // Support for extensions. Returns a non-null object, though not
580     // all methods it contains may necessarily be supported on the
581     // current hardware. Must call ExtensionsGL::supports() to
582     // determine this.
583     ExtensionsGL&amp; getExtensions() final;
584 
585     IntSize getInternalFramebufferSize() const;
586 
587     // Packs the contents of the given Image which is passed in |pixels| into the passed Vector
588     // according to the given format and type, and obeying the flipY and AlphaOp flags.
589     // Returns true upon success.
590     static bool packImageData(Image*, const void* pixels, GCGLenum format, GCGLenum type, bool flipY, AlphaOp, DataFormat sourceFormat, unsigned width, unsigned height, unsigned sourceUnpackAlignment, Vector&lt;uint8_t&gt;&amp; data);
591 
592     class ImageExtractor {
593     public:
594         ImageExtractor(Image*, DOMSource, bool premultiplyAlpha, bool ignoreGammaAndColorProfile);
595 
596         // Each platform must provide an implementation of this method to deallocate or release resources
597         // associated with the image if needed.
598         ~ImageExtractor();
599 
600         bool extractSucceeded() { return m_extractSucceeded; }
601         const void* imagePixelData() { return m_imagePixelData; }
602         unsigned imageWidth() { return m_imageWidth; }
603         unsigned imageHeight() { return m_imageHeight; }
604         DataFormat imageSourceFormat() { return m_imageSourceFormat; }
605         AlphaOp imageAlphaOp() { return m_alphaOp; }
606         unsigned imageSourceUnpackAlignment() { return m_imageSourceUnpackAlignment; }
607         DOMSource imageHtmlDomSource() { return m_imageHtmlDomSource; }
608     private:
609         // Each platform must provide an implementation of this method.
610         // Extracts the image and keeps track of its status, such as width, height, Source Alignment, format and AlphaOp etc,
611         // needs to lock the resources or relevant data if needed and returns true upon success
612         bool extractImage(bool premultiplyAlpha, bool ignoreGammaAndColorProfile);
613 
614 #if USE(CAIRO)
615         RefPtr&lt;cairo_surface_t&gt; m_imageSurface;
616 #elif USE(CG)
617         RetainPtr&lt;CGImageRef&gt; m_cgImage;
618         RetainPtr&lt;CGImageRef&gt; m_decodedImage;
619         RetainPtr&lt;CFDataRef&gt; m_pixelData;
620         UniqueArray&lt;uint8_t&gt; m_formalizedRGBA8Data;
621 #endif
622         Image* m_image;
623         DOMSource m_imageHtmlDomSource;
624         bool m_extractSucceeded;
625         const void* m_imagePixelData;
626         unsigned m_imageWidth;
627         unsigned m_imageHeight;
628         DataFormat m_imageSourceFormat;
629         AlphaOp m_alphaOp;
630         unsigned m_imageSourceUnpackAlignment;
631     };
632 
633     void setFailNextGPUStatusCheck() { m_failNextStatusCheck = true; }
634 
635     GCGLenum activeTextureUnit() const { return m_state.activeTextureUnit; }
636     GCGLenum currentBoundTexture() const { return m_state.currentBoundTexture(); }
637     GCGLenum currentBoundTarget() const { return m_state.currentBoundTarget(); }
638     unsigned textureSeed(GCGLuint texture) { return m_state.textureSeedCount.count(texture); }
639 
640 #if PLATFORM(MAC)
641     using PlatformDisplayID = uint32_t;
642     void screenDidChange(PlatformDisplayID);
643 #endif
644 
645 private:
646     GraphicsContextGLOpenGL(GraphicsContextGLAttributes, HostWindow*, Destination = Destination::Offscreen, GraphicsContextGLOpenGL* sharedContext = nullptr);
647 
648     // Helper for packImageData/extractImageData/extractTextureData which implement packing of pixel
649     // data into the specified OpenGL destination format and type.
650     // A sourceUnpackAlignment of zero indicates that the source
651     // data is tightly packed. Non-zero values may take a slow path.
652     // Destination data will have no gaps between rows.
653     static bool packPixels(const uint8_t* sourceData, DataFormat sourceDataFormat, unsigned width, unsigned height, unsigned sourceUnpackAlignment, unsigned destinationFormat, unsigned destinationType, AlphaOp, void* destinationData, bool flipY);
654 
655     // Take into account the user&#39;s requested context creation attributes,
656     // in particular stencil and antialias, and determine which could or
657     // could not be honored based on the capabilities of the OpenGL
658     // implementation.
659     void validateDepthStencil(const char* packedDepthStencilExtension);
660     void validateAttributes();
661 
662     // Did the most recent drawing operation leave the GPU in an acceptable state?
663     void checkGPUStatus();
664 
665     // Read rendering results into a pixel array with the same format as the
666     // backbuffer.
667     void readRenderingResults(unsigned char* pixels, int pixelsSize);
668     void readPixelsAndConvertToBGRAIfNecessary(int x, int y, int width, int height, unsigned char* pixels);
669 
670 #if USE(OPENGL_ES)
671     void setRenderbufferStorageFromDrawable(GCGLsizei width, GCGLsizei height);
672 #endif
673 
674     bool reshapeFBOs(const IntSize&amp;);
675     void resolveMultisamplingIfNecessary(const IntRect&amp; = IntRect());
676     void attachDepthAndStencilBufferIfNeeded(GLuint internalDepthStencilFormat, int width, int height);
677 
678 #if PLATFORM(COCOA)
679     bool allowOfflineRenderers() const;
680 #endif
681 
682     int m_currentWidth { 0 };
683     int m_currentHeight { 0 };
684 
685 #if PLATFORM(COCOA)
686     RetainPtr&lt;WebGLLayer&gt; m_webGLLayer;
687     PlatformGraphicsContextGL m_contextObj { nullptr };
688 #if USE(ANGLE)
689     PlatformGraphicsContextGLDisplay m_displayObj { nullptr };
690     PlatformGraphicsContextGLConfig m_configObj { nullptr };
691 #endif // USE(ANGLE)
692 #endif // PLATFORM(COCOA)
693 
694 #if PLATFORM(WIN) &amp;&amp; USE(CA)
695     RefPtr&lt;PlatformCALayer&gt; m_webGLLayer;
696 #endif
697 
698     typedef HashMap&lt;String, sh::ShaderVariable&gt; ShaderSymbolMap;
699 
700     struct ShaderSourceEntry {
701         GCGLenum type;
702         String source;
703         String translatedSource;
704         String log;
705         bool isValid;
706         ShaderSymbolMap attributeMap;
707         ShaderSymbolMap uniformMap;
708         ShaderSymbolMap varyingMap;
709         ShaderSourceEntry()
710             : type(VERTEX_SHADER)
711             , isValid(false)
712         {
713         }
714 
715         ShaderSymbolMap&amp; symbolMap(enum ANGLEShaderSymbolType symbolType)
716         {
717             ASSERT(symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE || symbolType == SHADER_SYMBOL_TYPE_UNIFORM || symbolType == SHADER_SYMBOL_TYPE_VARYING);
718             if (symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE)
719                 return attributeMap;
720             if (symbolType == SHADER_SYMBOL_TYPE_VARYING)
721                 return varyingMap;
722             return uniformMap;
723         }
724     };
725 
726 #if !USE(ANGLE)
727     // FIXME: Shaders are never removed from this map, even if they and their program are deleted.
728     // This is bad, and it also relies on the fact we never reuse PlatformGLObject numbers.
729     typedef HashMap&lt;PlatformGLObject, ShaderSourceEntry&gt; ShaderSourceMap;
730     ShaderSourceMap m_shaderSourceMap;
731 
732     typedef HashMap&lt;PlatformGLObject, std::pair&lt;PlatformGLObject, PlatformGLObject&gt;&gt; LinkedShaderMap;
733     LinkedShaderMap m_linkedShaderMap;
734 
735     struct ActiveShaderSymbolCounts {
736         Vector&lt;GCGLint&gt; filteredToActualAttributeIndexMap;
737         Vector&lt;GCGLint&gt; filteredToActualUniformIndexMap;
738 
739         ActiveShaderSymbolCounts()
740         {
741         }
742 
743         GCGLint countForType(GCGLenum activeType)
744         {
745             ASSERT(activeType == ACTIVE_ATTRIBUTES || activeType == ACTIVE_UNIFORMS);
746             if (activeType == ACTIVE_ATTRIBUTES)
747                 return filteredToActualAttributeIndexMap.size();
748 
749             return filteredToActualUniformIndexMap.size();
750         }
751     };
752     typedef HashMap&lt;PlatformGLObject, ActiveShaderSymbolCounts&gt; ShaderProgramSymbolCountMap;
753     ShaderProgramSymbolCountMap m_shaderProgramSymbolCountMap;
754 
755     typedef HashMap&lt;String, String&gt; HashedSymbolMap;
756     HashedSymbolMap m_possiblyUnusedAttributeMap;
757 
758     String mappedSymbolName(PlatformGLObject program, ANGLEShaderSymbolType, const String&amp; name);
759     String mappedSymbolName(PlatformGLObject shaders[2], size_t count, const String&amp; name);
760     String originalSymbolName(PlatformGLObject program, ANGLEShaderSymbolType, const String&amp; name);
761     Optional&lt;String&gt; mappedSymbolInShaderSourceMap(PlatformGLObject shader, ANGLEShaderSymbolType, const String&amp; name);
762     Optional&lt;String&gt; originalSymbolInShaderSourceMap(PlatformGLObject shader, ANGLEShaderSymbolType, const String&amp; name);
763 
764     std::unique_ptr&lt;ShaderNameHash&gt; nameHashMapForShaders;
765 #endif // !USE(ANGLE)
766 
767 #if USE(ANGLE)
768     friend class ExtensionsGLANGLE;
769     std::unique_ptr&lt;ExtensionsGLANGLE&gt; m_extensions;
770 #elif !PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
771     friend class ExtensionsGLOpenGLES;
772     friend class ExtensionsGLOpenGLCommon;
773     std::unique_ptr&lt;ExtensionsGLOpenGLES&gt; m_extensions;
774 #elif USE(OPENGL) || (PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES))
775     friend class ExtensionsGLOpenGL;
776     friend class ExtensionsGLOpenGLCommon;
777     std::unique_ptr&lt;ExtensionsGLOpenGL&gt; m_extensions;
778 #endif
779 
780     GraphicsContextGLPowerPreference m_powerPreferenceUsedForCreation { GraphicsContextGLPowerPreference::Default };
781     Vector&lt;Vector&lt;float&gt;&gt; m_vertexArray;
782 
783 #if !USE(ANGLE)
784     ANGLEWebKitBridge m_compiler;
785 #endif
786 
787     GCGLuint m_texture { 0 };
788     GCGLuint m_fbo { 0 };
789 #if USE(COORDINATED_GRAPHICS)
790     GCGLuint m_compositorTexture { 0 };
791     GCGLuint m_intermediateTexture { 0 };
792 #endif
793 
794     GCGLuint m_depthBuffer { 0 };
795     GCGLuint m_stencilBuffer { 0 };
796     GCGLuint m_depthStencilBuffer { 0 };
797 
798     bool m_layerComposited { false };
799     GCGLuint m_internalColorFormat { 0 };
800 
801 #if USE(ANGLE) &amp;&amp; PLATFORM(COCOA)
802     PlatformGraphicsContextGLSurface m_pbuffer;
803 #endif
804 
805     struct GraphicsContextGLState {
806         GCGLuint boundFBO { 0 };
807         GCGLenum activeTextureUnit { GraphicsContextGL::TEXTURE0 };
808 
809         using BoundTextureMap = HashMap&lt;GCGLenum,
810             std::pair&lt;GCGLuint, GCGLenum&gt;,
811             WTF::IntHash&lt;GCGLenum&gt;,
812             WTF::UnsignedWithZeroKeyHashTraits&lt;GCGLuint&gt;,
813             WTF::PairHashTraits&lt;WTF::UnsignedWithZeroKeyHashTraits&lt;GCGLuint&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;GCGLuint&gt;&gt;
814         &gt;;
815         BoundTextureMap boundTextureMap;
816         GCGLuint currentBoundTexture() const { return boundTexture(activeTextureUnit); }
817         GCGLuint boundTexture(GCGLenum textureUnit) const
818         {
819             auto iterator = boundTextureMap.find(textureUnit);
820             if (iterator != boundTextureMap.end())
821                 return iterator-&gt;value.first;
822             return 0;
823         }
824 
825         GCGLuint currentBoundTarget() const { return boundTarget(activeTextureUnit); }
826         GCGLenum boundTarget(GCGLenum textureUnit) const
827         {
828             auto iterator = boundTextureMap.find(textureUnit);
829             if (iterator != boundTextureMap.end())
830                 return iterator-&gt;value.second;
831             return 0;
832         }
833 
834         void setBoundTexture(GCGLenum textureUnit, GCGLuint texture, GCGLenum target)
835         {
836             boundTextureMap.set(textureUnit, std::make_pair(texture, target));
837         }
838 
839         using TextureSeedCount = HashCountedSet&lt;GCGLuint, WTF::IntHash&lt;GCGLuint&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;GCGLuint&gt;&gt;;
840         TextureSeedCount textureSeedCount;
841     };
842 
843     GraphicsContextGLState m_state;
844 
845     // For multisampling
846     GCGLuint m_multisampleFBO { 0 };
847     GCGLuint m_multisampleDepthStencilBuffer { 0 };
848     GCGLuint m_multisampleColorBuffer { 0 };
849 
850     // Errors raised by synthesizeGLError().
851     ListHashSet&lt;GCGLenum&gt; m_syntheticErrors;
852 
853 #if USE(NICOSIA) &amp;&amp; USE(TEXTURE_MAPPER)
854     friend class Nicosia::GC3DLayer;
855     std::unique_ptr&lt;Nicosia::GC3DLayer&gt; m_nicosiaLayer;
856 #elif USE(TEXTURE_MAPPER)
857     friend class TextureMapperGC3DPlatformLayer;
858     std::unique_ptr&lt;TextureMapperGC3DPlatformLayer&gt; m_texmapLayer;
859 #elif !PLATFORM(COCOA)
860     friend class GraphicsContextGLOpenGLPrivate;
861     std::unique_ptr&lt;GraphicsContextGLOpenGLPrivate&gt; m_private;
862 #endif
863 
864     HashSet&lt;Client*&gt; m_clients;
865 
866     bool m_isForWebGL2 { false };
867     bool m_usingCoreProfile { false };
868 
869     unsigned m_statusCheckCount { 0 };
870     bool m_failNextStatusCheck { false };
871 
872 #if USE(CAIRO)
873     PlatformGLObject m_vao { 0 };
874 #endif
875 
876 #if PLATFORM(COCOA) &amp;&amp; (USE(OPENGL) || USE(ANGLE))
877     bool m_hasSwitchedToHighPerformanceGPU { false };
878 #endif
879 
880 #if PLATFORM(MAC) &amp;&amp; USE(OPENGL)
881     bool m_needsFlushBeforeDeleteTextures { false };
882 #endif
883 };
884 
885 } // namespace WebCore
886 
887 #endif // ENABLE(GRAPHICS_CONTEXT_GL)
    </pre>
  </body>
</html>
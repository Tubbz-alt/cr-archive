<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSafeToExecute.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSSALoweringPhase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSafepoint.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSafeToExecute.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,10 ***</span>
<span class="line-new-header">--- 29,16 ---</span>
  
  #include &quot;DFGGraph.h&quot;
  
  namespace JSC { namespace DFG {
  
<span class="line-added">+ // This phase is used to determine if a node can safely run at a new location.</span>
<span class="line-added">+ // It is important to note that returning false does not mean it&#39;s definitely</span>
<span class="line-added">+ // wrong to run the node at the new location. In other words, returning false</span>
<span class="line-added">+ // does not imply moving the node would be invalid only that this phase could</span>
<span class="line-added">+ // not prove it is valid. Thus, it is always ok to return false.</span>
<span class="line-added">+ </span>
  template&lt;typename AbstractStateType&gt;
  class SafeToExecuteEdge {
  public:
      SafeToExecuteEdge(AbstractStateType&amp; state)
          : m_state(state)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,12 ***</span>
<span class="line-new-header">--- 63,14 ---</span>
          case ObjectUse:
          case ArrayUse:
          case FunctionUse:
          case FinalObjectUse:
          case RegExpObjectUse:
<span class="line-added">+         case PromiseObjectUse:</span>
          case ProxyObjectUse:
          case DerivedArrayUse:
<span class="line-added">+         case DateObjectUse:</span>
          case MapObjectUse:
          case SetObjectUse:
          case WeakMapObjectUse:
          case WeakSetObjectUse:
          case DataViewObjectUse:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,56 ***</span>
          // for hoisted structure checks because it can not guarantee that a particular local is not
          // the empty value.
          switch (node-&gt;op()) {
          case CheckNotEmpty:
          case CheckStructureOrEmpty:
              break;
          default:
              return false;
          }
      }
  
<span class="line-modified">!     // NOTE: This tends to lie when it comes to effectful nodes, because it knows that they aren&#39;t going to</span>
<span class="line-modified">!     // get hoisted anyway.</span>
  
      switch (node-&gt;op()) {
      case JSConstant:
      case DoubleConstant:
      case Int52Constant:
      case LazyJSConstant:
      case Identity:
      case IdentityWithProfile:
<span class="line-removed">-     case ToThis:</span>
<span class="line-removed">-     case CreateThis:</span>
<span class="line-removed">-     case ObjectCreate:</span>
<span class="line-removed">-     case ObjectKeys:</span>
      case GetCallee:
<span class="line-removed">-     case SetCallee:</span>
      case GetArgumentCountIncludingThis:
<span class="line-removed">-     case SetArgumentCountIncludingThis:</span>
      case GetRestLength:
      case GetLocal:
<span class="line-removed">-     case SetLocal:</span>
<span class="line-removed">-     case PutStack:</span>
<span class="line-removed">-     case KillStack:</span>
      case GetStack:
<span class="line-removed">-     case MovHint:</span>
<span class="line-removed">-     case ZombieHint:</span>
      case ExitOK:
      case Phantom:
<span class="line-removed">-     case Upsilon:</span>
<span class="line-removed">-     case Phi:</span>
<span class="line-removed">-     case Flush:</span>
<span class="line-removed">-     case PhantomLocal:</span>
<span class="line-removed">-     case SetArgumentDefinitely:</span>
<span class="line-removed">-     case SetArgumentMaybe:</span>
      case ArithBitNot:
      case ArithBitAnd:
      case ArithBitOr:
      case ArithBitXor:
      case ArithBitLShift:
<span class="line-modified">!     case BitRShift:</span>
      case BitURShift:
      case ValueToInt32:
      case UInt32ToNumber:
      case DoubleAsInt32:
      case ArithAdd:
<span class="line-new-header">--- 165,44 ---</span>
          // for hoisted structure checks because it can not guarantee that a particular local is not
          // the empty value.
          switch (node-&gt;op()) {
          case CheckNotEmpty:
          case CheckStructureOrEmpty:
<span class="line-added">+         case CheckArrayOrEmpty:</span>
              break;
          default:
              return false;
          }
      }
  
<span class="line-modified">!     // NOTE: This can lie when it comes to effectful nodes, because it knows that they aren&#39;t going to</span>
<span class="line-modified">!     // get hoisted anyway. Sometimes this is convenient so we can avoid branching on some internal</span>
<span class="line-added">+     // state of the node (like what some child&#39;s UseKind might be). However, nodes that are obviously</span>
<span class="line-added">+     // always effectful, we return false for, to make auditing the &quot;return true&quot; cases easier.</span>
  
      switch (node-&gt;op()) {
<span class="line-added">+     // FIXME: Audit these:</span>
<span class="line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=207075</span>
      case JSConstant:
      case DoubleConstant:
      case Int52Constant:
      case LazyJSConstant:
      case Identity:
      case IdentityWithProfile:
      case GetCallee:
      case GetArgumentCountIncludingThis:
      case GetRestLength:
      case GetLocal:
      case GetStack:
      case ExitOK:
      case Phantom:
      case ArithBitNot:
      case ArithBitAnd:
      case ArithBitOr:
      case ArithBitXor:
      case ArithBitLShift:
<span class="line-modified">!     case ArithBitRShift:</span>
      case BitURShift:
      case ValueToInt32:
      case UInt32ToNumber:
      case DoubleAsInt32:
      case ArithAdd:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,111 ***</span>
      case ArithRound:
      case ArithFloor:
      case ArithCeil:
      case ArithTrunc:
      case ArithUnary:
<span class="line-modified">!     case ValueBitAnd:</span>
<span class="line-removed">-     case ValueBitXor:</span>
<span class="line-removed">-     case ValueBitOr:</span>
<span class="line-removed">-     case ValueBitNot:</span>
<span class="line-removed">-     case ValueBitLShift:</span>
<span class="line-removed">-     case ValueNegate:</span>
<span class="line-removed">-     case ValueAdd:</span>
<span class="line-removed">-     case ValueSub:</span>
<span class="line-removed">-     case ValueMul:</span>
<span class="line-removed">-     case ValueDiv:</span>
<span class="line-removed">-     case ValueMod:</span>
<span class="line-removed">-     case ValuePow:</span>
<span class="line-removed">-     case TryGetById:</span>
<span class="line-removed">-     case DeleteById:</span>
<span class="line-removed">-     case DeleteByVal:</span>
<span class="line-removed">-     case GetById:</span>
<span class="line-removed">-     case GetByIdWithThis:</span>
<span class="line-removed">-     case GetByValWithThis:</span>
<span class="line-removed">-     case GetByIdFlush:</span>
<span class="line-removed">-     case GetByIdDirect:</span>
<span class="line-removed">-     case GetByIdDirectFlush:</span>
<span class="line-removed">-     case PutById:</span>
<span class="line-removed">-     case PutByIdFlush:</span>
<span class="line-removed">-     case PutByIdWithThis:</span>
<span class="line-removed">-     case PutByValWithThis:</span>
<span class="line-removed">-     case PutByIdDirect:</span>
<span class="line-removed">-     case PutGetterById:</span>
<span class="line-removed">-     case PutSetterById:</span>
<span class="line-removed">-     case PutGetterSetterById:</span>
<span class="line-removed">-     case PutGetterByVal:</span>
<span class="line-removed">-     case PutSetterByVal:</span>
<span class="line-removed">-     case DefineDataProperty:</span>
<span class="line-removed">-     case DefineAccessorProperty:</span>
      case CheckStructure:
      case CheckStructureOrEmpty:
      case GetExecutable:
<span class="line-removed">-     case GetButterfly:</span>
      case CallDOMGetter:
      case CallDOM:
      case CheckSubClass:
      case CheckArray:
<span class="line-modified">!     case Arrayify:</span>
<span class="line-removed">-     case ArrayifyToStructure:</span>
      case GetScope:
      case SkipScope:
      case GetGlobalObject:
      case GetGlobalThis:
      case GetClosureVar:
<span class="line-removed">-     case PutClosureVar:</span>
      case GetGlobalVar:
      case GetGlobalLexicalVariable:
<span class="line-removed">-     case PutGlobalVariable:</span>
      case CheckCell:
<span class="line-removed">-     case CheckBadCell:</span>
      case CheckNotEmpty:
      case AssertNotEmpty:
<span class="line-modified">!     case CheckStringIdent:</span>
<span class="line-removed">-     case RegExpExec:</span>
<span class="line-removed">-     case RegExpExecNonGlobalOrSticky:</span>
<span class="line-removed">-     case RegExpTest:</span>
<span class="line-removed">-     case RegExpMatchFast:</span>
<span class="line-removed">-     case RegExpMatchFastGlobal:</span>
      case CompareLess:
      case CompareLessEq:
      case CompareGreater:
      case CompareGreaterEq:
      case CompareBelow:
      case CompareBelowEq:
      case CompareEq:
      case CompareStrictEq:
      case CompareEqPtr:
      case SameValue:
<span class="line-removed">-     case Call:</span>
<span class="line-removed">-     case DirectCall:</span>
<span class="line-removed">-     case TailCallInlinedCaller:</span>
<span class="line-removed">-     case DirectTailCallInlinedCaller:</span>
<span class="line-removed">-     case Construct:</span>
<span class="line-removed">-     case DirectConstruct:</span>
<span class="line-removed">-     case CallVarargs:</span>
<span class="line-removed">-     case CallEval:</span>
<span class="line-removed">-     case TailCallVarargsInlinedCaller:</span>
<span class="line-removed">-     case TailCallForwardVarargsInlinedCaller:</span>
<span class="line-removed">-     case ConstructVarargs:</span>
<span class="line-removed">-     case LoadVarargs:</span>
<span class="line-removed">-     case CallForwardVarargs:</span>
<span class="line-removed">-     case ConstructForwardVarargs:</span>
<span class="line-removed">-     case NewObject:</span>
<span class="line-removed">-     case NewArray:</span>
<span class="line-removed">-     case NewArrayWithSize:</span>
<span class="line-removed">-     case NewArrayBuffer:</span>
<span class="line-removed">-     case NewArrayWithSpread:</span>
<span class="line-removed">-     case Spread:</span>
<span class="line-removed">-     case NewRegexp:</span>
<span class="line-removed">-     case NewSymbol:</span>
<span class="line-removed">-     case ProfileType:</span>
<span class="line-removed">-     case ProfileControlFlow:</span>
      case CheckTypeInfoFlags:
      case ParseInt:
      case OverridesHasInstance:
<span class="line-removed">-     case InstanceOf:</span>
<span class="line-removed">-     case InstanceOfCustom:</span>
      case IsEmpty:
      case IsUndefined:
      case IsUndefinedOrNull:
      case IsBoolean:
      case IsNumber:
<span class="line-new-header">--- 223,43 ---</span>
      case ArithRound:
      case ArithFloor:
      case ArithCeil:
      case ArithTrunc:
      case ArithUnary:
<span class="line-modified">!     case TryGetById: // FIXME: Audit this: https://bugs.webkit.org/show_bug.cgi?id=163834</span>
      case CheckStructure:
      case CheckStructureOrEmpty:
      case GetExecutable:
      case CallDOMGetter:
      case CallDOM:
      case CheckSubClass:
      case CheckArray:
<span class="line-modified">!     case CheckArrayOrEmpty:</span>
      case GetScope:
      case SkipScope:
      case GetGlobalObject:
      case GetGlobalThis:
      case GetClosureVar:
      case GetGlobalVar:
      case GetGlobalLexicalVariable:
      case CheckCell:
      case CheckNotEmpty:
      case AssertNotEmpty:
<span class="line-modified">!     case CheckIdent:</span>
      case CompareLess:
      case CompareLessEq:
      case CompareGreater:
      case CompareGreaterEq:
      case CompareBelow:
      case CompareBelowEq:
      case CompareEq:
      case CompareStrictEq:
      case CompareEqPtr:
      case SameValue:
      case CheckTypeInfoFlags:
      case ParseInt:
      case OverridesHasInstance:
      case IsEmpty:
      case IsUndefined:
      case IsUndefinedOrNull:
      case IsBoolean:
      case IsNumber:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,158 ***</span>
      case IsFunction:
      case IsCellWithType:
      case IsTypedArrayView:
      case TypeOf:
      case LogicalNot:
<span class="line-removed">-     case CallObjectConstructor:</span>
<span class="line-removed">-     case ToPrimitive:</span>
      case ToString:
<span class="line-removed">-     case ToNumber:</span>
<span class="line-removed">-     case ToObject:</span>
<span class="line-removed">-     case NumberToStringWithRadix:</span>
      case NumberToStringWithValidRadixConstant:
<span class="line-removed">-     case SetFunctionName:</span>
      case StrCat:
      case CallStringConstructor:
<span class="line-removed">-     case NewStringObject:</span>
      case MakeRope:
<span class="line-removed">-     case InByVal:</span>
<span class="line-removed">-     case InById:</span>
<span class="line-removed">-     case HasOwnProperty:</span>
<span class="line-removed">-     case PushWithScope:</span>
<span class="line-removed">-     case CreateActivation:</span>
<span class="line-removed">-     case CreateDirectArguments:</span>
<span class="line-removed">-     case CreateScopedArguments:</span>
<span class="line-removed">-     case CreateClonedArguments:</span>
      case GetFromArguments:
      case GetArgument:
<span class="line-removed">-     case PutToArguments:</span>
<span class="line-removed">-     case NewFunction:</span>
<span class="line-removed">-     case NewGeneratorFunction:</span>
<span class="line-removed">-     case NewAsyncGeneratorFunction:</span>
<span class="line-removed">-     case NewAsyncFunction:</span>
<span class="line-removed">-     case Jump:</span>
<span class="line-removed">-     case Branch:</span>
<span class="line-removed">-     case Switch:</span>
<span class="line-removed">-     case EntrySwitch:</span>
<span class="line-removed">-     case Return:</span>
<span class="line-removed">-     case TailCall:</span>
<span class="line-removed">-     case DirectTailCall:</span>
<span class="line-removed">-     case TailCallVarargs:</span>
<span class="line-removed">-     case TailCallForwardVarargs:</span>
<span class="line-removed">-     case Throw:</span>
<span class="line-removed">-     case ThrowStaticError:</span>
<span class="line-removed">-     case CountExecution:</span>
<span class="line-removed">-     case SuperSamplerBegin:</span>
<span class="line-removed">-     case SuperSamplerEnd:</span>
<span class="line-removed">-     case ForceOSRExit:</span>
<span class="line-removed">-     case CPUIntrinsic:</span>
<span class="line-removed">-     case CheckTraps:</span>
<span class="line-removed">-     case LogShadowChickenPrologue:</span>
<span class="line-removed">-     case LogShadowChickenTail:</span>
      case StringFromCharCode:
<span class="line-removed">-     case NewTypedArray:</span>
<span class="line-removed">-     case Unreachable:</span>
      case ExtractOSREntryLocal:
      case ExtractCatchLocal:
<span class="line-removed">-     case ClearCatchLocals:</span>
<span class="line-removed">-     case CheckTierUpInLoop:</span>
<span class="line-removed">-     case CheckTierUpAtReturn:</span>
<span class="line-removed">-     case CheckTierUpAndOSREnter:</span>
<span class="line-removed">-     case LoopHint:</span>
<span class="line-removed">-     case InvalidationPoint:</span>
<span class="line-removed">-     case NotifyWrite:</span>
      case CheckInBounds:
      case ConstantStoragePointer:
      case Check:
      case CheckVarargs:
<span class="line-removed">-     case MultiPutByOffset:</span>
      case ValueRep:
      case DoubleRep:
      case Int52Rep:
      case BooleanToNumber:
      case FiatInt52:
<span class="line-removed">-     case GetGetter:</span>
<span class="line-removed">-     case GetSetter:</span>
<span class="line-removed">-     case GetEnumerableLength:</span>
<span class="line-removed">-     case HasGenericProperty:</span>
<span class="line-removed">-     case HasStructureProperty:</span>
      case HasIndexedProperty:
<span class="line-removed">-     case GetDirectPname:</span>
<span class="line-removed">-     case GetPropertyEnumerator:</span>
      case GetEnumeratorStructurePname:
      case GetEnumeratorGenericPname:
      case ToIndexString:
<span class="line-removed">-     case PhantomNewObject:</span>
<span class="line-removed">-     case PhantomNewFunction:</span>
<span class="line-removed">-     case PhantomNewGeneratorFunction:</span>
<span class="line-removed">-     case PhantomNewAsyncGeneratorFunction:</span>
<span class="line-removed">-     case PhantomNewAsyncFunction:</span>
<span class="line-removed">-     case PhantomCreateActivation:</span>
<span class="line-removed">-     case PhantomNewRegexp:</span>
<span class="line-removed">-     case PutHint:</span>
      case CheckStructureImmediate:
<span class="line-removed">-     case MaterializeNewObject:</span>
<span class="line-removed">-     case MaterializeCreateActivation:</span>
<span class="line-removed">-     case PhantomDirectArguments:</span>
<span class="line-removed">-     case PhantomCreateRest:</span>
<span class="line-removed">-     case PhantomSpread:</span>
<span class="line-removed">-     case PhantomNewArrayWithSpread:</span>
<span class="line-removed">-     case PhantomNewArrayBuffer:</span>
<span class="line-removed">-     case PhantomClonedArguments:</span>
      case GetMyArgumentByVal:
      case GetMyArgumentByValOutOfBounds:
<span class="line-removed">-     case ForwardVarargs:</span>
<span class="line-removed">-     case CreateRest:</span>
      case GetPrototypeOf:
      case StringReplace:
      case StringReplaceRegExp:
      case GetRegExpObjectLastIndex:
<span class="line-removed">-     case SetRegExpObjectLastIndex:</span>
<span class="line-removed">-     case RecordRegExpCachedResult:</span>
<span class="line-removed">-     case GetDynamicVar:</span>
<span class="line-removed">-     case PutDynamicVar:</span>
<span class="line-removed">-     case ResolveScopeForHoistingFuncDeclInEval:</span>
<span class="line-removed">-     case ResolveScope:</span>
      case MapHash:
      case NormalizeMapKey:
<span class="line-removed">-     case StringValueOf:</span>
      case StringSlice:
      case ToLowerCase:
      case GetMapBucket:
      case GetMapBucketHead:
      case GetMapBucketNext:
      case LoadKeyFromMapBucket:
      case LoadValueFromMapBucket:
      case ExtractValueFromWeakMapGet:
      case WeakMapGet:
<span class="line-removed">-     case WeakSetAdd:</span>
<span class="line-removed">-     case WeakMapSet:</span>
<span class="line-removed">-     case AtomicsAdd:</span>
<span class="line-removed">-     case AtomicsAnd:</span>
<span class="line-removed">-     case AtomicsCompareExchange:</span>
<span class="line-removed">-     case AtomicsExchange:</span>
<span class="line-removed">-     case AtomicsLoad:</span>
<span class="line-removed">-     case AtomicsOr:</span>
<span class="line-removed">-     case AtomicsStore:</span>
<span class="line-removed">-     case AtomicsSub:</span>
<span class="line-removed">-     case AtomicsXor:</span>
      case AtomicsIsLockFree:
<span class="line-removed">-     case InitializeEntrypointArguments:</span>
      case MatchStructure:
      case DataViewGetInt:
      case DataViewGetFloat:
          return true;
  
      case ArraySlice:
      case ArrayIndexOf: {
          // You could plausibly move this code around as long as you proved the
          // incoming array base structure is an original array at the hoisted location.
          // Instead of doing that extra work, we just conservatively return false.
          return false;
      }
  
      case BottomValue:
          // If in doubt, assume that this isn&#39;t safe to execute, just because we have no way of
          // compiling this node.
          return false;
  
<span class="line-new-header">--- 269,81 ---</span>
      case IsFunction:
      case IsCellWithType:
      case IsTypedArrayView:
      case TypeOf:
      case LogicalNot:
      case ToString:
      case NumberToStringWithValidRadixConstant:
      case StrCat:
      case CallStringConstructor:
      case MakeRope:
      case GetFromArguments:
      case GetArgument:
      case StringFromCharCode:
      case ExtractOSREntryLocal:
      case ExtractCatchLocal:
      case CheckInBounds:
      case ConstantStoragePointer:
      case Check:
      case CheckVarargs:
      case ValueRep:
      case DoubleRep:
      case Int52Rep:
      case BooleanToNumber:
      case FiatInt52:
      case HasIndexedProperty:
      case GetEnumeratorStructurePname:
      case GetEnumeratorGenericPname:
      case ToIndexString:
      case CheckStructureImmediate:
      case GetMyArgumentByVal:
      case GetMyArgumentByValOutOfBounds:
      case GetPrototypeOf:
      case StringReplace:
      case StringReplaceRegExp:
      case GetRegExpObjectLastIndex:
      case MapHash:
      case NormalizeMapKey:
      case StringSlice:
      case ToLowerCase:
      case GetMapBucket:
      case GetMapBucketHead:
      case GetMapBucketNext:
      case LoadKeyFromMapBucket:
      case LoadValueFromMapBucket:
      case ExtractValueFromWeakMapGet:
      case WeakMapGet:
      case AtomicsIsLockFree:
      case MatchStructure:
<span class="line-added">+     case DateGetInt32OrNaN:</span>
<span class="line-added">+     case DateGetTime:</span>
      case DataViewGetInt:
      case DataViewGetFloat:
          return true;
  
<span class="line-added">+     case GetButterfly:</span>
<span class="line-added">+         return state.forNode(node-&gt;child1()).isType(SpecObject);</span>
<span class="line-added">+ </span>
      case ArraySlice:
      case ArrayIndexOf: {
          // You could plausibly move this code around as long as you proved the
          // incoming array base structure is an original array at the hoisted location.
          // Instead of doing that extra work, we just conservatively return false.
          return false;
      }
  
<span class="line-added">+     case GetGetter:</span>
<span class="line-added">+     case GetSetter: {</span>
<span class="line-added">+         if (!state.forNode(node-&gt;child1()).isType(SpecCell))</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         StructureAbstractValue&amp; value = state.forNode(node-&gt;child1()).m_structure;</span>
<span class="line-added">+         if (value.isInfinite() || value.size() != 1)</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         return value[0].get() == graph.m_vm.getterSetterStructure;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case BottomValue:
          // If in doubt, assume that this isn&#39;t safe to execute, just because we have no way of
          // compiling this node.
          return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 505,11 ***</span>
          // already force these things to be ordered precisely. I&#39;m just not confident enough in my
          // effect based memory model to rely solely on that right now.
          return false;
  
      case FilterCallLinkStatus:
<span class="line-modified">!     case FilterGetByIdStatus:</span>
      case FilterPutByIdStatus:
      case FilterInByIdStatus:
          // We don&#39;t want these to be moved anywhere other than where we put them, since we want them
          // to capture &quot;profiling&quot; at the point in control flow here the user put them.
          return false;
<span class="line-new-header">--- 356,11 ---</span>
          // already force these things to be ordered precisely. I&#39;m just not confident enough in my
          // effect based memory model to rely solely on that right now.
          return false;
  
      case FilterCallLinkStatus:
<span class="line-modified">!     case FilterGetByStatus:</span>
      case FilterPutByIdStatus:
      case FilterInByIdStatus:
          // We don&#39;t want these to be moved anywhere other than where we put them, since we want them
          // to capture &quot;profiling&quot; at the point in control flow here the user put them.
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 519,15 ***</span>
<span class="line-new-header">--- 370,17 ---</span>
      case GetArrayLength:
      case GetVectorLength:
      case ArrayPop:
      case StringCharAt:
      case StringCharCodeAt:
<span class="line-added">+     case StringCodePointAt:</span>
          return node-&gt;arrayMode().alreadyChecked(graph, node, state.forNode(graph.child(node, 0)));
  
      case ArrayPush:
          return node-&gt;arrayMode().alreadyChecked(graph, node, state.forNode(graph.varArgChild(node, 1)));
  
<span class="line-added">+     case CheckNeutered:</span>
      case GetTypedArrayByteOffset:
          return !(state.forNode(node-&gt;child1()).m_type &amp; ~(SpecTypedArrayView));
  
      case PutByValDirect:
      case PutByVal:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 538,13 ***</span>
      case AllocatePropertyStorage:
      case ReallocatePropertyStorage:
          return state.forNode(node-&gt;child1()).m_structure.isSubsetOf(
              RegisteredStructureSet(node-&gt;transition()-&gt;previous));
  
      case GetByOffset:
<span class="line-removed">-     case GetGetterSetterByOffset:</span>
      case PutByOffset: {
          StorageAccessData&amp; data = node-&gt;storageAccessData();
          PropertyOffset offset = data.offset;
          // Graph::isSafeToLoad() is all about proofs derived from PropertyConditions. Those don&#39;t
          // know anything about inferred types. But if we have a proof derived from watching a
          // structure that has a type proof, then the next case below will deal with it.
<span class="line-new-header">--- 391,39 ---</span>
      case AllocatePropertyStorage:
      case ReallocatePropertyStorage:
          return state.forNode(node-&gt;child1()).m_structure.isSubsetOf(
              RegisteredStructureSet(node-&gt;transition()-&gt;previous));
  
<span class="line-added">+     case GetGetterSetterByOffset: {</span>
<span class="line-added">+         // If it&#39;s an inline property, we need to make sure it&#39;s a cell before trusting what the structure set tells us.</span>
<span class="line-added">+         if (node-&gt;child1().node() == node-&gt;child2().node() &amp;&amp; !state.forNode(node-&gt;child2()).isType(SpecCell))</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         StorageAccessData&amp; data = node-&gt;storageAccessData();</span>
<span class="line-added">+         auto* uid = graph.identifiers()[data.identifierNumber];</span>
<span class="line-added">+         PropertyOffset desiredOffset = data.offset;</span>
<span class="line-added">+         StructureAbstractValue&amp; value = state.forNode(node-&gt;child2()).m_structure;</span>
<span class="line-added">+         if (value.isInfinite())</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         for (unsigned i = value.size(); i--;) {</span>
<span class="line-added">+             Structure* thisStructure = value[i].get();</span>
<span class="line-added">+             if (thisStructure-&gt;isUncacheableDictionary())</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             unsigned attributes = 0;</span>
<span class="line-added">+             PropertyOffset checkOffset = thisStructure-&gt;getConcurrently(uid, attributes);</span>
<span class="line-added">+             if (checkOffset != desiredOffset || !(attributes &amp; PropertyAttribute::Accessor))</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case GetByOffset:
      case PutByOffset: {
<span class="line-added">+         // If it&#39;s an inline property, we need to make sure it&#39;s a cell before trusting what the structure set tells us.</span>
<span class="line-added">+         if (node-&gt;child1().node() == node-&gt;child2().node() &amp;&amp; !state.forNode(node-&gt;child2()).isType(SpecCell))</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+ </span>
          StorageAccessData&amp; data = node-&gt;storageAccessData();
          PropertyOffset offset = data.offset;
          // Graph::isSafeToLoad() is all about proofs derived from PropertyConditions. Those don&#39;t
          // know anything about inferred types. But if we have a proof derived from watching a
          // structure that has a type proof, then the next case below will deal with it.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 558,10 ***</span>
<span class="line-new-header">--- 437,12 ---</span>
          StructureAbstractValue&amp; value = state.forNode(node-&gt;child2()).m_structure;
          if (value.isInfinite())
              return false;
          for (unsigned i = value.size(); i--;) {
              Structure* thisStructure = value[i].get();
<span class="line-added">+             if (thisStructure-&gt;isUncacheableDictionary())</span>
<span class="line-added">+                 return false;</span>
              if (!thisStructure-&gt;isValidOffset(offset))
                  return false;
          }
          return true;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 592,17 ***</span>
              }
          }
          return true;
      }
  
      case DataViewSet:
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
      case SetAdd:
      case MapSet:
          return false;
  
      case LastNodeType:
          RELEASE_ASSERT_NOT_REACHED();
          return false;
      }
  
<span class="line-new-header">--- 473,215 ---</span>
              }
          }
          return true;
      }
  
<span class="line-added">+     case ToThis:</span>
<span class="line-added">+     case CreateThis:</span>
<span class="line-added">+     case CreatePromise:</span>
<span class="line-added">+     case CreateGenerator:</span>
<span class="line-added">+     case CreateAsyncGenerator:</span>
<span class="line-added">+     case ObjectCreate:</span>
<span class="line-added">+     case ObjectKeys:</span>
<span class="line-added">+     case SetLocal:</span>
<span class="line-added">+     case SetCallee:</span>
<span class="line-added">+     case PutStack:</span>
<span class="line-added">+     case KillStack:</span>
<span class="line-added">+     case MovHint:</span>
<span class="line-added">+     case ZombieHint:</span>
<span class="line-added">+     case Upsilon:</span>
<span class="line-added">+     case Phi:</span>
<span class="line-added">+     case Flush:</span>
<span class="line-added">+     case SetArgumentDefinitely:</span>
<span class="line-added">+     case SetArgumentMaybe:</span>
<span class="line-added">+     case SetArgumentCountIncludingThis:</span>
<span class="line-added">+     case PhantomLocal:</span>
<span class="line-added">+     case DeleteById:</span>
<span class="line-added">+     case DeleteByVal:</span>
<span class="line-added">+     case GetById:</span>
<span class="line-added">+     case GetByIdWithThis:</span>
<span class="line-added">+     case GetByValWithThis:</span>
<span class="line-added">+     case GetByIdFlush:</span>
<span class="line-added">+     case GetByIdDirect:</span>
<span class="line-added">+     case GetByIdDirectFlush:</span>
<span class="line-added">+     case PutById:</span>
<span class="line-added">+     case PutByIdFlush:</span>
<span class="line-added">+     case PutByIdWithThis:</span>
<span class="line-added">+     case PutByValWithThis:</span>
<span class="line-added">+     case PutByIdDirect:</span>
<span class="line-added">+     case PutGetterById:</span>
<span class="line-added">+     case PutSetterById:</span>
<span class="line-added">+     case PutGetterSetterById:</span>
<span class="line-added">+     case PutGetterByVal:</span>
<span class="line-added">+     case PutSetterByVal:</span>
<span class="line-added">+     case DefineDataProperty:</span>
<span class="line-added">+     case DefineAccessorProperty:</span>
<span class="line-added">+     case Arrayify:</span>
<span class="line-added">+     case ArrayifyToStructure:</span>
<span class="line-added">+     case PutClosureVar:</span>
<span class="line-added">+     case PutGlobalVariable:</span>
<span class="line-added">+     case CheckBadCell:</span>
<span class="line-added">+     case RegExpExec:</span>
<span class="line-added">+     case RegExpExecNonGlobalOrSticky:</span>
<span class="line-added">+     case RegExpTest:</span>
<span class="line-added">+     case RegExpMatchFast:</span>
<span class="line-added">+     case RegExpMatchFastGlobal:</span>
<span class="line-added">+     case Call:</span>
<span class="line-added">+     case DirectCall:</span>
<span class="line-added">+     case TailCallInlinedCaller:</span>
<span class="line-added">+     case DirectTailCallInlinedCaller:</span>
<span class="line-added">+     case Construct:</span>
<span class="line-added">+     case DirectConstruct:</span>
<span class="line-added">+     case CallVarargs:</span>
<span class="line-added">+     case CallEval:</span>
<span class="line-added">+     case TailCallVarargsInlinedCaller:</span>
<span class="line-added">+     case TailCallForwardVarargsInlinedCaller:</span>
<span class="line-added">+     case ConstructVarargs:</span>
<span class="line-added">+     case VarargsLength:</span>
<span class="line-added">+     case LoadVarargs:</span>
<span class="line-added">+     case CallForwardVarargs:</span>
<span class="line-added">+     case ConstructForwardVarargs:</span>
<span class="line-added">+     case NewObject:</span>
<span class="line-added">+     case NewPromise:</span>
<span class="line-added">+     case NewGenerator:</span>
<span class="line-added">+     case NewAsyncGenerator:</span>
<span class="line-added">+     case NewArray:</span>
<span class="line-added">+     case NewArrayWithSize:</span>
<span class="line-added">+     case NewArrayBuffer:</span>
<span class="line-added">+     case NewArrayWithSpread:</span>
<span class="line-added">+     case NewArrayIterator:</span>
<span class="line-added">+     case Spread:</span>
<span class="line-added">+     case NewRegexp:</span>
<span class="line-added">+     case NewSymbol:</span>
<span class="line-added">+     case ProfileType:</span>
<span class="line-added">+     case ProfileControlFlow:</span>
<span class="line-added">+     case InstanceOf:</span>
<span class="line-added">+     case InstanceOfCustom:</span>
<span class="line-added">+     case CallObjectConstructor:</span>
<span class="line-added">+     case ToPrimitive:</span>
<span class="line-added">+     case ToPropertyKey:</span>
<span class="line-added">+     case ToNumber:</span>
<span class="line-added">+     case ToNumeric:</span>
<span class="line-added">+     case ToObject:</span>
<span class="line-added">+     case NumberToStringWithRadix:</span>
<span class="line-added">+     case SetFunctionName:</span>
<span class="line-added">+     case NewStringObject:</span>
<span class="line-added">+     case InByVal:</span>
<span class="line-added">+     case InById:</span>
<span class="line-added">+     case HasOwnProperty:</span>
<span class="line-added">+     case PushWithScope:</span>
<span class="line-added">+     case CreateActivation:</span>
<span class="line-added">+     case CreateDirectArguments:</span>
<span class="line-added">+     case CreateScopedArguments:</span>
<span class="line-added">+     case CreateClonedArguments:</span>
<span class="line-added">+     case CreateArgumentsButterfly:</span>
<span class="line-added">+     case PutToArguments:</span>
<span class="line-added">+     case NewFunction:</span>
<span class="line-added">+     case NewGeneratorFunction:</span>
<span class="line-added">+     case NewAsyncGeneratorFunction:</span>
<span class="line-added">+     case NewAsyncFunction:</span>
<span class="line-added">+     case Jump:</span>
<span class="line-added">+     case Branch:</span>
<span class="line-added">+     case Switch:</span>
<span class="line-added">+     case EntrySwitch:</span>
<span class="line-added">+     case Return:</span>
<span class="line-added">+     case TailCall:</span>
<span class="line-added">+     case DirectTailCall:</span>
<span class="line-added">+     case TailCallVarargs:</span>
<span class="line-added">+     case TailCallForwardVarargs:</span>
<span class="line-added">+     case Throw:</span>
<span class="line-added">+     case ThrowStaticError:</span>
<span class="line-added">+     case CountExecution:</span>
<span class="line-added">+     case SuperSamplerBegin:</span>
<span class="line-added">+     case SuperSamplerEnd:</span>
<span class="line-added">+     case ForceOSRExit:</span>
<span class="line-added">+     case CPUIntrinsic:</span>
<span class="line-added">+     case CheckTraps:</span>
<span class="line-added">+     case LogShadowChickenPrologue:</span>
<span class="line-added">+     case LogShadowChickenTail:</span>
<span class="line-added">+     case NewTypedArray:</span>
<span class="line-added">+     case Unreachable:</span>
<span class="line-added">+     case ClearCatchLocals:</span>
<span class="line-added">+     case CheckTierUpInLoop:</span>
<span class="line-added">+     case CheckTierUpAtReturn:</span>
<span class="line-added">+     case CheckTierUpAndOSREnter:</span>
<span class="line-added">+     case LoopHint:</span>
<span class="line-added">+     case InvalidationPoint:</span>
<span class="line-added">+     case NotifyWrite:</span>
<span class="line-added">+     case MultiPutByOffset:</span>
<span class="line-added">+     case GetEnumerableLength:</span>
<span class="line-added">+     case HasGenericProperty:</span>
<span class="line-added">+     case HasStructureProperty:</span>
<span class="line-added">+     case GetDirectPname:</span>
<span class="line-added">+     case GetPropertyEnumerator:</span>
<span class="line-added">+     case PhantomNewObject:</span>
<span class="line-added">+     case PhantomNewFunction:</span>
<span class="line-added">+     case PhantomNewGeneratorFunction:</span>
<span class="line-added">+     case PhantomNewAsyncGeneratorFunction:</span>
<span class="line-added">+     case PhantomNewAsyncFunction:</span>
<span class="line-added">+     case PhantomNewArrayIterator:</span>
<span class="line-added">+     case PhantomCreateActivation:</span>
<span class="line-added">+     case PhantomNewRegexp:</span>
<span class="line-added">+     case PutHint:</span>
<span class="line-added">+     case MaterializeNewObject:</span>
<span class="line-added">+     case MaterializeCreateActivation:</span>
<span class="line-added">+     case MaterializeNewInternalFieldObject:</span>
<span class="line-added">+     case PhantomDirectArguments:</span>
<span class="line-added">+     case PhantomCreateRest:</span>
<span class="line-added">+     case PhantomSpread:</span>
<span class="line-added">+     case PhantomNewArrayWithSpread:</span>
<span class="line-added">+     case PhantomNewArrayBuffer:</span>
<span class="line-added">+     case PhantomClonedArguments:</span>
<span class="line-added">+     case ForwardVarargs:</span>
<span class="line-added">+     case CreateRest:</span>
<span class="line-added">+     case SetRegExpObjectLastIndex:</span>
<span class="line-added">+     case RecordRegExpCachedResult:</span>
<span class="line-added">+     case GetDynamicVar:</span>
<span class="line-added">+     case PutDynamicVar:</span>
<span class="line-added">+     case ResolveScopeForHoistingFuncDeclInEval:</span>
<span class="line-added">+     case ResolveScope:</span>
<span class="line-added">+     case StringValueOf:</span>
<span class="line-added">+     case WeakSetAdd:</span>
<span class="line-added">+     case WeakMapSet:</span>
<span class="line-added">+     case AtomicsAdd:</span>
<span class="line-added">+     case AtomicsAnd:</span>
<span class="line-added">+     case AtomicsCompareExchange:</span>
<span class="line-added">+     case AtomicsExchange:</span>
<span class="line-added">+     case AtomicsLoad:</span>
<span class="line-added">+     case AtomicsOr:</span>
<span class="line-added">+     case AtomicsStore:</span>
<span class="line-added">+     case AtomicsSub:</span>
<span class="line-added">+     case AtomicsXor:</span>
<span class="line-added">+     case InitializeEntrypointArguments:</span>
<span class="line-added">+     case ValueNegate:</span>
<span class="line-added">+     case GetInternalField:</span>
<span class="line-added">+     case PutInternalField:</span>
      case DataViewSet:
      case SetAdd:
      case MapSet:
          return false;
  
<span class="line-added">+     case Inc:</span>
<span class="line-added">+     case Dec:</span>
<span class="line-added">+         return node-&gt;child1().useKind() != UntypedUse;</span>
<span class="line-added">+ </span>
<span class="line-added">+     case ValueBitAnd:</span>
<span class="line-added">+     case ValueBitXor:</span>
<span class="line-added">+     case ValueBitOr:</span>
<span class="line-added">+     case ValueBitLShift:</span>
<span class="line-added">+     case ValueBitRShift:</span>
<span class="line-added">+     case ValueAdd:</span>
<span class="line-added">+     case ValueSub:</span>
<span class="line-added">+     case ValueMul:</span>
<span class="line-added">+     case ValueDiv:</span>
<span class="line-added">+     case ValueMod:</span>
<span class="line-added">+     case ValuePow:</span>
<span class="line-added">+         return node-&gt;isBinaryUseKind(BigIntUse);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case ValueBitNot:</span>
<span class="line-added">+         return node-&gt;child1().useKind() == BigIntUse;</span>
<span class="line-added">+ </span>
      case LastNodeType:
          RELEASE_ASSERT_NOT_REACHED();
          return false;
      }
  
</pre>
<center><a href="DFGSSALoweringPhase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSafepoint.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
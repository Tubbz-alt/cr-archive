diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/Threading.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/Threading.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/Threading.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/Threading.h
@@ -50,10 +50,14 @@
 
 #if USE(PTHREADS) && !OS(DARWIN)
 #include <signal.h>
 #endif
 
+#if OS(WINDOWS)
+#include <array>
+#endif
+
 namespace WTF {
 
 class AbstractLocker;
 class ThreadMessageData;
 
@@ -104,10 +108,29 @@
     // that the thread information is alive. While Thread::current() is not safe if it is called
     // from the destructor of the other TLS data, currentID() always returns meaningful thread ID.
     WTF_EXPORT_PRIVATE static ThreadIdentifier currentID();
 
     ThreadIdentifier id() const { return m_id; }
+
+    class SpecificStorage {
+    public:
+        using DestroyFunction = void (*)(void*);
+        WTF_EXPORT_PRIVATE static bool allocateKey(int& key, DestroyFunction);
+        WTF_EXPORT_PRIVATE void* get(int key);
+        WTF_EXPORT_PRIVATE void set(int key, void* value);
+        void destroySlots();
+
+    private:
+        static constexpr size_t s_maxKeys = 32;
+        static Atomic<int> s_numberOfKeys;
+        static std::array<Atomic<DestroyFunction>, s_maxKeys> s_destroyFunctions;
+        std::array<void*, s_maxKeys> m_slots { };
+    };
+
+    SpecificStorage& specificStorage() { return m_specificStorage; };
+
+    class ThreadHolder;
 #endif
 
     WTF_EXPORT_PRIVATE void changePriority(int);
     WTF_EXPORT_PRIVATE int waitForCompletion();
     WTF_EXPORT_PRIVATE void detach();
@@ -141,11 +164,10 @@
     // Called in the thread during initialization.
     // Helpful for platforms where the thread name must be set from within the thread.
     static void initializeCurrentThreadInternal(const char* threadName);
     static void initializeCurrentThreadEvenIfNonWTFCreated();
 
-    WTF_EXPORT_PRIVATE static const unsigned lockSpinLimit;
     WTF_EXPORT_PRIVATE static void yield();
 
     WTF_EXPORT_PRIVATE static bool exchangeIsCompilationThread(bool newValue);
     WTF_EXPORT_PRIVATE static void registerGCThread(GCThreadType);
     WTF_EXPORT_PRIVATE static bool mayBeGCThread();
@@ -249,41 +271,37 @@
 
     // These functions are only called from ThreadGroup.
     ThreadGroupAddResult addToThreadGroup(const AbstractLocker& threadGroupLocker, ThreadGroup&);
     void removeFromThreadGroup(const AbstractLocker& threadGroupLocker, ThreadGroup&);
 
-    // The Thread instance is ref'ed and held in thread-specific storage. It will be deref'ed by destructTLS at thread destruction time.
-    // For pthread, it employs pthreads-specific 2-pass destruction to reliably remove Thread.
-    // For Windows, we use thread_local to defer thread TLS destruction. It assumes regular ThreadSpecific
-    // types don't use multiple-pass destruction.
+    // For pthread, the Thread instance is ref'ed and held in thread-specific storage. It will be deref'ed by destructTLS at thread destruction time.
+    // It employs pthreads-specific 2-pass destruction to reliably remove Thread.
 
-#if !HAVE(FAST_TLS)
+#if !HAVE(FAST_TLS) && !OS(WINDOWS)
     static WTF_EXPORT_PRIVATE ThreadSpecificKey s_key;
     // One time initialization for this class as a whole.
     // This method must be called before initializeTLS() and it is not thread-safe.
     static void initializeTLSKey();
 #endif
+    // This thread-specific destructor is called 2 times when thread terminates:
+    // - first, when all the other thread-specific destructors are called, it simply remembers it was 'destroyed once'
+    // and (1) re-sets itself into the thread-specific slot or (2) constructs thread local value to call it again later.
+    // - second, after all thread-specific destructors were invoked, it gets called again - this time, we deref the
+    // Thread in the TLS, completing the cleanup.
+    static void destructTLS(void* data);
 
     // Creates and puts an instance of Thread into thread-specific storage.
     static Thread& initializeTLS(Ref<Thread>&&);
     WTF_EXPORT_PRIVATE static Thread& initializeCurrentTLS();
 
     // Returns nullptr if thread-specific storage was not initialized.
-    static Thread* currentMayBeNull();
-
 #if OS(WINDOWS)
-    WTF_EXPORT_PRIVATE static Thread* currentDying();
-    static RefPtr<Thread> get(ThreadIdentifier);
+    WTF_EXPORT_PRIVATE static Thread* currentMayBeNull();
+#else
+    static Thread* currentMayBeNull();
 #endif
 
-    // This thread-specific destructor is called 2 times when thread terminates:
-    // - first, when all the other thread-specific destructors are called, it simply remembers it was 'destroyed once'
-    // and (1) re-sets itself into the thread-specific slot or (2) constructs thread local value to call it again later.
-    // - second, after all thread-specific destructors were invoked, it gets called again - this time, we remove the
-    // Thread from the threadMap, completing the cleanup.
-    static void THREAD_SPECIFIC_CALL destructTLS(void* data);
-
     JoinableState m_joinableState { Joinable };
     bool m_isShuttingDown : 1;
     bool m_didExit : 1;
     bool m_isDestroyedOnce : 1;
     bool m_isCompilationThread: 1;
@@ -302,10 +320,14 @@
 #elif USE(PTHREADS)
     PlatformRegisters* m_platformRegisters { nullptr };
     unsigned m_suspendCount { 0 };
 #endif
 
+#if OS(WINDOWS)
+    SpecificStorage m_specificStorage;
+#endif
+
     AtomStringTable* m_currentAtomStringTable { nullptr };
     AtomStringTable m_defaultAtomStringTable;
 
 #if ENABLE(STACK_STATS)
     StackStats::PerThreadStats m_stackStats;
@@ -323,38 +345,36 @@
     , m_isCompilationThread(false)
     , m_gcThreadType(static_cast<unsigned>(GCThreadType::None))
 {
 }
 
+#if !OS(WINDOWS)
 inline Thread* Thread::currentMayBeNull()
 {
 #if !HAVE(FAST_TLS)
     ASSERT(s_key != InvalidThreadSpecificKey);
     return static_cast<Thread*>(threadSpecificGet(s_key));
 #else
     return static_cast<Thread*>(_pthread_getspecific_direct(WTF_THREAD_DATA_KEY));
 #endif
 }
+#endif
 
 inline Thread& Thread::current()
 {
     // WRT WebCore:
     //    Thread::current() is used on main thread before it could possibly be used
     //    on secondary ones, so there is no need for synchronization here.
     // WRT JavaScriptCore:
     //    Thread::initializeTLSKey() is initially called from initializeThreading(), ensuring
     //    this is initially called in a std::call_once locked context.
-#if !HAVE(FAST_TLS)
+#if !HAVE(FAST_TLS) && !OS(WINDOWS)
     if (UNLIKELY(Thread::s_key == InvalidThreadSpecificKey))
         WTF::initializeThreading();
 #endif
     if (auto* thread = currentMayBeNull())
         return *thread;
-#if OS(WINDOWS)
-    if (auto* thread = currentDying())
-        return *thread;
-#endif
     return initializeCurrentTLS();
 }
 
 } // namespace WTF
 

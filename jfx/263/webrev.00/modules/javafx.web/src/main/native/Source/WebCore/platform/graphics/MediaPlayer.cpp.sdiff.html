<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MediaPlaybackTargetPicker.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaPlayer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2007-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  78 #include &quot;MediaPlayerPrivateMediaStreamAVFObjC.h&quot;
  79 #endif
  80 
  81 #endif // PLATFORM(COCOA)
  82 
  83 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION) &amp;&amp; !USE(GSTREAMER)
  84 #include &quot;MediaPlayerPrivateAVFoundationCF.h&quot;
  85 #endif // USE(AVFOUNDATION)
  86 
  87 #if PLATFORM(JAVA)
  88 #include &quot;MediaPlayerPrivateJava.h&quot;
  89 #define PlatformMediaEngineClassName MediaPlayerPrivate
  90 #endif  // PLATFORM(JAVA)
  91 
  92 #if USE(EXTERNAL_HOLEPUNCH)
  93 #include &quot;MediaPlayerPrivateHolePunch.h&quot;
  94 #endif
  95 
  96 namespace WebCore {
  97 
<span class="line-removed">  98 #if !RELEASE_LOG_DISABLED</span>
<span class="line-removed">  99 static RefPtr&lt;Logger&gt;&amp; nullLogger()</span>
<span class="line-removed"> 100 {</span>
<span class="line-removed"> 101     static NeverDestroyed&lt;RefPtr&lt;Logger&gt;&gt; logger;</span>
<span class="line-removed"> 102     return logger;</span>
<span class="line-removed"> 103 }</span>
<span class="line-removed"> 104 #endif</span>
<span class="line-removed"> 105 </span>
 106 // a null player to make MediaPlayer logic simpler
 107 
 108 class NullMediaPlayerPrivate final : public MediaPlayerPrivateInterface {
 109 public:
 110     explicit NullMediaPlayerPrivate(MediaPlayer*) { }
 111 
 112     void load(const String&amp;) final { }
 113 #if ENABLE(MEDIA_SOURCE)
 114     void load(const String&amp;, MediaSourcePrivateClient*) final { }
 115 #endif
 116 #if ENABLE(MEDIA_STREAM)
 117     void load(MediaStreamPrivate&amp;) final { }
 118 #endif
 119     void cancelLoad() final { }
 120 
 121     void prepareToPlay() final { }
 122     void play() final { }
 123     void pause() final { }
 124 
<span class="line-modified"> 125     PlatformLayer* platformLayer() const final { return 0; }</span>
 126 
 127     FloatSize naturalSize() const final { return FloatSize(); }
 128 
 129     bool hasVideo() const final { return false; }
 130     bool hasAudio() const final { return false; }
 131 
 132     void setVisible(bool) final { }
 133 
 134     double durationDouble() const final { return 0; }
 135 
 136     double currentTimeDouble() const final { return 0; }
 137     void seekDouble(double) final { }
 138     bool seeking() const final { return false; }
 139 
 140     void setRateDouble(double) final { }
 141     void setPreservesPitch(bool) final { }
 142     bool paused() const final { return true; }
 143 
 144     void setVolumeDouble(double) final { }
 145 
 146     void setMuted(bool) final { }
 147 
 148     bool hasClosedCaptions() const final { return false; }
 149     void setClosedCaptionsVisible(bool) final { };
 150 
<span class="line-modified"> 151     MediaPlayer::NetworkState networkState() const final { return MediaPlayer::Empty; }</span>
<span class="line-modified"> 152     MediaPlayer::ReadyState readyState() const final { return MediaPlayer::HaveNothing; }</span>
 153 
 154     float maxTimeSeekable() const final { return 0; }
 155     double minTimeSeekable() const final { return 0; }
 156     std::unique_ptr&lt;PlatformTimeRanges&gt; buffered() const final { return makeUnique&lt;PlatformTimeRanges&gt;(); }
 157 
 158     double seekableTimeRangesLastModifiedTime() const final { return 0; }
 159     double liveUpdateInterval() const final { return 0; }
 160 
 161     unsigned long long totalBytes() const final { return 0; }
 162     bool didLoadingProgress() const final { return false; }
 163 
 164     void setSize(const IntSize&amp;) final { }
 165 
 166     void paint(GraphicsContext&amp;, const FloatRect&amp;) final { }
 167 
<span class="line-removed"> 168     bool canLoadPoster() const final { return false; }</span>
<span class="line-removed"> 169     void setPoster(const String&amp;) final { }</span>
<span class="line-removed"> 170 </span>
 171     bool hasSingleSecurityOrigin() const final { return true; }
 172 };
 173 














 174 class NullMediaPlayerClient : public MediaPlayerClient {
<span class="line-modified"> 175 public:</span>
 176 #if !RELEASE_LOG_DISABLED
 177     const Logger&amp; mediaPlayerLogger() final
 178     {
 179         if (!nullLogger().get()) {
 180             nullLogger() = Logger::create(this);
 181             nullLogger()-&gt;setEnabled(this, false);
 182         }
 183 
 184         return *nullLogger().get();
 185     }
 186 #endif


 187 };
 188 

 189 const Vector&lt;ContentType&gt;&amp; MediaPlayerClient::mediaContentTypesRequiringHardwareSupport() const
 190 {
 191     static NeverDestroyed&lt;Vector&lt;ContentType&gt;&gt; contentTypes;
 192     return contentTypes;
 193 }
 194 
 195 static MediaPlayerClient&amp; nullMediaPlayerClient()
 196 {
 197     static NeverDestroyed&lt;NullMediaPlayerClient&gt; client;
 198     return client.get();
 199 }
 200 
 201 // engine support
 202 
<span class="line-modified"> 203 struct MediaPlayerFactory {</span>
<span class="line-removed"> 204     CreateMediaEnginePlayer constructor;</span>
<span class="line-removed"> 205     MediaEngineSupportedTypes getSupportedTypes;</span>
<span class="line-removed"> 206     MediaEngineSupportsType supportsTypeAndCodecs;</span>
<span class="line-removed"> 207     MediaEngineOriginsInMediaCache originsInMediaCache;</span>
<span class="line-removed"> 208     MediaEngineClearMediaCache clearMediaCache;</span>
<span class="line-removed"> 209     MediaEngineClearMediaCacheForOrigins clearMediaCacheForOrigins;</span>
<span class="line-removed"> 210     MediaEngineSupportsKeySystem supportsKeySystem;</span>
<span class="line-removed"> 211 };</span>
<span class="line-removed"> 212 </span>
<span class="line-removed"> 213 static void addMediaEngine(CreateMediaEnginePlayer&amp;&amp;, MediaEngineSupportedTypes, MediaEngineSupportsType, MediaEngineOriginsInMediaCache, MediaEngineClearMediaCache, MediaEngineClearMediaCacheForOrigins, MediaEngineSupportsKeySystem);</span>
 214 
 215 static Lock mediaEngineVectorLock;
 216 
 217 static bool&amp; haveMediaEnginesVector()
 218 {
 219     static bool haveVector;
 220     return haveVector;
 221 }
 222 
<span class="line-modified"> 223 static Vector&lt;MediaPlayerFactory&gt;&amp; mutableInstalledMediaEnginesVector()</span>
 224 {
<span class="line-modified"> 225     static NeverDestroyed&lt;Vector&lt;MediaPlayerFactory&gt;&gt; installedEngines;</span>
 226     return installedEngines;
 227 }
 228 











 229 static void buildMediaEnginesVector()
 230 {
 231     ASSERT(mediaEngineVectorLock.isLocked());
 232 
 233 #if USE(AVFOUNDATION)

 234     if (DeprecatedGlobalSettings::isAVFoundationEnabled()) {
 235 

 236 #if PLATFORM(COCOA)
<span class="line-modified"> 237         MediaPlayerPrivateAVFoundationObjC::registerMediaEngine(addMediaEngine);</span>



 238 #endif
 239 
 240 #if ENABLE(MEDIA_SOURCE)
 241         MediaPlayerPrivateMediaSourceAVFObjC::registerMediaEngine(addMediaEngine);
 242 #endif
 243 
 244 #if ENABLE(MEDIA_STREAM)
 245         MediaPlayerPrivateMediaStreamAVFObjC::registerMediaEngine(addMediaEngine);
 246 #endif
 247 
 248 #if PLATFORM(WIN)
 249         MediaPlayerPrivateAVFoundationCF::registerMediaEngine(addMediaEngine);
 250 #endif
 251     }
 252 #endif // USE(AVFOUNDATION)
 253 
 254 #if defined(PlatformMediaEngineClassName)
 255 #if USE(GSTREAMER)
 256     if (DeprecatedGlobalSettings::isGStreamerEnabled())
 257 #endif
 258         PlatformMediaEngineClassName::registerMediaEngine(addMediaEngine);
 259 #endif
 260 
 261 #if USE(GSTREAMER) &amp;&amp; ENABLE(MEDIA_SOURCE) &amp;&amp; ENABLE(VIDEO_TRACK)
 262     if (DeprecatedGlobalSettings::isGStreamerEnabled())
 263         MediaPlayerPrivateGStreamerMSE::registerMediaEngine(addMediaEngine);
 264 #endif
 265 
 266 #if USE(EXTERNAL_HOLEPUNCH)
 267     MediaPlayerPrivateHolePunch::registerMediaEngine(addMediaEngine);
 268 #endif
 269 
 270     haveMediaEnginesVector() = true;
 271 }
 272 
<span class="line-modified"> 273 static const Vector&lt;MediaPlayerFactory&gt;&amp; installedMediaEngines()</span>
 274 {
 275     {
 276         auto locker = holdLock(mediaEngineVectorLock);
 277         if (!haveMediaEnginesVector())
 278             buildMediaEnginesVector();
 279     }
 280 
 281     return mutableInstalledMediaEnginesVector();
 282 }
 283 
<span class="line-modified"> 284 static void addMediaEngine(CreateMediaEnginePlayer&amp;&amp; constructor, MediaEngineSupportedTypes getSupportedTypes, MediaEngineSupportsType supportsType,</span>
<span class="line-removed"> 285     MediaEngineOriginsInMediaCache originsInMediaCache, MediaEngineClearMediaCache clearMediaCache, MediaEngineClearMediaCacheForOrigins clearMediaCacheForOrigins, MediaEngineSupportsKeySystem supportsKeySystem)</span>
 286 {
<span class="line-modified"> 287     ASSERT(constructor);</span>
<span class="line-removed"> 288     ASSERT(getSupportedTypes);</span>
<span class="line-removed"> 289     ASSERT(supportsType);</span>
<span class="line-removed"> 290 </span>
<span class="line-removed"> 291     mutableInstalledMediaEnginesVector().append(MediaPlayerFactory { WTFMove(constructor), getSupportedTypes, supportsType, originsInMediaCache, clearMediaCache, clearMediaCacheForOrigins, supportsKeySystem });</span>
 292 }
 293 
 294 static const AtomString&amp; applicationOctetStream()
 295 {
 296     static NeverDestroyed&lt;const AtomString&gt; applicationOctetStream(&quot;application/octet-stream&quot;, AtomString::ConstructFromLiteral);
 297     return applicationOctetStream;
 298 }
 299 
 300 static const AtomString&amp; textPlain()
 301 {
 302     static NeverDestroyed&lt;const AtomString&gt; textPlain(&quot;text/plain&quot;, AtomString::ConstructFromLiteral);
 303     return textPlain;
 304 }
 305 















 306 static const MediaPlayerFactory* bestMediaEngineForSupportParameters(const MediaEngineSupportParameters&amp; parameters, const MediaPlayerFactory* current = nullptr)
 307 {
 308     if (parameters.type.isEmpty() &amp;&amp; !parameters.isMediaSource &amp;&amp; !parameters.isMediaStream)
 309         return nullptr;
 310 
 311     // 4.8.10.3 MIME types - In the absence of a specification to the contrary, the MIME type &quot;application/octet-stream&quot;
 312     // when used with parameters, e.g. &quot;application/octet-stream;codecs=theora&quot;, is a type that the user agent knows
 313     // it cannot render.
 314     if (parameters.type.containerType() == applicationOctetStream()) {
 315         if (!parameters.type.codecs().isEmpty())
 316             return nullptr;
 317     }
 318 
 319     const MediaPlayerFactory* foundEngine = nullptr;
<span class="line-modified"> 320     MediaPlayer::SupportsType supported = MediaPlayer::IsNotSupported;</span>
 321     for (auto&amp; engine : installedMediaEngines()) {
 322         if (current) {
<span class="line-modified"> 323             if (current == &amp;engine)</span>
 324                 current = nullptr;
 325             continue;
 326         }
<span class="line-modified"> 327         MediaPlayer::SupportsType engineSupport = engine.supportsTypeAndCodecs(parameters);</span>
 328         if (engineSupport &gt; supported) {
 329             supported = engineSupport;
<span class="line-modified"> 330             foundEngine = &amp;engine;</span>
 331         }
 332     }
 333 
 334     return foundEngine;
 335 }
 336 
<span class="line-modified"> 337 static const MediaPlayerFactory* nextMediaEngine(const MediaPlayerFactory* current)</span>
 338 {





 339     auto&amp; engines = installedMediaEngines();
 340     if (engines.isEmpty())
 341         return nullptr;
 342 
 343     if (!current)
<span class="line-modified"> 344         return &amp;engines.first();</span>








 345 
<span class="line-removed"> 346     size_t currentIndex = current - &amp;engines.first();</span>
 347     if (currentIndex + 1 &gt;= engines.size())
 348         return nullptr;
 349 
<span class="line-modified"> 350     return &amp;engines[currentIndex + 1];</span>
 351 }
 352 
 353 // media player
 354 
 355 Ref&lt;MediaPlayer&gt; MediaPlayer::create(MediaPlayerClient&amp; client)
 356 {
 357     return adoptRef(*new MediaPlayer(client));
 358 }
 359 





 360 MediaPlayer::MediaPlayer(MediaPlayerClient&amp; client)
 361     : m_client(&amp;client)
 362     , m_reloadTimer(*this, &amp;MediaPlayer::reloadTimerFired)
 363     , m_private(makeUnique&lt;NullMediaPlayerPrivate&gt;(this))
 364 {
 365 }
 366 








 367 MediaPlayer::~MediaPlayer()
 368 {
 369     ASSERT(!m_initializingMediaEngine);
 370 }
 371 
 372 void MediaPlayer::invalidate()
 373 {
 374     m_client = &amp;nullMediaPlayerClient();
 375 }
 376 
 377 bool MediaPlayer::load(const URL&amp; url, const ContentType&amp; contentType, const String&amp; keySystem)
 378 {
 379     ASSERT(!m_reloadTimer.isActive());
 380 
 381     // Protect against MediaPlayer being destroyed during a MediaPlayerClient callback.
 382     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 383 
 384     m_contentType = contentType;
 385     m_url = url;
 386     m_keySystem = keySystem.convertToASCIILowercase();
</pre>
<hr />
<pre>
 429     m_contentMIMETypeWasInferredFromExtension = false;
 430     loadWithNextMediaEngine(nullptr);
 431     return m_currentMediaEngine;
 432 }
 433 #endif
 434 
 435 #if ENABLE(MEDIA_STREAM)
 436 bool MediaPlayer::load(MediaStreamPrivate&amp; mediaStream)
 437 {
 438     ASSERT(!m_reloadTimer.isActive());
 439 
 440     m_mediaStream = &amp;mediaStream;
 441     m_keySystem = emptyString();
 442     m_contentType = { };
 443     m_contentMIMETypeWasInferredFromExtension = false;
 444     loadWithNextMediaEngine(nullptr);
 445     return m_currentMediaEngine;
 446 }
 447 #endif
 448 
<span class="line-modified"> 449 const MediaPlayerFactory* MediaPlayer::nextBestMediaEngine(const MediaPlayerFactory* current) const</span>
 450 {
 451     MediaEngineSupportParameters parameters;
 452     parameters.type = m_contentType;
 453     parameters.url = m_url;
 454 #if ENABLE(MEDIA_SOURCE)
 455     parameters.isMediaSource = !!m_mediaSource;
 456 #endif
 457 #if ENABLE(MEDIA_STREAM)
 458     parameters.isMediaStream = !!m_mediaStream;
 459 #endif
 460 











 461     return bestMediaEngineForSupportParameters(parameters, current);
 462 }
 463 
 464 void MediaPlayer::loadWithNextMediaEngine(const MediaPlayerFactory* current)
 465 {
 466 #if ENABLE(MEDIA_SOURCE)
 467 #define MEDIASOURCE m_mediaSource
 468 #else
 469 #define MEDIASOURCE 0
 470 #endif
 471 
 472 #if ENABLE(MEDIA_STREAM)
 473 #define MEDIASTREAM m_mediaStream
 474 #else
 475 #define MEDIASTREAM 0
 476 #endif
 477 
 478     ASSERT(!m_initializingMediaEngine);
 479     m_initializingMediaEngine = true;
 480 
 481     const MediaPlayerFactory* engine = nullptr;
 482 
 483     if (!m_contentType.isEmpty() || MEDIASTREAM || MEDIASOURCE)
 484         engine = nextBestMediaEngine(current);
 485 
 486     // If no MIME type is specified or the type was inferred from the file extension, just use the next engine.
 487     if (!engine &amp;&amp; (m_contentType.isEmpty() || m_contentMIMETypeWasInferredFromExtension))
 488         engine = nextMediaEngine(current);
 489 
 490     // Don&#39;t delete and recreate the player unless it comes from a different engine.
 491     if (!engine) {
 492         LOG(Media, &quot;MediaPlayer::loadWithNextMediaEngine - no media engine found for type \&quot;%s\&quot;&quot;, m_contentType.raw().utf8().data());
 493         m_currentMediaEngine = engine;
 494         m_private = nullptr;
 495     } else if (m_currentMediaEngine != engine) {
 496         m_currentMediaEngine = engine;
<span class="line-modified"> 497         m_private = engine-&gt;constructor(this);</span>
<span class="line-modified"> 498         client().mediaPlayerEngineUpdated(this);</span>
<span class="line-modified"> 499         m_private-&gt;setPrivateBrowsingMode(m_privateBrowsing);</span>
<span class="line-modified"> 500         m_private-&gt;setPreload(m_preload);</span>
<span class="line-modified"> 501         m_private-&gt;setPreservesPitch(preservesPitch());</span>
<span class="line-removed"> 502         if (m_shouldPrepareToRender)</span>
<span class="line-removed"> 503             m_private-&gt;prepareForRendering();</span>
 504     }
 505 
 506     if (m_private) {
 507 #if ENABLE(MEDIA_SOURCE)
 508         if (m_mediaSource)
 509             m_private-&gt;load(m_url.string(), m_mediaSource.get());
 510         else
 511 #endif
 512 #if ENABLE(MEDIA_STREAM)
 513         if (m_mediaStream)
 514             m_private-&gt;load(*m_mediaStream);
 515         else
 516 #endif
<span class="line-modified"> 517         m_private-&gt;load(m_url.string());</span>
 518     } else {
 519         m_private = makeUnique&lt;NullMediaPlayerPrivate&gt;(this);
<span class="line-modified"> 520         client().mediaPlayerEngineUpdated(this);</span>
<span class="line-modified"> 521         client().mediaPlayerResourceNotSupported(this);</span>




 522     }
 523 
 524     m_initializingMediaEngine = false;
 525 }
 526 
 527 bool MediaPlayer::hasAvailableVideoFrame() const
 528 {
 529     return m_private-&gt;hasAvailableVideoFrame();
 530 }
 531 
 532 void MediaPlayer::prepareForRendering()
 533 {
 534     m_shouldPrepareToRender = true;
 535     m_private-&gt;prepareForRendering();
 536 }
 537 
<span class="line-removed"> 538 bool MediaPlayer::canLoadPoster() const</span>
<span class="line-removed"> 539 {</span>
<span class="line-removed"> 540     return m_private-&gt;canLoadPoster();</span>
<span class="line-removed"> 541 }</span>
<span class="line-removed"> 542 </span>
<span class="line-removed"> 543 void MediaPlayer::setPoster(const String&amp; url)</span>
<span class="line-removed"> 544 {</span>
<span class="line-removed"> 545     m_private-&gt;setPoster(url);</span>
<span class="line-removed"> 546 }</span>
<span class="line-removed"> 547 </span>
 548 void MediaPlayer::cancelLoad()
 549 {
 550     m_private-&gt;cancelLoad();
 551 }
 552 
 553 void MediaPlayer::prepareToPlay()
 554 {
 555     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 556 
 557     m_private-&gt;prepareToPlay();
 558 }
 559 
 560 void MediaPlayer::play()
 561 {
 562     m_private-&gt;play();
 563 }
 564 
 565 void MediaPlayer::pause()
 566 {
 567     m_private-&gt;pause();
</pre>
<hr />
<pre>
 673 bool MediaPlayer::requiresImmediateCompositing() const
 674 {
 675     return m_private-&gt;requiresImmediateCompositing();
 676 }
 677 
 678 FloatSize MediaPlayer::naturalSize()
 679 {
 680     return m_private-&gt;naturalSize();
 681 }
 682 
 683 bool MediaPlayer::hasVideo() const
 684 {
 685     return m_private-&gt;hasVideo();
 686 }
 687 
 688 bool MediaPlayer::hasAudio() const
 689 {
 690     return m_private-&gt;hasAudio();
 691 }
 692 
<span class="line-removed"> 693 bool MediaPlayer::inMediaDocument() const</span>
<span class="line-removed"> 694 {</span>
<span class="line-removed"> 695     return m_visible &amp;&amp; client().mediaPlayerIsInMediaDocument();</span>
<span class="line-removed"> 696 }</span>
<span class="line-removed"> 697 </span>
 698 PlatformLayer* MediaPlayer::platformLayer() const
 699 {
 700     return m_private-&gt;platformLayer();
 701 }
 702 
 703 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 704 
 705 void MediaPlayer::setVideoFullscreenLayer(PlatformLayer* layer, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
 706 {
 707     m_private-&gt;setVideoFullscreenLayer(layer, WTFMove(completionHandler));
 708 }
 709 
 710 void MediaPlayer::updateVideoFullscreenInlineImage()
 711 {
 712     m_private-&gt;updateVideoFullscreenInlineImage();
 713 }
 714 
 715 void MediaPlayer::setVideoFullscreenFrame(FloatRect frame)
 716 {
 717     m_private-&gt;setVideoFullscreenFrame(frame);
</pre>
<hr />
<pre>
 840 std::unique_ptr&lt;PlatformTimeRanges&gt; MediaPlayer::seekable()
 841 {
 842     return m_private-&gt;seekable();
 843 }
 844 
 845 MediaTime MediaPlayer::maxTimeSeekable()
 846 {
 847     return m_private-&gt;maxMediaTimeSeekable();
 848 }
 849 
 850 MediaTime MediaPlayer::minTimeSeekable()
 851 {
 852     return m_private-&gt;minMediaTimeSeekable();
 853 }
 854 
 855 double MediaPlayer::seekableTimeRangesLastModifiedTime()
 856 {
 857     return m_private-&gt;seekableTimeRangesLastModifiedTime();
 858 }
 859 










 860 double MediaPlayer::liveUpdateInterval()
 861 {
 862     return m_private-&gt;liveUpdateInterval();
 863 }
 864 
 865 bool MediaPlayer::didLoadingProgress()
 866 {
 867     return m_private-&gt;didLoadingProgress();
 868 }
 869 
 870 void MediaPlayer::setSize(const IntSize&amp; size)
 871 {
 872     m_size = size;
 873     m_private-&gt;setSize(size);
 874 }
 875 
 876 bool MediaPlayer::visible() const
 877 {
 878     return m_visible;
 879 }
</pre>
<hr />
<pre>
 888 {
 889     return m_preload;
 890 }
 891 
 892 void MediaPlayer::setPreload(MediaPlayer::Preload preload)
 893 {
 894     m_preload = preload;
 895     m_private-&gt;setPreload(preload);
 896 }
 897 
 898 void MediaPlayer::paint(GraphicsContext&amp; p, const FloatRect&amp; r)
 899 {
 900     m_private-&gt;paint(p, r);
 901 }
 902 
 903 void MediaPlayer::paintCurrentFrameInContext(GraphicsContext&amp; p, const FloatRect&amp; r)
 904 {
 905     m_private-&gt;paintCurrentFrameInContext(p, r);
 906 }
 907 
<span class="line-modified"> 908 bool MediaPlayer::copyVideoTextureToPlatformTexture(GraphicsContext3D* context, Platform3DObject texture, GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY)</span>
 909 {
 910     return m_private-&gt;copyVideoTextureToPlatformTexture(context, texture, target, level, internalFormat, format, type, premultiplyAlpha, flipY);
 911 }
 912 
 913 NativeImagePtr MediaPlayer::nativeImageForCurrentTime()
 914 {
 915     return m_private-&gt;nativeImageForCurrentTime();
 916 }
 917 
 918 MediaPlayer::SupportsType MediaPlayer::supportsType(const MediaEngineSupportParameters&amp; parameters)
 919 {
 920     // 4.8.10.3 MIME types - The canPlayType(type) method must return the empty string if type is a type that the
 921     // user agent knows it cannot render or is the type &quot;application/octet-stream&quot;
 922     AtomString containerType = parameters.type.containerType();
 923     if (containerType == applicationOctetStream())
<span class="line-modified"> 924         return IsNotSupported;</span>
 925 
 926     const MediaPlayerFactory* engine = bestMediaEngineForSupportParameters(parameters);
 927     if (!engine)
<span class="line-modified"> 928         return IsNotSupported;</span>
 929 
 930     return engine-&gt;supportsTypeAndCodecs(parameters);
 931 }
 932 
 933 void MediaPlayer::getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types)
 934 {
 935     for (auto&amp; engine : installedMediaEngines()) {
 936         HashSet&lt;String, ASCIICaseInsensitiveHash&gt; engineTypes;
<span class="line-modified"> 937         engine.getSupportedTypes(engineTypes);</span>
 938         types.add(engineTypes.begin(), engineTypes.end());
 939     }
 940 }
 941 
 942 bool MediaPlayer::isAvailable()
 943 {
 944 #if PLATFORM(IOS_FAMILY)
 945     if (DeprecatedGlobalSettings::isAVFoundationEnabled())
 946         return true;
 947 #endif
 948     return !installedMediaEngines().isEmpty();
 949 }
 950 
 951 bool MediaPlayer::supportsPictureInPicture() const
 952 {
 953     return m_private-&gt;supportsPictureInPicture();
 954 }
 955 
 956 #if USE(NATIVE_FULLSCREEN_VIDEO)
 957 
</pre>
<hr />
<pre>
 977 String MediaPlayer::wirelessPlaybackTargetName() const
 978 {
 979     return m_private-&gt;wirelessPlaybackTargetName();
 980 }
 981 
 982 MediaPlayer::WirelessPlaybackTargetType MediaPlayer::wirelessPlaybackTargetType() const
 983 {
 984     return m_private-&gt;wirelessPlaybackTargetType();
 985 }
 986 
 987 bool MediaPlayer::wirelessVideoPlaybackDisabled() const
 988 {
 989     return m_private-&gt;wirelessVideoPlaybackDisabled();
 990 }
 991 
 992 void MediaPlayer::setWirelessVideoPlaybackDisabled(bool disabled)
 993 {
 994     m_private-&gt;setWirelessVideoPlaybackDisabled(disabled);
 995 }
 996 
<span class="line-modified"> 997 void MediaPlayer::currentPlaybackTargetIsWirelessChanged()</span>
 998 {
<span class="line-modified"> 999     client().mediaPlayerCurrentPlaybackTargetIsWirelessChanged(this);</span>
1000 }
1001 
1002 bool MediaPlayer::canPlayToWirelessPlaybackTarget() const
1003 {
1004     return m_private-&gt;canPlayToWirelessPlaybackTarget();
1005 }
1006 
1007 void MediaPlayer::setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
1008 {
1009     m_private-&gt;setWirelessPlaybackTarget(WTFMove(device));
1010 }
1011 
1012 void MediaPlayer::setShouldPlayToPlaybackTarget(bool shouldPlay)
1013 {
1014     m_private-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
1015 }
1016 
1017 #endif
1018 
1019 double MediaPlayer::maxFastForwardRate() const
</pre>
<hr />
<pre>
1113 }
1114 
1115 void MediaPlayer::reloadTimerFired()
1116 {
1117     m_private-&gt;cancelLoad();
1118     loadWithNextMediaEngine(m_currentMediaEngine);
1119 }
1120 
1121 template&lt;typename T&gt;
1122 static void addToHash(HashSet&lt;T&gt;&amp; toHash, HashSet&lt;T&gt;&amp;&amp; fromHash)
1123 {
1124     if (toHash.isEmpty())
1125         toHash = WTFMove(fromHash);
1126     else
1127         toHash.add(fromHash.begin(), fromHash.end());
1128 }
1129 
1130 HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; MediaPlayer::originsInMediaCache(const String&amp; path)
1131 {
1132     HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; origins;
<span class="line-modified">1133     for (auto&amp; engine : installedMediaEngines()) {</span>
<span class="line-modified">1134         if (!engine.originsInMediaCache)</span>
<span class="line-modified">1135             continue;</span>
<span class="line-removed">1136         addToHash(origins, engine.originsInMediaCache(path));</span>
<span class="line-removed">1137     }</span>
1138     return origins;
1139 }
1140 
1141 void MediaPlayer::clearMediaCache(const String&amp; path, WallTime modifiedSince)
1142 {
<span class="line-modified">1143     for (auto&amp; engine : installedMediaEngines()) {</span>
<span class="line-modified">1144         if (engine.clearMediaCache)</span>
<span class="line-removed">1145             engine.clearMediaCache(path, modifiedSince);</span>
<span class="line-removed">1146     }</span>
1147 }
1148 
1149 void MediaPlayer::clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; origins)
1150 {
<span class="line-modified">1151     for (auto&amp; engine : installedMediaEngines()) {</span>
<span class="line-modified">1152         if (engine.clearMediaCacheForOrigins)</span>
<span class="line-removed">1153             engine.clearMediaCacheForOrigins(path, origins);</span>
<span class="line-removed">1154     }</span>
1155 }
1156 
1157 bool MediaPlayer::supportsKeySystem(const String&amp; keySystem, const String&amp; mimeType)
1158 {
1159     for (auto&amp; engine : installedMediaEngines()) {
<span class="line-modified">1160         if (engine.supportsKeySystem &amp;&amp; engine.supportsKeySystem(keySystem, mimeType))</span>
1161             return true;
1162     }
1163     return false;
1164 }
1165 
1166 void MediaPlayer::setPrivateBrowsingMode(bool privateBrowsingMode)
1167 {
1168     m_privateBrowsing = privateBrowsingMode;
1169     if (m_private)
1170         m_private-&gt;setPrivateBrowsingMode(m_privateBrowsing);
1171 }
1172 
1173 // Client callbacks.
1174 void MediaPlayer::networkStateChanged()
1175 {
1176     // If more than one media engine is installed and this one failed before finding metadata,
1177     // let the next engine try.
<span class="line-modified">1178     if (m_private-&gt;networkState() &gt;= FormatError &amp;&amp; m_private-&gt;readyState() &lt; HaveMetadata) {</span>
1179         client().mediaPlayerEngineFailedToLoad();
<span class="line-modified">1180         if (installedMediaEngines().size() &gt; 1 &amp;&amp; (m_contentType.isEmpty() || nextBestMediaEngine(m_currentMediaEngine))) {</span>
1181             m_reloadTimer.startOneShot(0_s);
1182             return;
1183         }
1184     }
<span class="line-modified">1185     client().mediaPlayerNetworkStateChanged(this);</span>
1186 }
1187 
1188 void MediaPlayer::readyStateChanged()
1189 {
<span class="line-modified">1190     client().mediaPlayerReadyStateChanged(this);</span>
1191 }
1192 
1193 void MediaPlayer::volumeChanged(double newVolume)
1194 {
1195 #if PLATFORM(IOS_FAMILY)
1196     UNUSED_PARAM(newVolume);
1197     m_volume = m_private-&gt;volume();
1198 #else
1199     m_volume = newVolume;
1200 #endif
<span class="line-modified">1201     client().mediaPlayerVolumeChanged(this);</span>
1202 }
1203 
1204 void MediaPlayer::muteChanged(bool newMuted)
1205 {
1206     if (newMuted == m_muted)
1207         return;
1208 
1209     m_muted = newMuted;
<span class="line-modified">1210     client().mediaPlayerMuteChanged(this);</span>
1211 }
1212 
1213 void MediaPlayer::timeChanged()
1214 {
<span class="line-modified">1215     client().mediaPlayerTimeChanged(this);</span>
1216 }
1217 
1218 void MediaPlayer::sizeChanged()
1219 {
<span class="line-modified">1220     client().mediaPlayerSizeChanged(this);</span>
1221 }
1222 
1223 void MediaPlayer::repaint()
1224 {
<span class="line-modified">1225     client().mediaPlayerRepaint(this);</span>
1226 }
1227 
1228 void MediaPlayer::durationChanged()
1229 {
<span class="line-modified">1230     client().mediaPlayerDurationChanged(this);</span>
1231 }
1232 
1233 void MediaPlayer::rateChanged()
1234 {
<span class="line-modified">1235     client().mediaPlayerRateChanged(this);</span>
1236 }
1237 
1238 void MediaPlayer::playbackStateChanged()
1239 {
<span class="line-modified">1240     client().mediaPlayerPlaybackStateChanged(this);</span>
1241 }
1242 
1243 void MediaPlayer::firstVideoFrameAvailable()
1244 {
<span class="line-modified">1245     client().mediaPlayerFirstVideoFrameAvailable(this);</span>
1246 }
1247 
1248 void MediaPlayer::characteristicChanged()
1249 {
<span class="line-modified">1250     client().mediaPlayerCharacteristicChanged(this);</span>
1251 }
1252 
1253 #if ENABLE(WEB_AUDIO)
1254 
1255 AudioSourceProvider* MediaPlayer::audioSourceProvider()
1256 {
1257     return m_private-&gt;audioSourceProvider();
1258 }
1259 
1260 #endif
1261 
1262 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
1263 
1264 RefPtr&lt;ArrayBuffer&gt; MediaPlayer::cachedKeyForKeyId(const String&amp; keyId) const
1265 {
1266     return client().mediaPlayerCachedKeyForKeyId(keyId);
1267 }
1268 
1269 bool MediaPlayer::keyNeeded(Uint8Array* initData)
1270 {
<span class="line-modified">1271     return client().mediaPlayerKeyNeeded(this, initData);</span>
1272 }
1273 
1274 String MediaPlayer::mediaKeysStorageDirectory() const
1275 {
1276     return client().mediaPlayerMediaKeysStorageDirectory();
1277 }
1278 
1279 #endif
1280 
1281 #if ENABLE(ENCRYPTED_MEDIA)
1282 
1283 void MediaPlayer::initializationDataEncountered(const String&amp; initDataType, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; initData)
1284 {
1285     client().mediaPlayerInitializationDataEncountered(initDataType, WTFMove(initData));
1286 }
1287 
1288 void MediaPlayer::waitingForKeyChanged()
1289 {
1290     client().mediaPlayerWaitingForKeyChanged();
1291 }
</pre>
<hr />
<pre>
1310 
1311 String MediaPlayer::engineDescription() const
1312 {
1313     if (!m_private)
1314         return String();
1315 
1316     return m_private-&gt;engineDescription();
1317 }
1318 
1319 long MediaPlayer::platformErrorCode() const
1320 {
1321     if (!m_private)
1322         return 0;
1323 
1324     return m_private-&gt;platformErrorCode();
1325 }
1326 
1327 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
1328 GraphicsDeviceAdapter* MediaPlayer::graphicsDeviceAdapter() const
1329 {
<span class="line-modified">1330     return client().mediaPlayerGraphicsDeviceAdapter(this);</span>
1331 }
1332 #endif
1333 
1334 CachedResourceLoader* MediaPlayer::cachedResourceLoader()
1335 {
1336     return client().mediaPlayerCachedResourceLoader();
1337 }
1338 
1339 RefPtr&lt;PlatformMediaResourceLoader&gt; MediaPlayer::createResourceLoader()
1340 {
1341     return client().mediaPlayerCreateResourceLoader();
1342 }
1343 
1344 #if ENABLE(VIDEO_TRACK)
1345 
1346 void MediaPlayer::addAudioTrack(AudioTrackPrivate&amp; track)
1347 {
1348     client().mediaPlayerDidAddAudioTrack(track);
1349 }
1350 
</pre>
<hr />
<pre>
1460 {
1461     if (!m_private)
1462         return 0;
1463 
1464     return m_private-&gt;fileSize();
1465 }
1466 
1467 bool MediaPlayer::ended() const
1468 {
1469     return m_private-&gt;ended();
1470 }
1471 
1472 Optional&lt;VideoPlaybackQualityMetrics&gt; MediaPlayer::videoPlaybackQualityMetrics()
1473 {
1474     if (!m_private)
1475         return WTF::nullopt;
1476 
1477     return m_private-&gt;videoPlaybackQualityMetrics();
1478 }
1479 
<span class="line-removed">1480 void MediaPlayer::handlePlaybackCommand(PlatformMediaSession::RemoteControlCommandType command)</span>
<span class="line-removed">1481 {</span>
<span class="line-removed">1482     client().mediaPlayerHandlePlaybackCommand(command);</span>
<span class="line-removed">1483 }</span>
<span class="line-removed">1484 </span>
1485 String MediaPlayer::sourceApplicationIdentifier() const
1486 {
1487     return client().mediaPlayerSourceApplicationIdentifier();
1488 }
1489 
1490 Vector&lt;String&gt; MediaPlayer::preferredAudioCharacteristics() const
1491 {
1492     return client().mediaPlayerPreferredAudioCharacteristics();
1493 }
1494 
1495 void MediaPlayerFactorySupport::callRegisterMediaEngine(MediaEngineRegister registerMediaEngine)
1496 {
1497     registerMediaEngine(addMediaEngine);
1498 }
1499 
1500 bool MediaPlayer::doesHaveAttribute(const AtomString&amp; attribute, AtomString* value) const
1501 {
1502     return client().doesHaveAttribute(attribute, value);
1503 }
1504 
</pre>
<hr />
<pre>
1547 
1548 #if USE(AVFOUNDATION)
1549 
1550 AVPlayer* MediaPlayer::objCAVFoundationAVPlayer() const
1551 {
1552     return m_private-&gt;objCAVFoundationAVPlayer();
1553 }
1554 
1555 #endif
1556 
1557 bool MediaPlayer::performTaskAtMediaTime(WTF::Function&lt;void()&gt;&amp;&amp; task, MediaTime time)
1558 {
1559     return m_private-&gt;performTaskAtMediaTime(WTFMove(task), time);
1560 }
1561 
1562 bool MediaPlayer::shouldIgnoreIntrinsicSize()
1563 {
1564     return m_private-&gt;shouldIgnoreIntrinsicSize();
1565 }
1566 





1567 #if !RELEASE_LOG_DISABLED
1568 const Logger&amp; MediaPlayer::mediaPlayerLogger()
1569 {
1570     return client().mediaPlayerLogger();
1571 }
1572 #endif
1573 
<span class="line-modified">1574 String convertEnumerationToString(MediaPlayerEnums::ReadyState enumerationValue)</span>
1575 {
1576     static const NeverDestroyed&lt;String&gt; values[] = {
1577         MAKE_STATIC_STRING_IMPL(&quot;HaveNothing&quot;),
1578         MAKE_STATIC_STRING_IMPL(&quot;HaveMetadata&quot;),
1579         MAKE_STATIC_STRING_IMPL(&quot;HaveCurrentData&quot;),
1580         MAKE_STATIC_STRING_IMPL(&quot;HaveFutureData&quot;),
1581         MAKE_STATIC_STRING_IMPL(&quot;HaveEnoughData&quot;),
1582     };
<span class="line-modified">1583     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveNothing) == 0, &quot;MediaPlayerEnums::HaveNothing is not 0 as expected&quot;);</span>
<span class="line-modified">1584     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveMetadata) == 1, &quot;MediaPlayerEnums::HaveMetadata is not 1 as expected&quot;);</span>
<span class="line-modified">1585     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveCurrentData) == 2, &quot;MediaPlayerEnums::HaveCurrentData is not 2 as expected&quot;);</span>
<span class="line-modified">1586     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveFutureData) == 3, &quot;MediaPlayerEnums::HaveFutureData is not 3 as expected&quot;);</span>
<span class="line-modified">1587     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveEnoughData) == 4, &quot;MediaPlayerEnums::HaveEnoughData is not 4 as expected&quot;);</span>
1588     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1589     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1590 }
1591 
<span class="line-modified">1592 String convertEnumerationToString(MediaPlayerEnums::NetworkState enumerationValue)</span>
1593 {
1594     static const NeverDestroyed&lt;String&gt; values[] = {
1595         MAKE_STATIC_STRING_IMPL(&quot;Empty&quot;),
1596         MAKE_STATIC_STRING_IMPL(&quot;Idle&quot;),
1597         MAKE_STATIC_STRING_IMPL(&quot;Loading&quot;),
1598         MAKE_STATIC_STRING_IMPL(&quot;Loaded&quot;),
1599         MAKE_STATIC_STRING_IMPL(&quot;FormatError&quot;),
1600         MAKE_STATIC_STRING_IMPL(&quot;NetworkError&quot;),
1601         MAKE_STATIC_STRING_IMPL(&quot;DecodeError&quot;),
1602     };
<span class="line-modified">1603     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Empty) == 0, &quot;MediaPlayerEnums::Empty is not 0 as expected&quot;);</span>
<span class="line-modified">1604     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Idle) == 1, &quot;MediaPlayerEnums::Idle is not 1 as expected&quot;);</span>
<span class="line-modified">1605     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Loading) == 2, &quot;MediaPlayerEnums::Loading is not 2 as expected&quot;);</span>
<span class="line-modified">1606     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Loaded) == 3, &quot;MediaPlayerEnums::Loaded is not 3 as expected&quot;);</span>
<span class="line-modified">1607     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::FormatError) == 4, &quot;MediaPlayerEnums::FormatError is not 4 as expected&quot;);</span>
<span class="line-modified">1608     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::NetworkError) == 5, &quot;MediaPlayerEnums::NetworkError is not 5 as expected&quot;);</span>
<span class="line-modified">1609     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::DecodeError) == 6, &quot;MediaPlayerEnums::DecodeError is not 6 as expected&quot;);</span>
1610     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1611     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1612 }
1613 
<span class="line-modified">1614 String convertEnumerationToString(MediaPlayerEnums::Preload enumerationValue)</span>
1615 {
1616     static const NeverDestroyed&lt;String&gt; values[] = {
1617         MAKE_STATIC_STRING_IMPL(&quot;None&quot;),
1618         MAKE_STATIC_STRING_IMPL(&quot;MetaData&quot;),
1619         MAKE_STATIC_STRING_IMPL(&quot;Auto&quot;),
1620     };
<span class="line-modified">1621     static_assert(!static_cast&lt;size_t&gt;(MediaPlayerEnums::None), &quot;MediaPlayerEnums::None is not 0 as expected&quot;);</span>
<span class="line-modified">1622     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::MetaData) == 1, &quot;MediaPlayerEnums::MetaData is not 1 as expected&quot;);</span>
<span class="line-modified">1623     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Auto) == 2, &quot;MediaPlayerEnums::Auto is not 2 as expected&quot;);</span>
1624     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1625     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1626 }
1627 
<span class="line-modified">1628 String convertEnumerationToString(MediaPlayerEnums::SupportsType enumerationValue)</span>
1629 {
1630     static const NeverDestroyed&lt;String&gt; values[] = {
1631         MAKE_STATIC_STRING_IMPL(&quot;IsNotSupported&quot;),
1632         MAKE_STATIC_STRING_IMPL(&quot;IsSupported&quot;),
1633         MAKE_STATIC_STRING_IMPL(&quot;MayBeSupported&quot;),
1634     };
<span class="line-modified">1635     static_assert(!static_cast&lt;size_t&gt;(MediaPlayerEnums::IsNotSupported), &quot;MediaPlayerEnums::IsNotSupported is not 0 as expected&quot;);</span>
<span class="line-modified">1636     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::IsSupported) == 1, &quot;MediaPlayerEnums::IsSupported is not 1 as expected&quot;);</span>
<span class="line-modified">1637     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::MayBeSupported) == 2, &quot;MediaPlayerEnums::MayBeSupported is not 2 as expected&quot;);</span>
1638     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1639     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1640 }
1641 
<span class="line-modified">1642 String convertEnumerationToString(MediaPlayerEnums::BufferingPolicy enumerationValue)</span>
1643 {
1644     static const NeverDestroyed&lt;String&gt; values[] = {
1645         MAKE_STATIC_STRING_IMPL(&quot;Default&quot;),
1646         MAKE_STATIC_STRING_IMPL(&quot;LimitReadAhead&quot;),
1647         MAKE_STATIC_STRING_IMPL(&quot;MakeResourcesPurgeable&quot;),
1648         MAKE_STATIC_STRING_IMPL(&quot;PurgeResources&quot;),
1649     };
<span class="line-modified">1650     static_assert(!static_cast&lt;size_t&gt;(MediaPlayerEnums::BufferingPolicy::Default), &quot;MediaPlayerEnums::Default is not 0 as expected&quot;);</span>
<span class="line-modified">1651     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::BufferingPolicy::LimitReadAhead) == 1, &quot;MediaPlayerEnums::LimitReadAhead is not 1 as expected&quot;);</span>
<span class="line-modified">1652     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::BufferingPolicy::MakeResourcesPurgeable) == 2, &quot;MediaPlayerEnums::MakeResourcesPurgeable is not 2 as expected&quot;);</span>
<span class="line-modified">1653     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::BufferingPolicy::PurgeResources) == 3, &quot;MediaPlayerEnums::PurgeResources is not 3 as expected&quot;);</span>
1654     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1655     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1656 }
1657 
1658 }
1659 
1660 #endif
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  78 #include &quot;MediaPlayerPrivateMediaStreamAVFObjC.h&quot;
  79 #endif
  80 
  81 #endif // PLATFORM(COCOA)
  82 
  83 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION) &amp;&amp; !USE(GSTREAMER)
  84 #include &quot;MediaPlayerPrivateAVFoundationCF.h&quot;
  85 #endif // USE(AVFOUNDATION)
  86 
  87 #if PLATFORM(JAVA)
  88 #include &quot;MediaPlayerPrivateJava.h&quot;
  89 #define PlatformMediaEngineClassName MediaPlayerPrivate
  90 #endif  // PLATFORM(JAVA)
  91 
  92 #if USE(EXTERNAL_HOLEPUNCH)
  93 #include &quot;MediaPlayerPrivateHolePunch.h&quot;
  94 #endif
  95 
  96 namespace WebCore {
  97 








  98 // a null player to make MediaPlayer logic simpler
  99 
 100 class NullMediaPlayerPrivate final : public MediaPlayerPrivateInterface {
 101 public:
 102     explicit NullMediaPlayerPrivate(MediaPlayer*) { }
 103 
 104     void load(const String&amp;) final { }
 105 #if ENABLE(MEDIA_SOURCE)
 106     void load(const String&amp;, MediaSourcePrivateClient*) final { }
 107 #endif
 108 #if ENABLE(MEDIA_STREAM)
 109     void load(MediaStreamPrivate&amp;) final { }
 110 #endif
 111     void cancelLoad() final { }
 112 
 113     void prepareToPlay() final { }
 114     void play() final { }
 115     void pause() final { }
 116 
<span class="line-modified"> 117     PlatformLayer* platformLayer() const final { return nullptr; }</span>
 118 
 119     FloatSize naturalSize() const final { return FloatSize(); }
 120 
 121     bool hasVideo() const final { return false; }
 122     bool hasAudio() const final { return false; }
 123 
 124     void setVisible(bool) final { }
 125 
 126     double durationDouble() const final { return 0; }
 127 
 128     double currentTimeDouble() const final { return 0; }
 129     void seekDouble(double) final { }
 130     bool seeking() const final { return false; }
 131 
 132     void setRateDouble(double) final { }
 133     void setPreservesPitch(bool) final { }
 134     bool paused() const final { return true; }
 135 
 136     void setVolumeDouble(double) final { }
 137 
 138     void setMuted(bool) final { }
 139 
 140     bool hasClosedCaptions() const final { return false; }
 141     void setClosedCaptionsVisible(bool) final { };
 142 
<span class="line-modified"> 143     MediaPlayer::NetworkState networkState() const final { return MediaPlayer::NetworkState::Empty; }</span>
<span class="line-modified"> 144     MediaPlayer::ReadyState readyState() const final { return MediaPlayer::ReadyState::HaveNothing; }</span>
 145 
 146     float maxTimeSeekable() const final { return 0; }
 147     double minTimeSeekable() const final { return 0; }
 148     std::unique_ptr&lt;PlatformTimeRanges&gt; buffered() const final { return makeUnique&lt;PlatformTimeRanges&gt;(); }
 149 
 150     double seekableTimeRangesLastModifiedTime() const final { return 0; }
 151     double liveUpdateInterval() const final { return 0; }
 152 
 153     unsigned long long totalBytes() const final { return 0; }
 154     bool didLoadingProgress() const final { return false; }
 155 
 156     void setSize(const IntSize&amp;) final { }
 157 
 158     void paint(GraphicsContext&amp;, const FloatRect&amp;) final { }
 159 



 160     bool hasSingleSecurityOrigin() const final { return true; }
 161 };
 162 
<span class="line-added"> 163 #if !RELEASE_LOG_DISABLED</span>
<span class="line-added"> 164 static RefPtr&lt;Logger&gt;&amp; nullLogger()</span>
<span class="line-added"> 165 {</span>
<span class="line-added"> 166     static NeverDestroyed&lt;RefPtr&lt;Logger&gt;&gt; logger;</span>
<span class="line-added"> 167     return logger;</span>
<span class="line-added"> 168 }</span>
<span class="line-added"> 169 #endif</span>
<span class="line-added"> 170 </span>
<span class="line-added"> 171 static const Vector&lt;WebCore::ContentType&gt;&amp; nullContentTypeVector()</span>
<span class="line-added"> 172 {</span>
<span class="line-added"> 173     static NeverDestroyed&lt;Vector&lt;WebCore::ContentType&gt;&gt; vector;</span>
<span class="line-added"> 174     return vector;</span>
<span class="line-added"> 175 }</span>
<span class="line-added"> 176 </span>
 177 class NullMediaPlayerClient : public MediaPlayerClient {
<span class="line-modified"> 178 private:</span>
 179 #if !RELEASE_LOG_DISABLED
 180     const Logger&amp; mediaPlayerLogger() final
 181     {
 182         if (!nullLogger().get()) {
 183             nullLogger() = Logger::create(this);
 184             nullLogger()-&gt;setEnabled(this, false);
 185         }
 186 
 187         return *nullLogger().get();
 188     }
 189 #endif
<span class="line-added"> 190 </span>
<span class="line-added"> 191     const Vector&lt;WebCore::ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const final { return nullContentTypeVector(); }</span>
 192 };
 193 
<span class="line-added"> 194 </span>
 195 const Vector&lt;ContentType&gt;&amp; MediaPlayerClient::mediaContentTypesRequiringHardwareSupport() const
 196 {
 197     static NeverDestroyed&lt;Vector&lt;ContentType&gt;&gt; contentTypes;
 198     return contentTypes;
 199 }
 200 
 201 static MediaPlayerClient&amp; nullMediaPlayerClient()
 202 {
 203     static NeverDestroyed&lt;NullMediaPlayerClient&gt; client;
 204     return client.get();
 205 }
 206 
 207 // engine support
 208 
<span class="line-modified"> 209 static void addMediaEngine(std::unique_ptr&lt;MediaPlayerFactory&gt;&amp;&amp;);</span>










 210 
 211 static Lock mediaEngineVectorLock;
 212 
 213 static bool&amp; haveMediaEnginesVector()
 214 {
 215     static bool haveVector;
 216     return haveVector;
 217 }
 218 
<span class="line-modified"> 219 static Vector&lt;std::unique_ptr&lt;MediaPlayerFactory&gt;&gt;&amp; mutableInstalledMediaEnginesVector()</span>
 220 {
<span class="line-modified"> 221     static NeverDestroyed&lt;Vector&lt;std::unique_ptr&lt;MediaPlayerFactory&gt;&gt;&gt; installedEngines;</span>
 222     return installedEngines;
 223 }
 224 
<span class="line-added"> 225 static RemoteMediaPlayerSupport::RegisterRemotePlayerCallback&amp; registerRemotePlayerCallback()</span>
<span class="line-added"> 226 {</span>
<span class="line-added"> 227     static NeverDestroyed&lt;RemoteMediaPlayerSupport::RegisterRemotePlayerCallback&gt; callback;</span>
<span class="line-added"> 228     return callback;</span>
<span class="line-added"> 229 }</span>
<span class="line-added"> 230 </span>
<span class="line-added"> 231 void RemoteMediaPlayerSupport::setRegisterRemotePlayerCallback(RegisterRemotePlayerCallback&amp;&amp; callback)</span>
<span class="line-added"> 232 {</span>
<span class="line-added"> 233     registerRemotePlayerCallback() = WTFMove(callback);</span>
<span class="line-added"> 234 }</span>
<span class="line-added"> 235 </span>
 236 static void buildMediaEnginesVector()
 237 {
 238     ASSERT(mediaEngineVectorLock.isLocked());
 239 
 240 #if USE(AVFOUNDATION)
<span class="line-added"> 241 </span>
 242     if (DeprecatedGlobalSettings::isAVFoundationEnabled()) {
 243 
<span class="line-added"> 244         auto&amp; registerRemoteEngine = registerRemotePlayerCallback();</span>
 245 #if PLATFORM(COCOA)
<span class="line-modified"> 246         if (registerRemoteEngine)</span>
<span class="line-added"> 247             registerRemoteEngine(addMediaEngine, MediaPlayerEnums::MediaEngineIdentifier::AVFoundation);</span>
<span class="line-added"> 248         else</span>
<span class="line-added"> 249             MediaPlayerPrivateAVFoundationObjC::registerMediaEngine(addMediaEngine);</span>
 250 #endif
 251 
 252 #if ENABLE(MEDIA_SOURCE)
 253         MediaPlayerPrivateMediaSourceAVFObjC::registerMediaEngine(addMediaEngine);
 254 #endif
 255 
 256 #if ENABLE(MEDIA_STREAM)
 257         MediaPlayerPrivateMediaStreamAVFObjC::registerMediaEngine(addMediaEngine);
 258 #endif
 259 
 260 #if PLATFORM(WIN)
 261         MediaPlayerPrivateAVFoundationCF::registerMediaEngine(addMediaEngine);
 262 #endif
 263     }
 264 #endif // USE(AVFOUNDATION)
 265 
 266 #if defined(PlatformMediaEngineClassName)
 267 #if USE(GSTREAMER)
 268     if (DeprecatedGlobalSettings::isGStreamerEnabled())
 269 #endif
 270         PlatformMediaEngineClassName::registerMediaEngine(addMediaEngine);
 271 #endif
 272 
 273 #if USE(GSTREAMER) &amp;&amp; ENABLE(MEDIA_SOURCE) &amp;&amp; ENABLE(VIDEO_TRACK)
 274     if (DeprecatedGlobalSettings::isGStreamerEnabled())
 275         MediaPlayerPrivateGStreamerMSE::registerMediaEngine(addMediaEngine);
 276 #endif
 277 
 278 #if USE(EXTERNAL_HOLEPUNCH)
 279     MediaPlayerPrivateHolePunch::registerMediaEngine(addMediaEngine);
 280 #endif
 281 
 282     haveMediaEnginesVector() = true;
 283 }
 284 
<span class="line-modified"> 285 static const Vector&lt;std::unique_ptr&lt;MediaPlayerFactory&gt;&gt;&amp; installedMediaEngines()</span>
 286 {
 287     {
 288         auto locker = holdLock(mediaEngineVectorLock);
 289         if (!haveMediaEnginesVector())
 290             buildMediaEnginesVector();
 291     }
 292 
 293     return mutableInstalledMediaEnginesVector();
 294 }
 295 
<span class="line-modified"> 296 static void addMediaEngine(std::unique_ptr&lt;MediaPlayerFactory&gt;&amp;&amp; factory)</span>

 297 {
<span class="line-modified"> 298     mutableInstalledMediaEnginesVector().append(WTFMove(factory));</span>




 299 }
 300 
 301 static const AtomString&amp; applicationOctetStream()
 302 {
 303     static NeverDestroyed&lt;const AtomString&gt; applicationOctetStream(&quot;application/octet-stream&quot;, AtomString::ConstructFromLiteral);
 304     return applicationOctetStream;
 305 }
 306 
 307 static const AtomString&amp; textPlain()
 308 {
 309     static NeverDestroyed&lt;const AtomString&gt; textPlain(&quot;text/plain&quot;, AtomString::ConstructFromLiteral);
 310     return textPlain;
 311 }
 312 
<span class="line-added"> 313 const MediaPlayerFactory* MediaPlayer::mediaEngine(MediaPlayerEnums::MediaEngineIdentifier identifier)</span>
<span class="line-added"> 314 {</span>
<span class="line-added"> 315     auto&amp; engines = installedMediaEngines();</span>
<span class="line-added"> 316     auto currentIndex = engines.findMatching([identifier] (auto&amp; engine) {</span>
<span class="line-added"> 317         return engine-&gt;identifier() == identifier;</span>
<span class="line-added"> 318     });</span>
<span class="line-added"> 319 </span>
<span class="line-added"> 320     if (currentIndex == notFound) {</span>
<span class="line-added"> 321         ASSERT_NOT_REACHED();</span>
<span class="line-added"> 322         return nullptr;</span>
<span class="line-added"> 323     }</span>
<span class="line-added"> 324 </span>
<span class="line-added"> 325     return engines[currentIndex].get();</span>
<span class="line-added"> 326 }</span>
<span class="line-added"> 327 </span>
 328 static const MediaPlayerFactory* bestMediaEngineForSupportParameters(const MediaEngineSupportParameters&amp; parameters, const MediaPlayerFactory* current = nullptr)
 329 {
 330     if (parameters.type.isEmpty() &amp;&amp; !parameters.isMediaSource &amp;&amp; !parameters.isMediaStream)
 331         return nullptr;
 332 
 333     // 4.8.10.3 MIME types - In the absence of a specification to the contrary, the MIME type &quot;application/octet-stream&quot;
 334     // when used with parameters, e.g. &quot;application/octet-stream;codecs=theora&quot;, is a type that the user agent knows
 335     // it cannot render.
 336     if (parameters.type.containerType() == applicationOctetStream()) {
 337         if (!parameters.type.codecs().isEmpty())
 338             return nullptr;
 339     }
 340 
 341     const MediaPlayerFactory* foundEngine = nullptr;
<span class="line-modified"> 342     MediaPlayer::SupportsType supported = MediaPlayer::SupportsType::IsNotSupported;</span>
 343     for (auto&amp; engine : installedMediaEngines()) {
 344         if (current) {
<span class="line-modified"> 345             if (current == engine.get())</span>
 346                 current = nullptr;
 347             continue;
 348         }
<span class="line-modified"> 349         MediaPlayer::SupportsType engineSupport = engine-&gt;supportsTypeAndCodecs(parameters);</span>
 350         if (engineSupport &gt; supported) {
 351             supported = engineSupport;
<span class="line-modified"> 352             foundEngine = engine.get();</span>
 353         }
 354     }
 355 
 356     return foundEngine;
 357 }
 358 
<span class="line-modified"> 359 const MediaPlayerFactory* MediaPlayer::nextMediaEngine(const MediaPlayerFactory* current)</span>
 360 {
<span class="line-added"> 361     if (m_activeEngineIdentifier) {</span>
<span class="line-added"> 362         auto* engine = mediaEngine(m_activeEngineIdentifier.value());</span>
<span class="line-added"> 363         return current != engine ? engine : nullptr;</span>
<span class="line-added"> 364     }</span>
<span class="line-added"> 365 </span>
 366     auto&amp; engines = installedMediaEngines();
 367     if (engines.isEmpty())
 368         return nullptr;
 369 
 370     if (!current)
<span class="line-modified"> 371         return engines.first().get();</span>
<span class="line-added"> 372 </span>
<span class="line-added"> 373     auto currentIndex = engines.findMatching([current] (auto&amp; engine) {</span>
<span class="line-added"> 374         return engine.get() == current;</span>
<span class="line-added"> 375     });</span>
<span class="line-added"> 376     if (currentIndex == notFound) {</span>
<span class="line-added"> 377         ASSERT_NOT_REACHED();</span>
<span class="line-added"> 378         return nullptr;</span>
<span class="line-added"> 379     }</span>
 380 

 381     if (currentIndex + 1 &gt;= engines.size())
 382         return nullptr;
 383 
<span class="line-modified"> 384     return engines[currentIndex + 1].get();</span>
 385 }
 386 
 387 // media player
 388 
 389 Ref&lt;MediaPlayer&gt; MediaPlayer::create(MediaPlayerClient&amp; client)
 390 {
 391     return adoptRef(*new MediaPlayer(client));
 392 }
 393 
<span class="line-added"> 394 Ref&lt;MediaPlayer&gt; MediaPlayer::create(MediaPlayerClient&amp; client, MediaPlayerEnums::MediaEngineIdentifier mediaEngineIdentifier)</span>
<span class="line-added"> 395 {</span>
<span class="line-added"> 396     return adoptRef(*new MediaPlayer(client, mediaEngineIdentifier));</span>
<span class="line-added"> 397 }</span>
<span class="line-added"> 398 </span>
 399 MediaPlayer::MediaPlayer(MediaPlayerClient&amp; client)
 400     : m_client(&amp;client)
 401     , m_reloadTimer(*this, &amp;MediaPlayer::reloadTimerFired)
 402     , m_private(makeUnique&lt;NullMediaPlayerPrivate&gt;(this))
 403 {
 404 }
 405 
<span class="line-added"> 406 MediaPlayer::MediaPlayer(MediaPlayerClient&amp; client, MediaPlayerEnums::MediaEngineIdentifier mediaEngineIdentifier)</span>
<span class="line-added"> 407     : m_client(&amp;client)</span>
<span class="line-added"> 408     , m_reloadTimer(*this, &amp;MediaPlayer::reloadTimerFired)</span>
<span class="line-added"> 409     , m_private(makeUnique&lt;NullMediaPlayerPrivate&gt;(this))</span>
<span class="line-added"> 410     , m_activeEngineIdentifier(mediaEngineIdentifier)</span>
<span class="line-added"> 411 {</span>
<span class="line-added"> 412 }</span>
<span class="line-added"> 413 </span>
 414 MediaPlayer::~MediaPlayer()
 415 {
 416     ASSERT(!m_initializingMediaEngine);
 417 }
 418 
 419 void MediaPlayer::invalidate()
 420 {
 421     m_client = &amp;nullMediaPlayerClient();
 422 }
 423 
 424 bool MediaPlayer::load(const URL&amp; url, const ContentType&amp; contentType, const String&amp; keySystem)
 425 {
 426     ASSERT(!m_reloadTimer.isActive());
 427 
 428     // Protect against MediaPlayer being destroyed during a MediaPlayerClient callback.
 429     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 430 
 431     m_contentType = contentType;
 432     m_url = url;
 433     m_keySystem = keySystem.convertToASCIILowercase();
</pre>
<hr />
<pre>
 476     m_contentMIMETypeWasInferredFromExtension = false;
 477     loadWithNextMediaEngine(nullptr);
 478     return m_currentMediaEngine;
 479 }
 480 #endif
 481 
 482 #if ENABLE(MEDIA_STREAM)
 483 bool MediaPlayer::load(MediaStreamPrivate&amp; mediaStream)
 484 {
 485     ASSERT(!m_reloadTimer.isActive());
 486 
 487     m_mediaStream = &amp;mediaStream;
 488     m_keySystem = emptyString();
 489     m_contentType = { };
 490     m_contentMIMETypeWasInferredFromExtension = false;
 491     loadWithNextMediaEngine(nullptr);
 492     return m_currentMediaEngine;
 493 }
 494 #endif
 495 
<span class="line-modified"> 496 const MediaPlayerFactory* MediaPlayer::nextBestMediaEngine(const MediaPlayerFactory* current)</span>
 497 {
 498     MediaEngineSupportParameters parameters;
 499     parameters.type = m_contentType;
 500     parameters.url = m_url;
 501 #if ENABLE(MEDIA_SOURCE)
 502     parameters.isMediaSource = !!m_mediaSource;
 503 #endif
 504 #if ENABLE(MEDIA_STREAM)
 505     parameters.isMediaStream = !!m_mediaStream;
 506 #endif
 507 
<span class="line-added"> 508     if (m_activeEngineIdentifier) {</span>
<span class="line-added"> 509         if (current)</span>
<span class="line-added"> 510             return nullptr;</span>
<span class="line-added"> 511 </span>
<span class="line-added"> 512         auto* engine = mediaEngine(m_activeEngineIdentifier.value());</span>
<span class="line-added"> 513         if (engine &amp;&amp; engine-&gt;supportsTypeAndCodecs(parameters) != SupportsType::IsNotSupported)</span>
<span class="line-added"> 514             return engine;</span>
<span class="line-added"> 515 </span>
<span class="line-added"> 516         return nullptr;</span>
<span class="line-added"> 517     }</span>
<span class="line-added"> 518 </span>
 519     return bestMediaEngineForSupportParameters(parameters, current);
 520 }
 521 
 522 void MediaPlayer::loadWithNextMediaEngine(const MediaPlayerFactory* current)
 523 {
 524 #if ENABLE(MEDIA_SOURCE)
 525 #define MEDIASOURCE m_mediaSource
 526 #else
 527 #define MEDIASOURCE 0
 528 #endif
 529 
 530 #if ENABLE(MEDIA_STREAM)
 531 #define MEDIASTREAM m_mediaStream
 532 #else
 533 #define MEDIASTREAM 0
 534 #endif
 535 
 536     ASSERT(!m_initializingMediaEngine);
 537     m_initializingMediaEngine = true;
 538 
 539     const MediaPlayerFactory* engine = nullptr;
 540 
 541     if (!m_contentType.isEmpty() || MEDIASTREAM || MEDIASOURCE)
 542         engine = nextBestMediaEngine(current);
 543 
 544     // If no MIME type is specified or the type was inferred from the file extension, just use the next engine.
 545     if (!engine &amp;&amp; (m_contentType.isEmpty() || m_contentMIMETypeWasInferredFromExtension))
 546         engine = nextMediaEngine(current);
 547 
 548     // Don&#39;t delete and recreate the player unless it comes from a different engine.
 549     if (!engine) {
 550         LOG(Media, &quot;MediaPlayer::loadWithNextMediaEngine - no media engine found for type \&quot;%s\&quot;&quot;, m_contentType.raw().utf8().data());
 551         m_currentMediaEngine = engine;
 552         m_private = nullptr;
 553     } else if (m_currentMediaEngine != engine) {
 554         m_currentMediaEngine = engine;
<span class="line-modified"> 555         m_private = engine-&gt;createMediaEnginePlayer(this);</span>
<span class="line-modified"> 556         if (m_private) {</span>
<span class="line-modified"> 557             client().mediaPlayerEngineUpdated();</span>
<span class="line-modified"> 558             m_private-&gt;prepareForPlayback(m_privateBrowsing, m_preload, m_preservesPitch, m_shouldPrepareToRender);</span>
<span class="line-modified"> 559         }</span>


 560     }
 561 
 562     if (m_private) {
 563 #if ENABLE(MEDIA_SOURCE)
 564         if (m_mediaSource)
 565             m_private-&gt;load(m_url.string(), m_mediaSource.get());
 566         else
 567 #endif
 568 #if ENABLE(MEDIA_STREAM)
 569         if (m_mediaStream)
 570             m_private-&gt;load(*m_mediaStream);
 571         else
 572 #endif
<span class="line-modified"> 573         m_private-&gt;load(m_url, m_contentType, m_keySystem);</span>
 574     } else {
 575         m_private = makeUnique&lt;NullMediaPlayerPrivate&gt;(this);
<span class="line-modified"> 576         if (!m_activeEngineIdentifier &amp;&amp; installedMediaEngines().size() &gt; 1 &amp;&amp; nextBestMediaEngine(m_currentMediaEngine))</span>
<span class="line-modified"> 577             m_reloadTimer.startOneShot(0_s);</span>
<span class="line-added"> 578         else {</span>
<span class="line-added"> 579             client().mediaPlayerEngineUpdated();</span>
<span class="line-added"> 580             client().mediaPlayerResourceNotSupported();</span>
<span class="line-added"> 581         }</span>
 582     }
 583 
 584     m_initializingMediaEngine = false;
 585 }
 586 
 587 bool MediaPlayer::hasAvailableVideoFrame() const
 588 {
 589     return m_private-&gt;hasAvailableVideoFrame();
 590 }
 591 
 592 void MediaPlayer::prepareForRendering()
 593 {
 594     m_shouldPrepareToRender = true;
 595     m_private-&gt;prepareForRendering();
 596 }
 597 










 598 void MediaPlayer::cancelLoad()
 599 {
 600     m_private-&gt;cancelLoad();
 601 }
 602 
 603 void MediaPlayer::prepareToPlay()
 604 {
 605     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 606 
 607     m_private-&gt;prepareToPlay();
 608 }
 609 
 610 void MediaPlayer::play()
 611 {
 612     m_private-&gt;play();
 613 }
 614 
 615 void MediaPlayer::pause()
 616 {
 617     m_private-&gt;pause();
</pre>
<hr />
<pre>
 723 bool MediaPlayer::requiresImmediateCompositing() const
 724 {
 725     return m_private-&gt;requiresImmediateCompositing();
 726 }
 727 
 728 FloatSize MediaPlayer::naturalSize()
 729 {
 730     return m_private-&gt;naturalSize();
 731 }
 732 
 733 bool MediaPlayer::hasVideo() const
 734 {
 735     return m_private-&gt;hasVideo();
 736 }
 737 
 738 bool MediaPlayer::hasAudio() const
 739 {
 740     return m_private-&gt;hasAudio();
 741 }
 742 





 743 PlatformLayer* MediaPlayer::platformLayer() const
 744 {
 745     return m_private-&gt;platformLayer();
 746 }
 747 
 748 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 749 
 750 void MediaPlayer::setVideoFullscreenLayer(PlatformLayer* layer, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
 751 {
 752     m_private-&gt;setVideoFullscreenLayer(layer, WTFMove(completionHandler));
 753 }
 754 
 755 void MediaPlayer::updateVideoFullscreenInlineImage()
 756 {
 757     m_private-&gt;updateVideoFullscreenInlineImage();
 758 }
 759 
 760 void MediaPlayer::setVideoFullscreenFrame(FloatRect frame)
 761 {
 762     m_private-&gt;setVideoFullscreenFrame(frame);
</pre>
<hr />
<pre>
 885 std::unique_ptr&lt;PlatformTimeRanges&gt; MediaPlayer::seekable()
 886 {
 887     return m_private-&gt;seekable();
 888 }
 889 
 890 MediaTime MediaPlayer::maxTimeSeekable()
 891 {
 892     return m_private-&gt;maxMediaTimeSeekable();
 893 }
 894 
 895 MediaTime MediaPlayer::minTimeSeekable()
 896 {
 897     return m_private-&gt;minMediaTimeSeekable();
 898 }
 899 
 900 double MediaPlayer::seekableTimeRangesLastModifiedTime()
 901 {
 902     return m_private-&gt;seekableTimeRangesLastModifiedTime();
 903 }
 904 
<span class="line-added"> 905 void MediaPlayer::bufferedTimeRangesChanged()</span>
<span class="line-added"> 906 {</span>
<span class="line-added"> 907     client().mediaPlayerBufferedTimeRangesChanged();</span>
<span class="line-added"> 908 }</span>
<span class="line-added"> 909 </span>
<span class="line-added"> 910 void MediaPlayer::seekableTimeRangesChanged()</span>
<span class="line-added"> 911 {</span>
<span class="line-added"> 912     client().mediaPlayerSeekableTimeRangesChanged();</span>
<span class="line-added"> 913 }</span>
<span class="line-added"> 914 </span>
 915 double MediaPlayer::liveUpdateInterval()
 916 {
 917     return m_private-&gt;liveUpdateInterval();
 918 }
 919 
 920 bool MediaPlayer::didLoadingProgress()
 921 {
 922     return m_private-&gt;didLoadingProgress();
 923 }
 924 
 925 void MediaPlayer::setSize(const IntSize&amp; size)
 926 {
 927     m_size = size;
 928     m_private-&gt;setSize(size);
 929 }
 930 
 931 bool MediaPlayer::visible() const
 932 {
 933     return m_visible;
 934 }
</pre>
<hr />
<pre>
 943 {
 944     return m_preload;
 945 }
 946 
 947 void MediaPlayer::setPreload(MediaPlayer::Preload preload)
 948 {
 949     m_preload = preload;
 950     m_private-&gt;setPreload(preload);
 951 }
 952 
 953 void MediaPlayer::paint(GraphicsContext&amp; p, const FloatRect&amp; r)
 954 {
 955     m_private-&gt;paint(p, r);
 956 }
 957 
 958 void MediaPlayer::paintCurrentFrameInContext(GraphicsContext&amp; p, const FloatRect&amp; r)
 959 {
 960     m_private-&gt;paintCurrentFrameInContext(p, r);
 961 }
 962 
<span class="line-modified"> 963 bool MediaPlayer::copyVideoTextureToPlatformTexture(GraphicsContextGLOpenGL* context, PlatformGLObject texture, GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY)</span>
 964 {
 965     return m_private-&gt;copyVideoTextureToPlatformTexture(context, texture, target, level, internalFormat, format, type, premultiplyAlpha, flipY);
 966 }
 967 
 968 NativeImagePtr MediaPlayer::nativeImageForCurrentTime()
 969 {
 970     return m_private-&gt;nativeImageForCurrentTime();
 971 }
 972 
 973 MediaPlayer::SupportsType MediaPlayer::supportsType(const MediaEngineSupportParameters&amp; parameters)
 974 {
 975     // 4.8.10.3 MIME types - The canPlayType(type) method must return the empty string if type is a type that the
 976     // user agent knows it cannot render or is the type &quot;application/octet-stream&quot;
 977     AtomString containerType = parameters.type.containerType();
 978     if (containerType == applicationOctetStream())
<span class="line-modified"> 979         return SupportsType::IsNotSupported;</span>
 980 
 981     const MediaPlayerFactory* engine = bestMediaEngineForSupportParameters(parameters);
 982     if (!engine)
<span class="line-modified"> 983         return SupportsType::IsNotSupported;</span>
 984 
 985     return engine-&gt;supportsTypeAndCodecs(parameters);
 986 }
 987 
 988 void MediaPlayer::getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types)
 989 {
 990     for (auto&amp; engine : installedMediaEngines()) {
 991         HashSet&lt;String, ASCIICaseInsensitiveHash&gt; engineTypes;
<span class="line-modified"> 992         engine-&gt;getSupportedTypes(engineTypes);</span>
 993         types.add(engineTypes.begin(), engineTypes.end());
 994     }
 995 }
 996 
 997 bool MediaPlayer::isAvailable()
 998 {
 999 #if PLATFORM(IOS_FAMILY)
1000     if (DeprecatedGlobalSettings::isAVFoundationEnabled())
1001         return true;
1002 #endif
1003     return !installedMediaEngines().isEmpty();
1004 }
1005 
1006 bool MediaPlayer::supportsPictureInPicture() const
1007 {
1008     return m_private-&gt;supportsPictureInPicture();
1009 }
1010 
1011 #if USE(NATIVE_FULLSCREEN_VIDEO)
1012 
</pre>
<hr />
<pre>
1032 String MediaPlayer::wirelessPlaybackTargetName() const
1033 {
1034     return m_private-&gt;wirelessPlaybackTargetName();
1035 }
1036 
1037 MediaPlayer::WirelessPlaybackTargetType MediaPlayer::wirelessPlaybackTargetType() const
1038 {
1039     return m_private-&gt;wirelessPlaybackTargetType();
1040 }
1041 
1042 bool MediaPlayer::wirelessVideoPlaybackDisabled() const
1043 {
1044     return m_private-&gt;wirelessVideoPlaybackDisabled();
1045 }
1046 
1047 void MediaPlayer::setWirelessVideoPlaybackDisabled(bool disabled)
1048 {
1049     m_private-&gt;setWirelessVideoPlaybackDisabled(disabled);
1050 }
1051 
<span class="line-modified">1052 void MediaPlayer::currentPlaybackTargetIsWirelessChanged(bool isCurrentPlaybackTargetWireless)</span>
1053 {
<span class="line-modified">1054     client().mediaPlayerCurrentPlaybackTargetIsWirelessChanged(isCurrentPlaybackTargetWireless);</span>
1055 }
1056 
1057 bool MediaPlayer::canPlayToWirelessPlaybackTarget() const
1058 {
1059     return m_private-&gt;canPlayToWirelessPlaybackTarget();
1060 }
1061 
1062 void MediaPlayer::setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
1063 {
1064     m_private-&gt;setWirelessPlaybackTarget(WTFMove(device));
1065 }
1066 
1067 void MediaPlayer::setShouldPlayToPlaybackTarget(bool shouldPlay)
1068 {
1069     m_private-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
1070 }
1071 
1072 #endif
1073 
1074 double MediaPlayer::maxFastForwardRate() const
</pre>
<hr />
<pre>
1168 }
1169 
1170 void MediaPlayer::reloadTimerFired()
1171 {
1172     m_private-&gt;cancelLoad();
1173     loadWithNextMediaEngine(m_currentMediaEngine);
1174 }
1175 
1176 template&lt;typename T&gt;
1177 static void addToHash(HashSet&lt;T&gt;&amp; toHash, HashSet&lt;T&gt;&amp;&amp; fromHash)
1178 {
1179     if (toHash.isEmpty())
1180         toHash = WTFMove(fromHash);
1181     else
1182         toHash.add(fromHash.begin(), fromHash.end());
1183 }
1184 
1185 HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; MediaPlayer::originsInMediaCache(const String&amp; path)
1186 {
1187     HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; origins;
<span class="line-modified">1188     for (auto&amp; engine : installedMediaEngines())</span>
<span class="line-modified">1189         addToHash(origins, engine-&gt;originsInMediaCache(path));</span>
<span class="line-modified">1190 </span>


1191     return origins;
1192 }
1193 
1194 void MediaPlayer::clearMediaCache(const String&amp; path, WallTime modifiedSince)
1195 {
<span class="line-modified">1196     for (auto&amp; engine : installedMediaEngines())</span>
<span class="line-modified">1197         engine-&gt;clearMediaCache(path, modifiedSince);</span>


1198 }
1199 
1200 void MediaPlayer::clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; origins)
1201 {
<span class="line-modified">1202     for (auto&amp; engine : installedMediaEngines())</span>
<span class="line-modified">1203         engine-&gt;clearMediaCacheForOrigins(path, origins);</span>


1204 }
1205 
1206 bool MediaPlayer::supportsKeySystem(const String&amp; keySystem, const String&amp; mimeType)
1207 {
1208     for (auto&amp; engine : installedMediaEngines()) {
<span class="line-modified">1209         if (engine-&gt;supportsKeySystem(keySystem, mimeType))</span>
1210             return true;
1211     }
1212     return false;
1213 }
1214 
1215 void MediaPlayer::setPrivateBrowsingMode(bool privateBrowsingMode)
1216 {
1217     m_privateBrowsing = privateBrowsingMode;
1218     if (m_private)
1219         m_private-&gt;setPrivateBrowsingMode(m_privateBrowsing);
1220 }
1221 
1222 // Client callbacks.
1223 void MediaPlayer::networkStateChanged()
1224 {
1225     // If more than one media engine is installed and this one failed before finding metadata,
1226     // let the next engine try.
<span class="line-modified">1227     if (m_private-&gt;networkState() &gt;= MediaPlayer::NetworkState::FormatError &amp;&amp; m_private-&gt;readyState() &lt; MediaPlayer::ReadyState::HaveMetadata) {</span>
1228         client().mediaPlayerEngineFailedToLoad();
<span class="line-modified">1229         if (!m_activeEngineIdentifier &amp;&amp; installedMediaEngines().size() &gt; 1 &amp;&amp; (m_contentType.isEmpty() || nextBestMediaEngine(m_currentMediaEngine))) {</span>
1230             m_reloadTimer.startOneShot(0_s);
1231             return;
1232         }
1233     }
<span class="line-modified">1234     client().mediaPlayerNetworkStateChanged();</span>
1235 }
1236 
1237 void MediaPlayer::readyStateChanged()
1238 {
<span class="line-modified">1239     client().mediaPlayerReadyStateChanged();</span>
1240 }
1241 
1242 void MediaPlayer::volumeChanged(double newVolume)
1243 {
1244 #if PLATFORM(IOS_FAMILY)
1245     UNUSED_PARAM(newVolume);
1246     m_volume = m_private-&gt;volume();
1247 #else
1248     m_volume = newVolume;
1249 #endif
<span class="line-modified">1250     client().mediaPlayerVolumeChanged();</span>
1251 }
1252 
1253 void MediaPlayer::muteChanged(bool newMuted)
1254 {
1255     if (newMuted == m_muted)
1256         return;
1257 
1258     m_muted = newMuted;
<span class="line-modified">1259     client().mediaPlayerMuteChanged();</span>
1260 }
1261 
1262 void MediaPlayer::timeChanged()
1263 {
<span class="line-modified">1264     client().mediaPlayerTimeChanged();</span>
1265 }
1266 
1267 void MediaPlayer::sizeChanged()
1268 {
<span class="line-modified">1269     client().mediaPlayerSizeChanged();</span>
1270 }
1271 
1272 void MediaPlayer::repaint()
1273 {
<span class="line-modified">1274     client().mediaPlayerRepaint();</span>
1275 }
1276 
1277 void MediaPlayer::durationChanged()
1278 {
<span class="line-modified">1279     client().mediaPlayerDurationChanged();</span>
1280 }
1281 
1282 void MediaPlayer::rateChanged()
1283 {
<span class="line-modified">1284     client().mediaPlayerRateChanged();</span>
1285 }
1286 
1287 void MediaPlayer::playbackStateChanged()
1288 {
<span class="line-modified">1289     client().mediaPlayerPlaybackStateChanged();</span>
1290 }
1291 
1292 void MediaPlayer::firstVideoFrameAvailable()
1293 {
<span class="line-modified">1294     client().mediaPlayerFirstVideoFrameAvailable();</span>
1295 }
1296 
1297 void MediaPlayer::characteristicChanged()
1298 {
<span class="line-modified">1299     client().mediaPlayerCharacteristicChanged();</span>
1300 }
1301 
1302 #if ENABLE(WEB_AUDIO)
1303 
1304 AudioSourceProvider* MediaPlayer::audioSourceProvider()
1305 {
1306     return m_private-&gt;audioSourceProvider();
1307 }
1308 
1309 #endif
1310 
1311 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
1312 
1313 RefPtr&lt;ArrayBuffer&gt; MediaPlayer::cachedKeyForKeyId(const String&amp; keyId) const
1314 {
1315     return client().mediaPlayerCachedKeyForKeyId(keyId);
1316 }
1317 
1318 bool MediaPlayer::keyNeeded(Uint8Array* initData)
1319 {
<span class="line-modified">1320     return client().mediaPlayerKeyNeeded(initData);</span>
1321 }
1322 
1323 String MediaPlayer::mediaKeysStorageDirectory() const
1324 {
1325     return client().mediaPlayerMediaKeysStorageDirectory();
1326 }
1327 
1328 #endif
1329 
1330 #if ENABLE(ENCRYPTED_MEDIA)
1331 
1332 void MediaPlayer::initializationDataEncountered(const String&amp; initDataType, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; initData)
1333 {
1334     client().mediaPlayerInitializationDataEncountered(initDataType, WTFMove(initData));
1335 }
1336 
1337 void MediaPlayer::waitingForKeyChanged()
1338 {
1339     client().mediaPlayerWaitingForKeyChanged();
1340 }
</pre>
<hr />
<pre>
1359 
1360 String MediaPlayer::engineDescription() const
1361 {
1362     if (!m_private)
1363         return String();
1364 
1365     return m_private-&gt;engineDescription();
1366 }
1367 
1368 long MediaPlayer::platformErrorCode() const
1369 {
1370     if (!m_private)
1371         return 0;
1372 
1373     return m_private-&gt;platformErrorCode();
1374 }
1375 
1376 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
1377 GraphicsDeviceAdapter* MediaPlayer::graphicsDeviceAdapter() const
1378 {
<span class="line-modified">1379     return client().mediaPlayerGraphicsDeviceAdapter();</span>
1380 }
1381 #endif
1382 
1383 CachedResourceLoader* MediaPlayer::cachedResourceLoader()
1384 {
1385     return client().mediaPlayerCachedResourceLoader();
1386 }
1387 
1388 RefPtr&lt;PlatformMediaResourceLoader&gt; MediaPlayer::createResourceLoader()
1389 {
1390     return client().mediaPlayerCreateResourceLoader();
1391 }
1392 
1393 #if ENABLE(VIDEO_TRACK)
1394 
1395 void MediaPlayer::addAudioTrack(AudioTrackPrivate&amp; track)
1396 {
1397     client().mediaPlayerDidAddAudioTrack(track);
1398 }
1399 
</pre>
<hr />
<pre>
1509 {
1510     if (!m_private)
1511         return 0;
1512 
1513     return m_private-&gt;fileSize();
1514 }
1515 
1516 bool MediaPlayer::ended() const
1517 {
1518     return m_private-&gt;ended();
1519 }
1520 
1521 Optional&lt;VideoPlaybackQualityMetrics&gt; MediaPlayer::videoPlaybackQualityMetrics()
1522 {
1523     if (!m_private)
1524         return WTF::nullopt;
1525 
1526     return m_private-&gt;videoPlaybackQualityMetrics();
1527 }
1528 





1529 String MediaPlayer::sourceApplicationIdentifier() const
1530 {
1531     return client().mediaPlayerSourceApplicationIdentifier();
1532 }
1533 
1534 Vector&lt;String&gt; MediaPlayer::preferredAudioCharacteristics() const
1535 {
1536     return client().mediaPlayerPreferredAudioCharacteristics();
1537 }
1538 
1539 void MediaPlayerFactorySupport::callRegisterMediaEngine(MediaEngineRegister registerMediaEngine)
1540 {
1541     registerMediaEngine(addMediaEngine);
1542 }
1543 
1544 bool MediaPlayer::doesHaveAttribute(const AtomString&amp; attribute, AtomString* value) const
1545 {
1546     return client().doesHaveAttribute(attribute, value);
1547 }
1548 
</pre>
<hr />
<pre>
1591 
1592 #if USE(AVFOUNDATION)
1593 
1594 AVPlayer* MediaPlayer::objCAVFoundationAVPlayer() const
1595 {
1596     return m_private-&gt;objCAVFoundationAVPlayer();
1597 }
1598 
1599 #endif
1600 
1601 bool MediaPlayer::performTaskAtMediaTime(WTF::Function&lt;void()&gt;&amp;&amp; task, MediaTime time)
1602 {
1603     return m_private-&gt;performTaskAtMediaTime(WTFMove(task), time);
1604 }
1605 
1606 bool MediaPlayer::shouldIgnoreIntrinsicSize()
1607 {
1608     return m_private-&gt;shouldIgnoreIntrinsicSize();
1609 }
1610 
<span class="line-added">1611 void MediaPlayer::remoteEngineFailedToLoad()</span>
<span class="line-added">1612 {</span>
<span class="line-added">1613     client().mediaPlayerEngineFailedToLoad();</span>
<span class="line-added">1614 }</span>
<span class="line-added">1615 </span>
1616 #if !RELEASE_LOG_DISABLED
1617 const Logger&amp; MediaPlayer::mediaPlayerLogger()
1618 {
1619     return client().mediaPlayerLogger();
1620 }
1621 #endif
1622 
<span class="line-modified">1623 String convertEnumerationToString(MediaPlayer::ReadyState enumerationValue)</span>
1624 {
1625     static const NeverDestroyed&lt;String&gt; values[] = {
1626         MAKE_STATIC_STRING_IMPL(&quot;HaveNothing&quot;),
1627         MAKE_STATIC_STRING_IMPL(&quot;HaveMetadata&quot;),
1628         MAKE_STATIC_STRING_IMPL(&quot;HaveCurrentData&quot;),
1629         MAKE_STATIC_STRING_IMPL(&quot;HaveFutureData&quot;),
1630         MAKE_STATIC_STRING_IMPL(&quot;HaveEnoughData&quot;),
1631     };
<span class="line-modified">1632     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::ReadyState::HaveNothing) == 0, &quot;MediaPlayer::ReadyState::HaveNothing is not 0 as expected&quot;);</span>
<span class="line-modified">1633     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::ReadyState::HaveMetadata) == 1, &quot;MediaPlayer::ReadyState::HaveMetadata is not 1 as expected&quot;);</span>
<span class="line-modified">1634     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::ReadyState::HaveCurrentData) == 2, &quot;MediaPlayer::ReadyState::HaveCurrentData is not 2 as expected&quot;);</span>
<span class="line-modified">1635     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::ReadyState::HaveFutureData) == 3, &quot;MediaPlayer::ReadyState::HaveFutureData is not 3 as expected&quot;);</span>
<span class="line-modified">1636     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::ReadyState::HaveEnoughData) == 4, &quot;MediaPlayer::ReadyState::HaveEnoughData is not 4 as expected&quot;);</span>
1637     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1638     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1639 }
1640 
<span class="line-modified">1641 String convertEnumerationToString(MediaPlayer::NetworkState enumerationValue)</span>
1642 {
1643     static const NeverDestroyed&lt;String&gt; values[] = {
1644         MAKE_STATIC_STRING_IMPL(&quot;Empty&quot;),
1645         MAKE_STATIC_STRING_IMPL(&quot;Idle&quot;),
1646         MAKE_STATIC_STRING_IMPL(&quot;Loading&quot;),
1647         MAKE_STATIC_STRING_IMPL(&quot;Loaded&quot;),
1648         MAKE_STATIC_STRING_IMPL(&quot;FormatError&quot;),
1649         MAKE_STATIC_STRING_IMPL(&quot;NetworkError&quot;),
1650         MAKE_STATIC_STRING_IMPL(&quot;DecodeError&quot;),
1651     };
<span class="line-modified">1652     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::Empty) == 0, &quot;MediaPlayer::NetworkState::Empty is not 0 as expected&quot;);</span>
<span class="line-modified">1653     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::Idle) == 1, &quot;MediaPlayer::NetworkState::Idle is not 1 as expected&quot;);</span>
<span class="line-modified">1654     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::Loading) == 2, &quot;MediaPlayer::NetworkState::Loading is not 2 as expected&quot;);</span>
<span class="line-modified">1655     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::Loaded) == 3, &quot;MediaPlayer::NetworkState::Loaded is not 3 as expected&quot;);</span>
<span class="line-modified">1656     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::FormatError) == 4, &quot;MediaPlayer::NetworkState::FormatError is not 4 as expected&quot;);</span>
<span class="line-modified">1657     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::NetworkError) == 5, &quot;MediaPlayer::NetworkError is not 5 as expected&quot;);</span>
<span class="line-modified">1658     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::DecodeError) == 6, &quot;MediaPlayer::NetworkState::DecodeError is not 6 as expected&quot;);</span>
1659     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1660     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1661 }
1662 
<span class="line-modified">1663 String convertEnumerationToString(MediaPlayer::Preload enumerationValue)</span>
1664 {
1665     static const NeverDestroyed&lt;String&gt; values[] = {
1666         MAKE_STATIC_STRING_IMPL(&quot;None&quot;),
1667         MAKE_STATIC_STRING_IMPL(&quot;MetaData&quot;),
1668         MAKE_STATIC_STRING_IMPL(&quot;Auto&quot;),
1669     };
<span class="line-modified">1670     static_assert(!static_cast&lt;size_t&gt;(MediaPlayer::Preload::None), &quot;MediaPlayer::Preload::None is not 0 as expected&quot;);</span>
<span class="line-modified">1671     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::Preload::MetaData) == 1, &quot;MediaPlayer::Preload::MetaData is not 1 as expected&quot;);</span>
<span class="line-modified">1672     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::Preload::Auto) == 2, &quot;MediaPlayer::Preload::Auto is not 2 as expected&quot;);</span>
1673     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1674     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1675 }
1676 
<span class="line-modified">1677 String convertEnumerationToString(MediaPlayer::SupportsType enumerationValue)</span>
1678 {
1679     static const NeverDestroyed&lt;String&gt; values[] = {
1680         MAKE_STATIC_STRING_IMPL(&quot;IsNotSupported&quot;),
1681         MAKE_STATIC_STRING_IMPL(&quot;IsSupported&quot;),
1682         MAKE_STATIC_STRING_IMPL(&quot;MayBeSupported&quot;),
1683     };
<span class="line-modified">1684     static_assert(!static_cast&lt;size_t&gt;(MediaPlayer::SupportsType::IsNotSupported), &quot;MediaPlayer::SupportsType::IsNotSupported is not 0 as expected&quot;);</span>
<span class="line-modified">1685     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::SupportsType::IsSupported) == 1, &quot;MediaPlayer::SupportsType::IsSupported is not 1 as expected&quot;);</span>
<span class="line-modified">1686     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::SupportsType::MayBeSupported) == 2, &quot;MediaPlayer::SupportsType::MayBeSupported is not 2 as expected&quot;);</span>
1687     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1688     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1689 }
1690 
<span class="line-modified">1691 String convertEnumerationToString(MediaPlayer::BufferingPolicy enumerationValue)</span>
1692 {
1693     static const NeverDestroyed&lt;String&gt; values[] = {
1694         MAKE_STATIC_STRING_IMPL(&quot;Default&quot;),
1695         MAKE_STATIC_STRING_IMPL(&quot;LimitReadAhead&quot;),
1696         MAKE_STATIC_STRING_IMPL(&quot;MakeResourcesPurgeable&quot;),
1697         MAKE_STATIC_STRING_IMPL(&quot;PurgeResources&quot;),
1698     };
<span class="line-modified">1699     static_assert(!static_cast&lt;size_t&gt;(MediaPlayer::BufferingPolicy::Default), &quot;MediaPlayer::Default is not 0 as expected&quot;);</span>
<span class="line-modified">1700     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::BufferingPolicy::LimitReadAhead) == 1, &quot;MediaPlayer::LimitReadAhead is not 1 as expected&quot;);</span>
<span class="line-modified">1701     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::BufferingPolicy::MakeResourcesPurgeable) == 2, &quot;MediaPlayer::MakeResourcesPurgeable is not 2 as expected&quot;);</span>
<span class="line-modified">1702     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::BufferingPolicy::PurgeResources) == 3, &quot;MediaPlayer::PurgeResources is not 3 as expected&quot;);</span>
1703     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1704     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1705 }
1706 
1707 }
1708 
1709 #endif
</pre>
</td>
</tr>
</table>
<center><a href="MediaPlaybackTargetPicker.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaPlayer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
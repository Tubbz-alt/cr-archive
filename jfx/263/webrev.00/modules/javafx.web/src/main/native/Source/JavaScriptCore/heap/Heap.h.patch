diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/Heap.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/Heap.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/Heap.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/Heap.h
@@ -26,10 +26,11 @@
 #include "CollectionScope.h"
 #include "CollectorPhase.h"
 #include "DeleteAllCodeEffort.h"
 #include "GCConductor.h"
 #include "GCIncomingRefCountedSet.h"
+#include "GCMemoryOperations.h"
 #include "GCRequest.h"
 #include "HandleSet.h"
 #include "HeapFinalizerCallback.h"
 #include "HeapObserver.h"
 #include "MarkedBlock.h"
@@ -93,15 +94,11 @@
 namespace DFG {
 class SpeculativeJIT;
 class Worklist;
 }
 
-#if !ASSERT_DISABLED
-#define ENABLE_DFG_DOES_GC_VALIDATION 1
-#else
-#define ENABLE_DFG_DOES_GC_VALIDATION 0
-#endif
+#define ENABLE_DFG_DOES_GC_VALIDATION ASSERT_ENABLED
 constexpr bool validateDFGDoesGC = ENABLE_DFG_DOES_GC_VALIDATION;
 
 typedef HashCountedSet<JSCell*> ProtectCountSet;
 typedef HashCountedSet<const char*> TypeCountSet;
 
@@ -119,11 +116,11 @@
 
     // This constant determines how many blocks we iterate between checks of our
     // deadline when calling Heap::isPagedOut. Decreasing it will cause us to detect
     // overstepping our deadline more quickly, while increasing it will cause
     // our scan to run faster.
-    static const unsigned s_timeCheckResolution = 16;
+    static constexpr unsigned s_timeCheckResolution = 16;
 
     bool isMarked(const void*);
     static bool testAndSetMarked(HeapVersion, const void*);
 
     static size_t cellSize(const void*);
@@ -168,12 +165,14 @@
 
     // We're always busy on the collection threads. On the main thread, this returns true if we're
     // helping heap.
     JS_EXPORT_PRIVATE bool isCurrentThreadBusy();
 
-    typedef void (*Finalizer)(JSCell*);
-    JS_EXPORT_PRIVATE void addFinalizer(JSCell*, Finalizer);
+    typedef void (*CFinalizer)(JSCell*);
+    JS_EXPORT_PRIVATE void addFinalizer(JSCell*, CFinalizer);
+    using LambdaFinalizer = WTF::Function<void(JSCell*)>;
+    JS_EXPORT_PRIVATE void addFinalizer(JSCell*, LambdaFinalizer);
 
     void notifyIsSafeToCollect();
     bool isSafeToCollect() const { return m_isSafeToCollect; }
 
     bool isShuttingDown() const { return m_isShuttingDown; }
@@ -426,13 +425,17 @@
     friend class WeakSet;
 
     class HeapThread;
     friend class HeapThread;
 
-    static const size_t minExtraMemory = 256;
+    static constexpr size_t minExtraMemory = 256;
+
+    class CFinalizerOwner : public WeakHandleOwner {
+        void finalize(Handle<Unknown>, void* context) override;
+    };
 
-    class FinalizerOwner : public WeakHandleOwner {
+    class LambdaFinalizerOwner : public WeakHandleOwner {
         void finalize(Handle<Unknown>, void* context) override;
     };
 
     JS_EXPORT_PRIVATE bool isValidAllocation(size_t);
     JS_EXPORT_PRIVATE void reportExtraMemoryAllocatedSlowCase(size_t);
@@ -631,11 +634,12 @@
     Vector<SlotVisitor*> m_availableParallelSlotVisitors;
 
     HandleSet m_handleSet;
     std::unique_ptr<CodeBlockSet> m_codeBlocks;
     std::unique_ptr<JITStubRoutineSet> m_jitStubRoutines;
-    FinalizerOwner m_finalizerOwner;
+    CFinalizerOwner m_cFinalizerOwner;
+    LambdaFinalizerOwner m_lambdaFinalizerOwner;
 
     Lock m_parallelSlotVisitorLock;
     bool m_isSafeToCollect { false };
     bool m_isShuttingDown { false };
     bool m_mutatorShouldBeFenced { Options::forceFencedBarrier() };
@@ -676,11 +680,11 @@
     std::unique_ptr<MarkStackArray> m_sharedMutatorMarkStack;
     unsigned m_numberOfActiveParallelMarkers { 0 };
     unsigned m_numberOfWaitingParallelMarkers { 0 };
 
     ConcurrentPtrHashSet m_opaqueRoots;
-    static const size_t s_blockFragmentLength = 32;
+    static constexpr size_t s_blockFragmentLength = 32;
 
     ParallelHelperClient m_helperClient;
     RefPtr<SharedTask<void(SlotVisitor&)>> m_bonusVisitorTask;
 
 #if ENABLE(RESOURCE_USAGE)
@@ -688,16 +692,16 @@
     size_t m_externalMemorySize { 0 };
 #endif
 
     std::unique_ptr<MutatorScheduler> m_scheduler;
 
-    static const unsigned mutatorHasConnBit = 1u << 0u; // Must also be protected by threadLock.
-    static const unsigned stoppedBit = 1u << 1u; // Only set when !hasAccessBit
-    static const unsigned hasAccessBit = 1u << 2u;
-    static const unsigned gcDidJITBit = 1u << 3u; // Set when the GC did some JITing, so on resume we need to cpuid.
-    static const unsigned needFinalizeBit = 1u << 4u;
-    static const unsigned mutatorWaitingBit = 1u << 5u; // Allows the mutator to use this as a condition variable.
+    static constexpr unsigned mutatorHasConnBit = 1u << 0u; // Must also be protected by threadLock.
+    static constexpr unsigned stoppedBit = 1u << 1u; // Only set when !hasAccessBit
+    static constexpr unsigned hasAccessBit = 1u << 2u;
+    static constexpr unsigned gcDidJITBit = 1u << 3u; // Set when the GC did some JITing, so on resume we need to cpuid.
+    static constexpr unsigned needFinalizeBit = 1u << 4u;
+    static constexpr unsigned mutatorWaitingBit = 1u << 5u; // Allows the mutator to use this as a condition variable.
     Atomic<unsigned> m_worldState;
     bool m_worldIsStopped { false };
     Lock m_visitRaceLock;
     Lock m_markingMutex;
     Condition m_markingConditionVariable;
@@ -737,13 +741,13 @@
     uintptr_t m_barriersExecuted { 0 };
 
     CurrentThreadState* m_currentThreadState { nullptr };
     Thread* m_currentThread { nullptr }; // It's OK if this becomes a dangling pointer.
 
-#if PLATFORM(IOS_FAMILY)
-    unsigned m_precentAvailableMemoryCachedCallCount;
-    bool m_overCriticalMemoryThreshold;
+#if USE(BMALLOC_MEMORY_FOOTPRINT_API)
+    unsigned m_percentAvailableMemoryCachedCallCount { 0 };
+    bool m_overCriticalMemoryThreshold { false };
 #endif
 
     bool m_parallelMarkersShouldExit { false };
     Lock m_collectContinuouslyLock;
     Condition m_collectContinuouslyCondition;

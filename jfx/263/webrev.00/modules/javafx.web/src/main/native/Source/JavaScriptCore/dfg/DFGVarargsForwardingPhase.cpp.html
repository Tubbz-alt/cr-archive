<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVarargsForwardingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGVarargsForwardingPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;ClonedArguments.h&quot;
 32 #include &quot;DFGArgumentsUtilities.h&quot;
 33 #include &quot;DFGClobberize.h&quot;
 34 #include &quot;DFGForAllKills.h&quot;
 35 #include &quot;DFGGraph.h&quot;
 36 #include &quot;DFGPhase.h&quot;
 37 #include &quot;JSCInlines.h&quot;
 38 #include &lt;wtf/ListDump.h&gt;
 39 
 40 namespace JSC { namespace DFG {
 41 
 42 namespace {
 43 
 44 
 45 class VarargsForwardingPhase : public Phase {
 46     static constexpr bool verbose = false;
 47 public:
 48     VarargsForwardingPhase(Graph&amp; graph)
 49         : Phase(graph, &quot;varargs forwarding&quot;)
 50     {
 51     }
 52 
 53     bool run()
 54     {
 55         DFG_ASSERT(m_graph, nullptr, m_graph.m_form != SSA);
 56 
 57         if (verbose) {
 58             dataLog(&quot;Graph before varargs forwarding:\n&quot;);
 59             m_graph.dump();
 60         }
 61 
 62         m_changed = false;
 63         for (BasicBlock* block : m_graph.blocksInNaturalOrder())
 64             handleBlock(block);
 65         return m_changed;
 66     }
 67 
 68 private:
 69     void handleBlock(BasicBlock* block)
 70     {
 71         for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
 72             Node* node = block-&gt;at(nodeIndex);
 73             switch (node-&gt;op()) {
 74             case CreateDirectArguments:
 75             case CreateClonedArguments:
 76                 handleCandidate(block, nodeIndex);
 77                 break;
 78             default:
 79                 break;
 80             }
 81         }
 82     }
 83 
 84     void handleCandidate(BasicBlock* block, unsigned candidateNodeIndex)
 85     {
 86         // We expect calls into this function to be rare. So, this is written in a simple O(n) manner.
 87 
 88         Node* candidate = block-&gt;at(candidateNodeIndex);
 89         if (verbose)
 90             dataLog(&quot;Handling candidate &quot;, candidate, &quot;\n&quot;);
 91 
 92         // We eliminate GetButterfly over CreateClonedArguments if the butterfly is only
 93         // used by a GetByOffset  that loads the CreateClonedArguments&#39;s length. We also
 94         // eliminate it if the GetButterfly node is totally unused.
 95         Vector&lt;Node*, 1&gt; candidateButterflies;
 96 
 97         // Find the index of the last node in this block to use the candidate, and look for escaping
 98         // sites.
 99         unsigned lastUserIndex = candidateNodeIndex;
100         Vector&lt;VirtualRegister, 2&gt; relevantLocals; // This is a set. We expect it to be a small set.
101         for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
102             Node* node = block-&gt;at(nodeIndex);
103 
104             auto defaultEscape = [&amp;] {
105                 if (m_graph.uses(node, candidate)) {
106                     if (verbose)
107                         dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
108                     return true;
109                 }
110                 return false;
111             };
112 
113             bool validGetByOffset = false;
114             switch (node-&gt;op()) {
115             case MovHint:
116                 if (node-&gt;child1() != candidate)
117                     break;
118                 ASSERT_WITH_MESSAGE(!node-&gt;unlinkedOperand().isTmp(), &quot;We don&#39;t currently support a tmp referring to an arguments object.&quot;);
119                 lastUserIndex = nodeIndex;
120                 if (!relevantLocals.contains(node-&gt;unlinkedOperand().virtualRegister()))
121                     relevantLocals.append(node-&gt;unlinkedOperand().virtualRegister());
122                 break;
123 
124             case CheckVarargs:
125             case Check: {
126                 bool sawEscape = false;
127                 m_graph.doToChildren(
128                     node,
129                     [&amp;] (Edge edge) {
130                         if (edge == candidate)
131                             lastUserIndex = nodeIndex;
132 
133                         if (edge.willNotHaveCheck())
134                             return;
135 
136                         if (alreadyChecked(edge.useKind(), SpecObject))
137                             return;
138 
139                         sawEscape = true;
140                     });
141                 if (sawEscape) {
142                     if (verbose)
143                         dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
144                     return;
145                 }
146                 break;
147             }
148 
149             case VarargsLength:
150             case LoadVarargs:
151                 if (m_graph.uses(node, candidate))
152                     lastUserIndex = nodeIndex;
153                 break;
154 
155             case CallVarargs:
156             case ConstructVarargs:
157             case TailCallVarargs:
158             case TailCallVarargsInlinedCaller:
159                 if (node-&gt;child1() == candidate || node-&gt;child2() == candidate) {
160                     if (verbose)
161                         dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
162                     return;
163                 }
164                 if (node-&gt;child2() == candidate)
165                     lastUserIndex = nodeIndex;
166                 break;
167 
168             case SetLocal:
169                 if (node-&gt;child1() == candidate &amp;&amp; node-&gt;variableAccessData()-&gt;isLoadedFrom()) {
170                     if (verbose)
171                         dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
172                     return;
173                 }
174                 break;
175 
176             case GetArrayLength: {
177                 if (node-&gt;arrayMode().type() == Array::DirectArguments &amp;&amp; node-&gt;child1() == candidate &amp;&amp; node-&gt;child1()-&gt;op() == CreateDirectArguments) {
178                     lastUserIndex = nodeIndex;
179                     break;
180                 }
181                 if (defaultEscape())
182                     return;
183                 break;
184             }
185 
186             case GetButterfly: {
187                 if (node-&gt;child1() == candidate &amp;&amp; candidate-&gt;op() == CreateClonedArguments) {
188                     lastUserIndex = nodeIndex;
189                     candidateButterflies.append(node);
190                     break;
191                 }
192                 if (defaultEscape())
193                     return;
194                 break;
195             }
196 
197             case FilterGetByStatus:
198             case FilterPutByIdStatus:
199             case FilterCallLinkStatus:
200             case FilterInByIdStatus:
201                 break;
202 
203             case GetByOffset: {
204                 if (node-&gt;child1()-&gt;op() == GetButterfly
205                     &amp;&amp; candidateButterflies.contains(node-&gt;child1().node())
206                     &amp;&amp; node-&gt;child2() == candidate
207                     &amp;&amp; node-&gt;storageAccessData().offset == clonedArgumentsLengthPropertyOffset) {
208                     ASSERT(node-&gt;child1()-&gt;child1() == candidate);
209                     ASSERT(isOutOfLineOffset(clonedArgumentsLengthPropertyOffset));
210                     // We&#39;re good to go. This is getting the length of the arguments.
211                     lastUserIndex = nodeIndex;
212                     validGetByOffset = true;
213                     break;
214                 }
215                 if (defaultEscape())
216                     return;
217                 break;
218             }
219 
220             default:
221                 if (defaultEscape())
222                     return;
223                 break;
224             }
225 
226             if (!validGetByOffset) {
227                 for (Node* butterfly : candidateButterflies) {
228                     if (m_graph.uses(node, butterfly)) {
229                         if (verbose)
230                             dataLog(&quot;    Butterfly escaped at &quot;, node, &quot;\n&quot;);
231                         return;
232                     }
233                 }
234             }
235 
236             forAllKilledOperands(
237                 m_graph, node, block-&gt;tryAt(nodeIndex + 1),
238                 [&amp;] (Operand operand) {
239                     if (verbose)
240                         dataLog(&quot;    Killing &quot;, operand, &quot; while we are interested in &quot;, listDump(relevantLocals), &quot;\n&quot;);
241                     for (unsigned i = 0; i &lt; relevantLocals.size(); ++i) {
242                         if (operand == relevantLocals[i]) {
243                             relevantLocals[i--] = relevantLocals.last();
244                             relevantLocals.removeLast();
245                             lastUserIndex = nodeIndex;
246                         }
247                     }
248                 });
249         }
250         if (verbose)
251             dataLog(&quot;Selected lastUserIndex = &quot;, lastUserIndex, &quot;, &quot;, block-&gt;at(lastUserIndex), &quot;\n&quot;);
252 
253         // We&#39;re still in business. Determine if between the candidate and the last user there is any
254         // effect that could interfere with sinking.
255         for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex &lt;= lastUserIndex; ++nodeIndex) {
256             Node* node = block-&gt;at(nodeIndex);
257 
258             // We have our own custom switch to detect some interferences that clobberize() wouldn&#39;t know
259             // about, and also some of the common ones, too. In particular, clobberize() doesn&#39;t know
260             // that Flush, MovHint, ZombieHint, and KillStack are bad because it&#39;s not worried about
261             // what gets read on OSR exit.
262             switch (node-&gt;op()) {
263             case MovHint:
264             case ZombieHint:
265             case KillStack:
266                 if (argumentsInvolveStackSlot(candidate, node-&gt;unlinkedOperand())) {
267                     if (verbose)
268                         dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
269                     return;
270                 }
271                 break;
272 
273             case PutStack:
274                 if (argumentsInvolveStackSlot(candidate, node-&gt;stackAccessData()-&gt;operand)) {
275                     if (verbose)
276                         dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
277                     return;
278                 }
279                 break;
280 
281             case SetLocal:
282             case Flush:
283                 if (argumentsInvolveStackSlot(candidate, node-&gt;operand())) {
284                     if (verbose)
285                         dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
286                     return;
287                 }
288                 break;
289 
290             default: {
291                 bool doesInterfere = false;
292                 clobberize(
293                     m_graph, node, NoOpClobberize(),
294                     [&amp;] (AbstractHeap heap) {
295                         if (heap.kind() != Stack) {
296                             ASSERT(!heap.overlaps(Stack));
297                             return;
298                         }
299                         ASSERT(!heap.payload().isTop());
300                         if (argumentsInvolveStackSlot(candidate, heap.operand()))
301                             doesInterfere = true;
302                     },
303                     NoOpClobberize());
304                 if (doesInterfere) {
305                     if (verbose)
306                         dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
307                     return;
308                 }
309             } }
310         }
311 
312         // We can make this work.
313         if (verbose)
314             dataLog(&quot;    Will do forwarding!\n&quot;);
315         m_changed = true;
316 
317         // Transform the program.
318         switch (candidate-&gt;op()) {
319         case CreateDirectArguments:
320             candidate-&gt;setOpAndDefaultFlags(PhantomDirectArguments);
321             break;
322 
323         case CreateClonedArguments:
324             candidate-&gt;setOpAndDefaultFlags(PhantomClonedArguments);
325             break;
326 
327         default:
328             DFG_CRASH(m_graph, candidate, &quot;bad node type&quot;);
329             break;
330         }
331 
332         InsertionSet insertionSet(m_graph);
333         for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex &lt;= lastUserIndex; ++nodeIndex) {
334             Node* node = block-&gt;at(nodeIndex);
335             switch (node-&gt;op()) {
336             case Check:
337             case CheckVarargs:
338             case MovHint:
339             case PutHint:
340                 // We don&#39;t need to change anything with these.
341                 break;
342 
343             case VarargsLength: {
344                 if (node-&gt;argumentsChild() != candidate)
345                     break;
346 
347                 node-&gt;convertToIdentityOn(emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, node-&gt;origin, /* addThis = */ true));
348                 break;
349             }
350 
351             case LoadVarargs:
352                 if (node-&gt;argumentsChild() != candidate)
353                     break;
354                 node-&gt;setOpAndDefaultFlags(ForwardVarargs);
355                 break;
356 
357             case CallVarargs:
358                 if (node-&gt;child3() != candidate)
359                     break;
360                 node-&gt;setOpAndDefaultFlags(CallForwardVarargs);
361                 break;
362 
363             case ConstructVarargs:
364                 if (node-&gt;child3() != candidate)
365                     break;
366                 node-&gt;setOpAndDefaultFlags(ConstructForwardVarargs);
367                 break;
368 
369             case TailCallVarargs:
370                 if (node-&gt;child3() != candidate)
371                     break;
372                 node-&gt;setOpAndDefaultFlags(TailCallForwardVarargs);
373                 break;
374 
375             case TailCallVarargsInlinedCaller:
376                 if (node-&gt;child3() != candidate)
377                     break;
378                 node-&gt;setOpAndDefaultFlags(TailCallForwardVarargsInlinedCaller);
379                 break;
380 
381             case SetLocal:
382                 // This is super odd. We don&#39;t have to do anything here, since in DFG IR, the phantom
383                 // arguments nodes do produce a JSValue. Also, we know that if this SetLocal referenecs a
384                 // candidate then the SetLocal - along with all of its references - will die off pretty
385                 // soon, since it has no real users. DCE will surely kill it. If we make it to SSA, then
386                 // SSA conversion will kill it.
387                 break;
388 
389             case GetButterfly: {
390                 if (node-&gt;child1().node() == candidate) {
391                     ASSERT(candidateButterflies.contains(node));
392                     node-&gt;child1() = Edge();
393                     node-&gt;remove(m_graph);
394                 }
395                 break;
396             }
397 
398             case FilterGetByStatus:
399             case FilterPutByIdStatus:
400             case FilterCallLinkStatus:
401             case FilterInByIdStatus:
402                 if (node-&gt;child1().node() == candidate)
403                     node-&gt;remove(m_graph);
404                 break;
405 
406             case GetByOffset: {
407                 if (node-&gt;child2() == candidate) {
408                     ASSERT(candidateButterflies.contains(node-&gt;child1().node())); // It&#39;s no longer a GetButterfly node, but it should&#39;ve been a candidate butterfly.
409                     ASSERT(node-&gt;storageAccessData().offset == clonedArgumentsLengthPropertyOffset);
410                     node-&gt;convertToIdentityOn(
411                         emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, node-&gt;origin));
412                 }
413                 break;
414             }
415 
416             case GetArrayLength:
417                 if (node-&gt;arrayMode().type() == Array::DirectArguments &amp;&amp; node-&gt;child1() == candidate) {
418                     node-&gt;convertToIdentityOn(
419                         emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, node-&gt;origin));
420                 }
421                 break;
422 
423             default:
424                 if (!ASSERT_ENABLED)
425                     break;
426                 m_graph.doToChildren(
427                     node,
428                     [&amp;] (Edge edge) {
429                         DFG_ASSERT(m_graph, node, edge != candidate);
430                     });
431                 break;
432             }
433         }
434 
435         insertionSet.execute(block);
436     }
437 
438     bool m_changed;
439 };
440 
441 } // anonymous namespace
442 
443 bool performVarargsForwarding(Graph&amp; graph)
444 {
445     return runPhase&lt;VarargsForwardingPhase&gt;(graph);
446 }
447 
448 } } // namespace JSC::DFG
449 
450 #endif // ENABLE(DFG_JIT)
451 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/loader/PolicyChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PingLoader.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PolicyChecker.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/PolicyChecker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 104,15 ***</span>
      if (!request.url().protocolIsBlob())
          return { };
  
      // Create a new temporary blobURL in case this one gets revoked during the asynchronous navigation policy decision.
      URL temporaryBlobURL = BlobURL::createPublicURL(&amp;m_frame.document()-&gt;securityOrigin());
<span class="line-modified">!     auto sessionID = m_frame.document()-&gt;sessionID();</span>
<span class="line-removed">-     blobRegistry().registerBlobURL(sessionID, temporaryBlobURL, request.url());</span>
      request.setURL(temporaryBlobURL);
<span class="line-modified">!     return CompletionHandler&lt;void()&gt;([sessionID, temporaryBlobURL = WTFMove(temporaryBlobURL)] {</span>
<span class="line-modified">!         blobRegistry().unregisterBlobURL(sessionID, temporaryBlobURL);</span>
      });
  }
  
  void PolicyChecker::checkNavigationPolicy(ResourceRequest&amp;&amp; request, const ResourceResponse&amp; redirectResponse, DocumentLoader* loader, RefPtr&lt;FormState&gt;&amp;&amp; formState, NavigationPolicyDecisionFunction&amp;&amp; function, PolicyDecisionMode policyDecisionMode)
  {
<span class="line-new-header">--- 104,14 ---</span>
      if (!request.url().protocolIsBlob())
          return { };
  
      // Create a new temporary blobURL in case this one gets revoked during the asynchronous navigation policy decision.
      URL temporaryBlobURL = BlobURL::createPublicURL(&amp;m_frame.document()-&gt;securityOrigin());
<span class="line-modified">!     blobRegistry().registerBlobURL(temporaryBlobURL, request.url());</span>
      request.setURL(temporaryBlobURL);
<span class="line-modified">!     return CompletionHandler&lt;void()&gt;([temporaryBlobURL = WTFMove(temporaryBlobURL)] {</span>
<span class="line-modified">!         blobRegistry().unregisterBlobURL(temporaryBlobURL);</span>
      });
  }
  
  void PolicyChecker::checkNavigationPolicy(ResourceRequest&amp;&amp; request, const ResourceResponse&amp; redirectResponse, DocumentLoader* loader, RefPtr&lt;FormState&gt;&amp;&amp; formState, NavigationPolicyDecisionFunction&amp;&amp; function, PolicyDecisionMode policyDecisionMode)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,14 ***</span>
          return;
      }
  
      loader-&gt;setLastCheckedRequest(ResourceRequest(request));
  
<span class="line-removed">-     // Initial &#39;about:blank&#39; load needs to happen synchronously so the policy check needs to be synchronous in this case.</span>
<span class="line-removed">-     if (!m_frame.loader().stateMachine().committedFirstRealDocumentLoad() &amp;&amp; request.url().protocolIsAbout() &amp;&amp; !substituteData.isValid())</span>
<span class="line-removed">-         policyDecisionMode = PolicyDecisionMode::Synchronous;</span>
<span class="line-removed">- </span>
  #if USE(QUICK_LOOK)
      // Always allow QuickLook-generated URLs based on the protocol scheme.
      if (!request.isNull() &amp;&amp; isQuickLookPreviewURL(request.url()))
          return function(WTFMove(request), makeWeakPtr(formState.get()), NavigationPolicyDecision::ContinueLoad);
  #endif
<span class="line-new-header">--- 157,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,17 ***</span>
  
      m_frame.loader().clearProvisionalLoadForPolicyCheck();
  
      auto blobURLLifetimeExtension = policyDecisionMode == PolicyDecisionMode::Asynchronous ? extendBlobURLLifetimeIfNecessary(request) : CompletionHandlerCallingScope { };
  
      auto requestIdentifier = PolicyCheckIdentifier::create();
      m_delegateIsDecidingNavigationPolicy = true;
      String suggestedFilename = action.downloadAttribute().isEmpty() ? nullAtom() : action.downloadAttribute();
<span class="line-modified">!     m_frame.loader().client().dispatchDecidePolicyForNavigationAction(action, request, redirectResponse, formState.get(), policyDecisionMode, requestIdentifier,</span>
<span class="line-removed">-         [this, function = WTFMove(function), request = ResourceRequest(request), formState = WTFMove(formState), suggestedFilename = WTFMove(suggestedFilename),</span>
           blobURLLifetimeExtension = WTFMove(blobURLLifetimeExtension), requestIdentifier] (PolicyAction policyAction, PolicyCheckIdentifier responseIdentifier) mutable {
<span class="line-removed">- </span>
          if (!responseIdentifier.isValidFor(requestIdentifier))
              return function({ }, nullptr, NavigationPolicyDecision::IgnoreLoad);
  
          m_delegateIsDecidingNavigationPolicy = false;
  
<span class="line-new-header">--- 179,16 ---</span>
  
      m_frame.loader().clearProvisionalLoadForPolicyCheck();
  
      auto blobURLLifetimeExtension = policyDecisionMode == PolicyDecisionMode::Asynchronous ? extendBlobURLLifetimeIfNecessary(request) : CompletionHandlerCallingScope { };
  
<span class="line-added">+     bool isInitialEmptyDocumentLoad = !m_frame.loader().stateMachine().committedFirstRealDocumentLoad() &amp;&amp; request.url().protocolIsAbout() &amp;&amp; !substituteData.isValid();</span>
      auto requestIdentifier = PolicyCheckIdentifier::create();
      m_delegateIsDecidingNavigationPolicy = true;
      String suggestedFilename = action.downloadAttribute().isEmpty() ? nullAtom() : action.downloadAttribute();
<span class="line-modified">!     FramePolicyFunction decisionHandler = [this, function = WTFMove(function), request = ResourceRequest(request), formState = WTFMove(formState), suggestedFilename = WTFMove(suggestedFilename),</span>
           blobURLLifetimeExtension = WTFMove(blobURLLifetimeExtension), requestIdentifier] (PolicyAction policyAction, PolicyCheckIdentifier responseIdentifier) mutable {
          if (!responseIdentifier.isValidFor(requestIdentifier))
              return function({ }, nullptr, NavigationPolicyDecision::IgnoreLoad);
  
          m_delegateIsDecidingNavigationPolicy = false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,11 ***</span>
                  return function({ }, { }, NavigationPolicyDecision::IgnoreLoad);
              }
              return function(WTFMove(request), makeWeakPtr(formState.get()), NavigationPolicyDecision::ContinueLoad);
          }
          ASSERT_NOT_REACHED();
<span class="line-modified">!     });</span>
  }
  
  void PolicyChecker::checkNewWindowPolicy(NavigationAction&amp;&amp; navigationAction, ResourceRequest&amp;&amp; request, RefPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, NewWindowPolicyDecisionFunction&amp;&amp; function)
  {
      if (m_frame.document() &amp;&amp; m_frame.document()-&gt;isSandboxed(SandboxPopups))
<span class="line-new-header">--- 208,18 ---</span>
                  return function({ }, { }, NavigationPolicyDecision::IgnoreLoad);
              }
              return function(WTFMove(request), makeWeakPtr(formState.get()), NavigationPolicyDecision::ContinueLoad);
          }
          ASSERT_NOT_REACHED();
<span class="line-modified">!     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (isInitialEmptyDocumentLoad) {</span>
<span class="line-added">+         // We ignore the response from the client for initial empty document loads and proceed with the load synchronously.</span>
<span class="line-added">+         m_frame.loader().client().dispatchDecidePolicyForNavigationAction(action, request, redirectResponse, formState.get(), policyDecisionMode, requestIdentifier, [](PolicyAction, PolicyCheckIdentifier) { });</span>
<span class="line-added">+         decisionHandler(PolicyAction::Use, requestIdentifier);</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         m_frame.loader().client().dispatchDecidePolicyForNavigationAction(action, request, redirectResponse, formState.get(), policyDecisionMode, requestIdentifier, WTFMove(decisionHandler));</span>
  }
  
  void PolicyChecker::checkNewWindowPolicy(NavigationAction&amp;&amp; navigationAction, ResourceRequest&amp;&amp; request, RefPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, NewWindowPolicyDecisionFunction&amp;&amp; function)
  {
      if (m_frame.document() &amp;&amp; m_frame.document()-&gt;isSandboxed(SandboxPopups))
</pre>
<center><a href="PingLoader.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PolicyChecker.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AXObjectCache.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AXObjectCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityARIAGrid.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AXObjectCache.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
<span class="line-removed"> 28 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-removed"> 29 #include &quot;AXIsolatedTree.h&quot;</span>
<span class="line-removed"> 30 #endif</span>
 31 #include &quot;AXTextStateChangeIntent.h&quot;
 32 #include &quot;AccessibilityObject.h&quot;
 33 #include &quot;Range.h&quot;
 34 #include &quot;Timer.h&quot;
 35 #include &quot;VisibleUnits.h&quot;
 36 #include &lt;limits.h&gt;
 37 #include &lt;wtf/Forward.h&gt;
 38 #include &lt;wtf/HashMap.h&gt;
 39 #include &lt;wtf/HashSet.h&gt;
 40 #include &lt;wtf/ListHashSet.h&gt;
 41 #include &lt;wtf/RefPtr.h&gt;
 42 
 43 #if USE(ATK)
 44 #include &lt;wtf/glib/GRefPtr.h&gt;
 45 #endif
 46 
 47 namespace WebCore {
 48 
 49 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
<span class="line-modified"> 50 class AXIsolatedTreeNode;</span>

 51 #endif
 52 class Document;
 53 class HTMLAreaElement;
 54 class HTMLTextFormControlElement;
 55 class Node;
 56 class Page;
 57 class RenderBlock;
 58 class RenderObject;
 59 class RenderText;
 60 class ScrollView;
 61 class VisiblePosition;
 62 class Widget;
 63 
 64 struct TextMarkerData {
 65     AXID axID { 0 };
 66     Node* node { nullptr };
 67     int offset { 0 };
 68     int characterStartIndex { 0 };
 69     int characterOffset { 0 };
 70     bool ignored { false };
</pre>
<hr />
<pre>
131     const VisiblePositionIndexRange&amp; replacedRange() { return m_replacedRange; }
132 protected:
133     String m_replacedText;
134     VisiblePositionIndexRange m_replacedRange;
135 };
136 
137 #if !PLATFORM(COCOA)
138 enum AXTextChange { AXTextInserted, AXTextDeleted, AXTextAttributesChanged };
139 #endif
140 
141 enum PostTarget { TargetElement, TargetObservableParent };
142 
143 enum PostType { PostSynchronously, PostAsynchronously };
144 
145 class AXObjectCache {
146     WTF_MAKE_NONCOPYABLE(AXObjectCache); WTF_MAKE_FAST_ALLOCATED;
147 public:
148     explicit AXObjectCache(Document&amp;);
149     ~AXObjectCache();
150 
<span class="line-modified">151     WEBCORE_EXPORT static AccessibilityObject* focusedUIElementForPage(const Page*);</span>
152 
153     // Returns the root object for the entire document.
<span class="line-modified">154     WEBCORE_EXPORT AccessibilityObject* rootObject();</span>
155     // Returns the root object for a specific frame.
156     WEBCORE_EXPORT AccessibilityObject* rootObjectForFrame(Frame*);
157 
158     // For AX objects with elements that back them.
159     AccessibilityObject* getOrCreate(RenderObject*);
160     AccessibilityObject* getOrCreate(Widget*);
161     WEBCORE_EXPORT AccessibilityObject* getOrCreate(Node*);
162 
163     // used for objects without backing elements
164     AccessibilityObject* getOrCreate(AccessibilityRole);
165 
166     // will only return the AccessibilityObject if it already exists
167     AccessibilityObject* get(RenderObject*);
168     AccessibilityObject* get(Widget*);
169     AccessibilityObject* get(Node*);
170 
171     void remove(RenderObject*);
172     void remove(Node&amp;);
173     void remove(Widget*);
174     void remove(AXID);
175 
<span class="line-modified">176     void detachWrapper(AccessibilityObject*, AccessibilityDetachmentType);</span>
<span class="line-modified">177     void attachWrapper(AccessibilityObject*);</span>










178     void childrenChanged(Node*, Node* newChild = nullptr);
179     void childrenChanged(RenderObject*, RenderObject* newChild = nullptr);
<span class="line-modified">180     void childrenChanged(AccessibilityObject*);</span>
181     void checkedStateChanged(Node*);
182     // Called when a node has just been attached, so we can make sure we have the right subclass of AccessibilityObject.
183     void updateCacheAfterNodeIsAttached(Node*);
184 
185     void deferFocusedUIElementChangeIfNeeded(Node* oldFocusedNode, Node* newFocusedNode);
186     void handleScrolledToAnchor(const Node* anchorNode);
187     void handleScrollbarUpdate(ScrollView*);
188 
189     Node* modalNode();
190 
191     void deferAttributeChangeIfNeeded(const QualifiedName&amp;, Element*);
192     void recomputeIsIgnored(RenderObject* renderer);
193 
194 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
<span class="line-modified">195     WEBCORE_EXPORT Ref&lt;AXIsolatedTree&gt; generateIsolatedAccessibilityTree();</span>
<span class="line-modified">196 </span>
<span class="line-modified">197     void associateIsolatedTreeNode(AccessibilityObject&amp;, AXIsolatedTreeNode&amp;, AXIsolatedTreeID);</span>
<span class="line-modified">198     Ref&lt;AXIsolatedTreeNode&gt; createIsolatedAccessibilityTreeHierarchy(AccessibilityObject&amp;, AXID, AXIsolatedTree&amp;, Vector&lt;Ref&lt;AXIsolatedTreeNode&gt;&gt;&amp;);</span>



199 #endif
200 



201 #if ENABLE(ACCESSIBILITY)
202     WEBCORE_EXPORT static void enableAccessibility();
203     WEBCORE_EXPORT static void disableAccessibility();
204 
205     // Enhanced user interface accessibility can be toggled by the assistive technology.
206     WEBCORE_EXPORT static void setEnhancedUserInterfaceAccessibility(bool flag);
207 
208     // Note: these may be called from a non-main thread concurrently as other readers.
209     static bool accessibilityEnabled() { return gAccessibilityEnabled; }
210     static bool accessibilityEnhancedUserInterfaceEnabled() { return gAccessibilityEnhancedUserInterfaceEnabled; }
211 #else
212     static void enableAccessibility() { }
213     static void disableAccessibility() { }
214     static void setEnhancedUserInterfaceAccessibility(bool) { }
215     static bool accessibilityEnabled() { return false; }
216     static bool accessibilityEnhancedUserInterfaceEnabled() { return false; }
217 #endif
218 
219     const Element* rootAXEditableElement(const Node*);
220     bool nodeIsTextControl(const Node*);
</pre>
<hr />
<pre>
240     static RefPtr&lt;Range&gt; rangeForNodeContents(Node*);
241     static int lengthForRange(Range*);
242 
243     // Word boundary
244     CharacterOffset nextWordEndCharacterOffset(const CharacterOffset&amp;);
245     CharacterOffset previousWordStartCharacterOffset(const CharacterOffset&amp;);
246     RefPtr&lt;Range&gt; leftWordRange(const CharacterOffset&amp;);
247     RefPtr&lt;Range&gt; rightWordRange(const CharacterOffset&amp;);
248 
249     // Paragraph
250     RefPtr&lt;Range&gt; paragraphForCharacterOffset(const CharacterOffset&amp;);
251     CharacterOffset nextParagraphEndCharacterOffset(const CharacterOffset&amp;);
252     CharacterOffset previousParagraphStartCharacterOffset(const CharacterOffset&amp;);
253 
254     // Sentence
255     RefPtr&lt;Range&gt; sentenceForCharacterOffset(const CharacterOffset&amp;);
256     CharacterOffset nextSentenceEndCharacterOffset(const CharacterOffset&amp;);
257     CharacterOffset previousSentenceStartCharacterOffset(const CharacterOffset&amp;);
258 
259     // Bounds
<span class="line-modified">260     CharacterOffset characterOffsetForPoint(const IntPoint&amp;, AccessibilityObject*);</span>
261     IntRect absoluteCaretBoundsForCharacterOffset(const CharacterOffset&amp;);
262     CharacterOffset characterOffsetForBounds(const IntRect&amp;, bool);
263 
264     // Lines
265     CharacterOffset endCharacterOffsetOfLine(const CharacterOffset&amp;);
266     CharacterOffset startCharacterOffsetOfLine(const CharacterOffset&amp;);
267 
268     // Index
<span class="line-modified">269     CharacterOffset characterOffsetForIndex(int, const AccessibilityObject*);</span>
270     int indexForCharacterOffset(const CharacterOffset&amp;, AccessibilityObject*);
271 
272     enum AXNotification {
273         AXActiveDescendantChanged,
274         AXAutocorrectionOccured,
275         AXCheckedStateChanged,
276         AXChildrenChanged,
277         AXCurrentChanged,
278         AXDisabledStateChanged,
279         AXFocusedUIElementChanged,
280         AXLayoutComplete,
281         AXLoadComplete,
282         AXNewDocumentLoadComplete,
283         AXSelectedChildrenChanged,
284         AXSelectedTextChanged,
285         AXValueChanged,
286         AXScrolledToAnchor,
287         AXLiveRegionCreated,
288         AXLiveRegionChanged,
289         AXMenuListItemSelected,
290         AXMenuListValueChanged,
291         AXMenuClosed,
292         AXMenuOpened,
293         AXRowCountChanged,
294         AXRowCollapsed,
295         AXRowExpanded,
296         AXExpandedChanged,
297         AXInvalidStatusChanged,
298         AXPressDidSucceed,
299         AXPressDidFail,
300         AXPressedStateChanged,
301         AXReadOnlyStatusChanged,
302         AXRequiredStatusChanged,
303         AXTextChanged,
304         AXAriaAttributeChanged,
305         AXElementBusyChanged
306     };
307 
308     void postNotification(RenderObject*, AXNotification, PostTarget = TargetElement, PostType = PostAsynchronously);
309     void postNotification(Node*, AXNotification, PostTarget = TargetElement, PostType = PostAsynchronously);
<span class="line-modified">310     void postNotification(AccessibilityObject*, Document*, AXNotification, PostTarget = TargetElement, PostType = PostAsynchronously);</span>
311 
312 #ifndef NDEBUG
313     void showIntent(const AXTextStateChangeIntent&amp;);
314 #endif
315 
316     void setTextSelectionIntent(const AXTextStateChangeIntent&amp;);
317     void setIsSynchronizingSelection(bool);
318 
319     void postTextStateChangeNotification(Node*, AXTextEditType, const String&amp;, const VisiblePosition&amp;);
320     void postTextReplacementNotification(Node*, AXTextEditType deletionType, const String&amp; deletedText, AXTextEditType insertionType, const String&amp; insertedText, const VisiblePosition&amp;);
321     void postTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp;, const String&amp; deletedText, const String&amp; insertedText);
322     void postTextStateChangeNotification(Node*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;);
323     void postTextStateChangeNotification(const Position&amp;, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;);
324     void postLiveRegionChangeNotification(AccessibilityObject*);
325     void focusModalNode();
326 
327     enum AXLoadingEvent {
328         AXLoadingStarted,
329         AXLoadingReloaded,
330         AXLoadingFailed,
</pre>
<hr />
<pre>
339     void stopCachingComputedObjectAttributes();
340 
341     AXComputedObjectAttributeCache* computedObjectAttributeCache() { return m_computedObjectAttributeCache.get(); }
342 
343     Document&amp; document() const { return m_document; }
344 
345 #if PLATFORM(MAC)
346     static void setShouldRepostNotificationsForTests(bool value);
347 #endif
348     void deferRecomputeIsIgnoredIfNeeded(Element*);
349     void deferRecomputeIsIgnored(Element*);
350     void deferTextChangedIfNeeded(Node*);
351     void deferSelectedChildrenChangedIfNeeded(Element&amp;);
352     void performDeferredCacheUpdate();
353     void deferTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp;, const String&amp; previousValue);
354 
355     RefPtr&lt;Range&gt; rangeMatchesTextNearRange(RefPtr&lt;Range&gt;, const String&amp;);
356 
357 
358 protected:
<span class="line-modified">359     void postPlatformNotification(AccessibilityObject*, AXNotification);</span>
360     void platformHandleFocusedUIElementChanged(Node* oldFocusedNode, Node* newFocusedNode);
361 
362     void platformPerformDeferredCacheUpdate();
363 
364 #if PLATFORM(COCOA)
365     void postTextStateChangePlatformNotification(AccessibilityObject*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;);
366     void postTextStateChangePlatformNotification(AccessibilityObject*, AXTextEditType, const String&amp;, const VisiblePosition&amp;);
367     void postTextReplacementPlatformNotificationForTextControl(AccessibilityObject*, const String&amp; deletedText, const String&amp; insertedText, HTMLTextFormControlElement&amp;);
368     void postTextReplacementPlatformNotification(AccessibilityObject*, AXTextEditType, const String&amp;, AXTextEditType, const String&amp;, const VisiblePosition&amp;);
369 #else
370     static AXTextChange textChangeForEditType(AXTextEditType);
371     void nodeTextChangePlatformNotification(AccessibilityObject*, AXTextChange, unsigned, const String&amp;);
372 #endif
373 
374     void frameLoadingEventPlatformNotification(AccessibilityObject*, AXLoadingEvent);
375     void textChanged(AccessibilityObject*);
376     void labelChanged(Element*);
377 
378     // This is a weak reference cache for knowing if Nodes used by TextMarkers are valid.
379     void setNodeInUse(Node* n) { m_textMarkerNodes.add(n); }
</pre>
<hr />
<pre>
392     UChar32 characterBefore(const CharacterOffset&amp;);
393     CharacterOffset characterOffsetForNodeAndOffset(Node&amp;, int, TraverseOption = TraverseOptionDefault);
394 
395     enum class NeedsContextAtParagraphStart { Yes, No };
396     CharacterOffset previousBoundary(const CharacterOffset&amp;, BoundarySearchFunction, NeedsContextAtParagraphStart = NeedsContextAtParagraphStart::No);
397     CharacterOffset nextBoundary(const CharacterOffset&amp;, BoundarySearchFunction);
398     CharacterOffset startCharacterOffsetOfWord(const CharacterOffset&amp;, EWordSide = RightWordIfOnBoundary);
399     CharacterOffset endCharacterOffsetOfWord(const CharacterOffset&amp;, EWordSide = RightWordIfOnBoundary);
400     CharacterOffset startCharacterOffsetOfParagraph(const CharacterOffset&amp;, EditingBoundaryCrossingRule = CannotCrossEditingBoundary);
401     CharacterOffset endCharacterOffsetOfParagraph(const CharacterOffset&amp;, EditingBoundaryCrossingRule = CannotCrossEditingBoundary);
402     CharacterOffset startCharacterOffsetOfSentence(const CharacterOffset&amp;);
403     CharacterOffset endCharacterOffsetOfSentence(const CharacterOffset&amp;);
404     CharacterOffset characterOffsetForPoint(const IntPoint&amp;);
405     LayoutRect localCaretRectForCharacterOffset(RenderObject*&amp;, const CharacterOffset&amp;);
406     bool shouldSkipBoundary(const CharacterOffset&amp;, const CharacterOffset&amp;);
407 
408 private:
409     AccessibilityObject* rootWebArea();
410 
411     static AccessibilityObject* focusedImageMapUIElement(HTMLAreaElement*);

412 
413     AXID getAXID(AccessibilityObject*);
414 
415     void notificationPostTimerFired();
416 
417     void liveRegionChangedNotificationPostTimerFired();
418 
419     void focusModalNodeTimerFired();
420 
421     void performCacheUpdateTimerFired();
422 
423     void postTextStateChangeNotification(AccessibilityObject*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;);
424 
425     bool enqueuePasswordValueChangeNotification(AccessibilityObject*);
426     void passwordNotificationPostTimerFired();
427 
428     void handleMenuOpened(Node*);
429     void handleLiveRegionCreated(Node*);
430     void handleMenuItemSelected(Node*);
431     void handleAttributeChange(const QualifiedName&amp;, Element*);
432     bool shouldProcessAttributeChange(const QualifiedName&amp;, Element*);
433     void selectedChildrenChanged(Node*);
434     void selectedChildrenChanged(RenderObject*);
435     // Called by a node when text or a text equivalent (e.g. alt) attribute is changed.
436     void textChanged(Node*);
437     void handleActiveDescendantChanged(Node*);
438     void handleAriaRoleChanged(Node*);
439     void handleAriaExpandedChange(Node*);
440     void handleFocusedUIElementChanged(Node* oldFocusedNode, Node* newFocusedNode);
441 
442     // aria-modal related
443     void findModalNodes();
444     void updateCurrentModalNode();
445     bool isNodeVisible(Node*) const;
446     void handleModalChange(Node*);
447 
448     Document&amp; m_document;

449     HashMap&lt;AXID, RefPtr&lt;AccessibilityObject&gt;&gt; m_objects;
450     HashMap&lt;RenderObject*, AXID&gt; m_renderObjectMapping;
451     HashMap&lt;Widget*, AXID&gt; m_widgetObjectMapping;
452     HashMap&lt;Node*, AXID&gt; m_nodeObjectMapping;
453     ListHashSet&lt;Node*&gt; m_textMarkerNodes;
454     std::unique_ptr&lt;AXComputedObjectAttributeCache&gt; m_computedObjectAttributeCache;
455     WEBCORE_EXPORT static bool gAccessibilityEnabled;
456     WEBCORE_EXPORT static bool gAccessibilityEnhancedUserInterfaceEnabled;
457 
458     HashSet&lt;AXID&gt; m_idsInUse;
459 
460     Timer m_notificationPostTimer;
<span class="line-modified">461     Vector&lt;std::pair&lt;RefPtr&lt;AccessibilityObject&gt;, AXNotification&gt;&gt; m_notificationsToPost;</span>
462 
463     Timer m_passwordNotificationPostTimer;
464 
465     ListHashSet&lt;RefPtr&lt;AccessibilityObject&gt;&gt; m_passwordNotificationsToPost;
466 
467     Timer m_liveRegionChangedPostTimer;
468     ListHashSet&lt;RefPtr&lt;AccessibilityObject&gt;&gt; m_liveRegionObjectsSet;
469 
470     Timer m_focusModalNodeTimer;
471     Node* m_currentModalNode;
472     ListHashSet&lt;Node*&gt; m_modalNodesSet;
473 
474     Timer m_performCacheUpdateTimer;
475 
476     AXTextStateChangeIntent m_textSelectionIntent;
477     ListHashSet&lt;Element*&gt; m_deferredRecomputeIsIgnoredList;
478     ListHashSet&lt;Node*&gt; m_deferredTextChangedList;
479     ListHashSet&lt;Element*&gt; m_deferredSelectedChildredChangedList;
<span class="line-modified">480     ListHashSet&lt;RefPtr&lt;AccessibilityObject&gt;&gt; m_deferredChildredChangedList;</span>
481     ListHashSet&lt;Node*&gt; m_deferredChildrenChangedNodeList;
482     HashMap&lt;Element*, String&gt; m_deferredTextFormControlValue;
483     HashMap&lt;Element*, QualifiedName&gt; m_deferredAttributeChange;
484     Vector&lt;std::pair&lt;Node*, Node*&gt;&gt; m_deferredFocusedNodeChange;
485     bool m_isSynchronizingSelection { false };
486     bool m_performingDeferredCacheUpdate { false };
487 
488 #if USE(ATK)
489     ListHashSet&lt;RefPtr&lt;AccessibilityObject&gt;&gt; m_deferredAttachedWrapperObjectList;
490     ListHashSet&lt;GRefPtr&lt;AccessibilityObjectWrapper&gt;&gt; m_deferredDetachedWrapperList;
491 #endif
492 };
493 
494 class AXAttributeCacheEnabler
495 {
496 public:
497     explicit AXAttributeCacheEnabler(AXObjectCache *cache);
498     ~AXAttributeCacheEnabler();
499 
500 #if ENABLE(ACCESSIBILITY)
501 private:
502     AXObjectCache* m_cache;
503 #endif
504 };
505 
506 bool nodeHasRole(Node*, const String&amp; role);
507 // This will let you know if aria-hidden was explicitly set to false.
508 bool isNodeAriaVisible(Node*);
509 
510 #if !ENABLE(ACCESSIBILITY)
511 inline AccessibilityObjectInclusion AXComputedObjectAttributeCache::getIgnored(AXID) const { return AccessibilityObjectInclusion::DefaultBehavior; }
512 inline AccessibilityReplacedText::AccessibilityReplacedText(const VisibleSelection&amp;) { }
513 inline void AccessibilityReplacedText::postTextStateChangeNotification(AXObjectCache*, AXTextEditType, const String&amp;, const VisibleSelection&amp;) { }
514 inline void AXComputedObjectAttributeCache::setIgnored(AXID, AccessibilityObjectInclusion) { }
515 inline AXObjectCache::AXObjectCache(Document&amp; document) : m_document(document), m_notificationPostTimer(*this, &amp;AXObjectCache::notificationPostTimerFired), m_passwordNotificationPostTimer(*this, &amp;AXObjectCache::passwordNotificationPostTimerFired), m_liveRegionChangedPostTimer(*this, &amp;AXObjectCache::liveRegionChangedNotificationPostTimerFired), m_focusModalNodeTimer(*this, &amp;AXObjectCache::focusModalNodeTimerFired), m_performCacheUpdateTimer(*this, &amp;AXObjectCache::performCacheUpdateTimerFired) { }
516 inline AXObjectCache::~AXObjectCache() { }
<span class="line-modified">517 inline AccessibilityObject* AXObjectCache::focusedUIElementForPage(const Page*) { return nullptr; }</span>
518 inline AccessibilityObject* AXObjectCache::get(RenderObject*) { return nullptr; }
519 inline AccessibilityObject* AXObjectCache::get(Node*) { return nullptr; }
520 inline AccessibilityObject* AXObjectCache::get(Widget*) { return nullptr; }
521 inline AccessibilityObject* AXObjectCache::getOrCreate(RenderObject*) { return nullptr; }
522 inline AccessibilityObject* AXObjectCache::getOrCreate(AccessibilityRole) { return nullptr; }
523 inline AccessibilityObject* AXObjectCache::getOrCreate(Node*) { return nullptr; }
524 inline AccessibilityObject* AXObjectCache::getOrCreate(Widget*) { return nullptr; }
<span class="line-modified">525 inline AccessibilityObject* AXObjectCache::rootObject() { return nullptr; }</span>
526 inline AccessibilityObject* AXObjectCache::rootObjectForFrame(Frame*) { return nullptr; }
527 inline bool nodeHasRole(Node*, const String&amp;) { return false; }
528 inline void AXObjectCache::startCachingComputedObjectAttributesUntilTreeMutates() { }
529 inline void AXObjectCache::stopCachingComputedObjectAttributes() { }
530 inline bool isNodeAriaVisible(Node*) { return true; }
531 inline const Element* AXObjectCache::rootAXEditableElement(const Node*) { return nullptr; }
532 inline Node* AXObjectCache::modalNode() { return nullptr; }
<span class="line-modified">533 inline void AXObjectCache::attachWrapper(AccessibilityObject*) { }</span>
534 inline void AXObjectCache::checkedStateChanged(Node*) { }
<span class="line-modified">535 inline void AXObjectCache::childrenChanged(AccessibilityObject*) { }</span>
536 inline void AXObjectCache::childrenChanged(Node*, Node*) { }
537 inline void AXObjectCache::childrenChanged(RenderObject*, RenderObject*) { }
538 inline void AXObjectCache::deferFocusedUIElementChangeIfNeeded(Node*, Node*) { }
539 inline void AXObjectCache::deferRecomputeIsIgnoredIfNeeded(Element*) { }
540 inline void AXObjectCache::deferRecomputeIsIgnored(Element*) { }
541 inline void AXObjectCache::deferTextChangedIfNeeded(Node*) { }
542 inline void AXObjectCache::deferSelectedChildrenChangedIfNeeded(Element&amp;) { }
543 inline void AXObjectCache::deferTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp;, const String&amp;) { }
<span class="line-modified">544 inline void AXObjectCache::detachWrapper(AccessibilityObject*, AccessibilityDetachmentType) { }</span>


545 inline void AXObjectCache::focusModalNodeTimerFired() { }
546 inline void AXObjectCache::performCacheUpdateTimerFired() { }
547 inline void AXObjectCache::frameLoadingEventNotification(Frame*, AXLoadingEvent) { }
548 inline void AXObjectCache::frameLoadingEventPlatformNotification(AccessibilityObject*, AXLoadingEvent) { }
549 inline void AXObjectCache::handleActiveDescendantChanged(Node*) { }
550 inline void AXObjectCache::handleAriaExpandedChange(Node*) { }
551 inline void AXObjectCache::handleModalChange(Node*) { }
552 inline void AXObjectCache::handleAriaRoleChanged(Node*) { }
553 inline void AXObjectCache::deferAttributeChangeIfNeeded(const QualifiedName&amp;, Element*) { }
554 inline void AXObjectCache::handleAttributeChange(const QualifiedName&amp;, Element*) { }
555 inline bool AXObjectCache::shouldProcessAttributeChange(const QualifiedName&amp;, Element*) { return false; }
556 inline void AXObjectCache::handleFocusedUIElementChanged(Node*, Node*) { }
557 inline void AXObjectCache::handleScrollbarUpdate(ScrollView*) { }
558 inline void AXObjectCache::handleScrolledToAnchor(const Node*) { }
559 inline void AXObjectCache::liveRegionChangedNotificationPostTimerFired() { }
560 inline void AXObjectCache::notificationPostTimerFired() { }
561 inline void AXObjectCache::passwordNotificationPostTimerFired() { }
562 inline void AXObjectCache::performDeferredCacheUpdate() { }
563 inline void AXObjectCache::postLiveRegionChangeNotification(AccessibilityObject*) { }
<span class="line-modified">564 inline void AXObjectCache::postNotification(AccessibilityObject*, Document*, AXNotification, PostTarget, PostType) { }</span>
565 inline void AXObjectCache::postNotification(Node*, AXNotification, PostTarget, PostType) { }
566 inline void AXObjectCache::postNotification(RenderObject*, AXNotification, PostTarget, PostType) { }
<span class="line-modified">567 inline void AXObjectCache::postPlatformNotification(AccessibilityObject*, AXNotification) { }</span>
568 inline void AXObjectCache::postTextReplacementNotification(Node*, AXTextEditType, const String&amp;, AXTextEditType, const String&amp;, const VisiblePosition&amp;) { }
569 inline void AXObjectCache::postTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp;, const String&amp;, const String&amp;) { }
570 inline void AXObjectCache::postTextStateChangeNotification(Node*, AXTextEditType, const String&amp;, const VisiblePosition&amp;) { }
571 inline void AXObjectCache::postTextStateChangeNotification(Node*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;) { }
572 inline void AXObjectCache::recomputeIsIgnored(RenderObject*) { }
573 inline void AXObjectCache::textChanged(AccessibilityObject*) { }
574 inline void AXObjectCache::textChanged(Node*) { }
575 inline void AXObjectCache::updateCacheAfterNodeIsAttached(Node*) { }
576 inline RefPtr&lt;Range&gt; AXObjectCache::rangeForNodeContents(Node*) { return nullptr; }
577 inline void AXObjectCache::remove(AXID) { }
578 inline void AXObjectCache::remove(RenderObject*) { }
579 inline void AXObjectCache::remove(Node&amp;) { }
580 inline void AXObjectCache::remove(Widget*) { }
581 inline void AXObjectCache::selectedChildrenChanged(RenderObject*) { }
582 inline void AXObjectCache::selectedChildrenChanged(Node*) { }
583 inline void AXObjectCache::setIsSynchronizingSelection(bool) { }
584 inline void AXObjectCache::setTextSelectionIntent(const AXTextStateChangeIntent&amp;) { }
585 inline RefPtr&lt;Range&gt; AXObjectCache::rangeForUnorderedCharacterOffsets(const CharacterOffset&amp;, const CharacterOffset&amp;) { return nullptr; }
586 inline IntRect AXObjectCache::absoluteCaretBoundsForCharacterOffset(const CharacterOffset&amp;) { return IntRect(); }
<span class="line-modified">587 inline CharacterOffset AXObjectCache::characterOffsetForIndex(int, const AccessibilityObject*) { return CharacterOffset(); }</span>
588 inline CharacterOffset AXObjectCache::startOrEndCharacterOffsetForRange(RefPtr&lt;Range&gt;, bool, bool) { return CharacterOffset(); }
589 inline CharacterOffset AXObjectCache::endCharacterOffsetOfLine(const CharacterOffset&amp;) { return CharacterOffset(); }
590 inline CharacterOffset AXObjectCache::nextCharacterOffset(const CharacterOffset&amp;, bool) { return CharacterOffset(); }
591 inline CharacterOffset AXObjectCache::previousCharacterOffset(const CharacterOffset&amp;, bool) { return CharacterOffset(); }
592 #if PLATFORM(COCOA)
593 inline void AXObjectCache::postTextStateChangePlatformNotification(AccessibilityObject*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;) { }
594 inline void AXObjectCache::postTextStateChangePlatformNotification(AccessibilityObject*, AXTextEditType, const String&amp;, const VisiblePosition&amp;) { }
595 inline void AXObjectCache::postTextReplacementPlatformNotification(AccessibilityObject*, AXTextEditType, const String&amp;, AXTextEditType, const String&amp;, const VisiblePosition&amp;) { }
596 #else
597 inline AXTextChange AXObjectCache::textChangeForEditType(AXTextEditType) { return AXTextInserted; }
598 inline void AXObjectCache::nodeTextChangePlatformNotification(AccessibilityObject*, AXTextChange, unsigned, const String&amp;) { }
599 #endif
600 
601 inline AXAttributeCacheEnabler::AXAttributeCacheEnabler(AXObjectCache*) { }
602 inline AXAttributeCacheEnabler::~AXAttributeCacheEnabler() { }
603 
604 #endif
605 
606 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 



 28 #include &quot;AXTextStateChangeIntent.h&quot;
 29 #include &quot;AccessibilityObject.h&quot;
 30 #include &quot;Range.h&quot;
 31 #include &quot;Timer.h&quot;
 32 #include &quot;VisibleUnits.h&quot;
 33 #include &lt;limits.h&gt;
 34 #include &lt;wtf/Forward.h&gt;
 35 #include &lt;wtf/HashMap.h&gt;
 36 #include &lt;wtf/HashSet.h&gt;
 37 #include &lt;wtf/ListHashSet.h&gt;
 38 #include &lt;wtf/RefPtr.h&gt;
 39 
 40 #if USE(ATK)
 41 #include &lt;wtf/glib/GRefPtr.h&gt;
 42 #endif
 43 
 44 namespace WebCore {
 45 
 46 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
<span class="line-modified"> 47 class AXIsolatedObject;</span>
<span class="line-added"> 48 class AXIsolatedTree;</span>
 49 #endif
 50 class Document;
 51 class HTMLAreaElement;
 52 class HTMLTextFormControlElement;
 53 class Node;
 54 class Page;
 55 class RenderBlock;
 56 class RenderObject;
 57 class RenderText;
 58 class ScrollView;
 59 class VisiblePosition;
 60 class Widget;
 61 
 62 struct TextMarkerData {
 63     AXID axID { 0 };
 64     Node* node { nullptr };
 65     int offset { 0 };
 66     int characterStartIndex { 0 };
 67     int characterOffset { 0 };
 68     bool ignored { false };
</pre>
<hr />
<pre>
129     const VisiblePositionIndexRange&amp; replacedRange() { return m_replacedRange; }
130 protected:
131     String m_replacedText;
132     VisiblePositionIndexRange m_replacedRange;
133 };
134 
135 #if !PLATFORM(COCOA)
136 enum AXTextChange { AXTextInserted, AXTextDeleted, AXTextAttributesChanged };
137 #endif
138 
139 enum PostTarget { TargetElement, TargetObservableParent };
140 
141 enum PostType { PostSynchronously, PostAsynchronously };
142 
143 class AXObjectCache {
144     WTF_MAKE_NONCOPYABLE(AXObjectCache); WTF_MAKE_FAST_ALLOCATED;
145 public:
146     explicit AXObjectCache(Document&amp;);
147     ~AXObjectCache();
148 
<span class="line-modified">149     WEBCORE_EXPORT static AXCoreObject* focusedUIElementForPage(const Page*);</span>
150 
151     // Returns the root object for the entire document.
<span class="line-modified">152     WEBCORE_EXPORT AXCoreObject* rootObject();</span>
153     // Returns the root object for a specific frame.
154     WEBCORE_EXPORT AccessibilityObject* rootObjectForFrame(Frame*);
155 
156     // For AX objects with elements that back them.
157     AccessibilityObject* getOrCreate(RenderObject*);
158     AccessibilityObject* getOrCreate(Widget*);
159     WEBCORE_EXPORT AccessibilityObject* getOrCreate(Node*);
160 
161     // used for objects without backing elements
162     AccessibilityObject* getOrCreate(AccessibilityRole);
163 
164     // will only return the AccessibilityObject if it already exists
165     AccessibilityObject* get(RenderObject*);
166     AccessibilityObject* get(Widget*);
167     AccessibilityObject* get(Node*);
168 
169     void remove(RenderObject*);
170     void remove(Node&amp;);
171     void remove(Widget*);
172     void remove(AXID);
173 
<span class="line-modified">174 #if !PLATFORM(COCOA)</span>
<span class="line-modified">175     void detachWrapper(AXCoreObject*, AccessibilityDetachmentType);</span>
<span class="line-added">176 #endif</span>
<span class="line-added">177 private:</span>
<span class="line-added">178     using DOMObjectVariant = Variant&lt;std::nullptr_t, RenderObject*, Node*, Widget*&gt;;</span>
<span class="line-added">179     void cacheAndInitializeWrapper(AccessibilityObject*, DOMObjectVariant = nullptr);</span>
<span class="line-added">180     void attachWrapper(AXCoreObject*);</span>
<span class="line-added">181 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added">182     void attachWrapper(AXIsolatedObject*, WebAccessibilityObjectWrapper*);</span>
<span class="line-added">183 #endif</span>
<span class="line-added">184 </span>
<span class="line-added">185 public:</span>
186     void childrenChanged(Node*, Node* newChild = nullptr);
187     void childrenChanged(RenderObject*, RenderObject* newChild = nullptr);
<span class="line-modified">188     void childrenChanged(AXCoreObject*);</span>
189     void checkedStateChanged(Node*);
190     // Called when a node has just been attached, so we can make sure we have the right subclass of AccessibilityObject.
191     void updateCacheAfterNodeIsAttached(Node*);
192 
193     void deferFocusedUIElementChangeIfNeeded(Node* oldFocusedNode, Node* newFocusedNode);
194     void handleScrolledToAnchor(const Node* anchorNode);
195     void handleScrollbarUpdate(ScrollView*);
196 
197     Node* modalNode();
198 
199     void deferAttributeChangeIfNeeded(const QualifiedName&amp;, Element*);
200     void recomputeIsIgnored(RenderObject* renderer);
201 
202 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
<span class="line-modified">203     WEBCORE_EXPORT static bool clientSupportsIsolatedTree();</span>
<span class="line-modified">204 private:</span>
<span class="line-modified">205     AXCoreObject* isolatedTreeRootObject();</span>
<span class="line-modified">206     static AXCoreObject* isolatedTreeFocusedObject(Document&amp;);</span>
<span class="line-added">207     void setIsolatedTreeFocusedObject(Node*);</span>
<span class="line-added">208     static Ref&lt;AXIsolatedTree&gt; generateIsolatedTree(PageIdentifier, Document&amp;);</span>
<span class="line-added">209     static Ref&lt;AXIsolatedObject&gt; createIsolatedTreeHierarchy(AXCoreObject&amp;, AXID, AXObjectCache*, AXIsolatedTree&amp;, Vector&lt;Ref&lt;AXIsolatedObject&gt;&gt;&amp;, bool isRoot);</span>
210 #endif
211 
<span class="line-added">212 public:</span>
<span class="line-added">213     WEBCORE_EXPORT bool canUseSecondaryAXThread();</span>
<span class="line-added">214 </span>
215 #if ENABLE(ACCESSIBILITY)
216     WEBCORE_EXPORT static void enableAccessibility();
217     WEBCORE_EXPORT static void disableAccessibility();
218 
219     // Enhanced user interface accessibility can be toggled by the assistive technology.
220     WEBCORE_EXPORT static void setEnhancedUserInterfaceAccessibility(bool flag);
221 
222     // Note: these may be called from a non-main thread concurrently as other readers.
223     static bool accessibilityEnabled() { return gAccessibilityEnabled; }
224     static bool accessibilityEnhancedUserInterfaceEnabled() { return gAccessibilityEnhancedUserInterfaceEnabled; }
225 #else
226     static void enableAccessibility() { }
227     static void disableAccessibility() { }
228     static void setEnhancedUserInterfaceAccessibility(bool) { }
229     static bool accessibilityEnabled() { return false; }
230     static bool accessibilityEnhancedUserInterfaceEnabled() { return false; }
231 #endif
232 
233     const Element* rootAXEditableElement(const Node*);
234     bool nodeIsTextControl(const Node*);
</pre>
<hr />
<pre>
254     static RefPtr&lt;Range&gt; rangeForNodeContents(Node*);
255     static int lengthForRange(Range*);
256 
257     // Word boundary
258     CharacterOffset nextWordEndCharacterOffset(const CharacterOffset&amp;);
259     CharacterOffset previousWordStartCharacterOffset(const CharacterOffset&amp;);
260     RefPtr&lt;Range&gt; leftWordRange(const CharacterOffset&amp;);
261     RefPtr&lt;Range&gt; rightWordRange(const CharacterOffset&amp;);
262 
263     // Paragraph
264     RefPtr&lt;Range&gt; paragraphForCharacterOffset(const CharacterOffset&amp;);
265     CharacterOffset nextParagraphEndCharacterOffset(const CharacterOffset&amp;);
266     CharacterOffset previousParagraphStartCharacterOffset(const CharacterOffset&amp;);
267 
268     // Sentence
269     RefPtr&lt;Range&gt; sentenceForCharacterOffset(const CharacterOffset&amp;);
270     CharacterOffset nextSentenceEndCharacterOffset(const CharacterOffset&amp;);
271     CharacterOffset previousSentenceStartCharacterOffset(const CharacterOffset&amp;);
272 
273     // Bounds
<span class="line-modified">274     CharacterOffset characterOffsetForPoint(const IntPoint&amp;, AXCoreObject*);</span>
275     IntRect absoluteCaretBoundsForCharacterOffset(const CharacterOffset&amp;);
276     CharacterOffset characterOffsetForBounds(const IntRect&amp;, bool);
277 
278     // Lines
279     CharacterOffset endCharacterOffsetOfLine(const CharacterOffset&amp;);
280     CharacterOffset startCharacterOffsetOfLine(const CharacterOffset&amp;);
281 
282     // Index
<span class="line-modified">283     CharacterOffset characterOffsetForIndex(int, const AXCoreObject*);</span>
284     int indexForCharacterOffset(const CharacterOffset&amp;, AccessibilityObject*);
285 
286     enum AXNotification {
287         AXActiveDescendantChanged,
288         AXAutocorrectionOccured,
289         AXCheckedStateChanged,
290         AXChildrenChanged,
291         AXCurrentChanged,
292         AXDisabledStateChanged,
293         AXFocusedUIElementChanged,
294         AXLayoutComplete,
295         AXLoadComplete,
296         AXNewDocumentLoadComplete,
297         AXSelectedChildrenChanged,
298         AXSelectedTextChanged,
299         AXValueChanged,
300         AXScrolledToAnchor,
301         AXLiveRegionCreated,
302         AXLiveRegionChanged,
303         AXMenuListItemSelected,
304         AXMenuListValueChanged,
305         AXMenuClosed,
306         AXMenuOpened,
307         AXRowCountChanged,
308         AXRowCollapsed,
309         AXRowExpanded,
310         AXExpandedChanged,
311         AXInvalidStatusChanged,
312         AXPressDidSucceed,
313         AXPressDidFail,
314         AXPressedStateChanged,
315         AXReadOnlyStatusChanged,
316         AXRequiredStatusChanged,
317         AXTextChanged,
318         AXAriaAttributeChanged,
319         AXElementBusyChanged
320     };
321 
322     void postNotification(RenderObject*, AXNotification, PostTarget = TargetElement, PostType = PostAsynchronously);
323     void postNotification(Node*, AXNotification, PostTarget = TargetElement, PostType = PostAsynchronously);
<span class="line-modified">324     void postNotification(AXCoreObject*, Document*, AXNotification, PostTarget = TargetElement, PostType = PostAsynchronously);</span>
325 
326 #ifndef NDEBUG
327     void showIntent(const AXTextStateChangeIntent&amp;);
328 #endif
329 
330     void setTextSelectionIntent(const AXTextStateChangeIntent&amp;);
331     void setIsSynchronizingSelection(bool);
332 
333     void postTextStateChangeNotification(Node*, AXTextEditType, const String&amp;, const VisiblePosition&amp;);
334     void postTextReplacementNotification(Node*, AXTextEditType deletionType, const String&amp; deletedText, AXTextEditType insertionType, const String&amp; insertedText, const VisiblePosition&amp;);
335     void postTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp;, const String&amp; deletedText, const String&amp; insertedText);
336     void postTextStateChangeNotification(Node*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;);
337     void postTextStateChangeNotification(const Position&amp;, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;);
338     void postLiveRegionChangeNotification(AccessibilityObject*);
339     void focusModalNode();
340 
341     enum AXLoadingEvent {
342         AXLoadingStarted,
343         AXLoadingReloaded,
344         AXLoadingFailed,
</pre>
<hr />
<pre>
353     void stopCachingComputedObjectAttributes();
354 
355     AXComputedObjectAttributeCache* computedObjectAttributeCache() { return m_computedObjectAttributeCache.get(); }
356 
357     Document&amp; document() const { return m_document; }
358 
359 #if PLATFORM(MAC)
360     static void setShouldRepostNotificationsForTests(bool value);
361 #endif
362     void deferRecomputeIsIgnoredIfNeeded(Element*);
363     void deferRecomputeIsIgnored(Element*);
364     void deferTextChangedIfNeeded(Node*);
365     void deferSelectedChildrenChangedIfNeeded(Element&amp;);
366     void performDeferredCacheUpdate();
367     void deferTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp;, const String&amp; previousValue);
368 
369     RefPtr&lt;Range&gt; rangeMatchesTextNearRange(RefPtr&lt;Range&gt;, const String&amp;);
370 
371 
372 protected:
<span class="line-modified">373     void postPlatformNotification(AXCoreObject*, AXNotification);</span>
374     void platformHandleFocusedUIElementChanged(Node* oldFocusedNode, Node* newFocusedNode);
375 
376     void platformPerformDeferredCacheUpdate();
377 
378 #if PLATFORM(COCOA)
379     void postTextStateChangePlatformNotification(AccessibilityObject*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;);
380     void postTextStateChangePlatformNotification(AccessibilityObject*, AXTextEditType, const String&amp;, const VisiblePosition&amp;);
381     void postTextReplacementPlatformNotificationForTextControl(AccessibilityObject*, const String&amp; deletedText, const String&amp; insertedText, HTMLTextFormControlElement&amp;);
382     void postTextReplacementPlatformNotification(AccessibilityObject*, AXTextEditType, const String&amp;, AXTextEditType, const String&amp;, const VisiblePosition&amp;);
383 #else
384     static AXTextChange textChangeForEditType(AXTextEditType);
385     void nodeTextChangePlatformNotification(AccessibilityObject*, AXTextChange, unsigned, const String&amp;);
386 #endif
387 
388     void frameLoadingEventPlatformNotification(AccessibilityObject*, AXLoadingEvent);
389     void textChanged(AccessibilityObject*);
390     void labelChanged(Element*);
391 
392     // This is a weak reference cache for knowing if Nodes used by TextMarkers are valid.
393     void setNodeInUse(Node* n) { m_textMarkerNodes.add(n); }
</pre>
<hr />
<pre>
406     UChar32 characterBefore(const CharacterOffset&amp;);
407     CharacterOffset characterOffsetForNodeAndOffset(Node&amp;, int, TraverseOption = TraverseOptionDefault);
408 
409     enum class NeedsContextAtParagraphStart { Yes, No };
410     CharacterOffset previousBoundary(const CharacterOffset&amp;, BoundarySearchFunction, NeedsContextAtParagraphStart = NeedsContextAtParagraphStart::No);
411     CharacterOffset nextBoundary(const CharacterOffset&amp;, BoundarySearchFunction);
412     CharacterOffset startCharacterOffsetOfWord(const CharacterOffset&amp;, EWordSide = RightWordIfOnBoundary);
413     CharacterOffset endCharacterOffsetOfWord(const CharacterOffset&amp;, EWordSide = RightWordIfOnBoundary);
414     CharacterOffset startCharacterOffsetOfParagraph(const CharacterOffset&amp;, EditingBoundaryCrossingRule = CannotCrossEditingBoundary);
415     CharacterOffset endCharacterOffsetOfParagraph(const CharacterOffset&amp;, EditingBoundaryCrossingRule = CannotCrossEditingBoundary);
416     CharacterOffset startCharacterOffsetOfSentence(const CharacterOffset&amp;);
417     CharacterOffset endCharacterOffsetOfSentence(const CharacterOffset&amp;);
418     CharacterOffset characterOffsetForPoint(const IntPoint&amp;);
419     LayoutRect localCaretRectForCharacterOffset(RenderObject*&amp;, const CharacterOffset&amp;);
420     bool shouldSkipBoundary(const CharacterOffset&amp;, const CharacterOffset&amp;);
421 
422 private:
423     AccessibilityObject* rootWebArea();
424 
425     static AccessibilityObject* focusedImageMapUIElement(HTMLAreaElement*);
<span class="line-added">426     static AXCoreObject* focusedObject(Document&amp;);</span>
427 
428     AXID getAXID(AccessibilityObject*);
429 
430     void notificationPostTimerFired();
431 
432     void liveRegionChangedNotificationPostTimerFired();
433 
434     void focusModalNodeTimerFired();
435 
436     void performCacheUpdateTimerFired();
437 
438     void postTextStateChangeNotification(AccessibilityObject*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;);
439 
440     bool enqueuePasswordValueChangeNotification(AccessibilityObject*);
441     void passwordNotificationPostTimerFired();
442 
443     void handleMenuOpened(Node*);
444     void handleLiveRegionCreated(Node*);
445     void handleMenuItemSelected(Node*);
446     void handleAttributeChange(const QualifiedName&amp;, Element*);
447     bool shouldProcessAttributeChange(const QualifiedName&amp;, Element*);
448     void selectedChildrenChanged(Node*);
449     void selectedChildrenChanged(RenderObject*);
450     // Called by a node when text or a text equivalent (e.g. alt) attribute is changed.
451     void textChanged(Node*);
452     void handleActiveDescendantChanged(Node*);
453     void handleAriaRoleChanged(Node*);
454     void handleAriaExpandedChange(Node*);
455     void handleFocusedUIElementChanged(Node* oldFocusedNode, Node* newFocusedNode);
456 
457     // aria-modal related
458     void findModalNodes();
459     void updateCurrentModalNode();
460     bool isNodeVisible(Node*) const;
461     void handleModalChange(Node*);
462 
463     Document&amp; m_document;
<span class="line-added">464     const Optional&lt;PageIdentifier&gt; m_pageID; // constant for object&#39;s lifetime.</span>
465     HashMap&lt;AXID, RefPtr&lt;AccessibilityObject&gt;&gt; m_objects;
466     HashMap&lt;RenderObject*, AXID&gt; m_renderObjectMapping;
467     HashMap&lt;Widget*, AXID&gt; m_widgetObjectMapping;
468     HashMap&lt;Node*, AXID&gt; m_nodeObjectMapping;
469     ListHashSet&lt;Node*&gt; m_textMarkerNodes;
470     std::unique_ptr&lt;AXComputedObjectAttributeCache&gt; m_computedObjectAttributeCache;
471     WEBCORE_EXPORT static bool gAccessibilityEnabled;
472     WEBCORE_EXPORT static bool gAccessibilityEnhancedUserInterfaceEnabled;
473 
474     HashSet&lt;AXID&gt; m_idsInUse;
475 
476     Timer m_notificationPostTimer;
<span class="line-modified">477     Vector&lt;std::pair&lt;RefPtr&lt;AXCoreObject&gt;, AXNotification&gt;&gt; m_notificationsToPost;</span>
478 
479     Timer m_passwordNotificationPostTimer;
480 
481     ListHashSet&lt;RefPtr&lt;AccessibilityObject&gt;&gt; m_passwordNotificationsToPost;
482 
483     Timer m_liveRegionChangedPostTimer;
484     ListHashSet&lt;RefPtr&lt;AccessibilityObject&gt;&gt; m_liveRegionObjectsSet;
485 
486     Timer m_focusModalNodeTimer;
487     Node* m_currentModalNode;
488     ListHashSet&lt;Node*&gt; m_modalNodesSet;
489 
490     Timer m_performCacheUpdateTimer;
491 
492     AXTextStateChangeIntent m_textSelectionIntent;
493     ListHashSet&lt;Element*&gt; m_deferredRecomputeIsIgnoredList;
494     ListHashSet&lt;Node*&gt; m_deferredTextChangedList;
495     ListHashSet&lt;Element*&gt; m_deferredSelectedChildredChangedList;
<span class="line-modified">496     ListHashSet&lt;RefPtr&lt;AXCoreObject&gt;&gt; m_deferredChildrenChangedList;</span>
497     ListHashSet&lt;Node*&gt; m_deferredChildrenChangedNodeList;
498     HashMap&lt;Element*, String&gt; m_deferredTextFormControlValue;
499     HashMap&lt;Element*, QualifiedName&gt; m_deferredAttributeChange;
500     Vector&lt;std::pair&lt;Node*, Node*&gt;&gt; m_deferredFocusedNodeChange;
501     bool m_isSynchronizingSelection { false };
502     bool m_performingDeferredCacheUpdate { false };
503 
504 #if USE(ATK)
505     ListHashSet&lt;RefPtr&lt;AccessibilityObject&gt;&gt; m_deferredAttachedWrapperObjectList;
506     ListHashSet&lt;GRefPtr&lt;AccessibilityObjectWrapper&gt;&gt; m_deferredDetachedWrapperList;
507 #endif
508 };
509 
510 class AXAttributeCacheEnabler
511 {
512 public:
513     explicit AXAttributeCacheEnabler(AXObjectCache *cache);
514     ~AXAttributeCacheEnabler();
515 
516 #if ENABLE(ACCESSIBILITY)
517 private:
518     AXObjectCache* m_cache;
519 #endif
520 };
521 
522 bool nodeHasRole(Node*, const String&amp; role);
523 // This will let you know if aria-hidden was explicitly set to false.
524 bool isNodeAriaVisible(Node*);
525 
526 #if !ENABLE(ACCESSIBILITY)
527 inline AccessibilityObjectInclusion AXComputedObjectAttributeCache::getIgnored(AXID) const { return AccessibilityObjectInclusion::DefaultBehavior; }
528 inline AccessibilityReplacedText::AccessibilityReplacedText(const VisibleSelection&amp;) { }
529 inline void AccessibilityReplacedText::postTextStateChangeNotification(AXObjectCache*, AXTextEditType, const String&amp;, const VisibleSelection&amp;) { }
530 inline void AXComputedObjectAttributeCache::setIgnored(AXID, AccessibilityObjectInclusion) { }
531 inline AXObjectCache::AXObjectCache(Document&amp; document) : m_document(document), m_notificationPostTimer(*this, &amp;AXObjectCache::notificationPostTimerFired), m_passwordNotificationPostTimer(*this, &amp;AXObjectCache::passwordNotificationPostTimerFired), m_liveRegionChangedPostTimer(*this, &amp;AXObjectCache::liveRegionChangedNotificationPostTimerFired), m_focusModalNodeTimer(*this, &amp;AXObjectCache::focusModalNodeTimerFired), m_performCacheUpdateTimer(*this, &amp;AXObjectCache::performCacheUpdateTimerFired) { }
532 inline AXObjectCache::~AXObjectCache() { }
<span class="line-modified">533 inline AXCoreObject* AXObjectCache::focusedUIElementForPage(const Page*) { return nullptr; }</span>
534 inline AccessibilityObject* AXObjectCache::get(RenderObject*) { return nullptr; }
535 inline AccessibilityObject* AXObjectCache::get(Node*) { return nullptr; }
536 inline AccessibilityObject* AXObjectCache::get(Widget*) { return nullptr; }
537 inline AccessibilityObject* AXObjectCache::getOrCreate(RenderObject*) { return nullptr; }
538 inline AccessibilityObject* AXObjectCache::getOrCreate(AccessibilityRole) { return nullptr; }
539 inline AccessibilityObject* AXObjectCache::getOrCreate(Node*) { return nullptr; }
540 inline AccessibilityObject* AXObjectCache::getOrCreate(Widget*) { return nullptr; }
<span class="line-modified">541 inline AXCoreObject* AXObjectCache::rootObject() { return nullptr; }</span>
542 inline AccessibilityObject* AXObjectCache::rootObjectForFrame(Frame*) { return nullptr; }
543 inline bool nodeHasRole(Node*, const String&amp;) { return false; }
544 inline void AXObjectCache::startCachingComputedObjectAttributesUntilTreeMutates() { }
545 inline void AXObjectCache::stopCachingComputedObjectAttributes() { }
546 inline bool isNodeAriaVisible(Node*) { return true; }
547 inline const Element* AXObjectCache::rootAXEditableElement(const Node*) { return nullptr; }
548 inline Node* AXObjectCache::modalNode() { return nullptr; }
<span class="line-modified">549 inline void AXObjectCache::attachWrapper(AXCoreObject*) { }</span>
550 inline void AXObjectCache::checkedStateChanged(Node*) { }
<span class="line-modified">551 inline void AXObjectCache::childrenChanged(AXCoreObject*) { }</span>
552 inline void AXObjectCache::childrenChanged(Node*, Node*) { }
553 inline void AXObjectCache::childrenChanged(RenderObject*, RenderObject*) { }
554 inline void AXObjectCache::deferFocusedUIElementChangeIfNeeded(Node*, Node*) { }
555 inline void AXObjectCache::deferRecomputeIsIgnoredIfNeeded(Element*) { }
556 inline void AXObjectCache::deferRecomputeIsIgnored(Element*) { }
557 inline void AXObjectCache::deferTextChangedIfNeeded(Node*) { }
558 inline void AXObjectCache::deferSelectedChildrenChangedIfNeeded(Element&amp;) { }
559 inline void AXObjectCache::deferTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp;, const String&amp;) { }
<span class="line-modified">560 #if !PLATFORM(COCOA)</span>
<span class="line-added">561 inline void AXObjectCache::detachWrapper(AXCoreObject*, AccessibilityDetachmentType) { }</span>
<span class="line-added">562 #endif</span>
563 inline void AXObjectCache::focusModalNodeTimerFired() { }
564 inline void AXObjectCache::performCacheUpdateTimerFired() { }
565 inline void AXObjectCache::frameLoadingEventNotification(Frame*, AXLoadingEvent) { }
566 inline void AXObjectCache::frameLoadingEventPlatformNotification(AccessibilityObject*, AXLoadingEvent) { }
567 inline void AXObjectCache::handleActiveDescendantChanged(Node*) { }
568 inline void AXObjectCache::handleAriaExpandedChange(Node*) { }
569 inline void AXObjectCache::handleModalChange(Node*) { }
570 inline void AXObjectCache::handleAriaRoleChanged(Node*) { }
571 inline void AXObjectCache::deferAttributeChangeIfNeeded(const QualifiedName&amp;, Element*) { }
572 inline void AXObjectCache::handleAttributeChange(const QualifiedName&amp;, Element*) { }
573 inline bool AXObjectCache::shouldProcessAttributeChange(const QualifiedName&amp;, Element*) { return false; }
574 inline void AXObjectCache::handleFocusedUIElementChanged(Node*, Node*) { }
575 inline void AXObjectCache::handleScrollbarUpdate(ScrollView*) { }
576 inline void AXObjectCache::handleScrolledToAnchor(const Node*) { }
577 inline void AXObjectCache::liveRegionChangedNotificationPostTimerFired() { }
578 inline void AXObjectCache::notificationPostTimerFired() { }
579 inline void AXObjectCache::passwordNotificationPostTimerFired() { }
580 inline void AXObjectCache::performDeferredCacheUpdate() { }
581 inline void AXObjectCache::postLiveRegionChangeNotification(AccessibilityObject*) { }
<span class="line-modified">582 inline void AXObjectCache::postNotification(AXCoreObject*, Document*, AXNotification, PostTarget, PostType) { }</span>
583 inline void AXObjectCache::postNotification(Node*, AXNotification, PostTarget, PostType) { }
584 inline void AXObjectCache::postNotification(RenderObject*, AXNotification, PostTarget, PostType) { }
<span class="line-modified">585 inline void AXObjectCache::postPlatformNotification(AXCoreObject*, AXNotification) { }</span>
586 inline void AXObjectCache::postTextReplacementNotification(Node*, AXTextEditType, const String&amp;, AXTextEditType, const String&amp;, const VisiblePosition&amp;) { }
587 inline void AXObjectCache::postTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp;, const String&amp;, const String&amp;) { }
588 inline void AXObjectCache::postTextStateChangeNotification(Node*, AXTextEditType, const String&amp;, const VisiblePosition&amp;) { }
589 inline void AXObjectCache::postTextStateChangeNotification(Node*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;) { }
590 inline void AXObjectCache::recomputeIsIgnored(RenderObject*) { }
591 inline void AXObjectCache::textChanged(AccessibilityObject*) { }
592 inline void AXObjectCache::textChanged(Node*) { }
593 inline void AXObjectCache::updateCacheAfterNodeIsAttached(Node*) { }
594 inline RefPtr&lt;Range&gt; AXObjectCache::rangeForNodeContents(Node*) { return nullptr; }
595 inline void AXObjectCache::remove(AXID) { }
596 inline void AXObjectCache::remove(RenderObject*) { }
597 inline void AXObjectCache::remove(Node&amp;) { }
598 inline void AXObjectCache::remove(Widget*) { }
599 inline void AXObjectCache::selectedChildrenChanged(RenderObject*) { }
600 inline void AXObjectCache::selectedChildrenChanged(Node*) { }
601 inline void AXObjectCache::setIsSynchronizingSelection(bool) { }
602 inline void AXObjectCache::setTextSelectionIntent(const AXTextStateChangeIntent&amp;) { }
603 inline RefPtr&lt;Range&gt; AXObjectCache::rangeForUnorderedCharacterOffsets(const CharacterOffset&amp;, const CharacterOffset&amp;) { return nullptr; }
604 inline IntRect AXObjectCache::absoluteCaretBoundsForCharacterOffset(const CharacterOffset&amp;) { return IntRect(); }
<span class="line-modified">605 inline CharacterOffset AXObjectCache::characterOffsetForIndex(int, const AXCoreObject*) { return CharacterOffset(); }</span>
606 inline CharacterOffset AXObjectCache::startOrEndCharacterOffsetForRange(RefPtr&lt;Range&gt;, bool, bool) { return CharacterOffset(); }
607 inline CharacterOffset AXObjectCache::endCharacterOffsetOfLine(const CharacterOffset&amp;) { return CharacterOffset(); }
608 inline CharacterOffset AXObjectCache::nextCharacterOffset(const CharacterOffset&amp;, bool) { return CharacterOffset(); }
609 inline CharacterOffset AXObjectCache::previousCharacterOffset(const CharacterOffset&amp;, bool) { return CharacterOffset(); }
610 #if PLATFORM(COCOA)
611 inline void AXObjectCache::postTextStateChangePlatformNotification(AccessibilityObject*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;) { }
612 inline void AXObjectCache::postTextStateChangePlatformNotification(AccessibilityObject*, AXTextEditType, const String&amp;, const VisiblePosition&amp;) { }
613 inline void AXObjectCache::postTextReplacementPlatformNotification(AccessibilityObject*, AXTextEditType, const String&amp;, AXTextEditType, const String&amp;, const VisiblePosition&amp;) { }
614 #else
615 inline AXTextChange AXObjectCache::textChangeForEditType(AXTextEditType) { return AXTextInserted; }
616 inline void AXObjectCache::nodeTextChangePlatformNotification(AccessibilityObject*, AXTextChange, unsigned, const String&amp;) { }
617 #endif
618 
619 inline AXAttributeCacheEnabler::AXAttributeCacheEnabler(AXObjectCache*) { }
620 inline AXAttributeCacheEnabler::~AXAttributeCacheEnabler() { }
621 
622 #endif
623 
624 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="AXObjectCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityARIAGrid.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
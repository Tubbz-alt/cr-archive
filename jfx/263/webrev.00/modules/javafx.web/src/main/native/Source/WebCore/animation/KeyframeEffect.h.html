<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/animation/KeyframeEffect.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;AnimationEffect.h&quot;
 29 #include &quot;AnimationEffectPhase.h&quot;
 30 #include &quot;CSSPropertyBlendingClient.h&quot;
 31 #include &quot;CompositeOperation.h&quot;
 32 #include &quot;CompositeOperationOrAuto.h&quot;
 33 #include &quot;EffectTiming.h&quot;
 34 #include &quot;Element.h&quot;
 35 #include &quot;IterationCompositeOperation.h&quot;
 36 #include &quot;KeyframeEffectOptions.h&quot;
 37 #include &quot;KeyframeList.h&quot;
 38 #include &quot;RenderStyle.h&quot;
 39 #include &quot;StyleProperties.h&quot;
 40 #include &quot;WebAnimationUtilities.h&quot;
 41 #include &lt;wtf/Ref.h&gt;
 42 
 43 namespace WebCore {
 44 
 45 class Element;
 46 class FilterOperations;
 47 
 48 class KeyframeEffect : public AnimationEffect
 49     , public CSSPropertyBlendingClient {
 50 public:
 51     static ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; create(JSC::JSGlobalObject&amp;, Element*, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;, Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt;&amp;&amp;);
 52     static ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; create(JSC::JSGlobalObject&amp;, Ref&lt;KeyframeEffect&gt;&amp;&amp;);
 53     static Ref&lt;KeyframeEffect&gt; create(const Element&amp;);
 54     ~KeyframeEffect() { }
 55 
 56     bool isKeyframeEffect() const final { return true; }
 57 
 58     struct BasePropertyIndexedKeyframe {
 59         Variant&lt;std::nullptr_t, Vector&lt;Optional&lt;double&gt;&gt;, double&gt; offset = Vector&lt;Optional&lt;double&gt;&gt;();
 60         Variant&lt;Vector&lt;String&gt;, String&gt; easing = Vector&lt;String&gt;();
 61         Variant&lt;Vector&lt;CompositeOperationOrAuto&gt;, CompositeOperationOrAuto&gt; composite = Vector&lt;CompositeOperationOrAuto&gt;();
 62     };
 63 
 64     struct BaseKeyframe {
 65         MarkableDouble offset;
 66         String easing { &quot;linear&quot; };
 67         CompositeOperationOrAuto composite { CompositeOperationOrAuto::Auto };
 68     };
 69 
 70     struct PropertyAndValues {
 71         CSSPropertyID property;
 72         Vector&lt;String&gt; values;
 73     };
 74 
 75     struct KeyframeLikeObject {
 76         BasePropertyIndexedKeyframe baseProperties;
 77         Vector&lt;PropertyAndValues&gt; propertiesAndValues;
 78     };
 79 
 80     struct ParsedKeyframe {
 81         MarkableDouble offset;
 82         double computedOffset;
 83         CompositeOperationOrAuto composite { CompositeOperationOrAuto::Auto };
 84         String easing;
 85         RefPtr&lt;TimingFunction&gt; timingFunction;
 86         Ref&lt;MutableStyleProperties&gt; style;
 87         HashMap&lt;CSSPropertyID, String&gt; unparsedStyle;
 88 
 89         ParsedKeyframe()
 90             : style(MutableStyleProperties::create())
 91         {
 92         }
 93     };
 94 
 95     struct BaseComputedKeyframe {
 96         MarkableDouble offset;
 97         double computedOffset;
 98         String easing { &quot;linear&quot; };
 99         CompositeOperationOrAuto composite { CompositeOperationOrAuto::Auto };
100     };
101 
102     const Vector&lt;ParsedKeyframe&gt;&amp; parsedKeyframes() const { return m_parsedKeyframes; }
103 
104     Element* target() const { return m_target.get(); }
105     void setTarget(RefPtr&lt;Element&gt;&amp;&amp;);
106 
107     Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt; getKeyframes(JSC::JSGlobalObject&amp;);
108     ExceptionOr&lt;void&gt; setKeyframes(JSC::JSGlobalObject&amp;, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;);
109 
110     IterationCompositeOperation iterationComposite() const { return m_iterationCompositeOperation; }
111     void setIterationComposite(IterationCompositeOperation iterationCompositeOperation) { m_iterationCompositeOperation = iterationCompositeOperation; }
112     CompositeOperation composite() const { return m_compositeOperation; }
113     void setComposite(CompositeOperation compositeOperation) { m_compositeOperation = compositeOperation; }
114 
115     void getAnimatedStyle(std::unique_ptr&lt;RenderStyle&gt;&amp; animatedStyle);
116     void apply(RenderStyle&amp;) override;
117     void invalidate() override;
118     void animationDidTick() final;
119     void animationDidPlay() final;
120     void animationDidSeek() final;
121     void animationWasCanceled() final;
122     void animationSuspensionStateDidChange(bool) final;
123     void animationTimelineDidChange(AnimationTimeline*) final;
124     void animationTimingDidChange();
125     void applyPendingAcceleratedActions();
126 
127     void willChangeRenderer();
128 
129     void setAnimation(WebAnimation*) final;
130 
131     RenderElement* renderer() const override;
132     const RenderStyle&amp; currentStyle() const override;
133     bool triggersStackingContext() const { return m_triggersStackingContext; }
134     bool isRunningAccelerated() const { return m_isRunningAccelerated; }
135     bool isAboutToRunAccelerated() const { return m_acceleratedPropertiesState != AcceleratedProperties::None &amp;&amp; m_lastRecordedAcceleratedAction != AcceleratedAction::Stop; }
136     bool isCompletelyAccelerated() const { return m_acceleratedPropertiesState == AcceleratedProperties::All; }
137     bool filterFunctionListsMatch() const override { return m_filterFunctionListsMatch; }
138     bool transformFunctionListsMatch() const override { return m_transformFunctionListsMatch; }
139 #if ENABLE(FILTERS_LEVEL_2)
140     bool backdropFilterFunctionListsMatch() const override { return m_backdropFilterFunctionListsMatch; }
141 #endif
142     bool colorFilterFunctionListsMatch() const override { return m_colorFilterFunctionListsMatch; }
143 
144     void computeDeclarativeAnimationBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle);
145     const KeyframeList&amp; blendingKeyframes() const { return m_blendingKeyframes; }
146     const HashSet&lt;CSSPropertyID&gt;&amp; animatedProperties() const { return m_blendingKeyframes.properties(); }
147     bool animatesProperty(CSSPropertyID) const;
148 
149     bool computeExtentOfTransformAnimation(LayoutRect&amp;) const;
150     bool computeTransformedExtentViaTransformList(const FloatRect&amp;, const RenderStyle&amp;, LayoutRect&amp;) const;
151     bool computeTransformedExtentViaMatrix(const FloatRect&amp;, const RenderStyle&amp;, LayoutRect&amp;) const;
152     bool forceLayoutIfNeeded();
153 
154     enum class Accelerated : uint8_t { Yes, No };
155     bool isCurrentlyAffectingProperty(CSSPropertyID, Accelerated = Accelerated::No) const;
156     bool isRunningAcceleratedAnimationForProperty(CSSPropertyID) const;
157 
158     const RenderStyle* unanimatedStyle() const { return m_unanimatedStyle.get(); }
159 
160 private:
161     KeyframeEffect(Element*);
162 
163     enum class AcceleratedAction : uint8_t { Play, Pause, Seek, Stop };
164     enum class BlendingKeyframesSource : uint8_t { CSSAnimation, CSSTransition, WebAnimation };
165     enum class AcceleratedProperties : uint8_t { None, Some, All };
166 
167     void updateEffectStackMembership();
168     void copyPropertiesFromSource(Ref&lt;KeyframeEffect&gt;&amp;&amp;);
169     ExceptionOr&lt;void&gt; processKeyframes(JSC::JSGlobalObject&amp;, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;);
170     void addPendingAcceleratedAction(AcceleratedAction);
171     void updateAcceleratedActions();
172     void setAnimatedPropertiesInStyle(RenderStyle&amp;, double);
173     TimingFunction* timingFunctionForKeyframeAtIndex(size_t);
174     Ref&lt;const Animation&gt; backingAnimationForCompositedRenderer() const;
175     void computedNeedsForcedLayout();
176     void computeStackingContextImpact();
177     void clearBlendingKeyframes();
178     void updateBlendingKeyframes(RenderStyle&amp;);
179     void computeCSSAnimationBlendingKeyframes(const RenderStyle&amp;);
180     void computeCSSTransitionBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle);
181     void computeAcceleratedPropertiesState();
182     void setBlendingKeyframes(KeyframeList&amp;);
183     void checkForMatchingTransformFunctionLists();
184     void checkForMatchingFilterFunctionLists();
185     void checkForMatchingColorFilterFunctionLists();
186     bool checkForMatchingFilterFunctionLists(CSSPropertyID, const std::function&lt;const FilterOperations&amp; (const RenderStyle&amp;)&gt;&amp;) const;
187 #if ENABLE(FILTERS_LEVEL_2)
188     void checkForMatchingBackdropFilterFunctionLists();
189 #endif
190 
191     KeyframeList m_blendingKeyframes { emptyString() };
192     Vector&lt;ParsedKeyframe&gt; m_parsedKeyframes;
193     Vector&lt;AcceleratedAction&gt; m_pendingAcceleratedActions;
194     WeakPtr&lt;Element&gt; m_target;
195 
196     std::unique_ptr&lt;const RenderStyle&gt; m_unanimatedStyle;
197 
198     AcceleratedAction m_lastRecordedAcceleratedAction { AcceleratedAction::Stop };
199     BlendingKeyframesSource m_blendingKeyframesSource { BlendingKeyframesSource::WebAnimation };
200     IterationCompositeOperation m_iterationCompositeOperation { IterationCompositeOperation::Replace };
201     CompositeOperation m_compositeOperation { CompositeOperation::Replace };
202     AcceleratedProperties m_acceleratedPropertiesState { AcceleratedProperties::None };
203     AnimationEffectPhase m_phaseAtLastApplication { AnimationEffectPhase::Idle };
204     bool m_isRunningAccelerated { false };
205     bool m_needsForcedLayout { false };
206     bool m_triggersStackingContext { false };
207     bool m_transformFunctionListsMatch { false };
208     bool m_filterFunctionListsMatch { false };
209 #if ENABLE(FILTERS_LEVEL_2)
210     bool m_backdropFilterFunctionListsMatch { false };
211 #endif
212     bool m_colorFilterFunctionListsMatch { false };
213     bool m_inTargetEffectStack { false };
214 };
215 
216 } // namespace WebCore
217 
218 SPECIALIZE_TYPE_TRAITS_ANIMATION_EFFECT(KeyframeEffect, isKeyframeEffect());
    </pre>
  </body>
</html>
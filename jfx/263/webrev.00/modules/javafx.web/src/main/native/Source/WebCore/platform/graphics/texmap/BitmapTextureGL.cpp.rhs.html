<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/BitmapTextureGL.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  3  Copyright (C) 2012 Igalia S.L.
  4  Copyright (C) 2012 Adobe Systems Incorporated
  5 
  6  This library is free software; you can redistribute it and/or
  7  modify it under the terms of the GNU Library General Public
  8  License as published by the Free Software Foundation; either
  9  version 2 of the License, or (at your option) any later version.
 10 
 11  This library is distributed in the hope that it will be useful,
 12  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  Library General Public License for more details.
 15 
 16  You should have received a copy of the GNU Library General Public License
 17  along with this library; see the file COPYING.LIB.  If not, write to
 18  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;BitmapTextureGL.h&quot;
 24 
 25 #if USE(TEXTURE_MAPPER_GL)
 26 
<a name="1" id="anc1"></a><span class="line-modified"> 27 #include &quot;ExtensionsGL.h&quot;</span>
 28 #include &quot;FilterOperations.h&quot;
<a name="2" id="anc2"></a>
 29 #include &quot;LengthFunctions.h&quot;
 30 #include &quot;NativeImage.h&quot;
 31 #include &quot;NotImplemented.h&quot;
 32 #include &quot;TextureMapperShaderProgram.h&quot;
 33 #include &quot;Timer.h&quot;
 34 #include &lt;wtf/HashMap.h&gt;
 35 #include &lt;wtf/RefCounted.h&gt;
 36 #include &lt;wtf/RefPtr.h&gt;
 37 
 38 #if USE(CAIRO)
 39 #include &quot;CairoUtilities.h&quot;
 40 #include &quot;RefPtrCairo.h&quot;
 41 #include &lt;cairo.h&gt;
 42 #include &lt;wtf/text/CString.h&gt;
 43 #endif
 44 
 45 #if USE(DIRECT2D)
 46 #include &lt;d2d1.h&gt;
 47 #include &lt;wincodec.h&gt;
 48 #endif
 49 
 50 #if OS(DARWIN)
 51 #define GL_UNSIGNED_INT_8_8_8_8_REV 0x8367
 52 #endif
 53 
 54 namespace WebCore {
 55 
 56 BitmapTextureGL* toBitmapTextureGL(BitmapTexture* texture)
 57 {
 58     if (!texture || !texture-&gt;isBackedByOpenGL())
 59         return 0;
 60 
 61     return static_cast&lt;BitmapTextureGL*&gt;(texture);
 62 }
 63 
 64 BitmapTextureGL::BitmapTextureGL(const TextureMapperContextAttributes&amp; contextAttributes, const Flags, GLint internalFormat)
 65     : m_contextAttributes(contextAttributes)
<a name="3" id="anc3"></a><span class="line-added"> 66     , m_format(GL_RGBA)</span>
 67 {
 68     if (internalFormat != GL_DONT_CARE) {
<a name="4" id="anc4"></a><span class="line-modified"> 69         m_internalFormat = internalFormat;</span>
 70         return;
 71     }
 72 
<a name="5" id="anc5"></a><span class="line-modified"> 73     m_internalFormat = GL_RGBA;</span>
 74 }
 75 
 76 void BitmapTextureGL::didReset()
 77 {
 78     if (!m_id)
 79         glGenTextures(1, &amp;m_id);
 80 
 81     m_shouldClear = true;
 82     m_colorConvertFlags = TextureMapperGL::NoFlag;
 83     if (m_textureSize == contentSize())
 84         return;
 85 
 86     m_textureSize = contentSize();
 87     glBindTexture(GL_TEXTURE_2D, m_id);
 88     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
 89     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 90     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 91     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 92 
 93     glTexImage2D(GL_TEXTURE_2D, 0, m_internalFormat, m_textureSize.width(), m_textureSize.height(), 0, m_format, m_type, 0);
 94 }
 95 
 96 void BitmapTextureGL::updateContents(const void* srcData, const IntRect&amp; targetRect, const IntPoint&amp; sourceOffset, int bytesPerLine)
 97 {
 98     // We are updating a texture with format RGBA with content from a buffer that has BGRA format. Instead of turning BGRA
 99     // into RGBA and then uploading it, we upload it as is. This causes the texture format to be RGBA but the content to be BGRA,
100     // so we mark the texture to convert the colors when painting the texture.
101     m_colorConvertFlags = TextureMapperGL::ShouldConvertTextureBGRAToRGBA;
102 
103     glBindTexture(GL_TEXTURE_2D, m_id);
104 
105     const unsigned bytesPerPixel = 4;
106     const char* data = static_cast&lt;const char*&gt;(srcData);
107     Vector&lt;char&gt; temporaryData;
108     IntPoint adjustedSourceOffset = sourceOffset;
109 
110     // Texture upload requires subimage buffer if driver doesn&#39;t support subimage and we don&#39;t have full image upload.
111     bool requireSubImageBuffer = !m_contextAttributes.supportsUnpackSubimage
112         &amp;&amp; !(bytesPerLine == static_cast&lt;int&gt;(targetRect.width() * bytesPerPixel) &amp;&amp; adjustedSourceOffset == IntPoint::zero());
113 
114     // prepare temporaryData if necessary
115     if (requireSubImageBuffer) {
116         temporaryData.resize(targetRect.width() * targetRect.height() * bytesPerPixel);
117         char* dst = temporaryData.data();
118         data = dst;
119         const char* bits = static_cast&lt;const char*&gt;(srcData);
120         const char* src = bits + sourceOffset.y() * bytesPerLine + sourceOffset.x() * bytesPerPixel;
121         const int targetBytesPerLine = targetRect.width() * bytesPerPixel;
122         for (int y = 0; y &lt; targetRect.height(); ++y) {
123             memcpy(dst, src, targetBytesPerLine);
124             src += bytesPerLine;
125             dst += targetBytesPerLine;
126         }
127 
128         bytesPerLine = targetBytesPerLine;
129         adjustedSourceOffset = IntPoint(0, 0);
130     }
131 
132     glBindTexture(GL_TEXTURE_2D, m_id);
133 
134     if (m_contextAttributes.supportsUnpackSubimage) {
135         // Use the OpenGL sub-image extension, now that we know it&#39;s available.
136         glPixelStorei(GL_UNPACK_ROW_LENGTH, bytesPerLine / bytesPerPixel);
137         glPixelStorei(GL_UNPACK_SKIP_ROWS, adjustedSourceOffset.y());
138         glPixelStorei(GL_UNPACK_SKIP_PIXELS, adjustedSourceOffset.x());
139     }
140 
141     glTexSubImage2D(GL_TEXTURE_2D, 0, targetRect.x(), targetRect.y(), targetRect.width(), targetRect.height(), m_format, m_type, data);
142 
143     if (m_contextAttributes.supportsUnpackSubimage) {
144         glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
145         glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
146         glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
147     }
148 }
149 
150 void BitmapTextureGL::updateContents(Image* image, const IntRect&amp; targetRect, const IntPoint&amp; offset)
151 {
152     if (!image)
153         return;
154     NativeImagePtr frameImage = image-&gt;nativeImageForCurrentFrame();
155     if (!frameImage)
156         return;
157 
158     int bytesPerLine;
159     const char* imageData;
160 
161 #if USE(CAIRO)
162     cairo_surface_t* surface = frameImage.get();
163     imageData = reinterpret_cast&lt;const char*&gt;(cairo_image_surface_get_data(surface));
164     bytesPerLine = cairo_image_surface_get_stride(surface);
165 #elif USE(DIRECT2D)
166     notImplemented();
167 #endif
168 
169     updateContents(imageData, targetRect, offset, bytesPerLine);
170 }
171 
<a name="6" id="anc6"></a><span class="line-added">172 #if USE(ANGLE)</span>
<span class="line-added">173 void BitmapTextureGL::setPendingContents(RefPtr&lt;Image&gt;&amp;&amp; image)</span>
<span class="line-added">174 {</span>
<span class="line-added">175     m_pendingContents = image;</span>
<span class="line-added">176 }</span>
<span class="line-added">177 </span>
<span class="line-added">178 void BitmapTextureGL::updatePendingContents(const IntRect&amp; targetRect, const IntPoint&amp; offset)</span>
<span class="line-added">179 {</span>
<span class="line-added">180     if (!m_pendingContents)</span>
<span class="line-added">181         return;</span>
<span class="line-added">182 </span>
<span class="line-added">183     if (!isValid()) {</span>
<span class="line-added">184         IntSize textureSize(m_pendingContents-&gt;size());</span>
<span class="line-added">185         reset(textureSize);</span>
<span class="line-added">186     }</span>
<span class="line-added">187     updateContents(m_pendingContents.get(), targetRect, offset);</span>
<span class="line-added">188 }</span>
<span class="line-added">189 #endif</span>
<span class="line-added">190 </span>
191 static unsigned getPassesRequiredForFilter(FilterOperation::OperationType type)
192 {
193     switch (type) {
194     case FilterOperation::GRAYSCALE:
195     case FilterOperation::SEPIA:
196     case FilterOperation::SATURATE:
197     case FilterOperation::HUE_ROTATE:
198     case FilterOperation::INVERT:
199     case FilterOperation::BRIGHTNESS:
200     case FilterOperation::CONTRAST:
201     case FilterOperation::OPACITY:
202         return 1;
203     case FilterOperation::BLUR:
204     case FilterOperation::DROP_SHADOW:
205         // We use two-passes (vertical+horizontal) for blur and drop-shadow.
206         return 2;
207     default:
208         return 0;
209     }
210 }
211 
212 RefPtr&lt;BitmapTexture&gt; BitmapTextureGL::applyFilters(TextureMapper&amp; textureMapper, const FilterOperations&amp; filters)
213 {
214     if (filters.isEmpty())
215         return this;
216 
217     TextureMapperGL&amp; texmapGL = static_cast&lt;TextureMapperGL&amp;&gt;(textureMapper);
218     RefPtr&lt;BitmapTexture&gt; previousSurface = texmapGL.currentSurface();
219     RefPtr&lt;BitmapTexture&gt; resultSurface = this;
220     RefPtr&lt;BitmapTexture&gt; intermediateSurface;
221     RefPtr&lt;BitmapTexture&gt; spareSurface;
222 
223     m_filterInfo = FilterInfo();
224 
225     for (size_t i = 0; i &lt; filters.size(); ++i) {
226         RefPtr&lt;FilterOperation&gt; filter = filters.operations()[i];
227         ASSERT(filter);
228 
229         int numPasses = getPassesRequiredForFilter(filter-&gt;type());
230         for (int j = 0; j &lt; numPasses; ++j) {
231             bool last = (i == filters.size() - 1) &amp;&amp; (j == numPasses - 1);
232             if (!last) {
233                 if (!intermediateSurface)
234                     intermediateSurface = texmapGL.acquireTextureFromPool(contentSize(), BitmapTexture::SupportsAlpha);
235                 texmapGL.bindSurface(intermediateSurface.get());
236             }
237 
238             if (last) {
239                 toBitmapTextureGL(resultSurface.get())-&gt;m_filterInfo = BitmapTextureGL::FilterInfo(filter.copyRef(), j, spareSurface.copyRef());
240                 break;
241             }
242 
243             texmapGL.drawFiltered(*resultSurface.get(), spareSurface.get(), *filter, j);
244             if (!j &amp;&amp; filter-&gt;type() == FilterOperation::DROP_SHADOW) {
245                 spareSurface = resultSurface;
246                 resultSurface = nullptr;
247             }
248             std::swap(resultSurface, intermediateSurface);
249         }
250     }
251 
252     texmapGL.bindSurface(previousSurface.get());
253     return resultSurface;
254 }
255 
256 void BitmapTextureGL::initializeStencil()
257 {
258     if (m_rbo)
259         return;
260 
261     glGenRenderbuffers(1, &amp;m_rbo);
262     glBindRenderbuffer(GL_RENDERBUFFER, m_rbo);
263     glRenderbufferStorage(GL_RENDERBUFFER, GL_STENCIL_INDEX8, m_textureSize.width(), m_textureSize.height());
264     glBindRenderbuffer(GL_RENDERBUFFER, 0);
265     glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, m_rbo);
266     glClearStencil(0);
267     glClear(GL_STENCIL_BUFFER_BIT);
268 }
269 
270 void BitmapTextureGL::initializeDepthBuffer()
271 {
272     if (m_depthBufferObject)
273         return;
274 
275     glGenRenderbuffers(1, &amp;m_depthBufferObject);
276     glBindRenderbuffer(GL_RENDERBUFFER, m_depthBufferObject);
277     glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, m_textureSize.width(), m_textureSize.height());
278     glBindRenderbuffer(GL_RENDERBUFFER, 0);
279     glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, m_depthBufferObject);
280 }
281 
282 void BitmapTextureGL::clearIfNeeded()
283 {
284     if (!m_shouldClear)
285         return;
286 
287     m_clipStack.reset(IntRect(IntPoint::zero(), m_textureSize), ClipStack::YAxisMode::Default);
288     m_clipStack.applyIfNeeded();
289     glClearColor(0, 0, 0, 0);
290     glClear(GL_COLOR_BUFFER_BIT);
291     m_shouldClear = false;
292 }
293 
294 void BitmapTextureGL::createFboIfNeeded()
295 {
296     if (m_fbo)
297         return;
298 
299     glGenFramebuffers(1, &amp;m_fbo);
300     glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);
301     glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, id(), 0);
302     m_shouldClear = true;
303 }
304 
305 void BitmapTextureGL::bindAsSurface()
306 {
307     glBindTexture(GL_TEXTURE_2D, 0);
308     createFboIfNeeded();
309     glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);
310     glViewport(0, 0, m_textureSize.width(), m_textureSize.height());
311     clearIfNeeded();
312     m_clipStack.apply();
313 }
314 
315 BitmapTextureGL::~BitmapTextureGL()
316 {
317     if (m_id)
318         glDeleteTextures(1, &amp;m_id);
319 
320     if (m_fbo)
321         glDeleteFramebuffers(1, &amp;m_fbo);
322 
323     if (m_rbo)
324         glDeleteRenderbuffers(1, &amp;m_rbo);
325 
326     if (m_depthBufferObject)
327         glDeleteRenderbuffers(1, &amp;m_depthBufferObject);
328 }
329 
330 bool BitmapTextureGL::isValid() const
331 {
332     return m_id;
333 }
334 
335 IntSize BitmapTextureGL::size() const
336 {
337     return m_textureSize;
338 }
339 
340 
341 void BitmapTextureGL::copyFromExternalTexture(GLuint sourceTextureID)
342 {
343     GLint boundTexture = 0;
344     GLint boundFramebuffer = 0;
345     GLint boundActiveTexture = 0;
346 
347     glGetIntegerv(GL_TEXTURE_BINDING_2D, &amp;boundTexture);
348     glGetIntegerv(GL_FRAMEBUFFER_BINDING, &amp;boundFramebuffer);
349     glGetIntegerv(GL_ACTIVE_TEXTURE, &amp;boundActiveTexture);
350 
351     glBindTexture(GL_TEXTURE_2D, sourceTextureID);
352 
353     GLuint copyFbo = 0;
354     glGenFramebuffers(1, &amp;copyFbo);
355     glBindFramebuffer(GL_FRAMEBUFFER, copyFbo);
356     glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, sourceTextureID, 0);
357 
358     glActiveTexture(GL_TEXTURE0);
359     glBindTexture(GL_TEXTURE_2D, id());
360     glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, m_textureSize.width(), m_textureSize.height());
361 
362     glBindTexture(GL_TEXTURE_2D, boundTexture);
363     glBindFramebuffer(GL_FRAMEBUFFER, boundFramebuffer);
364     glBindTexture(GL_TEXTURE_2D, boundTexture);
365     glActiveTexture(boundActiveTexture);
366     glDeleteFramebuffers(1, &amp;copyFbo);
367 }
368 
369 } // namespace WebCore
370 
371 #endif // USE(TEXTURE_MAPPER_GL)
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCFGSimplificationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGCFGSimplificationPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGBasicBlockInlines.h&quot;
 32 #include &quot;DFGGraph.h&quot;
 33 #include &quot;DFGInsertionSet.h&quot;
 34 #include &quot;DFGPhase.h&quot;
 35 #include &quot;DFGValidate.h&quot;
 36 #include &quot;JSCInlines.h&quot;
 37 
 38 namespace JSC { namespace DFG {
 39 
 40 class CFGSimplificationPhase : public Phase {
 41 public:
 42     CFGSimplificationPhase(Graph&amp; graph)
 43         : Phase(graph, &quot;CFG simplification&quot;)
 44     {
 45     }
 46 
 47     bool canMergeBlocks(BasicBlock* block, BasicBlock* targetBlock)
 48     {
 49         return targetBlock-&gt;predecessors.size() == 1 &amp;&amp; targetBlock != block;
 50     }
 51 
 52     bool run()
 53     {
 54         // FIXME: We should make this work in SSA. https://bugs.webkit.org/show_bug.cgi?id=148260
 55         DFG_ASSERT(m_graph, nullptr, m_graph.m_form != SSA);
 56 
 57         const bool extremeLogging = false;
 58 
 59         bool outerChanged = false;
 60         bool innerChanged;
 61 
 62         do {
 63             innerChanged = false;
 64             for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 65                 BasicBlock* block = m_graph.block(blockIndex);
 66                 if (!block)
 67                     continue;
 68                 ASSERT(block-&gt;isReachable);
 69 
 70                 auto canMergeWithBlock = [&amp;] (BasicBlock* targetBlock) {
 71                     return canMergeBlocks(block, targetBlock);
 72                 };
 73 
 74                 switch (block-&gt;terminal()-&gt;op()) {
 75                 case Jump: {
 76                     // Successor with one predecessor -&gt; merge.
 77                     if (canMergeWithBlock(block-&gt;successor(0))) {
 78                         ASSERT(block-&gt;successor(0)-&gt;predecessors[0] == block);
 79                         if (extremeLogging)
 80                             m_graph.dump();
 81                         m_graph.dethread();
 82                         mergeBlocks(block, block-&gt;successor(0), noBlocks());
 83                         innerChanged = outerChanged = true;
 84                         break;
 85                     }
 86 
 87                     // FIXME: Block only has a jump -&gt; remove. This is tricky though because of
 88                     // liveness. What we really want is to slam in a phantom at the end of the
 89                     // block, after the terminal. But we can&#39;t right now. :-(
 90                     // Idea: what if I slam the ghosties into my successor? Nope, that&#39;s
 91                     // suboptimal, because if my successor has multiple predecessors then we&#39;ll
 92                     // be keeping alive things on other predecessor edges unnecessarily.
 93                     // What we really need is the notion of end-of-block ghosties!
 94                     // FIXME: Allow putting phantoms after terminals.
 95                     // https://bugs.webkit.org/show_bug.cgi?id=126778
 96                     break;
 97                 }
 98 
 99                 case Branch: {
100                     // Branch on constant -&gt; jettison the not-taken block and merge.
101                     if (isKnownDirection(block-&gt;cfaBranchDirection)) {
102                         bool condition = branchCondition(block-&gt;cfaBranchDirection);
103                         BasicBlock* targetBlock = block-&gt;successorForCondition(condition);
104                         BasicBlock* jettisonedBlock = block-&gt;successorForCondition(!condition);
105                         if (canMergeWithBlock(targetBlock)) {
106                             if (extremeLogging)
107                                 m_graph.dump();
108                             m_graph.dethread();
109                             if (targetBlock == jettisonedBlock)
110                                 mergeBlocks(block, targetBlock, noBlocks());
111                             else
112                                 mergeBlocks(block, targetBlock, oneBlock(jettisonedBlock));
113                         } else {
114                             if (extremeLogging)
115                                 m_graph.dump();
116                             m_graph.dethread();
117 
118                             Node* terminal = block-&gt;terminal();
119                             ASSERT(terminal-&gt;isTerminal());
120                             NodeOrigin boundaryNodeOrigin = terminal-&gt;origin;
121 
122                             if (targetBlock != jettisonedBlock)
123                                 jettisonBlock(block, jettisonedBlock, boundaryNodeOrigin);
124 
125                             block-&gt;replaceTerminal(
126                                 m_graph, SpecNone, Jump, boundaryNodeOrigin,
127                                 OpInfo(targetBlock));
128 
129                             ASSERT(block-&gt;terminal());
130 
131                         }
132                         innerChanged = outerChanged = true;
133                         break;
134                     }
135 
136                     if (block-&gt;successor(0) == block-&gt;successor(1)) {
137                         convertToJump(block, block-&gt;successor(0));
138                         innerChanged = outerChanged = true;
139                         break;
140                     }
141 
142                     // Branch to same destination -&gt; jump.
143                     // FIXME: this will currently not be hit because of the lack of jump-only
144                     // block simplification.
145 
146                     break;
147                 }
148 
149                 case Switch: {
150                     SwitchData* data = block-&gt;terminal()-&gt;switchData();
151 
152                     // Prune out cases that end up jumping to default.
153                     for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
154                         if (data-&gt;cases[i].target.block == data-&gt;fallThrough.block) {
155                             data-&gt;fallThrough.count += data-&gt;cases[i].target.count;
156                             data-&gt;cases[i--] = data-&gt;cases.last();
157                             data-&gt;cases.removeLast();
158                         }
159                     }
160 
161                     // If there are no cases other than default then this turns
162                     // into a jump.
163                     if (data-&gt;cases.isEmpty()) {
164                         convertToJump(block, data-&gt;fallThrough.block);
165                         innerChanged = outerChanged = true;
166                         break;
167                     }
168 
169                     // Switch on constant -&gt; jettison all other targets and merge.
170                     Node* terminal = block-&gt;terminal();
171                     if (terminal-&gt;child1()-&gt;hasConstant()) {
172                         FrozenValue* value = terminal-&gt;child1()-&gt;constant();
173                         TriState found = FalseTriState;
174                         BasicBlock* targetBlock = 0;
175                         for (unsigned i = data-&gt;cases.size(); found == FalseTriState &amp;&amp; i--;) {
176                             found = data-&gt;cases[i].value.strictEqual(value);
177                             if (found == TrueTriState)
178                                 targetBlock = data-&gt;cases[i].target.block;
179                         }
180 
181                         if (found == MixedTriState)
182                             break;
183                         if (found == FalseTriState)
184                             targetBlock = data-&gt;fallThrough.block;
185                         ASSERT(targetBlock);
186 
187                         Vector&lt;BasicBlock*, 1&gt; jettisonedBlocks;
188                         for (BasicBlock* successor : terminal-&gt;successors()) {
189                             if (successor != targetBlock &amp;&amp; !jettisonedBlocks.contains(successor))
190                                 jettisonedBlocks.append(successor);
191                         }
192 
193                         if (canMergeWithBlock(targetBlock)) {
194                             if (extremeLogging)
195                                 m_graph.dump();
196                             m_graph.dethread();
197 
198                             mergeBlocks(block, targetBlock, jettisonedBlocks);
199                         } else {
200                             if (extremeLogging)
201                                 m_graph.dump();
202                             m_graph.dethread();
203 
204                             NodeOrigin boundaryNodeOrigin = terminal-&gt;origin;
205 
206                             for (unsigned i = jettisonedBlocks.size(); i--;)
207                                 jettisonBlock(block, jettisonedBlocks[i], boundaryNodeOrigin);
208 
209                             block-&gt;replaceTerminal(
210                                 m_graph, SpecNone, Jump, boundaryNodeOrigin, OpInfo(targetBlock));
211                         }
212                         innerChanged = outerChanged = true;
213                         break;
214                     }
215                     break;
216                 }
217 
218                 default:
219                     break;
220                 }
221             }
222 
223             if (innerChanged) {
224                 // Here&#39;s the reason for this pass:
225                 // Blocks: A, B, C, D, E, F
226                 // A -&gt; B, C
227                 // B -&gt; F
228                 // C -&gt; D, E
229                 // D -&gt; F
230                 // E -&gt; F
231                 //
232                 // Assume that A&#39;s branch is determined to go to B. Then the rest of this phase
233                 // is smart enough to simplify down to:
234                 // A -&gt; B
235                 // B -&gt; F
236                 // C -&gt; D, E
237                 // D -&gt; F
238                 // E -&gt; F
239                 //
240                 // We will also merge A and B. But then we don&#39;t have any other mechanism to
241                 // remove D, E as predecessors for F. Worse, the rest of this phase does not
242                 // know how to fix the Phi functions of F to ensure that they no longer refer
243                 // to variables in D, E. In general, we need a way to handle Phi simplification
244                 // upon:
245                 // 1) Removal of a predecessor due to branch simplification. The branch
246                 //    simplifier already does that.
247                 // 2) Invalidation of a predecessor because said predecessor was rendered
248                 //    unreachable. We do this here.
249                 //
250                 // This implies that when a block is unreachable, we must inspect its
251                 // successors&#39; Phi functions to remove any references from them into the
252                 // removed block.
253 
254                 m_graph.invalidateCFG();
255                 m_graph.resetReachability();
256                 m_graph.killUnreachableBlocks();
257             }
258 
259             if (Options::validateGraphAtEachPhase())
260                 validate();
261         } while (innerChanged);
262 
263         return outerChanged;
264     }
265 
266 private:
267     void convertToJump(BasicBlock* block, BasicBlock* targetBlock)
268     {
269         ASSERT(targetBlock);
270         ASSERT(targetBlock-&gt;isReachable);
271         if (canMergeBlocks(block, targetBlock)) {
272             m_graph.dethread();
273             mergeBlocks(block, targetBlock, noBlocks());
274         } else {
275             Node* branch = block-&gt;terminal();
276             ASSERT(branch-&gt;op() == Branch || branch-&gt;op() == Switch);
277 
278             block-&gt;replaceTerminal(
279                 m_graph, SpecNone, Jump, branch-&gt;origin, OpInfo(targetBlock));
280         }
281     }
282 
283     void keepOperandAlive(BasicBlock* block, BasicBlock* jettisonedBlock, NodeOrigin nodeOrigin, VirtualRegister operand)
284     {
285         Node* livenessNode = jettisonedBlock-&gt;variablesAtHead.operand(operand);
286         if (!livenessNode)
287             return;
288         NodeType nodeType;
289         if (livenessNode-&gt;flags() &amp; NodeIsFlushed)
290             nodeType = Flush;
291         else {
292             // This seems like it shouldn&#39;t be necessary because we could just rematerialize
293             // PhantomLocals or something similar using bytecode liveness. However, in ThreadedCPS, it&#39;s
294             // worth the sanity to maintain this eagerly. See
295             // https://bugs.webkit.org/show_bug.cgi?id=144086
296             nodeType = PhantomLocal;
297         }
298         block-&gt;appendNode(
299             m_graph, SpecNone, nodeType, nodeOrigin,
300             OpInfo(livenessNode-&gt;variableAccessData()));
301     }
302 
303     void jettisonBlock(BasicBlock* block, BasicBlock* jettisonedBlock, NodeOrigin boundaryNodeOrigin)
304     {
305         for (size_t i = 0; i &lt; jettisonedBlock-&gt;variablesAtHead.numberOfArguments(); ++i)
<a name="1" id="anc1"></a><span class="line-modified">306             keepOperandAlive(block, jettisonedBlock, boundaryNodeOrigin, virtualRegisterForArgument(i));</span>
307         for (size_t i = 0; i &lt; jettisonedBlock-&gt;variablesAtHead.numberOfLocals(); ++i)
308             keepOperandAlive(block, jettisonedBlock, boundaryNodeOrigin, virtualRegisterForLocal(i));
309 
310         fixJettisonedPredecessors(block, jettisonedBlock);
311     }
312 
313     void fixJettisonedPredecessors(BasicBlock* block, BasicBlock* jettisonedBlock)
314     {
315         jettisonedBlock-&gt;removePredecessor(block);
316     }
317 
318     Vector&lt;BasicBlock*, 1&gt; noBlocks()
319     {
320         return Vector&lt;BasicBlock*, 1&gt;();
321     }
322 
323     Vector&lt;BasicBlock*, 1&gt; oneBlock(BasicBlock* block)
324     {
325         Vector&lt;BasicBlock*, 1&gt; result;
326         result.append(block);
327         return result;
328     }
329 
330     void mergeBlocks(
331         BasicBlock* firstBlock, BasicBlock* secondBlock,
332         Vector&lt;BasicBlock*, 1&gt; jettisonedBlocks)
333     {
334         RELEASE_ASSERT(canMergeBlocks(firstBlock, secondBlock));
335         // This will add all of the nodes in secondBlock to firstBlock, but in so doing
336         // it will also ensure that any GetLocals from the second block that refer to
337         // SetLocals in the first block are relinked. If jettisonedBlock is not NoBlock,
338         // then Phantoms are inserted for anything that the jettisonedBlock would have
339         // kept alive.
340 
341         // Remove the terminal of firstBlock since we don&#39;t need it anymore. Well, we don&#39;t
342         // really remove it; we actually turn it into a check.
343         Node* terminal = firstBlock-&gt;terminal();
344         ASSERT(terminal-&gt;isTerminal());
345         NodeOrigin boundaryNodeOrigin = terminal-&gt;origin;
346         terminal-&gt;remove(m_graph);
347         ASSERT(terminal-&gt;refCount() == 1);
348 
349         for (unsigned i = jettisonedBlocks.size(); i--;) {
350             BasicBlock* jettisonedBlock = jettisonedBlocks[i];
351 
352             // Time to insert ghosties for things that need to be kept alive in case we OSR
353             // exit prior to hitting the firstBlock&#39;s terminal, and end up going down a
354             // different path than secondBlock.
355 
356             for (size_t i = 0; i &lt; jettisonedBlock-&gt;variablesAtHead.numberOfArguments(); ++i)
<a name="2" id="anc2"></a><span class="line-modified">357                 keepOperandAlive(firstBlock, jettisonedBlock, boundaryNodeOrigin, virtualRegisterForArgument(i));</span>
358             for (size_t i = 0; i &lt; jettisonedBlock-&gt;variablesAtHead.numberOfLocals(); ++i)
359                 keepOperandAlive(firstBlock, jettisonedBlock, boundaryNodeOrigin, virtualRegisterForLocal(i));
360         }
361 
362         for (size_t i = 0; i &lt; secondBlock-&gt;phis.size(); ++i)
363             firstBlock-&gt;phis.append(secondBlock-&gt;phis[i]);
364 
365         for (size_t i = 0; i &lt; secondBlock-&gt;size(); ++i)
366             firstBlock-&gt;append(secondBlock-&gt;at(i));
367 
368         ASSERT(firstBlock-&gt;terminal()-&gt;isTerminal());
369 
370         // Fix the predecessors of my new successors. This is tricky, since we are going to reset
371         // all predecessors anyway due to reachability analysis. But we need to fix the
372         // predecessors eagerly to ensure that we know what they are in case the next block we
373         // consider in this phase wishes to query the predecessors of one of the blocks we
374         // affected.
375         for (unsigned i = firstBlock-&gt;numSuccessors(); i--;) {
376             BasicBlock* successor = firstBlock-&gt;successor(i);
377             for (unsigned j = 0; j &lt; successor-&gt;predecessors.size(); ++j) {
378                 if (successor-&gt;predecessors[j] == secondBlock)
379                     successor-&gt;predecessors[j] = firstBlock;
380             }
381         }
382 
383         // Fix the predecessors of my former successors. Again, we&#39;d rather not do this, but it&#39;s
384         // an unfortunate necessity. See above comment.
385         for (unsigned i = jettisonedBlocks.size(); i--;)
386             fixJettisonedPredecessors(firstBlock, jettisonedBlocks[i]);
387 
388         firstBlock-&gt;valuesAtTail = secondBlock-&gt;valuesAtTail;
389         firstBlock-&gt;cfaBranchDirection = secondBlock-&gt;cfaBranchDirection;
390 
391         m_graph.killBlock(secondBlock);
392     }
393 };
394 
395 bool performCFGSimplification(Graph&amp; graph)
396 {
397     return runPhase&lt;CFGSimplificationPhase&gt;(graph);
398 }
399 
400 } } // namespace JSC::DFG
401 
402 #endif // ENABLE(DFG_JIT)
403 
404 
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLASTDumper.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Metal/WHLSLNativeTypeWriter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLASTDumper.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLASTDumper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
285 void ASTDumper::visit(AST::StageInOutSemantic&amp; stageInOutSemantic)
286 {
287     m_out.print(&quot;attribute(&quot;, stageInOutSemantic.index(), &quot;)&quot;);
288 }
289 
290 void ASTDumper::visit(AST::IntegerLiteral&amp; integerLiteral)
291 {
292     m_out.print(integerLiteral.value());
293 }
294 
295 void ASTDumper::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
296 {
297     m_out.print(unsignedIntegerLiteral.value());
298 }
299 
300 void ASTDumper::visit(AST::FloatLiteral&amp; floatLiteral)
301 {
302     m_out.print(floatLiteral.value());
303 }
304 
<span class="line-removed">305 void ASTDumper::visit(AST::NullLiteral&amp; nullLiteral)</span>
<span class="line-removed">306 {</span>
<span class="line-removed">307     m_out.print(&quot;null&quot;);</span>
<span class="line-removed">308     visit(nullLiteral.type());</span>
<span class="line-removed">309 }</span>
<span class="line-removed">310 </span>
311 void ASTDumper::visit(AST::BooleanLiteral&amp; booleanLiteral)
312 {
313     if (booleanLiteral.value())
314         m_out.print(&quot;true&quot;);
315     else
316         m_out.print(&quot;false&quot;);
317 }
318 
319 void ASTDumper::visit(AST::IntegerLiteralType&amp;)
320 {
321 }
322 
323 void ASTDumper::visit(AST::UnsignedIntegerLiteralType&amp;)
324 {
325 }
326 
327 void ASTDumper::visit(AST::FloatLiteralType&amp;)
328 {
329 }
330 
<span class="line-removed">331 void ASTDumper::visit(AST::NullLiteralType&amp;)</span>
<span class="line-removed">332 {</span>
<span class="line-removed">333 }</span>
<span class="line-removed">334 </span>
335 void ASTDumper::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
336 {
337     m_out.print(enumerationMemberLiteral.left(), &quot;.&quot;, enumerationMemberLiteral.right());
338 }
339 
340 void ASTDumper::visit(AST::FunctionAttribute&amp; functionAttribute)
341 {
342     WTF::visit(WTF::makeVisitor([&amp;](AST::NumThreadsFunctionAttribute&amp; numThreadsFunctionAttribute) {
343         visit(numThreadsFunctionAttribute);
344     }), functionAttribute);
345 }
346 
347 void ASTDumper::visit(AST::NumThreadsFunctionAttribute&amp; numThreadsAttribute)
348 {
349     m_out.print(&quot;numthreads(&quot;, numThreadsAttribute.width(), &quot;, &quot;, numThreadsAttribute.height(), &quot;, &quot;, numThreadsAttribute.depth(), &quot;)&quot;);
350 }
351 
352 void ASTDumper::visit(AST::Block&amp; block)
353 {
354     m_out.println(&quot;{&quot;);
</pre>
<hr />
<pre>
408 
409 void ASTDumper::visit(AST::ForLoop&amp; forLoop)
410 {
411     m_out.print(&quot;for (&quot;);
412     visit(forLoop.initialization());
413     m_out.print(&quot;; &quot;);
414     if (forLoop.condition())
415         visit(*forLoop.condition());
416     m_out.print(&quot;; &quot;);
417     if (forLoop.increment())
418         visit(*forLoop.increment());
419     m_out.print(&quot;) &quot;);
420     visit(forLoop.body());
421 }
422 
423 void ASTDumper::visit(AST::Expression&amp; expression)
424 {
425     bool skipParens = is&lt;AST::BooleanLiteral&gt;(expression)
426         || is&lt;AST::FloatLiteral&gt;(expression)
427         || is&lt;AST::IntegerLiteral&gt;(expression)
<span class="line-removed">428         || is&lt;AST::NullLiteral&gt;(expression)</span>
429         || is&lt;AST::UnsignedIntegerLiteral&gt;(expression)
430         || is&lt;AST::EnumerationMemberLiteral&gt;(expression)
431         || is&lt;AST::CommaExpression&gt;(expression)
432         || is&lt;AST::VariableReference&gt;(expression);
433 
434     if (auto* annotation = expression.maybeTypeAnnotation()) {
435         if (auto addressSpace = annotation-&gt;leftAddressSpace())
436             m_out.print(&quot;&lt;LV:&quot;, AST::toString(*addressSpace));
437         else if (annotation-&gt;isAbstractLeftValue())
438             m_out.print(&quot;&lt;ALV&quot;);
439         else if (annotation-&gt;isRightValue())
440             m_out.print(&quot;&lt;RV&quot;);
441 
442         m_out.print(&quot;, &quot;, expression.resolvedType().toString(), &quot;&gt;&quot;);
443 
444         skipParens = false;
445     }
446 
447     if (!skipParens)
448         m_out.print(&quot;(&quot;);
</pre>
</td>
<td>
<hr />
<pre>
285 void ASTDumper::visit(AST::StageInOutSemantic&amp; stageInOutSemantic)
286 {
287     m_out.print(&quot;attribute(&quot;, stageInOutSemantic.index(), &quot;)&quot;);
288 }
289 
290 void ASTDumper::visit(AST::IntegerLiteral&amp; integerLiteral)
291 {
292     m_out.print(integerLiteral.value());
293 }
294 
295 void ASTDumper::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
296 {
297     m_out.print(unsignedIntegerLiteral.value());
298 }
299 
300 void ASTDumper::visit(AST::FloatLiteral&amp; floatLiteral)
301 {
302     m_out.print(floatLiteral.value());
303 }
304 






305 void ASTDumper::visit(AST::BooleanLiteral&amp; booleanLiteral)
306 {
307     if (booleanLiteral.value())
308         m_out.print(&quot;true&quot;);
309     else
310         m_out.print(&quot;false&quot;);
311 }
312 
313 void ASTDumper::visit(AST::IntegerLiteralType&amp;)
314 {
315 }
316 
317 void ASTDumper::visit(AST::UnsignedIntegerLiteralType&amp;)
318 {
319 }
320 
321 void ASTDumper::visit(AST::FloatLiteralType&amp;)
322 {
323 }
324 




325 void ASTDumper::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
326 {
327     m_out.print(enumerationMemberLiteral.left(), &quot;.&quot;, enumerationMemberLiteral.right());
328 }
329 
330 void ASTDumper::visit(AST::FunctionAttribute&amp; functionAttribute)
331 {
332     WTF::visit(WTF::makeVisitor([&amp;](AST::NumThreadsFunctionAttribute&amp; numThreadsFunctionAttribute) {
333         visit(numThreadsFunctionAttribute);
334     }), functionAttribute);
335 }
336 
337 void ASTDumper::visit(AST::NumThreadsFunctionAttribute&amp; numThreadsAttribute)
338 {
339     m_out.print(&quot;numthreads(&quot;, numThreadsAttribute.width(), &quot;, &quot;, numThreadsAttribute.height(), &quot;, &quot;, numThreadsAttribute.depth(), &quot;)&quot;);
340 }
341 
342 void ASTDumper::visit(AST::Block&amp; block)
343 {
344     m_out.println(&quot;{&quot;);
</pre>
<hr />
<pre>
398 
399 void ASTDumper::visit(AST::ForLoop&amp; forLoop)
400 {
401     m_out.print(&quot;for (&quot;);
402     visit(forLoop.initialization());
403     m_out.print(&quot;; &quot;);
404     if (forLoop.condition())
405         visit(*forLoop.condition());
406     m_out.print(&quot;; &quot;);
407     if (forLoop.increment())
408         visit(*forLoop.increment());
409     m_out.print(&quot;) &quot;);
410     visit(forLoop.body());
411 }
412 
413 void ASTDumper::visit(AST::Expression&amp; expression)
414 {
415     bool skipParens = is&lt;AST::BooleanLiteral&gt;(expression)
416         || is&lt;AST::FloatLiteral&gt;(expression)
417         || is&lt;AST::IntegerLiteral&gt;(expression)

418         || is&lt;AST::UnsignedIntegerLiteral&gt;(expression)
419         || is&lt;AST::EnumerationMemberLiteral&gt;(expression)
420         || is&lt;AST::CommaExpression&gt;(expression)
421         || is&lt;AST::VariableReference&gt;(expression);
422 
423     if (auto* annotation = expression.maybeTypeAnnotation()) {
424         if (auto addressSpace = annotation-&gt;leftAddressSpace())
425             m_out.print(&quot;&lt;LV:&quot;, AST::toString(*addressSpace));
426         else if (annotation-&gt;isAbstractLeftValue())
427             m_out.print(&quot;&lt;ALV&quot;);
428         else if (annotation-&gt;isRightValue())
429             m_out.print(&quot;&lt;RV&quot;);
430 
431         m_out.print(&quot;, &quot;, expression.resolvedType().toString(), &quot;&gt;&quot;);
432 
433         skipParens = false;
434     }
435 
436     if (!skipParens)
437         m_out.print(&quot;(&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="Metal/WHLSLNativeTypeWriter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLASTDumper.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapSnapshotBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HeapSnapshot.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HeapUtil.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapSnapshotBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
133     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
134 
135     m_edges.append(HeapSnapshotEdge(from, to, EdgeType::Variable, variableName));
136 }
137 
138 void HeapSnapshotBuilder::analyzeIndexEdge(JSCell* from, JSCell* to, uint32_t index)
139 {
140     ASSERT(m_profiler.activeHeapAnalyzer() == this);
141     ASSERT(to);
142 
143     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
144 
145     m_edges.append(HeapSnapshotEdge(from, to, index));
146 }
147 
148 void HeapSnapshotBuilder::setOpaqueRootReachabilityReasonForCell(JSCell* cell, const char* reason)
149 {
150     if (!reason || !*reason || m_snapshotType != SnapshotType::GCDebuggingSnapshot)
151         return;
152 


153     m_rootData.ensure(cell, [] () -&gt; RootData {
154         return { };
155     }).iterator-&gt;value.reachabilityFromOpaqueRootReasons = reason;
156 }
157 
158 void HeapSnapshotBuilder::setWrappedObjectForCell(JSCell* cell, void* wrappedPtr)
159 {
160     m_wrappedObjectPointers.set(cell, wrappedPtr);
161 }
162 
163 bool HeapSnapshotBuilder::previousSnapshotHasNodeForCell(JSCell* cell, NodeIdentifier&amp; identifier)
164 {
165     if (!m_snapshot-&gt;previous())
166         return false;
167 
168     auto existingNode = m_snapshot-&gt;previous()-&gt;nodeForCell(cell);
169     if (existingNode) {
170         identifier = existingNode.value().identifier;
171         return true;
172     }
</pre>
<hr />
<pre>
383     StringBuilder json;
384 
385     auto appendNodeJSON = [&amp;] (const HeapSnapshotNode&amp; node) {
386         // Let the client decide if they want to allow or disallow certain nodes.
387         if (!allowNodeCallback(node))
388             return;
389 
390         unsigned flags = 0;
391 
392         allowedNodeIdentifiers.set(node.cell, node.identifier);
393 
394         String className = node.cell-&gt;classInfo(vm)-&gt;className;
395         if (node.cell-&gt;isObject() &amp;&amp; className == JSObject::info()-&gt;className) {
396             flags |= static_cast&lt;unsigned&gt;(NodeFlags::ObjectSubtype);
397 
398             // Skip calculating a class name if this object has a `constructor` own property.
399             // These cases are typically F.prototype objects and we want to treat these as
400             // &quot;Object&quot; in snapshots and not get the name of the prototype&#39;s parent.
401             JSObject* object = asObject(node.cell);
402             if (JSGlobalObject* globalObject = object-&gt;globalObject(vm)) {
<span class="line-removed">403                 ExecState* exec = globalObject-&gt;globalExec();</span>
404                 PropertySlot slot(object, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">405                 if (!object-&gt;getOwnPropertySlot(object, exec, vm.propertyNames-&gt;constructor, slot))</span>
406                     className = JSObject::calculatedClassName(object);
407             }
408         }
409 
410         auto result = classNameIndexes.add(className, nextClassNameIndex);
411         if (result.isNewEntry)
412             nextClassNameIndex++;
413         unsigned classNameIndex = result.iterator-&gt;value;
414 
415         void* wrappedAddress = 0;
416         unsigned labelIndex = 0;
417         if (!node.cell-&gt;isString() &amp;&amp; !node.cell-&gt;isBigInt()) {
418             Structure* structure = node.cell-&gt;structure(vm);
419             if (!structure || !structure-&gt;globalObject())
420                 flags |= static_cast&lt;unsigned&gt;(NodeFlags::Internal);
421 
422             if (m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
423                 String nodeLabel;
424                 auto it = m_cellLabels.find(node.cell);
425                 if (it != m_cellLabels.end())
</pre>
<hr />
<pre>
446                     labelIndex = result.iterator-&gt;value;
447                 }
448 
449                 wrappedAddress = m_wrappedObjectPointers.get(node.cell);
450             }
451         }
452 
453         // &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;flags&gt;, [&lt;labelIndex&gt;, &lt;cellEddress&gt;, &lt;wrappedAddress&gt;]
454         json.append(&#39;,&#39;);
455         json.appendNumber(node.identifier);
456         json.append(&#39;,&#39;);
457         json.appendNumber(node.cell-&gt;estimatedSizeInBytes(vm));
458         json.append(&#39;,&#39;);
459         json.appendNumber(classNameIndex);
460         json.append(&#39;,&#39;);
461         json.appendNumber(flags);
462         if (m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
463             json.append(&#39;,&#39;);
464             json.appendNumber(labelIndex);
465             json.appendLiteral(&quot;,\&quot;0x&quot;);
<span class="line-modified">466             appendUnsignedAsHex(reinterpret_cast&lt;uintptr_t&gt;(node.cell), json, Lowercase);</span>
467             json.appendLiteral(&quot;\&quot;,\&quot;0x&quot;);
<span class="line-modified">468             appendUnsignedAsHex(reinterpret_cast&lt;uintptr_t&gt;(wrappedAddress), json, Lowercase);</span>
469             json.append(&#39;&quot;&#39;);
470         }
471     };
472 
473     bool firstEdge = true;
474     auto appendEdgeJSON = [&amp;] (const HeapSnapshotEdge&amp; edge) {
475         if (!firstEdge)
476             json.append(&#39;,&#39;);
477         firstEdge = false;
478 
479         // &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;
480         json.appendNumber(edge.from.identifier);
481         json.append(&#39;,&#39;);
482         json.appendNumber(edge.to.identifier);
483         json.append(&#39;,&#39;);
484         json.appendNumber(edgeTypeToNumber(edge.type));
485         json.append(&#39;,&#39;);
486         switch (edge.type) {
487         case EdgeType::Property:
488         case EdgeType::Variable: {
</pre>
</td>
<td>
<hr />
<pre>
133     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
134 
135     m_edges.append(HeapSnapshotEdge(from, to, EdgeType::Variable, variableName));
136 }
137 
138 void HeapSnapshotBuilder::analyzeIndexEdge(JSCell* from, JSCell* to, uint32_t index)
139 {
140     ASSERT(m_profiler.activeHeapAnalyzer() == this);
141     ASSERT(to);
142 
143     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
144 
145     m_edges.append(HeapSnapshotEdge(from, to, index));
146 }
147 
148 void HeapSnapshotBuilder::setOpaqueRootReachabilityReasonForCell(JSCell* cell, const char* reason)
149 {
150     if (!reason || !*reason || m_snapshotType != SnapshotType::GCDebuggingSnapshot)
151         return;
152 
<span class="line-added">153     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);</span>
<span class="line-added">154 </span>
155     m_rootData.ensure(cell, [] () -&gt; RootData {
156         return { };
157     }).iterator-&gt;value.reachabilityFromOpaqueRootReasons = reason;
158 }
159 
160 void HeapSnapshotBuilder::setWrappedObjectForCell(JSCell* cell, void* wrappedPtr)
161 {
162     m_wrappedObjectPointers.set(cell, wrappedPtr);
163 }
164 
165 bool HeapSnapshotBuilder::previousSnapshotHasNodeForCell(JSCell* cell, NodeIdentifier&amp; identifier)
166 {
167     if (!m_snapshot-&gt;previous())
168         return false;
169 
170     auto existingNode = m_snapshot-&gt;previous()-&gt;nodeForCell(cell);
171     if (existingNode) {
172         identifier = existingNode.value().identifier;
173         return true;
174     }
</pre>
<hr />
<pre>
385     StringBuilder json;
386 
387     auto appendNodeJSON = [&amp;] (const HeapSnapshotNode&amp; node) {
388         // Let the client decide if they want to allow or disallow certain nodes.
389         if (!allowNodeCallback(node))
390             return;
391 
392         unsigned flags = 0;
393 
394         allowedNodeIdentifiers.set(node.cell, node.identifier);
395 
396         String className = node.cell-&gt;classInfo(vm)-&gt;className;
397         if (node.cell-&gt;isObject() &amp;&amp; className == JSObject::info()-&gt;className) {
398             flags |= static_cast&lt;unsigned&gt;(NodeFlags::ObjectSubtype);
399 
400             // Skip calculating a class name if this object has a `constructor` own property.
401             // These cases are typically F.prototype objects and we want to treat these as
402             // &quot;Object&quot; in snapshots and not get the name of the prototype&#39;s parent.
403             JSObject* object = asObject(node.cell);
404             if (JSGlobalObject* globalObject = object-&gt;globalObject(vm)) {

405                 PropertySlot slot(object, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">406                 if (!object-&gt;getOwnPropertySlot(object, globalObject, vm.propertyNames-&gt;constructor, slot))</span>
407                     className = JSObject::calculatedClassName(object);
408             }
409         }
410 
411         auto result = classNameIndexes.add(className, nextClassNameIndex);
412         if (result.isNewEntry)
413             nextClassNameIndex++;
414         unsigned classNameIndex = result.iterator-&gt;value;
415 
416         void* wrappedAddress = 0;
417         unsigned labelIndex = 0;
418         if (!node.cell-&gt;isString() &amp;&amp; !node.cell-&gt;isBigInt()) {
419             Structure* structure = node.cell-&gt;structure(vm);
420             if (!structure || !structure-&gt;globalObject())
421                 flags |= static_cast&lt;unsigned&gt;(NodeFlags::Internal);
422 
423             if (m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
424                 String nodeLabel;
425                 auto it = m_cellLabels.find(node.cell);
426                 if (it != m_cellLabels.end())
</pre>
<hr />
<pre>
447                     labelIndex = result.iterator-&gt;value;
448                 }
449 
450                 wrappedAddress = m_wrappedObjectPointers.get(node.cell);
451             }
452         }
453 
454         // &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;flags&gt;, [&lt;labelIndex&gt;, &lt;cellEddress&gt;, &lt;wrappedAddress&gt;]
455         json.append(&#39;,&#39;);
456         json.appendNumber(node.identifier);
457         json.append(&#39;,&#39;);
458         json.appendNumber(node.cell-&gt;estimatedSizeInBytes(vm));
459         json.append(&#39;,&#39;);
460         json.appendNumber(classNameIndex);
461         json.append(&#39;,&#39;);
462         json.appendNumber(flags);
463         if (m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
464             json.append(&#39;,&#39;);
465             json.appendNumber(labelIndex);
466             json.appendLiteral(&quot;,\&quot;0x&quot;);
<span class="line-modified">467             json.append(hex(reinterpret_cast&lt;uintptr_t&gt;(node.cell), Lowercase));</span>
468             json.appendLiteral(&quot;\&quot;,\&quot;0x&quot;);
<span class="line-modified">469             json.append(hex(reinterpret_cast&lt;uintptr_t&gt;(wrappedAddress), Lowercase));</span>
470             json.append(&#39;&quot;&#39;);
471         }
472     };
473 
474     bool firstEdge = true;
475     auto appendEdgeJSON = [&amp;] (const HeapSnapshotEdge&amp; edge) {
476         if (!firstEdge)
477             json.append(&#39;,&#39;);
478         firstEdge = false;
479 
480         // &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;
481         json.appendNumber(edge.from.identifier);
482         json.append(&#39;,&#39;);
483         json.appendNumber(edge.to.identifier);
484         json.append(&#39;,&#39;);
485         json.appendNumber(edgeTypeToNumber(edge.type));
486         json.append(&#39;,&#39;);
487         switch (edge.type) {
488         case EdgeType::Property:
489         case EdgeType::Variable: {
</pre>
</td>
</tr>
</table>
<center><a href="HeapSnapshot.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HeapUtil.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
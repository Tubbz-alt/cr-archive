<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Operands.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Opcode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OperandsInlines.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Operands.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2011-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 33,115 ***</span>
  
  namespace JSC {
  
  template&lt;typename T&gt; struct OperandValueTraits;
  
<span class="line-modified">! enum OperandKind { ArgumentOperand, LocalOperand };</span>
  
  enum OperandsLikeTag { OperandsLike };
  
  template&lt;typename T&gt;
  class Operands {
  public:
<span class="line-modified">!     Operands()</span>
<span class="line-modified">!         : m_numArguments(0) { }</span>
  
<span class="line-modified">!     explicit Operands(size_t numArguments, size_t numLocals)</span>
          : m_numArguments(numArguments)
      {
<span class="line-modified">!         if (WTF::VectorTraits&lt;T&gt;::needsInitialization) {</span>
<span class="line-modified">!             m_values.resize(numArguments + numLocals);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             m_values.fill(T(), numArguments + numLocals);</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     explicit Operands(size_t numArguments, size_t numLocals, const T&amp; initialValue)</span>
          : m_numArguments(numArguments)
      {
<span class="line-modified">!         m_values.fill(initialValue, numArguments + numLocals);</span>
      }
  
      template&lt;typename U&gt;
<span class="line-modified">!     explicit Operands(OperandsLikeTag, const Operands&lt;U&gt;&amp; other)</span>
          : m_numArguments(other.numberOfArguments())
      {
<span class="line-modified">!         m_values.fill(T(), other.numberOfArguments() + other.numberOfLocals());</span>
      }
  
      size_t numberOfArguments() const { return m_numArguments; }
<span class="line-modified">!     size_t numberOfLocals() const { return m_values.size() - m_numArguments; }</span>
  
      size_t argumentIndex(size_t idx) const
      {
<span class="line-modified">!         ASSERT(idx &lt; m_numArguments);</span>
          return idx;
      }
  
      size_t localIndex(size_t idx) const
      {
<span class="line-modified">!         return m_numArguments + idx;</span>
      }
  
<span class="line-modified">!     T&amp; argument(size_t idx)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         return m_values[argumentIndex(idx)];</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     const T&amp; argument(size_t idx) const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return m_values[argumentIndex(idx)];</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     T&amp; local(size_t idx) { return m_values[localIndex(idx)]; }</span>
<span class="line-modified">!     const T&amp; local(size_t idx) const { return m_values[localIndex(idx)]; }</span>
  
      template&lt;OperandKind operandKind&gt;
      size_t sizeFor() const
      {
<span class="line-modified">!         if (operandKind == ArgumentOperand)</span>
              return numberOfArguments();
<span class="line-modified">!         return numberOfLocals();</span>
      }
      template&lt;OperandKind operandKind&gt;
<span class="line-modified">!     T&amp; atFor(size_t idx)</span>
      {
<span class="line-modified">!         if (operandKind == ArgumentOperand)</span>
              return argument(idx);
<span class="line-modified">!         return local(idx);</span>
      }
      template&lt;OperandKind operandKind&gt;
<span class="line-modified">!     const T&amp; atFor(size_t idx) const</span>
      {
<span class="line-modified">!         if (operandKind == ArgumentOperand)</span>
              return argument(idx);
<span class="line-modified">!         return local(idx);</span>
      }
  
<span class="line-modified">!     void ensureLocals(size_t size)</span>
      {
<span class="line-modified">!         size_t oldSize = m_values.size();</span>
<span class="line-removed">-         size_t newSize = m_numArguments + size;</span>
<span class="line-removed">-         if (newSize &lt;= oldSize)</span>
              return;
  
          m_values.grow(newSize);
<span class="line-modified">!         if (!WTF::VectorTraits&lt;T&gt;::needsInitialization) {</span>
<span class="line-modified">!             for (size_t i = oldSize; i &lt; m_values.size(); ++i)</span>
<span class="line-modified">!                 m_values[i] = T();</span>
          }
      }
  
<span class="line-modified">!     void ensureLocals(size_t size, const T&amp; ensuredValue)</span>
      {
<span class="line-modified">!         size_t oldSize = m_values.size();</span>
<span class="line-removed">-         size_t newSize = m_numArguments + size;</span>
<span class="line-removed">-         if (newSize &lt;= oldSize)</span>
              return;
  
          m_values.grow(newSize);
<span class="line-modified">!         for (size_t i = oldSize; i &lt; m_values.size(); ++i)</span>
<span class="line-modified">!             m_values[i] = ensuredValue;</span>
      }
  
      void setLocal(size_t idx, const T&amp; value)
      {
          ensureLocals(idx + 1);
<span class="line-new-header">--- 33,250 ---</span>
  
  namespace JSC {
  
  template&lt;typename T&gt; struct OperandValueTraits;
  
<span class="line-modified">! constexpr unsigned maxNumCheckpointTmps = 4;</span>
<span class="line-added">+ </span>
<span class="line-added">+ // A OperandKind::Tmp is one that exists for exiting to a checkpoint but does not exist between bytecodes.</span>
<span class="line-added">+ enum class OperandKind : uint32_t { Argument, Local, Tmp }; // Keep bit-width in sync with Operand::operandKindBits&#39; definition.</span>
<span class="line-added">+ static constexpr OperandKind lastOperandKind = OperandKind::Tmp;</span>
<span class="line-added">+ </span>
<span class="line-added">+ class Operand {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     static constexpr unsigned kindBits = WTF::getMSBSetConstexpr(static_cast&lt;std::underlying_type_t&lt;OperandKind&gt;&gt;(lastOperandKind)) + 1;</span>
<span class="line-added">+     static constexpr unsigned maxBits = 32 + kindBits;</span>
<span class="line-added">+     static_assert(maxBits == 34);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Operand() = default;</span>
<span class="line-added">+     Operand(const Operand&amp;) = default;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Operand(VirtualRegister operand)</span>
<span class="line-added">+         : Operand(operand.isLocal() ? OperandKind::Local : OperandKind::Argument, operand.offset())</span>
<span class="line-added">+     { }</span>
<span class="line-added">+ </span>
<span class="line-added">+     Operand(OperandKind kind, int operand)</span>
<span class="line-added">+ #if CPU(LITTLE_ENDIAN)</span>
<span class="line-added">+         : m_operand(operand)</span>
<span class="line-added">+         , m_kind(kind)</span>
<span class="line-added">+ #else</span>
<span class="line-added">+         : m_kind(kind)</span>
<span class="line-added">+         , m_operand(operand)</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ASSERT(kind == OperandKind::Tmp || VirtualRegister(operand).isLocal() == (kind == OperandKind::Local));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     static Operand tmp(uint32_t index) { return Operand(OperandKind::Tmp, index); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     OperandKind kind() const { return m_kind; }</span>
<span class="line-added">+     int value() const { return m_operand; }</span>
<span class="line-added">+     VirtualRegister virtualRegister() const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ASSERT(m_kind != OperandKind::Tmp);</span>
<span class="line-added">+         return VirtualRegister(m_operand);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     uint64_t asBits() const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         uint64_t bits = bitwise_cast&lt;uint64_t&gt;(*this);</span>
<span class="line-added">+         ASSERT(bits &lt; (1ULL &lt;&lt; maxBits));</span>
<span class="line-added">+         return bits;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     static Operand fromBits(uint64_t value);</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool isTmp() const { return kind() == OperandKind::Tmp; }</span>
<span class="line-added">+     bool isArgument() const { return kind() == OperandKind::Argument; }</span>
<span class="line-added">+     bool isLocal() const { return kind() == OperandKind::Local &amp;&amp; virtualRegister().isLocal(); }</span>
<span class="line-added">+     bool isHeader() const { return kind() != OperandKind::Tmp &amp;&amp; virtualRegister().isHeader(); }</span>
<span class="line-added">+     bool isConstant() const { return kind() != OperandKind::Tmp &amp;&amp; virtualRegister().isConstant(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     int toArgument() const { ASSERT(isArgument()); return virtualRegister().toArgument(); }</span>
<span class="line-added">+     int toLocal() const { ASSERT(isLocal()); return virtualRegister().toLocal(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     inline bool isValid() const;</span>
<span class="line-added">+ </span>
<span class="line-added">+     inline bool operator==(const Operand&amp;) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+     void dump(PrintStream&amp;) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+ #if CPU(LITTLE_ENDIAN)</span>
<span class="line-added">+     int m_operand { VirtualRegister::invalidVirtualRegister };</span>
<span class="line-added">+     OperandKind m_kind { OperandKind::Argument };</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     OperandKind m_kind { OperandKind::Argument };</span>
<span class="line-added">+     int m_operand { VirtualRegister::invalidVirtualRegister };</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ ALWAYS_INLINE bool Operand::operator==(const Operand&amp; other) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (kind() != other.kind())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     if (isTmp())</span>
<span class="line-added">+         return value() == other.value();</span>
<span class="line-added">+     return virtualRegister() == other.virtualRegister();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline bool Operand::isValid() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (isTmp())</span>
<span class="line-added">+         return value() &gt;= 0;</span>
<span class="line-added">+     return virtualRegister().isValid();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline Operand Operand::fromBits(uint64_t value)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Operand result = bitwise_cast&lt;Operand&gt;(value);</span>
<span class="line-added">+     ASSERT(result.isValid());</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static_assert(sizeof(Operand) == sizeof(uint64_t), &quot;Operand::asBits() relies on this.&quot;);</span>
  
  enum OperandsLikeTag { OperandsLike };
  
  template&lt;typename T&gt;
  class Operands {
  public:
<span class="line-modified">!     using Storage = std::conditional_t&lt;std::is_same_v&lt;T, bool&gt;, FastBitVector, Vector&lt;T, 0, UnsafeVectorOverflow&gt;&gt;;</span>
<span class="line-modified">!     using RefType = std::conditional_t&lt;std::is_same_v&lt;T, bool&gt;, FastBitReference, T&amp;&gt;;</span>
<span class="line-added">+     using ConstRefType = std::conditional_t&lt;std::is_same_v&lt;T, bool&gt;, bool, const T&amp;&gt;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Operands() = default;</span>
  
<span class="line-modified">!     explicit Operands(size_t numArguments, size_t numLocals, size_t numTmps)</span>
          : m_numArguments(numArguments)
<span class="line-added">+         , m_numLocals(numLocals)</span>
      {
<span class="line-modified">!         size_t size = numArguments + numLocals + numTmps;</span>
<span class="line-modified">!         m_values.grow(size);</span>
<span class="line-modified">!         if (!WTF::VectorTraits&lt;T&gt;::needsInitialization)</span>
<span class="line-modified">!             m_values.fill(T());</span>
      }
  
<span class="line-modified">!     explicit Operands(size_t numArguments, size_t numLocals, size_t numTmps, const T&amp; initialValue)</span>
          : m_numArguments(numArguments)
<span class="line-added">+         , m_numLocals(numLocals)</span>
      {
<span class="line-modified">!         m_values.grow(numArguments + numLocals + numTmps);</span>
<span class="line-added">+         m_values.fill(initialValue);</span>
      }
  
      template&lt;typename U&gt;
<span class="line-modified">!     explicit Operands(OperandsLikeTag, const Operands&lt;U&gt;&amp; other, const T&amp; initialValue = T())</span>
          : m_numArguments(other.numberOfArguments())
<span class="line-added">+         , m_numLocals(other.numberOfLocals())</span>
      {
<span class="line-modified">!         m_values.grow(other.size());</span>
<span class="line-added">+         m_values.fill(initialValue);</span>
      }
  
      size_t numberOfArguments() const { return m_numArguments; }
<span class="line-modified">!     size_t numberOfLocals() const { return m_numLocals; }</span>
<span class="line-added">+     size_t numberOfTmps() const { return m_values.size() - numberOfArguments() - numberOfLocals(); }</span>
  
<span class="line-added">+     size_t tmpIndex(size_t idx) const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ASSERT(idx &lt; numberOfTmps());</span>
<span class="line-added">+         return idx + numberOfArguments() + numberOfLocals();</span>
<span class="line-added">+     }</span>
      size_t argumentIndex(size_t idx) const
      {
<span class="line-modified">!         ASSERT(idx &lt; numberOfArguments());</span>
          return idx;
      }
  
      size_t localIndex(size_t idx) const
      {
<span class="line-modified">!         ASSERT(idx &lt; numberOfLocals());</span>
<span class="line-added">+         return numberOfArguments() + idx;</span>
      }
  
<span class="line-modified">!     RefType tmp(size_t idx) { return m_values[tmpIndex(idx)]; }</span>
<span class="line-modified">!     ConstRefType tmp(size_t idx) const { return m_values[tmpIndex(idx)]; }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     RefType argument(size_t idx) { return m_values[argumentIndex(idx)]; }</span>
<span class="line-modified">!     ConstRefType argument(size_t idx) const { return m_values[argumentIndex(idx)]; }</span>
  
<span class="line-modified">!     RefType local(size_t idx) { return m_values[localIndex(idx)]; }</span>
<span class="line-modified">!     ConstRefType local(size_t idx) const { return m_values[localIndex(idx)]; }</span>
  
      template&lt;OperandKind operandKind&gt;
      size_t sizeFor() const
      {
<span class="line-modified">!         switch (operandKind) {</span>
<span class="line-added">+         case OperandKind::Tmp:</span>
<span class="line-added">+             return numberOfTmps();</span>
<span class="line-added">+         case OperandKind::Argument:</span>
              return numberOfArguments();
<span class="line-modified">!         case OperandKind::Local:</span>
<span class="line-added">+             return numberOfLocals();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return 0;</span>
      }
      template&lt;OperandKind operandKind&gt;
<span class="line-modified">!     RefType atFor(size_t idx)</span>
      {
<span class="line-modified">!         switch (operandKind) {</span>
<span class="line-added">+         case OperandKind::Tmp:</span>
<span class="line-added">+             return tmp(idx);</span>
<span class="line-added">+         case OperandKind::Argument:</span>
              return argument(idx);
<span class="line-modified">!         case OperandKind::Local:</span>
<span class="line-added">+             return local(idx);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return tmp(0);</span>
      }
      template&lt;OperandKind operandKind&gt;
<span class="line-modified">!     ConstRefType atFor(size_t idx) const</span>
      {
<span class="line-modified">!         switch (operandKind) {</span>
<span class="line-added">+         case OperandKind::Tmp:</span>
<span class="line-added">+             return tmp(idx);</span>
<span class="line-added">+         case OperandKind::Argument:</span>
              return argument(idx);
<span class="line-modified">!         case OperandKind::Local:</span>
<span class="line-added">+             return local(idx);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return tmp(0);</span>
      }
  
<span class="line-modified">!     void ensureLocals(size_t size, const T&amp; ensuredValue = T())</span>
      {
<span class="line-modified">!         if (size &lt;= numberOfLocals())</span>
              return;
  
<span class="line-added">+         size_t newSize = numberOfArguments() + numberOfTmps() + size;</span>
<span class="line-added">+         size_t oldNumLocals = numberOfLocals();</span>
<span class="line-added">+         size_t oldNumTmps = numberOfTmps();</span>
          m_values.grow(newSize);
<span class="line-modified">!         for (size_t i = 0; i &lt; oldNumTmps; ++i)</span>
<span class="line-modified">!             m_values[newSize - 1 - i] = m_values[tmpIndex(oldNumTmps - 1 - i)];</span>
<span class="line-modified">! </span>
<span class="line-added">+         m_numLocals = size;</span>
<span class="line-added">+         if (ensuredValue != T() || !WTF::VectorTraits&lt;T&gt;::needsInitialization) {</span>
<span class="line-added">+             for (size_t i = 0; i &lt; size - oldNumLocals; ++i)</span>
<span class="line-added">+                 m_values[localIndex(oldNumLocals + i)] = ensuredValue;</span>
          }
      }
  
<span class="line-modified">!     void ensureTmps(size_t size, const T&amp; ensuredValue = T())</span>
      {
<span class="line-modified">!         if (size &lt;= numberOfTmps())</span>
              return;
  
<span class="line-added">+         size_t oldSize = m_values.size();</span>
<span class="line-added">+         size_t newSize = numberOfArguments() + numberOfLocals() + size;</span>
          m_values.grow(newSize);
<span class="line-modified">! </span>
<span class="line-modified">!         if (ensuredValue != T() || !WTF::VectorTraits&lt;T&gt;::needsInitialization) {</span>
<span class="line-added">+             for (size_t i = oldSize; i &lt; newSize; ++i)</span>
<span class="line-added">+                 m_values[i] = ensuredValue;</span>
<span class="line-added">+         }</span>
      }
  
      void setLocal(size_t idx, const T&amp; value)
      {
          ensureLocals(idx + 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,85 ***</span>
      {
          ASSERT(idx &gt;= numberOfLocals() || local(idx) == T());
          setLocal(idx, value);
      }
  
<span class="line-modified">!     size_t operandIndex(int operand) const</span>
      {
<span class="line-modified">!         if (operandIsArgument(operand))</span>
<span class="line-modified">!             return argumentIndex(VirtualRegister(operand).toArgument());</span>
<span class="line-modified">!         return localIndex(VirtualRegister(operand).toLocal());</span>
      }
  
<span class="line-modified">!     size_t operandIndex(VirtualRegister virtualRegister) const</span>
      {
<span class="line-modified">!         return operandIndex(virtualRegister.offset());</span>
      }
  
<span class="line-modified">!     T&amp; operand(int operand)</span>
      {
<span class="line-modified">!         if (operandIsArgument(operand))</span>
<span class="line-modified">!             return argument(VirtualRegister(operand).toArgument());</span>
<span class="line-modified">!         return local(VirtualRegister(operand).toLocal());</span>
      }
  
<span class="line-modified">!     T&amp; operand(VirtualRegister virtualRegister)</span>
      {
<span class="line-modified">!         return operand(virtualRegister.offset());</span>
      }
  
<span class="line-modified">!     const T&amp; operand(int operand) const { return const_cast&lt;const T&amp;&gt;(const_cast&lt;Operands*&gt;(this)-&gt;operand(operand)); }</span>
<span class="line-modified">!     const T&amp; operand(VirtualRegister operand) const { return const_cast&lt;const T&amp;&gt;(const_cast&lt;Operands*&gt;(this)-&gt;operand(operand)); }</span>
  
<span class="line-modified">!     bool hasOperand(int operand) const</span>
      {
<span class="line-modified">!         if (operandIsArgument(operand))</span>
              return true;
<span class="line-modified">!         return static_cast&lt;size_t&gt;(VirtualRegister(operand).toLocal()) &lt; numberOfLocals();</span>
      }
<span class="line-modified">!     bool hasOperand(VirtualRegister reg) const</span>
      {
<span class="line-modified">!         return hasOperand(reg.offset());</span>
      }
  
<span class="line-modified">!     void setOperand(int operand, const T&amp; value)</span>
      {
          this-&gt;operand(operand) = value;
      }
  
<span class="line-removed">-     void setOperand(VirtualRegister virtualRegister, const T&amp; value)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         setOperand(virtualRegister.offset(), value);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      size_t size() const { return m_values.size(); }
<span class="line-modified">!     const T&amp; at(size_t index) const { return m_values[index]; }</span>
<span class="line-modified">!     T&amp; at(size_t index) { return m_values[index]; }</span>
<span class="line-modified">!     const T&amp; operator[](size_t index) const { return at(index); }</span>
<span class="line-modified">!     T&amp; operator[](size_t index) { return at(index); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bool isArgument(size_t index) const { return index &lt; m_numArguments; }</span>
<span class="line-removed">-     bool isLocal(size_t index) const { return !isArgument(index); }</span>
<span class="line-removed">-     int operandForIndex(size_t index) const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         if (index &lt; numberOfArguments())</span>
<span class="line-removed">-             return virtualRegisterForArgument(index).offset();</span>
<span class="line-removed">-         return virtualRegisterForLocal(index - numberOfArguments()).offset();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     VirtualRegister virtualRegisterForIndex(size_t index) const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return VirtualRegister(operandForIndex(index));</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void setOperandFirstTime(int operand, const T&amp; value)</span>
      {
<span class="line-modified">!         if (operandIsArgument(operand)) {</span>
<span class="line-modified">!             setArgumentFirstTime(VirtualRegister(operand).toArgument(), value);</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-removed">-         setLocalFirstTime(VirtualRegister(operand).toLocal(), value);</span>
      }
  
      void fill(T value)
      {
          for (size_t i = 0; i &lt; m_values.size(); ++i)
<span class="line-new-header">--- 298,77 ---</span>
      {
          ASSERT(idx &gt;= numberOfLocals() || local(idx) == T());
          setLocal(idx, value);
      }
  
<span class="line-modified">!     RefType getForOperandIndex(size_t index) { return m_values[index]; }</span>
<span class="line-added">+     ConstRefType getForOperandIndex(size_t index) const { return const_cast&lt;Operands*&gt;(this)-&gt;getForOperandIndex(index); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     size_t operandIndex(VirtualRegister operand) const</span>
      {
<span class="line-modified">!         if (operand.isArgument())</span>
<span class="line-modified">!             return argumentIndex(operand.toArgument());</span>
<span class="line-modified">!         return localIndex(operand.toLocal());</span>
      }
  
<span class="line-modified">!     size_t operandIndex(Operand op) const</span>
      {
<span class="line-modified">!         if (!op.isTmp())</span>
<span class="line-added">+             return operandIndex(op.virtualRegister());</span>
<span class="line-added">+         return tmpIndex(op.value());</span>
      }
  
<span class="line-modified">!     RefType operand(VirtualRegister operand)</span>
      {
<span class="line-modified">!         if (operand.isArgument())</span>
<span class="line-modified">!             return argument(operand.toArgument());</span>
<span class="line-modified">!         return local(operand.toLocal());</span>
      }
  
<span class="line-modified">!     RefType operand(Operand op)</span>
      {
<span class="line-modified">!         if (!op.isTmp())</span>
<span class="line-added">+             return operand(op.virtualRegister());</span>
<span class="line-added">+         return tmp(op.value());</span>
      }
  
<span class="line-modified">!     ConstRefType operand(VirtualRegister operand) const { return const_cast&lt;Operands*&gt;(this)-&gt;operand(operand); }</span>
<span class="line-modified">!     ConstRefType operand(Operand operand) const { return const_cast&lt;Operands*&gt;(this)-&gt;operand(operand); }</span>
  
<span class="line-modified">!     bool hasOperand(VirtualRegister operand) const</span>
      {
<span class="line-modified">!         if (operand.isArgument())</span>
              return true;
<span class="line-modified">!         return static_cast&lt;size_t&gt;(operand.toLocal()) &lt; numberOfLocals();</span>
      }
<span class="line-modified">!     bool hasOperand(Operand op) const</span>
      {
<span class="line-modified">!         if (op.isTmp()) {</span>
<span class="line-added">+             ASSERT(op.value() &gt;= 0);</span>
<span class="line-added">+             return static_cast&lt;size_t&gt;(op.value()) &lt; numberOfTmps();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return hasOperand(op.virtualRegister());</span>
      }
  
<span class="line-modified">!     void setOperand(Operand operand, const T&amp; value)</span>
      {
          this-&gt;operand(operand) = value;
      }
  
      size_t size() const { return m_values.size(); }
<span class="line-modified">!     ConstRefType at(size_t index) const { return m_values[index]; }</span>
<span class="line-modified">!     RefType at(size_t index) { return m_values[index]; }</span>
<span class="line-modified">!     ConstRefType operator[](size_t index) const { return at(index); }</span>
<span class="line-modified">!     RefType operator[](size_t index) { return at(index); }</span>
  
<span class="line-modified">!     Operand operandForIndex(size_t index) const</span>
      {
<span class="line-modified">!         if (index &lt; numberOfArguments())</span>
<span class="line-modified">!             return virtualRegisterForArgumentIncludingThis(index);</span>
<span class="line-modified">!         else if (index &lt; numberOfLocals() + numberOfArguments())</span>
<span class="line-modified">!             return virtualRegisterForLocal(index - numberOfArguments());</span>
<span class="line-modified">!         return Operand::tmp(index - (numberOfLocals() + numberOfArguments()));</span>
      }
  
      void fill(T value)
      {
          for (size_t i = 0; i &lt; m_values.size(); ++i)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 255,19 ***</span>
  
      bool operator==(const Operands&amp; other) const
      {
          ASSERT(numberOfArguments() == other.numberOfArguments());
          ASSERT(numberOfLocals() == other.numberOfLocals());
  
          return m_values == other.m_values;
      }
  
      void dumpInContext(PrintStream&amp; out, DumpContext* context) const;
      void dump(PrintStream&amp; out) const;
  
  private:
<span class="line-modified">!     // The first m_numArguments of m_values are arguments, the rest are locals.</span>
<span class="line-modified">!     Vector&lt;T, 0, UnsafeVectorOverflow&gt; m_values;</span>
<span class="line-modified">!     unsigned m_numArguments;</span>
  };
  
  } // namespace JSC
<span class="line-new-header">--- 382,21 ---</span>
  
      bool operator==(const Operands&amp; other) const
      {
          ASSERT(numberOfArguments() == other.numberOfArguments());
          ASSERT(numberOfLocals() == other.numberOfLocals());
<span class="line-added">+         ASSERT(numberOfTmps() == other.numberOfTmps());</span>
  
          return m_values == other.m_values;
      }
  
      void dumpInContext(PrintStream&amp; out, DumpContext* context) const;
      void dump(PrintStream&amp; out) const;
  
  private:
<span class="line-modified">!     // The first m_numArguments of m_values are arguments, the next m_numLocals are locals, and the rest are tmps.</span>
<span class="line-modified">!     Storage m_values;</span>
<span class="line-modified">!     unsigned m_numArguments { 0 };</span>
<span class="line-added">+     unsigned m_numLocals { 0 };</span>
  };
  
  } // namespace JSC
</pre>
<center><a href="Opcode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OperandsInlines.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
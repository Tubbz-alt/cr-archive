<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMIterator.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Canon, Inc. All rights reserved.
  3  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY CANON INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CANON INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;JSDOMConvert.h&quot;
 30 #include &lt;JavaScriptCore/IteratorPrototype.h&gt;
 31 #include &lt;type_traits&gt;
 32 
 33 namespace WebCore {
 34 
 35 void addValueIterableMethods(JSC::JSGlobalObject&amp;, JSC::JSObject&amp;);
 36 
 37 enum class JSDOMIteratorType { Set, Map };
 38 
 39 // struct IteratorTraits {
 40 //     static constexpr JSDOMIteratorType type = [Map|Set];
 41 //     using KeyType = [IDLType|void];
 42 //     using ValueType = [IDLType];
 43 // };
 44 
 45 template&lt;typename T, typename U = void&gt; using EnableIfMap = typename std::enable_if&lt;T::type == JSDOMIteratorType::Map, U&gt;::type;
 46 template&lt;typename T, typename U = void&gt; using EnableIfSet = typename std::enable_if&lt;T::type == JSDOMIteratorType::Set, U&gt;::type;
 47 
 48 template&lt;typename JSWrapper, typename IteratorTraits&gt; class JSDOMIteratorPrototype : public JSC::JSNonFinalObject {
 49 public:
 50     using Base = JSC::JSNonFinalObject;
 51     using DOMWrapped = typename JSWrapper::DOMWrapped;
 52 
 53     static JSDOMIteratorPrototype* create(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
 54     {
 55         JSDOMIteratorPrototype* prototype = new (NotNull, JSC::allocateCell&lt;JSDOMIteratorPrototype&gt;(vm.heap)) JSDOMIteratorPrototype(vm, structure);
 56         prototype-&gt;finishCreation(vm, globalObject);
 57         return prototype;
 58     }
 59 
 60     DECLARE_INFO;
 61 
 62     static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
 63     {
 64         return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
 65     }
 66 
 67     static JSC::EncodedJSValue JSC_HOST_CALL next(JSC::ExecState*);
 68 
 69 private:
 70     JSDOMIteratorPrototype(JSC::VM&amp; vm, JSC::Structure* structure) : Base(vm, structure) { }
 71 
 72     void finishCreation(JSC::VM&amp;, JSC::JSGlobalObject*);
 73 };
 74 
 75 enum class IterationKind { Key, Value, KeyValue };
 76 
 77 template&lt;typename JSWrapper, typename IteratorTraits&gt; class JSDOMIterator : public JSDOMObject {
 78 public:
 79     using Base = JSDOMObject;
 80 
 81     using Wrapper = JSWrapper;
 82     using Traits = IteratorTraits;
 83 
 84     using DOMWrapped = typename Wrapper::DOMWrapped;
 85     using Prototype = JSDOMIteratorPrototype&lt;Wrapper, Traits&gt;;
 86 
 87     DECLARE_INFO;
 88 
 89     static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
 90     {
 91         return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
 92     }
 93 
 94     static JSDOMIterator* create(JSC::VM&amp; vm, JSC::Structure* structure, JSWrapper&amp; iteratedObject, IterationKind kind)
 95     {
 96         JSDOMIterator* instance = new (NotNull, JSC::allocateCell&lt;JSDOMIterator&gt;(vm.heap)) JSDOMIterator(structure, iteratedObject, kind);
 97         instance-&gt;finishCreation(vm);
 98         return instance;
 99     }
100 
101     static Prototype* createPrototype(JSC::VM&amp; vm, JSC::JSGlobalObject&amp; globalObject)
102     {
103         return Prototype::create(vm, &amp;globalObject, Prototype::createStructure(vm, &amp;globalObject, globalObject.iteratorPrototype()));
104     }
105 
106     JSC::JSValue next(JSC::ExecState&amp;);
107 
108 private:
109     JSDOMIterator(JSC::Structure* structure, JSWrapper&amp; iteratedObject, IterationKind kind)
110         : Base(structure, *iteratedObject.globalObject())
111         , m_iterator(iteratedObject.wrapped().createIterator())
112         , m_kind(kind)
113     {
114     }
115 
116     template&lt;typename IteratorValue, typename T = Traits&gt; EnableIfMap&lt;T, JSC::JSValue&gt; asJS(JSC::ExecState&amp;, IteratorValue&amp;);
117     template&lt;typename IteratorValue, typename T = Traits&gt; EnableIfSet&lt;T, JSC::JSValue&gt; asJS(JSC::ExecState&amp;, IteratorValue&amp;);
118 
119     static void destroy(JSC::JSCell*);
120 
121     Optional&lt;typename DOMWrapped::Iterator&gt; m_iterator;
122     IterationKind m_kind;
123 };
124 
125 inline JSC::JSValue jsPair(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, JSC::JSValue value1, JSC::JSValue value2)
126 {
127     JSC::MarkedArgumentBuffer arguments;
128     arguments.append(value1);
129     arguments.append(value2);
130     ASSERT(!arguments.hasOverflowed());
131     return constructArray(&amp;state, nullptr, &amp;globalObject, arguments);
132 }
133 
134 template&lt;typename FirstType, typename SecondType, typename T, typename U&gt;
135 inline JSC::JSValue jsPair(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const T&amp; value1, const U&amp; value2)
136 {
137     return jsPair(state, globalObject, toJS&lt;FirstType&gt;(state, globalObject, value1), toJS&lt;SecondType&gt;(state, globalObject, value2));
138 }
139 
140 template&lt;typename JSIterator&gt; JSC::JSValue iteratorCreate(typename JSIterator::Wrapper&amp;, IterationKind);
141 template&lt;typename JSIterator&gt; JSC::JSValue iteratorForEach(JSC::ExecState&amp;, typename JSIterator::Wrapper&amp;, JSC::ThrowScope&amp;);
142 
143 template&lt;typename JSIterator&gt; JSC::JSValue iteratorCreate(typename JSIterator::Wrapper&amp; thisObject, IterationKind kind)
144 {
145     ASSERT(thisObject.globalObject());
146     JSDOMGlobalObject&amp; globalObject = *thisObject.globalObject();
147     return JSIterator::create(globalObject.vm(), getDOMStructure&lt;JSIterator&gt;(globalObject.vm(), globalObject), thisObject, kind);
148 }
149 
150 template&lt;typename JSWrapper, typename IteratorTraits&gt;
151 template&lt;typename IteratorValue, typename T&gt; inline EnableIfMap&lt;T, JSC::JSValue&gt; JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::asJS(JSC::ExecState&amp; state, IteratorValue&amp; value)
152 {
153     ASSERT(value);
154 
155     switch (m_kind) {
156     case IterationKind::Key:
157         return toJS&lt;typename Traits::KeyType&gt;(state, *globalObject(), value-&gt;key);
158     case IterationKind::Value:
159         return toJS&lt;typename Traits::ValueType&gt;(state, *globalObject(), value-&gt;value);
160     case IterationKind::KeyValue:
161         return jsPair&lt;typename Traits::KeyType, typename Traits::ValueType&gt;(state, *globalObject(), value-&gt;key, value-&gt;value);
162     };
163 
164     ASSERT_NOT_REACHED();
165     return { };
166 }
167 
168 template&lt;typename JSWrapper, typename IteratorTraits&gt;
169 template&lt;typename IteratorValue, typename T&gt; inline EnableIfSet&lt;T, JSC::JSValue&gt; JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::asJS(JSC::ExecState&amp; state, IteratorValue&amp; value)
170 {
171     ASSERT(value);
172 
173     auto globalObject = this-&gt;globalObject();
174     auto result = toJS&lt;typename Traits::ValueType&gt;(state, *globalObject, value);
175 
176     switch (m_kind) {
177     case IterationKind::Key:
178     case IterationKind::Value:
179         return result;
180     case IterationKind::KeyValue:
181         return jsPair(state, *globalObject, result, result);
182     };
183 
184     ASSERT_NOT_REACHED();
185     return { };
186 }
187 
188 template&lt;typename JSIterator, typename IteratorValue&gt; EnableIfMap&lt;typename JSIterator::Traits&gt; appendForEachArguments(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, JSC::MarkedArgumentBuffer&amp; arguments, IteratorValue&amp; value)
189 {
190     ASSERT(value);
191     arguments.append(toJS&lt;typename JSIterator::Traits::ValueType&gt;(state, globalObject, value-&gt;value));
192     arguments.append(toJS&lt;typename JSIterator::Traits::KeyType&gt;(state, globalObject, value-&gt;key));
193 }
194 
195 template&lt;typename JSIterator, typename IteratorValue&gt; EnableIfSet&lt;typename JSIterator::Traits&gt; appendForEachArguments(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, JSC::MarkedArgumentBuffer&amp; arguments, IteratorValue&amp; value)
196 {
197     ASSERT(value);
198     auto argument = toJS&lt;typename JSIterator::Traits::ValueType&gt;(state, globalObject, value);
199     arguments.append(argument);
200     arguments.append(argument);
201 }
202 
203 template&lt;typename JSIterator&gt; JSC::JSValue iteratorForEach(JSC::ExecState&amp; state, typename JSIterator::Wrapper&amp; thisObject, JSC::ThrowScope&amp; scope)
204 {
205     JSC::JSValue callback = state.argument(0);
206     JSC::JSValue thisValue = state.argument(1);
207 
208     JSC::CallData callData;
209     JSC::CallType callType = JSC::getCallData(state.vm(), callback, callData);
210     if (callType == JSC::CallType::None)
211         return throwTypeError(&amp;state, scope, &quot;Cannot call callback&quot;_s);
212 
213     auto iterator = thisObject.wrapped().createIterator();
214     while (auto value = iterator.next()) {
215         JSC::MarkedArgumentBuffer arguments;
216         appendForEachArguments&lt;JSIterator&gt;(state, *thisObject.globalObject(), arguments, value);
217         arguments.append(&amp;thisObject);
218         if (UNLIKELY(arguments.hasOverflowed())) {
219             throwOutOfMemoryError(&amp;state, scope);
220             return { };
221         }
222         JSC::call(&amp;state, callback, callType, callData, thisValue, arguments);
223         if (UNLIKELY(scope.exception()))
224             break;
225     }
226     return JSC::jsUndefined();
227 }
228 
229 template&lt;typename JSWrapper, typename IteratorTraits&gt;
230 void JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::destroy(JSCell* cell)
231 {
232     JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;* thisObject = static_cast&lt;JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;*&gt;(cell);
233     thisObject-&gt;JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::~JSDOMIterator();
234 }
235 
236 template&lt;typename JSWrapper, typename IteratorTraits&gt;
237 JSC::JSValue JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::next(JSC::ExecState&amp; state)
238 {
239     if (m_iterator) {
240         auto iteratorValue = m_iterator-&gt;next();
241         if (iteratorValue)
242             return createIteratorResultObject(&amp;state, asJS(state, iteratorValue), false);
243         m_iterator = WTF::nullopt;
244     }
245     return createIteratorResultObject(&amp;state, JSC::jsUndefined(), true);
246 }
247 
248 template&lt;typename JSWrapper, typename IteratorTraits&gt;
249 JSC::EncodedJSValue JSC_HOST_CALL JSDOMIteratorPrototype&lt;JSWrapper, IteratorTraits&gt;::next(JSC::ExecState* state)
250 {
251     JSC::VM&amp; vm = state-&gt;vm();
252     auto scope = DECLARE_THROW_SCOPE(vm);
253 
254     auto iterator = JSC::jsDynamicCast&lt;JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;*&gt;(vm, state-&gt;thisValue());
255     if (!iterator)
256         return JSC::JSValue::encode(throwTypeError(state, scope, &quot;Cannot call next() on a non-Iterator object&quot;_s));
257 
258     return JSC::JSValue::encode(iterator-&gt;next(*state));
259 }
260 
261 template&lt;typename JSWrapper, typename IteratorTraits&gt;
262 void JSDOMIteratorPrototype&lt;JSWrapper, IteratorTraits&gt;::finishCreation(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject)
263 {
264     Base::finishCreation(vm);
265     ASSERT(inherits(vm, info()));
266 
267     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;next, next, 0, 0, JSC::NoIntrinsic);
268 }
269 
270 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Operands.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Opcode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OperandsInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Operands.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2011-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CallFrame.h&quot;
 29 #include &quot;VirtualRegister.h&quot;
 30 
 31 #include &lt;wtf/PrintStream.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 
 34 namespace JSC {
 35 
 36 template&lt;typename T&gt; struct OperandValueTraits;
 37 
<span class="line-modified"> 38 enum OperandKind { ArgumentOperand, LocalOperand };</span>































































































 39 
 40 enum OperandsLikeTag { OperandsLike };
 41 
 42 template&lt;typename T&gt;
 43 class Operands {
 44 public:
<span class="line-modified"> 45     Operands()</span>
<span class="line-modified"> 46         : m_numArguments(0) { }</span>



 47 
<span class="line-modified"> 48     explicit Operands(size_t numArguments, size_t numLocals)</span>
 49         : m_numArguments(numArguments)

 50     {
<span class="line-modified"> 51         if (WTF::VectorTraits&lt;T&gt;::needsInitialization) {</span>
<span class="line-modified"> 52             m_values.resize(numArguments + numLocals);</span>
<span class="line-modified"> 53         } else {</span>
<span class="line-modified"> 54             m_values.fill(T(), numArguments + numLocals);</span>
<span class="line-removed"> 55         }</span>
 56     }
 57 
<span class="line-modified"> 58     explicit Operands(size_t numArguments, size_t numLocals, const T&amp; initialValue)</span>
 59         : m_numArguments(numArguments)

 60     {
<span class="line-modified"> 61         m_values.fill(initialValue, numArguments + numLocals);</span>

 62     }
 63 
 64     template&lt;typename U&gt;
<span class="line-modified"> 65     explicit Operands(OperandsLikeTag, const Operands&lt;U&gt;&amp; other)</span>
 66         : m_numArguments(other.numberOfArguments())

 67     {
<span class="line-modified"> 68         m_values.fill(T(), other.numberOfArguments() + other.numberOfLocals());</span>

 69     }
 70 
 71     size_t numberOfArguments() const { return m_numArguments; }
<span class="line-modified"> 72     size_t numberOfLocals() const { return m_values.size() - m_numArguments; }</span>

 73 





 74     size_t argumentIndex(size_t idx) const
 75     {
<span class="line-modified"> 76         ASSERT(idx &lt; m_numArguments);</span>
 77         return idx;
 78     }
 79 
 80     size_t localIndex(size_t idx) const
 81     {
<span class="line-modified"> 82         return m_numArguments + idx;</span>

 83     }
 84 
<span class="line-modified"> 85     T&amp; argument(size_t idx)</span>
<span class="line-modified"> 86     {</span>
<span class="line-modified"> 87         return m_values[argumentIndex(idx)];</span>
<span class="line-modified"> 88     }</span>
<span class="line-modified"> 89     const T&amp; argument(size_t idx) const</span>
<span class="line-removed"> 90     {</span>
<span class="line-removed"> 91         return m_values[argumentIndex(idx)];</span>
<span class="line-removed"> 92     }</span>
 93 
<span class="line-modified"> 94     T&amp; local(size_t idx) { return m_values[localIndex(idx)]; }</span>
<span class="line-modified"> 95     const T&amp; local(size_t idx) const { return m_values[localIndex(idx)]; }</span>
 96 
 97     template&lt;OperandKind operandKind&gt;
 98     size_t sizeFor() const
 99     {
<span class="line-modified">100         if (operandKind == ArgumentOperand)</span>



101             return numberOfArguments();
<span class="line-modified">102         return numberOfLocals();</span>




103     }
104     template&lt;OperandKind operandKind&gt;
<span class="line-modified">105     T&amp; atFor(size_t idx)</span>
106     {
<span class="line-modified">107         if (operandKind == ArgumentOperand)</span>



108             return argument(idx);
<span class="line-modified">109         return local(idx);</span>




110     }
111     template&lt;OperandKind operandKind&gt;
<span class="line-modified">112     const T&amp; atFor(size_t idx) const</span>
113     {
<span class="line-modified">114         if (operandKind == ArgumentOperand)</span>



115             return argument(idx);
<span class="line-modified">116         return local(idx);</span>




117     }
118 
<span class="line-modified">119     void ensureLocals(size_t size)</span>
120     {
<span class="line-modified">121         size_t oldSize = m_values.size();</span>
<span class="line-removed">122         size_t newSize = m_numArguments + size;</span>
<span class="line-removed">123         if (newSize &lt;= oldSize)</span>
124             return;
125 



126         m_values.grow(newSize);
<span class="line-modified">127         if (!WTF::VectorTraits&lt;T&gt;::needsInitialization) {</span>
<span class="line-modified">128             for (size_t i = oldSize; i &lt; m_values.size(); ++i)</span>
<span class="line-modified">129                 m_values[i] = T();</span>




130         }
131     }
132 
<span class="line-modified">133     void ensureLocals(size_t size, const T&amp; ensuredValue)</span>
134     {
<span class="line-modified">135         size_t oldSize = m_values.size();</span>
<span class="line-removed">136         size_t newSize = m_numArguments + size;</span>
<span class="line-removed">137         if (newSize &lt;= oldSize)</span>
138             return;
139 


140         m_values.grow(newSize);
<span class="line-modified">141         for (size_t i = oldSize; i &lt; m_values.size(); ++i)</span>
<span class="line-modified">142             m_values[i] = ensuredValue;</span>



143     }
144 
145     void setLocal(size_t idx, const T&amp; value)
146     {
147         ensureLocals(idx + 1);
148         local(idx) = value;
149     }
150 
151     T getLocal(size_t idx)
152     {
153         return idx &gt;= numberOfLocals() ? T() : local(idx);
154     }
155 
156     void setArgumentFirstTime(size_t idx, const T&amp; value)
157     {
158         ASSERT(m_values[idx] == T());
159         argument(idx) = value;
160     }
161 
162     void setLocalFirstTime(size_t idx, const T&amp; value)
163     {
164         ASSERT(idx &gt;= numberOfLocals() || local(idx) == T());
165         setLocal(idx, value);
166     }
167 
<span class="line-modified">168     size_t operandIndex(int operand) const</span>



169     {
<span class="line-modified">170         if (operandIsArgument(operand))</span>
<span class="line-modified">171             return argumentIndex(VirtualRegister(operand).toArgument());</span>
<span class="line-modified">172         return localIndex(VirtualRegister(operand).toLocal());</span>
173     }
174 
<span class="line-modified">175     size_t operandIndex(VirtualRegister virtualRegister) const</span>
176     {
<span class="line-modified">177         return operandIndex(virtualRegister.offset());</span>


178     }
179 
<span class="line-modified">180     T&amp; operand(int operand)</span>
181     {
<span class="line-modified">182         if (operandIsArgument(operand))</span>
<span class="line-modified">183             return argument(VirtualRegister(operand).toArgument());</span>
<span class="line-modified">184         return local(VirtualRegister(operand).toLocal());</span>
185     }
186 
<span class="line-modified">187     T&amp; operand(VirtualRegister virtualRegister)</span>
188     {
<span class="line-modified">189         return operand(virtualRegister.offset());</span>


190     }
191 
<span class="line-modified">192     const T&amp; operand(int operand) const { return const_cast&lt;const T&amp;&gt;(const_cast&lt;Operands*&gt;(this)-&gt;operand(operand)); }</span>
<span class="line-modified">193     const T&amp; operand(VirtualRegister operand) const { return const_cast&lt;const T&amp;&gt;(const_cast&lt;Operands*&gt;(this)-&gt;operand(operand)); }</span>
194 
<span class="line-modified">195     bool hasOperand(int operand) const</span>
196     {
<span class="line-modified">197         if (operandIsArgument(operand))</span>
198             return true;
<span class="line-modified">199         return static_cast&lt;size_t&gt;(VirtualRegister(operand).toLocal()) &lt; numberOfLocals();</span>
200     }
<span class="line-modified">201     bool hasOperand(VirtualRegister reg) const</span>
202     {
<span class="line-modified">203         return hasOperand(reg.offset());</span>




204     }
205 
<span class="line-modified">206     void setOperand(int operand, const T&amp; value)</span>
207     {
208         this-&gt;operand(operand) = value;
209     }
210 
<span class="line-removed">211     void setOperand(VirtualRegister virtualRegister, const T&amp; value)</span>
<span class="line-removed">212     {</span>
<span class="line-removed">213         setOperand(virtualRegister.offset(), value);</span>
<span class="line-removed">214     }</span>
<span class="line-removed">215 </span>
216     size_t size() const { return m_values.size(); }
<span class="line-modified">217     const T&amp; at(size_t index) const { return m_values[index]; }</span>
<span class="line-modified">218     T&amp; at(size_t index) { return m_values[index]; }</span>
<span class="line-modified">219     const T&amp; operator[](size_t index) const { return at(index); }</span>
<span class="line-modified">220     T&amp; operator[](size_t index) { return at(index); }</span>
<span class="line-removed">221 </span>
<span class="line-removed">222     bool isArgument(size_t index) const { return index &lt; m_numArguments; }</span>
<span class="line-removed">223     bool isLocal(size_t index) const { return !isArgument(index); }</span>
<span class="line-removed">224     int operandForIndex(size_t index) const</span>
<span class="line-removed">225     {</span>
<span class="line-removed">226         if (index &lt; numberOfArguments())</span>
<span class="line-removed">227             return virtualRegisterForArgument(index).offset();</span>
<span class="line-removed">228         return virtualRegisterForLocal(index - numberOfArguments()).offset();</span>
<span class="line-removed">229     }</span>
<span class="line-removed">230     VirtualRegister virtualRegisterForIndex(size_t index) const</span>
<span class="line-removed">231     {</span>
<span class="line-removed">232         return VirtualRegister(operandForIndex(index));</span>
<span class="line-removed">233     }</span>
234 
<span class="line-modified">235     void setOperandFirstTime(int operand, const T&amp; value)</span>
236     {
<span class="line-modified">237         if (operandIsArgument(operand)) {</span>
<span class="line-modified">238             setArgumentFirstTime(VirtualRegister(operand).toArgument(), value);</span>
<span class="line-modified">239             return;</span>
<span class="line-modified">240         }</span>
<span class="line-modified">241 </span>
<span class="line-removed">242         setLocalFirstTime(VirtualRegister(operand).toLocal(), value);</span>
243     }
244 
245     void fill(T value)
246     {
247         for (size_t i = 0; i &lt; m_values.size(); ++i)
248             m_values[i] = value;
249     }
250 
251     void clear()
252     {
253         fill(T());
254     }
255 
256     bool operator==(const Operands&amp; other) const
257     {
258         ASSERT(numberOfArguments() == other.numberOfArguments());
259         ASSERT(numberOfLocals() == other.numberOfLocals());

260 
261         return m_values == other.m_values;
262     }
263 
264     void dumpInContext(PrintStream&amp; out, DumpContext* context) const;
265     void dump(PrintStream&amp; out) const;
266 
267 private:
<span class="line-modified">268     // The first m_numArguments of m_values are arguments, the rest are locals.</span>
<span class="line-modified">269     Vector&lt;T, 0, UnsafeVectorOverflow&gt; m_values;</span>
<span class="line-modified">270     unsigned m_numArguments;</span>

271 };
272 
273 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CallFrame.h&quot;
 29 #include &quot;VirtualRegister.h&quot;
 30 
 31 #include &lt;wtf/PrintStream.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 
 34 namespace JSC {
 35 
 36 template&lt;typename T&gt; struct OperandValueTraits;
 37 
<span class="line-modified"> 38 constexpr unsigned maxNumCheckpointTmps = 4;</span>
<span class="line-added"> 39 </span>
<span class="line-added"> 40 // A OperandKind::Tmp is one that exists for exiting to a checkpoint but does not exist between bytecodes.</span>
<span class="line-added"> 41 enum class OperandKind : uint32_t { Argument, Local, Tmp }; // Keep bit-width in sync with Operand::operandKindBits&#39; definition.</span>
<span class="line-added"> 42 static constexpr OperandKind lastOperandKind = OperandKind::Tmp;</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44 class Operand {</span>
<span class="line-added"> 45 public:</span>
<span class="line-added"> 46     static constexpr unsigned kindBits = WTF::getMSBSetConstexpr(static_cast&lt;std::underlying_type_t&lt;OperandKind&gt;&gt;(lastOperandKind)) + 1;</span>
<span class="line-added"> 47     static constexpr unsigned maxBits = 32 + kindBits;</span>
<span class="line-added"> 48     static_assert(maxBits == 34);</span>
<span class="line-added"> 49 </span>
<span class="line-added"> 50     Operand() = default;</span>
<span class="line-added"> 51     Operand(const Operand&amp;) = default;</span>
<span class="line-added"> 52 </span>
<span class="line-added"> 53     Operand(VirtualRegister operand)</span>
<span class="line-added"> 54         : Operand(operand.isLocal() ? OperandKind::Local : OperandKind::Argument, operand.offset())</span>
<span class="line-added"> 55     { }</span>
<span class="line-added"> 56 </span>
<span class="line-added"> 57     Operand(OperandKind kind, int operand)</span>
<span class="line-added"> 58 #if CPU(LITTLE_ENDIAN)</span>
<span class="line-added"> 59         : m_operand(operand)</span>
<span class="line-added"> 60         , m_kind(kind)</span>
<span class="line-added"> 61 #else</span>
<span class="line-added"> 62         : m_kind(kind)</span>
<span class="line-added"> 63         , m_operand(operand)</span>
<span class="line-added"> 64 #endif</span>
<span class="line-added"> 65     {</span>
<span class="line-added"> 66         ASSERT(kind == OperandKind::Tmp || VirtualRegister(operand).isLocal() == (kind == OperandKind::Local));</span>
<span class="line-added"> 67     }</span>
<span class="line-added"> 68     static Operand tmp(uint32_t index) { return Operand(OperandKind::Tmp, index); }</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70     OperandKind kind() const { return m_kind; }</span>
<span class="line-added"> 71     int value() const { return m_operand; }</span>
<span class="line-added"> 72     VirtualRegister virtualRegister() const</span>
<span class="line-added"> 73     {</span>
<span class="line-added"> 74         ASSERT(m_kind != OperandKind::Tmp);</span>
<span class="line-added"> 75         return VirtualRegister(m_operand);</span>
<span class="line-added"> 76     }</span>
<span class="line-added"> 77     uint64_t asBits() const</span>
<span class="line-added"> 78     {</span>
<span class="line-added"> 79         uint64_t bits = bitwise_cast&lt;uint64_t&gt;(*this);</span>
<span class="line-added"> 80         ASSERT(bits &lt; (1ULL &lt;&lt; maxBits));</span>
<span class="line-added"> 81         return bits;</span>
<span class="line-added"> 82     }</span>
<span class="line-added"> 83     static Operand fromBits(uint64_t value);</span>
<span class="line-added"> 84 </span>
<span class="line-added"> 85     bool isTmp() const { return kind() == OperandKind::Tmp; }</span>
<span class="line-added"> 86     bool isArgument() const { return kind() == OperandKind::Argument; }</span>
<span class="line-added"> 87     bool isLocal() const { return kind() == OperandKind::Local &amp;&amp; virtualRegister().isLocal(); }</span>
<span class="line-added"> 88     bool isHeader() const { return kind() != OperandKind::Tmp &amp;&amp; virtualRegister().isHeader(); }</span>
<span class="line-added"> 89     bool isConstant() const { return kind() != OperandKind::Tmp &amp;&amp; virtualRegister().isConstant(); }</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91     int toArgument() const { ASSERT(isArgument()); return virtualRegister().toArgument(); }</span>
<span class="line-added"> 92     int toLocal() const { ASSERT(isLocal()); return virtualRegister().toLocal(); }</span>
<span class="line-added"> 93 </span>
<span class="line-added"> 94     inline bool isValid() const;</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96     inline bool operator==(const Operand&amp;) const;</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98     void dump(PrintStream&amp;) const;</span>
<span class="line-added"> 99 </span>
<span class="line-added">100 private:</span>
<span class="line-added">101 #if CPU(LITTLE_ENDIAN)</span>
<span class="line-added">102     int m_operand { VirtualRegister::invalidVirtualRegister };</span>
<span class="line-added">103     OperandKind m_kind { OperandKind::Argument };</span>
<span class="line-added">104 #else</span>
<span class="line-added">105     OperandKind m_kind { OperandKind::Argument };</span>
<span class="line-added">106     int m_operand { VirtualRegister::invalidVirtualRegister };</span>
<span class="line-added">107 #endif</span>
<span class="line-added">108 };</span>
<span class="line-added">109 </span>
<span class="line-added">110 ALWAYS_INLINE bool Operand::operator==(const Operand&amp; other) const</span>
<span class="line-added">111 {</span>
<span class="line-added">112     if (kind() != other.kind())</span>
<span class="line-added">113         return false;</span>
<span class="line-added">114     if (isTmp())</span>
<span class="line-added">115         return value() == other.value();</span>
<span class="line-added">116     return virtualRegister() == other.virtualRegister();</span>
<span class="line-added">117 }</span>
<span class="line-added">118 </span>
<span class="line-added">119 inline bool Operand::isValid() const</span>
<span class="line-added">120 {</span>
<span class="line-added">121     if (isTmp())</span>
<span class="line-added">122         return value() &gt;= 0;</span>
<span class="line-added">123     return virtualRegister().isValid();</span>
<span class="line-added">124 }</span>
<span class="line-added">125 </span>
<span class="line-added">126 inline Operand Operand::fromBits(uint64_t value)</span>
<span class="line-added">127 {</span>
<span class="line-added">128     Operand result = bitwise_cast&lt;Operand&gt;(value);</span>
<span class="line-added">129     ASSERT(result.isValid());</span>
<span class="line-added">130     return result;</span>
<span class="line-added">131 }</span>
<span class="line-added">132 </span>
<span class="line-added">133 static_assert(sizeof(Operand) == sizeof(uint64_t), &quot;Operand::asBits() relies on this.&quot;);</span>
134 
135 enum OperandsLikeTag { OperandsLike };
136 
137 template&lt;typename T&gt;
138 class Operands {
139 public:
<span class="line-modified">140     using Storage = std::conditional_t&lt;std::is_same_v&lt;T, bool&gt;, FastBitVector, Vector&lt;T, 0, UnsafeVectorOverflow&gt;&gt;;</span>
<span class="line-modified">141     using RefType = std::conditional_t&lt;std::is_same_v&lt;T, bool&gt;, FastBitReference, T&amp;&gt;;</span>
<span class="line-added">142     using ConstRefType = std::conditional_t&lt;std::is_same_v&lt;T, bool&gt;, bool, const T&amp;&gt;;</span>
<span class="line-added">143 </span>
<span class="line-added">144     Operands() = default;</span>
145 
<span class="line-modified">146     explicit Operands(size_t numArguments, size_t numLocals, size_t numTmps)</span>
147         : m_numArguments(numArguments)
<span class="line-added">148         , m_numLocals(numLocals)</span>
149     {
<span class="line-modified">150         size_t size = numArguments + numLocals + numTmps;</span>
<span class="line-modified">151         m_values.grow(size);</span>
<span class="line-modified">152         if (!WTF::VectorTraits&lt;T&gt;::needsInitialization)</span>
<span class="line-modified">153             m_values.fill(T());</span>

154     }
155 
<span class="line-modified">156     explicit Operands(size_t numArguments, size_t numLocals, size_t numTmps, const T&amp; initialValue)</span>
157         : m_numArguments(numArguments)
<span class="line-added">158         , m_numLocals(numLocals)</span>
159     {
<span class="line-modified">160         m_values.grow(numArguments + numLocals + numTmps);</span>
<span class="line-added">161         m_values.fill(initialValue);</span>
162     }
163 
164     template&lt;typename U&gt;
<span class="line-modified">165     explicit Operands(OperandsLikeTag, const Operands&lt;U&gt;&amp; other, const T&amp; initialValue = T())</span>
166         : m_numArguments(other.numberOfArguments())
<span class="line-added">167         , m_numLocals(other.numberOfLocals())</span>
168     {
<span class="line-modified">169         m_values.grow(other.size());</span>
<span class="line-added">170         m_values.fill(initialValue);</span>
171     }
172 
173     size_t numberOfArguments() const { return m_numArguments; }
<span class="line-modified">174     size_t numberOfLocals() const { return m_numLocals; }</span>
<span class="line-added">175     size_t numberOfTmps() const { return m_values.size() - numberOfArguments() - numberOfLocals(); }</span>
176 
<span class="line-added">177     size_t tmpIndex(size_t idx) const</span>
<span class="line-added">178     {</span>
<span class="line-added">179         ASSERT(idx &lt; numberOfTmps());</span>
<span class="line-added">180         return idx + numberOfArguments() + numberOfLocals();</span>
<span class="line-added">181     }</span>
182     size_t argumentIndex(size_t idx) const
183     {
<span class="line-modified">184         ASSERT(idx &lt; numberOfArguments());</span>
185         return idx;
186     }
187 
188     size_t localIndex(size_t idx) const
189     {
<span class="line-modified">190         ASSERT(idx &lt; numberOfLocals());</span>
<span class="line-added">191         return numberOfArguments() + idx;</span>
192     }
193 
<span class="line-modified">194     RefType tmp(size_t idx) { return m_values[tmpIndex(idx)]; }</span>
<span class="line-modified">195     ConstRefType tmp(size_t idx) const { return m_values[tmpIndex(idx)]; }</span>
<span class="line-modified">196 </span>
<span class="line-modified">197     RefType argument(size_t idx) { return m_values[argumentIndex(idx)]; }</span>
<span class="line-modified">198     ConstRefType argument(size_t idx) const { return m_values[argumentIndex(idx)]; }</span>



199 
<span class="line-modified">200     RefType local(size_t idx) { return m_values[localIndex(idx)]; }</span>
<span class="line-modified">201     ConstRefType local(size_t idx) const { return m_values[localIndex(idx)]; }</span>
202 
203     template&lt;OperandKind operandKind&gt;
204     size_t sizeFor() const
205     {
<span class="line-modified">206         switch (operandKind) {</span>
<span class="line-added">207         case OperandKind::Tmp:</span>
<span class="line-added">208             return numberOfTmps();</span>
<span class="line-added">209         case OperandKind::Argument:</span>
210             return numberOfArguments();
<span class="line-modified">211         case OperandKind::Local:</span>
<span class="line-added">212             return numberOfLocals();</span>
<span class="line-added">213         }</span>
<span class="line-added">214         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">215         return 0;</span>
216     }
217     template&lt;OperandKind operandKind&gt;
<span class="line-modified">218     RefType atFor(size_t idx)</span>
219     {
<span class="line-modified">220         switch (operandKind) {</span>
<span class="line-added">221         case OperandKind::Tmp:</span>
<span class="line-added">222             return tmp(idx);</span>
<span class="line-added">223         case OperandKind::Argument:</span>
224             return argument(idx);
<span class="line-modified">225         case OperandKind::Local:</span>
<span class="line-added">226             return local(idx);</span>
<span class="line-added">227         }</span>
<span class="line-added">228         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">229         return tmp(0);</span>
230     }
231     template&lt;OperandKind operandKind&gt;
<span class="line-modified">232     ConstRefType atFor(size_t idx) const</span>
233     {
<span class="line-modified">234         switch (operandKind) {</span>
<span class="line-added">235         case OperandKind::Tmp:</span>
<span class="line-added">236             return tmp(idx);</span>
<span class="line-added">237         case OperandKind::Argument:</span>
238             return argument(idx);
<span class="line-modified">239         case OperandKind::Local:</span>
<span class="line-added">240             return local(idx);</span>
<span class="line-added">241         }</span>
<span class="line-added">242         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">243         return tmp(0);</span>
244     }
245 
<span class="line-modified">246     void ensureLocals(size_t size, const T&amp; ensuredValue = T())</span>
247     {
<span class="line-modified">248         if (size &lt;= numberOfLocals())</span>


249             return;
250 
<span class="line-added">251         size_t newSize = numberOfArguments() + numberOfTmps() + size;</span>
<span class="line-added">252         size_t oldNumLocals = numberOfLocals();</span>
<span class="line-added">253         size_t oldNumTmps = numberOfTmps();</span>
254         m_values.grow(newSize);
<span class="line-modified">255         for (size_t i = 0; i &lt; oldNumTmps; ++i)</span>
<span class="line-modified">256             m_values[newSize - 1 - i] = m_values[tmpIndex(oldNumTmps - 1 - i)];</span>
<span class="line-modified">257 </span>
<span class="line-added">258         m_numLocals = size;</span>
<span class="line-added">259         if (ensuredValue != T() || !WTF::VectorTraits&lt;T&gt;::needsInitialization) {</span>
<span class="line-added">260             for (size_t i = 0; i &lt; size - oldNumLocals; ++i)</span>
<span class="line-added">261                 m_values[localIndex(oldNumLocals + i)] = ensuredValue;</span>
262         }
263     }
264 
<span class="line-modified">265     void ensureTmps(size_t size, const T&amp; ensuredValue = T())</span>
266     {
<span class="line-modified">267         if (size &lt;= numberOfTmps())</span>


268             return;
269 
<span class="line-added">270         size_t oldSize = m_values.size();</span>
<span class="line-added">271         size_t newSize = numberOfArguments() + numberOfLocals() + size;</span>
272         m_values.grow(newSize);
<span class="line-modified">273 </span>
<span class="line-modified">274         if (ensuredValue != T() || !WTF::VectorTraits&lt;T&gt;::needsInitialization) {</span>
<span class="line-added">275             for (size_t i = oldSize; i &lt; newSize; ++i)</span>
<span class="line-added">276                 m_values[i] = ensuredValue;</span>
<span class="line-added">277         }</span>
278     }
279 
280     void setLocal(size_t idx, const T&amp; value)
281     {
282         ensureLocals(idx + 1);
283         local(idx) = value;
284     }
285 
286     T getLocal(size_t idx)
287     {
288         return idx &gt;= numberOfLocals() ? T() : local(idx);
289     }
290 
291     void setArgumentFirstTime(size_t idx, const T&amp; value)
292     {
293         ASSERT(m_values[idx] == T());
294         argument(idx) = value;
295     }
296 
297     void setLocalFirstTime(size_t idx, const T&amp; value)
298     {
299         ASSERT(idx &gt;= numberOfLocals() || local(idx) == T());
300         setLocal(idx, value);
301     }
302 
<span class="line-modified">303     RefType getForOperandIndex(size_t index) { return m_values[index]; }</span>
<span class="line-added">304     ConstRefType getForOperandIndex(size_t index) const { return const_cast&lt;Operands*&gt;(this)-&gt;getForOperandIndex(index); }</span>
<span class="line-added">305 </span>
<span class="line-added">306     size_t operandIndex(VirtualRegister operand) const</span>
307     {
<span class="line-modified">308         if (operand.isArgument())</span>
<span class="line-modified">309             return argumentIndex(operand.toArgument());</span>
<span class="line-modified">310         return localIndex(operand.toLocal());</span>
311     }
312 
<span class="line-modified">313     size_t operandIndex(Operand op) const</span>
314     {
<span class="line-modified">315         if (!op.isTmp())</span>
<span class="line-added">316             return operandIndex(op.virtualRegister());</span>
<span class="line-added">317         return tmpIndex(op.value());</span>
318     }
319 
<span class="line-modified">320     RefType operand(VirtualRegister operand)</span>
321     {
<span class="line-modified">322         if (operand.isArgument())</span>
<span class="line-modified">323             return argument(operand.toArgument());</span>
<span class="line-modified">324         return local(operand.toLocal());</span>
325     }
326 
<span class="line-modified">327     RefType operand(Operand op)</span>
328     {
<span class="line-modified">329         if (!op.isTmp())</span>
<span class="line-added">330             return operand(op.virtualRegister());</span>
<span class="line-added">331         return tmp(op.value());</span>
332     }
333 
<span class="line-modified">334     ConstRefType operand(VirtualRegister operand) const { return const_cast&lt;Operands*&gt;(this)-&gt;operand(operand); }</span>
<span class="line-modified">335     ConstRefType operand(Operand operand) const { return const_cast&lt;Operands*&gt;(this)-&gt;operand(operand); }</span>
336 
<span class="line-modified">337     bool hasOperand(VirtualRegister operand) const</span>
338     {
<span class="line-modified">339         if (operand.isArgument())</span>
340             return true;
<span class="line-modified">341         return static_cast&lt;size_t&gt;(operand.toLocal()) &lt; numberOfLocals();</span>
342     }
<span class="line-modified">343     bool hasOperand(Operand op) const</span>
344     {
<span class="line-modified">345         if (op.isTmp()) {</span>
<span class="line-added">346             ASSERT(op.value() &gt;= 0);</span>
<span class="line-added">347             return static_cast&lt;size_t&gt;(op.value()) &lt; numberOfTmps();</span>
<span class="line-added">348         }</span>
<span class="line-added">349         return hasOperand(op.virtualRegister());</span>
350     }
351 
<span class="line-modified">352     void setOperand(Operand operand, const T&amp; value)</span>
353     {
354         this-&gt;operand(operand) = value;
355     }
356 





357     size_t size() const { return m_values.size(); }
<span class="line-modified">358     ConstRefType at(size_t index) const { return m_values[index]; }</span>
<span class="line-modified">359     RefType at(size_t index) { return m_values[index]; }</span>
<span class="line-modified">360     ConstRefType operator[](size_t index) const { return at(index); }</span>
<span class="line-modified">361     RefType operator[](size_t index) { return at(index); }</span>













362 
<span class="line-modified">363     Operand operandForIndex(size_t index) const</span>
364     {
<span class="line-modified">365         if (index &lt; numberOfArguments())</span>
<span class="line-modified">366             return virtualRegisterForArgumentIncludingThis(index);</span>
<span class="line-modified">367         else if (index &lt; numberOfLocals() + numberOfArguments())</span>
<span class="line-modified">368             return virtualRegisterForLocal(index - numberOfArguments());</span>
<span class="line-modified">369         return Operand::tmp(index - (numberOfLocals() + numberOfArguments()));</span>

370     }
371 
372     void fill(T value)
373     {
374         for (size_t i = 0; i &lt; m_values.size(); ++i)
375             m_values[i] = value;
376     }
377 
378     void clear()
379     {
380         fill(T());
381     }
382 
383     bool operator==(const Operands&amp; other) const
384     {
385         ASSERT(numberOfArguments() == other.numberOfArguments());
386         ASSERT(numberOfLocals() == other.numberOfLocals());
<span class="line-added">387         ASSERT(numberOfTmps() == other.numberOfTmps());</span>
388 
389         return m_values == other.m_values;
390     }
391 
392     void dumpInContext(PrintStream&amp; out, DumpContext* context) const;
393     void dump(PrintStream&amp; out) const;
394 
395 private:
<span class="line-modified">396     // The first m_numArguments of m_values are arguments, the next m_numLocals are locals, and the rest are tmps.</span>
<span class="line-modified">397     Storage m_values;</span>
<span class="line-modified">398     unsigned m_numArguments { 0 };</span>
<span class="line-added">399     unsigned m_numLocals { 0 };</span>
400 };
401 
402 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="Opcode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OperandsInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
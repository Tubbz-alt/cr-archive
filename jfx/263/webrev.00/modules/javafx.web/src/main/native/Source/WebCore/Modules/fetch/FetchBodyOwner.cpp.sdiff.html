<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchBodyOwner.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FetchBodyConsumer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FetchBodyOwner.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchBodyOwner.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Canon Inc. nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY CANON INC. AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL CANON INC. AND ITS CONTRIBUTORS BE LIABLE FOR
 21  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 22  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 23  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 24  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 25  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;FetchBodyOwner.h&quot;
 31 

 32 #include &quot;FetchLoader.h&quot;
 33 #include &quot;HTTPParsers.h&quot;
 34 #include &quot;JSBlob.h&quot;
 35 #include &quot;ResourceError.h&quot;
 36 #include &quot;ResourceResponse.h&quot;

 37 
 38 namespace WebCore {
 39 
 40 FetchBodyOwner::FetchBodyOwner(ScriptExecutionContext&amp; context, Optional&lt;FetchBody&gt;&amp;&amp; body, Ref&lt;FetchHeaders&gt;&amp;&amp; headers)
 41     : ActiveDOMObject(&amp;context)
 42     , m_body(WTFMove(body))
 43     , m_headers(WTFMove(headers))
 44 {
 45     suspendIfNeeded();
 46 }
 47 
 48 FetchBodyOwner::~FetchBodyOwner()
 49 {
 50     if (m_readableStreamSource)
 51         m_readableStreamSource-&gt;detach();
 52 }
 53 
 54 void FetchBodyOwner::stop()
 55 {
 56     if (m_body)
</pre>
<hr />
<pre>
107     if (isBodyNullOrOpaque()) {
108         fulfillPromiseWithArrayBuffer(WTFMove(promise), nullptr, 0);
109         return;
110     }
111     if (isDisturbedOrLocked()) {
112         promise-&gt;reject(Exception { TypeError, &quot;Body is disturbed or locked&quot;_s });
113         return;
114     }
115     m_isDisturbed = true;
116     m_body-&gt;arrayBuffer(*this, WTFMove(promise));
117 }
118 
119 void FetchBodyOwner::blob(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
120 {
121     if (auto exception = loadingException()) {
122         promise-&gt;reject(*exception);
123         return;
124     }
125 
126     if (isBodyNullOrOpaque()) {
<span class="line-modified">127         promise-&gt;resolveCallbackValueWithNewlyCreated&lt;IDLInterface&lt;Blob&gt;&gt;([this](auto&amp; context) {</span>
<span class="line-modified">128             return Blob::create(context.sessionID(), Vector&lt;uint8_t&gt; { }, Blob::normalizedContentType(extractMIMETypeFromMediaType(m_contentType)));</span>
129         });
130         return;
131     }
132     if (isDisturbedOrLocked()) {
133         promise-&gt;reject(Exception { TypeError, &quot;Body is disturbed or locked&quot;_s });
134         return;
135     }
136     m_isDisturbed = true;
137     m_body-&gt;blob(*this, WTFMove(promise), m_contentType);
138 }
139 
140 void FetchBodyOwner::cloneBody(FetchBodyOwner&amp; owner)
141 {
142     m_loadingError = owner.m_loadingError;
143 
144     m_contentType = owner.m_contentType;
145     if (owner.isBodyNull())
146         return;
147     m_body = owner.m_body-&gt;clone();
148 }
</pre>
<hr />
<pre>
272     if (m_readableStreamSource) {
273         m_readableStreamSource-&gt;close();
274         m_readableStreamSource = nullptr;
275     }
276 #endif
277     m_body-&gt;loadingSucceeded();
278     finishBlobLoading();
279 }
280 
281 void FetchBodyOwner::blobLoadingFailed()
282 {
283     ASSERT(!isBodyNull());
284 #if ENABLE(STREAMS_API)
285     if (m_readableStreamSource) {
286         if (!m_readableStreamSource-&gt;isCancelling())
287             m_readableStreamSource-&gt;error(Exception { TypeError, &quot;Blob loading failed&quot;_s});
288         m_readableStreamSource = nullptr;
289     } else
290 #endif
291         m_body-&gt;loadingFailed(Exception { TypeError, &quot;Blob loading failed&quot;_s});
<span class="line-removed">292 </span>
293     finishBlobLoading();
294 }
295 
296 void FetchBodyOwner::blobChunk(const char* data, size_t size)
297 {
298     ASSERT(data);
299 #if ENABLE(STREAMS_API)
300     ASSERT(m_readableStreamSource);
301     if (!m_readableStreamSource-&gt;enqueue(ArrayBuffer::tryCreate(data, size)))
302         stop();
303 #else
304     UNUSED_PARAM(data);
305     UNUSED_PARAM(size);
306 #endif
307 }
308 
309 FetchBodyOwner::BlobLoader::BlobLoader(FetchBodyOwner&amp; owner)
310     : owner(owner)
311 {
312 }
313 
314 void FetchBodyOwner::BlobLoader::didReceiveResponse(const ResourceResponse&amp; response)
315 {
316     if (response.httpStatusCode() != 200)
317         didFail({ });
318 }
319 
320 void FetchBodyOwner::BlobLoader::didFail(const ResourceError&amp;)
321 {
322     // didFail might be called within FetchLoader::start call.
323     if (loader-&gt;isStarted())
324         owner.blobLoadingFailed();
325 }
326 
<span class="line-modified">327 RefPtr&lt;ReadableStream&gt; FetchBodyOwner::readableStream(JSC::ExecState&amp; state)</span>
328 {
329     if (isBodyNullOrOpaque())
330         return nullptr;
331 
332     if (!m_body-&gt;hasReadableStream())
333         createReadableStream(state);
334 
335     return m_body-&gt;readableStream();
336 }
337 
<span class="line-modified">338 void FetchBodyOwner::createReadableStream(JSC::ExecState&amp; state)</span>
339 {
340     ASSERT(!m_readableStreamSource);
341     if (isDisturbed()) {
342         m_body-&gt;setReadableStream(ReadableStream::create(state, nullptr));
343         m_body-&gt;readableStream()-&gt;lock();
344     } else {
345         m_readableStreamSource = adoptRef(*new FetchBodySource(*this));
346         m_body-&gt;setReadableStream(ReadableStream::create(state, m_readableStreamSource));
347     }
348 }
349 
350 void FetchBodyOwner::consumeBodyAsStream()
351 {
352     ASSERT(m_readableStreamSource);
353 
354     if (auto exception = loadingException()) {
355         m_readableStreamSource-&gt;error(*exception);
356         return;
357     }
358 
</pre>
</td>
<td>
<hr />
<pre>
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Canon Inc. nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY CANON INC. AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL CANON INC. AND ITS CONTRIBUTORS BE LIABLE FOR
 21  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 22  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 23  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 24  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 25  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;FetchBodyOwner.h&quot;
 31 
<span class="line-added"> 32 #include &quot;Document.h&quot;</span>
 33 #include &quot;FetchLoader.h&quot;
 34 #include &quot;HTTPParsers.h&quot;
 35 #include &quot;JSBlob.h&quot;
 36 #include &quot;ResourceError.h&quot;
 37 #include &quot;ResourceResponse.h&quot;
<span class="line-added"> 38 #include &quot;WindowEventLoop.h&quot;</span>
 39 
 40 namespace WebCore {
 41 
 42 FetchBodyOwner::FetchBodyOwner(ScriptExecutionContext&amp; context, Optional&lt;FetchBody&gt;&amp;&amp; body, Ref&lt;FetchHeaders&gt;&amp;&amp; headers)
 43     : ActiveDOMObject(&amp;context)
 44     , m_body(WTFMove(body))
 45     , m_headers(WTFMove(headers))
 46 {
 47     suspendIfNeeded();
 48 }
 49 
 50 FetchBodyOwner::~FetchBodyOwner()
 51 {
 52     if (m_readableStreamSource)
 53         m_readableStreamSource-&gt;detach();
 54 }
 55 
 56 void FetchBodyOwner::stop()
 57 {
 58     if (m_body)
</pre>
<hr />
<pre>
109     if (isBodyNullOrOpaque()) {
110         fulfillPromiseWithArrayBuffer(WTFMove(promise), nullptr, 0);
111         return;
112     }
113     if (isDisturbedOrLocked()) {
114         promise-&gt;reject(Exception { TypeError, &quot;Body is disturbed or locked&quot;_s });
115         return;
116     }
117     m_isDisturbed = true;
118     m_body-&gt;arrayBuffer(*this, WTFMove(promise));
119 }
120 
121 void FetchBodyOwner::blob(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
122 {
123     if (auto exception = loadingException()) {
124         promise-&gt;reject(*exception);
125         return;
126     }
127 
128     if (isBodyNullOrOpaque()) {
<span class="line-modified">129         promise-&gt;resolveCallbackValueWithNewlyCreated&lt;IDLInterface&lt;Blob&gt;&gt;([this](auto&amp;) {</span>
<span class="line-modified">130             return Blob::create(Vector&lt;uint8_t&gt; { }, Blob::normalizedContentType(extractMIMETypeFromMediaType(m_contentType)));</span>
131         });
132         return;
133     }
134     if (isDisturbedOrLocked()) {
135         promise-&gt;reject(Exception { TypeError, &quot;Body is disturbed or locked&quot;_s });
136         return;
137     }
138     m_isDisturbed = true;
139     m_body-&gt;blob(*this, WTFMove(promise), m_contentType);
140 }
141 
142 void FetchBodyOwner::cloneBody(FetchBodyOwner&amp; owner)
143 {
144     m_loadingError = owner.m_loadingError;
145 
146     m_contentType = owner.m_contentType;
147     if (owner.isBodyNull())
148         return;
149     m_body = owner.m_body-&gt;clone();
150 }
</pre>
<hr />
<pre>
274     if (m_readableStreamSource) {
275         m_readableStreamSource-&gt;close();
276         m_readableStreamSource = nullptr;
277     }
278 #endif
279     m_body-&gt;loadingSucceeded();
280     finishBlobLoading();
281 }
282 
283 void FetchBodyOwner::blobLoadingFailed()
284 {
285     ASSERT(!isBodyNull());
286 #if ENABLE(STREAMS_API)
287     if (m_readableStreamSource) {
288         if (!m_readableStreamSource-&gt;isCancelling())
289             m_readableStreamSource-&gt;error(Exception { TypeError, &quot;Blob loading failed&quot;_s});
290         m_readableStreamSource = nullptr;
291     } else
292 #endif
293         m_body-&gt;loadingFailed(Exception { TypeError, &quot;Blob loading failed&quot;_s});

294     finishBlobLoading();
295 }
296 
297 void FetchBodyOwner::blobChunk(const char* data, size_t size)
298 {
299     ASSERT(data);
300 #if ENABLE(STREAMS_API)
301     ASSERT(m_readableStreamSource);
302     if (!m_readableStreamSource-&gt;enqueue(ArrayBuffer::tryCreate(data, size)))
303         stop();
304 #else
305     UNUSED_PARAM(data);
306     UNUSED_PARAM(size);
307 #endif
308 }
309 
310 FetchBodyOwner::BlobLoader::BlobLoader(FetchBodyOwner&amp; owner)
311     : owner(owner)
312 {
313 }
314 
315 void FetchBodyOwner::BlobLoader::didReceiveResponse(const ResourceResponse&amp; response)
316 {
317     if (response.httpStatusCode() != 200)
318         didFail({ });
319 }
320 
321 void FetchBodyOwner::BlobLoader::didFail(const ResourceError&amp;)
322 {
323     // didFail might be called within FetchLoader::start call.
324     if (loader-&gt;isStarted())
325         owner.blobLoadingFailed();
326 }
327 
<span class="line-modified">328 RefPtr&lt;ReadableStream&gt; FetchBodyOwner::readableStream(JSC::JSGlobalObject&amp; state)</span>
329 {
330     if (isBodyNullOrOpaque())
331         return nullptr;
332 
333     if (!m_body-&gt;hasReadableStream())
334         createReadableStream(state);
335 
336     return m_body-&gt;readableStream();
337 }
338 
<span class="line-modified">339 void FetchBodyOwner::createReadableStream(JSC::JSGlobalObject&amp; state)</span>
340 {
341     ASSERT(!m_readableStreamSource);
342     if (isDisturbed()) {
343         m_body-&gt;setReadableStream(ReadableStream::create(state, nullptr));
344         m_body-&gt;readableStream()-&gt;lock();
345     } else {
346         m_readableStreamSource = adoptRef(*new FetchBodySource(*this));
347         m_body-&gt;setReadableStream(ReadableStream::create(state, m_readableStreamSource));
348     }
349 }
350 
351 void FetchBodyOwner::consumeBodyAsStream()
352 {
353     ASSERT(m_readableStreamSource);
354 
355     if (auto exception = loadingException()) {
356         m_readableStreamSource-&gt;error(*exception);
357         return;
358     }
359 
</pre>
</td>
</tr>
</table>
<center><a href="FetchBodyConsumer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FetchBodyOwner.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
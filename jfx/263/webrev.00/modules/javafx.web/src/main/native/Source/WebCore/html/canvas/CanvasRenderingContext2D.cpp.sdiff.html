<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CanvasRenderingContext.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CanvasRenderingContext2DBase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 27  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 28  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31  */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;CanvasRenderingContext2D.h&quot;
 35 
 36 #include &quot;CSSFontSelector.h&quot;
 37 #include &quot;CSSParser.h&quot;
 38 #include &quot;CSSPropertyNames.h&quot;
 39 #include &quot;ImageBuffer.h&quot;
 40 #include &quot;ImageData.h&quot;
 41 #include &quot;InspectorInstrumentation.h&quot;
 42 #include &quot;Path2D.h&quot;
 43 #include &quot;RenderTheme.h&quot;
 44 #include &quot;ResourceLoadObserver.h&quot;
 45 #include &quot;RuntimeEnabledFeatures.h&quot;

 46 #include &quot;StyleProperties.h&quot;
<span class="line-removed"> 47 #include &quot;StyleResolver.h&quot;</span>
 48 #include &quot;TextMetrics.h&quot;
 49 #include &quot;TextRun.h&quot;
 50 #include &lt;wtf/CheckedArithmetic.h&gt;
 51 #include &lt;wtf/IsoMallocInlines.h&gt;
 52 #include &lt;wtf/MathExtras.h&gt;
 53 #include &lt;wtf/text/StringBuilder.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 using namespace HTMLNames;
 58 
 59 WTF_MAKE_ISO_ALLOCATED_IMPL(CanvasRenderingContext2D);
 60 
 61 std::unique_ptr&lt;CanvasRenderingContext2D&gt; CanvasRenderingContext2D::create(CanvasBase&amp; canvas, bool usesCSSCompatibilityParseMode)
 62 {
 63     auto renderingContext = std::unique_ptr&lt;CanvasRenderingContext2D&gt;(new CanvasRenderingContext2D(canvas, usesCSSCompatibilityParseMode));
 64 
 65     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
 66 
 67     return renderingContext;
</pre>
<hr />
<pre>
110 
111     for (unsigned i = 0; i &lt; fontDescription.familyCount(); ++i) {
112         if (i)
113             serializedFont.append(&#39;,&#39;);
114 
115         // FIXME: We should append family directly to serializedFont rather than building a temporary string.
116         String family = fontDescription.familyAt(i);
117         if (family.startsWith(&quot;-webkit-&quot;))
118             family = family.substring(8);
119         if (family.contains(&#39; &#39;))
120             family = makeString(&#39;&quot;&#39;, family, &#39;&quot;&#39;);
121 
122         serializedFont.append(&#39; &#39;, family);
123     }
124 
125     return serializedFont.toString();
126 }
127 
128 void CanvasRenderingContext2D::setFont(const String&amp; newFont)
129 {



130     if (newFont == state().unparsedFont &amp;&amp; state().font.realized())
131         return;
132 
133     auto parsedStyle = MutableStyleProperties::create();
134     CSSParser::parseValue(parsedStyle, CSSPropertyFont, newFont, true, strictToCSSParserMode(!m_usesCSSCompatibilityParseMode));
135     if (parsedStyle-&gt;isEmpty())
136         return;
137 
138     String fontValue = parsedStyle-&gt;getPropertyValue(CSSPropertyFont);
139 
140     // According to http://lists.w3.org/Archives/Public/public-html/2009Jul/0947.html,
141     // the &quot;inherit&quot; and &quot;initial&quot; values must be ignored.
142     if (fontValue == &quot;inherit&quot; || fontValue == &quot;initial&quot;)
143         return;
144 
145     // The parse succeeded.
146     String newFontSafeCopy(newFont); // Create a string copy since newFont can be deleted inside realizeSaves.
147     realizeSaves();
148     modifiableState().unparsedFont = newFontSafeCopy;
149 
</pre>
<hr />
<pre>
151     // relative to the canvas.
152     auto newStyle = RenderStyle::createPtr();
153 
154     Document&amp; document = canvas().document();
155     document.updateStyleIfNeeded();
156 
157     if (auto* computedStyle = canvas().computedStyle())
158         newStyle-&gt;setFontDescription(FontCascadeDescription { computedStyle-&gt;fontDescription() });
159     else {
160         FontCascadeDescription defaultFontDescription;
161         defaultFontDescription.setOneFamily(DefaultFontFamily);
162         defaultFontDescription.setSpecifiedSize(DefaultFontSize);
163         defaultFontDescription.setComputedSize(DefaultFontSize);
164 
165         newStyle-&gt;setFontDescription(WTFMove(defaultFontDescription));
166     }
167 
168     newStyle-&gt;fontCascade().update(&amp;document.fontSelector());
169 
170     // Now map the font property longhands into the style.
<span class="line-modified">171     StyleResolver&amp; styleResolver = canvas().styleResolver();</span>
<span class="line-modified">172     styleResolver.applyPropertyToStyle(CSSPropertyFontFamily, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontFamily).get(), WTFMove(newStyle));</span>
<span class="line-modified">173     styleResolver.applyPropertyToCurrentStyle(CSSPropertyFontStyle, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontStyle).get());</span>
<span class="line-modified">174     styleResolver.applyPropertyToCurrentStyle(CSSPropertyFontVariantCaps, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontVariantCaps).get());</span>
<span class="line-modified">175     styleResolver.applyPropertyToCurrentStyle(CSSPropertyFontWeight, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontWeight).get());</span>
<span class="line-modified">176 </span>
<span class="line-modified">177     // As described in BUG66291, setting font-size and line-height on a font may entail a CSSPrimitiveValue::computeLengthDouble call,</span>
<span class="line-modified">178     // which assumes the fontMetrics are available for the affected font, otherwise a crash occurs (see http://trac.webkit.org/changeset/96122).</span>
<span class="line-modified">179     // The updateFont() calls below update the fontMetrics and ensure the proper setting of font-size and line-height.</span>
<span class="line-modified">180     styleResolver.updateFont();</span>
<span class="line-modified">181     styleResolver.applyPropertyToCurrentStyle(CSSPropertyFontSize, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontSize).get());</span>
<span class="line-modified">182     styleResolver.updateFont();</span>
<span class="line-modified">183     styleResolver.applyPropertyToCurrentStyle(CSSPropertyLineHeight, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyLineHeight).get());</span>
<span class="line-removed">184 </span>
<span class="line-removed">185     modifiableState().font.initialize(document.fontSelector(), *styleResolver.style());</span>
186 }
187 
188 static CanvasTextAlign toCanvasTextAlign(TextAlign textAlign)
189 {
190     switch (textAlign) {
191     case StartTextAlign:
192         return CanvasTextAlign::Start;
193     case EndTextAlign:
194         return CanvasTextAlign::End;
195     case LeftTextAlign:
196         return CanvasTextAlign::Left;
197     case RightTextAlign:
198         return CanvasTextAlign::Right;
199     case CenterTextAlign:
200         return CanvasTextAlign::Center;
201     }
202 
203     ASSERT_NOT_REACHED();
204     return CanvasTextAlign::Start;
205 }
</pre>
<hr />
<pre>
527             Color shadowColor;
528             c-&gt;getShadow(shadowOffset, shadowRadius, shadowColor);
529 
530             FloatRect shadowRect(maskRect);
531             shadowRect.inflate(shadowRadius * 1.4);
532             shadowRect.move(shadowOffset * -1);
533             c-&gt;clip(shadowRect);
534 
535             shadowOffset += offset;
536 
537             c-&gt;setLegacyShadow(shadowOffset, shadowRadius, shadowColor);
538 
539             if (fill)
540                 c-&gt;setFillColor(Color::black);
541             else
542                 c-&gt;setStrokeColor(Color::black);
543 
544             fontProxy.drawBidiText(*c, textRun, location + offset, FontCascade::UseFallbackIfFontNotReady);
545         }
546 
<span class="line-modified">547         auto maskImage = ImageBuffer::createCompatibleBuffer(maskRect.size(), ColorSpaceSRGB, *c);</span>
548         if (!maskImage)
549             return;
550 
551         auto&amp; maskImageContext = maskImage-&gt;context();
552 
553         if (fill)
554             maskImageContext.setFillColor(Color::black);
555         else {
556             maskImageContext.setStrokeColor(Color::black);
557             maskImageContext.setStrokeThickness(c-&gt;strokeThickness());
558         }
559 
560         maskImageContext.setTextDrawingMode(fill ? TextModeFill : TextModeStroke);
561 
562         if (useMaxWidth) {
563             maskImageContext.translate(location - maskRect.location());
564             // We draw when fontWidth is 0 so compositing operations (eg, a &quot;copy&quot; op) still work.
565             maskImageContext.scale(FloatSize((fontWidth &gt; 0 ? (width / fontWidth) : 0), 1));
566             fontProxy.drawBidiText(maskImageContext, textRun, FloatPoint(0, 0), FontCascade::UseFallbackIfFontNotReady);
567         } else {
</pre>
<hr />
<pre>
575         c-&gt;fillRect(maskRect);
576         return;
577     }
578 #endif
579 
580     c-&gt;setTextDrawingMode(fill ? TextModeFill : TextModeStroke);
581 
582     GraphicsContextStateSaver stateSaver(*c);
583     if (useMaxWidth) {
584         c-&gt;translate(location);
585         // We draw when fontWidth is 0 so compositing operations (eg, a &quot;copy&quot; op) still work.
586         c-&gt;scale(FloatSize((fontWidth &gt; 0 ? (width / fontWidth) : 0), 1));
587         location = FloatPoint();
588     }
589 
590     if (isFullCanvasCompositeMode(state().globalComposite)) {
591         beginCompositeLayer();
592         fontProxy.drawBidiText(*c, textRun, location, FontCascade::UseFallbackIfFontNotReady);
593         endCompositeLayer();
594         didDrawEntireCanvas();
<span class="line-modified">595     } else if (state().globalComposite == CompositeCopy) {</span>
596         clearCanvas();
597         fontProxy.drawBidiText(*c, textRun, location, FontCascade::UseFallbackIfFontNotReady);
598         didDrawEntireCanvas();
599     } else {
600         fontProxy.drawBidiText(*c, textRun, location, FontCascade::UseFallbackIfFontNotReady);
601         didDraw(textRect);
602     }
603 }
604 
605 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 26  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 27  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 28  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31  */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;CanvasRenderingContext2D.h&quot;
 35 
 36 #include &quot;CSSFontSelector.h&quot;
 37 #include &quot;CSSParser.h&quot;
 38 #include &quot;CSSPropertyNames.h&quot;
 39 #include &quot;ImageBuffer.h&quot;
 40 #include &quot;ImageData.h&quot;
 41 #include &quot;InspectorInstrumentation.h&quot;
 42 #include &quot;Path2D.h&quot;
 43 #include &quot;RenderTheme.h&quot;
 44 #include &quot;ResourceLoadObserver.h&quot;
 45 #include &quot;RuntimeEnabledFeatures.h&quot;
<span class="line-added"> 46 #include &quot;StyleBuilder.h&quot;</span>
 47 #include &quot;StyleProperties.h&quot;

 48 #include &quot;TextMetrics.h&quot;
 49 #include &quot;TextRun.h&quot;
 50 #include &lt;wtf/CheckedArithmetic.h&gt;
 51 #include &lt;wtf/IsoMallocInlines.h&gt;
 52 #include &lt;wtf/MathExtras.h&gt;
 53 #include &lt;wtf/text/StringBuilder.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 using namespace HTMLNames;
 58 
 59 WTF_MAKE_ISO_ALLOCATED_IMPL(CanvasRenderingContext2D);
 60 
 61 std::unique_ptr&lt;CanvasRenderingContext2D&gt; CanvasRenderingContext2D::create(CanvasBase&amp; canvas, bool usesCSSCompatibilityParseMode)
 62 {
 63     auto renderingContext = std::unique_ptr&lt;CanvasRenderingContext2D&gt;(new CanvasRenderingContext2D(canvas, usesCSSCompatibilityParseMode));
 64 
 65     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
 66 
 67     return renderingContext;
</pre>
<hr />
<pre>
110 
111     for (unsigned i = 0; i &lt; fontDescription.familyCount(); ++i) {
112         if (i)
113             serializedFont.append(&#39;,&#39;);
114 
115         // FIXME: We should append family directly to serializedFont rather than building a temporary string.
116         String family = fontDescription.familyAt(i);
117         if (family.startsWith(&quot;-webkit-&quot;))
118             family = family.substring(8);
119         if (family.contains(&#39; &#39;))
120             family = makeString(&#39;&quot;&#39;, family, &#39;&quot;&#39;);
121 
122         serializedFont.append(&#39; &#39;, family);
123     }
124 
125     return serializedFont.toString();
126 }
127 
128 void CanvasRenderingContext2D::setFont(const String&amp; newFont)
129 {
<span class="line-added">130     if (newFont.isEmpty())</span>
<span class="line-added">131         return;</span>
<span class="line-added">132 </span>
133     if (newFont == state().unparsedFont &amp;&amp; state().font.realized())
134         return;
135 
136     auto parsedStyle = MutableStyleProperties::create();
137     CSSParser::parseValue(parsedStyle, CSSPropertyFont, newFont, true, strictToCSSParserMode(!m_usesCSSCompatibilityParseMode));
138     if (parsedStyle-&gt;isEmpty())
139         return;
140 
141     String fontValue = parsedStyle-&gt;getPropertyValue(CSSPropertyFont);
142 
143     // According to http://lists.w3.org/Archives/Public/public-html/2009Jul/0947.html,
144     // the &quot;inherit&quot; and &quot;initial&quot; values must be ignored.
145     if (fontValue == &quot;inherit&quot; || fontValue == &quot;initial&quot;)
146         return;
147 
148     // The parse succeeded.
149     String newFontSafeCopy(newFont); // Create a string copy since newFont can be deleted inside realizeSaves.
150     realizeSaves();
151     modifiableState().unparsedFont = newFontSafeCopy;
152 
</pre>
<hr />
<pre>
154     // relative to the canvas.
155     auto newStyle = RenderStyle::createPtr();
156 
157     Document&amp; document = canvas().document();
158     document.updateStyleIfNeeded();
159 
160     if (auto* computedStyle = canvas().computedStyle())
161         newStyle-&gt;setFontDescription(FontCascadeDescription { computedStyle-&gt;fontDescription() });
162     else {
163         FontCascadeDescription defaultFontDescription;
164         defaultFontDescription.setOneFamily(DefaultFontFamily);
165         defaultFontDescription.setSpecifiedSize(DefaultFontSize);
166         defaultFontDescription.setComputedSize(DefaultFontSize);
167 
168         newStyle-&gt;setFontDescription(WTFMove(defaultFontDescription));
169     }
170 
171     newStyle-&gt;fontCascade().update(&amp;document.fontSelector());
172 
173     // Now map the font property longhands into the style.
<span class="line-modified">174 </span>
<span class="line-modified">175     Style::MatchResult matchResult;</span>
<span class="line-modified">176     auto parentStyle = RenderStyle::clone(*newStyle);</span>
<span class="line-modified">177     Style::Builder styleBuilder(*newStyle, { document, parentStyle }, matchResult, { });</span>
<span class="line-modified">178 </span>
<span class="line-modified">179     styleBuilder.applyPropertyValue(CSSPropertyFontFamily, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontFamily).get());</span>
<span class="line-modified">180     styleBuilder.applyPropertyValue(CSSPropertyFontStyle, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontStyle).get());</span>
<span class="line-modified">181     styleBuilder.applyPropertyValue(CSSPropertyFontVariantCaps, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontVariantCaps).get());</span>
<span class="line-modified">182     styleBuilder.applyPropertyValue(CSSPropertyFontWeight, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontWeight).get());</span>
<span class="line-modified">183     styleBuilder.applyPropertyValue(CSSPropertyFontSize, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyFontSize).get());</span>
<span class="line-modified">184     styleBuilder.applyPropertyValue(CSSPropertyLineHeight, parsedStyle-&gt;getPropertyCSSValue(CSSPropertyLineHeight).get());</span>
<span class="line-modified">185 </span>
<span class="line-modified">186     modifiableState().font.initialize(document.fontSelector(), *newStyle);</span>


187 }
188 
189 static CanvasTextAlign toCanvasTextAlign(TextAlign textAlign)
190 {
191     switch (textAlign) {
192     case StartTextAlign:
193         return CanvasTextAlign::Start;
194     case EndTextAlign:
195         return CanvasTextAlign::End;
196     case LeftTextAlign:
197         return CanvasTextAlign::Left;
198     case RightTextAlign:
199         return CanvasTextAlign::Right;
200     case CenterTextAlign:
201         return CanvasTextAlign::Center;
202     }
203 
204     ASSERT_NOT_REACHED();
205     return CanvasTextAlign::Start;
206 }
</pre>
<hr />
<pre>
528             Color shadowColor;
529             c-&gt;getShadow(shadowOffset, shadowRadius, shadowColor);
530 
531             FloatRect shadowRect(maskRect);
532             shadowRect.inflate(shadowRadius * 1.4);
533             shadowRect.move(shadowOffset * -1);
534             c-&gt;clip(shadowRect);
535 
536             shadowOffset += offset;
537 
538             c-&gt;setLegacyShadow(shadowOffset, shadowRadius, shadowColor);
539 
540             if (fill)
541                 c-&gt;setFillColor(Color::black);
542             else
543                 c-&gt;setStrokeColor(Color::black);
544 
545             fontProxy.drawBidiText(*c, textRun, location + offset, FontCascade::UseFallbackIfFontNotReady);
546         }
547 
<span class="line-modified">548         auto maskImage = ImageBuffer::createCompatibleBuffer(maskRect.size(), ColorSpace::SRGB, *c);</span>
549         if (!maskImage)
550             return;
551 
552         auto&amp; maskImageContext = maskImage-&gt;context();
553 
554         if (fill)
555             maskImageContext.setFillColor(Color::black);
556         else {
557             maskImageContext.setStrokeColor(Color::black);
558             maskImageContext.setStrokeThickness(c-&gt;strokeThickness());
559         }
560 
561         maskImageContext.setTextDrawingMode(fill ? TextModeFill : TextModeStroke);
562 
563         if (useMaxWidth) {
564             maskImageContext.translate(location - maskRect.location());
565             // We draw when fontWidth is 0 so compositing operations (eg, a &quot;copy&quot; op) still work.
566             maskImageContext.scale(FloatSize((fontWidth &gt; 0 ? (width / fontWidth) : 0), 1));
567             fontProxy.drawBidiText(maskImageContext, textRun, FloatPoint(0, 0), FontCascade::UseFallbackIfFontNotReady);
568         } else {
</pre>
<hr />
<pre>
576         c-&gt;fillRect(maskRect);
577         return;
578     }
579 #endif
580 
581     c-&gt;setTextDrawingMode(fill ? TextModeFill : TextModeStroke);
582 
583     GraphicsContextStateSaver stateSaver(*c);
584     if (useMaxWidth) {
585         c-&gt;translate(location);
586         // We draw when fontWidth is 0 so compositing operations (eg, a &quot;copy&quot; op) still work.
587         c-&gt;scale(FloatSize((fontWidth &gt; 0 ? (width / fontWidth) : 0), 1));
588         location = FloatPoint();
589     }
590 
591     if (isFullCanvasCompositeMode(state().globalComposite)) {
592         beginCompositeLayer();
593         fontProxy.drawBidiText(*c, textRun, location, FontCascade::UseFallbackIfFontNotReady);
594         endCompositeLayer();
595         didDrawEntireCanvas();
<span class="line-modified">596     } else if (state().globalComposite == CompositeOperator::Copy) {</span>
597         clearCanvas();
598         fontProxy.drawBidiText(*c, textRun, location, FontCascade::UseFallbackIfFontNotReady);
599         didDrawEntireCanvas();
600     } else {
601         fontProxy.drawBidiText(*c, textRun, location, FontCascade::UseFallbackIfFontNotReady);
602         didDraw(textRect);
603     }
604 }
605 
606 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="CanvasRenderingContext.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CanvasRenderingContext2DBase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
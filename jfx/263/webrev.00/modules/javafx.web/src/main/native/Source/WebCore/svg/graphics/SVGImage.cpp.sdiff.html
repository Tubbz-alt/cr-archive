<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/graphics/SVGImage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../animation/SVGSMILElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGImage.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/graphics/SVGImage.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
201     adjustedSrcSize.scale(roundedContainerSize.width() / containerSize.width(), roundedContainerSize.height() / containerSize.height());
202     scaledSrc.setSize(adjustedSrcSize);
203 
204     frameView()-&gt;scrollToFragment(initialFragmentURL);
205 
206     ImageDrawResult result = draw(context, dstRect, scaledSrc, options);
207 
208     setImageObserver(observer);
209     return result;
210 }
211 
212 #if USE(CAIRO)
213 // Passes ownership of the native image to the caller so NativeImagePtr needs
214 // to be a smart pointer type.
215 NativeImagePtr SVGImage::nativeImageForCurrentFrame(const GraphicsContext*)
216 {
217     if (!m_page)
218         return nullptr;
219 
220     // Cairo does not use the accelerated drawing flag, so it&#39;s OK to make an unconditionally unaccelerated buffer.
<span class="line-modified">221     std::unique_ptr&lt;ImageBuffer&gt; buffer = ImageBuffer::create(size(), Unaccelerated);</span>
222     if (!buffer) // failed to allocate image
223         return nullptr;
224 
225     draw(buffer-&gt;context(), rect(), rect());
226 
227     // FIXME: WK(Bug 113657): We should use DontCopyBackingStore here.
228     return buffer-&gt;copyImage(CopyBackingStore)-&gt;nativeImageForCurrentFrame();
229 }
230 #endif
231 
232 #if USE(DIRECT2D)
233 NativeImagePtr SVGImage::nativeImage(const GraphicsContext* targetContext)
234 {
235     ASSERT(targetContext);
236     if (!m_page || !targetContext)
237         return nullptr;
238 
239     ASSERT(targetContext-&gt;hasPlatformContext());
240     auto* renderTarget = targetContext-&gt;platformContext()-&gt;renderTarget();
241 
242     IntSize bitmapSize(size().width(), size().height());
243     auto nativeImageTarget = Direct2D::createBitmapRenderTargetOfSize(bitmapSize, renderTarget, 1.0);
244     if (!nativeImageTarget)
245         return nullptr;
246 
247     PlatformContextDirect2D platformContext(nativeImageTarget.get());
248     GraphicsContext localContext(&amp;platformContext, GraphicsContext::BitmapRenderingContextType::GPUMemory);
249 
<span class="line-modified">250     draw(localContext, rect(), rect(), CompositeSourceOver, BlendMode::Normal, DecodingMode::Synchronous, ImageOrientation::None);</span>
251 
252     COMPtr&lt;ID2D1Bitmap&gt; nativeImage;
253     HRESULT hr = nativeImageTarget-&gt;GetBitmap(&amp;nativeImage);
254     if (!SUCCEEDED(hr))
255         return nullptr;
256 
<span class="line-modified">257 #if !ASSERT_DISABLED</span>
258     auto nativeImageSize = nativeImage-&gt;GetPixelSize();
259     ASSERT(nativeImageSize.height = rect().size().height());
260     ASSERT(nativeImageSize.width = rect().size().width());
261 #endif
262 
263     return nativeImage;
264 }
265 #endif
266 
267 void SVGImage::drawPatternForContainer(GraphicsContext&amp; context, const FloatSize&amp; containerSize, float containerZoom, const URL&amp; initialFragmentURL, const FloatRect&amp; srcRect,
268     const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const FloatRect&amp; dstRect, const ImagePaintingOptions&amp; options)
269 {
270     FloatRect zoomedContainerRect = FloatRect(FloatPoint(), containerSize);
271     zoomedContainerRect.scale(containerZoom);
272 
273     // The ImageBuffer size needs to be scaled to match the final resolution.
274     AffineTransform transform = context.getCTM();
275     FloatSize imageBufferScale = FloatSize(transform.xScale(), transform.yScale());
276     ASSERT(imageBufferScale.width());
277     ASSERT(imageBufferScale.height());
278 
279     FloatRect imageBufferSize = zoomedContainerRect;
280     imageBufferSize.scale(imageBufferScale.width(), imageBufferScale.height());
281 
<span class="line-modified">282     std::unique_ptr&lt;ImageBuffer&gt; buffer = ImageBuffer::createCompatibleBuffer(expandedIntSize(imageBufferSize.size()), 1, ColorSpaceSRGB, context);</span>
283     if (!buffer) // Failed to allocate buffer.
284         return;
285     drawForContainer(buffer-&gt;context(), containerSize, containerZoom, initialFragmentURL, imageBufferSize, zoomedContainerRect);
286     if (context.drawLuminanceMask())
287         buffer-&gt;convertToLuminanceMask();
288 
289     RefPtr&lt;Image&gt; image = ImageBuffer::sinkIntoImage(WTFMove(buffer), PreserveResolution::Yes);
290     if (!image)
291         return;
292 
293     // Adjust the source rect and transform due to the image buffer&#39;s scaling.
294     FloatRect scaledSrcRect = srcRect;
295     scaledSrcRect.scale(imageBufferScale.width(), imageBufferScale.height());
296     AffineTransform unscaledPatternTransform(patternTransform);
297     unscaledPatternTransform.scale(1 / imageBufferScale.width(), 1 / imageBufferScale.height());
298 
299     context.setDrawLuminanceMask(false);
300     image-&gt;drawPattern(context, dstRect, scaledSrcRect, unscaledPatternTransform, phase, spacing, options);
301 }
302 
303 ImageDrawResult SVGImage::draw(GraphicsContext&amp; context, const FloatRect&amp; dstRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
304 {
305     if (!m_page)
306         return ImageDrawResult::DidNothing;
307 
308     auto view = makeRefPtr(frameView());
309     ASSERT(view);
310 
311     GraphicsContextStateSaver stateSaver(context);
312     context.setCompositeOperation(options.compositeOperator(), options.blendMode());
313     context.clip(enclosingIntRect(dstRect));
314 
315     float alpha = context.alpha();
<span class="line-modified">316     bool compositingRequiresTransparencyLayer = options.compositeOperator() != CompositeSourceOver || options.blendMode() != BlendMode::Normal || alpha &lt; 1;</span>
317     if (compositingRequiresTransparencyLayer) {
318         context.beginTransparencyLayer(alpha);
<span class="line-modified">319         context.setCompositeOperation(CompositeSourceOver, BlendMode::Normal);</span>
320     }
321 
322     FloatSize scale(dstRect.size() / srcRect.size());
323 
324     // We can only draw the entire frame, clipped to the rect we want. So compute where the top left
325     // of the image would be if we were drawing without clipping, and translate accordingly.
326     FloatSize topLeftOffset(srcRect.location().x() * scale.width(), srcRect.location().y() * scale.height());
327     FloatPoint destOffset = dstRect.location() - topLeftOffset;
328 
329     context.translate(destOffset);
330     context.scale(scale);
331 
332     view-&gt;resize(containerSize());
333 
334     {
335         ScriptDisallowedScope::DisableAssertionsInScope disabledScope;
336         if (view-&gt;needsLayout())
337             view-&gt;layoutContext().layout();
338     }
339 
</pre>
<hr />
<pre>
450     auto document = makeRefPtr(m_page-&gt;mainFrame().document());
451     size_t decodedImageMemoryCost = 0;
452 
453     for (RefPtr&lt;Node&gt; node = document; node; node = NodeTraversal::next(*node))
454         decodedImageMemoryCost += node-&gt;approximateMemoryCost();
455 
456     JSC::VM&amp; vm = commonVM();
457     JSC::JSLockHolder lock(vm);
458     // FIXME: Adopt reportExtraMemoryVisited, and switch to reportExtraMemoryAllocated.
459     // https://bugs.webkit.org/show_bug.cgi?id=142595
460     vm.heap.deprecatedReportExtraMemory(decodedImageMemoryCost + data()-&gt;size());
461 }
462 
463 EncodedDataStatus SVGImage::dataChanged(bool allDataReceived)
464 {
465     // Don&#39;t do anything; it is an empty image.
466     if (!data()-&gt;size())
467         return EncodedDataStatus::Complete;
468 
469     if (allDataReceived) {
<span class="line-modified">470         auto pageConfiguration = pageConfigurationWithEmptyClients();</span>
471         m_chromeClient = makeUnique&lt;SVGImageChromeClient&gt;(this);
472         pageConfiguration.chromeClient = m_chromeClient.get();
473 
474         // FIXME: If this SVG ends up loading itself, we might leak the world.
475         // The Cache code does not know about CachedImages holding Frames and
476         // won&#39;t know to break the cycle.
477         // This will become an issue when SVGImage will be able to load other
478         // SVGImage objects, but we&#39;re safe now, because SVGImage can only be
479         // loaded by a top-level document.
480         m_page = makeUnique&lt;Page&gt;(WTFMove(pageConfiguration));
481         m_page-&gt;settings().setMediaEnabled(false);
482         m_page-&gt;settings().setScriptEnabled(false);
483         m_page-&gt;settings().setPluginsEnabled(false);
484         m_page-&gt;settings().setAcceleratedCompositingEnabled(false);
485         m_page-&gt;settings().setShouldAllowUserInstalledFonts(false);
<span class="line-removed">486         m_page-&gt;settings().setShouldAllowDesignSystemUIFonts(false);</span>
487 
488         Frame&amp; frame = m_page-&gt;mainFrame();
489         frame.setView(FrameView::create(frame));
490         frame.init();
491         FrameLoader&amp; loader = frame.loader();
492         loader.forceSandboxFlags(SandboxAll);
493 
494         frame.view()-&gt;setCanHaveScrollbars(false); // SVG Images will always synthesize a viewBox, if it&#39;s not available, and thus never see scrollbars.
495         frame.view()-&gt;setTransparent(true); // SVG Images are transparent.
496 
497         ASSERT(loader.activeDocumentLoader()); // DocumentLoader should have been created by frame-&gt;init().
498         loader.activeDocumentLoader()-&gt;writer().setMIMEType(&quot;image/svg+xml&quot;);
499         loader.activeDocumentLoader()-&gt;writer().begin(URL()); // create the empty document
500         loader.activeDocumentLoader()-&gt;writer().addData(data()-&gt;data(), data()-&gt;size());
501         loader.activeDocumentLoader()-&gt;writer().end();
502 
503         frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
504 
505         // Set the intrinsic size before a container size is available.
506         m_intrinsicSize = containerSize();
</pre>
</td>
<td>
<hr />
<pre>
201     adjustedSrcSize.scale(roundedContainerSize.width() / containerSize.width(), roundedContainerSize.height() / containerSize.height());
202     scaledSrc.setSize(adjustedSrcSize);
203 
204     frameView()-&gt;scrollToFragment(initialFragmentURL);
205 
206     ImageDrawResult result = draw(context, dstRect, scaledSrc, options);
207 
208     setImageObserver(observer);
209     return result;
210 }
211 
212 #if USE(CAIRO)
213 // Passes ownership of the native image to the caller so NativeImagePtr needs
214 // to be a smart pointer type.
215 NativeImagePtr SVGImage::nativeImageForCurrentFrame(const GraphicsContext*)
216 {
217     if (!m_page)
218         return nullptr;
219 
220     // Cairo does not use the accelerated drawing flag, so it&#39;s OK to make an unconditionally unaccelerated buffer.
<span class="line-modified">221     std::unique_ptr&lt;ImageBuffer&gt; buffer = ImageBuffer::create(size(), RenderingMode::Unaccelerated);</span>
222     if (!buffer) // failed to allocate image
223         return nullptr;
224 
225     draw(buffer-&gt;context(), rect(), rect());
226 
227     // FIXME: WK(Bug 113657): We should use DontCopyBackingStore here.
228     return buffer-&gt;copyImage(CopyBackingStore)-&gt;nativeImageForCurrentFrame();
229 }
230 #endif
231 
232 #if USE(DIRECT2D)
233 NativeImagePtr SVGImage::nativeImage(const GraphicsContext* targetContext)
234 {
235     ASSERT(targetContext);
236     if (!m_page || !targetContext)
237         return nullptr;
238 
239     ASSERT(targetContext-&gt;hasPlatformContext());
240     auto* renderTarget = targetContext-&gt;platformContext()-&gt;renderTarget();
241 
242     IntSize bitmapSize(size().width(), size().height());
243     auto nativeImageTarget = Direct2D::createBitmapRenderTargetOfSize(bitmapSize, renderTarget, 1.0);
244     if (!nativeImageTarget)
245         return nullptr;
246 
247     PlatformContextDirect2D platformContext(nativeImageTarget.get());
248     GraphicsContext localContext(&amp;platformContext, GraphicsContext::BitmapRenderingContextType::GPUMemory);
249 
<span class="line-modified">250     draw(localContext, rect(), rect(), { CompositeOperator::SourceOver, BlendMode::Normal, DecodingMode::Synchronous, ImageOrientation::None });</span>
251 
252     COMPtr&lt;ID2D1Bitmap&gt; nativeImage;
253     HRESULT hr = nativeImageTarget-&gt;GetBitmap(&amp;nativeImage);
254     if (!SUCCEEDED(hr))
255         return nullptr;
256 
<span class="line-modified">257 #if ASSERT_ENABLED</span>
258     auto nativeImageSize = nativeImage-&gt;GetPixelSize();
259     ASSERT(nativeImageSize.height = rect().size().height());
260     ASSERT(nativeImageSize.width = rect().size().width());
261 #endif
262 
263     return nativeImage;
264 }
265 #endif
266 
267 void SVGImage::drawPatternForContainer(GraphicsContext&amp; context, const FloatSize&amp; containerSize, float containerZoom, const URL&amp; initialFragmentURL, const FloatRect&amp; srcRect,
268     const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const FloatRect&amp; dstRect, const ImagePaintingOptions&amp; options)
269 {
270     FloatRect zoomedContainerRect = FloatRect(FloatPoint(), containerSize);
271     zoomedContainerRect.scale(containerZoom);
272 
273     // The ImageBuffer size needs to be scaled to match the final resolution.
274     AffineTransform transform = context.getCTM();
275     FloatSize imageBufferScale = FloatSize(transform.xScale(), transform.yScale());
276     ASSERT(imageBufferScale.width());
277     ASSERT(imageBufferScale.height());
278 
279     FloatRect imageBufferSize = zoomedContainerRect;
280     imageBufferSize.scale(imageBufferScale.width(), imageBufferScale.height());
281 
<span class="line-modified">282     std::unique_ptr&lt;ImageBuffer&gt; buffer = ImageBuffer::createCompatibleBuffer(expandedIntSize(imageBufferSize.size()), 1, ColorSpace::SRGB, context);</span>
283     if (!buffer) // Failed to allocate buffer.
284         return;
285     drawForContainer(buffer-&gt;context(), containerSize, containerZoom, initialFragmentURL, imageBufferSize, zoomedContainerRect);
286     if (context.drawLuminanceMask())
287         buffer-&gt;convertToLuminanceMask();
288 
289     RefPtr&lt;Image&gt; image = ImageBuffer::sinkIntoImage(WTFMove(buffer), PreserveResolution::Yes);
290     if (!image)
291         return;
292 
293     // Adjust the source rect and transform due to the image buffer&#39;s scaling.
294     FloatRect scaledSrcRect = srcRect;
295     scaledSrcRect.scale(imageBufferScale.width(), imageBufferScale.height());
296     AffineTransform unscaledPatternTransform(patternTransform);
297     unscaledPatternTransform.scale(1 / imageBufferScale.width(), 1 / imageBufferScale.height());
298 
299     context.setDrawLuminanceMask(false);
300     image-&gt;drawPattern(context, dstRect, scaledSrcRect, unscaledPatternTransform, phase, spacing, options);
301 }
302 
303 ImageDrawResult SVGImage::draw(GraphicsContext&amp; context, const FloatRect&amp; dstRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
304 {
305     if (!m_page)
306         return ImageDrawResult::DidNothing;
307 
308     auto view = makeRefPtr(frameView());
309     ASSERT(view);
310 
311     GraphicsContextStateSaver stateSaver(context);
312     context.setCompositeOperation(options.compositeOperator(), options.blendMode());
313     context.clip(enclosingIntRect(dstRect));
314 
315     float alpha = context.alpha();
<span class="line-modified">316     bool compositingRequiresTransparencyLayer = options.compositeOperator() != CompositeOperator::SourceOver || options.blendMode() != BlendMode::Normal || alpha &lt; 1;</span>
317     if (compositingRequiresTransparencyLayer) {
318         context.beginTransparencyLayer(alpha);
<span class="line-modified">319         context.setCompositeOperation(CompositeOperator::SourceOver, BlendMode::Normal);</span>
320     }
321 
322     FloatSize scale(dstRect.size() / srcRect.size());
323 
324     // We can only draw the entire frame, clipped to the rect we want. So compute where the top left
325     // of the image would be if we were drawing without clipping, and translate accordingly.
326     FloatSize topLeftOffset(srcRect.location().x() * scale.width(), srcRect.location().y() * scale.height());
327     FloatPoint destOffset = dstRect.location() - topLeftOffset;
328 
329     context.translate(destOffset);
330     context.scale(scale);
331 
332     view-&gt;resize(containerSize());
333 
334     {
335         ScriptDisallowedScope::DisableAssertionsInScope disabledScope;
336         if (view-&gt;needsLayout())
337             view-&gt;layoutContext().layout();
338     }
339 
</pre>
<hr />
<pre>
450     auto document = makeRefPtr(m_page-&gt;mainFrame().document());
451     size_t decodedImageMemoryCost = 0;
452 
453     for (RefPtr&lt;Node&gt; node = document; node; node = NodeTraversal::next(*node))
454         decodedImageMemoryCost += node-&gt;approximateMemoryCost();
455 
456     JSC::VM&amp; vm = commonVM();
457     JSC::JSLockHolder lock(vm);
458     // FIXME: Adopt reportExtraMemoryVisited, and switch to reportExtraMemoryAllocated.
459     // https://bugs.webkit.org/show_bug.cgi?id=142595
460     vm.heap.deprecatedReportExtraMemory(decodedImageMemoryCost + data()-&gt;size());
461 }
462 
463 EncodedDataStatus SVGImage::dataChanged(bool allDataReceived)
464 {
465     // Don&#39;t do anything; it is an empty image.
466     if (!data()-&gt;size())
467         return EncodedDataStatus::Complete;
468 
469     if (allDataReceived) {
<span class="line-modified">470         auto pageConfiguration = pageConfigurationWithEmptyClients(PAL::SessionID::defaultSessionID());</span>
471         m_chromeClient = makeUnique&lt;SVGImageChromeClient&gt;(this);
472         pageConfiguration.chromeClient = m_chromeClient.get();
473 
474         // FIXME: If this SVG ends up loading itself, we might leak the world.
475         // The Cache code does not know about CachedImages holding Frames and
476         // won&#39;t know to break the cycle.
477         // This will become an issue when SVGImage will be able to load other
478         // SVGImage objects, but we&#39;re safe now, because SVGImage can only be
479         // loaded by a top-level document.
480         m_page = makeUnique&lt;Page&gt;(WTFMove(pageConfiguration));
481         m_page-&gt;settings().setMediaEnabled(false);
482         m_page-&gt;settings().setScriptEnabled(false);
483         m_page-&gt;settings().setPluginsEnabled(false);
484         m_page-&gt;settings().setAcceleratedCompositingEnabled(false);
485         m_page-&gt;settings().setShouldAllowUserInstalledFonts(false);

486 
487         Frame&amp; frame = m_page-&gt;mainFrame();
488         frame.setView(FrameView::create(frame));
489         frame.init();
490         FrameLoader&amp; loader = frame.loader();
491         loader.forceSandboxFlags(SandboxAll);
492 
493         frame.view()-&gt;setCanHaveScrollbars(false); // SVG Images will always synthesize a viewBox, if it&#39;s not available, and thus never see scrollbars.
494         frame.view()-&gt;setTransparent(true); // SVG Images are transparent.
495 
496         ASSERT(loader.activeDocumentLoader()); // DocumentLoader should have been created by frame-&gt;init().
497         loader.activeDocumentLoader()-&gt;writer().setMIMEType(&quot;image/svg+xml&quot;);
498         loader.activeDocumentLoader()-&gt;writer().begin(URL()); // create the empty document
499         loader.activeDocumentLoader()-&gt;writer().addData(data()-&gt;data(), data()-&gt;size());
500         loader.activeDocumentLoader()-&gt;writer().end();
501 
502         frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
503 
504         // Set the intrinsic size before a container size is available.
505         m_intrinsicSize = containerSize();
</pre>
</td>
</tr>
</table>
<center><a href="../animation/SVGSMILElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGImage.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
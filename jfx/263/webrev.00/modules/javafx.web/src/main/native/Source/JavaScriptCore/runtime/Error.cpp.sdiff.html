<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Error.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ECMAScriptSpecInternalFunctions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Error.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Error.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25 #include &quot;Error.h&quot;
 26 
 27 #include &quot;ConstructData.h&quot;
 28 #include &quot;ErrorConstructor.h&quot;
 29 #include &quot;ExceptionHelpers.h&quot;
 30 #include &quot;FunctionPrototype.h&quot;
 31 #include &quot;Interpreter.h&quot;
 32 #include &quot;JSArray.h&quot;
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;JSFunction.h&quot;
 35 #include &quot;JSGlobalObject.h&quot;
 36 #include &quot;JSObject.h&quot;
 37 #include &quot;JSString.h&quot;
 38 #include &quot;NativeErrorConstructor.h&quot;
 39 #include &quot;SourceCode.h&quot;
 40 #include &quot;StackFrame.h&quot;
 41 #include &quot;SuperSampler.h&quot;
 42 
 43 namespace JSC {
 44 
<span class="line-modified"> 45 JSObject* createError(ExecState* exec, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
 46 {
 47     ASSERT(!message.isEmpty());
<span class="line-modified"> 48     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed"> 49     return ErrorInstance::create(exec, globalObject-&gt;vm(), globalObject-&gt;errorStructure(), message, appender, TypeNothing, true);</span>
 50 }
 51 
<span class="line-modified"> 52 JSObject* createEvalError(ExecState* exec, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
 53 {
 54     ASSERT(!message.isEmpty());
<span class="line-modified"> 55     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed"> 56     return ErrorInstance::create(exec, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::EvalError), message, appender, TypeNothing, true);</span>
 57 }
 58 
<span class="line-modified"> 59 JSObject* createRangeError(ExecState* exec, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
<span class="line-removed"> 60 {</span>
<span class="line-removed"> 61     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed"> 62     return createRangeError(exec, globalObject, message, appender);</span>
<span class="line-removed"> 63 }</span>
<span class="line-removed"> 64 </span>
<span class="line-removed"> 65 JSObject* createRangeError(ExecState* exec, JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
 66 {
 67     ASSERT(!message.isEmpty());
<span class="line-modified"> 68     return ErrorInstance::create(exec, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::RangeError), message, appender, TypeNothing, true);</span>
 69 }
 70 
<span class="line-modified"> 71 JSObject* createReferenceError(ExecState* exec, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
 72 {
 73     ASSERT(!message.isEmpty());
<span class="line-modified"> 74     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed"> 75     return ErrorInstance::create(exec, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::ReferenceError), message, appender, TypeNothing, true);</span>
 76 }
 77 
<span class="line-modified"> 78 JSObject* createSyntaxError(ExecState* exec, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
 79 {
 80     ASSERT(!message.isEmpty());
<span class="line-modified"> 81     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed"> 82     return ErrorInstance::create(exec, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::SyntaxError), message, appender, TypeNothing, true);</span>
 83 }
 84 
<span class="line-modified"> 85 JSObject* createTypeError(ExecState* exec, const String&amp; message, ErrorInstance::SourceAppender appender, RuntimeType type)</span>
 86 {
 87     ASSERT(!message.isEmpty());
<span class="line-modified"> 88     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed"> 89     return ErrorInstance::create(exec, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::TypeError), message, appender, type, true);</span>
 90 }
 91 
<span class="line-modified"> 92 JSObject* createNotEnoughArgumentsError(ExecState* exec, ErrorInstance::SourceAppender appender)</span>
 93 {
<span class="line-modified"> 94     return createTypeError(exec, &quot;Not enough arguments&quot;_s, appender, TypeNothing);</span>
 95 }
 96 
<span class="line-modified"> 97 JSObject* createURIError(ExecState* exec, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
 98 {
 99     ASSERT(!message.isEmpty());
<span class="line-modified">100     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">101     return ErrorInstance::create(exec, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::URIError), message, appender, TypeNothing, true);</span>
102 }
103 
<span class="line-modified">104 JSObject* createError(ExecState* exec, ErrorType errorType, const String&amp; message)</span>
105 {
106     switch (errorType) {
107     case ErrorType::Error:
<span class="line-modified">108         return createError(exec, message);</span>
109     case ErrorType::EvalError:
<span class="line-modified">110         return createEvalError(exec, message);</span>
111     case ErrorType::RangeError:
<span class="line-modified">112         return createRangeError(exec, message);</span>
113     case ErrorType::ReferenceError:
<span class="line-modified">114         return createReferenceError(exec, message);</span>
115     case ErrorType::SyntaxError:
<span class="line-modified">116         return createSyntaxError(exec, message);</span>
117     case ErrorType::TypeError:
<span class="line-modified">118         return createTypeError(exec, message);</span>
119     case ErrorType::URIError:
<span class="line-modified">120         return createURIError(exec, message);</span>
121     }
122     ASSERT_NOT_REACHED();
123     return nullptr;
124 }
125 
<span class="line-modified">126 JSObject* createGetterTypeError(ExecState* exec, const String&amp; message)</span>
127 {
128     ASSERT(!message.isEmpty());
<span class="line-modified">129     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">130     auto* error = ErrorInstance::create(exec, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::TypeError), message);</span>
131     error-&gt;setNativeGetterTypeError();
132     return error;
133 }
134 
135 class FindFirstCallerFrameWithCodeblockFunctor {
136 public:
137     FindFirstCallerFrameWithCodeblockFunctor(CallFrame* startCallFrame)
138         : m_startCallFrame(startCallFrame)
139         , m_foundCallFrame(nullptr)
140         , m_foundStartCallFrame(false)
141         , m_index(0)
142     { }
143 
144     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
145     {
146         if (!m_foundStartCallFrame &amp;&amp; (visitor-&gt;callFrame() == m_startCallFrame))
147             m_foundStartCallFrame = true;
148 
149         if (m_foundStartCallFrame) {
<span class="line-modified">150             if (visitor-&gt;callFrame()-&gt;codeBlock()) {</span>
151                 m_foundCallFrame = visitor-&gt;callFrame();
152                 return StackVisitor::Done;
153             }
154             m_index++;
155         }
156 
157         return StackVisitor::Continue;
158     }
159 
160     CallFrame* foundCallFrame() const { return m_foundCallFrame; }
161     unsigned index() const { return m_index; }
162 
163 private:
164     CallFrame* m_startCallFrame;
165     mutable CallFrame* m_foundCallFrame;
166     mutable bool m_foundStartCallFrame;
167     mutable unsigned m_index;
168 };
169 
<span class="line-modified">170 std::unique_ptr&lt;Vector&lt;StackFrame&gt;&gt; getStackTrace(ExecState* exec, VM&amp; vm, JSObject* obj, bool useCurrentFrame)</span>
171 {
172     JSGlobalObject* globalObject = obj-&gt;globalObject(vm);
173     if (!globalObject-&gt;stackTraceLimit())
174         return nullptr;
175 
176     size_t framesToSkip = useCurrentFrame ? 0 : 1;
177     std::unique_ptr&lt;Vector&lt;StackFrame&gt;&gt; stackTrace = makeUnique&lt;Vector&lt;StackFrame&gt;&gt;();
178     vm.interpreter-&gt;getStackTrace(obj, *stackTrace, framesToSkip, globalObject-&gt;stackTraceLimit().value());
<span class="line-removed">179     if (!stackTrace-&gt;isEmpty())</span>
<span class="line-removed">180         ASSERT_UNUSED(exec, exec == vm.topCallFrame || exec-&gt;isGlobalExec());</span>
181     return stackTrace;
182 }
183 
<span class="line-modified">184 void getBytecodeOffset(ExecState* exec, VM&amp; vm, Vector&lt;StackFrame&gt;* stackTrace, CallFrame*&amp; callFrame, unsigned&amp; bytecodeOffset)</span>
185 {
<span class="line-modified">186     FindFirstCallerFrameWithCodeblockFunctor functor(exec);</span>
<span class="line-modified">187     StackVisitor::visit(vm.topCallFrame, &amp;vm, functor);</span>
188     callFrame = functor.foundCallFrame();
189     unsigned stackIndex = functor.index();
<span class="line-modified">190     bytecodeOffset = 0;</span>
<span class="line-modified">191     if (stackTrace &amp;&amp; stackIndex &lt; stackTrace-&gt;size() &amp;&amp; stackTrace-&gt;at(stackIndex).hasBytecodeOffset())</span>
<span class="line-modified">192         bytecodeOffset = stackTrace-&gt;at(stackIndex).bytecodeOffset();</span>
193 }
194 
195 bool getLineColumnAndSource(Vector&lt;StackFrame&gt;* stackTrace, unsigned&amp; line, unsigned&amp; column, String&amp; sourceURL)
196 {
197     line = 0;
198     column = 0;
199     sourceURL = String();
200 
201     if (!stackTrace)
202         return false;
203 
204     for (unsigned i = 0 ; i &lt; stackTrace-&gt;size(); ++i) {
205         StackFrame&amp; frame = stackTrace-&gt;at(i);
206         if (frame.hasLineAndColumnInfo()) {
207             frame.computeLineAndColumn(line, column);
208             sourceURL = frame.sourceURL();
209             return true;
210         }
211     }
212 
</pre>
<hr />
<pre>
220 
221     if (!stackTrace-&gt;isEmpty()) {
222         unsigned line;
223         unsigned column;
224         String sourceURL;
225         getLineColumnAndSource(stackTrace, line, column, sourceURL);
226         obj-&gt;putDirect(vm, vm.propertyNames-&gt;line, jsNumber(line));
227         obj-&gt;putDirect(vm, vm.propertyNames-&gt;column, jsNumber(column));
228         if (!sourceURL.isEmpty())
229             obj-&gt;putDirect(vm, vm.propertyNames-&gt;sourceURL, jsString(vm, sourceURL));
230 
231         obj-&gt;putDirect(vm, vm.propertyNames-&gt;stack, jsString(vm, Interpreter::stackTraceAsString(vm, *stackTrace)), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
232 
233         return true;
234     }
235 
236     obj-&gt;putDirect(vm, vm.propertyNames-&gt;stack, vm.smallStrings.emptyString(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
237     return false;
238 }
239 
<span class="line-modified">240 void addErrorInfo(ExecState* exec, JSObject* obj, bool useCurrentFrame)</span>
241 {
<span class="line-modified">242     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">243     std::unique_ptr&lt;Vector&lt;StackFrame&gt;&gt; stackTrace = getStackTrace(exec, vm, obj, useCurrentFrame);</span>
244     addErrorInfo(vm, stackTrace.get(), obj);
245 }
246 
<span class="line-modified">247 JSObject* addErrorInfo(CallFrame* callFrame, JSObject* error, int line, const SourceCode&amp; source)</span>
248 {
<span class="line-removed">249     VM&amp; vm = callFrame-&gt;vm();</span>
250     const String&amp; sourceURL = source.provider()-&gt;url();
251 
252     // The putDirect() calls below should really be put() so that they trigger materialization of
253     // the line/sourceURL properties. Otherwise, what we set here will just be overwritten later.
254     // But calling put() would be bad because we&#39;d rather not do effectful things here. Luckily, we
255     // know that this will get called on some kind of error - so we can just directly ask the
256     // ErrorInstance to materialize whatever it needs to. There&#39;s a chance that we get passed some
257     // other kind of object, which also has materializable properties. But this code is heuristic-ey
258     // enough that if we&#39;re wrong in such corner cases, it&#39;s not the end of the world.
259     if (ErrorInstance* errorInstance = jsDynamicCast&lt;ErrorInstance*&gt;(vm, error))
260         errorInstance-&gt;materializeErrorInfoIfNeeded(vm);
261 
262     // FIXME: This does not modify the column property, which confusingly continues to reflect
263     // the column at which the exception was thrown.
264     // https://bugs.webkit.org/show_bug.cgi?id=176673
265     if (line != -1)
266         error-&gt;putDirect(vm, vm.propertyNames-&gt;line, jsNumber(line));
267     if (!sourceURL.isNull())
268         error-&gt;putDirect(vm, vm.propertyNames-&gt;sourceURL, jsString(vm, sourceURL));
269     return error;
270 }
271 
<span class="line-modified">272 Exception* throwConstructorCannotBeCalledAsFunctionTypeError(ExecState* exec, ThrowScope&amp; scope, const char* constructorName)</span>
<span class="line-removed">273 {</span>
<span class="line-removed">274     return throwTypeError(exec, scope, makeString(&quot;calling &quot;, constructorName, &quot; constructor without new is invalid&quot;));</span>
<span class="line-removed">275 }</span>
<span class="line-removed">276 </span>
<span class="line-removed">277 Exception* throwTypeError(ExecState* exec, ThrowScope&amp; scope)</span>
278 {
<span class="line-modified">279     return throwException(exec, scope, createTypeError(exec));</span>
280 }
281 
<span class="line-modified">282 Exception* throwTypeError(ExecState* exec, ThrowScope&amp; scope, ASCIILiteral errorMessage)</span>
283 {
<span class="line-modified">284     return throwTypeError(exec, scope, String(errorMessage));</span>
285 }
286 
<span class="line-modified">287 Exception* throwTypeError(ExecState* exec, ThrowScope&amp; scope, const String&amp; message)</span>
288 {
<span class="line-modified">289     return throwException(exec, scope, createTypeError(exec, message));</span>
290 }
291 
<span class="line-modified">292 Exception* throwSyntaxError(ExecState* exec, ThrowScope&amp; scope)</span>
293 {
<span class="line-modified">294     return throwException(exec, scope, createSyntaxError(exec, &quot;Syntax error&quot;_s));</span>
295 }
296 
<span class="line-modified">297 Exception* throwSyntaxError(ExecState* exec, ThrowScope&amp; scope, const String&amp; message)</span>
298 {
<span class="line-modified">299     return throwException(exec, scope, createSyntaxError(exec, message));</span>
300 }
301 
<span class="line-modified">302 Exception* throwGetterTypeError(ExecState* exec, ThrowScope&amp; scope, const String&amp; message)</span>
303 {
<span class="line-modified">304     return throwException(exec, scope, createGetterTypeError(exec, message));</span>
305 }
306 
<span class="line-modified">307 JSValue throwDOMAttributeGetterTypeError(ExecState* exec, ThrowScope&amp; scope, const ClassInfo* classInfo, PropertyName propertyName)</span>
308 {
<span class="line-modified">309     return throwGetterTypeError(exec, scope, makeString(&quot;The &quot;, classInfo-&gt;className, &#39;.&#39;, String(propertyName.uid()), &quot; getter can only be used on instances of &quot;, classInfo-&gt;className));</span>
310 }
311 
<span class="line-modified">312 JSObject* createError(ExecState* exec, const String&amp; message)</span>
313 {
<span class="line-modified">314     return createError(exec, message, nullptr);</span>
315 }
316 
<span class="line-modified">317 JSObject* createEvalError(ExecState* exec, const String&amp; message)</span>
318 {
<span class="line-modified">319     return createEvalError(exec, message, nullptr);</span>
320 }
321 
<span class="line-modified">322 JSObject* createRangeError(ExecState* exec, const String&amp; message)</span>
323 {
<span class="line-modified">324     return createRangeError(exec, message, nullptr);</span>
325 }
326 
<span class="line-modified">327 JSObject* createRangeError(ExecState* exec, JSGlobalObject* globalObject, const String&amp; message)</span>
328 {
<span class="line-modified">329     return createRangeError(exec, globalObject, message, nullptr);</span>
330 }
331 
<span class="line-modified">332 JSObject* createReferenceError(ExecState* exec, const String&amp; message)</span>
333 {
<span class="line-modified">334     return createReferenceError(exec, message, nullptr);</span>
335 }
336 
<span class="line-modified">337 JSObject* createSyntaxError(ExecState* exec, const String&amp; message)</span>
338 {
<span class="line-modified">339     return createSyntaxError(exec, message, nullptr);</span>
340 }
341 
<span class="line-modified">342 JSObject* createTypeError(ExecState* exec)</span>
343 {
<span class="line-modified">344     return createTypeError(exec, &quot;Type error&quot;_s);</span>
345 }
346 
<span class="line-modified">347 JSObject* createTypeError(ExecState* exec, const String&amp; message)</span>
348 {
<span class="line-modified">349     return createTypeError(exec, message, nullptr, TypeNothing);</span>
350 }
351 
<span class="line-modified">352 JSObject* createNotEnoughArgumentsError(ExecState* exec)</span>
353 {
<span class="line-modified">354     return createNotEnoughArgumentsError(exec, nullptr);</span>
355 }
356 
<span class="line-modified">357 JSObject* createURIError(ExecState* exec, const String&amp; message)</span>
358 {
<span class="line-modified">359     return createURIError(exec, message, nullptr);</span>
360 }
361 
<span class="line-modified">362 JSObject* createOutOfMemoryError(ExecState* exec)</span>
363 {
<span class="line-modified">364     auto* error = createError(exec, &quot;Out of memory&quot;_s, nullptr);</span>
365     jsCast&lt;ErrorInstance*&gt;(error)-&gt;setOutOfMemoryError();
366     return error;
367 }
368 
<span class="line-modified">369 JSObject* createOutOfMemoryError(ExecState* exec, const String&amp; message)</span>
370 {
371 
<span class="line-modified">372     auto* error = createError(exec, makeString(&quot;Out of memory: &quot;, message), nullptr);</span>
373     jsCast&lt;ErrorInstance*&gt;(error)-&gt;setOutOfMemoryError();
374     return error;
375 }
376 
377 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 25 #include &quot;Error.h&quot;
 26 
 27 #include &quot;ConstructData.h&quot;
 28 #include &quot;ErrorConstructor.h&quot;
 29 #include &quot;ExceptionHelpers.h&quot;
 30 #include &quot;FunctionPrototype.h&quot;
 31 #include &quot;Interpreter.h&quot;
 32 #include &quot;JSArray.h&quot;
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;JSFunction.h&quot;
 35 #include &quot;JSGlobalObject.h&quot;
 36 #include &quot;JSObject.h&quot;
 37 #include &quot;JSString.h&quot;
 38 #include &quot;NativeErrorConstructor.h&quot;
 39 #include &quot;SourceCode.h&quot;
 40 #include &quot;StackFrame.h&quot;
 41 #include &quot;SuperSampler.h&quot;
 42 
 43 namespace JSC {
 44 
<span class="line-modified"> 45 JSObject* createError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
 46 {
 47     ASSERT(!message.isEmpty());
<span class="line-modified"> 48     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(), message, appender, TypeNothing, true);</span>

 49 }
 50 
<span class="line-modified"> 51 JSObject* createEvalError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
 52 {
 53     ASSERT(!message.isEmpty());
<span class="line-modified"> 54     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::EvalError), message, appender, TypeNothing, true);</span>

 55 }
 56 
<span class="line-modified"> 57 JSObject* createRangeError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender)</span>






 58 {
 59     ASSERT(!message.isEmpty());
<span class="line-modified"> 60     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::RangeError), message, appender, TypeNothing, true);</span>
 61 }
 62 
<span class="line-modified"> 63 JSObject* createReferenceError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
 64 {
 65     ASSERT(!message.isEmpty());
<span class="line-modified"> 66     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::ReferenceError), message, appender, TypeNothing, true);</span>

 67 }
 68 
<span class="line-modified"> 69 JSObject* createSyntaxError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
 70 {
 71     ASSERT(!message.isEmpty());
<span class="line-modified"> 72     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::SyntaxError), message, appender, TypeNothing, true);</span>

 73 }
 74 
<span class="line-modified"> 75 JSObject* createTypeError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender, RuntimeType type)</span>
 76 {
 77     ASSERT(!message.isEmpty());
<span class="line-modified"> 78     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::TypeError), message, appender, type, true);</span>

 79 }
 80 
<span class="line-modified"> 81 JSObject* createNotEnoughArgumentsError(JSGlobalObject* globalObject, ErrorInstance::SourceAppender appender)</span>
 82 {
<span class="line-modified"> 83     return createTypeError(globalObject, &quot;Not enough arguments&quot;_s, appender, TypeNothing);</span>
 84 }
 85 
<span class="line-modified"> 86 JSObject* createURIError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender)</span>
 87 {
 88     ASSERT(!message.isEmpty());
<span class="line-modified"> 89     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::URIError), message, appender, TypeNothing, true);</span>

 90 }
 91 
<span class="line-modified"> 92 JSObject* createError(JSGlobalObject* globalObject, ErrorType errorType, const String&amp; message)</span>
 93 {
 94     switch (errorType) {
 95     case ErrorType::Error:
<span class="line-modified"> 96         return createError(globalObject, message);</span>
 97     case ErrorType::EvalError:
<span class="line-modified"> 98         return createEvalError(globalObject, message);</span>
 99     case ErrorType::RangeError:
<span class="line-modified">100         return createRangeError(globalObject, message);</span>
101     case ErrorType::ReferenceError:
<span class="line-modified">102         return createReferenceError(globalObject, message);</span>
103     case ErrorType::SyntaxError:
<span class="line-modified">104         return createSyntaxError(globalObject, message);</span>
105     case ErrorType::TypeError:
<span class="line-modified">106         return createTypeError(globalObject, message);</span>
107     case ErrorType::URIError:
<span class="line-modified">108         return createURIError(globalObject, message);</span>
109     }
110     ASSERT_NOT_REACHED();
111     return nullptr;
112 }
113 
<span class="line-modified">114 JSObject* createGetterTypeError(JSGlobalObject* globalObject, const String&amp; message)</span>
115 {
116     ASSERT(!message.isEmpty());
<span class="line-modified">117     auto* error = ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::TypeError), message);</span>

118     error-&gt;setNativeGetterTypeError();
119     return error;
120 }
121 
122 class FindFirstCallerFrameWithCodeblockFunctor {
123 public:
124     FindFirstCallerFrameWithCodeblockFunctor(CallFrame* startCallFrame)
125         : m_startCallFrame(startCallFrame)
126         , m_foundCallFrame(nullptr)
127         , m_foundStartCallFrame(false)
128         , m_index(0)
129     { }
130 
131     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
132     {
133         if (!m_foundStartCallFrame &amp;&amp; (visitor-&gt;callFrame() == m_startCallFrame))
134             m_foundStartCallFrame = true;
135 
136         if (m_foundStartCallFrame) {
<span class="line-modified">137             if (!visitor-&gt;isWasmFrame() &amp;&amp; visitor-&gt;callFrame()-&gt;codeBlock()) {</span>
138                 m_foundCallFrame = visitor-&gt;callFrame();
139                 return StackVisitor::Done;
140             }
141             m_index++;
142         }
143 
144         return StackVisitor::Continue;
145     }
146 
147     CallFrame* foundCallFrame() const { return m_foundCallFrame; }
148     unsigned index() const { return m_index; }
149 
150 private:
151     CallFrame* m_startCallFrame;
152     mutable CallFrame* m_foundCallFrame;
153     mutable bool m_foundStartCallFrame;
154     mutable unsigned m_index;
155 };
156 
<span class="line-modified">157 std::unique_ptr&lt;Vector&lt;StackFrame&gt;&gt; getStackTrace(JSGlobalObject*, VM&amp; vm, JSObject* obj, bool useCurrentFrame)</span>
158 {
159     JSGlobalObject* globalObject = obj-&gt;globalObject(vm);
160     if (!globalObject-&gt;stackTraceLimit())
161         return nullptr;
162 
163     size_t framesToSkip = useCurrentFrame ? 0 : 1;
164     std::unique_ptr&lt;Vector&lt;StackFrame&gt;&gt; stackTrace = makeUnique&lt;Vector&lt;StackFrame&gt;&gt;();
165     vm.interpreter-&gt;getStackTrace(obj, *stackTrace, framesToSkip, globalObject-&gt;stackTraceLimit().value());


166     return stackTrace;
167 }
168 
<span class="line-modified">169 void getBytecodeIndex(VM&amp; vm, CallFrame* startCallFrame, Vector&lt;StackFrame&gt;* stackTrace, CallFrame*&amp; callFrame, BytecodeIndex&amp; bytecodeIndex)</span>
170 {
<span class="line-modified">171     FindFirstCallerFrameWithCodeblockFunctor functor(startCallFrame);</span>
<span class="line-modified">172     StackVisitor::visit(vm.topCallFrame, vm, functor);</span>
173     callFrame = functor.foundCallFrame();
174     unsigned stackIndex = functor.index();
<span class="line-modified">175     bytecodeIndex = BytecodeIndex(0);</span>
<span class="line-modified">176     if (stackTrace &amp;&amp; stackIndex &lt; stackTrace-&gt;size() &amp;&amp; stackTrace-&gt;at(stackIndex).hasBytecodeIndex())</span>
<span class="line-modified">177         bytecodeIndex = stackTrace-&gt;at(stackIndex).bytecodeIndex();</span>
178 }
179 
180 bool getLineColumnAndSource(Vector&lt;StackFrame&gt;* stackTrace, unsigned&amp; line, unsigned&amp; column, String&amp; sourceURL)
181 {
182     line = 0;
183     column = 0;
184     sourceURL = String();
185 
186     if (!stackTrace)
187         return false;
188 
189     for (unsigned i = 0 ; i &lt; stackTrace-&gt;size(); ++i) {
190         StackFrame&amp; frame = stackTrace-&gt;at(i);
191         if (frame.hasLineAndColumnInfo()) {
192             frame.computeLineAndColumn(line, column);
193             sourceURL = frame.sourceURL();
194             return true;
195         }
196     }
197 
</pre>
<hr />
<pre>
205 
206     if (!stackTrace-&gt;isEmpty()) {
207         unsigned line;
208         unsigned column;
209         String sourceURL;
210         getLineColumnAndSource(stackTrace, line, column, sourceURL);
211         obj-&gt;putDirect(vm, vm.propertyNames-&gt;line, jsNumber(line));
212         obj-&gt;putDirect(vm, vm.propertyNames-&gt;column, jsNumber(column));
213         if (!sourceURL.isEmpty())
214             obj-&gt;putDirect(vm, vm.propertyNames-&gt;sourceURL, jsString(vm, sourceURL));
215 
216         obj-&gt;putDirect(vm, vm.propertyNames-&gt;stack, jsString(vm, Interpreter::stackTraceAsString(vm, *stackTrace)), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
217 
218         return true;
219     }
220 
221     obj-&gt;putDirect(vm, vm.propertyNames-&gt;stack, vm.smallStrings.emptyString(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
222     return false;
223 }
224 
<span class="line-modified">225 void addErrorInfo(JSGlobalObject* globalObject, JSObject* obj, bool useCurrentFrame)</span>
226 {
<span class="line-modified">227     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">228     std::unique_ptr&lt;Vector&lt;StackFrame&gt;&gt; stackTrace = getStackTrace(globalObject, vm, obj, useCurrentFrame);</span>
229     addErrorInfo(vm, stackTrace.get(), obj);
230 }
231 
<span class="line-modified">232 JSObject* addErrorInfo(VM&amp; vm, JSObject* error, int line, const SourceCode&amp; source)</span>
233 {

234     const String&amp; sourceURL = source.provider()-&gt;url();
235 
236     // The putDirect() calls below should really be put() so that they trigger materialization of
237     // the line/sourceURL properties. Otherwise, what we set here will just be overwritten later.
238     // But calling put() would be bad because we&#39;d rather not do effectful things here. Luckily, we
239     // know that this will get called on some kind of error - so we can just directly ask the
240     // ErrorInstance to materialize whatever it needs to. There&#39;s a chance that we get passed some
241     // other kind of object, which also has materializable properties. But this code is heuristic-ey
242     // enough that if we&#39;re wrong in such corner cases, it&#39;s not the end of the world.
243     if (ErrorInstance* errorInstance = jsDynamicCast&lt;ErrorInstance*&gt;(vm, error))
244         errorInstance-&gt;materializeErrorInfoIfNeeded(vm);
245 
246     // FIXME: This does not modify the column property, which confusingly continues to reflect
247     // the column at which the exception was thrown.
248     // https://bugs.webkit.org/show_bug.cgi?id=176673
249     if (line != -1)
250         error-&gt;putDirect(vm, vm.propertyNames-&gt;line, jsNumber(line));
251     if (!sourceURL.isNull())
252         error-&gt;putDirect(vm, vm.propertyNames-&gt;sourceURL, jsString(vm, sourceURL));
253     return error;
254 }
255 
<span class="line-modified">256 Exception* throwConstructorCannotBeCalledAsFunctionTypeError(JSGlobalObject* globalObject, ThrowScope&amp; scope, const char* constructorName)</span>





257 {
<span class="line-modified">258     return throwTypeError(globalObject, scope, makeString(&quot;calling &quot;, constructorName, &quot; constructor without new is invalid&quot;));</span>
259 }
260 
<span class="line-modified">261 Exception* throwTypeError(JSGlobalObject* globalObject, ThrowScope&amp; scope)</span>
262 {
<span class="line-modified">263     return throwException(globalObject, scope, createTypeError(globalObject));</span>
264 }
265 
<span class="line-modified">266 Exception* throwTypeError(JSGlobalObject* globalObject, ThrowScope&amp; scope, ASCIILiteral errorMessage)</span>
267 {
<span class="line-modified">268     return throwTypeError(globalObject, scope, String(errorMessage));</span>
269 }
270 
<span class="line-modified">271 Exception* throwTypeError(JSGlobalObject* globalObject, ThrowScope&amp; scope, const String&amp; message)</span>
272 {
<span class="line-modified">273     return throwException(globalObject, scope, createTypeError(globalObject, message));</span>
274 }
275 
<span class="line-modified">276 Exception* throwSyntaxError(JSGlobalObject* globalObject, ThrowScope&amp; scope)</span>
277 {
<span class="line-modified">278     return throwException(globalObject, scope, createSyntaxError(globalObject, &quot;Syntax error&quot;_s));</span>
279 }
280 
<span class="line-modified">281 Exception* throwSyntaxError(JSGlobalObject* globalObject, ThrowScope&amp; scope, const String&amp; message)</span>
282 {
<span class="line-modified">283     return throwException(globalObject, scope, createSyntaxError(globalObject, message));</span>
284 }
285 
<span class="line-modified">286 Exception* throwGetterTypeError(JSGlobalObject* globalObject, ThrowScope&amp; scope, const String&amp; message)</span>
287 {
<span class="line-modified">288     return throwException(globalObject, scope, createGetterTypeError(globalObject, message));</span>
289 }
290 
<span class="line-modified">291 JSValue throwDOMAttributeGetterTypeError(JSGlobalObject* globalObject, ThrowScope&amp; scope, const ClassInfo* classInfo, PropertyName propertyName)</span>
292 {
<span class="line-modified">293     return throwGetterTypeError(globalObject, scope, makeString(&quot;The &quot;, classInfo-&gt;className, &#39;.&#39;, String(propertyName.uid()), &quot; getter can only be used on instances of &quot;, classInfo-&gt;className));</span>
294 }
295 
<span class="line-modified">296 JSObject* createError(JSGlobalObject* globalObject, const String&amp; message)</span>
297 {
<span class="line-modified">298     return createError(globalObject, message, nullptr);</span>
299 }
300 
<span class="line-modified">301 JSObject* createEvalError(JSGlobalObject* globalObject, const String&amp; message)</span>
302 {
<span class="line-modified">303     return createEvalError(globalObject, message, nullptr);</span>
304 }
305 
<span class="line-modified">306 JSObject* createRangeError(JSGlobalObject* globalObject, const String&amp; message)</span>
307 {
<span class="line-modified">308     return createRangeError(globalObject, message, nullptr);</span>
309 }
310 
<span class="line-modified">311 JSObject* createReferenceError(JSGlobalObject* globalObject, const String&amp; message)</span>
312 {
<span class="line-modified">313     return createReferenceError(globalObject, message, nullptr);</span>
314 }
315 
<span class="line-modified">316 JSObject* createSyntaxError(JSGlobalObject* globalObject, const String&amp; message)</span>
317 {
<span class="line-modified">318     return createSyntaxError(globalObject, message, nullptr);</span>
319 }
320 
<span class="line-modified">321 JSObject* createTypeError(JSGlobalObject* globalObject)</span>
322 {
<span class="line-modified">323     return createTypeError(globalObject, &quot;Type error&quot;_s);</span>
324 }
325 
<span class="line-modified">326 JSObject* createTypeError(JSGlobalObject* globalObject, const String&amp; message)</span>
327 {
<span class="line-modified">328     return createTypeError(globalObject, message, nullptr, TypeNothing);</span>
329 }
330 
<span class="line-modified">331 JSObject* createNotEnoughArgumentsError(JSGlobalObject* globalObject)</span>
332 {
<span class="line-modified">333     return createNotEnoughArgumentsError(globalObject, nullptr);</span>
334 }
335 
<span class="line-modified">336 JSObject* createURIError(JSGlobalObject* globalObject, const String&amp; message)</span>
337 {
<span class="line-modified">338     return createURIError(globalObject, message, nullptr);</span>
339 }
340 
<span class="line-modified">341 JSObject* createOutOfMemoryError(JSGlobalObject* globalObject)</span>
342 {
<span class="line-modified">343     auto* error = createError(globalObject, &quot;Out of memory&quot;_s, nullptr);</span>
344     jsCast&lt;ErrorInstance*&gt;(error)-&gt;setOutOfMemoryError();
345     return error;
346 }
347 
<span class="line-modified">348 JSObject* createOutOfMemoryError(JSGlobalObject* globalObject, const String&amp; message)</span>
349 {
350 
<span class="line-modified">351     auto* error = createError(globalObject, makeString(&quot;Out of memory: &quot;, message), nullptr);</span>
352     jsCast&lt;ErrorInstance*&gt;(error)-&gt;setOutOfMemoryError();
353     return error;
354 }
355 
356 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="ECMAScriptSpecInternalFunctions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Error.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
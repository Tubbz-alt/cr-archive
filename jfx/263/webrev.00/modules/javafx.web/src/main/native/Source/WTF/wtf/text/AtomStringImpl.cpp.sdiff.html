<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/text/AtomStringImpl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AtomStringHash.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AtomStringImpl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/text/AtomStringImpl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 50     static Lock s_stringTableLock;
 51 public:
 52     AtomStringTableLocker()
 53         : LockHolder(&amp;s_stringTableLock)
 54     {
 55     }
 56 };
 57 
 58 Lock AtomStringTableLocker::s_stringTableLock;
 59 
 60 #else
 61 
 62 class AtomStringTableLocker {
 63     WTF_MAKE_NONCOPYABLE(AtomStringTableLocker);
 64 public:
 65     AtomStringTableLocker() { }
 66 };
 67 
 68 #endif // USE(WEB_THREAD)
 69 
<span class="line-modified"> 70 using StringTableImpl = HashSet&lt;StringImpl*&gt;;</span>
 71 
 72 static ALWAYS_INLINE StringTableImpl&amp; stringTable()
 73 {
 74     return Thread::current().atomStringTable()-&gt;table();
 75 }
 76 
 77 template&lt;typename T, typename HashTranslator&gt;
 78 static inline Ref&lt;AtomStringImpl&gt; addToStringTable(AtomStringTableLocker&amp;, StringTableImpl&amp; atomStringTable, const T&amp; value)
 79 {
 80     auto addResult = atomStringTable.add&lt;HashTranslator&gt;(value);
 81 
 82     // If the string is newly-translated, then we need to adopt it.
 83     // The boolean in the pair tells us if that is so.
 84     if (addResult.isNewEntry)
<span class="line-modified"> 85         return adoptRef(static_cast&lt;AtomStringImpl&amp;&gt;(**addResult.iterator));</span>
<span class="line-modified"> 86     return *static_cast&lt;AtomStringImpl*&gt;(*addResult.iterator);</span>
 87 }
 88 
 89 template&lt;typename T, typename HashTranslator&gt;
 90 static inline Ref&lt;AtomStringImpl&gt; addToStringTable(const T&amp; value)
 91 {
 92     AtomStringTableLocker locker;
 93     return addToStringTable&lt;T, HashTranslator&gt;(locker, stringTable(), value);
 94 }
 95 
 96 struct CStringTranslator {
 97     static unsigned hash(const LChar* characters)
 98     {
 99         return StringHasher::computeHashAndMaskTop8Bits(characters);
100     }
101 
<span class="line-modified">102     static inline bool equal(StringImpl* str, const LChar* characters)</span>
103     {
<span class="line-modified">104         return WTF::equal(str, characters);</span>
105     }
106 
<span class="line-modified">107     static void translate(StringImpl*&amp; location, const LChar* const&amp; characters, unsigned hash)</span>
108     {
<span class="line-modified">109         location = &amp;StringImpl::create(characters).leakRef();</span>
<span class="line-modified">110         location-&gt;setHash(hash);</span>
<span class="line-modified">111         location-&gt;setIsAtom(true);</span>

112     }
113 };
114 
115 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(const LChar* characters)
116 {
117     if (!characters)
118         return nullptr;
119     if (!*characters)
120         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
121 
122     return addToStringTable&lt;const LChar*, CStringTranslator&gt;(characters);
123 }
124 
125 template&lt;typename CharacterType&gt;
126 struct HashTranslatorCharBuffer {
127     const CharacterType* characters;
128     unsigned length;
129     unsigned hash;
130 
131     HashTranslatorCharBuffer(const CharacterType* characters, unsigned length)
</pre>
<hr />
<pre>
133         , length(length)
134         , hash(StringHasher::computeHashAndMaskTop8Bits(characters, length))
135     {
136     }
137 
138     HashTranslatorCharBuffer(const CharacterType* characters, unsigned length, unsigned hash)
139         : characters(characters)
140         , length(length)
141         , hash(hash)
142     {
143     }
144 };
145 
146 using UCharBuffer = HashTranslatorCharBuffer&lt;UChar&gt;;
147 struct UCharBufferTranslator {
148     static unsigned hash(const UCharBuffer&amp; buf)
149     {
150         return buf.hash;
151     }
152 
<span class="line-modified">153     static bool equal(StringImpl* const&amp; str, const UCharBuffer&amp; buf)</span>
154     {
<span class="line-modified">155         return WTF::equal(str, buf.characters, buf.length);</span>
156     }
157 
<span class="line-modified">158     static void translate(StringImpl*&amp; location, const UCharBuffer&amp; buf, unsigned hash)</span>
159     {
<span class="line-modified">160         location = &amp;StringImpl::create8BitIfPossible(buf.characters, buf.length).leakRef();</span>
<span class="line-modified">161         location-&gt;setHash(hash);</span>
<span class="line-modified">162         location-&gt;setIsAtom(true);</span>

163     }
164 };
165 
166 struct HashAndUTF8Characters {
167     unsigned hash;
168     const char* characters;
169     unsigned length;
170     unsigned utf16Length;
171 };
172 
173 struct HashAndUTF8CharactersTranslator {
174     static unsigned hash(const HashAndUTF8Characters&amp; buffer)
175     {
176         return buffer.hash;
177     }
178 
<span class="line-modified">179     static bool equal(StringImpl* const&amp; string, const HashAndUTF8Characters&amp; buffer)</span>
180     {

181         if (buffer.utf16Length != string-&gt;length())
182             return false;
183 
184         // If buffer contains only ASCII characters UTF-8 and UTF16 length are the same.
185         if (buffer.utf16Length != buffer.length) {
186             if (string-&gt;is8Bit())
187                 return equalLatin1WithUTF8(string-&gt;characters8(), buffer.characters, buffer.characters + buffer.length);
188 
189             return equalUTF16WithUTF8(string-&gt;characters16(), buffer.characters, buffer.characters + buffer.length);
190         }
191 
192         if (string-&gt;is8Bit()) {
193             const LChar* stringCharacters = string-&gt;characters8();
194 
195             for (unsigned i = 0; i &lt; buffer.length; ++i) {
196                 ASSERT(isASCII(buffer.characters[i]));
197                 if (stringCharacters[i] != buffer.characters[i])
198                     return false;
199             }
200 
201             return true;
202         }
203 
204         const UChar* stringCharacters = string-&gt;characters16();
205 
206         for (unsigned i = 0; i &lt; buffer.length; ++i) {
207             ASSERT(isASCII(buffer.characters[i]));
208             if (stringCharacters[i] != buffer.characters[i])
209                 return false;
210         }
211 
212         return true;
213     }
214 
<span class="line-modified">215     static void translate(StringImpl*&amp; location, const HashAndUTF8Characters&amp; buffer, unsigned hash)</span>
216     {
217         UChar* target;
218         auto newString = StringImpl::createUninitialized(buffer.utf16Length, target);
219 
220         bool isAllASCII;
221         const char* source = buffer.characters;
222         if (!convertUTF8ToUTF16(source, source + buffer.length, &amp;target, target + buffer.utf16Length, &amp;isAllASCII))
223             ASSERT_NOT_REACHED();
224 
225         if (isAllASCII)
226             newString = StringImpl::create(buffer.characters, buffer.length);
227 
<span class="line-modified">228         location = &amp;newString.leakRef();</span>
<span class="line-modified">229         location-&gt;setHash(hash);</span>
<span class="line-modified">230         location-&gt;setIsAtom(true);</span>

231     }
232 };
233 
234 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(const UChar* characters, unsigned length)
235 {
236     if (!characters)
237         return nullptr;
238 
239     if (!length)
240         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
241 
242     UCharBuffer buffer { characters, length };
243     return addToStringTable&lt;UCharBuffer, UCharBufferTranslator&gt;(buffer);
244 }
245 
246 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(const UChar* characters)
247 {
248     if (!characters)
249         return nullptr;
250 
251     unsigned length = 0;
252     while (characters[length] != UChar(0))
253         ++length;
254 
255     if (!length)
256         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
257 
258     UCharBuffer buffer { characters, length };
259     return addToStringTable&lt;UCharBuffer, UCharBufferTranslator&gt;(buffer);
260 }
261 
262 struct SubstringLocation {
263     StringImpl* baseString;
264     unsigned start;
265     unsigned length;
266 };
267 
268 struct SubstringTranslator {
<span class="line-modified">269     static void translate(StringImpl*&amp; location, const SubstringLocation&amp; buffer, unsigned hash)</span>
270     {
<span class="line-modified">271         location = &amp;StringImpl::createSubstringSharingImpl(*buffer.baseString, buffer.start, buffer.length).leakRef();</span>
<span class="line-modified">272         location-&gt;setHash(hash);</span>
<span class="line-modified">273         location-&gt;setIsAtom(true);</span>

274     }
275 };
276 
277 struct SubstringTranslator8 : SubstringTranslator {
278     static unsigned hash(const SubstringLocation&amp; buffer)
279     {
280         return StringHasher::computeHashAndMaskTop8Bits(buffer.baseString-&gt;characters8() + buffer.start, buffer.length);
281     }
282 
<span class="line-modified">283     static bool equal(StringImpl* const&amp; string, const SubstringLocation&amp; buffer)</span>
284     {
<span class="line-modified">285         return WTF::equal(string, buffer.baseString-&gt;characters8() + buffer.start, buffer.length);</span>
286     }
287 };
288 
289 struct SubstringTranslator16 : SubstringTranslator {
290     static unsigned hash(const SubstringLocation&amp; buffer)
291     {
292         return StringHasher::computeHashAndMaskTop8Bits(buffer.baseString-&gt;characters16() + buffer.start, buffer.length);
293     }
294 
<span class="line-modified">295     static bool equal(StringImpl* const&amp; string, const SubstringLocation&amp; buffer)</span>
296     {
<span class="line-modified">297         return WTF::equal(string, buffer.baseString-&gt;characters16() + buffer.start, buffer.length);</span>
298     }
299 };
300 
301 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(StringImpl* baseString, unsigned start, unsigned length)
302 {
303     if (!baseString)
304         return nullptr;
305 
306     if (!length || start &gt;= baseString-&gt;length())
307         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
308 
309     unsigned maxLength = baseString-&gt;length() - start;
310     if (length &gt;= maxLength) {
311         if (!start)
312             return add(baseString);
313         length = maxLength;
314     }
315 
316     SubstringLocation buffer = { baseString, start, length };
317     if (baseString-&gt;is8Bit())
318         return addToStringTable&lt;SubstringLocation, SubstringTranslator8&gt;(buffer);
319     return addToStringTable&lt;SubstringLocation, SubstringTranslator16&gt;(buffer);
320 }
321 
322 using LCharBuffer = HashTranslatorCharBuffer&lt;LChar&gt;;
323 struct LCharBufferTranslator {
324     static unsigned hash(const LCharBuffer&amp; buf)
325     {
326         return buf.hash;
327     }
328 
<span class="line-modified">329     static bool equal(StringImpl* const&amp; str, const LCharBuffer&amp; buf)</span>
330     {
<span class="line-modified">331         return WTF::equal(str, buf.characters, buf.length);</span>
332     }
333 
<span class="line-modified">334     static void translate(StringImpl*&amp; location, const LCharBuffer&amp; buf, unsigned hash)</span>
335     {
<span class="line-modified">336         location = &amp;StringImpl::create(buf.characters, buf.length).leakRef();</span>
<span class="line-modified">337         location-&gt;setHash(hash);</span>
<span class="line-modified">338         location-&gt;setIsAtom(true);</span>

339     }
340 };
341 
342 template&lt;typename CharType&gt;
343 struct BufferFromStaticDataTranslator {
344     using Buffer = HashTranslatorCharBuffer&lt;CharType&gt;;
345     static unsigned hash(const Buffer&amp; buf)
346     {
347         return buf.hash;
348     }
349 
<span class="line-modified">350     static bool equal(StringImpl* const&amp; str, const Buffer&amp; buf)</span>
351     {
<span class="line-modified">352         return WTF::equal(str, buf.characters, buf.length);</span>
353     }
354 
<span class="line-modified">355     static void translate(StringImpl*&amp; location, const Buffer&amp; buf, unsigned hash)</span>
356     {
<span class="line-modified">357         location = &amp;StringImpl::createWithoutCopying(buf.characters, buf.length).leakRef();</span>
<span class="line-modified">358         location-&gt;setHash(hash);</span>
<span class="line-modified">359         location-&gt;setIsAtom(true);</span>

360     }
361 };
362 
363 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(const LChar* characters, unsigned length)
364 {
365     if (!characters)
366         return nullptr;
367 
368     if (!length)
369         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
370 
371     LCharBuffer buffer { characters, length };
372     return addToStringTable&lt;LCharBuffer, LCharBufferTranslator&gt;(buffer);
373 }
374 
375 Ref&lt;AtomStringImpl&gt; AtomStringImpl::addLiteral(const char* characters, unsigned length)
376 {
377     ASSERT(characters);
378     ASSERT(length);
379 
</pre>
<hr />
<pre>
426 
427 Ref&lt;AtomStringImpl&gt; AtomStringImpl::addSlowCase(StringImpl&amp; string)
428 {
429     // This check is necessary for null symbols.
430     // Their length is zero, but they are not AtomStringImpl.
431     if (!string.length())
432         return *static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
433 
434     if (string.isStatic())
435         return addStatic(string);
436 
437     if (string.isSymbol())
438         return addSymbol(string);
439 
440     ASSERT_WITH_MESSAGE(!string.isAtom(), &quot;AtomStringImpl should not hit the slow case if the string is already an atom.&quot;);
441 
442     AtomStringTableLocker locker;
443     auto addResult = stringTable().add(&amp;string);
444 
445     if (addResult.isNewEntry) {
<span class="line-modified">446         ASSERT(*addResult.iterator == &amp;string);</span>
447         string.setIsAtom(true);
448     }
449 
<span class="line-modified">450     return *static_cast&lt;AtomStringImpl*&gt;(*addResult.iterator);</span>
451 }
452 
453 Ref&lt;AtomStringImpl&gt; AtomStringImpl::addSlowCase(AtomStringTable&amp; stringTable, StringImpl&amp; string)
454 {
455     // This check is necessary for null symbols.
456     // Their length is zero, but they are not AtomStringImpl.
457     if (!string.length())
458         return *static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
459 
460     if (string.isStatic()) {
461         AtomStringTableLocker locker;
462         return addStatic(locker, stringTable.table(), string);
463     }
464 
465     if (string.isSymbol()) {
466         AtomStringTableLocker locker;
467         return addSymbol(locker, stringTable.table(), string);
468     }
469 
470     ASSERT_WITH_MESSAGE(!string.isAtom(), &quot;AtomStringImpl should not hit the slow case if the string is already an atom.&quot;);
471 
472     AtomStringTableLocker locker;
473     auto addResult = stringTable.table().add(&amp;string);
474 
475     if (addResult.isNewEntry) {
<span class="line-modified">476         ASSERT(*addResult.iterator == &amp;string);</span>
477         string.setIsAtom(true);
478     }
479 
<span class="line-modified">480     return *static_cast&lt;AtomStringImpl*&gt;(*addResult.iterator);</span>
481 }
482 
483 void AtomStringImpl::remove(AtomStringImpl* string)
484 {
485     ASSERT(string-&gt;isAtom());
486     AtomStringTableLocker locker;
487     auto&amp; atomStringTable = stringTable();
488     auto iterator = atomStringTable.find(string);
489     ASSERT_WITH_MESSAGE(iterator != atomStringTable.end(), &quot;The string being removed is an atom in the string table of an other thread!&quot;);
<span class="line-modified">490     ASSERT(string == *iterator);</span>
491     atomStringTable.remove(iterator);
492 }
493 
494 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::lookUpSlowCase(StringImpl&amp; string)
495 {
496     ASSERT_WITH_MESSAGE(!string.isAtom(), &quot;AtomStringImpl objects should return from the fast case.&quot;);
497 
498     if (!string.length())
499         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
500 
501     AtomStringTableLocker locker;
502     auto&amp; atomStringTable = stringTable();
503     auto iterator = atomStringTable.find(&amp;string);
504     if (iterator != atomStringTable.end())
<span class="line-modified">505         return static_cast&lt;AtomStringImpl*&gt;(*iterator);</span>
506     return nullptr;
507 }
508 
509 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::addUTF8(const char* charactersStart, const char* charactersEnd)
510 {
511     HashAndUTF8Characters buffer;
512     buffer.characters = charactersStart;
513     buffer.hash = calculateStringHashAndLengthFromUTF8MaskingTop8Bits(charactersStart, charactersEnd, buffer.length, buffer.utf16Length);
514 
515     if (!buffer.hash)
516         return nullptr;
517 
518     return addToStringTable&lt;HashAndUTF8Characters, HashAndUTF8CharactersTranslator&gt;(buffer);
519 }
520 
521 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::lookUp(const LChar* characters, unsigned length)
522 {
523     AtomStringTableLocker locker;
524     auto&amp; table = stringTable();
525 
526     LCharBuffer buffer = { characters, length };
527     auto iterator = table.find&lt;LCharBufferTranslator&gt;(buffer);
528     if (iterator != table.end())
<span class="line-modified">529         return static_cast&lt;AtomStringImpl*&gt;(*iterator);</span>
530     return nullptr;
531 }
532 
533 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::lookUp(const UChar* characters, unsigned length)
534 {
535     AtomStringTableLocker locker;
536     auto&amp; table = stringTable();
537 
538     UCharBuffer buffer { characters, length };
539     auto iterator = table.find&lt;UCharBufferTranslator&gt;(buffer);
540     if (iterator != table.end())
<span class="line-modified">541         return static_cast&lt;AtomStringImpl*&gt;(*iterator);</span>
542     return nullptr;
543 }
544 
<span class="line-modified">545 #if !ASSERT_DISABLED</span>
546 bool AtomStringImpl::isInAtomStringTable(StringImpl* string)
547 {
548     AtomStringTableLocker locker;
549     return stringTable().contains(string);
550 }
551 #endif
552 
553 } // namespace WTF
</pre>
</td>
<td>
<hr />
<pre>
 50     static Lock s_stringTableLock;
 51 public:
 52     AtomStringTableLocker()
 53         : LockHolder(&amp;s_stringTableLock)
 54     {
 55     }
 56 };
 57 
 58 Lock AtomStringTableLocker::s_stringTableLock;
 59 
 60 #else
 61 
 62 class AtomStringTableLocker {
 63     WTF_MAKE_NONCOPYABLE(AtomStringTableLocker);
 64 public:
 65     AtomStringTableLocker() { }
 66 };
 67 
 68 #endif // USE(WEB_THREAD)
 69 
<span class="line-modified"> 70 using StringTableImpl = HashSet&lt;PackedPtr&lt;StringImpl&gt;&gt;;</span>
 71 
 72 static ALWAYS_INLINE StringTableImpl&amp; stringTable()
 73 {
 74     return Thread::current().atomStringTable()-&gt;table();
 75 }
 76 
 77 template&lt;typename T, typename HashTranslator&gt;
 78 static inline Ref&lt;AtomStringImpl&gt; addToStringTable(AtomStringTableLocker&amp;, StringTableImpl&amp; atomStringTable, const T&amp; value)
 79 {
 80     auto addResult = atomStringTable.add&lt;HashTranslator&gt;(value);
 81 
 82     // If the string is newly-translated, then we need to adopt it.
 83     // The boolean in the pair tells us if that is so.
 84     if (addResult.isNewEntry)
<span class="line-modified"> 85         return adoptRef(static_cast&lt;AtomStringImpl&amp;&gt;(*addResult.iterator-&gt;get()));</span>
<span class="line-modified"> 86     return *static_cast&lt;AtomStringImpl*&gt;(addResult.iterator-&gt;get());</span>
 87 }
 88 
 89 template&lt;typename T, typename HashTranslator&gt;
 90 static inline Ref&lt;AtomStringImpl&gt; addToStringTable(const T&amp; value)
 91 {
 92     AtomStringTableLocker locker;
 93     return addToStringTable&lt;T, HashTranslator&gt;(locker, stringTable(), value);
 94 }
 95 
 96 struct CStringTranslator {
 97     static unsigned hash(const LChar* characters)
 98     {
 99         return StringHasher::computeHashAndMaskTop8Bits(characters);
100     }
101 
<span class="line-modified">102     static inline bool equal(PackedPtr&lt;StringImpl&gt; str, const LChar* characters)</span>
103     {
<span class="line-modified">104         return WTF::equal(str.get(), characters);</span>
105     }
106 
<span class="line-modified">107     static void translate(PackedPtr&lt;StringImpl&gt;&amp; location, const LChar* const&amp; characters, unsigned hash)</span>
108     {
<span class="line-modified">109         auto* pointer = &amp;StringImpl::create(characters).leakRef();</span>
<span class="line-modified">110         pointer-&gt;setHash(hash);</span>
<span class="line-modified">111         pointer-&gt;setIsAtom(true);</span>
<span class="line-added">112         location = pointer;</span>
113     }
114 };
115 
116 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(const LChar* characters)
117 {
118     if (!characters)
119         return nullptr;
120     if (!*characters)
121         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
122 
123     return addToStringTable&lt;const LChar*, CStringTranslator&gt;(characters);
124 }
125 
126 template&lt;typename CharacterType&gt;
127 struct HashTranslatorCharBuffer {
128     const CharacterType* characters;
129     unsigned length;
130     unsigned hash;
131 
132     HashTranslatorCharBuffer(const CharacterType* characters, unsigned length)
</pre>
<hr />
<pre>
134         , length(length)
135         , hash(StringHasher::computeHashAndMaskTop8Bits(characters, length))
136     {
137     }
138 
139     HashTranslatorCharBuffer(const CharacterType* characters, unsigned length, unsigned hash)
140         : characters(characters)
141         , length(length)
142         , hash(hash)
143     {
144     }
145 };
146 
147 using UCharBuffer = HashTranslatorCharBuffer&lt;UChar&gt;;
148 struct UCharBufferTranslator {
149     static unsigned hash(const UCharBuffer&amp; buf)
150     {
151         return buf.hash;
152     }
153 
<span class="line-modified">154     static bool equal(PackedPtr&lt;StringImpl&gt; const&amp; str, const UCharBuffer&amp; buf)</span>
155     {
<span class="line-modified">156         return WTF::equal(str.get(), buf.characters, buf.length);</span>
157     }
158 
<span class="line-modified">159     static void translate(PackedPtr&lt;StringImpl&gt;&amp; location, const UCharBuffer&amp; buf, unsigned hash)</span>
160     {
<span class="line-modified">161         auto* pointer = &amp;StringImpl::create8BitIfPossible(buf.characters, buf.length).leakRef();</span>
<span class="line-modified">162         pointer-&gt;setHash(hash);</span>
<span class="line-modified">163         pointer-&gt;setIsAtom(true);</span>
<span class="line-added">164         location = pointer;</span>
165     }
166 };
167 
168 struct HashAndUTF8Characters {
169     unsigned hash;
170     const char* characters;
171     unsigned length;
172     unsigned utf16Length;
173 };
174 
175 struct HashAndUTF8CharactersTranslator {
176     static unsigned hash(const HashAndUTF8Characters&amp; buffer)
177     {
178         return buffer.hash;
179     }
180 
<span class="line-modified">181     static bool equal(PackedPtr&lt;StringImpl&gt; const&amp; passedString, const HashAndUTF8Characters&amp; buffer)</span>
182     {
<span class="line-added">183         auto* string = passedString.get();</span>
184         if (buffer.utf16Length != string-&gt;length())
185             return false;
186 
187         // If buffer contains only ASCII characters UTF-8 and UTF16 length are the same.
188         if (buffer.utf16Length != buffer.length) {
189             if (string-&gt;is8Bit())
190                 return equalLatin1WithUTF8(string-&gt;characters8(), buffer.characters, buffer.characters + buffer.length);
191 
192             return equalUTF16WithUTF8(string-&gt;characters16(), buffer.characters, buffer.characters + buffer.length);
193         }
194 
195         if (string-&gt;is8Bit()) {
196             const LChar* stringCharacters = string-&gt;characters8();
197 
198             for (unsigned i = 0; i &lt; buffer.length; ++i) {
199                 ASSERT(isASCII(buffer.characters[i]));
200                 if (stringCharacters[i] != buffer.characters[i])
201                     return false;
202             }
203 
204             return true;
205         }
206 
207         const UChar* stringCharacters = string-&gt;characters16();
208 
209         for (unsigned i = 0; i &lt; buffer.length; ++i) {
210             ASSERT(isASCII(buffer.characters[i]));
211             if (stringCharacters[i] != buffer.characters[i])
212                 return false;
213         }
214 
215         return true;
216     }
217 
<span class="line-modified">218     static void translate(PackedPtr&lt;StringImpl&gt;&amp; location, const HashAndUTF8Characters&amp; buffer, unsigned hash)</span>
219     {
220         UChar* target;
221         auto newString = StringImpl::createUninitialized(buffer.utf16Length, target);
222 
223         bool isAllASCII;
224         const char* source = buffer.characters;
225         if (!convertUTF8ToUTF16(source, source + buffer.length, &amp;target, target + buffer.utf16Length, &amp;isAllASCII))
226             ASSERT_NOT_REACHED();
227 
228         if (isAllASCII)
229             newString = StringImpl::create(buffer.characters, buffer.length);
230 
<span class="line-modified">231         auto* pointer = &amp;newString.leakRef();</span>
<span class="line-modified">232         pointer-&gt;setHash(hash);</span>
<span class="line-modified">233         pointer-&gt;setIsAtom(true);</span>
<span class="line-added">234         location = pointer;</span>
235     }
236 };
237 
238 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(const UChar* characters, unsigned length)
239 {
240     if (!characters)
241         return nullptr;
242 
243     if (!length)
244         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
245 
246     UCharBuffer buffer { characters, length };
247     return addToStringTable&lt;UCharBuffer, UCharBufferTranslator&gt;(buffer);
248 }
249 
250 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(const UChar* characters)
251 {
252     if (!characters)
253         return nullptr;
254 
255     unsigned length = 0;
256     while (characters[length] != UChar(0))
257         ++length;
258 
259     if (!length)
260         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
261 
262     UCharBuffer buffer { characters, length };
263     return addToStringTable&lt;UCharBuffer, UCharBufferTranslator&gt;(buffer);
264 }
265 
266 struct SubstringLocation {
267     StringImpl* baseString;
268     unsigned start;
269     unsigned length;
270 };
271 
272 struct SubstringTranslator {
<span class="line-modified">273     static void translate(PackedPtr&lt;StringImpl&gt;&amp; location, const SubstringLocation&amp; buffer, unsigned hash)</span>
274     {
<span class="line-modified">275         auto* pointer = &amp;StringImpl::createSubstringSharingImpl(*buffer.baseString, buffer.start, buffer.length).leakRef();</span>
<span class="line-modified">276         pointer-&gt;setHash(hash);</span>
<span class="line-modified">277         pointer-&gt;setIsAtom(true);</span>
<span class="line-added">278         location = pointer;</span>
279     }
280 };
281 
282 struct SubstringTranslator8 : SubstringTranslator {
283     static unsigned hash(const SubstringLocation&amp; buffer)
284     {
285         return StringHasher::computeHashAndMaskTop8Bits(buffer.baseString-&gt;characters8() + buffer.start, buffer.length);
286     }
287 
<span class="line-modified">288     static bool equal(PackedPtr&lt;StringImpl&gt; const&amp; string, const SubstringLocation&amp; buffer)</span>
289     {
<span class="line-modified">290         return WTF::equal(string.get(), buffer.baseString-&gt;characters8() + buffer.start, buffer.length);</span>
291     }
292 };
293 
294 struct SubstringTranslator16 : SubstringTranslator {
295     static unsigned hash(const SubstringLocation&amp; buffer)
296     {
297         return StringHasher::computeHashAndMaskTop8Bits(buffer.baseString-&gt;characters16() + buffer.start, buffer.length);
298     }
299 
<span class="line-modified">300     static bool equal(PackedPtr&lt;StringImpl&gt; const&amp; string, const SubstringLocation&amp; buffer)</span>
301     {
<span class="line-modified">302         return WTF::equal(string.get(), buffer.baseString-&gt;characters16() + buffer.start, buffer.length);</span>
303     }
304 };
305 
306 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(StringImpl* baseString, unsigned start, unsigned length)
307 {
308     if (!baseString)
309         return nullptr;
310 
311     if (!length || start &gt;= baseString-&gt;length())
312         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
313 
314     unsigned maxLength = baseString-&gt;length() - start;
315     if (length &gt;= maxLength) {
316         if (!start)
317             return add(baseString);
318         length = maxLength;
319     }
320 
321     SubstringLocation buffer = { baseString, start, length };
322     if (baseString-&gt;is8Bit())
323         return addToStringTable&lt;SubstringLocation, SubstringTranslator8&gt;(buffer);
324     return addToStringTable&lt;SubstringLocation, SubstringTranslator16&gt;(buffer);
325 }
326 
327 using LCharBuffer = HashTranslatorCharBuffer&lt;LChar&gt;;
328 struct LCharBufferTranslator {
329     static unsigned hash(const LCharBuffer&amp; buf)
330     {
331         return buf.hash;
332     }
333 
<span class="line-modified">334     static bool equal(PackedPtr&lt;StringImpl&gt; const&amp; str, const LCharBuffer&amp; buf)</span>
335     {
<span class="line-modified">336         return WTF::equal(str.get(), buf.characters, buf.length);</span>
337     }
338 
<span class="line-modified">339     static void translate(PackedPtr&lt;StringImpl&gt;&amp; location, const LCharBuffer&amp; buf, unsigned hash)</span>
340     {
<span class="line-modified">341         auto* pointer = &amp;StringImpl::create(buf.characters, buf.length).leakRef();</span>
<span class="line-modified">342         pointer-&gt;setHash(hash);</span>
<span class="line-modified">343         pointer-&gt;setIsAtom(true);</span>
<span class="line-added">344         location = pointer;</span>
345     }
346 };
347 
348 template&lt;typename CharType&gt;
349 struct BufferFromStaticDataTranslator {
350     using Buffer = HashTranslatorCharBuffer&lt;CharType&gt;;
351     static unsigned hash(const Buffer&amp; buf)
352     {
353         return buf.hash;
354     }
355 
<span class="line-modified">356     static bool equal(PackedPtr&lt;StringImpl&gt; const&amp; str, const Buffer&amp; buf)</span>
357     {
<span class="line-modified">358         return WTF::equal(str.get(), buf.characters, buf.length);</span>
359     }
360 
<span class="line-modified">361     static void translate(PackedPtr&lt;StringImpl&gt;&amp; location, const Buffer&amp; buf, unsigned hash)</span>
362     {
<span class="line-modified">363         auto* pointer = &amp;StringImpl::createWithoutCopying(buf.characters, buf.length).leakRef();</span>
<span class="line-modified">364         pointer-&gt;setHash(hash);</span>
<span class="line-modified">365         pointer-&gt;setIsAtom(true);</span>
<span class="line-added">366         location = pointer;</span>
367     }
368 };
369 
370 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(const LChar* characters, unsigned length)
371 {
372     if (!characters)
373         return nullptr;
374 
375     if (!length)
376         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
377 
378     LCharBuffer buffer { characters, length };
379     return addToStringTable&lt;LCharBuffer, LCharBufferTranslator&gt;(buffer);
380 }
381 
382 Ref&lt;AtomStringImpl&gt; AtomStringImpl::addLiteral(const char* characters, unsigned length)
383 {
384     ASSERT(characters);
385     ASSERT(length);
386 
</pre>
<hr />
<pre>
433 
434 Ref&lt;AtomStringImpl&gt; AtomStringImpl::addSlowCase(StringImpl&amp; string)
435 {
436     // This check is necessary for null symbols.
437     // Their length is zero, but they are not AtomStringImpl.
438     if (!string.length())
439         return *static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
440 
441     if (string.isStatic())
442         return addStatic(string);
443 
444     if (string.isSymbol())
445         return addSymbol(string);
446 
447     ASSERT_WITH_MESSAGE(!string.isAtom(), &quot;AtomStringImpl should not hit the slow case if the string is already an atom.&quot;);
448 
449     AtomStringTableLocker locker;
450     auto addResult = stringTable().add(&amp;string);
451 
452     if (addResult.isNewEntry) {
<span class="line-modified">453         ASSERT(addResult.iterator-&gt;get() == &amp;string);</span>
454         string.setIsAtom(true);
455     }
456 
<span class="line-modified">457     return *static_cast&lt;AtomStringImpl*&gt;(addResult.iterator-&gt;get());</span>
458 }
459 
460 Ref&lt;AtomStringImpl&gt; AtomStringImpl::addSlowCase(AtomStringTable&amp; stringTable, StringImpl&amp; string)
461 {
462     // This check is necessary for null symbols.
463     // Their length is zero, but they are not AtomStringImpl.
464     if (!string.length())
465         return *static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
466 
467     if (string.isStatic()) {
468         AtomStringTableLocker locker;
469         return addStatic(locker, stringTable.table(), string);
470     }
471 
472     if (string.isSymbol()) {
473         AtomStringTableLocker locker;
474         return addSymbol(locker, stringTable.table(), string);
475     }
476 
477     ASSERT_WITH_MESSAGE(!string.isAtom(), &quot;AtomStringImpl should not hit the slow case if the string is already an atom.&quot;);
478 
479     AtomStringTableLocker locker;
480     auto addResult = stringTable.table().add(&amp;string);
481 
482     if (addResult.isNewEntry) {
<span class="line-modified">483         ASSERT(addResult.iterator-&gt;get() == &amp;string);</span>
484         string.setIsAtom(true);
485     }
486 
<span class="line-modified">487     return *static_cast&lt;AtomStringImpl*&gt;(addResult.iterator-&gt;get());</span>
488 }
489 
490 void AtomStringImpl::remove(AtomStringImpl* string)
491 {
492     ASSERT(string-&gt;isAtom());
493     AtomStringTableLocker locker;
494     auto&amp; atomStringTable = stringTable();
495     auto iterator = atomStringTable.find(string);
496     ASSERT_WITH_MESSAGE(iterator != atomStringTable.end(), &quot;The string being removed is an atom in the string table of an other thread!&quot;);
<span class="line-modified">497     ASSERT(string == iterator-&gt;get());</span>
498     atomStringTable.remove(iterator);
499 }
500 
501 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::lookUpSlowCase(StringImpl&amp; string)
502 {
503     ASSERT_WITH_MESSAGE(!string.isAtom(), &quot;AtomStringImpl objects should return from the fast case.&quot;);
504 
505     if (!string.length())
506         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
507 
508     AtomStringTableLocker locker;
509     auto&amp; atomStringTable = stringTable();
510     auto iterator = atomStringTable.find(&amp;string);
511     if (iterator != atomStringTable.end())
<span class="line-modified">512         return static_cast&lt;AtomStringImpl*&gt;(iterator-&gt;get());</span>
513     return nullptr;
514 }
515 
516 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::addUTF8(const char* charactersStart, const char* charactersEnd)
517 {
518     HashAndUTF8Characters buffer;
519     buffer.characters = charactersStart;
520     buffer.hash = calculateStringHashAndLengthFromUTF8MaskingTop8Bits(charactersStart, charactersEnd, buffer.length, buffer.utf16Length);
521 
522     if (!buffer.hash)
523         return nullptr;
524 
525     return addToStringTable&lt;HashAndUTF8Characters, HashAndUTF8CharactersTranslator&gt;(buffer);
526 }
527 
528 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::lookUp(const LChar* characters, unsigned length)
529 {
530     AtomStringTableLocker locker;
531     auto&amp; table = stringTable();
532 
533     LCharBuffer buffer = { characters, length };
534     auto iterator = table.find&lt;LCharBufferTranslator&gt;(buffer);
535     if (iterator != table.end())
<span class="line-modified">536         return static_cast&lt;AtomStringImpl*&gt;(iterator-&gt;get());</span>
537     return nullptr;
538 }
539 
540 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::lookUp(const UChar* characters, unsigned length)
541 {
542     AtomStringTableLocker locker;
543     auto&amp; table = stringTable();
544 
545     UCharBuffer buffer { characters, length };
546     auto iterator = table.find&lt;UCharBufferTranslator&gt;(buffer);
547     if (iterator != table.end())
<span class="line-modified">548         return static_cast&lt;AtomStringImpl*&gt;(iterator-&gt;get());</span>
549     return nullptr;
550 }
551 
<span class="line-modified">552 #if ASSERT_ENABLED</span>
553 bool AtomStringImpl::isInAtomStringTable(StringImpl* string)
554 {
555     AtomStringTableLocker locker;
556     return stringTable().contains(string);
557 }
558 #endif
559 
560 } // namespace WTF
</pre>
</td>
</tr>
</table>
<center><a href="AtomStringHash.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AtomStringImpl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
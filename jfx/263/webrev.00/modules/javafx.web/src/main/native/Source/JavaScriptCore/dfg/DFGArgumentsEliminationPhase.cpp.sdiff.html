<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsEliminationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGArgumentPosition.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArgumentsUtilities.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsEliminationPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  35 #include &quot;DFGBasicBlockInlines.h&quot;
  36 #include &quot;DFGBlockMapInlines.h&quot;
  37 #include &quot;DFGClobberize.h&quot;
  38 #include &quot;DFGCombinedLiveness.h&quot;
  39 #include &quot;DFGForAllKills.h&quot;
  40 #include &quot;DFGGraph.h&quot;
  41 #include &quot;DFGInsertionSet.h&quot;
  42 #include &quot;DFGLivenessAnalysisPhase.h&quot;
  43 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
  44 #include &quot;DFGPhase.h&quot;
  45 #include &quot;JSCInlines.h&quot;
  46 #include &lt;wtf/HashSet.h&gt;
  47 #include &lt;wtf/ListDump.h&gt;
  48 #include &lt;wtf/RecursableLambda.h&gt;
  49 
  50 namespace JSC { namespace DFG {
  51 
  52 namespace {
  53 
  54 namespace DFGArgumentsEliminationPhaseInternal {
<span class="line-modified">  55 static const bool verbose = false;</span>
  56 }
  57 
  58 class ArgumentsEliminationPhase : public Phase {
  59 public:
  60     ArgumentsEliminationPhase(Graph&amp; graph)
  61         : Phase(graph, &quot;arguments elimination&quot;)
  62     {
  63     }
  64 
  65     bool run()
  66     {
  67         // For now this phase only works on SSA. This could be changed; we could have a block-local
  68         // version over LoadStore.
  69         DFG_ASSERT(m_graph, nullptr, m_graph.m_form == SSA);
  70 
  71         if (DFGArgumentsEliminationPhaseInternal::verbose) {
  72             dataLog(&quot;Graph before arguments elimination:\n&quot;);
  73             m_graph.dump();
  74         }
  75 
</pre>
<hr />
<pre>
 341                         } else
 342                             dontEscape = false;
 343 
 344                         if (!dontEscape)
 345                             escape(child, node);
 346                     }
 347 
 348                     break;
 349                 }
 350 
 351                 case Spread: {
 352                     bool isOK = node-&gt;child1().useKind() == ArrayUse &amp;&amp; (node-&gt;child1()-&gt;op() == CreateRest || node-&gt;child1()-&gt;op() == NewArrayBuffer);
 353                     if (!isOK)
 354                         escape(node-&gt;child1(), node);
 355                     break;
 356                 }
 357 
 358                 case NewArrayBuffer:
 359                     break;
 360 



 361                 case LoadVarargs:
<span class="line-modified"> 362                     if (node-&gt;loadVarargsData()-&gt;offset &amp;&amp; (node-&gt;child1()-&gt;op() == NewArrayWithSpread || node-&gt;child1()-&gt;op() == Spread || node-&gt;child1()-&gt;op() == NewArrayBuffer))</span>
<span class="line-modified"> 363                         escape(node-&gt;child1(), node);</span>
 364                     break;
 365 
 366                 case CallVarargs:
 367                 case ConstructVarargs:
 368                 case TailCallVarargs:
 369                 case TailCallVarargsInlinedCaller:
 370                     escape(node-&gt;child1(), node);
 371                     escape(node-&gt;child2(), node);
 372                     if (node-&gt;callVarargsData()-&gt;firstVarArgOffset &amp;&amp; (node-&gt;child3()-&gt;op() == NewArrayWithSpread || node-&gt;child3()-&gt;op() == Spread || node-&gt;child1()-&gt;op() == NewArrayBuffer))
 373                         escape(node-&gt;child3(), node);
 374                     break;
 375 
 376                 case Check:
 377                 case CheckVarargs:
 378                     m_graph.doToChildren(
 379                         node,
 380                         [&amp;] (Edge edge) {
 381                             if (edge.willNotHaveCheck())
 382                                 return;
 383 
 384                             if (alreadyChecked(edge.useKind(), SpecObject))
 385                                 return;
 386 
 387                             escape(edge, node);
 388                         });
 389                     break;
 390 
 391                 case MovHint:
 392                 case PutHint:
 393                     break;
 394 
 395                 case GetButterfly:
 396                     // This barely works. The danger is that the GetButterfly is used by something that
 397                     // does something escaping to a candidate. Fortunately, the only butterfly-using ops
 398                     // that we exempt here also use the candidate directly. If there ever was a
 399                     // butterfly-using op that we wanted to exempt, then we&#39;d have to look at the
 400                     // butterfly&#39;s child and check if it&#39;s a candidate.
 401                     break;
 402 
<span class="line-modified"> 403                 case FilterGetByIdStatus:</span>
 404                 case FilterPutByIdStatus:
 405                 case FilterCallLinkStatus:
 406                 case FilterInByIdStatus:
 407                     break;
 408 

 409                 case CheckArray:
 410                     escapeBasedOnArrayMode(node-&gt;arrayMode(), node-&gt;child1(), node);
 411                     break;
 412 
 413                 case CheckStructureOrEmpty:
 414                 case CheckStructure: {
 415                     Node* target = node-&gt;child1().node();
 416                     if (!m_candidates.contains(target))
 417                         break;
 418 
 419                     Structure* structure = nullptr;
 420                     JSGlobalObject* globalObject = m_graph.globalObjectFor(target-&gt;origin.semantic);
 421                     switch (target-&gt;op()) {
 422                     case CreateDirectArguments:
 423                         structure = globalObject-&gt;directArgumentsStructure();
 424                         break;
 425                     case CreateClonedArguments:
 426                         structure = globalObject-&gt;clonedArgumentsStructure();
 427                         break;
 428                     case CreateRest:
</pre>
<hr />
<pre>
 476     void eliminateCandidatesThatInterfere()
 477     {
 478         performLivenessAnalysis(m_graph);
 479         performOSRAvailabilityAnalysis(m_graph);
 480         m_graph.initializeNodeOwners();
 481         CombinedLiveness combinedLiveness(m_graph);
 482 
 483         BlockMap&lt;Operands&lt;bool&gt;&gt; clobberedByBlock(m_graph);
 484         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 485             Operands&lt;bool&gt;&amp; clobberedByThisBlock = clobberedByBlock[block];
 486             clobberedByThisBlock = Operands&lt;bool&gt;(OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
 487             for (Node* node : *block) {
 488                 clobberize(
 489                     m_graph, node, NoOpClobberize(),
 490                     [&amp;] (AbstractHeap heap) {
 491                         if (heap.kind() != Stack) {
 492                             ASSERT(!heap.overlaps(Stack));
 493                             return;
 494                         }
 495                         ASSERT(!heap.payload().isTop());
<span class="line-modified"> 496                         VirtualRegister reg(heap.payload().value32());</span>
 497                         // The register may not point to an argument or local, for example if we are looking at SetArgumentCountIncludingThis.
<span class="line-modified"> 498                         if (!reg.isHeader())</span>
<span class="line-modified"> 499                             clobberedByThisBlock.operand(reg) = true;</span>
 500                     },
 501                     NoOpClobberize());
 502             }
 503         }
 504 
 505         using InlineCallFrames = HashSet&lt;InlineCallFrame*, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt;;
 506         using InlineCallFramesForCanditates = HashMap&lt;Node*, InlineCallFrames&gt;;
 507         InlineCallFramesForCanditates inlineCallFramesForCandidate;
 508         auto forEachDependentNode = recursableLambda([&amp;](auto self, Node* node, const auto&amp; functor) -&gt; void {
 509             functor(node);
 510 
 511             if (node-&gt;op() == Spread) {
 512                 self(node-&gt;child1().node(), functor);
 513                 return;
 514             }
 515 
 516             if (node-&gt;op() == NewArrayWithSpread) {
 517                 BitVector* bitVector = node-&gt;bitVector();
 518                 for (unsigned i = node-&gt;numChildren(); i--; ) {
 519                     if (bitVector-&gt;get(i))
</pre>
<hr />
<pre>
 543                 }
 544             }
 545             if (!writesToStack)
 546                 continue;
 547 
 548             forAllKillsInBlock(
 549                 m_graph, combinedLiveness, block,
 550                 [&amp;] (unsigned nodeIndex, Node* candidate) {
 551                     if (!m_candidates.contains(candidate))
 552                         return;
 553 
 554                     for (InlineCallFrame* inlineCallFrame : inlineCallFramesForCandidate.get(candidate)) {
 555                         // Check if this block has any clobbers that affect this candidate. This is a fairly
 556                         // fast check.
 557                         bool isClobberedByBlock = false;
 558                         Operands&lt;bool&gt;&amp; clobberedByThisBlock = clobberedByBlock[block];
 559 
 560                         if (inlineCallFrame) {
 561                             if (inlineCallFrame-&gt;isVarargs()) {
 562                                 isClobberedByBlock |= clobberedByThisBlock.operand(
<span class="line-modified"> 563                                     inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount);</span>
 564                             }
 565 
 566                             if (!isClobberedByBlock || inlineCallFrame-&gt;isClosureCall) {
 567                                 isClobberedByBlock |= clobberedByThisBlock.operand(
<span class="line-modified"> 568                                     inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee);</span>
 569                             }
 570 
 571                             if (!isClobberedByBlock) {
<span class="line-modified"> 572                                 for (unsigned i = 0; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1; ++i) {</span>
 573                                     VirtualRegister reg =
 574                                         VirtualRegister(inlineCallFrame-&gt;stackOffset) +
 575                                         CallFrame::argumentOffset(i);
 576                                     if (clobberedByThisBlock.operand(reg)) {
 577                                         isClobberedByBlock = true;
 578                                         break;
 579                                     }
 580                                 }
 581                             }
 582                         } else {
 583                             // We don&#39;t include the ArgumentCount or Callee in this case because we can be
 584                             // damn sure that this won&#39;t be clobbered.
 585                             for (unsigned i = 1; i &lt; static_cast&lt;unsigned&gt;(codeBlock()-&gt;numParameters()); ++i) {
 586                                 if (clobberedByThisBlock.argument(i)) {
 587                                     isClobberedByBlock = true;
 588                                     break;
 589                                 }
 590                             }
 591                         }
 592 
</pre>
<hr />
<pre>
 610                         // yet to be processed. Inside the look, it refers to the index
 611                         // of the current node to process (after we decrement it).
 612                         //
 613                         // If the remaining number of nodes is 0, we should not decrement nodeIndex.
 614                         // Hence, we must only decrement nodeIndex inside the while loop instead of
 615                         // in its condition statement. Note that this while loop is embedded in an
 616                         // outer for loop. If we decrement nodeIndex in the condition statement, a
 617                         // nodeIndex of 0 will become UINT_MAX, and the outer loop will wrongly
 618                         // treat this as there being UINT_MAX remaining nodes to process.
 619                         while (nodeIndex) {
 620                             --nodeIndex;
 621                             Node* node = block-&gt;at(nodeIndex);
 622                             if (node == candidate)
 623                                 break;
 624 
 625                             bool found = false;
 626                             clobberize(
 627                                 m_graph, node, NoOpClobberize(),
 628                                 [&amp;] (AbstractHeap heap) {
 629                                     if (heap.kind() == Stack &amp;&amp; !heap.payload().isTop()) {
<span class="line-modified"> 630                                         if (argumentsInvolveStackSlot(inlineCallFrame, VirtualRegister(heap.payload().value32())))</span>
 631                                             found = true;
 632                                         return;
 633                                     }
 634                                     if (heap.overlaps(Stack))
 635                                         found = true;
 636                                 },
 637                                 NoOpClobberize());
 638 
 639                             if (found) {
 640                                 if (DFGArgumentsEliminationPhaseInternal::verbose)
 641                                     dataLog(&quot;eliminating candidate: &quot;, candidate, &quot; because it is clobbered by &quot;, block-&gt;at(nodeIndex), &quot;\n&quot;);
 642                                 transitivelyRemoveCandidate(candidate);
 643                                 return;
 644                             }
 645                         }
 646                     }
 647                 });
 648         }
 649 
 650         // Q: How do we handle OSR exit with a live PhantomArguments at a point where the inline call
</pre>
<hr />
<pre>
 735 
 736                     node-&gt;setOpAndDefaultFlags(PhantomNewArrayWithSpread);
 737                     break;
 738 
 739                 case NewArrayBuffer:
 740                     if (!m_candidates.contains(node))
 741                         break;
 742 
 743                     node-&gt;setOpAndDefaultFlags(PhantomNewArrayBuffer);
 744                     node-&gt;child1() = Edge(insertionSet.insertConstant(nodeIndex, node-&gt;origin, node-&gt;cellOperand()));
 745                     break;
 746 
 747                 case GetFromArguments: {
 748                     Node* candidate = node-&gt;child1().node();
 749                     if (!isEliminatedAllocation(candidate))
 750                         break;
 751 
 752                     DFG_ASSERT(
 753                         m_graph, node, node-&gt;child1()-&gt;op() == PhantomDirectArguments, node-&gt;child1()-&gt;op());
 754                     VirtualRegister reg =
<span class="line-modified"> 755                         virtualRegisterForArgument(node-&gt;capturedArgumentsOffset().offset() + 1) +</span>
 756                         node-&gt;origin.semantic.stackOffset();
 757                     StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 758                     node-&gt;convertToGetStack(data);
 759                     break;
 760                 }
 761 
 762                 case GetByOffset: {
 763                     Node* candidate = node-&gt;child2().node();
 764                     if (!isEliminatedAllocation(candidate))
 765                         break;
 766 
 767                     ASSERT(candidate-&gt;op() == PhantomClonedArguments);
 768                     ASSERT(node-&gt;storageAccessData().offset == clonedArgumentsLengthPropertyOffset);
 769 
 770                     // Meh, this is kind of hackish - we use an Identity so that we can reuse the
 771                     // getArrayLength() helper.
 772                     node-&gt;convertToIdentityOn(getArrayLength(candidate));
 773                     break;
 774                 }
 775 
</pre>
<hr />
<pre>
 789                     // often implicitly part of GetMyArgumentByVal. B3 will probably eliminate the
 790                     // second bounds check, but still - that&#39;s just silly.
 791                     // https://bugs.webkit.org/show_bug.cgi?id=143076
 792 
 793                     Node* candidate = m_graph.varArgChild(node, 0).node();
 794                     if (!isEliminatedAllocation(candidate))
 795                         break;
 796 
 797                     unsigned numberOfArgumentsToSkip = 0;
 798                     if (candidate-&gt;op() == PhantomCreateRest)
 799                         numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
 800 
 801                     Node* result = nullptr;
 802                     if (m_graph.varArgChild(node, 1)-&gt;isInt32Constant()) {
 803                         unsigned index = m_graph.varArgChild(node, 1)-&gt;asUInt32();
 804                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
 805                         index += numberOfArgumentsToSkip;
 806 
 807                         bool safeToGetStack = index &gt;= numberOfArgumentsToSkip;
 808                         if (inlineCallFrame)
<span class="line-modified"> 809                             safeToGetStack &amp;= index &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>
 810                         else {
 811                             safeToGetStack &amp;=
 812                                 index &lt; static_cast&lt;unsigned&gt;(codeBlock()-&gt;numParameters()) - 1;
 813                         }
 814                         if (safeToGetStack) {
 815                             StackAccessData* data;
<span class="line-modified"> 816                             VirtualRegister arg = virtualRegisterForArgument(index + 1);</span>
 817                             if (inlineCallFrame)
 818                                 arg += inlineCallFrame-&gt;stackOffset;
 819                             data = m_graph.m_stackAccessData.add(arg, FlushedJSValue);
 820 
 821                             Node* check = nullptr;
 822                             if (!inlineCallFrame || inlineCallFrame-&gt;isVarargs()) {
 823                                 check = insertionSet.insertNode(
 824                                     nodeIndex, SpecNone, CheckInBounds, node-&gt;origin,
 825                                     m_graph.varArgChild(node, 1), Edge(getArrayLength(candidate), Int32Use));
 826                             }
 827 
 828                             result = insertionSet.insertNode(
 829                                 nodeIndex, node-&gt;prediction(), GetStack, node-&gt;origin, OpInfo(data), Edge(check, UntypedUse));
 830                         }
 831                     }
 832 
 833                     if (!result) {
 834                         NodeType op;
 835                         if (node-&gt;arrayMode().isInBounds())
 836                             op = GetMyArgumentByVal;
 837                         else
 838                             op = GetMyArgumentByValOutOfBounds;
 839                         result = insertionSet.insertNode(
 840                             nodeIndex, node-&gt;prediction(), op, node-&gt;origin, OpInfo(numberOfArgumentsToSkip),
 841                             m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1));
 842                     }
 843 
 844                     // Need to do this because we may have a data format conversion here.
 845                     node-&gt;convertToIdentityOn(result);
 846                     break;
 847                 }
 848 














 849                 case LoadVarargs: {
<span class="line-modified"> 850                     Node* candidate = node-&gt;child1().node();</span>
 851                     if (!isEliminatedAllocation(candidate))
 852                         break;
 853 
 854                     // LoadVarargs can exit, so it better be exitOK.
 855                     DFG_ASSERT(m_graph, node, node-&gt;origin.exitOK);
 856                     bool canExit = true;
 857                     LoadVarargsData* varargsData = node-&gt;loadVarargsData();
 858 
 859                     auto storeArgumentCountIncludingThis = [&amp;] (unsigned argumentCountIncludingThis) {
 860                         Node* argumentCountIncludingThisNode = insertionSet.insertConstant(
 861                             nodeIndex, node-&gt;origin.withExitOK(canExit),
 862                             jsNumber(argumentCountIncludingThis));
 863                         insertionSet.insertNode(
 864                             nodeIndex, SpecNone, KillStack, node-&gt;origin.takeValidExit(canExit),
<span class="line-modified"> 865                             OpInfo(varargsData-&gt;count.offset()));</span>
 866                         insertionSet.insertNode(
 867                             nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
<span class="line-modified"> 868                             OpInfo(varargsData-&gt;count.offset()), Edge(argumentCountIncludingThisNode));</span>
 869                         insertionSet.insertNode(
 870                             nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
 871                             OpInfo(m_graph.m_stackAccessData.add(varargsData-&gt;count, FlushedInt32)),
 872                             Edge(argumentCountIncludingThisNode, KnownInt32Use));
 873                     };
 874 
 875                     auto storeValue = [&amp;] (Node* value, unsigned storeIndex) {
 876                         VirtualRegister reg = varargsData-&gt;start + storeIndex;

 877                         StackAccessData* data =
 878                             m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 879 
 880                         insertionSet.insertNode(
<span class="line-modified"> 881                             nodeIndex, SpecNone, KillStack, node-&gt;origin.takeValidExit(canExit), OpInfo(reg.offset()));</span>
 882                         insertionSet.insertNode(
 883                             nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
<span class="line-modified"> 884                             OpInfo(reg.offset()), Edge(value));</span>
 885                         insertionSet.insertNode(
 886                             nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
 887                             OpInfo(data), Edge(value));
 888                     };
 889 
 890                     if (candidate-&gt;op() == PhantomNewArrayWithSpread || candidate-&gt;op() == PhantomNewArrayBuffer || candidate-&gt;op() == PhantomSpread) {
 891                         auto canConvertToStaticLoadStores = recursableLambda([&amp;] (auto self, Node* candidate) -&gt; bool {
 892                             if (candidate-&gt;op() == PhantomSpread)
 893                                 return self(candidate-&gt;child1().node());
 894 
 895                             if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 896                                 BitVector* bitVector = candidate-&gt;bitVector();
 897                                 for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 898                                     if (bitVector-&gt;get(i)) {
 899                                         if (!self(m_graph.varArgChild(candidate, i).node()))
 900                                             return false;
 901                                     }
 902                                 }
 903                                 return true;
 904                             }
</pre>
<hr />
<pre>
 918                                     return self(candidate-&gt;child1().node());
 919 
 920                                 if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 921                                     BitVector* bitVector = candidate-&gt;bitVector();
 922                                     unsigned result = 0;
 923                                     for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 924                                         if (bitVector-&gt;get(i))
 925                                             result += self(m_graph.varArgChild(candidate, i).node());
 926                                         else
 927                                             ++result;
 928                                     }
 929                                     return result;
 930                                 }
 931 
 932                                 if (candidate-&gt;op() == PhantomNewArrayBuffer)
 933                                     return candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 934 
 935                                 ASSERT(candidate-&gt;op() == PhantomCreateRest);
 936                                 unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
 937                                 InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
<span class="line-modified"> 938                                 unsigned frameArgumentCount = inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>
 939                                 if (frameArgumentCount &gt;= numberOfArgumentsToSkip)
 940                                     return frameArgumentCount - numberOfArgumentsToSkip;
 941                                 return 0;
 942                             });
 943 
 944                             unsigned argumentCountIncludingThis = 1 + countNumberOfArguments(candidate); // |this|
 945                             if (argumentCountIncludingThis &lt;= varargsData-&gt;limit) {
 946                                 storeArgumentCountIncludingThis(argumentCountIncludingThis);
 947 
 948                                 DFG_ASSERT(m_graph, node, varargsData-&gt;limit - 1 &gt;= varargsData-&gt;mandatoryMinimum, varargsData-&gt;limit, varargsData-&gt;mandatoryMinimum);
 949                                 // Define our limit to exclude &quot;this&quot;, since that&#39;s a bit easier to reason about.
 950                                 unsigned limit = varargsData-&gt;limit - 1;
 951 
 952                                 auto forwardNode = recursableLambda([&amp;](auto self, Node* candidate, unsigned storeIndex) -&gt; unsigned {
 953                                     if (candidate-&gt;op() == PhantomSpread)
 954                                         return self(candidate-&gt;child1().node(), storeIndex);
 955 
 956                                     if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 957                                         BitVector* bitVector = candidate-&gt;bitVector();
 958                                         for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
</pre>
<hr />
<pre>
 966                                         return storeIndex;
 967                                     }
 968 
 969                                     if (candidate-&gt;op() == PhantomNewArrayBuffer) {
 970                                         auto* array = candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 971                                         for (unsigned index = 0; index &lt; array-&gt;length(); ++index) {
 972                                             JSValue constant;
 973                                             if (candidate-&gt;indexingType() == ArrayWithDouble)
 974                                                 constant = jsDoubleNumber(array-&gt;get(index).asNumber());
 975                                             else
 976                                                 constant = array-&gt;get(index);
 977                                             Node* value = insertionSet.insertConstant(nodeIndex, node-&gt;origin.withExitOK(canExit), constant);
 978                                             storeValue(value, storeIndex++);
 979                                         }
 980                                         return storeIndex;
 981                                     }
 982 
 983                                     ASSERT(candidate-&gt;op() == PhantomCreateRest);
 984                                     unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
 985                                     InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
<span class="line-modified"> 986                                     unsigned frameArgumentCount = inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>
 987                                     for (unsigned loadIndex = numberOfArgumentsToSkip; loadIndex &lt; frameArgumentCount; ++loadIndex) {
<span class="line-modified"> 988                                         VirtualRegister reg = virtualRegisterForArgument(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;</span>
 989                                         StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 990                                         Node* value = insertionSet.insertNode(
 991                                             nodeIndex, SpecNone, GetStack, node-&gt;origin.withExitOK(canExit),
 992                                             OpInfo(data));
 993                                         storeValue(value, storeIndex++);
 994                                     }
 995                                     return storeIndex;
 996                                 });
 997 
 998                                 unsigned storeIndex = forwardNode(candidate, 0);
 999                                 RELEASE_ASSERT(storeIndex &lt;= limit);
1000                                 Node* undefined = nullptr;
1001                                 for (; storeIndex &lt; limit; ++storeIndex) {
1002                                     if (!undefined) {
1003                                         undefined = insertionSet.insertConstant(
1004                                             nodeIndex, node-&gt;origin.withExitOK(canExit), jsUndefined());
1005                                     }
1006                                     storeValue(undefined, storeIndex);
1007                                 }
1008 
1009                                 node-&gt;remove(m_graph);
1010                                 node-&gt;origin.exitOK = canExit;
1011                                 break;
1012                             }
1013                         }
1014                     } else {
1015                         unsigned numberOfArgumentsToSkip = 0;
1016                         if (candidate-&gt;op() == PhantomCreateRest)
1017                             numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1018                         varargsData-&gt;offset += numberOfArgumentsToSkip;
1019 
1020                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
1021 
<span class="line-modified">1022                         if (inlineCallFrame</span>
<span class="line-removed">1023                             &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {</span>
<span class="line-removed">1024 </span>
1025                             unsigned argumentCountIncludingThis = inlineCallFrame-&gt;argumentCountIncludingThis;
1026                             if (argumentCountIncludingThis &gt; varargsData-&gt;offset)
1027                                 argumentCountIncludingThis -= varargsData-&gt;offset;
1028                             else
1029                                 argumentCountIncludingThis = 1;
1030                             RELEASE_ASSERT(argumentCountIncludingThis &gt;= 1);
1031 
1032                             if (argumentCountIncludingThis &lt;= varargsData-&gt;limit) {
<span class="line-removed">1033 </span>
1034                                 storeArgumentCountIncludingThis(argumentCountIncludingThis);
1035 
1036                                 DFG_ASSERT(m_graph, node, varargsData-&gt;limit - 1 &gt;= varargsData-&gt;mandatoryMinimum, varargsData-&gt;limit, varargsData-&gt;mandatoryMinimum);
1037                                 // Define our limit to exclude &quot;this&quot;, since that&#39;s a bit easier to reason about.
1038                                 unsigned limit = varargsData-&gt;limit - 1;
1039                                 Node* undefined = nullptr;
1040                                 for (unsigned storeIndex = 0; storeIndex &lt; limit; ++storeIndex) {
1041                                     // First determine if we have an element we can load, and load it if
1042                                     // possible.
1043 
1044                                     Node* value = nullptr;
1045                                     unsigned loadIndex = storeIndex + varargsData-&gt;offset;
1046 
1047                                     if (loadIndex + 1 &lt; inlineCallFrame-&gt;argumentCountIncludingThis) {
<span class="line-modified">1048                                         VirtualRegister reg = virtualRegisterForArgument(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;</span>
1049                                         StackAccessData* data = m_graph.m_stackAccessData.add(
1050                                             reg, FlushedJSValue);
1051 
1052                                         value = insertionSet.insertNode(
1053                                             nodeIndex, SpecNone, GetStack, node-&gt;origin.withExitOK(canExit),
1054                                             OpInfo(data));
1055                                     } else {
1056                                         // FIXME: We shouldn&#39;t have to store anything if
1057                                         // storeIndex &gt;= varargsData-&gt;mandatoryMinimum, but we will still
1058                                         // have GetStacks in that range. So if we don&#39;t do the stores, we&#39;ll
1059                                         // have degenerate IR: we&#39;ll have GetStacks of something that didn&#39;t
1060                                         // have PutStacks.
1061                                         // https://bugs.webkit.org/show_bug.cgi?id=147434
1062 
1063                                         if (!undefined) {
1064                                             undefined = insertionSet.insertConstant(
1065                                                 nodeIndex, node-&gt;origin.withExitOK(canExit), jsUndefined());
1066                                         }
1067                                         value = undefined;
1068                                     }
</pre>
<hr />
<pre>
1184 
1185                                 if (candidate-&gt;op() == PhantomNewArrayBuffer) {
1186                                     bool canExit = true;
1187                                     auto* array = candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
1188                                     for (unsigned index = 0; index &lt; array-&gt;length(); ++index) {
1189                                         JSValue constant;
1190                                         if (candidate-&gt;indexingType() == ArrayWithDouble)
1191                                             constant = jsDoubleNumber(array-&gt;get(index).asNumber());
1192                                         else
1193                                             constant = array-&gt;get(index);
1194                                         arguments.append(insertionSet.insertConstant(nodeIndex, node-&gt;origin.withExitOK(canExit), constant));
1195                                     }
1196                                     return;
1197                                 }
1198 
1199                                 ASSERT(candidate-&gt;op() == PhantomCreateRest);
1200                                 InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
1201                                 unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1202                                 for (unsigned i = 1 + numberOfArgumentsToSkip; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
1203                                     StackAccessData* data = m_graph.m_stackAccessData.add(
<span class="line-modified">1204                                         virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset,</span>
1205                                         FlushedJSValue);
1206 
1207                                     Node* value = insertionSet.insertNode(
1208                                         nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
1209 
1210                                     arguments.append(value);
1211                                 }
1212                             });
1213 
1214                             appendNode(candidate);
1215                             convertToStaticArgumentCountCall(arguments);
1216                         } else
1217                             convertToForwardsCall();
1218                     } else {
1219                         unsigned numberOfArgumentsToSkip = 0;
1220                         if (candidate-&gt;op() == PhantomCreateRest)
1221                             numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1222                         CallVarargsData* varargsData = node-&gt;callVarargsData();
1223                         varargsData-&gt;firstVarArgOffset += numberOfArgumentsToSkip;
1224 
1225                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
1226                         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
1227                             Vector&lt;Node*&gt; arguments;
1228                             for (unsigned i = 1 + varargsData-&gt;firstVarArgOffset; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
1229                                 StackAccessData* data = m_graph.m_stackAccessData.add(
<span class="line-modified">1230                                     virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset,</span>
1231                                     FlushedJSValue);
1232 
1233                                 Node* value = insertionSet.insertNode(
1234                                     nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
1235 
1236                                 arguments.append(value);
1237                             }
1238 
1239                             convertToStaticArgumentCountCall(arguments);
1240                         } else
1241                             convertToForwardsCall();
1242                     }
1243 
1244                     break;
1245                 }
1246 

1247                 case CheckArray:
1248                 case GetButterfly:
<span class="line-modified">1249                 case FilterGetByIdStatus:</span>
1250                 case FilterPutByIdStatus:
1251                 case FilterCallLinkStatus:
1252                 case FilterInByIdStatus: {
1253                     if (!isEliminatedAllocation(node-&gt;child1().node()))
1254                         break;
1255                     node-&gt;remove(m_graph);
1256                     break;
1257                 }
1258 
1259                 case CheckStructureOrEmpty:
1260                 case CheckStructure:
1261                     if (!isEliminatedAllocation(node-&gt;child1().node()))
1262                         break;
1263                     node-&gt;child1() = Edge(); // Remove the cell check since we&#39;ve proven it&#39;s not needed and FTL lowering might botch this.
1264                     node-&gt;remove(m_graph);
1265                     break;
1266 
1267                 default:
1268                     break;
1269                 }
</pre>
</td>
<td>
<hr />
<pre>
  35 #include &quot;DFGBasicBlockInlines.h&quot;
  36 #include &quot;DFGBlockMapInlines.h&quot;
  37 #include &quot;DFGClobberize.h&quot;
  38 #include &quot;DFGCombinedLiveness.h&quot;
  39 #include &quot;DFGForAllKills.h&quot;
  40 #include &quot;DFGGraph.h&quot;
  41 #include &quot;DFGInsertionSet.h&quot;
  42 #include &quot;DFGLivenessAnalysisPhase.h&quot;
  43 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
  44 #include &quot;DFGPhase.h&quot;
  45 #include &quot;JSCInlines.h&quot;
  46 #include &lt;wtf/HashSet.h&gt;
  47 #include &lt;wtf/ListDump.h&gt;
  48 #include &lt;wtf/RecursableLambda.h&gt;
  49 
  50 namespace JSC { namespace DFG {
  51 
  52 namespace {
  53 
  54 namespace DFGArgumentsEliminationPhaseInternal {
<span class="line-modified">  55 static constexpr bool verbose = false;</span>
  56 }
  57 
  58 class ArgumentsEliminationPhase : public Phase {
  59 public:
  60     ArgumentsEliminationPhase(Graph&amp; graph)
  61         : Phase(graph, &quot;arguments elimination&quot;)
  62     {
  63     }
  64 
  65     bool run()
  66     {
  67         // For now this phase only works on SSA. This could be changed; we could have a block-local
  68         // version over LoadStore.
  69         DFG_ASSERT(m_graph, nullptr, m_graph.m_form == SSA);
  70 
  71         if (DFGArgumentsEliminationPhaseInternal::verbose) {
  72             dataLog(&quot;Graph before arguments elimination:\n&quot;);
  73             m_graph.dump();
  74         }
  75 
</pre>
<hr />
<pre>
 341                         } else
 342                             dontEscape = false;
 343 
 344                         if (!dontEscape)
 345                             escape(child, node);
 346                     }
 347 
 348                     break;
 349                 }
 350 
 351                 case Spread: {
 352                     bool isOK = node-&gt;child1().useKind() == ArrayUse &amp;&amp; (node-&gt;child1()-&gt;op() == CreateRest || node-&gt;child1()-&gt;op() == NewArrayBuffer);
 353                     if (!isOK)
 354                         escape(node-&gt;child1(), node);
 355                     break;
 356                 }
 357 
 358                 case NewArrayBuffer:
 359                     break;
 360 
<span class="line-added"> 361                 case VarargsLength:</span>
<span class="line-added"> 362                     break;</span>
<span class="line-added"> 363 </span>
 364                 case LoadVarargs:
<span class="line-modified"> 365                     if (node-&gt;loadVarargsData()-&gt;offset &amp;&amp; (node-&gt;argumentsChild()-&gt;op() == NewArrayWithSpread || node-&gt;argumentsChild()-&gt;op() == Spread || node-&gt;argumentsChild()-&gt;op() == NewArrayBuffer))</span>
<span class="line-modified"> 366                         escape(node-&gt;argumentsChild(), node);</span>
 367                     break;
 368 
 369                 case CallVarargs:
 370                 case ConstructVarargs:
 371                 case TailCallVarargs:
 372                 case TailCallVarargsInlinedCaller:
 373                     escape(node-&gt;child1(), node);
 374                     escape(node-&gt;child2(), node);
 375                     if (node-&gt;callVarargsData()-&gt;firstVarArgOffset &amp;&amp; (node-&gt;child3()-&gt;op() == NewArrayWithSpread || node-&gt;child3()-&gt;op() == Spread || node-&gt;child1()-&gt;op() == NewArrayBuffer))
 376                         escape(node-&gt;child3(), node);
 377                     break;
 378 
 379                 case Check:
 380                 case CheckVarargs:
 381                     m_graph.doToChildren(
 382                         node,
 383                         [&amp;] (Edge edge) {
 384                             if (edge.willNotHaveCheck())
 385                                 return;
 386 
 387                             if (alreadyChecked(edge.useKind(), SpecObject))
 388                                 return;
 389 
 390                             escape(edge, node);
 391                         });
 392                     break;
 393 
 394                 case MovHint:
 395                 case PutHint:
 396                     break;
 397 
 398                 case GetButterfly:
 399                     // This barely works. The danger is that the GetButterfly is used by something that
 400                     // does something escaping to a candidate. Fortunately, the only butterfly-using ops
 401                     // that we exempt here also use the candidate directly. If there ever was a
 402                     // butterfly-using op that we wanted to exempt, then we&#39;d have to look at the
 403                     // butterfly&#39;s child and check if it&#39;s a candidate.
 404                     break;
 405 
<span class="line-modified"> 406                 case FilterGetByStatus:</span>
 407                 case FilterPutByIdStatus:
 408                 case FilterCallLinkStatus:
 409                 case FilterInByIdStatus:
 410                     break;
 411 
<span class="line-added"> 412                 case CheckArrayOrEmpty:</span>
 413                 case CheckArray:
 414                     escapeBasedOnArrayMode(node-&gt;arrayMode(), node-&gt;child1(), node);
 415                     break;
 416 
 417                 case CheckStructureOrEmpty:
 418                 case CheckStructure: {
 419                     Node* target = node-&gt;child1().node();
 420                     if (!m_candidates.contains(target))
 421                         break;
 422 
 423                     Structure* structure = nullptr;
 424                     JSGlobalObject* globalObject = m_graph.globalObjectFor(target-&gt;origin.semantic);
 425                     switch (target-&gt;op()) {
 426                     case CreateDirectArguments:
 427                         structure = globalObject-&gt;directArgumentsStructure();
 428                         break;
 429                     case CreateClonedArguments:
 430                         structure = globalObject-&gt;clonedArgumentsStructure();
 431                         break;
 432                     case CreateRest:
</pre>
<hr />
<pre>
 480     void eliminateCandidatesThatInterfere()
 481     {
 482         performLivenessAnalysis(m_graph);
 483         performOSRAvailabilityAnalysis(m_graph);
 484         m_graph.initializeNodeOwners();
 485         CombinedLiveness combinedLiveness(m_graph);
 486 
 487         BlockMap&lt;Operands&lt;bool&gt;&gt; clobberedByBlock(m_graph);
 488         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 489             Operands&lt;bool&gt;&amp; clobberedByThisBlock = clobberedByBlock[block];
 490             clobberedByThisBlock = Operands&lt;bool&gt;(OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
 491             for (Node* node : *block) {
 492                 clobberize(
 493                     m_graph, node, NoOpClobberize(),
 494                     [&amp;] (AbstractHeap heap) {
 495                         if (heap.kind() != Stack) {
 496                             ASSERT(!heap.overlaps(Stack));
 497                             return;
 498                         }
 499                         ASSERT(!heap.payload().isTop());
<span class="line-modified"> 500                         Operand operand = heap.operand();</span>
 501                         // The register may not point to an argument or local, for example if we are looking at SetArgumentCountIncludingThis.
<span class="line-modified"> 502                         if (!operand.isHeader())</span>
<span class="line-modified"> 503                             clobberedByThisBlock.operand(operand) = true;</span>
 504                     },
 505                     NoOpClobberize());
 506             }
 507         }
 508 
 509         using InlineCallFrames = HashSet&lt;InlineCallFrame*, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt;;
 510         using InlineCallFramesForCanditates = HashMap&lt;Node*, InlineCallFrames&gt;;
 511         InlineCallFramesForCanditates inlineCallFramesForCandidate;
 512         auto forEachDependentNode = recursableLambda([&amp;](auto self, Node* node, const auto&amp; functor) -&gt; void {
 513             functor(node);
 514 
 515             if (node-&gt;op() == Spread) {
 516                 self(node-&gt;child1().node(), functor);
 517                 return;
 518             }
 519 
 520             if (node-&gt;op() == NewArrayWithSpread) {
 521                 BitVector* bitVector = node-&gt;bitVector();
 522                 for (unsigned i = node-&gt;numChildren(); i--; ) {
 523                     if (bitVector-&gt;get(i))
</pre>
<hr />
<pre>
 547                 }
 548             }
 549             if (!writesToStack)
 550                 continue;
 551 
 552             forAllKillsInBlock(
 553                 m_graph, combinedLiveness, block,
 554                 [&amp;] (unsigned nodeIndex, Node* candidate) {
 555                     if (!m_candidates.contains(candidate))
 556                         return;
 557 
 558                     for (InlineCallFrame* inlineCallFrame : inlineCallFramesForCandidate.get(candidate)) {
 559                         // Check if this block has any clobbers that affect this candidate. This is a fairly
 560                         // fast check.
 561                         bool isClobberedByBlock = false;
 562                         Operands&lt;bool&gt;&amp; clobberedByThisBlock = clobberedByBlock[block];
 563 
 564                         if (inlineCallFrame) {
 565                             if (inlineCallFrame-&gt;isVarargs()) {
 566                                 isClobberedByBlock |= clobberedByThisBlock.operand(
<span class="line-modified"> 567                                     VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis));</span>
 568                             }
 569 
 570                             if (!isClobberedByBlock || inlineCallFrame-&gt;isClosureCall) {
 571                                 isClobberedByBlock |= clobberedByThisBlock.operand(
<span class="line-modified"> 572                                     VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee));</span>
 573                             }
 574 
 575                             if (!isClobberedByBlock) {
<span class="line-modified"> 576                                 for (unsigned i = 0; i &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1); ++i) {</span>
 577                                     VirtualRegister reg =
 578                                         VirtualRegister(inlineCallFrame-&gt;stackOffset) +
 579                                         CallFrame::argumentOffset(i);
 580                                     if (clobberedByThisBlock.operand(reg)) {
 581                                         isClobberedByBlock = true;
 582                                         break;
 583                                     }
 584                                 }
 585                             }
 586                         } else {
 587                             // We don&#39;t include the ArgumentCount or Callee in this case because we can be
 588                             // damn sure that this won&#39;t be clobbered.
 589                             for (unsigned i = 1; i &lt; static_cast&lt;unsigned&gt;(codeBlock()-&gt;numParameters()); ++i) {
 590                                 if (clobberedByThisBlock.argument(i)) {
 591                                     isClobberedByBlock = true;
 592                                     break;
 593                                 }
 594                             }
 595                         }
 596 
</pre>
<hr />
<pre>
 614                         // yet to be processed. Inside the look, it refers to the index
 615                         // of the current node to process (after we decrement it).
 616                         //
 617                         // If the remaining number of nodes is 0, we should not decrement nodeIndex.
 618                         // Hence, we must only decrement nodeIndex inside the while loop instead of
 619                         // in its condition statement. Note that this while loop is embedded in an
 620                         // outer for loop. If we decrement nodeIndex in the condition statement, a
 621                         // nodeIndex of 0 will become UINT_MAX, and the outer loop will wrongly
 622                         // treat this as there being UINT_MAX remaining nodes to process.
 623                         while (nodeIndex) {
 624                             --nodeIndex;
 625                             Node* node = block-&gt;at(nodeIndex);
 626                             if (node == candidate)
 627                                 break;
 628 
 629                             bool found = false;
 630                             clobberize(
 631                                 m_graph, node, NoOpClobberize(),
 632                                 [&amp;] (AbstractHeap heap) {
 633                                     if (heap.kind() == Stack &amp;&amp; !heap.payload().isTop()) {
<span class="line-modified"> 634                                         if (argumentsInvolveStackSlot(inlineCallFrame, heap.operand()))</span>
 635                                             found = true;
 636                                         return;
 637                                     }
 638                                     if (heap.overlaps(Stack))
 639                                         found = true;
 640                                 },
 641                                 NoOpClobberize());
 642 
 643                             if (found) {
 644                                 if (DFGArgumentsEliminationPhaseInternal::verbose)
 645                                     dataLog(&quot;eliminating candidate: &quot;, candidate, &quot; because it is clobbered by &quot;, block-&gt;at(nodeIndex), &quot;\n&quot;);
 646                                 transitivelyRemoveCandidate(candidate);
 647                                 return;
 648                             }
 649                         }
 650                     }
 651                 });
 652         }
 653 
 654         // Q: How do we handle OSR exit with a live PhantomArguments at a point where the inline call
</pre>
<hr />
<pre>
 739 
 740                     node-&gt;setOpAndDefaultFlags(PhantomNewArrayWithSpread);
 741                     break;
 742 
 743                 case NewArrayBuffer:
 744                     if (!m_candidates.contains(node))
 745                         break;
 746 
 747                     node-&gt;setOpAndDefaultFlags(PhantomNewArrayBuffer);
 748                     node-&gt;child1() = Edge(insertionSet.insertConstant(nodeIndex, node-&gt;origin, node-&gt;cellOperand()));
 749                     break;
 750 
 751                 case GetFromArguments: {
 752                     Node* candidate = node-&gt;child1().node();
 753                     if (!isEliminatedAllocation(candidate))
 754                         break;
 755 
 756                     DFG_ASSERT(
 757                         m_graph, node, node-&gt;child1()-&gt;op() == PhantomDirectArguments, node-&gt;child1()-&gt;op());
 758                     VirtualRegister reg =
<span class="line-modified"> 759                         virtualRegisterForArgumentIncludingThis(node-&gt;capturedArgumentsOffset().offset() + 1) +</span>
 760                         node-&gt;origin.semantic.stackOffset();
 761                     StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 762                     node-&gt;convertToGetStack(data);
 763                     break;
 764                 }
 765 
 766                 case GetByOffset: {
 767                     Node* candidate = node-&gt;child2().node();
 768                     if (!isEliminatedAllocation(candidate))
 769                         break;
 770 
 771                     ASSERT(candidate-&gt;op() == PhantomClonedArguments);
 772                     ASSERT(node-&gt;storageAccessData().offset == clonedArgumentsLengthPropertyOffset);
 773 
 774                     // Meh, this is kind of hackish - we use an Identity so that we can reuse the
 775                     // getArrayLength() helper.
 776                     node-&gt;convertToIdentityOn(getArrayLength(candidate));
 777                     break;
 778                 }
 779 
</pre>
<hr />
<pre>
 793                     // often implicitly part of GetMyArgumentByVal. B3 will probably eliminate the
 794                     // second bounds check, but still - that&#39;s just silly.
 795                     // https://bugs.webkit.org/show_bug.cgi?id=143076
 796 
 797                     Node* candidate = m_graph.varArgChild(node, 0).node();
 798                     if (!isEliminatedAllocation(candidate))
 799                         break;
 800 
 801                     unsigned numberOfArgumentsToSkip = 0;
 802                     if (candidate-&gt;op() == PhantomCreateRest)
 803                         numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
 804 
 805                     Node* result = nullptr;
 806                     if (m_graph.varArgChild(node, 1)-&gt;isInt32Constant()) {
 807                         unsigned index = m_graph.varArgChild(node, 1)-&gt;asUInt32();
 808                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
 809                         index += numberOfArgumentsToSkip;
 810 
 811                         bool safeToGetStack = index &gt;= numberOfArgumentsToSkip;
 812                         if (inlineCallFrame)
<span class="line-modified"> 813                             safeToGetStack &amp;= index &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
 814                         else {
 815                             safeToGetStack &amp;=
 816                                 index &lt; static_cast&lt;unsigned&gt;(codeBlock()-&gt;numParameters()) - 1;
 817                         }
 818                         if (safeToGetStack) {
 819                             StackAccessData* data;
<span class="line-modified"> 820                             VirtualRegister arg = virtualRegisterForArgumentIncludingThis(index + 1);</span>
 821                             if (inlineCallFrame)
 822                                 arg += inlineCallFrame-&gt;stackOffset;
 823                             data = m_graph.m_stackAccessData.add(arg, FlushedJSValue);
 824 
 825                             Node* check = nullptr;
 826                             if (!inlineCallFrame || inlineCallFrame-&gt;isVarargs()) {
 827                                 check = insertionSet.insertNode(
 828                                     nodeIndex, SpecNone, CheckInBounds, node-&gt;origin,
 829                                     m_graph.varArgChild(node, 1), Edge(getArrayLength(candidate), Int32Use));
 830                             }
 831 
 832                             result = insertionSet.insertNode(
 833                                 nodeIndex, node-&gt;prediction(), GetStack, node-&gt;origin, OpInfo(data), Edge(check, UntypedUse));
 834                         }
 835                     }
 836 
 837                     if (!result) {
 838                         NodeType op;
 839                         if (node-&gt;arrayMode().isInBounds())
 840                             op = GetMyArgumentByVal;
 841                         else
 842                             op = GetMyArgumentByValOutOfBounds;
 843                         result = insertionSet.insertNode(
 844                             nodeIndex, node-&gt;prediction(), op, node-&gt;origin, OpInfo(numberOfArgumentsToSkip),
 845                             m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1));
 846                     }
 847 
 848                     // Need to do this because we may have a data format conversion here.
 849                     node-&gt;convertToIdentityOn(result);
 850                     break;
 851                 }
 852 
<span class="line-added"> 853                 case VarargsLength: {</span>
<span class="line-added"> 854                     Node* candidate = node-&gt;argumentsChild().node();</span>
<span class="line-added"> 855                     if (!isEliminatedAllocation(candidate))</span>
<span class="line-added"> 856                         break;</span>
<span class="line-added"> 857 </span>
<span class="line-added"> 858                     // VarargsLength can exit, so it better be exitOK.</span>
<span class="line-added"> 859                     DFG_ASSERT(m_graph, node, node-&gt;origin.exitOK);</span>
<span class="line-added"> 860                     NodeOrigin origin = node-&gt;origin.withExitOK(true);</span>
<span class="line-added"> 861 </span>
<span class="line-added"> 862 </span>
<span class="line-added"> 863                     node-&gt;convertToIdentityOn(emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, origin, /* addThis = */ true));</span>
<span class="line-added"> 864                     break;</span>
<span class="line-added"> 865                 }</span>
<span class="line-added"> 866 </span>
 867                 case LoadVarargs: {
<span class="line-modified"> 868                     Node* candidate = node-&gt;argumentsChild().node();</span>
 869                     if (!isEliminatedAllocation(candidate))
 870                         break;
 871 
 872                     // LoadVarargs can exit, so it better be exitOK.
 873                     DFG_ASSERT(m_graph, node, node-&gt;origin.exitOK);
 874                     bool canExit = true;
 875                     LoadVarargsData* varargsData = node-&gt;loadVarargsData();
 876 
 877                     auto storeArgumentCountIncludingThis = [&amp;] (unsigned argumentCountIncludingThis) {
 878                         Node* argumentCountIncludingThisNode = insertionSet.insertConstant(
 879                             nodeIndex, node-&gt;origin.withExitOK(canExit),
 880                             jsNumber(argumentCountIncludingThis));
 881                         insertionSet.insertNode(
 882                             nodeIndex, SpecNone, KillStack, node-&gt;origin.takeValidExit(canExit),
<span class="line-modified"> 883                             OpInfo(varargsData-&gt;count));</span>
 884                         insertionSet.insertNode(
 885                             nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
<span class="line-modified"> 886                             OpInfo(varargsData-&gt;count), Edge(argumentCountIncludingThisNode));</span>
 887                         insertionSet.insertNode(
 888                             nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
 889                             OpInfo(m_graph.m_stackAccessData.add(varargsData-&gt;count, FlushedInt32)),
 890                             Edge(argumentCountIncludingThisNode, KnownInt32Use));
 891                     };
 892 
 893                     auto storeValue = [&amp;] (Node* value, unsigned storeIndex) {
 894                         VirtualRegister reg = varargsData-&gt;start + storeIndex;
<span class="line-added"> 895                         ASSERT(reg.isLocal());</span>
 896                         StackAccessData* data =
 897                             m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 898 
 899                         insertionSet.insertNode(
<span class="line-modified"> 900                             nodeIndex, SpecNone, KillStack, node-&gt;origin.takeValidExit(canExit), OpInfo(reg));</span>
 901                         insertionSet.insertNode(
 902                             nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
<span class="line-modified"> 903                             OpInfo(reg), Edge(value));</span>
 904                         insertionSet.insertNode(
 905                             nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
 906                             OpInfo(data), Edge(value));
 907                     };
 908 
 909                     if (candidate-&gt;op() == PhantomNewArrayWithSpread || candidate-&gt;op() == PhantomNewArrayBuffer || candidate-&gt;op() == PhantomSpread) {
 910                         auto canConvertToStaticLoadStores = recursableLambda([&amp;] (auto self, Node* candidate) -&gt; bool {
 911                             if (candidate-&gt;op() == PhantomSpread)
 912                                 return self(candidate-&gt;child1().node());
 913 
 914                             if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 915                                 BitVector* bitVector = candidate-&gt;bitVector();
 916                                 for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 917                                     if (bitVector-&gt;get(i)) {
 918                                         if (!self(m_graph.varArgChild(candidate, i).node()))
 919                                             return false;
 920                                     }
 921                                 }
 922                                 return true;
 923                             }
</pre>
<hr />
<pre>
 937                                     return self(candidate-&gt;child1().node());
 938 
 939                                 if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 940                                     BitVector* bitVector = candidate-&gt;bitVector();
 941                                     unsigned result = 0;
 942                                     for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 943                                         if (bitVector-&gt;get(i))
 944                                             result += self(m_graph.varArgChild(candidate, i).node());
 945                                         else
 946                                             ++result;
 947                                     }
 948                                     return result;
 949                                 }
 950 
 951                                 if (candidate-&gt;op() == PhantomNewArrayBuffer)
 952                                     return candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 953 
 954                                 ASSERT(candidate-&gt;op() == PhantomCreateRest);
 955                                 unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
 956                                 InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
<span class="line-modified"> 957                                 unsigned frameArgumentCount = static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
 958                                 if (frameArgumentCount &gt;= numberOfArgumentsToSkip)
 959                                     return frameArgumentCount - numberOfArgumentsToSkip;
 960                                 return 0;
 961                             });
 962 
 963                             unsigned argumentCountIncludingThis = 1 + countNumberOfArguments(candidate); // |this|
 964                             if (argumentCountIncludingThis &lt;= varargsData-&gt;limit) {
 965                                 storeArgumentCountIncludingThis(argumentCountIncludingThis);
 966 
 967                                 DFG_ASSERT(m_graph, node, varargsData-&gt;limit - 1 &gt;= varargsData-&gt;mandatoryMinimum, varargsData-&gt;limit, varargsData-&gt;mandatoryMinimum);
 968                                 // Define our limit to exclude &quot;this&quot;, since that&#39;s a bit easier to reason about.
 969                                 unsigned limit = varargsData-&gt;limit - 1;
 970 
 971                                 auto forwardNode = recursableLambda([&amp;](auto self, Node* candidate, unsigned storeIndex) -&gt; unsigned {
 972                                     if (candidate-&gt;op() == PhantomSpread)
 973                                         return self(candidate-&gt;child1().node(), storeIndex);
 974 
 975                                     if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 976                                         BitVector* bitVector = candidate-&gt;bitVector();
 977                                         for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
</pre>
<hr />
<pre>
 985                                         return storeIndex;
 986                                     }
 987 
 988                                     if (candidate-&gt;op() == PhantomNewArrayBuffer) {
 989                                         auto* array = candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 990                                         for (unsigned index = 0; index &lt; array-&gt;length(); ++index) {
 991                                             JSValue constant;
 992                                             if (candidate-&gt;indexingType() == ArrayWithDouble)
 993                                                 constant = jsDoubleNumber(array-&gt;get(index).asNumber());
 994                                             else
 995                                                 constant = array-&gt;get(index);
 996                                             Node* value = insertionSet.insertConstant(nodeIndex, node-&gt;origin.withExitOK(canExit), constant);
 997                                             storeValue(value, storeIndex++);
 998                                         }
 999                                         return storeIndex;
1000                                     }
1001 
1002                                     ASSERT(candidate-&gt;op() == PhantomCreateRest);
1003                                     unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1004                                     InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
<span class="line-modified">1005                                     unsigned frameArgumentCount = static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
1006                                     for (unsigned loadIndex = numberOfArgumentsToSkip; loadIndex &lt; frameArgumentCount; ++loadIndex) {
<span class="line-modified">1007                                         VirtualRegister reg = virtualRegisterForArgumentIncludingThis(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;</span>
1008                                         StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
1009                                         Node* value = insertionSet.insertNode(
1010                                             nodeIndex, SpecNone, GetStack, node-&gt;origin.withExitOK(canExit),
1011                                             OpInfo(data));
1012                                         storeValue(value, storeIndex++);
1013                                     }
1014                                     return storeIndex;
1015                                 });
1016 
1017                                 unsigned storeIndex = forwardNode(candidate, 0);
1018                                 RELEASE_ASSERT(storeIndex &lt;= limit);
1019                                 Node* undefined = nullptr;
1020                                 for (; storeIndex &lt; limit; ++storeIndex) {
1021                                     if (!undefined) {
1022                                         undefined = insertionSet.insertConstant(
1023                                             nodeIndex, node-&gt;origin.withExitOK(canExit), jsUndefined());
1024                                     }
1025                                     storeValue(undefined, storeIndex);
1026                                 }
1027 
1028                                 node-&gt;remove(m_graph);
1029                                 node-&gt;origin.exitOK = canExit;
1030                                 break;
1031                             }
1032                         }
1033                     } else {
1034                         unsigned numberOfArgumentsToSkip = 0;
1035                         if (candidate-&gt;op() == PhantomCreateRest)
1036                             numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1037                         varargsData-&gt;offset += numberOfArgumentsToSkip;
1038 
1039                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
1040 
<span class="line-modified">1041                         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {</span>


1042                             unsigned argumentCountIncludingThis = inlineCallFrame-&gt;argumentCountIncludingThis;
1043                             if (argumentCountIncludingThis &gt; varargsData-&gt;offset)
1044                                 argumentCountIncludingThis -= varargsData-&gt;offset;
1045                             else
1046                                 argumentCountIncludingThis = 1;
1047                             RELEASE_ASSERT(argumentCountIncludingThis &gt;= 1);
1048 
1049                             if (argumentCountIncludingThis &lt;= varargsData-&gt;limit) {

1050                                 storeArgumentCountIncludingThis(argumentCountIncludingThis);
1051 
1052                                 DFG_ASSERT(m_graph, node, varargsData-&gt;limit - 1 &gt;= varargsData-&gt;mandatoryMinimum, varargsData-&gt;limit, varargsData-&gt;mandatoryMinimum);
1053                                 // Define our limit to exclude &quot;this&quot;, since that&#39;s a bit easier to reason about.
1054                                 unsigned limit = varargsData-&gt;limit - 1;
1055                                 Node* undefined = nullptr;
1056                                 for (unsigned storeIndex = 0; storeIndex &lt; limit; ++storeIndex) {
1057                                     // First determine if we have an element we can load, and load it if
1058                                     // possible.
1059 
1060                                     Node* value = nullptr;
1061                                     unsigned loadIndex = storeIndex + varargsData-&gt;offset;
1062 
1063                                     if (loadIndex + 1 &lt; inlineCallFrame-&gt;argumentCountIncludingThis) {
<span class="line-modified">1064                                         VirtualRegister reg = virtualRegisterForArgumentIncludingThis(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;</span>
1065                                         StackAccessData* data = m_graph.m_stackAccessData.add(
1066                                             reg, FlushedJSValue);
1067 
1068                                         value = insertionSet.insertNode(
1069                                             nodeIndex, SpecNone, GetStack, node-&gt;origin.withExitOK(canExit),
1070                                             OpInfo(data));
1071                                     } else {
1072                                         // FIXME: We shouldn&#39;t have to store anything if
1073                                         // storeIndex &gt;= varargsData-&gt;mandatoryMinimum, but we will still
1074                                         // have GetStacks in that range. So if we don&#39;t do the stores, we&#39;ll
1075                                         // have degenerate IR: we&#39;ll have GetStacks of something that didn&#39;t
1076                                         // have PutStacks.
1077                                         // https://bugs.webkit.org/show_bug.cgi?id=147434
1078 
1079                                         if (!undefined) {
1080                                             undefined = insertionSet.insertConstant(
1081                                                 nodeIndex, node-&gt;origin.withExitOK(canExit), jsUndefined());
1082                                         }
1083                                         value = undefined;
1084                                     }
</pre>
<hr />
<pre>
1200 
1201                                 if (candidate-&gt;op() == PhantomNewArrayBuffer) {
1202                                     bool canExit = true;
1203                                     auto* array = candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
1204                                     for (unsigned index = 0; index &lt; array-&gt;length(); ++index) {
1205                                         JSValue constant;
1206                                         if (candidate-&gt;indexingType() == ArrayWithDouble)
1207                                             constant = jsDoubleNumber(array-&gt;get(index).asNumber());
1208                                         else
1209                                             constant = array-&gt;get(index);
1210                                         arguments.append(insertionSet.insertConstant(nodeIndex, node-&gt;origin.withExitOK(canExit), constant));
1211                                     }
1212                                     return;
1213                                 }
1214 
1215                                 ASSERT(candidate-&gt;op() == PhantomCreateRest);
1216                                 InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
1217                                 unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1218                                 for (unsigned i = 1 + numberOfArgumentsToSkip; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
1219                                     StackAccessData* data = m_graph.m_stackAccessData.add(
<span class="line-modified">1220                                         virtualRegisterForArgumentIncludingThis(i) + inlineCallFrame-&gt;stackOffset,</span>
1221                                         FlushedJSValue);
1222 
1223                                     Node* value = insertionSet.insertNode(
1224                                         nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
1225 
1226                                     arguments.append(value);
1227                                 }
1228                             });
1229 
1230                             appendNode(candidate);
1231                             convertToStaticArgumentCountCall(arguments);
1232                         } else
1233                             convertToForwardsCall();
1234                     } else {
1235                         unsigned numberOfArgumentsToSkip = 0;
1236                         if (candidate-&gt;op() == PhantomCreateRest)
1237                             numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1238                         CallVarargsData* varargsData = node-&gt;callVarargsData();
1239                         varargsData-&gt;firstVarArgOffset += numberOfArgumentsToSkip;
1240 
1241                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
1242                         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
1243                             Vector&lt;Node*&gt; arguments;
1244                             for (unsigned i = 1 + varargsData-&gt;firstVarArgOffset; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
1245                                 StackAccessData* data = m_graph.m_stackAccessData.add(
<span class="line-modified">1246                                     virtualRegisterForArgumentIncludingThis(i) + inlineCallFrame-&gt;stackOffset,</span>
1247                                     FlushedJSValue);
1248 
1249                                 Node* value = insertionSet.insertNode(
1250                                     nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
1251 
1252                                 arguments.append(value);
1253                             }
1254 
1255                             convertToStaticArgumentCountCall(arguments);
1256                         } else
1257                             convertToForwardsCall();
1258                     }
1259 
1260                     break;
1261                 }
1262 
<span class="line-added">1263                 case CheckArrayOrEmpty:</span>
1264                 case CheckArray:
1265                 case GetButterfly:
<span class="line-modified">1266                 case FilterGetByStatus:</span>
1267                 case FilterPutByIdStatus:
1268                 case FilterCallLinkStatus:
1269                 case FilterInByIdStatus: {
1270                     if (!isEliminatedAllocation(node-&gt;child1().node()))
1271                         break;
1272                     node-&gt;remove(m_graph);
1273                     break;
1274                 }
1275 
1276                 case CheckStructureOrEmpty:
1277                 case CheckStructure:
1278                     if (!isEliminatedAllocation(node-&gt;child1().node()))
1279                         break;
1280                     node-&gt;child1() = Edge(); // Remove the cell check since we&#39;ve proven it&#39;s not needed and FTL lowering might botch this.
1281                     node-&gt;remove(m_graph);
1282                     break;
1283 
1284                 default:
1285                     break;
1286                 }
</pre>
</td>
</tr>
</table>
<center><a href="DFGArgumentPosition.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArgumentsUtilities.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/Timer.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/Timer.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/Timer.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/Timer.cpp
@@ -29,17 +29,16 @@
 
 #include "RuntimeApplicationChecks.h"
 #include "SharedTimer.h"
 #include "ThreadGlobalData.h"
 #include "ThreadTimers.h"
-#include <limits.h>
 #include <limits>
 #include <math.h>
 #include <wtf/MainThread.h>
 #include <wtf/Vector.h>
 
-#if PLATFORM(IOS_FAMILY) || PLATFORM(MAC)
+#if PLATFORM(COCOA)
 #include <wtf/spi/darwin/dyldSPI.h>
 #endif
 
 namespace WebCore {
 
@@ -48,11 +47,11 @@
 // Timers are stored in a heap data structure, used to implement a priority queue.
 // This allows us to efficiently determine which timer needs to fire the soonest.
 // Then we set a single shared system timer to fire at that time.
 //
 // When a timer's "next fire time" changes, we need to move it around in the priority queue.
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 static ThreadTimerHeap& threadGlobalTimerHeap()
 {
     return threadGlobalData().threadTimers().timerHeap();
 }
 #endif
@@ -257,30 +256,30 @@
 {
 }
 
 TimerBase::~TimerBase()
 {
-    ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));
-    RELEASE_ASSERT(canAccessThreadLocalDataForThread(m_thread.get()) || shouldSuppressThreadSafetyCheck());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));
+    RELEASE_ASSERT(canCurrentThreadAccessThreadLocalData(m_thread) || shouldSuppressThreadSafetyCheck());
     stop();
     ASSERT(!inHeap());
     if (m_heapItem)
         m_heapItem->clearTimer();
     m_unalignedNextFireTime = MonotonicTime::nan();
 }
 
 void TimerBase::start(Seconds nextFireInterval, Seconds repeatInterval)
 {
-    ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));
 
     m_repeatInterval = repeatInterval;
     setNextFireTime(MonotonicTime::now() + nextFireInterval);
 }
 
 void TimerBase::stop()
 {
-    ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));
 
     m_repeatInterval = 0_s;
     setNextFireTime(MonotonicTime { });
 
     ASSERT(!static_cast<bool>(nextFireTime()));
@@ -299,11 +298,11 @@
     return fireTime - current;
 }
 
 inline void TimerBase::checkHeapIndex() const
 {
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     ASSERT(m_heapItem);
     auto& heap = m_heapItem->timerHeap();
     ASSERT(&heap == &threadGlobalTimerHeap());
     ASSERT(!heap.isEmpty());
     ASSERT(m_heapItem->isInHeap());
@@ -433,11 +432,11 @@
 {
     auto fireTime = nextFireTime();
     if (fireTime && hasValidHeapPosition())
         return;
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     Optional<unsigned> oldHeapIndex;
     if (m_heapItem->isInHeap())
         oldHeapIndex = m_heapItem->heapIndex();
 #endif
 
@@ -448,11 +447,11 @@
     else if (fireTime < oldTime)
         heapDecreaseKey();
     else
         heapIncreaseKey();
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     Optional<unsigned> newHeapIndex;
     if (m_heapItem->isInHeap())
         newHeapIndex = m_heapItem->heapIndex();
     ASSERT(newHeapIndex != oldHeapIndex);
 #endif
@@ -460,12 +459,12 @@
     ASSERT(!inHeap() || hasValidHeapPosition());
 }
 
 void TimerBase::setNextFireTime(MonotonicTime newTime)
 {
-    ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));
-    RELEASE_ASSERT(canAccessThreadLocalDataForThread(m_thread.get()) || shouldSuppressThreadSafetyCheck());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));
+    RELEASE_ASSERT(canCurrentThreadAccessThreadLocalData(m_thread) || shouldSuppressThreadSafetyCheck());
     bool timerHasBeenDeleted = std::isnan(m_unalignedNextFireTime);
     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!timerHasBeenDeleted);
 
     if (m_unalignedNextFireTime != newTime) {
         RELEASE_ASSERT(!std::isnan(newTime));
@@ -479,13 +478,11 @@
         if (auto newAlignedTime = alignedFireTime(newTime))
             newTime = newAlignedTime.value();
     }
 
     if (oldTime != newTime) {
-        // FIXME: This should be part of ThreadTimers, or another per-thread structure.
-        static std::atomic<unsigned> currentHeapInsertionOrder;
-        auto newOrder = currentHeapInsertionOrder++;
+        auto newOrder = threadGlobalData().threadTimers().nextHeapInsertionCount();
 
         if (!m_heapItem)
             m_heapItem = ThreadTimerHeapItem::create(*this, newTime, 0);
         m_heapItem->time = newTime;
         m_heapItem->insertionOrder = newOrder;

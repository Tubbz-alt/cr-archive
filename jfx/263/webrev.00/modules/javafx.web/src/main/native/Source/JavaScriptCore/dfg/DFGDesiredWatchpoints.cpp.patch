diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGDesiredWatchpoints.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGDesiredWatchpoints.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGDesiredWatchpoints.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGDesiredWatchpoints.cpp
@@ -26,57 +26,80 @@
 #include "config.h"
 #include "DFGDesiredWatchpoints.h"
 
 #if ENABLE(DFG_JIT)
 
-#include "ArrayBufferNeuteringWatchpointSet.h"
 #include "CodeBlock.h"
 #include "DFGGraph.h"
 #include "JSCInlines.h"
 
 namespace JSC { namespace DFG {
 
 void ArrayBufferViewWatchpointAdaptor::add(
     CodeBlock* codeBlock, JSArrayBufferView* view, CommonData& common)
 {
-    VM& vm = codeBlock->vm();
-    Watchpoint* watchpoint = common.watchpoints.add(codeBlock);
-    ArrayBufferNeuteringWatchpointSet* neuteringWatchpoint =
-        ArrayBufferNeuteringWatchpointSet::create(vm);
-    neuteringWatchpoint->set().add(watchpoint);
-    codeBlock->addConstant(neuteringWatchpoint);
+    // view is already frozen. If it is deallocated, jettisoning happens.
+    CodeBlockJettisoningWatchpoint* watchpoint = nullptr;
+    {
+        ConcurrentJSLocker locker(codeBlock->m_lock);
+        watchpoint = common.watchpoints.add(codeBlock);
+    }
+    ArrayBuffer* arrayBuffer = view->possiblySharedBuffer();
+    RELEASE_ASSERT(arrayBuffer);
     // FIXME: We don't need to set this watchpoint at all for shared buffers.
     // https://bugs.webkit.org/show_bug.cgi?id=164108
-    vm.heap.addReference(neuteringWatchpoint, view->possiblySharedBuffer());
+    arrayBuffer->neuteringWatchpointSet().add(WTFMove(watchpoint));
 }
 
 void SymbolTableAdaptor::add(
     CodeBlock* codeBlock, SymbolTable* symbolTable, CommonData& common)
 {
-    codeBlock->addConstant(symbolTable); // For common users, it doesn't really matter if it's weak or not. If references to it go away, we go away, too.
-    symbolTable->singleton().add(common.watchpoints.add(codeBlock));
+    codeBlock->addConstant(ConcurrentJSLocker(codeBlock->m_lock), symbolTable); // For common users, it doesn't really matter if it's weak or not. If references to it go away, we go away, too.
+    CodeBlockJettisoningWatchpoint* watchpoint = nullptr;
+    {
+        ConcurrentJSLocker locker(codeBlock->m_lock);
+        watchpoint = common.watchpoints.add(codeBlock);
+    }
+    symbolTable->singleton().add(WTFMove(watchpoint));
 }
 
 void FunctionExecutableAdaptor::add(
     CodeBlock* codeBlock, FunctionExecutable* executable, CommonData& common)
 {
-    codeBlock->addConstant(executable); // For common users, it doesn't really matter if it's weak or not. If references to it go away, we go away, too.
-    executable->singleton().add(common.watchpoints.add(codeBlock));
+    codeBlock->addConstant(ConcurrentJSLocker(codeBlock->m_lock), executable); // For common users, it doesn't really matter if it's weak or not. If references to it go away, we go away, too.
+    CodeBlockJettisoningWatchpoint* watchpoint = nullptr;
+    {
+        ConcurrentJSLocker locker(codeBlock->m_lock);
+        watchpoint = common.watchpoints.add(codeBlock);
+    }
+    executable->singleton().add(WTFMove(watchpoint));
 }
 
 void AdaptiveStructureWatchpointAdaptor::add(
     CodeBlock* codeBlock, const ObjectPropertyCondition& key, CommonData& common)
 {
     VM& vm = codeBlock->vm();
     switch (key.kind()) {
-    case PropertyCondition::Equivalence:
-        common.adaptiveInferredPropertyValueWatchpoints.add(key, codeBlock)->install(vm);
+    case PropertyCondition::Equivalence: {
+        AdaptiveInferredPropertyValueWatchpoint* watchpoint = nullptr;
+        {
+            ConcurrentJSLocker locker(codeBlock->m_lock);
+            watchpoint = common.adaptiveInferredPropertyValueWatchpoints.add(key, codeBlock);
+        }
+        watchpoint->install(vm);
         break;
-    default:
-        common.adaptiveStructureWatchpoints.add(key, codeBlock)->install(vm);
+    }
+    default: {
+        AdaptiveStructureWatchpoint* watchpoint = nullptr;
+        {
+            ConcurrentJSLocker locker(codeBlock->m_lock);
+            watchpoint = common.adaptiveStructureWatchpoints.add(key, codeBlock);
+        }
+        watchpoint->install(vm);
         break;
     }
+    }
 }
 
 DesiredWatchpoints::DesiredWatchpoints() { }
 DesiredWatchpoints::~DesiredWatchpoints() { }
 

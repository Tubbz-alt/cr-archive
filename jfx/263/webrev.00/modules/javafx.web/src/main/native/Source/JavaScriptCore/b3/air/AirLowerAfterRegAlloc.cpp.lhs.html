<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirLowerAfterRegAlloc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AirLowerAfterRegAlloc.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;AirArgInlines.h&quot;
 32 #include &quot;AirCCallingConvention.h&quot;
 33 #include &quot;AirCode.h&quot;
 34 #include &quot;AirEmitShuffle.h&quot;
 35 #include &quot;AirInsertionSet.h&quot;
 36 #include &quot;AirInstInlines.h&quot;
 37 #include &quot;AirPadInterference.h&quot;
 38 #include &quot;AirRegLiveness.h&quot;
 39 #include &quot;AirPhaseScope.h&quot;
 40 #include &quot;B3CCallValue.h&quot;
 41 #include &quot;B3ValueInlines.h&quot;
 42 #include &quot;RegisterSet.h&quot;
 43 #include &lt;wtf/HashMap.h&gt;
 44 #include &lt;wtf/ListDump.h&gt;
 45 
 46 namespace JSC { namespace B3 { namespace Air {
 47 
 48 namespace {
 49 
 50 namespace AirLowerAfterRegAllocInternal {
<a name="2" id="anc2"></a><span class="line-modified"> 51 static const bool verbose = false;</span>
 52 }
 53 
 54 } // anonymous namespace
 55 
 56 void lowerAfterRegAlloc(Code&amp; code)
 57 {
 58     PhaseScope phaseScope(code, &quot;lowerAfterRegAlloc&quot;);
 59 
 60     if (AirLowerAfterRegAllocInternal::verbose)
 61         dataLog(&quot;Code before lowerAfterRegAlloc:\n&quot;, code);
 62 
 63     auto isRelevant = [] (Inst&amp; inst) -&gt; bool {
 64         return inst.kind.opcode == Shuffle || inst.kind.opcode == ColdCCall;
 65     };
 66 
 67     bool haveAnyRelevant = false;
 68     for (BasicBlock* block : code) {
 69         for (Inst&amp; inst : *block) {
 70             if (isRelevant(inst)) {
 71                 haveAnyRelevant = true;
 72                 break;
 73             }
 74         }
 75         if (haveAnyRelevant)
 76             break;
 77     }
 78     if (!haveAnyRelevant)
 79         return;
 80 
 81     padInterference(code);
 82 
 83     HashMap&lt;Inst*, RegisterSet&gt; usedRegisters;
 84 
 85     RegLiveness liveness(code);
 86     for (BasicBlock* block : code) {
 87         RegLiveness::LocalCalc localCalc(liveness, block);
 88 
 89         for (unsigned instIndex = block-&gt;size(); instIndex--;) {
 90             Inst&amp; inst = block-&gt;at(instIndex);
 91 
 92             RegisterSet set;
 93 
 94             if (isRelevant(inst)) {
 95                 for (Reg reg : localCalc.live())
 96                     set.set(reg);
 97             }
 98 
 99             localCalc.execute(instIndex);
100 
101             if (isRelevant(inst))
102                 usedRegisters.add(&amp;inst, set);
103         }
104     }
105 
106     std::array&lt;std::array&lt;StackSlot*, 2&gt;, numBanks&gt; slots;
107     forEachBank(
108         [&amp;] (Bank bank) {
109             for (unsigned i = 0; i &lt; 2; ++i)
110                 slots[bank][i] = nullptr;
111         });
112 
113     // If we run after stack allocation then we cannot use those callee saves that aren&#39;t in
114     // the callee save list. Note that we are only run after stack allocation in -O1, so this
115     // kind of slop is OK.
116     RegisterSet blacklistedCalleeSaves;
117     if (code.stackIsAllocated()) {
118         blacklistedCalleeSaves = RegisterSet::calleeSaveRegisters();
119         blacklistedCalleeSaves.exclude(code.calleeSaveRegisters());
120     }
121 
122     auto getScratches = [&amp;] (RegisterSet set, Bank bank) -&gt; std::array&lt;Arg, 2&gt; {
123         std::array&lt;Arg, 2&gt; result;
124         for (unsigned i = 0; i &lt; 2; ++i) {
125             bool found = false;
126             for (Reg reg : code.regsInPriorityOrder(bank)) {
127                 if (!set.get(reg) &amp;&amp; !blacklistedCalleeSaves.get(reg)) {
128                     result[i] = Tmp(reg);
129                     set.set(reg);
130                     found = true;
131                     break;
132                 }
133             }
134             if (!found) {
135                 StackSlot*&amp; slot = slots[bank][i];
136                 if (!slot)
137                     slot = code.addStackSlot(bytes(conservativeWidth(bank)), StackSlotKind::Spill);
138                 result[i] = Arg::stack(slots[bank][i]);
139             }
140         }
141         return result;
142     };
143 
144     // Now transform the code.
145     InsertionSet insertionSet(code);
146     for (BasicBlock* block : code) {
147         for (unsigned instIndex = 0; instIndex &lt; block-&gt;size(); ++instIndex) {
148             Inst&amp; inst = block-&gt;at(instIndex);
149 
150             switch (inst.kind.opcode) {
151             case Shuffle: {
152                 RegisterSet set = usedRegisters.get(&amp;inst);
153                 Vector&lt;ShufflePair&gt; pairs;
154                 for (unsigned i = 0; i &lt; inst.args.size(); i += 3) {
155                     Arg src = inst.args[i + 0];
156                     Arg dst = inst.args[i + 1];
157                     Width width = inst.args[i + 2].width();
158 
159                     // The used register set contains things live after the shuffle. But
160                     // emitShuffle() wants a scratch register that is not just dead but also does not
161                     // interfere with either sources or destinations.
162                     auto excludeRegisters = [&amp;] (Tmp tmp) {
163                         if (tmp.isReg())
164                             set.set(tmp.reg());
165                     };
166                     src.forEachTmpFast(excludeRegisters);
167                     dst.forEachTmpFast(excludeRegisters);
168 
169                     pairs.append(ShufflePair(src, dst, width));
170                 }
171                 std::array&lt;Arg, 2&gt; gpScratch = getScratches(set, GP);
172                 std::array&lt;Arg, 2&gt; fpScratch = getScratches(set, FP);
173                 insertionSet.insertInsts(
174                     instIndex, emitShuffle(code, pairs, gpScratch, fpScratch, inst.origin));
175                 inst = Inst();
176                 break;
177             }
178 
179             case ColdCCall: {
180                 CCallValue* value = inst.origin-&gt;as&lt;CCallValue&gt;();
181                 Kind oldKind = inst.kind;
182 
183                 RegisterSet liveRegs = usedRegisters.get(&amp;inst);
184                 RegisterSet regsToSave = liveRegs;
185                 regsToSave.exclude(RegisterSet::calleeSaveRegisters());
186                 regsToSave.exclude(RegisterSet::stackRegisters());
187                 regsToSave.exclude(RegisterSet::reservedHardwareRegisters());
188 
189                 RegisterSet preUsed = liveRegs;
190                 Vector&lt;Arg&gt; destinations = computeCCallingConvention(code, value);
191                 Tmp result = cCallResult(value-&gt;type());
192                 Arg originalResult = result ? inst.args[1] : Arg();
193 
194                 Vector&lt;ShufflePair&gt; pairs;
195                 for (unsigned i = 0; i &lt; destinations.size(); ++i) {
196                     Value* child = value-&gt;child(i);
197                     Arg src = inst.args[result ? (i &gt;= 1 ? i + 1 : i) : i ];
198                     Arg dst = destinations[i];
199                     Width width = widthForType(child-&gt;type());
200                     pairs.append(ShufflePair(src, dst, width));
201 
202                     auto excludeRegisters = [&amp;] (Tmp tmp) {
203                         if (tmp.isReg())
204                             preUsed.set(tmp.reg());
205                     };
206                     src.forEachTmpFast(excludeRegisters);
207                     dst.forEachTmpFast(excludeRegisters);
208                 }
209 
210                 std::array&lt;Arg, 2&gt; gpScratch = getScratches(preUsed, GP);
211                 std::array&lt;Arg, 2&gt; fpScratch = getScratches(preUsed, FP);
212 
213                 // Also need to save all live registers. Don&#39;t need to worry about the result
214                 // register.
215                 if (originalResult.isReg())
216                     regsToSave.clear(originalResult.reg());
217                 Vector&lt;StackSlot*&gt; stackSlots;
218                 regsToSave.forEach(
219                     [&amp;] (Reg reg) {
220                         Tmp tmp(reg);
221                         Arg arg(tmp);
222                         Width width = conservativeWidth(arg.bank());
223                         StackSlot* stackSlot =
224                             code.addStackSlot(bytes(width), StackSlotKind::Spill);
225                         pairs.append(ShufflePair(arg, Arg::stack(stackSlot), width));
226                         stackSlots.append(stackSlot);
227                     });
228 
229                 if (AirLowerAfterRegAllocInternal::verbose)
230                     dataLog(&quot;Pre-call pairs for &quot;, inst, &quot;: &quot;, listDump(pairs), &quot;\n&quot;);
231 
232                 insertionSet.insertInsts(
233                     instIndex, emitShuffle(code, pairs, gpScratch, fpScratch, inst.origin));
234 
235                 inst = buildCCall(code, inst.origin, destinations);
236                 if (oldKind.effects)
237                     inst.kind.effects = true;
238 
239                 // Now we need to emit code to restore registers.
240                 pairs.shrink(0);
241                 unsigned stackSlotIndex = 0;
242                 regsToSave.forEach(
243                     [&amp;] (Reg reg) {
244                         Tmp tmp(reg);
245                         Arg arg(tmp);
246                         Width width = conservativeWidth(arg.bank());
247                         StackSlot* stackSlot = stackSlots[stackSlotIndex++];
248                         pairs.append(ShufflePair(Arg::stack(stackSlot), arg, width));
249                     });
250                 if (result) {
251                     ShufflePair pair(result, originalResult, widthForType(value-&gt;type()));
252                     pairs.append(pair);
253                 }
254 
255                 // For finding scratch registers, we need to account for the possibility that
256                 // the result is dead.
257                 if (originalResult.isReg())
258                     liveRegs.set(originalResult.reg());
259 
260                 gpScratch = getScratches(liveRegs, GP);
261                 fpScratch = getScratches(liveRegs, FP);
262 
263                 insertionSet.insertInsts(
264                     instIndex + 1, emitShuffle(code, pairs, gpScratch, fpScratch, inst.origin));
265                 break;
266             }
267 
268             default:
269                 break;
270             }
271         }
272 
273         insertionSet.execute(block);
274 
275         block-&gt;insts().removeAllMatching(
276             [&amp;] (Inst&amp; inst) -&gt; bool {
277                 return !inst;
278             });
279     }
280 
281     if (AirLowerAfterRegAllocInternal::verbose)
282         dataLog(&quot;Code after lowerAfterRegAlloc:\n&quot;, code);
283 }
284 
285 } } } // namespace JSC::B3::Air
286 
287 #endif // ENABLE(B3_JIT)
288 
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
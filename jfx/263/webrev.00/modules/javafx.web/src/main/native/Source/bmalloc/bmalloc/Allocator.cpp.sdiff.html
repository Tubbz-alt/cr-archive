<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Allocator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AllIsoHeaps.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Allocator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Allocator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2014-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 33 #include &quot;Sizes.h&quot;
 34 #include &lt;algorithm&gt;
 35 #include &lt;cstdlib&gt;
 36 
 37 namespace bmalloc {
 38 
 39 Allocator::Allocator(Heap&amp; heap, Deallocator&amp; deallocator)
 40     : m_heap(heap)
 41     , m_deallocator(deallocator)
 42 {
 43     BASSERT(!Environment::get()-&gt;isDebugHeapEnabled());
 44     for (size_t sizeClass = 0; sizeClass &lt; sizeClassCount; ++sizeClass)
 45         m_bumpAllocators[sizeClass].init(objectSize(sizeClass));
 46 }
 47 
 48 Allocator::~Allocator()
 49 {
 50     scavenge();
 51 }
 52 
<span class="line-modified"> 53 void* Allocator::tryAllocate(size_t size)</span>
<span class="line-removed"> 54 {</span>
<span class="line-removed"> 55     if (size &lt;= smallMax)</span>
<span class="line-removed"> 56         return allocate(size);</span>
<span class="line-removed"> 57 </span>
<span class="line-removed"> 58     std::unique_lock&lt;Mutex&gt; lock(Heap::mutex());</span>
<span class="line-removed"> 59     return m_heap.tryAllocateLarge(lock, alignment, size);</span>
<span class="line-removed"> 60 }</span>
<span class="line-removed"> 61 </span>
<span class="line-removed"> 62 void* Allocator::allocate(size_t alignment, size_t size)</span>
<span class="line-removed"> 63 {</span>
<span class="line-removed"> 64     bool crashOnFailure = true;</span>
<span class="line-removed"> 65     return allocateImpl(alignment, size, crashOnFailure);</span>
<span class="line-removed"> 66 }</span>
<span class="line-removed"> 67 </span>
<span class="line-removed"> 68 void* Allocator::tryAllocate(size_t alignment, size_t size)</span>
<span class="line-removed"> 69 {</span>
<span class="line-removed"> 70     bool crashOnFailure = false;</span>
<span class="line-removed"> 71     return allocateImpl(alignment, size, crashOnFailure);</span>
<span class="line-removed"> 72 }</span>
<span class="line-removed"> 73 </span>
<span class="line-removed"> 74 void* Allocator::allocateImpl(size_t alignment, size_t size, bool crashOnFailure)</span>
 75 {
 76     BASSERT(isPowerOfTwo(alignment));
 77 
 78     if (!size)
 79         size = alignment;
 80 
 81     if (size &lt;= smallMax &amp;&amp; alignment &lt;= smallMax)
<span class="line-modified"> 82         return allocate(roundUpToMultipleOf(alignment, size));</span>
 83 
<span class="line-modified"> 84     std::unique_lock&lt;Mutex&gt; lock(Heap::mutex());</span>
<span class="line-removed"> 85     if (crashOnFailure)</span>
<span class="line-removed"> 86         return m_heap.allocateLarge(lock, alignment, size);</span>
<span class="line-removed"> 87     return m_heap.tryAllocateLarge(lock, alignment, size);</span>
 88 }
 89 
<span class="line-modified"> 90 void* Allocator::reallocate(void* object, size_t newSize)</span>
 91 {
<span class="line-modified"> 92     bool crashOnFailure = true;</span>
<span class="line-modified"> 93     return reallocateImpl(object, newSize, crashOnFailure);</span>
<span class="line-removed"> 94 }</span>
<span class="line-removed"> 95 </span>
<span class="line-removed"> 96 void* Allocator::tryReallocate(void* object, size_t newSize)</span>
<span class="line-removed"> 97 {</span>
<span class="line-removed"> 98     bool crashOnFailure = false;</span>
<span class="line-removed"> 99     return reallocateImpl(object, newSize, crashOnFailure);</span>
<span class="line-removed">100 }</span>
101 
<span class="line-removed">102 void* Allocator::reallocateImpl(void* object, size_t newSize, bool crashOnFailure)</span>
<span class="line-removed">103 {</span>
104     size_t oldSize = 0;
105     switch (objectType(m_heap, object)) {
106     case ObjectType::Small: {
<span class="line-removed">107         BASSERT(objectType(m_heap, nullptr) == ObjectType::Small);</span>
<span class="line-removed">108         if (!object)</span>
<span class="line-removed">109             break;</span>
<span class="line-removed">110 </span>
111         size_t sizeClass = Object(object).page()-&gt;sizeClass();
112         oldSize = objectSize(sizeClass);
113         break;
114     }
115     case ObjectType::Large: {
<span class="line-modified">116         std::unique_lock&lt;Mutex&gt; lock(Heap::mutex());</span>
117         oldSize = m_heap.largeSize(lock, object);
118 
119         if (newSize &lt; oldSize &amp;&amp; newSize &gt; smallMax) {
120             m_heap.shrinkLarge(lock, Range(object, oldSize), newSize);
121             return object;
122         }
123         break;
124     }
125     }
126 
127     void* result = nullptr;
<span class="line-modified">128     if (crashOnFailure)</span>
<span class="line-modified">129         result = allocate(newSize);</span>
<span class="line-modified">130     else {</span>
<span class="line-modified">131         result = tryAllocate(newSize);</span>
<span class="line-removed">132         if (!result)</span>
<span class="line-removed">133             return nullptr;</span>
134     }
135     size_t copySize = std::min(oldSize, newSize);
136     memcpy(result, object, copySize);
137     m_deallocator.deallocate(object);
138     return result;
139 }
140 
141 void Allocator::scavenge()
142 {
143     for (size_t sizeClass = 0; sizeClass &lt; sizeClassCount; ++sizeClass) {
144         BumpAllocator&amp; allocator = m_bumpAllocators[sizeClass];
145         BumpRangeCache&amp; bumpRangeCache = m_bumpRangeCaches[sizeClass];
146 
147         while (allocator.canAllocate())
148             m_deallocator.deallocate(allocator.allocate());
149 
150         while (bumpRangeCache.size()) {
151             allocator.refill(bumpRangeCache.pop());
152             while (allocator.canAllocate())
153                 m_deallocator.deallocate(allocator.allocate());
154         }
155 
156         allocator.clear();
157     }
158 }
159 
<span class="line-modified">160 BNO_INLINE void Allocator::refillAllocatorSlowCase(BumpAllocator&amp; allocator, size_t sizeClass)</span>
161 {
162     BumpRangeCache&amp; bumpRangeCache = m_bumpRangeCaches[sizeClass];
163 
<span class="line-modified">164     std::unique_lock&lt;Mutex&gt; lock(Heap::mutex());</span>
165     m_deallocator.processObjectLog(lock);
<span class="line-modified">166     m_heap.allocateSmallBumpRanges(lock, sizeClass, allocator, bumpRangeCache, m_deallocator.lineCache(lock));</span>
167 }
168 
<span class="line-modified">169 BINLINE void Allocator::refillAllocator(BumpAllocator&amp; allocator, size_t sizeClass)</span>
170 {
171     BumpRangeCache&amp; bumpRangeCache = m_bumpRangeCaches[sizeClass];
172     if (!bumpRangeCache.size())
<span class="line-modified">173         return refillAllocatorSlowCase(allocator, sizeClass);</span>
174     return allocator.refill(bumpRangeCache.pop());
175 }
176 
<span class="line-modified">177 BNO_INLINE void* Allocator::allocateLarge(size_t size)</span>
178 {
<span class="line-modified">179     std::unique_lock&lt;Mutex&gt; lock(Heap::mutex());</span>
<span class="line-modified">180     return m_heap.allocateLarge(lock, alignment, size);</span>
181 }
182 
<span class="line-modified">183 BNO_INLINE void* Allocator::allocateLogSizeClass(size_t size)</span>
184 {
185     size_t sizeClass = bmalloc::sizeClass(size);
186     BumpAllocator&amp; allocator = m_bumpAllocators[sizeClass];
187     if (!allocator.canAllocate())
<span class="line-modified">188         refillAllocator(allocator, sizeClass);</span>


189     return allocator.allocate();
190 }
191 
<span class="line-modified">192 void* Allocator::allocateSlowCase(size_t size)</span>
193 {
194     if (size &lt;= maskSizeClassMax) {
195         size_t sizeClass = bmalloc::maskSizeClass(size);
196         BumpAllocator&amp; allocator = m_bumpAllocators[sizeClass];
<span class="line-modified">197         refillAllocator(allocator, sizeClass);</span>


198         return allocator.allocate();
199     }
200 
201     if (size &lt;= smallMax)
<span class="line-modified">202         return allocateLogSizeClass(size);</span>
203 
<span class="line-modified">204     return allocateLarge(size);</span>
205 }
206 
207 } // namespace bmalloc
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 33 #include &quot;Sizes.h&quot;
 34 #include &lt;algorithm&gt;
 35 #include &lt;cstdlib&gt;
 36 
 37 namespace bmalloc {
 38 
 39 Allocator::Allocator(Heap&amp; heap, Deallocator&amp; deallocator)
 40     : m_heap(heap)
 41     , m_deallocator(deallocator)
 42 {
 43     BASSERT(!Environment::get()-&gt;isDebugHeapEnabled());
 44     for (size_t sizeClass = 0; sizeClass &lt; sizeClassCount; ++sizeClass)
 45         m_bumpAllocators[sizeClass].init(objectSize(sizeClass));
 46 }
 47 
 48 Allocator::~Allocator()
 49 {
 50     scavenge();
 51 }
 52 
<span class="line-modified"> 53 void* Allocator::allocateImpl(size_t alignment, size_t size, FailureAction action)</span>





















 54 {
 55     BASSERT(isPowerOfTwo(alignment));
 56 
 57     if (!size)
 58         size = alignment;
 59 
 60     if (size &lt;= smallMax &amp;&amp; alignment &lt;= smallMax)
<span class="line-modified"> 61         return allocateImpl(roundUpToMultipleOf(alignment, size), action);</span>
 62 
<span class="line-modified"> 63     return allocateLarge(size, action);</span>



 64 }
 65 
<span class="line-modified"> 66 void* Allocator::reallocateImpl(void* object, size_t newSize, FailureAction action)</span>
 67 {
<span class="line-modified"> 68     if (!object)</span>
<span class="line-modified"> 69         return allocateImpl(newSize, action);</span>







 70 


 71     size_t oldSize = 0;
 72     switch (objectType(m_heap, object)) {
 73     case ObjectType::Small: {




 74         size_t sizeClass = Object(object).page()-&gt;sizeClass();
 75         oldSize = objectSize(sizeClass);
 76         break;
 77     }
 78     case ObjectType::Large: {
<span class="line-modified"> 79         UniqueLockHolder lock(Heap::mutex());</span>
 80         oldSize = m_heap.largeSize(lock, object);
 81 
 82         if (newSize &lt; oldSize &amp;&amp; newSize &gt; smallMax) {
 83             m_heap.shrinkLarge(lock, Range(object, oldSize), newSize);
 84             return object;
 85         }
 86         break;
 87     }
 88     }
 89 
 90     void* result = nullptr;
<span class="line-modified"> 91     result = allocateImpl(newSize, action);</span>
<span class="line-modified"> 92     if (!result) {</span>
<span class="line-modified"> 93         BASSERT(action == FailureAction::ReturnNull);</span>
<span class="line-modified"> 94         return nullptr;</span>


 95     }
 96     size_t copySize = std::min(oldSize, newSize);
 97     memcpy(result, object, copySize);
 98     m_deallocator.deallocate(object);
 99     return result;
100 }
101 
102 void Allocator::scavenge()
103 {
104     for (size_t sizeClass = 0; sizeClass &lt; sizeClassCount; ++sizeClass) {
105         BumpAllocator&amp; allocator = m_bumpAllocators[sizeClass];
106         BumpRangeCache&amp; bumpRangeCache = m_bumpRangeCaches[sizeClass];
107 
108         while (allocator.canAllocate())
109             m_deallocator.deallocate(allocator.allocate());
110 
111         while (bumpRangeCache.size()) {
112             allocator.refill(bumpRangeCache.pop());
113             while (allocator.canAllocate())
114                 m_deallocator.deallocate(allocator.allocate());
115         }
116 
117         allocator.clear();
118     }
119 }
120 
<span class="line-modified">121 BNO_INLINE void Allocator::refillAllocatorSlowCase(BumpAllocator&amp; allocator, size_t sizeClass, FailureAction action)</span>
122 {
123     BumpRangeCache&amp; bumpRangeCache = m_bumpRangeCaches[sizeClass];
124 
<span class="line-modified">125     UniqueLockHolder lock(Heap::mutex());</span>
126     m_deallocator.processObjectLog(lock);
<span class="line-modified">127     m_heap.allocateSmallBumpRanges(lock, sizeClass, allocator, bumpRangeCache, m_deallocator.lineCache(lock), action);</span>
128 }
129 
<span class="line-modified">130 BINLINE void Allocator::refillAllocator(BumpAllocator&amp; allocator, size_t sizeClass, FailureAction action)</span>
131 {
132     BumpRangeCache&amp; bumpRangeCache = m_bumpRangeCaches[sizeClass];
133     if (!bumpRangeCache.size())
<span class="line-modified">134         return refillAllocatorSlowCase(allocator, sizeClass, action);</span>
135     return allocator.refill(bumpRangeCache.pop());
136 }
137 
<span class="line-modified">138 BNO_INLINE void* Allocator::allocateLarge(size_t size, FailureAction action)</span>
139 {
<span class="line-modified">140     UniqueLockHolder lock(Heap::mutex());</span>
<span class="line-modified">141     return m_heap.allocateLarge(lock, alignment, size, action);</span>
142 }
143 
<span class="line-modified">144 BNO_INLINE void* Allocator::allocateLogSizeClass(size_t size, FailureAction action)</span>
145 {
146     size_t sizeClass = bmalloc::sizeClass(size);
147     BumpAllocator&amp; allocator = m_bumpAllocators[sizeClass];
148     if (!allocator.canAllocate())
<span class="line-modified">149         refillAllocator(allocator, sizeClass, action);</span>
<span class="line-added">150     if (action == FailureAction::ReturnNull &amp;&amp; !allocator.canAllocate())</span>
<span class="line-added">151         return nullptr;</span>
152     return allocator.allocate();
153 }
154 
<span class="line-modified">155 void* Allocator::allocateSlowCase(size_t size, FailureAction action)</span>
156 {
157     if (size &lt;= maskSizeClassMax) {
158         size_t sizeClass = bmalloc::maskSizeClass(size);
159         BumpAllocator&amp; allocator = m_bumpAllocators[sizeClass];
<span class="line-modified">160         refillAllocator(allocator, sizeClass, action);</span>
<span class="line-added">161         if (action == FailureAction::ReturnNull &amp;&amp; !allocator.canAllocate())</span>
<span class="line-added">162             return nullptr;</span>
163         return allocator.allocate();
164     }
165 
166     if (size &lt;= smallMax)
<span class="line-modified">167         return allocateLogSizeClass(size, action);</span>
168 
<span class="line-modified">169     return allocateLarge(size, action);</span>
170 }
171 
172 } // namespace bmalloc
</pre>
</td>
</tr>
</table>
<center><a href="AllIsoHeaps.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Allocator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/InternalFunction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorInstrumentationObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InternalFunction.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/InternalFunction.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;InternalFunction.h&quot;
 25 
 26 #include &quot;FunctionPrototype.h&quot;
 27 #include &quot;JSGlobalObject.h&quot;
 28 #include &quot;JSString.h&quot;
 29 #include &quot;JSCInlines.h&quot;
 30 
 31 namespace JSC {
 32 
 33 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(InternalFunction);
 34 
 35 const ClassInfo InternalFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(InternalFunction) };
 36 
 37 InternalFunction::InternalFunction(VM&amp; vm, Structure* structure, NativeFunction functionForCall, NativeFunction functionForConstruct)
<span class="line-modified"> 38     : JSDestructibleObject(vm, structure)</span>
 39     , m_functionForCall(functionForCall)
 40     , m_functionForConstruct(functionForConstruct ? functionForConstruct : callHostFunctionAsConstructor)

 41 {
<span class="line-removed"> 42     // exec-&gt;vm() wants callees to not be large allocations.</span>
<span class="line-removed"> 43     RELEASE_ASSERT(!isLargeAllocation());</span>
 44     ASSERT_WITH_MESSAGE(m_functionForCall, &quot;[[Call]] must be implemented&quot;);
 45     ASSERT(m_functionForConstruct);
 46 }
 47 
<span class="line-modified"> 48 void InternalFunction::finishCreation(VM&amp; vm, const String&amp; name, NameVisibility nameVisibility, NameAdditionMode nameAdditionMode)</span>
 49 {
 50     Base::finishCreation(vm);
 51     ASSERT(jsDynamicCast&lt;InternalFunction*&gt;(vm, this));
 52     ASSERT(methodTable(vm)-&gt;getCallData == InternalFunction::info()-&gt;methodTable.getCallData);
 53     ASSERT(methodTable(vm)-&gt;getConstructData == InternalFunction::info()-&gt;methodTable.getConstructData);
 54     ASSERT(type() == InternalFunctionType);
 55     JSString* nameString = jsString(vm, name);
 56     m_originalName.set(vm, this, nameString);
<span class="line-modified"> 57     if (nameVisibility == NameVisibility::Visible) {</span>
<span class="line-modified"> 58         if (nameAdditionMode == NameAdditionMode::WithStructureTransition)</span>
<span class="line-modified"> 59             putDirect(vm, vm.propertyNames-&gt;name, nameString, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);</span>
<span class="line-modified"> 60         else</span>
<span class="line-removed"> 61             putDirectWithoutTransition(vm, vm.propertyNames-&gt;name, nameString, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);</span>
<span class="line-removed"> 62     }</span>
 63 }
 64 
 65 void InternalFunction::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 66 {
 67     InternalFunction* thisObject = jsCast&lt;InternalFunction*&gt;(cell);
 68     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 69     Base::visitChildren(thisObject, visitor);
 70 
 71     visitor.append(thisObject-&gt;m_originalName);
 72 }
 73 
 74 const String&amp; InternalFunction::name()
 75 {
 76     const String&amp; name = m_originalName-&gt;tryGetValue();
 77     ASSERT(name); // m_originalName was built from a String, and hence, there is no rope to resolve.
 78     return name;
 79 }
 80 
 81 const String InternalFunction::displayName(VM&amp; vm)
 82 {
</pre>
<hr />
<pre>
 98 
 99 ConstructType InternalFunction::getConstructData(JSCell* cell, ConstructData&amp; constructData)
100 {
101     auto* function = jsCast&lt;InternalFunction*&gt;(cell);
102     if (function-&gt;m_functionForConstruct == callHostFunctionAsConstructor)
103         return ConstructType::None;
104     constructData.native.function = function-&gt;m_functionForConstruct;
105     return ConstructType::Host;
106 }
107 
108 const String InternalFunction::calculatedDisplayName(VM&amp; vm)
109 {
110     const String explicitName = displayName(vm);
111 
112     if (!explicitName.isEmpty())
113         return explicitName;
114 
115     return name();
116 }
117 
<span class="line-modified">118 Structure* InternalFunction::createSubclassStructureSlow(ExecState* exec, JSValue newTarget, Structure* baseClass)</span>
119 {
<span class="line-modified">120     VM&amp; vm = exec-&gt;vm();</span>
121     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-removed">122     ASSERT(!newTarget || newTarget.isConstructor(vm));</span>
<span class="line-removed">123     ASSERT(newTarget &amp;&amp; newTarget != exec-&gt;jsCallee());</span>
124 
125     ASSERT(baseClass-&gt;hasMonoProto());
126 
127     // newTarget may be an InternalFunction if we were called from Reflect.construct.
128     JSFunction* targetFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, newTarget);
<span class="line-modified">129     JSGlobalObject* lexicalGlobalObject = exec-&gt;lexicalGlobalObject();</span>
130 
131     if (LIKELY(targetFunction)) {
<span class="line-modified">132         Structure* structure = targetFunction-&gt;rareData(vm)-&gt;internalFunctionAllocationStructure();</span>
<span class="line-modified">133         if (LIKELY(structure &amp;&amp; structure-&gt;classInfo() == baseClass-&gt;classInfo()))</span>

134             return structure;
135 
136         // Note, Reflect.construct might cause the profile to churn but we don&#39;t care.
<span class="line-modified">137         JSValue prototypeValue = newTarget.get(exec, vm.propertyNames-&gt;prototype);</span>
138         RETURN_IF_EXCEPTION(scope, nullptr);
139         if (JSObject* prototype = jsDynamicCast&lt;JSObject*&gt;(vm, prototypeValue))
<span class="line-modified">140             return targetFunction-&gt;rareData(vm)-&gt;createInternalFunctionAllocationStructureFromBase(vm, lexicalGlobalObject, prototype, baseClass);</span>
141     } else {
<span class="line-modified">142         JSValue prototypeValue = newTarget.get(exec, vm.propertyNames-&gt;prototype);</span>
143         RETURN_IF_EXCEPTION(scope, nullptr);
144         if (JSObject* prototype = jsDynamicCast&lt;JSObject*&gt;(vm, prototypeValue)) {
145             // This only happens if someone Reflect.constructs our builtin constructor with another builtin constructor as the new.target.
146             // Thus, we don&#39;t care about the cost of looking up the structure from our hash table every time.
<span class="line-modified">147             return vm.structureCache.emptyStructureForPrototypeFromBaseStructure(lexicalGlobalObject, prototype, baseClass);</span>
148         }
149     }
150 
151     return baseClass;
152 }
153 
154 
155 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;InternalFunction.h&quot;
 25 
 26 #include &quot;FunctionPrototype.h&quot;
 27 #include &quot;JSGlobalObject.h&quot;
 28 #include &quot;JSString.h&quot;
 29 #include &quot;JSCInlines.h&quot;
 30 
 31 namespace JSC {
 32 
 33 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(InternalFunction);
 34 
 35 const ClassInfo InternalFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(InternalFunction) };
 36 
 37 InternalFunction::InternalFunction(VM&amp; vm, Structure* structure, NativeFunction functionForCall, NativeFunction functionForConstruct)
<span class="line-modified"> 38     : Base(vm, structure)</span>
 39     , m_functionForCall(functionForCall)
 40     , m_functionForConstruct(functionForConstruct ? functionForConstruct : callHostFunctionAsConstructor)
<span class="line-added"> 41     , m_globalObject(vm, this, structure-&gt;globalObject())</span>
 42 {


 43     ASSERT_WITH_MESSAGE(m_functionForCall, &quot;[[Call]] must be implemented&quot;);
 44     ASSERT(m_functionForConstruct);
 45 }
 46 
<span class="line-modified"> 47 void InternalFunction::finishCreation(VM&amp; vm, const String&amp; name, NameAdditionMode nameAdditionMode)</span>
 48 {
 49     Base::finishCreation(vm);
 50     ASSERT(jsDynamicCast&lt;InternalFunction*&gt;(vm, this));
 51     ASSERT(methodTable(vm)-&gt;getCallData == InternalFunction::info()-&gt;methodTable.getCallData);
 52     ASSERT(methodTable(vm)-&gt;getConstructData == InternalFunction::info()-&gt;methodTable.getConstructData);
 53     ASSERT(type() == InternalFunctionType);
 54     JSString* nameString = jsString(vm, name);
 55     m_originalName.set(vm, this, nameString);
<span class="line-modified"> 56     if (nameAdditionMode == NameAdditionMode::WithStructureTransition)</span>
<span class="line-modified"> 57         putDirect(vm, vm.propertyNames-&gt;name, nameString, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);</span>
<span class="line-modified"> 58     else</span>
<span class="line-modified"> 59         putDirectWithoutTransition(vm, vm.propertyNames-&gt;name, nameString, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);</span>


 60 }
 61 
 62 void InternalFunction::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 63 {
 64     InternalFunction* thisObject = jsCast&lt;InternalFunction*&gt;(cell);
 65     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 66     Base::visitChildren(thisObject, visitor);
 67 
 68     visitor.append(thisObject-&gt;m_originalName);
 69 }
 70 
 71 const String&amp; InternalFunction::name()
 72 {
 73     const String&amp; name = m_originalName-&gt;tryGetValue();
 74     ASSERT(name); // m_originalName was built from a String, and hence, there is no rope to resolve.
 75     return name;
 76 }
 77 
 78 const String InternalFunction::displayName(VM&amp; vm)
 79 {
</pre>
<hr />
<pre>
 95 
 96 ConstructType InternalFunction::getConstructData(JSCell* cell, ConstructData&amp; constructData)
 97 {
 98     auto* function = jsCast&lt;InternalFunction*&gt;(cell);
 99     if (function-&gt;m_functionForConstruct == callHostFunctionAsConstructor)
100         return ConstructType::None;
101     constructData.native.function = function-&gt;m_functionForConstruct;
102     return ConstructType::Host;
103 }
104 
105 const String InternalFunction::calculatedDisplayName(VM&amp; vm)
106 {
107     const String explicitName = displayName(vm);
108 
109     if (!explicitName.isEmpty())
110         return explicitName;
111 
112     return name();
113 }
114 
<span class="line-modified">115 Structure* InternalFunction::createSubclassStructureSlow(JSGlobalObject* globalObject, JSValue newTarget, Structure* baseClass)</span>
116 {
<span class="line-modified">117     VM&amp; vm = globalObject-&gt;vm();</span>
118     auto scope = DECLARE_THROW_SCOPE(vm);


119 
120     ASSERT(baseClass-&gt;hasMonoProto());
121 
122     // newTarget may be an InternalFunction if we were called from Reflect.construct.
123     JSFunction* targetFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, newTarget);
<span class="line-modified">124     JSGlobalObject* baseGlobalObject = baseClass-&gt;globalObject();</span>
125 
126     if (LIKELY(targetFunction)) {
<span class="line-modified">127         FunctionRareData* rareData = targetFunction-&gt;ensureRareData(vm);</span>
<span class="line-modified">128         Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="line-added">129         if (LIKELY(structure &amp;&amp; structure-&gt;classInfo() == baseClass-&gt;classInfo() &amp;&amp; structure-&gt;globalObject() == baseGlobalObject))</span>
130             return structure;
131 
132         // Note, Reflect.construct might cause the profile to churn but we don&#39;t care.
<span class="line-modified">133         JSValue prototypeValue = targetFunction-&gt;get(globalObject, vm.propertyNames-&gt;prototype);</span>
134         RETURN_IF_EXCEPTION(scope, nullptr);
135         if (JSObject* prototype = jsDynamicCast&lt;JSObject*&gt;(vm, prototypeValue))
<span class="line-modified">136             return rareData-&gt;createInternalFunctionAllocationStructureFromBase(vm, baseGlobalObject, prototype, baseClass);</span>
137     } else {
<span class="line-modified">138         JSValue prototypeValue = newTarget.get(globalObject, vm.propertyNames-&gt;prototype);</span>
139         RETURN_IF_EXCEPTION(scope, nullptr);
140         if (JSObject* prototype = jsDynamicCast&lt;JSObject*&gt;(vm, prototypeValue)) {
141             // This only happens if someone Reflect.constructs our builtin constructor with another builtin constructor as the new.target.
142             // Thus, we don&#39;t care about the cost of looking up the structure from our hash table every time.
<span class="line-modified">143             return vm.structureCache.emptyStructureForPrototypeFromBaseStructure(baseGlobalObject, prototype, baseClass);</span>
144         }
145     }
146 
147     return baseClass;
148 }
149 
150 
151 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="InspectorInstrumentationObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InternalFunction.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
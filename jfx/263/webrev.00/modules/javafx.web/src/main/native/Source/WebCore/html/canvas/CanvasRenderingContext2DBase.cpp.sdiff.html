<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/CanvasRenderingContext2DBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CanvasRenderingContext2D.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CanvasRenderingContext2DBase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/CanvasRenderingContext2DBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 143     , m_stateStack(1)
 144     , m_usesCSSCompatibilityParseMode(usesCSSCompatibilityParseMode)
 145 {
 146 }
 147 
 148 void CanvasRenderingContext2DBase::unwindStateStack()
 149 {
 150     // Ensure that the state stack in the ImageBuffer&#39;s context
 151     // is cleared before destruction, to avoid assertions in the
 152     // GraphicsContext dtor.
 153     if (size_t stackSize = m_stateStack.size()) {
 154         if (auto* context = canvasBase().existingDrawingContext()) {
 155             while (--stackSize)
 156                 context-&gt;restore();
 157         }
 158     }
 159 }
 160 
 161 CanvasRenderingContext2DBase::~CanvasRenderingContext2DBase()
 162 {
<span class="line-modified"> 163 #if !ASSERT_DISABLED</span>
 164     unwindStateStack();
 165 #endif
 166 
 167     if (UNLIKELY(tracksDisplayListReplay()))
 168         contextDisplayListMap().remove(this);
 169 }
 170 
 171 bool CanvasRenderingContext2DBase::isAccelerated() const
 172 {
 173 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 174     auto* context = canvasBase().existingDrawingContext();
 175     return context &amp;&amp; context-&gt;isAcceleratedContext();
 176 #else
 177     return false;
 178 #endif
 179 }
 180 
 181 void CanvasRenderingContext2DBase::reset()
 182 {
 183     unwindStateStack();
 184     m_stateStack.resize(1);
 185     m_stateStack.first() = State();
 186     m_path.clear();
 187     m_unrealizedSaveCount = 0;
 188 
 189     m_recordingContext = nullptr;
 190 }
 191 
 192 CanvasRenderingContext2DBase::State::State()
 193     : strokeStyle(Color::black)
 194     , fillStyle(Color::black)
 195     , lineWidth(1)
 196     , lineCap(ButtCap)
 197     , lineJoin(MiterJoin)
 198     , miterLimit(10)
 199     , shadowBlur(0)
 200     , shadowColor(Color::transparent)
 201     , globalAlpha(1)
<span class="line-modified"> 202     , globalComposite(CompositeSourceOver)</span>
 203     , globalBlend(BlendMode::Normal)
 204     , hasInvertibleTransform(true)
 205     , lineDashOffset(0)
 206     , imageSmoothingEnabled(true)
 207     , imageSmoothingQuality(defaultSmoothingQuality)
 208     , textAlign(StartTextAlign)
 209     , textBaseline(AlphabeticTextBaseline)
 210     , direction(Direction::Inherit)
 211     , unparsedFont(DefaultFont)
 212 {
 213 }
 214 
 215 CanvasRenderingContext2DBase::State::State(const State&amp; other)
 216     : unparsedStrokeColor(other.unparsedStrokeColor)
 217     , unparsedFillColor(other.unparsedFillColor)
 218     , strokeStyle(other.strokeStyle)
 219     , fillStyle(other.fillStyle)
 220     , lineWidth(other.lineWidth)
 221     , lineCap(other.lineCap)
 222     , lineJoin(other.lineJoin)
</pre>
<hr />
<pre>
 385     if (m_stateStack.size() &lt;= 1)
 386         return;
 387     m_path.transform(state().transform);
 388     m_stateStack.removeLast();
 389     if (Optional&lt;AffineTransform&gt; inverse = state().transform.inverse())
 390         m_path.transform(inverse.value());
 391     GraphicsContext* c = drawingContext();
 392     if (!c)
 393         return;
 394     c-&gt;restore();
 395 }
 396 
 397 void CanvasRenderingContext2DBase::setStrokeStyle(CanvasStyle style)
 398 {
 399     if (!style.isValid())
 400         return;
 401 
 402     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentColor(style))
 403         return;
 404 
<span class="line-modified"> 405     if (style.isCurrentColor() &amp;&amp; is&lt;HTMLCanvasElement&gt;(canvasBase())) {</span>
<span class="line-removed"> 406         auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());</span>
<span class="line-removed"> 407 </span>
 408         if (style.hasOverrideAlpha()) {
 409             // FIXME: Should not use RGBA32 here.
<span class="line-modified"> 410             style = CanvasStyle(colorWithOverrideAlpha(currentColor(&amp;canvas).rgb(), style.overrideAlpha()));</span>
 411         } else
<span class="line-modified"> 412             style = CanvasStyle(currentColor(&amp;canvas));</span>
 413     } else
 414         checkOrigin(style.canvasPattern().get());
 415 
 416     realizeSaves();
 417     State&amp; state = modifiableState();
 418     state.strokeStyle = style;
 419     GraphicsContext* c = drawingContext();
 420     if (!c)
 421         return;
 422     state.strokeStyle.applyStrokeColor(*c);
 423     state.unparsedStrokeColor = String();
 424 }
 425 
 426 void CanvasRenderingContext2DBase::setFillStyle(CanvasStyle style)
 427 {
 428     if (!style.isValid())
 429         return;
 430 
 431     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentColor(style))
 432         return;
 433 
<span class="line-modified"> 434     if (style.isCurrentColor() &amp;&amp; is&lt;HTMLCanvasElement&gt;(canvasBase())) {</span>
<span class="line-removed"> 435         auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());</span>
<span class="line-removed"> 436 </span>
 437         if (style.hasOverrideAlpha()) {
 438             // FIXME: Should not use RGBA32 here.
<span class="line-modified"> 439             style = CanvasStyle(colorWithOverrideAlpha(currentColor(&amp;canvas).rgb(), style.overrideAlpha()));</span>
 440         } else
<span class="line-modified"> 441             style = CanvasStyle(currentColor(&amp;canvas));</span>
 442     } else
 443         checkOrigin(style.canvasPattern().get());
 444 
 445     realizeSaves();
 446     State&amp; state = modifiableState();
 447     state.fillStyle = style;
 448     GraphicsContext* c = drawingContext();
 449     if (!c)
 450         return;
 451     state.fillStyle.applyFillColor(*c);
 452     state.unparsedFillColor = String();
 453 }
 454 
 455 float CanvasRenderingContext2DBase::lineWidth() const
 456 {
 457     return state().lineWidth;
 458 }
 459 
 460 void CanvasRenderingContext2DBase::setLineWidth(float width)
 461 {
</pre>
<hr />
<pre>
 654 }
 655 
 656 void CanvasRenderingContext2DBase::setShadowBlur(float blur)
 657 {
 658     if (!(std::isfinite(blur) &amp;&amp; blur &gt;= 0))
 659         return;
 660     if (state().shadowBlur == blur)
 661         return;
 662     realizeSaves();
 663     modifiableState().shadowBlur = blur;
 664     applyShadow();
 665 }
 666 
 667 String CanvasRenderingContext2DBase::shadowColor() const
 668 {
 669     return Color(state().shadowColor).serialized();
 670 }
 671 
 672 void CanvasRenderingContext2DBase::setShadowColor(const String&amp; colorString)
 673 {
<span class="line-modified"> 674     auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());</span>
<span class="line-removed"> 675     Color color = parseColorOrCurrentColor(colorString, &amp;canvas);</span>
 676     if (!color.isValid())
 677         return;
 678     if (state().shadowColor == color)
 679         return;
 680     realizeSaves();
 681     modifiableState().shadowColor = color;
 682     applyShadow();
 683 }
 684 
 685 const Vector&lt;float&gt;&amp; CanvasRenderingContext2DBase::getLineDash() const
 686 {
 687     return state().lineDash;
 688 }
 689 
 690 static bool lineDashSequenceIsValid(const Vector&lt;float&gt;&amp; dash)
 691 {
 692     for (size_t i = 0; i &lt; dash.size(); i++) {
 693         if (!std::isfinite(dash[i]) || dash[i] &lt; 0)
 694             return false;
 695     }
</pre>
<hr />
<pre>
 757 {
 758     if (!(alpha &gt;= 0 &amp;&amp; alpha &lt;= 1))
 759         return;
 760     if (state().globalAlpha == alpha)
 761         return;
 762     realizeSaves();
 763     modifiableState().globalAlpha = alpha;
 764     GraphicsContext* c = drawingContext();
 765     if (!c)
 766         return;
 767     c-&gt;setAlpha(alpha);
 768 }
 769 
 770 String CanvasRenderingContext2DBase::globalCompositeOperation() const
 771 {
 772     return compositeOperatorName(state().globalComposite, state().globalBlend);
 773 }
 774 
 775 void CanvasRenderingContext2DBase::setGlobalCompositeOperation(const String&amp; operation)
 776 {
<span class="line-modified"> 777     CompositeOperator op = CompositeSourceOver;</span>
 778     BlendMode blendMode = BlendMode::Normal;
 779     if (!parseCompositeAndBlendOperator(operation, op, blendMode))
 780         return;
 781     if ((state().globalComposite == op) &amp;&amp; (state().globalBlend == blendMode))
 782         return;
 783     realizeSaves();
 784     modifiableState().globalComposite = op;
 785     modifiableState().globalBlend = blendMode;
 786     GraphicsContext* c = drawingContext();
 787     if (!c)
 788         return;
 789     c-&gt;setCompositeOperation(op, blendMode);
 790 }
 791 
 792 void CanvasRenderingContext2DBase::scale(float sx, float sy)
 793 {
 794     GraphicsContext* c = drawingContext();
 795     if (!c)
 796         return;
 797     if (!state().hasInvertibleTransform)
</pre>
<hr />
<pre>
 924     if (!c)
 925         return;
 926 
 927     AffineTransform ctm = state().transform;
 928     bool hasInvertibleTransform = state().hasInvertibleTransform;
 929 
 930     realizeSaves();
 931 
 932     c-&gt;setCTM(canvasBase().baseTransform());
 933     modifiableState().transform = AffineTransform();
 934 
 935     if (hasInvertibleTransform)
 936         m_path.transform(ctm);
 937 
 938     modifiableState().hasInvertibleTransform = true;
 939 }
 940 
 941 void CanvasRenderingContext2DBase::setStrokeColor(const String&amp; color, Optional&lt;float&gt; alpha)
 942 {
 943     if (alpha) {
<span class="line-modified"> 944         setStrokeStyle(CanvasStyle::createFromStringWithOverrideAlpha(color, alpha.value()));</span>
 945         return;
 946     }
 947 
 948     if (color == state().unparsedStrokeColor)
 949         return;
 950 
 951     realizeSaves();
<span class="line-modified"> 952     setStrokeStyle(CanvasStyle::createFromString(color));</span>
 953     modifiableState().unparsedStrokeColor = color;
 954 }
 955 
 956 void CanvasRenderingContext2DBase::setStrokeColor(float grayLevel, float alpha)
 957 {
 958     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentRGBA(grayLevel, grayLevel, grayLevel, alpha))
 959         return;
 960     setStrokeStyle(CanvasStyle(grayLevel, alpha));
 961 }
 962 
 963 void CanvasRenderingContext2DBase::setStrokeColor(float r, float g, float b, float a)
 964 {
 965     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentRGBA(r, g, b, a))
 966         return;
 967     setStrokeStyle(CanvasStyle(r, g, b, a));
 968 }
 969 
 970 void CanvasRenderingContext2DBase::setStrokeColor(float c, float m, float y, float k, float a)
 971 {
 972     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentCMYKA(c, m, y, k, a))
 973         return;
 974     setStrokeStyle(CanvasStyle(c, m, y, k, a));
 975 }
 976 
 977 void CanvasRenderingContext2DBase::setFillColor(const String&amp; color, Optional&lt;float&gt; alpha)
 978 {
 979     if (alpha) {
<span class="line-modified"> 980         setFillStyle(CanvasStyle::createFromStringWithOverrideAlpha(color, alpha.value()));</span>
 981         return;
 982     }
 983 
 984     if (color == state().unparsedFillColor)
 985         return;
 986 
 987     realizeSaves();
<span class="line-modified"> 988     setFillStyle(CanvasStyle::createFromString(color));</span>
 989     modifiableState().unparsedFillColor = color;
 990 }
 991 
 992 void CanvasRenderingContext2DBase::setFillColor(float grayLevel, float alpha)
 993 {
 994     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentRGBA(grayLevel, grayLevel, grayLevel, alpha))
 995         return;
 996     setFillStyle(CanvasStyle(grayLevel, alpha));
 997 }
 998 
 999 void CanvasRenderingContext2DBase::setFillColor(float r, float g, float b, float a)
1000 {
1001     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentRGBA(r, g, b, a))
1002         return;
1003     setFillStyle(CanvasStyle(r, g, b, a));
1004 }
1005 
1006 void CanvasRenderingContext2DBase::setFillColor(float c, float m, float y, float k, float a)
1007 {
1008     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentCMYKA(c, m, y, k, a))
</pre>
<hr />
<pre>
1022 
1023     if (!width &amp;&amp; !height)
1024         return false;
1025 
1026     if (width &lt; 0) {
1027         width = -width;
1028         x -= width;
1029     }
1030 
1031     if (height &lt; 0) {
1032         height = -height;
1033         y -= height;
1034     }
1035 
1036     return true;
1037 }
1038 
1039 bool CanvasRenderingContext2DBase::isFullCanvasCompositeMode(CompositeOperator op)
1040 {
1041     // See 4.8.11.1.3 Compositing
<span class="line-modified">1042     // CompositeSourceAtop and CompositeDestinationOut are not listed here as the platforms already</span>
1043     // implement the specification&#39;s behavior.
<span class="line-modified">1044     return op == CompositeSourceIn || op == CompositeSourceOut || op == CompositeDestinationIn || op == CompositeDestinationAtop;</span>
1045 }
1046 
1047 static WindRule toWindRule(CanvasFillRule rule)
1048 {
1049     return rule == CanvasFillRule::Nonzero ? WindRule::NonZero : WindRule::EvenOdd;
1050 }
1051 
1052 void CanvasRenderingContext2DBase::fill(CanvasFillRule windingRule)
1053 {
1054     fillInternal(m_path, windingRule);
1055 }
1056 
1057 void CanvasRenderingContext2DBase::stroke()
1058 {
1059     strokeInternal(m_path);
1060 }
1061 
1062 void CanvasRenderingContext2DBase::clip(CanvasFillRule windingRule)
1063 {
1064     clipInternal(m_path, windingRule);
</pre>
<hr />
<pre>
1084     auto* c = drawingContext();
1085     if (!c)
1086         return;
1087     if (!state().hasInvertibleTransform)
1088         return;
1089 
1090     // If gradient size is zero, then paint nothing.
1091     auto gradient = c-&gt;fillGradient();
1092     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1093         return;
1094 
1095     if (!path.isEmpty()) {
1096         auto savedFillRule = c-&gt;fillRule();
1097         c-&gt;setFillRule(toWindRule(windingRule));
1098 
1099         if (isFullCanvasCompositeMode(state().globalComposite)) {
1100             beginCompositeLayer();
1101             c-&gt;fillPath(path);
1102             endCompositeLayer();
1103             didDrawEntireCanvas();
<span class="line-modified">1104         } else if (state().globalComposite == CompositeCopy) {</span>
1105             clearCanvas();
1106             c-&gt;fillPath(path);
1107             didDrawEntireCanvas();
1108         } else {
1109             c-&gt;fillPath(path);
1110             didDraw(path.fastBoundingRect());
1111         }
1112 
1113         c-&gt;setFillRule(savedFillRule);
1114     }
1115 }
1116 
1117 void CanvasRenderingContext2DBase::strokeInternal(const Path&amp; path)
1118 {
1119     auto* c = drawingContext();
1120     if (!c)
1121         return;
1122     if (!state().hasInvertibleTransform)
1123         return;
1124 
1125     // If gradient size is zero, then paint nothing.
1126     auto gradient = c-&gt;strokeGradient();
1127     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1128         return;
1129 
1130     if (!path.isEmpty()) {
1131         if (isFullCanvasCompositeMode(state().globalComposite)) {
1132             beginCompositeLayer();
1133             c-&gt;strokePath(path);
1134             endCompositeLayer();
1135             didDrawEntireCanvas();
<span class="line-modified">1136         } else if (state().globalComposite == CompositeCopy) {</span>
1137             clearCanvas();
1138             c-&gt;strokePath(path);
1139             didDrawEntireCanvas();
1140         } else {
1141             FloatRect dirtyRect = path.fastBoundingRect();
1142             inflateStrokeRect(dirtyRect);
1143             c-&gt;strokePath(path);
1144             didDraw(dirtyRect);
1145         }
1146     }
1147 }
1148 
1149 void CanvasRenderingContext2DBase::clipInternal(const Path&amp; path, CanvasFillRule windingRule)
1150 {
1151     auto* c = drawingContext();
1152     if (!c)
1153         return;
1154     if (!state().hasInvertibleTransform)
1155         return;
1156 
</pre>
<hr />
<pre>
1204 
1205     if (!std::isfinite(transformedPoint.x()) || !std::isfinite(transformedPoint.y()))
1206         return false;
1207 
1208     return path.contains(transformedPoint, toWindRule(windingRule));
1209 }
1210 
1211 bool CanvasRenderingContext2DBase::isPointInStrokeInternal(const Path&amp; path, float x, float y)
1212 {
1213     auto* c = drawingContext();
1214     if (!c)
1215         return false;
1216     if (!state().hasInvertibleTransform)
1217         return false;
1218 
1219     auto transformedPoint = state().transform.inverse().valueOr(AffineTransform()).mapPoint(FloatPoint(x, y));
1220     if (!std::isfinite(transformedPoint.x()) || !std::isfinite(transformedPoint.y()))
1221         return false;
1222 
1223     CanvasStrokeStyleApplier applier(this);
<span class="line-modified">1224     return path.strokeContains(&amp;applier, transformedPoint);</span>
1225 }
1226 
1227 void CanvasRenderingContext2DBase::clearRect(float x, float y, float width, float height)
1228 {
1229     if (!validateRectForCanvas(x, y, width, height))
1230         return;
1231     auto* context = drawingContext();
1232     if (!context)
1233         return;
1234     if (!state().hasInvertibleTransform)
1235         return;
1236     FloatRect rect(x, y, width, height);
1237 
1238     bool saved = false;
1239     if (shouldDrawShadows()) {
1240         context-&gt;save();
1241         saved = true;
1242         context-&gt;setLegacyShadow(FloatSize(), 0, Color::transparent);
1243     }
1244     if (state().globalAlpha != 1) {
1245         if (!saved) {
1246             context-&gt;save();
1247             saved = true;
1248         }
1249         context-&gt;setAlpha(1);
1250     }
<span class="line-modified">1251     if (state().globalComposite != CompositeSourceOver) {</span>
1252         if (!saved) {
1253             context-&gt;save();
1254             saved = true;
1255         }
<span class="line-modified">1256         context-&gt;setCompositeOperation(CompositeSourceOver);</span>
1257     }
1258     context-&gt;clearRect(rect);
1259     if (saved)
1260         context-&gt;restore();
1261     didDraw(rect);
1262 }
1263 
1264 void CanvasRenderingContext2DBase::fillRect(float x, float y, float width, float height)
1265 {
1266     if (!validateRectForCanvas(x, y, width, height))
1267         return;
1268 
1269     auto* c = drawingContext();
1270     if (!c)
1271         return;
1272     if (!state().hasInvertibleTransform)
1273         return;
1274 
1275     // from the HTML5 Canvas spec:
1276     // If x0 = x1 and y0 = y1, then the linear gradient must paint nothing
1277     // If x0 = x1 and y0 = y1 and r0 = r1, then the radial gradient must paint nothing
1278     auto gradient = c-&gt;fillGradient();
1279     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1280         return;
1281 
1282     FloatRect rect(x, y, width, height);
1283 
1284     if (rectContainsCanvas(rect)) {
1285         c-&gt;fillRect(rect);
1286         didDrawEntireCanvas();
1287     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1288         beginCompositeLayer();
1289         c-&gt;fillRect(rect);
1290         endCompositeLayer();
1291         didDrawEntireCanvas();
<span class="line-modified">1292     } else if (state().globalComposite == CompositeCopy) {</span>
1293         clearCanvas();
1294         c-&gt;fillRect(rect);
1295         didDrawEntireCanvas();
1296     } else {
1297         c-&gt;fillRect(rect);
1298         didDraw(rect);
1299     }
1300 }
1301 
1302 void CanvasRenderingContext2DBase::strokeRect(float x, float y, float width, float height)
1303 {
1304     if (!validateRectForCanvas(x, y, width, height))
1305         return;
1306 
1307     auto* c = drawingContext();
1308     if (!c)
1309         return;
1310     if (!state().hasInvertibleTransform)
1311         return;
1312     if (!(state().lineWidth &gt;= 0))
1313         return;
1314 
1315     // If gradient size is zero, then paint nothing.
1316     auto gradient = c-&gt;strokeGradient();
1317     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1318         return;
1319 
1320     FloatRect rect(x, y, width, height);
1321     if (isFullCanvasCompositeMode(state().globalComposite)) {
1322         beginCompositeLayer();
1323         c-&gt;strokeRect(rect, state().lineWidth);
1324         endCompositeLayer();
1325         didDrawEntireCanvas();
<span class="line-modified">1326     } else if (state().globalComposite == CompositeCopy) {</span>
1327         clearCanvas();
1328         c-&gt;strokeRect(rect, state().lineWidth);
1329         didDrawEntireCanvas();
1330     } else {
1331         FloatRect boundingRect = rect;
1332         boundingRect.inflate(state().lineWidth / 2);
1333         c-&gt;strokeRect(rect, state().lineWidth);
1334         didDraw(boundingRect);
1335     }
1336 }
1337 
1338 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, const String&amp; colorString, Optional&lt;float&gt; alpha)
1339 {
1340     Color color = Color::transparent;
1341     if (!colorString.isNull()) {
<span class="line-modified">1342         auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());</span>
<span class="line-removed">1343         color = parseColorOrCurrentColor(colorString, &amp;canvas);</span>
1344         if (!color.isValid())
1345             return;
1346     }
1347     // FIXME: Should not use RGBA32 here.
1348     setShadow(FloatSize(width, height), blur, colorWithOverrideAlpha(color.rgb(), alpha));
1349 }
1350 
1351 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, float grayLevel, float alpha)
1352 {
1353     setShadow(FloatSize(width, height), blur, Color(grayLevel, grayLevel, grayLevel, alpha));
1354 }
1355 
1356 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, float r, float g, float b, float a)
1357 {
1358     setShadow(FloatSize(width, height), blur, Color(r, g, b, a));
1359 }
1360 
1361 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, float c, float m, float y, float k, float a)
1362 {
1363     setShadow(FloatSize(width, height), blur, Color(c, m, y, k, a));
</pre>
<hr />
<pre>
1396         c-&gt;setLegacyShadow(FloatSize(), 0, Color::transparent);
1397 }
1398 
1399 bool CanvasRenderingContext2DBase::shouldDrawShadows() const
1400 {
1401     return state().shadowColor.isVisible() &amp;&amp; (state().shadowBlur || !state().shadowOffset.isZero());
1402 }
1403 
1404 enum class ImageSizeType { AfterDevicePixelRatio, BeforeDevicePixelRatio };
1405 static LayoutSize size(HTMLImageElement&amp; element, ImageSizeType sizeType = ImageSizeType::BeforeDevicePixelRatio)
1406 {
1407     LayoutSize size;
1408     if (auto* cachedImage = element.cachedImage()) {
1409         size = cachedImage-&gt;imageSizeForRenderer(element.renderer(), 1.0f); // FIXME: Not sure about this.
1410         if (sizeType == ImageSizeType::AfterDevicePixelRatio &amp;&amp; is&lt;RenderImage&gt;(element.renderer()) &amp;&amp; cachedImage-&gt;image() &amp;&amp; !cachedImage-&gt;image()-&gt;hasRelativeWidth())
1411             size.scale(downcast&lt;RenderImage&gt;(*element.renderer()).imageDevicePixelRatio());
1412     }
1413     return size;
1414 }
1415 
<span class="line-modified">1416 static inline FloatSize size(HTMLCanvasElement&amp; canvasElement)</span>
1417 {
<span class="line-modified">1418     return canvasElement.size();</span>
1419 }
1420 
1421 static inline FloatSize size(ImageBitmap&amp; imageBitmap)
1422 {
1423     return FloatSize { static_cast&lt;float&gt;(imageBitmap.width()), static_cast&lt;float&gt;(imageBitmap.height()) };
1424 }
1425 
1426 #if ENABLE(VIDEO)
1427 
1428 static inline FloatSize size(HTMLVideoElement&amp; video)
1429 {
1430     auto player = video.player();
1431     if (!player)
1432         return { };
1433     return player-&gt;naturalSize();
1434 }
1435 
1436 #endif
1437 
1438 #if ENABLE(CSS_TYPED_OM)
</pre>
<hr />
<pre>
1561         return { };
1562 
1563     RefPtr&lt;Image&gt; image = cachedImage-&gt;imageForRenderer(renderer);
1564     if (!image)
1565         return { };
1566 
1567     ImageObserver* observer = image-&gt;imageObserver();
1568 
1569     if (image-&gt;isSVGImage()) {
1570         image-&gt;setImageObserver(nullptr);
1571         image-&gt;setContainerSize(imageRect.size());
1572     }
1573 
1574     if (image-&gt;isBitmapImage()) {
1575         // Drawing an animated image to a canvas should draw the first frame (except for a few layout tests)
1576         if (image-&gt;isAnimated() &amp;&amp; !document.settings().animatedImageDebugCanvasDrawingEnabled())
1577             image = BitmapImage::create(image-&gt;nativeImage());
1578         downcast&lt;BitmapImage&gt;(*image).updateFromSettings(document.settings());
1579     }
1580 


1581     if (rectContainsCanvas(normalizedDstRect)) {
<span class="line-modified">1582         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, { op, blendMode });</span>
1583         didDrawEntireCanvas();
1584     } else if (isFullCanvasCompositeMode(op)) {
1585         fullCanvasCompositedDrawImage(*image, normalizedDstRect, normalizedSrcRect, op);
1586         didDrawEntireCanvas();
<span class="line-modified">1587     } else if (op == CompositeCopy) {</span>
1588         clearCanvas();
<span class="line-modified">1589         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, { op, blendMode });</span>
1590         didDrawEntireCanvas();
1591     } else {
<span class="line-modified">1592         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, { op, blendMode });</span>
1593         didDraw(normalizedDstRect);
1594     }
1595 
1596     if (image-&gt;isSVGImage())
1597         image-&gt;setImageObserver(observer);
1598 
1599     return { };
1600 }
1601 
<span class="line-modified">1602 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLCanvasElement&amp; sourceCanvas, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)</span>
1603 {
1604     FloatRect srcCanvasRect = FloatRect(FloatPoint(), sourceCanvas.size());
1605 
1606     if (!srcCanvasRect.width() || !srcCanvasRect.height())
1607         return Exception { InvalidStateError };
1608 
1609     if (!srcRect.width() || !srcRect.height())
1610         return Exception { IndexSizeError };
1611 
1612     if (!srcCanvasRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
1613         return { };
1614 
1615     GraphicsContext* c = drawingContext();
1616     if (!c)
1617         return { };
1618     if (!state().hasInvertibleTransform)
1619         return { };
1620 
1621     // FIXME: Do this through platform-independent GraphicsContext API.
1622     ImageBuffer* buffer = sourceCanvas.buffer();
</pre>
<hr />
<pre>
1625 
1626     checkOrigin(&amp;sourceCanvas);
1627 
1628 #if ENABLE(ACCELERATED_2D_CANVAS)
1629     // If we&#39;re drawing from one accelerated canvas 2d to another, avoid calling sourceCanvas.makeRenderingResultsAvailable()
1630     // as that will do a readback to software.
1631     RefPtr&lt;CanvasRenderingContext&gt; sourceContext = sourceCanvas.renderingContext();
1632     // FIXME: Implement an accelerated path for drawing from a WebGL canvas to a 2d canvas when possible.
1633     if (!isAccelerated() || !sourceContext || !sourceContext-&gt;isAccelerated() || !sourceContext-&gt;is2d())
1634         sourceCanvas.makeRenderingResultsAvailable();
1635 #else
1636     sourceCanvas.makeRenderingResultsAvailable();
1637 #endif
1638 
1639     if (rectContainsCanvas(dstRect)) {
1640         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1641         didDrawEntireCanvas();
1642     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1643         fullCanvasCompositedDrawImage(*buffer, dstRect, srcRect, state().globalComposite);
1644         didDrawEntireCanvas();
<span class="line-modified">1645     } else if (state().globalComposite == CompositeCopy) {</span>
1646         if (&amp;sourceCanvas == &amp;canvasBase()) {
<span class="line-modified">1647             if (auto copy = buffer-&gt;copyRectToBuffer(srcRect, ColorSpaceSRGB, *c)) {</span>
1648                 clearCanvas();
1649                 c-&gt;drawImageBuffer(*copy, dstRect, { { }, srcRect.size() }, { state().globalComposite, state().globalBlend });
1650             }
1651         } else {
1652             clearCanvas();
1653             c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1654         }
1655         didDrawEntireCanvas();
1656     } else {
1657         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1658         didDraw(dstRect);
1659     }
1660 
1661     return { };
1662 }
1663 
1664 #if ENABLE(VIDEO)
1665 
1666 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLVideoElement&amp; video, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1667 {
</pre>
<hr />
<pre>
1723         return { };
1724 
1725     GraphicsContext* c = drawingContext();
1726     if (!c)
1727         return { };
1728     if (!state().hasInvertibleTransform)
1729         return { };
1730 
1731     ImageBuffer* buffer = imageBitmap.buffer();
1732     if (!buffer)
1733         return { };
1734 
1735     checkOrigin(&amp;imageBitmap);
1736 
1737     if (rectContainsCanvas(dstRect)) {
1738         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1739         didDrawEntireCanvas();
1740     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1741         fullCanvasCompositedDrawImage(*buffer, dstRect, srcRect, state().globalComposite);
1742         didDrawEntireCanvas();
<span class="line-modified">1743     } else if (state().globalComposite == CompositeCopy) {</span>
1744         clearCanvas();
1745         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1746         didDrawEntireCanvas();
1747     } else {
1748         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1749         didDraw(dstRect);
1750     }
1751 
1752     return { };
1753 }
1754 
1755 void CanvasRenderingContext2DBase::drawImageFromRect(HTMLImageElement&amp; imageElement, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh, const String&amp; compositeOperation)
1756 {
1757     CompositeOperator op;
1758     auto blendOp = BlendMode::Normal;
1759     if (!parseCompositeAndBlendOperator(compositeOperation, op, blendOp) || blendOp != BlendMode::Normal)
<span class="line-modified">1760         op = CompositeSourceOver;</span>
1761     drawImage(imageElement, FloatRect { sx, sy, sw, sh }, FloatRect { dx, dy, dw, dh }, op, BlendMode::Normal);
1762 }
1763 
1764 void CanvasRenderingContext2DBase::clearCanvas()
1765 {
1766     auto* c = drawingContext();
1767     if (!c)
1768         return;
1769 
1770     c-&gt;save();
1771     c-&gt;setCTM(canvasBase().baseTransform());
1772     c-&gt;clearRect(FloatRect(0, 0, canvasBase().width(), canvasBase().height()));
1773     c-&gt;restore();
1774 }
1775 
1776 Path CanvasRenderingContext2DBase::transformAreaToDevice(const Path&amp; path) const
1777 {
1778     Path transformed(path);
1779     transformed.transform(state().transform);
1780     transformed.transform(canvasBase().baseTransform());
</pre>
<hr />
<pre>
1793     FloatQuad quad(rect);
1794     FloatQuad canvasQuad(FloatRect(0, 0, canvasBase().width(), canvasBase().height()));
1795     return state().transform.mapQuad(quad).containsQuad(canvasQuad);
1796 }
1797 
1798 template&lt;class T&gt; IntRect CanvasRenderingContext2DBase::calculateCompositingBufferRect(const T&amp; area, IntSize* croppedOffset)
1799 {
1800     IntRect canvasRect(0, 0, canvasBase().width(), canvasBase().height());
1801     canvasRect = canvasBase().baseTransform().mapRect(canvasRect);
1802     Path path = transformAreaToDevice(area);
1803     IntRect bufferRect = enclosingIntRect(path.fastBoundingRect());
1804     IntPoint originalLocation = bufferRect.location();
1805     bufferRect.intersect(canvasRect);
1806     if (croppedOffset)
1807         *croppedOffset = originalLocation - bufferRect.location();
1808     return bufferRect;
1809 }
1810 
1811 std::unique_ptr&lt;ImageBuffer&gt; CanvasRenderingContext2DBase::createCompositingBuffer(const IntRect&amp; bufferRect)
1812 {
<span class="line-modified">1813     return ImageBuffer::create(bufferRect.size(), isAccelerated() ? Accelerated : Unaccelerated);</span>
1814 }
1815 
1816 void CanvasRenderingContext2DBase::compositeBuffer(ImageBuffer&amp; buffer, const IntRect&amp; bufferRect, CompositeOperator op)
1817 {
1818     IntRect canvasRect(0, 0, canvasBase().width(), canvasBase().height());
1819     canvasRect = canvasBase().baseTransform().mapRect(canvasRect);
1820 
1821     auto* c = drawingContext();
1822     if (!c)
1823         return;
1824 
1825     c-&gt;save();
1826     c-&gt;setCTM(AffineTransform());
1827     c-&gt;setCompositeOperation(op);
1828 
1829     c-&gt;save();
1830     c-&gt;clipOut(bufferRect);
1831     c-&gt;clearRect(canvasRect);
1832     c-&gt;restore();
1833     c-&gt;drawImageBuffer(buffer, bufferRect.location(), state().globalComposite);
</pre>
<hr />
<pre>
1853     if (bufferRect.isEmpty()) {
1854         clearCanvas();
1855         return;
1856     }
1857 
1858     auto buffer = createCompositingBuffer(bufferRect);
1859     if (!buffer)
1860         return;
1861 
1862     auto* c = drawingContext();
1863     if (!c)
1864         return;
1865 
1866     FloatRect adjustedDest = dest;
1867     adjustedDest.setLocation(FloatPoint(0, 0));
1868     AffineTransform effectiveTransform = c-&gt;getCTM();
1869     IntRect transformedAdjustedRect = enclosingIntRect(effectiveTransform.mapRect(adjustedDest));
1870     buffer-&gt;context().translate(-transformedAdjustedRect.location());
1871     buffer-&gt;context().translate(croppedOffset);
1872     buffer-&gt;context().concatCTM(effectiveTransform);
<span class="line-modified">1873     drawImageToContext(image, buffer-&gt;context(), adjustedDest, src, { CompositeSourceOver });</span>
1874 
1875     compositeBuffer(*buffer, bufferRect, op);
1876 }
1877 
<span class="line-modified">1878 static CanvasRenderingContext2DBase::Style toStyle(const CanvasStyle&amp; style)</span>
1879 {
1880     if (auto gradient = style.canvasGradient())
1881         return gradient;
1882     if (auto pattern = style.canvasPattern())
1883         return pattern;
1884     return style.color();
1885 }
1886 
<span class="line-modified">1887 CanvasRenderingContext2DBase::Style CanvasRenderingContext2DBase::strokeStyle() const</span>
1888 {
<span class="line-modified">1889     return toStyle(state().strokeStyle);</span>
1890 }
1891 
<span class="line-modified">1892 void CanvasRenderingContext2DBase::setStrokeStyle(CanvasRenderingContext2DBase::Style&amp;&amp; style)</span>
1893 {
1894     WTF::switchOn(style,
1895         [this] (const String&amp; string) { this-&gt;setStrokeColor(string); },
1896         [this] (const RefPtr&lt;CanvasGradient&gt;&amp; gradient) { this-&gt;setStrokeStyle(CanvasStyle(*gradient)); },
1897         [this] (const RefPtr&lt;CanvasPattern&gt;&amp; pattern) { this-&gt;setStrokeStyle(CanvasStyle(*pattern)); }
1898     );
1899 }
1900 
<span class="line-modified">1901 CanvasRenderingContext2DBase::Style CanvasRenderingContext2DBase::fillStyle() const</span>
1902 {
<span class="line-modified">1903     return toStyle(state().fillStyle);</span>
1904 }
1905 
<span class="line-modified">1906 void CanvasRenderingContext2DBase::setFillStyle(CanvasRenderingContext2DBase::Style&amp;&amp; style)</span>
1907 {
1908     WTF::switchOn(style,
1909         [this] (const String&amp; string) { this-&gt;setFillColor(string); },
1910         [this] (const RefPtr&lt;CanvasGradient&gt;&amp; gradient) { this-&gt;setFillStyle(CanvasStyle(*gradient)); },
1911         [this] (const RefPtr&lt;CanvasPattern&gt;&amp; pattern) { this-&gt;setFillStyle(CanvasStyle(*pattern)); }
1912     );
1913 }
1914 
1915 ExceptionOr&lt;Ref&lt;CanvasGradient&gt;&gt; CanvasRenderingContext2DBase::createLinearGradient(float x0, float y0, float x1, float y1)
1916 {
1917     if (!std::isfinite(x0) || !std::isfinite(y0) || !std::isfinite(x1) || !std::isfinite(y1))
1918         return Exception { NotSupportedError };
1919 
<span class="line-modified">1920     return CanvasGradient::create(FloatPoint(x0, y0), FloatPoint(x1, y1));</span>
1921 }
1922 
1923 ExceptionOr&lt;Ref&lt;CanvasGradient&gt;&gt; CanvasRenderingContext2DBase::createRadialGradient(float x0, float y0, float r0, float x1, float y1, float r1)
1924 {
1925     if (!std::isfinite(x0) || !std::isfinite(y0) || !std::isfinite(r0) || !std::isfinite(x1) || !std::isfinite(y1) || !std::isfinite(r1))
1926         return Exception { NotSupportedError };
1927 
1928     if (r0 &lt; 0 || r1 &lt; 0)
1929         return Exception { IndexSizeError };
1930 
<span class="line-modified">1931     return CanvasGradient::create(FloatPoint(x0, y0), r0, FloatPoint(x1, y1), r1);</span>
1932 }
1933 
1934 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(CanvasImageSource&amp;&amp; image, const String&amp; repetition)
1935 {
1936     bool repeatX, repeatY;
1937     if (!CanvasPattern::parseRepetitionType(repetition, repeatX, repeatY))
1938         return Exception { SyntaxError };
1939 
1940     return WTF::switchOn(image,
1941         [&amp;] (auto&amp; element) -&gt; ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; { return this-&gt;createPattern(*element, repeatX, repeatY); }
1942     );
1943 }
1944 
1945 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(HTMLImageElement&amp; imageElement, bool repeatX, bool repeatY)
1946 {
1947     auto* cachedImage = imageElement.cachedImage();
1948 
1949     // If the image loading hasn&#39;t started or the image is not complete, it is not fully decodable.
1950     if (!cachedImage || !imageElement.complete())
1951         return nullptr;
</pre>
<hr />
<pre>
1977         return Exception { InvalidStateError };
1978 
1979     return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(*copiedImage, repeatX, repeatY, canvas.originClean()) };
1980 }
1981 
1982 #if ENABLE(VIDEO)
1983 
1984 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(HTMLVideoElement&amp; videoElement, bool repeatX, bool repeatY)
1985 {
1986     if (videoElement.readyState() &lt; HTMLMediaElement::HAVE_CURRENT_DATA)
1987         return nullptr;
1988 
1989     checkOrigin(&amp;videoElement);
1990     bool originClean = canvasBase().originClean();
1991 
1992 #if USE(CG) || (ENABLE(ACCELERATED_2D_CANVAS) &amp;&amp; USE(GSTREAMER_GL) &amp;&amp; USE(CAIRO))
1993     if (auto nativeImage = videoElement.nativeImageForCurrentTime())
1994         return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(BitmapImage::create(WTFMove(nativeImage)), repeatX, repeatY, originClean) };
1995 #endif
1996 
<span class="line-modified">1997     auto imageBuffer = ImageBuffer::create(size(videoElement), drawingContext() ? drawingContext()-&gt;renderingMode() : Accelerated);</span>
1998     if (!imageBuffer)
1999         return nullptr;
2000 
2001     videoElement.paintCurrentFrameInContext(imageBuffer-&gt;context(), FloatRect(FloatPoint(), size(videoElement)));
2002 
2003     return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(ImageBuffer::sinkIntoImage(WTFMove(imageBuffer), PreserveResolution::Yes).releaseNonNull(), repeatX, repeatY, originClean) };
2004 }
2005 
2006 #endif
2007 
2008 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(ImageBitmap&amp;, bool, bool)
2009 {
2010     // FIXME: Implement.
2011     return Exception { TypeError };
2012 }
2013 
2014 #if ENABLE(CSS_TYPED_OM)
2015 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(TypedOMCSSImageValue&amp;, bool, bool)
2016 {
2017     // FIXME: Implement.
2018     return Exception { TypeError };
2019 }
2020 #endif
2021 
2022 void CanvasRenderingContext2DBase::didDrawEntireCanvas()
2023 {
2024     didDraw(FloatRect(FloatPoint::zero(), canvasBase().size()), CanvasDidDrawApplyClip);
2025 }
2026 
2027 void CanvasRenderingContext2DBase::didDraw(const FloatRect&amp; r, unsigned options)
2028 {
2029     auto* c = drawingContext();
2030     if (!c)
2031         return;
2032     if (!state().hasInvertibleTransform)
2033         return;
2034 
2035 #if ENABLE(ACCELERATED_2D_CANVAS)
2036     // If we are drawing to hardware and we have a composited layer, just call contentChanged().
<span class="line-modified">2037     if (isAccelerated()) {</span>
2038         auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());
2039         RenderBox* renderBox = canvas.renderBox();
2040         if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing()) {
2041             renderBox-&gt;contentChanged(CanvasPixelsChanged);
2042             canvas.clearCopiedImage();
2043             canvas.notifyObserversCanvasChanged(r);
2044             return;
2045         }
2046     }
2047 #endif
2048 
2049     FloatRect dirtyRect = r;
2050     if (options &amp; CanvasDidDrawApplyTransform) {
2051         AffineTransform ctm = state().transform;
2052         dirtyRect = ctm.mapRect(r);
2053     }
2054 
2055     if (options &amp; CanvasDidDrawApplyShadow &amp;&amp; state().shadowColor.isVisible()) {
2056         // The shadow gets applied after transformation
2057         FloatRect shadowRect(dirtyRect);
</pre>
<hr />
<pre>
2178         return Exception { IndexSizeError };
2179 
2180     if (sw &lt; 0) {
2181         sx += sw;
2182         sw = -sw;
2183     }
2184     if (sh &lt; 0) {
2185         sy += sh;
2186         sh = -sh;
2187     }
2188 
2189     FloatRect logicalRect(sx, sy, sw, sh);
2190     if (logicalRect.width() &lt; 1)
2191         logicalRect.setWidth(1);
2192     if (logicalRect.height() &lt; 1)
2193         logicalRect.setHeight(1);
2194     if (!logicalRect.isExpressibleAsIntRect())
2195         return nullptr;
2196 
2197     IntRect imageDataRect = enclosingIntRect(logicalRect);
<span class="line-removed">2198     auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());</span>
2199 
<span class="line-modified">2200     ImageBuffer* buffer = canvas.buffer();</span>
2201     if (!buffer)
2202         return createEmptyImageData(imageDataRect.size());
2203 
2204     auto byteArray = buffer-&gt;getUnmultipliedImageData(imageDataRect, nullptr, coordinateSystem);
2205     if (!byteArray) {
2206         StringBuilder consoleMessage;
2207         consoleMessage.appendLiteral(&quot;Unable to get image data from canvas. Requested size was &quot;);
2208         consoleMessage.appendNumber(imageDataRect.width());
2209         consoleMessage.appendLiteral(&quot; x &quot;);
2210         consoleMessage.appendNumber(imageDataRect.height());
2211 
2212         canvasBase().scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, consoleMessage.toString());
2213         return Exception { InvalidStateError };
2214     }
2215 
2216     return ImageData::create(imageDataRect.size(), byteArray.releaseNonNull());
2217 }
2218 
2219 void CanvasRenderingContext2DBase::putImageData(ImageData&amp; data, float dx, float dy)
2220 {
2221     putImageData(data, dx, dy, 0, 0, data.width(), data.height());
2222 }
2223 
2224 void CanvasRenderingContext2DBase::putImageData(ImageData&amp; data, float dx, float dy, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight)
2225 {
2226     putImageData(data, ImageBuffer::LogicalCoordinateSystem, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
2227 }
2228 
2229 void CanvasRenderingContext2DBase::putImageData(ImageData&amp; data, ImageBuffer::CoordinateSystem coordinateSystem, float dx, float dy, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight)
2230 {
<span class="line-modified">2231     auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());</span>
<span class="line-removed">2232 </span>
<span class="line-removed">2233     ImageBuffer* buffer = canvas.buffer();</span>
2234     if (!buffer)
2235         return;
2236 
2237     if (!data.data())
2238         return;
2239 
2240     if (dirtyWidth &lt; 0) {
2241         dirtyX += dirtyWidth;
2242         dirtyWidth = -dirtyWidth;
2243     }
2244 
2245     if (dirtyHeight &lt; 0) {
2246         dirtyY += dirtyHeight;
2247         dirtyHeight = -dirtyHeight;
2248     }
2249 
2250     FloatRect clipRect(dirtyX, dirtyY, dirtyWidth, dirtyHeight);
2251     clipRect.intersect(IntRect(0, 0, data.width(), data.height()));
2252     IntSize destOffset(static_cast&lt;int&gt;(dx), static_cast&lt;int&gt;(dy));
2253     IntRect destRect = enclosingIntRect(clipRect);
</pre>
<hr />
<pre>
2266 }
2267 
2268 void CanvasRenderingContext2DBase::inflateStrokeRect(FloatRect&amp; rect) const
2269 {
2270     // Fast approximation of the stroke&#39;s bounding rect.
2271     // This yields a slightly oversized rect but is very fast
2272     // compared to Path::strokeBoundingRect().
2273     static const float root2 = sqrtf(2);
2274     float delta = state().lineWidth / 2;
2275     if (state().lineJoin == MiterJoin)
2276         delta *= state().miterLimit;
2277     else if (state().lineCap == SquareCap)
2278         delta *= root2;
2279     rect.inflate(delta);
2280 }
2281 
2282 #if ENABLE(ACCELERATED_2D_CANVAS)
2283 
2284 PlatformLayer* CanvasRenderingContext2DBase::platformLayer() const
2285 {
<span class="line-modified">2286     auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());</span>

2287 
<span class="line-modified">2288     return canvas.buffer() ? canvas.buffer()-&gt;platformLayer() : nullptr;</span>
2289 }
2290 
2291 #endif
2292 
2293 static inline InterpolationQuality smoothingToInterpolationQuality(ImageSmoothingQuality quality)
2294 {
2295     switch (quality) {
2296     case ImageSmoothingQuality::Low:
<span class="line-modified">2297         return InterpolationLow;</span>
2298     case ImageSmoothingQuality::Medium:
<span class="line-modified">2299         return InterpolationMedium;</span>
2300     case ImageSmoothingQuality::High:
<span class="line-modified">2301         return InterpolationHigh;</span>
2302     }
2303 
2304     ASSERT_NOT_REACHED();
<span class="line-modified">2305     return InterpolationLow;</span>
2306 };
2307 
2308 auto CanvasRenderingContext2DBase::imageSmoothingQuality() const -&gt; ImageSmoothingQuality
2309 {
2310     return state().imageSmoothingQuality;
2311 }
2312 
2313 void CanvasRenderingContext2DBase::setImageSmoothingQuality(ImageSmoothingQuality quality)
2314 {
2315     if (quality == state().imageSmoothingQuality)
2316         return;
2317 
2318     realizeSaves();
2319     modifiableState().imageSmoothingQuality = quality;
2320 
2321     if (!state().imageSmoothingEnabled)
2322         return;
2323 
2324     if (auto* context = drawingContext())
2325         context-&gt;setImageInterpolationQuality(smoothingToInterpolationQuality(quality));
2326 }
2327 
2328 bool CanvasRenderingContext2DBase::imageSmoothingEnabled() const
2329 {
2330     return state().imageSmoothingEnabled;
2331 }
2332 
2333 void CanvasRenderingContext2DBase::setImageSmoothingEnabled(bool enabled)
2334 {
2335     if (enabled == state().imageSmoothingEnabled)
2336         return;
2337 
2338     realizeSaves();
2339     modifiableState().imageSmoothingEnabled = enabled;
2340     auto* c = drawingContext();
2341     if (c)
<span class="line-modified">2342         c-&gt;setImageInterpolationQuality(enabled ? smoothingToInterpolationQuality(state().imageSmoothingQuality) : InterpolationNone);</span>
2343 }
2344 
2345 void CanvasRenderingContext2DBase::setPath(Path2D&amp; path)
2346 {
2347     m_path = path.path();
2348 }
2349 
2350 Ref&lt;Path2D&gt; CanvasRenderingContext2DBase::getPath() const
2351 {
2352     return Path2D::create(m_path);
2353 }
2354 
2355 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 143     , m_stateStack(1)
 144     , m_usesCSSCompatibilityParseMode(usesCSSCompatibilityParseMode)
 145 {
 146 }
 147 
 148 void CanvasRenderingContext2DBase::unwindStateStack()
 149 {
 150     // Ensure that the state stack in the ImageBuffer&#39;s context
 151     // is cleared before destruction, to avoid assertions in the
 152     // GraphicsContext dtor.
 153     if (size_t stackSize = m_stateStack.size()) {
 154         if (auto* context = canvasBase().existingDrawingContext()) {
 155             while (--stackSize)
 156                 context-&gt;restore();
 157         }
 158     }
 159 }
 160 
 161 CanvasRenderingContext2DBase::~CanvasRenderingContext2DBase()
 162 {
<span class="line-modified"> 163 #if ASSERT_ENABLED</span>
 164     unwindStateStack();
 165 #endif
 166 
 167     if (UNLIKELY(tracksDisplayListReplay()))
 168         contextDisplayListMap().remove(this);
 169 }
 170 
 171 bool CanvasRenderingContext2DBase::isAccelerated() const
 172 {
 173 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 174     auto* context = canvasBase().existingDrawingContext();
 175     return context &amp;&amp; context-&gt;isAcceleratedContext();
 176 #else
 177     return false;
 178 #endif
 179 }
 180 
 181 void CanvasRenderingContext2DBase::reset()
 182 {
 183     unwindStateStack();
 184     m_stateStack.resize(1);
 185     m_stateStack.first() = State();
 186     m_path.clear();
 187     m_unrealizedSaveCount = 0;
 188 
 189     m_recordingContext = nullptr;
 190 }
 191 
 192 CanvasRenderingContext2DBase::State::State()
 193     : strokeStyle(Color::black)
 194     , fillStyle(Color::black)
 195     , lineWidth(1)
 196     , lineCap(ButtCap)
 197     , lineJoin(MiterJoin)
 198     , miterLimit(10)
 199     , shadowBlur(0)
 200     , shadowColor(Color::transparent)
 201     , globalAlpha(1)
<span class="line-modified"> 202     , globalComposite(CompositeOperator::SourceOver)</span>
 203     , globalBlend(BlendMode::Normal)
 204     , hasInvertibleTransform(true)
 205     , lineDashOffset(0)
 206     , imageSmoothingEnabled(true)
 207     , imageSmoothingQuality(defaultSmoothingQuality)
 208     , textAlign(StartTextAlign)
 209     , textBaseline(AlphabeticTextBaseline)
 210     , direction(Direction::Inherit)
 211     , unparsedFont(DefaultFont)
 212 {
 213 }
 214 
 215 CanvasRenderingContext2DBase::State::State(const State&amp; other)
 216     : unparsedStrokeColor(other.unparsedStrokeColor)
 217     , unparsedFillColor(other.unparsedFillColor)
 218     , strokeStyle(other.strokeStyle)
 219     , fillStyle(other.fillStyle)
 220     , lineWidth(other.lineWidth)
 221     , lineCap(other.lineCap)
 222     , lineJoin(other.lineJoin)
</pre>
<hr />
<pre>
 385     if (m_stateStack.size() &lt;= 1)
 386         return;
 387     m_path.transform(state().transform);
 388     m_stateStack.removeLast();
 389     if (Optional&lt;AffineTransform&gt; inverse = state().transform.inverse())
 390         m_path.transform(inverse.value());
 391     GraphicsContext* c = drawingContext();
 392     if (!c)
 393         return;
 394     c-&gt;restore();
 395 }
 396 
 397 void CanvasRenderingContext2DBase::setStrokeStyle(CanvasStyle style)
 398 {
 399     if (!style.isValid())
 400         return;
 401 
 402     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentColor(style))
 403         return;
 404 
<span class="line-modified"> 405     if (style.isCurrentColor()) {</span>


 406         if (style.hasOverrideAlpha()) {
 407             // FIXME: Should not use RGBA32 here.
<span class="line-modified"> 408             style = CanvasStyle(colorWithOverrideAlpha(currentColor(canvasBase()).rgb(), style.overrideAlpha()));</span>
 409         } else
<span class="line-modified"> 410             style = CanvasStyle(currentColor(canvasBase()));</span>
 411     } else
 412         checkOrigin(style.canvasPattern().get());
 413 
 414     realizeSaves();
 415     State&amp; state = modifiableState();
 416     state.strokeStyle = style;
 417     GraphicsContext* c = drawingContext();
 418     if (!c)
 419         return;
 420     state.strokeStyle.applyStrokeColor(*c);
 421     state.unparsedStrokeColor = String();
 422 }
 423 
 424 void CanvasRenderingContext2DBase::setFillStyle(CanvasStyle style)
 425 {
 426     if (!style.isValid())
 427         return;
 428 
 429     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentColor(style))
 430         return;
 431 
<span class="line-modified"> 432     if (style.isCurrentColor()) {</span>


 433         if (style.hasOverrideAlpha()) {
 434             // FIXME: Should not use RGBA32 here.
<span class="line-modified"> 435             style = CanvasStyle(colorWithOverrideAlpha(currentColor(canvasBase()).rgb(), style.overrideAlpha()));</span>
 436         } else
<span class="line-modified"> 437             style = CanvasStyle(currentColor(canvasBase()));</span>
 438     } else
 439         checkOrigin(style.canvasPattern().get());
 440 
 441     realizeSaves();
 442     State&amp; state = modifiableState();
 443     state.fillStyle = style;
 444     GraphicsContext* c = drawingContext();
 445     if (!c)
 446         return;
 447     state.fillStyle.applyFillColor(*c);
 448     state.unparsedFillColor = String();
 449 }
 450 
 451 float CanvasRenderingContext2DBase::lineWidth() const
 452 {
 453     return state().lineWidth;
 454 }
 455 
 456 void CanvasRenderingContext2DBase::setLineWidth(float width)
 457 {
</pre>
<hr />
<pre>
 650 }
 651 
 652 void CanvasRenderingContext2DBase::setShadowBlur(float blur)
 653 {
 654     if (!(std::isfinite(blur) &amp;&amp; blur &gt;= 0))
 655         return;
 656     if (state().shadowBlur == blur)
 657         return;
 658     realizeSaves();
 659     modifiableState().shadowBlur = blur;
 660     applyShadow();
 661 }
 662 
 663 String CanvasRenderingContext2DBase::shadowColor() const
 664 {
 665     return Color(state().shadowColor).serialized();
 666 }
 667 
 668 void CanvasRenderingContext2DBase::setShadowColor(const String&amp; colorString)
 669 {
<span class="line-modified"> 670     Color color = parseColorOrCurrentColor(colorString, canvasBase());</span>

 671     if (!color.isValid())
 672         return;
 673     if (state().shadowColor == color)
 674         return;
 675     realizeSaves();
 676     modifiableState().shadowColor = color;
 677     applyShadow();
 678 }
 679 
 680 const Vector&lt;float&gt;&amp; CanvasRenderingContext2DBase::getLineDash() const
 681 {
 682     return state().lineDash;
 683 }
 684 
 685 static bool lineDashSequenceIsValid(const Vector&lt;float&gt;&amp; dash)
 686 {
 687     for (size_t i = 0; i &lt; dash.size(); i++) {
 688         if (!std::isfinite(dash[i]) || dash[i] &lt; 0)
 689             return false;
 690     }
</pre>
<hr />
<pre>
 752 {
 753     if (!(alpha &gt;= 0 &amp;&amp; alpha &lt;= 1))
 754         return;
 755     if (state().globalAlpha == alpha)
 756         return;
 757     realizeSaves();
 758     modifiableState().globalAlpha = alpha;
 759     GraphicsContext* c = drawingContext();
 760     if (!c)
 761         return;
 762     c-&gt;setAlpha(alpha);
 763 }
 764 
 765 String CanvasRenderingContext2DBase::globalCompositeOperation() const
 766 {
 767     return compositeOperatorName(state().globalComposite, state().globalBlend);
 768 }
 769 
 770 void CanvasRenderingContext2DBase::setGlobalCompositeOperation(const String&amp; operation)
 771 {
<span class="line-modified"> 772     CompositeOperator op = CompositeOperator::SourceOver;</span>
 773     BlendMode blendMode = BlendMode::Normal;
 774     if (!parseCompositeAndBlendOperator(operation, op, blendMode))
 775         return;
 776     if ((state().globalComposite == op) &amp;&amp; (state().globalBlend == blendMode))
 777         return;
 778     realizeSaves();
 779     modifiableState().globalComposite = op;
 780     modifiableState().globalBlend = blendMode;
 781     GraphicsContext* c = drawingContext();
 782     if (!c)
 783         return;
 784     c-&gt;setCompositeOperation(op, blendMode);
 785 }
 786 
 787 void CanvasRenderingContext2DBase::scale(float sx, float sy)
 788 {
 789     GraphicsContext* c = drawingContext();
 790     if (!c)
 791         return;
 792     if (!state().hasInvertibleTransform)
</pre>
<hr />
<pre>
 919     if (!c)
 920         return;
 921 
 922     AffineTransform ctm = state().transform;
 923     bool hasInvertibleTransform = state().hasInvertibleTransform;
 924 
 925     realizeSaves();
 926 
 927     c-&gt;setCTM(canvasBase().baseTransform());
 928     modifiableState().transform = AffineTransform();
 929 
 930     if (hasInvertibleTransform)
 931         m_path.transform(ctm);
 932 
 933     modifiableState().hasInvertibleTransform = true;
 934 }
 935 
 936 void CanvasRenderingContext2DBase::setStrokeColor(const String&amp; color, Optional&lt;float&gt; alpha)
 937 {
 938     if (alpha) {
<span class="line-modified"> 939         setStrokeStyle(CanvasStyle::createFromStringWithOverrideAlpha(color, alpha.value(), canvasBase()));</span>
 940         return;
 941     }
 942 
 943     if (color == state().unparsedStrokeColor)
 944         return;
 945 
 946     realizeSaves();
<span class="line-modified"> 947     setStrokeStyle(CanvasStyle::createFromString(color, canvasBase()));</span>
 948     modifiableState().unparsedStrokeColor = color;
 949 }
 950 
 951 void CanvasRenderingContext2DBase::setStrokeColor(float grayLevel, float alpha)
 952 {
 953     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentRGBA(grayLevel, grayLevel, grayLevel, alpha))
 954         return;
 955     setStrokeStyle(CanvasStyle(grayLevel, alpha));
 956 }
 957 
 958 void CanvasRenderingContext2DBase::setStrokeColor(float r, float g, float b, float a)
 959 {
 960     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentRGBA(r, g, b, a))
 961         return;
 962     setStrokeStyle(CanvasStyle(r, g, b, a));
 963 }
 964 
 965 void CanvasRenderingContext2DBase::setStrokeColor(float c, float m, float y, float k, float a)
 966 {
 967     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentCMYKA(c, m, y, k, a))
 968         return;
 969     setStrokeStyle(CanvasStyle(c, m, y, k, a));
 970 }
 971 
 972 void CanvasRenderingContext2DBase::setFillColor(const String&amp; color, Optional&lt;float&gt; alpha)
 973 {
 974     if (alpha) {
<span class="line-modified"> 975         setFillStyle(CanvasStyle::createFromStringWithOverrideAlpha(color, alpha.value(), canvasBase()));</span>
 976         return;
 977     }
 978 
 979     if (color == state().unparsedFillColor)
 980         return;
 981 
 982     realizeSaves();
<span class="line-modified"> 983     setFillStyle(CanvasStyle::createFromString(color, canvasBase()));</span>
 984     modifiableState().unparsedFillColor = color;
 985 }
 986 
 987 void CanvasRenderingContext2DBase::setFillColor(float grayLevel, float alpha)
 988 {
 989     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentRGBA(grayLevel, grayLevel, grayLevel, alpha))
 990         return;
 991     setFillStyle(CanvasStyle(grayLevel, alpha));
 992 }
 993 
 994 void CanvasRenderingContext2DBase::setFillColor(float r, float g, float b, float a)
 995 {
 996     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentRGBA(r, g, b, a))
 997         return;
 998     setFillStyle(CanvasStyle(r, g, b, a));
 999 }
1000 
1001 void CanvasRenderingContext2DBase::setFillColor(float c, float m, float y, float k, float a)
1002 {
1003     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentCMYKA(c, m, y, k, a))
</pre>
<hr />
<pre>
1017 
1018     if (!width &amp;&amp; !height)
1019         return false;
1020 
1021     if (width &lt; 0) {
1022         width = -width;
1023         x -= width;
1024     }
1025 
1026     if (height &lt; 0) {
1027         height = -height;
1028         y -= height;
1029     }
1030 
1031     return true;
1032 }
1033 
1034 bool CanvasRenderingContext2DBase::isFullCanvasCompositeMode(CompositeOperator op)
1035 {
1036     // See 4.8.11.1.3 Compositing
<span class="line-modified">1037     // CompositeOperator::SourceAtop and CompositeOperator::DestinationOut are not listed here as the platforms already</span>
1038     // implement the specification&#39;s behavior.
<span class="line-modified">1039     return op == CompositeOperator::SourceIn || op == CompositeOperator::SourceOut || op == CompositeOperator::DestinationIn || op == CompositeOperator::DestinationAtop;</span>
1040 }
1041 
1042 static WindRule toWindRule(CanvasFillRule rule)
1043 {
1044     return rule == CanvasFillRule::Nonzero ? WindRule::NonZero : WindRule::EvenOdd;
1045 }
1046 
1047 void CanvasRenderingContext2DBase::fill(CanvasFillRule windingRule)
1048 {
1049     fillInternal(m_path, windingRule);
1050 }
1051 
1052 void CanvasRenderingContext2DBase::stroke()
1053 {
1054     strokeInternal(m_path);
1055 }
1056 
1057 void CanvasRenderingContext2DBase::clip(CanvasFillRule windingRule)
1058 {
1059     clipInternal(m_path, windingRule);
</pre>
<hr />
<pre>
1079     auto* c = drawingContext();
1080     if (!c)
1081         return;
1082     if (!state().hasInvertibleTransform)
1083         return;
1084 
1085     // If gradient size is zero, then paint nothing.
1086     auto gradient = c-&gt;fillGradient();
1087     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1088         return;
1089 
1090     if (!path.isEmpty()) {
1091         auto savedFillRule = c-&gt;fillRule();
1092         c-&gt;setFillRule(toWindRule(windingRule));
1093 
1094         if (isFullCanvasCompositeMode(state().globalComposite)) {
1095             beginCompositeLayer();
1096             c-&gt;fillPath(path);
1097             endCompositeLayer();
1098             didDrawEntireCanvas();
<span class="line-modified">1099         } else if (state().globalComposite == CompositeOperator::Copy) {</span>
1100             clearCanvas();
1101             c-&gt;fillPath(path);
1102             didDrawEntireCanvas();
1103         } else {
1104             c-&gt;fillPath(path);
1105             didDraw(path.fastBoundingRect());
1106         }
1107 
1108         c-&gt;setFillRule(savedFillRule);
1109     }
1110 }
1111 
1112 void CanvasRenderingContext2DBase::strokeInternal(const Path&amp; path)
1113 {
1114     auto* c = drawingContext();
1115     if (!c)
1116         return;
1117     if (!state().hasInvertibleTransform)
1118         return;
1119 
1120     // If gradient size is zero, then paint nothing.
1121     auto gradient = c-&gt;strokeGradient();
1122     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1123         return;
1124 
1125     if (!path.isEmpty()) {
1126         if (isFullCanvasCompositeMode(state().globalComposite)) {
1127             beginCompositeLayer();
1128             c-&gt;strokePath(path);
1129             endCompositeLayer();
1130             didDrawEntireCanvas();
<span class="line-modified">1131         } else if (state().globalComposite == CompositeOperator::Copy) {</span>
1132             clearCanvas();
1133             c-&gt;strokePath(path);
1134             didDrawEntireCanvas();
1135         } else {
1136             FloatRect dirtyRect = path.fastBoundingRect();
1137             inflateStrokeRect(dirtyRect);
1138             c-&gt;strokePath(path);
1139             didDraw(dirtyRect);
1140         }
1141     }
1142 }
1143 
1144 void CanvasRenderingContext2DBase::clipInternal(const Path&amp; path, CanvasFillRule windingRule)
1145 {
1146     auto* c = drawingContext();
1147     if (!c)
1148         return;
1149     if (!state().hasInvertibleTransform)
1150         return;
1151 
</pre>
<hr />
<pre>
1199 
1200     if (!std::isfinite(transformedPoint.x()) || !std::isfinite(transformedPoint.y()))
1201         return false;
1202 
1203     return path.contains(transformedPoint, toWindRule(windingRule));
1204 }
1205 
1206 bool CanvasRenderingContext2DBase::isPointInStrokeInternal(const Path&amp; path, float x, float y)
1207 {
1208     auto* c = drawingContext();
1209     if (!c)
1210         return false;
1211     if (!state().hasInvertibleTransform)
1212         return false;
1213 
1214     auto transformedPoint = state().transform.inverse().valueOr(AffineTransform()).mapPoint(FloatPoint(x, y));
1215     if (!std::isfinite(transformedPoint.x()) || !std::isfinite(transformedPoint.y()))
1216         return false;
1217 
1218     CanvasStrokeStyleApplier applier(this);
<span class="line-modified">1219     return path.strokeContains(applier, transformedPoint);</span>
1220 }
1221 
1222 void CanvasRenderingContext2DBase::clearRect(float x, float y, float width, float height)
1223 {
1224     if (!validateRectForCanvas(x, y, width, height))
1225         return;
1226     auto* context = drawingContext();
1227     if (!context)
1228         return;
1229     if (!state().hasInvertibleTransform)
1230         return;
1231     FloatRect rect(x, y, width, height);
1232 
1233     bool saved = false;
1234     if (shouldDrawShadows()) {
1235         context-&gt;save();
1236         saved = true;
1237         context-&gt;setLegacyShadow(FloatSize(), 0, Color::transparent);
1238     }
1239     if (state().globalAlpha != 1) {
1240         if (!saved) {
1241             context-&gt;save();
1242             saved = true;
1243         }
1244         context-&gt;setAlpha(1);
1245     }
<span class="line-modified">1246     if (state().globalComposite != CompositeOperator::SourceOver) {</span>
1247         if (!saved) {
1248             context-&gt;save();
1249             saved = true;
1250         }
<span class="line-modified">1251         context-&gt;setCompositeOperation(CompositeOperator::SourceOver);</span>
1252     }
1253     context-&gt;clearRect(rect);
1254     if (saved)
1255         context-&gt;restore();
1256     didDraw(rect);
1257 }
1258 
1259 void CanvasRenderingContext2DBase::fillRect(float x, float y, float width, float height)
1260 {
1261     if (!validateRectForCanvas(x, y, width, height))
1262         return;
1263 
1264     auto* c = drawingContext();
1265     if (!c)
1266         return;
1267     if (!state().hasInvertibleTransform)
1268         return;
1269 
1270     // from the HTML5 Canvas spec:
1271     // If x0 = x1 and y0 = y1, then the linear gradient must paint nothing
1272     // If x0 = x1 and y0 = y1 and r0 = r1, then the radial gradient must paint nothing
1273     auto gradient = c-&gt;fillGradient();
1274     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1275         return;
1276 
1277     FloatRect rect(x, y, width, height);
1278 
1279     if (rectContainsCanvas(rect)) {
1280         c-&gt;fillRect(rect);
1281         didDrawEntireCanvas();
1282     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1283         beginCompositeLayer();
1284         c-&gt;fillRect(rect);
1285         endCompositeLayer();
1286         didDrawEntireCanvas();
<span class="line-modified">1287     } else if (state().globalComposite == CompositeOperator::Copy) {</span>
1288         clearCanvas();
1289         c-&gt;fillRect(rect);
1290         didDrawEntireCanvas();
1291     } else {
1292         c-&gt;fillRect(rect);
1293         didDraw(rect);
1294     }
1295 }
1296 
1297 void CanvasRenderingContext2DBase::strokeRect(float x, float y, float width, float height)
1298 {
1299     if (!validateRectForCanvas(x, y, width, height))
1300         return;
1301 
1302     auto* c = drawingContext();
1303     if (!c)
1304         return;
1305     if (!state().hasInvertibleTransform)
1306         return;
1307     if (!(state().lineWidth &gt;= 0))
1308         return;
1309 
1310     // If gradient size is zero, then paint nothing.
1311     auto gradient = c-&gt;strokeGradient();
1312     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1313         return;
1314 
1315     FloatRect rect(x, y, width, height);
1316     if (isFullCanvasCompositeMode(state().globalComposite)) {
1317         beginCompositeLayer();
1318         c-&gt;strokeRect(rect, state().lineWidth);
1319         endCompositeLayer();
1320         didDrawEntireCanvas();
<span class="line-modified">1321     } else if (state().globalComposite == CompositeOperator::Copy) {</span>
1322         clearCanvas();
1323         c-&gt;strokeRect(rect, state().lineWidth);
1324         didDrawEntireCanvas();
1325     } else {
1326         FloatRect boundingRect = rect;
1327         boundingRect.inflate(state().lineWidth / 2);
1328         c-&gt;strokeRect(rect, state().lineWidth);
1329         didDraw(boundingRect);
1330     }
1331 }
1332 
1333 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, const String&amp; colorString, Optional&lt;float&gt; alpha)
1334 {
1335     Color color = Color::transparent;
1336     if (!colorString.isNull()) {
<span class="line-modified">1337         color = parseColorOrCurrentColor(colorString, canvasBase());</span>

1338         if (!color.isValid())
1339             return;
1340     }
1341     // FIXME: Should not use RGBA32 here.
1342     setShadow(FloatSize(width, height), blur, colorWithOverrideAlpha(color.rgb(), alpha));
1343 }
1344 
1345 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, float grayLevel, float alpha)
1346 {
1347     setShadow(FloatSize(width, height), blur, Color(grayLevel, grayLevel, grayLevel, alpha));
1348 }
1349 
1350 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, float r, float g, float b, float a)
1351 {
1352     setShadow(FloatSize(width, height), blur, Color(r, g, b, a));
1353 }
1354 
1355 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, float c, float m, float y, float k, float a)
1356 {
1357     setShadow(FloatSize(width, height), blur, Color(c, m, y, k, a));
</pre>
<hr />
<pre>
1390         c-&gt;setLegacyShadow(FloatSize(), 0, Color::transparent);
1391 }
1392 
1393 bool CanvasRenderingContext2DBase::shouldDrawShadows() const
1394 {
1395     return state().shadowColor.isVisible() &amp;&amp; (state().shadowBlur || !state().shadowOffset.isZero());
1396 }
1397 
1398 enum class ImageSizeType { AfterDevicePixelRatio, BeforeDevicePixelRatio };
1399 static LayoutSize size(HTMLImageElement&amp; element, ImageSizeType sizeType = ImageSizeType::BeforeDevicePixelRatio)
1400 {
1401     LayoutSize size;
1402     if (auto* cachedImage = element.cachedImage()) {
1403         size = cachedImage-&gt;imageSizeForRenderer(element.renderer(), 1.0f); // FIXME: Not sure about this.
1404         if (sizeType == ImageSizeType::AfterDevicePixelRatio &amp;&amp; is&lt;RenderImage&gt;(element.renderer()) &amp;&amp; cachedImage-&gt;image() &amp;&amp; !cachedImage-&gt;image()-&gt;hasRelativeWidth())
1405             size.scale(downcast&lt;RenderImage&gt;(*element.renderer()).imageDevicePixelRatio());
1406     }
1407     return size;
1408 }
1409 
<span class="line-modified">1410 static inline FloatSize size(CanvasBase&amp; canvas)</span>
1411 {
<span class="line-modified">1412     return canvas.size();</span>
1413 }
1414 
1415 static inline FloatSize size(ImageBitmap&amp; imageBitmap)
1416 {
1417     return FloatSize { static_cast&lt;float&gt;(imageBitmap.width()), static_cast&lt;float&gt;(imageBitmap.height()) };
1418 }
1419 
1420 #if ENABLE(VIDEO)
1421 
1422 static inline FloatSize size(HTMLVideoElement&amp; video)
1423 {
1424     auto player = video.player();
1425     if (!player)
1426         return { };
1427     return player-&gt;naturalSize();
1428 }
1429 
1430 #endif
1431 
1432 #if ENABLE(CSS_TYPED_OM)
</pre>
<hr />
<pre>
1555         return { };
1556 
1557     RefPtr&lt;Image&gt; image = cachedImage-&gt;imageForRenderer(renderer);
1558     if (!image)
1559         return { };
1560 
1561     ImageObserver* observer = image-&gt;imageObserver();
1562 
1563     if (image-&gt;isSVGImage()) {
1564         image-&gt;setImageObserver(nullptr);
1565         image-&gt;setContainerSize(imageRect.size());
1566     }
1567 
1568     if (image-&gt;isBitmapImage()) {
1569         // Drawing an animated image to a canvas should draw the first frame (except for a few layout tests)
1570         if (image-&gt;isAnimated() &amp;&amp; !document.settings().animatedImageDebugCanvasDrawingEnabled())
1571             image = BitmapImage::create(image-&gt;nativeImage());
1572         downcast&lt;BitmapImage&gt;(*image).updateFromSettings(document.settings());
1573     }
1574 
<span class="line-added">1575     ImagePaintingOptions options = { op, blendMode, ImageOrientation::FromImage };</span>
<span class="line-added">1576 </span>
1577     if (rectContainsCanvas(normalizedDstRect)) {
<span class="line-modified">1578         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, options);</span>
1579         didDrawEntireCanvas();
1580     } else if (isFullCanvasCompositeMode(op)) {
1581         fullCanvasCompositedDrawImage(*image, normalizedDstRect, normalizedSrcRect, op);
1582         didDrawEntireCanvas();
<span class="line-modified">1583     } else if (op == CompositeOperator::Copy) {</span>
1584         clearCanvas();
<span class="line-modified">1585         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, options);</span>
1586         didDrawEntireCanvas();
1587     } else {
<span class="line-modified">1588         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, options);</span>
1589         didDraw(normalizedDstRect);
1590     }
1591 
1592     if (image-&gt;isSVGImage())
1593         image-&gt;setImageObserver(observer);
1594 
1595     return { };
1596 }
1597 
<span class="line-modified">1598 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(CanvasBase&amp; sourceCanvas, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)</span>
1599 {
1600     FloatRect srcCanvasRect = FloatRect(FloatPoint(), sourceCanvas.size());
1601 
1602     if (!srcCanvasRect.width() || !srcCanvasRect.height())
1603         return Exception { InvalidStateError };
1604 
1605     if (!srcRect.width() || !srcRect.height())
1606         return Exception { IndexSizeError };
1607 
1608     if (!srcCanvasRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
1609         return { };
1610 
1611     GraphicsContext* c = drawingContext();
1612     if (!c)
1613         return { };
1614     if (!state().hasInvertibleTransform)
1615         return { };
1616 
1617     // FIXME: Do this through platform-independent GraphicsContext API.
1618     ImageBuffer* buffer = sourceCanvas.buffer();
</pre>
<hr />
<pre>
1621 
1622     checkOrigin(&amp;sourceCanvas);
1623 
1624 #if ENABLE(ACCELERATED_2D_CANVAS)
1625     // If we&#39;re drawing from one accelerated canvas 2d to another, avoid calling sourceCanvas.makeRenderingResultsAvailable()
1626     // as that will do a readback to software.
1627     RefPtr&lt;CanvasRenderingContext&gt; sourceContext = sourceCanvas.renderingContext();
1628     // FIXME: Implement an accelerated path for drawing from a WebGL canvas to a 2d canvas when possible.
1629     if (!isAccelerated() || !sourceContext || !sourceContext-&gt;isAccelerated() || !sourceContext-&gt;is2d())
1630         sourceCanvas.makeRenderingResultsAvailable();
1631 #else
1632     sourceCanvas.makeRenderingResultsAvailable();
1633 #endif
1634 
1635     if (rectContainsCanvas(dstRect)) {
1636         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1637         didDrawEntireCanvas();
1638     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1639         fullCanvasCompositedDrawImage(*buffer, dstRect, srcRect, state().globalComposite);
1640         didDrawEntireCanvas();
<span class="line-modified">1641     } else if (state().globalComposite == CompositeOperator::Copy) {</span>
1642         if (&amp;sourceCanvas == &amp;canvasBase()) {
<span class="line-modified">1643             if (auto copy = buffer-&gt;copyRectToBuffer(srcRect, ColorSpace::SRGB, *c)) {</span>
1644                 clearCanvas();
1645                 c-&gt;drawImageBuffer(*copy, dstRect, { { }, srcRect.size() }, { state().globalComposite, state().globalBlend });
1646             }
1647         } else {
1648             clearCanvas();
1649             c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1650         }
1651         didDrawEntireCanvas();
1652     } else {
1653         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1654         didDraw(dstRect);
1655     }
1656 
1657     return { };
1658 }
1659 
1660 #if ENABLE(VIDEO)
1661 
1662 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLVideoElement&amp; video, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1663 {
</pre>
<hr />
<pre>
1719         return { };
1720 
1721     GraphicsContext* c = drawingContext();
1722     if (!c)
1723         return { };
1724     if (!state().hasInvertibleTransform)
1725         return { };
1726 
1727     ImageBuffer* buffer = imageBitmap.buffer();
1728     if (!buffer)
1729         return { };
1730 
1731     checkOrigin(&amp;imageBitmap);
1732 
1733     if (rectContainsCanvas(dstRect)) {
1734         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1735         didDrawEntireCanvas();
1736     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1737         fullCanvasCompositedDrawImage(*buffer, dstRect, srcRect, state().globalComposite);
1738         didDrawEntireCanvas();
<span class="line-modified">1739     } else if (state().globalComposite == CompositeOperator::Copy) {</span>
1740         clearCanvas();
1741         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1742         didDrawEntireCanvas();
1743     } else {
1744         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1745         didDraw(dstRect);
1746     }
1747 
1748     return { };
1749 }
1750 
1751 void CanvasRenderingContext2DBase::drawImageFromRect(HTMLImageElement&amp; imageElement, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh, const String&amp; compositeOperation)
1752 {
1753     CompositeOperator op;
1754     auto blendOp = BlendMode::Normal;
1755     if (!parseCompositeAndBlendOperator(compositeOperation, op, blendOp) || blendOp != BlendMode::Normal)
<span class="line-modified">1756         op = CompositeOperator::SourceOver;</span>
1757     drawImage(imageElement, FloatRect { sx, sy, sw, sh }, FloatRect { dx, dy, dw, dh }, op, BlendMode::Normal);
1758 }
1759 
1760 void CanvasRenderingContext2DBase::clearCanvas()
1761 {
1762     auto* c = drawingContext();
1763     if (!c)
1764         return;
1765 
1766     c-&gt;save();
1767     c-&gt;setCTM(canvasBase().baseTransform());
1768     c-&gt;clearRect(FloatRect(0, 0, canvasBase().width(), canvasBase().height()));
1769     c-&gt;restore();
1770 }
1771 
1772 Path CanvasRenderingContext2DBase::transformAreaToDevice(const Path&amp; path) const
1773 {
1774     Path transformed(path);
1775     transformed.transform(state().transform);
1776     transformed.transform(canvasBase().baseTransform());
</pre>
<hr />
<pre>
1789     FloatQuad quad(rect);
1790     FloatQuad canvasQuad(FloatRect(0, 0, canvasBase().width(), canvasBase().height()));
1791     return state().transform.mapQuad(quad).containsQuad(canvasQuad);
1792 }
1793 
1794 template&lt;class T&gt; IntRect CanvasRenderingContext2DBase::calculateCompositingBufferRect(const T&amp; area, IntSize* croppedOffset)
1795 {
1796     IntRect canvasRect(0, 0, canvasBase().width(), canvasBase().height());
1797     canvasRect = canvasBase().baseTransform().mapRect(canvasRect);
1798     Path path = transformAreaToDevice(area);
1799     IntRect bufferRect = enclosingIntRect(path.fastBoundingRect());
1800     IntPoint originalLocation = bufferRect.location();
1801     bufferRect.intersect(canvasRect);
1802     if (croppedOffset)
1803         *croppedOffset = originalLocation - bufferRect.location();
1804     return bufferRect;
1805 }
1806 
1807 std::unique_ptr&lt;ImageBuffer&gt; CanvasRenderingContext2DBase::createCompositingBuffer(const IntRect&amp; bufferRect)
1808 {
<span class="line-modified">1809     return ImageBuffer::create(bufferRect.size(), isAccelerated() ? RenderingMode::Accelerated : RenderingMode::Unaccelerated);</span>
1810 }
1811 
1812 void CanvasRenderingContext2DBase::compositeBuffer(ImageBuffer&amp; buffer, const IntRect&amp; bufferRect, CompositeOperator op)
1813 {
1814     IntRect canvasRect(0, 0, canvasBase().width(), canvasBase().height());
1815     canvasRect = canvasBase().baseTransform().mapRect(canvasRect);
1816 
1817     auto* c = drawingContext();
1818     if (!c)
1819         return;
1820 
1821     c-&gt;save();
1822     c-&gt;setCTM(AffineTransform());
1823     c-&gt;setCompositeOperation(op);
1824 
1825     c-&gt;save();
1826     c-&gt;clipOut(bufferRect);
1827     c-&gt;clearRect(canvasRect);
1828     c-&gt;restore();
1829     c-&gt;drawImageBuffer(buffer, bufferRect.location(), state().globalComposite);
</pre>
<hr />
<pre>
1849     if (bufferRect.isEmpty()) {
1850         clearCanvas();
1851         return;
1852     }
1853 
1854     auto buffer = createCompositingBuffer(bufferRect);
1855     if (!buffer)
1856         return;
1857 
1858     auto* c = drawingContext();
1859     if (!c)
1860         return;
1861 
1862     FloatRect adjustedDest = dest;
1863     adjustedDest.setLocation(FloatPoint(0, 0));
1864     AffineTransform effectiveTransform = c-&gt;getCTM();
1865     IntRect transformedAdjustedRect = enclosingIntRect(effectiveTransform.mapRect(adjustedDest));
1866     buffer-&gt;context().translate(-transformedAdjustedRect.location());
1867     buffer-&gt;context().translate(croppedOffset);
1868     buffer-&gt;context().concatCTM(effectiveTransform);
<span class="line-modified">1869     drawImageToContext(image, buffer-&gt;context(), adjustedDest, src, { CompositeOperator::SourceOver });</span>
1870 
1871     compositeBuffer(*buffer, bufferRect, op);
1872 }
1873 
<span class="line-modified">1874 static CanvasRenderingContext2DBase::StyleVariant toStyleVariant(const CanvasStyle&amp; style)</span>
1875 {
1876     if (auto gradient = style.canvasGradient())
1877         return gradient;
1878     if (auto pattern = style.canvasPattern())
1879         return pattern;
1880     return style.color();
1881 }
1882 
<span class="line-modified">1883 CanvasRenderingContext2DBase::StyleVariant CanvasRenderingContext2DBase::strokeStyle() const</span>
1884 {
<span class="line-modified">1885     return toStyleVariant(state().strokeStyle);</span>
1886 }
1887 
<span class="line-modified">1888 void CanvasRenderingContext2DBase::setStrokeStyle(CanvasRenderingContext2DBase::StyleVariant&amp;&amp; style)</span>
1889 {
1890     WTF::switchOn(style,
1891         [this] (const String&amp; string) { this-&gt;setStrokeColor(string); },
1892         [this] (const RefPtr&lt;CanvasGradient&gt;&amp; gradient) { this-&gt;setStrokeStyle(CanvasStyle(*gradient)); },
1893         [this] (const RefPtr&lt;CanvasPattern&gt;&amp; pattern) { this-&gt;setStrokeStyle(CanvasStyle(*pattern)); }
1894     );
1895 }
1896 
<span class="line-modified">1897 CanvasRenderingContext2DBase::StyleVariant CanvasRenderingContext2DBase::fillStyle() const</span>
1898 {
<span class="line-modified">1899     return toStyleVariant(state().fillStyle);</span>
1900 }
1901 
<span class="line-modified">1902 void CanvasRenderingContext2DBase::setFillStyle(CanvasRenderingContext2DBase::StyleVariant&amp;&amp; style)</span>
1903 {
1904     WTF::switchOn(style,
1905         [this] (const String&amp; string) { this-&gt;setFillColor(string); },
1906         [this] (const RefPtr&lt;CanvasGradient&gt;&amp; gradient) { this-&gt;setFillStyle(CanvasStyle(*gradient)); },
1907         [this] (const RefPtr&lt;CanvasPattern&gt;&amp; pattern) { this-&gt;setFillStyle(CanvasStyle(*pattern)); }
1908     );
1909 }
1910 
1911 ExceptionOr&lt;Ref&lt;CanvasGradient&gt;&gt; CanvasRenderingContext2DBase::createLinearGradient(float x0, float y0, float x1, float y1)
1912 {
1913     if (!std::isfinite(x0) || !std::isfinite(y0) || !std::isfinite(x1) || !std::isfinite(y1))
1914         return Exception { NotSupportedError };
1915 
<span class="line-modified">1916     return CanvasGradient::create(FloatPoint(x0, y0), FloatPoint(x1, y1), canvasBase());</span>
1917 }
1918 
1919 ExceptionOr&lt;Ref&lt;CanvasGradient&gt;&gt; CanvasRenderingContext2DBase::createRadialGradient(float x0, float y0, float r0, float x1, float y1, float r1)
1920 {
1921     if (!std::isfinite(x0) || !std::isfinite(y0) || !std::isfinite(r0) || !std::isfinite(x1) || !std::isfinite(y1) || !std::isfinite(r1))
1922         return Exception { NotSupportedError };
1923 
1924     if (r0 &lt; 0 || r1 &lt; 0)
1925         return Exception { IndexSizeError };
1926 
<span class="line-modified">1927     return CanvasGradient::create(FloatPoint(x0, y0), r0, FloatPoint(x1, y1), r1, canvasBase());</span>
1928 }
1929 
1930 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(CanvasImageSource&amp;&amp; image, const String&amp; repetition)
1931 {
1932     bool repeatX, repeatY;
1933     if (!CanvasPattern::parseRepetitionType(repetition, repeatX, repeatY))
1934         return Exception { SyntaxError };
1935 
1936     return WTF::switchOn(image,
1937         [&amp;] (auto&amp; element) -&gt; ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; { return this-&gt;createPattern(*element, repeatX, repeatY); }
1938     );
1939 }
1940 
1941 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(HTMLImageElement&amp; imageElement, bool repeatX, bool repeatY)
1942 {
1943     auto* cachedImage = imageElement.cachedImage();
1944 
1945     // If the image loading hasn&#39;t started or the image is not complete, it is not fully decodable.
1946     if (!cachedImage || !imageElement.complete())
1947         return nullptr;
</pre>
<hr />
<pre>
1973         return Exception { InvalidStateError };
1974 
1975     return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(*copiedImage, repeatX, repeatY, canvas.originClean()) };
1976 }
1977 
1978 #if ENABLE(VIDEO)
1979 
1980 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(HTMLVideoElement&amp; videoElement, bool repeatX, bool repeatY)
1981 {
1982     if (videoElement.readyState() &lt; HTMLMediaElement::HAVE_CURRENT_DATA)
1983         return nullptr;
1984 
1985     checkOrigin(&amp;videoElement);
1986     bool originClean = canvasBase().originClean();
1987 
1988 #if USE(CG) || (ENABLE(ACCELERATED_2D_CANVAS) &amp;&amp; USE(GSTREAMER_GL) &amp;&amp; USE(CAIRO))
1989     if (auto nativeImage = videoElement.nativeImageForCurrentTime())
1990         return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(BitmapImage::create(WTFMove(nativeImage)), repeatX, repeatY, originClean) };
1991 #endif
1992 
<span class="line-modified">1993     auto imageBuffer = ImageBuffer::create(size(videoElement), drawingContext() ? drawingContext()-&gt;renderingMode() : RenderingMode::Accelerated);</span>
1994     if (!imageBuffer)
1995         return nullptr;
1996 
1997     videoElement.paintCurrentFrameInContext(imageBuffer-&gt;context(), FloatRect(FloatPoint(), size(videoElement)));
1998 
1999     return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(ImageBuffer::sinkIntoImage(WTFMove(imageBuffer), PreserveResolution::Yes).releaseNonNull(), repeatX, repeatY, originClean) };
2000 }
2001 
2002 #endif
2003 
2004 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(ImageBitmap&amp;, bool, bool)
2005 {
2006     // FIXME: Implement.
2007     return Exception { TypeError };
2008 }
2009 
2010 #if ENABLE(CSS_TYPED_OM)
2011 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(TypedOMCSSImageValue&amp;, bool, bool)
2012 {
2013     // FIXME: Implement.
2014     return Exception { TypeError };
2015 }
2016 #endif
2017 
2018 void CanvasRenderingContext2DBase::didDrawEntireCanvas()
2019 {
2020     didDraw(FloatRect(FloatPoint::zero(), canvasBase().size()), CanvasDidDrawApplyClip);
2021 }
2022 
2023 void CanvasRenderingContext2DBase::didDraw(const FloatRect&amp; r, unsigned options)
2024 {
2025     auto* c = drawingContext();
2026     if (!c)
2027         return;
2028     if (!state().hasInvertibleTransform)
2029         return;
2030 
2031 #if ENABLE(ACCELERATED_2D_CANVAS)
2032     // If we are drawing to hardware and we have a composited layer, just call contentChanged().
<span class="line-modified">2033     if (isAccelerated() &amp;&amp; is&lt;HTMLCanvasElement&gt;(canvasBase())) {</span>
2034         auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());
2035         RenderBox* renderBox = canvas.renderBox();
2036         if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing()) {
2037             renderBox-&gt;contentChanged(CanvasPixelsChanged);
2038             canvas.clearCopiedImage();
2039             canvas.notifyObserversCanvasChanged(r);
2040             return;
2041         }
2042     }
2043 #endif
2044 
2045     FloatRect dirtyRect = r;
2046     if (options &amp; CanvasDidDrawApplyTransform) {
2047         AffineTransform ctm = state().transform;
2048         dirtyRect = ctm.mapRect(r);
2049     }
2050 
2051     if (options &amp; CanvasDidDrawApplyShadow &amp;&amp; state().shadowColor.isVisible()) {
2052         // The shadow gets applied after transformation
2053         FloatRect shadowRect(dirtyRect);
</pre>
<hr />
<pre>
2174         return Exception { IndexSizeError };
2175 
2176     if (sw &lt; 0) {
2177         sx += sw;
2178         sw = -sw;
2179     }
2180     if (sh &lt; 0) {
2181         sy += sh;
2182         sh = -sh;
2183     }
2184 
2185     FloatRect logicalRect(sx, sy, sw, sh);
2186     if (logicalRect.width() &lt; 1)
2187         logicalRect.setWidth(1);
2188     if (logicalRect.height() &lt; 1)
2189         logicalRect.setHeight(1);
2190     if (!logicalRect.isExpressibleAsIntRect())
2191         return nullptr;
2192 
2193     IntRect imageDataRect = enclosingIntRect(logicalRect);

2194 
<span class="line-modified">2195     ImageBuffer* buffer = canvasBase().buffer();</span>
2196     if (!buffer)
2197         return createEmptyImageData(imageDataRect.size());
2198 
2199     auto byteArray = buffer-&gt;getUnmultipliedImageData(imageDataRect, nullptr, coordinateSystem);
2200     if (!byteArray) {
2201         StringBuilder consoleMessage;
2202         consoleMessage.appendLiteral(&quot;Unable to get image data from canvas. Requested size was &quot;);
2203         consoleMessage.appendNumber(imageDataRect.width());
2204         consoleMessage.appendLiteral(&quot; x &quot;);
2205         consoleMessage.appendNumber(imageDataRect.height());
2206 
2207         canvasBase().scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, consoleMessage.toString());
2208         return Exception { InvalidStateError };
2209     }
2210 
2211     return ImageData::create(imageDataRect.size(), byteArray.releaseNonNull());
2212 }
2213 
2214 void CanvasRenderingContext2DBase::putImageData(ImageData&amp; data, float dx, float dy)
2215 {
2216     putImageData(data, dx, dy, 0, 0, data.width(), data.height());
2217 }
2218 
2219 void CanvasRenderingContext2DBase::putImageData(ImageData&amp; data, float dx, float dy, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight)
2220 {
2221     putImageData(data, ImageBuffer::LogicalCoordinateSystem, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
2222 }
2223 
2224 void CanvasRenderingContext2DBase::putImageData(ImageData&amp; data, ImageBuffer::CoordinateSystem coordinateSystem, float dx, float dy, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight)
2225 {
<span class="line-modified">2226     ImageBuffer* buffer = canvasBase().buffer();</span>


2227     if (!buffer)
2228         return;
2229 
2230     if (!data.data())
2231         return;
2232 
2233     if (dirtyWidth &lt; 0) {
2234         dirtyX += dirtyWidth;
2235         dirtyWidth = -dirtyWidth;
2236     }
2237 
2238     if (dirtyHeight &lt; 0) {
2239         dirtyY += dirtyHeight;
2240         dirtyHeight = -dirtyHeight;
2241     }
2242 
2243     FloatRect clipRect(dirtyX, dirtyY, dirtyWidth, dirtyHeight);
2244     clipRect.intersect(IntRect(0, 0, data.width(), data.height()));
2245     IntSize destOffset(static_cast&lt;int&gt;(dx), static_cast&lt;int&gt;(dy));
2246     IntRect destRect = enclosingIntRect(clipRect);
</pre>
<hr />
<pre>
2259 }
2260 
2261 void CanvasRenderingContext2DBase::inflateStrokeRect(FloatRect&amp; rect) const
2262 {
2263     // Fast approximation of the stroke&#39;s bounding rect.
2264     // This yields a slightly oversized rect but is very fast
2265     // compared to Path::strokeBoundingRect().
2266     static const float root2 = sqrtf(2);
2267     float delta = state().lineWidth / 2;
2268     if (state().lineJoin == MiterJoin)
2269         delta *= state().miterLimit;
2270     else if (state().lineCap == SquareCap)
2271         delta *= root2;
2272     rect.inflate(delta);
2273 }
2274 
2275 #if ENABLE(ACCELERATED_2D_CANVAS)
2276 
2277 PlatformLayer* CanvasRenderingContext2DBase::platformLayer() const
2278 {
<span class="line-modified">2279     if (auto* buffer = canvasBase().buffer())</span>
<span class="line-added">2280         return buffer-&gt;platformLayer();</span>
2281 
<span class="line-modified">2282     return nullptr;</span>
2283 }
2284 
2285 #endif
2286 
2287 static inline InterpolationQuality smoothingToInterpolationQuality(ImageSmoothingQuality quality)
2288 {
2289     switch (quality) {
2290     case ImageSmoothingQuality::Low:
<span class="line-modified">2291         return InterpolationQuality::Low;</span>
2292     case ImageSmoothingQuality::Medium:
<span class="line-modified">2293         return InterpolationQuality::Medium;</span>
2294     case ImageSmoothingQuality::High:
<span class="line-modified">2295         return InterpolationQuality::High;</span>
2296     }
2297 
2298     ASSERT_NOT_REACHED();
<span class="line-modified">2299     return InterpolationQuality::Low;</span>
2300 };
2301 
2302 auto CanvasRenderingContext2DBase::imageSmoothingQuality() const -&gt; ImageSmoothingQuality
2303 {
2304     return state().imageSmoothingQuality;
2305 }
2306 
2307 void CanvasRenderingContext2DBase::setImageSmoothingQuality(ImageSmoothingQuality quality)
2308 {
2309     if (quality == state().imageSmoothingQuality)
2310         return;
2311 
2312     realizeSaves();
2313     modifiableState().imageSmoothingQuality = quality;
2314 
2315     if (!state().imageSmoothingEnabled)
2316         return;
2317 
2318     if (auto* context = drawingContext())
2319         context-&gt;setImageInterpolationQuality(smoothingToInterpolationQuality(quality));
2320 }
2321 
2322 bool CanvasRenderingContext2DBase::imageSmoothingEnabled() const
2323 {
2324     return state().imageSmoothingEnabled;
2325 }
2326 
2327 void CanvasRenderingContext2DBase::setImageSmoothingEnabled(bool enabled)
2328 {
2329     if (enabled == state().imageSmoothingEnabled)
2330         return;
2331 
2332     realizeSaves();
2333     modifiableState().imageSmoothingEnabled = enabled;
2334     auto* c = drawingContext();
2335     if (c)
<span class="line-modified">2336         c-&gt;setImageInterpolationQuality(enabled ? smoothingToInterpolationQuality(state().imageSmoothingQuality) : InterpolationQuality::DoNotInterpolate);</span>
2337 }
2338 
2339 void CanvasRenderingContext2DBase::setPath(Path2D&amp; path)
2340 {
2341     m_path = path.path();
2342 }
2343 
2344 Ref&lt;Path2D&gt; CanvasRenderingContext2DBase::getPath() const
2345 {
2346     return Path2D::create(m_path);
2347 }
2348 
2349 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="CanvasRenderingContext2D.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CanvasRenderingContext2DBase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
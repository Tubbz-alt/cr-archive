diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/Bitmap.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/Bitmap.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/Bitmap.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/Bitmap.h
@@ -1,7 +1,7 @@
 /*
- *  Copyright (C) 2010-2017 Apple Inc. All rights reserved.
+ *  Copyright (C) 2010-2019 Apple Inc. All rights reserved.
  *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Lesser General Public
  *  License as published by the Free Software Foundation; either
  *  version 2 of the License, or (at your option) any later version.
@@ -49,10 +49,11 @@
     bool concurrentTestAndSet(size_t, Dependency = Dependency());
     bool concurrentTestAndClear(size_t, Dependency = Dependency());
     size_t nextPossiblyUnset(size_t) const;
     void clear(size_t);
     void clearAll();
+    void invert();
     int64_t findRunOfZeros(size_t runLength) const;
     size_t count(size_t start = 0) const;
     size_t isEmpty() const;
     size_t isFull() const;
 
@@ -100,37 +101,46 @@
         bool operator!=(const iterator& other) const
         {
             return !(*this == other);
         }
 
+        iterator& operator=(bool value)
+        {
+            m_bitmap->set(m_index, value);
+            return *this;
+        }
+
     private:
         const Bitmap* m_bitmap;
         size_t m_index;
     };
 
     // Use this to iterate over set bits.
     iterator begin() const { return iterator(*this, findBit(0, true)); }
     iterator end() const { return iterator(*this, bitmapSize); }
 
+    iterator operator[](size_t);
+    const iterator operator[](size_t) const;
+
     void mergeAndClear(Bitmap&);
     void setAndClear(Bitmap&);
 
     bool operator==(const Bitmap&) const;
     bool operator!=(const Bitmap&) const;
 
     unsigned hash() const;
 
 private:
-    static const unsigned wordSize = sizeof(WordType) * 8;
-    static const unsigned words = (bitmapSize + wordSize - 1) / wordSize;
+    static constexpr unsigned wordSize = sizeof(WordType) * 8;
+    static constexpr unsigned words = (bitmapSize + wordSize - 1) / wordSize;
 
     // the literal '1' is of type signed int.  We want to use an unsigned
     // version of the correct size when doing the calculations because if
     // WordType is larger than int, '1 << 31' will first be sign extended
     // and then casted to unsigned, meaning that set(31) when WordType is
     // a 64 bit unsigned int would give 0xffff8000
-    static const WordType one = 1;
+    static constexpr WordType one = 1;
 
     std::array<WordType, words> bits;
 };
 
 template<size_t bitmapSize, typename WordType>
@@ -222,10 +232,17 @@
 inline void Bitmap<bitmapSize, WordType>::clearAll()
 {
     memset(bits.data(), 0, sizeof(bits));
 }
 
+template<size_t bitmapSize, typename WordType>
+inline void Bitmap<bitmapSize, WordType>::invert()
+{
+    for (size_t i = 0; i < words; ++i)
+        bits[i] = ~bits[i];
+}
+
 template<size_t bitmapSize, typename WordType>
 inline size_t Bitmap<bitmapSize, WordType>::nextPossiblyUnset(size_t start) const
 {
     if (!~bits[start / wordSize])
         return ((start / wordSize) + 1) * wordSize;
@@ -407,10 +424,23 @@
 inline bool Bitmap<bitmapSize, WordType>::operator!=(const Bitmap& other) const
 {
     return !(*this == other);
 }
 
+template<size_t bitmapSize, typename WordType>
+inline auto Bitmap<bitmapSize, WordType>::operator[](size_t index) -> iterator
+{
+    ASSERT(index < size());
+    return iterator(*this, index);
+}
+
+template<size_t bitmapSize, typename WordType>
+inline auto Bitmap<bitmapSize, WordType>::operator[](size_t index) const -> const iterator
+{
+    return (*const_cast<Bitmap<bitmapSize, WordType>*>(this))[index];
+}
+
 template<size_t bitmapSize, typename WordType>
 inline unsigned Bitmap<bitmapSize, WordType>::hash() const
 {
     unsigned result = 0;
     for (size_t i = 0; i < words; ++i)

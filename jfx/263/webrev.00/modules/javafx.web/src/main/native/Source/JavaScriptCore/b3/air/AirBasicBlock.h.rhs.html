<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirBasicBlock.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;AirFrequentedBlock.h&quot;
 31 #include &quot;AirInst.h&quot;
 32 #include &quot;B3SuccessorCollection.h&quot;
 33 #include &lt;wtf/FastMalloc.h&gt;
 34 #include &lt;wtf/Noncopyable.h&gt;
 35 
 36 namespace JSC { namespace B3 {
 37 
 38 template&lt;typename&gt; class GenericBlockInsertionSet;
 39 
 40 namespace Air {
 41 
 42 class BlockInsertionSet;
 43 class Code;
 44 class InsertionSet;
 45 class PhaseInsertionSet;
 46 
 47 class BasicBlock {
 48     WTF_MAKE_NONCOPYABLE(BasicBlock);
 49     WTF_MAKE_FAST_ALLOCATED;
 50 public:
 51     static const char* const dumpPrefix;
 52 
 53     typedef Vector&lt;Inst&gt; InstList;
 54     typedef Vector&lt;BasicBlock*, 2&gt; PredecessorList;
 55     typedef Vector&lt;FrequentedBlock, 2&gt; SuccessorList;
 56 
 57     unsigned index() const { return m_index; }
 58 
 59     // This method is exposed for phases that mess with the layout of basic blocks. Currently that means just
 60     // optimizeBlockOrder().
 61     void setIndex(unsigned index) { m_index = index; }
 62 
 63     unsigned size() const { return m_insts.size(); }
 64     InstList::iterator begin() { return m_insts.begin(); }
 65     InstList::iterator end() { return m_insts.end(); }
 66     InstList::const_iterator begin() const { return m_insts.begin(); }
 67     InstList::const_iterator end() const { return m_insts.end(); }
 68 
 69     const Inst&amp; at(unsigned index) const { return m_insts[index]; }
 70     Inst&amp; at(unsigned index) { return m_insts[index]; }
 71 
 72     Inst* get(unsigned index)
 73     {
 74         return index &lt; size() ? &amp;at(index) : nullptr;
 75     }
 76 
 77     const Inst&amp; last() const { return m_insts.last(); }
 78     Inst&amp; last() { return m_insts.last(); }
 79 
 80     void resize(unsigned size) { m_insts.resize(size); }
 81 
 82     const InstList&amp; insts() const { return m_insts; }
 83     InstList&amp; insts() { return m_insts; }
 84 
 85     template&lt;typename Inst&gt;
 86     Inst&amp; appendInst(Inst&amp;&amp; inst)
 87     {
 88         m_insts.append(std::forward&lt;Inst&gt;(inst));
 89         return m_insts.last();
 90     }
 91 
 92     template&lt;typename... Arguments&gt;
 93     Inst&amp; append(Arguments&amp;&amp;... arguments)
 94     {
 95         m_insts.append(Inst(std::forward&lt;Arguments&gt;(arguments)...));
 96         return m_insts.last();
 97     }
 98 
 99     // The &quot;0&quot; case is the case to which the branch jumps, so the &quot;then&quot; case. The &quot;1&quot; case is the
100     // &quot;else&quot; case, and is used to represent the fall-through of a conditional branch.
101     unsigned numSuccessors() const { return m_successors.size(); }
102     FrequentedBlock successor(unsigned index) const { return m_successors[index]; }
103     FrequentedBlock&amp; successor(unsigned index) { return m_successors[index]; }
104     const SuccessorList&amp; successors() const { return m_successors; }
105     SuccessorList&amp; successors() { return m_successors; }
106 
<a name="1" id="anc1"></a><span class="line-modified">107     JS_EXPORT_PRIVATE void setSuccessors(FrequentedBlock);</span>
<span class="line-modified">108     JS_EXPORT_PRIVATE void setSuccessors(FrequentedBlock, FrequentedBlock);</span>
109 
110     BasicBlock* successorBlock(unsigned index) const { return successor(index).block(); }
111     BasicBlock*&amp; successorBlock(unsigned index) { return successor(index).block(); }
112     SuccessorCollection&lt;BasicBlock, SuccessorList&gt; successorBlocks()
113     {
114         return SuccessorCollection&lt;BasicBlock, SuccessorList&gt;(m_successors);
115     }
116     SuccessorCollection&lt;const BasicBlock, const SuccessorList&gt; successorBlocks() const
117     {
118         return SuccessorCollection&lt;const BasicBlock, const SuccessorList&gt;(m_successors);
119     }
120 
121     unsigned numPredecessors() const { return m_predecessors.size(); }
122     BasicBlock* predecessor(unsigned index) const { return m_predecessors[index]; }
123     BasicBlock*&amp; predecessor(unsigned index) { return m_predecessors[index]; }
124     const PredecessorList&amp; predecessors() const { return m_predecessors; }
125     PredecessorList&amp; predecessors() { return m_predecessors; }
126 
127     bool addPredecessor(BasicBlock*);
128     bool removePredecessor(BasicBlock*);
129     bool replacePredecessor(BasicBlock* from, BasicBlock* to);
130     bool containsPredecessor(BasicBlock* predecessor) const { return m_predecessors.contains(predecessor); }
131 
132     double frequency() const { return m_frequency; }
133 
134     void dump(PrintStream&amp;) const;
135     void deepDump(PrintStream&amp;) const;
136 
137     void dumpHeader(PrintStream&amp;) const;
138     void dumpFooter(PrintStream&amp;) const;
139 
140 private:
141     friend class BlockInsertionSet;
142     friend class Code;
143     friend class InsertionSet;
144     friend class PhaseInsertionSet;
145     template&lt;typename&gt; friend class B3::GenericBlockInsertionSet;
146 
147     BasicBlock(unsigned index, double frequency);
148 
149     unsigned m_index;
150     InstList m_insts;
151     SuccessorList m_successors;
152     PredecessorList m_predecessors;
153     double m_frequency;
154 };
155 
156 class DeepBasicBlockDump {
157 public:
158     DeepBasicBlockDump(const BasicBlock* block)
159         : m_block(block)
160     {
161     }
162 
163     void dump(PrintStream&amp; out) const
164     {
165         if (m_block)
166             m_block-&gt;deepDump(out);
167         else
168             out.print(&quot;&lt;null&gt;&quot;);
169     }
170 
171 private:
172     const BasicBlock* m_block;
173 };
174 
175 inline DeepBasicBlockDump deepDump(const BasicBlock* block)
176 {
177     return DeepBasicBlockDump(block);
178 }
179 
180 } } } // namespace JSC::B3::Air
181 
182 #endif // ENABLE(B3_JIT)
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
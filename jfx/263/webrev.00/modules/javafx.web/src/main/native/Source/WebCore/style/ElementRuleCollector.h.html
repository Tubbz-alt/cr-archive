<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/ElementRuleCollector.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;MediaQueryEvaluator.h&quot;
 25 #include &quot;RuleSet.h&quot;
 26 #include &quot;SelectorChecker.h&quot;
 27 #include &quot;StyleScope.h&quot;
 28 #include &lt;memory&gt;
 29 #include &lt;wtf/RefPtr.h&gt;
 30 #include &lt;wtf/Vector.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 class SelectorFilter;
 35 
 36 namespace Style {
 37 
 38 class MatchRequest;
 39 class ScopeRuleSets;
 40 
 41 class PseudoElementRequest {
 42 public:
 43     PseudoElementRequest(PseudoId pseudoId, Optional&lt;StyleScrollbarState&gt; scrollbarState = WTF::nullopt)
 44         : pseudoId(pseudoId)
 45         , scrollbarState(scrollbarState)
 46     {
 47     }
 48 
 49     PseudoElementRequest(PseudoId pseudoId, const AtomString&amp; highlightName)
 50         : pseudoId(pseudoId)
 51         , highlightName(highlightName)
 52     {
 53         ASSERT(pseudoId == PseudoId::Highlight);
 54     }
 55 
 56     PseudoId pseudoId;
 57     Optional&lt;StyleScrollbarState&gt; scrollbarState;
 58     AtomString highlightName;
 59 };
 60 
 61 struct MatchedRule {
 62     const RuleData* ruleData;
 63     unsigned specificity;
 64     ScopeOrdinal styleScopeOrdinal;
 65 };
 66 
 67 struct MatchedProperties {
 68     RefPtr&lt;const StyleProperties&gt; properties;
 69     uint16_t linkMatchType { SelectorChecker::MatchAll };
 70     uint16_t whitelistType { PropertyWhitelistNone };
 71     ScopeOrdinal styleScopeOrdinal { ScopeOrdinal::Element };
 72 };
 73 
 74 struct MatchResult {
 75     bool isCacheable { true };
 76     Vector&lt;MatchedProperties&gt; userAgentDeclarations;
 77     Vector&lt;MatchedProperties&gt; userDeclarations;
 78     Vector&lt;MatchedProperties&gt; authorDeclarations;
 79 
 80     bool operator==(const MatchResult&amp; other) const
 81     {
 82         return isCacheable == other.isCacheable
 83             &amp;&amp; userAgentDeclarations == other.userAgentDeclarations
 84             &amp;&amp; userDeclarations == other.userDeclarations
 85             &amp;&amp; authorDeclarations == other.authorDeclarations;
 86     }
 87     bool operator!=(const MatchResult&amp; other) const { return !(*this == other); }
 88 
 89     bool isEmpty() const { return userAgentDeclarations.isEmpty() &amp;&amp; userDeclarations.isEmpty() &amp;&amp; authorDeclarations.isEmpty(); }
 90 };
 91 
 92 class ElementRuleCollector {
 93 public:
 94     ElementRuleCollector(const Element&amp;, const ScopeRuleSets&amp;, const SelectorFilter*);
 95     ElementRuleCollector(const Element&amp;, const RuleSet&amp; authorStyle, const SelectorFilter*);
 96 
 97     void setIncludeEmptyRules(bool value) { m_shouldIncludeEmptyRules = value; }
 98 
 99     void matchAllRules(bool matchAuthorAndUserStyles, bool includeSMILProperties);
100     void matchUARules();
101     void matchAuthorRules();
102     void matchUserRules();
103 
104     bool matchesAnyAuthorRules();
105 
106     void setMode(SelectorChecker::Mode mode) { m_mode = mode; }
107     void setPseudoElementRequest(const PseudoElementRequest&amp; request) { m_pseudoElementRequest = request; }
108     void setMedium(const MediaQueryEvaluator* medium) { m_isPrintStyle = medium-&gt;mediaTypeMatchSpecific(&quot;print&quot;); }
109 
110     bool hasAnyMatchingRules(const RuleSet*);
111 
112     const MatchResult&amp; matchResult() const;
113     const Vector&lt;RefPtr&lt;const StyleRule&gt;&gt;&amp; matchedRuleList() const;
114 
115     void clearMatchedRules();
116 
117     const PseudoIdSet&amp; matchedPseudoElementIds() const { return m_matchedPseudoElementIds; }
118     const Relations&amp; styleRelations() const { return m_styleRelations; }
119     bool didMatchUncommonAttributeSelector() const { return m_didMatchUncommonAttributeSelector; }
120 
121 private:
122     void addElementStyleProperties(const StyleProperties*, bool isCacheable = true);
123 
124     void matchUARules(const RuleSet&amp;);
125 
126     void collectMatchingAuthorRules();
127     void addElementInlineStyleProperties(bool includeSMILProperties);
128 
129     void matchAuthorShadowPseudoElementRules();
130     void matchHostPseudoClassRules();
131     void matchSlottedPseudoElementRules();
132     void matchPartPseudoElementRules();
133     void matchPartPseudoElementRulesForScope(const ShadowRoot&amp; scopeShadowRoot);
134 
135     void collectMatchingShadowPseudoElementRules(const MatchRequest&amp;);
136     std::unique_ptr&lt;RuleSet::RuleDataVector&gt; collectSlottedPseudoElementRulesForSlot();
137 
138     void collectMatchingRules(const MatchRequest&amp;);
139     void collectMatchingRulesForList(const RuleSet::RuleDataVector*, const MatchRequest&amp;);
140     bool ruleMatches(const RuleData&amp;, unsigned &amp;specificity);
141 
142     void sortMatchedRules();
143 
144     enum class DeclarationOrigin { UserAgent, User, Author };
145     static Vector&lt;MatchedProperties&gt;&amp; declarationsForOrigin(MatchResult&amp;, DeclarationOrigin);
146     void sortAndTransferMatchedRules(DeclarationOrigin);
147     void transferMatchedRules(DeclarationOrigin, Optional&lt;ScopeOrdinal&gt; forScope = { });
148 
149     void addMatchedRule(const RuleData&amp;, unsigned specificity, ScopeOrdinal);
150     void addMatchedProperties(MatchedProperties&amp;&amp;, DeclarationOrigin);
151 
152     const Element&amp; element() const { return m_element.get(); }
153 
154     const Ref&lt;const Element&gt; m_element;
155     Ref&lt;const RuleSet&gt; m_authorStyle;
156     RefPtr&lt;const RuleSet&gt; m_userStyle;
157     RefPtr&lt;const RuleSet&gt; m_userAgentMediaQueryStyle;
158     const SelectorFilter* m_selectorFilter;
159 
160     bool m_shouldIncludeEmptyRules { false };
161     bool m_isPrintStyle { false };
162     PseudoElementRequest m_pseudoElementRequest { PseudoId::None };
163     SelectorChecker::Mode m_mode { SelectorChecker::Mode::ResolvingStyle };
164     bool m_isMatchingSlottedPseudoElements { false };
165     bool m_isMatchingHostPseudoClass { false };
166     RefPtr&lt;const Element&gt; m_shadowHostInPartRuleScope;
167     Vector&lt;std::unique_ptr&lt;RuleSet::RuleDataVector&gt;&gt; m_keepAliveSlottedPseudoElementRules;
168 
169     Vector&lt;MatchedRule, 64&gt; m_matchedRules;
170     size_t m_matchedRuleTransferIndex { 0 };
171 
172     // Output.
173     Vector&lt;RefPtr&lt;const StyleRule&gt;&gt; m_matchedRuleList;
174     bool m_didMatchUncommonAttributeSelector { false };
175     MatchResult m_result;
176     Relations m_styleRelations;
177     PseudoIdSet m_matchedPseudoElementIds;
178 };
179 
180 inline bool operator==(const MatchedProperties&amp; a, const MatchedProperties&amp; b)
181 {
182     return a.properties == b.properties &amp;&amp; a.linkMatchType == b.linkMatchType;
183 }
184 
185 inline bool operator!=(const MatchedProperties&amp; a, const MatchedProperties&amp; b)
186 {
187     return !(a == b);
188 }
189 
190 } // namespace Style
191 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchResponse.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FetchRequest.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FetchResponse.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchResponse.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 37 #include &quot;ReadableStreamSink.h&quot;
 38 #include &quot;ResourceError.h&quot;
 39 #include &quot;ScriptExecutionContext.h&quot;
 40 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 // https://fetch.spec.whatwg.org/#null-body-status
 45 static inline bool isNullBodyStatus(int status)
 46 {
 47     return status == 101 || status == 204 || status == 205 || status == 304;
 48 }
 49 
 50 Ref&lt;FetchResponse&gt; FetchResponse::create(ScriptExecutionContext&amp; context, Optional&lt;FetchBody&gt;&amp;&amp; body, FetchHeaders::Guard guard, ResourceResponse&amp;&amp; response)
 51 {
 52     bool isSynthetic = response.type() == ResourceResponse::Type::Default || response.type() == ResourceResponse::Type::Error;
 53     bool isOpaque = response.tainting() == ResourceResponse::Tainting::Opaque;
 54     auto headers = isOpaque ? FetchHeaders::create(guard) : FetchHeaders::create(guard, HTTPHeaderMap { response.httpHeaderFields() });
 55 
 56     auto fetchResponse = adoptRef(*new FetchResponse(context, WTFMove(body), WTFMove(headers), WTFMove(response)));

 57     if (!isSynthetic)
 58         fetchResponse-&gt;m_filteredResponse = ResourceResponseBase::filter(fetchResponse-&gt;m_internalResponse);
 59     if (isOpaque)
 60         fetchResponse-&gt;setBodyAsOpaque();
 61     return fetchResponse;
 62 }
 63 
 64 ExceptionOr&lt;Ref&lt;FetchResponse&gt;&gt; FetchResponse::create(ScriptExecutionContext&amp; context, Optional&lt;FetchBody::Init&gt;&amp;&amp; body, Init&amp;&amp; init)
 65 {
 66     // 1. If init’s status member is not in the range 200 to 599, inclusive, then throw a RangeError.
 67     if (init.status &lt; 200  || init.status &gt; 599)
 68         return Exception { RangeError, &quot;Status must be between 200 and 599&quot;_s };
 69 
 70     // 2. If init’s statusText member does not match the reason-phrase token production, then throw a TypeError.
 71     if (!isValidReasonPhrase(init.statusText))
 72         return Exception { TypeError, &quot;Status text must be a valid reason-phrase.&quot;_s };
 73 
 74     // 3. Let r be a new Response object associated with a new response.
 75     // NOTE: Creation of the Response object is delayed until all potential exceptional cases are handled.
 76 
</pre>
<hr />
<pre>
289 
290 void FetchResponse::BodyLoader::didFail(const ResourceError&amp; error)
291 {
292     ASSERT(m_response.hasPendingActivity());
293 
294     m_response.setLoadingError(ResourceError { error });
295 
296     if (auto responseCallback = WTFMove(m_responseCallback))
297         responseCallback(Exception { TypeError, error.localizedDescription() });
298 
299     if (auto consumeDataCallback = WTFMove(m_consumeDataCallback))
300         consumeDataCallback(Exception { TypeError, error.localizedDescription() });
301 
302 #if ENABLE(STREAMS_API)
303     if (m_response.m_readableStreamSource) {
304         if (!m_response.m_readableStreamSource-&gt;isCancelling())
305             m_response.m_readableStreamSource-&gt;error(*m_response.loadingException());
306         m_response.m_readableStreamSource = nullptr;
307     }
308 #endif


309 
310     // Check whether didFail is called as part of FetchLoader::start.
311     if (m_loader &amp;&amp; m_loader-&gt;isStarted()) {
312         Ref&lt;FetchResponse&gt; protector(m_response);
313         m_response.m_bodyLoader = nullptr;
314     }
315 }
316 
317 FetchResponse::BodyLoader::BodyLoader(FetchResponse&amp; response, NotificationCallback&amp;&amp; responseCallback)
318     : m_response(response)
319     , m_responseCallback(WTFMove(responseCallback))
320     , m_pendingActivity(m_response.makePendingActivity(m_response))
321 {
322 }
323 
324 FetchResponse::BodyLoader::~BodyLoader()
325 {
326 }
327 
328 static uint64_t nextOpaqueLoadIdentifier { 0 };
</pre>
<hr />
<pre>
516 {
517     m_isDisturbed = true;
518     stop();
519 }
520 
521 #endif
522 
523 void FetchResponse::stop()
524 {
525     RefPtr&lt;FetchResponse&gt; protectedThis(this);
526     FetchBodyOwner::stop();
527     if (auto bodyLoader = WTFMove(m_bodyLoader))
528         bodyLoader-&gt;stop();
529 }
530 
531 const char* FetchResponse::activeDOMObjectName() const
532 {
533     return &quot;Response&quot;;
534 }
535 
<span class="line-removed">536 bool FetchResponse::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">537 {</span>
<span class="line-removed">538     // FIXME: We can probably do the same strategy as XHR.</span>
<span class="line-removed">539     return !isActive();</span>
<span class="line-removed">540 }</span>
<span class="line-removed">541 </span>
542 ResourceResponse FetchResponse::resourceResponse() const
543 {
544     auto response = m_internalResponse;
545 
546     if (headers().guard() != FetchHeaders::Guard::Immutable) {
547         // FIXME: Add a setHTTPHeaderFields on ResourceResponseBase.
548         for (auto&amp; header : headers().internalHeaders())
549             response.setHTTPHeaderField(header.key, header.value);
550     }
551 
552     return response;
553 }
554 
555 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 37 #include &quot;ReadableStreamSink.h&quot;
 38 #include &quot;ResourceError.h&quot;
 39 #include &quot;ScriptExecutionContext.h&quot;
 40 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 // https://fetch.spec.whatwg.org/#null-body-status
 45 static inline bool isNullBodyStatus(int status)
 46 {
 47     return status == 101 || status == 204 || status == 205 || status == 304;
 48 }
 49 
 50 Ref&lt;FetchResponse&gt; FetchResponse::create(ScriptExecutionContext&amp; context, Optional&lt;FetchBody&gt;&amp;&amp; body, FetchHeaders::Guard guard, ResourceResponse&amp;&amp; response)
 51 {
 52     bool isSynthetic = response.type() == ResourceResponse::Type::Default || response.type() == ResourceResponse::Type::Error;
 53     bool isOpaque = response.tainting() == ResourceResponse::Tainting::Opaque;
 54     auto headers = isOpaque ? FetchHeaders::create(guard) : FetchHeaders::create(guard, HTTPHeaderMap { response.httpHeaderFields() });
 55 
 56     auto fetchResponse = adoptRef(*new FetchResponse(context, WTFMove(body), WTFMove(headers), WTFMove(response)));
<span class="line-added"> 57     fetchResponse-&gt;updateContentType();</span>
 58     if (!isSynthetic)
 59         fetchResponse-&gt;m_filteredResponse = ResourceResponseBase::filter(fetchResponse-&gt;m_internalResponse);
 60     if (isOpaque)
 61         fetchResponse-&gt;setBodyAsOpaque();
 62     return fetchResponse;
 63 }
 64 
 65 ExceptionOr&lt;Ref&lt;FetchResponse&gt;&gt; FetchResponse::create(ScriptExecutionContext&amp; context, Optional&lt;FetchBody::Init&gt;&amp;&amp; body, Init&amp;&amp; init)
 66 {
 67     // 1. If init’s status member is not in the range 200 to 599, inclusive, then throw a RangeError.
 68     if (init.status &lt; 200  || init.status &gt; 599)
 69         return Exception { RangeError, &quot;Status must be between 200 and 599&quot;_s };
 70 
 71     // 2. If init’s statusText member does not match the reason-phrase token production, then throw a TypeError.
 72     if (!isValidReasonPhrase(init.statusText))
 73         return Exception { TypeError, &quot;Status text must be a valid reason-phrase.&quot;_s };
 74 
 75     // 3. Let r be a new Response object associated with a new response.
 76     // NOTE: Creation of the Response object is delayed until all potential exceptional cases are handled.
 77 
</pre>
<hr />
<pre>
290 
291 void FetchResponse::BodyLoader::didFail(const ResourceError&amp; error)
292 {
293     ASSERT(m_response.hasPendingActivity());
294 
295     m_response.setLoadingError(ResourceError { error });
296 
297     if (auto responseCallback = WTFMove(m_responseCallback))
298         responseCallback(Exception { TypeError, error.localizedDescription() });
299 
300     if (auto consumeDataCallback = WTFMove(m_consumeDataCallback))
301         consumeDataCallback(Exception { TypeError, error.localizedDescription() });
302 
303 #if ENABLE(STREAMS_API)
304     if (m_response.m_readableStreamSource) {
305         if (!m_response.m_readableStreamSource-&gt;isCancelling())
306             m_response.m_readableStreamSource-&gt;error(*m_response.loadingException());
307         m_response.m_readableStreamSource = nullptr;
308     }
309 #endif
<span class="line-added">310     if (m_response.m_body)</span>
<span class="line-added">311         m_response.m_body-&gt;loadingFailed(*m_response.loadingException());</span>
312 
313     // Check whether didFail is called as part of FetchLoader::start.
314     if (m_loader &amp;&amp; m_loader-&gt;isStarted()) {
315         Ref&lt;FetchResponse&gt; protector(m_response);
316         m_response.m_bodyLoader = nullptr;
317     }
318 }
319 
320 FetchResponse::BodyLoader::BodyLoader(FetchResponse&amp; response, NotificationCallback&amp;&amp; responseCallback)
321     : m_response(response)
322     , m_responseCallback(WTFMove(responseCallback))
323     , m_pendingActivity(m_response.makePendingActivity(m_response))
324 {
325 }
326 
327 FetchResponse::BodyLoader::~BodyLoader()
328 {
329 }
330 
331 static uint64_t nextOpaqueLoadIdentifier { 0 };
</pre>
<hr />
<pre>
519 {
520     m_isDisturbed = true;
521     stop();
522 }
523 
524 #endif
525 
526 void FetchResponse::stop()
527 {
528     RefPtr&lt;FetchResponse&gt; protectedThis(this);
529     FetchBodyOwner::stop();
530     if (auto bodyLoader = WTFMove(m_bodyLoader))
531         bodyLoader-&gt;stop();
532 }
533 
534 const char* FetchResponse::activeDOMObjectName() const
535 {
536     return &quot;Response&quot;;
537 }
538 






539 ResourceResponse FetchResponse::resourceResponse() const
540 {
541     auto response = m_internalResponse;
542 
543     if (headers().guard() != FetchHeaders::Guard::Immutable) {
544         // FIXME: Add a setHTTPHeaderFields on ResourceResponseBase.
545         for (auto&amp; header : headers().internalHeaders())
546             response.setHTTPHeaderField(header.key, header.value);
547     }
548 
549     return response;
550 }
551 
552 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="FetchRequest.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FetchResponse.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
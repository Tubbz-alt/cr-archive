<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Keywords.table.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Lexer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 477 /* 112 - p                  */ &#39;p&#39;,
 478 /* 113 - q                  */ &#39;q&#39;,
 479 /* 114 - r                  */ 0x0D,
 480 /* 115 - s                  */ &#39;s&#39;,
 481 /* 116 - t                  */ 0x09,
 482 /* 117 - u                  */ 0,
 483 /* 118 - v                  */ 0x0B,
 484 /* 119 - w                  */ &#39;w&#39;,
 485 /* 120 - x                  */ 0,
 486 /* 121 - y                  */ &#39;y&#39;,
 487 /* 122 - z                  */ &#39;z&#39;,
 488 /* 123 - {                  */ &#39;{&#39;,
 489 /* 124 - |                  */ &#39;|&#39;,
 490 /* 125 - }                  */ &#39;}&#39;,
 491 /* 126 - ~                  */ &#39;~&#39;,
 492 /* 127 - Delete             */ 0
 493 };
 494 
 495 template &lt;typename T&gt;
 496 Lexer&lt;T&gt;::Lexer(VM&amp; vm, JSParserBuiltinMode builtinMode, JSParserScriptMode scriptMode)
<span class="line-modified"> 497     : m_isReparsingFunction(false)</span>

 498     , m_vm(vm)
 499     , m_parsingBuiltinFunction(builtinMode == JSParserBuiltinMode::Builtin)
 500     , m_scriptMode(scriptMode)
 501 {
 502 }
 503 
 504 static inline JSTokenType tokenTypeForIntegerLikeToken(double doubleValue)
 505 {
 506     if ((doubleValue || !std::signbit(doubleValue)) &amp;&amp; static_cast&lt;int64_t&gt;(doubleValue) == doubleValue)
 507         return INTEGER;
 508     return DOUBLE;
 509 }
 510 
 511 template &lt;typename T&gt;
 512 Lexer&lt;T&gt;::~Lexer()
 513 {
 514 }
 515 
 516 template &lt;typename T&gt;
 517 String Lexer&lt;T&gt;::invalidCharacterMessage() const
</pre>
<hr />
<pre>
 888 template &lt;typename T&gt;
 889 inline void Lexer&lt;T&gt;::record16(int c)
 890 {
 891     ASSERT(c &gt;= 0);
 892     ASSERT(c &lt;= static_cast&lt;int&gt;(USHRT_MAX));
 893     m_buffer16.append(static_cast&lt;UChar&gt;(c));
 894 }
 895 
 896 template&lt;typename CharacterType&gt; inline void Lexer&lt;CharacterType&gt;::recordUnicodeCodePoint(UChar32 codePoint)
 897 {
 898     ASSERT(codePoint &gt;= 0);
 899     ASSERT(codePoint &lt;= UCHAR_MAX_VALUE);
 900     if (U_IS_BMP(codePoint))
 901         record16(codePoint);
 902     else {
 903         UChar codeUnits[2] = { U16_LEAD(codePoint), U16_TRAIL(codePoint) };
 904         append16(codeUnits, 2);
 905     }
 906 }
 907 
<span class="line-modified"> 908 #if !ASSERT_DISABLED</span>
 909 bool isSafeBuiltinIdentifier(VM&amp; vm, const Identifier* ident)
 910 {
 911     if (!ident)
 912         return true;
 913     /* Just block any use of suspicious identifiers.  This is intended to
 914      * be used as a safety net while implementing builtins.
 915      */
 916     // FIXME: How can a debug-only assertion be a safety net?
 917     if (*ident == vm.propertyNames-&gt;builtinNames().callPublicName())
 918         return false;
 919     if (*ident == vm.propertyNames-&gt;builtinNames().applyPublicName())
 920         return false;
 921     if (*ident == vm.propertyNames-&gt;eval)
 922         return false;
 923     if (*ident == vm.propertyNames-&gt;Function)
 924         return false;
 925     return true;
 926 }
<span class="line-modified"> 927 #endif</span>
 928 
 929 template &lt;&gt;
<span class="line-modified"> 930 template &lt;bool shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType Lexer&lt;LChar&gt;::parseIdentifier(JSTokenData* tokenData, unsigned lexerFlags, bool strictMode)</span>
 931 {
 932     tokenData-&gt;escaped = false;
 933     const ptrdiff_t remaining = m_codeEnd - m_code;
<span class="line-modified"> 934     if ((remaining &gt;= maxTokenLength) &amp;&amp; !(lexerFlags &amp; LexerFlagsIgnoreReservedWords)) {</span>
 935         JSTokenType keyword = parseKeyword&lt;shouldCreateIdentifier&gt;(tokenData);
 936         if (keyword != IDENT) {
 937             ASSERT((!shouldCreateIdentifier) || tokenData-&gt;ident);
 938             return keyword == RESERVED_IF_STRICT &amp;&amp; !strictMode ? IDENT : keyword;
 939         }
 940     }
 941 
 942     bool isPrivateName = m_current == &#39;@&#39; &amp;&amp; m_parsingBuiltinFunction;
 943     if (isPrivateName)
 944         shift();
 945 
 946     const LChar* identifierStart = currentSourcePtr();
 947     unsigned identifierLineStart = currentLineStartOffset();
 948 
 949     while (isIdentPart(m_current))
 950         shift();
 951 
 952     if (UNLIKELY(m_current == &#39;\\&#39;)) {
 953         setOffsetFromSourcePtr(identifierStart, identifierLineStart);
 954         return parseIdentifierSlowCase&lt;shouldCreateIdentifier&gt;(tokenData, lexerFlags, strictMode);
</pre>
<hr />
<pre>
 958 
 959     if (shouldCreateIdentifier || m_parsingBuiltinFunction) {
 960         int identifierLength = currentSourcePtr() - identifierStart;
 961         ident = makeIdentifier(identifierStart, identifierLength);
 962         if (m_parsingBuiltinFunction) {
 963             if (!isSafeBuiltinIdentifier(m_vm, ident) &amp;&amp; !isPrivateName) {
 964                 m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
 965                 return ERRORTOK;
 966             }
 967             if (isPrivateName)
 968                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm.propertyNames-&gt;lookUpPrivateName(*ident));
 969             else if (*ident == m_vm.propertyNames-&gt;undefinedKeyword)
 970                 tokenData-&gt;ident = &amp;m_vm.propertyNames-&gt;undefinedPrivateName;
 971             if (!ident)
 972                 return INVALID_PRIVATE_NAME_ERRORTOK;
 973         }
 974         tokenData-&gt;ident = ident;
 975     } else
 976         tokenData-&gt;ident = nullptr;
 977 
<span class="line-modified"> 978     if (UNLIKELY((remaining &lt; maxTokenLength) &amp;&amp; !(lexerFlags &amp; LexerFlagsIgnoreReservedWords)) &amp;&amp; !isPrivateName) {</span>
 979         ASSERT(shouldCreateIdentifier);
 980         if (remaining &lt; maxTokenLength) {
 981             const HashTableValue* entry = JSC::mainTable.entry(*ident);
 982             ASSERT((remaining &lt; maxTokenLength) || !entry);
 983             if (!entry)
 984                 return IDENT;
 985             JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
 986             return (token != RESERVED_IF_STRICT) || strictMode ? token : IDENT;
 987         }
 988         return IDENT;
 989     }
 990 
 991     return IDENT;
 992 }
 993 
 994 template &lt;&gt;
<span class="line-modified"> 995 template &lt;bool shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType Lexer&lt;UChar&gt;::parseIdentifier(JSTokenData* tokenData, unsigned lexerFlags, bool strictMode)</span>
 996 {
 997     tokenData-&gt;escaped = false;
 998     const ptrdiff_t remaining = m_codeEnd - m_code;
<span class="line-modified"> 999     if ((remaining &gt;= maxTokenLength) &amp;&amp; !(lexerFlags &amp; LexerFlagsIgnoreReservedWords)) {</span>
1000         JSTokenType keyword = parseKeyword&lt;shouldCreateIdentifier&gt;(tokenData);
1001         if (keyword != IDENT) {
1002             ASSERT((!shouldCreateIdentifier) || tokenData-&gt;ident);
1003             return keyword == RESERVED_IF_STRICT &amp;&amp; !strictMode ? IDENT : keyword;
1004         }
1005     }
1006 
1007     bool isPrivateName = m_current == &#39;@&#39; &amp;&amp; m_parsingBuiltinFunction;
1008     if (isPrivateName)
1009         shift();
1010 
1011     const UChar* identifierStart = currentSourcePtr();
1012     int identifierLineStart = currentLineStartOffset();
1013 
1014     UChar orAllChars = 0;
1015 
1016     while (isIdentPart(m_current)) {
1017         orAllChars |= m_current;
1018         shift();
1019     }
</pre>
<hr />
<pre>
1036         if (isAll8Bit)
1037             ident = makeIdentifierLCharFromUChar(identifierStart, identifierLength);
1038         else
1039             ident = makeIdentifier(identifierStart, identifierLength);
1040         if (m_parsingBuiltinFunction) {
1041             if (!isSafeBuiltinIdentifier(m_vm, ident) &amp;&amp; !isPrivateName) {
1042                 m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
1043                 return ERRORTOK;
1044             }
1045             if (isPrivateName)
1046                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm.propertyNames-&gt;lookUpPrivateName(*ident));
1047             else if (*ident == m_vm.propertyNames-&gt;undefinedKeyword)
1048                 tokenData-&gt;ident = &amp;m_vm.propertyNames-&gt;undefinedPrivateName;
1049             if (!ident)
1050                 return INVALID_PRIVATE_NAME_ERRORTOK;
1051         }
1052         tokenData-&gt;ident = ident;
1053     } else
1054         tokenData-&gt;ident = nullptr;
1055 
<span class="line-modified">1056     if (UNLIKELY((remaining &lt; maxTokenLength) &amp;&amp; !(lexerFlags &amp; LexerFlagsIgnoreReservedWords)) &amp;&amp; !isPrivateName) {</span>
1057         ASSERT(shouldCreateIdentifier);
1058         if (remaining &lt; maxTokenLength) {
1059             const HashTableValue* entry = JSC::mainTable.entry(*ident);
1060             ASSERT((remaining &lt; maxTokenLength) || !entry);
1061             if (!entry)
1062                 return IDENT;
1063             JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
1064             return (token != RESERVED_IF_STRICT) || strictMode ? token : IDENT;
1065         }
1066         return IDENT;
1067     }
1068 
1069     return IDENT;
1070 }
1071 
<span class="line-modified">1072 template&lt;typename CharacterType&gt; template&lt;bool shouldCreateIdentifier&gt; JSTokenType Lexer&lt;CharacterType&gt;::parseIdentifierSlowCase(JSTokenData* tokenData, unsigned lexerFlags, bool strictMode)</span>
1073 {
1074     tokenData-&gt;escaped = true;
1075     auto identifierStart = currentSourcePtr();
1076     bool bufferRequired = false;
1077 
1078     while (true) {
1079         if (LIKELY(isIdentPart(m_current))) {
1080             shift();
1081             continue;
1082         }
1083         if (LIKELY(m_current != &#39;\\&#39;))
1084             break;
1085 
1086         // \uXXXX unicode characters.
1087         bufferRequired = true;
1088         if (identifierStart != currentSourcePtr())
1089             m_buffer16.append(identifierStart, currentSourcePtr() - identifierStart);
1090         shift();
1091         if (UNLIKELY(m_current != &#39;u&#39;))
1092             return atEnd() ? UNTERMINATED_IDENTIFIER_ESCAPE_ERRORTOK : INVALID_IDENTIFIER_ESCAPE_ERRORTOK;
</pre>
<hr />
<pre>
1102     }
1103 
1104     int identifierLength;
1105     const Identifier* ident = nullptr;
1106     if (shouldCreateIdentifier) {
1107         if (!bufferRequired) {
1108             identifierLength = currentSourcePtr() - identifierStart;
1109             ident = makeIdentifier(identifierStart, identifierLength);
1110         } else {
1111             if (identifierStart != currentSourcePtr())
1112                 m_buffer16.append(identifierStart, currentSourcePtr() - identifierStart);
1113             ident = makeIdentifier(m_buffer16.data(), m_buffer16.size());
1114         }
1115 
1116         tokenData-&gt;ident = ident;
1117     } else
1118         tokenData-&gt;ident = nullptr;
1119 
1120     m_buffer16.shrink(0);
1121 
<span class="line-modified">1122     if (LIKELY(!(lexerFlags &amp; LexerFlagsIgnoreReservedWords))) {</span>
1123         ASSERT(shouldCreateIdentifier);
1124         const HashTableValue* entry = JSC::mainTable.entry(*ident);
1125         if (!entry)
1126             return IDENT;
1127         JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
1128         if ((token != RESERVED_IF_STRICT) || strictMode)
1129             return bufferRequired ? UNEXPECTED_ESCAPE_ERRORTOK : token;
1130     }
1131 
1132     return IDENT;
1133 }
1134 
1135 static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(LChar character)
1136 {
1137     return character &lt; 0xE;
1138 }
1139 
1140 static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(UChar character)
1141 {
1142     return character &lt; 0xE || !isLatin1(character);
</pre>
<hr />
<pre>
1842     const T* code = m_code;
1843     while (code &lt; m_codeEnd &amp;&amp; (isWhiteSpace(*code) || isLineTerminator(*code)))
1844         code++;
1845 
1846     return code &lt; m_codeEnd &amp;&amp; *code == &#39;:&#39;;
1847 }
1848 
1849 template &lt;typename T&gt;
1850 void Lexer&lt;T&gt;::fillTokenInfo(JSToken* tokenRecord, JSTokenType token, int lineNumber, int endOffset, int lineStartOffset, JSTextPosition endPosition)
1851 {
1852     JSTokenLocation* tokenLocation = &amp;tokenRecord-&gt;m_location;
1853     tokenLocation-&gt;line = lineNumber;
1854     tokenLocation-&gt;endOffset = endOffset;
1855     tokenLocation-&gt;lineStartOffset = lineStartOffset;
1856     ASSERT(tokenLocation-&gt;endOffset &gt;= tokenLocation-&gt;lineStartOffset);
1857     tokenRecord-&gt;m_endPosition = endPosition;
1858     m_lastToken = token;
1859 }
1860 
1861 template &lt;typename T&gt;
<span class="line-modified">1862 JSTokenType Lexer&lt;T&gt;::lexWithoutClearingLineTerminator(JSToken* tokenRecord, unsigned lexerFlags, bool strictMode)</span>
1863 {
1864     JSTokenData* tokenData = &amp;tokenRecord-&gt;m_data;
1865     JSTokenLocation* tokenLocation = &amp;tokenRecord-&gt;m_location;
1866     m_lastTokenLocation = JSTokenLocation(tokenRecord-&gt;m_location);
1867 
1868     ASSERT(!m_error);
1869     ASSERT(m_buffer8.isEmpty());
1870     ASSERT(m_buffer16.isEmpty());
1871 
1872     JSTokenType token = ERRORTOK;
1873 
1874 start:
1875     skipWhitespace();
1876 
1877     tokenLocation-&gt;startOffset = currentOffset();
1878     ASSERT(currentOffset() &gt;= currentLineStartOffset());
1879     tokenRecord-&gt;m_startPosition = currentPosition();
1880 
1881     if (atEnd()) {
1882         token = EOFTOK;
</pre>
<hr />
<pre>
2120         shift();
2121         break;
2122     case CharacterOpenBracket:
2123         token = OPENBRACKET;
2124         shift();
2125         break;
2126     case CharacterCloseBracket:
2127         token = CLOSEBRACKET;
2128         shift();
2129         break;
2130     case CharacterComma:
2131         token = COMMA;
2132         shift();
2133         break;
2134     case CharacterColon:
2135         token = COLON;
2136         shift();
2137         break;
2138     case CharacterQuestion:
2139         shift();
<span class="line-modified">2140         if (Options::useNullishAwareOperators()) {</span>
<span class="line-modified">2141             if (m_current == &#39;?&#39;) {</span>
<span class="line-modified">2142                 shift();</span>
<span class="line-modified">2143                 token = COALESCE;</span>
<span class="line-modified">2144                 break;</span>
<span class="line-modified">2145             }</span>
<span class="line-modified">2146             if (m_current == &#39;.&#39; &amp;&amp; !isASCIIDigit(peek(1))) {</span>
<span class="line-modified">2147                 shift();</span>
<span class="line-modified">2148                 token = QUESTIONDOT;</span>
<span class="line-removed">2149                 break;</span>
<span class="line-removed">2150             }</span>
2151         }
2152         token = QUESTION;
2153         break;
2154     case CharacterTilde:
2155         token = TILDE;
2156         shift();
2157         break;
2158     case CharacterSemicolon:
2159         shift();
2160         token = SEMICOLON;
2161         break;
2162     case CharacterBackQuote:
2163         shift();
2164         token = BACKQUOTE;
2165         break;
2166     case CharacterOpenBrace:
2167         tokenData-&gt;line = lineNumber();
2168         tokenData-&gt;offset = currentOffset();
2169         tokenData-&gt;lineStartOffset = currentLineStartOffset();
2170         ASSERT(tokenData-&gt;offset &gt;= tokenData-&gt;lineStartOffset);
</pre>
<hr />
<pre>
2362                     m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;
2363                     token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2364                     goto returnError;
2365                 }
2366                 size_t parsedLength;
2367                 tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);
2368                 if (token == INTEGER)
2369                     token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2370             }
2371         }
2372 
2373         if (UNLIKELY(isIdentStart(m_current))) {
2374             m_lexErrorMessage = &quot;No identifiers allowed directly after numeric literal&quot;_s;
2375             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2376             goto returnError;
2377         }
2378         m_buffer8.shrink(0);
2379         break;
2380     case CharacterQuote: {
2381         StringParseResult result = StringCannotBeParsed;
<span class="line-modified">2382         if (lexerFlags &amp; LexerFlagsDontBuildStrings)</span>
2383             result = parseString&lt;false&gt;(tokenData, strictMode);
2384         else
2385             result = parseString&lt;true&gt;(tokenData, strictMode);
2386 
2387         if (UNLIKELY(result != StringParsedSuccessfully)) {
2388             token = result == StringUnterminated ? UNTERMINATED_STRING_LITERAL_ERRORTOK : INVALID_STRING_LITERAL_ERRORTOK;
2389             goto returnError;
2390         }
2391         shift();
2392         token = STRING;
2393         break;
2394         }
2395     case CharacterIdentifierStart:
2396         ASSERT(isIdentStart(m_current));
2397         FALLTHROUGH;
2398     case CharacterBackSlash:
2399         parseIdent:
<span class="line-modified">2400         if (lexerFlags &amp; LexexFlagsDontBuildKeywords)</span>
2401             token = parseIdentifier&lt;false&gt;(tokenData, lexerFlags, strictMode);
2402         else
2403             token = parseIdentifier&lt;true&gt;(tokenData, lexerFlags, strictMode);
2404         break;
2405     case CharacterLineTerminator:
2406         ASSERT(isLineTerminator(m_current));
2407         shiftLineTerminator();
2408         m_atLineStart = true;
2409         m_hasLineTerminatorBeforeToken = true;
2410         m_lineStart = m_code;
2411         goto start;
2412     case CharacterHash:
2413         // Hashbang is only permitted at the start of the source text.
2414         if (peek(1) == &#39;!&#39; &amp;&amp; !currentOffset()) {
2415             shift();
2416             shift();
2417             goto inSingleLineComment;
2418         }
2419         goto invalidCharacter;
2420     case CharacterPrivateIdentifierStart:
</pre>
</td>
<td>
<hr />
<pre>
 477 /* 112 - p                  */ &#39;p&#39;,
 478 /* 113 - q                  */ &#39;q&#39;,
 479 /* 114 - r                  */ 0x0D,
 480 /* 115 - s                  */ &#39;s&#39;,
 481 /* 116 - t                  */ 0x09,
 482 /* 117 - u                  */ 0,
 483 /* 118 - v                  */ 0x0B,
 484 /* 119 - w                  */ &#39;w&#39;,
 485 /* 120 - x                  */ 0,
 486 /* 121 - y                  */ &#39;y&#39;,
 487 /* 122 - z                  */ &#39;z&#39;,
 488 /* 123 - {                  */ &#39;{&#39;,
 489 /* 124 - |                  */ &#39;|&#39;,
 490 /* 125 - }                  */ &#39;}&#39;,
 491 /* 126 - ~                  */ &#39;~&#39;,
 492 /* 127 - Delete             */ 0
 493 };
 494 
 495 template &lt;typename T&gt;
 496 Lexer&lt;T&gt;::Lexer(VM&amp; vm, JSParserBuiltinMode builtinMode, JSParserScriptMode scriptMode)
<span class="line-modified"> 497     : m_positionBeforeLastNewline(0,0,0)</span>
<span class="line-added"> 498     , m_isReparsingFunction(false)</span>
 499     , m_vm(vm)
 500     , m_parsingBuiltinFunction(builtinMode == JSParserBuiltinMode::Builtin)
 501     , m_scriptMode(scriptMode)
 502 {
 503 }
 504 
 505 static inline JSTokenType tokenTypeForIntegerLikeToken(double doubleValue)
 506 {
 507     if ((doubleValue || !std::signbit(doubleValue)) &amp;&amp; static_cast&lt;int64_t&gt;(doubleValue) == doubleValue)
 508         return INTEGER;
 509     return DOUBLE;
 510 }
 511 
 512 template &lt;typename T&gt;
 513 Lexer&lt;T&gt;::~Lexer()
 514 {
 515 }
 516 
 517 template &lt;typename T&gt;
 518 String Lexer&lt;T&gt;::invalidCharacterMessage() const
</pre>
<hr />
<pre>
 889 template &lt;typename T&gt;
 890 inline void Lexer&lt;T&gt;::record16(int c)
 891 {
 892     ASSERT(c &gt;= 0);
 893     ASSERT(c &lt;= static_cast&lt;int&gt;(USHRT_MAX));
 894     m_buffer16.append(static_cast&lt;UChar&gt;(c));
 895 }
 896 
 897 template&lt;typename CharacterType&gt; inline void Lexer&lt;CharacterType&gt;::recordUnicodeCodePoint(UChar32 codePoint)
 898 {
 899     ASSERT(codePoint &gt;= 0);
 900     ASSERT(codePoint &lt;= UCHAR_MAX_VALUE);
 901     if (U_IS_BMP(codePoint))
 902         record16(codePoint);
 903     else {
 904         UChar codeUnits[2] = { U16_LEAD(codePoint), U16_TRAIL(codePoint) };
 905         append16(codeUnits, 2);
 906     }
 907 }
 908 
<span class="line-modified"> 909 #if ASSERT_ENABLED</span>
 910 bool isSafeBuiltinIdentifier(VM&amp; vm, const Identifier* ident)
 911 {
 912     if (!ident)
 913         return true;
 914     /* Just block any use of suspicious identifiers.  This is intended to
 915      * be used as a safety net while implementing builtins.
 916      */
 917     // FIXME: How can a debug-only assertion be a safety net?
 918     if (*ident == vm.propertyNames-&gt;builtinNames().callPublicName())
 919         return false;
 920     if (*ident == vm.propertyNames-&gt;builtinNames().applyPublicName())
 921         return false;
 922     if (*ident == vm.propertyNames-&gt;eval)
 923         return false;
 924     if (*ident == vm.propertyNames-&gt;Function)
 925         return false;
 926     return true;
 927 }
<span class="line-modified"> 928 #endif // ASSERT_ENABLED</span>
 929 
 930 template &lt;&gt;
<span class="line-modified"> 931 template &lt;bool shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType Lexer&lt;LChar&gt;::parseIdentifier(JSTokenData* tokenData, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
 932 {
 933     tokenData-&gt;escaped = false;
 934     const ptrdiff_t remaining = m_codeEnd - m_code;
<span class="line-modified"> 935     if ((remaining &gt;= maxTokenLength) &amp;&amp; !lexerFlags.contains(LexerFlags::IgnoreReservedWords)) {</span>
 936         JSTokenType keyword = parseKeyword&lt;shouldCreateIdentifier&gt;(tokenData);
 937         if (keyword != IDENT) {
 938             ASSERT((!shouldCreateIdentifier) || tokenData-&gt;ident);
 939             return keyword == RESERVED_IF_STRICT &amp;&amp; !strictMode ? IDENT : keyword;
 940         }
 941     }
 942 
 943     bool isPrivateName = m_current == &#39;@&#39; &amp;&amp; m_parsingBuiltinFunction;
 944     if (isPrivateName)
 945         shift();
 946 
 947     const LChar* identifierStart = currentSourcePtr();
 948     unsigned identifierLineStart = currentLineStartOffset();
 949 
 950     while (isIdentPart(m_current))
 951         shift();
 952 
 953     if (UNLIKELY(m_current == &#39;\\&#39;)) {
 954         setOffsetFromSourcePtr(identifierStart, identifierLineStart);
 955         return parseIdentifierSlowCase&lt;shouldCreateIdentifier&gt;(tokenData, lexerFlags, strictMode);
</pre>
<hr />
<pre>
 959 
 960     if (shouldCreateIdentifier || m_parsingBuiltinFunction) {
 961         int identifierLength = currentSourcePtr() - identifierStart;
 962         ident = makeIdentifier(identifierStart, identifierLength);
 963         if (m_parsingBuiltinFunction) {
 964             if (!isSafeBuiltinIdentifier(m_vm, ident) &amp;&amp; !isPrivateName) {
 965                 m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
 966                 return ERRORTOK;
 967             }
 968             if (isPrivateName)
 969                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm.propertyNames-&gt;lookUpPrivateName(*ident));
 970             else if (*ident == m_vm.propertyNames-&gt;undefinedKeyword)
 971                 tokenData-&gt;ident = &amp;m_vm.propertyNames-&gt;undefinedPrivateName;
 972             if (!ident)
 973                 return INVALID_PRIVATE_NAME_ERRORTOK;
 974         }
 975         tokenData-&gt;ident = ident;
 976     } else
 977         tokenData-&gt;ident = nullptr;
 978 
<span class="line-modified"> 979     if (UNLIKELY((remaining &lt; maxTokenLength) &amp;&amp; !lexerFlags.contains(LexerFlags::IgnoreReservedWords)) &amp;&amp; !isPrivateName) {</span>
 980         ASSERT(shouldCreateIdentifier);
 981         if (remaining &lt; maxTokenLength) {
 982             const HashTableValue* entry = JSC::mainTable.entry(*ident);
 983             ASSERT((remaining &lt; maxTokenLength) || !entry);
 984             if (!entry)
 985                 return IDENT;
 986             JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
 987             return (token != RESERVED_IF_STRICT) || strictMode ? token : IDENT;
 988         }
 989         return IDENT;
 990     }
 991 
 992     return IDENT;
 993 }
 994 
 995 template &lt;&gt;
<span class="line-modified"> 996 template &lt;bool shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType Lexer&lt;UChar&gt;::parseIdentifier(JSTokenData* tokenData, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
 997 {
 998     tokenData-&gt;escaped = false;
 999     const ptrdiff_t remaining = m_codeEnd - m_code;
<span class="line-modified">1000     if ((remaining &gt;= maxTokenLength) &amp;&amp; !lexerFlags.contains(LexerFlags::IgnoreReservedWords)) {</span>
1001         JSTokenType keyword = parseKeyword&lt;shouldCreateIdentifier&gt;(tokenData);
1002         if (keyword != IDENT) {
1003             ASSERT((!shouldCreateIdentifier) || tokenData-&gt;ident);
1004             return keyword == RESERVED_IF_STRICT &amp;&amp; !strictMode ? IDENT : keyword;
1005         }
1006     }
1007 
1008     bool isPrivateName = m_current == &#39;@&#39; &amp;&amp; m_parsingBuiltinFunction;
1009     if (isPrivateName)
1010         shift();
1011 
1012     const UChar* identifierStart = currentSourcePtr();
1013     int identifierLineStart = currentLineStartOffset();
1014 
1015     UChar orAllChars = 0;
1016 
1017     while (isIdentPart(m_current)) {
1018         orAllChars |= m_current;
1019         shift();
1020     }
</pre>
<hr />
<pre>
1037         if (isAll8Bit)
1038             ident = makeIdentifierLCharFromUChar(identifierStart, identifierLength);
1039         else
1040             ident = makeIdentifier(identifierStart, identifierLength);
1041         if (m_parsingBuiltinFunction) {
1042             if (!isSafeBuiltinIdentifier(m_vm, ident) &amp;&amp; !isPrivateName) {
1043                 m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
1044                 return ERRORTOK;
1045             }
1046             if (isPrivateName)
1047                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm.propertyNames-&gt;lookUpPrivateName(*ident));
1048             else if (*ident == m_vm.propertyNames-&gt;undefinedKeyword)
1049                 tokenData-&gt;ident = &amp;m_vm.propertyNames-&gt;undefinedPrivateName;
1050             if (!ident)
1051                 return INVALID_PRIVATE_NAME_ERRORTOK;
1052         }
1053         tokenData-&gt;ident = ident;
1054     } else
1055         tokenData-&gt;ident = nullptr;
1056 
<span class="line-modified">1057     if (UNLIKELY((remaining &lt; maxTokenLength) &amp;&amp; !lexerFlags.contains(LexerFlags::IgnoreReservedWords)) &amp;&amp; !isPrivateName) {</span>
1058         ASSERT(shouldCreateIdentifier);
1059         if (remaining &lt; maxTokenLength) {
1060             const HashTableValue* entry = JSC::mainTable.entry(*ident);
1061             ASSERT((remaining &lt; maxTokenLength) || !entry);
1062             if (!entry)
1063                 return IDENT;
1064             JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
1065             return (token != RESERVED_IF_STRICT) || strictMode ? token : IDENT;
1066         }
1067         return IDENT;
1068     }
1069 
1070     return IDENT;
1071 }
1072 
<span class="line-modified">1073 template&lt;typename CharacterType&gt; template&lt;bool shouldCreateIdentifier&gt; JSTokenType Lexer&lt;CharacterType&gt;::parseIdentifierSlowCase(JSTokenData* tokenData, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
1074 {
1075     tokenData-&gt;escaped = true;
1076     auto identifierStart = currentSourcePtr();
1077     bool bufferRequired = false;
1078 
1079     while (true) {
1080         if (LIKELY(isIdentPart(m_current))) {
1081             shift();
1082             continue;
1083         }
1084         if (LIKELY(m_current != &#39;\\&#39;))
1085             break;
1086 
1087         // \uXXXX unicode characters.
1088         bufferRequired = true;
1089         if (identifierStart != currentSourcePtr())
1090             m_buffer16.append(identifierStart, currentSourcePtr() - identifierStart);
1091         shift();
1092         if (UNLIKELY(m_current != &#39;u&#39;))
1093             return atEnd() ? UNTERMINATED_IDENTIFIER_ESCAPE_ERRORTOK : INVALID_IDENTIFIER_ESCAPE_ERRORTOK;
</pre>
<hr />
<pre>
1103     }
1104 
1105     int identifierLength;
1106     const Identifier* ident = nullptr;
1107     if (shouldCreateIdentifier) {
1108         if (!bufferRequired) {
1109             identifierLength = currentSourcePtr() - identifierStart;
1110             ident = makeIdentifier(identifierStart, identifierLength);
1111         } else {
1112             if (identifierStart != currentSourcePtr())
1113                 m_buffer16.append(identifierStart, currentSourcePtr() - identifierStart);
1114             ident = makeIdentifier(m_buffer16.data(), m_buffer16.size());
1115         }
1116 
1117         tokenData-&gt;ident = ident;
1118     } else
1119         tokenData-&gt;ident = nullptr;
1120 
1121     m_buffer16.shrink(0);
1122 
<span class="line-modified">1123     if (LIKELY(!lexerFlags.contains(LexerFlags::IgnoreReservedWords))) {</span>
1124         ASSERT(shouldCreateIdentifier);
1125         const HashTableValue* entry = JSC::mainTable.entry(*ident);
1126         if (!entry)
1127             return IDENT;
1128         JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
1129         if ((token != RESERVED_IF_STRICT) || strictMode)
1130             return bufferRequired ? UNEXPECTED_ESCAPE_ERRORTOK : token;
1131     }
1132 
1133     return IDENT;
1134 }
1135 
1136 static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(LChar character)
1137 {
1138     return character &lt; 0xE;
1139 }
1140 
1141 static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(UChar character)
1142 {
1143     return character &lt; 0xE || !isLatin1(character);
</pre>
<hr />
<pre>
1843     const T* code = m_code;
1844     while (code &lt; m_codeEnd &amp;&amp; (isWhiteSpace(*code) || isLineTerminator(*code)))
1845         code++;
1846 
1847     return code &lt; m_codeEnd &amp;&amp; *code == &#39;:&#39;;
1848 }
1849 
1850 template &lt;typename T&gt;
1851 void Lexer&lt;T&gt;::fillTokenInfo(JSToken* tokenRecord, JSTokenType token, int lineNumber, int endOffset, int lineStartOffset, JSTextPosition endPosition)
1852 {
1853     JSTokenLocation* tokenLocation = &amp;tokenRecord-&gt;m_location;
1854     tokenLocation-&gt;line = lineNumber;
1855     tokenLocation-&gt;endOffset = endOffset;
1856     tokenLocation-&gt;lineStartOffset = lineStartOffset;
1857     ASSERT(tokenLocation-&gt;endOffset &gt;= tokenLocation-&gt;lineStartOffset);
1858     tokenRecord-&gt;m_endPosition = endPosition;
1859     m_lastToken = token;
1860 }
1861 
1862 template &lt;typename T&gt;
<span class="line-modified">1863 JSTokenType Lexer&lt;T&gt;::lexWithoutClearingLineTerminator(JSToken* tokenRecord, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
1864 {
1865     JSTokenData* tokenData = &amp;tokenRecord-&gt;m_data;
1866     JSTokenLocation* tokenLocation = &amp;tokenRecord-&gt;m_location;
1867     m_lastTokenLocation = JSTokenLocation(tokenRecord-&gt;m_location);
1868 
1869     ASSERT(!m_error);
1870     ASSERT(m_buffer8.isEmpty());
1871     ASSERT(m_buffer16.isEmpty());
1872 
1873     JSTokenType token = ERRORTOK;
1874 
1875 start:
1876     skipWhitespace();
1877 
1878     tokenLocation-&gt;startOffset = currentOffset();
1879     ASSERT(currentOffset() &gt;= currentLineStartOffset());
1880     tokenRecord-&gt;m_startPosition = currentPosition();
1881 
1882     if (atEnd()) {
1883         token = EOFTOK;
</pre>
<hr />
<pre>
2121         shift();
2122         break;
2123     case CharacterOpenBracket:
2124         token = OPENBRACKET;
2125         shift();
2126         break;
2127     case CharacterCloseBracket:
2128         token = CLOSEBRACKET;
2129         shift();
2130         break;
2131     case CharacterComma:
2132         token = COMMA;
2133         shift();
2134         break;
2135     case CharacterColon:
2136         token = COLON;
2137         shift();
2138         break;
2139     case CharacterQuestion:
2140         shift();
<span class="line-modified">2141         if (m_current == &#39;?&#39;) {</span>
<span class="line-modified">2142             shift();</span>
<span class="line-modified">2143             token = COALESCE;</span>
<span class="line-modified">2144             break;</span>
<span class="line-modified">2145         }</span>
<span class="line-modified">2146         if (m_current == &#39;.&#39; &amp;&amp; !isASCIIDigit(peek(1))) {</span>
<span class="line-modified">2147             shift();</span>
<span class="line-modified">2148             token = QUESTIONDOT;</span>
<span class="line-modified">2149             break;</span>


2150         }
2151         token = QUESTION;
2152         break;
2153     case CharacterTilde:
2154         token = TILDE;
2155         shift();
2156         break;
2157     case CharacterSemicolon:
2158         shift();
2159         token = SEMICOLON;
2160         break;
2161     case CharacterBackQuote:
2162         shift();
2163         token = BACKQUOTE;
2164         break;
2165     case CharacterOpenBrace:
2166         tokenData-&gt;line = lineNumber();
2167         tokenData-&gt;offset = currentOffset();
2168         tokenData-&gt;lineStartOffset = currentLineStartOffset();
2169         ASSERT(tokenData-&gt;offset &gt;= tokenData-&gt;lineStartOffset);
</pre>
<hr />
<pre>
2361                     m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;
2362                     token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2363                     goto returnError;
2364                 }
2365                 size_t parsedLength;
2366                 tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);
2367                 if (token == INTEGER)
2368                     token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2369             }
2370         }
2371 
2372         if (UNLIKELY(isIdentStart(m_current))) {
2373             m_lexErrorMessage = &quot;No identifiers allowed directly after numeric literal&quot;_s;
2374             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2375             goto returnError;
2376         }
2377         m_buffer8.shrink(0);
2378         break;
2379     case CharacterQuote: {
2380         StringParseResult result = StringCannotBeParsed;
<span class="line-modified">2381         if (lexerFlags.contains(LexerFlags::DontBuildStrings))</span>
2382             result = parseString&lt;false&gt;(tokenData, strictMode);
2383         else
2384             result = parseString&lt;true&gt;(tokenData, strictMode);
2385 
2386         if (UNLIKELY(result != StringParsedSuccessfully)) {
2387             token = result == StringUnterminated ? UNTERMINATED_STRING_LITERAL_ERRORTOK : INVALID_STRING_LITERAL_ERRORTOK;
2388             goto returnError;
2389         }
2390         shift();
2391         token = STRING;
2392         break;
2393         }
2394     case CharacterIdentifierStart:
2395         ASSERT(isIdentStart(m_current));
2396         FALLTHROUGH;
2397     case CharacterBackSlash:
2398         parseIdent:
<span class="line-modified">2399         if (lexerFlags.contains(LexerFlags::DontBuildKeywords))</span>
2400             token = parseIdentifier&lt;false&gt;(tokenData, lexerFlags, strictMode);
2401         else
2402             token = parseIdentifier&lt;true&gt;(tokenData, lexerFlags, strictMode);
2403         break;
2404     case CharacterLineTerminator:
2405         ASSERT(isLineTerminator(m_current));
2406         shiftLineTerminator();
2407         m_atLineStart = true;
2408         m_hasLineTerminatorBeforeToken = true;
2409         m_lineStart = m_code;
2410         goto start;
2411     case CharacterHash:
2412         // Hashbang is only permitted at the start of the source text.
2413         if (peek(1) == &#39;!&#39; &amp;&amp; !currentOffset()) {
2414             shift();
2415             shift();
2416             goto inSingleLineComment;
2417         }
2418         goto invalidCharacter;
2419     case CharacterPrivateIdentifierStart:
</pre>
</td>
</tr>
</table>
<center><a href="Keywords.table.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Lexer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
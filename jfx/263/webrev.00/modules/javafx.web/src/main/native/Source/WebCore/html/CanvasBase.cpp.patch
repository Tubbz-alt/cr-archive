diff a/modules/javafx.web/src/main/native/Source/WebCore/html/CanvasBase.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/CanvasBase.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/CanvasBase.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/CanvasBase.cpp
@@ -29,28 +29,95 @@
 #include "CSSCanvasValue.h"
 #include "CanvasRenderingContext.h"
 #include "Element.h"
 #include "FloatRect.h"
 #include "InspectorInstrumentation.h"
+#include <JavaScriptCore/JSCInlines.h>
+#include <JavaScriptCore/JSLock.h>
+#include <atomic>
 #include <wtf/Vector.h>
 
+static std::atomic<size_t> s_activePixelMemory { 0 };
+
 namespace WebCore {
 
-CanvasBase::CanvasBase()
+#if USE(CG)
+// FIXME: It seems strange that the default quality is not the one that is literally named "default".
+// Should fix names to make this easier to understand, or write an excellent comment here explaining why not.
+const InterpolationQuality defaultInterpolationQuality = InterpolationQuality::Low;
+#else
+const InterpolationQuality defaultInterpolationQuality = InterpolationQuality::Default;
+#endif
+
+CanvasBase::CanvasBase(IntSize size)
+    : m_size(size)
 {
 }
 
 CanvasBase::~CanvasBase()
 {
-    ASSERT(!m_context); // Should have been set to null by base class.
     ASSERT(m_didNotifyObserversCanvasDestroyed);
     ASSERT(m_observers.isEmpty());
+    ASSERT(!m_imageBuffer);
+}
+
+GraphicsContext* CanvasBase::drawingContext() const
+{
+    auto* context = renderingContext();
+    if (context && !context->is2d() && !context->isOffscreen2d())
+        return nullptr;
+
+    return buffer() ? &m_imageBuffer->context() : nullptr;
+}
+
+GraphicsContext* CanvasBase::existingDrawingContext() const
+{
+    if (!hasCreatedImageBuffer())
+        return nullptr;
+
+    return drawingContext();
 }
 
-CanvasRenderingContext* CanvasBase::renderingContext() const
+ImageBuffer* CanvasBase::buffer() const
 {
-    return m_context.get();
+    if (!hasCreatedImageBuffer())
+        createImageBuffer();
+    return m_imageBuffer.get();
+}
+
+AffineTransform CanvasBase::baseTransform() const
+{
+    ASSERT(hasCreatedImageBuffer());
+    return m_imageBuffer->baseTransform();
+}
+
+void CanvasBase::makeRenderingResultsAvailable()
+{
+    if (auto* context = renderingContext())
+        context->paintRenderingResultsToCanvas();
+}
+
+size_t CanvasBase::memoryCost() const
+{
+    // memoryCost() may be invoked concurrently from a GC thread, and we need to be careful
+    // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer
+    // from being changed while we access it.
+    auto locker = holdLock(m_imageBufferAssignmentLock);
+    if (!m_imageBuffer)
+        return 0;
+    return m_imageBuffer->memoryCost();
+}
+
+size_t CanvasBase::externalMemoryCost() const
+{
+    // externalMemoryCost() may be invoked concurrently from a GC thread, and we need to be careful
+    // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer
+    // from being changed while we access it.
+    auto locker = holdLock(m_imageBufferAssignmentLock);
+    if (!m_imageBuffer)
+        return 0;
+    return m_imageBuffer->externalMemoryCost();
 }
 
 void CanvasBase::addObserver(CanvasObserver& observer)
 {
     m_observers.add(&observer);
@@ -86,11 +153,11 @@
     for (auto& observer : copyToVector(m_observers))
         observer->canvasDestroyed(*this);
 
     m_observers.clear();
 
-#ifndef NDEBUG
+#if ASSERT_ENABLED
     m_didNotifyObserversCanvasDestroyed = true;
 #endif
 }
 
 HashSet<Element*> CanvasBase::cssCanvasClients() const
@@ -109,9 +176,57 @@
     return cssCanvasClients;
 }
 
 bool CanvasBase::callTracingActive() const
 {
-    return m_context && m_context->callTracingActive();
+    auto* context = renderingContext();
+    return context && context->callTracingActive();
+}
+
+std::unique_ptr<ImageBuffer> CanvasBase::setImageBuffer(std::unique_ptr<ImageBuffer>&& buffer) const
+{
+    std::unique_ptr<ImageBuffer> returnBuffer;
+    {
+        auto locker = holdLock(m_imageBufferAssignmentLock);
+        m_contextStateSaver = nullptr;
+        returnBuffer = std::exchange(m_imageBuffer, WTFMove(buffer));
+    }
+
+    if (m_imageBuffer && m_size != m_imageBuffer->internalSize())
+        m_size = m_imageBuffer->internalSize();
+
+    size_t previousMemoryCost = m_imageBufferCost;
+    m_imageBufferCost = memoryCost();
+    s_activePixelMemory += m_imageBufferCost - previousMemoryCost;
+
+    auto* context = renderingContext();
+    if (context && m_imageBuffer && previousMemoryCost != m_imageBufferCost)
+        InspectorInstrumentation::didChangeCanvasMemory(*context);
+
+    if (m_imageBuffer) {
+        m_imageBuffer->context().setShadowsIgnoreTransforms(true);
+        m_imageBuffer->context().setImageInterpolationQuality(defaultInterpolationQuality);
+        m_imageBuffer->context().setStrokeThickness(1);
+        m_contextStateSaver = makeUnique<GraphicsContextStateSaver>(m_imageBuffer->context());
+
+        JSC::JSLockHolder lock(scriptExecutionContext()->vm());
+        scriptExecutionContext()->vm().heap.reportExtraMemoryAllocated(memoryCost());
+    }
+
+    return returnBuffer;
+}
+
+size_t CanvasBase::activePixelMemory()
+{
+    return s_activePixelMemory.load();
+}
+
+void CanvasBase::resetGraphicsContextState() const
+{
+    if (m_contextStateSaver) {
+        // Reset to the initial graphics context state.
+        m_contextStateSaver->restore();
+        m_contextStateSaver->save();
+    }
 }
 
 }

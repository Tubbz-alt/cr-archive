<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/JSJavaScriptCallFrame.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSInjectedScriptHostPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSJavaScriptCallFrame.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/JSJavaScriptCallFrame.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,14 ***</span>
  #include &quot;IdentifierInlines.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSJavaScriptCallFramePrototype.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  
<span class="line-removed">- using namespace JSC;</span>
<span class="line-removed">- </span>
  namespace Inspector {
  
  const ClassInfo JSJavaScriptCallFrame::s_info = { &quot;JavaScriptCallFrame&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSJavaScriptCallFrame) };
  
  JSJavaScriptCallFrame::JSJavaScriptCallFrame(VM&amp; vm, Structure* structure, Ref&lt;JavaScriptCallFrame&gt;&amp;&amp; impl)
      : JSDestructibleObject(vm, structure)
      , m_impl(&amp;impl.leakRef())
<span class="line-new-header">--- 31,14 ---</span>
  #include &quot;IdentifierInlines.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSJavaScriptCallFramePrototype.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  
  namespace Inspector {
  
<span class="line-added">+ using namespace JSC;</span>
<span class="line-added">+ </span>
  const ClassInfo JSJavaScriptCallFrame::s_info = { &quot;JavaScriptCallFrame&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSJavaScriptCallFrame) };
  
  JSJavaScriptCallFrame::JSJavaScriptCallFrame(VM&amp; vm, Structure* structure, Ref&lt;JavaScriptCallFrame&gt;&amp;&amp; impl)
      : JSDestructibleObject(vm, structure)
      , m_impl(&amp;impl.leakRef())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,27 ***</span>
  JSJavaScriptCallFrame::~JSJavaScriptCallFrame()
  {
      releaseImpl();
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::evaluateWithScopeExtension(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue scriptValue = exec-&gt;argument(0);</span>
      if (!scriptValue.isString())
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;JSJavaScriptCallFrame.evaluateWithScopeExtension first argument must be a string.&quot;_s);</span>
  
<span class="line-modified">!     String script = asString(scriptValue)-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      NakedPtr&lt;Exception&gt; exception;
<span class="line-modified">!     JSObject* scopeExtension = exec-&gt;argument(1).getObject();</span>
      JSValue result = impl().evaluateWithScopeExtension(script, scopeExtension, exception);
      if (exception)
<span class="line-modified">!         throwException(exec, scope, exception);</span>
  
      return result;
  }
  
  static JSValue valueForScopeType(DebuggerScope* scope)
<span class="line-new-header">--- 71,27 ---</span>
  JSJavaScriptCallFrame::~JSJavaScriptCallFrame()
  {
      releaseImpl();
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::evaluateWithScopeExtension(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue scriptValue = callFrame-&gt;argument(0);</span>
      if (!scriptValue.isString())
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;JSJavaScriptCallFrame.evaluateWithScopeExtension first argument must be a string.&quot;_s);</span>
  
<span class="line-modified">!     String script = asString(scriptValue)-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      NakedPtr&lt;Exception&gt; exception;
<span class="line-modified">!     JSObject* scopeExtension = callFrame-&gt;argument(1).getObject();</span>
      JSValue result = impl().evaluateWithScopeExtension(script, scopeExtension, exception);
      if (exception)
<span class="line-modified">!         throwException(globalObject, scope, exception);</span>
  
      return result;
  }
  
  static JSValue valueForScopeType(DebuggerScope* scope)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,78 ***</span>
  
      ASSERT(scope-&gt;isClosureScope());
      return jsNumber(JSJavaScriptCallFrame::CLOSURE_SCOPE);
  }
  
<span class="line-modified">! static JSValue valueForScopeLocation(ExecState* exec, const DebuggerLocation&amp; location)</span>
  {
      if (location.sourceID == noSourceID)
          return jsNull();
  
      // Debugger.Location protocol object.
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSObject* result = constructEmptyObject(exec);</span>
      result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;scriptId&quot;), jsString(vm, String::number(location.sourceID)));
      result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;lineNumber&quot;), jsNumber(location.line));
      result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;columnNumber&quot;), jsNumber(location.column));
      return result;
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::scopeDescriptions(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      DebuggerScope* scopeChain = impl().scopeChain();
      if (!scopeChain)
          return jsUndefined();
  
      int index = 0;
<span class="line-modified">!     JSArray* array = constructEmptyArray(exec, nullptr);</span>
  
      DebuggerScope::iterator end = scopeChain-&gt;end();
      for (DebuggerScope::iterator iter = scopeChain-&gt;begin(); iter != end; ++iter) {
          DebuggerScope* scope = iter.get();
<span class="line-modified">!         JSObject* description = constructEmptyObject(exec);</span>
          description-&gt;putDirect(vm, Identifier::fromString(vm, &quot;type&quot;), valueForScopeType(scope));
          description-&gt;putDirect(vm, Identifier::fromString(vm, &quot;name&quot;), jsString(vm, scope-&gt;name()));
<span class="line-modified">!         description-&gt;putDirect(vm, Identifier::fromString(vm, &quot;location&quot;), valueForScopeLocation(exec, scope-&gt;location()));</span>
<span class="line-modified">!         array-&gt;putDirectIndex(exec, index++, description);</span>
          RETURN_IF_EXCEPTION(throwScope, JSValue());
      }
  
      return array;
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::caller(ExecState* exec) const</span>
  {
<span class="line-modified">!     return toJS(exec, globalObject(exec-&gt;vm()), impl().caller());</span>
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::sourceID(ExecState*) const</span>
  {
      return jsNumber(impl().sourceID());
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::line(ExecState*) const</span>
  {
      return jsNumber(impl().line());
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::column(ExecState*) const</span>
  {
      return jsNumber(impl().column());
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::functionName(ExecState* exec) const</span>
  {
<span class="line-modified">!     return jsString(exec-&gt;vm(), impl().functionName());</span>
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::scopeChain(ExecState* exec) const</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!impl().scopeChain())
          return jsNull();
  
<span class="line-new-header">--- 111,78 ---</span>
  
      ASSERT(scope-&gt;isClosureScope());
      return jsNumber(JSJavaScriptCallFrame::CLOSURE_SCOPE);
  }
  
<span class="line-modified">! static JSValue valueForScopeLocation(JSGlobalObject* globalObject, const DebuggerLocation&amp; location)</span>
  {
      if (location.sourceID == noSourceID)
          return jsNull();
  
      // Debugger.Location protocol object.
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSObject* result = constructEmptyObject(globalObject);</span>
      result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;scriptId&quot;), jsString(vm, String::number(location.sourceID)));
      result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;lineNumber&quot;), jsNumber(location.line));
      result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;columnNumber&quot;), jsNumber(location.column));
      return result;
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::scopeDescriptions(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      DebuggerScope* scopeChain = impl().scopeChain();
      if (!scopeChain)
          return jsUndefined();
  
      int index = 0;
<span class="line-modified">!     JSArray* array = constructEmptyArray(globalObject, nullptr);</span>
  
      DebuggerScope::iterator end = scopeChain-&gt;end();
      for (DebuggerScope::iterator iter = scopeChain-&gt;begin(); iter != end; ++iter) {
          DebuggerScope* scope = iter.get();
<span class="line-modified">!         JSObject* description = constructEmptyObject(globalObject);</span>
          description-&gt;putDirect(vm, Identifier::fromString(vm, &quot;type&quot;), valueForScopeType(scope));
          description-&gt;putDirect(vm, Identifier::fromString(vm, &quot;name&quot;), jsString(vm, scope-&gt;name()));
<span class="line-modified">!         description-&gt;putDirect(vm, Identifier::fromString(vm, &quot;location&quot;), valueForScopeLocation(globalObject, scope-&gt;location()));</span>
<span class="line-modified">!         array-&gt;putDirectIndex(globalObject, index++, description);</span>
          RETURN_IF_EXCEPTION(throwScope, JSValue());
      }
  
      return array;
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::caller(JSGlobalObject* lexicalGlobalObject) const</span>
  {
<span class="line-modified">!     return toJS(lexicalGlobalObject, this-&gt;globalObject(lexicalGlobalObject-&gt;vm()), impl().caller());</span>
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::sourceID(JSGlobalObject*) const</span>
  {
      return jsNumber(impl().sourceID());
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::line(JSGlobalObject*) const</span>
  {
      return jsNumber(impl().line());
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::column(JSGlobalObject*) const</span>
  {
      return jsNumber(impl().column());
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::functionName(JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     return jsString(globalObject-&gt;vm(), impl().functionName());</span>
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::scopeChain(JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!impl().scopeChain())
          return jsNull();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 197,30 ***</span>
      do {
          list.append(iter.get());
          ++iter;
      } while (iter != end);
      if (UNLIKELY(list.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return { };
      }
  
<span class="line-modified">!     return constructArray(exec, nullptr, globalObject(vm), list);</span>
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::thisObject(ExecState*) const</span>
  {
<span class="line-modified">!     return impl().thisValue();</span>
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::isTailDeleted(JSC::ExecState*) const</span>
  {
      return jsBoolean(impl().isTailDeleted());
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::type(ExecState* exec) const</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      switch (impl().type()) {
      case DebuggerCallFrame::FunctionType:
          return jsNontrivialString(vm, &quot;function&quot;_s);
      case DebuggerCallFrame::ProgramType:
          return jsNontrivialString(vm, &quot;program&quot;_s);
<span class="line-new-header">--- 197,30 ---</span>
      do {
          list.append(iter.get());
          ++iter;
      } while (iter != end);
      if (UNLIKELY(list.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return { };
      }
  
<span class="line-modified">!     return constructArray(this-&gt;globalObject(vm), static_cast&lt;ArrayAllocationProfile*&gt;(nullptr), list);</span>
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::thisObject(JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     return impl().thisValue(globalObject-&gt;vm());</span>
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::isTailDeleted(JSC::JSGlobalObject*) const</span>
  {
      return jsBoolean(impl().isTailDeleted());
  }
  
<span class="line-modified">! JSValue JSJavaScriptCallFrame::type(JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      switch (impl().type()) {
      case DebuggerCallFrame::FunctionType:
          return jsNontrivialString(vm, &quot;function&quot;_s);
      case DebuggerCallFrame::ProgramType:
          return jsNontrivialString(vm, &quot;program&quot;_s);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,16 ***</span>
  
      ASSERT_NOT_REACHED();
      return jsNull();
  }
  
<span class="line-modified">! JSValue toJS(ExecState* exec, JSGlobalObject* globalObject, JavaScriptCallFrame* impl)</span>
  {
      if (!impl)
          return jsNull();
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSObject* prototype = JSJavaScriptCallFrame::createPrototype(vm, globalObject);
      Structure* structure = JSJavaScriptCallFrame::createStructure(vm, globalObject, prototype);
      JSJavaScriptCallFrame* javaScriptCallFrame = JSJavaScriptCallFrame::create(vm, structure, *impl);
  
      return javaScriptCallFrame;
<span class="line-new-header">--- 228,16 ---</span>
  
      ASSERT_NOT_REACHED();
      return jsNull();
  }
  
<span class="line-modified">! JSValue toJS(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, JavaScriptCallFrame* impl)</span>
  {
      if (!impl)
          return jsNull();
  
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      JSObject* prototype = JSJavaScriptCallFrame::createPrototype(vm, globalObject);
      Structure* structure = JSJavaScriptCallFrame::createStructure(vm, globalObject, prototype);
      JSJavaScriptCallFrame* javaScriptCallFrame = JSJavaScriptCallFrame::create(vm, structure, *impl);
  
      return javaScriptCallFrame;
</pre>
<center><a href="JSInjectedScriptHostPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSJavaScriptCallFrame.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
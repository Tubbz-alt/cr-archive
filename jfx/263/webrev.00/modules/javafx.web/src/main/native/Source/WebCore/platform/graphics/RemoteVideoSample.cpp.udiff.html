<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/RemoteVideoSample.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Region.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RemoteVideoSample.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/RemoteVideoSample.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -26,13 +26,18 @@</span>
  #include &quot;config.h&quot;
  #include &quot;RemoteVideoSample.h&quot;
  
  #if ENABLE(MEDIA_STREAM) &amp;&amp; PLATFORM(COCOA)
  
<span class="udiff-line-added">+ #include &quot;IOSurface.h&quot;</span>
  #include &quot;Logging.h&quot;
  #include &quot;MediaSample.h&quot;
  
<span class="udiff-line-added">+ #if USE(ACCELERATE)</span>
<span class="udiff-line-added">+ #include &lt;Accelerate/Accelerate.h&gt;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  #if HAVE(IOSURFACE)
  #include &quot;GraphicsContextCG.h&quot;
  #endif
  
  #include &lt;pal/cf/CoreMediaSoftLink.h&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -40,27 +45,92 @@</span>
  
  namespace WebCore {
  using namespace PAL;
  
  #if HAVE(IOSURFACE)
<span class="udiff-line-modified-removed">- std::unique_ptr&lt;RemoteVideoSample&gt; RemoteVideoSample::create(MediaSample&amp;&amp; sample)</span>
<span class="udiff-line-modified-added">+ static inline std::unique_ptr&lt;IOSurface&gt; transferBGRAPixelBufferToIOSurface(CVPixelBufferRef pixelBuffer)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ #if USE(ACCELERATE)</span>
<span class="udiff-line-added">+     ASSERT(CVPixelBufferGetPixelFormatType(pixelBuffer) == kCVPixelFormatType_32BGRA);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto result = CVPixelBufferLockBaseAddress(pixelBuffer, kCVPixelBufferLock_ReadOnly);</span>
<span class="udiff-line-added">+     ASSERT(result == kCVReturnSuccess);</span>
<span class="udiff-line-added">+     if (result != kCVReturnSuccess) {</span>
<span class="udiff-line-added">+         RELEASE_LOG_ERROR(Media, &quot;transferBGRAPixelBufferToIOSurface CVPixelBufferLockBaseAddress() returned error code %d&quot;, result);</span>
<span class="udiff-line-added">+         return nullptr;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     IntSize size { static_cast&lt;int&gt;(CVPixelBufferGetWidth(pixelBuffer)), static_cast&lt;int&gt;(CVPixelBufferGetHeight(pixelBuffer)) };</span>
<span class="udiff-line-added">+     auto ioSurface =  IOSurface::create(size, sRGBColorSpaceRef(), IOSurface::Format::RGBA);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     IOSurface::Locker lock(*ioSurface);</span>
<span class="udiff-line-added">+     vImage_Buffer src;</span>
<span class="udiff-line-added">+     src.width = size.width();</span>
<span class="udiff-line-added">+     src.height = size.height();</span>
<span class="udiff-line-added">+     src.rowBytes = CVPixelBufferGetBytesPerRow(pixelBuffer);</span>
<span class="udiff-line-added">+     src.data = CVPixelBufferGetBaseAddress(pixelBuffer);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     vImage_Buffer dest;</span>
<span class="udiff-line-added">+     dest.width = size.width();</span>
<span class="udiff-line-added">+     dest.height = size.height();</span>
<span class="udiff-line-added">+     dest.rowBytes = ioSurface-&gt;bytesPerRow();</span>
<span class="udiff-line-added">+     dest.data = lock.surfaceBaseAddress();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     vImageUnpremultiplyData_BGRA8888(&amp;src, &amp;dest, kvImageNoFlags);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     result = CVPixelBufferUnlockBaseAddress(pixelBuffer, kCVPixelBufferLock_ReadOnly);</span>
<span class="udiff-line-added">+     ASSERT(result == kCVReturnSuccess);</span>
<span class="udiff-line-added">+     if (result != kCVReturnSuccess) {</span>
<span class="udiff-line-added">+         RELEASE_LOG_ERROR(Media, &quot;transferBGRAPixelBufferToIOSurface CVPixelBufferUnlockBaseAddress() returned error code %d&quot;, result);</span>
<span class="udiff-line-added">+         return nullptr;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return ioSurface;</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     RELEASE_LOG_ERROR(Media, &quot;transferBGRAPixelBufferToIOSurface cannot convert to IOSurface&quot;);</span>
<span class="udiff-line-added">+     return nullptr;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ std::unique_ptr&lt;RemoteVideoSample&gt; RemoteVideoSample::create(MediaSample&amp; sample)</span>
  {
      ASSERT(sample.platformSample().type == PlatformSample::CMSampleBufferType);
  
      auto imageBuffer = CMSampleBufferGetImageBuffer(sample.platformSample().sample.cmSampleBuffer);
      if (!imageBuffer) {
          RELEASE_LOG_ERROR(Media, &quot;RemoteVideoSample::create: CMSampleBufferGetImageBuffer returned nullptr&quot;);
          return nullptr;
      }
  
<span class="udiff-line-added">+     std::unique_ptr&lt;IOSurface&gt; ioSurface;</span>
<span class="udiff-line-added">+     auto surface = CVPixelBufferGetIOSurface(imageBuffer);</span>
<span class="udiff-line-added">+     if (!surface) {</span>
<span class="udiff-line-added">+         // Special case for canvas data that is RGBA, not IOSurface backed.</span>
<span class="udiff-line-added">+         auto pixelFormatType = CVPixelBufferGetPixelFormatType(imageBuffer);</span>
<span class="udiff-line-added">+         if (pixelFormatType != kCVPixelFormatType_32BGRA) {</span>
<span class="udiff-line-added">+             RELEASE_LOG_ERROR(Media, &quot;RemoteVideoSample::create does not support non IOSurface backed samples that are not BGRA&quot;);</span>
<span class="udiff-line-added">+             return nullptr;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ioSurface = transferBGRAPixelBufferToIOSurface(imageBuffer);</span>
<span class="udiff-line-added">+         if (!ioSurface)</span>
<span class="udiff-line-added">+             return nullptr;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         surface = ioSurface-&gt;surface();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return std::unique_ptr&lt;RemoteVideoSample&gt;(new RemoteVideoSample(surface, sRGBColorSpaceRef(), sample.presentationTime(), sample.videoRotation(), sample.videoMirrored()));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ std::unique_ptr&lt;RemoteVideoSample&gt; RemoteVideoSample::create(CVPixelBufferRef imageBuffer, MediaTime&amp;&amp; presentationTime, MediaSample::VideoRotation rotation)</span>
<span class="udiff-line-added">+ {</span>
      auto surface = CVPixelBufferGetIOSurface(imageBuffer);
      if (!surface) {
          RELEASE_LOG_ERROR(Media, &quot;RemoteVideoSample::create: CVPixelBufferGetIOSurface returned nullptr&quot;);
          return nullptr;
      }
  
<span class="udiff-line-modified-removed">-     return std::unique_ptr&lt;RemoteVideoSample&gt;(new RemoteVideoSample(surface, sRGBColorSpaceRef(), sample.presentationTime(), sample.videoRotation(), sample.videoMirrored()));</span>
<span class="udiff-line-modified-added">+     return std::unique_ptr&lt;RemoteVideoSample&gt;(new RemoteVideoSample(surface, sRGBColorSpaceRef(), WTFMove(presentationTime), rotation, false));</span>
  }
  
  RemoteVideoSample::RemoteVideoSample(IOSurfaceRef surface, CGColorSpaceRef colorSpace, MediaTime&amp;&amp; time, MediaSample::VideoRotation rotation, bool mirrored)
      : m_ioSurface(WebCore::IOSurface::createFromSurface(surface, colorSpace))
      , m_rotation(rotation)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -80,6 +150,6 @@</span>
  }
  #endif
  
  }
  
<span class="udiff-line-modified-removed">- #endif // ENABLE(MEDIA_STREAM)</span>
<span class="udiff-line-modified-added">+ #endif // ENABLE(MEDIA_STREAM) &amp;&amp; PLATFORM(COCOA)</span>
</pre>
<center><a href="Region.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RemoteVideoSample.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
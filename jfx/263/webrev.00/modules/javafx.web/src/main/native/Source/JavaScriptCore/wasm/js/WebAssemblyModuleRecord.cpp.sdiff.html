<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyModuleRecord.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebAssemblyModulePrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebAssemblyModuleRecord.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyModuleRecord.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebAssemblyModuleRecord.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;Error.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;JSLexicalEnvironment.h&quot;
 34 #include &quot;JSModuleEnvironment.h&quot;

 35 #include &quot;JSWebAssemblyHelpers.h&quot;
 36 #include &quot;JSWebAssemblyInstance.h&quot;
 37 #include &quot;JSWebAssemblyLinkError.h&quot;
 38 #include &quot;JSWebAssemblyModule.h&quot;
 39 #include &quot;ProtoCallFrame.h&quot;
 40 #include &quot;WasmSignatureInlines.h&quot;
 41 #include &quot;WebAssemblyFunction.h&quot;
 42 #include &lt;limits&gt;
 43 
 44 namespace JSC {
 45 
 46 const ClassInfo WebAssemblyModuleRecord::s_info = { &quot;WebAssemblyModuleRecord&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WebAssemblyModuleRecord) };
 47 
 48 Structure* WebAssemblyModuleRecord::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 49 {
 50     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 51 }
 52 
<span class="line-modified"> 53 WebAssemblyModuleRecord* WebAssemblyModuleRecord::create(ExecState* exec, VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey, const Wasm::ModuleInformation&amp; moduleInformation)</span>
 54 {
 55     WebAssemblyModuleRecord* instance = new (NotNull, allocateCell&lt;WebAssemblyModuleRecord&gt;(vm.heap)) WebAssemblyModuleRecord(vm, structure, moduleKey);
<span class="line-modified"> 56     instance-&gt;finishCreation(exec, vm, moduleInformation);</span>
 57     return instance;
 58 }
 59 
 60 WebAssemblyModuleRecord::WebAssemblyModuleRecord(VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey)
 61     : Base(vm, structure, moduleKey)
 62 {
 63 }
 64 
 65 void WebAssemblyModuleRecord::destroy(JSCell* cell)
 66 {
 67     WebAssemblyModuleRecord* thisObject = static_cast&lt;WebAssemblyModuleRecord*&gt;(cell);
 68     thisObject-&gt;WebAssemblyModuleRecord::~WebAssemblyModuleRecord();
 69 }
 70 
<span class="line-modified"> 71 void WebAssemblyModuleRecord::finishCreation(ExecState* exec, VM&amp; vm, const Wasm::ModuleInformation&amp; moduleInformation)</span>
 72 {
<span class="line-modified"> 73     Base::finishCreation(exec, vm);</span>
 74     ASSERT(inherits(vm, info()));
 75     for (const auto&amp; exp : moduleInformation.exports) {
 76         Identifier field = Identifier::fromString(vm, String::fromUTF8(exp.field));
 77         addExportEntry(ExportEntry::createLocal(field, field));
 78     }
 79 }
 80 
 81 void WebAssemblyModuleRecord::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 82 {
 83     WebAssemblyModuleRecord* thisObject = jsCast&lt;WebAssemblyModuleRecord*&gt;(cell);
 84     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 85     Base::visitChildren(thisObject, visitor);
 86     visitor.append(thisObject-&gt;m_instance);
 87     visitor.append(thisObject-&gt;m_startFunction);
 88 }
 89 
 90 void WebAssemblyModuleRecord::prepareLink(VM&amp; vm, JSWebAssemblyInstance* instance)
 91 {
 92     RELEASE_ASSERT(!m_instance);
 93     m_instance.set(vm, this, instance);
 94 }
 95 
<span class="line-modified"> 96 void WebAssemblyModuleRecord::link(ExecState* exec, JSValue, JSObject* importObject, Wasm::CreationMode creationMode)</span>
 97 {
<span class="line-modified"> 98     VM&amp; vm = exec-&gt;vm();</span>
 99     auto scope = DECLARE_THROW_SCOPE(vm);
100     UNUSED_PARAM(scope);
<span class="line-removed">101     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
102 
103     RELEASE_ASSERT(m_instance);
104 
105     Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
106     JSWebAssemblyModule* module = m_instance-&gt;module();
107     const Wasm::ModuleInformation&amp; moduleInformation = module-&gt;moduleInformation();
108 
109     auto exception = [&amp;] (JSObject* error) {
<span class="line-modified">110         throwException(exec, scope, error);</span>
111     };
112 
113     auto importFailMessage = [&amp;] (const Wasm::Import&amp; import, const char* before, const char* after) {
114         return makeString(before, &quot; &quot;, String::fromUTF8(import.module), &quot;:&quot;, String::fromUTF8(import.field), &quot; &quot;, after);
115     };
116 
117     for (const auto&amp; import : moduleInformation.imports) {
118         // Validation and linking other than Wasm::ExternalKind::Function is already done in JSWebAssemblyInstance.
119         // Eventually we will move all the linking code in JSWebAssemblyInstance here and remove this switch statement.
120         switch (import.kind) {
121         case Wasm::ExternalKind::Function:
122         case Wasm::ExternalKind::Global:
123         case Wasm::ExternalKind::Table:
124             break;
125         case Wasm::ExternalKind::Memory:
126             continue;
127         }
128 
129         Identifier moduleName = Identifier::fromString(vm, String::fromUTF8(import.module));
130         Identifier fieldName = Identifier::fromString(vm, String::fromUTF8(import.field));
131         JSValue value;
132         if (creationMode == Wasm::CreationMode::FromJS) {
133             // 1. Let o be the resultant value of performing Get(importObject, i.module_name).
<span class="line-modified">134             JSValue importModuleValue = importObject-&gt;get(exec, moduleName);</span>
135             RETURN_IF_EXCEPTION(scope, void());
136             // 2. If Type(o) is not Object, throw a TypeError.
137             if (!importModuleValue.isObject())
<span class="line-modified">138                 return exception(createTypeError(exec, importFailMessage(import, &quot;import&quot;, &quot;must be an object&quot;), defaultSourceAppender, runtimeTypeForValue(vm, importModuleValue)));</span>
139 
140             // 3. Let v be the value of performing Get(o, i.item_name)
141             JSObject* object = jsCast&lt;JSObject*&gt;(importModuleValue);
<span class="line-modified">142             value = object-&gt;get(exec, fieldName);</span>
143             RETURN_IF_EXCEPTION(scope, void());
144         } else {
<span class="line-modified">145             AbstractModuleRecord* importedModule = hostResolveImportedModule(exec, moduleName);</span>
146             RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">147             Resolution resolution = importedModule-&gt;resolveExport(exec, fieldName);</span>
148             RETURN_IF_EXCEPTION(scope, void());
149             switch (resolution.type) {
150             case Resolution::Type::NotFound:
<span class="line-modified">151                 throwSyntaxError(exec, scope, makeString(&quot;Importing binding name &#39;&quot;, String(fieldName.impl()), &quot;&#39; is not found.&quot;));</span>
152                 return;
153 
154             case Resolution::Type::Ambiguous:
<span class="line-modified">155                 throwSyntaxError(exec, scope, makeString(&quot;Importing binding name &#39;&quot;, String(fieldName.impl()), &quot;&#39; cannot be resolved due to ambiguous multiple bindings.&quot;));</span>
156                 return;
157 
158             case Resolution::Type::Error:
<span class="line-modified">159                 throwSyntaxError(exec, scope, makeString(&quot;Importing binding name &#39;default&#39; cannot be resolved by star export entries.&quot;));</span>
160                 return;
161 
162             case Resolution::Type::Resolved:
163                 break;
164             }
165 
166             AbstractModuleRecord* importedRecord = resolution.moduleRecord;
167             JSModuleEnvironment* importedEnvironment = importedRecord-&gt;moduleEnvironmentMayBeNull();
168             // It means that target module is not linked yet. In wasm loading, we allow this since we do not solve cyclic resolution as if JS&#39;s bindings.
169             // At that time, error occurs since |value| is an empty, and later |value| becomes an undefined.
170             // https://github.com/WebAssembly/esm-integration/tree/master/proposals/esm-integration#js---wasm-cycle-where-js-is-higher-in-the-module-graph
171             if (importedEnvironment) {
172                 SymbolTable* symbolTable = importedEnvironment-&gt;symbolTable();
173                 ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
174                 auto iter = symbolTable-&gt;find(locker, resolution.localName.impl());
175                 ASSERT(iter != symbolTable-&gt;end(locker));
176                 SymbolTableEntry&amp; entry = iter-&gt;value;
177                 ASSERT(!entry.isNull());
178                 ASSERT(importedEnvironment-&gt;isValidScopeOffset(entry.scopeOffset()));
179 
180                 // Snapshotting a value.
181                 value = importedEnvironment-&gt;variableAt(entry.scopeOffset()).get();
182             }
183         }
184         if (!value)
185             value = jsUndefined();
186 
187         switch (import.kind) {
188         case Wasm::ExternalKind::Function: {
189             // 4. If i is a function import:
190             // i. If IsCallable(v) is false, throw a WebAssembly.LinkError.
191             if (!value.isFunction(vm))
<span class="line-modified">192                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;import function&quot;, &quot;must be callable&quot;)));</span>
193 
194             Wasm::Instance* calleeInstance = nullptr;
195             WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = nullptr;
196             JSObject* function = jsCast&lt;JSObject*&gt;(value);
197 
198             // ii. If v is an Exported Function Exotic Object:
199             WebAssemblyFunction* wasmFunction;
200             WebAssemblyWrapperFunction* wasmWrapperFunction;
201             if (isWebAssemblyHostFunction(vm, function, wasmFunction, wasmWrapperFunction)) {
202                 // a. If the signature of v does not match the signature of i, throw a WebAssembly.LinkError.
203                 Wasm::SignatureIndex importedSignatureIndex;
204                 if (wasmFunction) {
205                     importedSignatureIndex = wasmFunction-&gt;signatureIndex();
206                     calleeInstance = &amp;wasmFunction-&gt;instance()-&gt;instance();
207                     entrypointLoadLocation = wasmFunction-&gt;entrypointLoadLocation();
208                 } else {
209                     importedSignatureIndex = wasmWrapperFunction-&gt;signatureIndex();
210                     // b. Let closure be v.[[Closure]].
211                     function = wasmWrapperFunction-&gt;function();
212                 }
213                 Wasm::SignatureIndex expectedSignatureIndex = moduleInformation.importFunctionSignatureIndices[import.kindIndex];
214                 if (importedSignatureIndex != expectedSignatureIndex)
<span class="line-modified">215                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;imported function&quot;, &quot;signature doesn&#39;t match the provided WebAssembly function&#39;s signature&quot;)));</span>
216             }
217             // iii. Otherwise:
218             // a. Let closure be a new host function of the given signature which calls v by coercing WebAssembly arguments to JavaScript arguments via ToJSValue and returns the result, if any, by coercing via ToWebAssemblyValue.
219             // Note: done as part of Plan compilation.
220             // iv. Append v to funcs.
221             // Note: adding the JSCell to the instance list fulfills closure requirements b. above (the WebAssembly.Instance wil be kept alive) and v. below (the JSFunction).
222 
223             auto* info = m_instance-&gt;instance().importFunctionInfo(import.kindIndex);
224             info-&gt;targetInstance = calleeInstance;
225             info-&gt;wasmEntrypointLoadLocation = entrypointLoadLocation;
226             m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(import.kindIndex)-&gt;set(vm, m_instance.get(), function);
227             break;
228         }
229 
230         case Wasm::ExternalKind::Global: {
231             // 5. If i is a global import:
<span class="line-modified">232             // i. If i is not an immutable global, throw a TypeError.</span>
<span class="line-modified">233             ASSERT(moduleInformation.globals[import.kindIndex].mutability == Wasm::Global::Immutable);</span>
<span class="line-modified">234             // ii. If the global_type of i is i64 or Type(v) is not Number, throw a WebAssembly.LinkError.</span>
<span class="line-modified">235             if (moduleInformation.globals[import.kindIndex].type == Wasm::I64)</span>
<span class="line-modified">236                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;imported global&quot;, &quot;cannot be an i64&quot;)));</span>
<span class="line-modified">237             if (!isSubtype(moduleInformation.globals[import.kindIndex].type, Wasm::Anyref) &amp;&amp; !value.isNumber())</span>
<span class="line-modified">238                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a number&quot;)));</span>
<span class="line-modified">239             // iii. Append ToWebAssemblyValue(v) to imports.</span>
<span class="line-modified">240             switch (moduleInformation.globals[import.kindIndex].type) {</span>
<span class="line-modified">241             case Wasm::Funcref:</span>
<span class="line-modified">242                 if (!isWebAssemblyHostFunction(vm, value) &amp;&amp; !value.isNull())</span>
<span class="line-modified">243                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a wasm exported function or null&quot;)));</span>
<span class="line-modified">244                 m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-modified">245                 break;</span>
<span class="line-modified">246             case Wasm::Anyref:</span>
<span class="line-modified">247                 m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-modified">248                 break;</span>
<span class="line-modified">249             case Wasm::I32:</span>
<span class="line-modified">250                 m_instance-&gt;instance().setGlobal(import.kindIndex, value.toInt32(exec));</span>
<span class="line-modified">251                 break;</span>
<span class="line-modified">252             case Wasm::F32:</span>
<span class="line-modified">253                 m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint32_t&gt;(value.toFloat(exec)));</span>
<span class="line-modified">254                 break;</span>
<span class="line-modified">255             case Wasm::F64:</span>
<span class="line-modified">256                 m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint64_t&gt;(value.asNumber()));</span>
<span class="line-modified">257                 break;</span>
<span class="line-modified">258             default:</span>
<span class="line-modified">259                 RELEASE_ASSERT_NOT_REACHED();</span>







































260             }
261             scope.assertNoException();
262             break;
263         }
264 
265         case Wasm::ExternalKind::Table: {
266             // 7. Otherwise (i is a table import):
267             JSWebAssemblyTable* table = jsDynamicCast&lt;JSWebAssemblyTable*&gt;(vm, value);
268             // i. If v is not a WebAssembly.Table object, throw a WebAssembly.LinkError.
269             if (!table)
<span class="line-modified">270                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;is not an instance of WebAssembly.Table&quot;)));</span>
271 
272             uint32_t expectedInitial = moduleInformation.tables[import.kindIndex].initial();
273             uint32_t actualInitial = table-&gt;length();
274             if (actualInitial &lt; expectedInitial)
<span class="line-modified">275                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;provided an &#39;initial&#39; that is too small&quot;)));</span>
276 
277             if (Optional&lt;uint32_t&gt; expectedMaximum = moduleInformation.tables[import.kindIndex].maximum()) {
278                 Optional&lt;uint32_t&gt; actualMaximum = table-&gt;maximum();
279                 if (!actualMaximum)
<span class="line-modified">280                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;does not have a &#39;maximum&#39; but the module requires that it does&quot;)));</span>
281                 if (*actualMaximum &gt; *expectedMaximum)
<span class="line-modified">282                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Imported Table&quot;, &quot;&#39;maximum&#39; is larger than the module&#39;s expected &#39;maximum&#39;&quot;)));</span>
283             }
284 
285             auto expectedType = moduleInformation.tables[import.kindIndex].type();
286             auto actualType = table-&gt;table()-&gt;type();
287             if (expectedType != actualType)
<span class="line-modified">288                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;provided a &#39;type&#39; that is wrong&quot;)));</span>
289 
290             // ii. Append v to tables.
291             // iii. Append v.[[Table]] to imports.
292             m_instance-&gt;setTable(vm, import.kindIndex, table);
293             RETURN_IF_EXCEPTION(scope, void());
294             break;
295         }
296 
297         case Wasm::ExternalKind::Memory:
298             break;
299         }
300     }
301 
302     for (unsigned i = 0; i &lt; moduleInformation.tableCount(); ++i) {
303         if (moduleInformation.tables[i].isImport()) {
304             // We should either have a Table import or we should have thrown an exception.
305             RELEASE_ASSERT(m_instance-&gt;table(i));
306         }
307 
308         if (!m_instance-&gt;table(i)) {
309             RELEASE_ASSERT(!moduleInformation.tables[i].isImport());
310             // We create a Table when it&#39;s a Table definition.
311             RefPtr&lt;Wasm::Table&gt; wasmTable = Wasm::Table::tryCreate(moduleInformation.tables[i].initial(), moduleInformation.tables[i].maximum(), moduleInformation.tables[i].type());
312             if (!wasmTable)
<span class="line-modified">313                 return exception(createJSWebAssemblyLinkError(exec, vm, &quot;couldn&#39;t create Table&quot;));</span>
<span class="line-modified">314             JSWebAssemblyTable* table = JSWebAssemblyTable::create(exec, vm, globalObject-&gt;webAssemblyTableStructure(), wasmTable.releaseNonNull());</span>
315             // We should always be able to allocate a JSWebAssemblyTable we&#39;ve defined.
316             // If it&#39;s defined to be too large, we should have thrown a validation error.
317             scope.assertNoException();
318             ASSERT(table);
319             m_instance-&gt;setTable(vm, i, table);
320             RETURN_IF_EXCEPTION(scope, void());
321         }
322     }
323 
324     unsigned functionImportCount = codeBlock-&gt;functionImportCount();
325     auto makeFunctionWrapper = [&amp;] (const String&amp; field, uint32_t index) -&gt; JSValue {
326         // If we already made a wrapper, do not make a new one.
327         JSValue wrapper = m_instance-&gt;instance().getFunctionWrapper(index);
328 
329         if (!wrapper.isNull())
330             return wrapper;
331 
332         // 1. If e is a closure c:
333         //   i. If there is an Exported Function Exotic Object func in funcs whose func.[[Closure]] equals c, then return func.
334         //   ii. (Note: At most one wrapper is created for any closure, so func is unique, even if there are multiple occurrances in the list. Moreover, if the item was an import that is already an Exported Function Exotic Object, then the original function object will be found. For imports that are regular JS functions, a new wrapper will be created.)
</pre>
<hr />
<pre>
349             Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = codeBlock-&gt;entrypointLoadLocationFromFunctionIndexSpace(index);
350             Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(index);
351             const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
352             WebAssemblyFunction* function = WebAssemblyFunction::create(vm, globalObject, globalObject-&gt;webAssemblyFunctionStructure(), signature.argumentCount(), field, m_instance.get(), embedderEntrypointCallee, entrypointLoadLocation, signatureIndex);
353             wrapper = function;
354         }
355 
356         ASSERT(wrapper.isFunction(vm));
357         m_instance-&gt;instance().setFunctionWrapper(index, wrapper);
358 
359         return wrapper;
360     };
361 
362     for (auto index : moduleInformation.referencedFunctions())
363         makeFunctionWrapper(&quot;Referenced function&quot;, index);
364 
365     // Globals
366     {
367         for (size_t globalIndex = moduleInformation.firstInternalGlobal; globalIndex &lt; moduleInformation.globals.size(); ++globalIndex) {
368             const auto&amp; global = moduleInformation.globals[globalIndex];
<span class="line-modified">369             ASSERT(global.initializationType != Wasm::Global::IsImport);</span>
<span class="line-modified">370             if (global.initializationType == Wasm::Global::FromGlobalImport) {</span>

371                 ASSERT(global.initialBitsOrImportNumber &lt; moduleInformation.firstInternalGlobal);
<span class="line-modified">372                 m_instance-&gt;instance().setGlobal(globalIndex, m_instance-&gt;instance().loadI64Global(global.initialBitsOrImportNumber));</span>
<span class="line-modified">373             } else if (global.initializationType == Wasm::Global::FromRefFunc) {</span>
374                 ASSERT(global.initialBitsOrImportNumber &lt; moduleInformation.functionIndexSpaceSize());
375                 ASSERT(makeFunctionWrapper(&quot;Global init expr&quot;, global.initialBitsOrImportNumber).isFunction(vm));
<span class="line-modified">376                 m_instance-&gt;instance().setGlobal(globalIndex, JSValue::encode(makeFunctionWrapper(&quot;Global init expr&quot;, global.initialBitsOrImportNumber)));</span>
377             } else
<span class="line-modified">378                 m_instance-&gt;instance().setGlobal(globalIndex, global.initialBitsOrImportNumber);</span>
















379         }
380     }
381 
382     SymbolTable* exportSymbolTable = module-&gt;exportSymbolTable();
383 
384     // Let exports be a list of (string, JS value) pairs that is mapped from each external value e in instance.exports as follows:
385     JSModuleEnvironment* moduleEnvironment = JSModuleEnvironment::create(vm, globalObject, nullptr, exportSymbolTable, JSValue(), this);
386     for (const auto&amp; exp : moduleInformation.exports) {
387         JSValue exportedValue;
388         switch (exp.kind) {
389         case Wasm::ExternalKind::Function: {
390             exportedValue = makeFunctionWrapper(String::fromUTF8(exp.field), exp.kindIndex);
391             ASSERT(exportedValue.isFunction(vm));
392             ASSERT(makeFunctionWrapper(String::fromUTF8(exp.field), exp.kindIndex) == exportedValue);
393             break;
394         }
395         case Wasm::ExternalKind::Table: {
396             // This should be guaranteed by module verification.
397             RELEASE_ASSERT(m_instance-&gt;table(exp.kindIndex));
398             exportedValue = m_instance-&gt;table(exp.kindIndex);
399             break;
400         }
401         case Wasm::ExternalKind::Memory: {
402             ASSERT(exp.kindIndex == 0);
403 
404             exportedValue = m_instance-&gt;memory();
405             break;
406         }
407         case Wasm::ExternalKind::Global: {
<span class="line-modified">408             // Assert: the global is immutable by MVP validation constraint.</span>
<span class="line-removed">409             const Wasm::Global&amp; global = moduleInformation.globals[exp.kindIndex];</span>
<span class="line-removed">410             ASSERT(global.mutability == Wasm::Global::Immutable);</span>
<span class="line-removed">411             // Return ToJSValue(v).</span>
412             switch (global.type) {
413             case Wasm::Anyref:
414             case Wasm::Funcref:
<span class="line-removed">415                 exportedValue = JSValue::decode(m_instance-&gt;instance().loadI64Global(exp.kindIndex));</span>
<span class="line-removed">416                 break;</span>
<span class="line-removed">417 </span>
418             case Wasm::I32:
<span class="line-removed">419                 exportedValue = JSValue(m_instance-&gt;instance().loadI32Global(exp.kindIndex));</span>
<span class="line-removed">420                 break;</span>
<span class="line-removed">421 </span>
422             case Wasm::I64:
<span class="line-removed">423                 throwException(exec, scope, createJSWebAssemblyLinkError(exec, vm, &quot;exported global cannot be an i64&quot;_s));</span>
<span class="line-removed">424                 return;</span>
<span class="line-removed">425 </span>
426             case Wasm::F32:
<span class="line-modified">427                 exportedValue = jsNumber(purifyNaN(m_instance-&gt;instance().loadF32Global(exp.kindIndex)));</span>
<span class="line-modified">428                 break;</span>
<span class="line-modified">429 </span>
<span class="line-modified">430             case Wasm::F64:</span>
<span class="line-modified">431                 exportedValue = jsNumber(purifyNaN(m_instance-&gt;instance().loadF64Global(exp.kindIndex)));</span>













432                 break;
<span class="line-modified">433 </span>
434             default:
435                 RELEASE_ASSERT_NOT_REACHED();
436             }
437             break;
438         }
439         }
440 
441         bool shouldThrowReadOnlyError = false;
442         bool ignoreReadOnlyErrors = true;
443         bool putResult = false;
<span class="line-modified">444         symbolTablePutTouchWatchpointSet(moduleEnvironment, exec, Identifier::fromString(vm, String::fromUTF8(exp.field)), exportedValue, shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);</span>
445         scope.assertNoException();
446         RELEASE_ASSERT(putResult);
447     }
448 
449     bool hasStart = !!moduleInformation.startFunctionIndexSpace;
450     if (hasStart) {
451         auto startFunctionIndexSpace = moduleInformation.startFunctionIndexSpace.valueOr(0);
452         Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndexSpace);
453         const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
454         // The start function must not take any arguments or return anything. This is enforced by the parser.
455         ASSERT(!signature.argumentCount());
<span class="line-modified">456         ASSERT(signature.returnType() == Wasm::Void);</span>
457         if (startFunctionIndexSpace &lt; codeBlock-&gt;functionImportCount()) {
458             JSObject* startFunction = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(startFunctionIndexSpace)-&gt;get();
459             m_startFunction.set(vm, this, startFunction);
460         } else {
461             Wasm::Callee&amp; embedderEntrypointCallee = codeBlock-&gt;embedderEntrypointCalleeFromFunctionIndexSpace(startFunctionIndexSpace);
462             Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = codeBlock-&gt;entrypointLoadLocationFromFunctionIndexSpace(startFunctionIndexSpace);
463             WebAssemblyFunction* function = WebAssemblyFunction::create(vm, globalObject, globalObject-&gt;webAssemblyFunctionStructure(), signature.argumentCount(), &quot;start&quot;, m_instance.get(), embedderEntrypointCallee, entrypointLoadLocation, signatureIndex);
464             m_startFunction.set(vm, this, function);
465         }
466     }
467     m_moduleEnvironment.set(vm, this, moduleEnvironment);
468 }
469 
470 template &lt;typename Scope, typename M, typename N, typename ...Args&gt;
<span class="line-modified">471 NEVER_INLINE static JSValue dataSegmentFail(ExecState* exec, VM&amp; vm, Scope&amp; scope, M memorySize, N segmentSize, N offset, Args... args)</span>
472 {
<span class="line-modified">473     return throwException(exec, scope, createJSWebAssemblyLinkError(exec, vm, makeString(&quot;Invalid data segment initialization: segment of &quot;_s, String::number(segmentSize), &quot; bytes memory of &quot;_s, String::number(memorySize), &quot; bytes, at offset &quot;_s, String::number(offset), args...)));</span>
474 }
475 
<span class="line-modified">476 JSValue WebAssemblyModuleRecord::evaluate(ExecState* exec)</span>
477 {
<span class="line-modified">478     VM&amp; vm = exec-&gt;vm();</span>
479     auto scope = DECLARE_THROW_SCOPE(vm);
480 
481     Wasm::Module&amp; module = m_instance-&gt;instance().module();
482     Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
483     const Wasm::ModuleInformation&amp; moduleInformation = module.moduleInformation();
484 
485     const Vector&lt;Wasm::Segment::Ptr&gt;&amp; data = moduleInformation.data;
486 
487     Optional&lt;JSValue&gt; exception;
488 
489     auto forEachElement = [&amp;] (auto fn) {
490         for (const Wasm::Element&amp; element : moduleInformation.elements) {
491             // It should be a validation error to have any elements without a table.
492             // Also, it could be that a table wasn&#39;t imported, or that the table
493             // imported wasn&#39;t compatible. However, those should error out before
494             // getting here.
495             ASSERT(!!m_instance-&gt;table(element.tableIndex));
496 
497             if (!element.functionIndices.size())
498                 continue;
</pre>
<hr />
<pre>
511     auto forEachSegment = [&amp;] (auto fn) {
512         uint8_t* memory = reinterpret_cast&lt;uint8_t*&gt;(m_instance-&gt;instance().cachedMemory());
513         uint64_t sizeInBytes = m_instance-&gt;instance().cachedMemorySize();
514 
515         for (const Wasm::Segment::Ptr&amp; segment : data) {
516             uint32_t offset = segment-&gt;offset.isGlobalImport()
517                 ? static_cast&lt;uint32_t&gt;(m_instance-&gt;instance().loadI32Global(segment-&gt;offset.globalImportIndex()))
518                 : segment-&gt;offset.constValue();
519 
520             fn(memory, sizeInBytes, segment, offset);
521 
522             if (exception)
523                 break;
524         }
525     };
526 
527     // Validation of all element ranges comes before all Table and Memory initialization.
528     forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex, uint32_t elementIndex) {
529         uint64_t lastWrittenIndex = static_cast&lt;uint64_t&gt;(elementIndex) + static_cast&lt;uint64_t&gt;(element.functionIndices.size()) - 1;
530         if (UNLIKELY(lastWrittenIndex &gt;= m_instance-&gt;table(tableIndex)-&gt;length()))
<span class="line-modified">531             exception = JSValue(throwException(exec, scope, createJSWebAssemblyLinkError(exec, vm, &quot;Element is trying to set an out of bounds table index&quot;_s)));</span>
532     });
533 
534     if (UNLIKELY(exception))
535         return exception.value();
536 
537     // Validation of all segment ranges comes before all Table and Memory initialization.
538     forEachSegment([&amp;] (uint8_t*, uint64_t sizeInBytes, const Wasm::Segment::Ptr&amp; segment, uint32_t offset) {
539         if (UNLIKELY(sizeInBytes &lt; segment-&gt;sizeInBytes))
<span class="line-modified">540             exception = dataSegmentFail(exec, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment is too big&quot;_s);</span>
541         else if (UNLIKELY(offset &gt; sizeInBytes - segment-&gt;sizeInBytes))
<span class="line-modified">542             exception = dataSegmentFail(exec, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment writes outside of memory&quot;_s);</span>
543     });
544 
545     if (UNLIKELY(exception))
546         return exception.value();
547 
<span class="line-removed">548     JSGlobalObject* globalObject = m_instance-&gt;globalObject(vm);</span>
549     forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex, uint32_t elementIndex) {
550         for (uint32_t i = 0; i &lt; element.functionIndices.size(); ++i) {
551             // FIXME: This essentially means we&#39;re exporting an import.
552             // We need a story here. We need to create a WebAssemblyFunction
553             // for the import.
554             // https://bugs.webkit.org/show_bug.cgi?id=165510
555             uint32_t functionIndex = element.functionIndices[i];
556             Wasm::SignatureIndex signatureIndex = module.signatureIndexFromFunctionIndexSpace(functionIndex);
557             if (functionIndex &lt; codeBlock-&gt;functionImportCount()) {
558                 JSObject* functionImport = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(functionIndex)-&gt;get();
559                 if (isWebAssemblyHostFunction(vm, functionImport)) {
560                     WebAssemblyFunction* wasmFunction = jsDynamicCast&lt;WebAssemblyFunction*&gt;(vm, functionImport);
561                     // If we ever import a WebAssemblyWrapperFunction, we set the import as the unwrapped value.
562                     // Because a WebAssemblyWrapperFunction can never wrap another WebAssemblyWrapperFunction,
563                     // the only type this could be is WebAssemblyFunction.
564                     RELEASE_ASSERT(wasmFunction);
565                     m_instance-&gt;table(tableIndex)-&gt;set(elementIndex, wasmFunction);
566                     ++elementIndex;
567                     continue;
568                 }
</pre>
<hr />
<pre>
586             m_instance-&gt;table(tableIndex)-&gt;set(elementIndex, function);
587             ++elementIndex;
588         }
589     });
590 
591     ASSERT(!exception);
592 
593     forEachSegment([&amp;] (uint8_t* memory, uint64_t, const Wasm::Segment::Ptr&amp; segment, uint32_t offset) {
594         // Empty segments are valid, but only if memory isn&#39;t present, which would be undefined behavior in memcpy.
595         if (segment-&gt;sizeInBytes) {
596             RELEASE_ASSERT(memory);
597             memcpy(memory + offset, &amp;segment-&gt;byte(0), segment-&gt;sizeInBytes);
598         }
599     });
600 
601     ASSERT(!exception);
602 
603     if (JSObject* startFunction = m_startFunction.get()) {
604         CallData callData;
605         CallType callType = JSC::getCallData(vm, startFunction, callData);
<span class="line-modified">606         call(exec, startFunction, callType, callData, jsUndefined(), *vm.emptyList);</span>
607         RETURN_IF_EXCEPTION(scope, { });
608     }
609 
610     return jsUndefined();
611 }
612 
613 } // namespace JSC
614 
615 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebAssemblyModuleRecord.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;Error.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;JSLexicalEnvironment.h&quot;
 34 #include &quot;JSModuleEnvironment.h&quot;
<span class="line-added"> 35 #include &quot;JSWebAssemblyGlobal.h&quot;</span>
 36 #include &quot;JSWebAssemblyHelpers.h&quot;
 37 #include &quot;JSWebAssemblyInstance.h&quot;
 38 #include &quot;JSWebAssemblyLinkError.h&quot;
 39 #include &quot;JSWebAssemblyModule.h&quot;
 40 #include &quot;ProtoCallFrame.h&quot;
 41 #include &quot;WasmSignatureInlines.h&quot;
 42 #include &quot;WebAssemblyFunction.h&quot;
 43 #include &lt;limits&gt;
 44 
 45 namespace JSC {
 46 
 47 const ClassInfo WebAssemblyModuleRecord::s_info = { &quot;WebAssemblyModuleRecord&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WebAssemblyModuleRecord) };
 48 
 49 Structure* WebAssemblyModuleRecord::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 50 {
 51     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 52 }
 53 
<span class="line-modified"> 54 WebAssemblyModuleRecord* WebAssemblyModuleRecord::create(JSGlobalObject* globalObject, VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey, const Wasm::ModuleInformation&amp; moduleInformation)</span>
 55 {
 56     WebAssemblyModuleRecord* instance = new (NotNull, allocateCell&lt;WebAssemblyModuleRecord&gt;(vm.heap)) WebAssemblyModuleRecord(vm, structure, moduleKey);
<span class="line-modified"> 57     instance-&gt;finishCreation(globalObject, vm, moduleInformation);</span>
 58     return instance;
 59 }
 60 
 61 WebAssemblyModuleRecord::WebAssemblyModuleRecord(VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey)
 62     : Base(vm, structure, moduleKey)
 63 {
 64 }
 65 
 66 void WebAssemblyModuleRecord::destroy(JSCell* cell)
 67 {
 68     WebAssemblyModuleRecord* thisObject = static_cast&lt;WebAssemblyModuleRecord*&gt;(cell);
 69     thisObject-&gt;WebAssemblyModuleRecord::~WebAssemblyModuleRecord();
 70 }
 71 
<span class="line-modified"> 72 void WebAssemblyModuleRecord::finishCreation(JSGlobalObject* globalObject, VM&amp; vm, const Wasm::ModuleInformation&amp; moduleInformation)</span>
 73 {
<span class="line-modified"> 74     Base::finishCreation(globalObject, vm);</span>
 75     ASSERT(inherits(vm, info()));
 76     for (const auto&amp; exp : moduleInformation.exports) {
 77         Identifier field = Identifier::fromString(vm, String::fromUTF8(exp.field));
 78         addExportEntry(ExportEntry::createLocal(field, field));
 79     }
 80 }
 81 
 82 void WebAssemblyModuleRecord::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 83 {
 84     WebAssemblyModuleRecord* thisObject = jsCast&lt;WebAssemblyModuleRecord*&gt;(cell);
 85     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 86     Base::visitChildren(thisObject, visitor);
 87     visitor.append(thisObject-&gt;m_instance);
 88     visitor.append(thisObject-&gt;m_startFunction);
 89 }
 90 
 91 void WebAssemblyModuleRecord::prepareLink(VM&amp; vm, JSWebAssemblyInstance* instance)
 92 {
 93     RELEASE_ASSERT(!m_instance);
 94     m_instance.set(vm, this, instance);
 95 }
 96 
<span class="line-modified"> 97 void WebAssemblyModuleRecord::link(JSGlobalObject* globalObject, JSValue, JSObject* importObject, Wasm::CreationMode creationMode)</span>
 98 {
<span class="line-modified"> 99     VM&amp; vm = globalObject-&gt;vm();</span>
100     auto scope = DECLARE_THROW_SCOPE(vm);
101     UNUSED_PARAM(scope);

102 
103     RELEASE_ASSERT(m_instance);
104 
105     Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
106     JSWebAssemblyModule* module = m_instance-&gt;module();
107     const Wasm::ModuleInformation&amp; moduleInformation = module-&gt;moduleInformation();
108 
109     auto exception = [&amp;] (JSObject* error) {
<span class="line-modified">110         throwException(globalObject, scope, error);</span>
111     };
112 
113     auto importFailMessage = [&amp;] (const Wasm::Import&amp; import, const char* before, const char* after) {
114         return makeString(before, &quot; &quot;, String::fromUTF8(import.module), &quot;:&quot;, String::fromUTF8(import.field), &quot; &quot;, after);
115     };
116 
117     for (const auto&amp; import : moduleInformation.imports) {
118         // Validation and linking other than Wasm::ExternalKind::Function is already done in JSWebAssemblyInstance.
119         // Eventually we will move all the linking code in JSWebAssemblyInstance here and remove this switch statement.
120         switch (import.kind) {
121         case Wasm::ExternalKind::Function:
122         case Wasm::ExternalKind::Global:
123         case Wasm::ExternalKind::Table:
124             break;
125         case Wasm::ExternalKind::Memory:
126             continue;
127         }
128 
129         Identifier moduleName = Identifier::fromString(vm, String::fromUTF8(import.module));
130         Identifier fieldName = Identifier::fromString(vm, String::fromUTF8(import.field));
131         JSValue value;
132         if (creationMode == Wasm::CreationMode::FromJS) {
133             // 1. Let o be the resultant value of performing Get(importObject, i.module_name).
<span class="line-modified">134             JSValue importModuleValue = importObject-&gt;get(globalObject, moduleName);</span>
135             RETURN_IF_EXCEPTION(scope, void());
136             // 2. If Type(o) is not Object, throw a TypeError.
137             if (!importModuleValue.isObject())
<span class="line-modified">138                 return exception(createTypeError(globalObject, importFailMessage(import, &quot;import&quot;, &quot;must be an object&quot;), defaultSourceAppender, runtimeTypeForValue(vm, importModuleValue)));</span>
139 
140             // 3. Let v be the value of performing Get(o, i.item_name)
141             JSObject* object = jsCast&lt;JSObject*&gt;(importModuleValue);
<span class="line-modified">142             value = object-&gt;get(globalObject, fieldName);</span>
143             RETURN_IF_EXCEPTION(scope, void());
144         } else {
<span class="line-modified">145             AbstractModuleRecord* importedModule = hostResolveImportedModule(globalObject, moduleName);</span>
146             RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">147             Resolution resolution = importedModule-&gt;resolveExport(globalObject, fieldName);</span>
148             RETURN_IF_EXCEPTION(scope, void());
149             switch (resolution.type) {
150             case Resolution::Type::NotFound:
<span class="line-modified">151                 throwSyntaxError(globalObject, scope, makeString(&quot;Importing binding name &#39;&quot;, String(fieldName.impl()), &quot;&#39; is not found.&quot;));</span>
152                 return;
153 
154             case Resolution::Type::Ambiguous:
<span class="line-modified">155                 throwSyntaxError(globalObject, scope, makeString(&quot;Importing binding name &#39;&quot;, String(fieldName.impl()), &quot;&#39; cannot be resolved due to ambiguous multiple bindings.&quot;));</span>
156                 return;
157 
158             case Resolution::Type::Error:
<span class="line-modified">159                 throwSyntaxError(globalObject, scope, makeString(&quot;Importing binding name &#39;default&#39; cannot be resolved by star export entries.&quot;));</span>
160                 return;
161 
162             case Resolution::Type::Resolved:
163                 break;
164             }
165 
166             AbstractModuleRecord* importedRecord = resolution.moduleRecord;
167             JSModuleEnvironment* importedEnvironment = importedRecord-&gt;moduleEnvironmentMayBeNull();
168             // It means that target module is not linked yet. In wasm loading, we allow this since we do not solve cyclic resolution as if JS&#39;s bindings.
169             // At that time, error occurs since |value| is an empty, and later |value| becomes an undefined.
170             // https://github.com/WebAssembly/esm-integration/tree/master/proposals/esm-integration#js---wasm-cycle-where-js-is-higher-in-the-module-graph
171             if (importedEnvironment) {
172                 SymbolTable* symbolTable = importedEnvironment-&gt;symbolTable();
173                 ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
174                 auto iter = symbolTable-&gt;find(locker, resolution.localName.impl());
175                 ASSERT(iter != symbolTable-&gt;end(locker));
176                 SymbolTableEntry&amp; entry = iter-&gt;value;
177                 ASSERT(!entry.isNull());
178                 ASSERT(importedEnvironment-&gt;isValidScopeOffset(entry.scopeOffset()));
179 
180                 // Snapshotting a value.
181                 value = importedEnvironment-&gt;variableAt(entry.scopeOffset()).get();
182             }
183         }
184         if (!value)
185             value = jsUndefined();
186 
187         switch (import.kind) {
188         case Wasm::ExternalKind::Function: {
189             // 4. If i is a function import:
190             // i. If IsCallable(v) is false, throw a WebAssembly.LinkError.
191             if (!value.isFunction(vm))
<span class="line-modified">192                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;import function&quot;, &quot;must be callable&quot;)));</span>
193 
194             Wasm::Instance* calleeInstance = nullptr;
195             WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = nullptr;
196             JSObject* function = jsCast&lt;JSObject*&gt;(value);
197 
198             // ii. If v is an Exported Function Exotic Object:
199             WebAssemblyFunction* wasmFunction;
200             WebAssemblyWrapperFunction* wasmWrapperFunction;
201             if (isWebAssemblyHostFunction(vm, function, wasmFunction, wasmWrapperFunction)) {
202                 // a. If the signature of v does not match the signature of i, throw a WebAssembly.LinkError.
203                 Wasm::SignatureIndex importedSignatureIndex;
204                 if (wasmFunction) {
205                     importedSignatureIndex = wasmFunction-&gt;signatureIndex();
206                     calleeInstance = &amp;wasmFunction-&gt;instance()-&gt;instance();
207                     entrypointLoadLocation = wasmFunction-&gt;entrypointLoadLocation();
208                 } else {
209                     importedSignatureIndex = wasmWrapperFunction-&gt;signatureIndex();
210                     // b. Let closure be v.[[Closure]].
211                     function = wasmWrapperFunction-&gt;function();
212                 }
213                 Wasm::SignatureIndex expectedSignatureIndex = moduleInformation.importFunctionSignatureIndices[import.kindIndex];
214                 if (importedSignatureIndex != expectedSignatureIndex)
<span class="line-modified">215                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported function&quot;, &quot;signature doesn&#39;t match the provided WebAssembly function&#39;s signature&quot;)));</span>
216             }
217             // iii. Otherwise:
218             // a. Let closure be a new host function of the given signature which calls v by coercing WebAssembly arguments to JavaScript arguments via ToJSValue and returns the result, if any, by coercing via ToWebAssemblyValue.
219             // Note: done as part of Plan compilation.
220             // iv. Append v to funcs.
221             // Note: adding the JSCell to the instance list fulfills closure requirements b. above (the WebAssembly.Instance wil be kept alive) and v. below (the JSFunction).
222 
223             auto* info = m_instance-&gt;instance().importFunctionInfo(import.kindIndex);
224             info-&gt;targetInstance = calleeInstance;
225             info-&gt;wasmEntrypointLoadLocation = entrypointLoadLocation;
226             m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(import.kindIndex)-&gt;set(vm, m_instance.get(), function);
227             break;
228         }
229 
230         case Wasm::ExternalKind::Global: {
231             // 5. If i is a global import:
<span class="line-modified">232             const Wasm::GlobalInformation&amp; global = moduleInformation.globals[import.kindIndex];</span>
<span class="line-modified">233             if (global.mutability == Wasm::GlobalInformation::Immutable) {</span>
<span class="line-modified">234                 if (value.inherits&lt;JSWebAssemblyGlobal&gt;(vm)) {</span>
<span class="line-modified">235                     JSWebAssemblyGlobal* globalValue = jsCast&lt;JSWebAssemblyGlobal*&gt;(value);</span>
<span class="line-modified">236                     if (globalValue-&gt;global()-&gt;type() != global.type)</span>
<span class="line-modified">237                         return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a same type&quot;)));</span>
<span class="line-modified">238                     if (globalValue-&gt;global()-&gt;mutability() != Wasm::GlobalInformation::Immutable)</span>
<span class="line-modified">239                         return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a same mutability&quot;)));</span>
<span class="line-modified">240                     switch (moduleInformation.globals[import.kindIndex].type) {</span>
<span class="line-modified">241                     case Wasm::Funcref:</span>
<span class="line-modified">242                         value = globalValue-&gt;global()-&gt;get();</span>
<span class="line-modified">243                         if (!isWebAssemblyHostFunction(vm, value) &amp;&amp; !value.isNull())</span>
<span class="line-modified">244                             return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a wasm exported function or null&quot;)));</span>
<span class="line-modified">245                         m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-modified">246                         break;</span>
<span class="line-modified">247                     case Wasm::Anyref:</span>
<span class="line-modified">248                         value = globalValue-&gt;global()-&gt;get();</span>
<span class="line-modified">249                         m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-modified">250                         break;</span>
<span class="line-modified">251                     case Wasm::I32:</span>
<span class="line-modified">252                     case Wasm::I64:</span>
<span class="line-modified">253                     case Wasm::F32:</span>
<span class="line-modified">254                     case Wasm::F64:</span>
<span class="line-modified">255                         m_instance-&gt;instance().setGlobal(import.kindIndex, globalValue-&gt;global()-&gt;getPrimitive());</span>
<span class="line-modified">256                         break;</span>
<span class="line-modified">257                     default:</span>
<span class="line-modified">258                         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-modified">259                     }</span>
<span class="line-added">260                 } else {</span>
<span class="line-added">261                     // ii. If the global_type of i is i64 or Type(v) is not Number, throw a WebAssembly.LinkError.</span>
<span class="line-added">262                     if (moduleInformation.globals[import.kindIndex].type == Wasm::I64)</span>
<span class="line-added">263                         return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;cannot be an i64&quot;)));</span>
<span class="line-added">264                     if (!isSubtype(moduleInformation.globals[import.kindIndex].type, Wasm::Anyref) &amp;&amp; !value.isNumber())</span>
<span class="line-added">265                         return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a number&quot;)));</span>
<span class="line-added">266 </span>
<span class="line-added">267                     // iii. Append ToWebAssemblyValue(v) to imports.</span>
<span class="line-added">268                     switch (moduleInformation.globals[import.kindIndex].type) {</span>
<span class="line-added">269                     case Wasm::Funcref:</span>
<span class="line-added">270                         if (!isWebAssemblyHostFunction(vm, value) &amp;&amp; !value.isNull())</span>
<span class="line-added">271                             return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a wasm exported function or null&quot;)));</span>
<span class="line-added">272                         m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-added">273                         break;</span>
<span class="line-added">274                     case Wasm::Anyref:</span>
<span class="line-added">275                         m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-added">276                         break;</span>
<span class="line-added">277                     case Wasm::I32:</span>
<span class="line-added">278                         m_instance-&gt;instance().setGlobal(import.kindIndex, value.toInt32(globalObject));</span>
<span class="line-added">279                         break;</span>
<span class="line-added">280                     case Wasm::F32:</span>
<span class="line-added">281                         m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint32_t&gt;(value.toFloat(globalObject)));</span>
<span class="line-added">282                         break;</span>
<span class="line-added">283                     case Wasm::F64:</span>
<span class="line-added">284                         m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint64_t&gt;(value.asNumber()));</span>
<span class="line-added">285                         break;</span>
<span class="line-added">286                     default:</span>
<span class="line-added">287                         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">288                     }</span>
<span class="line-added">289                 }</span>
<span class="line-added">290             } else {</span>
<span class="line-added">291                 if (!value.inherits&lt;JSWebAssemblyGlobal&gt;(vm))</span>
<span class="line-added">292                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a WebAssembly.Global object since it is mutable&quot;)));</span>
<span class="line-added">293                 JSWebAssemblyGlobal* globalValue = jsCast&lt;JSWebAssemblyGlobal*&gt;(value);</span>
<span class="line-added">294                 if (globalValue-&gt;global()-&gt;type() != global.type)</span>
<span class="line-added">295                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a same type&quot;)));</span>
<span class="line-added">296                 if (globalValue-&gt;global()-&gt;mutability() != global.mutability)</span>
<span class="line-added">297                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a same mutability&quot;)));</span>
<span class="line-added">298                 m_instance-&gt;linkGlobal(vm, import.kindIndex, globalValue);</span>
299             }
300             scope.assertNoException();
301             break;
302         }
303 
304         case Wasm::ExternalKind::Table: {
305             // 7. Otherwise (i is a table import):
306             JSWebAssemblyTable* table = jsDynamicCast&lt;JSWebAssemblyTable*&gt;(vm, value);
307             // i. If v is not a WebAssembly.Table object, throw a WebAssembly.LinkError.
308             if (!table)
<span class="line-modified">309                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Table import&quot;, &quot;is not an instance of WebAssembly.Table&quot;)));</span>
310 
311             uint32_t expectedInitial = moduleInformation.tables[import.kindIndex].initial();
312             uint32_t actualInitial = table-&gt;length();
313             if (actualInitial &lt; expectedInitial)
<span class="line-modified">314                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Table import&quot;, &quot;provided an &#39;initial&#39; that is too small&quot;)));</span>
315 
316             if (Optional&lt;uint32_t&gt; expectedMaximum = moduleInformation.tables[import.kindIndex].maximum()) {
317                 Optional&lt;uint32_t&gt; actualMaximum = table-&gt;maximum();
318                 if (!actualMaximum)
<span class="line-modified">319                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Table import&quot;, &quot;does not have a &#39;maximum&#39; but the module requires that it does&quot;)));</span>
320                 if (*actualMaximum &gt; *expectedMaximum)
<span class="line-modified">321                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Imported Table&quot;, &quot;&#39;maximum&#39; is larger than the module&#39;s expected &#39;maximum&#39;&quot;)));</span>
322             }
323 
324             auto expectedType = moduleInformation.tables[import.kindIndex].type();
325             auto actualType = table-&gt;table()-&gt;type();
326             if (expectedType != actualType)
<span class="line-modified">327                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Table import&quot;, &quot;provided a &#39;type&#39; that is wrong&quot;)));</span>
328 
329             // ii. Append v to tables.
330             // iii. Append v.[[Table]] to imports.
331             m_instance-&gt;setTable(vm, import.kindIndex, table);
332             RETURN_IF_EXCEPTION(scope, void());
333             break;
334         }
335 
336         case Wasm::ExternalKind::Memory:
337             break;
338         }
339     }
340 
341     for (unsigned i = 0; i &lt; moduleInformation.tableCount(); ++i) {
342         if (moduleInformation.tables[i].isImport()) {
343             // We should either have a Table import or we should have thrown an exception.
344             RELEASE_ASSERT(m_instance-&gt;table(i));
345         }
346 
347         if (!m_instance-&gt;table(i)) {
348             RELEASE_ASSERT(!moduleInformation.tables[i].isImport());
349             // We create a Table when it&#39;s a Table definition.
350             RefPtr&lt;Wasm::Table&gt; wasmTable = Wasm::Table::tryCreate(moduleInformation.tables[i].initial(), moduleInformation.tables[i].maximum(), moduleInformation.tables[i].type());
351             if (!wasmTable)
<span class="line-modified">352                 return exception(createJSWebAssemblyLinkError(globalObject, vm, &quot;couldn&#39;t create Table&quot;));</span>
<span class="line-modified">353             JSWebAssemblyTable* table = JSWebAssemblyTable::tryCreate(globalObject, vm, globalObject-&gt;webAssemblyTableStructure(), wasmTable.releaseNonNull());</span>
354             // We should always be able to allocate a JSWebAssemblyTable we&#39;ve defined.
355             // If it&#39;s defined to be too large, we should have thrown a validation error.
356             scope.assertNoException();
357             ASSERT(table);
358             m_instance-&gt;setTable(vm, i, table);
359             RETURN_IF_EXCEPTION(scope, void());
360         }
361     }
362 
363     unsigned functionImportCount = codeBlock-&gt;functionImportCount();
364     auto makeFunctionWrapper = [&amp;] (const String&amp; field, uint32_t index) -&gt; JSValue {
365         // If we already made a wrapper, do not make a new one.
366         JSValue wrapper = m_instance-&gt;instance().getFunctionWrapper(index);
367 
368         if (!wrapper.isNull())
369             return wrapper;
370 
371         // 1. If e is a closure c:
372         //   i. If there is an Exported Function Exotic Object func in funcs whose func.[[Closure]] equals c, then return func.
373         //   ii. (Note: At most one wrapper is created for any closure, so func is unique, even if there are multiple occurrances in the list. Moreover, if the item was an import that is already an Exported Function Exotic Object, then the original function object will be found. For imports that are regular JS functions, a new wrapper will be created.)
</pre>
<hr />
<pre>
388             Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = codeBlock-&gt;entrypointLoadLocationFromFunctionIndexSpace(index);
389             Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(index);
390             const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
391             WebAssemblyFunction* function = WebAssemblyFunction::create(vm, globalObject, globalObject-&gt;webAssemblyFunctionStructure(), signature.argumentCount(), field, m_instance.get(), embedderEntrypointCallee, entrypointLoadLocation, signatureIndex);
392             wrapper = function;
393         }
394 
395         ASSERT(wrapper.isFunction(vm));
396         m_instance-&gt;instance().setFunctionWrapper(index, wrapper);
397 
398         return wrapper;
399     };
400 
401     for (auto index : moduleInformation.referencedFunctions())
402         makeFunctionWrapper(&quot;Referenced function&quot;, index);
403 
404     // Globals
405     {
406         for (size_t globalIndex = moduleInformation.firstInternalGlobal; globalIndex &lt; moduleInformation.globals.size(); ++globalIndex) {
407             const auto&amp; global = moduleInformation.globals[globalIndex];
<span class="line-modified">408             ASSERT(global.initializationType != Wasm::GlobalInformation::IsImport);</span>
<span class="line-modified">409             uint64_t initialBits = 0;</span>
<span class="line-added">410             if (global.initializationType == Wasm::GlobalInformation::FromGlobalImport) {</span>
411                 ASSERT(global.initialBitsOrImportNumber &lt; moduleInformation.firstInternalGlobal);
<span class="line-modified">412                 initialBits = m_instance-&gt;instance().loadI64Global(global.initialBitsOrImportNumber);</span>
<span class="line-modified">413             } else if (global.initializationType == Wasm::GlobalInformation::FromRefFunc) {</span>
414                 ASSERT(global.initialBitsOrImportNumber &lt; moduleInformation.functionIndexSpaceSize());
415                 ASSERT(makeFunctionWrapper(&quot;Global init expr&quot;, global.initialBitsOrImportNumber).isFunction(vm));
<span class="line-modified">416                 initialBits = JSValue::encode(makeFunctionWrapper(&quot;Global init expr&quot;, global.initialBitsOrImportNumber));</span>
417             } else
<span class="line-modified">418                 initialBits = global.initialBitsOrImportNumber;</span>
<span class="line-added">419 </span>
<span class="line-added">420             switch (global.bindingMode) {</span>
<span class="line-added">421             case Wasm::GlobalInformation::BindingMode::EmbeddedInInstance: {</span>
<span class="line-added">422                 m_instance-&gt;instance().setGlobal(globalIndex, initialBits);</span>
<span class="line-added">423                 break;</span>
<span class="line-added">424             }</span>
<span class="line-added">425             case Wasm::GlobalInformation::BindingMode::Portable: {</span>
<span class="line-added">426                 ASSERT(global.mutability == Wasm::GlobalInformation::Mutability::Mutable);</span>
<span class="line-added">427                 Ref&lt;Wasm::Global&gt; globalRef = Wasm::Global::create(global.type, Wasm::GlobalInformation::Mutability::Mutable, initialBits);</span>
<span class="line-added">428                 JSWebAssemblyGlobal* globalValue = JSWebAssemblyGlobal::tryCreate(globalObject, vm, globalObject-&gt;webAssemblyGlobalStructure(), WTFMove(globalRef));</span>
<span class="line-added">429                 scope.assertNoException();</span>
<span class="line-added">430                 m_instance-&gt;linkGlobal(vm, globalIndex, globalValue);</span>
<span class="line-added">431                 keepAlive(bitwise_cast&lt;void*&gt;(initialBits)); // Ensure this is kept alive while creating JSWebAssemblyGlobal.</span>
<span class="line-added">432                 break;</span>
<span class="line-added">433             }</span>
<span class="line-added">434             }</span>
435         }
436     }
437 
438     SymbolTable* exportSymbolTable = module-&gt;exportSymbolTable();
439 
440     // Let exports be a list of (string, JS value) pairs that is mapped from each external value e in instance.exports as follows:
441     JSModuleEnvironment* moduleEnvironment = JSModuleEnvironment::create(vm, globalObject, nullptr, exportSymbolTable, JSValue(), this);
442     for (const auto&amp; exp : moduleInformation.exports) {
443         JSValue exportedValue;
444         switch (exp.kind) {
445         case Wasm::ExternalKind::Function: {
446             exportedValue = makeFunctionWrapper(String::fromUTF8(exp.field), exp.kindIndex);
447             ASSERT(exportedValue.isFunction(vm));
448             ASSERT(makeFunctionWrapper(String::fromUTF8(exp.field), exp.kindIndex) == exportedValue);
449             break;
450         }
451         case Wasm::ExternalKind::Table: {
452             // This should be guaranteed by module verification.
453             RELEASE_ASSERT(m_instance-&gt;table(exp.kindIndex));
454             exportedValue = m_instance-&gt;table(exp.kindIndex);
455             break;
456         }
457         case Wasm::ExternalKind::Memory: {
458             ASSERT(exp.kindIndex == 0);
459 
460             exportedValue = m_instance-&gt;memory();
461             break;
462         }
463         case Wasm::ExternalKind::Global: {
<span class="line-modified">464             const Wasm::GlobalInformation&amp; global = moduleInformation.globals[exp.kindIndex];</span>



465             switch (global.type) {
466             case Wasm::Anyref:
467             case Wasm::Funcref:



468             case Wasm::I32:



469             case Wasm::I64:



470             case Wasm::F32:
<span class="line-modified">471             case Wasm::F64: {</span>
<span class="line-modified">472                 // If global is immutable, we are not creating a binding internally.</span>
<span class="line-modified">473                 // But we need to create a binding just to export it. This binding is not actually connected. But this is OK since it is immutable.</span>
<span class="line-modified">474                 if (global.bindingMode == Wasm::GlobalInformation::BindingMode::EmbeddedInInstance) {</span>
<span class="line-modified">475                     uint64_t initialValue = m_instance-&gt;instance().loadI64Global(exp.kindIndex);</span>
<span class="line-added">476                     Ref&lt;Wasm::Global&gt; globalRef = Wasm::Global::create(global.type, global.mutability, initialValue);</span>
<span class="line-added">477                     exportedValue = JSWebAssemblyGlobal::tryCreate(globalObject, vm, globalObject-&gt;webAssemblyGlobalStructure(), WTFMove(globalRef));</span>
<span class="line-added">478                     scope.assertNoException();</span>
<span class="line-added">479                 } else {</span>
<span class="line-added">480                     ASSERT(global.mutability == Wasm::GlobalInformation::Mutability::Mutable);</span>
<span class="line-added">481                     RefPtr&lt;Wasm::Global&gt; globalRef = m_instance-&gt;instance().getGlobalBinding(exp.kindIndex);</span>
<span class="line-added">482                     ASSERT(globalRef);</span>
<span class="line-added">483                     ASSERT(globalRef-&gt;type() == global.type);</span>
<span class="line-added">484                     ASSERT(globalRef-&gt;mutability() == global.mutability);</span>
<span class="line-added">485                     ASSERT(globalRef-&gt;mutability() == Wasm::GlobalInformation::Mutability::Mutable);</span>
<span class="line-added">486                     ASSERT(globalRef-&gt;owner&lt;JSWebAssemblyGlobal&gt;());</span>
<span class="line-added">487                     exportedValue = globalRef-&gt;owner&lt;JSWebAssemblyGlobal&gt;();</span>
<span class="line-added">488                 }</span>
489                 break;
<span class="line-modified">490             }</span>
491             default:
492                 RELEASE_ASSERT_NOT_REACHED();
493             }
494             break;
495         }
496         }
497 
498         bool shouldThrowReadOnlyError = false;
499         bool ignoreReadOnlyErrors = true;
500         bool putResult = false;
<span class="line-modified">501         symbolTablePutTouchWatchpointSet(moduleEnvironment, globalObject, Identifier::fromString(vm, String::fromUTF8(exp.field)), exportedValue, shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);</span>
502         scope.assertNoException();
503         RELEASE_ASSERT(putResult);
504     }
505 
506     bool hasStart = !!moduleInformation.startFunctionIndexSpace;
507     if (hasStart) {
508         auto startFunctionIndexSpace = moduleInformation.startFunctionIndexSpace.valueOr(0);
509         Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndexSpace);
510         const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
511         // The start function must not take any arguments or return anything. This is enforced by the parser.
512         ASSERT(!signature.argumentCount());
<span class="line-modified">513         ASSERT(signature.returnsVoid());</span>
514         if (startFunctionIndexSpace &lt; codeBlock-&gt;functionImportCount()) {
515             JSObject* startFunction = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(startFunctionIndexSpace)-&gt;get();
516             m_startFunction.set(vm, this, startFunction);
517         } else {
518             Wasm::Callee&amp; embedderEntrypointCallee = codeBlock-&gt;embedderEntrypointCalleeFromFunctionIndexSpace(startFunctionIndexSpace);
519             Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = codeBlock-&gt;entrypointLoadLocationFromFunctionIndexSpace(startFunctionIndexSpace);
520             WebAssemblyFunction* function = WebAssemblyFunction::create(vm, globalObject, globalObject-&gt;webAssemblyFunctionStructure(), signature.argumentCount(), &quot;start&quot;, m_instance.get(), embedderEntrypointCallee, entrypointLoadLocation, signatureIndex);
521             m_startFunction.set(vm, this, function);
522         }
523     }
524     m_moduleEnvironment.set(vm, this, moduleEnvironment);
525 }
526 
527 template &lt;typename Scope, typename M, typename N, typename ...Args&gt;
<span class="line-modified">528 NEVER_INLINE static JSValue dataSegmentFail(JSGlobalObject* globalObject, VM&amp; vm, Scope&amp; scope, M memorySize, N segmentSize, N offset, Args... args)</span>
529 {
<span class="line-modified">530     return throwException(globalObject, scope, createJSWebAssemblyLinkError(globalObject, vm, makeString(&quot;Invalid data segment initialization: segment of &quot;_s, String::number(segmentSize), &quot; bytes memory of &quot;_s, String::number(memorySize), &quot; bytes, at offset &quot;_s, String::number(offset), args...)));</span>
531 }
532 
<span class="line-modified">533 JSValue WebAssemblyModuleRecord::evaluate(JSGlobalObject* globalObject)</span>
534 {
<span class="line-modified">535     VM&amp; vm = globalObject-&gt;vm();</span>
536     auto scope = DECLARE_THROW_SCOPE(vm);
537 
538     Wasm::Module&amp; module = m_instance-&gt;instance().module();
539     Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
540     const Wasm::ModuleInformation&amp; moduleInformation = module.moduleInformation();
541 
542     const Vector&lt;Wasm::Segment::Ptr&gt;&amp; data = moduleInformation.data;
543 
544     Optional&lt;JSValue&gt; exception;
545 
546     auto forEachElement = [&amp;] (auto fn) {
547         for (const Wasm::Element&amp; element : moduleInformation.elements) {
548             // It should be a validation error to have any elements without a table.
549             // Also, it could be that a table wasn&#39;t imported, or that the table
550             // imported wasn&#39;t compatible. However, those should error out before
551             // getting here.
552             ASSERT(!!m_instance-&gt;table(element.tableIndex));
553 
554             if (!element.functionIndices.size())
555                 continue;
</pre>
<hr />
<pre>
568     auto forEachSegment = [&amp;] (auto fn) {
569         uint8_t* memory = reinterpret_cast&lt;uint8_t*&gt;(m_instance-&gt;instance().cachedMemory());
570         uint64_t sizeInBytes = m_instance-&gt;instance().cachedMemorySize();
571 
572         for (const Wasm::Segment::Ptr&amp; segment : data) {
573             uint32_t offset = segment-&gt;offset.isGlobalImport()
574                 ? static_cast&lt;uint32_t&gt;(m_instance-&gt;instance().loadI32Global(segment-&gt;offset.globalImportIndex()))
575                 : segment-&gt;offset.constValue();
576 
577             fn(memory, sizeInBytes, segment, offset);
578 
579             if (exception)
580                 break;
581         }
582     };
583 
584     // Validation of all element ranges comes before all Table and Memory initialization.
585     forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex, uint32_t elementIndex) {
586         uint64_t lastWrittenIndex = static_cast&lt;uint64_t&gt;(elementIndex) + static_cast&lt;uint64_t&gt;(element.functionIndices.size()) - 1;
587         if (UNLIKELY(lastWrittenIndex &gt;= m_instance-&gt;table(tableIndex)-&gt;length()))
<span class="line-modified">588             exception = JSValue(throwException(globalObject, scope, createJSWebAssemblyLinkError(globalObject, vm, &quot;Element is trying to set an out of bounds table index&quot;_s)));</span>
589     });
590 
591     if (UNLIKELY(exception))
592         return exception.value();
593 
594     // Validation of all segment ranges comes before all Table and Memory initialization.
595     forEachSegment([&amp;] (uint8_t*, uint64_t sizeInBytes, const Wasm::Segment::Ptr&amp; segment, uint32_t offset) {
596         if (UNLIKELY(sizeInBytes &lt; segment-&gt;sizeInBytes))
<span class="line-modified">597             exception = dataSegmentFail(globalObject, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment is too big&quot;_s);</span>
598         else if (UNLIKELY(offset &gt; sizeInBytes - segment-&gt;sizeInBytes))
<span class="line-modified">599             exception = dataSegmentFail(globalObject, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment writes outside of memory&quot;_s);</span>
600     });
601 
602     if (UNLIKELY(exception))
603         return exception.value();
604 

605     forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex, uint32_t elementIndex) {
606         for (uint32_t i = 0; i &lt; element.functionIndices.size(); ++i) {
607             // FIXME: This essentially means we&#39;re exporting an import.
608             // We need a story here. We need to create a WebAssemblyFunction
609             // for the import.
610             // https://bugs.webkit.org/show_bug.cgi?id=165510
611             uint32_t functionIndex = element.functionIndices[i];
612             Wasm::SignatureIndex signatureIndex = module.signatureIndexFromFunctionIndexSpace(functionIndex);
613             if (functionIndex &lt; codeBlock-&gt;functionImportCount()) {
614                 JSObject* functionImport = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(functionIndex)-&gt;get();
615                 if (isWebAssemblyHostFunction(vm, functionImport)) {
616                     WebAssemblyFunction* wasmFunction = jsDynamicCast&lt;WebAssemblyFunction*&gt;(vm, functionImport);
617                     // If we ever import a WebAssemblyWrapperFunction, we set the import as the unwrapped value.
618                     // Because a WebAssemblyWrapperFunction can never wrap another WebAssemblyWrapperFunction,
619                     // the only type this could be is WebAssemblyFunction.
620                     RELEASE_ASSERT(wasmFunction);
621                     m_instance-&gt;table(tableIndex)-&gt;set(elementIndex, wasmFunction);
622                     ++elementIndex;
623                     continue;
624                 }
</pre>
<hr />
<pre>
642             m_instance-&gt;table(tableIndex)-&gt;set(elementIndex, function);
643             ++elementIndex;
644         }
645     });
646 
647     ASSERT(!exception);
648 
649     forEachSegment([&amp;] (uint8_t* memory, uint64_t, const Wasm::Segment::Ptr&amp; segment, uint32_t offset) {
650         // Empty segments are valid, but only if memory isn&#39;t present, which would be undefined behavior in memcpy.
651         if (segment-&gt;sizeInBytes) {
652             RELEASE_ASSERT(memory);
653             memcpy(memory + offset, &amp;segment-&gt;byte(0), segment-&gt;sizeInBytes);
654         }
655     });
656 
657     ASSERT(!exception);
658 
659     if (JSObject* startFunction = m_startFunction.get()) {
660         CallData callData;
661         CallType callType = JSC::getCallData(vm, startFunction, callData);
<span class="line-modified">662         call(globalObject, startFunction, callType, callData, jsUndefined(), *vm.emptyList);</span>
663         RETURN_IF_EXCEPTION(scope, { });
664     }
665 
666     return jsUndefined();
667 }
668 
669 } // namespace JSC
670 
671 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
</tr>
</table>
<center><a href="WebAssemblyModulePrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebAssemblyModuleRecord.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
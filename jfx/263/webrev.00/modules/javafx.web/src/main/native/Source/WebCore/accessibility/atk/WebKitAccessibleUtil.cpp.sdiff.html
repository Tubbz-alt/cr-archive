<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/WebKitAccessibleUtil.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebKitAccessibleInterfaceText.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebKitAccessibleUtil.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/WebKitAccessibleUtil.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
159         return false;
160 
161     RefPtr&lt;Range&gt; range = selection.toNormalizedRange();
162     if (!range)
163         return false;
164 
165     // We want to check that both the selection intersects the node
166     // AND that the selection is not just &quot;touching&quot; one of the
167     // boundaries for the selected node. We want to check whether the
168     // node is actually inside the region, at least partially.
169     auto&amp; node = *coreObject-&gt;node();
170     auto* lastDescendant = node.lastDescendant();
171     unsigned lastOffset = lastOffsetInNode(lastDescendant);
172     auto intersectsResult = range-&gt;intersectsNode(node);
173     return !intersectsResult.hasException()
174         &amp;&amp; intersectsResult.releaseReturnValue()
175         &amp;&amp; (&amp;range-&gt;endContainer() != &amp;node || range-&gt;endOffset())
176         &amp;&amp; (&amp;range-&gt;startContainer() != lastDescendant || range-&gt;startOffset() != lastOffset);
177 }
178 
<span class="line-modified">179 AccessibilityObject* objectFocusedAndCaretOffsetUnignored(AccessibilityObject* referenceObject, int&amp; offset)</span>
180 {
181     // Indication that something bogus has transpired.
182     offset = -1;
183 
184     Document* document = referenceObject-&gt;document();
185     if (!document)
186         return nullptr;
187 
188     Node* focusedNode = referenceObject-&gt;selection().end().containerNode();
189     if (!focusedNode)
190         return nullptr;
191 
192     RenderObject* focusedRenderer = focusedNode-&gt;renderer();
193     if (!focusedRenderer)
194         return nullptr;
195 
196     AccessibilityObject* focusedObject = document-&gt;axObjectCache()-&gt;getOrCreate(focusedRenderer);
197     if (!focusedObject)
198         return nullptr;
199 
200     // Look for the actual (not ignoring accessibility) selected object.
<span class="line-modified">201     AccessibilityObject* firstUnignoredParent = focusedObject;</span>
202     if (firstUnignoredParent-&gt;accessibilityIsIgnored())
203         firstUnignoredParent = firstUnignoredParent-&gt;parentObjectUnignored();
204     if (!firstUnignoredParent)
205         return nullptr;
206 
207     // Don&#39;t ignore links if the offset is being requested for a link
208     // or if the link is a block.
209     if (!referenceObject-&gt;isLink() &amp;&amp; firstUnignoredParent-&gt;isLink()
210         &amp;&amp; !(firstUnignoredParent-&gt;renderer() &amp;&amp; !firstUnignoredParent-&gt;renderer()-&gt;isInline()))
211         firstUnignoredParent = firstUnignoredParent-&gt;parentObjectUnignored();
212     if (!firstUnignoredParent)
213         return nullptr;
214 
215     // The reference object must either coincide with the focused
216     // object being considered, or be a descendant of it.
217     if (referenceObject-&gt;isDescendantOfObject(firstUnignoredParent))
218         referenceObject = firstUnignoredParent;
219 
220     Node* startNode = nullptr;
221     if (firstUnignoredParent != referenceObject || firstUnignoredParent-&gt;isTextControl()) {
222         // We need to use the first child&#39;s node of the reference
223         // object as the start point to calculate the caret offset
224         // because we want it to be relative to the object of
225         // reference, not just to the focused object (which could have
226         // previous siblings which should be taken into account too).
<span class="line-modified">227         AccessibilityObject* axFirstChild = referenceObject-&gt;firstChild();</span>
228         if (axFirstChild)
229             startNode = axFirstChild-&gt;node();
230     }
231     // Getting the Position of a PseudoElement now triggers an assertion.
232     // This can occur when clicking on empty space in a render block.
233     if (!startNode || startNode-&gt;isPseudoElement())
234         startNode = firstUnignoredParent-&gt;node();
235 
236     // Check if the node for the first parent object not ignoring
237     // accessibility is null again before using it. This might happen
238     // with certain kind of accessibility objects, such as the root
239     // one (the scroller containing the webArea object).
240     if (!startNode)
241         return nullptr;
242 
243     VisiblePosition startPosition = VisiblePosition(positionBeforeNode(startNode), DOWNSTREAM);
244     VisiblePosition endPosition = firstUnignoredParent-&gt;selection().visibleEnd();
245 
246     if (startPosition == endPosition)
247         offset = 0;
</pre>
</td>
<td>
<hr />
<pre>
159         return false;
160 
161     RefPtr&lt;Range&gt; range = selection.toNormalizedRange();
162     if (!range)
163         return false;
164 
165     // We want to check that both the selection intersects the node
166     // AND that the selection is not just &quot;touching&quot; one of the
167     // boundaries for the selected node. We want to check whether the
168     // node is actually inside the region, at least partially.
169     auto&amp; node = *coreObject-&gt;node();
170     auto* lastDescendant = node.lastDescendant();
171     unsigned lastOffset = lastOffsetInNode(lastDescendant);
172     auto intersectsResult = range-&gt;intersectsNode(node);
173     return !intersectsResult.hasException()
174         &amp;&amp; intersectsResult.releaseReturnValue()
175         &amp;&amp; (&amp;range-&gt;endContainer() != &amp;node || range-&gt;endOffset())
176         &amp;&amp; (&amp;range-&gt;startContainer() != lastDescendant || range-&gt;startOffset() != lastOffset);
177 }
178 
<span class="line-modified">179 AXCoreObject* objectFocusedAndCaretOffsetUnignored(AXCoreObject* referenceObject, int&amp; offset)</span>
180 {
181     // Indication that something bogus has transpired.
182     offset = -1;
183 
184     Document* document = referenceObject-&gt;document();
185     if (!document)
186         return nullptr;
187 
188     Node* focusedNode = referenceObject-&gt;selection().end().containerNode();
189     if (!focusedNode)
190         return nullptr;
191 
192     RenderObject* focusedRenderer = focusedNode-&gt;renderer();
193     if (!focusedRenderer)
194         return nullptr;
195 
196     AccessibilityObject* focusedObject = document-&gt;axObjectCache()-&gt;getOrCreate(focusedRenderer);
197     if (!focusedObject)
198         return nullptr;
199 
200     // Look for the actual (not ignoring accessibility) selected object.
<span class="line-modified">201     AXCoreObject* firstUnignoredParent = focusedObject;</span>
202     if (firstUnignoredParent-&gt;accessibilityIsIgnored())
203         firstUnignoredParent = firstUnignoredParent-&gt;parentObjectUnignored();
204     if (!firstUnignoredParent)
205         return nullptr;
206 
207     // Don&#39;t ignore links if the offset is being requested for a link
208     // or if the link is a block.
209     if (!referenceObject-&gt;isLink() &amp;&amp; firstUnignoredParent-&gt;isLink()
210         &amp;&amp; !(firstUnignoredParent-&gt;renderer() &amp;&amp; !firstUnignoredParent-&gt;renderer()-&gt;isInline()))
211         firstUnignoredParent = firstUnignoredParent-&gt;parentObjectUnignored();
212     if (!firstUnignoredParent)
213         return nullptr;
214 
215     // The reference object must either coincide with the focused
216     // object being considered, or be a descendant of it.
217     if (referenceObject-&gt;isDescendantOfObject(firstUnignoredParent))
218         referenceObject = firstUnignoredParent;
219 
220     Node* startNode = nullptr;
221     if (firstUnignoredParent != referenceObject || firstUnignoredParent-&gt;isTextControl()) {
222         // We need to use the first child&#39;s node of the reference
223         // object as the start point to calculate the caret offset
224         // because we want it to be relative to the object of
225         // reference, not just to the focused object (which could have
226         // previous siblings which should be taken into account too).
<span class="line-modified">227         AXCoreObject* axFirstChild = referenceObject-&gt;firstChild();</span>
228         if (axFirstChild)
229             startNode = axFirstChild-&gt;node();
230     }
231     // Getting the Position of a PseudoElement now triggers an assertion.
232     // This can occur when clicking on empty space in a render block.
233     if (!startNode || startNode-&gt;isPseudoElement())
234         startNode = firstUnignoredParent-&gt;node();
235 
236     // Check if the node for the first parent object not ignoring
237     // accessibility is null again before using it. This might happen
238     // with certain kind of accessibility objects, such as the root
239     // one (the scroller containing the webArea object).
240     if (!startNode)
241         return nullptr;
242 
243     VisiblePosition startPosition = VisiblePosition(positionBeforeNode(startNode), DOWNSTREAM);
244     VisiblePosition endPosition = firstUnignoredParent-&gt;selection().visibleEnd();
245 
246     if (startPosition == endPosition)
247         offset = 0;
</pre>
</td>
</tr>
</table>
<center><a href="WebKitAccessibleInterfaceText.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebKitAccessibleUtil.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
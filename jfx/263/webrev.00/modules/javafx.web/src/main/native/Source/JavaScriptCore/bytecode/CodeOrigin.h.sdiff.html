<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CodeOrigin.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CodeOrigin.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ComplexGetStatus.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CodeOrigin.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2011-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 


 28 #include &lt;limits.h&gt;
 29 #include &lt;wtf/HashMap.h&gt;
 30 #include &lt;wtf/PrintStream.h&gt;
 31 #include &lt;wtf/StdLibExtras.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 
 34 namespace JSC {
 35 
 36 class CodeBlock;
 37 struct DumpContext;
 38 struct InlineCallFrame;
 39 
 40 class CodeOrigin {
 41 public:
 42     CodeOrigin()
 43 #if CPU(ADDRESS64)
<span class="line-modified"> 44         : m_compositeValue(buildCompositeValue(nullptr, s_invalidBytecodeIndex))</span>
 45 #else
<span class="line-modified"> 46         : m_bytecodeIndex(s_invalidBytecodeIndex)</span>
<span class="line-removed"> 47         , m_inlineCallFrame(nullptr)</span>
 48 #endif
 49     {
 50     }
 51 
 52     CodeOrigin(WTF::HashTableDeletedValueType)
 53 #if CPU(ADDRESS64)
<span class="line-modified"> 54         : m_compositeValue(buildCompositeValue(deletedMarker(), s_invalidBytecodeIndex))</span>
 55 #else
<span class="line-modified"> 56         : m_bytecodeIndex(s_invalidBytecodeIndex)</span>
 57         , m_inlineCallFrame(deletedMarker())
 58 #endif
 59     {
 60     }
 61 
<span class="line-modified"> 62     explicit CodeOrigin(unsigned bytecodeIndex, InlineCallFrame* inlineCallFrame = nullptr)</span>
 63 #if CPU(ADDRESS64)
 64         : m_compositeValue(buildCompositeValue(inlineCallFrame, bytecodeIndex))
 65 #else
 66         : m_bytecodeIndex(bytecodeIndex)
 67         , m_inlineCallFrame(inlineCallFrame)
 68 #endif
 69     {
<span class="line-modified"> 70         ASSERT(bytecodeIndex &lt; s_invalidBytecodeIndex);</span>
 71 #if CPU(ADDRESS64)
 72         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(inlineCallFrame) &amp; ~s_maskCompositeValueForPointer));
 73 #endif
 74     }
 75 
 76 #if CPU(ADDRESS64)
 77     CodeOrigin&amp; operator=(const CodeOrigin&amp; other)
 78     {
 79         if (this != &amp;other) {
 80             if (UNLIKELY(isOutOfLine()))
 81                 delete outOfLineCodeOrigin();
 82 
 83             if (UNLIKELY(other.isOutOfLine()))
 84                 m_compositeValue = buildCompositeValue(other.inlineCallFrame(), other.bytecodeIndex());
 85             else
 86                 m_compositeValue = other.m_compositeValue;
 87         }
 88         return *this;
 89     }
 90     CodeOrigin&amp; operator=(CodeOrigin&amp;&amp; other)
</pre>
<hr />
<pre>
107         else
108             m_compositeValue = other.m_compositeValue;
109     }
110     CodeOrigin(CodeOrigin&amp;&amp; other)
111         : m_compositeValue(std::exchange(other.m_compositeValue, 0))
112     {
113     }
114 
115     ~CodeOrigin()
116     {
117         if (UNLIKELY(isOutOfLine()))
118             delete outOfLineCodeOrigin();
119     }
120 #endif
121 
122     bool isSet() const
123     {
124 #if CPU(ADDRESS64)
125         return !(m_compositeValue &amp; s_maskIsBytecodeIndexInvalid);
126 #else
<span class="line-modified">127         return m_bytecodeIndex != s_invalidBytecodeIndex;</span>
128 #endif
129     }
130     explicit operator bool() const { return isSet(); }
131 
132     bool isHashTableDeletedValue() const
133     {
134 #if CPU(ADDRESS64)
135         return !isSet() &amp;&amp; (m_compositeValue &amp; s_maskCompositeValueForPointer);
136 #else
<span class="line-modified">137         return m_bytecodeIndex == s_invalidBytecodeIndex &amp;&amp; !!m_inlineCallFrame;</span>
138 #endif
139     }
140 
141     // The inline depth is the depth of the inline stack, so 1 = not inlined,
142     // 2 = inlined one deep, etc.
143     unsigned inlineDepth() const;
144 
145     // If the code origin corresponds to inlined code, gives you the heap object that
146     // would have owned the code if it had not been inlined. Otherwise returns 0.
147     CodeBlock* codeOriginOwner() const;
148 
149     int stackOffset() const;
150 
151     unsigned hash() const;
152     bool operator==(const CodeOrigin&amp; other) const;
153     bool operator!=(const CodeOrigin&amp; other) const { return !(*this == other); }
154 
155     // This checks if the two code origins correspond to the same stack trace snippets,
156     // but ignore whether the InlineCallFrame&#39;s are identical.
157     bool isApproximatelyEqualTo(const CodeOrigin&amp; other, InlineCallFrame* terminal = nullptr) const;
158 
159     unsigned approximateHash(InlineCallFrame* terminal = nullptr) const;
160 
161     template &lt;typename Function&gt;
<span class="line-modified">162     void walkUpInlineStack(const Function&amp;);</span>


163 
164     // Get the inline stack. This is slow, and is intended for debugging only.
165     Vector&lt;CodeOrigin&gt; inlineStack() const;
166 
167     JS_EXPORT_PRIVATE void dump(PrintStream&amp;) const;
168     void dumpInContext(PrintStream&amp;, DumpContext*) const;
169 
<span class="line-modified">170     unsigned bytecodeIndex() const</span>
171     {
172 #if CPU(ADDRESS64)
173         if (!isSet())
<span class="line-modified">174             return s_invalidBytecodeIndex;</span>
175         if (UNLIKELY(isOutOfLine()))
176             return outOfLineCodeOrigin()-&gt;bytecodeIndex;
<span class="line-modified">177         return m_compositeValue &gt;&gt; (64 - s_freeBitsAtTop);</span>
178 #else
179         return m_bytecodeIndex;
180 #endif
181     }
182 
183     InlineCallFrame* inlineCallFrame() const
184     {
185 #if CPU(ADDRESS64)
186         if (UNLIKELY(isOutOfLine()))
187             return outOfLineCodeOrigin()-&gt;inlineCallFrame;
188         return bitwise_cast&lt;InlineCallFrame*&gt;(m_compositeValue &amp; s_maskCompositeValueForPointer);
189 #else
190         return m_inlineCallFrame;
191 #endif
192     }
193 
194 private:
<span class="line-removed">195     static constexpr unsigned s_invalidBytecodeIndex = UINT_MAX;</span>
<span class="line-removed">196 </span>
197 #if CPU(ADDRESS64)
198     static constexpr uintptr_t s_maskIsOutOfLine = 1;
199     static constexpr uintptr_t s_maskIsBytecodeIndexInvalid = 2;
200 
201     struct OutOfLineCodeOrigin {
202         WTF_MAKE_FAST_ALLOCATED;
203     public:
204         InlineCallFrame* inlineCallFrame;
<span class="line-modified">205         unsigned bytecodeIndex;</span>
206 
<span class="line-modified">207         OutOfLineCodeOrigin(InlineCallFrame* inlineCallFrame, unsigned bytecodeIndex)</span>
208             : inlineCallFrame(inlineCallFrame)
209             , bytecodeIndex(bytecodeIndex)
210         {
211         }
212     };
213 
214     bool isOutOfLine() const
215     {
216         return m_compositeValue &amp; s_maskIsOutOfLine;
217     }
218     OutOfLineCodeOrigin* outOfLineCodeOrigin() const
219     {
220         ASSERT(isOutOfLine());
221         return bitwise_cast&lt;OutOfLineCodeOrigin*&gt;(m_compositeValue &amp; s_maskCompositeValueForPointer);
222     }
223 #endif
224 
225     static InlineCallFrame* deletedMarker()
226     {
227         auto value = static_cast&lt;uintptr_t&gt;(1 &lt;&lt; 3);
228 #if CPU(ADDRESS64)
229         ASSERT(value &amp; s_maskCompositeValueForPointer);
230         ASSERT(!(value &amp; ~s_maskCompositeValueForPointer));
231 #endif
232         return bitwise_cast&lt;InlineCallFrame*&gt;(value);
233     }
234 
235 #if CPU(ADDRESS64)
<span class="line-modified">236     static constexpr unsigned s_freeBitsAtTop = 64 - WTF_CPU_EFFECTIVE_ADDRESS_WIDTH;</span>
<span class="line-modified">237     static constexpr uintptr_t s_maskCompositeValueForPointer = ((1ULL &lt;&lt; WTF_CPU_EFFECTIVE_ADDRESS_WIDTH) - 1) &amp; ~(8ULL - 1);</span>
<span class="line-modified">238     static uintptr_t buildCompositeValue(InlineCallFrame* inlineCallFrame, unsigned bytecodeIndex)</span>
239     {
<span class="line-modified">240         if (bytecodeIndex == s_invalidBytecodeIndex)</span>
241             return bitwise_cast&lt;uintptr_t&gt;(inlineCallFrame) | s_maskIsBytecodeIndexInvalid;
242 
<span class="line-modified">243         if (UNLIKELY(bytecodeIndex &gt;= 1 &lt;&lt; s_freeBitsAtTop)) {</span>
244             auto* outOfLine = new OutOfLineCodeOrigin(inlineCallFrame, bytecodeIndex);
245             return bitwise_cast&lt;uintptr_t&gt;(outOfLine) | s_maskIsOutOfLine;
246         }
247 
<span class="line-modified">248         uintptr_t encodedBytecodeIndex = static_cast&lt;uintptr_t&gt;(bytecodeIndex) &lt;&lt; (64 - s_freeBitsAtTop);</span>
249         ASSERT(!(encodedBytecodeIndex &amp; bitwise_cast&lt;uintptr_t&gt;(inlineCallFrame)));
250         return encodedBytecodeIndex | bitwise_cast&lt;uintptr_t&gt;(inlineCallFrame);
251     }
252 
253     // The bottom bit indicates whether to look at an out-of-line implementation (because of a bytecode index which is too big for us to store).
254     // The next bit indicates whether this is an invalid bytecode (which depending on the InlineCallFrame* can either indicate an unset CodeOrigin,
255     // or a deletion marker for a hash table).
256     // The next bit is free
257     // The next 64-s_freeBitsAtTop-3 are the InlineCallFrame* or the OutOfLineCodeOrigin*
258     // Finally the last s_freeBitsAtTop are the bytecodeIndex if it is inline
259     uintptr_t m_compositeValue;
260 #else
<span class="line-modified">261     unsigned m_bytecodeIndex;</span>
262     InlineCallFrame* m_inlineCallFrame;
263 #endif
264 };
265 
266 inline unsigned CodeOrigin::hash() const
267 {
<span class="line-modified">268     return WTF::IntHash&lt;unsigned&gt;::hash(bytecodeIndex()) +</span>
269         WTF::PtrHash&lt;InlineCallFrame*&gt;::hash(inlineCallFrame());
270 }
271 
272 inline bool CodeOrigin::operator==(const CodeOrigin&amp; other) const
273 {
274 #if CPU(ADDRESS64)
275     if (m_compositeValue == other.m_compositeValue)
276         return true;
277 #endif
278     return bytecodeIndex() == other.bytecodeIndex()
279         &amp;&amp; inlineCallFrame() == other.inlineCallFrame();
280 }
281 
282 struct CodeOriginHash {
283     static unsigned hash(const CodeOrigin&amp; key) { return key.hash(); }
284     static bool equal(const CodeOrigin&amp; a, const CodeOrigin&amp; b) { return a == b; }
<span class="line-modified">285     static const bool safeToCompareToEmptyOrDeleted = true;</span>
286 };
287 
288 struct CodeOriginApproximateHash {
289     static unsigned hash(const CodeOrigin&amp; key) { return key.approximateHash(); }
290     static bool equal(const CodeOrigin&amp; a, const CodeOrigin&amp; b) { return a.isApproximatelyEqualTo(b); }
<span class="line-modified">291     static const bool safeToCompareToEmptyOrDeleted = true;</span>
292 };
293 
294 } // namespace JSC
295 
296 namespace WTF {
297 
298 template&lt;typename T&gt; struct DefaultHash;
299 template&lt;&gt; struct DefaultHash&lt;JSC::CodeOrigin&gt; {
300     typedef JSC::CodeOriginHash Hash;
301 };
302 
303 template&lt;typename T&gt; struct HashTraits;
304 template&lt;&gt; struct HashTraits&lt;JSC::CodeOrigin&gt; : SimpleClassHashTraits&lt;JSC::CodeOrigin&gt; {
<span class="line-modified">305     static const bool emptyValueIsZero = false;</span>
306 };
307 
308 } // namespace WTF
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
<span class="line-added"> 28 #include &quot;BytecodeIndex.h&quot;</span>
<span class="line-added"> 29 </span>
 30 #include &lt;limits.h&gt;
 31 #include &lt;wtf/HashMap.h&gt;
 32 #include &lt;wtf/PrintStream.h&gt;
 33 #include &lt;wtf/StdLibExtras.h&gt;
 34 #include &lt;wtf/Vector.h&gt;
 35 
 36 namespace JSC {
 37 
 38 class CodeBlock;
 39 struct DumpContext;
 40 struct InlineCallFrame;
 41 
 42 class CodeOrigin {
 43 public:
 44     CodeOrigin()
 45 #if CPU(ADDRESS64)
<span class="line-modified"> 46         : m_compositeValue(buildCompositeValue(nullptr, BytecodeIndex()))</span>
 47 #else
<span class="line-modified"> 48         : m_inlineCallFrame(nullptr)</span>

 49 #endif
 50     {
 51     }
 52 
 53     CodeOrigin(WTF::HashTableDeletedValueType)
 54 #if CPU(ADDRESS64)
<span class="line-modified"> 55         : m_compositeValue(buildCompositeValue(deletedMarker(), BytecodeIndex()))</span>
 56 #else
<span class="line-modified"> 57         : m_bytecodeIndex(WTF::HashTableDeletedValue)</span>
 58         , m_inlineCallFrame(deletedMarker())
 59 #endif
 60     {
 61     }
 62 
<span class="line-modified"> 63     explicit CodeOrigin(BytecodeIndex bytecodeIndex, InlineCallFrame* inlineCallFrame = nullptr)</span>
 64 #if CPU(ADDRESS64)
 65         : m_compositeValue(buildCompositeValue(inlineCallFrame, bytecodeIndex))
 66 #else
 67         : m_bytecodeIndex(bytecodeIndex)
 68         , m_inlineCallFrame(inlineCallFrame)
 69 #endif
 70     {
<span class="line-modified"> 71         ASSERT(!!bytecodeIndex);</span>
 72 #if CPU(ADDRESS64)
 73         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(inlineCallFrame) &amp; ~s_maskCompositeValueForPointer));
 74 #endif
 75     }
 76 
 77 #if CPU(ADDRESS64)
 78     CodeOrigin&amp; operator=(const CodeOrigin&amp; other)
 79     {
 80         if (this != &amp;other) {
 81             if (UNLIKELY(isOutOfLine()))
 82                 delete outOfLineCodeOrigin();
 83 
 84             if (UNLIKELY(other.isOutOfLine()))
 85                 m_compositeValue = buildCompositeValue(other.inlineCallFrame(), other.bytecodeIndex());
 86             else
 87                 m_compositeValue = other.m_compositeValue;
 88         }
 89         return *this;
 90     }
 91     CodeOrigin&amp; operator=(CodeOrigin&amp;&amp; other)
</pre>
<hr />
<pre>
108         else
109             m_compositeValue = other.m_compositeValue;
110     }
111     CodeOrigin(CodeOrigin&amp;&amp; other)
112         : m_compositeValue(std::exchange(other.m_compositeValue, 0))
113     {
114     }
115 
116     ~CodeOrigin()
117     {
118         if (UNLIKELY(isOutOfLine()))
119             delete outOfLineCodeOrigin();
120     }
121 #endif
122 
123     bool isSet() const
124     {
125 #if CPU(ADDRESS64)
126         return !(m_compositeValue &amp; s_maskIsBytecodeIndexInvalid);
127 #else
<span class="line-modified">128         return !!m_bytecodeIndex;</span>
129 #endif
130     }
131     explicit operator bool() const { return isSet(); }
132 
133     bool isHashTableDeletedValue() const
134     {
135 #if CPU(ADDRESS64)
136         return !isSet() &amp;&amp; (m_compositeValue &amp; s_maskCompositeValueForPointer);
137 #else
<span class="line-modified">138         return m_bytecodeIndex.isHashTableDeletedValue() &amp;&amp; !!m_inlineCallFrame;</span>
139 #endif
140     }
141 
142     // The inline depth is the depth of the inline stack, so 1 = not inlined,
143     // 2 = inlined one deep, etc.
144     unsigned inlineDepth() const;
145 
146     // If the code origin corresponds to inlined code, gives you the heap object that
147     // would have owned the code if it had not been inlined. Otherwise returns 0.
148     CodeBlock* codeOriginOwner() const;
149 
150     int stackOffset() const;
151 
152     unsigned hash() const;
153     bool operator==(const CodeOrigin&amp; other) const;
154     bool operator!=(const CodeOrigin&amp; other) const { return !(*this == other); }
155 
156     // This checks if the two code origins correspond to the same stack trace snippets,
157     // but ignore whether the InlineCallFrame&#39;s are identical.
158     bool isApproximatelyEqualTo(const CodeOrigin&amp; other, InlineCallFrame* terminal = nullptr) const;
159 
160     unsigned approximateHash(InlineCallFrame* terminal = nullptr) const;
161 
162     template &lt;typename Function&gt;
<span class="line-modified">163     void walkUpInlineStack(const Function&amp;) const;</span>
<span class="line-added">164 </span>
<span class="line-added">165     inline bool inlineStackContainsActiveCheckpoint() const;</span>
166 
167     // Get the inline stack. This is slow, and is intended for debugging only.
168     Vector&lt;CodeOrigin&gt; inlineStack() const;
169 
170     JS_EXPORT_PRIVATE void dump(PrintStream&amp;) const;
171     void dumpInContext(PrintStream&amp;, DumpContext*) const;
172 
<span class="line-modified">173     BytecodeIndex bytecodeIndex() const</span>
174     {
175 #if CPU(ADDRESS64)
176         if (!isSet())
<span class="line-modified">177             return BytecodeIndex();</span>
178         if (UNLIKELY(isOutOfLine()))
179             return outOfLineCodeOrigin()-&gt;bytecodeIndex;
<span class="line-modified">180         return BytecodeIndex::fromBits(m_compositeValue &gt;&gt; (64 - s_freeBitsAtTop));</span>
181 #else
182         return m_bytecodeIndex;
183 #endif
184     }
185 
186     InlineCallFrame* inlineCallFrame() const
187     {
188 #if CPU(ADDRESS64)
189         if (UNLIKELY(isOutOfLine()))
190             return outOfLineCodeOrigin()-&gt;inlineCallFrame;
191         return bitwise_cast&lt;InlineCallFrame*&gt;(m_compositeValue &amp; s_maskCompositeValueForPointer);
192 #else
193         return m_inlineCallFrame;
194 #endif
195     }
196 
197 private:


198 #if CPU(ADDRESS64)
199     static constexpr uintptr_t s_maskIsOutOfLine = 1;
200     static constexpr uintptr_t s_maskIsBytecodeIndexInvalid = 2;
201 
202     struct OutOfLineCodeOrigin {
203         WTF_MAKE_FAST_ALLOCATED;
204     public:
205         InlineCallFrame* inlineCallFrame;
<span class="line-modified">206         BytecodeIndex bytecodeIndex;</span>
207 
<span class="line-modified">208         OutOfLineCodeOrigin(InlineCallFrame* inlineCallFrame, BytecodeIndex bytecodeIndex)</span>
209             : inlineCallFrame(inlineCallFrame)
210             , bytecodeIndex(bytecodeIndex)
211         {
212         }
213     };
214 
215     bool isOutOfLine() const
216     {
217         return m_compositeValue &amp; s_maskIsOutOfLine;
218     }
219     OutOfLineCodeOrigin* outOfLineCodeOrigin() const
220     {
221         ASSERT(isOutOfLine());
222         return bitwise_cast&lt;OutOfLineCodeOrigin*&gt;(m_compositeValue &amp; s_maskCompositeValueForPointer);
223     }
224 #endif
225 
226     static InlineCallFrame* deletedMarker()
227     {
228         auto value = static_cast&lt;uintptr_t&gt;(1 &lt;&lt; 3);
229 #if CPU(ADDRESS64)
230         ASSERT(value &amp; s_maskCompositeValueForPointer);
231         ASSERT(!(value &amp; ~s_maskCompositeValueForPointer));
232 #endif
233         return bitwise_cast&lt;InlineCallFrame*&gt;(value);
234     }
235 
236 #if CPU(ADDRESS64)
<span class="line-modified">237     static constexpr unsigned s_freeBitsAtTop = 64 - OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH);</span>
<span class="line-modified">238     static constexpr uintptr_t s_maskCompositeValueForPointer = ((1ULL &lt;&lt; OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH)) - 1) &amp; ~(8ULL - 1);</span>
<span class="line-modified">239     static uintptr_t buildCompositeValue(InlineCallFrame* inlineCallFrame, BytecodeIndex bytecodeIndex)</span>
240     {
<span class="line-modified">241         if (!bytecodeIndex)</span>
242             return bitwise_cast&lt;uintptr_t&gt;(inlineCallFrame) | s_maskIsBytecodeIndexInvalid;
243 
<span class="line-modified">244         if (UNLIKELY(bytecodeIndex.asBits() &gt;= 1 &lt;&lt; s_freeBitsAtTop)) {</span>
245             auto* outOfLine = new OutOfLineCodeOrigin(inlineCallFrame, bytecodeIndex);
246             return bitwise_cast&lt;uintptr_t&gt;(outOfLine) | s_maskIsOutOfLine;
247         }
248 
<span class="line-modified">249         uintptr_t encodedBytecodeIndex = static_cast&lt;uintptr_t&gt;(bytecodeIndex.asBits()) &lt;&lt; (64 - s_freeBitsAtTop);</span>
250         ASSERT(!(encodedBytecodeIndex &amp; bitwise_cast&lt;uintptr_t&gt;(inlineCallFrame)));
251         return encodedBytecodeIndex | bitwise_cast&lt;uintptr_t&gt;(inlineCallFrame);
252     }
253 
254     // The bottom bit indicates whether to look at an out-of-line implementation (because of a bytecode index which is too big for us to store).
255     // The next bit indicates whether this is an invalid bytecode (which depending on the InlineCallFrame* can either indicate an unset CodeOrigin,
256     // or a deletion marker for a hash table).
257     // The next bit is free
258     // The next 64-s_freeBitsAtTop-3 are the InlineCallFrame* or the OutOfLineCodeOrigin*
259     // Finally the last s_freeBitsAtTop are the bytecodeIndex if it is inline
260     uintptr_t m_compositeValue;
261 #else
<span class="line-modified">262     BytecodeIndex m_bytecodeIndex;</span>
263     InlineCallFrame* m_inlineCallFrame;
264 #endif
265 };
266 
267 inline unsigned CodeOrigin::hash() const
268 {
<span class="line-modified">269     return WTF::IntHash&lt;unsigned&gt;::hash(bytecodeIndex().asBits()) +</span>
270         WTF::PtrHash&lt;InlineCallFrame*&gt;::hash(inlineCallFrame());
271 }
272 
273 inline bool CodeOrigin::operator==(const CodeOrigin&amp; other) const
274 {
275 #if CPU(ADDRESS64)
276     if (m_compositeValue == other.m_compositeValue)
277         return true;
278 #endif
279     return bytecodeIndex() == other.bytecodeIndex()
280         &amp;&amp; inlineCallFrame() == other.inlineCallFrame();
281 }
282 
283 struct CodeOriginHash {
284     static unsigned hash(const CodeOrigin&amp; key) { return key.hash(); }
285     static bool equal(const CodeOrigin&amp; a, const CodeOrigin&amp; b) { return a == b; }
<span class="line-modified">286     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
287 };
288 
289 struct CodeOriginApproximateHash {
290     static unsigned hash(const CodeOrigin&amp; key) { return key.approximateHash(); }
291     static bool equal(const CodeOrigin&amp; a, const CodeOrigin&amp; b) { return a.isApproximatelyEqualTo(b); }
<span class="line-modified">292     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
293 };
294 
295 } // namespace JSC
296 
297 namespace WTF {
298 
299 template&lt;typename T&gt; struct DefaultHash;
300 template&lt;&gt; struct DefaultHash&lt;JSC::CodeOrigin&gt; {
301     typedef JSC::CodeOriginHash Hash;
302 };
303 
304 template&lt;typename T&gt; struct HashTraits;
305 template&lt;&gt; struct HashTraits&lt;JSC::CodeOrigin&gt; : SimpleClassHashTraits&lt;JSC::CodeOrigin&gt; {
<span class="line-modified">306     static constexpr bool emptyValueIsZero = false;</span>
307 };
308 
309 } // namespace WTF
</pre>
</td>
</tr>
</table>
<center><a href="CodeOrigin.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ComplexGetStatus.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
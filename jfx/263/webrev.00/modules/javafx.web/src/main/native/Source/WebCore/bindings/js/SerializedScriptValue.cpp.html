<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/js/SerializedScriptValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  *
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;SerializedScriptValue.h&quot;
  29 
  30 #include &quot;BlobRegistry.h&quot;
  31 #include &quot;CryptoKeyAES.h&quot;
  32 #include &quot;CryptoKeyEC.h&quot;
  33 #include &quot;CryptoKeyHMAC.h&quot;
  34 #include &quot;CryptoKeyRSA.h&quot;
  35 #include &quot;CryptoKeyRSAComponents.h&quot;
  36 #include &quot;CryptoKeyRaw.h&quot;
  37 #include &quot;IDBValue.h&quot;
  38 #include &quot;JSBlob.h&quot;
  39 #if PLATFORM(JAVA) &amp;&amp; ENABLE(SUBTLE_CRYPTO) // todo tav
  40 #include &quot;JSCryptoKey.h&quot;
  41 #endif
  42 #include &quot;JSDOMBinding.h&quot;
  43 #include &quot;JSDOMConvertBufferSource.h&quot;
  44 #include &quot;JSDOMGlobalObject.h&quot;
  45 #include &quot;JSDOMMatrix.h&quot;
  46 #include &quot;JSDOMPoint.h&quot;
  47 #include &quot;JSDOMQuad.h&quot;
  48 #include &quot;JSDOMRect.h&quot;
  49 #include &quot;JSFile.h&quot;
  50 #include &quot;JSFileList.h&quot;
  51 #include &quot;JSImageBitmap.h&quot;
  52 #include &quot;JSImageData.h&quot;
  53 #include &quot;JSMessagePort.h&quot;
  54 #include &quot;JSNavigator.h&quot;
  55 #include &quot;JSRTCCertificate.h&quot;
  56 #include &quot;ScriptExecutionContext.h&quot;
  57 #include &quot;ScriptState.h&quot;
  58 #include &quot;SharedBuffer.h&quot;
  59 #include &quot;WebCoreJSClientData.h&quot;
  60 #include &lt;JavaScriptCore/APICast.h&gt;
  61 #include &lt;JavaScriptCore/BooleanObject.h&gt;
  62 #include &lt;JavaScriptCore/CatchScope.h&gt;
  63 #include &lt;JavaScriptCore/DateInstance.h&gt;
  64 #include &lt;JavaScriptCore/Error.h&gt;
  65 #include &lt;JavaScriptCore/Exception.h&gt;
  66 #include &lt;JavaScriptCore/ExceptionHelpers.h&gt;
  67 #include &lt;JavaScriptCore/IterationKind.h&gt;
  68 #include &lt;JavaScriptCore/JSArrayBuffer.h&gt;
  69 #include &lt;JavaScriptCore/JSArrayBufferView.h&gt;
  70 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  71 #include &lt;JavaScriptCore/JSDataView.h&gt;
  72 #include &lt;JavaScriptCore/JSMap.h&gt;
  73 #include &lt;JavaScriptCore/JSMapIterator.h&gt;
  74 #include &lt;JavaScriptCore/JSSet.h&gt;
  75 #include &lt;JavaScriptCore/JSSetIterator.h&gt;
  76 #include &lt;JavaScriptCore/JSTypedArrays.h&gt;
  77 #include &lt;JavaScriptCore/JSWebAssemblyModule.h&gt;
  78 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
  79 #include &lt;JavaScriptCore/PropertyNameArray.h&gt;
  80 #include &lt;JavaScriptCore/RegExp.h&gt;
  81 #include &lt;JavaScriptCore/RegExpObject.h&gt;
  82 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  83 #include &lt;JavaScriptCore/TypedArrays.h&gt;
  84 #include &lt;JavaScriptCore/WasmModule.h&gt;
  85 #include &lt;JavaScriptCore/YarrFlags.h&gt;
  86 #include &lt;limits&gt;
  87 #include &lt;wtf/CompletionHandler.h&gt;
  88 #include &lt;wtf/MainThread.h&gt;
  89 #include &lt;wtf/RunLoop.h&gt;
  90 #include &lt;wtf/Vector.h&gt;
  91 
  92 #if ENABLE(OFFSCREEN_CANVAS)
  93 #include &quot;JSOffscreenCanvas.h&quot;
  94 #include &quot;OffscreenCanvas.h&quot;
  95 #endif
  96 
  97 #if CPU(BIG_ENDIAN) || CPU(MIDDLE_ENDIAN) || CPU(NEEDS_ALIGNED_ACCESS)
  98 #define ASSUME_LITTLE_ENDIAN 0
  99 #else
 100 #define ASSUME_LITTLE_ENDIAN 1
 101 #endif
 102 
 103 namespace WebCore {
 104 using namespace JSC;
 105 
 106 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SerializedScriptValue);
 107 
 108 static const unsigned maximumFilterRecursion = 40000;
 109 
 110 enum class SerializationReturnCode {
 111     SuccessfullyCompleted,
 112     StackOverflowError,
 113     InterruptedExecutionError,
 114     ValidationError,
 115     ExistingExceptionError,
 116     DataCloneError,
 117     UnspecifiedError
 118 };
 119 
 120 enum WalkerState { StateUnknown, ArrayStartState, ArrayStartVisitMember, ArrayEndVisitMember,
 121     ObjectStartState, ObjectStartVisitMember, ObjectEndVisitMember,
 122     MapDataStartVisitEntry, MapDataEndVisitKey, MapDataEndVisitValue,
 123     SetDataStartVisitEntry, SetDataEndVisitKey };
 124 
 125 // These can&#39;t be reordered, and any new types must be added to the end of the list
 126 // When making changes to these lists please cover your new type(s) in the API test &quot;IndexedDB.StructuredCloneBackwardCompatibility&quot;
 127 enum SerializationTag {
 128     ArrayTag = 1,
 129     ObjectTag = 2,
 130     UndefinedTag = 3,
 131     NullTag = 4,
 132     IntTag = 5,
 133     ZeroTag = 6,
 134     OneTag = 7,
 135     FalseTag = 8,
 136     TrueTag = 9,
 137     DoubleTag = 10,
 138     DateTag = 11,
 139     FileTag = 12,
 140     FileListTag = 13,
 141     ImageDataTag = 14,
 142     BlobTag = 15,
 143     StringTag = 16,
 144     EmptyStringTag = 17,
 145     RegExpTag = 18,
 146     ObjectReferenceTag = 19,
 147     MessagePortReferenceTag = 20,
 148     ArrayBufferTag = 21,
 149     ArrayBufferViewTag = 22,
 150     ArrayBufferTransferTag = 23,
 151     TrueObjectTag = 24,
 152     FalseObjectTag = 25,
 153     StringObjectTag = 26,
 154     EmptyStringObjectTag = 27,
 155     NumberObjectTag = 28,
 156     SetObjectTag = 29,
 157     MapObjectTag = 30,
 158     NonMapPropertiesTag = 31,
 159     NonSetPropertiesTag = 32,
 160 #if ENABLE(WEB_CRYPTO)
 161     CryptoKeyTag = 33,
 162 #endif
 163     SharedArrayBufferTag = 34,
 164 #if ENABLE(WEBASSEMBLY)
 165     WasmModuleTag = 35,
 166 #endif
 167     DOMPointReadOnlyTag = 36,
 168     DOMPointTag = 37,
 169     DOMRectReadOnlyTag = 38,
 170     DOMRectTag = 39,
 171     DOMMatrixReadOnlyTag = 40,
 172     DOMMatrixTag = 41,
 173     DOMQuadTag = 42,
 174     ImageBitmapTransferTag = 43,
 175 #if ENABLE(WEB_RTC)
 176     RTCCertificateTag = 44,
 177 #endif
 178     ImageBitmapTag = 45,
 179 #if ENABLE(OFFSCREEN_CANVAS)
 180     OffscreenCanvasTransferTag = 46,
 181 #endif
 182     ErrorTag = 255
 183 };
 184 
 185 enum ArrayBufferViewSubtag {
 186     DataViewTag = 0,
 187     Int8ArrayTag = 1,
 188     Uint8ArrayTag = 2,
 189     Uint8ClampedArrayTag = 3,
 190     Int16ArrayTag = 4,
 191     Uint16ArrayTag = 5,
 192     Int32ArrayTag = 6,
 193     Uint32ArrayTag = 7,
 194     Float32ArrayTag = 8,
 195     Float64ArrayTag = 9
 196 };
 197 
 198 static unsigned typedArrayElementSize(ArrayBufferViewSubtag tag)
 199 {
 200     switch (tag) {
 201     case DataViewTag:
 202     case Int8ArrayTag:
 203     case Uint8ArrayTag:
 204     case Uint8ClampedArrayTag:
 205         return 1;
 206     case Int16ArrayTag:
 207     case Uint16ArrayTag:
 208         return 2;
 209     case Int32ArrayTag:
 210     case Uint32ArrayTag:
 211     case Float32ArrayTag:
 212         return 4;
 213     case Float64ArrayTag:
 214         return 8;
 215     default:
 216         return 0;
 217     }
 218 
 219 }
 220 
 221 #if ENABLE(WEB_CRYPTO)
 222 
 223 const uint32_t currentKeyFormatVersion = 1;
 224 
 225 enum class CryptoKeyClassSubtag {
 226     HMAC = 0,
 227     AES = 1,
 228     RSA = 2,
 229     EC = 3,
 230     Raw = 4,
 231 };
 232 const uint8_t cryptoKeyClassSubtagMaximumValue = 4;
 233 
 234 enum class CryptoKeyAsymmetricTypeSubtag {
 235     Public = 0,
 236     Private = 1
 237 };
 238 const uint8_t cryptoKeyAsymmetricTypeSubtagMaximumValue = 1;
 239 
 240 enum class CryptoKeyUsageTag {
 241     Encrypt = 0,
 242     Decrypt = 1,
 243     Sign = 2,
 244     Verify = 3,
 245     DeriveKey = 4,
 246     DeriveBits = 5,
 247     WrapKey = 6,
 248     UnwrapKey = 7
 249 };
 250 const uint8_t cryptoKeyUsageTagMaximumValue = 7;
 251 
 252 enum class CryptoAlgorithmIdentifierTag {
 253     RSAES_PKCS1_v1_5 = 0,
 254     RSASSA_PKCS1_v1_5 = 1,
 255     RSA_PSS = 2,
 256     RSA_OAEP = 3,
 257     ECDSA = 4,
 258     ECDH = 5,
 259     AES_CTR = 6,
 260     AES_CBC = 7,
 261     AES_GCM = 9,
 262     AES_CFB = 10,
 263     AES_KW = 11,
 264     HMAC = 12,
 265     SHA_1 = 14,
 266     SHA_224 = 15,
 267     SHA_256 = 16,
 268     SHA_384 = 17,
 269     SHA_512 = 18,
 270     HKDF = 20,
 271     PBKDF2 = 21,
 272 };
 273 const uint8_t cryptoAlgorithmIdentifierTagMaximumValue = 21;
 274 
 275 static unsigned countUsages(CryptoKeyUsageBitmap usages)
 276 {
 277     // Fast bit count algorithm for sparse bit maps.
 278     unsigned count = 0;
 279     while (usages) {
 280         usages = usages &amp; (usages - 1);
 281         ++count;
 282     }
 283     return count;
 284 }
 285 
 286 #endif
 287 
 288 /* CurrentVersion tracks the serialization version so that persistent stores
 289  * are able to correctly bail out in the case of encountering newer formats.
 290  *
 291  * Initial version was 1.
 292  * Version 2. added the ObjectReferenceTag and support for serialization of cyclic graphs.
 293  * Version 3. added the FalseObjectTag, TrueObjectTag, NumberObjectTag, StringObjectTag
 294  * and EmptyStringObjectTag for serialization of Boolean, Number and String objects.
 295  * Version 4. added support for serializing non-index properties of arrays.
 296  * Version 5. added support for Map and Set types.
 297  * Version 6. added support for 8-bit strings.
 298  * Version 7. added support for File&#39;s lastModified attribute.
 299  */
 300 static const unsigned CurrentVersion = 7;
 301 static const unsigned TerminatorTag = 0xFFFFFFFF;
 302 static const unsigned StringPoolTag = 0xFFFFFFFE;
 303 static const unsigned NonIndexPropertiesTag = 0xFFFFFFFD;
 304 
 305 // The high bit of a StringData&#39;s length determines the character size.
 306 static const unsigned StringDataIs8BitFlag = 0x80000000;
 307 
 308 /*
 309  * Object serialization is performed according to the following grammar, all tags
 310  * are recorded as a single uint8_t.
 311  *
 312  * IndexType (used for the object pool and StringData&#39;s constant pool) is the
 313  * minimum sized unsigned integer type required to represent the maximum index
 314  * in the constant pool.
 315  *
 316  * SerializedValue :- &lt;CurrentVersion:uint32_t&gt; Value
 317  * Value :- Array | Object | Map | Set | Terminal
 318  *
 319  * Array :-
 320  *     ArrayTag &lt;length:uint32_t&gt;(&lt;index:uint32_t&gt;&lt;value:Value&gt;)* TerminatorTag
 321  *
 322  * Object :-
 323  *     ObjectTag (&lt;name:StringData&gt;&lt;value:Value&gt;)* TerminatorTag
 324  *
 325  * Map :- MapObjectTag MapData
 326  *
 327  * Set :- SetObjectTag SetData
 328  *
 329  * MapData :- (&lt;key:Value&gt;&lt;value:Value&gt;)* NonMapPropertiesTag (&lt;name:StringData&gt;&lt;value:Value&gt;)* TerminatorTag
 330  * SetData :- (&lt;key:Value&gt;)* NonSetPropertiesTag (&lt;name:StringData&gt;&lt;value:Value&gt;)* TerminatorTag
 331  *
 332  * Terminal :-
 333  *      UndefinedTag
 334  *    | NullTag
 335  *    | IntTag &lt;value:int32_t&gt;
 336  *    | ZeroTag
 337  *    | OneTag
 338  *    | FalseTag
 339  *    | TrueTag
 340  *    | FalseObjectTag
 341  *    | TrueObjectTag
 342  *    | DoubleTag &lt;value:double&gt;
 343  *    | NumberObjectTag &lt;value:double&gt;
 344  *    | DateTag &lt;value:double&gt;
 345  *    | String
 346  *    | EmptyStringTag
 347  *    | EmptyStringObjectTag
 348  *    | File
 349  *    | FileList
 350  *    | ImageData
 351  *    | Blob
 352  *    | ObjectReference
 353  *    | MessagePortReferenceTag &lt;value:uint32_t&gt;
 354  *    | ArrayBuffer
 355  *    | ArrayBufferViewTag ArrayBufferViewSubtag &lt;byteOffset:uint32_t&gt; &lt;byteLength:uint32_t&gt; (ArrayBuffer | ObjectReference)
 356  *    | ArrayBufferTransferTag &lt;value:uint32_t&gt;
 357  *    | CryptoKeyTag &lt;wrappedKeyLength:uint32_t&gt; &lt;factor:byte{wrappedKeyLength}&gt;
 358  *    | DOMPoint
 359  *    | DOMRect
 360  *    | DOMMatrix
 361  *    | DOMQuad
 362  *    | ImageBitmapTransferTag &lt;value:uint32_t&gt;
 363  *    | RTCCertificateTag
 364  *    | ImageBitmapTag &lt;originClean:uint8_t&gt; &lt;logicalWidth:int32_t&gt; &lt;logicalHeight:int32_t&gt; &lt;resolutionScale:double&gt; &lt;byteLength:uint32_t&gt;(&lt;imageByteData:uint8_t&gt;)
 365  *    | OffscreenCanvasTransferTag &lt;value:uint32_t&gt;
 366  *
 367  * Inside certificate, data is serialized in this format as per spec:
 368  *
 369  * &lt;expires:double&gt; &lt;certificate:StringData&gt; &lt;origin:StringData&gt; &lt;keyingMaterial:StringData&gt;
 370  * We also add fingerprints to make sure we expose to JavaScript the same information.
 371  *
 372  * Inside wrapped crypto key, data is serialized in this format:
 373  *
 374  * &lt;keyFormatVersion:uint32_t&gt; &lt;extractable:int32_t&gt; &lt;usagesCount:uint32_t&gt; &lt;usages:byte{usagesCount}&gt; CryptoKeyClassSubtag (CryptoKeyHMAC | CryptoKeyAES | CryptoKeyRSA)
 375  *
 376  * String :-
 377  *      EmptyStringTag
 378  *      StringTag StringData
 379  *
 380  * StringObject:
 381  *      EmptyStringObjectTag
 382  *      StringObjectTag StringData
 383  *
 384  * StringData :-
 385  *      StringPoolTag &lt;cpIndex:IndexType&gt;
 386  *      (not (TerminatorTag | StringPoolTag))&lt;is8Bit:uint32_t:1&gt;&lt;length:uint32_t:31&gt;&lt;characters:CharType{length}&gt; // Added to constant pool when seen, string length 0xFFFFFFFF is disallowed
 387  *
 388  * File :-
 389  *    FileTag FileData
 390  *
 391  * FileData :-
 392  *    &lt;path:StringData&gt; &lt;url:StringData&gt; &lt;type:StringData&gt; &lt;name:StringData&gt; &lt;lastModified:double&gt;
 393  *
 394  * FileList :-
 395  *    FileListTag &lt;length:uint32_t&gt;(&lt;file:FileData&gt;){length}
 396  *
 397  * ImageData :-
 398  *    ImageDataTag &lt;width:int32_t&gt;&lt;height:int32_t&gt;&lt;length:uint32_t&gt;&lt;data:uint8_t{length}&gt;
 399  *
 400  * Blob :-
 401  *    BlobTag &lt;url:StringData&gt;&lt;type:StringData&gt;&lt;size:long long&gt;
 402  *
 403  * RegExp :-
 404  *    RegExpTag &lt;pattern:StringData&gt;&lt;flags:StringData&gt;
 405  *
 406  * ObjectReference :-
 407  *    ObjectReferenceTag &lt;opIndex:IndexType&gt;
 408  *
 409  * ArrayBuffer :-
 410  *    ArrayBufferTag &lt;length:uint32_t&gt; &lt;contents:byte{length}&gt;
 411  *
 412  * CryptoKeyHMAC :-
 413  *    &lt;keySize:uint32_t&gt; &lt;keyData:byte{keySize}&gt; CryptoAlgorithmIdentifierTag // Algorithm tag inner hash function.
 414  *
 415  * CryptoKeyAES :-
 416  *    CryptoAlgorithmIdentifierTag &lt;keySize:uint32_t&gt; &lt;keyData:byte{keySize}&gt;
 417  *
 418  * CryptoKeyRSA :-
 419  *    CryptoAlgorithmIdentifierTag &lt;isRestrictedToHash:int32_t&gt; CryptoAlgorithmIdentifierTag? CryptoKeyAsymmetricTypeSubtag CryptoKeyRSAPublicComponents CryptoKeyRSAPrivateComponents?
 420  *
 421  * CryptoKeyRSAPublicComponents :-
 422  *    &lt;modulusSize:uint32_t&gt; &lt;modulus:byte{modulusSize}&gt; &lt;exponentSize:uint32_t&gt; &lt;exponent:byte{exponentSize}&gt;
 423  *
 424  * CryptoKeyRSAPrivateComponents :-
 425  *    &lt;privateExponentSize:uint32_t&gt; &lt;privateExponent:byte{privateExponentSize}&gt; &lt;primeCount:uint32_t&gt; FirstPrimeInfo? PrimeInfo{primeCount - 1}
 426  *
 427  * // CRT data could be computed from prime factors. It is only serialized to reuse a code path that&#39;s needed for JWK.
 428  * FirstPrimeInfo :-
 429  *    &lt;factorSize:uint32_t&gt; &lt;factor:byte{factorSize}&gt; &lt;crtExponentSize:uint32_t&gt; &lt;crtExponent:byte{crtExponentSize}&gt;
 430  *
 431  * PrimeInfo :-
 432  *    &lt;factorSize:uint32_t&gt; &lt;factor:byte{factorSize}&gt; &lt;crtExponentSize:uint32_t&gt; &lt;crtExponent:byte{crtExponentSize}&gt; &lt;crtCoefficientSize:uint32_t&gt; &lt;crtCoefficient:byte{crtCoefficientSize}&gt;
 433  *
 434  * CryptoKeyEC :-
 435  *    CryptoAlgorithmIdentifierTag &lt;namedCurve:StringData&gt; CryptoKeyAsymmetricTypeSubtag &lt;keySize:uint32_t&gt; &lt;keyData:byte{keySize}&gt;
 436  *
 437  * CryptoKeyRaw :-
 438  *    CryptoAlgorithmIdentifierTag &lt;keySize:uint32_t&gt; &lt;keyData:byte{keySize}&gt;
 439  *
 440  * DOMPoint :-
 441  *        DOMPointReadOnlyTag DOMPointData
 442  *      | DOMPointTag DOMPointData
 443  *
 444  * DOMPointData :-
 445  *      &lt;x:double&gt; &lt;y:double&gt; &lt;z:double&gt; &lt;w:double&gt;
 446  *
 447  * DOMRect :-
 448  *        DOMRectReadOnlyTag DOMRectData
 449  *      | DOMRectTag DOMRectData
 450  *
 451  * DOMRectData :-
 452  *      &lt;x:double&gt; &lt;y:double&gt; &lt;width:double&gt; &lt;height:double&gt;
 453  *
 454  * DOMMatrix :-
 455  *        DOMMatrixReadOnlyTag DOMMatrixData
 456  *      | DOMMatrixTag DOMMatrixData
 457  *
 458  * DOMMatrixData :-
 459  *        &lt;is2D:uint8_t:true&gt; &lt;m11:double&gt; &lt;m12:double&gt; &lt;m21:double&gt; &lt;m22:double&gt; &lt;m41:double&gt; &lt;m42:double&gt;
 460  *      | &lt;is2D:uint8_t:false&gt; &lt;m11:double&gt; &lt;m12:double&gt; &lt;m13:double&gt; &lt;m14:double&gt; &lt;m21:double&gt; &lt;m22:double&gt; &lt;m23:double&gt; &lt;m24:double&gt; &lt;m31:double&gt; &lt;m32:double&gt; &lt;m33:double&gt; &lt;m34:double&gt; &lt;m41:double&gt; &lt;m42:double&gt; &lt;m43:double&gt; &lt;m44:double&gt;
 461  *
 462  * DOMQuad :-
 463  *      DOMQuadTag DOMQuadData
 464  *
 465  * DOMQuadData :-
 466  *      &lt;p1:DOMPointData&gt; &lt;p2:DOMPointData&gt; &lt;p3:DOMPointData&gt; &lt;p4:DOMPointData&gt;
 467  *
 468  */
 469 
 470 using DeserializationResult = std::pair&lt;JSC::JSValue, SerializationReturnCode&gt;;
 471 
 472 class CloneBase {
 473 protected:
 474     CloneBase(JSGlobalObject* lexicalGlobalObject)
 475         : m_lexicalGlobalObject(lexicalGlobalObject)
 476         , m_failed(false)
 477     {
 478     }
 479 
 480     bool shouldTerminate()
 481     {
 482         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();
 483         auto scope = DECLARE_THROW_SCOPE(vm);
 484         return scope.exception();
 485     }
 486 
 487     void fail()
 488     {
 489         m_failed = true;
 490     }
 491 
 492     JSGlobalObject* m_lexicalGlobalObject;
 493     bool m_failed;
 494     MarkedArgumentBuffer m_gcBuffer;
 495 };
 496 
 497 #if ENABLE(WEB_CRYPTO)
 498 static bool wrapCryptoKey(JSGlobalObject* lexicalGlobalObject, const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
 499 {
 500     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(lexicalGlobalObject);
 501     if (!scriptExecutionContext)
 502         return false;
 503     return scriptExecutionContext-&gt;wrapCryptoKey(key, wrappedKey);
 504 }
 505 
 506 static bool unwrapCryptoKey(JSGlobalObject* lexicalGlobalObject, const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
 507 {
 508     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(lexicalGlobalObject);
 509     if (!scriptExecutionContext)
 510         return false;
 511     return scriptExecutionContext-&gt;unwrapCryptoKey(wrappedKey, key);
 512 }
 513 #endif
 514 
 515 #if ASSUME_LITTLE_ENDIAN
 516 template &lt;typename T&gt; static void writeLittleEndian(Vector&lt;uint8_t&gt;&amp; buffer, T value)
 517 {
 518     buffer.append(reinterpret_cast&lt;uint8_t*&gt;(&amp;value), sizeof(value));
 519 }
 520 #else
 521 template &lt;typename T&gt; static void writeLittleEndian(Vector&lt;uint8_t&gt;&amp; buffer, T value)
 522 {
 523     for (unsigned i = 0; i &lt; sizeof(T); i++) {
 524         buffer.append(value &amp; 0xFF);
 525         value &gt;&gt;= 8;
 526     }
 527 }
 528 #endif
 529 
 530 template &lt;&gt; void writeLittleEndian&lt;uint8_t&gt;(Vector&lt;uint8_t&gt;&amp; buffer, uint8_t value)
 531 {
 532     buffer.append(value);
 533 }
 534 
 535 template &lt;typename T&gt; static bool writeLittleEndian(Vector&lt;uint8_t&gt;&amp; buffer, const T* values, uint32_t length)
 536 {
 537     if (length &gt; std::numeric_limits&lt;uint32_t&gt;::max() / sizeof(T))
 538         return false;
 539 
 540 #if ASSUME_LITTLE_ENDIAN
 541     buffer.append(reinterpret_cast&lt;const uint8_t*&gt;(values), length * sizeof(T));
 542 #else
 543     for (unsigned i = 0; i &lt; length; i++) {
 544         T value = values[i];
 545         for (unsigned j = 0; j &lt; sizeof(T); j++) {
 546             buffer.append(static_cast&lt;uint8_t&gt;(value &amp; 0xFF));
 547             value &gt;&gt;= 8;
 548         }
 549     }
 550 #endif
 551     return true;
 552 }
 553 
 554 template &lt;&gt; bool writeLittleEndian&lt;uint8_t&gt;(Vector&lt;uint8_t&gt;&amp; buffer, const uint8_t* values, uint32_t length)
 555 {
 556     buffer.append(values, length);
 557     return true;
 558 }
 559 
 560 class CloneSerializer : CloneBase {
 561 public:
 562     static SerializationReturnCode serialize(JSGlobalObject* lexicalGlobalObject, JSValue value, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,
 563 #if ENABLE(OFFSCREEN_CANVAS)
 564             const Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt;&amp; offscreenCanvases,
 565 #endif
 566 #if ENABLE(WEBASSEMBLY)
 567             WasmModuleArray&amp; wasmModules,
 568 #endif
 569         Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)
 570     {
 571         CloneSerializer serializer(lexicalGlobalObject, messagePorts, arrayBuffers, imageBitmaps,
 572 #if ENABLE(OFFSCREEN_CANVAS)
 573             offscreenCanvases,
 574 #endif
 575 #if ENABLE(WEBASSEMBLY)
 576             wasmModules,
 577 #endif
 578             blobURLs, out, context, sharedBuffers);
 579         return serializer.serialize(value);
 580     }
 581 
 582     static bool serialize(StringView string, Vector&lt;uint8_t&gt;&amp; out)
 583     {
 584         writeLittleEndian(out, CurrentVersion);
 585         if (string.isEmpty()) {
 586             writeLittleEndian&lt;uint8_t&gt;(out, EmptyStringTag);
 587             return true;
 588         }
 589         writeLittleEndian&lt;uint8_t&gt;(out, StringTag);
 590         if (string.is8Bit()) {
 591             writeLittleEndian(out, string.length() | StringDataIs8BitFlag);
 592             return writeLittleEndian(out, string.characters8(), string.length());
 593         }
 594         writeLittleEndian(out, string.length());
 595         return writeLittleEndian(out, string.characters16(), string.length());
 596     }
 597 
 598 private:
 599     typedef HashMap&lt;JSObject*, uint32_t&gt; ObjectPool;
 600 
 601     CloneSerializer(JSGlobalObject* lexicalGlobalObject, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,
 602 #if ENABLE(OFFSCREEN_CANVAS)
 603             const Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt;&amp; offscreenCanvases,
 604 #endif
 605 #if ENABLE(WEBASSEMBLY)
 606             WasmModuleArray&amp; wasmModules,
 607 #endif
 608         Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)
 609         : CloneBase(lexicalGlobalObject)
 610         , m_buffer(out)
 611         , m_blobURLs(blobURLs)
 612         , m_emptyIdentifier(Identifier::fromString(lexicalGlobalObject-&gt;vm(), emptyString()))
 613         , m_context(context)
 614         , m_sharedBuffers(sharedBuffers)
 615 #if ENABLE(WEBASSEMBLY)
 616         , m_wasmModules(wasmModules)
 617 #endif
 618     {
 619         write(CurrentVersion);
 620         fillTransferMap(messagePorts, m_transferredMessagePorts);
 621         fillTransferMap(arrayBuffers, m_transferredArrayBuffers);
 622         fillTransferMap(imageBitmaps, m_transferredImageBitmaps);
 623 #if ENABLE(OFFSCREEN_CANVAS)
 624         fillTransferMap(offscreenCanvases, m_transferredOffscreenCanvases);
 625 #endif
 626     }
 627 
 628     template &lt;class T&gt;
 629     void fillTransferMap(const Vector&lt;RefPtr&lt;T&gt;&gt;&amp; input, ObjectPool&amp; result)
 630     {
 631         if (input.isEmpty())
 632             return;
 633         JSDOMGlobalObject* globalObject = jsCast&lt;JSDOMGlobalObject*&gt;(m_lexicalGlobalObject);
 634         for (size_t i = 0; i &lt; input.size(); i++) {
 635             JSC::JSValue value = toJS(m_lexicalGlobalObject, globalObject, input[i].get());
 636             JSC::JSObject* obj = value.getObject();
 637             if (obj &amp;&amp; !result.contains(obj))
 638                 result.add(obj, i);
 639         }
 640     }
 641 
 642     SerializationReturnCode serialize(JSValue in);
 643 
 644     bool isArray(VM&amp; vm, JSValue value)
 645     {
 646         if (!value.isObject())
 647             return false;
 648         JSObject* object = asObject(value);
 649         return object-&gt;inherits&lt;JSArray&gt;(vm);
 650     }
 651 
 652     bool isMap(VM&amp; vm, JSValue value)
 653     {
 654         if (!value.isObject())
 655             return false;
 656         JSObject* object = asObject(value);
 657         return object-&gt;inherits&lt;JSMap&gt;(vm);
 658     }
 659     bool isSet(VM&amp; vm, JSValue value)
 660     {
 661         if (!value.isObject())
 662             return false;
 663         JSObject* object = asObject(value);
 664         return object-&gt;inherits&lt;JSSet&gt;(vm);
 665     }
 666 
 667     bool checkForDuplicate(JSObject* object)
 668     {
 669         // Record object for graph reconstruction
 670         ObjectPool::const_iterator found = m_objectPool.find(object);
 671 
 672         // Handle duplicate references
 673         if (found != m_objectPool.end()) {
 674             write(ObjectReferenceTag);
 675             ASSERT(found-&gt;value &lt; m_objectPool.size());
 676             writeObjectIndex(found-&gt;value);
 677             return true;
 678         }
 679 
 680         return false;
 681     }
 682 
 683     void recordObject(JSObject* object)
 684     {
 685         m_objectPool.add(object, m_objectPool.size());
 686         m_gcBuffer.appendWithCrashOnOverflow(object);
 687     }
 688 
 689     bool startObjectInternal(JSObject* object)
 690     {
 691         if (checkForDuplicate(object))
 692             return false;
 693         recordObject(object);
 694         return true;
 695     }
 696 
 697     bool startObject(JSObject* object)
 698     {
 699         if (!startObjectInternal(object))
 700             return false;
 701         write(ObjectTag);
 702         return true;
 703     }
 704 
 705     bool startArray(JSArray* array)
 706     {
 707         if (!startObjectInternal(array))
 708             return false;
 709 
 710         unsigned length = array-&gt;length();
 711         write(ArrayTag);
 712         write(length);
 713         return true;
 714     }
 715 
 716     bool startSet(JSSet* set)
 717     {
 718         if (!startObjectInternal(set))
 719             return false;
 720 
 721         write(SetObjectTag);
 722         return true;
 723     }
 724 
 725     bool startMap(JSMap* map)
 726     {
 727         if (!startObjectInternal(map))
 728             return false;
 729 
 730         write(MapObjectTag);
 731         return true;
 732     }
 733 
 734     void endObject()
 735     {
 736         write(TerminatorTag);
 737     }
 738 
 739     JSValue getProperty(VM&amp; vm, JSObject* object, const Identifier&amp; propertyName)
 740     {
 741         PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
 742         if (object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, m_lexicalGlobalObject, propertyName, slot))
 743             return slot.getValue(m_lexicalGlobalObject, propertyName);
 744         return JSValue();
 745     }
 746 
 747     void dumpImmediate(JSValue value)
 748     {
 749         if (value.isNull())
 750             write(NullTag);
 751         else if (value.isUndefined())
 752             write(UndefinedTag);
 753         else if (value.isNumber()) {
 754             if (value.isInt32()) {
 755                 if (!value.asInt32())
 756                     write(ZeroTag);
 757                 else if (value.asInt32() == 1)
 758                     write(OneTag);
 759                 else {
 760                     write(IntTag);
 761                     write(static_cast&lt;uint32_t&gt;(value.asInt32()));
 762                 }
 763             } else {
 764                 write(DoubleTag);
 765                 write(value.asDouble());
 766             }
 767         } else if (value.isBoolean()) {
 768             if (value.isTrue())
 769                 write(TrueTag);
 770             else
 771                 write(FalseTag);
 772         }
 773     }
 774 
 775     void dumpString(const String&amp; string)
 776     {
 777         if (string.isEmpty())
 778             write(EmptyStringTag);
 779         else {
 780             write(StringTag);
 781             write(string);
 782         }
 783     }
 784 
 785     void dumpStringObject(const String&amp; string)
 786     {
 787         if (string.isEmpty())
 788             write(EmptyStringObjectTag);
 789         else {
 790             write(StringObjectTag);
 791             write(string);
 792         }
 793     }
 794 
 795     JSC::JSValue toJSArrayBuffer(ArrayBuffer&amp; arrayBuffer)
 796     {
 797         auto&amp; vm = m_lexicalGlobalObject-&gt;vm();
 798         auto* globalObject = m_lexicalGlobalObject;
 799         if (globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(vm))
 800             return toJS(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(globalObject), &amp;arrayBuffer);
 801 
 802         if (auto* buffer = arrayBuffer.m_wrapper.get())
 803             return buffer;
 804 
 805         return JSC::JSArrayBuffer::create(vm, globalObject-&gt;arrayBufferStructure(arrayBuffer.sharingMode()), &amp;arrayBuffer);
 806     }
 807 
 808     bool dumpArrayBufferView(JSObject* obj, SerializationReturnCode&amp; code)
 809     {
 810         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();
 811         write(ArrayBufferViewTag);
 812         if (obj-&gt;inherits&lt;JSDataView&gt;(vm))
 813             write(DataViewTag);
 814         else if (obj-&gt;inherits&lt;JSUint8ClampedArray&gt;(vm))
 815             write(Uint8ClampedArrayTag);
 816         else if (obj-&gt;inherits&lt;JSInt8Array&gt;(vm))
 817             write(Int8ArrayTag);
 818         else if (obj-&gt;inherits&lt;JSUint8Array&gt;(vm))
 819             write(Uint8ArrayTag);
 820         else if (obj-&gt;inherits&lt;JSInt16Array&gt;(vm))
 821             write(Int16ArrayTag);
 822         else if (obj-&gt;inherits&lt;JSUint16Array&gt;(vm))
 823             write(Uint16ArrayTag);
 824         else if (obj-&gt;inherits&lt;JSInt32Array&gt;(vm))
 825             write(Int32ArrayTag);
 826         else if (obj-&gt;inherits&lt;JSUint32Array&gt;(vm))
 827             write(Uint32ArrayTag);
 828         else if (obj-&gt;inherits&lt;JSFloat32Array&gt;(vm))
 829             write(Float32ArrayTag);
 830         else if (obj-&gt;inherits&lt;JSFloat64Array&gt;(vm))
 831             write(Float64ArrayTag);
 832         else
 833             return false;
 834 
 835         RefPtr&lt;ArrayBufferView&gt; arrayBufferView = toPossiblySharedArrayBufferView(vm, obj);
 836         write(static_cast&lt;uint32_t&gt;(arrayBufferView-&gt;byteOffset()));
 837         write(static_cast&lt;uint32_t&gt;(arrayBufferView-&gt;byteLength()));
 838         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = arrayBufferView-&gt;possiblySharedBuffer();
 839         if (!arrayBuffer) {
 840             code = SerializationReturnCode::ValidationError;
 841             return true;
 842         }
 843 
 844         return dumpIfTerminal(toJSArrayBuffer(*arrayBuffer), code);
 845     }
 846 
 847     void dumpDOMPoint(const DOMPointReadOnly&amp; point)
 848     {
 849         write(point.x());
 850         write(point.y());
 851         write(point.z());
 852         write(point.w());
 853     }
 854 
 855     void dumpDOMPoint(JSObject* obj)
 856     {
 857         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();
 858         if (obj-&gt;inherits&lt;JSDOMPoint&gt;(vm))
 859             write(DOMPointTag);
 860         else
 861             write(DOMPointReadOnlyTag);
 862 
 863         dumpDOMPoint(jsCast&lt;JSDOMPointReadOnly*&gt;(obj)-&gt;wrapped());
 864     }
 865 
 866     void dumpDOMRect(JSObject* obj)
 867     {
 868         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();
 869         if (obj-&gt;inherits&lt;JSDOMRect&gt;(vm))
 870             write(DOMRectTag);
 871         else
 872             write(DOMRectReadOnlyTag);
 873 
 874         auto&amp; rect = jsCast&lt;JSDOMRectReadOnly*&gt;(obj)-&gt;wrapped();
 875         write(rect.x());
 876         write(rect.y());
 877         write(rect.width());
 878         write(rect.height());
 879     }
 880 
 881     void dumpDOMMatrix(JSObject* obj)
 882     {
 883         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();
 884         if (obj-&gt;inherits&lt;JSDOMMatrix&gt;(vm))
 885             write(DOMMatrixTag);
 886         else
 887             write(DOMMatrixReadOnlyTag);
 888 
 889         auto&amp; matrix = jsCast&lt;JSDOMMatrixReadOnly*&gt;(obj)-&gt;wrapped();
 890         bool is2D = matrix.is2D();
 891         write(static_cast&lt;uint8_t&gt;(is2D));
 892         if (is2D) {
 893             write(matrix.m11());
 894             write(matrix.m12());
 895             write(matrix.m21());
 896             write(matrix.m22());
 897             write(matrix.m41());
 898             write(matrix.m42());
 899         } else {
 900             write(matrix.m11());
 901             write(matrix.m12());
 902             write(matrix.m13());
 903             write(matrix.m14());
 904             write(matrix.m21());
 905             write(matrix.m22());
 906             write(matrix.m23());
 907             write(matrix.m24());
 908             write(matrix.m31());
 909             write(matrix.m32());
 910             write(matrix.m33());
 911             write(matrix.m34());
 912             write(matrix.m41());
 913             write(matrix.m42());
 914             write(matrix.m43());
 915             write(matrix.m44());
 916         }
 917     }
 918 
 919     void dumpDOMQuad(JSObject* obj)
 920     {
 921         write(DOMQuadTag);
 922 
 923         auto&amp; quad = jsCast&lt;JSDOMQuad*&gt;(obj)-&gt;wrapped();
 924         dumpDOMPoint(quad.p1());
 925         dumpDOMPoint(quad.p2());
 926         dumpDOMPoint(quad.p3());
 927         dumpDOMPoint(quad.p4());
 928     }
 929 
 930     void dumpImageBitmap(JSObject* obj, SerializationReturnCode&amp; code)
 931     {
 932         auto index = m_transferredImageBitmaps.find(obj);
 933         if (index != m_transferredImageBitmaps.end()) {
 934             write(ImageBitmapTransferTag);
 935             write(index-&gt;value);
 936             return;
 937         }
 938 
 939         auto&amp; imageBitmap = jsCast&lt;JSImageBitmap*&gt;(obj)-&gt;wrapped();
 940         auto* buffer = imageBitmap.buffer();
 941 
 942         if (!buffer) {
 943             code = SerializationReturnCode::ValidationError;
 944             return;
 945         }
 946 
 947         const IntSize&amp; logicalSize = buffer-&gt;logicalSize();
 948         auto imageData = buffer-&gt;getPremultipliedImageData(IntRect(0, 0, logicalSize.width(), logicalSize.height()));
 949         if (!imageData) {
 950             code = SerializationReturnCode::ValidationError;
 951             return;
 952         }
 953 
 954         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = imageData-&gt;possiblySharedBuffer();
 955         if (!arrayBuffer) {
 956             code = SerializationReturnCode::ValidationError;
 957             return;
 958         }
 959 
 960         write(ImageBitmapTag);
 961         write(static_cast&lt;uint8_t&gt;(imageBitmap.originClean()));
 962         write(static_cast&lt;int32_t&gt;(logicalSize.width()));
 963         write(static_cast&lt;int32_t&gt;(logicalSize.height()));
 964         write(static_cast&lt;double&gt;(buffer-&gt;resolutionScale()));
 965 
 966         write(static_cast&lt;uint32_t&gt;(arrayBuffer-&gt;byteLength()));
 967         write(static_cast&lt;const uint8_t*&gt;(arrayBuffer-&gt;data()), arrayBuffer-&gt;byteLength());
 968     }
 969 
 970 #if ENABLE(OFFSCREEN_CANVAS)
 971     void dumpOffscreenCanvas(JSObject* obj, SerializationReturnCode&amp; code)
 972     {
 973         auto index = m_transferredOffscreenCanvases.find(obj);
 974         if (index != m_transferredOffscreenCanvases.end()) {
 975             write(OffscreenCanvasTransferTag);
 976             write(index-&gt;value);
 977             return;
 978         }
 979 
 980         code = SerializationReturnCode::DataCloneError;
 981     }
 982 #endif
 983 
 984     bool dumpIfTerminal(JSValue value, SerializationReturnCode&amp; code)
 985     {
 986         if (!value.isCell()) {
 987             dumpImmediate(value);
 988             return true;
 989         }
 990         ASSERT(value.isCell());
 991 
 992         if (value.isString()) {
 993             dumpString(asString(value)-&gt;value(m_lexicalGlobalObject));
 994             return true;
 995         }
 996 
 997         if (value.isSymbol()) {
 998             code = SerializationReturnCode::DataCloneError;
 999             return true;
1000         }
1001 
1002         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();
1003         if (isArray(vm, value))
1004             return false;
1005 
1006         if (value.isObject()) {
1007             auto* obj = asObject(value);
1008             if (auto* dateObject = jsDynamicCast&lt;DateInstance*&gt;(vm, obj)) {
1009                 write(DateTag);
1010                 write(dateObject-&gt;internalNumber());
1011                 return true;
1012             }
1013             if (auto* booleanObject = jsDynamicCast&lt;BooleanObject*&gt;(vm, obj)) {
1014                 if (!startObjectInternal(booleanObject)) // handle duplicates
1015                     return true;
1016                 write(booleanObject-&gt;internalValue().toBoolean(m_lexicalGlobalObject) ? TrueObjectTag : FalseObjectTag);
1017                 return true;
1018             }
1019             if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, obj)) {
1020                 if (!startObjectInternal(stringObject)) // handle duplicates
1021                     return true;
1022                 String str = asString(stringObject-&gt;internalValue())-&gt;value(m_lexicalGlobalObject);
1023                 dumpStringObject(str);
1024                 return true;
1025             }
1026             if (auto* numberObject = jsDynamicCast&lt;NumberObject*&gt;(vm, obj)) {
1027                 if (!startObjectInternal(numberObject)) // handle duplicates
1028                     return true;
1029                 write(NumberObjectTag);
1030                 write(numberObject-&gt;internalValue().asNumber());
1031                 return true;
1032             }
1033             if (auto* file = JSFile::toWrapped(vm, obj)) {
1034                 write(FileTag);
1035                 write(*file);
1036                 return true;
1037             }
1038             if (auto* list = JSFileList::toWrapped(vm, obj)) {
1039                 write(FileListTag);
1040                 write(list-&gt;length());
1041                 for (auto&amp; file : list-&gt;files())
1042                     write(file.get());
1043                 return true;
1044             }
1045             if (auto* blob = JSBlob::toWrapped(vm, obj)) {
1046                 write(BlobTag);
1047                 m_blobURLs.append(blob-&gt;url());
1048                 write(blob-&gt;url());
1049                 write(blob-&gt;type());
1050                 write(blob-&gt;size());
1051                 return true;
1052             }
1053             if (auto* data = JSImageData::toWrapped(vm, obj)) {
1054                 write(ImageDataTag);
1055                 write(data-&gt;width());
1056                 write(data-&gt;height());
1057                 write(data-&gt;data()-&gt;length());
1058                 write(data-&gt;data()-&gt;data(), data-&gt;data()-&gt;length());
1059                 return true;
1060             }
1061             if (auto* regExp = jsDynamicCast&lt;RegExpObject*&gt;(vm, obj)) {
1062                 char flags[3];
1063                 int flagCount = 0;
1064                 if (regExp-&gt;regExp()-&gt;global())
1065                     flags[flagCount++] = &#39;g&#39;;
1066                 if (regExp-&gt;regExp()-&gt;ignoreCase())
1067                     flags[flagCount++] = &#39;i&#39;;
1068                 if (regExp-&gt;regExp()-&gt;multiline())
1069                     flags[flagCount++] = &#39;m&#39;;
1070                 write(RegExpTag);
1071                 write(regExp-&gt;regExp()-&gt;pattern());
1072                 write(String(flags, flagCount));
1073                 return true;
1074             }
1075             if (obj-&gt;inherits&lt;JSMessagePort&gt;(vm)) {
1076                 auto index = m_transferredMessagePorts.find(obj);
1077                 if (index != m_transferredMessagePorts.end()) {
1078                     write(MessagePortReferenceTag);
1079                     write(index-&gt;value);
1080                     return true;
1081                 }
1082                 // MessagePort object could not be found in transferred message ports
1083                 code = SerializationReturnCode::ValidationError;
1084                 return true;
1085             }
1086             if (auto* arrayBuffer = toPossiblySharedArrayBuffer(vm, obj)) {
1087                 if (arrayBuffer-&gt;isNeutered()) {
1088                     code = SerializationReturnCode::ValidationError;
1089                     return true;
1090                 }
1091                 auto index = m_transferredArrayBuffers.find(obj);
1092                 if (index != m_transferredArrayBuffers.end()) {
1093                     write(ArrayBufferTransferTag);
1094                     write(index-&gt;value);
1095                     return true;
1096                 }
1097                 if (!startObjectInternal(obj)) // handle duplicates
1098                     return true;
1099 
1100                 if (arrayBuffer-&gt;isShared() &amp;&amp; m_context == SerializationContext::WorkerPostMessage) {
1101                     uint32_t index = m_sharedBuffers.size();
1102                     ArrayBufferContents contents;
1103                     if (arrayBuffer-&gt;shareWith(contents)) {
1104                         write(SharedArrayBufferTag);
1105                         m_sharedBuffers.append(WTFMove(contents));
1106                         write(index);
1107                         return true;
1108                     }
1109                 }
1110 
1111                 write(ArrayBufferTag);
1112                 write(arrayBuffer-&gt;byteLength());
1113                 write(static_cast&lt;const uint8_t*&gt;(arrayBuffer-&gt;data()), arrayBuffer-&gt;byteLength());
1114                 return true;
1115             }
1116             if (obj-&gt;inherits&lt;JSArrayBufferView&gt;(vm)) {
1117                 if (checkForDuplicate(obj))
1118                     return true;
1119                 bool success = dumpArrayBufferView(obj, code);
1120                 recordObject(obj);
1121                 return success;
1122             }
1123 #if ENABLE(WEB_CRYPTO)
1124             if (auto* key = JSCryptoKey::toWrapped(vm, obj)) {
1125                 write(CryptoKeyTag);
1126                 Vector&lt;uint8_t&gt; serializedKey;
1127                 Vector&lt;String&gt; dummyBlobURLs;
1128                 Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
1129                 Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
1130 #if ENABLE(WEBASSEMBLY)
1131                 WasmModuleArray dummyModules;
1132 #endif
1133                 ArrayBufferContentsArray dummySharedBuffers;
1134                 CloneSerializer rawKeySerializer(m_lexicalGlobalObject, dummyMessagePorts, dummyArrayBuffers, { },
1135 #if ENABLE(OFFSCREEN_CANVAS)
1136                     { },
1137 #endif
1138 #if ENABLE(WEBASSEMBLY)
1139                     dummyModules,
1140 #endif
1141                     dummyBlobURLs, serializedKey, SerializationContext::Default, dummySharedBuffers);
1142                 rawKeySerializer.write(key);
1143                 Vector&lt;uint8_t&gt; wrappedKey;
1144                 if (!wrapCryptoKey(m_lexicalGlobalObject, serializedKey, wrappedKey))
1145                     return false;
1146                 write(wrappedKey);
1147                 return true;
1148             }
1149 #endif
1150 #if ENABLE(WEB_RTC)
1151             if (auto* rtcCertificate = JSRTCCertificate::toWrapped(vm, obj)) {
1152                 write(RTCCertificateTag);
1153                 write(rtcCertificate-&gt;expires());
1154                 write(rtcCertificate-&gt;pemCertificate());
1155                 write(rtcCertificate-&gt;origin().toString());
1156                 write(rtcCertificate-&gt;pemPrivateKey());
1157                 write(static_cast&lt;unsigned&gt;(rtcCertificate-&gt;getFingerprints().size()));
1158                 for (const auto&amp; fingerprint : rtcCertificate-&gt;getFingerprints()) {
1159                     write(fingerprint.algorithm);
1160                     write(fingerprint.value);
1161                 }
1162                 return true;
1163             }
1164 #endif
1165 #if ENABLE(WEBASSEMBLY)
1166             if (JSWebAssemblyModule* module = jsDynamicCast&lt;JSWebAssemblyModule*&gt;(vm, obj)) {
1167                 if (m_context != SerializationContext::WorkerPostMessage &amp;&amp; m_context != SerializationContext::WindowPostMessage)
1168                     return false;
1169 
1170                 uint32_t index = m_wasmModules.size();
1171                 m_wasmModules.append(makeRef(module-&gt;module()));
1172                 write(WasmModuleTag);
1173                 write(index);
1174                 return true;
1175             }
1176 #endif
1177             if (obj-&gt;inherits&lt;JSDOMPointReadOnly&gt;(vm)) {
1178                 dumpDOMPoint(obj);
1179                 return true;
1180             }
1181             if (obj-&gt;inherits&lt;JSDOMRectReadOnly&gt;(vm)) {
1182                 dumpDOMRect(obj);
1183                 return true;
1184             }
1185             if (obj-&gt;inherits&lt;JSDOMMatrixReadOnly&gt;(vm)) {
1186                 dumpDOMMatrix(obj);
1187                 return true;
1188             }
1189             if (obj-&gt;inherits&lt;JSDOMQuad&gt;(vm)) {
1190                 dumpDOMQuad(obj);
1191                 return true;
1192             }
1193             if (obj-&gt;inherits(vm, JSImageBitmap::info())) {
1194                 dumpImageBitmap(obj, code);
1195                 return true;
1196             }
1197 #if ENABLE(OFFSCREEN_CANVAS)
1198             if (obj-&gt;inherits(vm, JSOffscreenCanvas::info())) {
1199                 dumpOffscreenCanvas(obj, code);
1200                 return true;
1201             }
1202 #endif
1203             return false;
1204         }
1205         // Any other types are expected to serialize as null.
1206         write(NullTag);
1207         return true;
1208     }
1209 
1210     void write(SerializationTag tag)
1211     {
1212         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1213     }
1214 
1215     void write(ArrayBufferViewSubtag tag)
1216     {
1217         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1218     }
1219 
1220 #if ENABLE(WEB_CRYPTO)
1221     void write(CryptoKeyClassSubtag tag)
1222     {
1223         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1224     }
1225 
1226     void write(CryptoKeyAsymmetricTypeSubtag tag)
1227     {
1228         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1229     }
1230 
1231     void write(CryptoKeyUsageTag tag)
1232     {
1233         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1234     }
1235 
1236     void write(CryptoAlgorithmIdentifierTag tag)
1237     {
1238         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1239     }
1240 #endif
1241 
1242     void write(uint8_t c)
1243     {
1244         writeLittleEndian(m_buffer, c);
1245     }
1246 
1247     void write(uint32_t i)
1248     {
1249         writeLittleEndian(m_buffer, i);
1250     }
1251 
1252     void write(double d)
1253     {
1254         union {
1255             double d;
1256             int64_t i;
1257         } u;
1258         u.d = d;
1259         writeLittleEndian(m_buffer, u.i);
1260     }
1261 
1262     void write(int32_t i)
1263     {
1264         writeLittleEndian(m_buffer, i);
1265     }
1266 
1267     void write(unsigned long long i)
1268     {
1269         writeLittleEndian(m_buffer, i);
1270     }
1271 
1272     void write(uint16_t ch)
1273     {
1274         writeLittleEndian(m_buffer, ch);
1275     }
1276 
1277     void writeStringIndex(unsigned i)
1278     {
1279         writeConstantPoolIndex(m_constantPool, i);
1280     }
1281 
1282     void writeObjectIndex(unsigned i)
1283     {
1284         writeConstantPoolIndex(m_objectPool, i);
1285     }
1286 
1287     template &lt;class T&gt; void writeConstantPoolIndex(const T&amp; constantPool, unsigned i)
1288     {
1289         ASSERT(i &lt; constantPool.size());
1290         if (constantPool.size() &lt;= 0xFF)
1291             write(static_cast&lt;uint8_t&gt;(i));
1292         else if (constantPool.size() &lt;= 0xFFFF)
1293             write(static_cast&lt;uint16_t&gt;(i));
1294         else
1295             write(static_cast&lt;uint32_t&gt;(i));
1296     }
1297 
1298     void write(const Identifier&amp; ident)
1299     {
1300         const String&amp; str = ident.string();
1301         StringConstantPool::AddResult addResult = m_constantPool.add(ident.impl(), m_constantPool.size());
1302         if (!addResult.isNewEntry) {
1303             write(StringPoolTag);
1304             writeStringIndex(addResult.iterator-&gt;value);
1305             return;
1306         }
1307 
1308         unsigned length = str.length();
1309 
1310         // Guard against overflow
1311         if (length &gt; (std::numeric_limits&lt;uint32_t&gt;::max() - sizeof(uint32_t)) / sizeof(UChar)) {
1312             fail();
1313             return;
1314         }
1315 
1316         if (str.is8Bit())
1317             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length | StringDataIs8BitFlag);
1318         else
1319             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length);
1320 
1321         if (!length)
1322             return;
1323         if (str.is8Bit()) {
1324             if (!writeLittleEndian(m_buffer, str.characters8(), length))
1325                 fail();
1326             return;
1327         }
1328         if (!writeLittleEndian(m_buffer, str.characters16(), length))
1329             fail();
1330     }
1331 
1332     void write(const String&amp; str)
1333     {
1334         if (str.isNull())
1335             write(m_emptyIdentifier);
1336         else
1337             write(Identifier::fromString(m_lexicalGlobalObject-&gt;vm(), str));
1338     }
1339 
1340     void write(const Vector&lt;uint8_t&gt;&amp; vector)
1341     {
1342         uint32_t size = vector.size();
1343         write(size);
1344         writeLittleEndian(m_buffer, vector.data(), size);
1345     }
1346 
1347     void write(const File&amp; file)
1348     {
1349         m_blobURLs.append(file.url());
1350         write(file.path());
1351         write(file.url());
1352         write(file.type());
1353         write(file.name());
1354         write(static_cast&lt;double&gt;(file.lastModifiedOverride().valueOr(-1)));
1355     }
1356 
1357 #if ENABLE(WEB_CRYPTO)
1358     void write(CryptoAlgorithmIdentifier algorithm)
1359     {
1360         switch (algorithm) {
1361         case CryptoAlgorithmIdentifier::RSAES_PKCS1_v1_5:
1362             write(CryptoAlgorithmIdentifierTag::RSAES_PKCS1_v1_5);
1363             break;
1364         case CryptoAlgorithmIdentifier::RSASSA_PKCS1_v1_5:
1365             write(CryptoAlgorithmIdentifierTag::RSASSA_PKCS1_v1_5);
1366             break;
1367         case CryptoAlgorithmIdentifier::RSA_PSS:
1368             write(CryptoAlgorithmIdentifierTag::RSA_PSS);
1369             break;
1370         case CryptoAlgorithmIdentifier::RSA_OAEP:
1371             write(CryptoAlgorithmIdentifierTag::RSA_OAEP);
1372             break;
1373         case CryptoAlgorithmIdentifier::ECDSA:
1374             write(CryptoAlgorithmIdentifierTag::ECDSA);
1375             break;
1376         case CryptoAlgorithmIdentifier::ECDH:
1377             write(CryptoAlgorithmIdentifierTag::ECDH);
1378             break;
1379         case CryptoAlgorithmIdentifier::AES_CTR:
1380             write(CryptoAlgorithmIdentifierTag::AES_CTR);
1381             break;
1382         case CryptoAlgorithmIdentifier::AES_CBC:
1383             write(CryptoAlgorithmIdentifierTag::AES_CBC);
1384             break;
1385         case CryptoAlgorithmIdentifier::AES_GCM:
1386             write(CryptoAlgorithmIdentifierTag::AES_GCM);
1387             break;
1388         case CryptoAlgorithmIdentifier::AES_CFB:
1389             write(CryptoAlgorithmIdentifierTag::AES_CFB);
1390             break;
1391         case CryptoAlgorithmIdentifier::AES_KW:
1392             write(CryptoAlgorithmIdentifierTag::AES_KW);
1393             break;
1394         case CryptoAlgorithmIdentifier::HMAC:
1395             write(CryptoAlgorithmIdentifierTag::HMAC);
1396             break;
1397         case CryptoAlgorithmIdentifier::SHA_1:
1398             write(CryptoAlgorithmIdentifierTag::SHA_1);
1399             break;
1400         case CryptoAlgorithmIdentifier::SHA_224:
1401             write(CryptoAlgorithmIdentifierTag::SHA_224);
1402             break;
1403         case CryptoAlgorithmIdentifier::SHA_256:
1404             write(CryptoAlgorithmIdentifierTag::SHA_256);
1405             break;
1406         case CryptoAlgorithmIdentifier::SHA_384:
1407             write(CryptoAlgorithmIdentifierTag::SHA_384);
1408             break;
1409         case CryptoAlgorithmIdentifier::SHA_512:
1410             write(CryptoAlgorithmIdentifierTag::SHA_512);
1411             break;
1412         case CryptoAlgorithmIdentifier::HKDF:
1413             write(CryptoAlgorithmIdentifierTag::HKDF);
1414             break;
1415         case CryptoAlgorithmIdentifier::PBKDF2:
1416             write(CryptoAlgorithmIdentifierTag::PBKDF2);
1417             break;
1418         }
1419     }
1420 
1421     void write(CryptoKeyRSAComponents::Type type)
1422     {
1423         switch (type) {
1424         case CryptoKeyRSAComponents::Type::Public:
1425             write(CryptoKeyAsymmetricTypeSubtag::Public);
1426             return;
1427         case CryptoKeyRSAComponents::Type::Private:
1428             write(CryptoKeyAsymmetricTypeSubtag::Private);
1429             return;
1430         }
1431     }
1432 
1433     void write(const CryptoKeyRSAComponents&amp; key)
1434     {
1435         write(key.type());
1436         write(key.modulus());
1437         write(key.exponent());
1438         if (key.type() == CryptoKeyRSAComponents::Type::Public)
1439             return;
1440 
1441         write(key.privateExponent());
1442 
1443         unsigned primeCount = key.hasAdditionalPrivateKeyParameters() ? key.otherPrimeInfos().size() + 2 : 0;
1444         write(primeCount);
1445         if (!primeCount)
1446             return;
1447 
1448         write(key.firstPrimeInfo().primeFactor);
1449         write(key.firstPrimeInfo().factorCRTExponent);
1450         write(key.secondPrimeInfo().primeFactor);
1451         write(key.secondPrimeInfo().factorCRTExponent);
1452         write(key.secondPrimeInfo().factorCRTCoefficient);
1453         for (unsigned i = 2; i &lt; primeCount; ++i) {
1454             write(key.otherPrimeInfos()[i].primeFactor);
1455             write(key.otherPrimeInfos()[i].factorCRTExponent);
1456             write(key.otherPrimeInfos()[i].factorCRTCoefficient);
1457         }
1458     }
1459 
1460     void write(const CryptoKey* key)
1461     {
1462         write(currentKeyFormatVersion);
1463 
1464         write(key-&gt;extractable());
1465 
1466         CryptoKeyUsageBitmap usages = key-&gt;usagesBitmap();
1467         write(countUsages(usages));
1468         if (usages &amp; CryptoKeyUsageEncrypt)
1469             write(CryptoKeyUsageTag::Encrypt);
1470         if (usages &amp; CryptoKeyUsageDecrypt)
1471             write(CryptoKeyUsageTag::Decrypt);
1472         if (usages &amp; CryptoKeyUsageSign)
1473             write(CryptoKeyUsageTag::Sign);
1474         if (usages &amp; CryptoKeyUsageVerify)
1475             write(CryptoKeyUsageTag::Verify);
1476         if (usages &amp; CryptoKeyUsageDeriveKey)
1477             write(CryptoKeyUsageTag::DeriveKey);
1478         if (usages &amp; CryptoKeyUsageDeriveBits)
1479             write(CryptoKeyUsageTag::DeriveBits);
1480         if (usages &amp; CryptoKeyUsageWrapKey)
1481             write(CryptoKeyUsageTag::WrapKey);
1482         if (usages &amp; CryptoKeyUsageUnwrapKey)
1483             write(CryptoKeyUsageTag::UnwrapKey);
1484 
1485         switch (key-&gt;keyClass()) {
1486         case CryptoKeyClass::HMAC:
1487             write(CryptoKeyClassSubtag::HMAC);
1488             write(downcast&lt;CryptoKeyHMAC&gt;(*key).key());
1489             write(downcast&lt;CryptoKeyHMAC&gt;(*key).hashAlgorithmIdentifier());
1490             break;
1491         case CryptoKeyClass::AES:
1492             write(CryptoKeyClassSubtag::AES);
1493             write(key-&gt;algorithmIdentifier());
1494             write(downcast&lt;CryptoKeyAES&gt;(*key).key());
1495             break;
1496         case CryptoKeyClass::EC:
1497             write(CryptoKeyClassSubtag::EC);
1498             write(key-&gt;algorithmIdentifier());
1499             write(downcast&lt;CryptoKeyEC&gt;(*key).namedCurveString());
1500             switch (key-&gt;type()) {
1501             case CryptoKey::Type::Public: {
1502                 write(CryptoKeyAsymmetricTypeSubtag::Public);
1503                 auto result = downcast&lt;CryptoKeyEC&gt;(*key).exportRaw();
1504                 ASSERT(!result.hasException());
1505                 write(result.releaseReturnValue());
1506                 break;
1507             }
1508             case CryptoKey::Type::Private: {
1509                 write(CryptoKeyAsymmetricTypeSubtag::Private);
1510                 // Use the standard complied method is not very efficient, but simple/reliable.
1511                 auto result = downcast&lt;CryptoKeyEC&gt;(*key).exportPkcs8();
1512                 ASSERT(!result.hasException());
1513                 write(result.releaseReturnValue());
1514                 break;
1515             }
1516             default:
1517                 ASSERT_NOT_REACHED();
1518             }
1519             break;
1520         case CryptoKeyClass::Raw:
1521             write(CryptoKeyClassSubtag::Raw);
1522             write(key-&gt;algorithmIdentifier());
1523             write(downcast&lt;CryptoKeyRaw&gt;(*key).key());
1524             break;
1525         case CryptoKeyClass::RSA:
1526             write(CryptoKeyClassSubtag::RSA);
1527             write(key-&gt;algorithmIdentifier());
1528             CryptoAlgorithmIdentifier hash;
1529             bool isRestrictedToHash = downcast&lt;CryptoKeyRSA&gt;(*key).isRestrictedToHash(hash);
1530             write(isRestrictedToHash);
1531             if (isRestrictedToHash)
1532                 write(hash);
1533             write(*downcast&lt;CryptoKeyRSA&gt;(*key).exportData());
1534             break;
1535         }
1536     }
1537 #endif
1538 
1539     void write(const uint8_t* data, unsigned length)
1540     {
1541         m_buffer.append(data, length);
1542     }
1543 
1544     Vector&lt;uint8_t&gt;&amp; m_buffer;
1545     Vector&lt;String&gt;&amp; m_blobURLs;
1546     ObjectPool m_objectPool;
1547     ObjectPool m_transferredMessagePorts;
1548     ObjectPool m_transferredArrayBuffers;
1549     ObjectPool m_transferredImageBitmaps;
1550 #if ENABLE(OFFSCREEN_CANVAS)
1551     ObjectPool m_transferredOffscreenCanvases;
1552 #endif
1553     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, uint32_t, IdentifierRepHash&gt; StringConstantPool;
1554     StringConstantPool m_constantPool;
1555     Identifier m_emptyIdentifier;
1556     SerializationContext m_context;
1557     ArrayBufferContentsArray&amp; m_sharedBuffers;
1558 #if ENABLE(WEBASSEMBLY)
1559     WasmModuleArray&amp; m_wasmModules;
1560 #endif
1561 };
1562 
1563 SerializationReturnCode CloneSerializer::serialize(JSValue in)
1564 {
1565     VM&amp; vm = m_lexicalGlobalObject-&gt;vm();
1566     Vector&lt;uint32_t, 16&gt; indexStack;
1567     Vector&lt;uint32_t, 16&gt; lengthStack;
1568     Vector&lt;PropertyNameArray, 16&gt; propertyStack;
1569     Vector&lt;JSObject*, 32&gt; inputObjectStack;
1570     Vector&lt;JSMapIterator*, 4&gt; mapIteratorStack;
1571     Vector&lt;JSSetIterator*, 4&gt; setIteratorStack;
1572     Vector&lt;JSValue, 4&gt; mapIteratorValueStack;
1573     Vector&lt;WalkerState, 16&gt; stateStack;
1574     WalkerState lexicalGlobalObject = StateUnknown;
1575     JSValue inValue = in;
1576     while (1) {
1577         switch (lexicalGlobalObject) {
1578             arrayStartState:
1579             case ArrayStartState: {
1580                 ASSERT(isArray(vm, inValue));
1581                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1582                     return SerializationReturnCode::StackOverflowError;
1583 
1584                 JSArray* inArray = asArray(inValue);
1585                 unsigned length = inArray-&gt;length();
1586                 if (!startArray(inArray))
1587                     break;
1588                 inputObjectStack.append(inArray);
1589                 indexStack.append(0);
1590                 lengthStack.append(length);
1591             }
1592             arrayStartVisitMember:
1593             FALLTHROUGH;
1594             case ArrayStartVisitMember: {
1595                 JSObject* array = inputObjectStack.last();
1596                 uint32_t index = indexStack.last();
1597                 if (index == lengthStack.last()) {
1598                     indexStack.removeLast();
1599                     lengthStack.removeLast();
1600 
1601                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
1602                     array-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(array, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());
1603                     if (propertyStack.last().size()) {
1604                         write(NonIndexPropertiesTag);
1605                         indexStack.append(0);
1606                         goto objectStartVisitMember;
1607                     }
1608                     propertyStack.removeLast();
1609 
1610                     endObject();
1611                     inputObjectStack.removeLast();
1612                     break;
1613                 }
1614                 inValue = array-&gt;getDirectIndex(m_lexicalGlobalObject, index);
1615                 if (!inValue) {
1616                     indexStack.last()++;
1617                     goto arrayStartVisitMember;
1618                 }
1619 
1620                 write(index);
1621                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1622                 if (dumpIfTerminal(inValue, terminalCode)) {
1623                     if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1624                         return terminalCode;
1625                     indexStack.last()++;
1626                     goto arrayStartVisitMember;
1627                 }
1628                 stateStack.append(ArrayEndVisitMember);
1629                 goto stateUnknown;
1630             }
1631             case ArrayEndVisitMember: {
1632                 indexStack.last()++;
1633                 goto arrayStartVisitMember;
1634             }
1635             objectStartState:
1636             case ObjectStartState: {
1637                 ASSERT(inValue.isObject());
1638                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1639                     return SerializationReturnCode::StackOverflowError;
1640                 JSObject* inObject = asObject(inValue);
1641                 if (!startObject(inObject))
1642                     break;
1643                 // At this point, all supported objects other than Object
1644                 // objects have been handled. If we reach this point and
1645                 // the input is not an Object object then we should throw
1646                 // a DataCloneError.
1647                 if (inObject-&gt;classInfo(vm) != JSFinalObject::info())
1648                     return SerializationReturnCode::DataCloneError;
1649                 inputObjectStack.append(inObject);
1650                 indexStack.append(0);
1651                 propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
1652                 inObject-&gt;methodTable(vm)-&gt;getOwnPropertyNames(inObject, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());
1653             }
1654             objectStartVisitMember:
1655             FALLTHROUGH;
1656             case ObjectStartVisitMember: {
1657                 JSObject* object = inputObjectStack.last();
1658                 uint32_t index = indexStack.last();
1659                 PropertyNameArray&amp; properties = propertyStack.last();
1660                 if (index == properties.size()) {
1661                     endObject();
1662                     inputObjectStack.removeLast();
1663                     indexStack.removeLast();
1664                     propertyStack.removeLast();
1665                     break;
1666                 }
1667                 inValue = getProperty(vm, object, properties[index]);
1668                 if (shouldTerminate())
1669                     return SerializationReturnCode::ExistingExceptionError;
1670 
1671                 if (!inValue) {
1672                     // Property was removed during serialisation
1673                     indexStack.last()++;
1674                     goto objectStartVisitMember;
1675                 }
1676                 write(properties[index]);
1677 
1678                 if (shouldTerminate())
1679                     return SerializationReturnCode::ExistingExceptionError;
1680 
1681                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1682                 if (!dumpIfTerminal(inValue, terminalCode)) {
1683                     stateStack.append(ObjectEndVisitMember);
1684                     goto stateUnknown;
1685                 }
1686                 if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1687                     return terminalCode;
1688                 FALLTHROUGH;
1689             }
1690             case ObjectEndVisitMember: {
1691                 if (shouldTerminate())
1692                     return SerializationReturnCode::ExistingExceptionError;
1693 
1694                 indexStack.last()++;
1695                 goto objectStartVisitMember;
1696             }
1697             mapStartState: {
1698                 ASSERT(inValue.isObject());
1699                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1700                     return SerializationReturnCode::StackOverflowError;
1701                 JSMap* inMap = jsCast&lt;JSMap*&gt;(inValue);
1702                 if (!startMap(inMap))
1703                     break;
1704                 JSMapIterator* iterator = JSMapIterator::create(vm, vm.mapIteratorStructure(), inMap, IterationKind::Entries);
1705                 m_gcBuffer.appendWithCrashOnOverflow(inMap);
1706                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1707                 mapIteratorStack.append(iterator);
1708                 inputObjectStack.append(inMap);
1709                 goto mapDataStartVisitEntry;
1710             }
1711             mapDataStartVisitEntry:
1712             case MapDataStartVisitEntry: {
1713                 JSMapIterator* iterator = mapIteratorStack.last();
1714                 JSValue key, value;
1715                 if (!iterator-&gt;nextKeyValue(m_lexicalGlobalObject, key, value)) {
1716                     mapIteratorStack.removeLast();
1717                     JSObject* object = inputObjectStack.last();
1718                     ASSERT(jsDynamicCast&lt;JSMap*&gt;(vm, object));
1719                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
1720                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());
1721                     write(NonMapPropertiesTag);
1722                     indexStack.append(0);
1723                     goto objectStartVisitMember;
1724                 }
1725                 inValue = key;
1726                 m_gcBuffer.appendWithCrashOnOverflow(value);
1727                 mapIteratorValueStack.append(value);
1728                 stateStack.append(MapDataEndVisitKey);
1729                 goto stateUnknown;
1730             }
1731             case MapDataEndVisitKey: {
1732                 inValue = mapIteratorValueStack.last();
1733                 mapIteratorValueStack.removeLast();
1734                 stateStack.append(MapDataEndVisitValue);
1735                 goto stateUnknown;
1736             }
1737             case MapDataEndVisitValue: {
1738                 goto mapDataStartVisitEntry;
1739             }
1740 
1741             setStartState: {
1742                 ASSERT(inValue.isObject());
1743                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1744                     return SerializationReturnCode::StackOverflowError;
1745                 JSSet* inSet = jsCast&lt;JSSet*&gt;(inValue);
1746                 if (!startSet(inSet))
1747                     break;
1748                 JSSetIterator* iterator = JSSetIterator::create(vm, vm.setIteratorStructure(), inSet, IterationKind::Keys);
1749                 m_gcBuffer.appendWithCrashOnOverflow(inSet);
1750                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1751                 setIteratorStack.append(iterator);
1752                 inputObjectStack.append(inSet);
1753                 goto setDataStartVisitEntry;
1754             }
1755             setDataStartVisitEntry:
1756             case SetDataStartVisitEntry: {
1757                 JSSetIterator* iterator = setIteratorStack.last();
1758                 JSValue key;
1759                 if (!iterator-&gt;next(m_lexicalGlobalObject, key)) {
1760                     setIteratorStack.removeLast();
1761                     JSObject* object = inputObjectStack.last();
1762                     ASSERT(jsDynamicCast&lt;JSSet*&gt;(vm, object));
1763                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
1764                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());
1765                     write(NonSetPropertiesTag);
1766                     indexStack.append(0);
1767                     goto objectStartVisitMember;
1768                 }
1769                 inValue = key;
1770                 stateStack.append(SetDataEndVisitKey);
1771                 goto stateUnknown;
1772             }
1773             case SetDataEndVisitKey: {
1774                 goto setDataStartVisitEntry;
1775             }
1776 
1777             stateUnknown:
1778             case StateUnknown: {
1779                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1780                 if (dumpIfTerminal(inValue, terminalCode)) {
1781                     if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1782                         return terminalCode;
1783                     break;
1784                 }
1785 
1786                 if (isArray(vm, inValue))
1787                     goto arrayStartState;
1788                 if (isMap(vm, inValue))
1789                     goto mapStartState;
1790                 if (isSet(vm, inValue))
1791                     goto setStartState;
1792                 goto objectStartState;
1793             }
1794         }
1795         if (stateStack.isEmpty())
1796             break;
1797 
1798         lexicalGlobalObject = stateStack.last();
1799         stateStack.removeLast();
1800     }
1801     if (m_failed)
1802         return SerializationReturnCode::UnspecifiedError;
1803 
1804     return SerializationReturnCode::SuccessfullyCompleted;
1805 }
1806 
1807 class CloneDeserializer : CloneBase {
1808 public:
1809     static String deserializeString(const Vector&lt;uint8_t&gt;&amp; buffer)
1810     {
1811         if (buffer.isEmpty())
1812             return String();
1813         const uint8_t* ptr = buffer.begin();
1814         const uint8_t* end = buffer.end();
1815         uint32_t version;
1816         if (!readLittleEndian(ptr, end, version) || version &gt; CurrentVersion)
1817             return String();
1818         uint8_t tag;
1819         if (!readLittleEndian(ptr, end, tag) || tag != StringTag)
1820             return String();
1821         uint32_t length;
1822         if (!readLittleEndian(ptr, end, length))
1823             return String();
1824         bool is8Bit = length &amp; StringDataIs8BitFlag;
1825         length &amp;= ~StringDataIs8BitFlag;
1826         String str;
1827         if (!readString(ptr, end, str, length, is8Bit))
1828             return String();
1829         return str;
1830     }
1831 
1832     static DeserializationResult deserialize(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers
1833 #if ENABLE(OFFSCREEN_CANVAS)
1834         , Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt;&amp;&amp; detachedOffscreenCanvases
1835 #endif
1836         , ArrayBufferContentsArray* arrayBufferContentsArray, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers
1837 #if ENABLE(WEBASSEMBLY)
1838         , WasmModuleArray* wasmModules
1839 #endif
1840         )
1841     {
1842         if (!buffer.size())
1843             return std::make_pair(jsNull(), SerializationReturnCode::UnspecifiedError);
1844         CloneDeserializer deserializer(lexicalGlobalObject, globalObject, messagePorts, arrayBufferContentsArray, buffer, blobURLs, blobFilePaths, sharedBuffers, WTFMove(imageBuffers)
1845 #if ENABLE(OFFSCREEN_CANVAS)
1846             , WTFMove(detachedOffscreenCanvases)
1847 #endif
1848 #if ENABLE(WEBASSEMBLY)
1849             , wasmModules
1850 #endif
1851             );
1852         if (!deserializer.isValid())
1853             return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
1854         return deserializer.deserialize();
1855     }
1856 
1857 private:
1858     struct CachedString {
1859         CachedString(const String&amp; string)
1860             : m_string(string)
1861         {
1862         }
1863 
1864         JSValue jsString(JSGlobalObject* lexicalGlobalObject)
1865         {
1866             if (!m_jsString)
1867                 m_jsString = JSC::jsString(lexicalGlobalObject-&gt;vm(), m_string);
1868             return m_jsString;
1869         }
1870         const String&amp; string() { return m_string; }
1871         String takeString() { return WTFMove(m_string); }
1872 
1873     private:
1874         String m_string;
1875         JSValue m_jsString;
1876     };
1877 
1878     struct CachedStringRef {
1879         CachedStringRef()
1880             : m_base(0)
1881             , m_index(0)
1882         {
1883         }
1884         CachedStringRef(Vector&lt;CachedString&gt;* base, size_t index)
1885             : m_base(base)
1886             , m_index(index)
1887         {
1888         }
1889 
1890         CachedString* operator-&gt;() { ASSERT(m_base); return &amp;m_base-&gt;at(m_index); }
1891 
1892     private:
1893         Vector&lt;CachedString&gt;* m_base;
1894         size_t m_index;
1895     };
1896 
1897     CloneDeserializer(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers, const Vector&lt;uint8_t&gt;&amp; buffer
1898 #if ENABLE(OFFSCREEN_CANVAS)
1899         , Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt;&amp;&amp; detachedOffscreenCanvases = { }
1900 #endif
1901 #if ENABLE(WEBASSEMBLY)
1902         , WasmModuleArray* wasmModules = nullptr
1903 #endif
1904         )
1905         : CloneBase(lexicalGlobalObject)
1906         , m_globalObject(globalObject)
1907         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1908         , m_ptr(buffer.data())
1909         , m_end(buffer.data() + buffer.size())
1910         , m_version(0xFFFFFFFF)
1911         , m_messagePorts(messagePorts)
1912         , m_arrayBufferContents(arrayBufferContents)
1913         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1914         , m_imageBuffers(WTFMove(imageBuffers))
1915         , m_imageBitmaps(m_imageBuffers.size())
1916 #if ENABLE(OFFSCREEN_CANVAS)
1917         , m_detachedOffscreenCanvases(WTFMove(detachedOffscreenCanvases))
1918         , m_offscreenCanvases(m_detachedOffscreenCanvases.size())
1919 #endif
1920 #if ENABLE(WEBASSEMBLY)
1921         , m_wasmModules(wasmModules)
1922 #endif
1923     {
1924         if (!read(m_version))
1925             m_version = 0xFFFFFFFF;
1926     }
1927 
1928     CloneDeserializer(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers
1929 #if ENABLE(OFFSCREEN_CANVAS)
1930         , Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt;&amp;&amp; detachedOffscreenCanvases
1931 #endif
1932 #if ENABLE(WEBASSEMBLY)
1933         , WasmModuleArray* wasmModules
1934 #endif
1935         )
1936         : CloneBase(lexicalGlobalObject)
1937         , m_globalObject(globalObject)
1938         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1939         , m_ptr(buffer.data())
1940         , m_end(buffer.data() + buffer.size())
1941         , m_version(0xFFFFFFFF)
1942         , m_messagePorts(messagePorts)
1943         , m_arrayBufferContents(arrayBufferContents)
1944         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1945         , m_blobURLs(blobURLs)
1946         , m_blobFilePaths(blobFilePaths)
1947         , m_sharedBuffers(sharedBuffers)
1948         , m_imageBuffers(WTFMove(imageBuffers))
1949         , m_imageBitmaps(m_imageBuffers.size())
1950 #if ENABLE(OFFSCREEN_CANVAS)
1951         , m_detachedOffscreenCanvases(WTFMove(detachedOffscreenCanvases))
1952         , m_offscreenCanvases(m_detachedOffscreenCanvases.size())
1953 #endif
1954 #if ENABLE(WEBASSEMBLY)
1955         , m_wasmModules(wasmModules)
1956 #endif
1957     {
1958         if (!read(m_version))
1959             m_version = 0xFFFFFFFF;
1960     }
1961 
1962     DeserializationResult deserialize();
1963 
1964     bool isValid() const { return m_version &lt;= CurrentVersion; }
1965 
1966     template &lt;typename T&gt; bool readLittleEndian(T&amp; value)
1967     {
1968         if (m_failed || !readLittleEndian(m_ptr, m_end, value)) {
1969             fail();
1970             return false;
1971         }
1972         return true;
1973     }
1974 #if ASSUME_LITTLE_ENDIAN
1975     template &lt;typename T&gt; static bool readLittleEndian(const uint8_t*&amp; ptr, const uint8_t* end, T&amp; value)
1976     {
1977         if (ptr &gt; end - sizeof(value))
1978             return false;
1979 
1980         if (sizeof(T) == 1)
1981             value = *ptr++;
1982         else {
1983             value = *reinterpret_cast&lt;const T*&gt;(ptr);
1984             ptr += sizeof(T);
1985         }
1986         return true;
1987     }
1988 #else
1989     template &lt;typename T&gt; static bool readLittleEndian(const uint8_t*&amp; ptr, const uint8_t* end, T&amp; value)
1990     {
1991         if (ptr &gt; end - sizeof(value))
1992             return false;
1993 
1994         if (sizeof(T) == 1)
1995             value = *ptr++;
1996         else {
1997             value = 0;
1998             for (unsigned i = 0; i &lt; sizeof(T); i++)
1999                 value += ((T)*ptr++) &lt;&lt; (i * 8);
2000         }
2001         return true;
2002     }
2003 #endif
2004 
2005     bool read(uint32_t&amp; i)
2006     {
2007         return readLittleEndian(i);
2008     }
2009 
2010     bool read(int32_t&amp; i)
2011     {
2012         return readLittleEndian(*reinterpret_cast&lt;uint32_t*&gt;(&amp;i));
2013     }
2014 
2015     bool read(uint16_t&amp; i)
2016     {
2017         return readLittleEndian(i);
2018     }
2019 
2020     bool read(uint8_t&amp; i)
2021     {
2022         return readLittleEndian(i);
2023     }
2024 
2025     bool read(double&amp; d)
2026     {
2027         union {
2028             double d;
2029             uint64_t i64;
2030         } u;
2031         if (!readLittleEndian(u.i64))
2032             return false;
2033         d = u.d;
2034         return true;
2035     }
2036 
2037     bool read(unsigned long long&amp; i)
2038     {
2039         return readLittleEndian(i);
2040     }
2041 
2042     bool readStringIndex(uint32_t&amp; i)
2043     {
2044         return readConstantPoolIndex(m_constantPool, i);
2045     }
2046 
2047     template &lt;class T&gt; bool readConstantPoolIndex(const T&amp; constantPool, uint32_t&amp; i)
2048     {
2049         if (constantPool.size() &lt;= 0xFF) {
2050             uint8_t i8;
2051             if (!read(i8))
2052                 return false;
2053             i = i8;
2054             return true;
2055         }
2056         if (constantPool.size() &lt;= 0xFFFF) {
2057             uint16_t i16;
2058             if (!read(i16))
2059                 return false;
2060             i = i16;
2061             return true;
2062         }
2063         return read(i);
2064     }
2065 
2066     static bool readString(const uint8_t*&amp; ptr, const uint8_t* end, String&amp; str, unsigned length, bool is8Bit)
2067     {
2068         if (length &gt;= std::numeric_limits&lt;int32_t&gt;::max() / sizeof(UChar))
2069             return false;
2070 
2071         if (is8Bit) {
2072             if ((end - ptr) &lt; static_cast&lt;int&gt;(length))
2073                 return false;
2074             str = String(reinterpret_cast&lt;const LChar*&gt;(ptr), length);
2075             ptr += length;
2076             return true;
2077         }
2078 
2079         unsigned size = length * sizeof(UChar);
2080         if ((end - ptr) &lt; static_cast&lt;int&gt;(size))
2081             return false;
2082 
2083 #if ASSUME_LITTLE_ENDIAN
2084         str = String(reinterpret_cast&lt;const UChar*&gt;(ptr), length);
2085         ptr += length * sizeof(UChar);
2086 #else
2087         Vector&lt;UChar&gt; buffer;
2088         buffer.reserveCapacity(length);
2089         for (unsigned i = 0; i &lt; length; i++) {
2090             uint16_t ch;
2091             readLittleEndian(ptr, end, ch);
2092             buffer.append(ch);
2093         }
2094         str = String::adopt(WTFMove(buffer));
2095 #endif
2096         return true;
2097     }
2098 
2099     bool readStringData(CachedStringRef&amp; cachedString)
2100     {
2101         bool scratch;
2102         return readStringData(cachedString, scratch);
2103     }
2104 
2105     bool readStringData(CachedStringRef&amp; cachedString, bool&amp; wasTerminator)
2106     {
2107         if (m_failed)
2108             return false;
2109         uint32_t length = 0;
2110         if (!read(length))
2111             return false;
2112         if (length == TerminatorTag) {
2113             wasTerminator = true;
2114             return false;
2115         }
2116         if (length == StringPoolTag) {
2117             unsigned index = 0;
2118             if (!readStringIndex(index)) {
2119                 fail();
2120                 return false;
2121             }
2122             if (index &gt;= m_constantPool.size()) {
2123                 fail();
2124                 return false;
2125             }
2126             cachedString = CachedStringRef(&amp;m_constantPool, index);
2127             return true;
2128         }
2129         bool is8Bit = length &amp; StringDataIs8BitFlag;
2130         length &amp;= ~StringDataIs8BitFlag;
2131         String str;
2132         if (!readString(m_ptr, m_end, str, length, is8Bit)) {
2133             fail();
2134             return false;
2135         }
2136         m_constantPool.append(str);
2137         cachedString = CachedStringRef(&amp;m_constantPool, m_constantPool.size() - 1);
2138         return true;
2139     }
2140 
2141     SerializationTag readTag()
2142     {
2143         if (m_ptr &gt;= m_end)
2144             return ErrorTag;
2145         return static_cast&lt;SerializationTag&gt;(*m_ptr++);
2146     }
2147 
2148     bool readArrayBufferViewSubtag(ArrayBufferViewSubtag&amp; tag)
2149     {
2150         if (m_ptr &gt;= m_end)
2151             return false;
2152         tag = static_cast&lt;ArrayBufferViewSubtag&gt;(*m_ptr++);
2153         return true;
2154     }
2155 
2156     void putProperty(JSObject* object, unsigned index, JSValue value)
2157     {
2158         object-&gt;putDirectIndex(m_lexicalGlobalObject, index, value);
2159     }
2160 
2161     void putProperty(JSObject* object, const Identifier&amp; property, JSValue value)
2162     {
2163         object-&gt;putDirectMayBeIndex(m_lexicalGlobalObject, property, value);
2164     }
2165 
2166     bool readFile(RefPtr&lt;File&gt;&amp; file)
2167     {
2168         CachedStringRef path;
2169         if (!readStringData(path))
2170             return false;
2171         CachedStringRef url;
2172         if (!readStringData(url))
2173             return false;
2174         CachedStringRef type;
2175         if (!readStringData(type))
2176             return false;
2177         CachedStringRef name;
2178         if (!readStringData(name))
2179             return false;
2180         Optional&lt;int64_t&gt; optionalLastModified;
2181         if (m_version &gt; 6) {
2182             double lastModified;
2183             if (!read(lastModified))
2184                 return false;
2185             if (lastModified &gt;= 0)
2186                 optionalLastModified = lastModified;
2187         }
2188 
2189         // If the blob URL for this file has an associated blob file path, prefer that one over the &quot;built-in&quot; path.
2190         String filePath = blobFilePathForBlobURL(url-&gt;string());
2191         if (filePath.isEmpty())
2192             filePath = path-&gt;string();
2193 
2194         if (m_isDOMGlobalObject)
2195             file = File::deserialize(filePath, URL(URL(), url-&gt;string()), type-&gt;string(), name-&gt;string(), optionalLastModified);
2196         return true;
2197     }
2198 
2199     bool readArrayBuffer(RefPtr&lt;ArrayBuffer&gt;&amp; arrayBuffer)
2200     {
2201         uint32_t length;
2202         if (!read(length))
2203             return false;
2204         if (m_ptr + length &gt; m_end)
2205             return false;
2206         arrayBuffer = ArrayBuffer::create(m_ptr, length);
2207         m_ptr += length;
2208         return true;
2209     }
2210 
2211     bool readArrayBufferView(VM&amp; vm, JSValue&amp; arrayBufferView)
2212     {
2213         ArrayBufferViewSubtag arrayBufferViewSubtag;
2214         if (!readArrayBufferViewSubtag(arrayBufferViewSubtag))
2215             return false;
2216         uint32_t byteOffset;
2217         if (!read(byteOffset))
2218             return false;
2219         uint32_t byteLength;
2220         if (!read(byteLength))
2221             return false;
2222         JSObject* arrayBufferObj = asObject(readTerminal());
2223         if (!arrayBufferObj || !arrayBufferObj-&gt;inherits&lt;JSArrayBuffer&gt;(vm))
2224             return false;
2225 
2226         unsigned elementSize = typedArrayElementSize(arrayBufferViewSubtag);
2227         if (!elementSize)
2228             return false;
2229         unsigned length = byteLength / elementSize;
2230         if (length * elementSize != byteLength)
2231             return false;
2232 
2233         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = toPossiblySharedArrayBuffer(vm, arrayBufferObj);
2234         switch (arrayBufferViewSubtag) {
2235         case DataViewTag:
2236             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, DataView::create(WTFMove(arrayBuffer), byteOffset, length).get());
2237             return true;
2238         case Int8ArrayTag:
2239             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Int8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2240             return true;
2241         case Uint8ArrayTag:
2242             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2243             return true;
2244         case Uint8ClampedArrayTag:
2245             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2246             return true;
2247         case Int16ArrayTag:
2248             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Int16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2249             return true;
2250         case Uint16ArrayTag:
2251             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2252             return true;
2253         case Int32ArrayTag:
2254             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Int32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2255             return true;
2256         case Uint32ArrayTag:
2257             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2258             return true;
2259         case Float32ArrayTag:
2260             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Float32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2261             return true;
2262         case Float64ArrayTag:
2263             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Float64Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2264             return true;
2265         default:
2266             return false;
2267         }
2268     }
2269 
2270     bool read(Vector&lt;uint8_t&gt;&amp; result)
2271     {
2272         ASSERT(result.isEmpty());
2273         uint32_t size;
2274         if (!read(size))
2275             return false;
2276         if (m_ptr + size &gt; m_end)
2277             return false;
2278         result.append(m_ptr, size);
2279         m_ptr += size;
2280         return true;
2281     }
2282 
2283 #if ENABLE(WEB_CRYPTO)
2284     bool read(CryptoAlgorithmIdentifier&amp; result)
2285     {
2286         uint8_t algorithmTag;
2287         if (!read(algorithmTag))
2288             return false;
2289         if (algorithmTag &gt; cryptoAlgorithmIdentifierTagMaximumValue)
2290             return false;
2291         switch (static_cast&lt;CryptoAlgorithmIdentifierTag&gt;(algorithmTag)) {
2292         case CryptoAlgorithmIdentifierTag::RSAES_PKCS1_v1_5:
2293             result = CryptoAlgorithmIdentifier::RSAES_PKCS1_v1_5;
2294             break;
2295         case CryptoAlgorithmIdentifierTag::RSASSA_PKCS1_v1_5:
2296             result = CryptoAlgorithmIdentifier::RSASSA_PKCS1_v1_5;
2297             break;
2298         case CryptoAlgorithmIdentifierTag::RSA_PSS:
2299             result = CryptoAlgorithmIdentifier::RSA_PSS;
2300             break;
2301         case CryptoAlgorithmIdentifierTag::RSA_OAEP:
2302             result = CryptoAlgorithmIdentifier::RSA_OAEP;
2303             break;
2304         case CryptoAlgorithmIdentifierTag::ECDSA:
2305             result = CryptoAlgorithmIdentifier::ECDSA;
2306             break;
2307         case CryptoAlgorithmIdentifierTag::ECDH:
2308             result = CryptoAlgorithmIdentifier::ECDH;
2309             break;
2310         case CryptoAlgorithmIdentifierTag::AES_CTR:
2311             result = CryptoAlgorithmIdentifier::AES_CTR;
2312             break;
2313         case CryptoAlgorithmIdentifierTag::AES_CBC:
2314             result = CryptoAlgorithmIdentifier::AES_CBC;
2315             break;
2316         case CryptoAlgorithmIdentifierTag::AES_GCM:
2317             result = CryptoAlgorithmIdentifier::AES_GCM;
2318             break;
2319         case CryptoAlgorithmIdentifierTag::AES_CFB:
2320             result = CryptoAlgorithmIdentifier::AES_CFB;
2321             break;
2322         case CryptoAlgorithmIdentifierTag::AES_KW:
2323             result = CryptoAlgorithmIdentifier::AES_KW;
2324             break;
2325         case CryptoAlgorithmIdentifierTag::HMAC:
2326             result = CryptoAlgorithmIdentifier::HMAC;
2327             break;
2328         case CryptoAlgorithmIdentifierTag::SHA_1:
2329             result = CryptoAlgorithmIdentifier::SHA_1;
2330             break;
2331         case CryptoAlgorithmIdentifierTag::SHA_224:
2332             result = CryptoAlgorithmIdentifier::SHA_224;
2333             break;
2334         case CryptoAlgorithmIdentifierTag::SHA_256:
2335             result = CryptoAlgorithmIdentifier::SHA_256;
2336             break;
2337         case CryptoAlgorithmIdentifierTag::SHA_384:
2338             result = CryptoAlgorithmIdentifier::SHA_384;
2339             break;
2340         case CryptoAlgorithmIdentifierTag::SHA_512:
2341             result = CryptoAlgorithmIdentifier::SHA_512;
2342             break;
2343         case CryptoAlgorithmIdentifierTag::HKDF:
2344             result = CryptoAlgorithmIdentifier::HKDF;
2345             break;
2346         case CryptoAlgorithmIdentifierTag::PBKDF2:
2347             result = CryptoAlgorithmIdentifier::PBKDF2;
2348             break;
2349         }
2350         return true;
2351     }
2352 
2353     bool read(CryptoKeyClassSubtag&amp; result)
2354     {
2355         uint8_t tag;
2356         if (!read(tag))
2357             return false;
2358         if (tag &gt; cryptoKeyClassSubtagMaximumValue)
2359             return false;
2360         result = static_cast&lt;CryptoKeyClassSubtag&gt;(tag);
2361         return true;
2362     }
2363 
2364     bool read(CryptoKeyUsageTag&amp; result)
2365     {
2366         uint8_t tag;
2367         if (!read(tag))
2368             return false;
2369         if (tag &gt; cryptoKeyUsageTagMaximumValue)
2370             return false;
2371         result = static_cast&lt;CryptoKeyUsageTag&gt;(tag);
2372         return true;
2373     }
2374 
2375     bool read(CryptoKeyAsymmetricTypeSubtag&amp; result)
2376     {
2377         uint8_t tag;
2378         if (!read(tag))
2379             return false;
2380         if (tag &gt; cryptoKeyAsymmetricTypeSubtagMaximumValue)
2381             return false;
2382         result = static_cast&lt;CryptoKeyAsymmetricTypeSubtag&gt;(tag);
2383         return true;
2384     }
2385 
2386     bool readHMACKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2387     {
2388         Vector&lt;uint8_t&gt; keyData;
2389         if (!read(keyData))
2390             return false;
2391         CryptoAlgorithmIdentifier hash;
2392         if (!read(hash))
2393             return false;
2394         result = CryptoKeyHMAC::importRaw(0, hash, WTFMove(keyData), extractable, usages);
2395         return true;
2396     }
2397 
2398     bool readAESKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2399     {
2400         CryptoAlgorithmIdentifier algorithm;
2401         if (!read(algorithm))
2402             return false;
2403         if (!CryptoKeyAES::isValidAESAlgorithm(algorithm))
2404             return false;
2405         Vector&lt;uint8_t&gt; keyData;
2406         if (!read(keyData))
2407             return false;
2408         result = CryptoKeyAES::importRaw(algorithm, WTFMove(keyData), extractable, usages);
2409         return true;
2410     }
2411 
2412     bool readRSAKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2413     {
2414         CryptoAlgorithmIdentifier algorithm;
2415         if (!read(algorithm))
2416             return false;
2417 
2418         int32_t isRestrictedToHash;
2419         CryptoAlgorithmIdentifier hash = CryptoAlgorithmIdentifier::SHA_1;
2420         if (!read(isRestrictedToHash))
2421             return false;
2422         if (isRestrictedToHash &amp;&amp; !read(hash))
2423             return false;
2424 
2425         CryptoKeyAsymmetricTypeSubtag type;
2426         if (!read(type))
2427             return false;
2428 
2429         Vector&lt;uint8_t&gt; modulus;
2430         if (!read(modulus))
2431             return false;
2432         Vector&lt;uint8_t&gt; exponent;
2433         if (!read(exponent))
2434             return false;
2435 
2436         if (type == CryptoKeyAsymmetricTypeSubtag::Public) {
2437             auto keyData = CryptoKeyRSAComponents::createPublic(modulus, exponent);
2438             auto key = CryptoKeyRSA::create(algorithm, hash, isRestrictedToHash, *keyData, extractable, usages);
2439             result = WTFMove(key);
2440             return true;
2441         }
2442 
2443         Vector&lt;uint8_t&gt; privateExponent;
2444         if (!read(privateExponent))
2445             return false;
2446 
2447         uint32_t primeCount;
2448         if (!read(primeCount))
2449             return false;
2450 
2451         if (!primeCount) {
2452             auto keyData = CryptoKeyRSAComponents::createPrivate(modulus, exponent, privateExponent);
2453             auto key = CryptoKeyRSA::create(algorithm, hash, isRestrictedToHash, *keyData, extractable, usages);
2454             result = WTFMove(key);
2455             return true;
2456         }
2457 
2458         if (primeCount &lt; 2)
2459             return false;
2460 
2461         CryptoKeyRSAComponents::PrimeInfo firstPrimeInfo;
2462         CryptoKeyRSAComponents::PrimeInfo secondPrimeInfo;
2463         Vector&lt;CryptoKeyRSAComponents::PrimeInfo&gt; otherPrimeInfos(primeCount - 2);
2464 
2465         if (!read(firstPrimeInfo.primeFactor))
2466             return false;
2467         if (!read(firstPrimeInfo.factorCRTExponent))
2468             return false;
2469         if (!read(secondPrimeInfo.primeFactor))
2470             return false;
2471         if (!read(secondPrimeInfo.factorCRTExponent))
2472             return false;
2473         if (!read(secondPrimeInfo.factorCRTCoefficient))
2474             return false;
2475         for (unsigned i = 2; i &lt; primeCount; ++i) {
2476             if (!read(otherPrimeInfos[i].primeFactor))
2477                 return false;
2478             if (!read(otherPrimeInfos[i].factorCRTExponent))
2479                 return false;
2480             if (!read(otherPrimeInfos[i].factorCRTCoefficient))
2481                 return false;
2482         }
2483 
2484         auto keyData = CryptoKeyRSAComponents::createPrivateWithAdditionalData(modulus, exponent, privateExponent, firstPrimeInfo, secondPrimeInfo, otherPrimeInfos);
2485         auto key = CryptoKeyRSA::create(algorithm, hash, isRestrictedToHash, *keyData, extractable, usages);
2486         result = WTFMove(key);
2487         return true;
2488     }
2489 
2490     bool readECKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2491     {
2492         CryptoAlgorithmIdentifier algorithm;
2493         if (!read(algorithm))
2494             return false;
2495         if (!CryptoKeyEC::isValidECAlgorithm(algorithm))
2496             return false;
2497         CachedStringRef curve;
2498         if (!readStringData(curve))
2499             return false;
2500         CryptoKeyAsymmetricTypeSubtag type;
2501         if (!read(type))
2502             return false;
2503         Vector&lt;uint8_t&gt; keyData;
2504         if (!read(keyData))
2505             return false;
2506 
2507         switch (type) {
2508         case CryptoKeyAsymmetricTypeSubtag::Public:
2509             result = CryptoKeyEC::importRaw(algorithm, curve-&gt;string(), WTFMove(keyData), extractable, usages);
2510             break;
2511         case CryptoKeyAsymmetricTypeSubtag::Private:
2512             result = CryptoKeyEC::importPkcs8(algorithm, curve-&gt;string(), WTFMove(keyData), extractable, usages);
2513             break;
2514         }
2515 
2516         return true;
2517     }
2518 
2519     bool readRawKey(CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2520     {
2521         CryptoAlgorithmIdentifier algorithm;
2522         if (!read(algorithm))
2523             return false;
2524         Vector&lt;uint8_t&gt; keyData;
2525         if (!read(keyData))
2526             return false;
2527         result = CryptoKeyRaw::create(algorithm, WTFMove(keyData), usages);
2528         return true;
2529     }
2530 
2531     bool readCryptoKey(JSValue&amp; cryptoKey)
2532     {
2533         uint32_t keyFormatVersion;
2534         if (!read(keyFormatVersion) || keyFormatVersion &gt; currentKeyFormatVersion)
2535             return false;
2536 
2537         int32_t extractable;
2538         if (!read(extractable))
2539             return false;
2540 
2541         uint32_t usagesCount;
2542         if (!read(usagesCount))
2543             return false;
2544 
2545         CryptoKeyUsageBitmap usages = 0;
2546         for (uint32_t i = 0; i &lt; usagesCount; ++i) {
2547             CryptoKeyUsageTag usage;
2548             if (!read(usage))
2549                 return false;
2550             switch (usage) {
2551             case CryptoKeyUsageTag::Encrypt:
2552                 usages |= CryptoKeyUsageEncrypt;
2553                 break;
2554             case CryptoKeyUsageTag::Decrypt:
2555                 usages |= CryptoKeyUsageDecrypt;
2556                 break;
2557             case CryptoKeyUsageTag::Sign:
2558                 usages |= CryptoKeyUsageSign;
2559                 break;
2560             case CryptoKeyUsageTag::Verify:
2561                 usages |= CryptoKeyUsageVerify;
2562                 break;
2563             case CryptoKeyUsageTag::DeriveKey:
2564                 usages |= CryptoKeyUsageDeriveKey;
2565                 break;
2566             case CryptoKeyUsageTag::DeriveBits:
2567                 usages |= CryptoKeyUsageDeriveBits;
2568                 break;
2569             case CryptoKeyUsageTag::WrapKey:
2570                 usages |= CryptoKeyUsageWrapKey;
2571                 break;
2572             case CryptoKeyUsageTag::UnwrapKey:
2573                 usages |= CryptoKeyUsageUnwrapKey;
2574                 break;
2575             }
2576         }
2577 
2578         CryptoKeyClassSubtag cryptoKeyClass;
2579         if (!read(cryptoKeyClass))
2580             return false;
2581         RefPtr&lt;CryptoKey&gt; result;
2582         switch (cryptoKeyClass) {
2583         case CryptoKeyClassSubtag::HMAC:
2584             if (!readHMACKey(extractable, usages, result))
2585                 return false;
2586             break;
2587         case CryptoKeyClassSubtag::AES:
2588             if (!readAESKey(extractable, usages, result))
2589                 return false;
2590             break;
2591         case CryptoKeyClassSubtag::RSA:
2592             if (!readRSAKey(extractable, usages, result))
2593                 return false;
2594             break;
2595         case CryptoKeyClassSubtag::EC:
2596             if (!readECKey(extractable, usages, result))
2597                 return false;
2598             break;
2599         case CryptoKeyClassSubtag::Raw:
2600             if (!readRawKey(usages, result))
2601                 return false;
2602             break;
2603         }
2604         cryptoKey = getJSValue(result.get());
2605         return true;
2606     }
2607 #endif
2608 
2609     template&lt;class T&gt;
2610     JSValue getJSValue(T* nativeObj)
2611     {
2612         return toJS(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);
2613     }
2614 
2615     template&lt;class T&gt;
2616     JSValue getJSValue(T&amp; nativeObj)
2617     {
2618         return toJS(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);
2619     }
2620 
2621     template&lt;class T&gt;
2622     JSValue readDOMPoint()
2623     {
2624         double x;
2625         if (!read(x))
2626             return { };
2627         double y;
2628         if (!read(y))
2629             return { };
2630         double z;
2631         if (!read(z))
2632             return { };
2633         double w;
2634         if (!read(w))
2635             return { };
2636 
2637         return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, z, w));
2638     }
2639 
2640     template&lt;class T&gt;
2641     JSValue readDOMMatrix()
2642     {
2643         uint8_t is2D;
2644         if (!read(is2D))
2645             return { };
2646 
2647         if (is2D) {
2648             double m11;
2649             if (!read(m11))
2650                 return { };
2651             double m12;
2652             if (!read(m12))
2653                 return { };
2654             double m21;
2655             if (!read(m21))
2656                 return { };
2657             double m22;
2658             if (!read(m22))
2659                 return { };
2660             double m41;
2661             if (!read(m41))
2662                 return { };
2663             double m42;
2664             if (!read(m42))
2665                 return { };
2666 
2667             TransformationMatrix matrix(m11, m12, m21, m22, m41, m42);
2668             return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::Yes));
2669         } else {
2670             double m11;
2671             if (!read(m11))
2672                 return { };
2673             double m12;
2674             if (!read(m12))
2675                 return { };
2676             double m13;
2677             if (!read(m13))
2678                 return { };
2679             double m14;
2680             if (!read(m14))
2681                 return { };
2682             double m21;
2683             if (!read(m21))
2684                 return { };
2685             double m22;
2686             if (!read(m22))
2687                 return { };
2688             double m23;
2689             if (!read(m23))
2690                 return { };
2691             double m24;
2692             if (!read(m24))
2693                 return { };
2694             double m31;
2695             if (!read(m31))
2696                 return { };
2697             double m32;
2698             if (!read(m32))
2699                 return { };
2700             double m33;
2701             if (!read(m33))
2702                 return { };
2703             double m34;
2704             if (!read(m34))
2705                 return { };
2706             double m41;
2707             if (!read(m41))
2708                 return { };
2709             double m42;
2710             if (!read(m42))
2711                 return { };
2712             double m43;
2713             if (!read(m43))
2714                 return { };
2715             double m44;
2716             if (!read(m44))
2717                 return { };
2718 
2719             TransformationMatrix matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
2720             return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::No));
2721         }
2722     }
2723 
2724     template&lt;class T&gt;
2725     JSValue readDOMRect()
2726     {
2727         double x;
2728         if (!read(x))
2729             return { };
2730         double y;
2731         if (!read(y))
2732             return { };
2733         double width;
2734         if (!read(width))
2735             return { };
2736         double height;
2737         if (!read(height))
2738             return { };
2739 
2740         return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, width, height));
2741     }
2742 
2743     Optional&lt;DOMPointInit&gt; readDOMPointInit()
2744     {
2745         DOMPointInit point;
2746         if (!read(point.x))
2747             return WTF::nullopt;
2748         if (!read(point.y))
2749             return WTF::nullopt;
2750         if (!read(point.z))
2751             return WTF::nullopt;
2752         if (!read(point.w))
2753             return WTF::nullopt;
2754 
2755         return point;
2756     }
2757 
2758     JSValue readDOMQuad()
2759     {
2760         auto p1 = readDOMPointInit();
2761         if (!p1)
2762             return JSValue();
2763         auto p2 = readDOMPointInit();
2764         if (!p2)
2765             return JSValue();
2766         auto p3 = readDOMPointInit();
2767         if (!p3)
2768             return JSValue();
2769         auto p4 = readDOMPointInit();
2770         if (!p4)
2771             return JSValue();
2772 
2773         return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), DOMQuad::create(p1.value(), p2.value(), p3.value(), p4.value()));
2774     }
2775 
2776     JSValue readTransferredImageBitmap()
2777     {
2778         uint32_t index;
2779         bool indexSuccessfullyRead = read(index);
2780         if (!indexSuccessfullyRead || index &gt;= m_imageBuffers.size()) {
2781             fail();
2782             return JSValue();
2783         }
2784 
2785         if (!m_imageBitmaps[index])
2786             m_imageBitmaps[index] = ImageBitmap::create(WTFMove(m_imageBuffers.at(index)));
2787 
2788         auto bitmap = m_imageBitmaps[index].get();
2789         return getJSValue(bitmap);
2790     }
2791 
2792 #if ENABLE(OFFSCREEN_CANVAS)
2793     JSValue readOffscreenCanvas()
2794     {
2795         uint32_t index;
2796         bool indexSuccessfullyRead = read(index);
2797         if (!indexSuccessfullyRead || index &gt;= m_detachedOffscreenCanvases.size()) {
2798             fail();
2799             return JSValue();
2800         }
2801 
2802         if (!m_offscreenCanvases[index])
2803             m_offscreenCanvases[index] = OffscreenCanvas::create(*scriptExecutionContextFromExecState(m_lexicalGlobalObject), WTFMove(m_detachedOffscreenCanvases.at(index)));
2804 
2805         auto offscreenCanvas = m_offscreenCanvases[index].get();
2806         return getJSValue(offscreenCanvas);
2807     }
2808 #endif
2809 
2810 #if ENABLE(WEB_RTC)
2811     JSValue readRTCCertificate()
2812     {
2813         double expires;
2814         if (!read(expires)) {
2815             fail();
2816             return JSValue();
2817         }
2818         CachedStringRef certificate;
2819         if (!readStringData(certificate)) {
2820             fail();
2821             return JSValue();
2822         }
2823         CachedStringRef origin;
2824         if (!readStringData(origin)) {
2825             fail();
2826             return JSValue();
2827         }
2828         CachedStringRef keyedMaterial;
2829         if (!readStringData(keyedMaterial)) {
2830             fail();
2831             return JSValue();
2832         }
2833         unsigned size = 0;
2834         if (!read(size))
2835             return JSValue();
2836 
2837         Vector&lt;RTCCertificate::DtlsFingerprint&gt; fingerprints;
2838         fingerprints.reserveInitialCapacity(size);
2839         for (unsigned i = 0; i &lt; size; i++) {
2840             CachedStringRef algorithm;
2841             if (!readStringData(algorithm))
2842                 return JSValue();
2843             CachedStringRef value;
2844             if (!readStringData(value))
2845                 return JSValue();
2846             fingerprints.uncheckedAppend(RTCCertificate::DtlsFingerprint { algorithm-&gt;string(), value-&gt;string() });
2847         }
2848 
2849         if (!m_isDOMGlobalObject)
2850             return constructEmptyObject(m_lexicalGlobalObject, m_globalObject-&gt;objectPrototype());
2851 
2852         auto rtcCertificate = RTCCertificate::create(SecurityOrigin::createFromString(origin-&gt;string()), expires, WTFMove(fingerprints), certificate-&gt;takeString(), keyedMaterial-&gt;takeString());
2853         return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), WTFMove(rtcCertificate));
2854     }
2855 #endif
2856 
2857     JSValue readImageBitmap()
2858     {
2859         uint8_t originClean;
2860         int32_t logicalWidth;
2861         int32_t logicalHeight;
2862         double resolutionScale;
2863         RefPtr&lt;ArrayBuffer&gt; arrayBuffer;
2864 
2865         if (!read(originClean) || !read(logicalWidth) || !read(logicalHeight) || !read(resolutionScale) || !readArrayBuffer(arrayBuffer)) {
2866             fail();
2867             return JSValue();
2868         }
2869 
2870         auto imageData = Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), 0, arrayBuffer-&gt;byteLength());
2871         if (!imageData) {
2872             fail();
2873             return JSValue();
2874         }
2875 
2876         auto buffer = ImageBuffer::create(FloatSize(logicalWidth, logicalHeight), RenderingMode::Unaccelerated, resolutionScale);
2877         if (!buffer) {
2878             fail();
2879             return JSValue();
2880         }
2881 
2882         buffer-&gt;putByteArray(*imageData, AlphaPremultiplication::Premultiplied, IntSize(logicalWidth, logicalHeight), IntRect(0, 0, logicalWidth, logicalHeight), IntPoint());
2883 
2884         auto bitmap = ImageBitmap::create({ WTFMove(buffer), static_cast&lt;bool&gt;(originClean) });
2885         return getJSValue(bitmap);
2886     }
2887 
2888     JSValue readTerminal()
2889     {
2890         SerializationTag tag = readTag();
2891         switch (tag) {
2892         case UndefinedTag:
2893             return jsUndefined();
2894         case NullTag:
2895             return jsNull();
2896         case IntTag: {
2897             int32_t i;
2898             if (!read(i))
2899                 return JSValue();
2900             return jsNumber(i);
2901         }
2902         case ZeroTag:
2903             return jsNumber(0);
2904         case OneTag:
2905             return jsNumber(1);
2906         case FalseTag:
2907             return jsBoolean(false);
2908         case TrueTag:
2909             return jsBoolean(true);
2910         case FalseObjectTag: {
2911             BooleanObject* obj = BooleanObject::create(m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());
2912             obj-&gt;setInternalValue(m_lexicalGlobalObject-&gt;vm(), jsBoolean(false));
2913             m_gcBuffer.appendWithCrashOnOverflow(obj);
2914             return obj;
2915         }
2916         case TrueObjectTag: {
2917             BooleanObject* obj = BooleanObject::create(m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());
2918             obj-&gt;setInternalValue(m_lexicalGlobalObject-&gt;vm(), jsBoolean(true));
2919             m_gcBuffer.appendWithCrashOnOverflow(obj);
2920             return obj;
2921         }
2922         case DoubleTag: {
2923             double d;
2924             if (!read(d))
2925                 return JSValue();
2926             return jsNumber(d);
2927         }
2928         case NumberObjectTag: {
2929             double d;
2930             if (!read(d))
2931                 return JSValue();
2932             NumberObject* obj = constructNumber(m_globalObject, jsNumber(d));
2933             m_gcBuffer.appendWithCrashOnOverflow(obj);
2934             return obj;
2935         }
2936         case DateTag: {
2937             double d;
2938             if (!read(d))
2939                 return JSValue();
2940             return DateInstance::create(m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;dateStructure(), d);
2941         }
2942         case FileTag: {
2943             RefPtr&lt;File&gt; file;
2944             if (!readFile(file))
2945                 return JSValue();
2946             if (!m_isDOMGlobalObject)
2947                 return jsNull();
2948             return toJS(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), file.get());
2949         }
2950         case FileListTag: {
2951             unsigned length = 0;
2952             if (!read(length))
2953                 return JSValue();
2954             Vector&lt;Ref&lt;File&gt;&gt; files;
2955             for (unsigned i = 0; i &lt; length; i++) {
2956                 RefPtr&lt;File&gt; file;
2957                 if (!readFile(file))
2958                     return JSValue();
2959                 if (m_isDOMGlobalObject)
2960                     files.append(file.releaseNonNull());
2961             }
2962             if (!m_isDOMGlobalObject)
2963                 return jsNull();
2964             return getJSValue(FileList::create(WTFMove(files)).get());
2965         }
2966         case ImageDataTag: {
2967             uint32_t width;
2968             if (!read(width))
2969                 return JSValue();
2970             uint32_t height;
2971             if (!read(height))
2972                 return JSValue();
2973             uint32_t length;
2974             if (!read(length))
2975                 return JSValue();
2976             if (static_cast&lt;uint32_t&gt;(m_end - m_ptr) &lt; length) {
2977                 fail();
2978                 return JSValue();
2979             }
2980             if (!m_isDOMGlobalObject) {
2981                 m_ptr += length;
2982                 return jsNull();
2983             }
2984             IntSize imageSize(width, height);
2985             RELEASE_ASSERT(!length || (imageSize.area() * 4).unsafeGet() &lt;= length);
2986             auto result = ImageData::create(imageSize);
2987             if (!result) {
2988                 fail();
2989                 return JSValue();
2990             }
2991             if (length)
2992                 memcpy(result-&gt;data()-&gt;data(), m_ptr, length);
2993             else
2994                 result-&gt;data()-&gt;zeroFill();
2995             m_ptr += length;
2996             return getJSValue(result.get());
2997         }
2998         case BlobTag: {
2999             CachedStringRef url;
3000             if (!readStringData(url))
3001                 return JSValue();
3002             CachedStringRef type;
3003             if (!readStringData(type))
3004                 return JSValue();
3005             unsigned long long size = 0;
3006             if (!read(size))
3007                 return JSValue();
3008             if (!m_isDOMGlobalObject)
3009                 return jsNull();
3010             return getJSValue(Blob::deserialize(URL(URL(), url-&gt;string()), type-&gt;string(), size, blobFilePathForBlobURL(url-&gt;string())).get());
3011         }
3012         case StringTag: {
3013             CachedStringRef cachedString;
3014             if (!readStringData(cachedString))
3015                 return JSValue();
3016             return cachedString-&gt;jsString(m_lexicalGlobalObject);
3017         }
3018         case EmptyStringTag:
3019             return jsEmptyString(m_lexicalGlobalObject-&gt;vm());
3020         case StringObjectTag: {
3021             CachedStringRef cachedString;
3022             if (!readStringData(cachedString))
3023                 return JSValue();
3024             StringObject* obj = constructString(m_lexicalGlobalObject-&gt;vm(), m_globalObject, cachedString-&gt;jsString(m_lexicalGlobalObject));
3025             m_gcBuffer.appendWithCrashOnOverflow(obj);
3026             return obj;
3027         }
3028         case EmptyStringObjectTag: {
3029             VM&amp; vm = m_lexicalGlobalObject-&gt;vm();
3030             StringObject* obj = constructString(vm, m_globalObject, jsEmptyString(vm));
3031             m_gcBuffer.appendWithCrashOnOverflow(obj);
3032             return obj;
3033         }
3034         case RegExpTag: {
3035             CachedStringRef pattern;
3036             if (!readStringData(pattern))
3037                 return JSValue();
3038             CachedStringRef flags;
3039             if (!readStringData(flags))
3040                 return JSValue();
3041             auto reFlags = Yarr::parseFlags(flags-&gt;string());
3042             ASSERT(reFlags.hasValue());
3043             VM&amp; vm = m_lexicalGlobalObject-&gt;vm();
3044             RegExp* regExp = RegExp::create(vm, pattern-&gt;string(), reFlags.value());
3045             return RegExpObject::create(vm, m_globalObject-&gt;regExpStructure(), regExp);
3046         }
3047         case ObjectReferenceTag: {
3048             unsigned index = 0;
3049             if (!readConstantPoolIndex(m_gcBuffer, index)) {
3050                 fail();
3051                 return JSValue();
3052             }
3053             return m_gcBuffer.at(index);
3054         }
3055         case MessagePortReferenceTag: {
3056             uint32_t index;
3057             bool indexSuccessfullyRead = read(index);
3058             if (!indexSuccessfullyRead || index &gt;= m_messagePorts.size()) {
3059                 fail();
3060                 return JSValue();
3061             }
3062             return getJSValue(m_messagePorts[index].get());
3063         }
3064 #if ENABLE(WEBASSEMBLY)
3065         case WasmModuleTag: {
3066             uint32_t index;
3067             bool indexSuccessfullyRead = read(index);
3068             if (!indexSuccessfullyRead || !m_wasmModules || index &gt;= m_wasmModules-&gt;size()) {
3069                 fail();
3070                 return JSValue();
3071             }
3072             auto scope = DECLARE_THROW_SCOPE(m_lexicalGlobalObject-&gt;vm());
3073             JSValue result = JSC::JSWebAssemblyModule::createStub(m_lexicalGlobalObject-&gt;vm(), m_lexicalGlobalObject, m_globalObject-&gt;webAssemblyModuleStructure(), m_wasmModules-&gt;at(index));
3074             // Since we are cloning a JSWebAssemblyModule, it&#39;s impossible for that
3075             // module to not have been a valid module. Therefore, createStub should
3076             // not trow.
3077             scope.releaseAssertNoException();
3078             m_gcBuffer.appendWithCrashOnOverflow(result);
3079             return result;
3080         }
3081 #endif
3082         case ArrayBufferTag: {
3083             RefPtr&lt;ArrayBuffer&gt; arrayBuffer;
3084             if (!readArrayBuffer(arrayBuffer)) {
3085                 fail();
3086                 return JSValue();
3087             }
3088             Structure* structure = m_globalObject-&gt;arrayBufferStructure(arrayBuffer-&gt;sharingMode());
3089             // A crazy RuntimeFlags mismatch could mean that we are not equipped to handle shared
3090             // array buffers while the sender is. In that case, we would see a null structure here.
3091             if (!structure) {
3092                 fail();
3093                 return JSValue();
3094             }
3095             JSValue result = JSArrayBuffer::create(m_lexicalGlobalObject-&gt;vm(), structure, WTFMove(arrayBuffer));
3096             m_gcBuffer.appendWithCrashOnOverflow(result);
3097             return result;
3098         }
3099         case ArrayBufferTransferTag: {
3100             uint32_t index;
3101             bool indexSuccessfullyRead = read(index);
3102             if (!indexSuccessfullyRead || index &gt;= m_arrayBuffers.size()) {
3103                 fail();
3104                 return JSValue();
3105             }
3106 
3107             if (!m_arrayBuffers[index])
3108                 m_arrayBuffers[index] = ArrayBuffer::create(WTFMove(m_arrayBufferContents-&gt;at(index)));
3109 
3110             return getJSValue(m_arrayBuffers[index].get());
3111         }
3112         case SharedArrayBufferTag: {
3113             uint32_t index = UINT_MAX;
3114             bool indexSuccessfullyRead = read(index);
3115             if (!indexSuccessfullyRead || !m_sharedBuffers || index &gt;= m_sharedBuffers-&gt;size()) {
3116                 fail();
3117                 return JSValue();
3118             }
3119 
3120             RELEASE_ASSERT(m_sharedBuffers-&gt;at(index));
3121             auto buffer = ArrayBuffer::create(WTFMove(m_sharedBuffers-&gt;at(index)));
3122             JSValue result = getJSValue(buffer.get());
3123             m_gcBuffer.appendWithCrashOnOverflow(result);
3124             return result;
3125         }
3126         case ArrayBufferViewTag: {
3127             JSValue arrayBufferView;
3128             if (!readArrayBufferView(m_lexicalGlobalObject-&gt;vm(), arrayBufferView)) {
3129                 fail();
3130                 return JSValue();
3131             }
3132             m_gcBuffer.appendWithCrashOnOverflow(arrayBufferView);
3133             return arrayBufferView;
3134         }
3135 #if ENABLE(WEB_CRYPTO)
3136         case CryptoKeyTag: {
3137             Vector&lt;uint8_t&gt; wrappedKey;
3138             if (!read(wrappedKey)) {
3139                 fail();
3140                 return JSValue();
3141             }
3142             Vector&lt;uint8_t&gt; serializedKey;
3143             if (!unwrapCryptoKey(m_lexicalGlobalObject, wrappedKey, serializedKey)) {
3144                 fail();
3145                 return JSValue();
3146             }
3147             JSValue cryptoKey;
3148             Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
3149             CloneDeserializer rawKeyDeserializer(m_lexicalGlobalObject, m_globalObject, dummyMessagePorts, nullptr, { }, serializedKey);
3150             if (!rawKeyDeserializer.readCryptoKey(cryptoKey)) {
3151                 fail();
3152                 return JSValue();
3153             }
3154             m_gcBuffer.appendWithCrashOnOverflow(cryptoKey);
3155             return cryptoKey;
3156         }
3157 #endif
3158         case DOMPointReadOnlyTag:
3159             return readDOMPoint&lt;DOMPointReadOnly&gt;();
3160         case DOMPointTag:
3161             return readDOMPoint&lt;DOMPoint&gt;();
3162         case DOMRectReadOnlyTag:
3163             return readDOMRect&lt;DOMRectReadOnly&gt;();
3164         case DOMRectTag:
3165             return readDOMRect&lt;DOMRect&gt;();
3166         case DOMMatrixReadOnlyTag:
3167             return readDOMMatrix&lt;DOMMatrixReadOnly&gt;();
3168         case DOMMatrixTag:
3169             return readDOMMatrix&lt;DOMMatrix&gt;();
3170         case DOMQuadTag:
3171             return readDOMQuad();
3172         case ImageBitmapTransferTag:
3173             return readTransferredImageBitmap();
3174 #if ENABLE(WEB_RTC)
3175         case RTCCertificateTag:
3176             return readRTCCertificate();
3177 
3178 #endif
3179         case ImageBitmapTag:
3180             return readImageBitmap();
3181 #if ENABLE(OFFSCREEN_CANVAS)
3182         case OffscreenCanvasTransferTag:
3183             return readOffscreenCanvas();
3184 #endif
3185         default:
3186             m_ptr--; // Push the tag back
3187             return JSValue();
3188         }
3189     }
3190 
3191     template&lt;SerializationTag Tag&gt;
3192     bool consumeCollectionDataTerminationIfPossible()
3193     {
3194         if (readTag() == Tag)
3195             return true;
3196         m_ptr--;
3197         return false;
3198     }
3199 
3200     JSGlobalObject* m_globalObject;
3201     bool m_isDOMGlobalObject;
3202     const uint8_t* m_ptr;
3203     const uint8_t* m_end;
3204     unsigned m_version;
3205     Vector&lt;CachedString&gt; m_constantPool;
3206     const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; m_messagePorts;
3207     ArrayBufferContentsArray* m_arrayBufferContents;
3208     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; m_arrayBuffers;
3209     Vector&lt;String&gt; m_blobURLs;
3210     Vector&lt;String&gt; m_blobFilePaths;
3211     ArrayBufferContentsArray* m_sharedBuffers;
3212     Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt; m_imageBuffers;
3213     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; m_imageBitmaps;
3214 #if ENABLE(OFFSCREEN_CANVAS)
3215     Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt; m_detachedOffscreenCanvases;
3216     Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt; m_offscreenCanvases;
3217 #endif
3218 #if ENABLE(WEBASSEMBLY)
3219     WasmModuleArray* m_wasmModules;
3220 #endif
3221 
3222     String blobFilePathForBlobURL(const String&amp; blobURL)
3223     {
3224         size_t i = 0;
3225         for (; i &lt; m_blobURLs.size(); ++i) {
3226             if (m_blobURLs[i] == blobURL)
3227                 break;
3228         }
3229 
3230         return i &lt; m_blobURLs.size() ? m_blobFilePaths[i] : String();
3231     }
3232 };
3233 
3234 DeserializationResult CloneDeserializer::deserialize()
3235 {
3236     VM&amp; vm = m_lexicalGlobalObject-&gt;vm();
3237     auto scope = DECLARE_THROW_SCOPE(vm);
3238 
3239     Vector&lt;uint32_t, 16&gt; indexStack;
3240     Vector&lt;Identifier, 16&gt; propertyNameStack;
3241     Vector&lt;JSObject*, 32&gt; outputObjectStack;
3242     Vector&lt;JSValue, 4&gt; mapKeyStack;
3243     Vector&lt;JSMap*, 4&gt; mapStack;
3244     Vector&lt;JSSet*, 4&gt; setStack;
3245     Vector&lt;WalkerState, 16&gt; stateStack;
3246     WalkerState lexicalGlobalObject = StateUnknown;
3247     JSValue outValue;
3248 
3249     while (1) {
3250         switch (lexicalGlobalObject) {
3251         arrayStartState:
3252         case ArrayStartState: {
3253             uint32_t length;
3254             if (!read(length)) {
3255                 fail();
3256                 goto error;
3257             }
3258             JSArray* outArray = constructEmptyArray(m_globalObject, static_cast&lt;JSC::ArrayAllocationProfile*&gt;(nullptr), length);
3259             if (UNLIKELY(scope.exception()))
3260                 goto error;
3261             m_gcBuffer.appendWithCrashOnOverflow(outArray);
3262             outputObjectStack.append(outArray);
3263         }
3264         arrayStartVisitMember:
3265         FALLTHROUGH;
3266         case ArrayStartVisitMember: {
3267             uint32_t index;
3268             if (!read(index)) {
3269                 fail();
3270                 goto error;
3271             }
3272             if (index == TerminatorTag) {
3273                 JSObject* outArray = outputObjectStack.last();
3274                 outValue = outArray;
3275                 outputObjectStack.removeLast();
3276                 break;
3277             } else if (index == NonIndexPropertiesTag) {
3278                 goto objectStartVisitMember;
3279             }
3280 
3281             if (JSValue terminal = readTerminal()) {
3282                 putProperty(outputObjectStack.last(), index, terminal);
3283                 goto arrayStartVisitMember;
3284             }
3285             if (m_failed)
3286                 goto error;
3287             indexStack.append(index);
3288             stateStack.append(ArrayEndVisitMember);
3289             goto stateUnknown;
3290         }
3291         case ArrayEndVisitMember: {
3292             JSObject* outArray = outputObjectStack.last();
3293             putProperty(outArray, indexStack.last(), outValue);
3294             indexStack.removeLast();
3295             goto arrayStartVisitMember;
3296         }
3297         objectStartState:
3298         case ObjectStartState: {
3299             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3300                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
3301             JSObject* outObject = constructEmptyObject(m_lexicalGlobalObject, m_globalObject-&gt;objectPrototype());
3302             m_gcBuffer.appendWithCrashOnOverflow(outObject);
3303             outputObjectStack.append(outObject);
3304         }
3305         objectStartVisitMember:
3306         FALLTHROUGH;
3307         case ObjectStartVisitMember: {
3308             CachedStringRef cachedString;
3309             bool wasTerminator = false;
3310             if (!readStringData(cachedString, wasTerminator)) {
3311                 if (!wasTerminator)
3312                     goto error;
3313 
3314                 JSObject* outObject = outputObjectStack.last();
3315                 outValue = outObject;
3316                 outputObjectStack.removeLast();
3317                 break;
3318             }
3319 
3320             if (JSValue terminal = readTerminal()) {
3321                 putProperty(outputObjectStack.last(), Identifier::fromString(vm, cachedString-&gt;string()), terminal);
3322                 goto objectStartVisitMember;
3323             }
3324             stateStack.append(ObjectEndVisitMember);
3325             propertyNameStack.append(Identifier::fromString(vm, cachedString-&gt;string()));
3326             goto stateUnknown;
3327         }
3328         case ObjectEndVisitMember: {
3329             putProperty(outputObjectStack.last(), propertyNameStack.last(), outValue);
3330             propertyNameStack.removeLast();
3331             goto objectStartVisitMember;
3332         }
3333         mapObjectStartState: {
3334             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3335                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
3336             JSMap* map = JSMap::create(m_lexicalGlobalObject, m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;mapStructure());
3337             if (UNLIKELY(scope.exception()))
3338                 goto error;
3339             m_gcBuffer.appendWithCrashOnOverflow(map);
3340             outputObjectStack.append(map);
3341             mapStack.append(map);
3342             goto mapDataStartVisitEntry;
3343         }
3344         mapDataStartVisitEntry:
3345         case MapDataStartVisitEntry: {
3346             if (consumeCollectionDataTerminationIfPossible&lt;NonMapPropertiesTag&gt;()) {
3347                 mapStack.removeLast();
3348                 goto objectStartVisitMember;
3349             }
3350             stateStack.append(MapDataEndVisitKey);
3351             goto stateUnknown;
3352         }
3353         case MapDataEndVisitKey: {
3354             mapKeyStack.append(outValue);
3355             stateStack.append(MapDataEndVisitValue);
3356             goto stateUnknown;
3357         }
3358         case MapDataEndVisitValue: {
3359             mapStack.last()-&gt;set(m_lexicalGlobalObject, mapKeyStack.last(), outValue);
3360             mapKeyStack.removeLast();
3361             goto mapDataStartVisitEntry;
3362         }
3363 
3364         setObjectStartState: {
3365             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3366                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
3367             JSSet* set = JSSet::create(m_lexicalGlobalObject, m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;setStructure());
3368             if (UNLIKELY(scope.exception()))
3369                 goto error;
3370             m_gcBuffer.appendWithCrashOnOverflow(set);
3371             outputObjectStack.append(set);
3372             setStack.append(set);
3373             goto setDataStartVisitEntry;
3374         }
3375         setDataStartVisitEntry:
3376         case SetDataStartVisitEntry: {
3377             if (consumeCollectionDataTerminationIfPossible&lt;NonSetPropertiesTag&gt;()) {
3378                 setStack.removeLast();
3379                 goto objectStartVisitMember;
3380             }
3381             stateStack.append(SetDataEndVisitKey);
3382             goto stateUnknown;
3383         }
3384         case SetDataEndVisitKey: {
3385             JSSet* set = setStack.last();
3386             set-&gt;add(m_lexicalGlobalObject, outValue);
3387             goto setDataStartVisitEntry;
3388         }
3389 
3390         stateUnknown:
3391         case StateUnknown:
3392             if (JSValue terminal = readTerminal()) {
3393                 outValue = terminal;
3394                 break;
3395             }
3396             SerializationTag tag = readTag();
3397             if (tag == ArrayTag)
3398                 goto arrayStartState;
3399             if (tag == ObjectTag)
3400                 goto objectStartState;
3401             if (tag == MapObjectTag)
3402                 goto mapObjectStartState;
3403             if (tag == SetObjectTag)
3404                 goto setObjectStartState;
3405             goto error;
3406         }
3407         if (stateStack.isEmpty())
3408             break;
3409 
3410         lexicalGlobalObject = stateStack.last();
3411         stateStack.removeLast();
3412     }
3413     ASSERT(outValue);
3414     ASSERT(!m_failed);
3415     return std::make_pair(outValue, SerializationReturnCode::SuccessfullyCompleted);
3416 error:
3417     fail();
3418     return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
3419 }
3420 
3421 SerializedScriptValue::~SerializedScriptValue() = default;
3422 
3423 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer)
3424     : m_data(WTFMove(buffer))
3425 {
3426 }
3427 
3428 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray)
3429     : m_data(WTFMove(buffer))
3430     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3431 {
3432 }
3433 
3434 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray, std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBufferContentsArray, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers
3435 #if ENABLE(OFFSCREEN_CANVAS)
3436         , Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt;&amp;&amp; detachedOffscreenCanvases
3437 #endif
3438 #if ENABLE(WEBASSEMBLY)
3439         , std::unique_ptr&lt;WasmModuleArray&gt; wasmModulesArray
3440 #endif
3441         )
3442     : m_data(WTFMove(buffer))
3443     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3444     , m_sharedBufferContentsArray(WTFMove(sharedBufferContentsArray))
3445     , m_imageBuffers(WTFMove(imageBuffers))
3446 #if ENABLE(OFFSCREEN_CANVAS)
3447     , m_detachedOffscreenCanvases(WTFMove(detachedOffscreenCanvases))
3448 #endif
3449 #if ENABLE(WEBASSEMBLY)
3450     , m_wasmModulesArray(WTFMove(wasmModulesArray))
3451 #endif
3452 {
3453     // Since this SerializedScriptValue is meant to be passed between threads, its String data members
3454     // need to be isolatedCopies so we don&#39;t run into thread safety issues for the StringImpls.
3455     m_blobURLs.reserveInitialCapacity(blobURLs.size());
3456     for (auto&amp; url : blobURLs)
3457         m_blobURLs.uncheckedAppend(url.isolatedCopy());
3458 }
3459 
3460 static ExceptionOr&lt;std::unique_ptr&lt;ArrayBufferContentsArray&gt;&gt; transferArrayBuffers(VM&amp; vm, const Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers)
3461 {
3462     if (arrayBuffers.isEmpty())
3463         return nullptr;
3464 
3465     auto contents = makeUnique&lt;ArrayBufferContentsArray&gt;(arrayBuffers.size());
3466 
3467     HashSet&lt;JSC::ArrayBuffer*&gt; visited;
3468     for (size_t arrayBufferIndex = 0; arrayBufferIndex &lt; arrayBuffers.size(); arrayBufferIndex++) {
3469         if (visited.contains(arrayBuffers[arrayBufferIndex].get()))
3470             continue;
3471         visited.add(arrayBuffers[arrayBufferIndex].get());
3472 
3473         bool result = arrayBuffers[arrayBufferIndex]-&gt;transferTo(vm, contents-&gt;at(arrayBufferIndex));
3474         if (!result)
3475             return Exception { TypeError };
3476     }
3477 
3478     return contents;
3479 }
3480 
3481 static void maybeThrowExceptionIfSerializationFailed(JSGlobalObject&amp; lexicalGlobalObject, SerializationReturnCode code)
3482 {
3483     auto&amp; vm = lexicalGlobalObject.vm();
3484     auto scope = DECLARE_THROW_SCOPE(vm);
3485 
3486     switch (code) {
3487     case SerializationReturnCode::SuccessfullyCompleted:
3488         break;
3489     case SerializationReturnCode::StackOverflowError:
3490         throwException(&amp;lexicalGlobalObject, scope, createStackOverflowError(&amp;lexicalGlobalObject));
3491         break;
3492     case SerializationReturnCode::ValidationError:
3493         throwTypeError(&amp;lexicalGlobalObject, scope, &quot;Unable to deserialize data.&quot;_s);
3494         break;
3495     case SerializationReturnCode::DataCloneError:
3496         throwDataCloneError(lexicalGlobalObject, scope);
3497         break;
3498     case SerializationReturnCode::ExistingExceptionError:
3499     case SerializationReturnCode::UnspecifiedError:
3500         break;
3501     case SerializationReturnCode::InterruptedExecutionError:
3502         ASSERT_NOT_REACHED();
3503     }
3504 }
3505 
3506 static Exception exceptionForSerializationFailure(SerializationReturnCode code)
3507 {
3508     ASSERT(code != SerializationReturnCode::SuccessfullyCompleted);
3509 
3510     switch (code) {
3511     case SerializationReturnCode::StackOverflowError:
3512         return Exception { StackOverflowError };
3513     case SerializationReturnCode::ValidationError:
3514         return Exception { TypeError };
3515     case SerializationReturnCode::DataCloneError:
3516         return Exception { DataCloneError };
3517     case SerializationReturnCode::ExistingExceptionError:
3518         return Exception { ExistingExceptionError };
3519     case SerializationReturnCode::UnspecifiedError:
3520         return Exception { TypeError };
3521     case SerializationReturnCode::SuccessfullyCompleted:
3522     case SerializationReturnCode::InterruptedExecutionError:
3523         ASSERT_NOT_REACHED();
3524         return Exception { TypeError };
3525     }
3526     ASSERT_NOT_REACHED();
3527     return Exception { TypeError };
3528 }
3529 
3530 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(JSGlobalObject&amp; lexicalGlobalObject, JSValue value, SerializationErrorMode throwExceptions)
3531 {
3532     Vector&lt;uint8_t&gt; buffer;
3533     Vector&lt;String&gt; blobURLs;
3534     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
3535     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; dummyImageBitmaps;
3536 #if ENABLE(OFFSCREEN_CANVAS)
3537     Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt; dummyOffscreenCanvases;
3538 #endif
3539     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
3540 #if ENABLE(WEBASSEMBLY)
3541     WasmModuleArray dummyModules;
3542 #endif
3543     ArrayBufferContentsArray dummySharedBuffers;
3544     auto code = CloneSerializer::serialize(&amp;lexicalGlobalObject, value, dummyMessagePorts, dummyArrayBuffers, dummyImageBitmaps,
3545 #if ENABLE(OFFSCREEN_CANVAS)
3546         dummyOffscreenCanvases,
3547 #endif
3548 #if ENABLE(WEBASSEMBLY)
3549         dummyModules,
3550 #endif
3551         blobURLs, buffer, SerializationContext::Default, dummySharedBuffers);
3552 
3553 #if ENABLE(WEBASSEMBLY)
3554     ASSERT_WITH_MESSAGE(dummyModules.isEmpty(), &quot;Wasm::Module serialization is only allowed in the postMessage context&quot;);
3555 #endif
3556 
3557     if (throwExceptions == SerializationErrorMode::Throwing)
3558         maybeThrowExceptionIfSerializationFailed(lexicalGlobalObject, code);
3559 
3560     if (code != SerializationReturnCode::SuccessfullyCompleted)
3561         return nullptr;
3562 
3563     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, nullptr, nullptr, { }));
3564 }
3565 
3566 static bool containsDuplicates(const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps)
3567 {
3568     HashSet&lt;ImageBitmap*&gt; visited;
3569     for (auto&amp; imageBitmap : imageBitmaps) {
3570         if (!visited.add(imageBitmap.get()))
3571             return true;
3572     }
3573     return false;
3574 }
3575 
3576 #if ENABLE(OFFSCREEN_CANVAS)
3577 static bool canOffscreenCanvasesDetach(const Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt;&amp; offscreenCanvases)
3578 {
3579     HashSet&lt;OffscreenCanvas*&gt; visited;
3580     for (auto&amp; offscreenCanvas : offscreenCanvases) {
3581         if (!offscreenCanvas-&gt;canDetach())
3582             return false;
3583         // Check the return value of add, we should not encounter duplicates.
3584         if (!visited.add(offscreenCanvas.get()))
3585             return false;
3586     }
3587     return true;
3588 }
3589 #endif
3590 
3591 ExceptionOr&lt;Ref&lt;SerializedScriptValue&gt;&gt; SerializedScriptValue::create(JSGlobalObject&amp; lexicalGlobalObject, JSValue value, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transferList, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationContext context)
3592 {
3593     VM&amp; vm = lexicalGlobalObject.vm();
3594     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; arrayBuffers;
3595     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; imageBitmaps;
3596 #if ENABLE(OFFSCREEN_CANVAS)
3597     Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt; offscreenCanvases;
3598 #endif
3599     for (auto&amp; transferable : transferList) {
3600         if (auto arrayBuffer = toPossiblySharedArrayBuffer(vm, transferable.get())) {
3601             if (arrayBuffer-&gt;isNeutered())
3602                 return Exception { DataCloneError };
3603             if (arrayBuffer-&gt;isLocked()) {
3604                 auto scope = DECLARE_THROW_SCOPE(vm);
3605                 throwVMTypeError(&amp;lexicalGlobalObject, scope, errorMesasgeForTransfer(arrayBuffer));
3606                 return Exception { ExistingExceptionError };
3607             }
3608             arrayBuffers.append(WTFMove(arrayBuffer));
3609             continue;
3610         }
3611         if (auto port = JSMessagePort::toWrapped(vm, transferable.get())) {
3612             // FIXME: This should check if the port is detached as per https://html.spec.whatwg.org/multipage/infrastructure.html#istransferable.
3613             messagePorts.append(WTFMove(port));
3614             continue;
3615         }
3616 
3617         if (auto imageBitmap = JSImageBitmap::toWrapped(vm, transferable.get())) {
3618             if (imageBitmap-&gt;isDetached())
3619                 return Exception { DataCloneError };
3620 
3621             imageBitmaps.append(WTFMove(imageBitmap));
3622             continue;
3623         }
3624 
3625 #if ENABLE(OFFSCREEN_CANVAS)
3626         if (auto offscreenCanvas = JSOffscreenCanvas::toWrapped(vm, transferable.get())) {
3627             offscreenCanvases.append(WTFMove(offscreenCanvas));
3628             continue;
3629         }
3630 #endif
3631 
3632         return Exception { DataCloneError };
3633     }
3634 
3635     if (containsDuplicates(imageBitmaps))
3636         return Exception { DataCloneError };
3637 #if ENABLE(OFFSCREEN_CANVAS)
3638     if (!canOffscreenCanvasesDetach(offscreenCanvases))
3639         return Exception { InvalidStateError };
3640 #endif
3641 
3642     Vector&lt;uint8_t&gt; buffer;
3643     Vector&lt;String&gt; blobURLs;
3644 #if ENABLE(WEBASSEMBLY)
3645     WasmModuleArray wasmModules;
3646 #endif
3647     std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBuffers = makeUnique&lt;ArrayBufferContentsArray&gt;();
3648     auto code = CloneSerializer::serialize(&amp;lexicalGlobalObject, value, messagePorts, arrayBuffers, imageBitmaps,
3649 #if ENABLE(OFFSCREEN_CANVAS)
3650         offscreenCanvases,
3651 #endif
3652 #if ENABLE(WEBASSEMBLY)
3653         wasmModules,
3654 #endif
3655         blobURLs, buffer, context, *sharedBuffers);
3656 
3657     if (code != SerializationReturnCode::SuccessfullyCompleted)
3658         return exceptionForSerializationFailure(code);
3659 
3660     auto arrayBufferContentsArray = transferArrayBuffers(vm, arrayBuffers);
3661     if (arrayBufferContentsArray.hasException())
3662         return arrayBufferContentsArray.releaseException();
3663 
3664     auto imageBuffers = ImageBitmap::detachBitmaps(WTFMove(imageBitmaps));
3665 
3666 #if ENABLE(OFFSCREEN_CANVAS)
3667     Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt; detachedCanvases;
3668     for (auto offscreenCanvas : offscreenCanvases)
3669         detachedCanvases.append(offscreenCanvas-&gt;detach());
3670 #endif
3671 
3672     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, arrayBufferContentsArray.releaseReturnValue(), context == SerializationContext::WorkerPostMessage ? WTFMove(sharedBuffers) : nullptr, WTFMove(imageBuffers)
3673 #if ENABLE(OFFSCREEN_CANVAS)
3674                 , WTFMove(detachedCanvases)
3675 #endif
3676 #if ENABLE(WEBASSEMBLY)
3677                 , makeUnique&lt;WasmModuleArray&gt;(wasmModules)
3678 #endif
3679                 ));
3680 }
3681 
3682 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(StringView string)
3683 {
3684     Vector&lt;uint8_t&gt; buffer;
3685     if (!CloneSerializer::serialize(string, buffer))
3686         return nullptr;
3687     return adoptRef(*new SerializedScriptValue(WTFMove(buffer)));
3688 }
3689 
3690 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(JSContextRef originContext, JSValueRef apiValue, JSValueRef* exception)
3691 {
3692     JSGlobalObject* lexicalGlobalObject = toJS(originContext);
3693     VM&amp; vm = lexicalGlobalObject-&gt;vm();
3694     JSLockHolder locker(vm);
3695     auto scope = DECLARE_CATCH_SCOPE(vm);
3696 
3697     JSValue value = toJS(lexicalGlobalObject, apiValue);
3698     auto serializedValue = SerializedScriptValue::create(*lexicalGlobalObject, value);
3699     if (UNLIKELY(scope.exception())) {
3700         if (exception)
3701             *exception = toRef(lexicalGlobalObject, scope.exception()-&gt;value());
3702         scope.clearException();
3703         return nullptr;
3704     }
3705     ASSERT(serializedValue);
3706     return serializedValue;
3707 }
3708 
3709 String SerializedScriptValue::toString()
3710 {
3711     return CloneDeserializer::deserializeString(m_data);
3712 }
3713 
3714 JSValue SerializedScriptValue::deserialize(JSGlobalObject&amp; lexicalGlobalObject, JSGlobalObject* globalObject, SerializationErrorMode throwExceptions)
3715 {
3716     return deserialize(lexicalGlobalObject, globalObject, { }, throwExceptions);
3717 }
3718 
3719 JSValue SerializedScriptValue::deserialize(JSGlobalObject&amp; lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationErrorMode throwExceptions)
3720 {
3721     Vector&lt;String&gt; dummyBlobs;
3722     Vector&lt;String&gt; dummyPaths;
3723     return deserialize(lexicalGlobalObject, globalObject, messagePorts, dummyBlobs, dummyPaths, throwExceptions);
3724 }
3725 
3726 JSValue SerializedScriptValue::deserialize(JSGlobalObject&amp; lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt;&amp; blobFilePaths, SerializationErrorMode throwExceptions)
3727 {
3728     DeserializationResult result = CloneDeserializer::deserialize(&amp;lexicalGlobalObject, globalObject, messagePorts, WTFMove(m_imageBuffers)
3729 #if ENABLE(OFFSCREEN_CANVAS)
3730         , WTFMove(m_detachedOffscreenCanvases)
3731 #endif
3732         , m_arrayBufferContentsArray.get(), m_data, blobURLs, blobFilePaths, m_sharedBufferContentsArray.get()
3733 #if ENABLE(WEBASSEMBLY)
3734         , m_wasmModulesArray.get()
3735 #endif
3736         );
3737     if (throwExceptions == SerializationErrorMode::Throwing)
3738         maybeThrowExceptionIfSerializationFailed(lexicalGlobalObject, result.second);
3739     return result.first ? result.first : jsNull();
3740 }
3741 
3742 JSValueRef SerializedScriptValue::deserialize(JSContextRef destinationContext, JSValueRef* exception)
3743 {
3744     JSGlobalObject* lexicalGlobalObject = toJS(destinationContext);
3745     VM&amp; vm = lexicalGlobalObject-&gt;vm();
3746     JSLockHolder locker(vm);
3747     auto scope = DECLARE_CATCH_SCOPE(vm);
3748 
3749     JSValue value = deserialize(*lexicalGlobalObject, lexicalGlobalObject);
3750     if (UNLIKELY(scope.exception())) {
3751         if (exception)
3752             *exception = toRef(lexicalGlobalObject, scope.exception()-&gt;value());
3753         scope.clearException();
3754         return nullptr;
3755     }
3756     ASSERT(value);
3757     return toRef(lexicalGlobalObject, value);
3758 }
3759 
3760 Ref&lt;SerializedScriptValue&gt; SerializedScriptValue::nullValue()
3761 {
3762     return adoptRef(*new SerializedScriptValue(Vector&lt;uint8_t&gt;()));
3763 }
3764 
3765 uint32_t SerializedScriptValue::wireFormatVersion()
3766 {
3767     return CurrentVersion;
3768 }
3769 
3770 #if ENABLE(INDEXED_DATABASE)
3771 Vector&lt;String&gt; SerializedScriptValue::blobURLsIsolatedCopy() const
3772 {
3773     Vector&lt;String&gt; result;
3774     result.reserveInitialCapacity(m_blobURLs.size());
3775     for (auto&amp; url : m_blobURLs)
3776         result.uncheckedAppend(url.isolatedCopy());
3777 
3778     return result;
3779 }
3780 
3781 void SerializedScriptValue::writeBlobsToDiskForIndexedDB(CompletionHandler&lt;void(IDBValue&amp;&amp;)&gt;&amp;&amp; completionHandler)
3782 {
3783     ASSERT(isMainThread());
3784     ASSERT(hasBlobURLs());
3785 
3786     blobRegistry().writeBlobsToTemporaryFiles(m_blobURLs, [completionHandler = WTFMove(completionHandler), this, protectedThis = makeRef(*this)] (auto&amp;&amp; blobFilePaths) mutable {
3787         ASSERT(isMainThread());
3788 
3789         if (blobFilePaths.isEmpty()) {
3790             // We should have successfully written blobs to temporary files.
3791             // If we failed, then we can&#39;t successfully store this record.
3792             completionHandler({ });
3793             return;
3794         }
3795 
3796         ASSERT(m_blobURLs.size() == blobFilePaths.size());
3797 
3798         completionHandler({ *this, m_blobURLs, blobFilePaths });
3799     });
3800 }
3801 
3802 IDBValue SerializedScriptValue::writeBlobsToDiskForIndexedDBSynchronously()
3803 {
3804     ASSERT(!isMainThread());
3805 
3806     IDBValue value;
3807     Lock lock;
3808     Condition condition;
3809     lock.lock();
3810 
3811     RunLoop::main().dispatch([this, conditionPtr = &amp;condition, valuePtr = &amp;value] {
3812         writeBlobsToDiskForIndexedDB([conditionPtr, valuePtr](IDBValue&amp;&amp; result) {
3813             ASSERT(isMainThread());
3814             valuePtr-&gt;setAsIsolatedCopy(result);
3815 
3816             conditionPtr-&gt;notifyAll();
3817         });
3818     });
3819 
3820     condition.wait(lock);
3821 
3822     return value;
3823 }
3824 
3825 #endif // ENABLE(INDEXED_DATABASE)
3826 
3827 } // namespace WebCore
    </pre>
  </body>
</html>
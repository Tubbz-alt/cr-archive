<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/ScriptElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScriptElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptExecutionContext.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/ScriptElement.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39 
 40 class ScriptElement {
 41 public:
 42     virtual ~ScriptElement() = default;
 43 
 44     Element&amp; element() { return m_element; }
 45     const Element&amp; element() const { return m_element; }
 46 
 47     enum LegacyTypeSupport { DisallowLegacyTypeInTypeAttribute, AllowLegacyTypeInTypeAttribute };
 48     bool prepareScript(const TextPosition&amp; scriptStartPosition = TextPosition(), LegacyTypeSupport = DisallowLegacyTypeInTypeAttribute);
 49 
 50     String scriptCharset() const { return m_characterEncoding; }
 51     WEBCORE_EXPORT String scriptContent() const;
 52     void executeClassicScript(const ScriptSourceCode&amp;);
 53     void executeModuleScript(LoadableModuleScript&amp;);
 54 
 55     void executePendingScript(PendingScript&amp;);
 56 
 57     // XML parser calls these
 58     virtual void dispatchLoadEvent() = 0;
<span class="line-modified"> 59     void dispatchErrorEvent();</span>
 60 
 61     bool haveFiredLoadEvent() const { return m_haveFiredLoad; }

 62     bool willBeParserExecuted() const { return m_willBeParserExecuted; }
 63     bool readyToBeParserExecuted() const { return m_readyToBeParserExecuted; }
 64     bool willExecuteWhenDocumentFinishedParsing() const { return m_willExecuteWhenDocumentFinishedParsing; }
 65     bool willExecuteInOrder() const { return m_willExecuteInOrder; }
 66     LoadableScript* loadableScript() { return m_loadableScript.get(); }
 67 
 68     // https://html.spec.whatwg.org/multipage/scripting.html#concept-script-type
 69     enum class ScriptType { Classic, Module };
 70     ScriptType scriptType() const { return m_isModuleScript ? ScriptType::Module : ScriptType::Classic; }
 71 
 72     void ref();
 73     void deref();
 74 
 75 protected:
 76     ScriptElement(Element&amp;, bool createdByParser, bool isEvaluated);
 77 
 78     void setHaveFiredLoadEvent(bool haveFiredLoad) { m_haveFiredLoad = haveFiredLoad; }

 79     bool isParserInserted() const { return m_parserInserted; }
 80     bool alreadyStarted() const { return m_alreadyStarted; }
 81     bool forceAsync() const { return m_forceAsync; }
 82 
 83     // Helper functions used by our parent classes.
 84     Node::InsertedIntoAncestorResult insertedIntoAncestor(Node::InsertionType insertionType, ContainerNode&amp;) const
 85     {
 86         if (insertionType.connectedToDocument &amp;&amp; !m_parserInserted)
 87             return Node::InsertedIntoAncestorResult::NeedsPostInsertionCallback;
 88         return Node::InsertedIntoAncestorResult::Done;
 89     }
 90 
 91     void didFinishInsertingNode();
 92     void childrenChanged(const ContainerNode::ChildChange&amp;);
 93     void handleSourceAttribute(const String&amp; sourceURL);
 94     void handleAsyncAttribute();
 95 
 96 private:
 97     void executeScriptAndDispatchEvent(LoadableScript&amp;);
 98 
</pre>
<hr />
<pre>
105     bool requestModuleScript(const TextPosition&amp; scriptStartPosition);
106 
107     virtual String sourceAttributeValue() const = 0;
108     virtual String charsetAttributeValue() const = 0;
109     virtual String typeAttributeValue() const = 0;
110     virtual String languageAttributeValue() const = 0;
111     virtual String forAttributeValue() const = 0;
112     virtual String eventAttributeValue() const = 0;
113     virtual bool hasAsyncAttribute() const = 0;
114     virtual bool hasDeferAttribute() const = 0;
115     virtual bool hasSourceAttribute() const = 0;
116     virtual bool hasNoModuleAttribute() const = 0;
117     virtual ReferrerPolicy referrerPolicy() const = 0;
118 
119     Element&amp; m_element;
120     WTF::OrdinalNumber m_startLineNumber;
121     bool m_parserInserted : 1;
122     bool m_isExternalScript : 1;
123     bool m_alreadyStarted : 1;
124     bool m_haveFiredLoad : 1;

125     bool m_willBeParserExecuted : 1; // Same as &quot;The parser will handle executing the script.&quot;
126     bool m_readyToBeParserExecuted : 1;
127     bool m_willExecuteWhenDocumentFinishedParsing : 1;
128     bool m_forceAsync : 1;
129     bool m_willExecuteInOrder : 1;
130     bool m_isModuleScript : 1;
131     String m_characterEncoding;
132     String m_fallbackCharacterEncoding;
133     RefPtr&lt;LoadableScript&gt; m_loadableScript;
134 
135     MonotonicTime m_creationTime;
136     RefPtr&lt;UserGestureToken&gt; m_userGestureToken;
137 };
138 
139 // FIXME: replace with is/downcast&lt;ScriptElement&gt;.
140 bool isScriptElement(Element&amp;);
141 ScriptElement&amp; downcastScriptElement(Element&amp;);
142 
143 }
</pre>
</td>
<td>
<hr />
<pre>
 39 
 40 class ScriptElement {
 41 public:
 42     virtual ~ScriptElement() = default;
 43 
 44     Element&amp; element() { return m_element; }
 45     const Element&amp; element() const { return m_element; }
 46 
 47     enum LegacyTypeSupport { DisallowLegacyTypeInTypeAttribute, AllowLegacyTypeInTypeAttribute };
 48     bool prepareScript(const TextPosition&amp; scriptStartPosition = TextPosition(), LegacyTypeSupport = DisallowLegacyTypeInTypeAttribute);
 49 
 50     String scriptCharset() const { return m_characterEncoding; }
 51     WEBCORE_EXPORT String scriptContent() const;
 52     void executeClassicScript(const ScriptSourceCode&amp;);
 53     void executeModuleScript(LoadableModuleScript&amp;);
 54 
 55     void executePendingScript(PendingScript&amp;);
 56 
 57     // XML parser calls these
 58     virtual void dispatchLoadEvent() = 0;
<span class="line-modified"> 59     virtual void dispatchErrorEvent();</span>
 60 
 61     bool haveFiredLoadEvent() const { return m_haveFiredLoad; }
<span class="line-added"> 62     bool errorOccurred() const { return m_errorOccurred; }</span>
 63     bool willBeParserExecuted() const { return m_willBeParserExecuted; }
 64     bool readyToBeParserExecuted() const { return m_readyToBeParserExecuted; }
 65     bool willExecuteWhenDocumentFinishedParsing() const { return m_willExecuteWhenDocumentFinishedParsing; }
 66     bool willExecuteInOrder() const { return m_willExecuteInOrder; }
 67     LoadableScript* loadableScript() { return m_loadableScript.get(); }
 68 
 69     // https://html.spec.whatwg.org/multipage/scripting.html#concept-script-type
 70     enum class ScriptType { Classic, Module };
 71     ScriptType scriptType() const { return m_isModuleScript ? ScriptType::Module : ScriptType::Classic; }
 72 
 73     void ref();
 74     void deref();
 75 
 76 protected:
 77     ScriptElement(Element&amp;, bool createdByParser, bool isEvaluated);
 78 
 79     void setHaveFiredLoadEvent(bool haveFiredLoad) { m_haveFiredLoad = haveFiredLoad; }
<span class="line-added"> 80     void setErrorOccurred(bool errorOccurred) { m_errorOccurred = errorOccurred; }</span>
 81     bool isParserInserted() const { return m_parserInserted; }
 82     bool alreadyStarted() const { return m_alreadyStarted; }
 83     bool forceAsync() const { return m_forceAsync; }
 84 
 85     // Helper functions used by our parent classes.
 86     Node::InsertedIntoAncestorResult insertedIntoAncestor(Node::InsertionType insertionType, ContainerNode&amp;) const
 87     {
 88         if (insertionType.connectedToDocument &amp;&amp; !m_parserInserted)
 89             return Node::InsertedIntoAncestorResult::NeedsPostInsertionCallback;
 90         return Node::InsertedIntoAncestorResult::Done;
 91     }
 92 
 93     void didFinishInsertingNode();
 94     void childrenChanged(const ContainerNode::ChildChange&amp;);
 95     void handleSourceAttribute(const String&amp; sourceURL);
 96     void handleAsyncAttribute();
 97 
 98 private:
 99     void executeScriptAndDispatchEvent(LoadableScript&amp;);
100 
</pre>
<hr />
<pre>
107     bool requestModuleScript(const TextPosition&amp; scriptStartPosition);
108 
109     virtual String sourceAttributeValue() const = 0;
110     virtual String charsetAttributeValue() const = 0;
111     virtual String typeAttributeValue() const = 0;
112     virtual String languageAttributeValue() const = 0;
113     virtual String forAttributeValue() const = 0;
114     virtual String eventAttributeValue() const = 0;
115     virtual bool hasAsyncAttribute() const = 0;
116     virtual bool hasDeferAttribute() const = 0;
117     virtual bool hasSourceAttribute() const = 0;
118     virtual bool hasNoModuleAttribute() const = 0;
119     virtual ReferrerPolicy referrerPolicy() const = 0;
120 
121     Element&amp; m_element;
122     WTF::OrdinalNumber m_startLineNumber;
123     bool m_parserInserted : 1;
124     bool m_isExternalScript : 1;
125     bool m_alreadyStarted : 1;
126     bool m_haveFiredLoad : 1;
<span class="line-added">127     bool m_errorOccurred : 1;</span>
128     bool m_willBeParserExecuted : 1; // Same as &quot;The parser will handle executing the script.&quot;
129     bool m_readyToBeParserExecuted : 1;
130     bool m_willExecuteWhenDocumentFinishedParsing : 1;
131     bool m_forceAsync : 1;
132     bool m_willExecuteInOrder : 1;
133     bool m_isModuleScript : 1;
134     String m_characterEncoding;
135     String m_fallbackCharacterEncoding;
136     RefPtr&lt;LoadableScript&gt; m_loadableScript;
137 
138     MonotonicTime m_creationTime;
139     RefPtr&lt;UserGestureToken&gt; m_userGestureToken;
140 };
141 
142 // FIXME: replace with is/downcast&lt;ScriptElement&gt;.
143 bool isScriptElement(Element&amp;);
144 ScriptElement&amp; downcastScriptElement(Element&amp;);
145 
146 }
</pre>
</td>
</tr>
</table>
<center><a href="ScriptElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptExecutionContext.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
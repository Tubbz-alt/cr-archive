<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/audio/AudioArray.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../animation/AnimationUtilities.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FFTFrame.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/audio/AudioArray.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #ifndef AudioArray_h
 30 #define AudioArray_h
 31 
 32 #include &lt;string.h&gt;
 33 #include &lt;wtf/CheckedArithmetic.h&gt;
 34 #include &lt;wtf/FastMalloc.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 template&lt;typename T&gt;
 39 class AudioArray {
 40     WTF_MAKE_FAST_ALLOCATED;
 41 public:
<span class="line-modified"> 42     AudioArray() : m_allocation(0), m_alignedData(0), m_size(0) { }</span>
<span class="line-modified"> 43     explicit AudioArray(size_t n) : m_allocation(0), m_alignedData(0), m_size(0)</span>
 44     {
 45         allocate(n);
 46     }
 47 
 48     ~AudioArray()
 49     {
<span class="line-modified"> 50         fastFree(m_allocation);</span>
 51     }
 52 
 53     // It&#39;s OK to call allocate() multiple times, but data will *not* be copied from an initial allocation
 54     // if re-allocated. Allocations are zero-initialized.
 55     void allocate(Checked&lt;size_t&gt; n)
 56     {
<span class="line-modified"> 57         Checked&lt;unsigned&gt; initialSize = sizeof(T) * n;</span>
 58         const size_t alignment = 16;
 59 
<span class="line-modified"> 60         if (m_allocation)</span>
<span class="line-modified"> 61             fastFree(m_allocation);</span>
<span class="line-modified"> 62 </span>
<span class="line-modified"> 63         bool isAllocationGood = false;</span>
<span class="line-modified"> 64 </span>
<span class="line-modified"> 65         while (!isAllocationGood) {</span>
<span class="line-modified"> 66             // Initially we try to allocate the exact size, but if it&#39;s not aligned</span>
<span class="line-removed"> 67             // then we&#39;ll have to reallocate and from then on allocate extra.</span>
<span class="line-removed"> 68             static size_t extraAllocationBytes = 0;</span>
<span class="line-removed"> 69 </span>
<span class="line-removed"> 70             T* allocation = static_cast&lt;T*&gt;(fastMalloc((initialSize + extraAllocationBytes).unsafeGet()));</span>
<span class="line-removed"> 71             if (!allocation)</span>
<span class="line-removed"> 72                 CRASH();</span>
<span class="line-removed"> 73             T* alignedData = alignedAddress(allocation, alignment);</span>
<span class="line-removed"> 74 </span>
<span class="line-removed"> 75             if (alignedData == allocation || extraAllocationBytes == alignment) {</span>
<span class="line-removed"> 76                 m_allocation = allocation;</span>
<span class="line-removed"> 77                 m_alignedData = alignedData;</span>
<span class="line-removed"> 78                 m_size = n.unsafeGet();</span>
<span class="line-removed"> 79                 isAllocationGood = true;</span>
<span class="line-removed"> 80                 zero();</span>
<span class="line-removed"> 81             } else {</span>
<span class="line-removed"> 82                 extraAllocationBytes = alignment; // always allocate extra after the first alignment failure.</span>
<span class="line-removed"> 83                 fastFree(allocation);</span>
<span class="line-removed"> 84             }</span>
<span class="line-removed"> 85         }</span>
 86     }
 87 
<span class="line-modified"> 88     T* data() { return m_alignedData; }</span>
<span class="line-modified"> 89     const T* data() const { return m_alignedData; }</span>
 90     size_t size() const { return m_size; }
 91 
 92     T&amp; at(size_t i)
 93     {
 94         // Note that although it is a size_t, m_size is now guaranteed to be
 95         // no greater than max unsigned. This guarantee is enforced in allocate().
 96         ASSERT_WITH_SECURITY_IMPLICATION(i &lt; size());
 97         return data()[i];
 98     }
 99 
100     T&amp; operator[](size_t i) { return at(i); }
101 
102     void zero()
103     {
104         // This multiplication is made safe by the check in allocate().
105         memset(this-&gt;data(), 0, sizeof(T) * this-&gt;size());
106     }
107 
108     void zeroRange(unsigned start, unsigned end)
109     {
</pre>
<hr />
<pre>
113             return;
114 
115         // This expression cannot overflow because end - start cannot be
116         // greater than m_size, which is safe due to the check in allocate().
117         memset(this-&gt;data() + start, 0, sizeof(T) * (end - start));
118     }
119 
120     void copyToRange(const T* sourceData, unsigned start, unsigned end)
121     {
122         bool isSafe = (start &lt;= end) &amp;&amp; (end &lt;= this-&gt;size());
123         ASSERT(isSafe);
124         if (!isSafe)
125             return;
126 
127         // This expression cannot overflow because end - start cannot be
128         // greater than m_size, which is safe due to the check in allocate().
129         memcpy(this-&gt;data() + start, sourceData, sizeof(T) * (end - start));
130     }
131 
132 private:
<span class="line-modified">133     static T* alignedAddress(T* address, intptr_t alignment)</span>
<span class="line-modified">134     {</span>
<span class="line-removed">135         intptr_t value = reinterpret_cast&lt;intptr_t&gt;(address);</span>
<span class="line-removed">136         return reinterpret_cast&lt;T*&gt;((value + alignment - 1) &amp; ~(alignment - 1));</span>
<span class="line-removed">137     }</span>
<span class="line-removed">138 </span>
<span class="line-removed">139     T* m_allocation;</span>
<span class="line-removed">140     T* m_alignedData;</span>
<span class="line-removed">141     size_t m_size;</span>
142 };
143 
144 typedef AudioArray&lt;float&gt; AudioFloatArray;
145 typedef AudioArray&lt;double&gt; AudioDoubleArray;
146 
147 } // WebCore
148 
149 #endif // AudioArray_h
</pre>
</td>
<td>
<hr />
<pre>
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #ifndef AudioArray_h
 30 #define AudioArray_h
 31 
 32 #include &lt;string.h&gt;
 33 #include &lt;wtf/CheckedArithmetic.h&gt;
 34 #include &lt;wtf/FastMalloc.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 template&lt;typename T&gt;
 39 class AudioArray {
 40     WTF_MAKE_FAST_ALLOCATED;
 41 public:
<span class="line-modified"> 42     AudioArray() = default;</span>
<span class="line-modified"> 43     explicit AudioArray(size_t n)</span>
 44     {
 45         allocate(n);
 46     }
 47 
 48     ~AudioArray()
 49     {
<span class="line-modified"> 50         fastAlignedFree(m_allocation);</span>
 51     }
 52 
 53     // It&#39;s OK to call allocate() multiple times, but data will *not* be copied from an initial allocation
 54     // if re-allocated. Allocations are zero-initialized.
 55     void allocate(Checked&lt;size_t&gt; n)
 56     {
<span class="line-modified"> 57         Checked&lt;size_t&gt; initialSize = sizeof(T) * n;</span>
 58         const size_t alignment = 16;
 59 
<span class="line-modified"> 60         fastAlignedFree(m_allocation);</span>
<span class="line-modified"> 61 </span>
<span class="line-modified"> 62         m_allocation = static_cast&lt;T*&gt;(fastAlignedMalloc(alignment, initialSize.unsafeGet()));</span>
<span class="line-modified"> 63         if (!m_allocation)</span>
<span class="line-modified"> 64             CRASH();</span>
<span class="line-modified"> 65         m_size = n.unsafeGet();</span>
<span class="line-modified"> 66         zero();</span>



















 67     }
 68 
<span class="line-modified"> 69     T* data() { return m_allocation; }</span>
<span class="line-modified"> 70     const T* data() const { return m_allocation; }</span>
 71     size_t size() const { return m_size; }
 72 
 73     T&amp; at(size_t i)
 74     {
 75         // Note that although it is a size_t, m_size is now guaranteed to be
 76         // no greater than max unsigned. This guarantee is enforced in allocate().
 77         ASSERT_WITH_SECURITY_IMPLICATION(i &lt; size());
 78         return data()[i];
 79     }
 80 
 81     T&amp; operator[](size_t i) { return at(i); }
 82 
 83     void zero()
 84     {
 85         // This multiplication is made safe by the check in allocate().
 86         memset(this-&gt;data(), 0, sizeof(T) * this-&gt;size());
 87     }
 88 
 89     void zeroRange(unsigned start, unsigned end)
 90     {
</pre>
<hr />
<pre>
 94             return;
 95 
 96         // This expression cannot overflow because end - start cannot be
 97         // greater than m_size, which is safe due to the check in allocate().
 98         memset(this-&gt;data() + start, 0, sizeof(T) * (end - start));
 99     }
100 
101     void copyToRange(const T* sourceData, unsigned start, unsigned end)
102     {
103         bool isSafe = (start &lt;= end) &amp;&amp; (end &lt;= this-&gt;size());
104         ASSERT(isSafe);
105         if (!isSafe)
106             return;
107 
108         // This expression cannot overflow because end - start cannot be
109         // greater than m_size, which is safe due to the check in allocate().
110         memcpy(this-&gt;data() + start, sourceData, sizeof(T) * (end - start));
111     }
112 
113 private:
<span class="line-modified">114     T* m_allocation { nullptr };</span>
<span class="line-modified">115     size_t m_size { 0 };</span>







116 };
117 
118 typedef AudioArray&lt;float&gt; AudioFloatArray;
119 typedef AudioArray&lt;double&gt; AudioDoubleArray;
120 
121 } // WebCore
122 
123 #endif // AudioArray_h
</pre>
</td>
</tr>
</table>
<center><a href="../animation/AnimationUtilities.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FFTFrame.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
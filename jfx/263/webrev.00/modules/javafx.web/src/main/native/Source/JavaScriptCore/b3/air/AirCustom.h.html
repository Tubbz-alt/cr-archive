<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCustom.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;AirCode.h&quot;
 31 #include &quot;AirGenerationContext.h&quot;
 32 #include &quot;AirInst.h&quot;
 33 #include &quot;AirSpecial.h&quot;
 34 #include &quot;B3ValueInlines.h&quot;
 35 #include &quot;B3WasmBoundsCheckValue.h&quot;
 36 #include &quot;MacroAssembler.h&quot;
 37 
 38 namespace JSC { namespace B3 { namespace Air {
 39 
 40 // This defines the behavior of custom instructions - i.e. those whose behavior cannot be
 41 // described using AirOpcode.opcodes. If you define an opcode as &quot;custom Foo&quot; in that file, then
 42 // you will need to create a &quot;struct FooCustom&quot; here that implements the custom behavior
 43 // methods.
 44 //
 45 // The customizability granted by the custom instruction mechanism is strictly less than what
 46 // you get using the Patch instruction and implementing a Special. However, that path requires
 47 // allocating a Special object and ensuring that it&#39;s the first operand. For many instructions,
 48 // that is not as convenient as using Custom, which makes the instruction look like any other
 49 // instruction. Note that both of those extra powers of the Patch instruction happen because we
 50 // special-case that instruction in many phases and analyses. Non-special-cased behaviors of
 51 // Patch are implemented using the custom instruction mechanism.
 52 //
 53 // Specials are still more flexible if you need to list extra clobbered registers and you&#39;d like
 54 // that to be expressed as a bitvector rather than an arglist. They are also more flexible if
 55 // you need to carry extra state around with the instruction. Also, Specials mean that you
 56 // always have access to Code&amp; even in methods that don&#39;t take a GenerationContext.
 57 
 58 // Definition of Patch instruction. Patch is used to delegate the behavior of the instruction to the
 59 // Special object, which will be the first argument to the instruction.
 60 struct PatchCustom {
 61     static void forEachArg(Inst&amp; inst, ScopedLambda&lt;Inst::EachArgCallback&gt; lambda)
 62     {
 63         // This is basically bogus, but it works for analyses that model Special as an
 64         // immediate.
 65         lambda(inst.args[0], Arg::Use, GP, pointerWidth());
 66 
 67         inst.args[0].special()-&gt;forEachArg(inst, lambda);
 68     }
 69 
 70     template&lt;typename... Arguments&gt;
 71     static bool isValidFormStatic(Arguments...)
 72     {
 73         return false;
 74     }
 75 
 76     static bool isValidForm(Inst&amp; inst);
 77 
 78     static bool admitsStack(Inst&amp; inst, unsigned argIndex)
 79     {
 80         if (!argIndex)
 81             return false;
 82         return inst.args[0].special()-&gt;admitsStack(inst, argIndex);
 83     }
 84 
 85     static bool admitsExtendedOffsetAddr(Inst&amp; inst, unsigned argIndex)
 86     {
 87         if (!argIndex)
 88             return false;
 89         return inst.args[0].special()-&gt;admitsExtendedOffsetAddr(inst, argIndex);
 90     }
 91 
 92     static Optional&lt;unsigned&gt; shouldTryAliasingDef(Inst&amp; inst)
 93     {
 94         return inst.args[0].special()-&gt;shouldTryAliasingDef(inst);
 95     }
 96 
 97     static bool isTerminal(Inst&amp; inst)
 98     {
 99         return inst.args[0].special()-&gt;isTerminal(inst);
100     }
101 
102     static bool hasNonArgEffects(Inst&amp; inst)
103     {
104         return inst.args[0].special()-&gt;hasNonArgEffects(inst);
105     }
106 
107     static bool hasNonArgNonControlEffects(Inst&amp; inst)
108     {
109         return inst.args[0].special()-&gt;hasNonArgNonControlEffects(inst);
110     }
111 
112     static MacroAssembler::Jump generate(
113         Inst&amp; inst, CCallHelpers&amp; jit, GenerationContext&amp; context)
114     {
115         return inst.args[0].special()-&gt;generate(inst, jit, context);
116     }
117 };
118 
119 template&lt;typename Subtype&gt;
120 struct CommonCustomBase {
121     static bool hasNonArgEffects(Inst&amp; inst)
122     {
123         return Subtype::isTerminal(inst) || Subtype::hasNonArgNonControlEffects(inst);
124     }
125 };
126 
127 // Definition of CCall instruction. CCall is used for hot path C function calls. It&#39;s lowered to a
128 // Patch with an Air CCallSpecial along with code to marshal instructions. The lowering happens
129 // before register allocation, so that the register allocator sees the clobbers.
130 struct CCallCustom : public CommonCustomBase&lt;CCallCustom&gt; {
131     template&lt;typename Functor&gt;
132     static void forEachArg(Inst&amp; inst, const Functor&amp; functor)
133     {
134         Value* value = inst.origin;
135 
136         unsigned index = 0;
137 
138         functor(inst.args[index++], Arg::Use, GP, pointerWidth()); // callee
139 
140         if (value-&gt;type() != Void) {
141             functor(
142                 inst.args[index++], Arg::Def,
143                 bankForType(value-&gt;type()),
144                 widthForType(value-&gt;type()));
145         }
146 
147         for (unsigned i = 1; i &lt; value-&gt;numChildren(); ++i) {
148             Value* child = value-&gt;child(i);
149             functor(
150                 inst.args[index++], Arg::Use,
151                 bankForType(child-&gt;type()),
152                 widthForType(child-&gt;type()));
153         }
154     }
155 
156     template&lt;typename... Arguments&gt;
157     static bool isValidFormStatic(Arguments...)
158     {
159         return false;
160     }
161 
162     static bool isValidForm(Inst&amp;);
163 
164     static bool admitsStack(Inst&amp;, unsigned)
165     {
166         return true;
167     }
168 
169     static bool admitsExtendedOffsetAddr(Inst&amp;, unsigned)
170     {
171         return false;
172     }
173 
174     static bool isTerminal(Inst&amp;)
175     {
176         return false;
177     }
178 
179     static bool hasNonArgNonControlEffects(Inst&amp;)
180     {
181         return true;
182     }
183 
184     // This just crashes, since we expect C calls to be lowered before generation.
185     static MacroAssembler::Jump generate(Inst&amp;, CCallHelpers&amp;, GenerationContext&amp;);
186 };
187 
188 struct ColdCCallCustom : CCallCustom {
189     template&lt;typename Functor&gt;
190     static void forEachArg(Inst&amp; inst, const Functor&amp; functor)
191     {
192         // This is just like a call, but uses become cold.
193         CCallCustom::forEachArg(
194             inst,
195             [&amp;] (Arg&amp; arg, Arg::Role role, Bank bank, Width width) {
196                 functor(arg, Arg::cooled(role), bank, width);
197             });
198     }
199 };
200 
201 struct ShuffleCustom : public CommonCustomBase&lt;ShuffleCustom&gt; {
202     template&lt;typename Functor&gt;
203     static void forEachArg(Inst&amp; inst, const Functor&amp; functor)
204     {
205         unsigned limit = inst.args.size() / 3 * 3;
206         for (unsigned i = 0; i &lt; limit; i += 3) {
207             Arg&amp; src = inst.args[i + 0];
208             Arg&amp; dst = inst.args[i + 1];
209             Arg&amp; widthArg = inst.args[i + 2];
210             Width width = widthArg.width();
211             Bank bank = src.isGP() &amp;&amp; dst.isGP() ? GP : FP;
212             functor(src, Arg::Use, bank, width);
213             functor(dst, Arg::Def, bank, width);
214             functor(widthArg, Arg::Use, GP, Width8);
215         }
216     }
217 
218     template&lt;typename... Arguments&gt;
219     static bool isValidFormStatic(Arguments...)
220     {
221         return false;
222     }
223 
224     static bool isValidForm(Inst&amp;);
225 
226     static bool admitsStack(Inst&amp;, unsigned index)
227     {
228         switch (index % 3) {
229         case 0:
230         case 1:
231             return true;
232         default:
233             return false;
234         }
235     }
236 
237     static bool admitsExtendedOffsetAddr(Inst&amp;, unsigned)
238     {
239         return false;
240     }
241 
242     static bool isTerminal(Inst&amp;)
243     {
244         return false;
245     }
246 
247     static bool hasNonArgNonControlEffects(Inst&amp;)
248     {
249         return false;
250     }
251 
252     static MacroAssembler::Jump generate(Inst&amp;, CCallHelpers&amp;, GenerationContext&amp;);
253 };
254 
255 struct EntrySwitchCustom : public CommonCustomBase&lt;EntrySwitchCustom&gt; {
256     template&lt;typename Func&gt;
257     static void forEachArg(Inst&amp;, const Func&amp;)
258     {
259     }
260 
261     template&lt;typename... Arguments&gt;
262     static bool isValidFormStatic(Arguments...)
263     {
264         return !sizeof...(Arguments);
265     }
266 
267     static bool isValidForm(Inst&amp; inst)
268     {
269         return inst.args.isEmpty();
270     }
271 
272     static bool admitsStack(Inst&amp;, unsigned)
273     {
274         return false;
275     }
276 
277     static bool admitsExtendedOffsetAddr(Inst&amp;, unsigned)
278     {
279         return false;
280     }
281 
282     static bool isTerminal(Inst&amp;)
283     {
284         return true;
285     }
286 
287     static bool hasNonArgNonControlEffects(Inst&amp;)
288     {
289         return false;
290     }
291 
292     static MacroAssembler::Jump generate(Inst&amp;, CCallHelpers&amp;, GenerationContext&amp;)
293     {
294         // This should never be reached because we should have lowered EntrySwitch before
295         // generation.
296         UNREACHABLE_FOR_PLATFORM();
297         return MacroAssembler::Jump();
298     }
299 };
300 
301 struct WasmBoundsCheckCustom : public CommonCustomBase&lt;WasmBoundsCheckCustom&gt; {
302     template&lt;typename Func&gt;
303     static void forEachArg(Inst&amp; inst, const Func&amp; functor)
304     {
305         functor(inst.args[0], Arg::Use, GP, Width64);
306         functor(inst.args[1], Arg::Use, GP, Width64);
307     }
308 
309     template&lt;typename... Arguments&gt;
310     static bool isValidFormStatic(Arguments...)
311     {
312         return false;
313     }
314 
315     static bool isValidForm(Inst&amp;);
316 
317     static bool admitsStack(Inst&amp;, unsigned)
318     {
319         return false;
320     }
321 
322     static bool admitsExtendedOffsetAddr(Inst&amp;, unsigned)
323     {
324         return false;
325     }
326 
327     static bool isTerminal(Inst&amp;)
328     {
329         return false;
330     }
331 
332     static bool hasNonArgNonControlEffects(Inst&amp;)
333     {
334         return true;
335     }
336 
337     static MacroAssembler::Jump generate(Inst&amp;, CCallHelpers&amp;, GenerationContext&amp;);
338 };
339 
340 } } } // namespace JSC::B3::Air
341 
342 #endif // ENABLE(B3_JIT)
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/RejectedPromiseTracker.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/RejectedPromiseTracker.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/RejectedPromiseTracker.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/RejectedPromiseTracker.cpp
@@ -83,36 +83,36 @@
 {
 }
 
 RejectedPromiseTracker::~RejectedPromiseTracker() = default;
 
-static RefPtr<ScriptCallStack> createScriptCallStackFromReason(ExecState& state, JSValue reason)
+static RefPtr<ScriptCallStack> createScriptCallStackFromReason(JSGlobalObject& lexicalGlobalObject, JSValue reason)
 {
-    VM& vm = state.vm();
+    VM& vm = lexicalGlobalObject.vm();
 
     // Always capture a stack from the exception if this rejection was an exception.
     if (auto* exception = vm.lastException()) {
         if (exception->value() == reason)
-            return createScriptCallStackFromException(&state, exception);
+            return createScriptCallStackFromException(&lexicalGlobalObject, exception);
     }
 
     // Otherwise, only capture a stack if a debugger is open.
-    if (state.lexicalGlobalObject()->debugger())
-        return createScriptCallStack(&state);
+    if (lexicalGlobalObject.debugger())
+        return createScriptCallStack(&lexicalGlobalObject);
 
     return nullptr;
 }
 
-void RejectedPromiseTracker::promiseRejected(ExecState& state, JSDOMGlobalObject& globalObject, JSPromise& promise)
+void RejectedPromiseTracker::promiseRejected(JSDOMGlobalObject& globalObject, JSPromise& promise)
 {
     // https://html.spec.whatwg.org/multipage/webappapis.html#the-hostpromiserejectiontracker-implementation
 
-    JSValue reason = promise.result(state.vm());
-    m_aboutToBeNotifiedRejectedPromises.append(UnhandledPromise { globalObject, promise, createScriptCallStackFromReason(state, reason) });
+    JSValue reason = promise.result(globalObject.vm());
+    m_aboutToBeNotifiedRejectedPromises.append(UnhandledPromise { globalObject, promise, createScriptCallStackFromReason(globalObject, reason) });
 }
 
-void RejectedPromiseTracker::promiseHandled(ExecState&, JSDOMGlobalObject& globalObject, JSPromise& promise)
+void RejectedPromiseTracker::promiseHandled(JSDOMGlobalObject& globalObject, JSPromise& promise)
 {
     // https://html.spec.whatwg.org/multipage/webappapis.html#the-hostpromiserejectiontracker-implementation
 
     bool removed = m_aboutToBeNotifiedRejectedPromises.removeFirstMatching([&] (UnhandledPromise& unhandledPromise) {
         auto& domPromise = unhandledPromise.promise();
@@ -153,11 +153,11 @@
 
     for (auto& unhandledPromise : unhandledPromises) {
         auto& domPromise = unhandledPromise.promise();
         if (domPromise.isSuspended())
             continue;
-        auto& state = *domPromise.globalObject()->globalExec();
+        auto& lexicalGlobalObject = *domPromise.globalObject();
         auto& promise = *domPromise.promise();
 
         if (promise.isHandled(vm))
             continue;
 
@@ -169,11 +169,11 @@
         auto event = PromiseRejectionEvent::create(eventNames().unhandledrejectionEvent, initializer);
         auto target = m_context.errorEventTarget();
         target->dispatchEvent(event);
 
         if (!event->defaultPrevented())
-            m_context.reportUnhandledPromiseRejection(state, promise, unhandledPromise.callStack());
+            m_context.reportUnhandledPromiseRejection(lexicalGlobalObject, promise, unhandledPromise.callStack());
 
         if (!promise.isHandled(vm))
             m_outstandingRejectedPromises.set(&promise, &promise);
     }
 }

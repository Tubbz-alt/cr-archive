<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3LowerToAir.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="B3Kind.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3MemoryValue.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3LowerToAir.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,10 ***</span>
<span class="line-new-header">--- 29,11 ---</span>
  #if ENABLE(B3_JIT)
  
  #include &quot;AirBlockInsertionSet.h&quot;
  #include &quot;AirCCallSpecial.h&quot;
  #include &quot;AirCode.h&quot;
<span class="line-added">+ #include &quot;AirHelpers.h&quot;</span>
  #include &quot;AirInsertionSet.h&quot;
  #include &quot;AirInstInlines.h&quot;
  #include &quot;AirPrintSpecial.h&quot;
  #include &quot;AirStackSlot.h&quot;
  #include &quot;B3ArgumentRegValue.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,27 ***</span>
  #include &quot;B3WasmAddressValue.h&quot;
  #include &lt;wtf/IndexMap.h&gt;
  #include &lt;wtf/IndexSet.h&gt;
  #include &lt;wtf/ListDump.h&gt;
  
<span class="line-modified">! #if ASSERT_DISABLED</span>
  IGNORE_RETURN_TYPE_WARNINGS_BEGIN
  #endif
  
  namespace JSC { namespace B3 {
  
  namespace {
  
  namespace B3LowerToAirInternal {
<span class="line-modified">! static const bool verbose = false;</span>
  }
  
  using Arg = Air::Arg;
  using Inst = Air::Inst;
  using Code = Air::Code;
  using Tmp = Air::Tmp;
  
  // FIXME: We wouldn&#39;t need this if Air supported Width modifiers in Air::Kind.
  // https://bugs.webkit.org/show_bug.cgi?id=169247
  #define OPCODE_FOR_WIDTH(opcode, width) ( \
      (width) == Width8 ? Air::opcode ## 8 : \
      (width) == Width16 ? Air::opcode ## 16 :    \
<span class="line-new-header">--- 62,30 ---</span>
  #include &quot;B3WasmAddressValue.h&quot;
  #include &lt;wtf/IndexMap.h&gt;
  #include &lt;wtf/IndexSet.h&gt;
  #include &lt;wtf/ListDump.h&gt;
  
<span class="line-modified">! #if !ASSERT_ENABLED</span>
  IGNORE_RETURN_TYPE_WARNINGS_BEGIN
  #endif
  
  namespace JSC { namespace B3 {
  
  namespace {
  
  namespace B3LowerToAirInternal {
<span class="line-modified">! static constexpr bool verbose = false;</span>
  }
  
  using Arg = Air::Arg;
  using Inst = Air::Inst;
  using Code = Air::Code;
  using Tmp = Air::Tmp;
  
<span class="line-added">+ using Air::moveForType;</span>
<span class="line-added">+ using Air::relaxedMoveForType;</span>
<span class="line-added">+ </span>
  // FIXME: We wouldn&#39;t need this if Air supported Width modifiers in Air::Kind.
  // https://bugs.webkit.org/show_bug.cgi?id=169247
  #define OPCODE_FOR_WIDTH(opcode, width) ( \
      (width) == Width8 ? Air::opcode ## 8 : \
      (width) == Width16 ? Air::opcode ## 16 :    \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,14 ***</span>
          }
  
          for (B3::StackSlot* stack : m_procedure.stackSlots())
              m_stackToStack.add(stack, m_code.addStackSlot(stack));
          for (Variable* variable : m_procedure.variables()) {
<span class="line-modified">!             auto addResult = m_variableToTmps.add(variable, Vector&lt;Tmp, 1&gt;(m_procedure.returnCount(variable-&gt;type())));</span>
              ASSERT(addResult.isNewEntry);
<span class="line-modified">!             for (unsigned i = 0; i &lt; m_procedure.returnCount(variable-&gt;type()); ++i)</span>
<span class="line-modified">!                 addResult.iterator-&gt;value[i] = tmpForType(variable-&gt;type().isNumeric() ? variable-&gt;type() : m_procedure.extractFromTuple(variable-&gt;type(), i));</span>
          }
  
          // Figure out which blocks are not rare.
          m_fastWorklist.push(m_procedure[0]);
          while (B3::BasicBlock* block = m_fastWorklist.pop()) {
<span class="line-new-header">--- 157,14 ---</span>
          }
  
          for (B3::StackSlot* stack : m_procedure.stackSlots())
              m_stackToStack.add(stack, m_code.addStackSlot(stack));
          for (Variable* variable : m_procedure.variables()) {
<span class="line-modified">!             auto addResult = m_variableToTmps.add(variable, Vector&lt;Tmp, 1&gt;(m_procedure.resultCount(variable-&gt;type())));</span>
              ASSERT(addResult.isNewEntry);
<span class="line-modified">!             for (unsigned i = 0; i &lt; m_procedure.resultCount(variable-&gt;type()); ++i)</span>
<span class="line-modified">!                 addResult.iterator-&gt;value[i] = tmpForType(m_procedure.typeAtOffset(variable-&gt;type(), i));</span>
          }
  
          // Figure out which blocks are not rare.
          m_fastWorklist.push(m_procedure[0]);
          while (B3::BasicBlock* block = m_fastWorklist.pop()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,11 ***</span>
  
          auto fallback = [&amp;] () -&gt; Arg {
              return Arg::addr(tmp(address), offset);
          };
  
<span class="line-modified">!         static const unsigned lotsOfUses = 10; // This is arbitrary and we should tune it eventually.</span>
  
          // Only match if the address value isn&#39;t used in some large number of places.
          if (m_useCounts.numUses(address) &gt; lotsOfUses)
              return fallback();
  
<span class="line-new-header">--- 533,11 ---</span>
  
          auto fallback = [&amp;] () -&gt; Arg {
              return Arg::addr(tmp(address), offset);
          };
  
<span class="line-modified">!         static constexpr unsigned lotsOfUses = 10; // This is arbitrary and we should tune it eventually.</span>
  
          // Only match if the address value isn&#39;t used in some large number of places.
          if (m_useCounts.numUses(address) &gt; lotsOfUses)
              return fallback();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1171,66 ***</span>
          kind.effects |= memory-&gt;traps();
  
          append(createStore(kind, memory-&gt;child(0), dest));
      }
  
<span class="line-removed">-     Air::Opcode moveForType(Type type)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         using namespace Air;</span>
<span class="line-removed">-         switch (type.kind()) {</span>
<span class="line-removed">-         case Int32:</span>
<span class="line-removed">-             return Move32;</span>
<span class="line-removed">-         case Int64:</span>
<span class="line-removed">-             RELEASE_ASSERT(is64Bit());</span>
<span class="line-removed">-             return Move;</span>
<span class="line-removed">-         case Float:</span>
<span class="line-removed">-             return MoveFloat;</span>
<span class="line-removed">-         case Double:</span>
<span class="line-removed">-             return MoveDouble;</span>
<span class="line-removed">-         case Void:</span>
<span class="line-removed">-         case Tuple:</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         return Air::Oops;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Air::Opcode relaxedMoveForType(Type type)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         using namespace Air;</span>
<span class="line-removed">-         switch (type.kind()) {</span>
<span class="line-removed">-         case Int32:</span>
<span class="line-removed">-         case Int64:</span>
<span class="line-removed">-             // For Int32, we could return Move or Move32. It&#39;s a trade-off.</span>
<span class="line-removed">-             //</span>
<span class="line-removed">-             // Move32: Using Move32 guarantees that we use the narrower move, but in cases where the</span>
<span class="line-removed">-             //     register allocator can&#39;t prove that the variables involved are 32-bit, this will</span>
<span class="line-removed">-             //     disable coalescing.</span>
<span class="line-removed">-             //</span>
<span class="line-removed">-             // Move: Using Move guarantees that the register allocator can coalesce normally, but in</span>
<span class="line-removed">-             //     cases where it can&#39;t prove that the variables are 32-bit and it doesn&#39;t coalesce,</span>
<span class="line-removed">-             //     this will force us to use a full 64-bit Move instead of the slightly cheaper</span>
<span class="line-removed">-             //     32-bit Move32.</span>
<span class="line-removed">-             //</span>
<span class="line-removed">-             // Coalescing is a lot more profitable than turning Move into Move32. So, it&#39;s better to</span>
<span class="line-removed">-             // use Move here because in cases where the register allocator cannot prove that</span>
<span class="line-removed">-             // everything is 32-bit, we still get coalescing.</span>
<span class="line-removed">-             return Move;</span>
<span class="line-removed">-         case Float:</span>
<span class="line-removed">-             // MoveFloat is always coalescable and we never convert MoveDouble to MoveFloat, so we</span>
<span class="line-removed">-             // should use MoveFloat when we know that the temporaries involved are 32-bit.</span>
<span class="line-removed">-             return MoveFloat;</span>
<span class="line-removed">-         case Double:</span>
<span class="line-removed">-             return MoveDouble;</span>
<span class="line-removed">-         case Void:</span>
<span class="line-removed">-         case Tuple:</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         return Air::Oops;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
  #if ENABLE(MASM_PROBE)
      template&lt;typename... Arguments&gt;
      void print(Arguments&amp;&amp;... arguments)
      {
          Value* origin = m_value;
<span class="line-new-header">--- 1175,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2338,11 ***</span>
          Air::BasicBlock* failBlock = nullptr;
          if (!isBranch) {
              failBlock = newBlock();
              failure = failBlock;
          }
<span class="line-modified">!         Air::BasicBlock* strongFailBlock;</span>
          if (isStrong &amp;&amp; hasFence)
              strongFailBlock = newBlock();
          Air::FrequentedBlock comparisonFail = failure;
          Air::FrequentedBlock weakFail;
          if (isStrong) {
<span class="line-new-header">--- 2286,11 ---</span>
          Air::BasicBlock* failBlock = nullptr;
          if (!isBranch) {
              failBlock = newBlock();
              failure = failBlock;
          }
<span class="line-modified">!         Air::BasicBlock* strongFailBlock = nullptr;</span>
          if (isStrong &amp;&amp; hasFence)
              strongFailBlock = newBlock();
          Air::FrequentedBlock comparisonFail = failure;
          Air::FrequentedBlock weakFail;
          if (isStrong) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2747,11 ***</span>
              if (m_value-&gt;child(1)-&gt;isInt(0xffff)) {
                  appendUnOp&lt;ZeroExtend16To32, ZeroExtend16To32&gt;(m_value-&gt;child(0));
                  return;
              }
  
<span class="line-modified">!             if (m_value-&gt;child(1)-&gt;isInt(0xffffffff)) {</span>
                  appendUnOp&lt;Move32, Move32&gt;(m_value-&gt;child(0));
                  return;
              }
  
              appendBinOp&lt;And32, And64, AndDouble, AndFloat, Commutative&gt;(
<span class="line-new-header">--- 2695,11 ---</span>
              if (m_value-&gt;child(1)-&gt;isInt(0xffff)) {
                  appendUnOp&lt;ZeroExtend16To32, ZeroExtend16To32&gt;(m_value-&gt;child(0));
                  return;
              }
  
<span class="line-modified">!             if (m_value-&gt;child(1)-&gt;isInt64(0xffffffff) || m_value-&gt;child(1)-&gt;isInt32(0xffffffff)) {</span>
                  appendUnOp&lt;Move32, Move32&gt;(m_value-&gt;child(0));
                  return;
              }
  
              appendBinOp&lt;And32, And64, AndDouble, AndFloat, Commutative&gt;(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3738,10 ***</span>
      lowerToAir.run();
  }
  
  } } // namespace JSC::B3
  
<span class="line-modified">! #if ASSERT_DISABLED</span>
  IGNORE_RETURN_TYPE_WARNINGS_END
  #endif
  
  #endif // ENABLE(B3_JIT)
<span class="line-new-header">--- 3686,10 ---</span>
      lowerToAir.run();
  }
  
  } } // namespace JSC::B3
  
<span class="line-modified">! #if !ASSERT_ENABLED</span>
  IGNORE_RETURN_TYPE_WARNINGS_END
  #endif
  
  #endif // ENABLE(B3_JIT)
</pre>
<center><a href="B3Kind.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3MemoryValue.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
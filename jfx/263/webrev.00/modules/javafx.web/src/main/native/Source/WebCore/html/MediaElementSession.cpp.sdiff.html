<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/MediaElementSession.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MediaDocument.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MediaElementSession.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/MediaElementSession.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 295         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for video rate change restriction&quot;);
 296         return MediaPlaybackDenialReason::UserGestureRequired;
 297     }
 298 
 299     if (m_restrictions &amp; RequireUserGestureForAudioRateChange &amp;&amp; (!m_element.isVideo() || m_element.hasAudio()) &amp;&amp; !m_element.muted() &amp;&amp; m_element.volume() &amp;&amp; !document.processingUserGestureForMedia()) {
 300         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for audio rate change restriction&quot;);
 301         return MediaPlaybackDenialReason::UserGestureRequired;
 302     }
 303 
 304     if (m_restrictions &amp; RequireUserGestureForVideoDueToLowPowerMode &amp;&amp; m_element.isVideo() &amp;&amp; !document.processingUserGestureForMedia()) {
 305         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because of video low power mode restriction&quot;);
 306         return MediaPlaybackDenialReason::UserGestureRequired;
 307     }
 308 
 309     return { };
 310 }
 311 
 312 bool MediaElementSession::autoplayPermitted() const
 313 {
 314     const Document&amp; document = m_element.document();
<span class="line-modified"> 315     if (document.pageCacheState() != Document::NotInPageCache)</span>
 316         return false;
 317     if (document.activeDOMObjectsAreSuspended())
 318         return false;
 319 
 320     if (!hasBehaviorRestriction(MediaElementSession::InvisibleAutoplayNotPermitted))
 321         return true;
 322 
 323     // If the media element is audible, allow autoplay even when not visible as pausing it would be observable by the user.
 324     if ((!m_element.isVideo() || m_element.hasAudio()) &amp;&amp; !m_element.muted() &amp;&amp; m_element.volume())
 325         return true;
 326 
 327     auto* renderer = m_element.renderer();
 328     if (!renderer) {
 329         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element has no renderer&quot;);
 330         return false;
 331     }
 332     if (renderer-&gt;style().visibility() != Visibility::Visible) {
 333         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is not visible&quot;);
 334         return false;
 335     }
</pre>
<hr />
<pre>
 419     if (m_element.isSuspended() || !m_element.inActiveDocument()) {
 420         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: isSuspended()&quot;);
 421         return false;
 422     }
 423 
 424     if (m_element.isFullscreen()) {
 425         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is fullscreen&quot;);
 426         return true;
 427     }
 428 
 429     if (m_element.muted()) {
 430         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: muted&quot;);
 431         return false;
 432     }
 433 
 434     if (m_element.document().isMediaDocument() &amp;&amp; (m_element.document().frame() &amp;&amp; m_element.document().frame()-&gt;isMainFrame())) {
 435         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is media document&quot;);
 436         return true;
 437     }
 438 
<span class="line-modified"> 439     if (client().presentationType() == Audio) {</span>
 440         if (!hasBehaviorRestriction(RequireUserGestureToControlControlsManager) || m_element.document().processingUserGestureForMedia()) {
 441             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: audio element with user gesture&quot;);
 442             return true;
 443         }
 444 
 445         if (m_element.isPlaying() &amp;&amp; allowsPlaybackControlsForAutoplayingAudio()) {
 446             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: user has played media before&quot;);
 447             return true;
 448         }
 449 
 450         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: audio element is not suitable&quot;);
 451         return false;
 452     }
 453 
 454     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; !isElementRectMostlyInMainFrame(m_element)) {
 455         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: not in main frame&quot;);
 456         return false;
 457     }
 458 
 459     if (!m_element.hasAudio() &amp;&amp; !m_element.hasEverHadAudio()) {
</pre>
<hr />
<pre>
 583         return true;
 584     }
 585 
 586     if (m_element.hasAttributeWithoutSynchronization(HTMLNames::webkitwirelessvideoplaybackdisabledAttr)) {
 587         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE because of attribute&quot;);
 588         return true;
 589     }
 590 
 591 #if PLATFORM(IOS_FAMILY)
 592     auto&amp; legacyAirplayAttributeValue = m_element.attributeWithoutSynchronization(HTMLNames::webkitairplayAttr);
 593     if (equalLettersIgnoringASCIICase(legacyAirplayAttributeValue, &quot;deny&quot;)) {
 594         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE because of legacy attribute&quot;);
 595         return true;
 596     }
 597     if (equalLettersIgnoringASCIICase(legacyAirplayAttributeValue, &quot;allow&quot;)) {
 598         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE because of legacy attribute&quot;);
 599         return false;
 600     }
 601 #endif
 602 





 603     auto player = m_element.player();
 604     if (!player)
 605         return true;
 606 
 607     bool disabled = player-&gt;wirelessVideoPlaybackDisabled();
 608     INFO_LOG(LOGIDENTIFIER, &quot;returning &quot;, disabled, &quot; because media engine says so&quot;);
 609 
 610     return disabled;
 611 }
 612 
 613 void MediaElementSession::setWirelessVideoPlaybackDisabled(bool disabled)
 614 {
 615     if (disabled)
 616         addBehaviorRestriction(WirelessVideoPlaybackDisabled);
 617     else
 618         removeBehaviorRestriction(WirelessVideoPlaybackDisabled);
 619 
 620     auto player = m_element.player();
 621     if (!player)
 622         return;
</pre>
<hr />
<pre>
 661 }
 662 
 663 bool MediaElementSession::isPlayingToWirelessPlaybackTarget() const
 664 {
 665 #if !PLATFORM(IOS_FAMILY)
 666     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute())
 667         return false;
 668 #endif
 669 
 670     return client().isPlayingToWirelessPlaybackTarget();
 671 }
 672 
 673 void MediaElementSession::setShouldPlayToPlaybackTarget(bool shouldPlay)
 674 {
 675     INFO_LOG(LOGIDENTIFIER, shouldPlay);
 676     m_shouldPlayToPlaybackTarget = shouldPlay;
 677     updateClientDataBuffering();
 678     client().setShouldPlayToPlaybackTarget(shouldPlay);
 679 }
 680 






 681 void MediaElementSession::mediaStateDidChange(MediaProducer::MediaStateFlags state)
 682 {
 683     m_element.document().playbackTargetPickerClientStateDidChange(*this, state);
 684 }
 685 #endif
 686 
 687 MediaPlayer::Preload MediaElementSession::effectivePreloadForElement() const
 688 {
 689     MediaPlayer::Preload preload = m_element.preloadValue();
 690 
 691     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
 692         return preload;
 693 
 694     if (m_restrictions &amp; AutoPreloadingNotPermitted) {
<span class="line-modified"> 695         if (preload &gt; MediaPlayer::MetaData)</span>
<span class="line-modified"> 696             return MediaPlayer::MetaData;</span>
 697     }
 698 
 699     return preload;
 700 }
 701 
 702 bool MediaElementSession::requiresFullscreenForVideoPlayback() const
 703 {
 704     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
 705         return false;
 706 
 707     if (is&lt;HTMLAudioElement&gt;(m_element))
 708         return false;
 709 
 710     if (m_element.document().isMediaDocument()) {
 711         ASSERT(is&lt;HTMLVideoElement&gt;(m_element));
 712         const HTMLVideoElement&amp; videoElement = *downcast&lt;const HTMLVideoElement&gt;(&amp;m_element);
 713         if (m_element.readyState() &lt; HTMLVideoElement::HAVE_METADATA || !videoElement.hasEverHadVideo())
 714             return false;
 715     }
 716 
</pre>
</td>
<td>
<hr />
<pre>
 295         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for video rate change restriction&quot;);
 296         return MediaPlaybackDenialReason::UserGestureRequired;
 297     }
 298 
 299     if (m_restrictions &amp; RequireUserGestureForAudioRateChange &amp;&amp; (!m_element.isVideo() || m_element.hasAudio()) &amp;&amp; !m_element.muted() &amp;&amp; m_element.volume() &amp;&amp; !document.processingUserGestureForMedia()) {
 300         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for audio rate change restriction&quot;);
 301         return MediaPlaybackDenialReason::UserGestureRequired;
 302     }
 303 
 304     if (m_restrictions &amp; RequireUserGestureForVideoDueToLowPowerMode &amp;&amp; m_element.isVideo() &amp;&amp; !document.processingUserGestureForMedia()) {
 305         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because of video low power mode restriction&quot;);
 306         return MediaPlaybackDenialReason::UserGestureRequired;
 307     }
 308 
 309     return { };
 310 }
 311 
 312 bool MediaElementSession::autoplayPermitted() const
 313 {
 314     const Document&amp; document = m_element.document();
<span class="line-modified"> 315     if (document.backForwardCacheState() != Document::NotInBackForwardCache)</span>
 316         return false;
 317     if (document.activeDOMObjectsAreSuspended())
 318         return false;
 319 
 320     if (!hasBehaviorRestriction(MediaElementSession::InvisibleAutoplayNotPermitted))
 321         return true;
 322 
 323     // If the media element is audible, allow autoplay even when not visible as pausing it would be observable by the user.
 324     if ((!m_element.isVideo() || m_element.hasAudio()) &amp;&amp; !m_element.muted() &amp;&amp; m_element.volume())
 325         return true;
 326 
 327     auto* renderer = m_element.renderer();
 328     if (!renderer) {
 329         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element has no renderer&quot;);
 330         return false;
 331     }
 332     if (renderer-&gt;style().visibility() != Visibility::Visible) {
 333         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is not visible&quot;);
 334         return false;
 335     }
</pre>
<hr />
<pre>
 419     if (m_element.isSuspended() || !m_element.inActiveDocument()) {
 420         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: isSuspended()&quot;);
 421         return false;
 422     }
 423 
 424     if (m_element.isFullscreen()) {
 425         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is fullscreen&quot;);
 426         return true;
 427     }
 428 
 429     if (m_element.muted()) {
 430         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: muted&quot;);
 431         return false;
 432     }
 433 
 434     if (m_element.document().isMediaDocument() &amp;&amp; (m_element.document().frame() &amp;&amp; m_element.document().frame()-&gt;isMainFrame())) {
 435         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is media document&quot;);
 436         return true;
 437     }
 438 
<span class="line-modified"> 439     if (client().presentationType() == Audio &amp;&amp; purpose == PlaybackControlsPurpose::ControlsManager) {</span>
 440         if (!hasBehaviorRestriction(RequireUserGestureToControlControlsManager) || m_element.document().processingUserGestureForMedia()) {
 441             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: audio element with user gesture&quot;);
 442             return true;
 443         }
 444 
 445         if (m_element.isPlaying() &amp;&amp; allowsPlaybackControlsForAutoplayingAudio()) {
 446             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: user has played media before&quot;);
 447             return true;
 448         }
 449 
 450         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: audio element is not suitable&quot;);
 451         return false;
 452     }
 453 
 454     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; !isElementRectMostlyInMainFrame(m_element)) {
 455         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: not in main frame&quot;);
 456         return false;
 457     }
 458 
 459     if (!m_element.hasAudio() &amp;&amp; !m_element.hasEverHadAudio()) {
</pre>
<hr />
<pre>
 583         return true;
 584     }
 585 
 586     if (m_element.hasAttributeWithoutSynchronization(HTMLNames::webkitwirelessvideoplaybackdisabledAttr)) {
 587         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE because of attribute&quot;);
 588         return true;
 589     }
 590 
 591 #if PLATFORM(IOS_FAMILY)
 592     auto&amp; legacyAirplayAttributeValue = m_element.attributeWithoutSynchronization(HTMLNames::webkitairplayAttr);
 593     if (equalLettersIgnoringASCIICase(legacyAirplayAttributeValue, &quot;deny&quot;)) {
 594         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE because of legacy attribute&quot;);
 595         return true;
 596     }
 597     if (equalLettersIgnoringASCIICase(legacyAirplayAttributeValue, &quot;allow&quot;)) {
 598         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE because of legacy attribute&quot;);
 599         return false;
 600     }
 601 #endif
 602 
<span class="line-added"> 603     if (m_element.document().settings().remotePlaybackEnabled() &amp;&amp; m_element.hasAttributeWithoutSynchronization(HTMLNames::disableremoteplaybackAttr)) {</span>
<span class="line-added"> 604         LOG(Media, &quot;MediaElementSession::wirelessVideoPlaybackDisabled - returning TRUE because of RemotePlayback attribute&quot;);</span>
<span class="line-added"> 605         return true;</span>
<span class="line-added"> 606     }</span>
<span class="line-added"> 607 </span>
 608     auto player = m_element.player();
 609     if (!player)
 610         return true;
 611 
 612     bool disabled = player-&gt;wirelessVideoPlaybackDisabled();
 613     INFO_LOG(LOGIDENTIFIER, &quot;returning &quot;, disabled, &quot; because media engine says so&quot;);
 614 
 615     return disabled;
 616 }
 617 
 618 void MediaElementSession::setWirelessVideoPlaybackDisabled(bool disabled)
 619 {
 620     if (disabled)
 621         addBehaviorRestriction(WirelessVideoPlaybackDisabled);
 622     else
 623         removeBehaviorRestriction(WirelessVideoPlaybackDisabled);
 624 
 625     auto player = m_element.player();
 626     if (!player)
 627         return;
</pre>
<hr />
<pre>
 666 }
 667 
 668 bool MediaElementSession::isPlayingToWirelessPlaybackTarget() const
 669 {
 670 #if !PLATFORM(IOS_FAMILY)
 671     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute())
 672         return false;
 673 #endif
 674 
 675     return client().isPlayingToWirelessPlaybackTarget();
 676 }
 677 
 678 void MediaElementSession::setShouldPlayToPlaybackTarget(bool shouldPlay)
 679 {
 680     INFO_LOG(LOGIDENTIFIER, shouldPlay);
 681     m_shouldPlayToPlaybackTarget = shouldPlay;
 682     updateClientDataBuffering();
 683     client().setShouldPlayToPlaybackTarget(shouldPlay);
 684 }
 685 
<span class="line-added"> 686 void MediaElementSession::playbackTargetPickerWasDismissed()</span>
<span class="line-added"> 687 {</span>
<span class="line-added"> 688     INFO_LOG(LOGIDENTIFIER);</span>
<span class="line-added"> 689     client().playbackTargetPickerWasDismissed();</span>
<span class="line-added"> 690 }</span>
<span class="line-added"> 691 </span>
 692 void MediaElementSession::mediaStateDidChange(MediaProducer::MediaStateFlags state)
 693 {
 694     m_element.document().playbackTargetPickerClientStateDidChange(*this, state);
 695 }
 696 #endif
 697 
 698 MediaPlayer::Preload MediaElementSession::effectivePreloadForElement() const
 699 {
 700     MediaPlayer::Preload preload = m_element.preloadValue();
 701 
 702     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
 703         return preload;
 704 
 705     if (m_restrictions &amp; AutoPreloadingNotPermitted) {
<span class="line-modified"> 706         if (preload &gt; MediaPlayer::Preload::MetaData)</span>
<span class="line-modified"> 707             return MediaPlayer::Preload::MetaData;</span>
 708     }
 709 
 710     return preload;
 711 }
 712 
 713 bool MediaElementSession::requiresFullscreenForVideoPlayback() const
 714 {
 715     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
 716         return false;
 717 
 718     if (is&lt;HTMLAudioElement&gt;(m_element))
 719         return false;
 720 
 721     if (m_element.document().isMediaDocument()) {
 722         ASSERT(is&lt;HTMLVideoElement&gt;(m_element));
 723         const HTMLVideoElement&amp; videoElement = *downcast&lt;const HTMLVideoElement&gt;(&amp;m_element);
 724         if (m_element.readyState() &lt; HTMLVideoElement::HAVE_METADATA || !videoElement.hasEverHadVideo())
 725             return false;
 726     }
 727 
</pre>
</td>
</tr>
</table>
<center><a href="MediaDocument.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MediaElementSession.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
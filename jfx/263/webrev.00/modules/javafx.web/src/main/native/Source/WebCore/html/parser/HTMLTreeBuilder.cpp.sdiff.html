<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/parser/HTMLTreeBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLTokenizer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTMLTreeBuilder.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/parser/HTMLTreeBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 252     StringView m_text;
 253     bool m_isAll8BitData;
 254 };
 255 
 256 inline bool HTMLTreeBuilder::isParsingTemplateContents() const
 257 {
 258     return m_tree.openElements().hasTemplateInHTMLScope();
 259 }
 260 
 261 inline bool HTMLTreeBuilder::isParsingFragmentOrTemplateContents() const
 262 {
 263     return isParsingFragment() || isParsingTemplateContents();
 264 }
 265 
 266 HTMLTreeBuilder::HTMLTreeBuilder(HTMLDocumentParser&amp; parser, HTMLDocument&amp; document, ParserContentPolicy parserContentPolicy, const HTMLParserOptions&amp; options)
 267     : m_parser(parser)
 268     , m_options(options)
 269     , m_tree(document, parserContentPolicy, options.maximumDOMTreeDepth)
 270     , m_scriptToProcessStartPosition(uninitializedPositionValue1())
 271 {
<span class="line-modified"> 272 #if !ASSERT_DISABLED</span>
 273     m_destructionProhibited = false;
 274 #endif
 275 }
 276 
 277 HTMLTreeBuilder::HTMLTreeBuilder(HTMLDocumentParser&amp; parser, DocumentFragment&amp; fragment, Element&amp; contextElement, ParserContentPolicy parserContentPolicy, const HTMLParserOptions&amp; options)
 278     : m_parser(parser)
 279     , m_options(options)
 280     , m_fragmentContext(fragment, contextElement)
 281     , m_tree(fragment, parserContentPolicy, options.maximumDOMTreeDepth)
 282     , m_scriptToProcessStartPosition(uninitializedPositionValue1())
 283 {
 284     ASSERT(isMainThread());
 285 
 286     // https://html.spec.whatwg.org/multipage/syntax.html#parsing-html-fragments
 287     // For efficiency, we skip step 5 (&quot;Let root be a new html element with no attributes&quot;) and instead use the DocumentFragment as a root node.
 288     m_tree.openElements().pushRootNode(HTMLStackItem::create(fragment));
 289 
 290     if (contextElement.hasTagName(templateTag))
 291         m_templateInsertionModes.append(InsertionMode::TemplateContents);
 292 
 293     resetInsertionModeAppropriately();
 294 
 295     m_tree.setForm(is&lt;HTMLFormElement&gt;(contextElement) ? &amp;downcast&lt;HTMLFormElement&gt;(contextElement) : HTMLFormElement::findClosestFormAncestor(contextElement));
 296 
<span class="line-modified"> 297 #if !ASSERT_DISABLED</span>
 298     m_destructionProhibited = false;
 299 #endif
 300 }
 301 
 302 HTMLTreeBuilder::FragmentParsingContext::FragmentParsingContext()
 303 {
 304 }
 305 
 306 HTMLTreeBuilder::FragmentParsingContext::FragmentParsingContext(DocumentFragment&amp; fragment, Element&amp; contextElement)
 307     : m_fragment(&amp;fragment)
 308 {
 309     ASSERT(!fragment.hasChildNodes());
 310     m_contextElementStackItem = HTMLStackItem::create(contextElement);
 311 }
 312 
 313 inline Element&amp; HTMLTreeBuilder::FragmentParsingContext::contextElement() const
 314 {
 315     return contextElementStackItem().element();
 316 }
 317 
</pre>
<hr />
<pre>
 321     return *m_contextElementStackItem;
 322 }
 323 
 324 RefPtr&lt;ScriptElement&gt; HTMLTreeBuilder::takeScriptToProcess(TextPosition&amp; scriptStartPosition)
 325 {
 326     ASSERT(!m_destroyed);
 327 
 328     if (!m_scriptToProcess)
 329         return nullptr;
 330 
 331     // Unpause ourselves, callers may pause us again when processing the script.
 332     // The HTML5 spec is written as though scripts are executed inside the tree builder.
 333     // We pause the parser to exit the tree builder, and then resume before running scripts.
 334     scriptStartPosition = m_scriptToProcessStartPosition;
 335     m_scriptToProcessStartPosition = uninitializedPositionValue1();
 336     return WTFMove(m_scriptToProcess);
 337 }
 338 
 339 void HTMLTreeBuilder::constructTree(AtomicHTMLToken&amp;&amp; token)
 340 {
<span class="line-modified"> 341 #if !ASSERT_DISABLED</span>
 342     ASSERT(!m_destroyed);
 343     ASSERT(!m_destructionProhibited);
 344     m_destructionProhibited = true;
 345 #endif
 346 
 347     if (shouldProcessTokenInForeignContent(token))
 348         processTokenInForeignContent(WTFMove(token));
 349     else
 350         processToken(WTFMove(token));
 351 
 352     bool inForeignContent = !m_tree.isEmpty()
 353         &amp;&amp; !isInHTMLNamespace(adjustedCurrentStackItem())
 354         &amp;&amp; !HTMLElementStack::isHTMLIntegrationPoint(m_tree.currentStackItem())
 355         &amp;&amp; !HTMLElementStack::isMathMLTextIntegrationPoint(m_tree.currentStackItem());
 356 
 357     m_parser.tokenizer().setForceNullCharacterReplacement(m_insertionMode == InsertionMode::Text || inForeignContent);
 358     m_parser.tokenizer().setShouldAllowCDATA(inForeignContent);
 359 
<span class="line-modified"> 360 #if !ASSERT_DISABLED</span>
 361     m_destructionProhibited = false;
 362 #endif
 363 
 364     m_tree.executeQueuedTasks();
 365     // The tree builder might have been destroyed as an indirect result of executing the queued tasks.
 366 }
 367 
 368 void HTMLTreeBuilder::processToken(AtomicHTMLToken&amp;&amp; token)
 369 {
 370     switch (token.type()) {
 371     case HTMLToken::Uninitialized:
 372         ASSERT_NOT_REACHED();
 373         break;
 374     case HTMLToken::DOCTYPE:
 375         m_shouldSkipLeadingNewline = false;
 376         processDoctypeToken(WTFMove(token));
 377         break;
 378     case HTMLToken::StartTag:
 379         m_shouldSkipLeadingNewline = false;
 380         processStartTag(WTFMove(token));
</pre>
<hr />
<pre>
 774         m_framesetOk = false;
 775         m_insertionMode = InsertionMode::Text;
 776         return;
 777     }
 778     if (token.name() == xmpTag) {
 779         processFakePEndTagIfPInButtonScope();
 780         m_tree.reconstructTheActiveFormattingElements();
 781         m_framesetOk = false;
 782         processGenericRawTextStartTag(WTFMove(token));
 783         return;
 784     }
 785     if (token.name() == iframeTag) {
 786         m_framesetOk = false;
 787         processGenericRawTextStartTag(WTFMove(token));
 788         return;
 789     }
 790     if (token.name() == noembedTag) {
 791         processGenericRawTextStartTag(WTFMove(token));
 792         return;
 793     }
<span class="line-modified"> 794     if (token.name() == noscriptTag &amp;&amp; m_options.scriptEnabled) {</span>
 795         processGenericRawTextStartTag(WTFMove(token));
 796         return;
 797     }
 798     if (token.name() == selectTag) {
 799         m_tree.reconstructTheActiveFormattingElements();
 800         m_tree.insertHTMLElement(WTFMove(token));
 801         m_framesetOk = false;
 802         if (m_insertionMode == InsertionMode::InTable
 803             || m_insertionMode == InsertionMode::InCaption
 804             || m_insertionMode == InsertionMode::InColumnGroup
 805             || m_insertionMode == InsertionMode::InTableBody
 806             || m_insertionMode == InsertionMode::InRow
 807             || m_insertionMode == InsertionMode::InCell)
 808             m_insertionMode = InsertionMode::InSelectInTable;
 809         else
 810             m_insertionMode = InsertionMode::InSelect;
 811         return;
 812     }
 813     if (token.name() == optgroupTag || token.name() == optionTag) {
 814         if (is&lt;HTMLOptionElement&gt;(m_tree.currentStackItem().node())) {
</pre>
<hr />
<pre>
2591     ASSERT(token.type() == HTMLToken::StartTag);
2592     if (token.name() == htmlTag) {
2593         processHtmlStartTagForInBody(WTFMove(token));
2594         return true;
2595     }
2596     if (token.name() == baseTag
2597         || token.name() == basefontTag
2598         || token.name() == bgsoundTag
2599         || token.name() == commandTag
2600         || token.name() == linkTag
2601         || token.name() == metaTag) {
2602         m_tree.insertSelfClosingHTMLElement(WTFMove(token));
2603         // Note: The custom processing for the &lt;meta&gt; tag is done in HTMLMetaElement::process().
2604         return true;
2605     }
2606     if (token.name() == titleTag) {
2607         processGenericRCDATAStartTag(WTFMove(token));
2608         return true;
2609     }
2610     if (token.name() == noscriptTag) {
<span class="line-modified">2611         if (m_options.scriptEnabled) {</span>
2612             processGenericRawTextStartTag(WTFMove(token));
2613             return true;
2614         }
2615         m_tree.insertHTMLElement(WTFMove(token));
2616         m_insertionMode = InsertionMode::InHeadNoscript;
2617         return true;
2618     }
2619     if (token.name() == noframesTag || token.name() == styleTag) {
2620         processGenericRawTextStartTag(WTFMove(token));
2621         return true;
2622     }
2623     if (token.name() == scriptTag) {
2624         bool isSelfClosing = token.selfClosing();
2625         processScriptStartTag(WTFMove(token));
2626         if (m_options.usePreHTML5ParserQuirks &amp;&amp; isSelfClosing)
2627             processFakeEndTag(scriptTag);
2628         return true;
2629     }
2630     if (token.name() == templateTag) {
2631         m_framesetOk = false;
</pre>
</td>
<td>
<hr />
<pre>
 252     StringView m_text;
 253     bool m_isAll8BitData;
 254 };
 255 
 256 inline bool HTMLTreeBuilder::isParsingTemplateContents() const
 257 {
 258     return m_tree.openElements().hasTemplateInHTMLScope();
 259 }
 260 
 261 inline bool HTMLTreeBuilder::isParsingFragmentOrTemplateContents() const
 262 {
 263     return isParsingFragment() || isParsingTemplateContents();
 264 }
 265 
 266 HTMLTreeBuilder::HTMLTreeBuilder(HTMLDocumentParser&amp; parser, HTMLDocument&amp; document, ParserContentPolicy parserContentPolicy, const HTMLParserOptions&amp; options)
 267     : m_parser(parser)
 268     , m_options(options)
 269     , m_tree(document, parserContentPolicy, options.maximumDOMTreeDepth)
 270     , m_scriptToProcessStartPosition(uninitializedPositionValue1())
 271 {
<span class="line-modified"> 272 #if ASSERT_ENABLED</span>
 273     m_destructionProhibited = false;
 274 #endif
 275 }
 276 
 277 HTMLTreeBuilder::HTMLTreeBuilder(HTMLDocumentParser&amp; parser, DocumentFragment&amp; fragment, Element&amp; contextElement, ParserContentPolicy parserContentPolicy, const HTMLParserOptions&amp; options)
 278     : m_parser(parser)
 279     , m_options(options)
 280     , m_fragmentContext(fragment, contextElement)
 281     , m_tree(fragment, parserContentPolicy, options.maximumDOMTreeDepth)
 282     , m_scriptToProcessStartPosition(uninitializedPositionValue1())
 283 {
 284     ASSERT(isMainThread());
 285 
 286     // https://html.spec.whatwg.org/multipage/syntax.html#parsing-html-fragments
 287     // For efficiency, we skip step 5 (&quot;Let root be a new html element with no attributes&quot;) and instead use the DocumentFragment as a root node.
 288     m_tree.openElements().pushRootNode(HTMLStackItem::create(fragment));
 289 
 290     if (contextElement.hasTagName(templateTag))
 291         m_templateInsertionModes.append(InsertionMode::TemplateContents);
 292 
 293     resetInsertionModeAppropriately();
 294 
 295     m_tree.setForm(is&lt;HTMLFormElement&gt;(contextElement) ? &amp;downcast&lt;HTMLFormElement&gt;(contextElement) : HTMLFormElement::findClosestFormAncestor(contextElement));
 296 
<span class="line-modified"> 297 #if ASSERT_ENABLED</span>
 298     m_destructionProhibited = false;
 299 #endif
 300 }
 301 
 302 HTMLTreeBuilder::FragmentParsingContext::FragmentParsingContext()
 303 {
 304 }
 305 
 306 HTMLTreeBuilder::FragmentParsingContext::FragmentParsingContext(DocumentFragment&amp; fragment, Element&amp; contextElement)
 307     : m_fragment(&amp;fragment)
 308 {
 309     ASSERT(!fragment.hasChildNodes());
 310     m_contextElementStackItem = HTMLStackItem::create(contextElement);
 311 }
 312 
 313 inline Element&amp; HTMLTreeBuilder::FragmentParsingContext::contextElement() const
 314 {
 315     return contextElementStackItem().element();
 316 }
 317 
</pre>
<hr />
<pre>
 321     return *m_contextElementStackItem;
 322 }
 323 
 324 RefPtr&lt;ScriptElement&gt; HTMLTreeBuilder::takeScriptToProcess(TextPosition&amp; scriptStartPosition)
 325 {
 326     ASSERT(!m_destroyed);
 327 
 328     if (!m_scriptToProcess)
 329         return nullptr;
 330 
 331     // Unpause ourselves, callers may pause us again when processing the script.
 332     // The HTML5 spec is written as though scripts are executed inside the tree builder.
 333     // We pause the parser to exit the tree builder, and then resume before running scripts.
 334     scriptStartPosition = m_scriptToProcessStartPosition;
 335     m_scriptToProcessStartPosition = uninitializedPositionValue1();
 336     return WTFMove(m_scriptToProcess);
 337 }
 338 
 339 void HTMLTreeBuilder::constructTree(AtomicHTMLToken&amp;&amp; token)
 340 {
<span class="line-modified"> 341 #if ASSERT_ENABLED</span>
 342     ASSERT(!m_destroyed);
 343     ASSERT(!m_destructionProhibited);
 344     m_destructionProhibited = true;
 345 #endif
 346 
 347     if (shouldProcessTokenInForeignContent(token))
 348         processTokenInForeignContent(WTFMove(token));
 349     else
 350         processToken(WTFMove(token));
 351 
 352     bool inForeignContent = !m_tree.isEmpty()
 353         &amp;&amp; !isInHTMLNamespace(adjustedCurrentStackItem())
 354         &amp;&amp; !HTMLElementStack::isHTMLIntegrationPoint(m_tree.currentStackItem())
 355         &amp;&amp; !HTMLElementStack::isMathMLTextIntegrationPoint(m_tree.currentStackItem());
 356 
 357     m_parser.tokenizer().setForceNullCharacterReplacement(m_insertionMode == InsertionMode::Text || inForeignContent);
 358     m_parser.tokenizer().setShouldAllowCDATA(inForeignContent);
 359 
<span class="line-modified"> 360 #if ASSERT_ENABLED</span>
 361     m_destructionProhibited = false;
 362 #endif
 363 
 364     m_tree.executeQueuedTasks();
 365     // The tree builder might have been destroyed as an indirect result of executing the queued tasks.
 366 }
 367 
 368 void HTMLTreeBuilder::processToken(AtomicHTMLToken&amp;&amp; token)
 369 {
 370     switch (token.type()) {
 371     case HTMLToken::Uninitialized:
 372         ASSERT_NOT_REACHED();
 373         break;
 374     case HTMLToken::DOCTYPE:
 375         m_shouldSkipLeadingNewline = false;
 376         processDoctypeToken(WTFMove(token));
 377         break;
 378     case HTMLToken::StartTag:
 379         m_shouldSkipLeadingNewline = false;
 380         processStartTag(WTFMove(token));
</pre>
<hr />
<pre>
 774         m_framesetOk = false;
 775         m_insertionMode = InsertionMode::Text;
 776         return;
 777     }
 778     if (token.name() == xmpTag) {
 779         processFakePEndTagIfPInButtonScope();
 780         m_tree.reconstructTheActiveFormattingElements();
 781         m_framesetOk = false;
 782         processGenericRawTextStartTag(WTFMove(token));
 783         return;
 784     }
 785     if (token.name() == iframeTag) {
 786         m_framesetOk = false;
 787         processGenericRawTextStartTag(WTFMove(token));
 788         return;
 789     }
 790     if (token.name() == noembedTag) {
 791         processGenericRawTextStartTag(WTFMove(token));
 792         return;
 793     }
<span class="line-modified"> 794     if (token.name() == noscriptTag &amp;&amp; m_options.scriptingFlag) {</span>
 795         processGenericRawTextStartTag(WTFMove(token));
 796         return;
 797     }
 798     if (token.name() == selectTag) {
 799         m_tree.reconstructTheActiveFormattingElements();
 800         m_tree.insertHTMLElement(WTFMove(token));
 801         m_framesetOk = false;
 802         if (m_insertionMode == InsertionMode::InTable
 803             || m_insertionMode == InsertionMode::InCaption
 804             || m_insertionMode == InsertionMode::InColumnGroup
 805             || m_insertionMode == InsertionMode::InTableBody
 806             || m_insertionMode == InsertionMode::InRow
 807             || m_insertionMode == InsertionMode::InCell)
 808             m_insertionMode = InsertionMode::InSelectInTable;
 809         else
 810             m_insertionMode = InsertionMode::InSelect;
 811         return;
 812     }
 813     if (token.name() == optgroupTag || token.name() == optionTag) {
 814         if (is&lt;HTMLOptionElement&gt;(m_tree.currentStackItem().node())) {
</pre>
<hr />
<pre>
2591     ASSERT(token.type() == HTMLToken::StartTag);
2592     if (token.name() == htmlTag) {
2593         processHtmlStartTagForInBody(WTFMove(token));
2594         return true;
2595     }
2596     if (token.name() == baseTag
2597         || token.name() == basefontTag
2598         || token.name() == bgsoundTag
2599         || token.name() == commandTag
2600         || token.name() == linkTag
2601         || token.name() == metaTag) {
2602         m_tree.insertSelfClosingHTMLElement(WTFMove(token));
2603         // Note: The custom processing for the &lt;meta&gt; tag is done in HTMLMetaElement::process().
2604         return true;
2605     }
2606     if (token.name() == titleTag) {
2607         processGenericRCDATAStartTag(WTFMove(token));
2608         return true;
2609     }
2610     if (token.name() == noscriptTag) {
<span class="line-modified">2611         if (m_options.scriptingFlag) {</span>
2612             processGenericRawTextStartTag(WTFMove(token));
2613             return true;
2614         }
2615         m_tree.insertHTMLElement(WTFMove(token));
2616         m_insertionMode = InsertionMode::InHeadNoscript;
2617         return true;
2618     }
2619     if (token.name() == noframesTag || token.name() == styleTag) {
2620         processGenericRawTextStartTag(WTFMove(token));
2621         return true;
2622     }
2623     if (token.name() == scriptTag) {
2624         bool isSelfClosing = token.selfClosing();
2625         processScriptStartTag(WTFMove(token));
2626         if (m_options.usePreHTML5ParserQuirks &amp;&amp; isSelfClosing)
2627             processFakeEndTag(scriptTag);
2628         return true;
2629     }
2630     if (token.name() == templateTag) {
2631         m_framesetOk = false;
</pre>
</td>
</tr>
</table>
<center><a href="HTMLTokenizer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTMLTreeBuilder.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
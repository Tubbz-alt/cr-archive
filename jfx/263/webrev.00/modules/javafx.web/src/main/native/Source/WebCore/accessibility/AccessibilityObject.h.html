<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008, 2009, 2011 Apple Inc. All rights reserved.
  3  * Copyright (C) 2008 Nuanti Ltd.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 15  *     its contributors may be used to endorse or promote products derived
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;AccessibilityObjectInterface.h&quot;
 33 #include &quot;FloatQuad.h&quot;
 34 #include &quot;LayoutRect.h&quot;
 35 #include &quot;Path.h&quot;
 36 #include &quot;Range.h&quot;
 37 #include &lt;wtf/Forward.h&gt;
 38 #include &lt;wtf/Function.h&gt;
 39 #include &lt;wtf/RefPtr.h&gt;
 40 #include &lt;wtf/Vector.h&gt;
 41 
 42 #if PLATFORM(COCOA)
 43 #include &lt;wtf/RetainPtr.h&gt;
 44 #endif
 45 
 46 #if USE(ATK)
 47 #include &lt;wtf/glib/GRefPtr.h&gt;
 48 #endif
 49 
 50 #if PLATFORM(COCOA)
 51 
 52 OBJC_CLASS NSArray;
 53 OBJC_CLASS NSAttributedString;
 54 OBJC_CLASS NSData;
 55 OBJC_CLASS NSMutableAttributedString;
 56 OBJC_CLASS NSString;
 57 OBJC_CLASS NSValue;
 58 OBJC_CLASS NSView;
 59 
 60 #endif
 61 
 62 namespace WebCore {
 63 
 64 class AccessibilityObject;
 65 class IntPoint;
 66 class IntSize;
 67 class ScrollableArea;
 68 
 69 struct AccessibilityText {
 70     String text;
 71     AccessibilityTextSource textSource;
 72     Vector&lt;RefPtr&lt;AXCoreObject&gt;&gt; textElements;
 73 
 74     AccessibilityText(const String&amp; t, const AccessibilityTextSource&amp; s)
 75         : text(t)
 76         , textSource(s)
 77     { }
 78 
 79     AccessibilityText(const String&amp; t, const AccessibilityTextSource&amp; s, Vector&lt;AXCoreObject*&gt; elements)
 80         : text(t)
 81         , textSource(s)
 82     {
 83         textElements.reserveCapacity(elements.size());
 84         for (auto element : elements)
 85             textElements.uncheckedAppend(element);
 86     }
 87 
 88     AccessibilityText(const String&amp; t, const AccessibilityTextSource&amp; s, AXCoreObject* element)
 89         : text(t)
 90         , textSource(s)
 91     {
 92         textElements.append(element);
 93     }
 94 };
 95 
 96 bool nodeHasPresentationRole(Node*);
 97 
 98 class AccessibilityObject : public AXCoreObject {
 99 public:
100     virtual ~AccessibilityObject();
101 
102     // After constructing an AccessibilityObject, it must be given a
103     // unique ID, then added to AXObjectCache, and finally init() must
104     // be called last.
105     void setObjectID(AXID id) override { m_id = id; }
106     void init() override { }
107 
108     bool isDetached() const override;
109 
110     bool isAccessibilityNodeObject() const override { return false; }
111     bool isAccessibilityRenderObject() const override { return false; }
112     bool isAccessibilityScrollbar() const override { return false; }
113     bool isAccessibilityScrollView() const override { return false; }
114     bool isAccessibilitySVGRoot() const override { return false; }
115     bool isAccessibilitySVGElement() const override { return false; }
116 
117     bool isAttachmentElement() const override { return false; }
118     bool isHeading() const override { return false; }
119     bool isLink() const override { return false; }
120     bool isImage() const override { return false; }
121     bool isNativeImage() const override { return false; }
122     bool isImageButton() const override { return false; }
123     bool isPasswordField() const override { return false; }
124     bool isContainedByPasswordField() const override;
125     AccessibilityObject* passwordFieldOrContainingPasswordField() override { return nullptr; }
126     bool isNativeTextControl() const override { return false; }
127     bool isSearchField() const override { return false; }
128     bool isNativeListBox() const override { return false; }
129     bool isListBoxOption() const override { return false; }
130     bool isAttachment() const override { return false; }
131     bool isMediaTimeline() const override { return false; }
132     bool isMenuRelated() const override { return false; }
133     bool isMenu() const override { return false; }
134     bool isMenuBar() const override { return false; }
135     bool isMenuButton() const override { return false; }
136     bool isMenuItem() const override { return false; }
137     bool isFileUploadButton() const override { return false; }
138     bool isInputImage() const override { return false; }
139     bool isProgressIndicator() const override { return false; }
140     bool isSlider() const override { return false; }
141     bool isSliderThumb() const override { return false; }
142     bool isInputSlider() const override { return false; }
143     bool isControl() const override { return false; }
144     bool isLabel() const override { return false; }
145 
146     bool isList() const override { return false; }
147     bool isUnorderedList() const override { return false; }
148     bool isOrderedList() const override { return false; }
149     bool isDescriptionList() const override { return false; }
150 
151     bool isTable() const override { return false; }
152     bool isDataTable() const override { return false; }
153     bool isTableRow() const override { return false; }
154     bool isTableColumn() const override { return false; }
155     bool isTableCell() const override { return false; }
156     bool isFieldset() const override { return false; }
157     bool isGroup() const override { return false; }
158     bool isARIATreeGridRow() const override { return false; }
159     bool isImageMapLink() const override { return false; }
160     bool isMenuList() const override { return false; }
161     bool isMenuListPopup() const override { return false; }
162     bool isMenuListOption() const override { return false; }
163     bool isNativeSpinButton() const override { return false; }
164     AXCoreObject* incrementButton() override { return nullptr; }
165     AXCoreObject* decrementButton() override { return nullptr; }
166     bool isSpinButtonPart() const override { return false; }
167     bool isIncrementor() const override { return false; }
168     bool isMockObject() const override { return false; }
169     virtual bool isMediaControlLabel() const { return false; }
170     bool isMediaObject() const override { return false; }
171     bool isTextControl() const override;
172     bool isARIATextControl() const override;
173     bool isNonNativeTextControl() const override;
174     bool isButton() const override;
175     bool isBlockquote() const override;
176     bool isLandmark() const override;
177     bool isRangeControl() const override;
178     bool isMeter() const override;
179     bool isStyleFormatGroup() const override;
180     bool isFigureElement() const override;
181     bool isKeyboardFocusable() const override;
182     bool isOutput() const override;
183 
184     bool isChecked() const override { return false; }
185     bool isEnabled() const override { return false; }
186     bool isSelected() const override { return false; }
187     bool isFocused() const override { return false; }
188     bool isHovered() const override { return false; }
189     bool isIndeterminate() const override { return false; }
190     bool isLoaded() const override { return false; }
191     bool isMultiSelectable() const override { return false; }
192     bool isOffScreen() const override { return false; }
193     bool isPressed() const override { return false; }
194     bool isUnvisited() const override { return false; }
195     bool isVisited() const override { return false; }
196     bool isRequired() const override { return false; }
197     bool supportsRequiredAttribute() const override { return false; }
198     bool isLinked() const override { return false; }
199     bool isExpanded() const override;
200     bool isVisible() const override { return true; }
201     bool isCollapsed() const override { return false; }
202     void setIsExpanded(bool) override { }
203     FloatRect relativeFrame() const override;
204     FloatRect convertFrameToSpace(const FloatRect&amp;, AccessibilityConversionSpace) const override;
205 
206     // In a multi-select list, many items can be selected but only one is active at a time.
207     bool isSelectedOptionActive() const override { return false; }
208 
209     bool hasBoldFont() const override { return false; }
210     bool hasItalicFont() const override { return false; }
211     bool hasMisspelling() const override;
212     RefPtr&lt;Range&gt; getMisspellingRange(RefPtr&lt;Range&gt; const&amp; start, AccessibilitySearchDirection) const override;
213     bool hasPlainText() const override { return false; }
214     bool hasSameFont(RenderObject*) const override { return false; }
215     bool hasSameFontColor(RenderObject*) const override { return false; }
216     bool hasSameStyle(RenderObject*) const override { return false; }
217     bool hasUnderline() const override { return false; }
218     bool hasHighlighting() const override;
219 
220     bool supportsDatetimeAttribute() const override;
221     String datetimeAttributeValue() const override;
222 
223     bool canSetFocusAttribute() const override { return false; }
224     bool canSetTextRangeAttributes() const override { return false; }
225     bool canSetValueAttribute() const override { return false; }
226     bool canSetNumericValue() const override { return false; }
227     bool canSetSelectedAttribute() const override { return false; }
228     bool canSetSelectedChildrenAttribute() const override { return false; }
229     bool canSetExpandedAttribute() const override { return false; }
230 
231     Element* element() const override;
232     Node* node() const override { return nullptr; }
233     RenderObject* renderer() const override { return nullptr; }
234     bool accessibilityIsIgnored() const override;
235     AccessibilityObjectInclusion defaultObjectInclusion() const override;
236     bool accessibilityIsIgnoredByDefault() const override;
237 
238     bool isShowingValidationMessage() const override;
239     String validationMessage() const override;
240 
241     unsigned blockquoteLevel() const override;
242     int headingLevel() const override { return 0; }
243     int tableLevel() const override { return 0; }
244     AccessibilityButtonState checkboxOrRadioValue() const override;
245     String valueDescription() const override { return String(); }
246     float valueForRange() const override { return 0.0f; }
247     float maxValueForRange() const override { return 0.0f; }
248     float minValueForRange() const override { return 0.0f; }
249     float stepValueForRange() const override { return 0.0f; }
250     AXCoreObject* selectedRadioButton() override { return nullptr; }
251     AXCoreObject* selectedTabItem() override { return nullptr; }
252     AXCoreObject* selectedListItem() override;
253     int layoutCount() const override { return 0; }
254     double estimatedLoadingProgress() const override { return 0; }
255     WEBCORE_EXPORT static bool isARIAControl(AccessibilityRole);
256     WEBCORE_EXPORT static bool isARIAInput(AccessibilityRole);
257 
258     bool supportsARIAOwns() const override { return false; }
259     bool isActiveDescendantOfFocusedContainer() const override;
260     void ariaActiveDescendantReferencingElements(AccessibilityChildrenVector&amp;) const override;
261     void ariaControlsElements(AccessibilityChildrenVector&amp;) const override;
262     void ariaControlsReferencingElements(AccessibilityChildrenVector&amp;) const override;
263     void ariaDescribedByElements(AccessibilityChildrenVector&amp;) const override;
264     void ariaDescribedByReferencingElements(AccessibilityChildrenVector&amp;) const override;
265     void ariaDetailsElements(AccessibilityChildrenVector&amp;) const override;
266     void ariaDetailsReferencingElements(AccessibilityChildrenVector&amp;) const override;
267     void ariaErrorMessageElements(AccessibilityChildrenVector&amp;) const override;
268     void ariaErrorMessageReferencingElements(AccessibilityChildrenVector&amp;) const override;
269     void ariaFlowToElements(AccessibilityChildrenVector&amp;) const override;
270     void ariaFlowToReferencingElements(AccessibilityChildrenVector&amp;) const override;
271     void ariaLabelledByElements(AccessibilityChildrenVector&amp;) const override;
272     void ariaLabelledByReferencingElements(AccessibilityChildrenVector&amp;) const override;
273     void ariaOwnsElements(AccessibilityChildrenVector&amp;) const override;
274     void ariaOwnsReferencingElements(AccessibilityChildrenVector&amp;) const override;
275 
276     bool hasPopup() const override { return false; }
277     String popupValue() const override;
278     bool hasDatalist() const override;
279     bool supportsHasPopup() const override;
280     bool pressedIsPresent() const override;
281     bool ariaIsMultiline() const override;
282     String invalidStatus() const override;
283     bool supportsPressed() const override;
284     bool supportsExpanded() const override;
285     bool supportsChecked() const override;
286     AccessibilitySortDirection sortDirection() const override;
287     bool canvasHasFallbackContent() const override { return false; }
288     bool supportsRangeValue() const override;
289     String identifierAttribute() const override;
290     String linkRelValue() const override;
291     void classList(Vector&lt;String&gt;&amp;) const override;
292     AccessibilityCurrentState currentState() const override;
293     String currentValue() const override;
294     bool supportsCurrent() const override;
295     const String keyShortcutsValue() const override;
296 
297     // This function checks if the object should be ignored when there&#39;s a modal dialog displayed.
298     bool ignoredFromModalPresence() const override;
299     bool isModalDescendant(Node*) const override;
300     bool isModalNode() const override;
301 
302     bool supportsSetSize() const override;
303     bool supportsPosInSet() const override;
304     int setSize() const override;
305     int posInSet() const override;
306 
307     // ARIA drag and drop
308     bool supportsARIADropping() const override { return false; }
309     bool supportsARIADragging() const override { return false; }
310     bool isARIAGrabbed() override { return false; }
311     void setARIAGrabbed(bool) override { }
312     Vector&lt;String&gt; determineARIADropEffects() override { return { }; }
313 
314     // Called on the root AX object to return the deepest available element.
315     AXCoreObject* accessibilityHitTest(const IntPoint&amp;) const override { return nullptr; }
316     // Called on the AX object after the render tree determines which is the right AccessibilityRenderObject.
317     AXCoreObject* elementAccessibilityHitTest(const IntPoint&amp;) const override;
318 
319     AXCoreObject* focusedUIElement() const override;
320 
321     AccessibilityObject* firstChild() const override { return nullptr; }
322     AccessibilityObject* lastChild() const override { return nullptr; }
323     AccessibilityObject* previousSibling() const override { return nullptr; }
324     AccessibilityObject* nextSibling() const override { return nullptr; }
325     AccessibilityObject* nextSiblingUnignored(int limit) const override;
326     AccessibilityObject* previousSiblingUnignored(int limit) const override;
327     AccessibilityObject* parentObject() const override { return nullptr; }
328     AXCoreObject* parentObjectUnignored() const override;
329     AccessibilityObject* parentObjectIfExists() const override { return nullptr; }
330     static AccessibilityObject* firstAccessibleObjectFromNode(const Node*);
331     void findMatchingObjects(AccessibilitySearchCriteria*, AccessibilityChildrenVector&amp;) override;
332     bool isDescendantOfBarrenParent() const override { return false; }
333 
334     bool isDescendantOfRole(AccessibilityRole) const override;
335 
336     // Text selection
337 private:
338     RefPtr&lt;Range&gt; rangeOfStringClosestToRangeInDirection(Range*, AccessibilitySearchDirection, Vector&lt;String&gt; const&amp;) const;
339     RefPtr&lt;Range&gt; selectionRange() const;
340     RefPtr&lt;Range&gt; findTextRange(Vector&lt;String&gt; const&amp; searchStrings, RefPtr&lt;Range&gt; const&amp; start, AccessibilitySearchTextDirection) const;
341 public:
342     Vector&lt;RefPtr&lt;Range&gt;&gt; findTextRanges(AccessibilitySearchTextCriteria const&amp;) const override;
343     Vector&lt;String&gt; performTextOperation(AccessibilityTextOperation const&amp;) override;
344 
345     AccessibilityObject* observableObject() const override { return nullptr; }
346     void linkedUIElements(AccessibilityChildrenVector&amp;) const override { }
347     AccessibilityObject* titleUIElement() const override { return nullptr; }
348     bool exposesTitleUIElement() const override { return true; }
349     AccessibilityObject* correspondingLabelForControlElement() const override { return nullptr; }
350     AccessibilityObject* correspondingControlForLabelElement() const override { return nullptr; }
351     AccessibilityObject* scrollBar(AccessibilityOrientation) override { return nullptr; }
352 
353     AccessibilityRole ariaRoleAttribute() const override { return AccessibilityRole::Unknown; }
354     bool isPresentationalChildOfAriaRole() const override { return false; }
355     bool ariaRoleHasPresentationalChildren() const override { return false; }
356     bool inheritsPresentationalRole() const override { return false; }
357 
358     // Accessibility Text
359     void accessibilityText(Vector&lt;AccessibilityText&gt;&amp;) const override { };
360     // A single method for getting a computed label for an AXObject. It condenses the nuances of accessibilityText. Used by Inspector.
361     String computedLabel() override;
362 
363     // A programmatic way to set a name on an AccessibleObject.
364     void setAccessibleName(const AtomString&amp;) override { }
365     bool hasAttributesRequiredForInclusion() const override;
366 
367     // Accessibility Text - (To be deprecated).
368     String accessibilityDescription() const override { return String(); }
369     String title() const override { return String(); }
370     String helpText() const override { return String(); }
371 
372     // Methods for determining accessibility text.
373     bool isARIAStaticText() const override { return ariaRoleAttribute() == AccessibilityRole::StaticText; }
374     String stringValue() const override { return String(); }
375     String textUnderElement(AccessibilityTextUnderElementMode = AccessibilityTextUnderElementMode()) const override { return String(); }
376     String text() const override { return String(); }
377     int textLength() const override { return 0; }
378     String ariaLabeledByAttribute() const override { return String(); }
379     String ariaDescribedByAttribute() const override { return String(); }
380     const String placeholderValue() const override;
381     bool accessibleNameDerivesFromContent() const override;
382 
383     // Abbreviations
384     String expandedTextValue() const override { return String(); }
385     bool supportsExpandedTextValue() const override { return false; }
386 
387     void elementsFromAttribute(Vector&lt;Element*&gt;&amp;, const QualifiedName&amp;) const override;
388 
389     // Only if isColorWell()
390     void colorValue(int&amp; r, int&amp; g, int&amp; b) const override { r = 0; g = 0; b = 0; }
391 
392     AccessibilityRole roleValue() const override { return m_role; }
393     String rolePlatformString() const override;
394     String roleDescription() const override;
395     String ariaLandmarkRoleDescription() const override;
396 
397     AXObjectCache* axObjectCache() const override;
398     AXID objectID() const override { return m_id; }
399 
400     static AccessibilityObject* anchorElementForNode(Node*);
401     static AccessibilityObject* headingElementForNode(Node*);
402     Element* anchorElement() const override { return nullptr; }
403     bool supportsPressAction() const override;
404     Element* actionElement() const override { return nullptr; }
405     LayoutRect boundingBoxRect() const override { return LayoutRect(); }
406     LayoutRect elementRect() const override = 0;
407     IntPoint clickPoint() override;
408     static IntRect boundingBoxForQuads(RenderObject*, const Vector&lt;FloatQuad&gt;&amp;);
409     Path elementPath() const override { return Path(); }
410     bool supportsPath() const override { return false; }
411 
412     TextIteratorBehavior textIteratorBehaviorForTextRange() const override;
413     PlainTextRange selectedTextRange() const override { return PlainTextRange(); }
414     unsigned selectionStart() const override { return selectedTextRange().start; }
415     unsigned selectionEnd() const override { return selectedTextRange().length; }
416 
417     URL url() const override { return URL(); }
418     VisibleSelection selection() const override { return VisibleSelection(); }
419     String selectedText() const override { return String(); }
420     String accessKey() const override { return nullAtom(); }
421     String actionVerb() const override;
422     Widget* widget() const override { return nullptr; }
423     Widget* widgetForAttachmentView() const override { return nullptr; }
424     Page* page() const override;
425     Document* document() const override;
426     FrameView* documentFrameView() const override;
427     Frame* frame() const override;
428     Frame* mainFrame() const override;
429     Document* topDocument() const override;
430     ScrollView* scrollViewAncestor() const override;
431     String language() const override;
432     // 1-based, to match the aria-level spec.
433     unsigned hierarchicalLevel() const override { return 0; }
434     bool isInlineText() const override;
435 
436     void setFocused(bool) override { }
437     void setSelectedText(const String&amp;) override { }
438     void setSelectedTextRange(const PlainTextRange&amp;) override { }
439     void setValue(const String&amp;) override { }
440     bool replaceTextInRange(const String&amp;, const PlainTextRange&amp;) override;
441     bool insertText(const String&amp;) override;
442 
443     void setValue(float) override { }
444     void setSelected(bool) override { }
445     void setSelectedRows(AccessibilityChildrenVector&amp;) override { }
446 
447     void makeRangeVisible(const PlainTextRange&amp;) override { }
448     bool press() override;
449     bool performDefaultAction() override { return press(); }
450 
451     AccessibilityOrientation orientation() const override;
452     void increment() override { }
453     void decrement() override { }
454 
455     void childrenChanged() override { }
456     void textChanged() override { }
457     void updateAccessibilityRole() override { }
458     const AccessibilityChildrenVector&amp; children(bool updateChildrenIfNeeded = true) override;
459     void addChildren() override { }
460     void addChild(AXCoreObject*) override;
461     void insertChild(AXCoreObject*, unsigned) override;
462 
463     bool shouldIgnoreAttributeRole() const override { return false; }
464 
465     bool canHaveChildren() const override { return true; }
466     bool hasChildren() const override { return m_haveChildren; }
467     void updateChildrenIfNecessary() override;
468     void setNeedsToUpdateChildren() override { }
469     void setNeedsToUpdateSubtree() override { }
470     void clearChildren() override;
471     bool needsToUpdateChildren() const override { return false; }
472 #if PLATFORM(COCOA)
473     void detachFromParent() override;
474 #else
475     void detachFromParent() override { }
476 #endif
477     bool isDetachedFromParent() override { return false; }
478 
479     bool canHaveSelectedChildren() const override { return false; }
480     void selectedChildren(AccessibilityChildrenVector&amp;) override { }
481     void visibleChildren(AccessibilityChildrenVector&amp;) override { }
482     void tabChildren(AccessibilityChildrenVector&amp;) override { }
483     bool shouldFocusActiveDescendant() const override { return false; }
484     AccessibilityObject* activeDescendant() const override { return nullptr; }
485     void handleActiveDescendantChanged() override { }
486     void handleAriaExpandedChanged() override { }
487     bool isDescendantOfObject(const AXCoreObject*) const override;
488     bool isAncestorOfObject(const AXCoreObject*) const override;
489     AccessibilityObject* firstAnonymousBlockChild() const override;
490 
491     WEBCORE_EXPORT static AccessibilityRole ariaRoleToWebCoreRole(const String&amp;);
492     bool hasAttribute(const QualifiedName&amp;) const override;
493     const AtomString&amp; getAttribute(const QualifiedName&amp;) const override;
494     bool hasTagName(const QualifiedName&amp;) const override;
495     String tagName() const override;
496 
497     VisiblePositionRange visiblePositionRange() const override { return VisiblePositionRange(); }
498     VisiblePositionRange visiblePositionRangeForLine(unsigned) const override { return VisiblePositionRange(); }
499 
500     RefPtr&lt;Range&gt; elementRange() const override;
501     static bool replacedNodeNeedsCharacter(Node* replacedNode);
502 
503     VisiblePositionRange visiblePositionRangeForUnorderedPositions(const VisiblePosition&amp;, const VisiblePosition&amp;) const override;
504     VisiblePositionRange positionOfLeftWord(const VisiblePosition&amp;) const override;
505     VisiblePositionRange positionOfRightWord(const VisiblePosition&amp;) const override;
506     VisiblePositionRange leftLineVisiblePositionRange(const VisiblePosition&amp;) const override;
507     VisiblePositionRange rightLineVisiblePositionRange(const VisiblePosition&amp;) const override;
508     VisiblePositionRange sentenceForPosition(const VisiblePosition&amp;) const override;
509     VisiblePositionRange paragraphForPosition(const VisiblePosition&amp;) const override;
510     VisiblePositionRange styleRangeForPosition(const VisiblePosition&amp;) const override;
511     VisiblePositionRange visiblePositionRangeForRange(const PlainTextRange&amp;) const override;
512     VisiblePositionRange lineRangeForPosition(const VisiblePosition&amp;) const override;
513 
514     RefPtr&lt;Range&gt; rangeForPlainTextRange(const PlainTextRange&amp;) const override;
515 
516     static String stringForVisiblePositionRange(const VisiblePositionRange&amp;);
517     String stringForRange(RefPtr&lt;Range&gt;) const override;
518     IntRect boundsForVisiblePositionRange(const VisiblePositionRange&amp;) const override { return IntRect(); }
519     IntRect boundsForRange(const RefPtr&lt;Range&gt;) const override { return IntRect(); }
520     int lengthForVisiblePositionRange(const VisiblePositionRange&amp;) const override;
521     void setSelectedVisiblePositionRange(const VisiblePositionRange&amp;) const override { }
522 
523     VisiblePosition visiblePositionForBounds(const IntRect&amp;, AccessibilityVisiblePositionForBounds) const override;
524     VisiblePosition visiblePositionForPoint(const IntPoint&amp;) const override { return VisiblePosition(); }
525     VisiblePosition nextVisiblePosition(const VisiblePosition&amp; visiblePos) const override { return visiblePos.next(); }
526     VisiblePosition previousVisiblePosition(const VisiblePosition&amp; visiblePos) const override { return visiblePos.previous(); }
527     VisiblePosition nextWordEnd(const VisiblePosition&amp;) const override;
528     VisiblePosition previousWordStart(const VisiblePosition&amp;) const override;
529     VisiblePosition nextLineEndPosition(const VisiblePosition&amp;) const override;
530     VisiblePosition previousLineStartPosition(const VisiblePosition&amp;) const override;
531     VisiblePosition nextSentenceEndPosition(const VisiblePosition&amp;) const override;
532     VisiblePosition previousSentenceStartPosition(const VisiblePosition&amp;) const override;
533     VisiblePosition nextParagraphEndPosition(const VisiblePosition&amp;) const override;
534     VisiblePosition previousParagraphStartPosition(const VisiblePosition&amp;) const override;
535     VisiblePosition visiblePositionForIndex(unsigned, bool /*lastIndexOK */) const override { return VisiblePosition(); }
536 
537     VisiblePosition visiblePositionForIndex(int) const override { return VisiblePosition(); }
538     int indexForVisiblePosition(const VisiblePosition&amp;) const override { return 0; }
539 
540     AccessibilityObject* accessibilityObjectForPosition(const VisiblePosition&amp;) const override;
541     int lineForPosition(const VisiblePosition&amp;) const override;
542     PlainTextRange plainTextRangeForVisiblePositionRange(const VisiblePositionRange&amp;) const override;
543     int index(const VisiblePosition&amp;) const override { return -1; }
544 
545     void lineBreaks(Vector&lt;int&gt;&amp;) const override { }
546     PlainTextRange doAXRangeForLine(unsigned) const override { return PlainTextRange(); }
547     PlainTextRange doAXRangeForPosition(const IntPoint&amp;) const override;
548     PlainTextRange doAXRangeForIndex(unsigned) const override { return PlainTextRange(); }
549     PlainTextRange doAXStyleRangeForIndex(unsigned) const override;
550 
551     String doAXStringForRange(const PlainTextRange&amp;) const override { return String(); }
552     IntRect doAXBoundsForRange(const PlainTextRange&amp;) const override { return IntRect(); }
553     IntRect doAXBoundsForRangeUsingCharacterOffset(const PlainTextRange&amp;) const override { return IntRect(); }
554     static String listMarkerTextForNodeAndPosition(Node*, const VisiblePosition&amp;);
555 
556     unsigned doAXLineForIndex(unsigned) override;
557 
558     String computedRoleString() const override;
559 
560     String stringValueForMSAA() const override { return String(); }
561     String stringRoleForMSAA() const override { return String(); }
562     String nameForMSAA() const override { return String(); }
563     String descriptionForMSAA() const override { return String(); }
564     AccessibilityRole roleValueForMSAA() const override { return roleValue(); }
565 
566     String passwordFieldValue() const override { return String(); }
567     bool isValueAutofilled() const override;
568     bool isValueAutofillAvailable() const override;
569     AutoFillButtonType valueAutofillButtonType() const override;
570 
571     // Used by an ARIA tree to get all its rows.
572     void ariaTreeRows(AccessibilityChildrenVector&amp;) override;
573     // Used by an ARIA tree item to get all of its direct rows that it can disclose.
574     void ariaTreeItemDisclosedRows(AccessibilityChildrenVector&amp;) override;
575     // Used by an ARIA tree item to get only its content, and not its child tree items and groups.
576     void ariaTreeItemContent(AccessibilityChildrenVector&amp;) override;
577 
578     // ARIA live-region features.
579     bool supportsLiveRegion(bool excludeIfOff = true) const override;
580     bool isInsideLiveRegion(bool excludeIfOff = true) const override;
581     AccessibilityObject* liveRegionAncestor(bool excludeIfOff = true) const override;
582     const String liveRegionStatus() const override { return String(); }
583     const String liveRegionRelevant() const override { return nullAtom(); }
584     bool liveRegionAtomic() const override { return false; }
585     bool isBusy() const override { return false; }
586     static const String defaultLiveRegionStatusForRole(AccessibilityRole);
587     static bool liveRegionStatusIsEnabled(const AtomString&amp;);
588     static bool contentEditableAttributeIsEnabled(Element*);
589     bool hasContentEditableAttributeSet() const override;
590 
591     bool supportsReadOnly() const override;
592     String readOnlyValue() const override;
593 
594     bool supportsAutoComplete() const override;
595     String autoCompleteValue() const override;
596 
597     bool hasARIAValueNow() const override { return hasAttribute(HTMLNames::aria_valuenowAttr); }
598     bool supportsARIAAttributes() const override;
599 
600     // CSS3 Speech properties.
601     OptionSet&lt;SpeakAs&gt; speakAsProperty() const override { return OptionSet&lt;SpeakAs&gt; { }; }
602 
603     // Make this object visible by scrolling as many nested scrollable views as needed.
604     void scrollToMakeVisible() const override;
605     // Same, but if the whole object can&#39;t be made visible, try for this subrect, in local coordinates.
606     void scrollToMakeVisibleWithSubFocus(const IntRect&amp;) const override;
607     // Scroll this object to a given point in global coordinates of the top-level window.
608     void scrollToGlobalPoint(const IntPoint&amp;) const override;
609 
610     bool scrollByPage(ScrollByPageDirection) const override;
611     IntPoint scrollPosition() const override;
612     IntSize scrollContentsSize() const override;
613     IntRect scrollVisibleContentRect() const override;
614     void scrollToMakeVisible(const ScrollRectToVisibleOptions&amp;) const override;
615 
616     bool lastKnownIsIgnoredValue() override;
617     void setLastKnownIsIgnoredValue(bool) override;
618 
619     // Fires a children changed notification on the parent if the isIgnored value changed.
620     void notifyIfIgnoredValueChanged() override;
621 
622     // All math elements return true for isMathElement().
623     bool isMathElement() const override { return false; }
624     bool isMathFraction() const override { return false; }
625     bool isMathFenced() const override { return false; }
626     bool isMathSubscriptSuperscript() const override { return false; }
627     bool isMathRow() const override { return false; }
628     bool isMathUnderOver() const override { return false; }
629     bool isMathRoot() const override { return false; }
630     bool isMathSquareRoot() const override { return false; }
631     bool isMathText() const override { return false; }
632     bool isMathNumber() const override { return false; }
633     bool isMathOperator() const override { return false; }
634     bool isMathFenceOperator() const override { return false; }
635     bool isMathSeparatorOperator() const override { return false; }
636     bool isMathIdentifier() const override { return false; }
637     bool isMathTable() const override { return false; }
638     bool isMathTableRow() const override { return false; }
639     bool isMathTableCell() const override { return false; }
640     bool isMathMultiscript() const override { return false; }
641     bool isMathToken() const override { return false; }
642     bool isMathScriptObject(AccessibilityMathScriptObjectType) const override { return false; }
643     bool isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType) const override { return false; }
644 
645     // Root components.
646     AXCoreObject* mathRadicandObject() override { return nullptr; }
647     AXCoreObject* mathRootIndexObject() override { return nullptr; }
648 
649     // Under over components.
650     AXCoreObject* mathUnderObject() override { return nullptr; }
651     AXCoreObject* mathOverObject() override { return nullptr; }
652 
653     // Fraction components.
654     AXCoreObject* mathNumeratorObject() override { return nullptr; }
655     AXCoreObject* mathDenominatorObject() override { return nullptr; }
656 
657     // Subscript/superscript components.
658     AXCoreObject* mathBaseObject() override { return nullptr; }
659     AXCoreObject* mathSubscriptObject() override { return nullptr; }
660     AXCoreObject* mathSuperscriptObject() override { return nullptr; }
661 
662     // Fenced components.
663     String mathFencedOpenString() const override { return String(); }
664     String mathFencedCloseString() const override { return String(); }
665     int mathLineThickness() const override { return 0; }
666     bool isAnonymousMathOperator() const override { return false; }
667 
668     // Multiscripts components.
669     void mathPrescripts(AccessibilityMathMultiscriptPairs&amp;) override { }
670     void mathPostscripts(AccessibilityMathMultiscriptPairs&amp;) override { }
671 
672     // Visibility.
673     bool isAXHidden() const override;
674     bool isDOMHidden() const override;
675     bool isHidden() const override { return isAXHidden() || isDOMHidden(); }
676 
677 #if PLATFORM(COCOA)
678     void overrideAttachmentParent(AXCoreObject* parent) override;
679 #else
680     void overrideAttachmentParent(AXCoreObject*) override { }
681 #endif
682 
683 #if ENABLE(ACCESSIBILITY)
684     // a platform-specific method for determining if an attachment is ignored
685     bool accessibilityIgnoreAttachment() const override;
686     // gives platforms the opportunity to indicate if and how an object should be included
687     AccessibilityObjectInclusion accessibilityPlatformIncludesObject() const override;
688 #else
689     bool accessibilityIgnoreAttachment() const override { return true; }
690     AccessibilityObjectInclusion accessibilityPlatformIncludesObject() const override { return AccessibilityObjectInclusion::DefaultBehavior; }
691 #endif
692 
693 #if PLATFORM(IOS_FAMILY)
694     int accessibilityPasswordFieldLength() override;
695     bool hasTouchEventListener() const override;
696     bool isInputTypePopupButton() const override;
697 #endif
698 
699     // allows for an AccessibilityObject to update its render tree or perform
700     // other operations update type operations
701     void updateBackingStore() override;
702 
703 #if PLATFORM(COCOA)
704     bool preventKeyboardDOMEventDispatch() const override;
705     void setPreventKeyboardDOMEventDispatch(bool) override;
706     bool fileUploadButtonReturnsValueInTitle() const override;
707     String speechHintAttributeValue() const override;
708     String descriptionAttributeValue() const override;
709     String helpTextAttributeValue() const override;
710     String titleAttributeValue() const override;
711     bool hasApplePDFAnnotationAttribute() const override { return hasAttribute(HTMLNames::x_apple_pdf_annotationAttr); }
712 #endif
713 
714 #if PLATFORM(COCOA) &amp;&amp; !PLATFORM(IOS_FAMILY)
715     bool caretBrowsingEnabled() const override;
716     void setCaretBrowsingEnabled(bool) override;
717 #endif
718 
719     AccessibilityObject* focusableAncestor() override;
720     AccessibilityObject* editableAncestor() override;
721     AccessibilityObject* highestEditableAncestor() override;
722 
723     const AccessibilityScrollView* ancestorAccessibilityScrollView(bool includeSelf) const override;
724 
725     void clearIsIgnoredFromParentData() override { m_isIgnoredFromParentData = AccessibilityIsIgnoredFromParentData(); }
726     void setIsIgnoredFromParentDataForChild(AXCoreObject*) override;
727 
728     uint64_t sessionID() const override;
729     String documentURI() const override;
730     String documentEncoding() const override;
731 
732 protected:
733     AccessibilityObject() = default;
734     void detachRemoteParts(AccessibilityDetachmentType) override;
735     void detachPlatformWrapper(AccessibilityDetachmentType) override;
736 
737     AXID m_id { 0 };
738     AccessibilityChildrenVector m_children;
739     mutable bool m_haveChildren { false };
740     AccessibilityRole m_role { AccessibilityRole::Unknown };
741     AccessibilityObjectInclusion m_lastKnownIsIgnoredValue { AccessibilityObjectInclusion::DefaultBehavior };
742     AccessibilityIsIgnoredFromParentData m_isIgnoredFromParentData { };
743     bool m_childrenDirty { false };
744     bool m_subtreeDirty { false };
745 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
746     bool m_isolatedTreeNodeInitialized { false };
747 #endif
748 
749     void setIsIgnoredFromParentData(AccessibilityIsIgnoredFromParentData&amp; data) override { m_isIgnoredFromParentData = data; }
750 
751     virtual bool computeAccessibilityIsIgnored() const { return true; }
752     bool isAccessibilityObject() const override { return true; }
753 
754     // If this object itself scrolls, return its ScrollableArea.
755     virtual ScrollableArea* getScrollableAreaIfScrollable() const { return nullptr; }
756     virtual void scrollTo(const IntPoint&amp;) const { }
757     ScrollableArea* scrollableAreaAncestor() const;
758     void scrollAreaAndAncestor(std::pair&lt;ScrollableArea*, AccessibilityObject*&gt;&amp;) const;
759 
760     virtual AccessibilityRole buttonRoleType() const;
761     String rolePlatformDescription() const;
762     bool isOnScreen() const override;
763     bool dispatchTouchEvent();
764 
765     void ariaElementsFromAttribute(AccessibilityChildrenVector&amp;, const QualifiedName&amp;) const;
766     void ariaElementsReferencedByAttribute(AccessibilityChildrenVector&amp;, const QualifiedName&amp;) const;
767 
768     AccessibilityObject* radioGroupAncestor() const;
769 
770 #if ENABLE(ACCESSIBILITY) &amp;&amp; USE(ATK)
771     bool allowsTextRanges() const;
772     unsigned getLengthForTextRange() const;
773 #else
774     bool allowsTextRanges() const { return isTextControl(); }
775     unsigned getLengthForTextRange() const { return text().length(); }
776 #endif
777 };
778 
779 #if !ENABLE(ACCESSIBILITY)
780 inline const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityObject::children(bool) { return m_children; }
781 inline String AccessibilityObject::actionVerb() const { return emptyString(); }
782 inline int AccessibilityObject::lineForPosition(const VisiblePosition&amp;) const { return -1; }
783 inline void AccessibilityObject::updateBackingStore() { }
784 inline void AccessibilityObject::detachPlatformWrapper(AccessibilityDetachmentType) { }
785 #endif
786 
787 AccessibilityObject* firstAccessibleObjectFromNode(const Node*, const WTF::Function&lt;bool(const AccessibilityObject&amp;)&gt;&amp; isAccessible);
788 
789 namespace Accessibility {
790 
791 using PlatformRoleMap = HashMap&lt;AccessibilityRole, String, DefaultHash&lt;unsigned&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt;;
792 
793 PlatformRoleMap createPlatformRoleMap();
794 String roleToPlatformString(AccessibilityRole);
795 
796 } // namespace Accessibility
797 
798 } // namespace WebCore
799 
800 #define SPECIALIZE_TYPE_TRAITS_ACCESSIBILITY(ToValueTypeName, predicate) \
801 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToValueTypeName) \
802     static bool isType(const WebCore::AXCoreObject&amp; object) { return object.predicate; } \
803 SPECIALIZE_TYPE_TRAITS_END()
804 
805 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::AccessibilityObject)
806 static bool isType(const WebCore::AXCoreObject&amp; context) { return context.isAccessibilityObject(); }
807 SPECIALIZE_TYPE_TRAITS_END()
    </pre>
  </body>
</html>
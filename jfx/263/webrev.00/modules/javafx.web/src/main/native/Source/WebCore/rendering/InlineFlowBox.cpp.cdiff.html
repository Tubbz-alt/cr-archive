<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineFlowBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineBox.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineFlowBox.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineFlowBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 94,20 ***</span>
  
  void InlineFlowBox::addToLine(InlineBox* child)
  {
      ASSERT(!child-&gt;parent());
      ASSERT(!child-&gt;nextOnLine());
<span class="line-modified">!     ASSERT(!child-&gt;prevOnLine());</span>
      checkConsistency();
  
      child-&gt;setParent(this);
      if (!m_firstChild) {
          m_firstChild = child;
          m_lastChild = child;
      } else {
          m_lastChild-&gt;setNextOnLine(child);
<span class="line-modified">!         child-&gt;setPrevOnLine(m_lastChild);</span>
          m_lastChild = child;
      }
      child-&gt;setIsFirstLine(isFirstLine());
      child-&gt;setIsHorizontal(isHorizontal());
      if (child-&gt;behavesLikeText()) {
<span class="line-new-header">--- 94,20 ---</span>
  
  void InlineFlowBox::addToLine(InlineBox* child)
  {
      ASSERT(!child-&gt;parent());
      ASSERT(!child-&gt;nextOnLine());
<span class="line-modified">!     ASSERT(!child-&gt;previousOnLine());</span>
      checkConsistency();
  
      child-&gt;setParent(this);
      if (!m_firstChild) {
          m_firstChild = child;
          m_lastChild = child;
      } else {
          m_lastChild-&gt;setNextOnLine(child);
<span class="line-modified">!         child-&gt;setPreviousOnLine(m_lastChild);</span>
          m_lastChild = child;
      }
      child-&gt;setIsFirstLine(isFirstLine());
      child-&gt;setIsHorizontal(isHorizontal());
      if (child-&gt;behavesLikeText()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,15 ***</span>
      root().childRemoved(child);
  
      if (child == m_firstChild)
          m_firstChild = child-&gt;nextOnLine();
      if (child == m_lastChild)
<span class="line-modified">!         m_lastChild = child-&gt;prevOnLine();</span>
      if (child-&gt;nextOnLine())
<span class="line-modified">!         child-&gt;nextOnLine()-&gt;setPrevOnLine(child-&gt;prevOnLine());</span>
<span class="line-modified">!     if (child-&gt;prevOnLine())</span>
<span class="line-modified">!         child-&gt;prevOnLine()-&gt;setNextOnLine(child-&gt;nextOnLine());</span>
  
      child-&gt;setParent(nullptr);
  
      checkConsistency();
  }
<span class="line-new-header">--- 193,15 ---</span>
      root().childRemoved(child);
  
      if (child == m_firstChild)
          m_firstChild = child-&gt;nextOnLine();
      if (child == m_lastChild)
<span class="line-modified">!         m_lastChild = child-&gt;previousOnLine();</span>
      if (child-&gt;nextOnLine())
<span class="line-modified">!         child-&gt;nextOnLine()-&gt;setPreviousOnLine(child-&gt;previousOnLine());</span>
<span class="line-modified">!     if (child-&gt;previousOnLine())</span>
<span class="line-modified">!         child-&gt;previousOnLine()-&gt;setNextOnLine(child-&gt;nextOnLine());</span>
  
      child-&gt;setParent(nullptr);
  
      checkConsistency();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,11 ***</span>
              auto&amp; textBox = downcast&lt;InlineTextBox&gt;(*child);
              RenderText&amp; renderText = textBox.renderer();
              if (renderText.text().length()) {
                  if (needsWordSpacing &amp;&amp; isSpaceOrNewline(renderText.characterAt(textBox.start())))
                      logicalLeft += textBox.lineStyle().fontCascade().wordSpacing();
<span class="line-modified">!                 needsWordSpacing = !isSpaceOrNewline(renderText.characterAt(textBox.end()));</span>
              }
              textBox.setLogicalLeft(logicalLeft);
              if (knownToHaveNoOverflow())
                  minLogicalLeft = std::min(logicalLeft, minLogicalLeft);
              logicalLeft += textBox.logicalWidth();
<span class="line-new-header">--- 390,11 ---</span>
              auto&amp; textBox = downcast&lt;InlineTextBox&gt;(*child);
              RenderText&amp; renderText = textBox.renderer();
              if (renderText.text().length()) {
                  if (needsWordSpacing &amp;&amp; isSpaceOrNewline(renderText.characterAt(textBox.start())))
                      logicalLeft += textBox.lineStyle().fontCascade().wordSpacing();
<span class="line-modified">!                 needsWordSpacing = !isSpaceOrNewline(renderText.characterAt(textBox.end() - 1));</span>
              }
              textBox.setLogicalLeft(logicalLeft);
              if (knownToHaveNoOverflow())
                  minLogicalLeft = std::min(logicalLeft, minLogicalLeft);
              logicalLeft += textBox.logicalWidth();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1066,11 ***</span>
          return false;
  
      // Check children first.
      // We need to account for culled inline parents of the hit-tested nodes, so that they may also get included in area-based hit-tests.
      RenderElement* culledParent = nullptr;
<span class="line-modified">!     for (InlineBox* child = lastChild(); child; child = child-&gt;prevOnLine()) {</span>
          if (is&lt;RenderText&gt;(child-&gt;renderer()) || !child-&gt;boxModelObject()-&gt;hasSelfPaintingLayer()) {
              RenderElement* newParent = nullptr;
              // Culled parents are only relevant for area-based hit-tests, so ignore it in point-based ones.
              if (locationInContainer.isRectBasedTest()) {
                  newParent = child-&gt;renderer().parent();
<span class="line-new-header">--- 1066,11 ---</span>
          return false;
  
      // Check children first.
      // We need to account for culled inline parents of the hit-tested nodes, so that they may also get included in area-based hit-tests.
      RenderElement* culledParent = nullptr;
<span class="line-modified">!     for (InlineBox* child = lastChild(); child; child = child-&gt;previousOnLine()) {</span>
          if (is&lt;RenderText&gt;(child-&gt;renderer()) || !child-&gt;boxModelObject()-&gt;hasSelfPaintingLayer()) {
              RenderElement* newParent = nullptr;
              // Culled parents are only relevant for area-based hit-tests, so ignore it in point-based ones.
              if (locationInContainer.isRectBasedTest()) {
                  newParent = child-&gt;renderer().parent();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1365,19 ***</span>
      LayoutPoint adjustedPaintoffset = paintOffset + localRect.location();
      GraphicsContext&amp; context = paintInfo.context();
      LayoutRect paintRect = LayoutRect(adjustedPaintoffset, frameRect.size());
      // Shadow comes first and is behind the background and border.
      if (!renderer().boxShadowShouldBeAppliedToBackground(adjustedPaintoffset, BackgroundBleedNone, this))
<span class="line-modified">!         paintBoxShadow(paintInfo, lineStyle, Normal, paintRect);</span>
  
      auto color = lineStyle.visitedDependentColor(CSSPropertyBackgroundColor);
      auto compositeOp = renderer().document().compositeOperatorForBackgroundColor(color, renderer());
  
      color = lineStyle.colorByApplyingColorFilter(color);
  
      paintFillLayers(paintInfo, color, lineStyle.backgroundLayers(), paintRect, compositeOp);
<span class="line-modified">!     paintBoxShadow(paintInfo, lineStyle, Inset, paintRect);</span>
  
      // :first-line cannot be used to put borders on a line. Always paint borders with our
      // non-first-line style.
      if (!parent() || !renderer().style().hasVisibleBorderDecoration())
          return;
<span class="line-new-header">--- 1365,19 ---</span>
      LayoutPoint adjustedPaintoffset = paintOffset + localRect.location();
      GraphicsContext&amp; context = paintInfo.context();
      LayoutRect paintRect = LayoutRect(adjustedPaintoffset, frameRect.size());
      // Shadow comes first and is behind the background and border.
      if (!renderer().boxShadowShouldBeAppliedToBackground(adjustedPaintoffset, BackgroundBleedNone, this))
<span class="line-modified">!         paintBoxShadow(paintInfo, lineStyle, ShadowStyle::Normal, paintRect);</span>
  
      auto color = lineStyle.visitedDependentColor(CSSPropertyBackgroundColor);
      auto compositeOp = renderer().document().compositeOperatorForBackgroundColor(color, renderer());
  
      color = lineStyle.colorByApplyingColorFilter(color);
  
      paintFillLayers(paintInfo, color, lineStyle.backgroundLayers(), paintRect, compositeOp);
<span class="line-modified">!     paintBoxShadow(paintInfo, lineStyle, ShadowStyle::Inset, paintRect);</span>
  
      // :first-line cannot be used to put borders on a line. Always paint borders with our
      // non-first-line style.
      if (!parent() || !renderer().style().hasVisibleBorderDecoration())
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1436,20 ***</span>
  
      // Figure out if we need to push a transparency layer to render our mask.
      bool pushTransparencyLayer = false;
      bool compositedMask = renderer().hasLayer() &amp;&amp; renderer().layer()-&gt;hasCompositedMask();
      bool flattenCompositingLayers = renderer().view().frameView().paintBehavior().contains(PaintBehavior::FlattenCompositingLayers);
<span class="line-modified">!     CompositeOperator compositeOp = CompositeSourceOver;</span>
      if (!compositedMask || flattenCompositingLayers) {
          if ((maskBoxImage &amp;&amp; renderer().style().maskLayers().hasImage()) || renderer().style().maskLayers().next())
              pushTransparencyLayer = true;
  
<span class="line-modified">!         compositeOp = CompositeDestinationIn;</span>
          if (pushTransparencyLayer) {
<span class="line-modified">!             paintInfo.context().setCompositeOperation(CompositeDestinationIn);</span>
              paintInfo.context().beginTransparencyLayer(1.0f);
<span class="line-modified">!             compositeOp = CompositeSourceOver;</span>
          }
      }
  
      LayoutRect paintRect = LayoutRect(adjustedPaintOffset, frameRect.size());
      paintFillLayers(paintInfo, Color(), renderer().style().maskLayers(), paintRect, compositeOp);
<span class="line-new-header">--- 1436,20 ---</span>
  
      // Figure out if we need to push a transparency layer to render our mask.
      bool pushTransparencyLayer = false;
      bool compositedMask = renderer().hasLayer() &amp;&amp; renderer().layer()-&gt;hasCompositedMask();
      bool flattenCompositingLayers = renderer().view().frameView().paintBehavior().contains(PaintBehavior::FlattenCompositingLayers);
<span class="line-modified">!     CompositeOperator compositeOp = CompositeOperator::SourceOver;</span>
      if (!compositedMask || flattenCompositingLayers) {
          if ((maskBoxImage &amp;&amp; renderer().style().maskLayers().hasImage()) || renderer().style().maskLayers().next())
              pushTransparencyLayer = true;
  
<span class="line-modified">!         compositeOp = CompositeOperator::DestinationIn;</span>
          if (pushTransparencyLayer) {
<span class="line-modified">!             paintInfo.context().setCompositeOperation(CompositeOperator::DestinationIn);</span>
              paintInfo.context().beginTransparencyLayer(1.0f);
<span class="line-modified">!             compositeOp = CompositeOperator::SourceOver;</span>
          }
      }
  
      LayoutRect paintRect = LayoutRect(adjustedPaintOffset, frameRect.size());
      paintFillLayers(paintInfo, Color(), renderer().style().maskLayers(), paintRect, compositeOp);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1487,23 ***</span>
  
      if (pushTransparencyLayer)
          paintInfo.context().endTransparencyLayer();
  }
  
<span class="line-modified">! InlineBox* InlineFlowBox::firstLeafChild() const</span>
  {
      InlineBox* leaf = nullptr;
      for (InlineBox* child = firstChild(); child &amp;&amp; !leaf; child = child-&gt;nextOnLine())
<span class="line-modified">!         leaf = child-&gt;isLeaf() ? child : downcast&lt;InlineFlowBox&gt;(*child).firstLeafChild();</span>
      return leaf;
  }
  
<span class="line-modified">! InlineBox* InlineFlowBox::lastLeafChild() const</span>
  {
      InlineBox* leaf = nullptr;
<span class="line-modified">!     for (InlineBox* child = lastChild(); child &amp;&amp; !leaf; child = child-&gt;prevOnLine())</span>
<span class="line-modified">!         leaf = child-&gt;isLeaf() ? child : downcast&lt;InlineFlowBox&gt;(*child).lastLeafChild();</span>
      return leaf;
  }
  
  RenderObject::SelectionState InlineFlowBox::selectionState()
  {
<span class="line-new-header">--- 1487,23 ---</span>
  
      if (pushTransparencyLayer)
          paintInfo.context().endTransparencyLayer();
  }
  
<span class="line-modified">! InlineBox* InlineFlowBox::firstLeafDescendant() const</span>
  {
      InlineBox* leaf = nullptr;
      for (InlineBox* child = firstChild(); child &amp;&amp; !leaf; child = child-&gt;nextOnLine())
<span class="line-modified">!         leaf = child-&gt;isLeaf() ? child : downcast&lt;InlineFlowBox&gt;(*child).firstLeafDescendant();</span>
      return leaf;
  }
  
<span class="line-modified">! InlineBox* InlineFlowBox::lastLeafDescendant() const</span>
  {
      InlineBox* leaf = nullptr;
<span class="line-modified">!     for (InlineBox* child = lastChild(); child &amp;&amp; !leaf; child = child-&gt;previousOnLine())</span>
<span class="line-modified">!         leaf = child-&gt;isLeaf() ? child : downcast&lt;InlineFlowBox&gt;(*child).lastLeafDescendant();</span>
      return leaf;
  }
  
  RenderObject::SelectionState InlineFlowBox::selectionState()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1541,11 ***</span>
              visibleLeftEdge += box-&gt;logicalWidth();
              box = box-&gt;nextOnLine();
          }
          else {
              visibleRightEdge -= box-&gt;logicalWidth();
<span class="line-modified">!             box = box-&gt;prevOnLine();</span>
          }
      }
      return result;
  }
  
<span class="line-new-header">--- 1541,11 ---</span>
              visibleLeftEdge += box-&gt;logicalWidth();
              box = box-&gt;nextOnLine();
          }
          else {
              visibleRightEdge -= box-&gt;logicalWidth();
<span class="line-modified">!             box = box-&gt;previousOnLine();</span>
          }
      }
      return result;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1651,19 ***</span>
      return result;
  }
  
  void InlineFlowBox::collectLeafBoxesInLogicalOrder(Vector&lt;InlineBox*&gt;&amp; leafBoxesInLogicalOrder, CustomInlineBoxRangeReverse customReverseImplementation, void* userData) const
  {
<span class="line-modified">!     InlineBox* leaf = firstLeafChild();</span>
  
      // FIXME: The reordering code is a copy of parts from BidiResolver::createBidiRunsForLine, operating directly on InlineBoxes, instead of BidiRuns.
      // Investigate on how this code could possibly be shared.
      unsigned char minLevel = 128;
      unsigned char maxLevel = 0;
  
      // First find highest and lowest levels, and initialize leafBoxesInLogicalOrder with the leaf boxes in visual order.
<span class="line-modified">!     for (; leaf; leaf = leaf-&gt;nextLeafChild()) {</span>
          minLevel = std::min(minLevel, leaf-&gt;bidiLevel());
          maxLevel = std::max(maxLevel, leaf-&gt;bidiLevel());
          leafBoxesInLogicalOrder.append(leaf);
      }
  
<span class="line-new-header">--- 1651,19 ---</span>
      return result;
  }
  
  void InlineFlowBox::collectLeafBoxesInLogicalOrder(Vector&lt;InlineBox*&gt;&amp; leafBoxesInLogicalOrder, CustomInlineBoxRangeReverse customReverseImplementation, void* userData) const
  {
<span class="line-modified">!     InlineBox* leaf = firstLeafDescendant();</span>
  
      // FIXME: The reordering code is a copy of parts from BidiResolver::createBidiRunsForLine, operating directly on InlineBoxes, instead of BidiRuns.
      // Investigate on how this code could possibly be shared.
      unsigned char minLevel = 128;
      unsigned char maxLevel = 0;
  
      // First find highest and lowest levels, and initialize leafBoxesInLogicalOrder with the leaf boxes in visual order.
<span class="line-modified">!     for (; leaf; leaf = leaf-&gt;nextLeafOnLine()) {</span>
          minLevel = std::min(minLevel, leaf-&gt;bidiLevel());
          maxLevel = std::max(maxLevel, leaf-&gt;bidiLevel());
          leafBoxesInLogicalOrder.append(leaf);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1742,11 ***</span>
      ASSERT_WITH_SECURITY_IMPLICATION(!m_hasBadChildList);
  #ifdef CHECK_CONSISTENCY
      const InlineBox* previousChild = nullptr;
      for (const InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine()) {
          ASSERT(child-&gt;parent() == this);
<span class="line-modified">!         ASSERT(child-&gt;prevOnLine() == previousChild);</span>
          previousChild = child;
      }
      ASSERT(previousChild == m_lastChild);
  #endif
  }
<span class="line-new-header">--- 1742,11 ---</span>
      ASSERT_WITH_SECURITY_IMPLICATION(!m_hasBadChildList);
  #ifdef CHECK_CONSISTENCY
      const InlineBox* previousChild = nullptr;
      for (const InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine()) {
          ASSERT(child-&gt;parent() == this);
<span class="line-modified">!         ASSERT(child-&gt;previousOnLine() == previousChild);</span>
          previousChild = child;
      }
      ASSERT(previousChild == m_lastChild);
  #endif
  }
</pre>
<center><a href="InlineBox.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineFlowBox.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
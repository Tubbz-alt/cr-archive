<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/editing/ReplaceSelectionCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ReplaceRangeWithTextCommand.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReplaceSelectionCommand.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/ReplaceSelectionCommand.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -53,10 +53,11 @@</span>
  #include &quot;HTMLNames.h&quot;
  #include &quot;HTMLStyleElement.h&quot;
  #include &quot;HTMLTitleElement.h&quot;
  #include &quot;NodeList.h&quot;
  #include &quot;NodeRenderStyle.h&quot;
<span class="udiff-line-added">+ #include &quot;Position.h&quot;</span>
  #include &quot;RenderInline.h&quot;
  #include &quot;RenderText.h&quot;
  #include &quot;ScriptElement.h&quot;
  #include &quot;SimplifyMarkupCommand.h&quot;
  #include &quot;SmartReplace.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -385,11 +386,11 @@</span>
  {
      if (m_firstNodeInserted == node)
          m_firstNodeInserted = NodeTraversal::next(*node);
      if (m_lastNodeInserted == node) {
          m_lastNodeInserted = node-&gt;lastChild() ? node-&gt;lastChild() : NodeTraversal::nextSkippingChildren(*node);
<span class="udiff-line-modified-removed">-         if (!m_lastNodeInserted) {</span>
<span class="udiff-line-modified-added">+         if (!m_lastNodeInserted &amp;&amp; m_firstNodeInserted) {</span>
              // If the last inserted node is at the end of the document and doesn&#39;t have any children, look backwards for the
              // previous node as the last inserted node, clamping to the first inserted node if needed to ensure that the
              // document position of the last inserted node is not behind the first inserted node.
              auto* previousNode = NodeTraversal::previousSkippingChildren(*node);
              ASSERT(previousNode);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -518,10 +519,86 @@</span>
          // Don&#39;t merge to or from a position before or after a block because it would
          // be a no-op and cause infinite recursion.
          &amp;&amp; !isBlock(sourceNode) &amp;&amp; !isBlock(destinationNode);
  }
  
<span class="udiff-line-added">+ static bool fragmentNeedsColorTransformed(ReplacementFragment&amp; fragment, const Position&amp; insertionPos)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // Dark mode content that is inserted should have the inline styles inverse color</span>
<span class="udiff-line-added">+     // transformed by the color filter to match the color filtered document contents.</span>
<span class="udiff-line-added">+     // This applies to Mail and Notes when pasting from Xcode. &lt;rdar://problem/40529867&gt;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     RefPtr&lt;Element&gt; editableRoot = insertionPos.rootEditableElement();</span>
<span class="udiff-line-added">+     ASSERT(editableRoot);</span>
<span class="udiff-line-added">+     if (!editableRoot)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto* editableRootRenderer = editableRoot-&gt;renderer();</span>
<span class="udiff-line-added">+     if (!editableRootRenderer || !editableRootRenderer-&gt;style().hasAppleColorFilter())</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const auto&amp; colorFilter = editableRootRenderer-&gt;style().appleColorFilter();</span>
<span class="udiff-line-added">+     for (const auto&amp; colorFilterOperation : colorFilter.operations()) {</span>
<span class="udiff-line-added">+         if (colorFilterOperation-&gt;type() != FilterOperation::APPLE_INVERT_LIGHTNESS)</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto propertyLightness = [&amp;](const StyleProperties&amp; inlineStyle, CSSPropertyID propertyID) -&gt; Optional&lt;double&gt; {</span>
<span class="udiff-line-added">+         auto color = inlineStyle.propertyAsColor(propertyID);</span>
<span class="udiff-line-added">+         if (!color || !color.value().isVisible() || color.value().isSemantic())</span>
<span class="udiff-line-added">+             return { };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         double hue, saturation, lightness;</span>
<span class="udiff-line-added">+         color.value().getHSL(hue, saturation, lightness);</span>
<span class="udiff-line-added">+         return lightness;</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const double lightnessDarkEnoughForText = 0.4;</span>
<span class="udiff-line-added">+     const double lightnessLightEnoughForBackground = 0.6;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (RefPtr&lt;Node&gt; node = fragment.firstChild(); node; node = NodeTraversal::next(*node)) {</span>
<span class="udiff-line-added">+         if (!is&lt;StyledElement&gt;(*node))</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         auto&amp; element = downcast&lt;StyledElement&gt;(*node);</span>
<span class="udiff-line-added">+         auto* inlineStyle = element.inlineStyle();</span>
<span class="udiff-line-added">+         if (!inlineStyle)</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         auto textLightness = propertyLightness(*inlineStyle, CSSPropertyColor);</span>
<span class="udiff-line-added">+         if (textLightness &amp;&amp; *textLightness &lt; lightnessDarkEnoughForText)</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         auto backgroundLightness = propertyLightness(*inlineStyle, CSSPropertyBackgroundColor);</span>
<span class="udiff-line-added">+         if (backgroundLightness &amp;&amp; *backgroundLightness &gt; lightnessLightEnoughForBackground)</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ReplaceSelectionCommand::inverseTransformColor(InsertedNodes&amp; insertedNodes)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();</span>
<span class="udiff-line-added">+     for (RefPtr&lt;Node&gt; node = insertedNodes.firstNodeInserted(); node &amp;&amp; node != pastEndNode; node = NodeTraversal::next(*node)) {</span>
<span class="udiff-line-added">+         if (!is&lt;StyledElement&gt;(*node))</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         auto&amp; element = downcast&lt;StyledElement&gt;(*node);</span>
<span class="udiff-line-added">+         auto* inlineStyle = element.inlineStyle();</span>
<span class="udiff-line-added">+         if (!inlineStyle)</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         auto editingStyle = EditingStyle::create(inlineStyle);</span>
<span class="udiff-line-added">+         auto transformedStyle = editingStyle-&gt;inverseTransformColorIfNeeded(element);</span>
<span class="udiff-line-added">+         if (editingStyle.ptr() == transformedStyle.ptr())</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         setNodeAttribute(element, styleAttr, transformedStyle-&gt;style()-&gt;asText());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Style rules that match just inserted elements could change their appearance, like
  // a div inserted into a document with div { display:inline; }.
  void ReplaceSelectionCommand::removeRedundantStylesAndKeepStyleSpanInline(InsertedNodes&amp; insertedNodes)
  {
      RefPtr&lt;Node&gt; pastEndNode = insertedNodes.pastLastLeaf();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1113,12 +1190,12 @@</span>
  
      // Paste into run of tabs splits the tab span.
      insertionPos = positionOutsideTabSpan(insertionPos);
  
      bool hasBlankLinesBetweenParagraphs = hasBlankLineBetweenParagraphs(insertionPos);
<span class="udiff-line-removed">- </span>
      bool handledStyleSpans = handleStyleSpansBeforeInsertion(fragment, insertionPos);
<span class="udiff-line-added">+     bool needsColorTransformed = fragmentNeedsColorTransformed(fragment, insertionPos);</span>
  
      // We&#39;re finished if there is nothing to add.
      if (fragment.isEmpty() || !fragment.firstChild())
          return;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1230,10 +1307,13 @@</span>
  
      makeInsertedContentRoundTrippableWithHTMLTreeBuilder(insertedNodes);
      if (insertedNodes.isEmpty())
          return;
  
<span class="udiff-line-added">+     if (needsColorTransformed)</span>
<span class="udiff-line-added">+         inverseTransformColor(insertedNodes);</span>
<span class="udiff-line-added">+ </span>
      removeRedundantStylesAndKeepStyleSpanInline(insertedNodes);
      if (insertedNodes.isEmpty())
          return;
  
      if (m_sanitizeFragment)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1340,11 +1420,11 @@</span>
  RefPtr&lt;DataTransfer&gt; ReplaceSelectionCommand::inputEventDataTransfer() const
  {
      if (isEditingTextAreaOrTextInput())
          return CompositeEditCommand::inputEventDataTransfer();
  
<span class="udiff-line-modified-removed">-     return DataTransfer::createForInputEvent(document(), m_documentFragmentPlainText, m_documentFragmentHTMLMarkup);</span>
<span class="udiff-line-modified-added">+     return DataTransfer::createForInputEvent(m_documentFragmentPlainText, m_documentFragmentHTMLMarkup);</span>
  }
  
  bool ReplaceSelectionCommand::shouldRemoveEndBR(Node* endBR, const VisiblePosition&amp; originalVisPosBeforeEndBR)
  {
      if (!endBR || !endBR-&gt;isConnected())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1689,6 +1769,14 @@</span>
      setEndingSelection(selectionAfterReplace);
  
      return true;
  }
  
<span class="udiff-line-added">+ RefPtr&lt;Range&gt; ReplaceSelectionCommand::insertedContentRange() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (auto document = makeRefPtr(m_startOfInsertedContent.document()))</span>
<span class="udiff-line-added">+         return Range::create(*document, m_startOfInsertedContent, m_endOfInsertedContent);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return nullptr;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  } // namespace WebCore
</pre>
<center><a href="ReplaceRangeWithTextCommand.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReplaceSelectionCommand.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
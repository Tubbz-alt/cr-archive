diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/LargeRange.h b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/LargeRange.h
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/LargeRange.h
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/LargeRange.h
@@ -35,36 +35,51 @@
 public:
     LargeRange()
         : Range()
         , m_startPhysicalSize(0)
         , m_totalPhysicalSize(0)
+#if !BUSE(PARTIAL_SCAVENGE)
         , m_isEligible(true)
         , m_usedSinceLastScavenge(false)
+#endif
     {
     }
 
     LargeRange(const Range& other, size_t startPhysicalSize, size_t totalPhysicalSize)
         : Range(other)
         , m_startPhysicalSize(startPhysicalSize)
         , m_totalPhysicalSize(totalPhysicalSize)
+#if !BUSE(PARTIAL_SCAVENGE)
         , m_isEligible(true)
         , m_usedSinceLastScavenge(false)
+#endif
     {
         BASSERT(this->size() >= this->totalPhysicalSize());
         BASSERT(this->totalPhysicalSize() >= this->startPhysicalSize());
     }
 
+#if BUSE(PARTIAL_SCAVENGE)
+    LargeRange(void* begin, size_t size, size_t startPhysicalSize, size_t totalPhysicalSize)
+        : Range(begin, size)
+        , m_startPhysicalSize(startPhysicalSize)
+        , m_totalPhysicalSize(totalPhysicalSize)
+    {
+        BASSERT(this->size() >= this->totalPhysicalSize());
+        BASSERT(this->totalPhysicalSize() >= this->startPhysicalSize());
+    }
+#else
     LargeRange(void* begin, size_t size, size_t startPhysicalSize, size_t totalPhysicalSize, bool usedSinceLastScavenge = false)
         : Range(begin, size)
         , m_startPhysicalSize(startPhysicalSize)
         , m_totalPhysicalSize(totalPhysicalSize)
         , m_isEligible(true)
         , m_usedSinceLastScavenge(usedSinceLastScavenge)
     {
         BASSERT(this->size() >= this->totalPhysicalSize());
         BASSERT(this->totalPhysicalSize() >= this->startPhysicalSize());
     }
+#endif
 
     // Returns a lower bound on physical size at the start of the range. Ranges that
     // span non-physical fragments use this number to remember the physical size of
     // the first fragment.
     size_t startPhysicalSize() const { return m_startPhysicalSize; }
@@ -87,22 +102,28 @@
     std::pair<LargeRange, LargeRange> split(size_t) const;
 
     void setEligible(bool eligible) { m_isEligible = eligible; }
     bool isEligibile() const { return m_isEligible; }
 
+#if !BUSE(PARTIAL_SCAVENGE)
     bool usedSinceLastScavenge() const { return m_usedSinceLastScavenge; }
     void clearUsedSinceLastScavenge() { m_usedSinceLastScavenge = false; }
     void setUsedSinceLastScavenge() { m_usedSinceLastScavenge = true; }
+#endif
 
     bool operator<(const void* other) const { return begin() < other; }
     bool operator<(const LargeRange& other) const { return begin() < other.begin(); }
 
 private:
     size_t m_startPhysicalSize;
     size_t m_totalPhysicalSize;
+#if BUSE(PARTIAL_SCAVENGE)
+    bool m_isEligible { true };
+#else
     unsigned m_isEligible: 1;
     unsigned m_usedSinceLastScavenge: 1;
+#endif
 };
 
 inline bool canMerge(const LargeRange& a, const LargeRange& b)
 {
     if (!a.isEligibile() || !b.isEligibile()) {
@@ -121,26 +142,35 @@
 }
 
 inline LargeRange merge(const LargeRange& a, const LargeRange& b)
 {
     const LargeRange& left = std::min(a, b);
+#if !BUSE(PARTIAL_SCAVENGE)
     bool mergedUsedSinceLastScavenge = a.usedSinceLastScavenge() || b.usedSinceLastScavenge();
+#endif
     if (left.size() == left.startPhysicalSize()) {
         return LargeRange(
             left.begin(),
             a.size() + b.size(),
             a.startPhysicalSize() + b.startPhysicalSize(),
-            a.totalPhysicalSize() + b.totalPhysicalSize(),
-            mergedUsedSinceLastScavenge);
+            a.totalPhysicalSize() + b.totalPhysicalSize()
+#if !BUSE(PARTIAL_SCAVENGE)
+            , mergedUsedSinceLastScavenge
+#endif
+        );
+
     }
 
     return LargeRange(
         left.begin(),
         a.size() + b.size(),
         left.startPhysicalSize(),
-        a.totalPhysicalSize() + b.totalPhysicalSize(),
-        mergedUsedSinceLastScavenge);
+        a.totalPhysicalSize() + b.totalPhysicalSize()
+#if !BUSE(PARTIAL_SCAVENGE)
+        , mergedUsedSinceLastScavenge
+#endif
+    );
 }
 
 inline std::pair<LargeRange, LargeRange> LargeRange::split(size_t leftSize) const
 {
     BASSERT(leftSize <= this->size());

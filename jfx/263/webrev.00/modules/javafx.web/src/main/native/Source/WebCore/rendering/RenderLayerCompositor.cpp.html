<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2009, 2010 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;RenderLayerCompositor.h&quot;
  29 
  30 #include &quot;CSSAnimationController.h&quot;
  31 #include &quot;CSSPropertyNames.h&quot;
  32 #include &quot;CanvasRenderingContext.h&quot;
  33 #include &quot;Chrome.h&quot;
  34 #include &quot;ChromeClient.h&quot;
  35 #include &quot;Frame.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;FullscreenManager.h&quot;
  38 #include &quot;GraphicsLayer.h&quot;
  39 #include &quot;HTMLCanvasElement.h&quot;
  40 #include &quot;HTMLIFrameElement.h&quot;
  41 #include &quot;HTMLNames.h&quot;
  42 #include &quot;HitTestResult.h&quot;
  43 #include &quot;InspectorInstrumentation.h&quot;
  44 #include &quot;KeyframeEffectStack.h&quot;
  45 #include &quot;LayerAncestorClippingStack.h&quot;
  46 #include &quot;LayerOverlapMap.h&quot;
  47 #include &quot;Logging.h&quot;
  48 #include &quot;NodeList.h&quot;
  49 #include &quot;Page.h&quot;
  50 #include &quot;PageOverlayController.h&quot;
  51 #include &quot;RenderEmbeddedObject.h&quot;
  52 #include &quot;RenderFragmentedFlow.h&quot;
  53 #include &quot;RenderFullScreen.h&quot;
  54 #include &quot;RenderGeometryMap.h&quot;
  55 #include &quot;RenderIFrame.h&quot;
  56 #include &quot;RenderImage.h&quot;
  57 #include &quot;RenderLayerBacking.h&quot;
  58 #include &quot;RenderReplica.h&quot;
  59 #include &quot;RenderVideo.h&quot;
  60 #include &quot;RenderView.h&quot;
  61 #include &quot;RuntimeEnabledFeatures.h&quot;
  62 #include &quot;ScrollingConstraints.h&quot;
  63 #include &quot;ScrollingCoordinator.h&quot;
  64 #include &quot;Settings.h&quot;
  65 #include &quot;TiledBacking.h&quot;
  66 #include &quot;TransformState.h&quot;
  67 #include &lt;wtf/HexNumber.h&gt;
  68 #include &lt;wtf/MemoryPressureHandler.h&gt;
  69 #include &lt;wtf/SetForScope.h&gt;
  70 #include &lt;wtf/SystemTracing.h&gt;
  71 #include &lt;wtf/text/CString.h&gt;
  72 #include &lt;wtf/text/StringBuilder.h&gt;
  73 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  74 #include &lt;wtf/text/TextStream.h&gt;
  75 
  76 #if PLATFORM(IOS_FAMILY)
  77 #include &quot;LegacyTileCache.h&quot;
  78 #include &quot;RenderScrollbar.h&quot;
  79 #endif
  80 
  81 #if PLATFORM(MAC)
  82 #include &quot;LocalDefaultSystemAppearance.h&quot;
  83 #endif
  84 
  85 #if ENABLE(TREE_DEBUGGING)
  86 #include &quot;RenderTreeAsText.h&quot;
  87 #endif
  88 
  89 #if ENABLE(3D_TRANSFORMS)
  90 // This symbol is used to determine from a script whether 3D rendering is enabled (via &#39;nm&#39;).
  91 WEBCORE_EXPORT bool WebCoreHas3DRendering = true;
  92 #endif
  93 
  94 #if !PLATFORM(MAC) &amp;&amp; !PLATFORM(IOS_FAMILY)
  95 #define USE_COMPOSITING_FOR_SMALL_CANVASES 1
  96 #endif
  97 
  98 namespace WebCore {
  99 
 100 #if !USE(COMPOSITING_FOR_SMALL_CANVASES)
 101 static const int canvasAreaThresholdRequiringCompositing = 50 * 100;
 102 #endif
 103 // During page loading delay layer flushes up to this many seconds to allow them coalesce, reducing workload.
 104 #if PLATFORM(IOS_FAMILY)
 105 static const Seconds throttledLayerFlushInitialDelay { 500_ms };
 106 static const Seconds throttledLayerFlushDelay { 1.5_s };
 107 #else
 108 static const Seconds throttledLayerFlushInitialDelay { 500_ms };
 109 static const Seconds throttledLayerFlushDelay { 500_ms };
 110 #endif
 111 
 112 using namespace HTMLNames;
 113 
 114 struct ScrollingTreeState {
 115     Optional&lt;ScrollingNodeID&gt; parentNodeID;
 116     size_t nextChildIndex { 0 };
 117 };
 118 
 119 struct RenderLayerCompositor::OverlapExtent {
 120     LayoutRect bounds;
 121     bool extentComputed { false };
 122     bool hasTransformAnimation { false };
 123     bool animationCausesExtentUncertainty { false };
 124 
 125     bool knownToBeHaveExtentUncertainty() const { return extentComputed &amp;&amp; animationCausesExtentUncertainty; }
 126 };
 127 
 128 struct RenderLayerCompositor::CompositingState {
 129     CompositingState(RenderLayer* compAncestor, bool testOverlap = true)
 130         : compositingAncestor(compAncestor)
 131         , testingOverlap(testOverlap)
 132     {
 133     }
 134 
 135     CompositingState stateForPaintOrderChildren(RenderLayer&amp; layer) const
 136     {
 137         UNUSED_PARAM(layer);
 138         CompositingState childState(compositingAncestor);
 139         if (layer.isStackingContext())
 140             childState.stackingContextAncestor = &amp;layer;
 141         else
 142             childState.stackingContextAncestor = stackingContextAncestor;
 143 
 144         childState.backingSharingAncestor = backingSharingAncestor;
 145         childState.subtreeIsCompositing = false;
 146         childState.testingOverlap = testingOverlap;
 147         childState.fullPaintOrderTraversalRequired = fullPaintOrderTraversalRequired;
 148         childState.descendantsRequireCompositingUpdate = descendantsRequireCompositingUpdate;
 149         childState.ancestorHasTransformAnimation = ancestorHasTransformAnimation;
 150 #if ENABLE(CSS_COMPOSITING)
 151         childState.hasNotIsolatedCompositedBlendingDescendants = false; // FIXME: should this only be reset for stacking contexts?
 152 #endif
 153 #if !LOG_DISABLED
 154         childState.depth = depth + 1;
 155 #endif
 156         return childState;
 157     }
 158 
 159     void updateWithDescendantStateAndLayer(const CompositingState&amp; childState, const RenderLayer&amp; layer, const OverlapExtent&amp; layerExtent, bool isUnchangedSubtree = false)
 160     {
 161         // Subsequent layers in the parent stacking context also need to composite.
 162         subtreeIsCompositing |= childState.subtreeIsCompositing | layer.isComposited();
 163         if (!isUnchangedSubtree)
 164             fullPaintOrderTraversalRequired |= childState.fullPaintOrderTraversalRequired;
 165 
 166         // Turn overlap testing off for later layers if it&#39;s already off, or if we have an animating transform.
 167         // Note that if the layer clips its descendants, there&#39;s no reason to propagate the child animation to the parent layers. That&#39;s because
 168         // we know for sure the animation is contained inside the clipping rectangle, which is already added to the overlap map.
 169         auto canReenableOverlapTesting = [&amp;layer]() {
 170             return layer.isComposited() &amp;&amp; RenderLayerCompositor::clipsCompositingDescendants(layer);
 171         };
 172         if ((!childState.testingOverlap &amp;&amp; !canReenableOverlapTesting()) || layerExtent.knownToBeHaveExtentUncertainty())
 173             testingOverlap = false;
 174 
 175 #if ENABLE(CSS_COMPOSITING)
 176         if ((layer.isComposited() &amp;&amp; layer.hasBlendMode()) || (layer.hasNotIsolatedCompositedBlendingDescendants() &amp;&amp; !layer.isolatesCompositedBlending()))
 177             hasNotIsolatedCompositedBlendingDescendants = true;
 178 #endif
 179     }
 180 
 181     bool hasNonRootCompositedAncestor() const
 182     {
 183         return compositingAncestor &amp;&amp; !compositingAncestor-&gt;isRenderViewLayer();
 184     }
 185 
 186     RenderLayer* compositingAncestor;
 187     RenderLayer* backingSharingAncestor { nullptr };
 188     RenderLayer* stackingContextAncestor { nullptr };
 189     bool subtreeIsCompositing { false };
 190     bool testingOverlap { true };
 191     bool fullPaintOrderTraversalRequired { false };
 192     bool descendantsRequireCompositingUpdate { false };
 193     bool ancestorHasTransformAnimation { false };
 194 #if ENABLE(CSS_COMPOSITING)
 195     bool hasNotIsolatedCompositedBlendingDescendants { false };
 196 #endif
 197 #if !LOG_DISABLED
 198     unsigned depth { 0 };
 199 #endif
 200 };
 201 
 202 struct RenderLayerCompositor::UpdateBackingTraversalState {
 203 
 204     UpdateBackingTraversalState(RenderLayer* compAncestor = nullptr)
 205         : compositingAncestor(compAncestor)
 206     {
 207     }
 208 
 209     UpdateBackingTraversalState stateForDescendants() const
 210     {
 211         UpdateBackingTraversalState state(compositingAncestor);
 212 #if !LOG_DISABLED
 213         state.depth = depth + 1;
 214 #endif
 215         return state;
 216     }
 217 
 218     RenderLayer* compositingAncestor;
 219 #if !LOG_DISABLED
 220     unsigned depth { 0 };
 221 #endif
 222 };
 223 
 224 class RenderLayerCompositor::BackingSharingState {
 225     WTF_MAKE_NONCOPYABLE(BackingSharingState);
 226 public:
 227     BackingSharingState() = default;
 228 
 229     RenderLayer* backingProviderCandidate() const { return m_backingProviderCandidate; };
 230 
 231     void appendSharingLayer(RenderLayer&amp; layer)
 232     {
 233         ASSERT(m_backingProviderCandidate);
 234         m_backingSharingLayers.append(makeWeakPtr(layer));
 235     }
 236 
 237     void updateBeforeDescendantTraversal(RenderLayer&amp;, bool willBeComposited);
 238     void updateAfterDescendantTraversal(RenderLayer&amp;, RenderLayer* stackingContextAncestor);
 239 
 240 private:
 241     void layerWillBeComposited(RenderLayer&amp;);
 242 
 243     void startBackingSharingSequence(RenderLayer&amp; candidateLayer, RenderLayer* candidateStackingContext);
 244     void endBackingSharingSequence();
 245 
 246     RenderLayer* m_backingProviderCandidate { nullptr };
 247     RenderLayer* m_backingProviderStackingContext { nullptr };
 248     Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt; m_backingSharingLayers;
 249 };
 250 
 251 void RenderLayerCompositor::BackingSharingState::startBackingSharingSequence(RenderLayer&amp; candidateLayer, RenderLayer* candidateStackingContext)
 252 {
 253     ASSERT(!m_backingProviderCandidate);
 254     ASSERT(m_backingSharingLayers.isEmpty());
 255 
 256     m_backingProviderCandidate = &amp;candidateLayer;
 257     m_backingProviderStackingContext = candidateStackingContext;
 258 }
 259 
 260 void RenderLayerCompositor::BackingSharingState::endBackingSharingSequence()
 261 {
 262     if (m_backingProviderCandidate) {
 263         m_backingProviderCandidate-&gt;backing()-&gt;setBackingSharingLayers(WTFMove(m_backingSharingLayers));
 264         m_backingSharingLayers.clear();
 265     }
 266 
 267     m_backingProviderCandidate = nullptr;
 268 }
 269 
 270 void RenderLayerCompositor::BackingSharingState::updateBeforeDescendantTraversal(RenderLayer&amp; layer, bool willBeComposited)
 271 {
 272     layer.setBackingProviderLayer(nullptr);
 273 
 274     // A layer that composites resets backing-sharing, since subsequent layers need to composite to overlap it.
 275     if (willBeComposited) {
 276         m_backingSharingLayers.removeAll(&amp;layer);
 277         endBackingSharingSequence();
 278     }
 279 }
 280 
 281 void RenderLayerCompositor::BackingSharingState::updateAfterDescendantTraversal(RenderLayer&amp; layer, RenderLayer* stackingContextAncestor)
 282 {
 283     if (layer.isComposited()) {
 284         // If this layer is being composited, clean up sharing-related state.
 285         layer.disconnectFromBackingProviderLayer();
 286         m_backingSharingLayers.removeAll(&amp;layer);
 287     }
 288 
 289     if (m_backingProviderCandidate &amp;&amp; &amp;layer == m_backingProviderStackingContext) {
 290         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;End of stacking context for backing provider &quot; &lt;&lt; m_backingProviderCandidate &lt;&lt; &quot;, ending sharing sequence with &quot; &lt;&lt; m_backingSharingLayers.size() &lt;&lt; &quot; sharing layers&quot;);
 291         endBackingSharingSequence();
 292     } else if (!m_backingProviderCandidate &amp;&amp; layer.isComposited()) {
 293         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Post-descendant compositing of &quot; &lt;&lt; &amp;layer &lt;&lt; &quot;, ending sharing sequence for &quot; &lt;&lt; m_backingProviderCandidate &lt;&lt; &quot; with &quot; &lt;&lt; m_backingSharingLayers.size() &lt;&lt; &quot; sharing layers&quot;);
 294         endBackingSharingSequence();
 295         startBackingSharingSequence(layer, stackingContextAncestor);
 296     }
 297 
 298     if (&amp;layer != m_backingProviderCandidate &amp;&amp; layer.isComposited())
 299         layer.backing()-&gt;clearBackingSharingLayers();
 300 }
 301 
 302 #if !LOG_DISABLED || ENABLE(TREE_DEBUGGING)
 303 static inline bool compositingLogEnabled()
 304 {
 305     return LogCompositing.state == WTFLogChannelState::On;
 306 }
 307 
 308 static inline bool layersLogEnabled()
 309 {
 310     return LogLayers.state == WTFLogChannelState::On;
 311 }
 312 #endif
 313 
 314 RenderLayerCompositor::RenderLayerCompositor(RenderView&amp; renderView)
 315     : m_renderView(renderView)
 316     , m_updateCompositingLayersTimer(*this, &amp;RenderLayerCompositor::updateCompositingLayersTimerFired)
 317     , m_layerFlushTimer(*this, &amp;RenderLayerCompositor::layerFlushTimerFired)
 318 {
 319 #if PLATFORM(IOS_FAMILY)
 320     if (m_renderView.frameView().platformWidget())
 321         m_legacyScrollingLayerCoordinator = makeUnique&lt;LegacyWebKitScrollingLayerCoordinator&gt;(page().chrome().client(), isMainFrameCompositor());
 322 #endif
 323 }
 324 
 325 RenderLayerCompositor::~RenderLayerCompositor()
 326 {
 327     // Take care that the owned GraphicsLayers are deleted first as their destructors may call back here.
 328     GraphicsLayer::unparentAndClear(m_rootContentsLayer);
 329 
 330     GraphicsLayer::unparentAndClear(m_clipLayer);
 331     GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
 332     GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
 333 
 334     GraphicsLayer::unparentAndClear(m_overflowControlsHostLayer);
 335 
 336     GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
 337     GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
 338     GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
 339 
 340 #if ENABLE(RUBBER_BANDING)
 341     GraphicsLayer::unparentAndClear(m_layerForOverhangAreas);
 342     GraphicsLayer::unparentAndClear(m_contentShadowLayer);
 343     GraphicsLayer::unparentAndClear(m_layerForTopOverhangArea);
 344     GraphicsLayer::unparentAndClear(m_layerForBottomOverhangArea);
 345     GraphicsLayer::unparentAndClear(m_layerForHeader);
 346     GraphicsLayer::unparentAndClear(m_layerForFooter);
 347 #endif
 348 
 349     ASSERT(m_rootLayerAttachment == RootLayerUnattached);
 350 }
 351 
 352 void RenderLayerCompositor::enableCompositingMode(bool enable /* = true */)
 353 {
 354     if (enable != m_compositing) {
 355         m_compositing = enable;
 356 
 357         if (m_compositing) {
 358             ensureRootLayer();
 359             notifyIFramesOfCompositingChange();
 360         } else
 361             destroyRootLayer();
 362 
 363 
 364         m_renderView.layer()-&gt;setNeedsPostLayoutCompositingUpdate();
 365     }
 366 }
 367 
 368 void RenderLayerCompositor::cacheAcceleratedCompositingFlags()
 369 {
 370     auto&amp; settings = m_renderView.settings();
 371     bool hasAcceleratedCompositing = settings.acceleratedCompositingEnabled();
 372 
 373     // We allow the chrome to override the settings, in case the page is rendered
 374     // on a chrome that doesn&#39;t allow accelerated compositing.
 375     if (hasAcceleratedCompositing) {
 376         m_compositingTriggers = page().chrome().client().allowedCompositingTriggers();
 377         hasAcceleratedCompositing = m_compositingTriggers;
 378     }
 379 
 380     bool showDebugBorders = settings.showDebugBorders();
 381     bool showRepaintCounter = settings.showRepaintCounter();
 382     bool acceleratedDrawingEnabled = settings.acceleratedDrawingEnabled();
 383     bool displayListDrawingEnabled = settings.displayListDrawingEnabled();
 384 
 385     // forceCompositingMode for subframes can only be computed after layout.
 386     bool forceCompositingMode = m_forceCompositingMode;
 387     if (isMainFrameCompositor())
 388         forceCompositingMode = m_renderView.settings().forceCompositingMode() &amp;&amp; hasAcceleratedCompositing;
 389 
 390     if (hasAcceleratedCompositing != m_hasAcceleratedCompositing || showDebugBorders != m_showDebugBorders || showRepaintCounter != m_showRepaintCounter || forceCompositingMode != m_forceCompositingMode) {
 391         if (auto* rootLayer = m_renderView.layer()) {
 392             rootLayer-&gt;setNeedsCompositingConfigurationUpdate();
 393             rootLayer-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
 394         }
 395     }
 396 
 397     bool debugBordersChanged = m_showDebugBorders != showDebugBorders;
 398     m_hasAcceleratedCompositing = hasAcceleratedCompositing;
 399     m_forceCompositingMode = forceCompositingMode;
 400     m_showDebugBorders = showDebugBorders;
 401     m_showRepaintCounter = showRepaintCounter;
 402     m_acceleratedDrawingEnabled = acceleratedDrawingEnabled;
 403     m_displayListDrawingEnabled = displayListDrawingEnabled;
 404 
 405     if (debugBordersChanged) {
 406         if (m_layerForHorizontalScrollbar)
 407             m_layerForHorizontalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
 408 
 409         if (m_layerForVerticalScrollbar)
 410             m_layerForVerticalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
 411 
 412         if (m_layerForScrollCorner)
 413             m_layerForScrollCorner-&gt;setShowDebugBorder(m_showDebugBorders);
 414     }
 415 
 416     if (updateCompositingPolicy())
 417         rootRenderLayer().setDescendantsNeedCompositingRequirementsTraversal();
 418 }
 419 
 420 void RenderLayerCompositor::cacheAcceleratedCompositingFlagsAfterLayout()
 421 {
 422     cacheAcceleratedCompositingFlags();
 423 
 424     if (isMainFrameCompositor())
 425         return;
 426 
 427     RequiresCompositingData queryData;
 428     bool forceCompositingMode = m_hasAcceleratedCompositing &amp;&amp; m_renderView.settings().forceCompositingMode() &amp;&amp; requiresCompositingForScrollableFrame(queryData);
 429     if (forceCompositingMode != m_forceCompositingMode) {
 430         m_forceCompositingMode = forceCompositingMode;
 431         rootRenderLayer().setDescendantsNeedCompositingRequirementsTraversal();
 432     }
 433 }
 434 
 435 bool RenderLayerCompositor::updateCompositingPolicy()
 436 {
 437     if (!usesCompositing())
 438         return false;
 439 
 440     auto currentPolicy = m_compositingPolicy;
 441     if (page().compositingPolicyOverride()) {
 442         m_compositingPolicy = page().compositingPolicyOverride().value();
 443         return m_compositingPolicy != currentPolicy;
 444     }
 445 
 446     auto memoryPolicy = MemoryPressureHandler::currentMemoryUsagePolicy();
 447     m_compositingPolicy = memoryPolicy == WTF::MemoryUsagePolicy::Unrestricted ? CompositingPolicy::Normal : CompositingPolicy::Conservative;
 448     return m_compositingPolicy != currentPolicy;
 449 }
 450 
 451 bool RenderLayerCompositor::canRender3DTransforms() const
 452 {
 453     return hasAcceleratedCompositing() &amp;&amp; (m_compositingTriggers &amp; ChromeClient::ThreeDTransformTrigger);
 454 }
 455 
 456 void RenderLayerCompositor::willRecalcStyle()
 457 {
 458     cacheAcceleratedCompositingFlags();
 459 }
 460 
 461 bool RenderLayerCompositor::didRecalcStyleWithNoPendingLayout()
 462 {
 463     return updateCompositingLayers(CompositingUpdateType::AfterStyleChange);
 464 }
 465 
 466 void RenderLayerCompositor::customPositionForVisibleRectComputation(const GraphicsLayer* graphicsLayer, FloatPoint&amp; position) const
 467 {
 468     if (graphicsLayer != m_scrolledContentsLayer.get())
 469         return;
 470 
 471     FloatPoint scrollPosition = -position;
 472 
 473     if (m_renderView.frameView().scrollBehaviorForFixedElements() == StickToDocumentBounds)
 474         scrollPosition = m_renderView.frameView().constrainScrollPositionForOverhang(roundedIntPoint(scrollPosition));
 475 
 476     position = -scrollPosition;
 477 }
 478 
 479 void RenderLayerCompositor::notifyFlushRequired(const GraphicsLayer* layer)
 480 {
 481     scheduleLayerFlush(layer-&gt;canThrottleLayerFlush());
 482 }
 483 
 484 void RenderLayerCompositor::scheduleLayerFlush(bool canThrottle)
 485 {
 486     ASSERT(!m_flushingLayers);
 487 
 488     if (canThrottle)
 489         startInitialLayerFlushTimerIfNeeded();
 490 
 491     if (canThrottle &amp;&amp; isThrottlingLayerFlushes())
 492         m_hasPendingLayerFlush = true;
 493     else {
 494         m_hasPendingLayerFlush = false;
 495         page().renderingUpdateScheduler().scheduleRenderingUpdate();
 496     }
 497 }
 498 
 499 FloatRect RenderLayerCompositor::visibleRectForLayerFlushing() const
 500 {
 501     const FrameView&amp; frameView = m_renderView.frameView();
 502 #if PLATFORM(IOS_FAMILY)
 503     return frameView.exposedContentRect();
 504 #else
 505     // Having a m_scrolledContentsLayer indicates that we&#39;re doing scrolling via GraphicsLayers.
 506     FloatRect visibleRect = m_scrolledContentsLayer ? FloatRect({ }, frameView.sizeForVisibleContent()) : frameView.visibleContentRect();
 507 
 508     if (frameView.viewExposedRect())
 509         visibleRect.intersect(frameView.viewExposedRect().value());
 510 
 511     return visibleRect;
 512 #endif
 513 }
 514 
 515 void RenderLayerCompositor::flushPendingLayerChanges(bool isFlushRoot)
 516 {
 517     // FrameView::flushCompositingStateIncludingSubframes() flushes each subframe,
 518     // but GraphicsLayer::flushCompositingState() will cross frame boundaries
 519     // if the GraphicsLayers are connected (the RootLayerAttachedViaEnclosingFrame case).
 520     // As long as we&#39;re not the root of the flush, we can bail.
 521     if (!isFlushRoot &amp;&amp; rootLayerAttachment() == RootLayerAttachedViaEnclosingFrame)
 522         return;
 523 
 524     if (rootLayerAttachment() == RootLayerUnattached) {
 525 #if PLATFORM(IOS_FAMILY)
 526         startLayerFlushTimerIfNeeded();
 527 #endif
 528         m_shouldFlushOnReattach = true;
 529         return;
 530     }
 531 
 532     auto&amp; frameView = m_renderView.frameView();
 533     AnimationUpdateBlock animationUpdateBlock(&amp;frameView.frame().animation());
 534 
 535     ASSERT(!m_flushingLayers);
 536     {
 537         SetForScope&lt;bool&gt; flushingLayersScope(m_flushingLayers, true);
 538 
 539         if (auto* rootLayer = rootGraphicsLayer()) {
 540             FloatRect visibleRect = visibleRectForLayerFlushing();
 541             LOG_WITH_STREAM(Compositing,  stream &lt;&lt; &quot;\nRenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; flushPendingLayerChanges (is root &quot; &lt;&lt; isFlushRoot &lt;&lt; &quot;) visible rect &quot; &lt;&lt; visibleRect);
 542             rootLayer-&gt;flushCompositingState(visibleRect);
 543         }
 544 
 545         ASSERT(m_flushingLayers);
 546 
 547 #if ENABLE(TREE_DEBUGGING)
 548         if (layersLogEnabled()) {
 549             LOG(Layers, &quot;RenderLayerCompositor::flushPendingLayerChanges&quot;);
 550             showGraphicsLayerTree(rootGraphicsLayer());
 551         }
 552 #endif
 553     }
 554 
 555 #if PLATFORM(IOS_FAMILY)
 556     updateScrollCoordinatedLayersAfterFlushIncludingSubframes();
 557 
 558     if (isFlushRoot)
 559         page().chrome().client().didFlushCompositingLayers();
 560 #endif
 561 
 562     ++m_layerFlushCount;
 563     startLayerFlushTimerIfNeeded();
 564 }
 565 
 566 #if PLATFORM(IOS_FAMILY)
 567 void RenderLayerCompositor::updateScrollCoordinatedLayersAfterFlushIncludingSubframes()
 568 {
 569     updateScrollCoordinatedLayersAfterFlush();
 570 
 571     auto&amp; frame = m_renderView.frameView().frame();
 572     for (Frame* subframe = frame.tree().firstChild(); subframe; subframe = subframe-&gt;tree().traverseNext(&amp;frame)) {
 573         auto* view = subframe-&gt;contentRenderer();
 574         if (!view)
 575             continue;
 576 
 577         view-&gt;compositor().updateScrollCoordinatedLayersAfterFlush();
 578     }
 579 }
 580 
 581 void RenderLayerCompositor::updateScrollCoordinatedLayersAfterFlush()
 582 {
 583     if (m_legacyScrollingLayerCoordinator) {
 584         m_legacyScrollingLayerCoordinator-&gt;registerAllViewportConstrainedLayers(*this);
 585         m_legacyScrollingLayerCoordinator-&gt;registerAllScrollingLayers();
 586     }
 587 }
 588 #endif
 589 
 590 void RenderLayerCompositor::didChangePlatformLayerForLayer(RenderLayer&amp; layer, const GraphicsLayer*)
 591 {
 592     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
 593     if (!scrollingCoordinator)
 594         return;
 595 
 596     auto* backing = layer.backing();
 597     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling))
 598         updateScrollingNodeLayers(nodeID, layer, *scrollingCoordinator);
 599 
 600     if (auto* clippingStack = layer.backing()-&gt;ancestorClippingStack())
 601         clippingStack-&gt;updateScrollingNodeLayers(*scrollingCoordinator);
 602 
 603     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::ViewportConstrained))
 604         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });
 605 
 606     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
 607         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });
 608 
 609     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Positioning))
 610         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });
 611 }
 612 
 613 void RenderLayerCompositor::didPaintBacking(RenderLayerBacking*)
 614 {
 615     auto&amp; frameView = m_renderView.frameView();
 616     frameView.setLastPaintTime(MonotonicTime::now());
 617     if (frameView.milestonesPendingPaint())
 618         frameView.firePaintRelatedMilestonesIfNeeded();
 619 }
 620 
 621 void RenderLayerCompositor::didChangeVisibleRect()
 622 {
 623     auto* rootLayer = rootGraphicsLayer();
 624     if (!rootLayer)
 625         return;
 626 
 627     FloatRect visibleRect = visibleRectForLayerFlushing();
 628     bool requiresFlush = rootLayer-&gt;visibleRectChangeRequiresFlush(visibleRect);
 629     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor::didChangeVisibleRect &quot; &lt;&lt; visibleRect &lt;&lt; &quot; requiresFlush &quot; &lt;&lt; requiresFlush);
 630     if (requiresFlush)
 631         scheduleLayerFlush();
 632 }
 633 
 634 void RenderLayerCompositor::notifyFlushBeforeDisplayRefresh(const GraphicsLayer*)
 635 {
 636     if (!m_layerUpdater) {
 637         PlatformDisplayID displayID = page().chrome().displayID();
 638         m_layerUpdater = makeUnique&lt;GraphicsLayerUpdater&gt;(*this, displayID);
 639     }
 640 
 641     m_layerUpdater-&gt;scheduleUpdate();
 642 }
 643 
 644 void RenderLayerCompositor::flushLayersSoon(GraphicsLayerUpdater&amp;)
 645 {
 646     scheduleLayerFlush(true);
 647 }
 648 
 649 void RenderLayerCompositor::layerTiledBackingUsageChanged(const GraphicsLayer* graphicsLayer, bool usingTiledBacking)
 650 {
 651     if (usingTiledBacking) {
 652         ++m_layersWithTiledBackingCount;
 653         graphicsLayer-&gt;tiledBacking()-&gt;setIsInWindow(page().isInWindow());
 654     } else {
 655         ASSERT(m_layersWithTiledBackingCount &gt; 0);
 656         --m_layersWithTiledBackingCount;
 657     }
 658 }
 659 
 660 void RenderLayerCompositor::scheduleCompositingLayerUpdate()
 661 {
 662     if (!m_updateCompositingLayersTimer.isActive())
 663         m_updateCompositingLayersTimer.startOneShot(0_s);
 664 }
 665 
 666 void RenderLayerCompositor::updateCompositingLayersTimerFired()
 667 {
 668     updateCompositingLayers(CompositingUpdateType::AfterLayout);
 669 }
 670 
 671 void RenderLayerCompositor::cancelCompositingLayerUpdate()
 672 {
 673     m_updateCompositingLayersTimer.stop();
 674 }
 675 
 676 static Optional&lt;ScrollingNodeID&gt; frameHostingNodeForFrame(Frame&amp; frame)
 677 {
 678     if (!frame.document() || !frame.view())
 679         return { };
 680 
 681     // Find the frame&#39;s enclosing layer in our render tree.
 682     auto* ownerElement = frame.document()-&gt;ownerElement();
 683     if (!ownerElement)
 684         return { };
 685 
 686     auto* frameRenderer = ownerElement-&gt;renderer();
 687     if (!frameRenderer || !is&lt;RenderWidget&gt;(frameRenderer))
 688         return { };
 689 
 690     auto&amp; widgetRenderer = downcast&lt;RenderWidget&gt;(*frameRenderer);
 691     if (!widgetRenderer.hasLayer() || !widgetRenderer.layer()-&gt;isComposited()) {
 692         LOG(Scrolling, &quot;frameHostingNodeForFrame: frame renderer has no layer or is not composited.&quot;);
 693         return { };
 694     }
 695 
 696     if (auto frameHostingNodeID = widgetRenderer.layer()-&gt;backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
 697         return frameHostingNodeID;
 698 
 699     return { };
 700 }
 701 
 702 // Returns true on a successful update.
 703 bool RenderLayerCompositor::updateCompositingLayers(CompositingUpdateType updateType, RenderLayer* updateRoot)
 704 {
 705     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; contentLayersCount &quot; &lt;&lt; m_contentLayersCount);
 706 
 707     TraceScope tracingScope(CompositingUpdateStart, CompositingUpdateEnd);
 708 
 709 #if ENABLE(TREE_DEBUGGING)
 710     if (compositingLogEnabled())
 711         showPaintOrderTree(m_renderView.layer());
 712 #endif
 713 
 714     if (updateType == CompositingUpdateType::AfterStyleChange || updateType == CompositingUpdateType::AfterLayout)
 715         cacheAcceleratedCompositingFlagsAfterLayout(); // Some flags (e.g. forceCompositingMode) depend on layout.
 716 
 717     m_updateCompositingLayersTimer.stop();
 718 
 719     ASSERT(m_renderView.document().backForwardCacheState() == Document::NotInBackForwardCache
 720         || m_renderView.document().backForwardCacheState() == Document::AboutToEnterBackForwardCache);
 721 
 722     // Compositing layers will be updated in Document::setVisualUpdatesAllowed(bool) if suppressed here.
 723     if (!m_renderView.document().visualUpdatesAllowed())
 724         return false;
 725 
 726     // Avoid updating the layers with old values. Compositing layers will be updated after the layout is finished.
 727     // This happens when m_updateCompositingLayersTimer fires before layout is updated.
 728     if (m_renderView.needsLayout()) {
 729         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; - m_renderView.needsLayout, bailing &quot;);
 730         return false;
 731     }
 732 
 733     if (!m_compositing &amp;&amp; (m_forceCompositingMode || (isMainFrameCompositor() &amp;&amp; page().pageOverlayController().overlayCount())))
 734         enableCompositingMode(true);
 735 
 736     bool isPageScroll = !updateRoot || updateRoot == &amp;rootRenderLayer();
 737     updateRoot = &amp;rootRenderLayer();
 738 
 739     if (updateType == CompositingUpdateType::OnScroll || updateType == CompositingUpdateType::OnCompositedScroll) {
 740         // We only get here if we didn&#39;t scroll on the scrolling thread, so this update needs to re-position viewport-constrained layers.
 741         if (m_renderView.settings().acceleratedCompositingForFixedPositionEnabled() &amp;&amp; isPageScroll) {
 742             if (auto* viewportConstrainedObjects = m_renderView.frameView().viewportConstrainedObjects()) {
 743                 for (auto* renderer : *viewportConstrainedObjects) {
 744                     if (auto* layer = renderer-&gt;layer())
 745                         layer-&gt;setNeedsCompositingGeometryUpdate();
 746                 }
 747             }
 748         }
 749 
 750         // Scrolling can affect overlap. FIXME: avoid for page scrolling.
 751         updateRoot-&gt;setDescendantsNeedCompositingRequirementsTraversal();
 752     }
 753 
 754     if (updateType == CompositingUpdateType::AfterLayout) {
 755         // Ensure that post-layout updates push new scroll position and viewport rects onto the root node.
 756         rootRenderLayer().setNeedsScrollingTreeUpdate();
 757     }
 758 
 759     if (!updateRoot-&gt;hasDescendantNeedingCompositingRequirementsTraversal() &amp;&amp; !m_compositing) {
 760         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot; no compositing work to do&quot;);
 761         return true;
 762     }
 763 
 764     if (!updateRoot-&gt;needsAnyCompositingTraversal()) {
 765         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot; updateRoot has no dirty child and doesn&#39;t need update&quot;);
 766         return true;
 767     }
 768 
 769     ++m_compositingUpdateCount;
 770 
 771     AnimationUpdateBlock animationUpdateBlock(&amp;m_renderView.frameView().frame().animation());
 772 
 773     SetForScope&lt;bool&gt; postLayoutChange(m_inPostLayoutUpdate, true);
 774 
 775 #if !LOG_DISABLED
 776     MonotonicTime startTime;
 777     if (compositingLogEnabled()) {
 778         ++m_rootLayerUpdateCount;
 779         startTime = MonotonicTime::now();
 780     }
 781 
 782     if (compositingLogEnabled()) {
 783         m_obligateCompositedLayerCount = 0;
 784         m_secondaryCompositedLayerCount = 0;
 785         m_obligatoryBackingStoreBytes = 0;
 786         m_secondaryBackingStoreBytes = 0;
 787 
 788         auto&amp; frame = m_renderView.frameView().frame();
 789         bool isMainFrame = isMainFrameCompositor();
 790         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;\nUpdate &quot; &lt;&lt; m_rootLayerUpdateCount &lt;&lt; &quot; of &quot; &lt;&lt; (isMainFrame ? &quot;main frame&quot; : frame.tree().uniqueName().string().utf8().data()) &lt;&lt; &quot; - compositing policy is &quot; &lt;&lt; m_compositingPolicy);
 791     }
 792 #endif
 793 
 794     // FIXME: optimize root-only update.
 795     if (updateRoot-&gt;hasDescendantNeedingCompositingRequirementsTraversal() || updateRoot-&gt;needsCompositingRequirementsTraversal()) {
 796         auto&amp; rootLayer = rootRenderLayer();
 797         CompositingState compositingState(updateRoot);
 798         BackingSharingState backingSharingState;
 799         LayerOverlapMap overlapMap(rootLayer);
 800 
 801         bool descendantHas3DTransform = false;
 802         computeCompositingRequirements(nullptr, rootLayer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);
 803     }
 804 
 805     LOG(Compositing, &quot;\nRenderLayerCompositor::updateCompositingLayers - mid&quot;);
 806 #if ENABLE(TREE_DEBUGGING)
 807     if (compositingLogEnabled())
 808         showPaintOrderTree(m_renderView.layer());
 809 #endif
 810 
 811     if (updateRoot-&gt;hasDescendantNeedingUpdateBackingOrHierarchyTraversal() || updateRoot-&gt;needsUpdateBackingOrHierarchyTraversal()) {
 812         ScrollingTreeState scrollingTreeState = { 0, 0 };
 813         if (!m_renderView.frame().isMainFrame())
 814             scrollingTreeState.parentNodeID = frameHostingNodeForFrame(m_renderView.frame());
 815 
 816         UpdateBackingTraversalState traversalState;
 817         Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; childList;
 818         updateBackingAndHierarchy(*updateRoot, childList, traversalState, scrollingTreeState);
 819 
 820         // Host the document layer in the RenderView&#39;s root layer.
 821         appendDocumentOverlayLayers(childList);
 822         // Even when childList is empty, don&#39;t drop out of compositing mode if there are
 823         // composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
 824         if (childList.isEmpty() &amp;&amp; !needsCompositingForContentOrOverlays())
 825             destroyRootLayer();
 826         else if (m_rootContentsLayer)
 827             m_rootContentsLayer-&gt;setChildren(WTFMove(childList));
 828     }
 829 
 830 #if !LOG_DISABLED
 831     if (compositingLogEnabled()) {
 832         MonotonicTime endTime = MonotonicTime::now();
 833         LOG(Compositing, &quot;Total layers   primary   secondary   obligatory backing (KB)   secondary backing(KB)   total backing (KB)  update time (ms)\n&quot;);
 834 
 835         LOG(Compositing, &quot;%8d %11d %9d %20.2f %22.2f %22.2f %18.2f\n&quot;,
 836             m_obligateCompositedLayerCount + m_secondaryCompositedLayerCount, m_obligateCompositedLayerCount,
 837             m_secondaryCompositedLayerCount, m_obligatoryBackingStoreBytes / 1024, m_secondaryBackingStoreBytes / 1024, (m_obligatoryBackingStoreBytes + m_secondaryBackingStoreBytes) / 1024, (endTime - startTime).milliseconds());
 838     }
 839 #endif
 840 
 841     // FIXME: Only do if dirty.
 842     updateRootLayerPosition();
 843 
 844 #if ENABLE(TREE_DEBUGGING)
 845     if (compositingLogEnabled()) {
 846         LOG(Compositing, &quot;RenderLayerCompositor::updateCompositingLayers - post&quot;);
 847         showPaintOrderTree(m_renderView.layer());
 848     }
 849 #endif
 850 
 851     InspectorInstrumentation::layerTreeDidChange(&amp;page());
 852 
 853     return true;
 854 }
 855 
 856 static bool backingProviderLayerCanIncludeLayer(const RenderLayer&amp; sharedLayer, const RenderLayer&amp; layer)
 857 {
 858     // Disable sharing when painting shared layers doesn&#39;t work correctly.
 859     if (layer.hasReflection())
 860         return false;
 861 
 862     return layer.ancestorLayerIsInContainingBlockChain(sharedLayer);
 863 }
 864 
 865 void RenderLayerCompositor::computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)
 866 {
 867     layer.updateDescendantDependentFlags();
 868     layer.updateLayerListsIfNeeded();
 869 
 870     if (!layer.hasDescendantNeedingCompositingRequirementsTraversal()
 871         &amp;&amp; !layer.needsCompositingRequirementsTraversal()
 872         &amp;&amp; !compositingState.fullPaintOrderTraversalRequired
 873         &amp;&amp; !compositingState.descendantsRequireCompositingUpdate) {
 874         traverseUnchangedSubtree(ancestorLayer, layer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);
 875         return;
 876     }
 877 
 878     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; (layer.isNormalFlowOnly() ? &quot; n&quot; : &quot; s&quot;) &lt;&lt; &quot; computeCompositingRequirements (backing provider candidate &quot; &lt;&lt; backingSharingState.backingProviderCandidate() &lt;&lt; &quot;)&quot;);
 879 
 880     // FIXME: maybe we can avoid updating all remaining layers in paint order.
 881     compositingState.fullPaintOrderTraversalRequired |= layer.needsCompositingRequirementsTraversal();
 882     compositingState.descendantsRequireCompositingUpdate |= layer.descendantsNeedCompositingRequirementsTraversal();
 883 
 884     layer.setHasCompositingDescendant(false);
 885 
 886     // We updated compositing for direct reasons in layerStyleChanged(). Here, check for compositing that can only be evaluated after layout.
 887     RequiresCompositingData queryData;
 888     bool willBeComposited = layer.isComposited();
 889     bool becameCompositedAfterDescendantTraversal = false;
 890     IndirectCompositingReason compositingReason = compositingState.subtreeIsCompositing ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None;
 891 
 892     if (layer.needsPostLayoutCompositingUpdate() || compositingState.fullPaintOrderTraversalRequired || compositingState.descendantsRequireCompositingUpdate) {
 893         layer.setIndirectCompositingReason(IndirectCompositingReason::None);
 894         willBeComposited = needsToBeComposited(layer, queryData);
 895     }
 896 
 897     bool layerPaintsIntoProvidedBacking = false;
 898     if (!willBeComposited &amp;&amp; compositingState.subtreeIsCompositing &amp;&amp; backingSharingState.backingProviderCandidate() &amp;&amp; canBeComposited(layer) &amp;&amp; backingProviderLayerCanIncludeLayer(*backingSharingState.backingProviderCandidate(), layer)) {
 899         backingSharingState.appendSharingLayer(layer);
 900         LOG(Compositing, &quot; layer %p can share with %p&quot;, &amp;layer, backingSharingState.backingProviderCandidate());
 901         compositingReason = IndirectCompositingReason::None;
 902         layerPaintsIntoProvidedBacking = true;
 903     }
 904 
 905     compositingState.fullPaintOrderTraversalRequired |= layer.subsequentLayersNeedCompositingRequirementsTraversal();
 906 
 907     OverlapExtent layerExtent;
 908     // Use the fact that we&#39;re composited as a hint to check for an animating transform.
 909     // FIXME: Maybe needsToBeComposited() should return a bitmask of reasons, to avoid the need to recompute things.
 910     if (willBeComposited &amp;&amp; !layer.isRenderViewLayer())
 911         layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
 912 
 913     bool respectTransforms = !layerExtent.hasTransformAnimation;
 914     overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
 915 
 916     // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
 917     if (!willBeComposited &amp;&amp; !layerPaintsIntoProvidedBacking &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap) {
 918         // If we&#39;re testing for overlap, we only need to composite if we overlap something that is already composited.
 919         if (layerOverlaps(overlapMap, layer, layerExtent))
 920             compositingReason = IndirectCompositingReason::Overlap;
 921         else
 922             compositingReason = IndirectCompositingReason::None;
 923     }
 924 
 925 #if ENABLE(VIDEO)
 926     // Video is special. It&#39;s the only RenderLayer type that can both have
 927     // RenderLayer children and whose children can&#39;t use its backing to render
 928     // into. These children (the controls) always need to be promoted into their
 929     // own layers to draw on top of the accelerated video.
 930     if (compositingState.compositingAncestor &amp;&amp; compositingState.compositingAncestor-&gt;renderer().isVideo())
 931         compositingReason = IndirectCompositingReason::Overlap;
 932 #endif
 933 
 934     if (compositingReason != IndirectCompositingReason::None)
 935         layer.setIndirectCompositingReason(compositingReason);
 936 
 937     // Check if the computed indirect reason will force the layer to become composited.
 938     if (!willBeComposited &amp;&amp; layer.mustCompositeForIndirectReasons() &amp;&amp; canBeComposited(layer)) {
 939         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; compositing for indirect reason &quot; &lt;&lt; layer.indirectCompositingReason() &lt;&lt; &quot; (was sharing: &quot; &lt;&lt; layerPaintsIntoProvidedBacking &lt;&lt; &quot;)&quot;);
 940         willBeComposited = true;
 941         layerPaintsIntoProvidedBacking = false;
 942     }
 943 
 944     // The children of this layer don&#39;t need to composite, unless there is
 945     // a compositing layer among them, so start by inheriting the compositing
 946     // ancestor with subtreeIsCompositing set to false.
 947     CompositingState currentState = compositingState.stateForPaintOrderChildren(layer);
 948     bool didPushOverlapContainer = false;
 949 
 950     auto layerWillComposite = [&amp;] {
 951         // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
 952         // animation running behind this layer, meaning they can rely on the overlap map testing again.
 953         currentState.testingOverlap = true;
 954         // This layer now acts as the ancestor for kids.
 955         currentState.compositingAncestor = &amp;layer;
 956         // Compositing turns off backing sharing.
 957         currentState.backingSharingAncestor = nullptr;
 958 
 959         if (layerPaintsIntoProvidedBacking) {
 960             layerPaintsIntoProvidedBacking = false;
 961             // layerPaintsIntoProvidedBacking was only true for layers that would otherwise composite because of overlap. If we can
 962             // no longer share, put this this indirect reason back on the layer so that requiresOwnBackingStore() sees it.
 963             layer.setIndirectCompositingReason(IndirectCompositingReason::Overlap);
 964             LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; was sharing now will composite&quot;);
 965         } else {
 966             overlapMap.pushCompositingContainer();
 967             didPushOverlapContainer = true;
 968             LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will composite, pushed container &quot; &lt;&lt; overlapMap);
 969         }
 970 
 971         willBeComposited = true;
 972     };
 973 
 974     auto layerWillCompositePostDescendants = [&amp;] {
 975         layerWillComposite();
 976         currentState.subtreeIsCompositing = true;
 977         becameCompositedAfterDescendantTraversal = true;
 978     };
 979 
 980     if (willBeComposited) {
 981         layerWillComposite();
 982 
 983         computeExtent(overlapMap, layer, layerExtent);
 984         currentState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;
 985         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
 986         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
 987     } else if (layerPaintsIntoProvidedBacking) {
 988         currentState.backingSharingAncestor = &amp;layer;
 989         overlapMap.pushCompositingContainer();
 990         didPushOverlapContainer = true;
 991         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);
 992     }
 993 
 994     backingSharingState.updateBeforeDescendantTraversal(layer, willBeComposited);
 995 
 996 #if ASSERT_ENABLED
 997     LayerListMutationDetector mutationChecker(layer);
 998 #endif
 999 
1000     bool anyDescendantHas3DTransform = false;
1001     bool descendantsAddedToOverlap = currentState.hasNonRootCompositedAncestor();
1002 
1003     for (auto* childLayer : layer.negativeZOrderLayers()) {
1004         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1005 
1006         // If we have to make a layer for this child, make one now so we can have a contents layer
1007         // (since we need to ensure that the -ve z-order child renders underneath our contents).
1008         if (!willBeComposited &amp;&amp; currentState.subtreeIsCompositing) {
1009             layer.setIndirectCompositingReason(IndirectCompositingReason::BackgroundLayer);
1010             layerWillComposite();
1011         }
1012     }
1013 
1014     for (auto* childLayer : layer.normalFlowLayers())
1015         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1016 
1017     for (auto* childLayer : layer.positiveZOrderLayers())
1018         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1019 
1020     // Set the flag to say that this layer has compositing children.
1021     layer.setHasCompositingDescendant(currentState.subtreeIsCompositing);
1022 
1023     // If we just entered compositing mode, the root will have become composited (as long as accelerated compositing is enabled).
1024     if (layer.isRenderViewLayer()) {
1025         if (usesCompositing() &amp;&amp; m_hasAcceleratedCompositing)
1026             willBeComposited = true;
1027     }
1028 
1029 #if ENABLE(CSS_COMPOSITING)
1030     bool isolatedCompositedBlending = layer.isolatesCompositedBlending();
1031     layer.setHasNotIsolatedCompositedBlendingDescendants(currentState.hasNotIsolatedCompositedBlendingDescendants);
1032     if (layer.isolatesCompositedBlending() != isolatedCompositedBlending) {
1033         // isolatedCompositedBlending affects the result of clippedByAncestor().
1034         layer.setChildrenNeedCompositingGeometryUpdate();
1035     }
1036 
1037     ASSERT(!layer.hasNotIsolatedCompositedBlendingDescendants() || layer.hasNotIsolatedBlendingDescendants());
1038 #endif
1039     // Now check for reasons to become composited that depend on the state of descendant layers.
1040     if (!willBeComposited &amp;&amp; canBeComposited(layer)) {
1041         auto indirectReason = computeIndirectCompositingReason(layer, currentState.subtreeIsCompositing, anyDescendantHas3DTransform, layerPaintsIntoProvidedBacking);
1042         if (indirectReason != IndirectCompositingReason::None) {
1043             layer.setIndirectCompositingReason(indirectReason);
1044             layerWillCompositePostDescendants();
1045         }
1046     }
1047 
1048     if (layer.reflectionLayer()) {
1049         // FIXME: Shouldn&#39;t we call computeCompositingRequirements to handle a reflection overlapping with another renderer?
1050         layer.reflectionLayer()-&gt;setIndirectCompositingReason(willBeComposited ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None);
1051     }
1052 
1053     // If we&#39;re back at the root, and no other layers need to be composited, and the root layer itself doesn&#39;t need
1054     // to be composited, then we can drop out of compositing mode altogether. However, don&#39;t drop out of compositing mode
1055     // if there are composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
1056     RequiresCompositingData rootLayerQueryData;
1057     if (layer.isRenderViewLayer() &amp;&amp; !currentState.subtreeIsCompositing &amp;&amp; !requiresCompositingLayer(layer, rootLayerQueryData) &amp;&amp; !m_forceCompositingMode &amp;&amp; !needsCompositingForContentOrOverlays()) {
1058         // Don&#39;t drop out of compositing on iOS, because we may flash. See &lt;rdar://problem/8348337&gt;.
1059 #if !PLATFORM(IOS_FAMILY)
1060         enableCompositingMode(false);
1061         willBeComposited = false;
1062 #endif
1063     }
1064 
1065     ASSERT(willBeComposited == needsToBeComposited(layer, queryData));
1066 
1067     // Create or destroy backing here. However, we can&#39;t update geometry because layers above us may become composited
1068     // during post-order traversal (e.g. for clipping).
1069     if (updateBacking(layer, queryData, CompositingChangeRepaintNow, willBeComposited ? BackingRequired::Yes : BackingRequired::No)) {
1070         layer.setNeedsCompositingLayerConnection();
1071         // Child layers need to get a geometry update to recompute their position.
1072         layer.setChildrenNeedCompositingGeometryUpdate();
1073         // The composited bounds of enclosing layers depends on which descendants are composited, so they need a geometry update.
1074         layer.setNeedsCompositingGeometryUpdateOnAncestors();
1075     }
1076 
1077     // Update layer state bits.
1078     if (layer.reflectionLayer() &amp;&amp; updateLayerCompositingState(*layer.reflectionLayer(), &amp;layer, queryData, CompositingChangeRepaintNow))
1079         layer.setNeedsCompositingLayerConnection();
1080 
1081     // FIXME: clarify needsCompositingPaintOrderChildrenUpdate. If a composited layer gets a new ancestor, it needs geometry computations.
1082     if (layer.needsCompositingPaintOrderChildrenUpdate()) {
1083         layer.setChildrenNeedCompositingGeometryUpdate();
1084         layer.setNeedsCompositingLayerConnection();
1085     }
1086 
1087     layer.clearCompositingRequirementsTraversalState();
1088 
1089     // Compute state passed to the caller.
1090     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();
1091     compositingState.updateWithDescendantStateAndLayer(currentState, layer, layerExtent);
1092     backingSharingState.updateAfterDescendantTraversal(layer, compositingState.stackingContextAncestor);
1093 
1094     bool layerContributesToOverlap = (currentState.compositingAncestor &amp;&amp; !currentState.compositingAncestor-&gt;isRenderViewLayer()) || currentState.backingSharingAncestor;
1095     updateOverlapMap(overlapMap, layer, layerExtent, didPushOverlapContainer, layerContributesToOverlap, becameCompositedAfterDescendantTraversal &amp;&amp; !descendantsAddedToOverlap);
1096 
1097     if (layer.isComposited())
1098         layer.backing()-&gt;updateAllowsBackingStoreDetaching(layerExtent.bounds);
1099 
1100     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1101 
1102     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; &quot; computeCompositingRequirements - willBeComposited &quot; &lt;&lt; willBeComposited &lt;&lt; &quot; (backing provider candidate &quot; &lt;&lt; backingSharingState.backingProviderCandidate() &lt;&lt; &quot;)&quot;);
1103 }
1104 
1105 // We have to traverse unchanged layers to fill in the overlap map.
1106 void RenderLayerCompositor::traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)
1107 {
1108     layer.updateDescendantDependentFlags();
1109     layer.updateLayerListsIfNeeded();
1110 
1111     ASSERT(!compositingState.fullPaintOrderTraversalRequired);
1112     ASSERT(!layer.hasDescendantNeedingCompositingRequirementsTraversal());
1113     ASSERT(!layer.needsCompositingRequirementsTraversal());
1114 
1115     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; (layer.isNormalFlowOnly() ? &quot; n&quot; : &quot; s&quot;) &lt;&lt; &quot; traverseUnchangedSubtree&quot;);
1116 
1117     bool layerIsComposited = layer.isComposited();
1118     bool layerPaintsIntoProvidedBacking = false;
1119     bool didPushOverlapContainer = false;
1120 
1121     OverlapExtent layerExtent;
1122     if (layerIsComposited &amp;&amp; !layer.isRenderViewLayer())
1123         layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
1124 
1125     bool respectTransforms = !layerExtent.hasTransformAnimation;
1126     overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
1127 
1128     // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
1129     if (!layerIsComposited &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap)
1130         computeExtent(overlapMap, layer, layerExtent);
1131 
1132     if (layer.paintsIntoProvidedBacking()) {
1133         ASSERT(backingSharingState.backingProviderCandidate());
1134         ASSERT(backingProviderLayerCanIncludeLayer(*backingSharingState.backingProviderCandidate(), layer));
1135         backingSharingState.appendSharingLayer(layer);
1136         layerPaintsIntoProvidedBacking = true;
1137     }
1138 
1139     CompositingState currentState = compositingState.stateForPaintOrderChildren(layer);
1140 
1141     if (layerIsComposited) {
1142         // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
1143         // animation running behind this layer, meaning they can rely on the overlap map testing again.
1144         currentState.testingOverlap = true;
1145         // This layer now acts as the ancestor for kids.
1146         currentState.compositingAncestor = &amp;layer;
1147         currentState.backingSharingAncestor = nullptr;
1148         overlapMap.pushCompositingContainer();
1149         didPushOverlapContainer = true;
1150         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;unchangedSubtree: layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will composite, pushed container &quot; &lt;&lt; overlapMap);
1151 
1152         computeExtent(overlapMap, layer, layerExtent);
1153         currentState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;
1154         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
1155         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
1156     } else if (layerPaintsIntoProvidedBacking) {
1157         overlapMap.pushCompositingContainer();
1158         currentState.backingSharingAncestor = &amp;layer;
1159         didPushOverlapContainer = true;
1160         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;unchangedSubtree: layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);
1161     }
1162 
1163     backingSharingState.updateBeforeDescendantTraversal(layer, layerIsComposited);
1164 
1165 #if ASSERT_ENABLED
1166     LayerListMutationDetector mutationChecker(layer);
1167 #endif
1168 
1169     bool anyDescendantHas3DTransform = false;
1170 
1171     for (auto* childLayer : layer.negativeZOrderLayers()) {
1172         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1173         if (currentState.subtreeIsCompositing)
1174             ASSERT(layerIsComposited);
1175     }
1176 
1177     for (auto* childLayer : layer.normalFlowLayers())
1178         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1179 
1180     for (auto* childLayer : layer.positiveZOrderLayers())
1181         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1182 
1183     // Set the flag to say that this layer has compositing children.
1184     ASSERT(layer.hasCompositingDescendant() == currentState.subtreeIsCompositing);
1185     ASSERT_IMPLIES(canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer), layerIsComposited);
1186 
1187     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();
1188 
1189     ASSERT(!currentState.fullPaintOrderTraversalRequired);
1190     compositingState.updateWithDescendantStateAndLayer(currentState, layer, layerExtent, true);
1191     backingSharingState.updateAfterDescendantTraversal(layer, compositingState.stackingContextAncestor);
1192 
1193     bool layerContributesToOverlap = (currentState.compositingAncestor &amp;&amp; !currentState.compositingAncestor-&gt;isRenderViewLayer()) || currentState.backingSharingAncestor;
1194     updateOverlapMap(overlapMap, layer, layerExtent, didPushOverlapContainer, layerContributesToOverlap);
1195 
1196     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1197 
1198     ASSERT(!layer.needsCompositingRequirementsTraversal());
1199 }
1200 
1201 void RenderLayerCompositor::updateBackingAndHierarchy(RenderLayer&amp; layer, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childLayersOfEnclosingLayer, UpdateBackingTraversalState&amp; traversalState, ScrollingTreeState&amp; scrollingTreeState, OptionSet&lt;UpdateLevel&gt; updateLevel)
1202 {
1203     layer.updateDescendantDependentFlags();
1204     layer.updateLayerListsIfNeeded();
1205 
1206     bool layerNeedsUpdate = !updateLevel.isEmpty();
1207     if (layer.descendantsNeedUpdateBackingAndHierarchyTraversal())
1208         updateLevel.add(UpdateLevel::AllDescendants);
1209 
1210     ScrollingTreeState scrollingStateForDescendants = scrollingTreeState;
1211     UpdateBackingTraversalState traversalStateForDescendants = traversalState.stateForDescendants();
1212 
1213     auto* layerBacking = layer.backing();
1214     if (layerBacking) {
1215         updateLevel.remove(UpdateLevel::CompositedChildren);
1216 
1217         // We updated the composited bounds in RenderLayerBacking::updateAfterLayout(), but it may have changed
1218         // based on which descendants are now composited.
1219         if (layerBacking-&gt;updateCompositedBounds()) {
1220             layer.setNeedsCompositingGeometryUpdate();
1221             // Our geometry can affect descendants.
1222             updateLevel.add(UpdateLevel::CompositedChildren);
1223         }
1224 
1225         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate()) {
1226             if (layerBacking-&gt;updateConfiguration(traversalState.compositingAncestor)) {
1227                 layerNeedsUpdate = true; // We also need to update geometry.
1228                 layer.setNeedsCompositingLayerConnection();
1229             }
1230 
1231             layerBacking-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
1232         }
1233 
1234         OptionSet&lt;ScrollingNodeChangeFlags&gt; scrollingNodeChanges = { ScrollingNodeChangeFlags::Layer };
1235         if (layerNeedsUpdate || layer.needsCompositingGeometryUpdate()) {
1236             layerBacking-&gt;updateGeometry(traversalState.compositingAncestor);
1237             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
1238         } else if (layer.needsScrollingTreeUpdate())
1239             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
1240 
1241         // This needs to happen after any geometry update.
1242         // FIXME: Use separate bit for event region invalidation.
1243         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate())
1244             layerBacking-&gt;updateEventRegion();
1245 
1246         if (auto* reflection = layer.reflectionLayer()) {
1247             if (auto* reflectionBacking = reflection-&gt;backing()) {
1248                 reflectionBacking-&gt;updateCompositedBounds();
1249                 reflectionBacking-&gt;updateGeometry(&amp;layer);
1250                 reflectionBacking-&gt;updateAfterDescendants();
1251             }
1252         }
1253 
1254         if (!layer.parent())
1255             updateRootLayerPosition();
1256 
1257         // FIXME: do based on dirty flags. Need to do this for changes of geometry, configuration and hierarchy.
1258         // Need to be careful to do the right thing when a scroll-coordinated layer loses a scroll-coordinated ancestor.
1259         scrollingStateForDescendants.parentNodeID = updateScrollCoordinationForLayer(layer, traversalState.compositingAncestor, scrollingTreeState, scrollingNodeChanges);
1260         scrollingStateForDescendants.nextChildIndex = 0;
1261 
1262         traversalStateForDescendants.compositingAncestor = &amp;layer;
1263 
1264 #if !LOG_DISABLED
1265         logLayerInfo(layer, &quot;updateBackingAndHierarchy&quot;, traversalState.depth);
1266 #endif
1267     }
1268 
1269     if (layer.childrenNeedCompositingGeometryUpdate())
1270         updateLevel.add(UpdateLevel::CompositedChildren);
1271 
1272     // If this layer has backing, then we are collecting its children, otherwise appending
1273     // to the compositing child list of an enclosing layer.
1274     Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; layerChildren;
1275     auto&amp; childList = layerBacking ? layerChildren : childLayersOfEnclosingLayer;
1276 
1277     bool requireDescendantTraversal = layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal()
1278         || (layer.hasCompositingDescendant() &amp;&amp; (!layerBacking || layer.needsCompositingLayerConnection() || !updateLevel.isEmpty()));
1279 
1280     bool requiresChildRebuild = layerBacking &amp;&amp; layer.needsCompositingLayerConnection() &amp;&amp; !layer.hasCompositingDescendant();
1281 
1282 #if ASSERT_ENABLED
1283     LayerListMutationDetector mutationChecker(layer);
1284 #endif
1285 
1286     auto appendForegroundLayerIfNecessary = [&amp;] {
1287         // If a negative z-order child is compositing, we get a foreground layer which needs to get parented.
1288         if (layer.negativeZOrderLayers().size()) {
1289             if (layerBacking &amp;&amp; layerBacking-&gt;foregroundLayer())
1290                 childList.append(*layerBacking-&gt;foregroundLayer());
1291         }
1292     };
1293 
1294     if (requireDescendantTraversal) {
1295         for (auto* renderLayer : layer.negativeZOrderLayers())
1296             updateBackingAndHierarchy(*renderLayer, childList, traversalStateForDescendants, scrollingStateForDescendants, updateLevel);
1297 
1298         appendForegroundLayerIfNecessary();
1299 
1300         for (auto* renderLayer : layer.normalFlowLayers())
1301             updateBackingAndHierarchy(*renderLayer, childList, traversalStateForDescendants, scrollingStateForDescendants, updateLevel);
1302 
1303         for (auto* renderLayer : layer.positiveZOrderLayers())
1304             updateBackingAndHierarchy(*renderLayer, childList, traversalStateForDescendants, scrollingStateForDescendants, updateLevel);
1305     } else if (requiresChildRebuild)
1306         appendForegroundLayerIfNecessary();
1307 
1308     if (layerBacking) {
1309         if (requireDescendantTraversal || requiresChildRebuild) {
1310             bool parented = false;
1311             if (is&lt;RenderWidget&gt;(layer.renderer()))
1312                 parented = parentFrameContentLayers(downcast&lt;RenderWidget&gt;(layer.renderer()));
1313 
1314             if (!parented)
1315                 layerBacking-&gt;parentForSublayers()-&gt;setChildren(WTFMove(layerChildren));
1316 
1317             // If the layer has a clipping layer the overflow controls layers will be siblings of the clipping layer.
1318             // Otherwise, the overflow control layers are normal children.
1319             if (!layerBacking-&gt;hasClippingLayer() &amp;&amp; !layerBacking-&gt;hasScrollingLayer()) {
1320                 if (auto* overflowControlLayer = layerBacking-&gt;layerForHorizontalScrollbar())
1321                     layerBacking-&gt;parentForSublayers()-&gt;addChild(*overflowControlLayer);
1322 
1323                 if (auto* overflowControlLayer = layerBacking-&gt;layerForVerticalScrollbar())
1324                     layerBacking-&gt;parentForSublayers()-&gt;addChild(*overflowControlLayer);
1325 
1326                 if (auto* overflowControlLayer = layerBacking-&gt;layerForScrollCorner())
1327                     layerBacking-&gt;parentForSublayers()-&gt;addChild(*overflowControlLayer);
1328             }
1329         }
1330 
1331         childLayersOfEnclosingLayer.append(*layerBacking-&gt;childForSuperlayers());
1332 
1333         layerBacking-&gt;updateAfterDescendants();
1334     }
1335 
1336     layer.clearUpdateBackingOrHierarchyTraversalState();
1337 }
1338 
1339 void RenderLayerCompositor::appendDocumentOverlayLayers(Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childList)
1340 {
1341     if (!isMainFrameCompositor() || !m_compositing)
1342         return;
1343 
1344     if (!page().pageOverlayController().hasDocumentOverlays())
1345         return;
1346 
1347     Ref&lt;GraphicsLayer&gt; overlayHost = page().pageOverlayController().layerWithDocumentOverlays();
1348     childList.append(WTFMove(overlayHost));
1349 }
1350 
1351 bool RenderLayerCompositor::needsCompositingForContentOrOverlays() const
1352 {
1353     return m_contentLayersCount + page().pageOverlayController().overlayCount();
1354 }
1355 
1356 void RenderLayerCompositor::layerBecameComposited(const RenderLayer&amp; layer)
1357 {
1358     if (&amp;layer != m_renderView.layer())
1359         ++m_contentLayersCount;
1360 }
1361 
1362 void RenderLayerCompositor::layerBecameNonComposited(const RenderLayer&amp; layer)
1363 {
1364     // Inform the inspector that the given RenderLayer was destroyed.
1365     // FIXME: &quot;destroyed&quot; is a misnomer.
1366     InspectorInstrumentation::renderLayerDestroyed(&amp;page(), layer);
1367 
1368     if (&amp;layer != m_renderView.layer()) {
1369         ASSERT(m_contentLayersCount &gt; 0);
1370         --m_contentLayersCount;
1371     }
1372 }
1373 
1374 #if !LOG_DISABLED
1375 void RenderLayerCompositor::logLayerInfo(const RenderLayer&amp; layer, const char* phase, int depth)
1376 {
1377     if (!compositingLogEnabled())
1378         return;
1379 
1380     auto* backing = layer.backing();
1381     RequiresCompositingData queryData;
1382     if (requiresCompositingLayer(layer, queryData) || layer.isRenderViewLayer()) {
1383         ++m_obligateCompositedLayerCount;
1384         m_obligatoryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1385     } else {
1386         ++m_secondaryCompositedLayerCount;
1387         m_secondaryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1388     }
1389 
1390     LayoutRect absoluteBounds = backing-&gt;compositedBounds();
1391     absoluteBounds.move(layer.offsetFromAncestor(m_renderView.layer()));
1392 
1393     StringBuilder logString;
1394     logString.append(pad(&#39; &#39;, 12 + depth * 2, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;layer), Lowercase)), &quot; id &quot;, backing-&gt;graphicsLayer()-&gt;primaryLayerID(), &quot; (&quot;, absoluteBounds.x().toFloat(), &#39;,&#39;, absoluteBounds.y().toFloat(), &#39;-&#39;, absoluteBounds.maxX().toFloat(), &#39;,&#39;, absoluteBounds.maxY().toFloat(), &quot;) &quot;, FormattedNumber::fixedWidth(backing-&gt;backingStoreMemoryEstimate() / 1024, 2), &quot;KB&quot;);
1395 
1396     if (!layer.renderer().style().hasAutoUsedZIndex())
1397         logString.append(&quot; z-index: &quot;, layer.renderer().style().usedZIndex());
1398 
1399     logString.append(&quot; (&quot;, logReasonsForCompositing(layer), &quot;) &quot;);
1400 
1401     if (backing-&gt;graphicsLayer()-&gt;contentsOpaque() || backing-&gt;paintsIntoCompositedAncestor() || backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1402         logString.append(&#39;[&#39;);
1403         bool prependSpace = false;
1404         if (backing-&gt;graphicsLayer()-&gt;contentsOpaque()) {
1405             logString.appendLiteral(&quot;opaque&quot;);
1406             prependSpace = true;
1407         }
1408 
1409         if (backing-&gt;paintsIntoCompositedAncestor()) {
1410             if (prependSpace)
1411                 logString.appendLiteral(&quot;, &quot;);
1412             logString.appendLiteral(&quot;paints into ancestor&quot;);
1413             prependSpace = true;
1414         }
1415 
1416         if (backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1417             if (prependSpace)
1418                 logString.appendLiteral(&quot;, &quot;);
1419             if (backing-&gt;foregroundLayer() &amp;&amp; backing-&gt;backgroundLayer()) {
1420                 logString.appendLiteral(&quot;+foreground+background&quot;);
1421                 prependSpace = true;
1422             } else if (backing-&gt;foregroundLayer()) {
1423                 logString.appendLiteral(&quot;+foreground&quot;);
1424                 prependSpace = true;
1425             } else {
1426                 logString.appendLiteral(&quot;+background&quot;);
1427                 prependSpace = true;
1428             }
1429         }
1430 
1431         if (backing-&gt;paintsSubpixelAntialiasedText()) {
1432             if (prependSpace)
1433                 logString.appendLiteral(&quot;, &quot;);
1434             logString.appendLiteral(&quot;texty&quot;);
1435         }
1436 
1437         logString.appendLiteral(&quot;] &quot;);
1438     }
1439 
1440     logString.append(layer.name());
1441 
1442     logString.appendLiteral(&quot; - &quot;);
1443     logString.append(phase);
1444 
1445     LOG(Compositing, &quot;%s&quot;, logString.toString().utf8().data());
1446 }
1447 #endif
1448 
1449 static bool clippingChanged(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
1450 {
1451     return oldStyle.overflowX() != newStyle.overflowX() || oldStyle.overflowY() != newStyle.overflowY()
1452         || oldStyle.hasClip() != newStyle.hasClip() || oldStyle.clip() != newStyle.clip();
1453 }
1454 
1455 static bool styleAffectsLayerGeometry(const RenderStyle&amp; style)
1456 {
1457     return style.hasClip() || style.clipPath() || style.hasBorderRadius();
1458 }
1459 
1460 static bool recompositeChangeRequiresGeometryUpdate(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
1461 {
1462     return oldStyle.transform() != newStyle.transform()
1463         || oldStyle.transformOriginX() != newStyle.transformOriginX()
1464         || oldStyle.transformOriginY() != newStyle.transformOriginY()
1465         || oldStyle.transformOriginZ() != newStyle.transformOriginZ()
1466         || oldStyle.transformStyle3D() != newStyle.transformStyle3D()
1467         || oldStyle.perspective() != newStyle.perspective()
1468         || oldStyle.perspectiveOriginX() != newStyle.perspectiveOriginX()
1469         || oldStyle.perspectiveOriginY() != newStyle.perspectiveOriginY()
1470         || oldStyle.backfaceVisibility() != newStyle.backfaceVisibility()
1471         || !arePointingToEqualData(oldStyle.clipPath(), newStyle.clipPath());
1472 }
1473 
1474 void RenderLayerCompositor::layerStyleChanged(StyleDifference diff, RenderLayer&amp; layer, const RenderStyle* oldStyle)
1475 {
1476     if (diff == StyleDifference::Equal)
1477         return;
1478 
1479     // Create or destroy backing here so that code that runs during layout can reliably use isComposited() (though this
1480     // is only true for layers composited for direct reasons).
1481     // Also, it allows us to avoid a tree walk in updateCompositingLayers() when no layer changed its compositing state.
1482     RequiresCompositingData queryData;
1483     queryData.layoutUpToDate = LayoutUpToDate::No;
1484 
1485     bool layerChanged = updateBacking(layer, queryData, CompositingChangeRepaintNow);
1486     if (layerChanged) {
1487         layer.setChildrenNeedCompositingGeometryUpdate();
1488         layer.setNeedsCompositingLayerConnection();
1489         layer.setSubsequentLayersNeedCompositingRequirementsTraversal();
1490         // Ancestor layers that composited for indirect reasons (things listed in styleChangeMayAffectIndirectCompositingReasons()) need to get updated.
1491         // This could be optimized by only setting this flag on layers with the relevant styles.
1492         layer.setNeedsPostLayoutCompositingUpdateOnAncestors();
1493     }
1494 
1495     if (queryData.reevaluateAfterLayout)
1496         layer.setNeedsPostLayoutCompositingUpdate();
1497 
1498     const auto&amp; newStyle = layer.renderer().style();
1499 
1500     if (hasContentCompositingLayers()) {
1501         if (diff &gt;= StyleDifference::LayoutPositionedMovementOnly) {
1502             layer.setNeedsPostLayoutCompositingUpdate();
1503             layer.setNeedsCompositingGeometryUpdate();
1504         }
1505 
1506         if (diff &gt;= StyleDifference::Layout) {
1507             // FIXME: only set flags here if we know we have a composited descendant, but we might not know at this point.
1508             if (oldStyle &amp;&amp; clippingChanged(*oldStyle, newStyle)) {
1509                 if (layer.isStackingContext()) {
1510                     layer.setNeedsPostLayoutCompositingUpdate(); // Layer needs to become composited if it has composited descendants.
1511                     layer.setNeedsCompositingConfigurationUpdate(); // If already composited, layer needs to create/destroy clipping layer.
1512                 } else {
1513                     // Descendant (in containing block order) compositing layers need to re-evaluate their clipping,
1514                     // but they might be siblings in z-order so go up to our stacking context.
1515                     if (auto* stackingContext = layer.stackingContext())
1516                         stackingContext-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
1517                 }
1518             }
1519 
1520             // These properties trigger compositing if some descendant is composited.
1521             if (oldStyle &amp;&amp; styleChangeMayAffectIndirectCompositingReasons(*oldStyle, newStyle))
1522                 layer.setNeedsPostLayoutCompositingUpdate();
1523 
1524             layer.setNeedsCompositingGeometryUpdate();
1525         }
1526     }
1527 
1528     auto* backing = layer.backing();
1529     if (!backing)
1530         return;
1531 
1532     backing-&gt;updateConfigurationAfterStyleChange();
1533 
1534     if (diff &gt;= StyleDifference::Repaint) {
1535         // Visibility change may affect geometry of the enclosing composited layer.
1536         if (oldStyle &amp;&amp; oldStyle-&gt;visibility() != newStyle.visibility())
1537             layer.setNeedsCompositingGeometryUpdate();
1538 
1539         // We&#39;ll get a diff of Repaint when things like clip-path change; these might affect layer or inner-layer geometry.
1540         if (layer.isComposited() &amp;&amp; oldStyle) {
1541             if (styleAffectsLayerGeometry(*oldStyle) || styleAffectsLayerGeometry(newStyle))
1542                 layer.setNeedsCompositingGeometryUpdate();
1543         }
1544     }
1545 
1546     // This is necessary to get iframe layers hooked up in response to scheduleInvalidateStyleAndLayerComposition().
1547     if (diff == StyleDifference::RecompositeLayer &amp;&amp; layer.isComposited() &amp;&amp; is&lt;RenderWidget&gt;(layer.renderer()))
1548         layer.setNeedsCompositingConfigurationUpdate();
1549 
1550     if (diff &gt;= StyleDifference::RecompositeLayer &amp;&amp; oldStyle &amp;&amp; recompositeChangeRequiresGeometryUpdate(*oldStyle, newStyle)) {
1551         // FIXME: transform changes really need to trigger layout. See RenderElement::adjustStyleDifference().
1552         layer.setNeedsPostLayoutCompositingUpdate();
1553         layer.setNeedsCompositingGeometryUpdate();
1554     }
1555 }
1556 
1557 bool RenderLayerCompositor::needsCompositingUpdateForStyleChangeOnNonCompositedLayer(RenderLayer&amp; layer, const RenderStyle* oldStyle) const
1558 {
1559     // Needed for scroll bars.
1560     if (layer.isRenderViewLayer())
1561         return true;
1562 
1563     if (!oldStyle)
1564         return false;
1565 
1566     const RenderStyle&amp; newStyle = layer.renderer().style();
1567     // Visibility change may affect geometry of the enclosing composited layer.
1568     if (oldStyle-&gt;visibility() != newStyle.visibility())
1569         return true;
1570 
1571     // We don&#39;t have any direct reasons for this style change to affect layer composition. Test if it might affect things indirectly.
1572     if (styleChangeMayAffectIndirectCompositingReasons(*oldStyle, newStyle))
1573         return true;
1574 
1575     return false;
1576 }
1577 
1578 bool RenderLayerCompositor::canCompositeClipPath(const RenderLayer&amp; layer)
1579 {
1580     ASSERT(layer.isComposited());
1581     ASSERT(layer.renderer().style().clipPath());
1582 
1583     if (layer.renderer().hasMask())
1584         return false;
1585 
1586     auto&amp; clipPath = *layer.renderer().style().clipPath();
1587     return (clipPath.type() != ClipPathOperation::Shape || clipPath.type() == ClipPathOperation::Shape) &amp;&amp; GraphicsLayer::supportsLayerType(GraphicsLayer::Type::Shape);
1588 }
1589 
1590 // FIXME: remove and never ask questions about reflection layers.
1591 static RenderLayerModelObject&amp; rendererForCompositingTests(const RenderLayer&amp; layer)
1592 {
1593     auto* renderer = &amp;layer.renderer();
1594 
1595     // The compositing state of a reflection should match that of its reflected layer.
1596     if (layer.isReflection())
1597         renderer = downcast&lt;RenderLayerModelObject&gt;(renderer-&gt;parent()); // The RenderReplica&#39;s parent is the object being reflected.
1598 
1599     return *renderer;
1600 }
1601 
1602 void RenderLayerCompositor::updateRootContentLayerClipping()
1603 {
1604     m_rootContentsLayer-&gt;setMasksToBounds(!m_renderView.settings().backgroundShouldExtendBeyondPage());
1605 }
1606 
1607 bool RenderLayerCompositor::updateBacking(RenderLayer&amp; layer, RequiresCompositingData&amp; queryData, CompositingChangeRepaint shouldRepaint, BackingRequired backingRequired)
1608 {
1609     bool layerChanged = false;
1610     if (backingRequired == BackingRequired::Unknown)
1611         backingRequired = needsToBeComposited(layer, queryData) ? BackingRequired::Yes : BackingRequired::No;
1612     else {
1613         // Need to fetch viewportConstrainedNotCompositedReason, but without doing all the work that needsToBeComposited does.
1614         requiresCompositingForPosition(rendererForCompositingTests(layer), layer, queryData);
1615     }
1616 
1617     if (backingRequired == BackingRequired::Yes) {
1618         layer.disconnectFromBackingProviderLayer();
1619 
1620         enableCompositingMode();
1621 
1622         if (!layer.backing()) {
1623             // If we need to repaint, do so before making backing
1624             if (shouldRepaint == CompositingChangeRepaintNow)
1625                 repaintOnCompositingChange(layer); // wrong backing
1626 
1627             layer.ensureBacking();
1628 
1629             if (layer.isRenderViewLayer() &amp;&amp; useCoordinatedScrollingForLayer(layer)) {
1630                 auto&amp; frameView = m_renderView.frameView();
1631                 if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
1632                     scrollingCoordinator-&gt;frameViewRootLayerDidChange(frameView);
1633 #if ENABLE(RUBBER_BANDING)
1634                 updateLayerForHeader(frameView.headerHeight());
1635                 updateLayerForFooter(frameView.footerHeight());
1636 #endif
1637                 updateRootContentLayerClipping();
1638 
1639                 if (auto* tiledBacking = layer.backing()-&gt;tiledBacking())
1640                     tiledBacking-&gt;setTopContentInset(frameView.topContentInset());
1641             }
1642 
1643             // This layer and all of its descendants have cached repaints rects that are relative to
1644             // the repaint container, so change when compositing changes; we need to update them here.
1645             if (layer.parent())
1646                 layer.computeRepaintRectsIncludingDescendants();
1647 
1648             layer.setNeedsCompositingGeometryUpdate();
1649             layer.setNeedsCompositingConfigurationUpdate();
1650             layer.setNeedsCompositingPaintOrderChildrenUpdate();
1651 
1652             layerChanged = true;
1653         }
1654     } else {
1655         if (layer.backing()) {
1656             // If we&#39;re removing backing on a reflection, clear the source GraphicsLayer&#39;s pointer to
1657             // its replica GraphicsLayer. In practice this should never happen because reflectee and reflection
1658             // are both either composited, or not composited.
1659             if (layer.isReflection()) {
1660                 auto* sourceLayer = downcast&lt;RenderLayerModelObject&gt;(*layer.renderer().parent()).layer();
1661                 if (auto* backing = sourceLayer-&gt;backing()) {
1662                     ASSERT(backing-&gt;graphicsLayer()-&gt;replicaLayer() == layer.backing()-&gt;graphicsLayer());
1663                     backing-&gt;graphicsLayer()-&gt;setReplicatedByLayer(nullptr);
1664                 }
1665             }
1666 
1667             layer.clearBacking();
1668             layerChanged = true;
1669 
1670             // This layer and all of its descendants have cached repaints rects that are relative to
1671             // the repaint container, so change when compositing changes; we need to update them here.
1672             layer.computeRepaintRectsIncludingDescendants();
1673 
1674             // If we need to repaint, do so now that we&#39;ve removed the backing
1675             if (shouldRepaint == CompositingChangeRepaintNow)
1676                 repaintOnCompositingChange(layer);
1677         }
1678     }
1679 
1680 #if ENABLE(VIDEO)
1681     if (layerChanged &amp;&amp; is&lt;RenderVideo&gt;(layer.renderer())) {
1682         // If it&#39;s a video, give the media player a chance to hook up to the layer.
1683         downcast&lt;RenderVideo&gt;(layer.renderer()).acceleratedRenderingStateChanged();
1684     }
1685 #endif
1686 
1687     if (layerChanged &amp;&amp; is&lt;RenderWidget&gt;(layer.renderer())) {
1688         auto* innerCompositor = frameContentsCompositor(downcast&lt;RenderWidget&gt;(layer.renderer()));
1689         if (innerCompositor &amp;&amp; innerCompositor-&gt;usesCompositing())
1690             innerCompositor-&gt;updateRootLayerAttachment();
1691     }
1692 
1693     if (layerChanged)
1694         layer.clearClipRectsIncludingDescendants(PaintingClipRects);
1695 
1696     // If a fixed position layer gained/lost a backing or the reason not compositing it changed,
1697     // the scrolling coordinator needs to recalculate whether it can do fast scrolling.
1698     if (layer.renderer().isFixedPositioned()) {
1699         if (layer.viewportConstrainedNotCompositedReason() != queryData.nonCompositedForPositionReason) {
1700             layer.setViewportConstrainedNotCompositedReason(queryData.nonCompositedForPositionReason);
1701             layerChanged = true;
1702         }
1703         if (layerChanged) {
1704             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
1705                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(m_renderView.frameView());
1706         }
1707     } else
1708         layer.setViewportConstrainedNotCompositedReason(RenderLayer::NoNotCompositedReason);
1709 
1710     if (layer.backing())
1711         layer.backing()-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
1712 
1713     return layerChanged;
1714 }
1715 
1716 bool RenderLayerCompositor::updateLayerCompositingState(RenderLayer&amp; layer, const RenderLayer* compositingAncestor, RequiresCompositingData&amp; queryData, CompositingChangeRepaint shouldRepaint)
1717 {
1718     bool layerChanged = updateBacking(layer, queryData, shouldRepaint);
1719 
1720     // See if we need content or clipping layers. Methods called here should assume
1721     // that the compositing state of descendant layers has not been updated yet.
1722     if (layer.backing() &amp;&amp; layer.backing()-&gt;updateConfiguration(compositingAncestor))
1723         layerChanged = true;
1724 
1725     return layerChanged;
1726 }
1727 
1728 void RenderLayerCompositor::repaintOnCompositingChange(RenderLayer&amp; layer)
1729 {
1730     // If the renderer is not attached yet, no need to repaint.
1731     if (&amp;layer.renderer() != &amp;m_renderView &amp;&amp; !layer.renderer().parent())
1732         return;
1733 
1734     auto* repaintContainer = layer.renderer().containerForRepaint();
1735     if (!repaintContainer)
1736         repaintContainer = &amp;m_renderView;
1737 
1738     layer.repaintIncludingNonCompositingDescendants(repaintContainer);
1739     if (repaintContainer == &amp;m_renderView) {
1740         // The contents of this layer may be moving between the window
1741         // and a GraphicsLayer, so we need to make sure the window system
1742         // synchronizes those changes on the screen.
1743         m_renderView.frameView().setNeedsOneShotDrawingSynchronization();
1744     }
1745 }
1746 
1747 // This method assumes that layout is up-to-date, unlike repaintOnCompositingChange().
1748 void RenderLayerCompositor::repaintInCompositedAncestor(RenderLayer&amp; layer, const LayoutRect&amp; rect)
1749 {
1750     auto* compositedAncestor = layer.enclosingCompositingLayerForRepaint(ExcludeSelf);
1751     if (!compositedAncestor)
1752         return;
1753 
1754     ASSERT(compositedAncestor-&gt;backing());
1755     LayoutRect repaintRect = rect;
1756     repaintRect.move(layer.offsetFromAncestor(compositedAncestor));
1757     compositedAncestor-&gt;setBackingNeedsRepaintInRect(repaintRect);
1758 
1759     // The contents of this layer may be moving from a GraphicsLayer to the window,
1760     // so we need to make sure the window system synchronizes those changes on the screen.
1761     if (compositedAncestor-&gt;isRenderViewLayer())
1762         m_renderView.frameView().setNeedsOneShotDrawingSynchronization();
1763 }
1764 
1765 // FIXME: remove.
1766 void RenderLayerCompositor::layerWasAdded(RenderLayer&amp;, RenderLayer&amp;)
1767 {
1768 }
1769 
1770 void RenderLayerCompositor::layerWillBeRemoved(RenderLayer&amp; parent, RenderLayer&amp; child)
1771 {
1772     if (parent.renderer().renderTreeBeingDestroyed())
1773         return;
1774 
1775     if (child.isComposited())
1776         repaintInCompositedAncestor(child, child.backing()-&gt;compositedBounds()); // FIXME: do via dirty bits?
1777     else if (child.paintsIntoProvidedBacking()) {
1778         auto* backingProviderLayer = child.backingProviderLayer();
1779         // FIXME: Optimize this repaint.
1780         backingProviderLayer-&gt;setBackingNeedsRepaint();
1781         backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(child);
1782     } else
1783         return;
1784 
1785     child.setNeedsCompositingLayerConnection();
1786 }
1787 
1788 RenderLayer* RenderLayerCompositor::enclosingNonStackingClippingLayer(const RenderLayer&amp; layer) const
1789 {
1790     for (auto* parent = layer.parent(); parent; parent = parent-&gt;parent()) {
1791         if (parent-&gt;isStackingContext())
1792             return nullptr;
1793         if (parent-&gt;renderer().hasClipOrOverflowClip())
1794             return parent;
1795     }
1796     return nullptr;
1797 }
1798 
1799 void RenderLayerCompositor::computeExtent(const LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent) const
1800 {
1801     if (extent.extentComputed)
1802         return;
1803 
1804     LayoutRect layerBounds;
1805     if (extent.hasTransformAnimation)
1806         extent.animationCausesExtentUncertainty = !layer.getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(layerBounds);
1807     else
1808         layerBounds = layer.overlapBounds();
1809 
1810     // In the animating transform case, we avoid double-accounting for the transform because
1811     // we told pushMappingsToAncestor() to ignore transforms earlier.
1812     extent.bounds = enclosingLayoutRect(overlapMap.geometryMap().absoluteRect(layerBounds));
1813 
1814     // Empty rects never intersect, but we need them to for the purposes of overlap testing.
1815     if (extent.bounds.isEmpty())
1816         extent.bounds.setSize(LayoutSize(1, 1));
1817 
1818     RenderLayerModelObject&amp; renderer = layer.renderer();
1819     if (renderer.isFixedPositioned() &amp;&amp; renderer.container() == &amp;m_renderView) {
1820         // Because fixed elements get moved around without re-computing overlap, we have to compute an overlap
1821         // rect that covers all the locations that the fixed element could move to.
1822         // FIXME: need to handle sticky too.
1823         extent.bounds = m_renderView.frameView().fixedScrollableAreaBoundsInflatedForScrolling(extent.bounds);
1824     }
1825 
1826     extent.extentComputed = true;
1827 }
1828 
1829 enum class AncestorTraversal { Continue, Stop };
1830 
1831 // This is a simplified version of containing block walking that only handles absolute position.
1832 template &lt;typename Function&gt;
1833 static AncestorTraversal traverseAncestorLayers(const RenderLayer&amp; layer, Function&amp;&amp; function)
1834 {
1835     bool containingBlockCanSkipLayers = layer.renderer().isAbsolutelyPositioned();
1836     RenderLayer* nextPaintOrderParent = layer.paintOrderParent();
1837 
1838     for (const auto* ancestorLayer = layer.parent(); ancestorLayer; ancestorLayer = ancestorLayer-&gt;parent()) {
1839         bool inContainingBlockChain = true;
1840 
1841         if (containingBlockCanSkipLayers)
1842             inContainingBlockChain = ancestorLayer-&gt;renderer().canContainAbsolutelyPositionedObjects();
1843 
1844         if (function(*ancestorLayer, inContainingBlockChain, ancestorLayer == nextPaintOrderParent) == AncestorTraversal::Stop)
1845             return AncestorTraversal::Stop;
1846 
1847         if (inContainingBlockChain)
1848             containingBlockCanSkipLayers = ancestorLayer-&gt;renderer().isAbsolutelyPositioned();
1849 
1850         if (ancestorLayer == nextPaintOrderParent)
1851             nextPaintOrderParent = ancestorLayer-&gt;paintOrderParent();
1852     }
1853 
1854     return AncestorTraversal::Continue;
1855 }
1856 
1857 static bool createsClippingScope(const RenderLayer&amp; layer)
1858 {
1859     return layer.hasCompositedScrollableOverflow();
1860 }
1861 
1862 static Vector&lt;LayerOverlapMap::LayerAndBounds&gt; enclosingClippingScopes(const RenderLayer&amp; layer, const RenderLayer&amp; rootLayer)
1863 {
1864     Vector&lt;LayerOverlapMap::LayerAndBounds&gt; clippingScopes;
1865     clippingScopes.append({ const_cast&lt;RenderLayer&amp;&gt;(rootLayer), { } });
1866 
1867     if (!layer.hasCompositedScrollingAncestor())
1868         return clippingScopes;
1869 
1870     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool inContainingBlockChain, bool) {
1871         if (inContainingBlockChain &amp;&amp; createsClippingScope(ancestorLayer)) {
1872             LayoutRect clipRect;
1873             if (is&lt;RenderBox&gt;(ancestorLayer.renderer())) {
1874                 // FIXME: This is expensive. Broken with transforms.
1875                 LayoutPoint offsetFromRoot = ancestorLayer.convertToLayerCoords(&amp;rootLayer, { });
1876                 clipRect = downcast&lt;RenderBox&gt;(ancestorLayer.renderer()).overflowClipRect(offsetFromRoot);
1877             }
1878 
1879             LayerOverlapMap::LayerAndBounds layerAndBounds { const_cast&lt;RenderLayer&amp;&gt;(ancestorLayer), clipRect };
1880             clippingScopes.insert(1, layerAndBounds); // Order is roots to leaves.
1881         }
1882         return AncestorTraversal::Continue;
1883     });
1884 
1885     return clippingScopes;
1886 }
1887 
1888 void RenderLayerCompositor::addToOverlapMap(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent) const
1889 {
1890     if (layer.isRenderViewLayer())
1891         return;
1892 
1893     computeExtent(overlapMap, layer, extent);
1894 
1895     // FIXME: constrain the scopes (by composited stacking context ancestor I think).
1896     auto clippingScopes = enclosingClippingScopes(layer, rootRenderLayer());
1897 
1898     LayoutRect clipRect;
1899     if (layer.hasCompositedScrollingAncestor()) {
1900         // Compute a clip up to the composited scrolling ancestor, then convert it to absolute coordinates.
1901         auto&amp; scrollingScope = clippingScopes.last();
1902         clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;scrollingScope.layer, TemporaryClipRects, IgnoreOverlayScrollbarSize, IgnoreOverflowClip)).rect();
1903         if (!clipRect.isInfinite())
1904             clipRect.setLocation(layer.convertToLayerCoords(&amp;rootRenderLayer(), clipRect.location()));
1905     } else
1906         clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;rootRenderLayer(), AbsoluteClipRects)).rect(); // FIXME: Incorrect for CSS regions.
1907 
1908     auto clippedBounds = extent.bounds;
1909     if (!clipRect.isInfinite()) {
1910         // With delegated page scaling, pageScaleFactor() is not applied by RenderView, so we should not scale here.
1911         if (!page().delegatesScaling())
1912             clipRect.scale(pageScaleFactor());
1913 
1914         clippedBounds.intersect(clipRect);
1915     }
1916 
1917     overlapMap.add(layer, clippedBounds, clippingScopes);
1918 }
1919 
1920 void RenderLayerCompositor::addDescendantsToOverlapMapRecursive(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, const RenderLayer* ancestorLayer) const
1921 {
1922     if (!canBeComposited(layer))
1923         return;
1924 
1925     // A null ancestorLayer is an indication that &#39;layer&#39; has already been pushed.
1926     if (ancestorLayer) {
1927         overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer);
1928 
1929         OverlapExtent layerExtent;
1930         addToOverlapMap(overlapMap, layer, layerExtent);
1931     }
1932 
1933 #if ASSERT_ENABLED
1934     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
1935 #endif
1936 
1937     for (auto* renderLayer : layer.negativeZOrderLayers())
1938         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1939 
1940     for (auto* renderLayer : layer.normalFlowLayers())
1941         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1942 
1943     for (auto* renderLayer : layer.positiveZOrderLayers())
1944         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1945 
1946     if (ancestorLayer)
1947         overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1948 }
1949 
1950 void RenderLayerCompositor::updateOverlapMap(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; layerExtent, bool didPushContainer, bool addLayerToOverlap, bool addDescendantsToOverlap) const
1951 {
1952     if (addLayerToOverlap) {
1953         addToOverlapMap(overlapMap, layer, layerExtent);
1954         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; contributes to overlap, added to map &quot; &lt;&lt; overlapMap);
1955     }
1956 
1957     if (addDescendantsToOverlap) {
1958         // If this is the first non-root layer to composite, we need to add all the descendants we already traversed to the overlap map.
1959         addDescendantsToOverlapMapRecursive(overlapMap, layer);
1960         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; composited post descendant traversal, added recursive &quot; &lt;&lt; overlapMap);
1961     }
1962 
1963     if (didPushContainer) {
1964         overlapMap.popCompositingContainer();
1965         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; is composited or shared, popped container &quot; &lt;&lt; overlapMap);
1966     }
1967 }
1968 
1969 bool RenderLayerCompositor::layerOverlaps(const LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; layerExtent) const
1970 {
1971     computeExtent(overlapMap, layer, layerExtent);
1972 
1973     auto clippingScopes = enclosingClippingScopes(layer, rootRenderLayer());
1974     return overlapMap.overlapsLayers(layer, layerExtent.bounds, clippingScopes);
1975 }
1976 
1977 #if ENABLE(VIDEO)
1978 bool RenderLayerCompositor::canAccelerateVideoRendering(RenderVideo&amp; video) const
1979 {
1980     if (!m_hasAcceleratedCompositing)
1981         return false;
1982 
1983     return video.supportsAcceleratedRendering();
1984 }
1985 #endif
1986 
1987 void RenderLayerCompositor::frameViewDidChangeLocation(const IntPoint&amp; contentsOffset)
1988 {
1989     if (m_overflowControlsHostLayer)
1990         m_overflowControlsHostLayer-&gt;setPosition(contentsOffset);
1991 }
1992 
1993 void RenderLayerCompositor::frameViewDidChangeSize()
1994 {
1995     if (auto* layer = m_renderView.layer())
1996         layer-&gt;setNeedsCompositingGeometryUpdate();
1997 
1998     if (m_scrolledContentsLayer) {
1999         updateScrollLayerClipping();
2000         frameViewDidScroll();
2001         updateOverflowControlsLayers();
2002 
2003 #if ENABLE(RUBBER_BANDING)
2004         if (m_layerForOverhangAreas) {
2005             auto&amp; frameView = m_renderView.frameView();
2006             m_layerForOverhangAreas-&gt;setSize(frameView.frameRect().size());
2007             m_layerForOverhangAreas-&gt;setPosition(FloatPoint(0, frameView.topContentInset()));
2008         }
2009 #endif
2010     }
2011 }
2012 
2013 void RenderLayerCompositor::widgetDidChangeSize(RenderWidget&amp; widget)
2014 {
2015     if (!widget.hasLayer())
2016         return;
2017 
2018     auto&amp; layer = *widget.layer();
2019 
2020     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; widgetDidChangeSize (layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot;)&quot;);
2021 
2022     // Widget size affects answer to requiresCompositingForFrame() so we need to trigger
2023     // a compositing update.
2024     layer.setNeedsPostLayoutCompositingUpdate();
2025     scheduleCompositingLayerUpdate();
2026 
2027     if (layer.isComposited())
2028         layer.backing()-&gt;updateAfterWidgetResize();
2029 }
2030 
2031 bool RenderLayerCompositor::hasCoordinatedScrolling() const
2032 {
2033     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
2034     return scrollingCoordinator &amp;&amp; scrollingCoordinator-&gt;coordinatesScrollingForFrameView(m_renderView.frameView());
2035 }
2036 
2037 void RenderLayerCompositor::updateScrollLayerPosition()
2038 {
2039     ASSERT(!hasCoordinatedScrolling());
2040     ASSERT(m_scrolledContentsLayer);
2041 
2042     auto&amp; frameView = m_renderView.frameView();
2043     IntPoint scrollPosition = frameView.scrollPosition();
2044 
2045     // We use scroll position here because the root content layer is offset to account for scrollOrigin (see FrameView::positionForRootContentLayer).
2046     m_scrolledContentsLayer-&gt;setPosition(FloatPoint(-scrollPosition.x(), -scrollPosition.y()));
2047 
2048     if (auto* fixedBackgroundLayer = fixedRootBackgroundLayer())
2049         fixedBackgroundLayer-&gt;setPosition(frameView.scrollPositionForFixedPosition());
2050 }
2051 
2052 void RenderLayerCompositor::updateScrollLayerClipping()
2053 {
2054     auto* layerForClipping = this-&gt;layerForClipping();
2055     if (!layerForClipping)
2056         return;
2057 
2058     layerForClipping-&gt;setSize(m_renderView.frameView().sizeForVisibleContent());
2059     layerForClipping-&gt;setPosition(positionForClipLayer());
2060 }
2061 
2062 FloatPoint RenderLayerCompositor::positionForClipLayer() const
2063 {
2064     auto&amp; frameView = m_renderView.frameView();
2065 
2066     return FloatPoint(
2067         frameView.shouldPlaceBlockDirectionScrollbarOnLeft() ? frameView.horizontalScrollbarIntrusion() : 0,
2068         FrameView::yPositionForInsetClipLayer(frameView.scrollPosition(), frameView.topContentInset()));
2069 }
2070 
2071 void RenderLayerCompositor::frameViewDidScroll()
2072 {
2073     if (!m_scrolledContentsLayer)
2074         return;
2075 
2076     // If there&#39;s a scrolling coordinator that manages scrolling for this frame view,
2077     // it will also manage updating the scroll layer position.
2078     if (hasCoordinatedScrolling()) {
2079         // We have to schedule a flush in order for the main TiledBacking to update its tile coverage.
2080         scheduleLayerFlush();
2081         return;
2082     }
2083 
2084     updateScrollLayerPosition();
2085 }
2086 
2087 void RenderLayerCompositor::frameViewDidAddOrRemoveScrollbars()
2088 {
2089     updateOverflowControlsLayers();
2090 }
2091 
2092 void RenderLayerCompositor::frameViewDidLayout()
2093 {
2094     if (auto* renderViewBacking = m_renderView.layer()-&gt;backing())
2095         renderViewBacking-&gt;adjustTiledBackingCoverage();
2096 }
2097 
2098 void RenderLayerCompositor::rootLayerConfigurationChanged()
2099 {
2100     auto* renderViewBacking = m_renderView.layer()-&gt;backing();
2101     if (renderViewBacking &amp;&amp; renderViewBacking-&gt;isFrameLayerWithTiledBacking()) {
2102         m_renderView.layer()-&gt;setNeedsCompositingConfigurationUpdate();
2103         scheduleCompositingLayerUpdate();
2104     }
2105 }
2106 
2107 String RenderLayerCompositor::layerTreeAsText(LayerTreeFlags flags)
2108 {
2109     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; layerTreeAsText&quot;);
2110     updateCompositingLayers(CompositingUpdateType::AfterLayout);
2111 
2112     if (!m_rootContentsLayer)
2113         return String();
2114 
2115     flushPendingLayerChanges(true);
2116     page().renderingUpdateScheduler().scheduleImmediateRenderingUpdate();
2117 
2118     LayerTreeAsTextBehavior layerTreeBehavior = LayerTreeAsTextBehaviorNormal;
2119     if (flags &amp; LayerTreeFlagsIncludeDebugInfo)
2120         layerTreeBehavior |= LayerTreeAsTextDebug;
2121     if (flags &amp; LayerTreeFlagsIncludeVisibleRects)
2122         layerTreeBehavior |= LayerTreeAsTextIncludeVisibleRects;
2123     if (flags &amp; LayerTreeFlagsIncludeTileCaches)
2124         layerTreeBehavior |= LayerTreeAsTextIncludeTileCaches;
2125     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
2126         layerTreeBehavior |= LayerTreeAsTextIncludeRepaintRects;
2127     if (flags &amp; LayerTreeFlagsIncludePaintingPhases)
2128         layerTreeBehavior |= LayerTreeAsTextIncludePaintingPhases;
2129     if (flags &amp; LayerTreeFlagsIncludeContentLayers)
2130         layerTreeBehavior |= LayerTreeAsTextIncludeContentLayers;
2131     if (flags &amp; LayerTreeFlagsIncludeAcceleratesDrawing)
2132         layerTreeBehavior |= LayerTreeAsTextIncludeAcceleratesDrawing;
2133     if (flags &amp; LayerTreeFlagsIncludeClipping)
2134         layerTreeBehavior |= LayerTreeAsTextIncludeClipping;
2135     if (flags &amp; LayerTreeFlagsIncludeBackingStoreAttached)
2136         layerTreeBehavior |= LayerTreeAsTextIncludeBackingStoreAttached;
2137     if (flags &amp; LayerTreeFlagsIncludeRootLayerProperties)
2138         layerTreeBehavior |= LayerTreeAsTextIncludeRootLayerProperties;
2139     if (flags &amp; LayerTreeFlagsIncludeEventRegion)
2140         layerTreeBehavior |= LayerTreeAsTextIncludeEventRegion;
2141     if (flags &amp; LayerTreeFlagsIncludeDeepColor)
2142         layerTreeBehavior |= LayerTreeAsTextIncludeDeepColor;
2143 
2144     // We skip dumping the scroll and clip layers to keep layerTreeAsText output
2145     // similar between platforms.
2146     String layerTreeText = m_rootContentsLayer-&gt;layerTreeAsText(layerTreeBehavior);
2147 
2148     // Dump an empty layer tree only if the only composited layer is the main frame&#39;s tiled backing,
2149     // so that tests expecting us to drop out of accelerated compositing when there are no layers succeed.
2150     if (!hasContentCompositingLayers() &amp;&amp; documentUsesTiledBacking() &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeTileCaches) &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeRootLayerProperties))
2151         layerTreeText = emptyString();
2152 
2153     // The true root layer is not included in the dump, so if we want to report
2154     // its repaint rects, they must be included here.
2155     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
2156         return m_renderView.frameView().trackedRepaintRectsAsText() + layerTreeText;
2157 
2158     return layerTreeText;
2159 }
2160 
2161 static RenderView* frameContentsRenderView(RenderWidget&amp; renderer)
2162 {
2163     if (auto* contentDocument = renderer.frameOwnerElement().contentDocument())
2164         return contentDocument-&gt;renderView();
2165 
2166     return nullptr;
2167 }
2168 
2169 RenderLayerCompositor* RenderLayerCompositor::frameContentsCompositor(RenderWidget&amp; renderer)
2170 {
2171     if (auto* view = frameContentsRenderView(renderer))
2172         return &amp;view-&gt;compositor();
2173 
2174     return nullptr;
2175 }
2176 
2177 bool RenderLayerCompositor::parentFrameContentLayers(RenderWidget&amp; renderer)
2178 {
2179     auto* innerCompositor = frameContentsCompositor(renderer);
2180     if (!innerCompositor || !innerCompositor-&gt;usesCompositing() || innerCompositor-&gt;rootLayerAttachment() != RootLayerAttachedViaEnclosingFrame)
2181         return false;
2182 
2183     auto* layer = renderer.layer();
2184     if (!layer-&gt;isComposited())
2185         return false;
2186 
2187     auto* backing = layer-&gt;backing();
2188     auto* hostingLayer = backing-&gt;parentForSublayers();
2189     auto* rootLayer = innerCompositor-&gt;rootGraphicsLayer();
2190     if (hostingLayer-&gt;children().size() != 1 || hostingLayer-&gt;children()[0].ptr() != rootLayer) {
2191         hostingLayer-&gt;removeAllChildren();
2192         hostingLayer-&gt;addChild(*rootLayer);
2193     }
2194 
2195     if (auto frameHostingNodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting)) {
2196         auto* contentsRenderView = frameContentsRenderView(renderer);
2197         if (auto frameRootScrollingNodeID = contentsRenderView-&gt;frameView().scrollingNodeID()) {
2198             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
2199                 scrollingCoordinator-&gt;insertNode(ScrollingNodeType::Subframe, frameRootScrollingNodeID, frameHostingNodeID, 0);
2200         }
2201     }
2202 
2203     // FIXME: Why always return true and not just when the layers changed?
2204     return true;
2205 }
2206 
2207 void RenderLayerCompositor::repaintCompositedLayers()
2208 {
2209     recursiveRepaintLayer(rootRenderLayer());
2210 }
2211 
2212 void RenderLayerCompositor::recursiveRepaintLayer(RenderLayer&amp; layer)
2213 {
2214     layer.updateLayerListsIfNeeded();
2215 
2216     // FIXME: This method does not work correctly with transforms.
2217     if (layer.isComposited() &amp;&amp; !layer.backing()-&gt;paintsIntoCompositedAncestor())
2218         layer.setBackingNeedsRepaint();
2219 
2220 #if ASSERT_ENABLED
2221     LayerListMutationDetector mutationChecker(layer);
2222 #endif
2223 
2224     if (layer.hasCompositingDescendant()) {
2225         for (auto* renderLayer : layer.negativeZOrderLayers())
2226             recursiveRepaintLayer(*renderLayer);
2227 
2228         for (auto* renderLayer : layer.positiveZOrderLayers())
2229             recursiveRepaintLayer(*renderLayer);
2230     }
2231 
2232     for (auto* renderLayer : layer.normalFlowLayers())
2233         recursiveRepaintLayer(*renderLayer);
2234 }
2235 
2236 RenderLayer&amp; RenderLayerCompositor::rootRenderLayer() const
2237 {
2238     return *m_renderView.layer();
2239 }
2240 
2241 GraphicsLayer* RenderLayerCompositor::rootGraphicsLayer() const
2242 {
2243     if (m_overflowControlsHostLayer)
2244         return m_overflowControlsHostLayer.get();
2245     return m_rootContentsLayer.get();
2246 }
2247 
2248 void RenderLayerCompositor::setIsInWindow(bool isInWindow)
2249 {
2250     LOG(Compositing, &quot;RenderLayerCompositor %p setIsInWindow %d&quot;, this, isInWindow);
2251 
2252     if (!usesCompositing())
2253         return;
2254 
2255     if (auto* rootLayer = rootGraphicsLayer()) {
2256         GraphicsLayer::traverse(*rootLayer, [isInWindow](GraphicsLayer&amp; layer) {
2257             layer.setIsInWindow(isInWindow);
2258         });
2259     }
2260 
2261     if (isInWindow) {
2262         if (m_rootLayerAttachment != RootLayerUnattached)
2263             return;
2264 
2265         RootLayerAttachment attachment = isMainFrameCompositor() ? RootLayerAttachedViaChromeClient : RootLayerAttachedViaEnclosingFrame;
2266         attachRootLayer(attachment);
2267 #if PLATFORM(IOS_FAMILY)
2268         if (m_legacyScrollingLayerCoordinator) {
2269             m_legacyScrollingLayerCoordinator-&gt;registerAllViewportConstrainedLayers(*this);
2270             m_legacyScrollingLayerCoordinator-&gt;registerAllScrollingLayers();
2271         }
2272 #endif
2273     } else {
2274         if (m_rootLayerAttachment == RootLayerUnattached)
2275             return;
2276 
2277         detachRootLayer();
2278 #if PLATFORM(IOS_FAMILY)
2279         if (m_legacyScrollingLayerCoordinator) {
2280             m_legacyScrollingLayerCoordinator-&gt;unregisterAllViewportConstrainedLayers();
2281             m_legacyScrollingLayerCoordinator-&gt;unregisterAllScrollingLayers();
2282         }
2283 #endif
2284     }
2285 }
2286 
2287 void RenderLayerCompositor::clearBackingForLayerIncludingDescendants(RenderLayer&amp; layer)
2288 {
2289     if (layer.isComposited())
2290         layer.clearBacking();
2291 
2292     for (auto* childLayer = layer.firstChild(); childLayer; childLayer = childLayer-&gt;nextSibling())
2293         clearBackingForLayerIncludingDescendants(*childLayer);
2294 }
2295 
2296 void RenderLayerCompositor::clearBackingForAllLayers()
2297 {
2298     clearBackingForLayerIncludingDescendants(*m_renderView.layer());
2299 }
2300 
2301 void RenderLayerCompositor::updateRootLayerPosition()
2302 {
2303     if (m_rootContentsLayer) {
2304         m_rootContentsLayer-&gt;setSize(m_renderView.frameView().contentsSize());
2305         m_rootContentsLayer-&gt;setPosition(m_renderView.frameView().positionForRootContentLayer());
2306         m_rootContentsLayer-&gt;setAnchorPoint(FloatPoint3D());
2307     }
2308 
2309     updateScrollLayerClipping();
2310 
2311 #if ENABLE(RUBBER_BANDING)
2312     if (m_contentShadowLayer &amp;&amp; m_rootContentsLayer) {
2313         m_contentShadowLayer-&gt;setPosition(m_rootContentsLayer-&gt;position());
2314         m_contentShadowLayer-&gt;setSize(m_rootContentsLayer-&gt;size());
2315     }
2316 
2317     updateLayerForTopOverhangArea(m_layerForTopOverhangArea != nullptr);
2318     updateLayerForBottomOverhangArea(m_layerForBottomOverhangArea != nullptr);
2319     updateLayerForHeader(m_layerForHeader != nullptr);
2320     updateLayerForFooter(m_layerForFooter != nullptr);
2321 #endif
2322 }
2323 
2324 bool RenderLayerCompositor::has3DContent() const
2325 {
2326     return layerHas3DContent(rootRenderLayer());
2327 }
2328 
2329 bool RenderLayerCompositor::needsToBeComposited(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2330 {
2331     if (!canBeComposited(layer))
2332         return false;
2333 
2334     return requiresCompositingLayer(layer, queryData) || layer.mustCompositeForIndirectReasons() || (usesCompositing() &amp;&amp; layer.isRenderViewLayer());
2335 }
2336 
2337 // Note: this specifies whether the RL needs a compositing layer for intrinsic reasons.
2338 // Use needsToBeComposited() to determine if a RL actually needs a compositing layer.
2339 // FIXME: is clipsCompositingDescendants() an intrinsic reason?
2340 bool RenderLayerCompositor::requiresCompositingLayer(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2341 {
2342     auto&amp; renderer = rendererForCompositingTests(layer);
2343 
2344     // The root layer always has a compositing layer, but it may not have backing.
2345     return requiresCompositingForTransform(renderer)
2346         || requiresCompositingForAnimation(renderer)
2347         || requiresCompositingForPosition(renderer, *renderer.layer(), queryData)
2348         || requiresCompositingForCanvas(renderer)
2349         || requiresCompositingForFilters(renderer)
2350         || requiresCompositingForWillChange(renderer)
2351         || requiresCompositingForBackfaceVisibility(renderer)
2352         || requiresCompositingForVideo(renderer)
2353         || requiresCompositingForFrame(renderer, queryData)
2354         || requiresCompositingForPlugin(renderer, queryData)
2355         || requiresCompositingForEditableImage(renderer)
2356         || requiresCompositingForOverflowScrolling(*renderer.layer(), queryData);
2357 }
2358 
2359 bool RenderLayerCompositor::canBeComposited(const RenderLayer&amp; layer) const
2360 {
2361     if (m_hasAcceleratedCompositing &amp;&amp; layer.isSelfPaintingLayer()) {
2362         if (!layer.isInsideFragmentedFlow())
2363             return true;
2364 
2365         // CSS Regions flow threads do not need to be composited as we use composited RenderFragmentContainers
2366         // to render the background of the RenderFragmentedFlow.
2367         if (layer.isRenderFragmentedFlow())
2368             return false;
2369 
2370         return true;
2371     }
2372     return false;
2373 }
2374 
2375 #if ENABLE(FULLSCREEN_API)
2376 enum class FullScreenDescendant { Yes, No, NotApplicable };
2377 static FullScreenDescendant isDescendantOfFullScreenLayer(const RenderLayer&amp; layer)
2378 {
2379     auto&amp; document = layer.renderer().document();
2380 
2381     if (!document.fullscreenManager().isFullscreen() || !document.fullscreenManager().fullscreenRenderer())
2382         return FullScreenDescendant::NotApplicable;
2383 
2384     auto* fullScreenLayer = document.fullscreenManager().fullscreenRenderer()-&gt;layer();
2385     if (!fullScreenLayer) {
2386         ASSERT_NOT_REACHED();
2387         return FullScreenDescendant::NotApplicable;
2388     }
2389 
2390     return layer.isDescendantOf(*fullScreenLayer) ? FullScreenDescendant::Yes : FullScreenDescendant::No;
2391 }
2392 #endif
2393 
2394 bool RenderLayerCompositor::requiresOwnBackingStore(const RenderLayer&amp; layer, const RenderLayer* compositingAncestorLayer, const LayoutRect&amp; layerCompositedBoundsInAncestor, const LayoutRect&amp; ancestorCompositedBounds) const
2395 {
2396     auto&amp; renderer = layer.renderer();
2397 
2398     if (compositingAncestorLayer
2399         &amp;&amp; !(compositingAncestorLayer-&gt;backing()-&gt;graphicsLayer()-&gt;drawsContent()
2400             || compositingAncestorLayer-&gt;backing()-&gt;paintsIntoWindow()
2401             || compositingAncestorLayer-&gt;backing()-&gt;paintsIntoCompositedAncestor()))
2402         return true;
2403 
2404     RequiresCompositingData queryData;
2405     if (layer.isRenderViewLayer()
2406         || layer.transform() // note: excludes perspective and transformStyle3D.
2407         || requiresCompositingForAnimation(renderer)
2408         || requiresCompositingForPosition(renderer, layer, queryData)
2409         || requiresCompositingForCanvas(renderer)
2410         || requiresCompositingForFilters(renderer)
2411         || requiresCompositingForWillChange(renderer)
2412         || requiresCompositingForBackfaceVisibility(renderer)
2413         || requiresCompositingForVideo(renderer)
2414         || requiresCompositingForFrame(renderer, queryData)
2415         || requiresCompositingForPlugin(renderer, queryData)
2416         || requiresCompositingForEditableImage(renderer)
2417         || requiresCompositingForOverflowScrolling(layer, queryData)
2418         || needsContentsCompositingLayer(layer)
2419         || renderer.isTransparent()
2420         || renderer.hasMask()
2421         || renderer.hasReflection()
2422         || renderer.hasFilter()
2423         || renderer.hasBackdropFilter())
2424         return true;
2425 
2426     if (layer.isComposited() &amp;&amp; layer.backing()-&gt;hasBackingSharingLayers())
2427         return true;
2428 
2429     // FIXME: We really need to keep track of the ancestor layer that has its own backing store.
2430     if (!ancestorCompositedBounds.contains(layerCompositedBoundsInAncestor))
2431         return true;
2432 
2433     if (layer.mustCompositeForIndirectReasons()) {
2434         IndirectCompositingReason reason = layer.indirectCompositingReason();
2435         return reason == IndirectCompositingReason::Overlap
2436             || reason == IndirectCompositingReason::OverflowScrollPositioning
2437             || reason == IndirectCompositingReason::Stacking
2438             || reason == IndirectCompositingReason::BackgroundLayer
2439             || reason == IndirectCompositingReason::GraphicalEffect
2440             || reason == IndirectCompositingReason::Preserve3D; // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.
2441     }
2442 
2443     return false;
2444 }
2445 
2446 OptionSet&lt;CompositingReason&gt; RenderLayerCompositor::reasonsForCompositing(const RenderLayer&amp; layer) const
2447 {
2448     OptionSet&lt;CompositingReason&gt; reasons;
2449 
2450     if (!layer.isComposited())
2451         return reasons;
2452 
2453     RequiresCompositingData queryData;
2454 
2455     auto&amp; renderer = rendererForCompositingTests(layer);
2456 
2457     if (requiresCompositingForTransform(renderer))
2458         reasons.add(CompositingReason::Transform3D);
2459 
2460     if (requiresCompositingForVideo(renderer))
2461         reasons.add(CompositingReason::Video);
2462     else if (requiresCompositingForCanvas(renderer))
2463         reasons.add(CompositingReason::Canvas);
2464     else if (requiresCompositingForPlugin(renderer, queryData))
2465         reasons.add(CompositingReason::Plugin);
2466     else if (requiresCompositingForFrame(renderer, queryData))
2467         reasons.add(CompositingReason::IFrame);
2468     else if (requiresCompositingForEditableImage(renderer))
2469         reasons.add(CompositingReason::EmbeddedView);
2470 
2471     if ((canRender3DTransforms() &amp;&amp; renderer.style().backfaceVisibility() == BackfaceVisibility::Hidden))
2472         reasons.add(CompositingReason::BackfaceVisibilityHidden);
2473 
2474     if (requiresCompositingForAnimation(renderer))
2475         reasons.add(CompositingReason::Animation);
2476 
2477     if (requiresCompositingForFilters(renderer))
2478         reasons.add(CompositingReason::Filters);
2479 
2480     if (requiresCompositingForWillChange(renderer))
2481         reasons.add(CompositingReason::WillChange);
2482 
2483     if (requiresCompositingForPosition(renderer, *renderer.layer(), queryData))
2484         reasons.add(renderer.isFixedPositioned() ? CompositingReason::PositionFixed : CompositingReason::PositionSticky);
2485 
2486     if (requiresCompositingForOverflowScrolling(*renderer.layer(), queryData))
2487         reasons.add(CompositingReason::OverflowScrolling);
2488 
2489     switch (renderer.layer()-&gt;indirectCompositingReason()) {
2490     case IndirectCompositingReason::None:
2491         break;
2492     case IndirectCompositingReason::Clipping:
2493         reasons.add(CompositingReason::ClipsCompositingDescendants);
2494         break;
2495     case IndirectCompositingReason::Stacking:
2496         reasons.add(CompositingReason::Stacking);
2497         break;
2498     case IndirectCompositingReason::OverflowScrollPositioning:
2499         reasons.add(CompositingReason::OverflowScrollPositioning);
2500         break;
2501     case IndirectCompositingReason::Overlap:
2502         reasons.add(CompositingReason::Overlap);
2503         break;
2504     case IndirectCompositingReason::BackgroundLayer:
2505         reasons.add(CompositingReason::NegativeZIndexChildren);
2506         break;
2507     case IndirectCompositingReason::GraphicalEffect:
2508         if (renderer.hasTransform())
2509             reasons.add(CompositingReason::TransformWithCompositedDescendants);
2510 
2511         if (renderer.isTransparent())
2512             reasons.add(CompositingReason::OpacityWithCompositedDescendants);
2513 
2514         if (renderer.hasMask())
2515             reasons.add(CompositingReason::MaskWithCompositedDescendants);
2516 
2517         if (renderer.hasReflection())
2518             reasons.add(CompositingReason::ReflectionWithCompositedDescendants);
2519 
2520         if (renderer.hasFilter() || renderer.hasBackdropFilter())
2521             reasons.add(CompositingReason::FilterWithCompositedDescendants);
2522 
2523 #if ENABLE(CSS_COMPOSITING)
2524         if (layer.isolatesCompositedBlending())
2525             reasons.add(CompositingReason::IsolatesCompositedBlendingDescendants);
2526 
2527         if (layer.hasBlendMode())
2528             reasons.add(CompositingReason::BlendingWithCompositedDescendants);
2529 #endif
2530         break;
2531     case IndirectCompositingReason::Perspective:
2532         reasons.add(CompositingReason::Perspective);
2533         break;
2534     case IndirectCompositingReason::Preserve3D:
2535         reasons.add(CompositingReason::Preserve3D);
2536         break;
2537     }
2538 
2539     if (usesCompositing() &amp;&amp; renderer.layer()-&gt;isRenderViewLayer())
2540         reasons.add(CompositingReason::Root);
2541 
2542     return reasons;
2543 }
2544 
2545 #if !LOG_DISABLED
2546 const char* RenderLayerCompositor::logReasonsForCompositing(const RenderLayer&amp; layer)
2547 {
2548     OptionSet&lt;CompositingReason&gt; reasons = reasonsForCompositing(layer);
2549 
2550     if (reasons &amp; CompositingReason::Transform3D)
2551         return &quot;3D transform&quot;;
2552 
2553     if (reasons &amp; CompositingReason::Video)
2554         return &quot;video&quot;;
2555 
2556     if (reasons &amp; CompositingReason::Canvas)
2557         return &quot;canvas&quot;;
2558 
2559     if (reasons &amp; CompositingReason::Plugin)
2560         return &quot;plugin&quot;;
2561 
2562     if (reasons &amp; CompositingReason::IFrame)
2563         return &quot;iframe&quot;;
2564 
2565     if (reasons &amp; CompositingReason::BackfaceVisibilityHidden)
2566         return &quot;backface-visibility: hidden&quot;;
2567 
2568     if (reasons &amp; CompositingReason::ClipsCompositingDescendants)
2569         return &quot;clips compositing descendants&quot;;
2570 
2571     if (reasons &amp; CompositingReason::Animation)
2572         return &quot;animation&quot;;
2573 
2574     if (reasons &amp; CompositingReason::Filters)
2575         return &quot;filters&quot;;
2576 
2577     if (reasons &amp; CompositingReason::PositionFixed)
2578         return &quot;position: fixed&quot;;
2579 
2580     if (reasons &amp; CompositingReason::PositionSticky)
2581         return &quot;position: sticky&quot;;
2582 
2583     if (reasons &amp; CompositingReason::OverflowScrolling)
2584         return &quot;async overflow scrolling&quot;;
2585 
2586     if (reasons &amp; CompositingReason::Stacking)
2587         return &quot;stacking&quot;;
2588 
2589     if (reasons &amp; CompositingReason::Overlap)
2590         return &quot;overlap&quot;;
2591 
2592     if (reasons &amp; CompositingReason::NegativeZIndexChildren)
2593         return &quot;negative z-index children&quot;;
2594 
2595     if (reasons &amp; CompositingReason::TransformWithCompositedDescendants)
2596         return &quot;transform with composited descendants&quot;;
2597 
2598     if (reasons &amp; CompositingReason::OpacityWithCompositedDescendants)
2599         return &quot;opacity with composited descendants&quot;;
2600 
2601     if (reasons &amp; CompositingReason::MaskWithCompositedDescendants)
2602         return &quot;mask with composited descendants&quot;;
2603 
2604     if (reasons &amp; CompositingReason::ReflectionWithCompositedDescendants)
2605         return &quot;reflection with composited descendants&quot;;
2606 
2607     if (reasons &amp; CompositingReason::FilterWithCompositedDescendants)
2608         return &quot;filter with composited descendants&quot;;
2609 
2610 #if ENABLE(CSS_COMPOSITING)
2611     if (reasons &amp; CompositingReason::BlendingWithCompositedDescendants)
2612         return &quot;blending with composited descendants&quot;;
2613 
2614     if (reasons &amp; CompositingReason::IsolatesCompositedBlendingDescendants)
2615         return &quot;isolates composited blending descendants&quot;;
2616 #endif
2617 
2618     if (reasons &amp; CompositingReason::Perspective)
2619         return &quot;perspective&quot;;
2620 
2621     if (reasons &amp; CompositingReason::Preserve3D)
2622         return &quot;preserve-3d&quot;;
2623 
2624     if (reasons &amp; CompositingReason::Root)
2625         return &quot;root&quot;;
2626 
2627     return &quot;&quot;;
2628 }
2629 #endif
2630 
2631 // Return true if the given layer has some ancestor in the RenderLayer hierarchy that clips,
2632 // up to the enclosing compositing ancestor. This is required because compositing layers are parented
2633 // according to the z-order hierarchy, yet clipping goes down the renderer hierarchy.
2634 // Thus, a RenderLayer can be clipped by a RenderLayer that is an ancestor in the renderer hierarchy,
2635 // but a sibling in the z-order hierarchy.
2636 // FIXME: can we do this without a tree walk?
2637 bool RenderLayerCompositor::clippedByAncestor(RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const
2638 {
2639     ASSERT(layer.isComposited());
2640     if (!compositingAncestor)
2641         return false;
2642 
2643     // If the compositingAncestor clips, that will be taken care of by clipsCompositingDescendants(),
2644     // so we only care about clipping between its first child that is our ancestor (the computeClipRoot),
2645     // and layer. The exception is when the compositingAncestor isolates composited blending children,
2646     // in this case it is not allowed to clipsCompositingDescendants() and each of its children
2647     // will be clippedByAncestor()s, including the compositingAncestor.
2648     auto* computeClipRoot = compositingAncestor;
2649     if (!compositingAncestor-&gt;isolatesCompositedBlending()) {
2650         computeClipRoot = nullptr;
2651         auto* parent = &amp;layer;
2652         while (parent) {
2653             auto* next = parent-&gt;parent();
2654             if (next == compositingAncestor) {
2655                 computeClipRoot = parent;
2656                 break;
2657             }
2658             parent = next;
2659         }
2660 
2661         if (!computeClipRoot || computeClipRoot == &amp;layer)
2662             return false;
2663     }
2664 
2665     return !layer.backgroundClipRect(RenderLayer::ClipRectsContext(computeClipRoot, TemporaryClipRects)).isInfinite(); // FIXME: Incorrect for CSS regions.
2666 }
2667 
2668 bool RenderLayerCompositor::updateAncestorClippingStack(const RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const
2669 {
2670     ASSERT(layer.isComposited());
2671 
2672     auto clippingStack = computeAncestorClippingStack(layer, compositingAncestor);
2673     return layer.backing()-&gt;updateAncestorClippingStack(WTFMove(clippingStack));
2674 }
2675 
2676 Vector&lt;CompositedClipData&gt; RenderLayerCompositor::computeAncestorClippingStack(const RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const
2677 {
2678     // On first pass in WK1, the root may not have become composited yet.
2679     if (!compositingAncestor)
2680         return { };
2681 
2682     // We&#39;ll start by building a child-to-ancestors stack.
2683     Vector&lt;CompositedClipData&gt; newStack;
2684 
2685     // Walk up the containing block chain to composited ancestor, prepending an entry to the clip stack for:
2686     // * each composited scrolling layer
2687     // * each set of RenderLayers which contribute a clip.
2688     bool haveNonScrollableClippingIntermediateLayer = false;
2689     const RenderLayer* currentClippedLayer = &amp;layer;
2690 
2691     auto pushNonScrollableClip = [&amp;](const RenderLayer&amp; clippedLayer, const RenderLayer&amp; clippingRoot, ShouldRespectOverflowClip respectClip = IgnoreOverflowClip) {
2692         // Pass IgnoreOverflowClip to ignore overflow contributed by clippingRoot (which may be a scroller).
2693         auto clipRect = clippedLayer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;clippingRoot, TemporaryClipRects, IgnoreOverlayScrollbarSize, respectClip)).rect();
2694         auto offset = layer.convertToLayerCoords(&amp;clippingRoot, { }, RenderLayer::AdjustForColumns);
2695         clipRect.moveBy(-offset);
2696 
2697         CompositedClipData clipData { const_cast&lt;RenderLayer*&gt;(&amp;clippedLayer), clipRect, false };
2698         newStack.insert(0, WTFMove(clipData));
2699     };
2700 
2701     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool /*isPaintOrderAncestor*/) {
2702         if (&amp;ancestorLayer == compositingAncestor) {
2703 
2704             if (haveNonScrollableClippingIntermediateLayer)
2705                 pushNonScrollableClip(*currentClippedLayer, ancestorLayer, ancestorLayer.isolatesCompositedBlending() ? RespectOverflowClip : IgnoreOverflowClip);
2706             else if (ancestorLayer.isolatesCompositedBlending() &amp;&amp; newStack.isEmpty())
2707                 pushNonScrollableClip(*currentClippedLayer, ancestorLayer, RespectOverflowClip);
2708 
2709             return AncestorTraversal::Stop;
2710         }
2711 
2712         if (isContainingBlockChain &amp;&amp; ancestorLayer.renderer().hasClipOrOverflowClip()) {
2713             if (ancestorLayer.hasCompositedScrollableOverflow()) {
2714                 if (haveNonScrollableClippingIntermediateLayer) {
2715                     pushNonScrollableClip(*currentClippedLayer, ancestorLayer);
2716                     haveNonScrollableClippingIntermediateLayer = false;
2717                 }
2718 
2719                 auto clipRect = parentRelativeScrollableRect(ancestorLayer, &amp;ancestorLayer);
2720                 auto offset = layer.convertToLayerCoords(&amp;ancestorLayer, { }, RenderLayer::AdjustForColumns);
2721                 clipRect.moveBy(-offset);
2722 
2723                 CompositedClipData clipData { const_cast&lt;RenderLayer*&gt;(&amp;ancestorLayer), clipRect, true };
2724                 newStack.insert(0, WTFMove(clipData));
2725                 currentClippedLayer = &amp;ancestorLayer;
2726             } else
2727                 haveNonScrollableClippingIntermediateLayer = true;
2728         }
2729 
2730         return AncestorTraversal::Continue;
2731     });
2732 
2733     return newStack;
2734 }
2735 
2736 // Note that this returns the ScrollingNodeID of the scroller this layer is embedded in, not the layer&#39;s own ScrollingNodeID if it has one.
2737 ScrollingNodeID RenderLayerCompositor::asyncScrollableContainerNodeID(const RenderObject&amp; renderer)
2738 {
2739     auto* enclosingLayer = renderer.enclosingLayer();
2740     if (!enclosingLayer)
2741         return 0;
2742 
2743     auto layerScrollingNodeID = [](const RenderLayer&amp; layer) -&gt; ScrollingNodeID {
2744         if (layer.isComposited())
2745             return layer.backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
2746         return 0;
2747     };
2748 
2749     // If the renderer is inside the layer, we care about the layer&#39;s scrollability. Otherwise, we let traverseAncestorLayers look at ancestors.
2750     if (!renderer.hasLayer()) {
2751         if (auto scrollingNodeID = layerScrollingNodeID(*enclosingLayer))
2752             return scrollingNodeID;
2753     }
2754 
2755     ScrollingNodeID containerScrollingNodeID = 0;
2756     traverseAncestorLayers(*enclosingLayer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool /*isPaintOrderAncestor*/) {
2757         if (isContainingBlockChain &amp;&amp; ancestorLayer.hasCompositedScrollableOverflow()) {
2758             containerScrollingNodeID = layerScrollingNodeID(ancestorLayer);
2759             return AncestorTraversal::Stop;
2760         }
2761         return AncestorTraversal::Continue;
2762     });
2763 
2764     return containerScrollingNodeID;
2765 }
2766 
2767 // Return true if the given layer is a stacking context and has compositing child
2768 // layers that it needs to clip. In this case we insert a clipping GraphicsLayer
2769 // into the hierarchy between this layer and its children in the z-order hierarchy.
2770 bool RenderLayerCompositor::clipsCompositingDescendants(const RenderLayer&amp; layer)
2771 {
2772     return layer.hasCompositingDescendant() &amp;&amp; layer.renderer().hasClipOrOverflowClip() &amp;&amp; !layer.isolatesCompositedBlending();
2773 }
2774 
2775 bool RenderLayerCompositor::requiresCompositingForAnimation(RenderLayerModelObject&amp; renderer) const
2776 {
2777     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
2778         return false;
2779 
2780     if (auto* element = renderer.element()) {
2781         if (auto* effectsStack = element-&gt;keyframeEffectStack()) {
2782             return (effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyOpacity)
2783                 &amp;&amp; (usesCompositing() || (m_compositingTriggers &amp; ChromeClient::AnimatedOpacityTrigger)))
2784                 || effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyFilter)
2785 #if ENABLE(FILTERS_LEVEL_2)
2786                 || effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyWebkitBackdropFilter)
2787 #endif
2788                 || effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyTransform);
2789         }
2790     }
2791 
2792     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
2793         return false;
2794 
2795     auto&amp; animController = renderer.animation();
2796     return (animController.isRunningAnimationOnRenderer(renderer, CSSPropertyOpacity)
2797         &amp;&amp; (usesCompositing() || (m_compositingTriggers &amp; ChromeClient::AnimatedOpacityTrigger)))
2798         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyFilter)
2799 #if ENABLE(FILTERS_LEVEL_2)
2800         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyWebkitBackdropFilter)
2801 #endif
2802         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
2803 }
2804 
2805 bool RenderLayerCompositor::requiresCompositingForTransform(RenderLayerModelObject&amp; renderer) const
2806 {
2807     if (!(m_compositingTriggers &amp; ChromeClient::ThreeDTransformTrigger))
2808         return false;
2809 
2810     // Note that we ask the renderer if it has a transform, because the style may have transforms,
2811     // but the renderer may be an inline that doesn&#39;t suppport them.
2812     if (!renderer.hasTransform())
2813         return false;
2814 
2815     switch (m_compositingPolicy) {
2816     case CompositingPolicy::Normal:
2817         return renderer.style().transform().has3DOperation();
2818     case CompositingPolicy::Conservative:
2819         // Continue to allow pages to avoid the very slow software filter path.
2820         if (renderer.style().transform().has3DOperation() &amp;&amp; renderer.hasFilter())
2821             return true;
2822         return renderer.style().transform().isRepresentableIn2D() ? false : true;
2823     }
2824     return false;
2825 }
2826 
2827 bool RenderLayerCompositor::requiresCompositingForBackfaceVisibility(RenderLayerModelObject&amp; renderer) const
2828 {
2829     if (!(m_compositingTriggers &amp; ChromeClient::ThreeDTransformTrigger))
2830         return false;
2831 
2832     if (renderer.style().backfaceVisibility() != BackfaceVisibility::Hidden)
2833         return false;
2834 
2835     if (renderer.layer()-&gt;has3DTransformedAncestor())
2836         return true;
2837 
2838     // FIXME: workaround for webkit.org/b/132801
2839     auto* stackingContext = renderer.layer()-&gt;stackingContext();
2840     if (stackingContext &amp;&amp; stackingContext-&gt;renderer().style().transformStyle3D() == TransformStyle3D::Preserve3D)
2841         return true;
2842 
2843     return false;
2844 }
2845 
2846 bool RenderLayerCompositor::requiresCompositingForVideo(RenderLayerModelObject&amp; renderer) const
2847 {
2848     if (!(m_compositingTriggers &amp; ChromeClient::VideoTrigger))
2849         return false;
2850 
2851 #if ENABLE(VIDEO)
2852     if (!is&lt;RenderVideo&gt;(renderer))
2853         return false;
2854 
2855     auto&amp; video = downcast&lt;RenderVideo&gt;(renderer);
2856     if ((video.requiresImmediateCompositing() || video.shouldDisplayVideo()) &amp;&amp; canAccelerateVideoRendering(video))
2857         return true;
2858 #else
2859     UNUSED_PARAM(renderer);
2860 #endif
2861     return false;
2862 }
2863 
2864 bool RenderLayerCompositor::requiresCompositingForCanvas(RenderLayerModelObject&amp; renderer) const
2865 {
2866     if (!(m_compositingTriggers &amp; ChromeClient::CanvasTrigger))
2867         return false;
2868 
2869     if (!renderer.isCanvas())
2870         return false;
2871 
2872     bool isCanvasLargeEnoughToForceCompositing = true;
2873 #if !USE(COMPOSITING_FOR_SMALL_CANVASES)
2874     auto* canvas = downcast&lt;HTMLCanvasElement&gt;(renderer.element());
2875     auto canvasArea = canvas-&gt;size().area&lt;RecordOverflow&gt;();
2876     isCanvasLargeEnoughToForceCompositing = !canvasArea.hasOverflowed() &amp;&amp; canvasArea.unsafeGet() &gt;= canvasAreaThresholdRequiringCompositing;
2877 #endif
2878 
2879     CanvasCompositingStrategy compositingStrategy = canvasCompositingStrategy(renderer);
2880     if (compositingStrategy == CanvasAsLayerContents)
2881         return true;
2882 
2883     if (m_compositingPolicy == CompositingPolicy::Normal)
2884         return compositingStrategy == CanvasPaintedToLayer &amp;&amp; isCanvasLargeEnoughToForceCompositing;
2885 
2886     return false;
2887 }
2888 
2889 bool RenderLayerCompositor::requiresCompositingForFilters(RenderLayerModelObject&amp; renderer) const
2890 {
2891 #if ENABLE(FILTERS_LEVEL_2)
2892     if (renderer.hasBackdropFilter())
2893         return true;
2894 #endif
2895 
2896     if (!(m_compositingTriggers &amp; ChromeClient::FilterTrigger))
2897         return false;
2898 
2899     return renderer.hasFilter();
2900 }
2901 
2902 bool RenderLayerCompositor::requiresCompositingForWillChange(RenderLayerModelObject&amp; renderer) const
2903 {
2904     if (!renderer.style().willChange() || !renderer.style().willChange()-&gt;canTriggerCompositing())
2905         return false;
2906 
2907 #if ENABLE(FULLSCREEN_API)
2908     // FIXME: does this require layout?
2909     if (renderer.layer() &amp;&amp; isDescendantOfFullScreenLayer(*renderer.layer()) == FullScreenDescendant::No)
2910         return false;
2911 #endif
2912 
2913     if (m_compositingPolicy == CompositingPolicy::Conservative)
2914         return false;
2915 
2916     if (is&lt;RenderBox&gt;(renderer))
2917         return true;
2918 
2919     return renderer.style().willChange()-&gt;canTriggerCompositingOnInline();
2920 }
2921 
2922 bool RenderLayerCompositor::requiresCompositingForPlugin(RenderLayerModelObject&amp; renderer, RequiresCompositingData&amp; queryData) const
2923 {
2924     if (!(m_compositingTriggers &amp; ChromeClient::PluginTrigger))
2925         return false;
2926 
2927     bool isCompositedPlugin = is&lt;RenderEmbeddedObject&gt;(renderer) &amp;&amp; downcast&lt;RenderEmbeddedObject&gt;(renderer).allowsAcceleratedCompositing();
2928     if (!isCompositedPlugin)
2929         return false;
2930 
2931     auto&amp; pluginRenderer = downcast&lt;RenderWidget&gt;(renderer);
2932     if (pluginRenderer.style().visibility() != Visibility::Visible)
2933         return false;
2934 
2935     // If we can&#39;t reliably know the size of the plugin yet, don&#39;t change compositing state.
2936     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2937         queryData.reevaluateAfterLayout = true;
2938         return pluginRenderer.isComposited();
2939     }
2940 
2941     // Don&#39;t go into compositing mode if height or width are zero, or size is 1x1.
2942     IntRect contentBox = snappedIntRect(pluginRenderer.contentBoxRect());
2943     return (contentBox.height() * contentBox.width() &gt; 1);
2944 }
2945 
2946 bool RenderLayerCompositor::requiresCompositingForEditableImage(RenderLayerModelObject&amp; renderer) const
2947 {
2948     if (!renderer.isRenderImage())
2949         return false;
2950 
2951     auto&amp; image = downcast&lt;RenderImage&gt;(renderer);
2952     if (!image.isEditableImage())
2953         return false;
2954 
2955     return true;
2956 }
2957 
2958 bool RenderLayerCompositor::requiresCompositingForFrame(RenderLayerModelObject&amp; renderer, RequiresCompositingData&amp; queryData) const
2959 {
2960     if (!is&lt;RenderWidget&gt;(renderer))
2961         return false;
2962 
2963     auto&amp; frameRenderer = downcast&lt;RenderWidget&gt;(renderer);
2964     if (frameRenderer.style().visibility() != Visibility::Visible)
2965         return false;
2966 
2967     if (!frameRenderer.requiresAcceleratedCompositing())
2968         return false;
2969 
2970     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2971         queryData.reevaluateAfterLayout = true;
2972         return frameRenderer.isComposited();
2973     }
2974 
2975     // Don&#39;t go into compositing mode if height or width are zero.
2976     return !snappedIntRect(frameRenderer.contentBoxRect()).isEmpty();
2977 }
2978 
2979 bool RenderLayerCompositor::requiresCompositingForScrollableFrame(RequiresCompositingData&amp; queryData) const
2980 {
2981     if (isMainFrameCompositor())
2982         return false;
2983 
2984 #if PLATFORM(COCOA) || USE(NICOSIA)
2985     if (!m_renderView.settings().asyncFrameScrollingEnabled())
2986         return false;
2987 #endif
2988 
2989     if (!(m_compositingTriggers &amp; ChromeClient::ScrollableNonMainFrameTrigger))
2990         return false;
2991 
2992     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2993         queryData.reevaluateAfterLayout = true;
2994         return m_renderView.isComposited();
2995     }
2996 
2997     return m_renderView.frameView().isScrollable();
2998 }
2999 
3000 bool RenderLayerCompositor::requiresCompositingForPosition(RenderLayerModelObject&amp; renderer, const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
3001 {
3002     // position:fixed elements that create their own stacking context (e.g. have an explicit z-index,
3003     // opacity, transform) can get their own composited layer. A stacking context is required otherwise
3004     // z-index and clipping will be broken.
3005     if (!renderer.isPositioned())
3006         return false;
3007 
3008 #if ENABLE(FULLSCREEN_API)
3009     if (isDescendantOfFullScreenLayer(layer) == FullScreenDescendant::No)
3010         return false;
3011 #endif
3012 
3013     auto position = renderer.style().position();
3014     bool isFixed = renderer.isFixedPositioned();
3015     if (isFixed &amp;&amp; !layer.isStackingContext())
3016         return false;
3017 
3018     bool isSticky = renderer.isInFlowPositioned() &amp;&amp; position == PositionType::Sticky;
3019     if (!isFixed &amp;&amp; !isSticky)
3020         return false;
3021 
3022     // FIXME: acceleratedCompositingForFixedPositionEnabled should probably be renamed acceleratedCompositingForViewportConstrainedPositionEnabled().
3023     if (!m_renderView.settings().acceleratedCompositingForFixedPositionEnabled())
3024         return false;
3025 
3026     if (isSticky)
3027         return isAsyncScrollableStickyLayer(layer);
3028 
3029     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
3030         queryData.reevaluateAfterLayout = true;
3031         return layer.isComposited();
3032     }
3033 
3034     auto container = renderer.container();
3035     ASSERT(container);
3036 
3037     // Don&#39;t promote fixed position elements that are descendants of a non-view container, e.g. transformed elements.
3038     // They will stay fixed wrt the container rather than the enclosing frame.
3039     if (container != &amp;m_renderView) {
3040         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForNonViewContainer;
3041         return false;
3042     }
3043 
3044     bool paintsContent = layer.isVisuallyNonEmpty() || layer.hasVisibleDescendant();
3045     if (!paintsContent) {
3046         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForNoVisibleContent;
3047         return false;
3048     }
3049 
3050     bool intersectsViewport = fixedLayerIntersectsViewport(layer);
3051     if (!intersectsViewport) {
3052         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForBoundsOutOfView;
3053         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; is outside the viewport&quot;);
3054         return false;
3055     }
3056 
3057     return true;
3058 }
3059 
3060 bool RenderLayerCompositor::requiresCompositingForOverflowScrolling(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
3061 {
3062     if (!layer.canUseCompositedScrolling())
3063         return false;
3064 
3065     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
3066         queryData.reevaluateAfterLayout = true;
3067         return layer.isComposited();
3068     }
3069 
3070     return layer.hasCompositedScrollableOverflow();
3071 }
3072 
3073 IndirectCompositingReason RenderLayerCompositor::computeIndirectCompositingReason(const RenderLayer&amp; layer, bool hasCompositedDescendants, bool has3DTransformedDescendants, bool paintsIntoProvidedBacking) const
3074 {
3075     // When a layer has composited descendants, some effects, like 2d transforms, filters, masks etc must be implemented
3076     // via compositing so that they also apply to those composited descendants.
3077     auto&amp; renderer = layer.renderer();
3078     if (hasCompositedDescendants &amp;&amp; (layer.isolatesCompositedBlending() || layer.transform() || renderer.createsGroup() || renderer.hasReflection()))
3079         return IndirectCompositingReason::GraphicalEffect;
3080 
3081     // A layer with preserve-3d or perspective only needs to be composited if there are descendant layers that
3082     // will be affected by the preserve-3d or perspective.
3083     if (has3DTransformedDescendants) {
3084         if (renderer.style().transformStyle3D() == TransformStyle3D::Preserve3D)
3085             return IndirectCompositingReason::Preserve3D;
3086 
3087         if (renderer.style().hasPerspective())
3088             return IndirectCompositingReason::Perspective;
3089     }
3090 
3091     // If this layer scrolls independently from the layer that it would paint into, it needs to get composited.
3092     if (!paintsIntoProvidedBacking &amp;&amp; layer.hasCompositedScrollingAncestor()) {
3093         auto* paintDestination = layer.paintOrderParent();
3094         if (paintDestination &amp;&amp; layerScrollBehahaviorRelativeToCompositedAncestor(layer, *paintDestination) != ScrollPositioningBehavior::None)
3095             return IndirectCompositingReason::OverflowScrollPositioning;
3096     }
3097 
3098     // Check for clipping last; if compositing just for clipping, the layer doesn&#39;t need its own backing store.
3099     if (hasCompositedDescendants &amp;&amp; clipsCompositingDescendants(layer))
3100         return IndirectCompositingReason::Clipping;
3101 
3102     return IndirectCompositingReason::None;
3103 }
3104 
3105 bool RenderLayerCompositor::styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
3106 {
3107     if (RenderElement::createsGroupForStyle(newStyle) != RenderElement::createsGroupForStyle(oldStyle))
3108         return true;
3109     if (newStyle.isolation() != oldStyle.isolation())
3110         return true;
3111     if (newStyle.hasTransform() != oldStyle.hasTransform())
3112         return true;
3113     if (newStyle.boxReflect() != oldStyle.boxReflect())
3114         return true;
3115     if (newStyle.transformStyle3D() != oldStyle.transformStyle3D())
3116         return true;
3117     if (newStyle.hasPerspective() != oldStyle.hasPerspective())
3118         return true;
3119 
3120     return false;
3121 }
3122 
3123 bool RenderLayerCompositor::isAsyncScrollableStickyLayer(const RenderLayer&amp; layer, const RenderLayer** enclosingAcceleratedOverflowLayer) const
3124 {
3125     ASSERT(layer.renderer().isStickilyPositioned());
3126 
3127     auto* enclosingOverflowLayer = layer.enclosingOverflowClipLayer(ExcludeSelf);
3128 
3129     if (enclosingOverflowLayer &amp;&amp; enclosingOverflowLayer-&gt;hasCompositedScrollableOverflow()) {
3130         if (enclosingAcceleratedOverflowLayer)
3131             *enclosingAcceleratedOverflowLayer = enclosingOverflowLayer;
3132         return true;
3133     }
3134 
3135     // If the layer is inside normal overflow, it&#39;s not async-scrollable.
3136     if (enclosingOverflowLayer)
3137         return false;
3138 
3139     // No overflow ancestor, so see if the frame supports async scrolling.
3140     if (hasCoordinatedScrolling())
3141         return true;
3142 
3143 #if PLATFORM(IOS_FAMILY)
3144     // iOS WK1 has fixed/sticky support in the main frame via WebFixedPositionContent.
3145     return isMainFrameCompositor();
3146 #else
3147     return false;
3148 #endif
3149 }
3150 
3151 bool RenderLayerCompositor::isViewportConstrainedFixedOrStickyLayer(const RenderLayer&amp; layer) const
3152 {
3153     if (layer.renderer().isStickilyPositioned())
3154         return isAsyncScrollableStickyLayer(layer);
3155 
3156     if (!layer.renderer().isFixedPositioned())
3157         return false;
3158 
3159     // FIXME: Handle fixed inside of a transform, which should not behave as fixed.
3160     for (auto* ancestor = layer.parent(); ancestor; ancestor = ancestor-&gt;parent()) {
3161         if (ancestor-&gt;hasCompositedScrollableOverflow())
3162             return true;
3163         if (ancestor-&gt;isStackingContext() &amp;&amp; ancestor-&gt;isComposited() &amp;&amp; ancestor-&gt;renderer().isFixedPositioned())
3164             return false;
3165     }
3166 
3167     return true;
3168 }
3169 
3170 bool RenderLayerCompositor::fixedLayerIntersectsViewport(const RenderLayer&amp; layer) const
3171 {
3172     ASSERT(layer.renderer().isFixedPositioned());
3173 
3174     // Fixed position elements that are invisible in the current view don&#39;t get their own layer.
3175     // FIXME: We shouldn&#39;t have to check useFixedLayout() here; one of the viewport rects needs to give the correct answer.
3176     LayoutRect viewBounds;
3177     if (m_renderView.frameView().useFixedLayout())
3178         viewBounds = m_renderView.unscaledDocumentRect();
3179     else
3180         viewBounds = m_renderView.frameView().rectForFixedPositionLayout();
3181 
3182     LayoutRect layerBounds = layer.calculateLayerBounds(&amp;layer, LayoutSize(), { RenderLayer::UseLocalClipRectIfPossible, RenderLayer::IncludeFilterOutsets, RenderLayer::UseFragmentBoxesExcludingCompositing,
3183         RenderLayer::ExcludeHiddenDescendants, RenderLayer::DontConstrainForMask, RenderLayer::IncludeCompositedDescendants });
3184     // Map to m_renderView to ignore page scale.
3185     FloatRect absoluteBounds = layer.renderer().localToContainerQuad(FloatRect(layerBounds), &amp;m_renderView).boundingBox();
3186     return viewBounds.intersects(enclosingIntRect(absoluteBounds));
3187 }
3188 
3189 bool RenderLayerCompositor::useCoordinatedScrollingForLayer(const RenderLayer&amp; layer) const
3190 {
3191     if (layer.isRenderViewLayer() &amp;&amp; hasCoordinatedScrolling())
3192         return true;
3193 
3194     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3195         return scrollingCoordinator-&gt;coordinatesScrollingForOverflowLayer(layer);
3196 
3197     return false;
3198 }
3199 
3200 static bool isScrolledByOverflowScrollLayer(const RenderLayer&amp; layer, const RenderLayer&amp; overflowScrollLayer)
3201 {
3202     bool scrolledByOverflowScroll = false;
3203     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool inContainingBlockChain, bool) {
3204         if (&amp;ancestorLayer == &amp;overflowScrollLayer) {
3205             scrolledByOverflowScroll = inContainingBlockChain;
3206             return AncestorTraversal::Stop;
3207         }
3208         return AncestorTraversal::Continue;
3209     });
3210     return scrolledByOverflowScroll;
3211 }
3212 
3213 static RenderLayer* enclosingCompositedScrollingLayer(const RenderLayer&amp; layer, const RenderLayer&amp; intermediateLayer, bool&amp; sawIntermediateLayer)
3214 {
3215     const auto* ancestorLayer = layer.parent();
3216     while (ancestorLayer) {
3217         if (ancestorLayer == &amp;intermediateLayer)
3218             sawIntermediateLayer = true;
3219 
3220         if (ancestorLayer-&gt;hasCompositedScrollableOverflow())
3221             return const_cast&lt;RenderLayer*&gt;(ancestorLayer);
3222 
3223         ancestorLayer = ancestorLayer-&gt;parent();
3224     }
3225 
3226     return nullptr;
3227 }
3228 
3229 ScrollPositioningBehavior RenderLayerCompositor::layerScrollBehahaviorRelativeToCompositedAncestor(const RenderLayer&amp; layer, const RenderLayer&amp; compositedAncestor)
3230 {
3231     if (!layer.hasCompositedScrollingAncestor())
3232         return ScrollPositioningBehavior::None;
3233 
3234     bool compositedAncestorIsInsideScroller = false;
3235     auto* scrollingAncestor = enclosingCompositedScrollingLayer(layer, compositedAncestor, compositedAncestorIsInsideScroller);
3236     if (!scrollingAncestor) {
3237         ASSERT_NOT_REACHED(); // layer.hasCompositedScrollingAncestor() should guarantee we have one.
3238         return ScrollPositioningBehavior::None;
3239     }
3240 
3241     bool ancestorMovedByScroller = &amp;compositedAncestor == scrollingAncestor || (compositedAncestorIsInsideScroller &amp;&amp; isScrolledByOverflowScrollLayer(compositedAncestor, *scrollingAncestor));
3242     bool layerMovedByScroller = isScrolledByOverflowScrollLayer(layer, *scrollingAncestor);
3243 
3244     if (ancestorMovedByScroller == layerMovedByScroller)
3245         return ScrollPositioningBehavior::None;
3246 
3247     return layerMovedByScroller ? ScrollPositioningBehavior::Moves : ScrollPositioningBehavior::Stationary;
3248 }
3249 
3250 static void collectStationaryLayerRelatedOverflowNodes(const RenderLayer&amp; layer, const RenderLayer&amp;, Vector&lt;ScrollingNodeID&gt;&amp; scrollingNodes)
3251 {
3252     ASSERT(layer.isComposited());
3253 
3254     auto appendOverflowLayerNodeID = [&amp;scrollingNodes] (const RenderLayer&amp; overflowLayer) {
3255         ASSERT(overflowLayer.isComposited());
3256         auto scrollingNodeID = overflowLayer.backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
3257         if (scrollingNodeID)
3258             scrollingNodes.append(scrollingNodeID);
3259         else
3260             LOG(Scrolling, &quot;Layer %p doesn&#39;t have scrolling node ID yet&quot;, &amp;overflowLayer);
3261     };
3262 
3263     // Collect all the composited scrollers which affect the position of this layer relative to its compositing ancestor (which might be inside the scroller or the scroller itself).
3264     bool seenPaintOrderAncestor = false;
3265     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool isPaintOrderAncestor) {
3266         seenPaintOrderAncestor |= isPaintOrderAncestor;
3267         if (isContainingBlockChain &amp;&amp; isPaintOrderAncestor)
3268             return AncestorTraversal::Stop;
3269 
3270         if (seenPaintOrderAncestor &amp;&amp; !isContainingBlockChain &amp;&amp; ancestorLayer.hasCompositedScrollableOverflow())
3271             appendOverflowLayerNodeID(ancestorLayer);
3272 
3273         return AncestorTraversal::Continue;
3274     });
3275 }
3276 
3277 ScrollPositioningBehavior RenderLayerCompositor::computeCoordinatedPositioningForLayer(const RenderLayer&amp; layer, const RenderLayer* compositedAncestor) const
3278 {
3279     if (layer.isRenderViewLayer())
3280         return ScrollPositioningBehavior::None;
3281 
3282     if (layer.renderer().isFixedPositioned())
3283         return ScrollPositioningBehavior::None;
3284 
3285     if (!layer.hasCompositedScrollingAncestor())
3286         return ScrollPositioningBehavior::None;
3287 
3288     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
3289     if (!scrollingCoordinator)
3290         return ScrollPositioningBehavior::None;
3291 
3292     if (!compositedAncestor) {
3293         ASSERT_NOT_REACHED();
3294         return ScrollPositioningBehavior::None;
3295     }
3296 
3297     return layerScrollBehahaviorRelativeToCompositedAncestor(layer, *compositedAncestor);
3298 }
3299 
3300 static Vector&lt;ScrollingNodeID&gt; collectRelatedCoordinatedScrollingNodes(const RenderLayer&amp; layer, ScrollPositioningBehavior positioningBehavior)
3301 {
3302     Vector&lt;ScrollingNodeID&gt; overflowNodeIDs;
3303 
3304     switch (positioningBehavior) {
3305     case ScrollPositioningBehavior::Stationary: {
3306         auto* compositedAncestor = layer.ancestorCompositingLayer();
3307         if (!compositedAncestor)
3308             return overflowNodeIDs;
3309         collectStationaryLayerRelatedOverflowNodes(layer, *compositedAncestor, overflowNodeIDs);
3310         break;
3311     }
3312     case ScrollPositioningBehavior::Moves:
3313     case ScrollPositioningBehavior::None:
3314         ASSERT_NOT_REACHED();
3315         break;
3316     }
3317 
3318     return overflowNodeIDs;
3319 }
3320 
3321 bool RenderLayerCompositor::isLayerForIFrameWithScrollCoordinatedContents(const RenderLayer&amp; layer) const
3322 {
3323     if (!is&lt;RenderWidget&gt;(layer.renderer()))
3324         return false;
3325 
3326     auto* contentDocument = downcast&lt;RenderWidget&gt;(layer.renderer()).frameOwnerElement().contentDocument();
3327     if (!contentDocument)
3328         return false;
3329 
3330     auto* view = contentDocument-&gt;renderView();
3331     if (!view)
3332         return false;
3333 
3334     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3335         return scrollingCoordinator-&gt;coordinatesScrollingForFrameView(view-&gt;frameView());
3336 
3337     return false;
3338 }
3339 
3340 bool RenderLayerCompositor::isRunningTransformAnimation(RenderLayerModelObject&amp; renderer) const
3341 {
3342     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
3343         return false;
3344 
3345     if (auto* element = renderer.element()) {
3346         if (auto* effectsStack = element-&gt;keyframeEffectStack())
3347             return effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyTransform);
3348     }
3349 
3350     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
3351         return false;
3352 
3353     return renderer.animation().isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
3354 }
3355 
3356 // If an element has composited negative z-index children, those children render in front of the
3357 // layer background, so we need an extra &#39;contents&#39; layer for the foreground of the layer object.
3358 bool RenderLayerCompositor::needsContentsCompositingLayer(const RenderLayer&amp; layer) const
3359 {
3360     for (auto* layer : layer.negativeZOrderLayers()) {
3361         if (layer-&gt;isComposited() || layer-&gt;hasCompositingDescendant())
3362             return true;
3363     }
3364 
3365     return false;
3366 }
3367 
3368 bool RenderLayerCompositor::requiresScrollLayer(RootLayerAttachment attachment) const
3369 {
3370     auto&amp; frameView = m_renderView.frameView();
3371 
3372     // This applies when the application UI handles scrolling, in which case RenderLayerCompositor doesn&#39;t need to manage it.
3373     if (frameView.delegatesScrolling() &amp;&amp; isMainFrameCompositor())
3374         return false;
3375 
3376     // We need to handle our own scrolling if we&#39;re:
3377     return !m_renderView.frameView().platformWidget() // viewless (i.e. non-Mac, or Mac in WebKit2)
3378         || attachment == RootLayerAttachedViaEnclosingFrame; // a composited frame on Mac
3379 }
3380 
3381 void paintScrollbar(Scrollbar* scrollbar, GraphicsContext&amp; context, const IntRect&amp; clip)
3382 {
3383     if (!scrollbar)
3384         return;
3385 
3386     context.save();
3387     const IntRect&amp; scrollbarRect = scrollbar-&gt;frameRect();
3388     context.translate(-scrollbarRect.location());
3389     IntRect transformedClip = clip;
3390     transformedClip.moveBy(scrollbarRect.location());
3391     scrollbar-&gt;paint(context, transformedClip);
3392     context.restore();
3393 }
3394 
3395 void RenderLayerCompositor::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, const FloatRect&amp; clip, GraphicsLayerPaintBehavior)
3396 {
3397 #if PLATFORM(MAC)
3398     LocalDefaultSystemAppearance localAppearance(m_renderView.useDarkAppearance());
3399 #endif
3400 
3401     IntRect pixelSnappedRectForIntegralPositionedItems = snappedIntRect(LayoutRect(clip));
3402     if (graphicsLayer == layerForHorizontalScrollbar())
3403         paintScrollbar(m_renderView.frameView().horizontalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
3404     else if (graphicsLayer == layerForVerticalScrollbar())
3405         paintScrollbar(m_renderView.frameView().verticalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
3406     else if (graphicsLayer == layerForScrollCorner()) {
3407         const IntRect&amp; scrollCorner = m_renderView.frameView().scrollCornerRect();
3408         context.save();
3409         context.translate(-scrollCorner.location());
3410         IntRect transformedClip = pixelSnappedRectForIntegralPositionedItems;
3411         transformedClip.moveBy(scrollCorner.location());
3412         m_renderView.frameView().paintScrollCorner(context, transformedClip);
3413         context.restore();
3414     }
3415 }
3416 
3417 bool RenderLayerCompositor::supportsFixedRootBackgroundCompositing() const
3418 {
3419     auto* renderViewBacking = m_renderView.layer()-&gt;backing();
3420     return renderViewBacking &amp;&amp; renderViewBacking-&gt;isFrameLayerWithTiledBacking();
3421 }
3422 
3423 bool RenderLayerCompositor::needsFixedRootBackgroundLayer(const RenderLayer&amp; layer) const
3424 {
3425     if (!layer.isRenderViewLayer())
3426         return false;
3427 
3428     if (m_renderView.settings().fixedBackgroundsPaintRelativeToDocument())
3429         return false;
3430 
3431     return supportsFixedRootBackgroundCompositing() &amp;&amp; m_renderView.rootBackgroundIsEntirelyFixed();
3432 }
3433 
3434 GraphicsLayer* RenderLayerCompositor::fixedRootBackgroundLayer() const
3435 {
3436     // Get the fixed root background from the RenderView layer&#39;s backing.
3437     auto* viewLayer = m_renderView.layer();
3438     if (!viewLayer)
3439         return nullptr;
3440 
3441     if (viewLayer-&gt;isComposited() &amp;&amp; viewLayer-&gt;backing()-&gt;backgroundLayerPaintsFixedRootBackground())
3442         return viewLayer-&gt;backing()-&gt;backgroundLayer();
3443 
3444     return nullptr;
3445 }
3446 
3447 void RenderLayerCompositor::resetTrackedRepaintRects()
3448 {
3449     if (auto* rootLayer = rootGraphicsLayer()) {
3450         GraphicsLayer::traverse(*rootLayer, [](GraphicsLayer&amp; layer) {
3451             layer.resetTrackedRepaints();
3452         });
3453     }
3454 }
3455 
3456 float RenderLayerCompositor::deviceScaleFactor() const
3457 {
3458 #if PLATFORM(JAVA)
3459     // Java port does device scale factor in the lower level.
3460     return GraphicsLayerClient::deviceScaleFactor();
3461 #else
3462     return m_renderView.document().deviceScaleFactor();
3463 #endif
3464 }
3465 
3466 float RenderLayerCompositor::pageScaleFactor() const
3467 {
3468     return page().pageScaleFactor();
3469 }
3470 
3471 float RenderLayerCompositor::zoomedOutPageScaleFactor() const
3472 {
3473     return page().zoomedOutPageScaleFactor();
3474 }
3475 
3476 float RenderLayerCompositor::contentsScaleMultiplierForNewTiles(const GraphicsLayer*) const
3477 {
3478 #if PLATFORM(IOS_FAMILY)
3479     LegacyTileCache* tileCache = nullptr;
3480     if (auto* frameView = page().mainFrame().view())
3481         tileCache = frameView-&gt;legacyTileCache();
3482 
3483     if (!tileCache)
3484         return 1;
3485 
3486     return tileCache-&gt;tileControllerShouldUseLowScaleTiles() ? 0.125 : 1;
3487 #else
3488     return 1;
3489 #endif
3490 }
3491 
3492 bool RenderLayerCompositor::documentUsesTiledBacking() const
3493 {
3494     auto* layer = m_renderView.layer();
3495     if (!layer)
3496         return false;
3497 
3498     auto* backing = layer-&gt;backing();
3499     if (!backing)
3500         return false;
3501 
3502     return backing-&gt;isFrameLayerWithTiledBacking();
3503 }
3504 
3505 bool RenderLayerCompositor::isMainFrameCompositor() const
3506 {
3507     return m_renderView.frameView().frame().isMainFrame();
3508 }
3509 
3510 bool RenderLayerCompositor::shouldCompositeOverflowControls() const
3511 {
3512     auto&amp; frameView = m_renderView.frameView();
3513 
3514     if (!frameView.managesScrollbars())
3515         return false;
3516 
3517     if (documentUsesTiledBacking())
3518         return true;
3519 
3520     if (m_overflowControlsHostLayer &amp;&amp; isMainFrameCompositor())
3521         return true;
3522 
3523 #if !USE(COORDINATED_GRAPHICS)
3524     if (!frameView.hasOverlayScrollbars())
3525         return false;
3526 #endif
3527 
3528     return true;
3529 }
3530 
3531 bool RenderLayerCompositor::requiresHorizontalScrollbarLayer() const
3532 {
3533     return shouldCompositeOverflowControls() &amp;&amp; m_renderView.frameView().horizontalScrollbar();
3534 }
3535 
3536 bool RenderLayerCompositor::requiresVerticalScrollbarLayer() const
3537 {
3538     return shouldCompositeOverflowControls() &amp;&amp; m_renderView.frameView().verticalScrollbar();
3539 }
3540 
3541 bool RenderLayerCompositor::requiresScrollCornerLayer() const
3542 {
3543     return shouldCompositeOverflowControls() &amp;&amp; m_renderView.frameView().isScrollCornerVisible();
3544 }
3545 
3546 #if ENABLE(RUBBER_BANDING)
3547 bool RenderLayerCompositor::requiresOverhangAreasLayer() const
3548 {
3549     if (!isMainFrameCompositor())
3550         return false;
3551 
3552     // We do want a layer if we&#39;re using tiled drawing and can scroll.
3553     if (documentUsesTiledBacking() &amp;&amp; m_renderView.frameView().hasOpaqueBackground() &amp;&amp; !m_renderView.frameView().prohibitsScrolling())
3554         return true;
3555 
3556     return false;
3557 }
3558 
3559 bool RenderLayerCompositor::requiresContentShadowLayer() const
3560 {
3561     if (!isMainFrameCompositor())
3562         return false;
3563 
3564 #if PLATFORM(COCOA)
3565     if (viewHasTransparentBackground())
3566         return false;
3567 
3568     // If the background is going to extend, then it doesn&#39;t make sense to have a shadow layer.
3569     if (m_renderView.settings().backgroundShouldExtendBeyondPage())
3570         return false;
3571 
3572     // On Mac, we want a content shadow layer if we&#39;re using tiled drawing and can scroll.
3573     if (documentUsesTiledBacking() &amp;&amp; !m_renderView.frameView().prohibitsScrolling())
3574         return true;
3575 #endif
3576 
3577     return false;
3578 }
3579 
3580 GraphicsLayer* RenderLayerCompositor::updateLayerForTopOverhangArea(bool wantsLayer)
3581 {
3582     if (!isMainFrameCompositor())
3583         return nullptr;
3584 
3585     if (!wantsLayer) {
3586         GraphicsLayer::unparentAndClear(m_layerForTopOverhangArea);
3587         return nullptr;
3588     }
3589 
3590     if (!m_layerForTopOverhangArea) {
3591         m_layerForTopOverhangArea = GraphicsLayer::create(graphicsLayerFactory(), *this);
3592         m_layerForTopOverhangArea-&gt;setName(&quot;top overhang&quot;);
3593         m_scrolledContentsLayer-&gt;addChildBelow(*m_layerForTopOverhangArea, m_rootContentsLayer.get());
3594     }
3595 
3596     return m_layerForTopOverhangArea.get();
3597 }
3598 
3599 GraphicsLayer* RenderLayerCompositor::updateLayerForBottomOverhangArea(bool wantsLayer)
3600 {
3601     if (!isMainFrameCompositor())
3602         return nullptr;
3603 
3604     if (!wantsLayer) {
3605         GraphicsLayer::unparentAndClear(m_layerForBottomOverhangArea);
3606         return nullptr;
3607     }
3608 
3609     if (!m_layerForBottomOverhangArea) {
3610         m_layerForBottomOverhangArea = GraphicsLayer::create(graphicsLayerFactory(), *this);
3611         m_layerForBottomOverhangArea-&gt;setName(&quot;bottom overhang&quot;);
3612         m_scrolledContentsLayer-&gt;addChildBelow(*m_layerForBottomOverhangArea, m_rootContentsLayer.get());
3613     }
3614 
3615     m_layerForBottomOverhangArea-&gt;setPosition(FloatPoint(0, m_rootContentsLayer-&gt;size().height() + m_renderView.frameView().headerHeight()
3616         + m_renderView.frameView().footerHeight() + m_renderView.frameView().topContentInset()));
3617     return m_layerForBottomOverhangArea.get();
3618 }
3619 
3620 GraphicsLayer* RenderLayerCompositor::updateLayerForHeader(bool wantsLayer)
3621 {
3622     if (!isMainFrameCompositor())
3623         return nullptr;
3624 
3625     if (!wantsLayer) {
3626         if (m_layerForHeader) {
3627             GraphicsLayer::unparentAndClear(m_layerForHeader);
3628 
3629             // The ScrollingTree knows about the header layer, and the position of the root layer is affected
3630             // by the header layer, so if we remove the header, we need to tell the scrolling tree.
3631             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3632                 scrollingCoordinator-&gt;frameViewRootLayerDidChange(m_renderView.frameView());
3633         }
3634         return nullptr;
3635     }
3636 
3637     if (!m_layerForHeader) {
3638         m_layerForHeader = GraphicsLayer::create(graphicsLayerFactory(), *this);
3639         m_layerForHeader-&gt;setName(&quot;header&quot;);
3640         m_scrolledContentsLayer-&gt;addChildAbove(*m_layerForHeader, m_rootContentsLayer.get());
3641         m_renderView.frameView().addPaintPendingMilestones(DidFirstFlushForHeaderLayer);
3642     }
3643 
3644     m_layerForHeader-&gt;setPosition(FloatPoint(0,
3645         FrameView::yPositionForHeaderLayer(m_renderView.frameView().scrollPosition(), m_renderView.frameView().topContentInset())));
3646     m_layerForHeader-&gt;setAnchorPoint(FloatPoint3D());
3647     m_layerForHeader-&gt;setSize(FloatSize(m_renderView.frameView().visibleWidth(), m_renderView.frameView().headerHeight()));
3648 
3649     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3650         scrollingCoordinator-&gt;frameViewRootLayerDidChange(m_renderView.frameView());
3651 
3652     page().chrome().client().didAddHeaderLayer(*m_layerForHeader);
3653 
3654     return m_layerForHeader.get();
3655 }
3656 
3657 GraphicsLayer* RenderLayerCompositor::updateLayerForFooter(bool wantsLayer)
3658 {
3659     if (!isMainFrameCompositor())
3660         return nullptr;
3661 
3662     if (!wantsLayer) {
3663         if (m_layerForFooter) {
3664             GraphicsLayer::unparentAndClear(m_layerForFooter);
3665 
3666             // The ScrollingTree knows about the footer layer, and the total scrollable size is affected
3667             // by the footer layer, so if we remove the footer, we need to tell the scrolling tree.
3668             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3669                 scrollingCoordinator-&gt;frameViewRootLayerDidChange(m_renderView.frameView());
3670         }
3671         return nullptr;
3672     }
3673 
3674     if (!m_layerForFooter) {
3675         m_layerForFooter = GraphicsLayer::create(graphicsLayerFactory(), *this);
3676         m_layerForFooter-&gt;setName(&quot;footer&quot;);
3677         m_scrolledContentsLayer-&gt;addChildAbove(*m_layerForFooter, m_rootContentsLayer.get());
3678     }
3679 
3680     float totalContentHeight = m_rootContentsLayer-&gt;size().height() + m_renderView.frameView().headerHeight() + m_renderView.frameView().footerHeight();
3681     m_layerForFooter-&gt;setPosition(FloatPoint(0, FrameView::yPositionForFooterLayer(m_renderView.frameView().scrollPosition(),
3682         m_renderView.frameView().topContentInset(), totalContentHeight, m_renderView.frameView().footerHeight())));
3683     m_layerForFooter-&gt;setAnchorPoint(FloatPoint3D());
3684     m_layerForFooter-&gt;setSize(FloatSize(m_renderView.frameView().visibleWidth(), m_renderView.frameView().footerHeight()));
3685 
3686     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3687         scrollingCoordinator-&gt;frameViewRootLayerDidChange(m_renderView.frameView());
3688 
3689     page().chrome().client().didAddFooterLayer(*m_layerForFooter);
3690 
3691     return m_layerForFooter.get();
3692 }
3693 
3694 #endif
3695 
3696 bool RenderLayerCompositor::viewHasTransparentBackground(Color* backgroundColor) const
3697 {
3698     if (m_renderView.frameView().isTransparent()) {
3699         if (backgroundColor)
3700             *backgroundColor = Color(); // Return an invalid color.
3701         return true;
3702     }
3703 
3704     Color documentBackgroundColor = m_renderView.frameView().documentBackgroundColor();
3705     if (!documentBackgroundColor.isValid())
3706         documentBackgroundColor = m_renderView.frameView().baseBackgroundColor();
3707 
3708     ASSERT(documentBackgroundColor.isValid());
3709 
3710     if (backgroundColor)
3711         *backgroundColor = documentBackgroundColor;
3712 
3713     return !documentBackgroundColor.isOpaque();
3714 }
3715 
3716 // We can&#39;t rely on getting layerStyleChanged() for a style change that affects the root background, because the style change may
3717 // be on the body which has no RenderLayer.
3718 void RenderLayerCompositor::rootOrBodyStyleChanged(RenderElement&amp; renderer, const RenderStyle* oldStyle)
3719 {
3720     if (!usesCompositing())
3721         return;
3722 
3723     Color oldBackgroundColor;
3724     if (oldStyle)
3725         oldBackgroundColor = oldStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
3726 
3727     if (oldBackgroundColor != renderer.style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor))
3728         rootBackgroundColorOrTransparencyChanged();
3729 
3730     bool hadFixedBackground = oldStyle &amp;&amp; oldStyle-&gt;hasEntirelyFixedBackground();
3731     if (hadFixedBackground != renderer.style().hasEntirelyFixedBackground())
3732         rootLayerConfigurationChanged();
3733 }
3734 
3735 void RenderLayerCompositor::rootBackgroundColorOrTransparencyChanged()
3736 {
3737     if (!usesCompositing())
3738         return;
3739 
3740     Color backgroundColor;
3741     bool isTransparent = viewHasTransparentBackground(&amp;backgroundColor);
3742 
3743     Color extendedBackgroundColor = m_renderView.settings().backgroundShouldExtendBeyondPage() ? backgroundColor : Color();
3744 
3745     bool transparencyChanged = m_viewBackgroundIsTransparent != isTransparent;
3746     bool backgroundColorChanged = m_viewBackgroundColor != backgroundColor;
3747     bool extendedBackgroundColorChanged = m_rootExtendedBackgroundColor != extendedBackgroundColor;
3748 
3749     if (!transparencyChanged &amp;&amp; !backgroundColorChanged &amp;&amp; !extendedBackgroundColorChanged)
3750         return;
3751 
3752     LOG(Compositing, &quot;RenderLayerCompositor %p rootBackgroundColorOrTransparencyChanged. isTransparent=%d&quot;, this, isTransparent);
3753 
3754     m_viewBackgroundIsTransparent = isTransparent;
3755     m_viewBackgroundColor = backgroundColor;
3756     m_rootExtendedBackgroundColor = extendedBackgroundColor;
3757 
3758     if (extendedBackgroundColorChanged) {
3759         page().chrome().client().pageExtendedBackgroundColorDidChange(m_rootExtendedBackgroundColor);
3760 
3761 #if ENABLE(RUBBER_BANDING)
3762         if (m_layerForOverhangAreas) {
3763             m_layerForOverhangAreas-&gt;setBackgroundColor(m_rootExtendedBackgroundColor);
3764 
3765             if (!m_rootExtendedBackgroundColor.isValid())
3766                 m_layerForOverhangAreas-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::ScrollingOverhang);
3767         }
3768 #endif
3769     }
3770 
3771     rootLayerConfigurationChanged();
3772 }
3773 
3774 void RenderLayerCompositor::updateOverflowControlsLayers()
3775 {
3776 #if ENABLE(RUBBER_BANDING)
3777     if (requiresOverhangAreasLayer()) {
3778         if (!m_layerForOverhangAreas) {
3779             m_layerForOverhangAreas = GraphicsLayer::create(graphicsLayerFactory(), *this);
3780             m_layerForOverhangAreas-&gt;setName(&quot;overhang areas&quot;);
3781             m_layerForOverhangAreas-&gt;setDrawsContent(false);
3782 
3783             float topContentInset = m_renderView.frameView().topContentInset();
3784             IntSize overhangAreaSize = m_renderView.frameView().frameRect().size();
3785             overhangAreaSize.setHeight(overhangAreaSize.height() - topContentInset);
3786             m_layerForOverhangAreas-&gt;setSize(overhangAreaSize);
3787             m_layerForOverhangAreas-&gt;setPosition(FloatPoint(0, topContentInset));
3788             m_layerForOverhangAreas-&gt;setAnchorPoint(FloatPoint3D());
3789 
3790             if (m_renderView.settings().backgroundShouldExtendBeyondPage())
3791                 m_layerForOverhangAreas-&gt;setBackgroundColor(m_renderView.frameView().documentBackgroundColor());
3792             else
3793                 m_layerForOverhangAreas-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::ScrollingOverhang);
3794 
3795             // We want the overhang areas layer to be positioned below the frame contents,
3796             // so insert it below the clip layer.
3797             m_overflowControlsHostLayer-&gt;addChildBelow(*m_layerForOverhangAreas, layerForClipping());
3798         }
3799     } else
3800         GraphicsLayer::unparentAndClear(m_layerForOverhangAreas);
3801 
3802     if (requiresContentShadowLayer()) {
3803         if (!m_contentShadowLayer) {
3804             m_contentShadowLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3805             m_contentShadowLayer-&gt;setName(&quot;content shadow&quot;);
3806             m_contentShadowLayer-&gt;setSize(m_rootContentsLayer-&gt;size());
3807             m_contentShadowLayer-&gt;setPosition(m_rootContentsLayer-&gt;position());
3808             m_contentShadowLayer-&gt;setAnchorPoint(FloatPoint3D());
3809             m_contentShadowLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::ScrollingShadow);
3810 
3811             m_scrolledContentsLayer-&gt;addChildBelow(*m_contentShadowLayer, m_rootContentsLayer.get());
3812         }
3813     } else
3814         GraphicsLayer::unparentAndClear(m_contentShadowLayer);
3815 #endif
3816 
3817     if (requiresHorizontalScrollbarLayer()) {
3818         if (!m_layerForHorizontalScrollbar) {
3819             m_layerForHorizontalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
3820             m_layerForHorizontalScrollbar-&gt;setAllowsBackingStoreDetaching(false);
3821             m_layerForHorizontalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
3822             m_layerForHorizontalScrollbar-&gt;setName(&quot;horizontal scrollbar container&quot;);
3823 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3824             m_layerForHorizontalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3825 #endif
3826             m_overflowControlsHostLayer-&gt;addChild(*m_layerForHorizontalScrollbar);
3827 
3828             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3829                 scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), HorizontalScrollbar);
3830         }
3831     } else if (m_layerForHorizontalScrollbar) {
3832         GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
3833 
3834         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3835             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), HorizontalScrollbar);
3836     }
3837 
3838     if (requiresVerticalScrollbarLayer()) {
3839         if (!m_layerForVerticalScrollbar) {
3840             m_layerForVerticalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
3841             m_layerForVerticalScrollbar-&gt;setAllowsBackingStoreDetaching(false);
3842             m_layerForVerticalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
3843             m_layerForVerticalScrollbar-&gt;setName(&quot;vertical scrollbar container&quot;);
3844 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3845             m_layerForVerticalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3846 #endif
3847             m_overflowControlsHostLayer-&gt;addChild(*m_layerForVerticalScrollbar);
3848 
3849             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3850                 scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), VerticalScrollbar);
3851         }
3852     } else if (m_layerForVerticalScrollbar) {
3853         GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
3854 
3855         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3856             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), VerticalScrollbar);
3857     }
3858 
3859     if (requiresScrollCornerLayer()) {
3860         if (!m_layerForScrollCorner) {
3861             m_layerForScrollCorner = GraphicsLayer::create(graphicsLayerFactory(), *this);
3862             m_layerForScrollCorner-&gt;setAllowsBackingStoreDetaching(false);
3863             m_layerForScrollCorner-&gt;setShowDebugBorder(m_showDebugBorders);
3864             m_layerForScrollCorner-&gt;setName(&quot;scroll corner&quot;);
3865 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3866             m_layerForScrollCorner-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3867 #endif
3868             m_overflowControlsHostLayer-&gt;addChild(*m_layerForScrollCorner);
3869         }
3870     } else
3871         GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
3872 
3873     m_renderView.frameView().positionScrollbarLayers();
3874 }
3875 
3876 void RenderLayerCompositor::ensureRootLayer()
3877 {
3878     RootLayerAttachment expectedAttachment = isMainFrameCompositor() ? RootLayerAttachedViaChromeClient : RootLayerAttachedViaEnclosingFrame;
3879     if (expectedAttachment == m_rootLayerAttachment)
3880          return;
3881 
3882     if (!m_rootContentsLayer) {
3883         m_rootContentsLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3884         m_rootContentsLayer-&gt;setName(&quot;content root&quot;);
3885         IntRect overflowRect = snappedIntRect(m_renderView.layoutOverflowRect());
3886         m_rootContentsLayer-&gt;setSize(FloatSize(overflowRect.maxX(), overflowRect.maxY()));
3887         m_rootContentsLayer-&gt;setPosition(FloatPoint());
3888 
3889 #if PLATFORM(IOS_FAMILY)
3890         // Page scale is applied above this on iOS, so we&#39;ll just say that our root layer applies it.
3891         auto&amp; frame = m_renderView.frameView().frame();
3892         if (frame.isMainFrame())
3893             m_rootContentsLayer-&gt;setAppliesPageScale();
3894 #endif
3895 
3896         // Need to clip to prevent transformed content showing outside this frame
3897         updateRootContentLayerClipping();
3898     }
3899 
3900     if (requiresScrollLayer(expectedAttachment)) {
3901         if (!m_overflowControlsHostLayer) {
3902             ASSERT(!m_scrolledContentsLayer);
3903             ASSERT(!m_clipLayer);
3904 
3905             // Create a layer to host the clipping layer and the overflow controls layers.
3906             m_overflowControlsHostLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3907             m_overflowControlsHostLayer-&gt;setName(&quot;overflow controls host&quot;);
3908 
3909             m_scrolledContentsLayer = GraphicsLayer::create(graphicsLayerFactory(), *this, GraphicsLayer::Type::ScrolledContents);
3910             m_scrolledContentsLayer-&gt;setName(&quot;scrolled contents&quot;);
3911             m_scrolledContentsLayer-&gt;setAnchorPoint({ });
3912 
3913 #if PLATFORM(IOS_FAMILY)
3914             if (m_renderView.settings().asyncFrameScrollingEnabled()) {
3915                 m_scrollContainerLayer = GraphicsLayer::create(graphicsLayerFactory(), *this, GraphicsLayer::Type::ScrollContainer);
3916 
3917                 m_scrollContainerLayer-&gt;setName(&quot;scroll container&quot;);
3918                 m_scrollContainerLayer-&gt;setMasksToBounds(true);
3919                 m_scrollContainerLayer-&gt;setAnchorPoint({ });
3920 
3921                 m_scrollContainerLayer-&gt;addChild(*m_scrolledContentsLayer);
3922                 m_overflowControlsHostLayer-&gt;addChild(*m_scrollContainerLayer);
3923             }
3924 #endif
3925             // FIXME: m_scrollContainerLayer and m_clipLayer have similar roles here, but m_clipLayer has some special positioning to
3926             // account for clipping and top content inset (see FrameView::yPositionForInsetClipLayer()).
3927             if (!m_scrollContainerLayer) {
3928                 m_clipLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3929                 m_clipLayer-&gt;setName(&quot;frame clipping&quot;);
3930                 m_clipLayer-&gt;setMasksToBounds(true);
3931                 m_clipLayer-&gt;setAnchorPoint({ });
3932 
3933                 m_clipLayer-&gt;addChild(*m_scrolledContentsLayer);
3934                 m_overflowControlsHostLayer-&gt;addChild(*m_clipLayer);
3935             }
3936 
3937             m_scrolledContentsLayer-&gt;addChild(*m_rootContentsLayer);
3938 
3939             updateScrollLayerClipping();
3940             updateOverflowControlsLayers();
3941 
3942             if (hasCoordinatedScrolling())
3943                 scheduleLayerFlush(true);
3944             else
3945                 updateScrollLayerPosition();
3946         }
3947     } else {
3948         if (m_overflowControlsHostLayer) {
3949             GraphicsLayer::unparentAndClear(m_overflowControlsHostLayer);
3950             GraphicsLayer::unparentAndClear(m_clipLayer);
3951             GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
3952             GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
3953         }
3954     }
3955 
3956     // Check to see if we have to change the attachment
3957     if (m_rootLayerAttachment != RootLayerUnattached)
3958         detachRootLayer();
3959 
3960     attachRootLayer(expectedAttachment);
3961 }
3962 
3963 void RenderLayerCompositor::destroyRootLayer()
3964 {
3965     if (!m_rootContentsLayer)
3966         return;
3967 
3968     detachRootLayer();
3969 
3970 #if ENABLE(RUBBER_BANDING)
3971     GraphicsLayer::unparentAndClear(m_layerForOverhangAreas);
3972 #endif
3973 
3974     if (m_layerForHorizontalScrollbar) {
3975         GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
3976         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3977             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), HorizontalScrollbar);
3978         if (auto* horizontalScrollbar = m_renderView.frameView().verticalScrollbar())
3979             m_renderView.frameView().invalidateScrollbar(*horizontalScrollbar, IntRect(IntPoint(0, 0), horizontalScrollbar-&gt;frameRect().size()));
3980     }
3981 
3982     if (m_layerForVerticalScrollbar) {
3983         GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
3984         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3985             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), VerticalScrollbar);
3986         if (auto* verticalScrollbar = m_renderView.frameView().verticalScrollbar())
3987             m_renderView.frameView().invalidateScrollbar(*verticalScrollbar, IntRect(IntPoint(0, 0), verticalScrollbar-&gt;frameRect().size()));
3988     }
3989 
3990     if (m_layerForScrollCorner) {
3991         GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
3992         m_renderView.frameView().invalidateScrollCorner(m_renderView.frameView().scrollCornerRect());
3993     }
3994 
3995     if (m_overflowControlsHostLayer) {
3996         GraphicsLayer::unparentAndClear(m_overflowControlsHostLayer);
3997         GraphicsLayer::unparentAndClear(m_clipLayer);
3998         GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
3999         GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
4000     }
4001     ASSERT(!m_scrolledContentsLayer);
4002     GraphicsLayer::unparentAndClear(m_rootContentsLayer);
4003 
4004     m_layerUpdater = nullptr;
4005 }
4006 
4007 void RenderLayerCompositor::attachRootLayer(RootLayerAttachment attachment)
4008 {
4009     if (!m_rootContentsLayer)
4010         return;
4011 
4012     LOG(Compositing, &quot;RenderLayerCompositor %p attachRootLayer %d&quot;, this, attachment);
4013 
4014     switch (attachment) {
4015         case RootLayerUnattached:
4016             ASSERT_NOT_REACHED();
4017             break;
4018         case RootLayerAttachedViaChromeClient: {
4019             auto&amp; frame = m_renderView.frameView().frame();
4020             page().chrome().client().attachRootGraphicsLayer(frame, rootGraphicsLayer());
4021             break;
4022         }
4023         case RootLayerAttachedViaEnclosingFrame: {
4024             // The layer will get hooked up via RenderLayerBacking::updateConfiguration()
4025             // for the frame&#39;s renderer in the parent document.
4026             if (auto* ownerElement = m_renderView.document().ownerElement())
4027                 ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
4028             break;
4029         }
4030     }
4031 
4032     m_rootLayerAttachment = attachment;
4033     rootLayerAttachmentChanged();
4034 
4035     if (m_shouldFlushOnReattach) {
4036         scheduleLayerFlush();
4037         m_shouldFlushOnReattach = false;
4038     }
4039 }
4040 
4041 void RenderLayerCompositor::detachRootLayer()
4042 {
4043     if (!m_rootContentsLayer || m_rootLayerAttachment == RootLayerUnattached)
4044         return;
4045 
4046     switch (m_rootLayerAttachment) {
4047     case RootLayerAttachedViaEnclosingFrame: {
4048         // The layer will get unhooked up via RenderLayerBacking::updateConfiguration()
4049         // for the frame&#39;s renderer in the parent document.
4050         if (m_overflowControlsHostLayer)
4051             m_overflowControlsHostLayer-&gt;removeFromParent();
4052         else
4053             m_rootContentsLayer-&gt;removeFromParent();
4054 
4055         if (auto* ownerElement = m_renderView.document().ownerElement())
4056             ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
4057 
4058         if (auto frameRootScrollingNodeID = m_renderView.frameView().scrollingNodeID()) {
4059             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
4060                 scrollingCoordinator-&gt;unparentNode(frameRootScrollingNodeID);
4061         }
4062         break;
4063     }
4064     case RootLayerAttachedViaChromeClient: {
4065         auto&amp; frame = m_renderView.frameView().frame();
4066         page().chrome().client().attachRootGraphicsLayer(frame, nullptr);
4067     }
4068     break;
4069     case RootLayerUnattached:
4070         break;
4071     }
4072 
4073     m_rootLayerAttachment = RootLayerUnattached;
4074     rootLayerAttachmentChanged();
4075 }
4076 
4077 void RenderLayerCompositor::updateRootLayerAttachment()
4078 {
4079     ensureRootLayer();
4080 }
4081 
4082 void RenderLayerCompositor::rootLayerAttachmentChanged()
4083 {
4084     // The document-relative page overlay layer (which is pinned to the main frame&#39;s layer tree)
4085     // is moved between different RenderLayerCompositors&#39; layer trees, and needs to be
4086     // reattached whenever we swap in a new RenderLayerCompositor.
4087     if (m_rootLayerAttachment == RootLayerUnattached)
4088         return;
4089 
4090     auto&amp; frame = m_renderView.frameView().frame();
4091 
4092     // The attachment can affect whether the RenderView layer&#39;s paintsIntoWindow() behavior,
4093     // so call updateDrawsContent() to update that.
4094     auto* layer = m_renderView.layer();
4095     if (auto* backing = layer ? layer-&gt;backing() : nullptr)
4096         backing-&gt;updateDrawsContent();
4097 
4098     if (!frame.isMainFrame())
4099         return;
4100 
4101     Ref&lt;GraphicsLayer&gt; overlayHost = page().pageOverlayController().layerWithDocumentOverlays();
4102     m_rootContentsLayer-&gt;addChild(WTFMove(overlayHost));
4103 }
4104 
4105 void RenderLayerCompositor::notifyIFramesOfCompositingChange()
4106 {
4107     // Compositing affects the answer to RenderIFrame::requiresAcceleratedCompositing(), so
4108     // we need to schedule a style recalc in our parent document.
4109     if (auto* ownerElement = m_renderView.document().ownerElement())
4110         ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
4111 }
4112 
4113 bool RenderLayerCompositor::layerHas3DContent(const RenderLayer&amp; layer) const
4114 {
4115     const RenderStyle&amp; style = layer.renderer().style();
4116 
4117     if (style.transformStyle3D() == TransformStyle3D::Preserve3D || style.hasPerspective() || style.transform().has3DOperation())
4118         return true;
4119 
4120     const_cast&lt;RenderLayer&amp;&gt;(layer).updateLayerListsIfNeeded();
4121 
4122 #if ASSERT_ENABLED
4123     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
4124 #endif
4125 
4126     for (auto* renderLayer : layer.negativeZOrderLayers()) {
4127         if (layerHas3DContent(*renderLayer))
4128             return true;
4129     }
4130 
4131     for (auto* renderLayer : layer.positiveZOrderLayers()) {
4132         if (layerHas3DContent(*renderLayer))
4133             return true;
4134     }
4135 
4136     for (auto* renderLayer : layer.normalFlowLayers()) {
4137         if (layerHas3DContent(*renderLayer))
4138             return true;
4139     }
4140 
4141     return false;
4142 }
4143 
4144 void RenderLayerCompositor::deviceOrPageScaleFactorChanged()
4145 {
4146     // Page scale will only be applied at to the RenderView and sublayers, but the device scale factor
4147     // needs to be applied at the level of rootGraphicsLayer().
4148     if (auto* rootLayer = rootGraphicsLayer())
4149         rootLayer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
4150 }
4151 
4152 void RenderLayerCompositor::removeFromScrollCoordinatedLayers(RenderLayer&amp; layer)
4153 {
4154 #if PLATFORM(IOS_FAMILY)
4155     if (m_legacyScrollingLayerCoordinator)
4156         m_legacyScrollingLayerCoordinator-&gt;removeLayer(layer);
4157 #endif
4158 
4159     detachScrollCoordinatedLayer(layer, allScrollCoordinationRoles());
4160 }
4161 
4162 FixedPositionViewportConstraints RenderLayerCompositor::computeFixedViewportConstraints(RenderLayer&amp; layer) const
4163 {
4164     ASSERT(layer.isComposited());
4165 
4166     auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
4167 
4168     FixedPositionViewportConstraints constraints;
4169     constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
4170     constraints.setViewportRectAtLastLayout(m_renderView.frameView().rectForFixedPositionLayout());
4171     constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
4172 
4173     const RenderStyle&amp; style = layer.renderer().style();
4174     if (!style.left().isAuto())
4175         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeLeft);
4176 
4177     if (!style.right().isAuto())
4178         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeRight);
4179 
4180     if (!style.top().isAuto())
4181         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
4182 
4183     if (!style.bottom().isAuto())
4184         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeBottom);
4185 
4186     // If left and right are auto, use left.
4187     if (style.left().isAuto() &amp;&amp; style.right().isAuto())
4188         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeLeft);
4189 
4190     // If top and bottom are auto, use top.
4191     if (style.top().isAuto() &amp;&amp; style.bottom().isAuto())
4192         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
4193 
4194     return constraints;
4195 }
4196 
4197 StickyPositionViewportConstraints RenderLayerCompositor::computeStickyViewportConstraints(RenderLayer&amp; layer) const
4198 {
4199     ASSERT(layer.isComposited());
4200 
4201     auto&amp; renderer = downcast&lt;RenderBoxModelObject&gt;(layer.renderer());
4202 
4203     StickyPositionViewportConstraints constraints;
4204     renderer.computeStickyPositionConstraints(constraints, renderer.constrainingRectForStickyPosition());
4205 
4206     auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
4207     constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
4208     constraints.setStickyOffsetAtLastLayout(renderer.stickyPositionOffset());
4209     constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
4210 
4211     return constraints;
4212 }
4213 
4214 static inline ScrollCoordinationRole scrollCoordinationRoleForNodeType(ScrollingNodeType nodeType)
4215 {
4216     switch (nodeType) {
4217     case ScrollingNodeType::MainFrame:
4218     case ScrollingNodeType::Subframe:
4219     case ScrollingNodeType::Overflow:
4220         return ScrollCoordinationRole::Scrolling;
4221     case ScrollingNodeType::OverflowProxy:
4222         return ScrollCoordinationRole::ScrollingProxy;
4223     case ScrollingNodeType::FrameHosting:
4224         return ScrollCoordinationRole::FrameHosting;
4225     case ScrollingNodeType::Fixed:
4226     case ScrollingNodeType::Sticky:
4227         return ScrollCoordinationRole::ViewportConstrained;
4228     case ScrollingNodeType::Positioned:
4229         return ScrollCoordinationRole::Positioning;
4230     }
4231     ASSERT_NOT_REACHED();
4232     return ScrollCoordinationRole::Scrolling;
4233 }
4234 
4235 ScrollingNodeID RenderLayerCompositor::attachScrollingNode(RenderLayer&amp; layer, ScrollingNodeType nodeType, ScrollingTreeState&amp; treeState)
4236 {
4237     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4238     auto* backing = layer.backing();
4239     // Crash logs suggest that backing can be null here, but we don&#39;t know how: rdar://problem/18545452.
4240     ASSERT(backing);
4241     if (!backing)
4242         return 0;
4243 
4244     ASSERT(treeState.parentNodeID || nodeType == ScrollingNodeType::Subframe);
4245     ASSERT_IMPLIES(nodeType == ScrollingNodeType::MainFrame, !treeState.parentNodeID.value());
4246 
4247     ScrollCoordinationRole role = scrollCoordinationRoleForNodeType(nodeType);
4248     ScrollingNodeID nodeID = backing-&gt;scrollingNodeIDForRole(role);
4249 
4250     nodeID = registerScrollingNodeID(*scrollingCoordinator, nodeID, nodeType, treeState);
4251 
4252     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; attachScrollingNode &quot; &lt;&lt; nodeID &lt;&lt; &quot; (layer &quot; &lt;&lt; backing-&gt;graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;) type &quot; &lt;&lt; nodeType &lt;&lt; &quot; parent &quot; &lt;&lt; treeState.parentNodeID.valueOr(0));
4253 
4254     if (!nodeID)
4255         return 0;
4256 
4257     backing-&gt;setScrollingNodeIDForRole(nodeID, role);
4258     m_scrollingNodeToLayerMap.add(nodeID, &amp;layer);
4259 
4260     return nodeID;
4261 }
4262 
4263 ScrollingNodeID RenderLayerCompositor::registerScrollingNodeID(ScrollingCoordinator&amp; scrollingCoordinator, ScrollingNodeID nodeID, ScrollingNodeType nodeType, struct ScrollingTreeState&amp; treeState)
4264 {
4265     if (!nodeID)
4266         nodeID = scrollingCoordinator.uniqueScrollingNodeID();
4267 
4268     if (nodeType == ScrollingNodeType::Subframe &amp;&amp; !treeState.parentNodeID)
4269         nodeID = scrollingCoordinator.createNode(nodeType, nodeID);
4270     else {
4271         auto newNodeID = scrollingCoordinator.insertNode(nodeType, nodeID, treeState.parentNodeID.valueOr(0), treeState.nextChildIndex);
4272         if (newNodeID != nodeID) {
4273             // We&#39;ll get a new nodeID if the type changed (and not if the node is new).
4274             scrollingCoordinator.unparentChildrenAndDestroyNode(nodeID);
4275             m_scrollingNodeToLayerMap.remove(nodeID);
4276         }
4277         nodeID = newNodeID;
4278     }
4279 
4280     ASSERT(nodeID);
4281     if (!nodeID)
4282         return 0;
4283 
4284     ++treeState.nextChildIndex;
4285     return nodeID;
4286 }
4287 
4288 void RenderLayerCompositor::detachScrollCoordinatedLayerWithRole(RenderLayer&amp; layer, ScrollingCoordinator&amp; scrollingCoordinator, ScrollCoordinationRole role)
4289 {
4290     auto unregisterNode = [&amp;](ScrollingNodeID nodeID) {
4291         auto childNodes = scrollingCoordinator.childrenOfNode(nodeID);
4292         for (auto childNodeID : childNodes) {
4293             if (auto* layer = m_scrollingNodeToLayerMap.get(childNodeID))
4294                 layer-&gt;setNeedsScrollingTreeUpdate();
4295         }
4296 
4297         m_scrollingNodeToLayerMap.remove(nodeID);
4298     };
4299 
4300     if (role == ScrollCoordinationRole::ScrollingProxy) {
4301         ASSERT(layer.isComposited());
4302         auto* clippingStack = layer.backing()-&gt;ancestorClippingStack();
4303         if (!clippingStack)
4304             return;
4305 
4306         auto&amp; stack = clippingStack-&gt;stack();
4307         for (auto&amp; entry : stack) {
4308             if (entry.overflowScrollProxyNodeID)
4309                 unregisterNode(entry.overflowScrollProxyNodeID);
4310         }
4311         return;
4312     }
4313 
4314     auto nodeID = layer.backing()-&gt;scrollingNodeIDForRole(role);
4315     if (!nodeID)
4316         return;
4317 
4318     unregisterNode(nodeID);
4319 }
4320 
4321 void RenderLayerCompositor::detachScrollCoordinatedLayer(RenderLayer&amp; layer, OptionSet&lt;ScrollCoordinationRole&gt; roles)
4322 {
4323     auto* backing = layer.backing();
4324     if (!backing)
4325         return;
4326 
4327     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4328 
4329     if (roles.contains(ScrollCoordinationRole::Scrolling))
4330         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Scrolling);
4331 
4332     if (roles.contains(ScrollCoordinationRole::ScrollingProxy))
4333         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ScrollingProxy);
4334 
4335     if (roles.contains(ScrollCoordinationRole::FrameHosting))
4336         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::FrameHosting);
4337 
4338     if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
4339         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ViewportConstrained);
4340 
4341     if (roles.contains(ScrollCoordinationRole::Positioning))
4342         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Positioning);
4343 
4344     backing-&gt;detachFromScrollingCoordinator(roles);
4345 }
4346 
4347 OptionSet&lt;ScrollCoordinationRole&gt; RenderLayerCompositor::coordinatedScrollingRolesForLayer(const RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const
4348 {
4349     OptionSet&lt;ScrollCoordinationRole&gt; coordinationRoles;
4350     if (isViewportConstrainedFixedOrStickyLayer(layer))
4351         coordinationRoles.add(ScrollCoordinationRole::ViewportConstrained);
4352 
4353     if (useCoordinatedScrollingForLayer(layer))
4354         coordinationRoles.add(ScrollCoordinationRole::Scrolling);
4355 
4356     auto coordinatedPositioning = computeCoordinatedPositioningForLayer(layer, compositingAncestor);
4357     switch (coordinatedPositioning) {
4358     case ScrollPositioningBehavior::Moves:
4359         coordinationRoles.add(ScrollCoordinationRole::ScrollingProxy);
4360         break;
4361     case ScrollPositioningBehavior::Stationary:
4362         coordinationRoles.add(ScrollCoordinationRole::Positioning);
4363         break;
4364     case ScrollPositioningBehavior::None:
4365         break;
4366     }
4367 
4368     if (isLayerForIFrameWithScrollCoordinatedContents(layer))
4369         coordinationRoles.add(ScrollCoordinationRole::FrameHosting);
4370 
4371     return coordinationRoles;
4372 }
4373 
4374 ScrollingNodeID RenderLayerCompositor::updateScrollCoordinationForLayer(RenderLayer&amp; layer, const RenderLayer* compositingAncestor, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4375 {
4376     auto roles = coordinatedScrollingRolesForLayer(layer, compositingAncestor);
4377 
4378 #if PLATFORM(IOS_FAMILY)
4379     if (m_legacyScrollingLayerCoordinator) {
4380         if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
4381             m_legacyScrollingLayerCoordinator-&gt;addViewportConstrainedLayer(layer);
4382         else
4383             m_legacyScrollingLayerCoordinator-&gt;removeViewportConstrainedLayer(layer);
4384     }
4385 #endif
4386 
4387     if (!hasCoordinatedScrolling()) {
4388         // If this frame isn&#39;t coordinated, it cannot contain any scrolling tree nodes.
4389         return 0;
4390     }
4391 
4392     auto newNodeID = treeState.parentNodeID.valueOr(0);
4393 
4394     ScrollingTreeState childTreeState;
4395     ScrollingTreeState* currentTreeState = &amp;treeState;
4396 
4397     // If there&#39;s a positioning node, it&#39;s the parent scrolling node for fixed/sticky/scrolling/frame hosting.
4398     if (roles.contains(ScrollCoordinationRole::Positioning)) {
4399         newNodeID = updateScrollingNodeForPositioningRole(layer, compositingAncestor, *currentTreeState, changes);
4400         childTreeState.parentNodeID = newNodeID;
4401         currentTreeState = &amp;childTreeState;
4402     } else
4403         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::Positioning);
4404 
4405     // If there&#39;s a scrolling proxy node, it&#39;s the parent scrolling node for fixed/sticky/scrolling/frame hosting.
4406     if (roles.contains(ScrollCoordinationRole::ScrollingProxy)) {
4407         newNodeID = updateScrollingNodeForScrollingProxyRole(layer, *currentTreeState, changes);
4408         childTreeState.parentNodeID = newNodeID;
4409         currentTreeState = &amp;childTreeState;
4410     } else
4411         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::ScrollingProxy);
4412 
4413     // If is fixed or sticky, it&#39;s the parent scrolling node for scrolling/frame hosting.
4414     if (roles.contains(ScrollCoordinationRole::ViewportConstrained)) {
4415         newNodeID = updateScrollingNodeForViewportConstrainedRole(layer, *currentTreeState, changes);
4416         // ViewportConstrained nodes are the parent of same-layer scrolling nodes, so adjust the ScrollingTreeState.
4417         childTreeState.parentNodeID = newNodeID;
4418         currentTreeState = &amp;childTreeState;
4419     } else
4420         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::ViewportConstrained);
4421 
4422     if (roles.contains(ScrollCoordinationRole::Scrolling))
4423         newNodeID = updateScrollingNodeForScrollingRole(layer, *currentTreeState, changes);
4424     else
4425         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::Scrolling);
4426 
4427     if (roles.contains(ScrollCoordinationRole::FrameHosting))
4428         newNodeID = updateScrollingNodeForFrameHostingRole(layer, *currentTreeState, changes);
4429     else
4430         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::FrameHosting);
4431 
4432     return newNodeID;
4433 }
4434 
4435 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForViewportConstrainedRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4436 {
4437     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4438 
4439     auto nodeType = ScrollingNodeType::Fixed;
4440     if (layer.renderer().style().position() == PositionType::Sticky)
4441         nodeType = ScrollingNodeType::Sticky;
4442     else
4443         ASSERT(layer.renderer().isFixedPositioned());
4444 
4445     auto newNodeID = attachScrollingNode(layer, nodeType, treeState);
4446     if (!newNodeID) {
4447         ASSERT_NOT_REACHED();
4448         return treeState.parentNodeID.valueOr(0);
4449     }
4450 
4451     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Registering ViewportConstrained &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID &lt;&lt; &quot; (layer &quot; &lt;&lt; layer.backing()-&gt;graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;) as child of &quot; &lt;&lt; treeState.parentNodeID.valueOr(0));
4452 
4453     if (changes &amp; ScrollingNodeChangeFlags::Layer)
4454         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
4455 
4456     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
4457         switch (nodeType) {
4458         case ScrollingNodeType::Fixed:
4459             scrollingCoordinator-&gt;setViewportConstraintedNodeConstraints(newNodeID, computeFixedViewportConstraints(layer));
4460             break;
4461         case ScrollingNodeType::Sticky:
4462             scrollingCoordinator-&gt;setViewportConstraintedNodeConstraints(newNodeID, computeStickyViewportConstraints(layer));
4463             break;
4464         default:
4465             break;
4466         }
4467     }
4468 
4469     return newNodeID;
4470 }
4471 
4472 LayoutRect RenderLayerCompositor::rootParentRelativeScrollableRect() const
4473 {
4474     auto&amp; frameView = m_renderView.frameView();
4475 
4476     if (m_renderView.frame().isMainFrame())
4477         return frameView.frameRect();
4478 
4479     return LayoutRect({ }, LayoutSize(frameView.size()));
4480 }
4481 
4482 LayoutRect RenderLayerCompositor::parentRelativeScrollableRect(const RenderLayer&amp; layer, const RenderLayer* ancestorLayer) const
4483 {
4484     // FIXME: ancestorLayer needs to be always non-null, so should become a reference.
4485     if (!ancestorLayer)
4486         return LayoutRect({ }, LayoutSize(layer.visibleSize()));
4487 
4488     LayoutRect scrollableRect;
4489     if (is&lt;RenderBox&gt;(layer.renderer()))
4490         scrollableRect = downcast&lt;RenderBox&gt;(layer.renderer()).paddingBoxRect();
4491 
4492     auto offset = layer.convertToLayerCoords(ancestorLayer, scrollableRect.location()); // FIXME: broken for columns.
4493     scrollableRect.setLocation(offset);
4494     return scrollableRect;
4495 }
4496 
4497 void RenderLayerCompositor::updateScrollingNodeLayers(ScrollingNodeID nodeID, RenderLayer&amp; layer, ScrollingCoordinator&amp; scrollingCoordinator)
4498 {
4499     if (layer.isRenderViewLayer()) {
4500         FrameView&amp; frameView = m_renderView.frameView();
4501         scrollingCoordinator.setNodeLayers(nodeID, { nullptr,
4502             scrollContainerLayer(), scrolledContentsLayer(),
4503             fixedRootBackgroundLayer(), clipLayer(), rootContentsLayer(),
4504             frameView.layerForHorizontalScrollbar(), frameView.layerForVerticalScrollbar() });
4505     } else {
4506         auto&amp; backing = *layer.backing();
4507         scrollingCoordinator.setNodeLayers(nodeID, { backing.graphicsLayer(),
4508             backing.scrollContainerLayer(), backing.scrolledContentsLayer(),
4509             nullptr, nullptr, nullptr,
4510             layer.layerForHorizontalScrollbar(), layer.layerForVerticalScrollbar() });
4511     }
4512 }
4513 
4514 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForScrollingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4515 {
4516     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4517 
4518     ScrollingNodeID newNodeID = 0;
4519 
4520     if (layer.isRenderViewLayer()) {
4521         FrameView&amp; frameView = m_renderView.frameView();
4522         ASSERT_UNUSED(frameView, scrollingCoordinator-&gt;coordinatesScrollingForFrameView(frameView));
4523 
4524         newNodeID = attachScrollingNode(*m_renderView.layer(), m_renderView.frame().isMainFrame() ? ScrollingNodeType::MainFrame : ScrollingNodeType::Subframe, treeState);
4525 
4526         if (!newNodeID) {
4527             ASSERT_NOT_REACHED();
4528             return treeState.parentNodeID.valueOr(0);
4529         }
4530 
4531         if (changes &amp; ScrollingNodeChangeFlags::Layer)
4532             updateScrollingNodeLayers(newNodeID, layer, *scrollingCoordinator);
4533 
4534         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
4535             scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, rootParentRelativeScrollableRect());
4536             scrollingCoordinator-&gt;setScrollingNodeScrollableAreaGeometry(newNodeID, frameView);
4537             scrollingCoordinator-&gt;setFrameScrollingNodeState(newNodeID, frameView);
4538         }
4539     } else {
4540         newNodeID = attachScrollingNode(layer, ScrollingNodeType::Overflow, treeState);
4541         if (!newNodeID) {
4542             ASSERT_NOT_REACHED();
4543             return treeState.parentNodeID.valueOr(0);
4544         }
4545 
4546         if (changes &amp; ScrollingNodeChangeFlags::Layer)
4547             updateScrollingNodeLayers(newNodeID, layer, *scrollingCoordinator);
4548 
4549         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4550             RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
4551             scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, parentRelativeScrollableRect(layer, scrollingAncestorLayer));
4552             scrollingCoordinator-&gt;setScrollingNodeScrollableAreaGeometry(newNodeID, layer);
4553         }
4554     }
4555 
4556     return newNodeID;
4557 }
4558 
4559 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForScrollingProxyRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4560 {
4561     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4562     auto* clippingStack = layer.backing()-&gt;ancestorClippingStack();
4563     if (!clippingStack) {
4564         ASSERT_NOT_REACHED();
4565         return treeState.parentNodeID.valueOr(0);
4566     }
4567 
4568     ScrollingNodeID nodeID = 0;
4569     for (auto&amp; entry : clippingStack-&gt;stack()) {
4570         if (!entry.clipData.isOverflowScroll)
4571             continue;
4572 
4573         nodeID = registerScrollingNodeID(*scrollingCoordinator, entry.overflowScrollProxyNodeID, ScrollingNodeType::OverflowProxy, treeState);
4574         if (!nodeID) {
4575             ASSERT_NOT_REACHED();
4576             return treeState.parentNodeID.valueOr(0);
4577         }
4578         entry.overflowScrollProxyNodeID = nodeID;
4579 
4580         if (changes &amp; ScrollingNodeChangeFlags::Layer)
4581             scrollingCoordinator-&gt;setNodeLayers(entry.overflowScrollProxyNodeID, { entry.clippingLayer.get() });
4582 
4583         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
4584             ASSERT(entry.clipData.clippingLayer);
4585             ASSERT(entry.clipData.clippingLayer-&gt;isComposited());
4586 
4587             ScrollingNodeID overflowScrollNodeID = 0;
4588             if (auto* backing = entry.clipData.clippingLayer-&gt;backing())
4589                 overflowScrollNodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
4590 
4591             Vector&lt;ScrollingNodeID&gt; scrollingNodeIDs;
4592             if (overflowScrollNodeID)
4593                 scrollingNodeIDs.append(overflowScrollNodeID);
4594             scrollingCoordinator-&gt;setRelatedOverflowScrollingNodes(entry.overflowScrollProxyNodeID, WTFMove(scrollingNodeIDs));
4595         }
4596     }
4597 
4598     if (!nodeID)
4599         return treeState.parentNodeID.valueOr(0);
4600 
4601     return nodeID;
4602 }
4603 
4604 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForFrameHostingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4605 {
4606     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4607 
4608     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::FrameHosting, treeState);
4609     if (!newNodeID) {
4610         ASSERT_NOT_REACHED();
4611         return treeState.parentNodeID.valueOr(0);
4612     }
4613 
4614     if (changes &amp; ScrollingNodeChangeFlags::Layer)
4615         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
4616 
4617     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4618         RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
4619         scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, parentRelativeScrollableRect(layer, scrollingAncestorLayer));
4620     }
4621 
4622     return newNodeID;
4623 }
4624 
4625 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForPositioningRole(RenderLayer&amp; layer, const RenderLayer* compositingAncestor, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4626 {
4627     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4628 
4629     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::Positioned, treeState);
4630     if (!newNodeID) {
4631         ASSERT_NOT_REACHED();
4632         return treeState.parentNodeID.valueOr(0);
4633     }
4634 
4635     if (changes &amp; ScrollingNodeChangeFlags::Layer) {
4636         auto&amp; backing = *layer.backing();
4637         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { backing.graphicsLayer() });
4638     }
4639 
4640     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4641         // Would be nice to avoid calling computeCoordinatedPositioningForLayer() again.
4642         auto positioningBehavior = computeCoordinatedPositioningForLayer(layer, compositingAncestor);
4643         auto relatedNodeIDs = collectRelatedCoordinatedScrollingNodes(layer, positioningBehavior);
4644         scrollingCoordinator-&gt;setRelatedOverflowScrollingNodes(newNodeID, WTFMove(relatedNodeIDs));
4645 
4646         auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
4647         AbsolutePositionConstraints constraints;
4648         constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
4649         constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
4650         scrollingCoordinator-&gt;setPositionedNodeConstraints(newNodeID, constraints);
4651     }
4652 
4653     return newNodeID;
4654 }
4655 
4656 ScrollableArea* RenderLayerCompositor::scrollableAreaForScrollLayerID(ScrollingNodeID nodeID) const
4657 {
4658     if (!nodeID)
4659         return nullptr;
4660 
4661     return m_scrollingNodeToLayerMap.get(nodeID);
4662 }
4663 
4664 void RenderLayerCompositor::willRemoveScrollingLayerWithBacking(RenderLayer&amp; layer, RenderLayerBacking&amp; backing)
4665 {
4666     if (scrollingCoordinator())
4667         return;
4668 
4669 #if PLATFORM(IOS_FAMILY)
4670     ASSERT(m_renderView.document().backForwardCacheState() == Document::NotInBackForwardCache);
4671     if (m_legacyScrollingLayerCoordinator)
4672         m_legacyScrollingLayerCoordinator-&gt;removeScrollingLayer(layer, backing);
4673 #else
4674     UNUSED_PARAM(layer);
4675     UNUSED_PARAM(backing);
4676 #endif
4677 }
4678 
4679 // FIXME: This should really be called from the updateBackingAndHierarchy.
4680 void RenderLayerCompositor::didAddScrollingLayer(RenderLayer&amp; layer)
4681 {
4682     if (scrollingCoordinator())
4683         return;
4684 
4685 #if PLATFORM(IOS_FAMILY)
4686     ASSERT(m_renderView.document().backForwardCacheState() == Document::NotInBackForwardCache);
4687     if (m_legacyScrollingLayerCoordinator)
4688         m_legacyScrollingLayerCoordinator-&gt;addScrollingLayer(layer);
4689 #else
4690     UNUSED_PARAM(layer);
4691 #endif
4692 }
4693 
4694 void RenderLayerCompositor::windowScreenDidChange(PlatformDisplayID displayID)
4695 {
4696     if (m_layerUpdater)
4697         m_layerUpdater-&gt;screenDidChange(displayID);
4698 }
4699 
4700 ScrollingCoordinator* RenderLayerCompositor::scrollingCoordinator() const
4701 {
4702     return page().scrollingCoordinator();
4703 }
4704 
4705 GraphicsLayerFactory* RenderLayerCompositor::graphicsLayerFactory() const
4706 {
4707     return page().chrome().client().graphicsLayerFactory();
4708 }
4709 
4710 void RenderLayerCompositor::setLayerFlushThrottlingEnabled(bool enabled)
4711 {
4712     m_layerFlushThrottlingEnabled = enabled;
4713     if (m_layerFlushThrottlingEnabled)
4714         return;
4715     m_layerFlushTimer.stop();
4716     if (!m_hasPendingLayerFlush)
4717         return;
4718     scheduleLayerFlush();
4719 }
4720 
4721 void RenderLayerCompositor::disableLayerFlushThrottlingTemporarilyForInteraction()
4722 {
4723     if (m_layerFlushThrottlingTemporarilyDisabledForInteraction)
4724         return;
4725     m_layerFlushThrottlingTemporarilyDisabledForInteraction = true;
4726 }
4727 
4728 bool RenderLayerCompositor::isThrottlingLayerFlushes() const
4729 {
4730     if (!m_layerFlushThrottlingEnabled)
4731         return false;
4732     if (!m_layerFlushTimer.isActive())
4733         return false;
4734     if (m_layerFlushThrottlingTemporarilyDisabledForInteraction)
4735         return false;
4736     return true;
4737 }
4738 
4739 void RenderLayerCompositor::startLayerFlushTimerIfNeeded()
4740 {
4741     m_layerFlushThrottlingTemporarilyDisabledForInteraction = false;
4742     m_layerFlushTimer.stop();
4743     if (!m_layerFlushThrottlingEnabled)
4744         return;
4745     m_layerFlushTimer.startOneShot(throttledLayerFlushDelay);
4746 }
4747 
4748 void RenderLayerCompositor::startInitialLayerFlushTimerIfNeeded()
4749 {
4750     if (!m_layerFlushThrottlingEnabled)
4751         return;
4752     if (m_layerFlushTimer.isActive())
4753         return;
4754     m_layerFlushTimer.startOneShot(throttledLayerFlushInitialDelay);
4755 }
4756 
4757 void RenderLayerCompositor::layerFlushTimerFired()
4758 {
4759     if (!m_hasPendingLayerFlush)
4760         return;
4761     scheduleLayerFlush();
4762 }
4763 
4764 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
4765 RefPtr&lt;DisplayRefreshMonitor&gt; RenderLayerCompositor::createDisplayRefreshMonitor(PlatformDisplayID displayID) const
4766 {
4767     if (auto monitor = page().chrome().client().createDisplayRefreshMonitor(displayID))
4768         return monitor;
4769 
4770     return DisplayRefreshMonitor::createDefaultDisplayRefreshMonitor(displayID);
4771 }
4772 #endif
4773 
4774 #if ENABLE(CSS_SCROLL_SNAP)
4775 void RenderLayerCompositor::updateScrollSnapPropertiesWithFrameView(const FrameView&amp; frameView) const
4776 {
4777     if (auto* coordinator = scrollingCoordinator())
4778         coordinator-&gt;updateScrollSnapPropertiesWithFrameView(frameView);
4779 }
4780 #endif
4781 
4782 Page&amp; RenderLayerCompositor::page() const
4783 {
4784     return m_renderView.page();
4785 }
4786 
4787 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, CompositingUpdateType updateType)
4788 {
4789     switch (updateType) {
4790     case CompositingUpdateType::AfterStyleChange: ts &lt;&lt; &quot;after style change&quot;; break;
4791     case CompositingUpdateType::AfterLayout: ts &lt;&lt; &quot;after layout&quot;; break;
4792     case CompositingUpdateType::OnScroll: ts &lt;&lt; &quot;on scroll&quot;; break;
4793     case CompositingUpdateType::OnCompositedScroll: ts &lt;&lt; &quot;on composited scroll&quot;; break;
4794     }
4795     return ts;
4796 }
4797 
4798 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, CompositingPolicy compositingPolicy)
4799 {
4800     switch (compositingPolicy) {
4801     case CompositingPolicy::Normal: ts &lt;&lt; &quot;normal&quot;; break;
4802     case CompositingPolicy::Conservative: ts &lt;&lt; &quot;conservative&quot;; break;
4803     }
4804     return ts;
4805 }
4806 
4807 #if PLATFORM(IOS_FAMILY)
4808 typedef HashMap&lt;PlatformLayer*, std::unique_ptr&lt;ViewportConstraints&gt;&gt; LayerMap;
4809 typedef HashMap&lt;PlatformLayer*, PlatformLayer*&gt; StickyContainerMap;
4810 
4811 void LegacyWebKitScrollingLayerCoordinator::registerAllViewportConstrainedLayers(RenderLayerCompositor&amp; compositor)
4812 {
4813     if (!m_coordinateViewportConstrainedLayers)
4814         return;
4815 
4816     LayerMap layerMap;
4817     StickyContainerMap stickyContainerMap;
4818 
4819     for (auto* layer : m_viewportConstrainedLayers) {
4820         ASSERT(layer-&gt;isComposited());
4821 
4822         std::unique_ptr&lt;ViewportConstraints&gt; constraints;
4823         if (layer-&gt;renderer().isStickilyPositioned()) {
4824             constraints = makeUnique&lt;StickyPositionViewportConstraints&gt;(compositor.computeStickyViewportConstraints(*layer));
4825             const RenderLayer* enclosingTouchScrollableLayer = nullptr;
4826             if (compositor.isAsyncScrollableStickyLayer(*layer, &amp;enclosingTouchScrollableLayer) &amp;&amp; enclosingTouchScrollableLayer) {
4827                 ASSERT(enclosingTouchScrollableLayer-&gt;isComposited());
4828                 // what
4829                 stickyContainerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), enclosingTouchScrollableLayer-&gt;backing()-&gt;scrollContainerLayer()-&gt;platformLayer());
4830             }
4831         } else if (layer-&gt;renderer().isFixedPositioned())
4832             constraints = makeUnique&lt;FixedPositionViewportConstraints&gt;(compositor.computeFixedViewportConstraints(*layer));
4833         else
4834             continue;
4835 
4836         layerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), WTFMove(constraints));
4837     }
4838 
4839     m_chromeClient.updateViewportConstrainedLayers(layerMap, stickyContainerMap);
4840 }
4841 
4842 void LegacyWebKitScrollingLayerCoordinator::unregisterAllViewportConstrainedLayers()
4843 {
4844     if (!m_coordinateViewportConstrainedLayers)
4845         return;
4846 
4847     LayerMap layerMap;
4848     m_chromeClient.updateViewportConstrainedLayers(layerMap, { });
4849 }
4850 
4851 void LegacyWebKitScrollingLayerCoordinator::updateScrollingLayer(RenderLayer&amp; layer)
4852 {
4853     auto* backing = layer.backing();
4854     ASSERT(backing);
4855 
4856     bool allowHorizontalScrollbar = !layer.horizontalScrollbarHiddenByStyle();
4857     bool allowVerticalScrollbar = !layer.verticalScrollbarHiddenByStyle();
4858 
4859     m_chromeClient.addOrUpdateScrollingLayer(layer.renderer().element(), backing-&gt;scrollContainerLayer()-&gt;platformLayer(), backing-&gt;scrolledContentsLayer()-&gt;platformLayer(),
4860         layer.reachableTotalContentsSize(), allowHorizontalScrollbar, allowVerticalScrollbar);
4861 }
4862 
4863 void LegacyWebKitScrollingLayerCoordinator::registerAllScrollingLayers()
4864 {
4865     for (auto* layer : m_scrollingLayers)
4866         updateScrollingLayer(*layer);
4867 }
4868 
4869 void LegacyWebKitScrollingLayerCoordinator::unregisterAllScrollingLayers()
4870 {
4871     for (auto* layer : m_scrollingLayers) {
4872         auto* backing = layer-&gt;backing();
4873         ASSERT(backing);
4874         m_chromeClient.removeScrollingLayer(layer-&gt;renderer().element(), backing-&gt;scrollContainerLayer()-&gt;platformLayer(), backing-&gt;scrolledContentsLayer()-&gt;platformLayer());
4875     }
4876 }
4877 
4878 void LegacyWebKitScrollingLayerCoordinator::addScrollingLayer(RenderLayer&amp; layer)
4879 {
4880     m_scrollingLayers.add(&amp;layer);
4881 }
4882 
4883 void LegacyWebKitScrollingLayerCoordinator::removeScrollingLayer(RenderLayer&amp; layer, RenderLayerBacking&amp; backing)
4884 {
4885     if (m_scrollingLayers.remove(&amp;layer)) {
4886         auto* scrollContainerLayer = backing.scrollContainerLayer()-&gt;platformLayer();
4887         auto* scrolledContentsLayer = backing.scrolledContentsLayer()-&gt;platformLayer();
4888         m_chromeClient.removeScrollingLayer(layer.renderer().element(), scrollContainerLayer, scrolledContentsLayer);
4889     }
4890 }
4891 
4892 void LegacyWebKitScrollingLayerCoordinator::removeLayer(RenderLayer&amp; layer)
4893 {
4894     removeScrollingLayer(layer, *layer.backing());
4895 
4896     // We&#39;ll put the new set of layers to the client via registerAllViewportConstrainedLayers() at flush time.
4897     m_viewportConstrainedLayers.remove(&amp;layer);
4898 }
4899 
4900 void LegacyWebKitScrollingLayerCoordinator::addViewportConstrainedLayer(RenderLayer&amp; layer)
4901 {
4902     m_viewportConstrainedLayers.add(&amp;layer);
4903 }
4904 
4905 void LegacyWebKitScrollingLayerCoordinator::removeViewportConstrainedLayer(RenderLayer&amp; layer)
4906 {
4907     m_viewportConstrainedLayers.remove(&amp;layer);
4908 }
4909 
4910 #endif
4911 
4912 } // namespace WebCore
4913 
4914 #if ENABLE(TREE_DEBUGGING)
4915 void showGraphicsLayerTreeForCompositor(WebCore::RenderLayerCompositor&amp; compositor)
4916 {
4917     showGraphicsLayerTree(compositor.rootGraphicsLayer());
4918 }
4919 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineLineBoxBuilder.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 29 
 30 #include &quot;DisplayBox.h&quot;
 31 #include &quot;DisplayInlineRect.h&quot;
 32 
 33 namespace WebCore {
 34 namespace Layout {
 35 
 36 class LineBoxBuilder {
 37     WTF_MAKE_FAST_ALLOCATED;
 38 public:
 39     struct Baseline {
 40         Baseline(InlineLayoutUnit ascent, InlineLayoutUnit descent);
 41         Baseline() = default;
 42 
 43         void setAscent(InlineLayoutUnit);
 44         void setDescent(InlineLayoutUnit);
 45 
 46         void reset();
 47 
 48         InlineLayoutUnit height() const { return ascent() + descent(); }
 49         InlineLayoutUnit ascent() const;
 50         InlineLayoutUnit descent() const;
 51 
 52     private:
 53 #if ASSERT_ENABLED
 54         bool m_hasValidAscent { false };
 55         bool m_hasValidDescent { false };
 56 #endif
 57         InlineLayoutUnit m_ascent { 0 };
 58         InlineLayoutUnit m_descent { 0 };
 59     };
 60 
 61     LineBoxBuilder(const Display::InlineRect&amp;, const Baseline&amp;, InlineLayoutUnit baselineOffset);
 62     LineBoxBuilder() = default;
 63 
 64     const Display::InlineRect&amp; logicalRect() const { return m_rect; }
 65     const Display::InlineRect&amp; scrollableOverflow() const { return m_scrollableOverflow; }
 66 
 67     InlineLayoutUnit logicalLeft() const { return m_rect.left(); }
 68     InlineLayoutUnit logicalRight() const { return m_rect.right(); }
 69     InlineLayoutUnit logicalTop() const { return m_rect.top(); }
 70     InlineLayoutUnit logicalBottom() const { return m_rect.bottom(); }
 71 
 72     InlineLayoutUnit logicalWidth() const { return m_rect.width(); }
 73     InlineLayoutUnit logicalHeight() const { return m_rect.height(); }
 74 
 75     const Baseline&amp; baseline() const;
 76     // Baseline offset from line logical top. Note that offset does not necessarily equal to ascent.
 77     //
 78     // -------------------    line logical top     ------------------- (top align)
 79     //             ^                                              ^
 80     //             |                                  ^           |
 81     //   ^         | baseline offset                  |           | baseline offset
 82     //   |         |                                  |           |
 83     //   | ascent  |                                  | ascent    |
 84     //   |         |                                  v           v
 85     //   v         v                               ------------------- baseline
 86     //   ----------------- baseline                   ^
 87     //   ^                                            | descent
 88     //   | descent                                    v
 89     //   v
 90     // -------------------    line logical bottom  -------------------
 91     InlineLayoutUnit baselineOffset() const;
 92     void setBaselineOffsetIfGreater(InlineLayoutUnit);
 93     void setAscentIfGreater(InlineLayoutUnit);
 94     void setDescentIfGreater(InlineLayoutUnit);
 95 
 96     void resetBaseline();
 97     void resetDescent() { m_baseline.setDescent(0_lu); }
 98 
 99     void setLogicalHeight(InlineLayoutUnit logicalHeight) { m_rect.setHeight(logicalHeight); }
100 
101     void setLogicalHeightIfGreater(InlineLayoutUnit);
102     void setLogicalWidth(InlineLayoutUnit logicalWidth) { m_rect.setWidth(logicalWidth); }
103 
104     void setScrollableOverflow(const Display::InlineRect&amp; rect) { m_scrollableOverflow = rect; }
105 
106     void moveHorizontally(InlineLayoutUnit delta) { m_rect.moveHorizontally(delta); }
107 
108     void expandHorizontally(InlineLayoutUnit delta) { m_rect.expandHorizontally(delta); }
109     void shrinkHorizontally(InlineLayoutUnit delta) { expandHorizontally(-delta); }
110 
111     void expandVertically(InlineLayoutUnit delta) { m_rect.expandVertically(delta); }
112     void shrinkVertically(InlineLayoutUnit delta) { expandVertically(-delta); }
113 
114     // https://www.w3.org/TR/CSS22/visuren.html#inline-formatting
115     // Line boxes that contain no text, no preserved white space, no inline elements with non-zero margins, padding, or borders,
116     // and no other in-flow content (such as images, inline blocks or inline tables), and do not end with a preserved newline
117     // must be treated as zero-height line boxes for the purposes of determining the positions of any elements inside of them,
118     // and must be treated as not existing for any other purpose.
119     // Note that it does not necessarily mean visually non-empty line. &lt;span style=&quot;font-size: 0px&quot;&gt;this is still considered non-empty&lt;/span&gt;
120     bool isConsideredEmpty() const { return m_isConsideredEmpty; }
121     void setIsConsideredEmpty() { m_isConsideredEmpty = true; }
122     void setIsConsideredNonEmpty() { m_isConsideredEmpty = false; }
123 
124 private:
125 #if ASSERT_ENABLED
126     bool m_hasValidBaseline { false };
127     bool m_hasValidBaselineOffset { false };
128 #endif
129     Display::InlineRect m_rect;
130     Display::InlineRect m_scrollableOverflow;
131     Baseline m_baseline;
132     InlineLayoutUnit m_baselineOffset { 0 };
133     bool m_isConsideredEmpty { true };
134 };
135 
136 inline LineBoxBuilder::LineBoxBuilder(const Display::InlineRect&amp; rect, const Baseline&amp; baseline, InlineLayoutUnit baselineOffset)
137     : m_rect(rect)
138     , m_baseline(baseline)
139     , m_baselineOffset(baselineOffset)
140 {
141 #if ASSERT_ENABLED
142     m_hasValidBaseline = true;
143     m_hasValidBaselineOffset = true;
144 #endif
145 }
146 
147 inline void LineBoxBuilder::setLogicalHeightIfGreater(InlineLayoutUnit logicalHeight)
148 {
149     if (logicalHeight &lt;= m_rect.height())
150         return;
151     m_rect.setHeight(logicalHeight);
152 }
153 
154 inline const LineBoxBuilder::Baseline&amp; LineBoxBuilder::baseline() const
155 {
156     ASSERT(m_hasValidBaseline);
157     return m_baseline;
158 }
159 
160 inline void LineBoxBuilder::setBaselineOffsetIfGreater(InlineLayoutUnit baselineOffset)
161 {
162 #if ASSERT_ENABLED
163     m_hasValidBaselineOffset = true;
164 #endif
165     m_baselineOffset = std::max(baselineOffset, m_baselineOffset);
166 }
167 
168 inline void LineBoxBuilder::setAscentIfGreater(InlineLayoutUnit ascent)
169 {
170     if (ascent &lt; m_baseline.ascent())
171         return;
172     setBaselineOffsetIfGreater(ascent);
173     m_baseline.setAscent(ascent);
174 }
175 
176 inline void LineBoxBuilder::setDescentIfGreater(InlineLayoutUnit descent)
177 {
178     if (descent &lt; m_baseline.descent())
179         return;
180     m_baseline.setDescent(descent);
181 }
182 
183 inline InlineLayoutUnit LineBoxBuilder::baselineOffset() const
184 {
185     ASSERT(m_hasValidBaselineOffset);
186     return m_baselineOffset;
187 }
188 
189 inline void LineBoxBuilder::resetBaseline()
190 {
191 #if ASSERT_ENABLED
192     m_hasValidBaselineOffset = true;
193 #endif
194     m_baselineOffset = 0_lu;
195     m_baseline.reset();
196 }
197 
198 inline LineBoxBuilder::Baseline::Baseline(InlineLayoutUnit ascent, InlineLayoutUnit descent)
199     : m_ascent(ascent)
200     , m_descent(descent)
201 {
202 #if ASSERT_ENABLED
203     m_hasValidAscent = true;
204     m_hasValidDescent = true;
205 #endif
206 }
207 
208 inline void LineBoxBuilder::Baseline::setAscent(InlineLayoutUnit ascent)
209 {
210 #if ASSERT_ENABLED
211     m_hasValidAscent = true;
212 #endif
213     m_ascent = ascent;
214 }
215 
216 inline void LineBoxBuilder::Baseline::setDescent(InlineLayoutUnit descent)
217 {
218 #if ASSERT_ENABLED
219     m_hasValidDescent = true;
220 #endif
221     m_descent = descent;
222 }
223 
224 inline void LineBoxBuilder::Baseline::reset()
225 {
226 #if ASSERT_ENABLED
227     m_hasValidAscent = true;
228     m_hasValidDescent = true;
229 #endif
230     m_ascent = 0_lu;
231     m_descent = 0_lu;
232 }
233 
234 inline InlineLayoutUnit LineBoxBuilder::Baseline::ascent() const
235 {
236     ASSERT(m_hasValidAscent);
237     return m_ascent;
238 }
239 
240 inline InlineLayoutUnit LineBoxBuilder::Baseline::descent() const
241 {
242     ASSERT(m_hasValidDescent);
243     return m_descent;
244 }
245 
246 }
247 }
248 
249 #endif
    </pre>
  </body>
</html>
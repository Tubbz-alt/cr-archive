<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   4  *  Copyright (C) 2009 Torch Mobile, Inc.
   5  *  Copyright (C) 2015 Jordan Harband (ljharb@gmail.com)
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;StringPrototype.h&quot;
  25 
  26 #include &quot;BuiltinNames.h&quot;
  27 #include &quot;ButterflyInlines.h&quot;
  28 #include &quot;CachedCall.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;FrameTracers.h&quot;
  31 #include &quot;InterpreterInlines.h&quot;
  32 #include &quot;IntlCollator.h&quot;
  33 #include &quot;IntlObject.h&quot;
  34 #include &quot;JITCodeInlines.h&quot;
  35 #include &quot;JSArray.h&quot;
  36 #include &quot;JSCBuiltins.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &quot;JSFunction.h&quot;
  39 #include &quot;JSGlobalObjectFunctions.h&quot;
  40 #include &quot;JSStringIterator.h&quot;
  41 #include &quot;Lookup.h&quot;
  42 #include &quot;ObjectConstructor.h&quot;
  43 #include &quot;ObjectPrototype.h&quot;
  44 #include &quot;ParseInt.h&quot;
  45 #include &quot;PropertyNameArray.h&quot;
  46 #include &quot;RegExpCache.h&quot;
  47 #include &quot;RegExpConstructor.h&quot;
  48 #include &quot;RegExpGlobalDataInlines.h&quot;
  49 #include &quot;StringPrototypeInlines.h&quot;
  50 #include &quot;SuperSampler.h&quot;
  51 #include &lt;algorithm&gt;
  52 #include &lt;unicode/uconfig.h&gt;
  53 #include &lt;unicode/unorm2.h&gt;
  54 #include &lt;unicode/ustring.h&gt;
  55 #include &lt;wtf/ASCIICType.h&gt;
  56 #include &lt;wtf/MathExtras.h&gt;
  57 #include &lt;wtf/text/StringBuilder.h&gt;
  58 #include &lt;wtf/text/StringView.h&gt;
  59 #include &lt;wtf/unicode/Collator.h&gt;
  60 
  61 namespace JSC {
  62 
  63 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(StringPrototype);
  64 
  65 EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(JSGlobalObject*, CallFrame*);
  66 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(JSGlobalObject*, CallFrame*);
  67 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(JSGlobalObject*, CallFrame*);
  68 EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(JSGlobalObject*, CallFrame*);
  69 EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(JSGlobalObject*, CallFrame*);
  70 EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(JSGlobalObject*, CallFrame*);
  71 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(JSGlobalObject*, CallFrame*);
  72 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(JSGlobalObject*, CallFrame*);
  73 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceAllUsingStringSearch(JSGlobalObject*, CallFrame*);
  74 EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(JSGlobalObject*, CallFrame*);
  75 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(JSGlobalObject*, CallFrame*);
  76 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(JSGlobalObject*, CallFrame*);
  77 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(JSGlobalObject*, CallFrame*);
  78 EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(JSGlobalObject*, CallFrame*);
  79 EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(JSGlobalObject*, CallFrame*);
  80 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(JSGlobalObject*, CallFrame*);
  81 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(JSGlobalObject*, CallFrame*);
  82 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(JSGlobalObject*, CallFrame*);
  83 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(JSGlobalObject*, CallFrame*);
  84 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(JSGlobalObject*, CallFrame*);
  85 EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(JSGlobalObject*, CallFrame*);
  86 EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(JSGlobalObject*, CallFrame*);
  87 EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(JSGlobalObject*, CallFrame*);
  88 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(JSGlobalObject*, CallFrame*);
  89 EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(JSGlobalObject*, CallFrame*);
  90 
  91 }
  92 
  93 #include &quot;StringPrototype.lut.h&quot;
  94 
  95 namespace JSC {
  96 
  97 const ClassInfo StringPrototype::s_info = { &quot;String&quot;, &amp;StringObject::s_info, &amp;stringPrototypeTable, nullptr, CREATE_METHOD_TABLE(StringPrototype) };
  98 
  99 /* Source for StringConstructor.lut.h
 100 @begin stringPrototypeTable
 101     concat        JSBuiltin    DontEnum|Function 1
 102     match         JSBuiltin    DontEnum|Function 1
 103     matchAll      JSBuiltin    DontEnum|Function 1
 104     padStart      JSBuiltin    DontEnum|Function 1
 105     padEnd        JSBuiltin    DontEnum|Function 1
 106     repeat        JSBuiltin    DontEnum|Function 1
 107     replace       JSBuiltin    DontEnum|Function 2
 108     replaceAll    JSBuiltin    DontEnum|Function 2
 109     search        JSBuiltin    DontEnum|Function 1
 110     split         JSBuiltin    DontEnum|Function 1
 111     anchor        JSBuiltin    DontEnum|Function 1
 112     big           JSBuiltin    DontEnum|Function 0
 113     bold          JSBuiltin    DontEnum|Function 0
 114     blink         JSBuiltin    DontEnum|Function 0
 115     fixed         JSBuiltin    DontEnum|Function 0
 116     fontcolor     JSBuiltin    DontEnum|Function 1
 117     fontsize      JSBuiltin    DontEnum|Function 1
 118     italics       JSBuiltin    DontEnum|Function 0
 119     link          JSBuiltin    DontEnum|Function 1
 120     small         JSBuiltin    DontEnum|Function 0
 121     strike        JSBuiltin    DontEnum|Function 0
 122     sub           JSBuiltin    DontEnum|Function 0
 123     sup           JSBuiltin    DontEnum|Function 0
 124 @end
 125 */
 126 
 127 // ECMA 15.5.4
 128 StringPrototype::StringPrototype(VM&amp; vm, Structure* structure)
 129     : StringObject(vm, structure)
 130 {
 131 }
 132 
 133 void StringPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject, JSString* nameAndMessage)
 134 {
 135     Base::finishCreation(vm, nameAndMessage);
 136     ASSERT(inherits(vm, info()));
 137 
 138     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toString, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
 139     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;valueOf, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
 140     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charAt&quot;, stringProtoFuncCharAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharAtIntrinsic);
 141     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charCodeAt&quot;, stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
 142     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;codePointAt&quot;, stringProtoFuncCodePointAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, StringPrototypeCodePointAtIntrinsic);
 143     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, stringProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 144     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, stringProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 145     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingRegExpPrivateName(), stringProtoFuncReplaceUsingRegExp, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeReplaceRegExpIntrinsic);
 146     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingStringSearchPrivateName(), stringProtoFuncReplaceUsingStringSearch, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 147     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceAllUsingStringSearchPrivateName(), stringProtoFuncReplaceAllUsingStringSearch, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 148     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;slice&quot;, stringProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeSliceIntrinsic);
 149     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substr&quot;, stringProtoFuncSubstr, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 150     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substring&quot;, stringProtoFuncSubstring, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 151     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;toLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeToLowerCaseIntrinsic);
 152     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 153     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;localeCompare&quot;, stringProtoFuncLocaleCompare, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 154 #if ENABLE(INTL)
 155     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLocaleLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 156     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToLocaleUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 157 #else
 158     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 159     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 160 #endif
 161     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;trim&quot;, stringProtoFuncTrim, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 162     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;startsWith&quot;, stringProtoFuncStartsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 163     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;endsWith&quot;, stringProtoFuncEndsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 164     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;includes&quot;, stringProtoFuncIncludes, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 165     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;normalize&quot;, stringProtoFuncNormalize, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 166     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().charCodeAtPrivateName(), stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
 167 
 168     JSFunction* trimStartFunction = JSFunction::create(vm, globalObject, 0, &quot;trimStart&quot;_s, stringProtoFuncTrimStart, NoIntrinsic);
 169     JSFunction* trimEndFunction = JSFunction::create(vm, globalObject, 0, &quot;trimEnd&quot;_s, stringProtoFuncTrimEnd, NoIntrinsic);
 170     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;trimStart&quot;), trimStartFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 171     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;trimLeft&quot;), trimStartFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 172     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;trimEnd&quot;), trimEndFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 173     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;trimRight&quot;), trimEndFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 174 
 175     JSFunction* iteratorFunction = JSFunction::create(vm, globalObject, 0, &quot;[Symbol.iterator]&quot;_s, stringProtoFuncIterator, NoIntrinsic);
 176     putDirectWithoutTransition(vm, vm.propertyNames-&gt;iteratorSymbol, iteratorFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 177 
 178     // The constructor will be added later, after StringConstructor has been built
 179     putDirectWithoutTransition(vm, vm.propertyNames-&gt;length, jsNumber(0), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 180 }
 181 
 182 StringPrototype* StringPrototype::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 183 {
 184     JSString* empty = jsEmptyString(vm);
 185     StringPrototype* prototype = new (NotNull, allocateCell&lt;StringPrototype&gt;(vm.heap)) StringPrototype(vm, structure);
 186     prototype-&gt;finishCreation(vm, globalObject, empty);
 187     return prototype;
 188 }
 189 
 190 // ------------------------------ Functions --------------------------
 191 
 192 static NEVER_INLINE void substituteBackreferencesSlow(StringBuilder&amp; result, StringView replacement, StringView source, const int* ovector, RegExp* reg, size_t i)
 193 {
 194     bool hasNamedCaptures = reg &amp;&amp; reg-&gt;hasNamedCaptures();
 195     int offset = 0;
 196     do {
 197         if (i + 1 == replacement.length())
 198             break;
 199 
 200         UChar ref = replacement[i + 1];
 201         if (ref == &#39;$&#39;) {
 202             // &quot;$$&quot; -&gt; &quot;$&quot;
 203             ++i;
 204             result.append(replacement.substring(offset, i - offset));
 205             offset = i + 1;
 206             continue;
 207         }
 208 
 209         int backrefStart;
 210         int backrefLength;
 211         int advance = 0;
 212         if (ref == &#39;&amp;&#39;) {
 213             backrefStart = ovector[0];
 214             backrefLength = ovector[1] - backrefStart;
 215         } else if (ref == &#39;`&#39;) {
 216             backrefStart = 0;
 217             backrefLength = ovector[0];
 218         } else if (ref == &#39;\&#39;&#39;) {
 219             backrefStart = ovector[1];
 220             backrefLength = source.length() - backrefStart;
 221         } else if (reg &amp;&amp; ref == &#39;&lt;&#39;) {
 222             // Named back reference
 223             if (!hasNamedCaptures)
 224                 continue;
 225 
 226             size_t closingBracket = replacement.find(&#39;&gt;&#39;, i + 2);
 227             if (closingBracket == WTF::notFound)
 228                 continue;
 229 
 230             unsigned nameLength = closingBracket - i - 2;
 231             unsigned backrefIndex = reg-&gt;subpatternForName(replacement.substring(i + 2, nameLength).toString());
 232 
 233             if (!backrefIndex || backrefIndex &gt; reg-&gt;numSubpatterns()) {
 234                 backrefStart = 0;
 235                 backrefLength = 0;
 236             } else {
 237                 backrefStart = ovector[2 * backrefIndex];
 238                 backrefLength = ovector[2 * backrefIndex + 1] - backrefStart;
 239             }
 240             advance = nameLength + 1;
 241         } else if (reg &amp;&amp; isASCIIDigit(ref)) {
 242             // 1- and 2-digit back references are allowed
 243             unsigned backrefIndex = ref - &#39;0&#39;;
 244             if (backrefIndex &gt; reg-&gt;numSubpatterns())
 245                 continue;
 246             if (replacement.length() &gt; i + 2) {
 247                 ref = replacement[i + 2];
 248                 if (isASCIIDigit(ref)) {
 249                     backrefIndex = 10 * backrefIndex + ref - &#39;0&#39;;
 250                     if (backrefIndex &gt; reg-&gt;numSubpatterns())
 251                         backrefIndex = backrefIndex / 10;   // Fall back to the 1-digit reference
 252                     else
 253                         advance = 1;
 254                 }
 255             }
 256             if (!backrefIndex)
 257                 continue;
 258             backrefStart = ovector[2 * backrefIndex];
 259             backrefLength = ovector[2 * backrefIndex + 1] - backrefStart;
 260         } else
 261             continue;
 262 
 263         if (i - offset)
 264             result.append(replacement.substring(offset, i - offset));
 265         i += 1 + advance;
 266         offset = i + 1;
 267         if (backrefStart &gt;= 0)
 268             result.append(source.substring(backrefStart, backrefLength));
 269     } while ((i = replacement.find(&#39;$&#39;, i + 1)) != notFound);
 270 
 271     if (replacement.length() - offset)
 272         result.append(replacement.substring(offset));
 273 }
 274 
 275 inline void substituteBackreferencesInline(StringBuilder&amp; result, const String&amp; replacement, StringView source, const int* ovector, RegExp* reg)
 276 {
 277     size_t i = replacement.find(&#39;$&#39;);
 278     if (UNLIKELY(i != notFound))
 279         return substituteBackreferencesSlow(result, replacement, source, ovector, reg, i);
 280 
 281     result.append(replacement);
 282 }
 283 
 284 void substituteBackreferences(StringBuilder&amp; result, const String&amp; replacement, StringView source, const int* ovector, RegExp* reg)
 285 {
 286     substituteBackreferencesInline(result, replacement, source, ovector, reg);
 287 }
 288 
 289 struct StringRange {
 290     StringRange(int pos, int len)
 291         : position(pos)
 292         , length(len)
 293     {
 294     }
 295 
 296     StringRange()
 297     {
 298     }
 299 
 300     int position;
 301     int length;
 302 };
 303 
 304 static ALWAYS_INLINE JSString* jsSpliceSubstrings(JSGlobalObject* globalObject, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount)
 305 {
 306     VM&amp; vm = globalObject-&gt;vm();
 307     auto scope = DECLARE_THROW_SCOPE(vm);
 308 
 309     if (rangeCount == 1) {
 310         int sourceSize = source.length();
 311         int position = substringRanges[0].position;
 312         int length = substringRanges[0].length;
 313         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 314             return sourceVal;
 315         // We could call String::substringSharingImpl(), but this would result in redundant checks.
 316         RELEASE_AND_RETURN(scope, jsString(vm, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));
 317     }
 318 
 319     // We know that the sum of substringRanges lengths cannot exceed length of
 320     // source because the substringRanges were computed from the source string
 321     // in removeUsingRegExpSearch(). Hence, totalLength cannot exceed
 322     // String::MaxLength, and therefore, cannot overflow.
 323     Checked&lt;int, AssertNoOverflow&gt; totalLength = 0;
 324     for (int i = 0; i &lt; rangeCount; i++)
 325         totalLength += substringRanges[i].length;
 326     ASSERT(totalLength &lt;= String::MaxLength);
 327 
 328     if (!totalLength)
 329         return jsEmptyString(vm);
 330 
 331     if (source.is8Bit()) {
 332         LChar* buffer;
 333         const LChar* sourceData = source.characters8();
 334         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 335         if (!impl) {
 336             throwOutOfMemoryError(globalObject, scope);
 337             return nullptr;
 338         }
 339 
 340         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 341         for (int i = 0; i &lt; rangeCount; i++) {
 342             if (int srcLen = substringRanges[i].length) {
 343                 StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 344                 bufferPos += srcLen;
 345             }
 346         }
 347 
 348         RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 349     }
 350 
 351     UChar* buffer;
 352     const UChar* sourceData = source.characters16();
 353 
 354     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 355     if (!impl) {
 356         throwOutOfMemoryError(globalObject, scope);
 357         return nullptr;
 358     }
 359 
 360     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 361     for (int i = 0; i &lt; rangeCount; i++) {
 362         if (int srcLen = substringRanges[i].length) {
 363             StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 364             bufferPos += srcLen;
 365         }
 366     }
 367 
 368     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 369 }
 370 
 371 static ALWAYS_INLINE JSString* jsSpliceSubstringsWithSeparators(JSGlobalObject* globalObject, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount, const String* separators, int separatorCount)
 372 {
 373     VM&amp; vm = globalObject-&gt;vm();
 374     auto scope = DECLARE_THROW_SCOPE(vm);
 375 
 376     if (rangeCount == 1 &amp;&amp; separatorCount == 0) {
 377         int sourceSize = source.length();
 378         int position = substringRanges[0].position;
 379         int length = substringRanges[0].length;
 380         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 381             return sourceVal;
 382         // We could call String::substringSharingImpl(), but this would result in redundant checks.
 383         RELEASE_AND_RETURN(scope, jsString(vm, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));
 384     }
 385 
 386     if (rangeCount == 2 &amp;&amp; separatorCount == 1) {
 387         String leftPart(StringImpl::createSubstringSharingImpl(*source.impl(), substringRanges[0].position, substringRanges[0].length));
 388         String rightPart(StringImpl::createSubstringSharingImpl(*source.impl(), substringRanges[1].position, substringRanges[1].length));
 389         RELEASE_AND_RETURN(scope, jsString(globalObject, leftPart, separators[0], rightPart));
 390     }
 391 
 392     Checked&lt;int, RecordOverflow&gt; totalLength = 0;
 393     bool allSeparators8Bit = true;
 394     for (int i = 0; i &lt; rangeCount; i++)
 395         totalLength += substringRanges[i].length;
 396     for (int i = 0; i &lt; separatorCount; i++) {
 397         totalLength += separators[i].length();
 398         if (separators[i].length() &amp;&amp; !separators[i].is8Bit())
 399             allSeparators8Bit = false;
 400     }
 401     if (totalLength.hasOverflowed()) {
 402         throwOutOfMemoryError(globalObject, scope);
 403         return nullptr;
 404     }
 405 
 406     if (!totalLength)
 407         return jsEmptyString(vm);
 408 
 409     if (source.is8Bit() &amp;&amp; allSeparators8Bit) {
 410         LChar* buffer;
 411         const LChar* sourceData = source.characters8();
 412 
 413         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 414         if (!impl) {
 415             throwOutOfMemoryError(globalObject, scope);
 416             return nullptr;
 417         }
 418 
 419         int maxCount = std::max(rangeCount, separatorCount);
 420         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 421         for (int i = 0; i &lt; maxCount; i++) {
 422             if (i &lt; rangeCount) {
 423                 if (int srcLen = substringRanges[i].length) {
 424                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 425                     bufferPos += srcLen;
 426                 }
 427             }
 428             if (i &lt; separatorCount) {
 429                 if (int sepLen = separators[i].length()) {
 430                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 431                     bufferPos += sepLen;
 432                 }
 433             }
 434         }
 435 
 436         RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 437     }
 438 
 439     UChar* buffer;
 440     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 441     if (!impl) {
 442         throwOutOfMemoryError(globalObject, scope);
 443         return nullptr;
 444     }
 445 
 446     int maxCount = std::max(rangeCount, separatorCount);
 447     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 448     for (int i = 0; i &lt; maxCount; i++) {
 449         if (i &lt; rangeCount) {
 450             if (int srcLen = substringRanges[i].length) {
 451                 if (source.is8Bit())
 452                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters8() + substringRanges[i].position, srcLen);
 453                 else
 454                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters16() + substringRanges[i].position, srcLen);
 455                 bufferPos += srcLen;
 456             }
 457         }
 458         if (i &lt; separatorCount) {
 459             if (int sepLen = separators[i].length()) {
 460                 if (separators[i].is8Bit())
 461                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 462                 else
 463                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters16(), sepLen);
 464                 bufferPos += sepLen;
 465             }
 466         }
 467     }
 468 
 469     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 470 }
 471 
 472 #define OUT_OF_MEMORY(exec__, scope__) \
 473     do { \
 474         throwOutOfMemoryError(exec__, scope__); \
 475         return nullptr; \
 476     } while (false)
 477 
 478 static ALWAYS_INLINE JSString* removeUsingRegExpSearch(VM&amp; vm, JSGlobalObject* globalObject, JSString* string, const String&amp; source, RegExp* regExp)
 479 {
 480     auto scope = DECLARE_THROW_SCOPE(vm);
 481     SuperSamplerScope superSamplerScope(false);
 482 
 483     size_t lastIndex = 0;
 484     unsigned startPosition = 0;
 485 
 486     Vector&lt;StringRange, 16&gt; sourceRanges;
 487     unsigned sourceLen = source.length();
 488 
 489     while (true) {
 490         MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition);
 491         RETURN_IF_EXCEPTION(scope, nullptr);
 492         if (!result)
 493             break;
 494 
 495         if (lastIndex &lt; result.start) {
 496             if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 497                 OUT_OF_MEMORY(globalObject, scope);
 498         }
 499         lastIndex = result.end;
 500         startPosition = lastIndex;
 501 
 502         // special case of empty match
 503         if (result.empty()) {
 504             startPosition++;
 505             if (startPosition &gt; sourceLen)
 506                 break;
 507         }
 508     }
 509 
 510     if (!lastIndex)
 511         return string;
 512 
 513     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 514         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
 515             OUT_OF_MEMORY(globalObject, scope);
 516     }
 517     RELEASE_AND_RETURN(scope, jsSpliceSubstrings(globalObject, string, source, sourceRanges.data(), sourceRanges.size()));
 518 }
 519 
 520 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(
 521     VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* string, JSValue searchValue, CallData&amp; callData,
 522     CallType callType, String&amp; replacementString, JSValue replaceValue)
 523 {
 524     auto scope = DECLARE_THROW_SCOPE(vm);
 525 
 526     String source = string-&gt;value(globalObject);
 527     RETURN_IF_EXCEPTION(scope, nullptr);
 528     unsigned sourceLen = source.length();
 529     RETURN_IF_EXCEPTION(scope, nullptr);
 530     RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(searchValue);
 531     RegExp* regExp = regExpObject-&gt;regExp();
 532     bool global = regExp-&gt;global();
 533     bool hasNamedCaptures = regExp-&gt;hasNamedCaptures();
 534 
 535     if (global) {
 536         // ES5.1 15.5.4.10 step 8.a.
 537         regExpObject-&gt;setLastIndex(globalObject, 0);
 538         RETURN_IF_EXCEPTION(scope, nullptr);
 539 
 540         if (callType == CallType::None &amp;&amp; !replacementString.length())
 541             RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, globalObject, string, source, regExp));
 542     }
 543 
 544     size_t lastIndex = 0;
 545     unsigned startPosition = 0;
 546 
 547     Vector&lt;StringRange, 16&gt; sourceRanges;
 548     Vector&lt;String, 16&gt; replacements;
 549 
 550     // This is either a loop (if global is set) or a one-way (if not).
 551     if (global &amp;&amp; callType == CallType::JS) {
 552         // regExp-&gt;numSubpatterns() + 1 for pattern args, + 2 for match start and string
 553         int argCount = regExp-&gt;numSubpatterns() + 1 + 2;
 554         if (hasNamedCaptures)
 555             ++argCount;
 556         JSFunction* func = jsCast&lt;JSFunction*&gt;(replaceValue);
 557         CachedCall cachedCall(globalObject, callFrame, func, argCount);
 558         RETURN_IF_EXCEPTION(scope, nullptr);
 559         while (true) {
 560             int* ovector;
 561             MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition, &amp;ovector);
 562             RETURN_IF_EXCEPTION(scope, nullptr);
 563             if (!result)
 564                 break;
 565 
 566             if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 567                 OUT_OF_MEMORY(globalObject, scope);
 568 
 569             cachedCall.clearArguments();
 570             JSObject* groups = hasNamedCaptures ? constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure()) : nullptr;
 571 
 572             for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 573                 int matchStart = ovector[i * 2];
 574                 int matchLen = ovector[i * 2 + 1] - matchStart;
 575 
 576                 JSValue patternValue;
 577 
 578                 if (matchStart &lt; 0)
 579                     patternValue = jsUndefined();
 580                 else
 581                     patternValue = jsSubstring(vm, source, matchStart, matchLen);
 582 
 583                 cachedCall.appendArgument(patternValue);
 584 
 585                 if (i &amp;&amp; hasNamedCaptures) {
 586                     String groupName = regExp-&gt;getCaptureGroupName(i);
 587                     if (!groupName.isEmpty())
 588                         groups-&gt;putDirect(vm, Identifier::fromString(vm, groupName), patternValue);
 589                 }
 590             }
 591 
 592             cachedCall.appendArgument(jsNumber(result.start));
 593             cachedCall.appendArgument(string);
 594             if (hasNamedCaptures)
 595                 cachedCall.appendArgument(groups);
 596 
 597             cachedCall.setThis(jsUndefined());
 598             if (UNLIKELY(cachedCall.hasOverflowedArguments())) {
 599                 throwOutOfMemoryError(globalObject, scope);
 600                 return nullptr;
 601             }
 602 
 603             JSValue jsResult = cachedCall.call();
 604             RETURN_IF_EXCEPTION(scope, nullptr);
 605             replacements.append(jsResult.toWTFString(globalObject));
 606             RETURN_IF_EXCEPTION(scope, nullptr);
 607 
 608             lastIndex = result.end;
 609             startPosition = lastIndex;
 610 
 611             // special case of empty match
 612             if (result.empty()) {
 613                 startPosition++;
 614                 if (startPosition &gt; sourceLen)
 615                     break;
 616             }
 617         }
 618     } else {
 619         do {
 620             int* ovector;
 621             MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition, &amp;ovector);
 622             RETURN_IF_EXCEPTION(scope, nullptr);
 623             if (!result)
 624                 break;
 625 
 626             if (callType != CallType::None) {
 627                 if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 628                     OUT_OF_MEMORY(globalObject, scope);
 629 
 630                 MarkedArgumentBuffer args;
 631                 JSObject* groups = hasNamedCaptures ? constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure()) : nullptr;
 632 
 633                 for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 634                     int matchStart = ovector[i * 2];
 635                     int matchLen = ovector[i * 2 + 1] - matchStart;
 636 
 637                     JSValue patternValue;
 638 
 639                     if (matchStart &lt; 0)
 640                         patternValue = jsUndefined();
 641                     else {
 642                         patternValue = jsSubstring(vm, source, matchStart, matchLen);
 643                         RETURN_IF_EXCEPTION(scope, nullptr);
 644                     }
 645 
 646                     args.append(patternValue);
 647 
 648                     if (i &amp;&amp; hasNamedCaptures) {
 649                         String groupName = regExp-&gt;getCaptureGroupName(i);
 650                         if (!groupName.isEmpty())
 651                             groups-&gt;putDirect(vm, Identifier::fromString(vm, groupName), patternValue);
 652                     }
 653                 }
 654 
 655                 args.append(jsNumber(result.start));
 656                 args.append(string);
 657                 if (hasNamedCaptures)
 658                     args.append(groups);
 659                 if (UNLIKELY(args.hasOverflowed())) {
 660                     throwOutOfMemoryError(globalObject, scope);
 661                     return nullptr;
 662                 }
 663 
 664                 JSValue replacement = call(globalObject, replaceValue, callType, callData, jsUndefined(), args);
 665                 RETURN_IF_EXCEPTION(scope, nullptr);
 666                 String replacementString = replacement.toWTFString(globalObject);
 667                 RETURN_IF_EXCEPTION(scope, nullptr);
 668                 replacements.append(replacementString);
 669                 RETURN_IF_EXCEPTION(scope, nullptr);
 670             } else {
 671                 int replLen = replacementString.length();
 672                 if (lastIndex &lt; result.start || replLen) {
 673                     if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 674                         OUT_OF_MEMORY(globalObject, scope);
 675 
 676                     if (replLen) {
 677                         StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
 678                         substituteBackreferences(replacement, replacementString, source, ovector, regExp);
 679                         if (UNLIKELY(replacement.hasOverflowed()))
 680                             OUT_OF_MEMORY(globalObject, scope);
 681                         replacements.append(replacement.toString());
 682                     } else
 683                         replacements.append(String());
 684                 }
 685             }
 686 
 687             lastIndex = result.end;
 688             startPosition = lastIndex;
 689 
 690             // special case of empty match
 691             if (result.empty()) {
 692                 startPosition++;
 693                 if (startPosition &gt; sourceLen)
 694                     break;
 695             }
 696         } while (global);
 697     }
 698 
 699     if (!lastIndex &amp;&amp; replacements.isEmpty())
 700         return string;
 701 
 702     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 703         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
 704             OUT_OF_MEMORY(globalObject, scope);
 705     }
 706     RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(globalObject, string, source, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));
 707 }
 708 
 709 IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)
 710 
 711 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpEmptyStr(JSGlobalObject* globalObject, JSString* thisValue, RegExpObject* searchValue)
 712 {
 713     VM&amp; vm = globalObject-&gt;vm();
 714     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 715     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 716     auto scope = DECLARE_THROW_SCOPE(vm);
 717 
 718     RegExp* regExp = searchValue-&gt;regExp();
 719     if (regExp-&gt;global()) {
 720         // ES5.1 15.5.4.10 step 8.a.
 721         searchValue-&gt;setLastIndex(globalObject, 0);
 722         RETURN_IF_EXCEPTION(scope, nullptr);
 723         String source = thisValue-&gt;value(globalObject);
 724         RETURN_IF_EXCEPTION(scope, nullptr);
 725         RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, globalObject, thisValue, source, regExp));
 726     }
 727 
 728     CallData callData;
 729     String replacementString = emptyString();
 730     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
 731         vm, globalObject, callFrame, thisValue, searchValue, callData, CallType::None, replacementString, JSValue()));
 732 }
 733 
 734 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpString(JSGlobalObject* globalObject, JSString* thisValue, RegExpObject* searchValue, JSString* replaceString)
 735 {
 736     VM&amp; vm = globalObject-&gt;vm();
 737     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 738     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 739     auto scope = DECLARE_THROW_SCOPE(vm);
 740 
 741     CallData callData;
 742     String replacementString = replaceString-&gt;value(globalObject);
 743     RETURN_IF_EXCEPTION(scope, nullptr);
 744     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
 745         vm, globalObject, callFrame, thisValue, searchValue, callData, CallType::None, replacementString, replaceString));
 746 }
 747 
 748 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* string, JSValue searchValue, JSValue replaceValue)
 749 {
 750     auto scope = DECLARE_THROW_SCOPE(vm);
 751 
 752     String replacementString;
 753     CallData callData;
 754     CallType callType = getCallData(vm, replaceValue, callData);
 755     if (callType == CallType::None) {
 756         replacementString = replaceValue.toWTFString(globalObject);
 757         RETURN_IF_EXCEPTION(scope, nullptr);
 758     }
 759 
 760     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
 761         vm, globalObject, callFrame, string, searchValue, callData, callType, replacementString, replaceValue));
 762 }
 763 
 764 enum class ReplaceMode : bool { Single, Global };
 765 
 766 static ALWAYS_INLINE JSString* replaceUsingStringSearch(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* jsString, JSValue searchValue, JSValue replaceValue, ReplaceMode mode)
 767 {
 768     auto scope = DECLARE_THROW_SCOPE(vm);
 769 
 770     String string = jsString-&gt;value(globalObject);
 771     RETURN_IF_EXCEPTION(scope, nullptr);
 772     String searchString = searchValue.toWTFString(globalObject);
 773     RETURN_IF_EXCEPTION(scope, nullptr);
 774 
 775     CallData callData;
 776     CallType callType = getCallData(vm, replaceValue, callData);
 777     Optional&lt;CachedCall&gt; cachedCall;
 778     String replaceString;
 779     if (callType == CallType::None) {
 780         replaceString = replaceValue.toWTFString(globalObject);
 781         RETURN_IF_EXCEPTION(scope, nullptr);
 782     } else if (callType == CallType::JS) {
 783         cachedCall.emplace(globalObject, callFrame, jsCast&lt;JSFunction*&gt;(replaceValue), 3);
 784         RETURN_IF_EXCEPTION(scope, nullptr);
 785         cachedCall-&gt;setThis(jsUndefined());
 786     }
 787 
 788     size_t matchStart = string.find(searchString);
 789     if (matchStart == notFound)
 790         return jsString;
 791 
 792     size_t endOfLastMatch = 0;
 793     size_t searchStringLength = searchString.length();
 794     Vector&lt;StringRange, 16&gt; sourceRanges;
 795     Vector&lt;String, 16&gt; replacements;
 796     do {
 797         if (callType != CallType::None) {
 798             JSValue replacement;
 799             if (cachedCall) {
 800                 auto* substring = jsSubstring(vm, string, matchStart, searchStringLength);
 801                 RETURN_IF_EXCEPTION(scope, nullptr);
 802                 cachedCall-&gt;clearArguments();
 803                 cachedCall-&gt;appendArgument(substring);
 804                 cachedCall-&gt;appendArgument(jsNumber(matchStart));
 805                 cachedCall-&gt;appendArgument(jsString);
 806                 ASSERT(!cachedCall-&gt;hasOverflowedArguments());
 807                 replacement = cachedCall-&gt;call();
 808             } else {
 809                 MarkedArgumentBuffer args;
 810                 auto* substring = jsSubstring(vm, string, matchStart, searchString.impl()-&gt;length());
 811                 RETURN_IF_EXCEPTION(scope, nullptr);
 812                 args.append(substring);
 813                 args.append(jsNumber(matchStart));
 814                 args.append(jsString);
 815                 ASSERT(!args.hasOverflowed());
 816                 replacement = call(globalObject, replaceValue, callType, callData, jsUndefined(), args);
 817             }
 818             RETURN_IF_EXCEPTION(scope, nullptr);
 819             replaceString = replacement.toWTFString(globalObject);
 820             RETURN_IF_EXCEPTION(scope, nullptr);
 821         }
 822 
 823         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(endOfLastMatch, matchStart - endOfLastMatch)))
 824             OUT_OF_MEMORY(globalObject, scope);
 825 
 826         size_t matchEnd = matchStart + searchStringLength;
 827         if (callType != CallType::None)
 828             replacements.append(replaceString);
 829         else {
 830             StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
 831             int ovector[2] = { static_cast&lt;int&gt;(matchStart),  static_cast&lt;int&gt;(matchEnd) };
 832             substituteBackreferences(replacement, replaceString, string, ovector, nullptr);
 833             if (UNLIKELY(replacement.hasOverflowed()))
 834                 OUT_OF_MEMORY(globalObject, scope);
 835             replacements.append(replacement.toString());
 836         }
 837 
 838         endOfLastMatch = matchEnd;
 839         if (mode == ReplaceMode::Single)
 840             break;
 841         matchStart = string.find(searchString, !searchStringLength ? endOfLastMatch + 1 : endOfLastMatch);
 842     } while (matchStart != notFound);
 843 
 844     if (UNLIKELY(!sourceRanges.tryConstructAndAppend(endOfLastMatch, string.length() - endOfLastMatch)))
 845         OUT_OF_MEMORY(globalObject, scope);
 846     RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(globalObject, jsString, string, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));
 847 }
 848 
 849 static inline bool checkObjectCoercible(JSValue thisValue)
 850 {
 851     if (thisValue.isString())
 852         return true;
 853 
 854     if (thisValue.isUndefinedOrNull())
 855         return false;
 856 
 857     if (thisValue.isObject() &amp;&amp; asObject(thisValue)-&gt;isEnvironment())
 858         return false;
 859 
 860     return true;
 861 }
 862 
 863 EncodedJSValue JSC_HOST_CALL stringProtoFuncRepeatCharacter(JSGlobalObject* globalObject, CallFrame* callFrame)
 864 {
 865     VM&amp; vm = globalObject-&gt;vm();
 866     auto scope = DECLARE_THROW_SCOPE(vm);
 867 
 868     // For a string which length is single, instead of creating ropes,
 869     // allocating a sequential buffer and fill with the repeated string for efficiency.
 870     ASSERT(callFrame-&gt;argumentCount() == 2);
 871 
 872     ASSERT(callFrame-&gt;uncheckedArgument(0).isString());
 873     JSString* string = asString(callFrame-&gt;uncheckedArgument(0));
 874     ASSERT(string-&gt;length() == 1);
 875 
 876     JSValue repeatCountValue = callFrame-&gt;uncheckedArgument(1);
 877     RELEASE_ASSERT(repeatCountValue.isNumber());
 878     int32_t repeatCount;
 879     double value = repeatCountValue.asNumber();
 880     if (value &gt; JSString::MaxLength)
 881         return JSValue::encode(throwOutOfMemoryError(globalObject, scope));
 882     repeatCount = static_cast&lt;int32_t&gt;(value);
 883     ASSERT(repeatCount &gt;= 0);
 884     ASSERT(!repeatCountValue.isDouble() || repeatCountValue.asDouble() == repeatCount);
 885 
 886     auto viewWithString = string-&gt;viewWithUnderlyingString(globalObject);
 887     StringView view = viewWithString.view;
 888     ASSERT(view.length() == 1);
 889     scope.assertNoException();
 890     UChar character = view[0];
 891     scope.release();
 892     if (isLatin1(character))
 893         return JSValue::encode(repeatCharacter(globalObject, static_cast&lt;LChar&gt;(character), repeatCount));
 894     return JSValue::encode(repeatCharacter(globalObject, character, repeatCount));
 895 }
 896 
 897 ALWAYS_INLINE JSString* replace(
 898     VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* string, JSValue searchValue, JSValue replaceValue)
 899 {
 900     if (searchValue.inherits&lt;RegExpObject&gt;(vm))
 901         return replaceUsingRegExpSearch(vm, globalObject, callFrame, string, searchValue, replaceValue);
 902     return replaceUsingStringSearch(vm, globalObject, callFrame, string, searchValue, replaceValue, ReplaceMode::Single);
 903 }
 904 
 905 ALWAYS_INLINE JSString* replace(
 906     VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSValue thisValue, JSValue searchValue, JSValue replaceValue)
 907 {
 908     auto scope = DECLARE_THROW_SCOPE(vm);
 909 
 910     if (!checkObjectCoercible(thisValue)) {
 911         throwVMTypeError(globalObject, scope);
 912         return nullptr;
 913     }
 914     JSString* string = thisValue.toString(globalObject);
 915     RETURN_IF_EXCEPTION(scope, nullptr);
 916     RELEASE_AND_RETURN(scope, replace(vm, globalObject, callFrame, string, searchValue, replaceValue));
 917 }
 918 
 919 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(JSGlobalObject* globalObject, CallFrame* callFrame)
 920 {
 921     VM&amp; vm = globalObject-&gt;vm();
 922     auto scope = DECLARE_THROW_SCOPE(vm);
 923 
 924     JSString* string = callFrame-&gt;thisValue().toString(globalObject);
 925     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 926 
 927     JSValue searchValue = callFrame-&gt;argument(0);
 928     if (!searchValue.inherits&lt;RegExpObject&gt;(vm))
 929         return JSValue::encode(jsUndefined());
 930 
 931     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingRegExpSearch(vm, globalObject, callFrame, string, searchValue, callFrame-&gt;argument(1))));
 932 }
 933 
 934 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(JSGlobalObject* globalObject, CallFrame* callFrame)
 935 {
 936     VM&amp; vm = globalObject-&gt;vm();
 937     auto scope = DECLARE_THROW_SCOPE(vm);
 938 
 939     JSString* string = callFrame-&gt;thisValue().toString(globalObject);
 940     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 941 
 942     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, globalObject, callFrame, string, callFrame-&gt;argument(0), callFrame-&gt;argument(1), ReplaceMode::Single)));
 943 }
 944 
 945 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceAllUsingStringSearch(JSGlobalObject* globalObject, CallFrame* callFrame)
 946 {
 947     VM&amp; vm = globalObject-&gt;vm();
 948     auto scope = DECLARE_THROW_SCOPE(vm);
 949 
 950     JSString* string = callFrame-&gt;thisValue().toString(globalObject);
 951     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 952 
 953     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, globalObject, callFrame, string, callFrame-&gt;argument(0), callFrame-&gt;argument(1), ReplaceMode::Global)));
 954 }
 955 
 956 JSCell* JIT_OPERATION operationStringProtoFuncReplaceGeneric(JSGlobalObject* globalObject, EncodedJSValue thisValue, EncodedJSValue searchValue, EncodedJSValue replaceValue)
 957 {
 958     VM&amp; vm = globalObject-&gt;vm();
 959     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
 960     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
 961 
 962     return replace(
 963         vm, globalObject, callFrame, JSValue::decode(thisValue), JSValue::decode(searchValue),
 964         JSValue::decode(replaceValue));
 965 }
 966 
 967 IGNORE_WARNINGS_END
 968 
 969 EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(JSGlobalObject* globalObject, CallFrame* callFrame)
 970 {
 971     VM&amp; vm = globalObject-&gt;vm();
 972     auto scope = DECLARE_THROW_SCOPE(vm);
 973 
 974     JSValue thisValue = callFrame-&gt;thisValue();
 975     // Also used for valueOf.
 976 
 977     if (thisValue.isString())
 978         return JSValue::encode(thisValue);
 979 
 980     auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, thisValue);
 981     if (stringObject)
 982         return JSValue::encode(stringObject-&gt;internalValue());
 983 
 984     return throwVMTypeError(globalObject, scope);
 985 }
 986 
 987 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(JSGlobalObject* globalObject, CallFrame* callFrame)
 988 {
 989     VM&amp; vm = globalObject-&gt;vm();
 990     auto scope = DECLARE_THROW_SCOPE(vm);
 991 
 992     JSValue thisValue = callFrame-&gt;thisValue();
 993     if (!checkObjectCoercible(thisValue))
 994         return throwVMTypeError(globalObject, scope);
 995     auto viewWithString = thisValue.toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);
 996     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 997     StringView view = viewWithString.view;
 998     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 999     JSValue a0 = callFrame-&gt;argument(0);
1000     if (a0.isUInt32()) {
1001         uint32_t i = a0.asUInt32();
1002         if (i &lt; view.length())
1003             return JSValue::encode(jsSingleCharacterString(vm, view[i]));
1004         return JSValue::encode(jsEmptyString(vm));
1005     }
1006     double dpos = a0.toInteger(globalObject);
1007     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1008     if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
1009         return JSValue::encode(jsSingleCharacterString(vm, view[static_cast&lt;unsigned&gt;(dpos)]));
1010     return JSValue::encode(jsEmptyString(vm));
1011 }
1012 
1013 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(JSGlobalObject* globalObject, CallFrame* callFrame)
1014 {
1015     VM&amp; vm = globalObject-&gt;vm();
1016     auto scope = DECLARE_THROW_SCOPE(vm);
1017 
1018     JSValue thisValue = callFrame-&gt;thisValue();
1019     if (!checkObjectCoercible(thisValue))
1020         return throwVMTypeError(globalObject, scope);
1021     auto viewWithString = thisValue.toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);
1022     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1023     StringView view = viewWithString.view;
1024     JSValue a0 = callFrame-&gt;argument(0);
1025     if (a0.isUInt32()) {
1026         uint32_t i = a0.asUInt32();
1027         if (i &lt; view.length())
1028             return JSValue::encode(jsNumber(view[i]));
1029         return JSValue::encode(jsNaN());
1030     }
1031     double dpos = a0.toInteger(globalObject);
1032     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1033     if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
1034         return JSValue::encode(jsNumber(view[static_cast&lt;int&gt;(dpos)]));
1035     return JSValue::encode(jsNaN());
1036 }
1037 
1038 static inline UChar32 codePointAt(const String&amp; string, unsigned position, unsigned length)
1039 {
1040     RELEASE_ASSERT(position &lt; length);
1041     if (string.is8Bit())
1042         return string.characters8()[position];
1043     UChar32 character;
1044     U16_NEXT(string.characters16(), position, length, character);
1045     return character;
1046 }
1047 
1048 EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(JSGlobalObject* globalObject, CallFrame* callFrame)
1049 {
1050     VM&amp; vm = globalObject-&gt;vm();
1051     auto scope = DECLARE_THROW_SCOPE(vm);
1052 
1053     JSValue thisValue = callFrame-&gt;thisValue();
1054     if (!checkObjectCoercible(thisValue))
1055         return throwVMTypeError(globalObject, scope);
1056 
1057     String string = thisValue.toWTFString(globalObject);
1058     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1059     unsigned length = string.length();
1060 
1061     JSValue argument0 = callFrame-&gt;argument(0);
1062     if (argument0.isUInt32()) {
1063         unsigned position = argument0.asUInt32();
1064         if (position &lt; length)
1065             return JSValue::encode(jsNumber(codePointAt(string, position, length)));
1066         return JSValue::encode(jsUndefined());
1067     }
1068 
1069     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1070 
1071     double doublePosition = argument0.toInteger(globalObject);
1072     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1073     if (doublePosition &gt;= 0 &amp;&amp; doublePosition &lt; length)
1074         return JSValue::encode(jsNumber(codePointAt(string, static_cast&lt;unsigned&gt;(doublePosition), length)));
1075     return JSValue::encode(jsUndefined());
1076 }
1077 
1078 EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(JSGlobalObject* globalObject, CallFrame* callFrame)
1079 {
1080     VM&amp; vm = globalObject-&gt;vm();
1081     auto scope = DECLARE_THROW_SCOPE(vm);
1082 
1083     JSValue thisValue = callFrame-&gt;thisValue();
1084     if (!checkObjectCoercible(thisValue))
1085         return throwVMTypeError(globalObject, scope);
1086 
1087     JSValue a0 = callFrame-&gt;argument(0);
1088     JSValue a1 = callFrame-&gt;argument(1);
1089 
1090     JSString* thisJSString = thisValue.toString(globalObject);
1091     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1092     JSString* otherJSString = a0.toString(globalObject);
1093     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1094 
1095     unsigned pos = 0;
1096     if (!a1.isUndefined()) {
1097         int len = thisJSString-&gt;length();
1098         RELEASE_ASSERT(len &gt;= 0);
1099         if (a1.isUInt32())
1100             pos = std::min&lt;uint32_t&gt;(a1.asUInt32(), len);
1101         else {
1102             double dpos = a1.toInteger(globalObject);
1103             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1104             if (dpos &lt; 0)
1105                 dpos = 0;
1106             else if (dpos &gt; len)
1107                 dpos = len;
1108             pos = static_cast&lt;unsigned&gt;(dpos);
1109         }
1110     }
1111 
1112     if (thisJSString-&gt;length() &lt; otherJSString-&gt;length() + pos)
1113         return JSValue::encode(jsNumber(-1));
1114 
1115     auto thisViewWithString = thisJSString-&gt;viewWithUnderlyingString(globalObject);
1116     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1117     auto otherViewWithString = otherJSString-&gt;viewWithUnderlyingString(globalObject);
1118     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1119     size_t result = thisViewWithString.view.find(otherViewWithString.view, pos);
1120     if (result == notFound)
1121         return JSValue::encode(jsNumber(-1));
1122     return JSValue::encode(jsNumber(result));
1123 }
1124 
1125 EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(JSGlobalObject* globalObject, CallFrame* callFrame)
1126 {
1127     VM&amp; vm = globalObject-&gt;vm();
1128     auto scope = DECLARE_THROW_SCOPE(vm);
1129 
1130     JSValue thisValue = callFrame-&gt;thisValue();
1131     if (!checkObjectCoercible(thisValue))
1132         return throwVMTypeError(globalObject, scope);
1133 
1134     JSValue a0 = callFrame-&gt;argument(0);
1135     JSValue a1 = callFrame-&gt;argument(1);
1136 
1137     JSString* thisJSString = thisValue.toString(globalObject);
1138     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1139     unsigned len = thisJSString-&gt;length();
1140     JSString* otherJSString = a0.toString(globalObject);
1141     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1142 
1143     double dpos = a1.toIntegerPreserveNaN(globalObject);
1144     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1145     unsigned startPosition;
1146     if (dpos &lt; 0)
1147         startPosition = 0;
1148     else if (!(dpos &lt;= len)) // true for NaN
1149         startPosition = len;
1150     else
1151         startPosition = static_cast&lt;unsigned&gt;(dpos);
1152 
1153     if (len &lt; otherJSString-&gt;length())
1154         return JSValue::encode(jsNumber(-1));
1155 
1156     String thisString = thisJSString-&gt;value(globalObject);
1157     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1158     String otherString = otherJSString-&gt;value(globalObject);
1159     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1160     size_t result;
1161     if (!startPosition)
1162         result = thisString.startsWith(otherString) ? 0 : notFound;
1163     else
1164         result = thisString.reverseFind(otherString, startPosition);
1165     if (result == notFound)
1166         return JSValue::encode(jsNumber(-1));
1167     return JSValue::encode(jsNumber(result));
1168 }
1169 
1170 EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(JSGlobalObject* globalObject, CallFrame* callFrame)
1171 {
1172     VM&amp; vm = globalObject-&gt;vm();
1173     auto scope = DECLARE_THROW_SCOPE(vm);
1174 
1175     JSValue thisValue = callFrame-&gt;thisValue();
1176     if (!checkObjectCoercible(thisValue))
1177         return throwVMTypeError(globalObject, scope);
1178     JSString* string = thisValue.toString(globalObject);
1179     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1180 
1181     JSValue a0 = callFrame-&gt;argument(0);
1182     JSValue a1 = callFrame-&gt;argument(1);
1183 
1184     int length = string-&gt;length();
1185     RELEASE_ASSERT(length &gt;= 0);
1186 
1187     // The arg processing is very much like ArrayProtoFunc::Slice
1188     double start = a0.toInteger(globalObject);
1189     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1190     double end = a1.isUndefined() ? length : a1.toInteger(globalObject);
1191     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1192     RELEASE_AND_RETURN(scope, JSValue::encode(stringSlice(globalObject, vm, string, length, start, end)));
1193 }
1194 
1195 // Return true in case of early return (resultLength got to limitLength).
1196 template&lt;typename CharacterType&gt;
1197 static ALWAYS_INLINE bool splitStringByOneCharacterImpl(JSGlobalObject* globalObject, JSArray* result, JSValue originalValue, const String&amp; input, StringImpl* string, UChar separatorCharacter, size_t&amp; position, unsigned&amp; resultLength, unsigned limitLength)
1198 {
1199     VM&amp; vm = globalObject-&gt;vm();
1200     auto scope = DECLARE_THROW_SCOPE(vm);
1201 
1202     // 12. Let q = p.
1203     size_t matchPosition;
1204     const CharacterType* characters = string-&gt;characters&lt;CharacterType&gt;();
1205     // 13. Repeat, while q != s
1206     //   a. Call SplitMatch(S, q, R) and let z be its MatchResult result.
1207     //   b. If z is failure, then let q = q+1.
1208     //   c. Else, z is not failure
1209     while ((matchPosition = WTF::find(characters, string-&gt;length(), separatorCharacter, position)) != notFound) {
1210         // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1211         //    through q (exclusive).
1212         // 2. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA),
1213         //    Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
1214         auto* substring = jsSubstring(globalObject, originalValue, input, position, matchPosition - position);
1215         RETURN_IF_EXCEPTION(scope, false);
1216         result-&gt;putDirectIndex(globalObject, resultLength, substring);
1217         RETURN_IF_EXCEPTION(scope, false);
1218         // 3. Increment lengthA by 1.
1219         // 4. If lengthA == lim, return A.
1220         if (++resultLength == limitLength)
1221             return true;
1222 
1223         // 5. Let p = e.
1224         // 8. Let q = p.
1225         position = matchPosition + 1;
1226     }
1227     return false;
1228 }
1229 
1230 // ES 21.1.3.17 String.prototype.split(separator, limit)
1231 EncodedJSValue JSC_HOST_CALL stringProtoFuncSplitFast(JSGlobalObject* globalObject, CallFrame* callFrame)
1232 {
1233     VM&amp; vm = globalObject-&gt;vm();
1234     auto scope = DECLARE_THROW_SCOPE(vm);
1235     JSValue thisValue = callFrame-&gt;thisValue();
1236     ASSERT(checkObjectCoercible(thisValue));
1237 
1238     // 3. Let S be the result of calling ToString, giving it the this value as its argument.
1239     // 7. Let s be the number of characters in S.
1240     String input = thisValue.toWTFString(globalObject);
1241     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1242     ASSERT(!input.isNull());
1243 
1244     // 4. Let A be a new array created as if by the expression new Array()
1245     //    where Array is the standard built-in constructor with that name.
1246     JSArray* result = constructEmptyArray(globalObject, 0);
1247     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1248 
1249     // 5. Let lengthA be 0.
1250     unsigned resultLength = 0;
1251 
1252     // 6. If limit is undefined, let lim = 2^32-1; else let lim = ToUint32(limit).
1253     JSValue limitValue = callFrame-&gt;uncheckedArgument(1);
1254     unsigned limit = limitValue.isUndefined() ? 0xFFFFFFFFu : limitValue.toUInt32(globalObject);
1255     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1256 
1257     // 8. Let p = 0.
1258     size_t position = 0;
1259 
1260     // 9. If separator is a RegExp object (its [[Class]] is &quot;RegExp&quot;), let R = separator;
1261     //    otherwise let R = ToString(separator).
1262     JSValue separatorValue = callFrame-&gt;uncheckedArgument(0);
1263     String separator = separatorValue.toWTFString(globalObject);
1264     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1265 
1266     // 10. If lim == 0, return A.
1267     if (!limit)
1268         return JSValue::encode(result);
1269 
1270     // 11. If separator is undefined, then
1271     if (separatorValue.isUndefined()) {
1272         // a. Call the [[DefineOwnProperty]] internal method of A with arguments &quot;0&quot;,
1273         scope.release();
1274         result-&gt;putDirectIndex(globalObject, 0, jsStringWithReuse(globalObject, thisValue, input));
1275         // b. Return A.
1276         return JSValue::encode(result);
1277     }
1278 
1279     // 12. If s == 0, then
1280     if (input.isEmpty()) {
1281         // a. Let z be SplitMatch(S, 0, R) where S is input, R is separator.
1282         // b. If z is not false, return A.
1283         // c. Call CreateDataProperty(A, &quot;0&quot;, S).
1284         // d. Return A.
1285         if (!separator.isEmpty()) {
1286             scope.release();
1287             result-&gt;putDirectIndex(globalObject, 0, jsStringWithReuse(globalObject, thisValue, input));
1288         }
1289         return JSValue::encode(result);
1290     }
1291 
1292     // Optimized case for splitting on the empty string.
1293     if (separator.isEmpty()) {
1294         limit = std::min(limit, input.length());
1295         // Zero limt/input length handled in steps 9/11 respectively, above.
1296         ASSERT(limit);
1297 
1298         do {
1299             result-&gt;putDirectIndex(globalObject, position, jsSingleCharacterString(vm, input[position]));
1300             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1301         } while (++position &lt; limit);
1302 
1303         return JSValue::encode(result);
1304     }
1305 
1306     // 3 cases:
1307     // -separator length == 1, 8 bits
1308     // -separator length == 1, 16 bits
1309     // -separator length &gt; 1
1310     StringImpl* stringImpl = input.impl();
1311     StringImpl* separatorImpl = separator.impl();
1312     size_t separatorLength = separatorImpl-&gt;length();
1313 
1314     if (separatorLength == 1) {
1315         UChar separatorCharacter;
1316         if (separatorImpl-&gt;is8Bit())
1317             separatorCharacter = separatorImpl-&gt;characters8()[0];
1318         else
1319             separatorCharacter = separatorImpl-&gt;characters16()[0];
1320 
1321         if (stringImpl-&gt;is8Bit()) {
1322             if (splitStringByOneCharacterImpl&lt;LChar&gt;(globalObject, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
1323                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1324         } else {
1325             if (splitStringByOneCharacterImpl&lt;UChar&gt;(globalObject, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
1326                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1327         }
1328         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1329     } else {
1330         // 13. Let q = p.
1331         size_t matchPosition;
1332         // 14. Repeat, while q != s
1333         //   a. let e be SplitMatch(S, q, R).
1334         //   b. If e is failure, then let q = q+1.
1335         //   c. Else, e is an integer index &lt;= s.
1336         while ((matchPosition = stringImpl-&gt;find(separatorImpl, position)) != notFound) {
1337             // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1338             //    through q (exclusive).
1339             // 2. Call CreateDataProperty(A, ToString(lengthA), T).
1340             auto* substring = jsSubstring(globalObject, thisValue, input, position, matchPosition - position);
1341             RETURN_IF_EXCEPTION(scope, { });
1342             result-&gt;putDirectIndex(globalObject, resultLength, substring);
1343             RETURN_IF_EXCEPTION(scope, { });
1344             // 3. Increment lengthA by 1.
1345             // 4. If lengthA == lim, return A.
1346             if (++resultLength == limit)
1347                 return JSValue::encode(result);
1348 
1349             // 5. Let p = e.
1350             // 6. Let q = p.
1351             position = matchPosition + separator.length();
1352         }
1353     }
1354 
1355     // 15. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1356     //     through s (exclusive).
1357     // 16. Call CreateDataProperty(A, ToString(lengthA), T).
1358     auto* substring = jsSubstring(globalObject, thisValue, input, position, input.length() - position);
1359     RETURN_IF_EXCEPTION(scope, { });
1360     scope.release();
1361     result-&gt;putDirectIndex(globalObject, resultLength++, substring);
1362 
1363     // 17. Return A.
1364     return JSValue::encode(result);
1365 }
1366 
1367 static EncodedJSValue stringProtoFuncSubstrImpl(JSGlobalObject* globalObject, CallFrame* callFrame)
1368 {
1369     VM&amp; vm = globalObject-&gt;vm();
1370     auto scope = DECLARE_THROW_SCOPE(vm);
1371 
1372     JSValue thisValue = callFrame-&gt;thisValue();
1373     if (!checkObjectCoercible(thisValue))
1374         return throwVMTypeError(globalObject, scope);
1375     unsigned len;
1376     JSString* jsString = 0;
1377     String uString;
1378     if (thisValue.isString()) {
1379         jsString = asString(thisValue);
1380         len = jsString-&gt;length();
1381     } else {
1382         uString = thisValue.toWTFString(globalObject);
1383         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1384         len = uString.length();
1385     }
1386 
1387     JSValue a0 = callFrame-&gt;argument(0);
1388     JSValue a1 = callFrame-&gt;argument(1);
1389 
1390     double start = a0.toInteger(globalObject);
1391     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1392     double length = a1.isUndefined() ? len : a1.toInteger(globalObject);
1393     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1394     if (start &gt;= len || length &lt;= 0)
1395         return JSValue::encode(jsEmptyString(vm));
1396     if (start &lt; 0) {
1397         start += len;
1398         if (start &lt; 0)
1399             start = 0;
1400     }
1401     if (start + length &gt; len)
1402         length = len - start;
1403     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1404     unsigned substringLength = static_cast&lt;unsigned&gt;(length);
1405     scope.release();
1406     if (jsString)
1407         return JSValue::encode(jsSubstring(globalObject, jsString, substringStart, substringLength));
1408     return JSValue::encode(jsSubstring(vm, uString, substringStart, substringLength));
1409 }
1410 
1411 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(JSGlobalObject* globalObject, CallFrame* callFrame)
1412 {
1413     return stringProtoFuncSubstrImpl(globalObject, callFrame);
1414 }
1415 
1416 EncodedJSValue JSC_HOST_CALL builtinStringSubstrInternal(JSGlobalObject* globalObject, CallFrame* callFrame)
1417 {
1418     // @substrInternal should not have any observable side effects (e.g. it should not call
1419     // GetMethod(..., @@toPrimitive) on the thisValue).
1420 
1421     // It is ok to use the default stringProtoFuncSubstr as the implementation of
1422     // @substrInternal because @substrInternal will only be called by builtins, which will
1423     // guarantee that we only pass it a string thisValue. As a result, stringProtoFuncSubstr
1424     // will not need to call toString() on the thisValue, and there will be no observable
1425     // side-effects.
1426     ASSERT(callFrame-&gt;thisValue().isString());
1427     return stringProtoFuncSubstrImpl(globalObject, callFrame);
1428 }
1429 
1430 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(JSGlobalObject* globalObject, CallFrame* callFrame)
1431 {
1432     VM&amp; vm = globalObject-&gt;vm();
1433     auto scope = DECLARE_THROW_SCOPE(vm);
1434 
1435     JSValue thisValue = callFrame-&gt;thisValue();
1436     if (!checkObjectCoercible(thisValue))
1437         return throwVMTypeError(globalObject, scope);
1438 
1439     JSString* jsString = thisValue.toString(globalObject);
1440     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1441 
1442     JSValue a0 = callFrame-&gt;argument(0);
1443     JSValue a1 = callFrame-&gt;argument(1);
1444     int len = jsString-&gt;length();
1445     RELEASE_ASSERT(len &gt;= 0);
1446 
1447     double start = a0.toNumber(globalObject);
1448     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1449     double end;
1450     if (!(start &gt;= 0)) // check for negative values or NaN
1451         start = 0;
1452     else if (start &gt; len)
1453         start = len;
1454     if (a1.isUndefined())
1455         end = len;
1456     else {
1457         end = a1.toNumber(globalObject);
1458         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1459         if (!(end &gt;= 0)) // check for negative values or NaN
1460             end = 0;
1461         else if (end &gt; len)
1462             end = len;
1463     }
1464     if (start &gt; end) {
1465         double temp = end;
1466         end = start;
1467         start = temp;
1468     }
1469     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1470     unsigned substringLength = static_cast&lt;unsigned&gt;(end) - substringStart;
1471     RELEASE_AND_RETURN(scope, JSValue::encode(jsSubstring(globalObject, jsString, substringStart, substringLength)));
1472 }
1473 
1474 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(JSGlobalObject* globalObject, CallFrame* callFrame)
1475 {
1476     VM&amp; vm = globalObject-&gt;vm();
1477     auto scope = DECLARE_THROW_SCOPE(vm);
1478 
1479     JSValue thisValue = callFrame-&gt;thisValue();
1480     if (!checkObjectCoercible(thisValue))
1481         return throwVMTypeError(globalObject, scope);
1482     JSString* sVal = thisValue.toString(globalObject);
1483     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1484     String s = sVal-&gt;value(globalObject);
1485     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1486     String lowercasedString = s.convertToLowercaseWithoutLocale();
1487     if (lowercasedString.impl() == s.impl())
1488         return JSValue::encode(sVal);
1489     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lowercasedString)));
1490 }
1491 
1492 EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(JSGlobalObject* globalObject, CallFrame* callFrame)
1493 {
1494     VM&amp; vm = globalObject-&gt;vm();
1495     auto scope = DECLARE_THROW_SCOPE(vm);
1496 
1497     JSValue thisValue = callFrame-&gt;thisValue();
1498     if (!checkObjectCoercible(thisValue))
1499         return throwVMTypeError(globalObject, scope);
1500     JSString* sVal = thisValue.toString(globalObject);
1501     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1502     String s = sVal-&gt;value(globalObject);
1503     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1504     String uppercasedString = s.convertToUppercaseWithoutLocale();
1505     if (uppercasedString.impl() == s.impl())
1506         return JSValue::encode(sVal);
1507     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, uppercasedString)));
1508 }
1509 
1510 EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(JSGlobalObject* globalObject, CallFrame* callFrame)
1511 {
1512     // 13.1.1 String.prototype.localeCompare (that [, locales [, options ]]) (ECMA-402 2.0)
1513     // http://ecma-international.org/publications/standards/Ecma-402.htm
1514 
1515     VM&amp; vm = globalObject-&gt;vm();
1516     auto scope = DECLARE_THROW_SCOPE(vm);
1517 
1518     // 1. Let O be RequireObjectCoercible(this value).
1519     JSValue thisValue = callFrame-&gt;thisValue();
1520     if (!checkObjectCoercible(thisValue))
1521         return throwVMTypeError(globalObject, scope, &quot;String.prototype.localeCompare requires that |this| not be null or undefined&quot;_s);
1522 
1523     // 2. Let S be ToString(O).
1524     // 3. ReturnIfAbrupt(S).
1525     String string = thisValue.toWTFString(globalObject);
1526     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1527 
1528     // 4. Let That be ToString(that).
1529     // 5. ReturnIfAbrupt(That).
1530     JSValue thatValue = callFrame-&gt;argument(0);
1531     String that = thatValue.toWTFString(globalObject);
1532     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1533 
1534 #if ENABLE(INTL)
1535     JSValue locales = callFrame-&gt;argument(1);
1536     JSValue options = callFrame-&gt;argument(2);
1537     IntlCollator* collator = nullptr;
1538     if (locales.isUndefined() &amp;&amp; options.isUndefined())
1539         collator = globalObject-&gt;defaultCollator();
1540     else {
1541         collator = IntlCollator::create(vm, globalObject-&gt;collatorStructure());
1542         collator-&gt;initializeCollator(globalObject, locales, options);
1543         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1544     }
1545     RELEASE_AND_RETURN(scope, JSValue::encode(collator-&gt;compareStrings(globalObject, string, that)));
1546 #else
1547     return JSValue::encode(jsNumber(Collator().collate(string, that)));
1548 #endif
1549 }
1550 
1551 #if ENABLE(INTL)
1552 enum class CaseConversionMode {
1553     Upper,
1554     Lower,
1555 };
1556 template&lt;CaseConversionMode mode&gt;
1557 static EncodedJSValue toLocaleCase(JSGlobalObject* globalObject, CallFrame* callFrame)
1558 {
1559     VM&amp; vm = globalObject-&gt;vm();
1560     auto scope = DECLARE_THROW_SCOPE(vm);
1561 
1562     auto convertCase = [&amp;] (auto&amp;&amp;... args) {
1563         if (mode == CaseConversionMode::Lower)
1564             return u_strToLower(std::forward&lt;decltype(args)&gt;(args)...);
1565         return u_strToUpper(std::forward&lt;decltype(args)&gt;(args)...);
1566     };
1567 
1568     // 1. Let O be RequireObjectCoercible(this value).
1569     JSValue thisValue = callFrame-&gt;thisValue();
1570     if (!checkObjectCoercible(thisValue))
1571         return throwVMTypeError(globalObject, scope);
1572 
1573     // 2. Let S be ToString(O).
1574     JSString* sVal = thisValue.toString(globalObject);
1575     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1576     String s = sVal-&gt;value(globalObject);
1577 
1578     // 3. ReturnIfAbrupt(S).
1579     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1580 
1581     // Optimization for empty strings.
1582     if (s.isEmpty())
1583         return JSValue::encode(sVal);
1584 
1585     // 4. Let requestedLocales be CanonicalizeLocaleList(locales).
1586     Vector&lt;String&gt; requestedLocales = canonicalizeLocaleList(globalObject, callFrame-&gt;argument(0));
1587 
1588     // 5. ReturnIfAbrupt(requestedLocales).
1589     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1590 
1591     // 6. Let len be the number of elements in requestedLocales.
1592     size_t len = requestedLocales.size();
1593 
1594     // 7. If len &gt; 0, then
1595     // a. Let requestedLocale be the first element of requestedLocales.
1596     // 8. Else
1597     // a. Let requestedLocale be DefaultLocale().
1598     String requestedLocale = len &gt; 0 ? requestedLocales.first() : defaultLocale(globalObject);
1599 
1600     // 9. Let noExtensionsLocale be the String value that is requestedLocale with all Unicode locale extension sequences (6.2.1) removed.
1601     String noExtensionsLocale = removeUnicodeLocaleExtension(requestedLocale);
1602 
1603     // 10. Let availableLocales be a List with the language tags of the languages for which the Unicode character database contains language sensitive case mappings.
1604     // Note 1: As of Unicode 5.1, the availableLocales list contains the elements &quot;az&quot;, &quot;lt&quot;, and &quot;tr&quot;.
1605     const HashSet&lt;String&gt; availableLocales({ &quot;az&quot;_s, &quot;lt&quot;_s, &quot;tr&quot;_s });
1606 
1607     // 11. Let locale be BestAvailableLocale(availableLocales, noExtensionsLocale).
1608     String locale = bestAvailableLocale(availableLocales, noExtensionsLocale);
1609 
1610     // 12. If locale is undefined, let locale be &quot;und&quot;.
1611     if (locale.isNull())
1612         locale = &quot;und&quot;_s;
1613 
1614     CString utf8LocaleBuffer = locale.utf8();
1615     const StringView view(s);
1616     const int32_t viewLength = view.length();
1617 
1618     // Delegate the following steps to icu u_strToLower or u_strToUpper.
1619     // 13. Let cpList be a List containing in order the code points of S as defined in ES2015, 6.1.4, starting at the first element of S.
1620     // 14. For each code point c in cpList, if the Unicode Character Database provides a lower(/upper) case equivalent of c that is either language insensitive or for the language locale, then replace c in cpList with that/those equivalent code point(s).
1621     // 15. Let cuList be a new List.
1622     // 16. For each code point c in cpList, in order, append to cuList the elements of the UTF-16 Encoding (defined in ES2015, 6.1.4) of c.
1623     // 17. Let L be a String whose elements are, in order, the elements of cuList.
1624 
1625     // Most strings lower/upper case will be the same size as original, so try that first.
1626     UErrorCode error(U_ZERO_ERROR);
1627     Vector&lt;UChar&gt; buffer(viewLength);
1628     String lower;
1629     const int32_t resultLength = convertCase(buffer.data(), viewLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1630     if (U_SUCCESS(error))
1631         lower = String(buffer.data(), resultLength);
1632     else if (error == U_BUFFER_OVERFLOW_ERROR) {
1633         // Converted case needs more space than original. Try again.
1634         UErrorCode error(U_ZERO_ERROR);
1635         Vector&lt;UChar&gt; buffer(resultLength);
1636         convertCase(buffer.data(), resultLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1637         if (U_FAILURE(error))
1638             return throwVMTypeError(globalObject, scope, u_errorName(error));
1639         lower = String(buffer.data(), resultLength);
1640     } else
1641         return throwVMTypeError(globalObject, scope, u_errorName(error));
1642 
1643     // 18. Return L.
1644     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lower)));
1645 }
1646 
1647 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(JSGlobalObject* globalObject, CallFrame* callFrame)
1648 {
1649     // 13.1.2 String.prototype.toLocaleLowerCase ([locales])
1650     // http://ecma-international.org/publications/standards/Ecma-402.htm
1651     return toLocaleCase&lt;CaseConversionMode::Lower&gt;(globalObject, callFrame);
1652 }
1653 
1654 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(JSGlobalObject* globalObject, CallFrame* callFrame)
1655 {
1656     // 13.1.3 String.prototype.toLocaleUpperCase ([locales])
1657     // http://ecma-international.org/publications/standards/Ecma-402.htm
1658     // This function interprets a string value as a sequence of code points, as described in ES2015, 6.1.4. This function behaves in exactly the same way as String.prototype.toLocaleLowerCase, except that characters are mapped to their uppercase equivalents as specified in the Unicode character database.
1659     return toLocaleCase&lt;CaseConversionMode::Upper&gt;(globalObject,callFrame);
1660 }
1661 #endif // ENABLE(INTL)
1662 
1663 enum {
1664     TrimStart = 1,
1665     TrimEnd = 2
1666 };
1667 
1668 static inline JSValue trimString(JSGlobalObject* globalObject, JSValue thisValue, int trimKind)
1669 {
1670     VM&amp; vm = globalObject-&gt;vm();
1671     auto scope = DECLARE_THROW_SCOPE(vm);
1672 
1673     if (!checkObjectCoercible(thisValue))
1674         return throwTypeError(globalObject, scope);
1675     String str = thisValue.toWTFString(globalObject);
1676     RETURN_IF_EXCEPTION(scope, { });
1677 
1678     unsigned left = 0;
1679     if (trimKind &amp; TrimStart) {
1680         while (left &lt; str.length() &amp;&amp; isStrWhiteSpace(str[left]))
1681             left++;
1682     }
1683     unsigned right = str.length();
1684     if (trimKind &amp; TrimEnd) {
1685         while (right &gt; left &amp;&amp; isStrWhiteSpace(str[right - 1]))
1686             right--;
1687     }
1688 
1689     // Don&#39;t gc allocate a new string if we don&#39;t have to.
1690     if (left == 0 &amp;&amp; right == str.length() &amp;&amp; thisValue.isString())
1691         return thisValue;
1692 
1693     RELEASE_AND_RETURN(scope, jsString(vm, str.substringSharingImpl(left, right - left)));
1694 }
1695 
1696 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(JSGlobalObject* globalObject, CallFrame* callFrame)
1697 {
1698     JSValue thisValue = callFrame-&gt;thisValue();
1699     return JSValue::encode(trimString(globalObject, thisValue, TrimStart | TrimEnd));
1700 }
1701 
1702 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(JSGlobalObject* globalObject, CallFrame* callFrame)
1703 {
1704     JSValue thisValue = callFrame-&gt;thisValue();
1705     return JSValue::encode(trimString(globalObject, thisValue, TrimStart));
1706 }
1707 
1708 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(JSGlobalObject* globalObject, CallFrame* callFrame)
1709 {
1710     JSValue thisValue = callFrame-&gt;thisValue();
1711     return JSValue::encode(trimString(globalObject, thisValue, TrimEnd));
1712 }
1713 
1714 static inline unsigned clampAndTruncateToUnsigned(double value, unsigned min, unsigned max)
1715 {
1716     if (value &lt; min)
1717         return min;
1718     if (value &gt; max)
1719         return max;
1720     return static_cast&lt;unsigned&gt;(value);
1721 }
1722 
1723 EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(JSGlobalObject* globalObject, CallFrame* callFrame)
1724 {
1725     VM&amp; vm = globalObject-&gt;vm();
1726     auto scope = DECLARE_THROW_SCOPE(vm);
1727 
1728     JSValue thisValue = callFrame-&gt;thisValue();
1729     if (!checkObjectCoercible(thisValue))
1730         return throwVMTypeError(globalObject, scope);
1731 
1732     String stringToSearchIn = thisValue.toWTFString(globalObject);
1733     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1734 
1735     JSValue a0 = callFrame-&gt;argument(0);
1736     bool isRegularExpression = isRegExp(vm, globalObject, a0);
1737     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1738     if (isRegularExpression)
1739         return throwVMTypeError(globalObject, scope, &quot;Argument to String.prototype.startsWith cannot be a RegExp&quot;);
1740 
1741     String searchString = a0.toWTFString(globalObject);
1742     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1743 
1744     JSValue positionArg = callFrame-&gt;argument(1);
1745     unsigned start = 0;
1746     if (positionArg.isInt32())
1747         start = std::max(0, positionArg.asInt32());
1748     else {
1749         unsigned length = stringToSearchIn.length();
1750         start = clampAndTruncateToUnsigned(positionArg.toInteger(globalObject), 0, length);
1751         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1752     }
1753 
1754     return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixStartingAt(searchString, start)));
1755 }
1756 
1757 EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(JSGlobalObject* globalObject, CallFrame* callFrame)
1758 {
1759     VM&amp; vm = globalObject-&gt;vm();
1760     auto scope = DECLARE_THROW_SCOPE(vm);
1761 
1762     JSValue thisValue = callFrame-&gt;thisValue();
1763     if (!checkObjectCoercible(thisValue))
1764         return throwVMTypeError(globalObject, scope);
1765 
1766     String stringToSearchIn = thisValue.toWTFString(globalObject);
1767     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1768 
1769     JSValue a0 = callFrame-&gt;argument(0);
1770     bool isRegularExpression = isRegExp(vm, globalObject, a0);
1771     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1772     if (isRegularExpression)
1773         return throwVMTypeError(globalObject, scope, &quot;Argument to String.prototype.endsWith cannot be a RegExp&quot;);
1774 
1775     String searchString = a0.toWTFString(globalObject);
1776     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1777 
1778     unsigned length = stringToSearchIn.length();
1779 
1780     JSValue endPositionArg = callFrame-&gt;argument(1);
1781     unsigned end = length;
1782     if (endPositionArg.isInt32())
1783         end = std::max(0, endPositionArg.asInt32());
1784     else if (!endPositionArg.isUndefined()) {
1785         end = clampAndTruncateToUnsigned(endPositionArg.toInteger(globalObject), 0, length);
1786         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1787     }
1788 
1789     return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixEndingAt(searchString, std::min(end, length))));
1790 }
1791 
1792 static EncodedJSValue stringIncludesImpl(JSGlobalObject* globalObject, VM&amp; vm, String stringToSearchIn, String searchString, JSValue positionArg)
1793 {
1794     auto scope = DECLARE_THROW_SCOPE(vm);
1795     unsigned start = 0;
1796     if (positionArg.isInt32())
1797         start = std::max(0, positionArg.asInt32());
1798     else {
1799         unsigned length = stringToSearchIn.length();
1800         start = clampAndTruncateToUnsigned(positionArg.toInteger(globalObject), 0, length);
1801         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1802     }
1803 
1804     return JSValue::encode(jsBoolean(stringToSearchIn.find(searchString, start) != notFound));
1805 }
1806 
1807 EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(JSGlobalObject* globalObject, CallFrame* callFrame)
1808 {
1809     VM&amp; vm = globalObject-&gt;vm();
1810     auto scope = DECLARE_THROW_SCOPE(vm);
1811 
1812     JSValue thisValue = callFrame-&gt;thisValue();
1813     if (!checkObjectCoercible(thisValue))
1814         return throwVMTypeError(globalObject, scope);
1815 
1816     String stringToSearchIn = thisValue.toWTFString(globalObject);
1817     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1818 
1819     JSValue a0 = callFrame-&gt;argument(0);
1820     bool isRegularExpression = isRegExp(vm, globalObject, a0);
1821     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1822     if (isRegularExpression)
1823         return throwVMTypeError(globalObject, scope, &quot;Argument to String.prototype.includes cannot be a RegExp&quot;);
1824 
1825     String searchString = a0.toWTFString(globalObject);
1826     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1827 
1828     JSValue positionArg = callFrame-&gt;argument(1);
1829 
1830     RELEASE_AND_RETURN(scope, stringIncludesImpl(globalObject, vm, stringToSearchIn, searchString, positionArg));
1831 }
1832 
1833 EncodedJSValue JSC_HOST_CALL builtinStringIncludesInternal(JSGlobalObject* globalObject, CallFrame* callFrame)
1834 {
1835     VM&amp; vm = globalObject-&gt;vm();
1836     auto scope = DECLARE_THROW_SCOPE(vm);
1837 
1838     JSValue thisValue = callFrame-&gt;thisValue();
1839     ASSERT(checkObjectCoercible(thisValue));
1840 
1841     String stringToSearchIn = thisValue.toWTFString(globalObject);
1842     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1843 
1844     JSValue a0 = callFrame-&gt;uncheckedArgument(0);
1845     String searchString = a0.toWTFString(globalObject);
1846     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1847 
1848     JSValue positionArg = callFrame-&gt;argument(1);
1849 
1850     RELEASE_AND_RETURN(scope, stringIncludesImpl(globalObject, vm, stringToSearchIn, searchString, positionArg));
1851 }
1852 
1853 EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(JSGlobalObject* globalObject, CallFrame* callFrame)
1854 {
1855     VM&amp; vm = globalObject-&gt;vm();
1856     auto scope = DECLARE_THROW_SCOPE(vm);
1857 
1858     JSValue thisValue = callFrame-&gt;thisValue();
1859     if (!checkObjectCoercible(thisValue))
1860         return throwVMTypeError(globalObject, scope);
1861     JSString* string = thisValue.toString(globalObject);
1862     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1863     return JSValue::encode(JSStringIterator::create(vm, globalObject-&gt;stringIteratorStructure(), string));
1864 }
1865 
1866 enum class NormalizationForm { NFC, NFD, NFKC, NFKD };
1867 
1868 static constexpr bool normalizationAffects8Bit(NormalizationForm form)
1869 {
1870     switch (form) {
1871     case NormalizationForm::NFC:
1872         return false;
1873     case NormalizationForm::NFD:
1874         return true;
1875     case NormalizationForm::NFKC:
1876         return false;
1877     case NormalizationForm::NFKD:
1878         return true;
1879     default:
1880         ASSERT_NOT_REACHED();
1881     }
1882     return true;
1883 }
1884 
1885 static const UNormalizer2* normalizer(NormalizationForm form)
1886 {
1887     UErrorCode status = U_ZERO_ERROR;
1888     const UNormalizer2* normalizer = nullptr;
1889     switch (form) {
1890     case NormalizationForm::NFC:
1891         normalizer = unorm2_getNFCInstance(&amp;status);
1892         break;
1893     case NormalizationForm::NFD:
1894         normalizer = unorm2_getNFDInstance(&amp;status);
1895         break;
1896     case NormalizationForm::NFKC:
1897         normalizer = unorm2_getNFKCInstance(&amp;status);
1898         break;
1899     case NormalizationForm::NFKD:
1900         normalizer = unorm2_getNFKDInstance(&amp;status);
1901         break;
1902     }
1903     ASSERT(normalizer);
1904     ASSERT(U_SUCCESS(status));
1905     return normalizer;
1906 }
1907 
1908 static JSValue normalize(JSGlobalObject* globalObject, JSString* string, NormalizationForm form)
1909 {
1910     VM&amp; vm = globalObject-&gt;vm();
1911     auto scope = DECLARE_THROW_SCOPE(vm);
1912 
1913     auto viewWithString = string-&gt;viewWithUnderlyingString(globalObject);
1914     RETURN_IF_EXCEPTION(scope, { });
1915 
1916     StringView view = viewWithString.view;
1917     if (view.is8Bit() &amp;&amp; (!normalizationAffects8Bit(form) || charactersAreAllASCII(view.characters8(), view.length())))
1918         RELEASE_AND_RETURN(scope, string);
1919 
1920     const UNormalizer2* normalizer = JSC::normalizer(form);
1921 
1922     // Since ICU does not offer functions that can perform normalization or check for
1923     // normalization with input that is Latin-1, we need to upconvert to UTF-16 at this point.
1924     auto characters = view.upconvertedCharacters();
1925 
1926     UErrorCode status = U_ZERO_ERROR;
1927     UBool isNormalized = unorm2_isNormalized(normalizer, characters, view.length(), &amp;status);
1928     ASSERT(U_SUCCESS(status));
1929     if (isNormalized)
1930         RELEASE_AND_RETURN(scope, string);
1931 
1932     int32_t normalizedStringLength = unorm2_normalize(normalizer, characters, view.length(), nullptr, 0, &amp;status);
1933     ASSERT(status == U_BUFFER_OVERFLOW_ERROR);
1934 
1935     UChar* buffer;
1936     auto result = StringImpl::tryCreateUninitialized(normalizedStringLength, buffer);
1937     if (!result)
1938         return throwOutOfMemoryError(globalObject, scope);
1939 
1940     status = U_ZERO_ERROR;
1941     unorm2_normalize(normalizer, characters, view.length(), buffer, normalizedStringLength, &amp;status);
1942     ASSERT(U_SUCCESS(status));
1943 
1944     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(result)));
1945 }
1946 
1947 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(JSGlobalObject* globalObject, CallFrame* callFrame)
1948 {
1949     VM&amp; vm = globalObject-&gt;vm();
1950     auto scope = DECLARE_THROW_SCOPE(vm);
1951 
1952     JSValue thisValue = callFrame-&gt;thisValue();
1953     if (!checkObjectCoercible(thisValue))
1954         return throwVMTypeError(globalObject, scope);
1955     JSString* string = thisValue.toString(globalObject);
1956     RETURN_IF_EXCEPTION(scope, { });
1957 
1958     auto form = NormalizationForm::NFC;
1959     JSValue formValue = callFrame-&gt;argument(0);
1960     if (!formValue.isUndefined()) {
1961         String formString = formValue.toWTFString(globalObject);
1962         RETURN_IF_EXCEPTION(scope, { });
1963 
1964         if (formString == &quot;NFC&quot;)
1965             form = NormalizationForm::NFC;
1966         else if (formString == &quot;NFD&quot;)
1967             form = NormalizationForm::NFD;
1968         else if (formString == &quot;NFKC&quot;)
1969             form = NormalizationForm::NFKC;
1970         else if (formString == &quot;NFKD&quot;)
1971             form = NormalizationForm::NFKD;
1972         else
1973             return throwVMRangeError(globalObject, scope, &quot;argument does not match any normalization form&quot;_s);
1974     }
1975 
1976     RELEASE_AND_RETURN(scope, JSValue::encode(normalize(globalObject, string, form)));
1977 }
1978 
1979 } // namespace JSC
    </pre>
  </body>
</html>
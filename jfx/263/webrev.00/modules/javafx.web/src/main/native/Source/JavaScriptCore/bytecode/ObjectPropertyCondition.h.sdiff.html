<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ObjectPropertyCondition.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ObjectPropertyCondition.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectPropertyConditionSet.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ObjectPropertyCondition.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
105         return absenceOfSetEffectWithoutBarrier(object, uid, prototype);
106     }
107 
108     static ObjectPropertyCondition equivalenceWithoutBarrier(
109         JSObject* object, UniquedStringImpl* uid, JSValue value)
110     {
111         ObjectPropertyCondition result;
112         result.m_object = object;
113         result.m_condition = PropertyCondition::equivalenceWithoutBarrier(uid, value);
114         return result;
115     }
116 
117     static ObjectPropertyCondition equivalence(
118         VM&amp; vm, JSCell* owner, JSObject* object, UniquedStringImpl* uid, JSValue value)
119     {
120         if (owner)
121             vm.heap.writeBarrier(owner);
122         return equivalenceWithoutBarrier(object, uid, value);
123     }
124 











125     static ObjectPropertyCondition hasPrototypeWithoutBarrier(JSObject* object, JSObject* prototype)
126     {
127         ObjectPropertyCondition result;
128         result.m_object = object;
129         result.m_condition = PropertyCondition::hasPrototypeWithoutBarrier(prototype);
130         return result;
131     }
132 
133     static ObjectPropertyCondition hasPrototype(
134         VM&amp; vm, JSCell* owner, JSObject* object, JSObject* prototype)
135     {
136         if (owner)
137             vm.heap.writeBarrier(owner);
138         return hasPrototypeWithoutBarrier(object, prototype);
139     }
140 
141     explicit operator bool() const { return !!m_condition; }
142 
143     JSObject* object() const { return m_object; }
144     PropertyCondition condition() const { return m_condition; }
</pre>
<hr />
<pre>
176     // Two conditions are compatible if they are identical or if they speak of different uids or
177     // different objects. If false is returned, you have to decide how to resolve the conflict -
178     // for example if there is a Presence and an Equivalence then in some cases you&#39;ll want the
179     // more general of the two while in other cases you&#39;ll want the more specific of the two. This
180     // will also return false for contradictions, like Presence and Absence on the same
181     // object/uid. By convention, invalid conditions aren&#39;t compatible with anything.
182     bool isCompatibleWith(const ObjectPropertyCondition&amp; other) const
183     {
184         if (!*this || !other)
185             return false;
186         return *this == other || uid() != other.uid() || object() != other.object();
187     }
188 
189     // These validity-checking methods can optionally take a Struture* instead of loading the
190     // Structure* from the object. If you&#39;re in the concurrent JIT, then you must use the forms
191     // that take an explicit Structure* because you want the compiler to optimize for the same
192     // structure that you validated (i.e. avoid a TOCTOU race).
193 
194     // Checks if the object&#39;s structure claims that the property won&#39;t be intercepted. Validity
195     // does not require watchpoints on the object.
<span class="line-removed">196     bool structureEnsuresValidityAssumingImpurePropertyWatchpoint(Structure*) const;</span>
197     bool structureEnsuresValidityAssumingImpurePropertyWatchpoint() const;
198 
199     // Returns true if we need an impure property watchpoint to ensure validity even if
200     // isStillValidAccordingToStructure() returned true.
201     bool validityRequiresImpurePropertyWatchpoint(Structure*) const;
202     bool validityRequiresImpurePropertyWatchpoint() const;
203 
204     // Checks if the condition still holds setting aside the need for an impure property watchpoint.
205     // Validity might still require watchpoints on the object.
206     bool isStillValidAssumingImpurePropertyWatchpoint(Structure*) const;
207     bool isStillValidAssumingImpurePropertyWatchpoint() const;
208 
209     // Checks if the condition still holds. May conservatively return false, if the object and
210     // structure alone don&#39;t guarantee the condition. Note that this may return true if the
211     // condition still requires some watchpoints on the object in addition to checking the
212     // structure. If you want to check if the condition holds by using the structure alone,
213     // use structureEnsuresValidity().
214     bool isStillValid(Structure*) const;
215     bool isStillValid() const;
216 
217     // Shorthand for condition().isStillValid(structure).
218     bool structureEnsuresValidity(Structure*) const;
219     bool structureEnsuresValidity() const;
220 
221     // This means that it&#39;s still valid and we could enforce validity by setting a transition
222     // watchpoint on the structure and possibly an impure property watchpoint.
223     bool isWatchableAssumingImpurePropertyWatchpoint(
224         Structure*,
225         PropertyCondition::WatchabilityEffort = PropertyCondition::MakeNoChanges) const;
226     bool isWatchableAssumingImpurePropertyWatchpoint(
227         PropertyCondition::WatchabilityEffort = PropertyCondition::MakeNoChanges) const;
228 
229     // This means that it&#39;s still valid and we could enforce validity by setting a transition
<span class="line-modified">230     // watchpoint on the structure.</span>
231     bool isWatchable(
232         Structure*,
233         PropertyCondition::WatchabilityEffort = PropertyCondition::MakeNoChanges) const;
234     bool isWatchable(
235         PropertyCondition::WatchabilityEffort = PropertyCondition::MakeNoChanges) const;
236 
237     bool watchingRequiresStructureTransitionWatchpoint() const
238     {
239         return condition().watchingRequiresStructureTransitionWatchpoint();
240     }
241     bool watchingRequiresReplacementWatchpoint() const
242     {
243         return condition().watchingRequiresReplacementWatchpoint();
244     }
245 







246     // This means that the objects involved in this are still live.
247     bool isStillLive(VM&amp;) const;
248 
249     void validateReferences(const TrackedReferences&amp;) const;
250 
251     bool isValidValueForPresence(VM&amp; vm, JSValue value) const
252     {
253         return condition().isValidValueForPresence(vm, value);
254     }
255 
256     ObjectPropertyCondition attemptToMakeEquivalenceWithoutBarrier(VM&amp;) const;
257 
258 private:
259     JSObject* m_object;
260     PropertyCondition m_condition;
261 };
262 
263 struct ObjectPropertyConditionHash {
264     static unsigned hash(const ObjectPropertyCondition&amp; key) { return key.hash(); }
265     static bool equal(
266         const ObjectPropertyCondition&amp; a, const ObjectPropertyCondition&amp; b)
267     {
268         return a == b;
269     }
<span class="line-modified">270     static const bool safeToCompareToEmptyOrDeleted = true;</span>
271 };
272 
273 } // namespace JSC
274 
275 namespace WTF {
276 
277 template&lt;typename T&gt; struct DefaultHash;
278 template&lt;&gt; struct DefaultHash&lt;JSC::ObjectPropertyCondition&gt; {
279     typedef JSC::ObjectPropertyConditionHash Hash;
280 };
281 
282 template&lt;typename T&gt; struct HashTraits;
283 template&lt;&gt; struct HashTraits&lt;JSC::ObjectPropertyCondition&gt; : SimpleClassHashTraits&lt;JSC::ObjectPropertyCondition&gt; { };
284 
285 } // namespace WTF
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
105         return absenceOfSetEffectWithoutBarrier(object, uid, prototype);
106     }
107 
108     static ObjectPropertyCondition equivalenceWithoutBarrier(
109         JSObject* object, UniquedStringImpl* uid, JSValue value)
110     {
111         ObjectPropertyCondition result;
112         result.m_object = object;
113         result.m_condition = PropertyCondition::equivalenceWithoutBarrier(uid, value);
114         return result;
115     }
116 
117     static ObjectPropertyCondition equivalence(
118         VM&amp; vm, JSCell* owner, JSObject* object, UniquedStringImpl* uid, JSValue value)
119     {
120         if (owner)
121             vm.heap.writeBarrier(owner);
122         return equivalenceWithoutBarrier(object, uid, value);
123     }
124 
<span class="line-added">125     static ObjectPropertyCondition customFunctionEquivalence(</span>
<span class="line-added">126         VM&amp; vm, JSCell* owner, JSObject* object, UniquedStringImpl* uid)</span>
<span class="line-added">127     {</span>
<span class="line-added">128         ObjectPropertyCondition result;</span>
<span class="line-added">129         result.m_object = object;</span>
<span class="line-added">130         result.m_condition = PropertyCondition::customFunctionEquivalence(uid);</span>
<span class="line-added">131         if (owner)</span>
<span class="line-added">132             vm.heap.writeBarrier(owner);</span>
<span class="line-added">133         return result;</span>
<span class="line-added">134     }</span>
<span class="line-added">135 </span>
136     static ObjectPropertyCondition hasPrototypeWithoutBarrier(JSObject* object, JSObject* prototype)
137     {
138         ObjectPropertyCondition result;
139         result.m_object = object;
140         result.m_condition = PropertyCondition::hasPrototypeWithoutBarrier(prototype);
141         return result;
142     }
143 
144     static ObjectPropertyCondition hasPrototype(
145         VM&amp; vm, JSCell* owner, JSObject* object, JSObject* prototype)
146     {
147         if (owner)
148             vm.heap.writeBarrier(owner);
149         return hasPrototypeWithoutBarrier(object, prototype);
150     }
151 
152     explicit operator bool() const { return !!m_condition; }
153 
154     JSObject* object() const { return m_object; }
155     PropertyCondition condition() const { return m_condition; }
</pre>
<hr />
<pre>
187     // Two conditions are compatible if they are identical or if they speak of different uids or
188     // different objects. If false is returned, you have to decide how to resolve the conflict -
189     // for example if there is a Presence and an Equivalence then in some cases you&#39;ll want the
190     // more general of the two while in other cases you&#39;ll want the more specific of the two. This
191     // will also return false for contradictions, like Presence and Absence on the same
192     // object/uid. By convention, invalid conditions aren&#39;t compatible with anything.
193     bool isCompatibleWith(const ObjectPropertyCondition&amp; other) const
194     {
195         if (!*this || !other)
196             return false;
197         return *this == other || uid() != other.uid() || object() != other.object();
198     }
199 
200     // These validity-checking methods can optionally take a Struture* instead of loading the
201     // Structure* from the object. If you&#39;re in the concurrent JIT, then you must use the forms
202     // that take an explicit Structure* because you want the compiler to optimize for the same
203     // structure that you validated (i.e. avoid a TOCTOU race).
204 
205     // Checks if the object&#39;s structure claims that the property won&#39;t be intercepted. Validity
206     // does not require watchpoints on the object.

207     bool structureEnsuresValidityAssumingImpurePropertyWatchpoint() const;
208 
209     // Returns true if we need an impure property watchpoint to ensure validity even if
210     // isStillValidAccordingToStructure() returned true.
211     bool validityRequiresImpurePropertyWatchpoint(Structure*) const;
212     bool validityRequiresImpurePropertyWatchpoint() const;
213 
214     // Checks if the condition still holds setting aside the need for an impure property watchpoint.
215     // Validity might still require watchpoints on the object.
216     bool isStillValidAssumingImpurePropertyWatchpoint(Structure*) const;
217     bool isStillValidAssumingImpurePropertyWatchpoint() const;
218 
219     // Checks if the condition still holds. May conservatively return false, if the object and
220     // structure alone don&#39;t guarantee the condition. Note that this may return true if the
221     // condition still requires some watchpoints on the object in addition to checking the
222     // structure. If you want to check if the condition holds by using the structure alone,
223     // use structureEnsuresValidity().
224     bool isStillValid(Structure*) const;
225     bool isStillValid() const;
226 
227     // Shorthand for condition().isStillValid(structure).
228     bool structureEnsuresValidity(Structure*) const;
229     bool structureEnsuresValidity() const;
230 
231     // This means that it&#39;s still valid and we could enforce validity by setting a transition
232     // watchpoint on the structure and possibly an impure property watchpoint.
233     bool isWatchableAssumingImpurePropertyWatchpoint(
234         Structure*,
235         PropertyCondition::WatchabilityEffort = PropertyCondition::MakeNoChanges) const;
236     bool isWatchableAssumingImpurePropertyWatchpoint(
237         PropertyCondition::WatchabilityEffort = PropertyCondition::MakeNoChanges) const;
238 
239     // This means that it&#39;s still valid and we could enforce validity by setting a transition
<span class="line-modified">240     // watchpoint on the structure, and a value change watchpoint if we&#39;re Equivalence.</span>
241     bool isWatchable(
242         Structure*,
243         PropertyCondition::WatchabilityEffort = PropertyCondition::MakeNoChanges) const;
244     bool isWatchable(
245         PropertyCondition::WatchabilityEffort = PropertyCondition::MakeNoChanges) const;
246 
247     bool watchingRequiresStructureTransitionWatchpoint() const
248     {
249         return condition().watchingRequiresStructureTransitionWatchpoint();
250     }
251     bool watchingRequiresReplacementWatchpoint() const
252     {
253         return condition().watchingRequiresReplacementWatchpoint();
254     }
255 
<span class="line-added">256     template&lt;typename Functor&gt;</span>
<span class="line-added">257     void forEachDependentCell(const Functor&amp; functor) const</span>
<span class="line-added">258     {</span>
<span class="line-added">259         functor(m_object);</span>
<span class="line-added">260         m_condition.forEachDependentCell(functor);</span>
<span class="line-added">261     }</span>
<span class="line-added">262 </span>
263     // This means that the objects involved in this are still live.
264     bool isStillLive(VM&amp;) const;
265 
266     void validateReferences(const TrackedReferences&amp;) const;
267 
268     bool isValidValueForPresence(VM&amp; vm, JSValue value) const
269     {
270         return condition().isValidValueForPresence(vm, value);
271     }
272 
273     ObjectPropertyCondition attemptToMakeEquivalenceWithoutBarrier(VM&amp;) const;
274 
275 private:
276     JSObject* m_object;
277     PropertyCondition m_condition;
278 };
279 
280 struct ObjectPropertyConditionHash {
281     static unsigned hash(const ObjectPropertyCondition&amp; key) { return key.hash(); }
282     static bool equal(
283         const ObjectPropertyCondition&amp; a, const ObjectPropertyCondition&amp; b)
284     {
285         return a == b;
286     }
<span class="line-modified">287     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
288 };
289 
290 } // namespace JSC
291 
292 namespace WTF {
293 
294 template&lt;typename T&gt; struct DefaultHash;
295 template&lt;&gt; struct DefaultHash&lt;JSC::ObjectPropertyCondition&gt; {
296     typedef JSC::ObjectPropertyConditionHash Hash;
297 };
298 
299 template&lt;typename T&gt; struct HashTraits;
300 template&lt;&gt; struct HashTraits&lt;JSC::ObjectPropertyCondition&gt; : SimpleClassHashTraits&lt;JSC::ObjectPropertyCondition&gt; { };
301 
302 } // namespace WTF
</pre>
</td>
</tr>
</table>
<center><a href="ObjectPropertyCondition.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectPropertyConditionSet.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
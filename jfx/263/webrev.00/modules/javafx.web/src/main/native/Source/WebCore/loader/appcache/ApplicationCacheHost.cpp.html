<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/appcache/ApplicationCacheHost.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008-2016 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ApplicationCacheHost.h&quot;
 28 
 29 #include &quot;ApplicationCache.h&quot;
 30 #include &quot;ApplicationCacheGroup.h&quot;
 31 #include &quot;ApplicationCacheResource.h&quot;
 32 #include &quot;ContentSecurityPolicy.h&quot;
 33 #include &quot;CustomHeaderFields.h&quot;
 34 #include &quot;DocumentLoader.h&quot;
 35 #include &quot;DOMApplicationCache.h&quot;
 36 #include &quot;EventNames.h&quot;
 37 #include &quot;Frame.h&quot;
 38 #include &quot;FrameLoader.h&quot;
 39 #include &quot;FrameLoaderClient.h&quot;
 40 #include &quot;InspectorInstrumentation.h&quot;
 41 #include &quot;Page.h&quot;
 42 #include &quot;ProgressEvent.h&quot;
 43 #include &quot;ResourceHandle.h&quot;
 44 #include &quot;ResourceRequest.h&quot;
 45 #include &quot;Settings.h&quot;
 46 #include &quot;SubresourceLoader.h&quot;
 47 #include &lt;wtf/FileSystem.h&gt;
 48 #include &lt;wtf/UUID.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 ApplicationCacheHost::ApplicationCacheHost(DocumentLoader&amp; documentLoader)
 53     : m_documentLoader(documentLoader)
 54 {
 55 }
 56 
 57 ApplicationCacheHost::~ApplicationCacheHost()
 58 {
 59     ASSERT(!m_applicationCache || !m_candidateApplicationCacheGroup || m_applicationCache-&gt;group() == m_candidateApplicationCacheGroup);
 60     if (m_applicationCache)
 61         m_applicationCache-&gt;group()-&gt;disassociateDocumentLoader(m_documentLoader);
 62     else if (m_candidateApplicationCacheGroup)
 63         m_candidateApplicationCacheGroup-&gt;disassociateDocumentLoader(m_documentLoader);
 64 }
 65 
 66 ApplicationCacheGroup* ApplicationCacheHost::candidateApplicationCacheGroup() const
 67 {
 68     return m_candidateApplicationCacheGroup.get();
 69 }
 70 
 71 void ApplicationCacheHost::selectCacheWithoutManifest()
 72 {
 73     ASSERT(m_documentLoader.frame());
 74     ApplicationCacheGroup::selectCacheWithoutManifestURL(*m_documentLoader.frame());
 75 }
 76 
 77 void ApplicationCacheHost::selectCacheWithManifest(const URL&amp; manifestURL)
 78 {
 79     ASSERT(m_documentLoader.frame());
 80     ApplicationCacheGroup::selectCache(*m_documentLoader.frame(), manifestURL);
 81 }
 82 
 83 bool ApplicationCacheHost::canLoadMainResource(const ResourceRequest&amp; request)
 84 {
 85     if (!isApplicationCacheEnabled() || isApplicationCacheBlockedForRequest(request))
 86         return false;
 87     return !!ApplicationCacheGroup::cacheForMainRequest(request, &amp;m_documentLoader);
 88 }
 89 
 90 void ApplicationCacheHost::maybeLoadMainResource(const ResourceRequest&amp; request, SubstituteData&amp; substituteData)
 91 {
 92     // Check if this request should be loaded from the application cache
 93     if (!substituteData.isValid() &amp;&amp; isApplicationCacheEnabled() &amp;&amp; !isApplicationCacheBlockedForRequest(request)) {
 94         ASSERT(!m_mainResourceApplicationCache);
 95 
 96         m_mainResourceApplicationCache = ApplicationCacheGroup::cacheForMainRequest(request, &amp;m_documentLoader);
 97 
 98         if (m_mainResourceApplicationCache) {
 99             // Get the resource from the application cache. By definition, cacheForMainRequest() returns a cache that contains the resource.
100             ApplicationCacheResource* resource = m_mainResourceApplicationCache-&gt;resourceForRequest(request);
101 
102             // ApplicationCache resources have fragment identifiers stripped off of their URLs,
103             // but we&#39;ll need to restore that for the SubstituteData.
104             ResourceResponse responseToUse = resource-&gt;response();
105             if (request.url().hasFragmentIdentifier()) {
106                 URL url = responseToUse.url();
107                 url.setFragmentIdentifier(request.url().fragmentIdentifier());
108                 responseToUse.setURL(url);
109             }
110 
111             substituteData = SubstituteData(&amp;resource-&gt;data(),
112                                             URL(),
113                                             responseToUse,
114                                             SubstituteData::SessionHistoryVisibility::Visible);
115         }
116     }
117 }
118 
119 void ApplicationCacheHost::maybeLoadMainResourceForRedirect(const ResourceRequest&amp; request, SubstituteData&amp; substituteData)
120 {
121     ASSERT(status() == UNCACHED);
122     maybeLoadMainResource(request, substituteData);
123 }
124 
125 bool ApplicationCacheHost::maybeLoadFallbackForMainResponse(const ResourceRequest&amp; request, const ResourceResponse&amp; r)
126 {
127     if (r.httpStatusCode() / 100 == 4 || r.httpStatusCode() / 100 == 5) {
128         ASSERT(!m_mainResourceApplicationCache);
129         if (isApplicationCacheEnabled() &amp;&amp; !isApplicationCacheBlockedForRequest(request)) {
130             m_mainResourceApplicationCache = ApplicationCacheGroup::fallbackCacheForMainRequest(request, &amp;m_documentLoader);
131 
132             if (scheduleLoadFallbackResourceFromApplicationCache(m_documentLoader.mainResourceLoader(), m_mainResourceApplicationCache.get()))
133                 return true;
134         }
135     }
136     return false;
137 }
138 
139 bool ApplicationCacheHost::maybeLoadFallbackForMainError(const ResourceRequest&amp; request, const ResourceError&amp; error)
140 {
141     if (!error.isCancellation()) {
142         ASSERT(!m_mainResourceApplicationCache);
143         if (isApplicationCacheEnabled() &amp;&amp; !isApplicationCacheBlockedForRequest(request)) {
144             m_mainResourceApplicationCache = ApplicationCacheGroup::fallbackCacheForMainRequest(request, &amp;m_documentLoader);
145 
146             if (scheduleLoadFallbackResourceFromApplicationCache(m_documentLoader.mainResourceLoader(), m_mainResourceApplicationCache.get()))
147                 return true;
148         }
149     }
150     return false;
151 }
152 
153 void ApplicationCacheHost::mainResourceDataReceived(const char*, int, long long, bool)
154 {
155 }
156 
157 void ApplicationCacheHost::failedLoadingMainResource()
158 {
159     auto* group = m_candidateApplicationCacheGroup.get();
160     if (!group &amp;&amp; m_applicationCache) {
161         if (mainResourceApplicationCache()) {
162             // Even when the main resource is being loaded from an application cache, loading can fail if aborted.
163             return;
164         }
165         group = m_applicationCache-&gt;group();
166     }
167 
168     if (group)
169         group-&gt;failedLoadingMainResource(m_documentLoader);
170 }
171 
172 void ApplicationCacheHost::finishedLoadingMainResource()
173 {
174     auto* group = candidateApplicationCacheGroup();
175     if (!group &amp;&amp; applicationCache() &amp;&amp; !mainResourceApplicationCache())
176         group = applicationCache()-&gt;group();
177 
178     if (group)
179         group-&gt;finishedLoadingMainResource(m_documentLoader);
180 }
181 
182 bool ApplicationCacheHost::maybeLoadResource(ResourceLoader&amp; loader, const ResourceRequest&amp; request, const URL&amp; originalURL)
183 {
184     if (loader.options().applicationCacheMode != ApplicationCacheMode::Use)
185         return false;
186 
187     if (!isApplicationCacheEnabled() &amp;&amp; !isApplicationCacheBlockedForRequest(request))
188         return false;
189 
190     if (request.url() != originalURL)
191         return false;
192 
193 #if ENABLE(SERVICE_WORKER)
194     if (loader.options().serviceWorkerRegistrationIdentifier)
195         return false;
196 #endif
197 
198     ApplicationCacheResource* resource;
199     if (!shouldLoadResourceFromApplicationCache(request, resource))
200         return false;
201 
202     if (resource)
203         m_documentLoader.scheduleSubstituteResourceLoad(loader, *resource);
204     else
205         m_documentLoader.scheduleCannotShowURLError(loader);
206     return true;
207 }
208 
209 bool ApplicationCacheHost::maybeLoadFallbackForRedirect(ResourceLoader* resourceLoader, ResourceRequest&amp; request, const ResourceResponse&amp; redirectResponse)
210 {
211     if (resourceLoader &amp;&amp; resourceLoader-&gt;options().applicationCacheMode != ApplicationCacheMode::Use)
212         return false;
213 
214     if (!redirectResponse.isNull() &amp;&amp; !protocolHostAndPortAreEqual(request.url(), redirectResponse.url())) {
215         if (scheduleLoadFallbackResourceFromApplicationCache(resourceLoader))
216             return true;
217     }
218     return false;
219 }
220 
221 bool ApplicationCacheHost::maybeLoadFallbackForResponse(ResourceLoader* resourceLoader, const ResourceResponse&amp; response)
222 {
223     if (resourceLoader &amp;&amp; resourceLoader-&gt;options().applicationCacheMode != ApplicationCacheMode::Use)
224         return false;
225 
226     if (response.httpStatusCode() / 100 == 4 || response.httpStatusCode() / 100 == 5) {
227         if (scheduleLoadFallbackResourceFromApplicationCache(resourceLoader))
228             return true;
229     }
230     return false;
231 }
232 
233 bool ApplicationCacheHost::maybeLoadFallbackForError(ResourceLoader* resourceLoader, const ResourceError&amp; error)
234 {
235     if (resourceLoader &amp;&amp; resourceLoader-&gt;options().applicationCacheMode != ApplicationCacheMode::Use)
236         return false;
237 
238     if (!error.isCancellation()) {
239         if (resourceLoader == m_documentLoader.mainResourceLoader())
240             return maybeLoadFallbackForMainError(resourceLoader-&gt;request(), error);
241         if (scheduleLoadFallbackResourceFromApplicationCache(resourceLoader))
242             return true;
243     }
244     return false;
245 }
246 
247 URL ApplicationCacheHost::createFileURL(const String&amp; path)
248 {
249     // FIXME: Can we just use fileURLWithFileSystemPath instead?
250 #if USE(CF) &amp;&amp; PLATFORM(WIN)
251     URL url(adoptCF(CFURLCreateWithFileSystemPath(0, path.createCFString().get(), kCFURLWindowsPathStyle, false)).get());
252 #else
253     URL url;
254     url.setProtocol(&quot;file&quot;_s);
255     url.setPath(path);
256 #endif
257     return url;
258 }
259 
260 static inline RefPtr&lt;SharedBuffer&gt; bufferFromResource(ApplicationCacheResource&amp; resource)
261 {
262     // FIXME: Clients probably do not need a copy of the SharedBuffer.
263     // Remove the call to copy() once we ensure SharedBuffer will not be modified.
264     if (resource.path().isEmpty())
265         return resource.data().copy();
266     return SharedBuffer::createWithContentsOfFile(resource.path());
267 }
268 
269 bool ApplicationCacheHost::maybeLoadSynchronously(ResourceRequest&amp; request, ResourceError&amp; error, ResourceResponse&amp; response, RefPtr&lt;SharedBuffer&gt;&amp; data)
270 {
271     ApplicationCacheResource* resource;
272     if (!shouldLoadResourceFromApplicationCache(request, resource))
273         return false;
274 
275     auto responseData = resource ? bufferFromResource(*resource) : nullptr;
276     if (!responseData) {
277         error = m_documentLoader.frameLoader()-&gt;client().cannotShowURLError(request);
278         return true;
279     }
280 
281     response = resource-&gt;response();
282     data = WTFMove(responseData);
283     return true;
284 }
285 
286 void ApplicationCacheHost::maybeLoadFallbackSynchronously(const ResourceRequest&amp; request, ResourceError&amp; error, ResourceResponse&amp; response, RefPtr&lt;SharedBuffer&gt;&amp; data)
287 {
288     // If normal loading results in a redirect to a resource with another origin (indicative of a captive portal), or a 4xx or 5xx status code or equivalent,
289     // or if there were network errors (but not if the user canceled the download), then instead get, from the cache, the resource of the fallback entry
290     // corresponding to the matched namespace.
291     if ((!error.isNull() &amp;&amp; !error.isCancellation())
292          || response.httpStatusCode() / 100 == 4 || response.httpStatusCode() / 100 == 5
293          || !protocolHostAndPortAreEqual(request.url(), response.url())) {
294         ApplicationCacheResource* resource;
295         if (getApplicationCacheFallbackResource(request, resource)) {
296             response = resource-&gt;response();
297             // FIXME: Clients proably do not need a copy of the SharedBuffer.
298             // Remove the call to copy() once we ensure SharedBuffer will not be modified.
299             data = resource-&gt;data().copy();
300         }
301     }
302 }
303 
304 bool ApplicationCacheHost::canCacheInBackForwardCache()
305 {
306     return !applicationCache() &amp;&amp; !candidateApplicationCacheGroup();
307 }
308 
309 void ApplicationCacheHost::setDOMApplicationCache(DOMApplicationCache* domApplicationCache)
310 {
311     ASSERT(!m_domApplicationCache || !domApplicationCache);
312     m_domApplicationCache = makeWeakPtr(domApplicationCache);
313 }
314 
315 void ApplicationCacheHost::notifyDOMApplicationCache(const AtomString&amp; eventType, int total, int done)
316 {
317     if (eventType != eventNames().progressEvent)
318         InspectorInstrumentation::updateApplicationCacheStatus(m_documentLoader.frame());
319 
320     if (m_defersEvents) {
321         // Event dispatching is deferred until document.onload has fired.
322         m_deferredEvents.append({ eventType, total, done });
323         return;
324     }
325 
326     dispatchDOMEvent(eventType, total, done);
327 }
328 
329 void ApplicationCacheHost::stopLoadingInFrame(Frame&amp; frame)
330 {
331     ASSERT(!m_applicationCache || !m_candidateApplicationCacheGroup || m_applicationCache-&gt;group() == m_candidateApplicationCacheGroup);
332 
333     if (m_candidateApplicationCacheGroup)
334         m_candidateApplicationCacheGroup-&gt;stopLoadingInFrame(frame);
335     else if (m_applicationCache)
336         m_applicationCache-&gt;group()-&gt;stopLoadingInFrame(frame);
337 }
338 
339 void ApplicationCacheHost::stopDeferringEvents()
340 {
341     Ref&lt;DocumentLoader&gt; protect(m_documentLoader);
342 
343     // Note, do not cache the size in a local variable.
344     // This code needs to properly handle the case where more events are added to
345     // m_deferredEvents while iterating it. This is why we don&#39;t use a modern for loop.
346     for (size_t i = 0; i &lt; m_deferredEvents.size(); ++i) {
347         auto&amp; event = m_deferredEvents[i];
348         dispatchDOMEvent(event.eventType, event.progressTotal, event.progressDone);
349     }
350 
351     m_deferredEvents.clear();
352     m_defersEvents = false;
353 }
354 
355 Vector&lt;ApplicationCacheHost::ResourceInfo&gt; ApplicationCacheHost::resourceList()
356 {
357     auto* cache = applicationCache();
358     if (!cache || !cache-&gt;isComplete())
359         return { };
360 
361     return WTF::map(cache-&gt;resources(), [] (auto&amp; urlAndResource) -&gt; ApplicationCacheHost::ResourceInfo {
362         ASSERT(urlAndResource.value);
363         auto&amp; resource = *urlAndResource.value;
364 
365         unsigned type = resource.type();
366         bool isMaster = type &amp; ApplicationCacheResource::Master;
367         bool isManifest = type &amp; ApplicationCacheResource::Manifest;
368         bool isExplicit = type &amp; ApplicationCacheResource::Explicit;
369         bool isForeign = type &amp; ApplicationCacheResource::Foreign;
370         bool isFallback = type &amp; ApplicationCacheResource::Fallback;
371 
372         return { resource.url(), isMaster, isManifest, isFallback, isForeign, isExplicit, resource.estimatedSizeInStorage() };
373     });
374 }
375 
376 ApplicationCacheHost::CacheInfo ApplicationCacheHost::applicationCacheInfo()
377 {
378     auto* cache = applicationCache();
379     if (!cache || !cache-&gt;isComplete())
380         return { { }, 0, 0, 0 };
381 
382     // FIXME: Add &quot;Creation Time&quot; and &quot;Update Time&quot; to Application Caches.
383     return { cache-&gt;manifestResource()-&gt;url(), 0, 0, cache-&gt;estimatedSizeInStorage() };
384 }
385 
386 static Ref&lt;Event&gt; createApplicationCacheEvent(const AtomString&amp; eventType, int total, int done)
387 {
388     if (eventType == eventNames().progressEvent)
389         return ProgressEvent::create(eventType, true, done, total);
390     return Event::create(eventType, Event::CanBubble::No, Event::IsCancelable::No);
391 }
392 
393 void ApplicationCacheHost::dispatchDOMEvent(const AtomString&amp; eventType, int total, int done)
394 {
395     if (!m_domApplicationCache || !m_domApplicationCache-&gt;frame())
396         return;
397 
398     m_domApplicationCache-&gt;dispatchEvent(createApplicationCacheEvent(eventType, total, done));
399 }
400 
401 void ApplicationCacheHost::setCandidateApplicationCacheGroup(ApplicationCacheGroup* group)
402 {
403     ASSERT(!m_applicationCache);
404     m_candidateApplicationCacheGroup = makeWeakPtr(group);
405 }
406 
407 void ApplicationCacheHost::setApplicationCache(RefPtr&lt;ApplicationCache&gt;&amp;&amp; applicationCache)
408 {
409     if (m_candidateApplicationCacheGroup) {
410         ASSERT(!m_applicationCache);
411         m_candidateApplicationCacheGroup = nullptr;
412     }
413     m_applicationCache = WTFMove(applicationCache);
414 }
415 
416 bool ApplicationCacheHost::shouldLoadResourceFromApplicationCache(const ResourceRequest&amp; originalRequest, ApplicationCacheResource*&amp; resource)
417 {
418     auto* cache = applicationCache();
419     if (!cache || !cache-&gt;isComplete())
420         return false;
421 
422     ResourceRequest request(originalRequest);
423     if (auto* loaderFrame = m_documentLoader.frame()) {
424         if (auto* document = loaderFrame-&gt;document())
425             document-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(request, ContentSecurityPolicy::InsecureRequestType::Load);
426     }
427 
428     // If the resource is not to be fetched using the HTTP GET mechanism or equivalent, or if its URL has a different
429     // &lt;scheme&gt; component than the application cache&#39;s manifest, then fetch the resource normally.
430     if (!ApplicationCache::requestIsHTTPOrHTTPSGet(request) || !equalIgnoringASCIICase(request.url().protocol(), cache-&gt;manifestResource()-&gt;url().protocol()))
431         return false;
432 
433     // If the resource&#39;s URL is an master entry, the manifest, an explicit entry, or a fallback entry
434     // in the application cache, then get the resource from the cache (instead of fetching it).
435     resource = cache-&gt;resourceForURL(request.url());
436 
437     // Resources that match fallback namespaces or online whitelist entries are fetched from the network,
438     // unless they are also cached.
439     if (!resource &amp;&amp; (cache-&gt;allowsAllNetworkRequests() || cache-&gt;urlMatchesFallbackNamespace(request.url()) || cache-&gt;isURLInOnlineWhitelist(request.url())))
440         return false;
441 
442     // Resources that are not present in the manifest will always fail to load (at least, after the
443     // cache has been primed the first time), making the testing of offline applications simpler.
444     return true;
445 }
446 
447 bool ApplicationCacheHost::getApplicationCacheFallbackResource(const ResourceRequest&amp; request, ApplicationCacheResource*&amp; resource, ApplicationCache* cache)
448 {
449     if (!cache) {
450         cache = applicationCache();
451         if (!cache)
452             return false;
453     }
454     if (!cache-&gt;isComplete())
455         return false;
456 
457     // If the resource is not a HTTP/HTTPS GET, then abort
458     if (!ApplicationCache::requestIsHTTPOrHTTPSGet(request))
459         return false;
460 
461     URL fallbackURL;
462     if (cache-&gt;isURLInOnlineWhitelist(request.url()))
463         return false;
464     if (!cache-&gt;urlMatchesFallbackNamespace(request.url(), &amp;fallbackURL))
465         return false;
466 
467     resource = cache-&gt;resourceForURL(fallbackURL);
468     ASSERT(resource);
469     return true;
470 }
471 
472 bool ApplicationCacheHost::scheduleLoadFallbackResourceFromApplicationCache(ResourceLoader* loader, ApplicationCache* cache)
473 {
474     if (!loader)
475         return false;
476 
477     if (!isApplicationCacheEnabled() &amp;&amp; !isApplicationCacheBlockedForRequest(loader-&gt;request()))
478         return false;
479 
480 #if ENABLE(SERVICE_WORKER)
481     if (loader-&gt;options().serviceWorkerRegistrationIdentifier)
482         return false;
483 #endif
484 
485     ApplicationCacheResource* resource;
486     if (!getApplicationCacheFallbackResource(loader-&gt;request(), resource, cache))
487         return false;
488 
489     loader-&gt;willSwitchToSubstituteResource();
490     m_documentLoader.scheduleSubstituteResourceLoad(*loader, *resource);
491     return true;
492 }
493 
494 ApplicationCacheHost::Status ApplicationCacheHost::status() const
495 {
496     auto* cache = applicationCache();
497     if (!cache)
498         return UNCACHED;
499 
500     switch (cache-&gt;group()-&gt;updateStatus()) {
501     case ApplicationCacheGroup::Checking:
502         return CHECKING;
503     case ApplicationCacheGroup::Downloading:
504         return DOWNLOADING;
505     case ApplicationCacheGroup::Idle:
506         if (cache-&gt;group()-&gt;isObsolete())
507             return OBSOLETE;
508         if (cache != cache-&gt;group()-&gt;newestCache())
509             return UPDATEREADY;
510         return IDLE;
511     }
512 
513     ASSERT_NOT_REACHED();
514     return UNCACHED;
515 }
516 
517 bool ApplicationCacheHost::update()
518 {
519     auto* cache = applicationCache();
520     if (!cache)
521         return false;
522     auto* frame = m_documentLoader.frame();
523     if (!frame)
524         return false;
525     cache-&gt;group()-&gt;update(*frame, ApplicationCacheUpdateWithoutBrowsingContext);
526     return true;
527 }
528 
529 bool ApplicationCacheHost::swapCache()
530 {
531     auto* cache = applicationCache();
532     if (!cache)
533         return false;
534 
535     auto* group = cache-&gt;group();
536     if (!group)
537         return false;
538 
539     // If the group of application caches to which cache belongs has the lifecycle status obsolete, unassociate document from cache.
540     if (group-&gt;isObsolete()) {
541         group-&gt;disassociateDocumentLoader(m_documentLoader);
542         return true;
543     }
544 
545     // If there is no newer cache, raise an InvalidStateError exception.
546     auto* newestCache = group-&gt;newestCache();
547     if (!newestCache || cache == newestCache)
548         return false;
549 
550     ASSERT(group == newestCache-&gt;group());
551     setApplicationCache(newestCache);
552     InspectorInstrumentation::updateApplicationCacheStatus(m_documentLoader.frame());
553     return true;
554 }
555 
556 void ApplicationCacheHost::abort()
557 {
558     auto* frame = m_documentLoader.frame();
559     if (!frame)
560         return;
561     if (auto* cacheGroup = candidateApplicationCacheGroup())
562         cacheGroup-&gt;abort(*frame);
563     else if (auto* cache = applicationCache())
564         cache-&gt;group()-&gt;abort(*frame);
565 }
566 
567 bool ApplicationCacheHost::isApplicationCacheEnabled()
568 {
569     return m_documentLoader.frame() &amp;&amp; m_documentLoader.frame()-&gt;settings().offlineWebApplicationCacheEnabled() &amp;&amp; !m_documentLoader.frame()-&gt;page()-&gt;usesEphemeralSession();
570 }
571 
572 bool ApplicationCacheHost::isApplicationCacheBlockedForRequest(const ResourceRequest&amp; request)
573 {
574     auto* frame = m_documentLoader.frame();
575     if (!frame)
576         return false;
577     if (frame-&gt;isMainFrame())
578         return false;
579     return !SecurityOrigin::create(request.url())-&gt;canAccessApplicationCache(frame-&gt;document()-&gt;topOrigin());
580 }
581 
582 }  // namespace WebCore
    </pre>
  </body>
</html>
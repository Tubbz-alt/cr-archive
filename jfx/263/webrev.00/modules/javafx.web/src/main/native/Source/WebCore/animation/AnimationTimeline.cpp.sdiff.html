<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationTimeline.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AnimationPlaybackEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AnimationTimeline.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationTimeline.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;AnimationTimeline.h&quot;
 29 
 30 #include &quot;Animation.h&quot;
 31 #include &quot;AnimationEffect.h&quot;
 32 #include &quot;AnimationList.h&quot;
 33 #include &quot;CSSAnimation.h&quot;
 34 #include &quot;CSSPropertyAnimation.h&quot;
 35 #include &quot;CSSTransition.h&quot;
 36 #include &quot;DocumentTimeline.h&quot;
 37 #include &quot;Element.h&quot;
 38 #include &quot;KeyframeEffect.h&quot;

 39 #include &quot;RenderStyle.h&quot;
 40 #include &quot;RenderView.h&quot;
 41 #include &quot;StylePropertyShorthand.h&quot;
 42 #include &quot;StyleResolver.h&quot;
 43 #include &quot;WebAnimationUtilities.h&quot;
 44 #include &lt;wtf/text/TextStream.h&gt;
 45 #include &lt;wtf/text/WTFString.h&gt;
 46 
 47 namespace WebCore {
 48 
 49 AnimationTimeline::AnimationTimeline()
 50 {
 51 }
 52 
 53 AnimationTimeline::~AnimationTimeline()
 54 {
 55 }
 56 
 57 void AnimationTimeline::forgetAnimation(WebAnimation* animation)
 58 {
 59     m_allAnimations.removeFirst(animation);
 60 }
 61 
 62 void AnimationTimeline::animationTimingDidChange(WebAnimation&amp; animation)
 63 {


 64     if (m_animations.add(&amp;animation)) {
 65         m_allAnimations.append(makeWeakPtr(&amp;animation));
 66         auto* timeline = animation.timeline();
 67         if (timeline &amp;&amp; timeline != this)
 68             timeline-&gt;removeAnimation(animation);
 69     }
 70 }
 71 







 72 void AnimationTimeline::removeAnimation(WebAnimation&amp; animation)
 73 {
 74     ASSERT(!animation.timeline() || animation.timeline() == this);
 75     m_animations.remove(&amp;animation);
 76     if (is&lt;KeyframeEffect&gt;(animation.effect())) {
<span class="line-modified"> 77         if (auto* target = downcast&lt;KeyframeEffect&gt;(animation.effect())-&gt;target())</span>
 78             animationWasRemovedFromElement(animation, *target);


 79     }
 80 }
 81 
 82 Optional&lt;double&gt; AnimationTimeline::bindingsCurrentTime()
 83 {
 84     auto time = currentTime();
 85     if (!time)
 86         return WTF::nullopt;
 87     return secondsToWebAnimationsAPITime(*time);
 88 }
 89 
 90 void AnimationTimeline::animationWasAddedToElement(WebAnimation&amp; animation, Element&amp; element)
 91 {
 92     [&amp;] () -&gt; ElementToAnimationsMap&amp; {
 93         if (is&lt;CSSTransition&gt;(animation) &amp;&amp; downcast&lt;CSSTransition&gt;(animation).owningElement())
 94             return m_elementToCSSTransitionsMap;
 95         if (is&lt;CSSAnimation&gt;(animation) &amp;&amp; downcast&lt;CSSAnimation&gt;(animation).owningElement())
 96             return m_elementToCSSAnimationsMap;
 97         return m_elementToAnimationsMap;
 98     }().ensure(&amp;element, [] {
<span class="line-modified"> 99         return ListHashSet&lt;RefPtr&lt;WebAnimation&gt;&gt; { };</span>
100     }).iterator-&gt;value.add(&amp;animation);
101 }
102 
103 static inline bool removeCSSTransitionFromMap(CSSTransition&amp; transition, Element&amp; element, HashMap&lt;Element*, AnimationTimeline::PropertyToTransitionMap&gt;&amp; map)
104 {
105     auto iterator = map.find(&amp;element);
106     if (iterator == map.end())
107         return false;
108 
109     auto&amp; cssTransitionsByProperty = iterator-&gt;value;
110 
111     auto transitionIterator = cssTransitionsByProperty.find(transition.property());
112     if (transitionIterator == cssTransitionsByProperty.end() || transitionIterator-&gt;value != &amp;transition)
113         return false;
114 
115     cssTransitionsByProperty.remove(transitionIterator);
116 
117     if (cssTransitionsByProperty.isEmpty())
118         map.remove(&amp;element);
119     return true;
120 }
121 
122 static inline void removeAnimationFromMapForElement(WebAnimation&amp; animation, AnimationTimeline::ElementToAnimationsMap&amp; map, Element&amp; element)
123 {
124     auto iterator = map.find(&amp;element);
125     if (iterator == map.end())
126         return;
127 
128     auto&amp; animations = iterator-&gt;value;
129     animations.remove(&amp;animation);
130     if (!animations.size())
131         map.remove(iterator);
132 }
133 
134 void AnimationTimeline::animationWasRemovedFromElement(WebAnimation&amp; animation, Element&amp; element)
135 {
136     removeAnimationFromMapForElement(animation, m_elementToCSSTransitionsMap, element);
137     removeAnimationFromMapForElement(animation, m_elementToCSSAnimationsMap, element);
138     removeAnimationFromMapForElement(animation, m_elementToAnimationsMap, element);
139 
<span class="line-modified">140     // Now, if we&#39;re dealing with a declarative animation, we remove it from either the m_elementToCSSAnimationByName</span>
<span class="line-modified">141     // or the m_elementToRunningCSSTransitionByCSSPropertyID map, whichever is relevant to this type of animation.</span>
<span class="line-modified">142     if (is&lt;DeclarativeAnimation&gt;(animation))</span>


143         removeDeclarativeAnimationFromListsForOwningElement(animation, element);
144 }
145 
146 void AnimationTimeline::removeDeclarativeAnimationFromListsForOwningElement(WebAnimation&amp; animation, Element&amp; element)
147 {
148     ASSERT(is&lt;DeclarativeAnimation&gt;(animation));
149 
<span class="line-modified">150     if (is&lt;CSSAnimation&gt;(animation)) {</span>
<span class="line-removed">151         auto iterator = m_elementToCSSAnimationByName.find(&amp;element);</span>
<span class="line-removed">152         if (iterator != m_elementToCSSAnimationByName.end()) {</span>
<span class="line-removed">153             auto&amp; cssAnimationsByName = iterator-&gt;value;</span>
<span class="line-removed">154             auto&amp; name = downcast&lt;CSSAnimation&gt;(animation).animationName();</span>
<span class="line-removed">155             cssAnimationsByName.remove(name);</span>
<span class="line-removed">156             if (cssAnimationsByName.isEmpty())</span>
<span class="line-removed">157                 m_elementToCSSAnimationByName.remove(&amp;element);</span>
<span class="line-removed">158         }</span>
<span class="line-removed">159     } else if (is&lt;CSSTransition&gt;(animation)) {</span>
160         auto&amp; transition = downcast&lt;CSSTransition&gt;(animation);
161         if (!removeCSSTransitionFromMap(transition, element, m_elementToRunningCSSTransitionByCSSPropertyID))
162             removeCSSTransitionFromMap(transition, element, m_elementToCompletedCSSTransitionByCSSPropertyID);
163     }
164 }
165 
166 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; AnimationTimeline::animationsForElement(Element&amp; element, Ordering ordering) const
167 {
168     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
<span class="line-modified">169     if (m_elementToCSSTransitionsMap.contains(&amp;element)) {</span>
<span class="line-modified">170         const auto&amp; cssTransitions = m_elementToCSSTransitionsMap.get(&amp;element);</span>
<span class="line-modified">171         if (ordering == Ordering::Sorted) {</span>
<span class="line-modified">172             Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; sortedCSSTransitions;</span>
<span class="line-modified">173             sortedCSSTransitions.appendRange(cssTransitions.begin(), cssTransitions.end());</span>
<span class="line-modified">174             std::sort(sortedCSSTransitions.begin(), sortedCSSTransitions.end(), [](auto&amp; lhs, auto&amp; rhs) {</span>
<span class="line-modified">175                 // Sort transitions first by their generation time, and then by transition-property.</span>
<span class="line-modified">176                 // https://drafts.csswg.org/css-transitions-2/#animation-composite-order</span>
<span class="line-modified">177                 auto* lhsTransition = downcast&lt;CSSTransition&gt;(lhs.get());</span>
<span class="line-removed">178                 auto* rhsTransition = downcast&lt;CSSTransition&gt;(rhs.get());</span>
<span class="line-removed">179                 if (lhsTransition-&gt;generationTime() != rhsTransition-&gt;generationTime())</span>
<span class="line-removed">180                     return lhsTransition-&gt;generationTime() &lt; rhsTransition-&gt;generationTime();</span>
<span class="line-removed">181                 return lhsTransition-&gt;transitionProperty().utf8() &lt; rhsTransition-&gt;transitionProperty().utf8();</span>
<span class="line-removed">182             });</span>
<span class="line-removed">183             animations.appendVector(sortedCSSTransitions);</span>
<span class="line-removed">184         } else</span>
185             animations.appendRange(cssTransitions.begin(), cssTransitions.end());









186     }
<span class="line-modified">187     if (m_elementToCSSAnimationsMap.contains(&amp;element)) {</span>
<span class="line-modified">188         const auto&amp; cssAnimations = m_elementToCSSAnimationsMap.get(&amp;element);</span>
<span class="line-modified">189         animations.appendRange(cssAnimations.begin(), cssAnimations.end());</span>









190     }
<span class="line-modified">191     if (m_elementToAnimationsMap.contains(&amp;element)) {</span>
<span class="line-modified">192         const auto&amp; webAnimations = m_elementToAnimationsMap.get(&amp;element);</span>
<span class="line-modified">193         animations.appendRange(webAnimations.begin(), webAnimations.end());</span>


























194     }
<span class="line-removed">195     return animations;</span>
196 }
197 
198 void AnimationTimeline::elementWasRemoved(Element&amp; element)
199 {
<span class="line-modified">200     for (auto&amp; animation : animationsForElement(element))</span>
<span class="line-modified">201         animation-&gt;cancel(WebAnimation::Silently::Yes);</span>





202 }
203 
204 void AnimationTimeline::removeAnimationsForElement(Element&amp; element)
205 {
206     for (auto&amp; animation : animationsForElement(element))
207         animation-&gt;remove();
208 }
209 






210 void AnimationTimeline::cancelDeclarativeAnimationsForElement(Element&amp; element)
211 {
212     for (auto&amp; cssTransition : m_elementToCSSTransitionsMap.get(&amp;element))
213         cssTransition-&gt;cancel();
<span class="line-modified">214     for (auto&amp; cssAnimation : m_elementToCSSAnimationsMap.get(&amp;element))</span>


215         cssAnimation-&gt;cancel();

216 }
217 
218 static bool shouldConsiderAnimation(Element&amp; element, const Animation&amp; animation)
219 {
220     if (!animation.isValidAnimation())
221         return false;
222 
223     static NeverDestroyed&lt;const String&gt; animationNameNone(MAKE_STATIC_STRING_IMPL(&quot;none&quot;));
224 
225     auto&amp; name = animation.name();
226     if (name == animationNameNone || name.isEmpty())
227         return false;
228 
229     if (auto* styleScope = Style::Scope::forOrdinal(element, animation.nameStyleScopeOrdinal()))
230         return styleScope-&gt;resolver().isAnimationNameValid(name);
231 
232     return false;
233 }
234 
235 void AnimationTimeline::updateCSSAnimationsForElement(Element&amp; element, const RenderStyle* currentStyle, const RenderStyle&amp; afterChangeStyle)
236 {


237     // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its animations and disregard new ones.
<span class="line-modified">238     if (currentStyle &amp;&amp; currentStyle-&gt;hasAnimations() &amp;&amp; currentStyle-&gt;display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {</span>
<span class="line-modified">239         if (m_elementToCSSAnimationByName.contains(&amp;element)) {</span>
<span class="line-modified">240             for (const auto&amp; cssAnimationsByNameMapItem : m_elementToCSSAnimationByName.take(&amp;element))</span>
<span class="line-modified">241                 cancelDeclarativeAnimation(*cssAnimationsByNameMapItem.value);</span>



242         }

243         return;
244     }
245 
<span class="line-modified">246     if (currentStyle &amp;&amp; currentStyle-&gt;hasAnimations() &amp;&amp; afterChangeStyle.hasAnimations() &amp;&amp; *(currentStyle-&gt;animations()) == *(afterChangeStyle.animations()))</span>


247         return;
248 
<span class="line-modified">249     // First, compile the list of animation names that were applied to this element up to this point.</span>
<span class="line-modified">250     HashSet&lt;String&gt; namesOfPreviousAnimations;</span>
<span class="line-modified">251     if (currentStyle &amp;&amp; currentStyle-&gt;hasAnimations()) {</span>
<span class="line-removed">252         auto* previousAnimations = currentStyle-&gt;animations();</span>
<span class="line-removed">253         for (size_t i = 0; i &lt; previousAnimations-&gt;size(); ++i) {</span>
<span class="line-removed">254             auto&amp; previousAnimation = previousAnimations-&gt;animation(i);</span>
<span class="line-removed">255             if (shouldConsiderAnimation(element, previousAnimation))</span>
<span class="line-removed">256                 namesOfPreviousAnimations.add(previousAnimation.name());</span>
<span class="line-removed">257         }</span>
<span class="line-removed">258     }</span>
<span class="line-removed">259 </span>
<span class="line-removed">260     // Create or get the CSSAnimations by animation name map for this element.</span>
<span class="line-removed">261     auto&amp; cssAnimationsByName = m_elementToCSSAnimationByName.ensure(&amp;element, [] {</span>
<span class="line-removed">262         return HashMap&lt;String, RefPtr&lt;CSSAnimation&gt;&gt; { };</span>
263     }).iterator-&gt;value;
264 
<span class="line-modified">265     if (auto* currentAnimations = afterChangeStyle.animations()) {</span>
<span class="line-modified">266         for (size_t i = 0; i &lt; currentAnimations-&gt;size(); ++i) {</span>
<span class="line-modified">267             auto&amp; currentAnimation = currentAnimations-&gt;animation(i);</span>
<span class="line-modified">268             auto&amp; name = currentAnimation.name();</span>
<span class="line-modified">269             if (namesOfPreviousAnimations.contains(name)) {</span>
<span class="line-modified">270                 // We&#39;ve found the name of this animation in our list of previous animations, this means we&#39;ve already</span>
<span class="line-modified">271                 // created a CSSAnimation object for it and need to ensure that this CSSAnimation is backed by the current</span>
<span class="line-modified">272                 // animation object for this animation name.</span>
<span class="line-modified">273                 if (auto cssAnimation = cssAnimationsByName.get(name))</span>
<span class="line-modified">274                     cssAnimation-&gt;setBackingAnimation(currentAnimation);</span>
<span class="line-modified">275             } else if (shouldConsiderAnimation(element, currentAnimation)) {</span>
<span class="line-modified">276                 // Otherwise we are dealing with a new animation name and must create a CSSAnimation for it.</span>
<span class="line-modified">277                 cssAnimationsByName.set(name, CSSAnimation::create(element, currentAnimation, currentStyle, afterChangeStyle));</span>














278             }
<span class="line-modified">279             // Remove the name of this animation from our list since it&#39;s now known to be current.</span>
<span class="line-modified">280             namesOfPreviousAnimations.remove(name);</span>

281         }
282     }
283 
<span class="line-modified">284     // The animations names left in namesOfPreviousAnimations are now known to no longer apply so we need to</span>
<span class="line-modified">285     // remove the CSSAnimation object created for them.</span>
<span class="line-modified">286     for (const auto&amp; nameOfAnimationToRemove : namesOfPreviousAnimations) {</span>
<span class="line-modified">287         if (auto animation = cssAnimationsByName.take(nameOfAnimationToRemove))</span>
<span class="line-modified">288             cancelDeclarativeAnimation(*animation);</span>

289     }







290 }
291 
<span class="line-modified">292 RefPtr&lt;WebAnimation&gt; AnimationTimeline::cssAnimationForElementAndProperty(Element&amp; element, CSSPropertyID property)</span>
293 {
<span class="line-modified">294     RefPtr&lt;WebAnimation&gt; matchingAnimation;</span>
<span class="line-modified">295     for (const auto&amp; animation : m_elementToCSSAnimationsMap.get(&amp;element)) {</span>
<span class="line-modified">296         auto* effect = animation-&gt;effect();</span>
<span class="line-modified">297         if (is&lt;KeyframeEffect&gt;(effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(effect)-&gt;animatedProperties().contains(property))</span>
<span class="line-modified">298             matchingAnimation = animation;</span>

299     }
<span class="line-modified">300     return matchingAnimation;</span>

301 }
302 
303 static bool propertyInStyleMatchesValueForTransitionInMap(CSSPropertyID property, const RenderStyle&amp; style, AnimationTimeline::PropertyToTransitionMap&amp; transitions)
304 {
305     if (auto* transition = transitions.get(property)) {
306         if (CSSPropertyAnimation::propertiesEqual(property, &amp;style, &amp;transition-&gt;targetStyle()))
307             return true;
308     }
309     return false;
310 }
311 
312 static double transitionCombinedDuration(const Animation* transition)
313 {
314     return std::max(0.0, transition-&gt;duration()) + transition-&gt;delay();
315 }
316 
317 static bool transitionMatchesProperty(const Animation&amp; transition, CSSPropertyID property)
318 {
319     auto mode = transition.animationMode();
320     if (mode == Animation::AnimateNone || mode == Animation::AnimateUnknownProperty)
</pre>
<hr />
<pre>
323         auto transitionProperty = transition.property();
324         if (transitionProperty != property) {
325             auto shorthand = shorthandForProperty(transitionProperty);
326             for (size_t i = 0; i &lt; shorthand.length(); ++i) {
327                 if (shorthand.properties()[i] == property)
328                     return true;
329             }
330             return false;
331         }
332     }
333     return true;
334 }
335 
336 AnimationTimeline::PropertyToTransitionMap&amp; AnimationTimeline::ensureRunningTransitionsByProperty(Element&amp; element)
337 {
338     return m_elementToRunningCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {
339         return PropertyToTransitionMap { };
340     }).iterator-&gt;value;
341 }
342 
<span class="line-modified">343 void AnimationTimeline::updateCSSTransitionsForElement(Element&amp; element, const RenderStyle&amp; currentStyle, const RenderStyle&amp; afterChangeStyle)</span>
344 {
<span class="line-modified">345     // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its transitions and disregard new ones.</span>
<span class="line-removed">346     if (currentStyle.hasTransitions() &amp;&amp; currentStyle.display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {</span>
<span class="line-removed">347         if (m_elementToRunningCSSTransitionByCSSPropertyID.contains(&amp;element)) {</span>
<span class="line-removed">348             for (const auto&amp; cssTransitionsByCSSPropertyIDMapItem : m_elementToRunningCSSTransitionByCSSPropertyID.take(&amp;element))</span>
<span class="line-removed">349                 cancelDeclarativeAnimation(*cssTransitionsByCSSPropertyIDMapItem.value);</span>
<span class="line-removed">350         }</span>
351         return;
<span class="line-removed">352     }</span>
<span class="line-removed">353 </span>
<span class="line-removed">354     // Section 3 &quot;Starting of transitions&quot; from the CSS Transitions Level 1 specification.</span>
<span class="line-removed">355     // https://drafts.csswg.org/css-transitions-1/#starting</span>
356 
<span class="line-modified">357     auto&amp; runningTransitionsByProperty = ensureRunningTransitionsByProperty(element);</span>


358 
<span class="line-modified">359     auto&amp; completedTransitionsByProperty = m_elementToCompletedCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {</span>
<span class="line-modified">360         return PropertyToTransitionMap { };</span>
<span class="line-modified">361     }).iterator-&gt;value;</span>














362 
<span class="line-modified">363     auto generationTime = MonotonicTime::now();</span>









364 
<span class="line-modified">365     auto numberOfProperties = CSSPropertyAnimation::getNumProperties();</span>
<span class="line-modified">366     for (int propertyIndex = 0; propertyIndex &lt; numberOfProperties; ++propertyIndex) {</span>
<span class="line-modified">367         Optional&lt;bool&gt; isShorthand;</span>
<span class="line-modified">368         auto property = CSSPropertyAnimation::getPropertyAtIndex(propertyIndex, isShorthand);</span>
<span class="line-modified">369         if (isShorthand &amp;&amp; *isShorthand)</span>
<span class="line-modified">370             continue;</span>
<span class="line-modified">371 </span>
<span class="line-modified">372         const Animation* matchingBackingAnimation = nullptr;</span>
<span class="line-modified">373         if (auto* transitions = afterChangeStyle.transitions()) {</span>
<span class="line-modified">374             for (size_t i = 0; i &lt; transitions-&gt;size(); ++i) {</span>
<span class="line-modified">375                 auto&amp; backingAnimation = transitions-&gt;animation(i);</span>
<span class="line-modified">376                 if (transitionMatchesProperty(backingAnimation, property))</span>
<span class="line-modified">377                     matchingBackingAnimation = &amp;backingAnimation;</span>



378             }
379         }
380 
<span class="line-modified">381         // https://drafts.csswg.org/css-transitions-1/#before-change-style</span>
<span class="line-modified">382         // Define the before-change style as the computed values of all properties on the element as of the previous style change event, except with</span>
<span class="line-modified">383         // any styles derived from declarative animations such as CSS Transitions, CSS Animations, and SMIL Animations updated to the current time.</span>
<span class="line-modified">384         auto existingAnimation = cssAnimationForElementAndProperty(element, property);</span>
<span class="line-modified">385         const auto&amp; beforeChangeStyle = existingAnimation ? downcast&lt;CSSAnimation&gt;(existingAnimation.get())-&gt;unanimatedStyle() : currentStyle;</span>
<span class="line-modified">386 </span>
<span class="line-modified">387         if (!runningTransitionsByProperty.contains(property)</span>
<span class="line-modified">388             &amp;&amp; !CSSPropertyAnimation::propertiesEqual(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)</span>
<span class="line-modified">389             &amp;&amp; CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)</span>
<span class="line-modified">390             &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)</span>
<span class="line-modified">391             &amp;&amp; matchingBackingAnimation &amp;&amp; transitionCombinedDuration(matchingBackingAnimation) &gt; 0) {</span>
<span class="line-modified">392             // 1. If all of the following are true:</span>
<span class="line-modified">393             //   - the element does not have a running transition for the property,</span>
<span class="line-modified">394             //   - the before-change style is different from and can be interpolated with the after-change style for that property,</span>
<span class="line-modified">395             //   - the element does not have a completed transition for the property or the end value of the completed transition is different from the after-change style for the property,</span>
<span class="line-modified">396             //   - there is a matching transition-property value, and</span>
<span class="line-modified">397             //   - the combined duration is greater than 0s,</span>
<span class="line-modified">398 </span>
<span class="line-modified">399             // then implementations must remove the completed transition (if present) from the set of completed transitions</span>







































400             completedTransitionsByProperty.remove(property);













































401 
<span class="line-modified">402             // and start a transition whose:</span>
403             //   - start time is the time of the style change event plus the matching transition delay,
404             //   - end time is the start time plus the matching transition duration,
<span class="line-modified">405             //   - start value is the value of the transitioning property in the before-change style,</span>
<span class="line-modified">406             //   - end value is the value of the transitioning property in the after-change style,</span>
407             //   - reversing-adjusted start value is the same as the start value, and
408             //   - reversing shortening factor is 1.
409             auto delay = Seconds(matchingBackingAnimation-&gt;delay());
410             auto duration = Seconds(matchingBackingAnimation-&gt;duration());
<span class="line-modified">411             auto&amp; reversingAdjustedStartStyle = beforeChangeStyle;</span>
412             auto reversingShorteningFactor = 1;
<span class="line-modified">413             runningTransitionsByProperty.set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;beforeChangeStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-removed">414         } else if (completedTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)) {</span>
<span class="line-removed">415             // 2. Otherwise, if the element has a completed transition for the property and the end value of the completed transition is different from</span>
<span class="line-removed">416             //    the after-change style for the property, then implementations must remove the completed transition from the set of completed transitions.</span>
<span class="line-removed">417             completedTransitionsByProperty.remove(property);</span>
418         }


419 
<span class="line-modified">420         bool hasRunningTransition = runningTransitionsByProperty.contains(property);</span>
<span class="line-modified">421         if ((hasRunningTransition || completedTransitionsByProperty.contains(property)) &amp;&amp; !matchingBackingAnimation) {</span>
<span class="line-modified">422             // 3. If the element has a running transition or completed transition for the property, and there is not a matching transition-property</span>
<span class="line-modified">423             //    value, then implementations must cancel the running transition or remove the completed transition from the set of completed transitions.</span>
<span class="line-modified">424             if (hasRunningTransition)</span>
<span class="line-modified">425                 runningTransitionsByProperty.take(property)-&gt;cancel();</span>
<span class="line-modified">426             else</span>
<span class="line-removed">427                 completedTransitionsByProperty.remove(property);</span>
428         }


429 
<span class="line-modified">430         if (matchingBackingAnimation &amp;&amp; runningTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, runningTransitionsByProperty)) {</span>
<span class="line-modified">431             auto previouslyRunningTransition = runningTransitionsByProperty.take(property);</span>
<span class="line-modified">432             auto&amp; previouslyRunningTransitionCurrentStyle = previouslyRunningTransition-&gt;currentStyle();</span>
<span class="line-modified">433             // 4. If the element has a running transition for the property, there is a matching transition-property value, and the end value of the running</span>
<span class="line-modified">434             //    transition is not equal to the value of the property in the after-change style, then:</span>
<span class="line-modified">435             if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle) || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;currentStyle, &amp;afterChangeStyle)) {</span>
<span class="line-modified">436                 // 1. If the current value of the property in the running transition is equal to the value of the property in the after-change style,</span>
<span class="line-modified">437                 //    or if these two values cannot be interpolated, then implementations must cancel the running transition.</span>
<span class="line-modified">438                 cancelDeclarativeAnimation(*previouslyRunningTransition);</span>
<span class="line-modified">439             } else if (transitionCombinedDuration(matchingBackingAnimation) &lt;= 0.0 || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle)) {</span>
<span class="line-modified">440                 // 2. Otherwise, if the combined duration is less than or equal to 0s, or if the current value of the property in the running transition</span>
<span class="line-modified">441                 //    cannot be interpolated with the value of the property in the after-change style, then implementations must cancel the running transition.</span>
<span class="line-modified">442                 cancelDeclarativeAnimation(*previouslyRunningTransition);</span>
<span class="line-modified">443             } else if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransition-&gt;reversingAdjustedStartStyle(), &amp;afterChangeStyle)) {</span>
<span class="line-modified">444                 // 3. Otherwise, if the reversing-adjusted start value of the running transition is the same as the value of the property in the after-change</span>
<span class="line-modified">445                 //    style (see the section on reversing of transitions for why these case exists), implementations must cancel the running transition</span>
<span class="line-modified">446                 cancelDeclarativeAnimation(*previouslyRunningTransition);</span>
<span class="line-modified">447 </span>
<span class="line-modified">448                 // and start a new transition whose:</span>
<span class="line-modified">449                 //   - reversing-adjusted start value is the end value of the running transition,</span>
<span class="line-modified">450                 //   - reversing shortening factor is the absolute value, clamped to the range [0, 1], of the sum of:</span>
<span class="line-modified">451                 //       1. the output of the timing function of the old transition at the time of the style change event, times the reversing shortening factor of the old transition</span>
<span class="line-modified">452                 //       2. 1 minus the reversing shortening factor of the old transition.</span>
<span class="line-modified">453                 //   - start time is the time of the style change event plus:</span>
<span class="line-modified">454                 //       1. if the matching transition delay is nonnegative, the matching transition delay, or</span>
<span class="line-removed">455                 //       2. if the matching transition delay is negative, the product of the new transition’s reversing shortening factor and the matching transition delay,</span>
<span class="line-removed">456                 //   - end time is the start time plus the product of the matching transition duration and the new transition’s reversing shortening factor,</span>
<span class="line-removed">457                 //   - start value is the current value of the property in the running transition,</span>
<span class="line-removed">458                 //   - end value is the value of the property in the after-change style</span>
<span class="line-removed">459                 auto&amp; reversingAdjustedStartStyle = previouslyRunningTransition-&gt;targetStyle();</span>
<span class="line-removed">460                 double transformedProgress = 1;</span>
<span class="line-removed">461                 if (auto* effect = previouslyRunningTransition-&gt;effect()) {</span>
<span class="line-removed">462                     if (auto computedTimingProgress = effect-&gt;getComputedTiming().progress)</span>
<span class="line-removed">463                         transformedProgress = *computedTimingProgress;</span>
<span class="line-removed">464                 }</span>
<span class="line-removed">465                 auto reversingShorteningFactor = std::max(std::min(((transformedProgress * previouslyRunningTransition-&gt;reversingShorteningFactor()) + (1 - previouslyRunningTransition-&gt;reversingShorteningFactor())), 1.0), 0.0);</span>
<span class="line-removed">466                 auto delay = matchingBackingAnimation-&gt;delay() &lt; 0 ? Seconds(matchingBackingAnimation-&gt;delay()) * reversingShorteningFactor : Seconds(matchingBackingAnimation-&gt;delay());</span>
<span class="line-removed">467                 auto duration = Seconds(matchingBackingAnimation-&gt;duration()) * reversingShorteningFactor;</span>
<span class="line-removed">468 </span>
<span class="line-removed">469                 ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-removed">470             } else {</span>
<span class="line-removed">471                 // 4. Otherwise, implementations must cancel the running transition</span>
<span class="line-removed">472                 cancelDeclarativeAnimation(*previouslyRunningTransition);</span>
<span class="line-removed">473 </span>
<span class="line-removed">474                 // and start a new transition whose:</span>
<span class="line-removed">475                 //   - start time is the time of the style change event plus the matching transition delay,</span>
<span class="line-removed">476                 //   - end time is the start time plus the matching transition duration,</span>
<span class="line-removed">477                 //   - start value is the current value of the property in the running transition,</span>
<span class="line-removed">478                 //   - end value is the value of the property in the after-change style,</span>
<span class="line-removed">479                 //   - reversing-adjusted start value is the same as the start value, and</span>
<span class="line-removed">480                 //   - reversing shortening factor is 1.</span>
<span class="line-removed">481                 auto delay = Seconds(matchingBackingAnimation-&gt;delay());</span>
<span class="line-removed">482                 auto duration = Seconds(matchingBackingAnimation-&gt;duration());</span>
<span class="line-removed">483                 auto&amp; reversingAdjustedStartStyle = currentStyle;</span>
<span class="line-removed">484                 auto reversingShorteningFactor = 1;</span>
<span class="line-removed">485                 ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-removed">486             }</span>
487         }

488     }
<span class="line-removed">489 }</span>
490 
<span class="line-modified">491 void AnimationTimeline::cancelDeclarativeAnimation(DeclarativeAnimation&amp; animation)</span>
<span class="line-modified">492 {</span>
<span class="line-removed">493     animation.cancelFromStyle();</span>
<span class="line-removed">494     removeAnimation(animation);</span>
<span class="line-removed">495     m_allAnimations.removeFirst(&amp;animation);</span>
496 }
497 
498 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;AnimationTimeline.h&quot;
 29 
 30 #include &quot;Animation.h&quot;
 31 #include &quot;AnimationEffect.h&quot;
 32 #include &quot;AnimationList.h&quot;
 33 #include &quot;CSSAnimation.h&quot;
 34 #include &quot;CSSPropertyAnimation.h&quot;
 35 #include &quot;CSSTransition.h&quot;
 36 #include &quot;DocumentTimeline.h&quot;
 37 #include &quot;Element.h&quot;
 38 #include &quot;KeyframeEffect.h&quot;
<span class="line-added"> 39 #include &quot;KeyframeEffectStack.h&quot;</span>
 40 #include &quot;RenderStyle.h&quot;
 41 #include &quot;RenderView.h&quot;
 42 #include &quot;StylePropertyShorthand.h&quot;
 43 #include &quot;StyleResolver.h&quot;
 44 #include &quot;WebAnimationUtilities.h&quot;
 45 #include &lt;wtf/text/TextStream.h&gt;
 46 #include &lt;wtf/text/WTFString.h&gt;
 47 
 48 namespace WebCore {
 49 
 50 AnimationTimeline::AnimationTimeline()
 51 {
 52 }
 53 
 54 AnimationTimeline::~AnimationTimeline()
 55 {
 56 }
 57 
 58 void AnimationTimeline::forgetAnimation(WebAnimation* animation)
 59 {
 60     m_allAnimations.removeFirst(animation);
 61 }
 62 
 63 void AnimationTimeline::animationTimingDidChange(WebAnimation&amp; animation)
 64 {
<span class="line-added"> 65     updateGlobalPosition(animation);</span>
<span class="line-added"> 66 </span>
 67     if (m_animations.add(&amp;animation)) {
 68         m_allAnimations.append(makeWeakPtr(&amp;animation));
 69         auto* timeline = animation.timeline();
 70         if (timeline &amp;&amp; timeline != this)
 71             timeline-&gt;removeAnimation(animation);
 72     }
 73 }
 74 
<span class="line-added"> 75 void AnimationTimeline::updateGlobalPosition(WebAnimation&amp; animation)</span>
<span class="line-added"> 76 {</span>
<span class="line-added"> 77     static uint64_t s_globalPosition = 0;</span>
<span class="line-added"> 78     if (!animation.globalPosition() &amp;&amp; animation.canHaveGlobalPosition())</span>
<span class="line-added"> 79         animation.setGlobalPosition(++s_globalPosition);</span>
<span class="line-added"> 80 }</span>
<span class="line-added"> 81 </span>
 82 void AnimationTimeline::removeAnimation(WebAnimation&amp; animation)
 83 {
 84     ASSERT(!animation.timeline() || animation.timeline() == this);
 85     m_animations.remove(&amp;animation);
 86     if (is&lt;KeyframeEffect&gt;(animation.effect())) {
<span class="line-modified"> 87         if (auto* target = downcast&lt;KeyframeEffect&gt;(animation.effect())-&gt;target()) {</span>
 88             animationWasRemovedFromElement(animation, *target);
<span class="line-added"> 89             target-&gt;ensureKeyframeEffectStack().removeEffect(*downcast&lt;KeyframeEffect&gt;(animation.effect()));</span>
<span class="line-added"> 90         }</span>
 91     }
 92 }
 93 
 94 Optional&lt;double&gt; AnimationTimeline::bindingsCurrentTime()
 95 {
 96     auto time = currentTime();
 97     if (!time)
 98         return WTF::nullopt;
 99     return secondsToWebAnimationsAPITime(*time);
100 }
101 
102 void AnimationTimeline::animationWasAddedToElement(WebAnimation&amp; animation, Element&amp; element)
103 {
104     [&amp;] () -&gt; ElementToAnimationsMap&amp; {
105         if (is&lt;CSSTransition&gt;(animation) &amp;&amp; downcast&lt;CSSTransition&gt;(animation).owningElement())
106             return m_elementToCSSTransitionsMap;
107         if (is&lt;CSSAnimation&gt;(animation) &amp;&amp; downcast&lt;CSSAnimation&gt;(animation).owningElement())
108             return m_elementToCSSAnimationsMap;
109         return m_elementToAnimationsMap;
110     }().ensure(&amp;element, [] {
<span class="line-modified">111         return AnimationCollection { };</span>
112     }).iterator-&gt;value.add(&amp;animation);
113 }
114 
115 static inline bool removeCSSTransitionFromMap(CSSTransition&amp; transition, Element&amp; element, HashMap&lt;Element*, AnimationTimeline::PropertyToTransitionMap&gt;&amp; map)
116 {
117     auto iterator = map.find(&amp;element);
118     if (iterator == map.end())
119         return false;
120 
121     auto&amp; cssTransitionsByProperty = iterator-&gt;value;
122 
123     auto transitionIterator = cssTransitionsByProperty.find(transition.property());
124     if (transitionIterator == cssTransitionsByProperty.end() || transitionIterator-&gt;value != &amp;transition)
125         return false;
126 
127     cssTransitionsByProperty.remove(transitionIterator);
128 
129     if (cssTransitionsByProperty.isEmpty())
130         map.remove(&amp;element);
131     return true;
132 }
133 
134 static inline void removeAnimationFromMapForElement(WebAnimation&amp; animation, AnimationTimeline::ElementToAnimationsMap&amp; map, Element&amp; element)
135 {
136     auto iterator = map.find(&amp;element);
137     if (iterator == map.end())
138         return;
139 
140     auto&amp; animations = iterator-&gt;value;
141     animations.remove(&amp;animation);
142     if (!animations.size())
143         map.remove(iterator);
144 }
145 
146 void AnimationTimeline::animationWasRemovedFromElement(WebAnimation&amp; animation, Element&amp; element)
147 {
148     removeAnimationFromMapForElement(animation, m_elementToCSSTransitionsMap, element);
149     removeAnimationFromMapForElement(animation, m_elementToCSSAnimationsMap, element);
150     removeAnimationFromMapForElement(animation, m_elementToAnimationsMap, element);
151 
<span class="line-modified">152     // Now, if we&#39;re dealing with a CSS Transition, we remove it from the m_elementToRunningCSSTransitionByCSSPropertyID map.</span>
<span class="line-modified">153     // We don&#39;t need to do this for CSS Animations because their timing can be set via CSS to end, which would cause this</span>
<span class="line-modified">154     // function to be called, but they should remain associated with their owning element until this is changed via a call</span>
<span class="line-added">155     // to the JS API or changing the target element&#39;s animation-name property.</span>
<span class="line-added">156     if (is&lt;CSSTransition&gt;(animation))</span>
157         removeDeclarativeAnimationFromListsForOwningElement(animation, element);
158 }
159 
160 void AnimationTimeline::removeDeclarativeAnimationFromListsForOwningElement(WebAnimation&amp; animation, Element&amp; element)
161 {
162     ASSERT(is&lt;DeclarativeAnimation&gt;(animation));
163 
<span class="line-modified">164     if (is&lt;CSSTransition&gt;(animation)) {</span>









165         auto&amp; transition = downcast&lt;CSSTransition&gt;(animation);
166         if (!removeCSSTransitionFromMap(transition, element, m_elementToRunningCSSTransitionByCSSPropertyID))
167             removeCSSTransitionFromMap(transition, element, m_elementToCompletedCSSTransitionByCSSPropertyID);
168     }
169 }
170 
171 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; AnimationTimeline::animationsForElement(Element&amp; element, Ordering ordering) const
172 {
173     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
<span class="line-modified">174 </span>
<span class="line-modified">175     if (ordering == Ordering::Sorted) {</span>
<span class="line-modified">176         if (element.hasKeyframeEffects()) {</span>
<span class="line-modified">177             for (auto&amp; effect : element.ensureKeyframeEffectStack().sortedEffects())</span>
<span class="line-modified">178                 animations.append(effect-&gt;animation());</span>
<span class="line-modified">179         }</span>
<span class="line-modified">180     } else {</span>
<span class="line-modified">181         if (m_elementToCSSTransitionsMap.contains(&amp;element)) {</span>
<span class="line-modified">182             const auto&amp; cssTransitions = m_elementToCSSTransitionsMap.get(&amp;element);</span>







183             animations.appendRange(cssTransitions.begin(), cssTransitions.end());
<span class="line-added">184         }</span>
<span class="line-added">185         if (m_elementToCSSAnimationsMap.contains(&amp;element)) {</span>
<span class="line-added">186             const auto&amp; cssAnimations = m_elementToCSSAnimationsMap.get(&amp;element);</span>
<span class="line-added">187             animations.appendRange(cssAnimations.begin(), cssAnimations.end());</span>
<span class="line-added">188         }</span>
<span class="line-added">189         if (m_elementToAnimationsMap.contains(&amp;element)) {</span>
<span class="line-added">190             const auto&amp; webAnimations = m_elementToAnimationsMap.get(&amp;element);</span>
<span class="line-added">191             animations.appendRange(webAnimations.begin(), webAnimations.end());</span>
<span class="line-added">192         }</span>
193     }
<span class="line-modified">194 </span>
<span class="line-modified">195     return animations;</span>
<span class="line-modified">196 }</span>
<span class="line-added">197 </span>
<span class="line-added">198 void AnimationTimeline::removeCSSAnimationCreatedByMarkup(Element&amp; element, CSSAnimation&amp; cssAnimation)</span>
<span class="line-added">199 {</span>
<span class="line-added">200     auto iterator = m_elementToCSSAnimationsCreatedByMarkupMap.find(&amp;element);</span>
<span class="line-added">201     if (iterator != m_elementToCSSAnimationsCreatedByMarkupMap.end()) {</span>
<span class="line-added">202         auto&amp; cssAnimations = iterator-&gt;value;</span>
<span class="line-added">203         cssAnimations.remove(&amp;cssAnimation);</span>
<span class="line-added">204         if (!cssAnimations.size())</span>
<span class="line-added">205             m_elementToCSSAnimationsCreatedByMarkupMap.remove(iterator);</span>
206     }
<span class="line-modified">207 </span>
<span class="line-modified">208     if (!element.hasKeyframeEffects())</span>
<span class="line-modified">209         return;</span>
<span class="line-added">210 </span>
<span class="line-added">211     auto&amp; keyframeEffectStack = element.ensureKeyframeEffectStack();</span>
<span class="line-added">212     auto* cssAnimationList = keyframeEffectStack.cssAnimationList();</span>
<span class="line-added">213     if (!cssAnimationList || cssAnimationList-&gt;isEmpty())</span>
<span class="line-added">214         return;</span>
<span class="line-added">215 </span>
<span class="line-added">216     auto&amp; backingAnimation = cssAnimation.backingAnimation();</span>
<span class="line-added">217     for (size_t i = 0; i &lt; cssAnimationList-&gt;size(); ++i) {</span>
<span class="line-added">218         if (cssAnimationList-&gt;animation(i) == backingAnimation) {</span>
<span class="line-added">219             auto newAnimationList = cssAnimationList-&gt;copy();</span>
<span class="line-added">220             newAnimationList-&gt;remove(i);</span>
<span class="line-added">221             keyframeEffectStack.setCSSAnimationList(WTFMove(newAnimationList));</span>
<span class="line-added">222             return;</span>
<span class="line-added">223         }</span>
<span class="line-added">224     }</span>
<span class="line-added">225 }</span>
<span class="line-added">226 </span>
<span class="line-added">227 void AnimationTimeline::willDestroyRendererForElement(Element&amp; element)</span>
<span class="line-added">228 {</span>
<span class="line-added">229     for (auto&amp; cssTransition : m_elementToCSSTransitionsMap.get(&amp;element))</span>
<span class="line-added">230         cssTransition-&gt;cancel(WebAnimation::Silently::Yes);</span>
<span class="line-added">231 </span>
<span class="line-added">232     for (auto&amp; cssAnimation : m_elementToCSSAnimationsMap.get(&amp;element)) {</span>
<span class="line-added">233         if (is&lt;CSSAnimation&gt;(cssAnimation))</span>
<span class="line-added">234             removeCSSAnimationCreatedByMarkup(element, downcast&lt;CSSAnimation&gt;(*cssAnimation));</span>
<span class="line-added">235         cssAnimation-&gt;cancel(WebAnimation::Silently::Yes);</span>
236     }

237 }
238 
239 void AnimationTimeline::elementWasRemoved(Element&amp; element)
240 {
<span class="line-modified">241     willDestroyRendererForElement(element);</span>
<span class="line-modified">242 </span>
<span class="line-added">243     m_elementToAnimationsMap.remove(&amp;element);</span>
<span class="line-added">244     m_elementToCSSAnimationsMap.remove(&amp;element);</span>
<span class="line-added">245     m_elementToCSSTransitionsMap.remove(&amp;element);</span>
<span class="line-added">246     m_elementToRunningCSSTransitionByCSSPropertyID.remove(&amp;element);</span>
<span class="line-added">247     m_elementToCSSAnimationsCreatedByMarkupMap.remove(&amp;element);</span>
248 }
249 
250 void AnimationTimeline::removeAnimationsForElement(Element&amp; element)
251 {
252     for (auto&amp; animation : animationsForElement(element))
253         animation-&gt;remove();
254 }
255 
<span class="line-added">256 void AnimationTimeline::willChangeRendererForElement(Element&amp; element)</span>
<span class="line-added">257 {</span>
<span class="line-added">258     for (auto&amp; animation : animationsForElement(element))</span>
<span class="line-added">259         animation-&gt;willChangeRenderer();</span>
<span class="line-added">260 }</span>
<span class="line-added">261 </span>
262 void AnimationTimeline::cancelDeclarativeAnimationsForElement(Element&amp; element)
263 {
264     for (auto&amp; cssTransition : m_elementToCSSTransitionsMap.get(&amp;element))
265         cssTransition-&gt;cancel();
<span class="line-modified">266     for (auto&amp; cssAnimation : m_elementToCSSAnimationsMap.get(&amp;element)) {</span>
<span class="line-added">267         if (is&lt;CSSAnimation&gt;(cssAnimation))</span>
<span class="line-added">268             removeCSSAnimationCreatedByMarkup(element, downcast&lt;CSSAnimation&gt;(*cssAnimation));</span>
269         cssAnimation-&gt;cancel();
<span class="line-added">270     }</span>
271 }
272 
273 static bool shouldConsiderAnimation(Element&amp; element, const Animation&amp; animation)
274 {
275     if (!animation.isValidAnimation())
276         return false;
277 
278     static NeverDestroyed&lt;const String&gt; animationNameNone(MAKE_STATIC_STRING_IMPL(&quot;none&quot;));
279 
280     auto&amp; name = animation.name();
281     if (name == animationNameNone || name.isEmpty())
282         return false;
283 
284     if (auto* styleScope = Style::Scope::forOrdinal(element, animation.nameStyleScopeOrdinal()))
285         return styleScope-&gt;resolver().isAnimationNameValid(name);
286 
287     return false;
288 }
289 
290 void AnimationTimeline::updateCSSAnimationsForElement(Element&amp; element, const RenderStyle* currentStyle, const RenderStyle&amp; afterChangeStyle)
291 {
<span class="line-added">292     auto&amp; keyframeEffectStack = element.ensureKeyframeEffectStack();</span>
<span class="line-added">293 </span>
294     // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its animations and disregard new ones.
<span class="line-modified">295     if (currentStyle &amp;&amp; currentStyle-&gt;display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {</span>
<span class="line-modified">296         auto iterator = m_elementToCSSAnimationsCreatedByMarkupMap.find(&amp;element);</span>
<span class="line-modified">297         if (iterator != m_elementToCSSAnimationsCreatedByMarkupMap.end()) {</span>
<span class="line-modified">298             auto&amp; cssAnimations = iterator-&gt;value;</span>
<span class="line-added">299             for (auto&amp; cssAnimation : cssAnimations)</span>
<span class="line-added">300                 cssAnimation-&gt;cancelFromStyle();</span>
<span class="line-added">301             m_elementToCSSAnimationsCreatedByMarkupMap.remove(iterator);</span>
302         }
<span class="line-added">303         keyframeEffectStack.setCSSAnimationList(nullptr);</span>
304         return;
305     }
306 
<span class="line-modified">307     auto* currentAnimationList = afterChangeStyle.animations();</span>
<span class="line-added">308     auto* previousAnimationList = keyframeEffectStack.cssAnimationList();</span>
<span class="line-added">309     if (previousAnimationList &amp;&amp; !previousAnimationList-&gt;isEmpty() &amp;&amp; afterChangeStyle.hasAnimations() &amp;&amp; *(previousAnimationList) == *(afterChangeStyle.animations()))</span>
310         return;
311 
<span class="line-modified">312     CSSAnimationCollection newAnimations;</span>
<span class="line-modified">313     auto&amp; previousAnimations = m_elementToCSSAnimationsCreatedByMarkupMap.ensure(&amp;element, [] {</span>
<span class="line-modified">314         return CSSAnimationCollection { };</span>











315     }).iterator-&gt;value;
316 
<span class="line-modified">317     // https://www.w3.org/TR/css-animations-1/#animations</span>
<span class="line-modified">318     // The same @keyframes rule name may be repeated within an animation-name. Changes to the animation-name update existing</span>
<span class="line-modified">319     // animations by iterating over the new list of animations from last to first, and, for each animation, finding the last</span>
<span class="line-modified">320     // matching animation in the list of existing animations. If a match is found, the existing animation is updated using the</span>
<span class="line-modified">321     // animation properties corresponding to its position in the new list of animations, whilst maintaining its current playback</span>
<span class="line-modified">322     // time as described above. The matching animation is removed from the existing list of animations such that it will not match</span>
<span class="line-modified">323     // twice. If a match is not found, a new animation is created. As a result, updating animation-name from ‘a’ to ‘a, a’ will</span>
<span class="line-modified">324     // cause the existing animation for ‘a’ to become the second animation in the list and a new animation will be created for the</span>
<span class="line-modified">325     // first item in the list.</span>
<span class="line-modified">326     if (currentAnimationList) {</span>
<span class="line-modified">327         for (size_t i = currentAnimationList-&gt;size(); i &gt; 0; --i) {</span>
<span class="line-modified">328             auto&amp; currentAnimation = currentAnimationList-&gt;animation(i - 1);</span>
<span class="line-modified">329             if (!shouldConsiderAnimation(element, currentAnimation))</span>
<span class="line-added">330                 continue;</span>
<span class="line-added">331 </span>
<span class="line-added">332             bool foundMatchingAnimation = false;</span>
<span class="line-added">333             for (auto&amp; previousAnimation : previousAnimations) {</span>
<span class="line-added">334                 if (previousAnimation-&gt;animationName() == currentAnimation.name()) {</span>
<span class="line-added">335                     // Timing properties or play state may have changed so we need to update the backing animation with</span>
<span class="line-added">336                     // the Animation found in the current style.</span>
<span class="line-added">337                     previousAnimation-&gt;setBackingAnimation(currentAnimation);</span>
<span class="line-added">338                     newAnimations.add(previousAnimation);</span>
<span class="line-added">339                     // Remove the matched animation from the list of previous animations so we may not match it again.</span>
<span class="line-added">340                     previousAnimations.remove(previousAnimation);</span>
<span class="line-added">341                     foundMatchingAnimation = true;</span>
<span class="line-added">342                     break;</span>
<span class="line-added">343                 }</span>
344             }
<span class="line-modified">345 </span>
<span class="line-modified">346             if (!foundMatchingAnimation)</span>
<span class="line-added">347                 newAnimations.add(CSSAnimation::create(element, currentAnimation, currentStyle, afterChangeStyle));</span>
348         }
349     }
350 
<span class="line-modified">351     // Any animation found in previousAnimations but not found in newAnimations is not longer current and should be canceled.</span>
<span class="line-modified">352     for (auto&amp; previousAnimation : previousAnimations) {</span>
<span class="line-modified">353         if (!newAnimations.contains(previousAnimation)) {</span>
<span class="line-modified">354             if (previousAnimation-&gt;owningElement())</span>
<span class="line-modified">355                 previousAnimation-&gt;cancelFromStyle();</span>
<span class="line-added">356         }</span>
357     }
<span class="line-added">358 </span>
<span class="line-added">359     if (newAnimations.isEmpty())</span>
<span class="line-added">360         m_elementToCSSAnimationsCreatedByMarkupMap.remove(&amp;element);</span>
<span class="line-added">361     else</span>
<span class="line-added">362         m_elementToCSSAnimationsCreatedByMarkupMap.set(&amp;element, WTFMove(newAnimations));</span>
<span class="line-added">363 </span>
<span class="line-added">364     keyframeEffectStack.setCSSAnimationList(currentAnimationList);</span>
365 }
366 
<span class="line-modified">367 static KeyframeEffect* keyframeEffectForElementAndProperty(Element&amp; element, CSSPropertyID property)</span>
368 {
<span class="line-modified">369     if (auto* keyframeEffectStack = element.keyframeEffectStack()) {</span>
<span class="line-modified">370         auto effects = keyframeEffectStack-&gt;sortedEffects();</span>
<span class="line-modified">371         for (const auto&amp; effect : makeReversedRange(effects)) {</span>
<span class="line-modified">372             if (effect-&gt;animatesProperty(property))</span>
<span class="line-modified">373                 return effect.get();</span>
<span class="line-added">374         }</span>
375     }
<span class="line-modified">376 </span>
<span class="line-added">377     return nullptr;</span>
378 }
379 
380 static bool propertyInStyleMatchesValueForTransitionInMap(CSSPropertyID property, const RenderStyle&amp; style, AnimationTimeline::PropertyToTransitionMap&amp; transitions)
381 {
382     if (auto* transition = transitions.get(property)) {
383         if (CSSPropertyAnimation::propertiesEqual(property, &amp;style, &amp;transition-&gt;targetStyle()))
384             return true;
385     }
386     return false;
387 }
388 
389 static double transitionCombinedDuration(const Animation* transition)
390 {
391     return std::max(0.0, transition-&gt;duration()) + transition-&gt;delay();
392 }
393 
394 static bool transitionMatchesProperty(const Animation&amp; transition, CSSPropertyID property)
395 {
396     auto mode = transition.animationMode();
397     if (mode == Animation::AnimateNone || mode == Animation::AnimateUnknownProperty)
</pre>
<hr />
<pre>
400         auto transitionProperty = transition.property();
401         if (transitionProperty != property) {
402             auto shorthand = shorthandForProperty(transitionProperty);
403             for (size_t i = 0; i &lt; shorthand.length(); ++i) {
404                 if (shorthand.properties()[i] == property)
405                     return true;
406             }
407             return false;
408         }
409     }
410     return true;
411 }
412 
413 AnimationTimeline::PropertyToTransitionMap&amp; AnimationTimeline::ensureRunningTransitionsByProperty(Element&amp; element)
414 {
415     return m_elementToRunningCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {
416         return PropertyToTransitionMap { };
417     }).iterator-&gt;value;
418 }
419 
<span class="line-modified">420 static void compileTransitionPropertiesInStyle(const RenderStyle&amp; style, HashSet&lt;CSSPropertyID&gt;&amp; transitionProperties, bool&amp; transitionPropertiesContainAll)</span>
421 {
<span class="line-modified">422     if (transitionPropertiesContainAll)</span>





423         return;




424 
<span class="line-modified">425     auto* transitions = style.transitions();</span>
<span class="line-added">426     if (!transitions)</span>
<span class="line-added">427         return;</span>
428 
<span class="line-modified">429     for (size_t i = 0; i &lt; transitions-&gt;size(); ++i) {</span>
<span class="line-modified">430         const auto&amp; animation = transitions-&gt;animation(i);</span>
<span class="line-modified">431         auto mode = animation.animationMode();</span>
<span class="line-added">432         if (mode == Animation::AnimateSingleProperty) {</span>
<span class="line-added">433             auto property = animation.property();</span>
<span class="line-added">434             if (isShorthandCSSProperty(property)) {</span>
<span class="line-added">435                 auto shorthand = shorthandForProperty(property);</span>
<span class="line-added">436                 for (size_t j = 0; j &lt; shorthand.length(); ++j)</span>
<span class="line-added">437                     transitionProperties.add(shorthand.properties()[j]);</span>
<span class="line-added">438             } else if (property != CSSPropertyInvalid)</span>
<span class="line-added">439                 transitionProperties.add(property);</span>
<span class="line-added">440         } else if (mode == Animation::AnimateAll) {</span>
<span class="line-added">441             transitionPropertiesContainAll = true;</span>
<span class="line-added">442             return;</span>
<span class="line-added">443         }</span>
<span class="line-added">444     }</span>
<span class="line-added">445 }</span>
446 
<span class="line-modified">447 void AnimationTimeline::updateCSSTransitionsForElementAndProperty(Element&amp; element, CSSPropertyID property, const RenderStyle&amp; currentStyle, const RenderStyle&amp; afterChangeStyle, AnimationTimeline::PropertyToTransitionMap&amp; runningTransitionsByProperty, PropertyToTransitionMap&amp; completedTransitionsByProperty, const MonotonicTime generationTime)</span>
<span class="line-added">448 {</span>
<span class="line-added">449     const Animation* matchingBackingAnimation = nullptr;</span>
<span class="line-added">450     if (auto* transitions = afterChangeStyle.transitions()) {</span>
<span class="line-added">451         for (size_t i = 0; i &lt; transitions-&gt;size(); ++i) {</span>
<span class="line-added">452             auto&amp; backingAnimation = transitions-&gt;animation(i);</span>
<span class="line-added">453             if (transitionMatchesProperty(backingAnimation, property))</span>
<span class="line-added">454                 matchingBackingAnimation = &amp;backingAnimation;</span>
<span class="line-added">455         }</span>
<span class="line-added">456     }</span>
457 
<span class="line-modified">458     // https://drafts.csswg.org/css-transitions-1/#before-change-style</span>
<span class="line-modified">459     // Define the before-change style as the computed values of all properties on the element as of the previous style change event, except with</span>
<span class="line-modified">460     // any styles derived from declarative animations such as CSS Transitions, CSS Animations, and SMIL Animations updated to the current time.</span>
<span class="line-modified">461     bool hasRunningTransition = runningTransitionsByProperty.contains(property);</span>
<span class="line-modified">462     auto beforeChangeStyle = [&amp;]() {</span>
<span class="line-modified">463         if (hasRunningTransition &amp;&amp; CSSPropertyAnimation::animationOfPropertyIsAccelerated(property)) {</span>
<span class="line-modified">464             // In case we have an accelerated transition running for this element, we need to get its computed style as the before-change style</span>
<span class="line-modified">465             // since otherwise the animated value for that property won&#39;t be visible.</span>
<span class="line-modified">466             auto* runningTransition = runningTransitionsByProperty.get(property);</span>
<span class="line-modified">467             if (is&lt;KeyframeEffect&gt;(runningTransition-&gt;effect())) {</span>
<span class="line-modified">468                 auto&amp; keyframeEffect = *downcast&lt;KeyframeEffect&gt;(runningTransition-&gt;effect());</span>
<span class="line-modified">469                 if (keyframeEffect.isRunningAccelerated()) {</span>
<span class="line-modified">470                     auto animatedStyle = RenderStyle::clone(currentStyle);</span>
<span class="line-added">471                     runningTransition-&gt;resolve(animatedStyle);</span>
<span class="line-added">472                     return animatedStyle;</span>
<span class="line-added">473                 }</span>
474             }
475         }
476 
<span class="line-modified">477         if (auto* keyframeEffect = keyframeEffectForElementAndProperty(element, property)) {</span>
<span class="line-modified">478             // If we already have a keyframe effect targeting this property, we should use its unanimated style to determine what the potential</span>
<span class="line-modified">479             // start value of the transition shoud be to make sure that we don&#39;t account for animated values that would have been blended onto</span>
<span class="line-modified">480             // the style applied during the last style resolution.</span>
<span class="line-modified">481             if (auto* unanimatedStyle = keyframeEffect-&gt;unanimatedStyle())</span>
<span class="line-modified">482                 return RenderStyle::clone(*unanimatedStyle);</span>
<span class="line-modified">483 </span>
<span class="line-modified">484             // If we have a keyframe effect targeting this property, but it doesn&#39;t yet have an unanimated style, this is because it has not</span>
<span class="line-modified">485             // had a chance to apply itself with a non-null progress. In this case, the before-change and after-change styles should be the</span>
<span class="line-modified">486             // same in order to prevent a transition from being triggered as the unanimated style for this keyframe effect will most likely</span>
<span class="line-modified">487             // be this after-change style, or any future style change that may happen before the keyframe effect starts blending animated values.</span>
<span class="line-modified">488             return RenderStyle::clone(afterChangeStyle);</span>
<span class="line-modified">489         }</span>
<span class="line-modified">490 </span>
<span class="line-modified">491         // In any other scenario, the before-change style should be the previously resolved style for this element.</span>
<span class="line-modified">492         return RenderStyle::clone(currentStyle);</span>
<span class="line-modified">493     }();</span>
<span class="line-modified">494 </span>
<span class="line-modified">495     if (!hasRunningTransition</span>
<span class="line-added">496         &amp;&amp; !CSSPropertyAnimation::propertiesEqual(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)</span>
<span class="line-added">497         &amp;&amp; CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)</span>
<span class="line-added">498         &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)</span>
<span class="line-added">499         &amp;&amp; matchingBackingAnimation &amp;&amp; transitionCombinedDuration(matchingBackingAnimation) &gt; 0) {</span>
<span class="line-added">500         // 1. If all of the following are true:</span>
<span class="line-added">501         //   - the element does not have a running transition for the property,</span>
<span class="line-added">502         //   - the before-change style is different from and can be interpolated with the after-change style for that property,</span>
<span class="line-added">503         //   - the element does not have a completed transition for the property or the end value of the completed transition is different from the after-change style for the property,</span>
<span class="line-added">504         //   - there is a matching transition-property value, and</span>
<span class="line-added">505         //   - the combined duration is greater than 0s,</span>
<span class="line-added">506 </span>
<span class="line-added">507         // then implementations must remove the completed transition (if present) from the set of completed transitions</span>
<span class="line-added">508         completedTransitionsByProperty.remove(property);</span>
<span class="line-added">509 </span>
<span class="line-added">510         // and start a transition whose:</span>
<span class="line-added">511         //   - start time is the time of the style change event plus the matching transition delay,</span>
<span class="line-added">512         //   - end time is the start time plus the matching transition duration,</span>
<span class="line-added">513         //   - start value is the value of the transitioning property in the before-change style,</span>
<span class="line-added">514         //   - end value is the value of the transitioning property in the after-change style,</span>
<span class="line-added">515         //   - reversing-adjusted start value is the same as the start value, and</span>
<span class="line-added">516         //   - reversing shortening factor is 1.</span>
<span class="line-added">517         auto delay = Seconds(matchingBackingAnimation-&gt;delay());</span>
<span class="line-added">518         auto duration = Seconds(matchingBackingAnimation-&gt;duration());</span>
<span class="line-added">519         auto&amp; reversingAdjustedStartStyle = beforeChangeStyle;</span>
<span class="line-added">520         auto reversingShorteningFactor = 1;</span>
<span class="line-added">521         runningTransitionsByProperty.set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;beforeChangeStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-added">522     } else if (completedTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)) {</span>
<span class="line-added">523         // 2. Otherwise, if the element has a completed transition for the property and the end value of the completed transition is different from</span>
<span class="line-added">524         //    the after-change style for the property, then implementations must remove the completed transition from the set of completed transitions.</span>
<span class="line-added">525         completedTransitionsByProperty.remove(property);</span>
<span class="line-added">526     }</span>
<span class="line-added">527 </span>
<span class="line-added">528     hasRunningTransition = runningTransitionsByProperty.contains(property);</span>
<span class="line-added">529     if ((hasRunningTransition || completedTransitionsByProperty.contains(property)) &amp;&amp; !matchingBackingAnimation) {</span>
<span class="line-added">530         // 3. If the element has a running transition or completed transition for the property, and there is not a matching transition-property</span>
<span class="line-added">531         //    value, then implementations must cancel the running transition or remove the completed transition from the set of completed transitions.</span>
<span class="line-added">532         if (hasRunningTransition)</span>
<span class="line-added">533             runningTransitionsByProperty.take(property)-&gt;cancel();</span>
<span class="line-added">534         else</span>
535             completedTransitionsByProperty.remove(property);
<span class="line-added">536     }</span>
<span class="line-added">537 </span>
<span class="line-added">538     if (matchingBackingAnimation &amp;&amp; runningTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, runningTransitionsByProperty)) {</span>
<span class="line-added">539         auto previouslyRunningTransition = runningTransitionsByProperty.take(property);</span>
<span class="line-added">540         auto&amp; previouslyRunningTransitionCurrentStyle = previouslyRunningTransition-&gt;currentStyle();</span>
<span class="line-added">541         // 4. If the element has a running transition for the property, there is a matching transition-property value, and the end value of the running</span>
<span class="line-added">542         //    transition is not equal to the value of the property in the after-change style, then:</span>
<span class="line-added">543         if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle) || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;currentStyle, &amp;afterChangeStyle)) {</span>
<span class="line-added">544             // 1. If the current value of the property in the running transition is equal to the value of the property in the after-change style,</span>
<span class="line-added">545             //    or if these two values cannot be interpolated, then implementations must cancel the running transition.</span>
<span class="line-added">546             previouslyRunningTransition-&gt;cancelFromStyle();</span>
<span class="line-added">547         } else if (transitionCombinedDuration(matchingBackingAnimation) &lt;= 0.0 || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle)) {</span>
<span class="line-added">548             // 2. Otherwise, if the combined duration is less than or equal to 0s, or if the current value of the property in the running transition</span>
<span class="line-added">549             //    cannot be interpolated with the value of the property in the after-change style, then implementations must cancel the running transition.</span>
<span class="line-added">550             previouslyRunningTransition-&gt;cancelFromStyle();</span>
<span class="line-added">551         } else if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransition-&gt;reversingAdjustedStartStyle(), &amp;afterChangeStyle)) {</span>
<span class="line-added">552             // 3. Otherwise, if the reversing-adjusted start value of the running transition is the same as the value of the property in the after-change</span>
<span class="line-added">553             //    style (see the section on reversing of transitions for why these case exists), implementations must cancel the running transition</span>
<span class="line-added">554             previouslyRunningTransition-&gt;cancelFromStyle();</span>
<span class="line-added">555 </span>
<span class="line-added">556             // and start a new transition whose:</span>
<span class="line-added">557             //   - reversing-adjusted start value is the end value of the running transition,</span>
<span class="line-added">558             //   - reversing shortening factor is the absolute value, clamped to the range [0, 1], of the sum of:</span>
<span class="line-added">559             //       1. the output of the timing function of the old transition at the time of the style change event, times the reversing shortening factor of the old transition</span>
<span class="line-added">560             //       2. 1 minus the reversing shortening factor of the old transition.</span>
<span class="line-added">561             //   - start time is the time of the style change event plus:</span>
<span class="line-added">562             //       1. if the matching transition delay is nonnegative, the matching transition delay, or</span>
<span class="line-added">563             //       2. if the matching transition delay is negative, the product of the new transition’s reversing shortening factor and the matching transition delay,</span>
<span class="line-added">564             //   - end time is the start time plus the product of the matching transition duration and the new transition’s reversing shortening factor,</span>
<span class="line-added">565             //   - start value is the current value of the property in the running transition,</span>
<span class="line-added">566             //   - end value is the value of the property in the after-change style</span>
<span class="line-added">567             auto&amp; reversingAdjustedStartStyle = previouslyRunningTransition-&gt;targetStyle();</span>
<span class="line-added">568             double transformedProgress = 1;</span>
<span class="line-added">569             if (auto* effect = previouslyRunningTransition-&gt;effect()) {</span>
<span class="line-added">570                 if (auto computedTimingProgress = effect-&gt;getComputedTiming().progress)</span>
<span class="line-added">571                     transformedProgress = *computedTimingProgress;</span>
<span class="line-added">572             }</span>
<span class="line-added">573             auto reversingShorteningFactor = std::max(std::min(((transformedProgress * previouslyRunningTransition-&gt;reversingShorteningFactor()) + (1 - previouslyRunningTransition-&gt;reversingShorteningFactor())), 1.0), 0.0);</span>
<span class="line-added">574             auto delay = matchingBackingAnimation-&gt;delay() &lt; 0 ? Seconds(matchingBackingAnimation-&gt;delay()) * reversingShorteningFactor : Seconds(matchingBackingAnimation-&gt;delay());</span>
<span class="line-added">575             auto duration = Seconds(matchingBackingAnimation-&gt;duration()) * reversingShorteningFactor;</span>
<span class="line-added">576 </span>
<span class="line-added">577             ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-added">578         } else {</span>
<span class="line-added">579             // 4. Otherwise, implementations must cancel the running transition</span>
<span class="line-added">580             previouslyRunningTransition-&gt;cancelFromStyle();</span>
581 
<span class="line-modified">582             // and start a new transition whose:</span>
583             //   - start time is the time of the style change event plus the matching transition delay,
584             //   - end time is the start time plus the matching transition duration,
<span class="line-modified">585             //   - start value is the current value of the property in the running transition,</span>
<span class="line-modified">586             //   - end value is the value of the property in the after-change style,</span>
587             //   - reversing-adjusted start value is the same as the start value, and
588             //   - reversing shortening factor is 1.
589             auto delay = Seconds(matchingBackingAnimation-&gt;delay());
590             auto duration = Seconds(matchingBackingAnimation-&gt;duration());
<span class="line-modified">591             auto&amp; reversingAdjustedStartStyle = currentStyle;</span>
592             auto reversingShorteningFactor = 1;
<span class="line-modified">593             ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>




594         }
<span class="line-added">595     }</span>
<span class="line-added">596 }</span>
597 
<span class="line-modified">598 void AnimationTimeline::updateCSSTransitionsForElement(Element&amp; element, const RenderStyle&amp; currentStyle, const RenderStyle&amp; afterChangeStyle)</span>
<span class="line-modified">599 {</span>
<span class="line-modified">600     // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its transitions and disregard new ones.</span>
<span class="line-modified">601     if (currentStyle.hasTransitions() &amp;&amp; currentStyle.display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {</span>
<span class="line-modified">602         if (m_elementToRunningCSSTransitionByCSSPropertyID.contains(&amp;element)) {</span>
<span class="line-modified">603             for (const auto&amp; cssTransitionsByCSSPropertyIDMapItem : m_elementToRunningCSSTransitionByCSSPropertyID.take(&amp;element))</span>
<span class="line-modified">604                 cssTransitionsByCSSPropertyIDMapItem.value-&gt;cancelFromStyle();</span>

605         }
<span class="line-added">606         return;</span>
<span class="line-added">607     }</span>
608 
<span class="line-modified">609     // Section 3 &quot;Starting of transitions&quot; from the CSS Transitions Level 1 specification.</span>
<span class="line-modified">610     // https://drafts.csswg.org/css-transitions-1/#starting</span>
<span class="line-modified">611 </span>
<span class="line-modified">612     auto&amp; runningTransitionsByProperty = ensureRunningTransitionsByProperty(element);</span>
<span class="line-modified">613 </span>
<span class="line-modified">614     auto&amp; completedTransitionsByProperty = m_elementToCompletedCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {</span>
<span class="line-modified">615         return PropertyToTransitionMap { };</span>
<span class="line-modified">616     }).iterator-&gt;value;</span>
<span class="line-modified">617 </span>
<span class="line-modified">618     auto generationTime = MonotonicTime::now();</span>
<span class="line-modified">619 </span>
<span class="line-modified">620     // First, let&#39;s compile the list of all CSS properties found in the current style and the after-change style.</span>
<span class="line-modified">621     bool transitionPropertiesContainAll = false;</span>
<span class="line-modified">622     HashSet&lt;CSSPropertyID&gt; transitionProperties;</span>
<span class="line-modified">623     compileTransitionPropertiesInStyle(currentStyle, transitionProperties, transitionPropertiesContainAll);</span>
<span class="line-modified">624     compileTransitionPropertiesInStyle(afterChangeStyle, transitionProperties, transitionPropertiesContainAll);</span>
<span class="line-modified">625 </span>
<span class="line-modified">626     if (transitionPropertiesContainAll) {</span>
<span class="line-modified">627         auto numberOfProperties = CSSPropertyAnimation::getNumProperties();</span>
<span class="line-modified">628         for (int propertyIndex = 0; propertyIndex &lt; numberOfProperties; ++propertyIndex) {</span>
<span class="line-modified">629             Optional&lt;bool&gt; isShorthand;</span>
<span class="line-modified">630             auto property = CSSPropertyAnimation::getPropertyAtIndex(propertyIndex, isShorthand);</span>
<span class="line-modified">631             if (isShorthand &amp;&amp; *isShorthand)</span>
<span class="line-modified">632                 continue;</span>
<span class="line-modified">633             updateCSSTransitionsForElementAndProperty(element, property, currentStyle, afterChangeStyle, runningTransitionsByProperty, completedTransitionsByProperty, generationTime);</span>
































634         }
<span class="line-added">635         return;</span>
636     }

637 
<span class="line-modified">638     for (auto property : transitionProperties)</span>
<span class="line-modified">639         updateCSSTransitionsForElementAndProperty(element, property, currentStyle, afterChangeStyle, runningTransitionsByProperty, completedTransitionsByProperty, generationTime);</span>



640 }
641 
642 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="AnimationPlaybackEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AnimationTimeline.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/StdLibExtras.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/StdLibExtras.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/StdLibExtras.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/StdLibExtras.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2008-2017 Apple Inc. All Rights Reserved.
+ * Copyright (C) 2008-2019 Apple Inc. All Rights Reserved.
  * Copyright (C) 2013 Patrick Gansterer <paroga@paroga.com>
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -111,13 +111,13 @@
 
 namespace WTF {
 
 enum CheckMoveParameterTag { CheckMoveParameter };
 
-static const size_t KB = 1024;
-static const size_t MB = 1024 * 1024;
-static const size_t GB = 1024 * 1024 * 1024;
+static constexpr size_t KB = 1024;
+static constexpr size_t MB = 1024 * 1024;
+static constexpr size_t GB = 1024 * 1024 * 1024;
 
 inline bool isPointerAligned(void* p)
 {
     return !((intptr_t)(p) & (sizeof(char*) - 1));
 }
@@ -457,51 +457,11 @@
 {
     ASSERT(location);
     return location;
 }
 
-// This adds various C++14 features for versions of the STL that may not yet have them.
 namespace std {
-#if COMPILER(CLANG) && __cplusplus < 201400L
-template<class T> struct _Unique_if {
-    typedef unique_ptr<T> _Single_object;
-};
-
-template<class T> struct _Unique_if<T[]> {
-    typedef unique_ptr<T[]> _Unknown_bound;
-};
-
-template<class T, size_t N> struct _Unique_if<T[N]> {
-    typedef void _Known_bound;
-};
-
-template<class T, class... Args> inline typename _Unique_if<T>::_Single_object
-make_unique(Args&&... args)
-{
-    return unique_ptr<T>(new T(std::forward<Args>(args)...));
-}
-
-template<class T> inline typename _Unique_if<T>::_Unknown_bound
-make_unique(size_t n)
-{
-    typedef typename remove_extent<T>::type U;
-    return unique_ptr<T>(new U[n]());
-}
-
-template<class T, class... Args> typename _Unique_if<T>::_Known_bound
-make_unique(Args&&...) = delete;
-
-// std::exchange
-template<class T, class U = T>
-T exchange(T& t, U&& newValue)
-{
-    T oldValue = std::move(t);
-    t = std::forward<U>(newValue);
-
-    return oldValue;
-}
-#endif
 
 template<WTF::CheckMoveParameterTag, typename T>
 ALWAYS_INLINE constexpr typename remove_reference<T>::type&& move(T&& value)
 {
     static_assert(is_lvalue_reference<T>::value, "T is not an lvalue reference; move() is unnecessary.");
@@ -510,61 +470,10 @@
     static_assert(!is_const<NonRefQualifiedType>::value, "T is const qualified.");
 
     return move(forward<T>(value));
 }
 
-#if __cplusplus < 201703L && (!defined(_MSC_FULL_VER) || _MSC_FULL_VER < 190023918) && !defined(__cpp_lib_logical_traits)
-template<class...> struct wtf_conjunction_impl;
-template<> struct wtf_conjunction_impl<> : true_type { };
-template<class B0> struct wtf_conjunction_impl<B0> : B0 { };
-template<class B0, class B1> struct wtf_conjunction_impl<B0, B1> : conditional<B0::value, B1, B0>::type { };
-template<class B0, class B1, class B2, class... Bn> struct wtf_conjunction_impl<B0, B1, B2, Bn...> : conditional<B0::value, wtf_conjunction_impl<B1, B2, Bn...>, B0>::type { };
-template<class... _Args> struct conjunction : wtf_conjunction_impl<_Args...> { };
-#endif
-
-// Provide in_place_t when not building with -std=c++17, or when building with libstdc++ 6
-// (which doesn't define the _GLIBCXX_RELEASE macro that's been introduced in libstdc++ 7).
-#if ((defined(__GLIBCXX__) && !defined(_GLIBCXX_RELEASE))) && (!defined(_MSVC_LANG) || _MSVC_LANG < 201703L)
-
-// These are inline variable for C++17 and later.
-#define __IN_PLACE_INLINE_VARIABLE static const
-
-struct in_place_t {
-    explicit in_place_t() = default;
-};
-__IN_PLACE_INLINE_VARIABLE constexpr in_place_t in_place { };
-
-template <class T> struct in_place_type_t {
-    explicit in_place_type_t() = default;
-};
-template <class T>
-__IN_PLACE_INLINE_VARIABLE constexpr in_place_type_t<T> in_place_type { };
-
-template <size_t I> struct in_place_index_t {
-    explicit in_place_index_t() = default;
-};
-template <size_t I>
-__IN_PLACE_INLINE_VARIABLE constexpr in_place_index_t<I> in_place_index { };
-#endif // __cplusplus < 201703L
-
-enum class ZeroStatus {
-    MayBeZero,
-    NonZero
-};
-
-constexpr size_t clz(uint32_t value, ZeroStatus mightBeZero = ZeroStatus::MayBeZero)
-{
-    if (mightBeZero == ZeroStatus::MayBeZero && value) {
-#if COMPILER(MSVC)
-        return __lzcnt(value);
-#else
-        return __builtin_clz(value);
-#endif
-    }
-    return 32;
-}
-
 } // namespace std
 
 namespace WTF {
 
 template<class T, class... Args>

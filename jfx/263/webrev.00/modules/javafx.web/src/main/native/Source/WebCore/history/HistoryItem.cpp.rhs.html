<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/history/HistoryItem.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2005, 2006, 2008, 2011, 2014 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;HistoryItem.h&quot;
 28 
<a name="1" id="anc1"></a><span class="line-added"> 29 #include &quot;BackForwardCache.h&quot;</span>
 30 #include &quot;CachedPage.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;KeyedCoding.h&quot;
<a name="2" id="anc2"></a>
 33 #include &quot;ResourceRequest.h&quot;
 34 #include &quot;SerializedScriptValue.h&quot;
 35 #include &quot;SharedBuffer.h&quot;
 36 #include &lt;stdio.h&gt;
 37 #include &lt;wtf/DateMath.h&gt;
 38 #include &lt;wtf/DebugUtilities.h&gt;
 39 #include &lt;wtf/WallTime.h&gt;
 40 #include &lt;wtf/text/CString.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 int64_t HistoryItem::generateSequenceNumber()
 45 {
 46     // Initialize to the current time to reduce the likelihood of generating
 47     // identifiers that overlap with those from past/future browser sessions.
 48     static long long next = static_cast&lt;long long&gt;(WallTime::now().secondsSinceEpoch().microseconds());
 49     return ++next;
 50 }
 51 
 52 static void defaultNotifyHistoryItemChanged(HistoryItem&amp;)
 53 {
 54 }
 55 
 56 void (*notifyHistoryItemChanged)(HistoryItem&amp;) = defaultNotifyHistoryItemChanged;
 57 
 58 #if PLATFORM(JAVA)
 59 extern &quot;C&quot; {
 60 extern void notifyHistoryItemDestroyed(const JLObject&amp;);
 61 }
 62 #endif
 63 
 64 HistoryItem::HistoryItem()
 65     : HistoryItem({ }, { })
 66 {
 67 }
 68 
 69 HistoryItem::HistoryItem(const String&amp; urlString, const String&amp; title)
 70     : HistoryItem(urlString, title, { })
 71 {
 72 }
 73 
 74 HistoryItem::HistoryItem(const String&amp; urlString, const String&amp; title, const String&amp; alternateTitle)
 75     : HistoryItem(urlString, title, alternateTitle, { Process::identifier(), ObjectIdentifier&lt;BackForwardItemIdentifier::ItemIdentifierType&gt;::generate() })
 76 {
 77 }
 78 
 79 HistoryItem::HistoryItem(const String&amp; urlString, const String&amp; title, const String&amp; alternateTitle, BackForwardItemIdentifier BackForwardItemIdentifier)
 80     : m_urlString(urlString)
 81     , m_originalURLString(urlString)
 82     , m_title(title)
 83     , m_displayTitle(alternateTitle)
 84     , m_pruningReason(PruningReason::None)
 85     , m_identifier(BackForwardItemIdentifier)
 86 {
 87 }
 88 
 89 HistoryItem::~HistoryItem()
 90 {
 91     ASSERT(!m_cachedPage);
 92 #if PLATFORM(JAVA)
 93     if (m_hostObject) {
 94         notifyHistoryItemDestroyed(m_hostObject);
 95     }
 96 #endif
 97 }
 98 
 99 inline HistoryItem::HistoryItem(const HistoryItem&amp; item)
100     : RefCounted&lt;HistoryItem&gt;()
101     , m_urlString(item.m_urlString)
102     , m_originalURLString(item.m_originalURLString)
103     , m_referrer(item.m_referrer)
104     , m_target(item.m_target)
105     , m_title(item.m_title)
106     , m_displayTitle(item.m_displayTitle)
107     , m_scrollPosition(item.m_scrollPosition)
108     , m_pageScaleFactor(item.m_pageScaleFactor)
109     , m_lastVisitWasFailure(item.m_lastVisitWasFailure)
110     , m_isTargetItem(item.m_isTargetItem)
111     , m_itemSequenceNumber(item.m_itemSequenceNumber)
112     , m_documentSequenceNumber(item.m_documentSequenceNumber)
113     , m_formContentType(item.m_formContentType)
114     , m_pruningReason(PruningReason::None)
115 #if PLATFORM(IOS_FAMILY)
116     , m_obscuredInsets(item.m_obscuredInsets)
117     , m_scale(item.m_scale)
118     , m_scaleIsInitial(item.m_scaleIsInitial)
119 #endif
120 #if PLATFORM(JAVA)
121     , m_hostObject(item.m_hostObject)
122 #endif
123     , m_identifier(item.m_identifier)
124 {
125     if (item.m_formData)
126         m_formData = item.m_formData-&gt;copy();
127 
128     unsigned size = item.m_children.size();
129     m_children.reserveInitialCapacity(size);
130     for (unsigned i = 0; i &lt; size; ++i)
131         m_children.uncheckedAppend(item.m_children[i]-&gt;copy());
132 }
133 
134 Ref&lt;HistoryItem&gt; HistoryItem::copy() const
135 {
136     return adoptRef(*new HistoryItem(*this));
137 }
138 
139 void HistoryItem::reset()
140 {
141     m_urlString = String();
142     m_originalURLString = String();
143     m_referrer = String();
144     m_target = String();
145     m_title = String();
146     m_displayTitle = String();
147 
148     m_lastVisitWasFailure = false;
149     m_isTargetItem = false;
150 
151     m_itemSequenceNumber = generateSequenceNumber();
152 
153     m_stateObject = nullptr;
154     m_documentSequenceNumber = generateSequenceNumber();
155 
156     m_formData = nullptr;
157     m_formContentType = String();
158 
159     clearChildren();
160 }
161 
162 const String&amp; HistoryItem::urlString() const
163 {
164     return m_urlString;
165 }
166 
167 // The first URL we loaded to get to where this history item points.  Includes both client
168 // and server redirects.
169 const String&amp; HistoryItem::originalURLString() const
170 {
171     return m_originalURLString;
172 }
173 
174 const String&amp; HistoryItem::title() const
175 {
176     return m_title;
177 }
178 
179 const String&amp; HistoryItem::alternateTitle() const
180 {
181     return m_displayTitle;
182 }
183 
184 bool HistoryItem::hasCachedPageExpired() const
185 {
186     return m_cachedPage ? m_cachedPage-&gt;hasExpired() : false;
187 }
188 
<a name="3" id="anc3"></a><span class="line-added">189 void HistoryItem::setCachedPage(std::unique_ptr&lt;CachedPage&gt;&amp;&amp; cachedPage)</span>
<span class="line-added">190 {</span>
<span class="line-added">191     bool wasInBackForwardCache = isInBackForwardCache();</span>
<span class="line-added">192     m_cachedPage = WTFMove(cachedPage);</span>
<span class="line-added">193     if (wasInBackForwardCache != isInBackForwardCache())</span>
<span class="line-added">194         notifyChanged();</span>
<span class="line-added">195 }</span>
<span class="line-added">196 </span>
<span class="line-added">197 std::unique_ptr&lt;CachedPage&gt; HistoryItem::takeCachedPage()</span>
<span class="line-added">198 {</span>
<span class="line-added">199     ASSERT(m_cachedPage);</span>
<span class="line-added">200     auto cachedPage = std::exchange(m_cachedPage, nullptr);</span>
<span class="line-added">201     notifyChanged();</span>
<span class="line-added">202     return cachedPage;</span>
<span class="line-added">203 }</span>
<span class="line-added">204 </span>
205 URL HistoryItem::url() const
206 {
207     return URL({ }, m_urlString);
208 }
209 
210 URL HistoryItem::originalURL() const
211 {
212     return URL({ }, m_originalURLString);
213 }
214 
215 const String&amp; HistoryItem::referrer() const
216 {
217     return m_referrer;
218 }
219 
220 const String&amp; HistoryItem::target() const
221 {
222     return m_target;
223 }
224 
225 void HistoryItem::setAlternateTitle(const String&amp; alternateTitle)
226 {
227     m_displayTitle = alternateTitle;
228     notifyChanged();
229 }
230 
231 void HistoryItem::setURLString(const String&amp; urlString)
232 {
233     m_urlString = urlString;
234     notifyChanged();
235 }
236 
237 void HistoryItem::setURL(const URL&amp; url)
238 {
<a name="4" id="anc4"></a><span class="line-modified">239     BackForwardCache::singleton().remove(*this);</span>
240     setURLString(url.string());
241     clearDocumentState();
242 }
243 
244 void HistoryItem::setOriginalURLString(const String&amp; urlString)
245 {
246     m_originalURLString = urlString;
247     notifyChanged();
248 }
249 
250 void HistoryItem::setReferrer(const String&amp; referrer)
251 {
252     m_referrer = referrer;
253     notifyChanged();
254 }
255 
256 void HistoryItem::setTitle(const String&amp; title)
257 {
258     m_title = title;
259     notifyChanged();
260 }
261 
262 void HistoryItem::setTarget(const String&amp; target)
263 {
264     m_target = target;
265     notifyChanged();
266 }
267 
268 const IntPoint&amp; HistoryItem::scrollPosition() const
269 {
270     return m_scrollPosition;
271 }
272 
273 void HistoryItem::setScrollPosition(const IntPoint&amp; position)
274 {
275     m_scrollPosition = position;
276 }
277 
278 void HistoryItem::clearScrollPosition()
279 {
280     m_scrollPosition = IntPoint();
281 }
282 
283 bool HistoryItem::shouldRestoreScrollPosition() const
284 {
285     return m_shouldRestoreScrollPosition;
286 }
287 
288 void HistoryItem::setShouldRestoreScrollPosition(bool shouldRestore)
289 {
290     m_shouldRestoreScrollPosition = shouldRestore;
291     notifyChanged();
292 }
293 
294 float HistoryItem::pageScaleFactor() const
295 {
296     return m_pageScaleFactor;
297 }
298 
299 void HistoryItem::setPageScaleFactor(float scaleFactor)
300 {
301     m_pageScaleFactor = scaleFactor;
302 }
303 
304 void HistoryItem::setDocumentState(const Vector&lt;String&gt;&amp; state)
305 {
306     m_documentState = state;
307 }
308 
309 const Vector&lt;String&gt;&amp; HistoryItem::documentState() const
310 {
311     return m_documentState;
312 }
313 
314 void HistoryItem::clearDocumentState()
315 {
316     m_documentState.clear();
317 }
318 
319 void HistoryItem::setShouldOpenExternalURLsPolicy(ShouldOpenExternalURLsPolicy policy)
320 {
321     m_shouldOpenExternalURLsPolicy = policy;
322 }
323 
324 ShouldOpenExternalURLsPolicy HistoryItem::shouldOpenExternalURLsPolicy() const
325 {
326     return m_shouldOpenExternalURLsPolicy;
327 }
328 
329 bool HistoryItem::isTargetItem() const
330 {
331     return m_isTargetItem;
332 }
333 
334 void HistoryItem::setIsTargetItem(bool flag)
335 {
336     m_isTargetItem = flag;
337 }
338 
339 void HistoryItem::setStateObject(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; object)
340 {
341     m_stateObject = WTFMove(object);
342     notifyChanged();
343 }
344 
345 void HistoryItem::addChildItem(Ref&lt;HistoryItem&gt;&amp;&amp; child)
346 {
347     ASSERT(!childItemWithTarget(child-&gt;target()));
348     m_children.append(WTFMove(child));
349 }
350 
351 void HistoryItem::setChildItem(Ref&lt;HistoryItem&gt;&amp;&amp; child)
352 {
353     ASSERT(!child-&gt;isTargetItem());
354     unsigned size = m_children.size();
355     for (unsigned i = 0; i &lt; size; ++i)  {
356         if (m_children[i]-&gt;target() == child-&gt;target()) {
357             child-&gt;setIsTargetItem(m_children[i]-&gt;isTargetItem());
358             m_children[i] = WTFMove(child);
359             return;
360         }
361     }
362     m_children.append(WTFMove(child));
363 }
364 
365 HistoryItem* HistoryItem::childItemWithTarget(const String&amp; target)
366 {
367     unsigned size = m_children.size();
368     for (unsigned i = 0; i &lt; size; ++i) {
369         if (m_children[i]-&gt;target() == target)
370             return m_children[i].ptr();
371     }
372     return nullptr;
373 }
374 
375 HistoryItem* HistoryItem::childItemWithDocumentSequenceNumber(long long number)
376 {
377     unsigned size = m_children.size();
378     for (unsigned i = 0; i &lt; size; ++i) {
379         if (m_children[i]-&gt;documentSequenceNumber() == number)
380             return m_children[i].ptr();
381     }
382     return nullptr;
383 }
384 
385 const Vector&lt;Ref&lt;HistoryItem&gt;&gt;&amp; HistoryItem::children() const
386 {
387     return m_children;
388 }
389 
390 bool HistoryItem::hasChildren() const
391 {
392     return !m_children.isEmpty();
393 }
394 
395 void HistoryItem::clearChildren()
396 {
397     m_children.clear();
398 }
399 
400 // We do same-document navigation if going to a different item and if either of the following is true:
401 // - The other item corresponds to the same document (for history entries created via pushState or fragment changes).
402 // - The other item corresponds to the same set of documents, including frames (for history entries created via regular navigation)
403 bool HistoryItem::shouldDoSameDocumentNavigationTo(HistoryItem&amp; otherItem) const
404 {
405     // The following logic must be kept in sync with WebKit::WebBackForwardListItem::itemIsInSameDocument().
406     if (this == &amp;otherItem)
407         return false;
408 
409     if (stateObject() || otherItem.stateObject())
410         return documentSequenceNumber() == otherItem.documentSequenceNumber();
411 
412     if ((url().hasFragmentIdentifier() || otherItem.url().hasFragmentIdentifier()) &amp;&amp; equalIgnoringFragmentIdentifier(url(), otherItem.url()))
413         return documentSequenceNumber() == otherItem.documentSequenceNumber();
414 
415     return hasSameDocumentTree(otherItem);
416 }
417 
418 // Does a recursive check that this item and its descendants have the same
419 // document sequence numbers as the other item.
420 bool HistoryItem::hasSameDocumentTree(HistoryItem&amp; otherItem) const
421 {
422     if (documentSequenceNumber() != otherItem.documentSequenceNumber())
423         return false;
424 
425     if (children().size() != otherItem.children().size())
426         return false;
427 
428     for (size_t i = 0; i &lt; children().size(); i++) {
429         auto&amp; child = children()[i].get();
430         auto* otherChild = otherItem.childItemWithDocumentSequenceNumber(child.documentSequenceNumber());
431         if (!otherChild || !child.hasSameDocumentTree(*otherChild))
432             return false;
433     }
434 
435     return true;
436 }
437 
438 // Does a non-recursive check that this item and its immediate children have the
439 // same frames as the other item.
440 bool HistoryItem::hasSameFrames(HistoryItem&amp; otherItem) const
441 {
442     if (target() != otherItem.target())
443         return false;
444 
445     if (children().size() != otherItem.children().size())
446         return false;
447 
448     for (size_t i = 0; i &lt; children().size(); i++) {
449         if (!otherItem.childItemWithTarget(children()[i]-&gt;target()))
450             return false;
451     }
452 
453     return true;
454 }
455 
456 String HistoryItem::formContentType() const
457 {
458     return m_formContentType;
459 }
460 
461 void HistoryItem::setFormInfoFromRequest(const ResourceRequest&amp; request)
462 {
463     m_referrer = request.httpReferrer();
464 
465     if (equalLettersIgnoringASCIICase(request.httpMethod(), &quot;post&quot;)) {
466         // FIXME: Eventually we have to make this smart enough to handle the case where
467         // we have a stream for the body to handle the &quot;data interspersed with files&quot; feature.
468         m_formData = request.httpBody();
469         m_formContentType = request.httpContentType();
470     } else {
471         m_formData = nullptr;
472         m_formContentType = String();
473     }
474 }
475 
476 void HistoryItem::setFormData(RefPtr&lt;FormData&gt;&amp;&amp; formData)
477 {
478     m_formData = WTFMove(formData);
479 }
480 
481 void HistoryItem::setFormContentType(const String&amp; formContentType)
482 {
483     m_formContentType = formContentType;
484 }
485 
486 FormData* HistoryItem::formData()
487 {
488     return m_formData.get();
489 }
490 
491 bool HistoryItem::isCurrentDocument(Document&amp; document) const
492 {
493     // FIXME: We should find a better way to check if this is the current document.
494     return equalIgnoringFragmentIdentifier(url(), document.url());
495 }
496 
497 void HistoryItem::notifyChanged()
498 {
499     notifyHistoryItemChanged(*this);
500 }
501 
502 #if PLATFORM(JAVA)
503 JLObject HistoryItem::hostObject()
504 {
505     return m_hostObject;
506 }
507 
508 void HistoryItem::setHostObject(const JLObject&amp; host)
509 {
510     m_hostObject = host;
511 }
512 #endif
513 
514 #ifndef NDEBUG
515 
516 int HistoryItem::showTree() const
517 {
518     return showTreeWithIndent(0);
519 }
520 
521 int HistoryItem::showTreeWithIndent(unsigned indentLevel) const
522 {
523     Vector&lt;char&gt; prefix;
524     for (unsigned i = 0; i &lt; indentLevel; ++i)
525         prefix.append(&quot;  &quot;, 2);
526     prefix.append(&quot;\0&quot;, 1);
527 
528     fprintf(stderr, &quot;%s+-%s (%p)\n&quot;, prefix.data(), m_urlString.utf8().data(), this);
529 
530     int totalSubItems = 0;
531     for (unsigned i = 0; i &lt; m_children.size(); ++i)
532         totalSubItems += m_children[i]-&gt;showTreeWithIndent(indentLevel + 1);
533     return totalSubItems + 1;
534 }
535 
536 #endif
537 
538 #if !LOG_DISABLED
539 const char* HistoryItem::logString() const
540 {
541     return debugString(&quot;HistoryItem current URL &quot;, urlString(), &quot;, identifier &quot;, m_identifier.logString());
542 }
543 #endif
544 
545 } // namespace WebCore
546 
547 #ifndef NDEBUG
548 
549 int showTree(const WebCore::HistoryItem* item)
550 {
551     return item-&gt;showTree();
552 }
553 
554 #endif
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
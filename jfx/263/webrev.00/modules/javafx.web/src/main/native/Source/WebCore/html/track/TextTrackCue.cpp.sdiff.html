<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/track/TextTrackCue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextTrack.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TextTrackCue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/track/TextTrackCue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (C) 2011, 2013 Google Inc.  All rights reserved.
<span class="line-modified">  3  * Copyright (C) 2011-2017 Apple Inc. All rights reserved.</span>
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;TextTrackCue.h&quot;
 34 
 35 #if ENABLE(VIDEO_TRACK)
 36 
 37 #include &quot;CSSPropertyNames.h&quot;
 38 #include &quot;CSSValueKeywords.h&quot;

 39 #include &quot;Event.h&quot;



 40 #include &quot;Logging.h&quot;
 41 #include &quot;NodeTraversal.h&quot;


 42 #include &quot;Text.h&quot;
 43 #include &quot;TextTrack.h&quot;
 44 #include &quot;TextTrackCueList.h&quot;
 45 #include &quot;VTTCue.h&quot;
 46 #include &quot;VTTRegionList.h&quot;

 47 #include &lt;wtf/HexNumber.h&gt;
 48 #include &lt;wtf/IsoMallocInlines.h&gt;
 49 #include &lt;wtf/MathExtras.h&gt;
 50 #include &lt;wtf/NeverDestroyed.h&gt;

 51 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 52 
 53 namespace WebCore {
 54 
 55 WTF_MAKE_ISO_ALLOCATED_IMPL(TextTrackCue);

 56 
 57 const AtomString&amp; TextTrackCue::cueShadowPseudoId()
 58 {
 59     static NeverDestroyed&lt;const AtomString&gt; cue(&quot;cue&quot;, AtomString::ConstructFromLiteral);
 60     return cue;
 61 }
 62 



























































































































































 63 TextTrackCue::TextTrackCue(ScriptExecutionContext&amp; context, const MediaTime&amp; start, const MediaTime&amp; end)
 64     : m_startTime(start)
 65     , m_endTime(end)
 66     , m_scriptExecutionContext(context)
<span class="line-removed"> 67     , m_isActive(false)</span>
<span class="line-removed"> 68     , m_pauseOnExit(false)</span>
 69 {
 70     ASSERT(m_scriptExecutionContext.isDocument());
 71 }
 72 
 73 void TextTrackCue::willChange()
 74 {
 75     if (++m_processingCueChanges &gt; 1)
 76         return;
 77 
 78     if (m_track)
 79         m_track-&gt;cueWillChange(this);
 80 }
 81 
 82 void TextTrackCue::didChange()
 83 {
 84     ASSERT(m_processingCueChanges);
 85     if (--m_processingCueChanges)
 86         return;
 87 


 88     if (m_track)
 89         m_track-&gt;cueDidChange(this);
 90 }
 91 
 92 TextTrack* TextTrackCue::track() const
 93 {
 94     return m_track;
 95 }
 96 
 97 void TextTrackCue::setTrack(TextTrack* track)
 98 {
 99     m_track = track;
100 }
101 
102 void TextTrackCue::setId(const String&amp; id)
103 {
104     if (m_id == id)
105         return;
106 
107     willChange();
</pre>
<hr />
<pre>
149     m_pauseOnExit = value;
150 }
151 
152 void TextTrackCue::dispatchEvent(Event&amp; event)
153 {
154     // When a TextTrack&#39;s mode is disabled: no cues are active, no events fired.
155     if (!track() || track()-&gt;mode() == TextTrack::Mode::Disabled)
156         return;
157 
158     EventTarget::dispatchEvent(event);
159 }
160 
161 bool TextTrackCue::isActive()
162 {
163     return m_isActive &amp;&amp; track() &amp;&amp; track()-&gt;mode() != TextTrack::Mode::Disabled;
164 }
165 
166 void TextTrackCue::setIsActive(bool active)
167 {
168     m_isActive = active;
















169 }
170 
171 bool TextTrackCue::isOrderedBefore(const TextTrackCue* other) const
172 {
<span class="line-modified">173     return startMediaTime() &lt; other-&gt;startMediaTime() || (startMediaTime() == other-&gt;startMediaTime() &amp;&amp; endMediaTime() &gt; other-&gt;endMediaTime());</span>











174 }
175 
176 bool TextTrackCue::cueContentsMatch(const TextTrackCue&amp; cue) const
177 {
178     if (cueType() != cue.cueType())
179         return false;
180 
181     if (id() != cue.id())
182         return false;
183 
184     return true;
185 }
186 
187 bool TextTrackCue::isEqual(const TextTrackCue&amp; cue, TextTrackCue::CueMatchRules match) const
188 {
189     if (cueType() != cue.cueType())
190         return false;
191 
192     if (match != IgnoreDuration &amp;&amp; endMediaTime() != cue.endMediaTime())
193         return false;
</pre>
<hr />
<pre>
208         startTimeVariance = cue.track()-&gt;startTimeVariance();
209 
210     return abs(abs(startMediaTime()) - abs(cue.startMediaTime())) &lt;= startTimeVariance;
211 }
212 
213 bool TextTrackCue::doesExtendCue(const TextTrackCue&amp; cue) const
214 {
215     if (!cueContentsMatch(cue))
216         return false;
217 
218     if (endMediaTime() != cue.startMediaTime())
219         return false;
220 
221     return true;
222 }
223 
224 void TextTrackCue::toJSON(JSON::Object&amp; value) const
225 {
226     ASCIILiteral type = &quot;Generic&quot;_s;
227     switch (cueType()) {
<span class="line-modified">228     case TextTrackCue::Generic:</span>
<span class="line-modified">229         type = &quot;Generic&quot;_s;</span>
230         break;
231     case TextTrackCue::WebVTT:
232         type = &quot;WebVTT&quot;_s;
233         break;
234     case TextTrackCue::Data:
235         type = &quot;Data&quot;_s;
236         break;



237     }
238 
239     value.setString(&quot;type&quot;_s, type);
240     value.setDouble(&quot;startTime&quot;_s, startTime());
241     value.setDouble(&quot;endTime&quot;_s, endTime());
242 }
243 
244 String TextTrackCue::toJSONString() const
245 {
246     auto object = JSON::Object::create();
247 
248     toJSON(object.get());
249 
250     return object-&gt;toJSONString();
251 }
252 
<span class="line-modified">253 String TextTrackCue::debugString() const</span>


254 {
255     String text;
<span class="line-modified">256     if (isRenderable())</span>
<span class="line-modified">257         text = toVTTCue(this)-&gt;text();</span>
<span class="line-modified">258     return makeString(&quot;0x&quot;, hex(reinterpret_cast&lt;uintptr_t&gt;(this)), &quot; id=&quot;, id(), &quot; interval=&quot;, startTime(), &quot;--&gt;&quot;, endTime(), &quot; cue=&quot;, text, &#39;)&#39;);</span>



































































































259 }
260 
261 } // namespace WebCore
262 
263 #endif
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (C) 2011, 2013 Google Inc.  All rights reserved.
<span class="line-modified">  3  * Copyright (C) 2011-2020 Apple Inc. All rights reserved.</span>
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;TextTrackCue.h&quot;
 34 
 35 #if ENABLE(VIDEO_TRACK)
 36 
 37 #include &quot;CSSPropertyNames.h&quot;
 38 #include &quot;CSSValueKeywords.h&quot;
<span class="line-added"> 39 #include &quot;DOMRect.h&quot;</span>
 40 #include &quot;Event.h&quot;
<span class="line-added"> 41 #include &quot;HTMLCollection.h&quot;</span>
<span class="line-added"> 42 #include &quot;HTMLDivElement.h&quot;</span>
<span class="line-added"> 43 #include &quot;HTMLStyleElement.h&quot;</span>
 44 #include &quot;Logging.h&quot;
 45 #include &quot;NodeTraversal.h&quot;
<span class="line-added"> 46 #include &quot;Page.h&quot;</span>
<span class="line-added"> 47 #include &quot;ScriptDisallowedScope.h&quot;</span>
 48 #include &quot;Text.h&quot;
 49 #include &quot;TextTrack.h&quot;
 50 #include &quot;TextTrackCueList.h&quot;
 51 #include &quot;VTTCue.h&quot;
 52 #include &quot;VTTRegionList.h&quot;
<span class="line-added"> 53 #include &lt;limits.h&gt;</span>
 54 #include &lt;wtf/HexNumber.h&gt;
 55 #include &lt;wtf/IsoMallocInlines.h&gt;
 56 #include &lt;wtf/MathExtras.h&gt;
 57 #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-added"> 58 #include &lt;wtf/OptionSet.h&gt;</span>
 59 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 60 
 61 namespace WebCore {
 62 
 63 WTF_MAKE_ISO_ALLOCATED_IMPL(TextTrackCue);
<span class="line-added"> 64 WTF_MAKE_ISO_ALLOCATED_IMPL(TextTrackCueBox);</span>
 65 
 66 const AtomString&amp; TextTrackCue::cueShadowPseudoId()
 67 {
 68     static NeverDestroyed&lt;const AtomString&gt; cue(&quot;cue&quot;, AtomString::ConstructFromLiteral);
 69     return cue;
 70 }
 71 
<span class="line-added"> 72 const AtomString&amp; TextTrackCue::cueBoxShadowPseudoId()</span>
<span class="line-added"> 73 {</span>
<span class="line-added"> 74     static NeverDestroyed&lt;const AtomString&gt; trackDisplayBoxShadowPseudoId(&quot;-webkit-media-text-track-display&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-added"> 75     return trackDisplayBoxShadowPseudoId;</span>
<span class="line-added"> 76 }</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78 const AtomString&amp; TextTrackCue::cueBackdropShadowPseudoId()</span>
<span class="line-added"> 79 {</span>
<span class="line-added"> 80     static NeverDestroyed&lt;const AtomString&gt; cueBackdropShadowPseudoId(&quot;-webkit-media-text-track-display-backdrop&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-added"> 81     return cueBackdropShadowPseudoId;</span>
<span class="line-added"> 82 }</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 static const QualifiedName&amp; cueAttributName()</span>
<span class="line-added"> 85 {</span>
<span class="line-added"> 86     static NeverDestroyed&lt;QualifiedName&gt; cueTag(nullAtom(), &quot;cue&quot;, nullAtom());</span>
<span class="line-added"> 87     return cueTag;</span>
<span class="line-added"> 88 }</span>
<span class="line-added"> 89 </span>
<span class="line-added"> 90 static const QualifiedName&amp; cueBackgroundAttributName()</span>
<span class="line-added"> 91 {</span>
<span class="line-added"> 92     static NeverDestroyed&lt;QualifiedName&gt; cueBackgroundTag(nullAtom(), &quot;cuebackground&quot;, nullAtom());</span>
<span class="line-added"> 93     return cueBackgroundTag;</span>
<span class="line-added"> 94 }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96 TextTrackCueBox::TextTrackCueBox(Document&amp; document, TextTrackCue&amp; cue)</span>
<span class="line-added"> 97     : HTMLElement(HTMLNames::divTag, document)</span>
<span class="line-added"> 98     , m_cue(makeWeakPtr(cue))</span>
<span class="line-added"> 99 {</span>
<span class="line-added">100     setHasCustomStyleResolveCallbacks();</span>
<span class="line-added">101     setPseudo(TextTrackCue::cueBoxShadowPseudoId());</span>
<span class="line-added">102 }</span>
<span class="line-added">103 </span>
<span class="line-added">104 TextTrackCue* TextTrackCueBox::getCue() const</span>
<span class="line-added">105 {</span>
<span class="line-added">106     return m_cue.get();</span>
<span class="line-added">107 }</span>
<span class="line-added">108 </span>
<span class="line-added">109 static inline bool isLegalNode(Node&amp; node)</span>
<span class="line-added">110 {</span>
<span class="line-added">111     return node.hasTagName(HTMLNames::brTag)</span>
<span class="line-added">112         || node.hasTagName(HTMLNames::divTag)</span>
<span class="line-added">113         || node.hasTagName(HTMLNames::imgTag)</span>
<span class="line-added">114         || node.hasTagName(HTMLNames::pTag)</span>
<span class="line-added">115         || node.hasTagName(HTMLNames::rbTag)</span>
<span class="line-added">116         || node.hasTagName(HTMLNames::rtTag)</span>
<span class="line-added">117         || node.hasTagName(HTMLNames::rtcTag)</span>
<span class="line-added">118         || node.hasTagName(HTMLNames::rubyTag)</span>
<span class="line-added">119         || node.hasTagName(HTMLNames::spanTag)</span>
<span class="line-added">120         || node.nodeType() == Node::TEXT_NODE;</span>
<span class="line-added">121 }</span>
<span class="line-added">122 </span>
<span class="line-added">123 static Exception invalidNodeException(Node&amp; node)</span>
<span class="line-added">124 {</span>
<span class="line-added">125     return Exception { InvalidNodeTypeError, makeString(&quot;Invalid node type: &quot;, node.nodeName()) };</span>
<span class="line-added">126 }</span>
<span class="line-added">127 </span>
<span class="line-added">128 static ExceptionOr&lt;void&gt; checkForInvalidNodeTypes(Node&amp; root)</span>
<span class="line-added">129 {</span>
<span class="line-added">130     if (!isLegalNode(root))</span>
<span class="line-added">131         return invalidNodeException(root);</span>
<span class="line-added">132 </span>
<span class="line-added">133     for (auto* child = root.firstChild(); child; child = child-&gt;nextSibling()) {</span>
<span class="line-added">134         if (!isLegalNode(*child))</span>
<span class="line-added">135             return invalidNodeException(*child);</span>
<span class="line-added">136 </span>
<span class="line-added">137         if (is&lt;ContainerNode&gt;(*child)) {</span>
<span class="line-added">138             auto result = checkForInvalidNodeTypes(*child);</span>
<span class="line-added">139             if (result.hasException())</span>
<span class="line-added">140                 return result.releaseException();</span>
<span class="line-added">141         }</span>
<span class="line-added">142     }</span>
<span class="line-added">143 </span>
<span class="line-added">144     return { };</span>
<span class="line-added">145 }</span>
<span class="line-added">146 </span>
<span class="line-added">147 enum RequiredNodes {</span>
<span class="line-added">148     Cue = 1 &lt;&lt; 0,</span>
<span class="line-added">149     CueBackground = 1 &lt;&lt; 1,</span>
<span class="line-added">150 };</span>
<span class="line-added">151 </span>
<span class="line-added">152 static OptionSet&lt;RequiredNodes&gt; tagPseudoObjects(Node&amp; node)</span>
<span class="line-added">153 {</span>
<span class="line-added">154     if (!is&lt;Element&gt;(node))</span>
<span class="line-added">155         return { };</span>
<span class="line-added">156 </span>
<span class="line-added">157     OptionSet&lt;RequiredNodes&gt; nodeTypes = { };</span>
<span class="line-added">158 </span>
<span class="line-added">159     auto&amp; element = downcast&lt;Element&gt;(node);</span>
<span class="line-added">160     if (element.hasAttributeWithoutSynchronization(cueAttributName())) {</span>
<span class="line-added">161         element.setPseudo(TextTrackCue::cueShadowPseudoId());</span>
<span class="line-added">162         nodeTypes = { RequiredNodes::Cue };</span>
<span class="line-added">163     } else if (element.hasAttributeWithoutSynchronization(cueBackgroundAttributName())) {</span>
<span class="line-added">164         element.setPseudo(TextTrackCue::cueBackdropShadowPseudoId());</span>
<span class="line-added">165         nodeTypes = { RequiredNodes::CueBackground };</span>
<span class="line-added">166     }</span>
<span class="line-added">167 </span>
<span class="line-added">168     for (auto* child = element.firstChild(); child; child = child-&gt;nextSibling())</span>
<span class="line-added">169         nodeTypes.add(tagPseudoObjects(*child));</span>
<span class="line-added">170 </span>
<span class="line-added">171     return nodeTypes;</span>
<span class="line-added">172 }</span>
<span class="line-added">173 </span>
<span class="line-added">174 static void removePseudoAttributes(Node&amp; node)</span>
<span class="line-added">175 {</span>
<span class="line-added">176     if (!is&lt;Element&gt;(node))</span>
<span class="line-added">177         return;</span>
<span class="line-added">178 </span>
<span class="line-added">179     auto&amp; element = downcast&lt;Element&gt;(node);</span>
<span class="line-added">180     if (element.hasAttributeWithoutSynchronization(cueAttributName()) || element.hasAttributeWithoutSynchronization(cueBackgroundAttributName()))</span>
<span class="line-added">181         element.removeAttribute(HTMLNames::pseudoAttr);</span>
<span class="line-added">182 </span>
<span class="line-added">183     for (auto* child = element.firstChild(); child; child = child-&gt;nextSibling())</span>
<span class="line-added">184         removePseudoAttributes(*child);</span>
<span class="line-added">185 }</span>
<span class="line-added">186 </span>
<span class="line-added">187 ExceptionOr&lt;Ref&lt;TextTrackCue&gt;&gt; TextTrackCue::create(ScriptExecutionContext&amp; context, double start, double end, DocumentFragment&amp; cueDocument)</span>
<span class="line-added">188 {</span>
<span class="line-added">189     ASSERT(context.isDocument());</span>
<span class="line-added">190     ASSERT(is&lt;DocumentFragment&gt;(cueDocument));</span>
<span class="line-added">191 </span>
<span class="line-added">192     if (!cueDocument.firstChild())</span>
<span class="line-added">193         return Exception { InvalidNodeTypeError, &quot;Empty cue fragment&quot; };</span>
<span class="line-added">194 </span>
<span class="line-added">195     for (Node* node = cueDocument.firstChild(); node; node = node-&gt;nextSibling()) {</span>
<span class="line-added">196         auto result = checkForInvalidNodeTypes(*node);</span>
<span class="line-added">197         if (result.hasException())</span>
<span class="line-added">198             return result.releaseException();</span>
<span class="line-added">199     }</span>
<span class="line-added">200 </span>
<span class="line-added">201     auto fragment = DocumentFragment::create(downcast&lt;Document&gt;(context));</span>
<span class="line-added">202     for (Node* node = cueDocument.firstChild(); node; node = node-&gt;nextSibling()) {</span>
<span class="line-added">203         auto result = fragment-&gt;ensurePreInsertionValidity(*node, nullptr);</span>
<span class="line-added">204         if (result.hasException())</span>
<span class="line-added">205             return result.releaseException();</span>
<span class="line-added">206     }</span>
<span class="line-added">207     cueDocument.cloneChildNodes(fragment);</span>
<span class="line-added">208 </span>
<span class="line-added">209     OptionSet&lt;RequiredNodes&gt; nodeTypes = { };</span>
<span class="line-added">210     for (Node* node = fragment-&gt;firstChild(); node; node = node-&gt;nextSibling())</span>
<span class="line-added">211         nodeTypes.add(tagPseudoObjects(*node));</span>
<span class="line-added">212 </span>
<span class="line-added">213     if (!nodeTypes.contains(RequiredNodes::Cue))</span>
<span class="line-added">214         return Exception { InvalidStateError, makeString(&quot;Missing required attribute: &quot;, cueAttributName().toString()) };</span>
<span class="line-added">215     if (!nodeTypes.contains(RequiredNodes::CueBackground))</span>
<span class="line-added">216         return Exception { InvalidStateError, makeString(&quot;Missing required attribute: &quot;, cueBackgroundAttributName().toString()) };</span>
<span class="line-added">217 </span>
<span class="line-added">218     return adoptRef(*new TextTrackCue(context, MediaTime::createWithDouble(start), MediaTime::createWithDouble(end), WTFMove(fragment.get())));</span>
<span class="line-added">219 }</span>
<span class="line-added">220 </span>
<span class="line-added">221 TextTrackCue::TextTrackCue(ScriptExecutionContext&amp; context, const MediaTime&amp; start, const MediaTime&amp; end, DocumentFragment&amp;&amp; cueFragment)</span>
<span class="line-added">222     : TextTrackCue(context, start, end)</span>
<span class="line-added">223 {</span>
<span class="line-added">224     m_cueNode = &amp;cueFragment;</span>
<span class="line-added">225 }</span>
<span class="line-added">226 </span>
227 TextTrackCue::TextTrackCue(ScriptExecutionContext&amp; context, const MediaTime&amp; start, const MediaTime&amp; end)
228     : m_startTime(start)
229     , m_endTime(end)
230     , m_scriptExecutionContext(context)


231 {
232     ASSERT(m_scriptExecutionContext.isDocument());
233 }
234 
235 void TextTrackCue::willChange()
236 {
237     if (++m_processingCueChanges &gt; 1)
238         return;
239 
240     if (m_track)
241         m_track-&gt;cueWillChange(this);
242 }
243 
244 void TextTrackCue::didChange()
245 {
246     ASSERT(m_processingCueChanges);
247     if (--m_processingCueChanges)
248         return;
249 
<span class="line-added">250     m_displayTreeNeedsUpdate = true;</span>
<span class="line-added">251 </span>
252     if (m_track)
253         m_track-&gt;cueDidChange(this);
254 }
255 
256 TextTrack* TextTrackCue::track() const
257 {
258     return m_track;
259 }
260 
261 void TextTrackCue::setTrack(TextTrack* track)
262 {
263     m_track = track;
264 }
265 
266 void TextTrackCue::setId(const String&amp; id)
267 {
268     if (m_id == id)
269         return;
270 
271     willChange();
</pre>
<hr />
<pre>
313     m_pauseOnExit = value;
314 }
315 
316 void TextTrackCue::dispatchEvent(Event&amp; event)
317 {
318     // When a TextTrack&#39;s mode is disabled: no cues are active, no events fired.
319     if (!track() || track()-&gt;mode() == TextTrack::Mode::Disabled)
320         return;
321 
322     EventTarget::dispatchEvent(event);
323 }
324 
325 bool TextTrackCue::isActive()
326 {
327     return m_isActive &amp;&amp; track() &amp;&amp; track()-&gt;mode() != TextTrack::Mode::Disabled;
328 }
329 
330 void TextTrackCue::setIsActive(bool active)
331 {
332     m_isActive = active;
<span class="line-added">333 </span>
<span class="line-added">334     if (m_isActive || !m_displayTree)</span>
<span class="line-added">335         return;</span>
<span class="line-added">336 </span>
<span class="line-added">337     // The display tree is never exposed to author scripts so it&#39;s safe to dispatch events here.</span>
<span class="line-added">338     ScriptDisallowedScope::EventAllowedScope allowedScope(*m_displayTree);</span>
<span class="line-added">339     m_displayTree-&gt;remove();</span>
<span class="line-added">340 }</span>
<span class="line-added">341 </span>
<span class="line-added">342 unsigned TextTrackCue::cueIndex() const</span>
<span class="line-added">343 {</span>
<span class="line-added">344     ASSERT(m_track &amp;&amp; m_track-&gt;cues());</span>
<span class="line-added">345     if (!m_track || !m_track-&gt;cues())</span>
<span class="line-added">346         return std::numeric_limits&lt;unsigned&gt;::max();</span>
<span class="line-added">347 </span>
<span class="line-added">348     return m_track-&gt;cues()-&gt;cueIndex(*this);</span>
349 }
350 
351 bool TextTrackCue::isOrderedBefore(const TextTrackCue* other) const
352 {
<span class="line-modified">353     // ... cues must be sorted by their start time, earliest first;</span>
<span class="line-added">354     if (startMediaTime() != other-&gt;startMediaTime())</span>
<span class="line-added">355         return startMediaTime() &lt; other-&gt;startMediaTime();</span>
<span class="line-added">356 </span>
<span class="line-added">357     // then, any cues with the same start time must be sorted by their end time, latest first;</span>
<span class="line-added">358     if (endMediaTime() != other-&gt;endMediaTime())</span>
<span class="line-added">359         return endMediaTime() &gt; other-&gt;endMediaTime();</span>
<span class="line-added">360 </span>
<span class="line-added">361     // and finally, any cues with identical end times must be sorted in the order they were last added to</span>
<span class="line-added">362     // their respective text track list of cues, oldest first (so e.g. for cues from a WebVTT file, that</span>
<span class="line-added">363     // would initially be the order in which the cues were listed in the file)</span>
<span class="line-added">364     return cueIndex() &lt; other-&gt;cueIndex();</span>
365 }
366 
367 bool TextTrackCue::cueContentsMatch(const TextTrackCue&amp; cue) const
368 {
369     if (cueType() != cue.cueType())
370         return false;
371 
372     if (id() != cue.id())
373         return false;
374 
375     return true;
376 }
377 
378 bool TextTrackCue::isEqual(const TextTrackCue&amp; cue, TextTrackCue::CueMatchRules match) const
379 {
380     if (cueType() != cue.cueType())
381         return false;
382 
383     if (match != IgnoreDuration &amp;&amp; endMediaTime() != cue.endMediaTime())
384         return false;
</pre>
<hr />
<pre>
399         startTimeVariance = cue.track()-&gt;startTimeVariance();
400 
401     return abs(abs(startMediaTime()) - abs(cue.startMediaTime())) &lt;= startTimeVariance;
402 }
403 
404 bool TextTrackCue::doesExtendCue(const TextTrackCue&amp; cue) const
405 {
406     if (!cueContentsMatch(cue))
407         return false;
408 
409     if (endMediaTime() != cue.startMediaTime())
410         return false;
411 
412     return true;
413 }
414 
415 void TextTrackCue::toJSON(JSON::Object&amp; value) const
416 {
417     ASCIILiteral type = &quot;Generic&quot;_s;
418     switch (cueType()) {
<span class="line-modified">419     case TextTrackCue::ConvertedToWebVTT:</span>
<span class="line-modified">420         type = &quot;ConvertedToWebVTT&quot;_s;</span>
421         break;
422     case TextTrackCue::WebVTT:
423         type = &quot;WebVTT&quot;_s;
424         break;
425     case TextTrackCue::Data:
426         type = &quot;Data&quot;_s;
427         break;
<span class="line-added">428     case TextTrackCue::Generic:</span>
<span class="line-added">429         type = &quot;Generic&quot;_s;</span>
<span class="line-added">430         break;</span>
431     }
432 
433     value.setString(&quot;type&quot;_s, type);
434     value.setDouble(&quot;startTime&quot;_s, startTime());
435     value.setDouble(&quot;endTime&quot;_s, endTime());
436 }
437 
438 String TextTrackCue::toJSONString() const
439 {
440     auto object = JSON::Object::create();
441 
442     toJSON(object.get());
443 
444     return object-&gt;toJSONString();
445 }
446 
<span class="line-modified">447 #ifndef NDEBUG</span>
<span class="line-added">448 </span>
<span class="line-added">449 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const TextTrackCue&amp; cue)</span>
450 {
451     String text;
<span class="line-modified">452     if (is&lt;VTTCue&gt;(cue))</span>
<span class="line-modified">453         text = toVTTCue(&amp;cue)-&gt;text();</span>
<span class="line-modified">454     return stream &lt;&lt; &amp;cue &lt;&lt; &quot; id=&quot; &lt;&lt; cue.id() &lt;&lt; &quot; interval=&quot; &lt;&lt; cue.startTime() &lt;&lt; &quot;--&gt;&quot; &lt;&lt; cue.endTime() &lt;&lt; &quot; cue=&quot; &lt;&lt; text &lt;&lt; &#39;)&#39;;</span>
<span class="line-added">455 }</span>
<span class="line-added">456 </span>
<span class="line-added">457 #endif</span>
<span class="line-added">458 </span>
<span class="line-added">459 RefPtr&lt;DocumentFragment&gt; TextTrackCue::getCueAsHTML()</span>
<span class="line-added">460 {</span>
<span class="line-added">461     if (!m_cueNode)</span>
<span class="line-added">462         return nullptr;</span>
<span class="line-added">463 </span>
<span class="line-added">464     auto clonedFragment = DocumentFragment::create(ownerDocument());</span>
<span class="line-added">465     m_cueNode-&gt;cloneChildNodes(clonedFragment);</span>
<span class="line-added">466 </span>
<span class="line-added">467     for (Node* node = clonedFragment-&gt;firstChild(); node; node = node-&gt;nextSibling())</span>
<span class="line-added">468         removePseudoAttributes(*node);</span>
<span class="line-added">469 </span>
<span class="line-added">470     return clonedFragment;</span>
<span class="line-added">471 }</span>
<span class="line-added">472 </span>
<span class="line-added">473 bool TextTrackCue::isRenderable() const</span>
<span class="line-added">474 {</span>
<span class="line-added">475     return m_cueNode &amp;&amp; m_cueNode-&gt;firstChild();</span>
<span class="line-added">476 }</span>
<span class="line-added">477 </span>
<span class="line-added">478 RefPtr&lt;TextTrackCueBox&gt; TextTrackCue::getDisplayTree(const IntSize&amp;, int)</span>
<span class="line-added">479 {</span>
<span class="line-added">480     if (m_displayTree &amp;&amp; !m_displayTreeNeedsUpdate)</span>
<span class="line-added">481         return m_displayTree;</span>
<span class="line-added">482 </span>
<span class="line-added">483     rebuildDisplayTree();</span>
<span class="line-added">484 </span>
<span class="line-added">485     return m_displayTree;</span>
<span class="line-added">486 }</span>
<span class="line-added">487 </span>
<span class="line-added">488 void TextTrackCue::removeDisplayTree()</span>
<span class="line-added">489 {</span>
<span class="line-added">490     if (!m_displayTree)</span>
<span class="line-added">491         return;</span>
<span class="line-added">492 </span>
<span class="line-added">493     // The display tree is never exposed to author scripts so it&#39;s safe to dispatch events here.</span>
<span class="line-added">494     ScriptDisallowedScope::EventAllowedScope allowedScope(*m_displayTree);</span>
<span class="line-added">495     m_displayTree-&gt;remove();</span>
<span class="line-added">496 }</span>
<span class="line-added">497 </span>
<span class="line-added">498 void TextTrackCue::setFontSize(int fontSize, const IntSize&amp;, bool important)</span>
<span class="line-added">499 {</span>
<span class="line-added">500     if (fontSize == m_fontSize &amp;&amp; important == m_fontSizeIsImportant)</span>
<span class="line-added">501         return;</span>
<span class="line-added">502 </span>
<span class="line-added">503     m_displayTreeNeedsUpdate = true;</span>
<span class="line-added">504     m_fontSizeIsImportant = important;</span>
<span class="line-added">505     m_fontSize = fontSize;</span>
<span class="line-added">506 }</span>
<span class="line-added">507 </span>
<span class="line-added">508 void TextTrackCue::rebuildDisplayTree()</span>
<span class="line-added">509 {</span>
<span class="line-added">510     if (!m_cueNode)</span>
<span class="line-added">511         return;</span>
<span class="line-added">512 </span>
<span class="line-added">513     ScriptDisallowedScope::EventAllowedScope allowedScopeForReferenceTree(*m_cueNode);</span>
<span class="line-added">514 </span>
<span class="line-added">515     if (!m_displayTree) {</span>
<span class="line-added">516         m_displayTree = TextTrackCueBox::create(ownerDocument(), *this);</span>
<span class="line-added">517         m_displayTree-&gt;setPseudo(AtomString(&quot;-webkit-generic-cue-root&quot;, AtomString::ConstructFromLiteral));</span>
<span class="line-added">518     }</span>
<span class="line-added">519 </span>
<span class="line-added">520     m_displayTree-&gt;removeChildren();</span>
<span class="line-added">521     auto clonedFragment = DocumentFragment::create(ownerDocument());</span>
<span class="line-added">522     m_cueNode-&gt;cloneChildNodes(clonedFragment);</span>
<span class="line-added">523     m_displayTree-&gt;appendChild(clonedFragment);</span>
<span class="line-added">524 </span>
<span class="line-added">525     if (m_fontSize &amp;&amp; ownerDocument().page()) {</span>
<span class="line-added">526         StringBuilder builder;</span>
<span class="line-added">527         builder.append(ownerDocument().page()-&gt;captionUserPreferencesStyleSheet());</span>
<span class="line-added">528         builder.appendLiteral(&quot; ::&quot;);</span>
<span class="line-added">529         builder.append(TextTrackCue::cueShadowPseudoId());</span>
<span class="line-added">530         builder.append(&#39;{&#39;);</span>
<span class="line-added">531         builder.append(getPropertyNameString(CSSPropertyFontSize));</span>
<span class="line-added">532         builder.append(&#39;:&#39;);</span>
<span class="line-added">533         builder.append(makeString(m_fontSize, &quot;px&quot;));</span>
<span class="line-added">534         if (m_fontSizeIsImportant)</span>
<span class="line-added">535             builder.appendLiteral(&quot; !important&quot;);</span>
<span class="line-added">536         builder.appendLiteral(&quot;; }&quot;);</span>
<span class="line-added">537 </span>
<span class="line-added">538         auto style = HTMLStyleElement::create(HTMLNames::styleTag, ownerDocument(), false);</span>
<span class="line-added">539         style-&gt;setTextContent(builder.toString());</span>
<span class="line-added">540         m_displayTree-&gt;appendChild(style);</span>
<span class="line-added">541     }</span>
<span class="line-added">542 </span>
<span class="line-added">543     if (track()) {</span>
<span class="line-added">544         if (const auto&amp; styleSheets = track()-&gt;styleSheets()) {</span>
<span class="line-added">545             for (const auto&amp; cssString : *styleSheets) {</span>
<span class="line-added">546                 auto style = HTMLStyleElement::create(HTMLNames::styleTag, m_displayTree-&gt;document(), false);</span>
<span class="line-added">547                 style-&gt;setTextContent(cssString);</span>
<span class="line-added">548                 m_displayTree-&gt;appendChild(style);</span>
<span class="line-added">549             }</span>
<span class="line-added">550         }</span>
<span class="line-added">551     }</span>
<span class="line-added">552 </span>
<span class="line-added">553     m_displayTreeNeedsUpdate = false;</span>
554 }
555 
556 } // namespace WebCore
557 
558 #endif
</pre>
</td>
</tr>
</table>
<center><a href="TextTrack.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TextTrackCue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
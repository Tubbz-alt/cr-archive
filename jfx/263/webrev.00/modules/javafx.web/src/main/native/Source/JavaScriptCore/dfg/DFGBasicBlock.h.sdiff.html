<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGBasicBlock.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGBasicBlock.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGBlockInsertionSet.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGBasicBlock.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DFGAbstractValue.h&quot;
 31 #include &quot;DFGAvailabilityMap.h&quot;
 32 #include &quot;DFGBranchDirection.h&quot;
 33 #include &quot;DFGNode.h&quot;
 34 #include &quot;DFGNodeAbstractValuePair.h&quot;
 35 #include &quot;DFGStructureClobberState.h&quot;
 36 #include &quot;Operands.h&quot;
 37 #include &lt;wtf/Vector.h&gt;
 38 
 39 namespace JSC { namespace DFG {
 40 
 41 class Graph;
 42 class InsertionSet;
 43 
 44 typedef Vector&lt;BasicBlock*, 2&gt; PredecessorList;
 45 typedef Vector&lt;Node*, 8&gt; BlockNodeList;
 46 


 47 struct BasicBlock : RefCounted&lt;BasicBlock&gt; {

 48     BasicBlock(
<span class="line-modified"> 49         unsigned bytecodeBegin, unsigned numArguments, unsigned numLocals,</span>
 50         float executionCount);
 51     ~BasicBlock();
 52 
 53     void ensureLocals(unsigned newNumLocals);

 54 
 55     size_t size() const { return m_nodes.size(); }
 56     bool isEmpty() const { return !size(); }
 57     Node*&amp; at(size_t i) { return m_nodes[i]; }
 58     Node* at(size_t i) const { return m_nodes[i]; }
 59     Node* tryAt(size_t i) const
 60     {
 61         if (i &gt;= size())
 62             return nullptr;
 63         return at(i);
 64     }
 65     Node*&amp; operator[](size_t i) { return at(i); }
 66     Node* operator[](size_t i) const { return at(i); }
 67     Node* last() const
 68     {
 69         RELEASE_ASSERT(!!size());
 70         return at(size() - 1);
 71     }
 72 
 73     // Use this to find both the index of the terminal and the terminal itself in one go. May
</pre>
<hr />
<pre>
154     {
155         return terminal()-&gt;successors();
156     }
157 
158     void removePredecessor(BasicBlock* block);
159     void replacePredecessor(BasicBlock* from, BasicBlock* to);
160 
161     template&lt;typename... Params&gt;
162     Node* appendNode(Graph&amp;, SpeculatedType, Params...);
163 
164     template&lt;typename... Params&gt;
165     Node* appendNonTerminal(Graph&amp;, SpeculatedType, Params...);
166 
167     template&lt;typename... Params&gt;
168     Node* replaceTerminal(Graph&amp;, SpeculatedType, Params...);
169 
170     void dump(PrintStream&amp; out) const;
171 
172     void didLink()
173     {
<span class="line-modified">174 #if !ASSERT_DISABLED</span>
175         isLinked = true;
176 #endif
177     }
178 
179     // This value is used internally for block linking and OSR entry. It is mostly meaningless
180     // for other purposes due to inlining.
<span class="line-modified">181     unsigned bytecodeBegin;</span>
182 
183     BlockIndex index;
184 
185     StructureClobberState cfaStructureClobberStateAtHead;
186     StructureClobberState cfaStructureClobberStateAtTail;
187     BranchDirection cfaBranchDirection;
188     bool cfaHasVisited;
189     bool cfaShouldRevisit;
<span class="line-modified">190     bool cfaFoundConstants;</span>
191     bool cfaDidFinish;
192     bool intersectionOfCFAHasVisited;
193     bool isOSRTarget;
194     bool isCatchEntrypoint;
195 
<span class="line-modified">196 #if !ASSERT_DISABLED</span>
197     bool isLinked;
198 #endif
199     bool isReachable;
200 
201     Vector&lt;Node*&gt; phis;
202     PredecessorList predecessors;
203 
204     Operands&lt;Node*&gt; variablesAtHead;
205     Operands&lt;Node*&gt; variablesAtTail;
206 
207     Operands&lt;AbstractValue&gt; valuesAtHead;
208     Operands&lt;AbstractValue&gt; valuesAtTail;
209 
210     // The intersection of assumptions we have made previously at the head of this block. Note
211     // that under normal circumstances, each time we run the CFA, we will get strictly more precise
212     // results. But we don&#39;t actually require this to be the case. It&#39;s fine for the CFA to loosen
213     // up for any odd reason. It&#39;s fine when this happens, because anything that the CFA proves
214     // must be true from that point forward, except if some registered watchpoint fires, in which
215     // case the code won&#39;t ever run. So, the CFA proving something less precise later on is just an
216     // outcome of the CFA being imperfect; the more precise thing that it had proved earlier is no
</pre>
<hr />
<pre>
242         AvailabilityMap availabilityAtHead;
243         AvailabilityMap availabilityAtTail;
244 
245         Vector&lt;NodeFlowProjection&gt; liveAtHead;
246         Vector&lt;NodeFlowProjection&gt; liveAtTail;
247         Vector&lt;NodeAbstractValuePair&gt; valuesAtHead;
248         Vector&lt;NodeAbstractValuePair&gt; valuesAtTail;
249 
250         SSAData(BasicBlock*);
251         ~SSAData();
252     };
253     std::unique_ptr&lt;SSAData&gt; ssa;
254 
255 private:
256     friend class InsertionSet;
257     BlockNodeList m_nodes;
258 };
259 
260 typedef Vector&lt;BasicBlock*&gt; BlockList;
261 
<span class="line-modified">262 static inline unsigned getBytecodeBeginForBlock(BasicBlock** basicBlock)</span>
263 {
264     return (*basicBlock)-&gt;bytecodeBegin;
265 }
266 
<span class="line-modified">267 static inline BasicBlock* blockForBytecodeOffset(Vector&lt;BasicBlock*&gt;&amp; linkingTargets, unsigned bytecodeBegin)</span>
268 {
<span class="line-modified">269     return *binarySearch&lt;BasicBlock*, unsigned&gt;(linkingTargets, linkingTargets.size(), bytecodeBegin, getBytecodeBeginForBlock);</span>
270 }
271 
272 } } // namespace JSC::DFG
273 
274 #endif // ENABLE(DFG_JIT)
</pre>
</td>
<td>
<hr />
<pre>
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DFGAbstractValue.h&quot;
 31 #include &quot;DFGAvailabilityMap.h&quot;
 32 #include &quot;DFGBranchDirection.h&quot;
 33 #include &quot;DFGNode.h&quot;
 34 #include &quot;DFGNodeAbstractValuePair.h&quot;
 35 #include &quot;DFGStructureClobberState.h&quot;
 36 #include &quot;Operands.h&quot;
 37 #include &lt;wtf/Vector.h&gt;
 38 
 39 namespace JSC { namespace DFG {
 40 
 41 class Graph;
 42 class InsertionSet;
 43 
 44 typedef Vector&lt;BasicBlock*, 2&gt; PredecessorList;
 45 typedef Vector&lt;Node*, 8&gt; BlockNodeList;
 46 
<span class="line-added"> 47 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(BasicBlock);</span>
<span class="line-added"> 48 </span>
 49 struct BasicBlock : RefCounted&lt;BasicBlock&gt; {
<span class="line-added"> 50     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(BasicBlock);</span>
 51     BasicBlock(
<span class="line-modified"> 52         BytecodeIndex bytecodeBegin, unsigned numArguments, unsigned numLocals, unsigned numTmps,</span>
 53         float executionCount);
 54     ~BasicBlock();
 55 
 56     void ensureLocals(unsigned newNumLocals);
<span class="line-added"> 57     void ensureTmps(unsigned newNumTmps);</span>
 58 
 59     size_t size() const { return m_nodes.size(); }
 60     bool isEmpty() const { return !size(); }
 61     Node*&amp; at(size_t i) { return m_nodes[i]; }
 62     Node* at(size_t i) const { return m_nodes[i]; }
 63     Node* tryAt(size_t i) const
 64     {
 65         if (i &gt;= size())
 66             return nullptr;
 67         return at(i);
 68     }
 69     Node*&amp; operator[](size_t i) { return at(i); }
 70     Node* operator[](size_t i) const { return at(i); }
 71     Node* last() const
 72     {
 73         RELEASE_ASSERT(!!size());
 74         return at(size() - 1);
 75     }
 76 
 77     // Use this to find both the index of the terminal and the terminal itself in one go. May
</pre>
<hr />
<pre>
158     {
159         return terminal()-&gt;successors();
160     }
161 
162     void removePredecessor(BasicBlock* block);
163     void replacePredecessor(BasicBlock* from, BasicBlock* to);
164 
165     template&lt;typename... Params&gt;
166     Node* appendNode(Graph&amp;, SpeculatedType, Params...);
167 
168     template&lt;typename... Params&gt;
169     Node* appendNonTerminal(Graph&amp;, SpeculatedType, Params...);
170 
171     template&lt;typename... Params&gt;
172     Node* replaceTerminal(Graph&amp;, SpeculatedType, Params...);
173 
174     void dump(PrintStream&amp; out) const;
175 
176     void didLink()
177     {
<span class="line-modified">178 #if ASSERT_ENABLED</span>
179         isLinked = true;
180 #endif
181     }
182 
183     // This value is used internally for block linking and OSR entry. It is mostly meaningless
184     // for other purposes due to inlining.
<span class="line-modified">185     BytecodeIndex bytecodeBegin;</span>
186 
187     BlockIndex index;
188 
189     StructureClobberState cfaStructureClobberStateAtHead;
190     StructureClobberState cfaStructureClobberStateAtTail;
191     BranchDirection cfaBranchDirection;
192     bool cfaHasVisited;
193     bool cfaShouldRevisit;
<span class="line-modified">194     bool cfaThinksShouldTryConstantFolding { false };</span>
195     bool cfaDidFinish;
196     bool intersectionOfCFAHasVisited;
197     bool isOSRTarget;
198     bool isCatchEntrypoint;
199 
<span class="line-modified">200 #if ASSERT_ENABLED</span>
201     bool isLinked;
202 #endif
203     bool isReachable;
204 
205     Vector&lt;Node*&gt; phis;
206     PredecessorList predecessors;
207 
208     Operands&lt;Node*&gt; variablesAtHead;
209     Operands&lt;Node*&gt; variablesAtTail;
210 
211     Operands&lt;AbstractValue&gt; valuesAtHead;
212     Operands&lt;AbstractValue&gt; valuesAtTail;
213 
214     // The intersection of assumptions we have made previously at the head of this block. Note
215     // that under normal circumstances, each time we run the CFA, we will get strictly more precise
216     // results. But we don&#39;t actually require this to be the case. It&#39;s fine for the CFA to loosen
217     // up for any odd reason. It&#39;s fine when this happens, because anything that the CFA proves
218     // must be true from that point forward, except if some registered watchpoint fires, in which
219     // case the code won&#39;t ever run. So, the CFA proving something less precise later on is just an
220     // outcome of the CFA being imperfect; the more precise thing that it had proved earlier is no
</pre>
<hr />
<pre>
246         AvailabilityMap availabilityAtHead;
247         AvailabilityMap availabilityAtTail;
248 
249         Vector&lt;NodeFlowProjection&gt; liveAtHead;
250         Vector&lt;NodeFlowProjection&gt; liveAtTail;
251         Vector&lt;NodeAbstractValuePair&gt; valuesAtHead;
252         Vector&lt;NodeAbstractValuePair&gt; valuesAtTail;
253 
254         SSAData(BasicBlock*);
255         ~SSAData();
256     };
257     std::unique_ptr&lt;SSAData&gt; ssa;
258 
259 private:
260     friend class InsertionSet;
261     BlockNodeList m_nodes;
262 };
263 
264 typedef Vector&lt;BasicBlock*&gt; BlockList;
265 
<span class="line-modified">266 static inline BytecodeIndex getBytecodeBeginForBlock(BasicBlock** basicBlock)</span>
267 {
268     return (*basicBlock)-&gt;bytecodeBegin;
269 }
270 
<span class="line-modified">271 static inline BasicBlock* blockForBytecodeIndex(Vector&lt;BasicBlock*&gt;&amp; linkingTargets, BytecodeIndex bytecodeBegin)</span>
272 {
<span class="line-modified">273     return *binarySearch&lt;BasicBlock*, BytecodeIndex&gt;(linkingTargets, linkingTargets.size(), bytecodeBegin, getBytecodeBeginForBlock);</span>
274 }
275 
276 } } // namespace JSC::DFG
277 
278 #endif // ENABLE(DFG_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="DFGBasicBlock.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGBlockInsertionSet.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
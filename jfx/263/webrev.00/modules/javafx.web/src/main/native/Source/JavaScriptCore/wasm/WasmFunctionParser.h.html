<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmFunctionParser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(WEBASSEMBLY)
  29 
  30 #include &quot;WasmParser.h&quot;
  31 #include &quot;WasmSignatureInlines.h&quot;
  32 #include &lt;wtf/DataLog.h&gt;
  33 
  34 namespace JSC { namespace Wasm {
  35 
  36 enum class BlockType {
  37     If,
  38     Block,
  39     Loop,
  40     TopLevel
  41 };
  42 
  43 template&lt;typename EnclosingStack, typename NewStack&gt;
  44 void splitStack(BlockSignature signature, EnclosingStack&amp; enclosingStack, NewStack&amp; newStack)
  45 {
  46     newStack.reserveInitialCapacity(signature-&gt;argumentCount());
  47     ASSERT(enclosingStack.size() &gt;= signature-&gt;argumentCount());
  48     unsigned offset = enclosingStack.size() - signature-&gt;argumentCount();
  49     for (unsigned i = 0; i &lt; signature-&gt;argumentCount(); ++i)
  50         newStack.uncheckedAppend(enclosingStack.at(i + offset));
  51     enclosingStack.shrink(offset);
  52 }
  53 
  54 template&lt;typename Context&gt;
  55 class FunctionParser : public Parser&lt;void&gt; {
  56 public:
  57     struct ControlEntry;
  58 
  59     using ControlType = typename Context::ControlType;
  60     using ExpressionType = typename Context::ExpressionType;
  61 
  62     class TypedExpression {
  63     public:
  64         TypedExpression() = default;
  65 
  66         TypedExpression(Type type, ExpressionType value)
  67             : m_type(type)
  68             , m_value(value)
  69         {
  70         }
  71 
  72         Type type() const { return m_type; }
  73 
  74         ExpressionType value() const { return m_value; }
  75         operator ExpressionType() const { return m_value; }
  76 
  77         ExpressionType operator-&gt;() const { return m_value; }
  78 
  79     private:
  80         Type m_type;
  81         ExpressionType m_value;
  82     };
  83 
  84     using ControlStack = Vector&lt;ControlEntry, 16&gt;;
  85     using ResultList = Vector&lt;ExpressionType, 8&gt;;
  86     using Stack = Vector&lt;TypedExpression, 16, UnsafeVectorOverflow&gt;;
  87 
  88     struct ControlEntry {
  89         Stack enclosedExpressionStack;
  90         Stack elseBlockStack;
  91         ControlType controlData;
  92     };
  93 
  94     FunctionParser(Context&amp;, const uint8_t* functionStart, size_t functionLength, const Signature&amp;, const ModuleInformation&amp;);
  95 
  96     Result WARN_UNUSED_RETURN parse();
  97 
  98     OpType currentOpcode() const { return m_currentOpcode; }
  99     size_t currentOpcodeStartingOffset() const { return m_currentOpcodeStartingOffset; }
 100     const Signature&amp; signature() const { return m_signature; }
 101 
 102     ControlStack&amp; controlStack() { return m_controlStack; }
 103     Stack&amp; expressionStack() { return m_expressionStack; }
 104 
 105 private:
 106     static constexpr bool verbose = false;
 107 
 108     PartialResult WARN_UNUSED_RETURN parseBody();
 109     PartialResult WARN_UNUSED_RETURN parseExpression();
 110     PartialResult WARN_UNUSED_RETURN parseUnreachableExpression();
 111     PartialResult WARN_UNUSED_RETURN unifyControl(Vector&lt;ExpressionType&gt;&amp;, unsigned level);
 112     PartialResult WARN_UNUSED_RETURN checkBranchTarget(const ControlType&amp;);
 113     PartialResult WARN_UNUSED_RETURN unify(const ControlType&amp;);
 114 
 115 #define WASM_TRY_POP_EXPRESSION_STACK_INTO(result, what) do {                               \
 116         WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t pop empty stack in &quot; what); \
 117         result = m_expressionStack.takeLast();                                              \
 118         m_context.didPopValueFromStack();                                                   \
 119     } while (0)
 120 
 121     template&lt;OpType&gt;
 122     PartialResult WARN_UNUSED_RETURN unaryCase(Type returnType, Type operandType);
 123 
 124     template&lt;OpType&gt;
 125     PartialResult WARN_UNUSED_RETURN binaryCase(Type returnType, Type lhsType, Type rhsType);
 126 
 127     PartialResult WARN_UNUSED_RETURN store(Type memoryType);
 128     PartialResult WARN_UNUSED_RETURN load(Type memoryType);
 129 
 130 #define WASM_TRY_ADD_TO_CONTEXT(add_expression) WASM_FAIL_IF_HELPER_FAILS(m_context.add_expression)
 131 
 132     template &lt;typename ...Args&gt;
 133     NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN validationFail(const Args&amp;... args) const
 134     {
 135         using namespace FailureHelper; // See ADL comment in WasmParser.h.
 136         if (UNLIKELY(ASSERT_ENABLED &amp;&amp; Options::crashOnFailedWebAssemblyValidate()))
 137             WTFBreakpointTrap();
 138 
 139         StringPrintStream out;
 140         out.print(&quot;WebAssembly.Module doesn&#39;t validate: &quot;_s, args...);
 141         return UnexpectedResult(out.toString());
 142     }
 143 
 144 #define WASM_VALIDATOR_FAIL_IF(condition, ...) do { \
 145         if (UNLIKELY(condition)) \
 146             return validationFail(__VA_ARGS__); \
 147     } while (0) \
 148 
 149     // FIXME add a macro as above for WASM_TRY_APPEND_TO_CONTROL_STACK https://bugs.webkit.org/show_bug.cgi?id=165862
 150 
 151     Context&amp; m_context;
 152     Stack m_expressionStack;
 153     ControlStack m_controlStack;
 154     Vector&lt;Type, 16&gt; m_locals;
 155     const Signature&amp; m_signature;
 156     const ModuleInformation&amp; m_info;
 157 
 158     OpType m_currentOpcode;
 159     size_t m_currentOpcodeStartingOffset { 0 };
 160 
 161     unsigned m_unreachableBlocks { 0 };
 162     unsigned m_loopIndex { 0 };
 163 };
 164 
 165 template&lt;typename Context&gt;
 166 FunctionParser&lt;Context&gt;::FunctionParser(Context&amp; context, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, const ModuleInformation&amp; info)
 167     : Parser(functionStart, functionLength)
 168     , m_context(context)
 169     , m_signature(signature)
 170     , m_info(info)
 171 {
 172     if (verbose)
 173         dataLogLn(&quot;Parsing function starting at: &quot;, (uintptr_t)functionStart, &quot; of length: &quot;, functionLength, &quot; with signature: &quot;, signature);
 174     m_context.setParser(this);
 175 }
 176 
 177 template&lt;typename Context&gt;
 178 auto FunctionParser&lt;Context&gt;::parse() -&gt; Result
 179 {
 180     uint32_t localGroupsCount;
 181 
 182     WASM_PARSER_FAIL_IF(!m_context.addArguments(m_signature), &quot;can&#39;t add &quot;, m_signature.argumentCount(), &quot; arguments to Function&quot;);
 183     WASM_PARSER_FAIL_IF(!parseVarUInt32(localGroupsCount), &quot;can&#39;t get local groups count&quot;);
 184 
 185     WASM_PARSER_FAIL_IF(!m_locals.tryReserveCapacity(m_signature.argumentCount()), &quot;can&#39;t allocate enough memory for function&#39;s &quot;, m_signature.argumentCount(), &quot; arguments&quot;);
 186     for (uint32_t i = 0; i &lt; m_signature.argumentCount(); ++i)
 187         m_locals.uncheckedAppend(m_signature.argument(i));
 188 
 189     uint64_t totalNumberOfLocals = m_signature.argumentCount();
 190     for (uint32_t i = 0; i &lt; localGroupsCount; ++i) {
 191         uint32_t numberOfLocals;
 192         Type typeOfLocal;
 193 
 194         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfLocals), &quot;can&#39;t get Function&#39;s number of locals in group &quot;, i);
 195         totalNumberOfLocals += numberOfLocals;
 196         WASM_PARSER_FAIL_IF(totalNumberOfLocals &gt; maxFunctionLocals, &quot;Function&#39;s number of locals is too big &quot;, totalNumberOfLocals, &quot; maximum &quot;, maxFunctionLocals);
 197         WASM_PARSER_FAIL_IF(!parseValueType(typeOfLocal), &quot;can&#39;t get Function local&#39;s type in group &quot;, i);
 198 
 199         WASM_PARSER_FAIL_IF(!m_locals.tryReserveCapacity(totalNumberOfLocals), &quot;can&#39;t allocate enough memory for function&#39;s &quot;, totalNumberOfLocals, &quot; locals&quot;);
 200         for (uint32_t i = 0; i &lt; numberOfLocals; ++i)
 201             m_locals.uncheckedAppend(typeOfLocal);
 202 
 203         WASM_TRY_ADD_TO_CONTEXT(addLocal(typeOfLocal, numberOfLocals));
 204     }
 205 
 206     m_context.didFinishParsingLocals();
 207 
 208     WASM_FAIL_IF_HELPER_FAILS(parseBody());
 209 
 210     return { };
 211 }
 212 
 213 template&lt;typename Context&gt;
 214 auto FunctionParser&lt;Context&gt;::parseBody() -&gt; PartialResult
 215 {
 216     m_controlStack.append({ { }, { }, m_context.addTopLevel(&amp;m_signature) });
 217     uint8_t op = 0;
 218     while (m_controlStack.size()) {
 219         m_currentOpcodeStartingOffset = m_offset;
 220         WASM_PARSER_FAIL_IF(!parseUInt8(op), &quot;can&#39;t decode opcode&quot;);
 221         WASM_PARSER_FAIL_IF(!isValidOpType(op), &quot;invalid opcode &quot;, op);
 222 
 223         m_currentOpcode = static_cast&lt;OpType&gt;(op);
 224 
 225         if (verbose) {
 226             dataLogLn(&quot;processing op (&quot;, m_unreachableBlocks, &quot;): &quot;,  RawPointer(reinterpret_cast&lt;void*&gt;(op)), &quot;, &quot;, makeString(static_cast&lt;OpType&gt;(op)), &quot; at offset: &quot;, RawPointer(reinterpret_cast&lt;void*&gt;(m_offset)));
 227             m_context.dump(m_controlStack, &amp;m_expressionStack);
 228         }
 229 
 230         if (m_unreachableBlocks)
 231             WASM_FAIL_IF_HELPER_FAILS(parseUnreachableExpression());
 232         else {
 233             WASM_FAIL_IF_HELPER_FAILS(parseExpression());
 234         }
 235     }
 236     WASM_FAIL_IF_HELPER_FAILS(m_context.endTopLevel(&amp;m_signature, m_expressionStack));
 237 
 238     ASSERT(op == OpType::End);
 239     return { };
 240 }
 241 
 242 template&lt;typename Context&gt;
 243 template&lt;OpType op&gt;
 244 auto FunctionParser&lt;Context&gt;::binaryCase(Type returnType, Type lhsType, Type rhsType) -&gt; PartialResult
 245 {
 246     TypedExpression right;
 247     TypedExpression left;
 248 
 249     WASM_TRY_POP_EXPRESSION_STACK_INTO(right, &quot;binary right&quot;);
 250     WASM_TRY_POP_EXPRESSION_STACK_INTO(left, &quot;binary left&quot;);
 251 
 252     WASM_VALIDATOR_FAIL_IF(left.type() != lhsType, op, &quot; left value type mismatch&quot;);
 253     WASM_VALIDATOR_FAIL_IF(right.type() != rhsType, op, &quot; right value type mismatch&quot;);
 254 
 255     ExpressionType result;
 256     WASM_TRY_ADD_TO_CONTEXT(template addOp&lt;op&gt;(left, right, result));
 257     m_expressionStack.constructAndAppend(returnType, result);
 258     return { };
 259 }
 260 
 261 template&lt;typename Context&gt;
 262 template&lt;OpType op&gt;
 263 auto FunctionParser&lt;Context&gt;::unaryCase(Type returnType, Type operandType) -&gt; PartialResult
 264 {
 265     TypedExpression value;
 266     WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;unary&quot;);
 267 
 268     WASM_VALIDATOR_FAIL_IF(value.type() != operandType, op, &quot; value type mismatch&quot;);
 269 
 270     ExpressionType result;
 271     WASM_TRY_ADD_TO_CONTEXT(template addOp&lt;op&gt;(value, result));
 272     m_expressionStack.constructAndAppend(returnType, result);
 273     return { };
 274 }
 275 
 276 template&lt;typename Context&gt;
 277 auto FunctionParser&lt;Context&gt;::load(Type memoryType) -&gt; PartialResult
 278 {
 279     WASM_VALIDATOR_FAIL_IF(!m_info.memory, &quot;load instruction without memory&quot;);
 280 
 281     uint32_t alignment;
 282     uint32_t offset;
 283     TypedExpression pointer;
 284     WASM_PARSER_FAIL_IF(!parseVarUInt32(alignment), &quot;can&#39;t get load alignment&quot;);
 285     WASM_PARSER_FAIL_IF(alignment &gt; memoryLog2Alignment(m_currentOpcode), &quot;byte alignment &quot;, 1ull &lt;&lt; alignment, &quot; exceeds load&#39;s natural alignment &quot;, 1ull &lt;&lt; memoryLog2Alignment(m_currentOpcode));
 286     WASM_PARSER_FAIL_IF(!parseVarUInt32(offset), &quot;can&#39;t get load offset&quot;);
 287     WASM_TRY_POP_EXPRESSION_STACK_INTO(pointer, &quot;load pointer&quot;);
 288 
 289     WASM_VALIDATOR_FAIL_IF(pointer.type() != I32, m_currentOpcode, &quot; pointer type mismatch&quot;);
 290 
 291     ExpressionType result;
 292     WASM_TRY_ADD_TO_CONTEXT(load(static_cast&lt;LoadOpType&gt;(m_currentOpcode), pointer, result, offset));
 293     m_expressionStack.constructAndAppend(memoryType, result);
 294     return { };
 295 }
 296 
 297 template&lt;typename Context&gt;
 298 auto FunctionParser&lt;Context&gt;::store(Type memoryType) -&gt; PartialResult
 299 {
 300     WASM_VALIDATOR_FAIL_IF(!m_info.memory, &quot;store instruction without memory&quot;);
 301 
 302     uint32_t alignment;
 303     uint32_t offset;
 304     TypedExpression value;
 305     TypedExpression pointer;
 306     WASM_PARSER_FAIL_IF(!parseVarUInt32(alignment), &quot;can&#39;t get store alignment&quot;);
 307     WASM_PARSER_FAIL_IF(alignment &gt; memoryLog2Alignment(m_currentOpcode), &quot;byte alignment &quot;, 1ull &lt;&lt; alignment, &quot; exceeds store&#39;s natural alignment &quot;, 1ull &lt;&lt; memoryLog2Alignment(m_currentOpcode));
 308     WASM_PARSER_FAIL_IF(!parseVarUInt32(offset), &quot;can&#39;t get store offset&quot;);
 309     WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;store value&quot;);
 310     WASM_TRY_POP_EXPRESSION_STACK_INTO(pointer, &quot;store pointer&quot;);
 311 
 312     WASM_VALIDATOR_FAIL_IF(pointer.type() != I32, m_currentOpcode, &quot; pointer type mismatch&quot;);
 313     WASM_VALIDATOR_FAIL_IF(value.type() != memoryType, m_currentOpcode, &quot; value type mismatch&quot;);
 314 
 315     WASM_TRY_ADD_TO_CONTEXT(store(static_cast&lt;StoreOpType&gt;(m_currentOpcode), pointer, value, offset));
 316     return { };
 317 }
 318 
 319 template&lt;typename Context&gt;
 320 auto FunctionParser&lt;Context&gt;::checkBranchTarget(const ControlType&amp; target) -&gt; PartialResult
 321 {
 322     if (!target.branchTargetArity())
 323         return { };
 324 
 325     WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; target.branchTargetArity(), ControlType::isTopLevel(target) ? &quot;branch out of function&quot; : &quot;branch to block&quot;, &quot; on expression stack of size &quot;, m_expressionStack.size(), &quot;, but block, &quot;, target.signature()-&gt;toString() , &quot; expects &quot;, target.branchTargetArity(), &quot; values&quot;);
 326 
 327 
 328     unsigned offset = m_expressionStack.size() - target.branchTargetArity();
 329     for (unsigned i = 0; i &lt; target.branchTargetArity(); ++i)
 330         WASM_VALIDATOR_FAIL_IF(!isSubtype(target.branchTargetType(i), m_expressionStack[offset + i].type()), &quot;branch&#39;s stack type is not a subtype of block&#39;s type branch target type. Stack value has type&quot;, m_expressionStack[offset + i].type(), &quot; but branch target expects a value with subtype of &quot;, target.branchTargetType(i), &quot; at index &quot;, i);
 331 
 332     return { };
 333 }
 334 
 335 template&lt;typename Context&gt;
 336 auto FunctionParser&lt;Context&gt;::unify(const ControlType&amp; controlData) -&gt; PartialResult
 337 {
 338     WASM_VALIDATOR_FAIL_IF(controlData.signature()-&gt;returnCount() != m_expressionStack.size(), &quot; block with type: &quot;, controlData.signature()-&gt;toString(), &quot; returns: &quot;, controlData.signature()-&gt;returnCount(), &quot; but stack has: &quot;, m_expressionStack.size(), &quot; values&quot;);
 339     for (unsigned i = 0; i &lt; controlData.signature()-&gt;returnCount(); ++i)
 340         WASM_VALIDATOR_FAIL_IF(!isSubtype(m_expressionStack[i].type(), controlData.signature()-&gt;returnType(i)), &quot;control flow returns with unexpected type. &quot;, m_expressionStack[i].type(), &quot; is not a subtype of &quot;, controlData.signature()-&gt;returnType(i));
 341 
 342     return { };
 343 }
 344 
 345 template&lt;typename Context&gt;
 346 auto FunctionParser&lt;Context&gt;::parseExpression() -&gt; PartialResult
 347 {
 348     switch (m_currentOpcode) {
 349 #define CREATE_CASE(name, id, b3op, inc, lhsType, rhsType, returnType) case OpType::name: return binaryCase&lt;OpType::name&gt;(returnType, lhsType, rhsType);
 350     FOR_EACH_WASM_BINARY_OP(CREATE_CASE)
 351 #undef CREATE_CASE
 352 
 353 #define CREATE_CASE(name, id, b3op, inc, operandType, returnType) case OpType::name: return unaryCase&lt;OpType::name&gt;(returnType, operandType);
 354     FOR_EACH_WASM_UNARY_OP(CREATE_CASE)
 355 #undef CREATE_CASE
 356 
 357     case Select: {
 358         TypedExpression condition;
 359         TypedExpression zero;
 360         TypedExpression nonZero;
 361 
 362         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;select condition&quot;);
 363         WASM_TRY_POP_EXPRESSION_STACK_INTO(zero, &quot;select zero&quot;);
 364         WASM_TRY_POP_EXPRESSION_STACK_INTO(nonZero, &quot;select non-zero&quot;);
 365 
 366         WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;select condition must be i32, got &quot;, condition.type());
 367         WASM_VALIDATOR_FAIL_IF(nonZero.type() != zero.type(), &quot;select result types must match, got &quot;, nonZero.type(), &quot; and &quot;, zero.type());
 368 
 369         ExpressionType result;
 370         WASM_TRY_ADD_TO_CONTEXT(addSelect(condition, nonZero, zero, result));
 371 
 372         m_expressionStack.constructAndAppend(zero.type(), result);
 373         return { };
 374     }
 375 
 376 #define CREATE_CASE(name, id, b3op, inc, memoryType) case OpType::name: return load(memoryType);
 377 FOR_EACH_WASM_MEMORY_LOAD_OP(CREATE_CASE)
 378 #undef CREATE_CASE
 379 
 380 #define CREATE_CASE(name, id, b3op, inc, memoryType) case OpType::name: return store(memoryType);
 381 FOR_EACH_WASM_MEMORY_STORE_OP(CREATE_CASE)
 382 #undef CREATE_CASE
 383 
 384     case F32Const: {
 385         uint32_t constant;
 386         WASM_PARSER_FAIL_IF(!parseUInt32(constant), &quot;can&#39;t parse 32-bit floating-point constant&quot;);
 387         m_expressionStack.constructAndAppend(F32, m_context.addConstant(F32, constant));
 388         return { };
 389     }
 390 
 391     case I32Const: {
 392         int32_t constant;
 393         WASM_PARSER_FAIL_IF(!parseVarInt32(constant), &quot;can&#39;t parse 32-bit constant&quot;);
 394         m_expressionStack.constructAndAppend(I32, m_context.addConstant(I32, constant));
 395         return { };
 396     }
 397 
 398     case F64Const: {
 399         uint64_t constant;
 400         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t parse 64-bit floating-point constant&quot;);
 401         m_expressionStack.constructAndAppend(F64, m_context.addConstant(F64, constant));
 402         return { };
 403     }
 404 
 405     case I64Const: {
 406         int64_t constant;
 407         WASM_PARSER_FAIL_IF(!parseVarInt64(constant), &quot;can&#39;t parse 64-bit constant&quot;);
 408         m_expressionStack.constructAndAppend(I64, m_context.addConstant(I64, constant));
 409         return { };
 410     }
 411 
 412     case TableGet: {
 413         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 414         unsigned tableIndex;
 415         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
 416         WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_info.tableCount());
 417 
 418         TypedExpression index;
 419         WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.get&quot;);
 420         WASM_VALIDATOR_FAIL_IF(I32 != index.type(), &quot;table.get index to type &quot;, index.type(), &quot; expected &quot;, I32);
 421 
 422         ExpressionType result;
 423         WASM_TRY_ADD_TO_CONTEXT(addTableGet(tableIndex, index, result));
 424         Type resultType = m_info.tables[tableIndex].wasmType();
 425         m_expressionStack.constructAndAppend(resultType, result);
 426         return { };
 427     }
 428 
 429     case TableSet: {
 430         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 431         unsigned tableIndex;
 432         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
 433         WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_info.tableCount());
 434         TypedExpression value, index;
 435         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;table.set&quot;);
 436         WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.set&quot;);
 437         WASM_VALIDATOR_FAIL_IF(I32 != index.type(), &quot;table.set index to type &quot;, index.type(), &quot; expected &quot;, I32);
 438         Type type = m_info.tables[tableIndex].wasmType();
 439         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), type), &quot;table.set value to type &quot;, value.type(), &quot; expected &quot;, type);
 440         RELEASE_ASSERT(m_info.tables[tableIndex].type() == TableElementType::Anyref || m_info.tables[tableIndex].type() == TableElementType::Funcref);
 441         WASM_TRY_ADD_TO_CONTEXT(addTableSet(tableIndex, index, value));
 442         return { };
 443     }
 444 
 445     case ExtTable: {
 446         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 447         uint8_t extOp;
 448         WASM_PARSER_FAIL_IF(!parseUInt8(extOp), &quot;can&#39;t parse table extended opcode&quot;);
 449         unsigned tableIndex;
 450         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
 451         WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_info.tableCount());
 452 
 453         switch (static_cast&lt;ExtTableOpType&gt;(extOp)) {
 454         case ExtTableOpType::TableSize: {
 455             ExpressionType result;
 456             WASM_TRY_ADD_TO_CONTEXT(addTableSize(tableIndex, result));
 457             m_expressionStack.constructAndAppend(I32, result);
 458             break;
 459         }
 460         case ExtTableOpType::TableGrow: {
 461             TypedExpression fill;
 462             TypedExpression delta;
 463             WASM_TRY_POP_EXPRESSION_STACK_INTO(delta, &quot;table.grow&quot;);
 464             WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.grow&quot;);
 465 
 466             WASM_VALIDATOR_FAIL_IF(!isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()), &quot;table.grow expects fill value of type &quot;, m_info.tables[tableIndex].wasmType(), &quot; got &quot;, fill.type());
 467             WASM_VALIDATOR_FAIL_IF(I32 != delta.type(), &quot;table.grow expects an i32 delta value, got &quot;, delta.type());
 468 
 469             ExpressionType result;
 470             WASM_TRY_ADD_TO_CONTEXT(addTableGrow(tableIndex, fill, delta, result));
 471             m_expressionStack.constructAndAppend(I32, result);
 472             break;
 473         }
 474         case ExtTableOpType::TableFill: {
 475             TypedExpression offset, fill, count;
 476             WASM_TRY_POP_EXPRESSION_STACK_INTO(count, &quot;table.fill&quot;);
 477             WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.fill&quot;);
 478             WASM_TRY_POP_EXPRESSION_STACK_INTO(offset, &quot;table.fill&quot;);
 479 
 480             WASM_VALIDATOR_FAIL_IF(!isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()), &quot;table.fill expects fill value of type &quot;, m_info.tables[tableIndex].wasmType(), &quot; got &quot;, fill.type());
 481             WASM_VALIDATOR_FAIL_IF(I32 != offset.type(), &quot;table.fill expects an i32 offset value, got &quot;, offset.type());
 482             WASM_VALIDATOR_FAIL_IF(I32 != count.type(), &quot;table.fill expects an i32 count value, got &quot;, count.type());
 483 
 484             WASM_TRY_ADD_TO_CONTEXT(addTableFill(tableIndex, offset, fill, count));
 485             break;
 486         }
 487         default:
 488             WASM_PARSER_FAIL_IF(true, &quot;invalid extended table op &quot;, extOp);
 489             break;
 490         }
 491         return { };
 492     }
 493 
 494     case RefNull: {
 495         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 496         m_expressionStack.constructAndAppend(Funcref, m_context.addConstant(Funcref, JSValue::encode(jsNull())));
 497         return { };
 498     }
 499 
 500     case RefIsNull: {
 501         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 502         TypedExpression value;
 503         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;ref.is_null&quot;);
 504         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), Anyref), &quot;ref.is_null to type &quot;, value.type(), &quot; expected &quot;, Anyref);
 505         ExpressionType result;
 506         WASM_TRY_ADD_TO_CONTEXT(addRefIsNull(value, result));
 507         m_expressionStack.constructAndAppend(I32, result);
 508         return { };
 509     }
 510 
 511     case RefFunc: {
 512         uint32_t index;
 513         ExpressionType result;
 514         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 515         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for ref.func&quot;);
 516 
 517         WASM_VALIDATOR_FAIL_IF(index &gt;= m_info.functionIndexSpaceSize(), &quot;ref.func index &quot;, index, &quot; is too large, max is &quot;, m_info.functionIndexSpaceSize());
 518         m_info.addReferencedFunction(index);
 519         WASM_TRY_ADD_TO_CONTEXT(addRefFunc(index, result));
 520         m_expressionStack.constructAndAppend(Funcref, result);
 521         return { };
 522     }
 523 
 524     case GetLocal: {
 525         uint32_t index;
 526         ExpressionType result;
 527         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for get_local&quot;);
 528         WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to use unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());
 529         WASM_TRY_ADD_TO_CONTEXT(getLocal(index, result));
 530         m_expressionStack.constructAndAppend(m_locals[index], result);
 531         return { };
 532     }
 533 
 534     case SetLocal: {
 535         uint32_t index;
 536         TypedExpression value;
 537         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for set_local&quot;);
 538         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_local&quot;);
 539         WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to set unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());
 540         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), m_locals[index]), &quot;set_local to type &quot;, value.type(), &quot; expected &quot;, m_locals[index]);
 541         WASM_TRY_ADD_TO_CONTEXT(setLocal(index, value));
 542         return { };
 543     }
 544 
 545     case TeeLocal: {
 546         uint32_t index;
 547         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for tee_local&quot;);
 548         WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t tee_local on empty expression stack&quot;);
 549         TypedExpression value = m_expressionStack.last();
 550         WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to tee unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());
 551         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), m_locals[index]), &quot;set_local to type &quot;, value.type(), &quot; expected &quot;, m_locals[index]);
 552         WASM_TRY_ADD_TO_CONTEXT(setLocal(index, value));
 553         return { };
 554     }
 555 
 556     case GetGlobal: {
 557         uint32_t index;
 558         ExpressionType result;
 559         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get get_global&#39;s index&quot;);
 560         WASM_VALIDATOR_FAIL_IF(index &gt;= m_info.globals.size(), &quot;get_global &quot;, index, &quot; of unknown global, limit is &quot;, m_info.globals.size());
 561         Type resultType = m_info.globals[index].type;
 562         ASSERT(isValueType(resultType));
 563         WASM_TRY_ADD_TO_CONTEXT(getGlobal(index, result));
 564         m_expressionStack.constructAndAppend(resultType, result);
 565         return { };
 566     }
 567 
 568     case SetGlobal: {
 569         uint32_t index;
 570         TypedExpression value;
 571         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get set_global&#39;s index&quot;);
 572         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_global value&quot;);
 573 
 574         WASM_VALIDATOR_FAIL_IF(index &gt;= m_info.globals.size(), &quot;set_global &quot;, index, &quot; of unknown global, limit is &quot;, m_info.globals.size());
 575         WASM_VALIDATOR_FAIL_IF(m_info.globals[index].mutability == GlobalInformation::Immutable, &quot;set_global &quot;, index, &quot; is immutable&quot;);
 576 
 577         Type globalType = m_info.globals[index].type;
 578         ASSERT(isValueType(globalType));
 579         WASM_VALIDATOR_FAIL_IF(globalType != value.type(), &quot;set_global &quot;, index, &quot; with type &quot;, globalType, &quot; with a variable of type &quot;, value.type());
 580 
 581         WASM_TRY_ADD_TO_CONTEXT(setGlobal(index, value));
 582         return { };
 583     }
 584 
 585     case Call: {
 586         uint32_t functionIndex;
 587         WASM_PARSER_FAIL_IF(!parseVarUInt32(functionIndex), &quot;can&#39;t parse call&#39;s function index&quot;);
 588         WASM_PARSER_FAIL_IF(functionIndex &gt;= m_info.functionIndexSpaceSize(), &quot;call function index &quot;, functionIndex, &quot; exceeds function index space &quot;, m_info.functionIndexSpaceSize());
 589 
 590         SignatureIndex calleeSignatureIndex = m_info.signatureIndexFromFunctionIndexSpace(functionIndex);
 591         const Signature&amp; calleeSignature = SignatureInformation::get(calleeSignatureIndex);
 592         WASM_PARSER_FAIL_IF(calleeSignature.argumentCount() &gt; m_expressionStack.size(), &quot;call function index &quot;, functionIndex, &quot; has &quot;, calleeSignature.argumentCount(), &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
 593 
 594         size_t firstArgumentIndex = m_expressionStack.size() - calleeSignature.argumentCount();
 595         Vector&lt;ExpressionType&gt; args;
 596         WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(calleeSignature.argumentCount()), &quot;can&#39;t allocate enough memory for call&#39;s &quot;, calleeSignature.argumentCount(), &quot; arguments&quot;);
 597         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i) {
 598             TypedExpression arg = m_expressionStack.at(i);
 599             WASM_VALIDATOR_FAIL_IF(!isSubtype(arg.type(), calleeSignature.argument(i - firstArgumentIndex)), &quot;argument type mismatch in call, got &quot;, arg.type(), &quot;, expected &quot;, calleeSignature.argument(i - firstArgumentIndex));
 600             args.uncheckedAppend(arg);
 601             m_context.didPopValueFromStack();
 602         }
 603         m_expressionStack.shrink(firstArgumentIndex);
 604 
 605         RELEASE_ASSERT(calleeSignature.argumentCount() == args.size());
 606 
 607         ResultList results;
 608         WASM_TRY_ADD_TO_CONTEXT(addCall(functionIndex, calleeSignature, args, results));
 609 
 610         RELEASE_ASSERT(calleeSignature.returnCount() == results.size());
 611 
 612         for (unsigned i = 0; i &lt; calleeSignature.returnCount(); ++i)
 613             m_expressionStack.constructAndAppend(calleeSignature.returnType(i), results[i]);
 614 
 615         return { };
 616     }
 617 
 618     case CallIndirect: {
 619         uint32_t signatureIndex;
 620         uint32_t tableIndex;
 621         WASM_PARSER_FAIL_IF(!m_info.tableCount(), &quot;call_indirect is only valid when a table is defined or imported&quot;);
 622         WASM_PARSER_FAIL_IF(!parseVarUInt32(signatureIndex), &quot;can&#39;t get call_indirect&#39;s signature index&quot;);
 623         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t get call_indirect&#39;s table index&quot;);
 624         WASM_PARSER_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;call_indirect&#39;s table index &quot;, tableIndex, &quot; invalid, limit is &quot;, m_info.tableCount());
 625         WASM_PARSER_FAIL_IF(m_info.usedSignatures.size() &lt;= signatureIndex, &quot;call_indirect&#39;s signature index &quot;, signatureIndex, &quot; exceeds known signatures &quot;, m_info.usedSignatures.size());
 626         WASM_PARSER_FAIL_IF(m_info.tables[tableIndex].type() != TableElementType::Funcref, &quot;call_indirect is only valid when a table has type funcref&quot;);
 627 
 628         const Signature&amp; calleeSignature = m_info.usedSignatures[signatureIndex].get();
 629         size_t argumentCount = calleeSignature.argumentCount() + 1; // Add the callee&#39;s index.
 630         WASM_PARSER_FAIL_IF(argumentCount &gt; m_expressionStack.size(), &quot;call_indirect expects &quot;, argumentCount, &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
 631 
 632         WASM_VALIDATOR_FAIL_IF(m_expressionStack.last().type() != I32, &quot;non-i32 call_indirect index &quot;, m_expressionStack.last().type());
 633 
 634         Vector&lt;ExpressionType&gt; args;
 635         WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for &quot;, argumentCount, &quot; call_indirect arguments&quot;);
 636         size_t firstArgumentIndex = m_expressionStack.size() - argumentCount;
 637         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i) {
 638             TypedExpression arg = m_expressionStack.at(i);
 639             if (i &lt; calleeSignature.argumentCount())
 640                 WASM_VALIDATOR_FAIL_IF(!isSubtype(arg.type(), calleeSignature.argument(i - firstArgumentIndex)), &quot;argument type mismatch in call_indirect, got &quot;, arg.type(), &quot;, expected &quot;, calleeSignature.argument(i - firstArgumentIndex));
 641             args.uncheckedAppend(arg);
 642             m_context.didPopValueFromStack();
 643         }
 644         m_expressionStack.shrink(firstArgumentIndex);
 645 
 646 
 647 
 648         ResultList results;
 649         WASM_TRY_ADD_TO_CONTEXT(addCallIndirect(tableIndex, calleeSignature, args, results));
 650 
 651         for (unsigned i = 0; i &lt; calleeSignature.returnCount(); ++i)
 652             m_expressionStack.constructAndAppend(calleeSignature.returnType(i), results[i]);
 653 
 654         return { };
 655     }
 656 
 657     case Block: {
 658         BlockSignature inlineSignature;
 659         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, inlineSignature), &quot;can&#39;t get block&#39;s signature&quot;);
 660 
 661         WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; inlineSignature-&gt;argumentCount(), &quot;Too few values on stack for block. Block expects &quot;, inlineSignature-&gt;argumentCount(), &quot;, but only &quot;, m_expressionStack.size(), &quot; were present. Block has inlineSignature: &quot;, inlineSignature-&gt;toString());
 662         unsigned offset = m_expressionStack.size() - inlineSignature-&gt;argumentCount();
 663         for (unsigned i = 0; i &lt; inlineSignature-&gt;argumentCount(); ++i) {
 664             Type type = m_expressionStack.at(offset + i).type();
 665             WASM_VALIDATOR_FAIL_IF(!isSubtype(type, inlineSignature-&gt;argument(i)), &quot;Block expects the argument at index&quot;, i, &quot; to be a subtype of &quot;, inlineSignature-&gt;argument(i), &quot; but argument has type &quot;, type);
 666         }
 667 
 668         int64_t oldSize = m_expressionStack.size();
 669         Stack newStack;
 670         ControlType block;
 671         WASM_TRY_ADD_TO_CONTEXT(addBlock(inlineSignature, m_expressionStack, block, newStack));
 672         ASSERT_UNUSED(oldSize, oldSize - m_expressionStack.size() == inlineSignature-&gt;argumentCount());
 673         ASSERT(newStack.size() == inlineSignature-&gt;argumentCount());
 674 
 675         m_controlStack.append({ WTFMove(m_expressionStack), { },  WTFMove(block) });
 676         m_expressionStack = WTFMove(newStack);
 677         return { };
 678     }
 679 
 680     case Loop: {
 681         BlockSignature inlineSignature;
 682         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, inlineSignature), &quot;can&#39;t get loop&#39;s signature&quot;);
 683 
 684         WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; inlineSignature-&gt;argumentCount(), &quot;Too few values on stack for loop block. Loop expects &quot;, inlineSignature-&gt;argumentCount(), &quot;, but only &quot;, m_expressionStack.size(), &quot; were present. Loop has inlineSignature: &quot;, inlineSignature-&gt;toString());
 685         unsigned offset = m_expressionStack.size() - inlineSignature-&gt;argumentCount();
 686         for (unsigned i = 0; i &lt; inlineSignature-&gt;argumentCount(); ++i) {
 687             Type type = m_expressionStack.at(offset + i).type();
 688             WASM_VALIDATOR_FAIL_IF(!isSubtype(type, inlineSignature-&gt;argument(i)), &quot;Loop expects the argument at index&quot;, i, &quot; to be a subtype of &quot;, inlineSignature-&gt;argument(i), &quot; but argument has type &quot;, type);
 689         }
 690 
 691         int64_t oldSize = m_expressionStack.size();
 692         Stack newStack;
 693         ControlType loop;
 694         WASM_TRY_ADD_TO_CONTEXT(addLoop(inlineSignature, m_expressionStack, loop, newStack, m_loopIndex++));
 695         ASSERT_UNUSED(oldSize, oldSize - m_expressionStack.size() == inlineSignature-&gt;argumentCount());
 696         ASSERT(newStack.size() == inlineSignature-&gt;argumentCount());
 697 
 698         m_controlStack.append({ WTFMove(m_expressionStack), { }, WTFMove(loop) });
 699         m_expressionStack = WTFMove(newStack);
 700         return { };
 701     }
 702 
 703     case If: {
 704         BlockSignature inlineSignature;
 705         TypedExpression condition;
 706         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, inlineSignature), &quot;can&#39;t get if&#39;s signature&quot;);
 707         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;if condition&quot;);
 708 
 709         WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;if condition must be i32, got &quot;, condition.type());
 710         WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; inlineSignature-&gt;argumentCount(), &quot;Too few arguments on stack for if block. If expects &quot;, inlineSignature-&gt;argumentCount(), &quot;, but only &quot;, m_expressionStack.size(), &quot; were present. If block has signature: &quot;, inlineSignature-&gt;toString());
 711         unsigned offset = m_expressionStack.size() - inlineSignature-&gt;argumentCount();
 712         for (unsigned i = 0; i &lt; inlineSignature-&gt;argumentCount(); ++i)
 713             WASM_VALIDATOR_FAIL_IF(!isSubtype(m_expressionStack[offset + i].type(), inlineSignature-&gt;argument(i)), &quot;Loop expects the argument at index&quot;, i, &quot; to be a subtype of &quot;, inlineSignature-&gt;argument(i), &quot; but argument has type &quot;, m_expressionStack[i].type());
 714 
 715         int64_t oldSize = m_expressionStack.size();
 716         Stack newStack;
 717         ControlType control;
 718         WASM_TRY_ADD_TO_CONTEXT(addIf(condition, inlineSignature, m_expressionStack, control, newStack));
 719         ASSERT_UNUSED(oldSize, oldSize - m_expressionStack.size() == inlineSignature-&gt;argumentCount());
 720         ASSERT(newStack.size() == inlineSignature-&gt;argumentCount());
 721 
 722         m_controlStack.append({ WTFMove(m_expressionStack), newStack, WTFMove(control) });
 723         m_expressionStack = WTFMove(newStack);
 724         return { };
 725     }
 726 
 727     case Else: {
 728         WASM_PARSER_FAIL_IF(m_controlStack.size() == 1, &quot;can&#39;t use else block at the top-level of a function&quot;);
 729 
 730         ControlEntry&amp; controlEntry = m_controlStack.last();
 731 
 732         WASM_VALIDATOR_FAIL_IF(!ControlType::isIf(controlEntry.controlData), &quot;else block isn&#39;t associated to an if&quot;);
 733         WASM_FAIL_IF_HELPER_FAILS(unify(controlEntry.controlData));
 734         WASM_TRY_ADD_TO_CONTEXT(addElse(controlEntry.controlData, m_expressionStack));
 735         m_expressionStack = WTFMove(controlEntry.elseBlockStack);
 736         return { };
 737     }
 738 
 739     case Br:
 740     case BrIf: {
 741         uint32_t target;
 742         TypedExpression condition;
 743         WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get br / br_if&#39;s target&quot;);
 744         WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br / br_if&#39;s target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
 745         if (m_currentOpcode == BrIf) {
 746             WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br / br_if condition&quot;);
 747             WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;conditional branch with non-i32 condition &quot;, condition.type());
 748         } else {
 749             m_unreachableBlocks = 1;
 750             condition = TypedExpression { Void, Context::emptyExpression() };
 751         }
 752 
 753         ControlType&amp; data = m_controlStack[m_controlStack.size() - 1 - target].controlData;
 754         WASM_FAIL_IF_HELPER_FAILS(checkBranchTarget(data));
 755         WASM_TRY_ADD_TO_CONTEXT(addBranch(data, condition, m_expressionStack));
 756         return { };
 757     }
 758 
 759     case BrTable: {
 760         uint32_t numberOfTargets;
 761         uint32_t defaultTargetIndex;
 762         TypedExpression condition;
 763         Vector&lt;ControlType*&gt; targets;
 764 
 765         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfTargets), &quot;can&#39;t get the number of targets for br_table&quot;);
 766         WASM_PARSER_FAIL_IF(numberOfTargets == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;br_table&#39;s number of targets is too big &quot;, numberOfTargets);
 767 
 768         WASM_PARSER_FAIL_IF(!targets.tryReserveCapacity(numberOfTargets), &quot;can&#39;t allocate memory for &quot;, numberOfTargets, &quot; br_table targets&quot;);
 769         for (uint32_t i = 0; i &lt; numberOfTargets; ++i) {
 770             uint32_t target;
 771             WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get &quot;, i, &quot;th target for br_table&quot;);
 772             WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br_table&#39;s &quot;, i, &quot;th target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
 773             targets.uncheckedAppend(&amp;m_controlStack[m_controlStack.size() - 1 - target].controlData);
 774         }
 775 
 776         WASM_PARSER_FAIL_IF(!parseVarUInt32(defaultTargetIndex), &quot;can&#39;t get default target for br_table&quot;);
 777         WASM_PARSER_FAIL_IF(defaultTargetIndex &gt;= m_controlStack.size(), &quot;br_table&#39;s default target &quot;, defaultTargetIndex, &quot; exceeds control stack size &quot;, m_controlStack.size());
 778         ControlType&amp; defaultTarget = m_controlStack[m_controlStack.size() - 1 - defaultTargetIndex].controlData;
 779 
 780         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br_table condition&quot;);
 781         WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;br_table with non-i32 condition &quot;, condition.type());
 782 
 783         for (unsigned i = 0; i &lt; targets.size(); ++i) {
 784             ControlType* target = targets[i];
 785             WASM_VALIDATOR_FAIL_IF(defaultTarget.branchTargetArity() != target-&gt;branchTargetArity(), &quot;br_table target type size mismatch. Default has size: &quot;, defaultTarget.branchTargetArity(), &quot;but target: &quot;, i, &quot; has size: &quot;, target-&gt;branchTargetArity());
 786             for (unsigned type = 0; type &lt; defaultTarget.branchTargetArity(); ++type)
 787                 WASM_VALIDATOR_FAIL_IF(!isSubtype(defaultTarget.branchTargetType(type), target-&gt;branchTargetType(type)), &quot;br_table target type mismatch at offset &quot;, type, &quot; expected: &quot;, defaultTarget.branchTargetType(type), &quot; but saw: &quot;, target-&gt;branchTargetType(type), &quot; when targeting block: &quot;, target-&gt;signature()-&gt;toString());
 788         }
 789 
 790         WASM_FAIL_IF_HELPER_FAILS(checkBranchTarget(defaultTarget));
 791         WASM_TRY_ADD_TO_CONTEXT(addSwitch(condition, targets, defaultTarget, m_expressionStack));
 792 
 793         m_unreachableBlocks = 1;
 794         return { };
 795     }
 796 
 797     case Return: {
 798         WASM_FAIL_IF_HELPER_FAILS(checkBranchTarget(m_controlStack[0].controlData));
 799         WASM_TRY_ADD_TO_CONTEXT(addReturn(m_controlStack[0].controlData, m_expressionStack));
 800         m_unreachableBlocks = 1;
 801         return { };
 802     }
 803 
 804     case End: {
 805         ControlEntry data = m_controlStack.takeLast();
 806         if (ControlType::isIf(data.controlData)) {
 807             WASM_FAIL_IF_HELPER_FAILS(unify(data.controlData));
 808             WASM_TRY_ADD_TO_CONTEXT(addElse(data.controlData, m_expressionStack));
 809             m_expressionStack = WTFMove(data.elseBlockStack);
 810         }
 811         // FIXME: This is a little weird in that it will modify the expressionStack for the result of the block.
 812         // That&#39;s a little too effectful for me but I don&#39;t have a better API right now.
 813         // see: https://bugs.webkit.org/show_bug.cgi?id=164353
 814         WASM_FAIL_IF_HELPER_FAILS(unify(data.controlData));
 815         WASM_TRY_ADD_TO_CONTEXT(endBlock(data, m_expressionStack));
 816         m_expressionStack.swap(data.enclosedExpressionStack);
 817         return { };
 818     }
 819 
 820     case Unreachable: {
 821         WASM_TRY_ADD_TO_CONTEXT(addUnreachable());
 822         m_unreachableBlocks = 1;
 823         return { };
 824     }
 825 
 826     case Drop: {
 827         WASM_PARSER_FAIL_IF(!m_expressionStack.size(), &quot;can&#39;t drop on empty stack&quot;);
 828         m_expressionStack.takeLast();
 829         m_context.didPopValueFromStack();
 830         return { };
 831     }
 832 
 833     case Nop: {
 834         return { };
 835     }
 836 
 837     case GrowMemory: {
 838         WASM_PARSER_FAIL_IF(!m_info.memory, &quot;grow_memory is only valid if a memory is defined or imported&quot;);
 839 
 840         uint8_t reserved;
 841         WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for grow_memory&quot;);
 842         WASM_PARSER_FAIL_IF(reserved != 0, &quot;reserved varUint1 for grow_memory must be zero&quot;);
 843 
 844         TypedExpression delta;
 845         WASM_TRY_POP_EXPRESSION_STACK_INTO(delta, &quot;expect an i32 argument to grow_memory on the stack&quot;);
 846         WASM_VALIDATOR_FAIL_IF(delta.type() != I32, &quot;grow_memory with non-i32 delta argument has type: &quot;, delta.type());
 847 
 848         ExpressionType result;
 849         WASM_TRY_ADD_TO_CONTEXT(addGrowMemory(delta, result));
 850         m_expressionStack.constructAndAppend(I32, result);
 851 
 852         return { };
 853     }
 854 
 855     case CurrentMemory: {
 856         WASM_PARSER_FAIL_IF(!m_info.memory, &quot;current_memory is only valid if a memory is defined or imported&quot;);
 857 
 858         uint8_t reserved;
 859         WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for current_memory&quot;);
 860         WASM_PARSER_FAIL_IF(reserved != 0, &quot;reserved varUint1 for current_memory must be zero&quot;);
 861 
 862         ExpressionType result;
 863         WASM_TRY_ADD_TO_CONTEXT(addCurrentMemory(result));
 864         m_expressionStack.constructAndAppend(I32, result);
 865 
 866         return { };
 867     }
 868     }
 869 
 870     ASSERT_NOT_REACHED();
 871     return { };
 872 }
 873 
 874 // FIXME: We should try to use the same decoder function for both unreachable and reachable code. https://bugs.webkit.org/show_bug.cgi?id=165965
 875 template&lt;typename Context&gt;
 876 auto FunctionParser&lt;Context&gt;::parseUnreachableExpression() -&gt; PartialResult
 877 {
 878     ASSERT(m_unreachableBlocks);
 879 #define CREATE_CASE(name, ...) case OpType::name:
 880     switch (m_currentOpcode) {
 881     case Else: {
 882         if (m_unreachableBlocks &gt; 1)
 883             return { };
 884 
 885         ControlEntry&amp; data = m_controlStack.last();
 886         m_unreachableBlocks = 0;
 887         WASM_VALIDATOR_FAIL_IF(!ControlType::isIf(data.controlData), &quot;else block isn&#39;t associated to an if&quot;);
 888         WASM_TRY_ADD_TO_CONTEXT(addElseToUnreachable(data.controlData));
 889         m_expressionStack = WTFMove(data.elseBlockStack);
 890         return { };
 891     }
 892 
 893     case End: {
 894         if (m_unreachableBlocks == 1) {
 895             ControlEntry data = m_controlStack.takeLast();
 896             if (ControlType::isIf(data.controlData)) {
 897                 WASM_TRY_ADD_TO_CONTEXT(addElseToUnreachable(data.controlData));
 898                 m_expressionStack = WTFMove(data.elseBlockStack);
 899                 WASM_FAIL_IF_HELPER_FAILS(unify(data.controlData));
 900                 WASM_TRY_ADD_TO_CONTEXT(endBlock(data, m_expressionStack));
 901             } else
 902                 WASM_TRY_ADD_TO_CONTEXT(addEndToUnreachable(data));
 903 
 904             m_expressionStack.swap(data.enclosedExpressionStack);
 905         }
 906         m_unreachableBlocks--;
 907         return { };
 908     }
 909 
 910     case Loop:
 911     case If:
 912     case Block: {
 913         m_unreachableBlocks++;
 914         BlockSignature unused;
 915         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, unused), &quot;can&#39;t get inline type for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
 916         return { };
 917     }
 918 
 919     case BrTable: {
 920         uint32_t numberOfTargets;
 921         uint32_t unused;
 922         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfTargets), &quot;can&#39;t get the number of targets for br_table in unreachable context&quot;);
 923         WASM_PARSER_FAIL_IF(numberOfTargets == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;br_table&#39;s number of targets is too big &quot;, numberOfTargets);
 924 
 925         for (uint32_t i = 0; i &lt; numberOfTargets; ++i)
 926             WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get &quot;, i, &quot;th target for br_table in unreachable context&quot;);
 927 
 928         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get default target for br_table in unreachable context&quot;);
 929         return { };
 930     }
 931 
 932     case CallIndirect: {
 933         uint32_t unused;
 934         uint32_t unused2;
 935         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get call_indirect&#39;s signature index in unreachable context&quot;);
 936         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused2), &quot;can&#39;t get call_indirect&#39;s reserved byte in unreachable context&quot;);
 937         return { };
 938     }
 939 
 940     case F32Const: {
 941         uint32_t unused;
 942         WASM_PARSER_FAIL_IF(!parseUInt32(unused), &quot;can&#39;t parse 32-bit floating-point constant&quot;);
 943         return { };
 944     }
 945 
 946     case F64Const: {
 947         uint64_t constant;
 948         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t parse 64-bit floating-point constant&quot;);
 949         return { };
 950     }
 951 
 952     // two immediate cases
 953     FOR_EACH_WASM_MEMORY_LOAD_OP(CREATE_CASE)
 954     FOR_EACH_WASM_MEMORY_STORE_OP(CREATE_CASE) {
 955         uint32_t unused;
 956         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get first immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
 957         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get second immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
 958         return { };
 959     }
 960 
 961     // one immediate cases
 962     case SetLocal:
 963     case GetLocal:
 964     case TeeLocal:
 965     case GetGlobal:
 966     case SetGlobal:
 967     case Br:
 968     case BrIf:
 969     case Call: {
 970         uint32_t unused;
 971         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
 972         return { };
 973     }
 974 
 975     case I32Const: {
 976         int32_t unused;
 977         WASM_PARSER_FAIL_IF(!parseVarInt32(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
 978         return { };
 979     }
 980 
 981     case I64Const: {
 982         int64_t unused;
 983         WASM_PARSER_FAIL_IF(!parseVarInt64(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
 984         return { };
 985     }
 986 
 987     case ExtTable:
 988     case TableGet:
 989     case TableSet: {
 990         unsigned tableIndex;
 991         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
 992         FALLTHROUGH;
 993     }
 994     case RefIsNull:
 995     case RefNull: {
 996         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 997         return { };
 998     }
 999 
1000     case RefFunc: {
1001         uint32_t unused;
1002         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
1003         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
1004         return { };
1005     }
1006 
1007     case GrowMemory:
1008     case CurrentMemory: {
1009         uint8_t reserved;
1010         WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for grow_memory/current_memory&quot;);
1011         return { };
1012     }
1013 
1014     // no immediate cases
1015     FOR_EACH_WASM_BINARY_OP(CREATE_CASE)
1016     FOR_EACH_WASM_UNARY_OP(CREATE_CASE)
1017     case Unreachable:
1018     case Nop:
1019     case Return:
1020     case Select:
1021     case Drop: {
1022         return { };
1023     }
1024     }
1025 #undef CREATE_CASE
1026     RELEASE_ASSERT_NOT_REACHED();
1027 }
1028 
1029 } } // namespace JSC::Wasm
1030 
1031 #undef WASM_TRY_POP_EXPRESSION_STACK_INTO
1032 #undef WASM_TRY_ADD_TO_CONTEXT
1033 #undef WASM_VALIDATOR_FAIL_IF
1034 
1035 #endif // ENABLE(WEBASSEMBLY)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerJob.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServiceWorkerGlobalScope.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerJob.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerJob.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerJob.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;HTTPHeaderNames.h&quot;
 32 #include &quot;JSDOMPromiseDeferred.h&quot;
 33 #include &quot;MIMETypeRegistry.h&quot;
 34 #include &quot;ResourceError.h&quot;
 35 #include &quot;ResourceResponse.h&quot;
 36 #include &quot;ScriptExecutionContext.h&quot;

 37 #include &quot;ServiceWorkerJobData.h&quot;
 38 #include &quot;ServiceWorkerRegistration.h&quot;
 39 
 40 namespace WebCore {
 41 
 42 ServiceWorkerJob::ServiceWorkerJob(ServiceWorkerJobClient&amp; client, RefPtr&lt;DeferredPromise&gt;&amp;&amp; promise, ServiceWorkerJobData&amp;&amp; jobData)
 43     : m_client(client)
 44     , m_jobData(WTFMove(jobData))
 45     , m_promise(WTFMove(promise))
 46     , m_contextIdentifier(client.contextIdentifier())
 47 {
 48 }
 49 
 50 ServiceWorkerJob::~ServiceWorkerJob()
 51 {
 52     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
 53 }
 54 





 55 void ServiceWorkerJob::failedWithException(const Exception&amp; exception)
 56 {
 57     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
 58     ASSERT(!m_completed);
 59 
 60     m_completed = true;
 61     m_client.jobFailedWithException(*this, exception);
 62 }
 63 
 64 void ServiceWorkerJob::resolvedWithRegistration(ServiceWorkerRegistrationData&amp;&amp; data, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
 65 {
 66     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
 67     ASSERT(!m_completed);
 68 
 69     m_completed = true;
 70     m_client.jobResolvedWithRegistration(*this, WTFMove(data), shouldNotifyWhenResolved);
 71 }
 72 
 73 void ServiceWorkerJob::resolvedWithUnregistrationResult(bool unregistrationResult)
 74 {
</pre>
<hr />
<pre>
 90 void ServiceWorkerJob::fetchScriptWithContext(ScriptExecutionContext&amp; context, FetchOptions::Cache cachePolicy)
 91 {
 92     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
 93     ASSERT(!m_completed);
 94 
 95     // FIXME: WorkerScriptLoader is the wrong loader class to use here, but there&#39;s nothing else better right now.
 96     m_scriptLoader = WorkerScriptLoader::create();
 97 
 98     ResourceRequest request { m_jobData.scriptURL };
 99     request.setInitiatorIdentifier(context.resourceRequestIdentifier());
100     request.addHTTPHeaderField(&quot;Service-Worker&quot;_s, &quot;script&quot;_s);
101 
102     FetchOptions options;
103     options.mode = FetchOptions::Mode::SameOrigin;
104     options.cache = cachePolicy;
105     options.redirect = FetchOptions::Redirect::Error;
106     options.destination = FetchOptions::Destination::Serviceworker;
107     m_scriptLoader-&gt;loadAsynchronously(context, WTFMove(request), WTFMove(options), ContentSecurityPolicyEnforcement::DoNotEnforce, ServiceWorkersMode::None, *this);
108 }
109 
<span class="line-modified">110 void ServiceWorkerJob::didReceiveResponse(unsigned long, const ResourceResponse&amp; response)</span>
111 {
<span class="line-removed">112     ASSERT(m_creationThread.ptr() == &amp;Thread::current());</span>
<span class="line-removed">113     ASSERT(!m_completed);</span>
<span class="line-removed">114     ASSERT(m_scriptLoader);</span>
<span class="line-removed">115 </span>
116     // Extract a MIME type from the response&#39;s header list. If this MIME type (ignoring parameters) is not a JavaScript MIME type, then:
<span class="line-modified">117     if (!MIMETypeRegistry::isSupportedJavaScriptMIMEType(response.mimeType())) {</span>
<span class="line-modified">118         m_scriptLoader-&gt;cancel();</span>
<span class="line-removed">119         m_scriptLoader = nullptr;</span>
<span class="line-removed">120 </span>
<span class="line-removed">121         // Invoke Reject Job Promise with job and &quot;SecurityError&quot; DOMException.</span>
<span class="line-removed">122         Exception exception { SecurityError, &quot;MIME Type is not a JavaScript MIME type&quot;_s };</span>
<span class="line-removed">123         // Asynchronously complete these steps with a network error.</span>
<span class="line-removed">124         ResourceError error { errorDomainWebKitInternal, 0, response.url(), &quot;Unexpected MIME type&quot;_s };</span>
<span class="line-removed">125         m_client.jobFailedLoadingScript(*this, WTFMove(error), WTFMove(exception));</span>
<span class="line-removed">126         return;</span>
<span class="line-removed">127     }</span>
128 
129     String serviceWorkerAllowed = response.httpHeaderField(HTTPHeaderName::ServiceWorkerAllowed);
130     String maxScopeString;
131     if (serviceWorkerAllowed.isNull()) {
<span class="line-modified">132         String path = m_jobData.scriptURL.path();</span>
133         // Last part of the path is the script&#39;s filename.
134         maxScopeString = path.substring(0, path.reverseFind(&#39;/&#39;) + 1);
135     } else {
<span class="line-modified">136         auto maxScope = URL(m_jobData.scriptURL, serviceWorkerAllowed);</span>
<span class="line-modified">137         maxScopeString = maxScope.path();</span>

138     }
139 
<span class="line-modified">140     String scopeString = m_jobData.scopeURL.path();</span>
<span class="line-modified">141     if (scopeString.startsWith(maxScopeString))</span>













142         return;
143 
144     m_scriptLoader-&gt;cancel();
145     m_scriptLoader = nullptr;
146 
<span class="line-modified">147     Exception exception { SecurityError, &quot;Scope URL should start with the given script URL&quot;_s };</span>
<span class="line-removed">148     ResourceError error { errorDomainWebKitInternal, 0, response.url(), &quot;Scope URL should start with the given script URL&quot;_s };</span>
149     m_client.jobFailedLoadingScript(*this, WTFMove(error), WTFMove(exception));
150 }
151 
152 void ServiceWorkerJob::notifyFinished()
153 {
154     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
155     ASSERT(m_scriptLoader);
156 
157     auto scriptLoader = WTFMove(m_scriptLoader);
158 
159     if (!scriptLoader-&gt;failed()) {
160         m_client.jobFinishedLoadingScript(*this, scriptLoader-&gt;script(), scriptLoader-&gt;contentSecurityPolicy(), scriptLoader-&gt;referrerPolicy());
161         return;
162     }
163 
164     auto&amp; error = scriptLoader-&gt;error();
165     ASSERT(!error.isNull());
166 
167     m_client.jobFailedLoadingScript(*this, error, Exception { error.isAccessControl() ? SecurityError : TypeError, makeString(&quot;Script &quot;, scriptLoader-&gt;url().string(), &quot; load failed&quot;) });
168 }
</pre>
</td>
<td>
<hr />
<pre>
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerJob.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;HTTPHeaderNames.h&quot;
 32 #include &quot;JSDOMPromiseDeferred.h&quot;
 33 #include &quot;MIMETypeRegistry.h&quot;
 34 #include &quot;ResourceError.h&quot;
 35 #include &quot;ResourceResponse.h&quot;
 36 #include &quot;ScriptExecutionContext.h&quot;
<span class="line-added"> 37 #include &quot;SecurityOrigin.h&quot;</span>
 38 #include &quot;ServiceWorkerJobData.h&quot;
 39 #include &quot;ServiceWorkerRegistration.h&quot;
 40 
 41 namespace WebCore {
 42 
 43 ServiceWorkerJob::ServiceWorkerJob(ServiceWorkerJobClient&amp; client, RefPtr&lt;DeferredPromise&gt;&amp;&amp; promise, ServiceWorkerJobData&amp;&amp; jobData)
 44     : m_client(client)
 45     , m_jobData(WTFMove(jobData))
 46     , m_promise(WTFMove(promise))
 47     , m_contextIdentifier(client.contextIdentifier())
 48 {
 49 }
 50 
 51 ServiceWorkerJob::~ServiceWorkerJob()
 52 {
 53     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
 54 }
 55 
<span class="line-added"> 56 RefPtr&lt;DeferredPromise&gt; ServiceWorkerJob::takePromise()</span>
<span class="line-added"> 57 {</span>
<span class="line-added"> 58     return WTFMove(m_promise);</span>
<span class="line-added"> 59 }</span>
<span class="line-added"> 60 </span>
 61 void ServiceWorkerJob::failedWithException(const Exception&amp; exception)
 62 {
 63     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
 64     ASSERT(!m_completed);
 65 
 66     m_completed = true;
 67     m_client.jobFailedWithException(*this, exception);
 68 }
 69 
 70 void ServiceWorkerJob::resolvedWithRegistration(ServiceWorkerRegistrationData&amp;&amp; data, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
 71 {
 72     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
 73     ASSERT(!m_completed);
 74 
 75     m_completed = true;
 76     m_client.jobResolvedWithRegistration(*this, WTFMove(data), shouldNotifyWhenResolved);
 77 }
 78 
 79 void ServiceWorkerJob::resolvedWithUnregistrationResult(bool unregistrationResult)
 80 {
</pre>
<hr />
<pre>
 96 void ServiceWorkerJob::fetchScriptWithContext(ScriptExecutionContext&amp; context, FetchOptions::Cache cachePolicy)
 97 {
 98     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
 99     ASSERT(!m_completed);
100 
101     // FIXME: WorkerScriptLoader is the wrong loader class to use here, but there&#39;s nothing else better right now.
102     m_scriptLoader = WorkerScriptLoader::create();
103 
104     ResourceRequest request { m_jobData.scriptURL };
105     request.setInitiatorIdentifier(context.resourceRequestIdentifier());
106     request.addHTTPHeaderField(&quot;Service-Worker&quot;_s, &quot;script&quot;_s);
107 
108     FetchOptions options;
109     options.mode = FetchOptions::Mode::SameOrigin;
110     options.cache = cachePolicy;
111     options.redirect = FetchOptions::Redirect::Error;
112     options.destination = FetchOptions::Destination::Serviceworker;
113     m_scriptLoader-&gt;loadAsynchronously(context, WTFMove(request), WTFMove(options), ContentSecurityPolicyEnforcement::DoNotEnforce, ServiceWorkersMode::None, *this);
114 }
115 
<span class="line-modified">116 ResourceError ServiceWorkerJob::validateServiceWorkerResponse(const ServiceWorkerJobData&amp; jobData, const ResourceResponse&amp; response)</span>
117 {




118     // Extract a MIME type from the response&#39;s header list. If this MIME type (ignoring parameters) is not a JavaScript MIME type, then:
<span class="line-modified">119     if (!MIMETypeRegistry::isSupportedJavaScriptMIMEType(response.mimeType()))</span>
<span class="line-modified">120         return { errorDomainWebKitInternal, 0, response.url(), &quot;MIME Type is not a JavaScript MIME type&quot;_s };</span>









121 
122     String serviceWorkerAllowed = response.httpHeaderField(HTTPHeaderName::ServiceWorkerAllowed);
123     String maxScopeString;
124     if (serviceWorkerAllowed.isNull()) {
<span class="line-modified">125         String path = jobData.scriptURL.path();</span>
126         // Last part of the path is the script&#39;s filename.
127         maxScopeString = path.substring(0, path.reverseFind(&#39;/&#39;) + 1);
128     } else {
<span class="line-modified">129         auto maxScope = URL(jobData.scriptURL, serviceWorkerAllowed);</span>
<span class="line-modified">130         if (SecurityOrigin::create(maxScope)-&gt;isSameOriginAs(SecurityOrigin::create(jobData.scriptURL)))</span>
<span class="line-added">131             maxScopeString = maxScope.path();</span>
132     }
133 
<span class="line-modified">134     String scopeString = jobData.scopeURL.path();</span>
<span class="line-modified">135     if (!scopeString.startsWith(maxScopeString))</span>
<span class="line-added">136         return { errorDomainWebKitInternal, 0, response.url(), &quot;Scope URL should start with the given script URL&quot;_s };</span>
<span class="line-added">137 </span>
<span class="line-added">138     return { };</span>
<span class="line-added">139 }</span>
<span class="line-added">140 </span>
<span class="line-added">141 void ServiceWorkerJob::didReceiveResponse(unsigned long, const ResourceResponse&amp; response)</span>
<span class="line-added">142 {</span>
<span class="line-added">143     ASSERT(m_creationThread.ptr() == &amp;Thread::current());</span>
<span class="line-added">144     ASSERT(!m_completed);</span>
<span class="line-added">145     ASSERT(m_scriptLoader);</span>
<span class="line-added">146 </span>
<span class="line-added">147     auto error = validateServiceWorkerResponse(m_jobData, response);</span>
<span class="line-added">148     if (error.isNull())</span>
149         return;
150 
151     m_scriptLoader-&gt;cancel();
152     m_scriptLoader = nullptr;
153 
<span class="line-modified">154     Exception exception { SecurityError, error.localizedDescription() };</span>

155     m_client.jobFailedLoadingScript(*this, WTFMove(error), WTFMove(exception));
156 }
157 
158 void ServiceWorkerJob::notifyFinished()
159 {
160     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
161     ASSERT(m_scriptLoader);
162 
163     auto scriptLoader = WTFMove(m_scriptLoader);
164 
165     if (!scriptLoader-&gt;failed()) {
166         m_client.jobFinishedLoadingScript(*this, scriptLoader-&gt;script(), scriptLoader-&gt;contentSecurityPolicy(), scriptLoader-&gt;referrerPolicy());
167         return;
168     }
169 
170     auto&amp; error = scriptLoader-&gt;error();
171     ASSERT(!error.isNull());
172 
173     m_client.jobFailedLoadingScript(*this, error, Exception { error.isAccessControl() ? SecurityError : TypeError, makeString(&quot;Script &quot;, scriptLoader-&gt;url().string(), &quot; load failed&quot;) });
174 }
</pre>
</td>
</tr>
</table>
<center><a href="ServiceWorkerGlobalScope.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerJob.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/PreviewConverter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;PreviewConverter.h&quot;
 28 
 29 #if ENABLE(PREVIEW_CONVERTER)
 30 
 31 #include &quot;PreviewConverterClient.h&quot;
 32 #include &quot;PreviewConverterProvider.h&quot;
 33 #include &quot;SharedBuffer.h&quot;
 34 #include &lt;wtf/RunLoop.h&gt;
 35 #include &lt;wtf/SetForScope.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 PreviewConverter::~PreviewConverter() = default;
 40 
 41 bool PreviewConverter::supportsMIMEType(const String&amp; mimeType)
 42 {
 43     if (mimeType.isNull())
 44         return false;
 45 
 46     if (equalLettersIgnoringASCIICase(mimeType, &quot;text/html&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;text/plain&quot;))
 47         return false;
 48 
 49     static NeverDestroyed&lt;HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&gt; supportedMIMETypes = platformSupportedMIMETypes();
 50     return supportedMIMETypes-&gt;contains(mimeType);
 51 }
 52 
 53 ResourceResponse PreviewConverter::previewResponse() const
 54 {
 55     auto response = platformPreviewResponse();
 56     ASSERT(response.mimeType().length());
 57     response.setIsQuickLook(true);
 58     return response;
 59 }
 60 
 61 const ResourceError&amp; PreviewConverter::previewError() const
 62 {
 63     return m_previewError;
 64 }
 65 
 66 const SharedBuffer&amp; PreviewConverter::previewData() const
 67 {
 68     return m_previewData.get();
 69 }
 70 
 71 void PreviewConverter::updateMainResource()
 72 {
 73     if (m_isInClientCallback)
 74         return;
 75 
 76     if (m_state != State::Updating)
 77         return;
 78 
 79     auto provider = m_provider.get();
 80     if (!provider) {
 81         didFailUpdating();
 82         return;
 83     }
 84 
 85     provider-&gt;provideMainResourceForPreviewConverter(*this, [this, protectedThis = makeRef(*this)](auto buffer) {
 86         if (buffer)
 87             appendFromBuffer(*buffer);
 88         else
 89             didFailUpdating();
 90     });
 91 }
 92 
 93 void PreviewConverter::appendFromBuffer(const SharedBuffer&amp; buffer)
 94 {
 95     while (buffer.size() &gt; m_lengthAppended) {
 96         auto newData = buffer.getSomeData(m_lengthAppended);
 97         platformAppend(newData);
 98         m_lengthAppended += newData.size();
 99     }
100 }
101 
102 void PreviewConverter::finishUpdating()
103 {
104     if (m_isInClientCallback)
105         return;
106 
107     if (m_state != State::Updating)
108         return;
109 
110     platformFinishedAppending();
111 
112     iterateClients([&amp;](auto&amp; client) {
113         client.previewConverterDidFinishUpdating(*this);
114     });
115 }
116 
117 void PreviewConverter::failedUpdating()
118 {
119     if (m_isInClientCallback)
120         return;
121 
122     if (m_state != State::Updating)
123         return;
124 
125     m_state = State::FailedUpdating;
126     platformFailedAppending();
127 }
128 
129 bool PreviewConverter::hasClient(PreviewConverterClient&amp; client) const
130 {
131     return m_clients.contains(&amp;client);
132 }
133 
134 void PreviewConverter::addClient(PreviewConverterClient&amp; client)
135 {
136     ASSERT(!hasClient(client));
137     m_clients.append(makeWeakPtr(client));
138     didAddClient(client);
139 }
140 
141 void PreviewConverter::removeClient(PreviewConverterClient&amp; client)
142 {
143     m_clients.removeFirst(&amp;client);
144     ASSERT(!hasClient(client));
145 }
146 
147 static String&amp; sharedPasswordForTesting()
148 {
149     static NeverDestroyed&lt;String&gt; passwordForTesting;
150     return passwordForTesting.get();
151 }
152 
153 const String&amp; PreviewConverter::passwordForTesting()
154 {
155     return sharedPasswordForTesting();
156 }
157 
158 void PreviewConverter::setPasswordForTesting(const String&amp; password)
159 {
160     sharedPasswordForTesting() = password;
161 }
162 
163 template&lt;typename T&gt;
164 void PreviewConverter::iterateClients(T&amp;&amp; callback)
165 {
166     SetForScope&lt;bool&gt; isInClientCallback { m_isInClientCallback, true };
167     auto clientsCopy { m_clients };
168     auto protectedThis { makeRef(*this) };
169 
170     for (auto&amp; client : clientsCopy) {
171         if (client &amp;&amp; hasClient(*client))
172             callback(*client);
173     }
174 }
175 
176 void PreviewConverter::didAddClient(PreviewConverterClient&amp; client)
177 {
178     RunLoop::current().dispatch([this, protectedThis = makeRef(*this), weakClient = makeWeakPtr(client)]() {
179         if (auto client = weakClient.get())
180             replayToClient(*client);
181     });
182 }
183 
184 void PreviewConverter::didFailConvertingWithError(const ResourceError&amp; error)
185 {
186     m_previewError = error;
187     m_state = State::FailedConverting;
188 
189     iterateClients([&amp;](auto&amp; client) {
190         client.previewConverterDidFailConverting(*this);
191     });
192 }
193 
194 void PreviewConverter::didFailUpdating()
195 {
196     failedUpdating();
197 
198     iterateClients([&amp;](auto&amp; client) {
199         client.previewConverterDidFailUpdating(*this);
200     });
201 }
202 
203 void PreviewConverter::replayToClient(PreviewConverterClient&amp; client)
204 {
205     if (!hasClient(client))
206         return;
207 
208     SetForScope&lt;bool&gt; isInClientCallback { m_isInClientCallback, true };
209     auto protectedThis { makeRef(*this) };
210 
211     client.previewConverterDidStartUpdating(*this);
212 
213     if (m_state == State::Updating || !hasClient(client))
214         return;
215 
216     if (m_state == State::FailedUpdating) {
217         client.previewConverterDidFailUpdating(*this);
218         return;
219     }
220 
221     ASSERT(m_state &gt;= State::Converting);
222     client.previewConverterDidStartConverting(*this);
223 
224     if (!m_previewData-&gt;isEmpty() &amp;&amp; hasClient(client))
225         client.previewConverterDidReceiveData(*this, m_previewData.get());
226 
227     if (m_state == State::Converting || !hasClient(client))
228         return;
229 
230     if (m_state == State::FailedConverting) {
231         ASSERT(!m_previewError.isNull());
232         client.previewConverterDidFailConverting(*this);
233         return;
234     }
235 
236     ASSERT(m_state == State::FinishedConverting);
237     ASSERT(!m_previewData-&gt;isEmpty());
238     ASSERT(m_previewError.isNull());
239     client.previewConverterDidFinishConverting(*this);
240 }
241 
242 void PreviewConverter::delegateDidReceiveData(const SharedBuffer&amp; data)
243 {
244     auto protectedThis { makeRef(*this) };
245 
246     if (m_state == State::Updating) {
247         m_provider = nullptr;
248         m_state = State::Converting;
249 
250         iterateClients([&amp;](auto&amp; client) {
251             client.previewConverterDidStartConverting(*this);
252         });
253     }
254 
255     ASSERT(m_state == State::Converting);
256     if (data.isEmpty())
257         return;
258 
259     m_previewData-&gt;append(data);
260 
261     iterateClients([&amp;](auto&amp; client) {
262         client.previewConverterDidReceiveData(*this, data);
263     });
264 }
265 
266 void PreviewConverter::delegateDidFinishLoading()
267 {
268     ASSERT(m_state == State::Converting);
269     m_state = State::FinishedConverting;
270 
271     iterateClients([&amp;](auto&amp; client) {
272         client.previewConverterDidFinishConverting(*this);
273     });
274 }
275 
276 void PreviewConverter::delegateDidFailWithError(const ResourceError&amp; error)
277 {
278     if (!isPlatformPasswordError(error)) {
279         didFailConvertingWithError(error);
280         return;
281     }
282 
283     ASSERT(m_state == State::Updating);
284     auto provider = m_provider.get();
285     if (!provider) {
286         didFailConvertingWithError(error);
287         return;
288     }
289 
290     provider-&gt;providePasswordForPreviewConverter(*this, [this, protectedThis = makeRef(*this)](auto&amp; password) mutable {
291         if (m_state != State::Updating)
292             return;
293 
294         platformUnlockWithPassword(password);
295         m_lengthAppended = 0;
296         updateMainResource();
297         finishUpdating();
298     });
299 }
300 
301 } // namespace WebCore
302 
303 #endif // ENABLE(PREVIEW_CONVERTER)
    </pre>
  </body>
</html>
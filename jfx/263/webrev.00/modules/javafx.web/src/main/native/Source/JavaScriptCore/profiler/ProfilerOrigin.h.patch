diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/profiler/ProfilerOrigin.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/profiler/ProfilerOrigin.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/profiler/ProfilerOrigin.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/profiler/ProfilerOrigin.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2012 Apple Inc. All rights reserved.
+ * Copyright (C) 2012-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -23,10 +23,11 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #pragma once
 
+#include "BytecodeIndex.h"
 #include "CodeBlockHash.h"
 #include "JSCJSValue.h"
 #include <wtf/PrintStream.h>
 
 namespace JSC {
@@ -38,68 +39,63 @@
 class Bytecodes;
 class Database;
 
 class Origin {
 public:
-    Origin()
-        : m_bytecodeIndex(std::numeric_limits<unsigned>::max())
-    {
-    }
-
+    Origin() = default;
     Origin(WTF::HashTableDeletedValueType)
-        : m_bytecodeIndex(std::numeric_limits<unsigned>::max() - 1)
-    {
-    }
+        : m_bytecodeIndex(WTF::HashTableDeletedValue)
+    { }
 
-    Origin(Bytecodes* bytecodes, unsigned bytecodeIndex)
+    Origin(Bytecodes* bytecodes, BytecodeIndex bytecodeIndex)
         : m_bytecodes(bytecodes)
         , m_bytecodeIndex(bytecodeIndex)
     {
-        ASSERT(m_bytecodeIndex < std::numeric_limits<unsigned>::max() - 1);
+        ASSERT(m_bytecodeIndex.offset() < std::numeric_limits<unsigned>::max() - 1);
     }
 
-    Origin(Database&, CodeBlock*, unsigned bytecodeIndex);
+    Origin(Database&, CodeBlock*, BytecodeIndex);
 
-    bool operator!() const { return m_bytecodeIndex == std::numeric_limits<unsigned>::max(); }
+    bool operator!() const { return !m_bytecodeIndex; }
 
     Bytecodes* bytecodes() const { return m_bytecodes; }
-    unsigned bytecodeIndex() const { return m_bytecodeIndex; }
+    BytecodeIndex bytecodeIndex() const { return m_bytecodeIndex; }
 
     bool operator==(const Origin&) const;
     bool operator!=(const Origin& other) const { return !(*this == other); }
     unsigned hash() const;
 
     bool isHashTableDeletedValue() const;
 
     void dump(PrintStream&) const;
-    JSValue toJS(ExecState*) const;
+    JSValue toJS(JSGlobalObject*) const;
 
 private:
     Bytecodes* m_bytecodes;
-    unsigned m_bytecodeIndex;
+    BytecodeIndex m_bytecodeIndex;
 };
 
 inline bool Origin::operator==(const Origin& other) const
 {
     return m_bytecodes == other.m_bytecodes
         && m_bytecodeIndex == other.m_bytecodeIndex;
 }
 
 inline unsigned Origin::hash() const
 {
-    return WTF::PtrHash<Bytecodes*>::hash(m_bytecodes) + m_bytecodeIndex;
+    return WTF::PtrHash<Bytecodes*>::hash(m_bytecodes) + m_bytecodeIndex.hash();
 }
 
 inline bool Origin::isHashTableDeletedValue() const
 {
-    return m_bytecodeIndex == std::numeric_limits<unsigned>::max();
+    return m_bytecodeIndex.isHashTableDeletedValue();
 }
 
 struct OriginHash {
     static unsigned hash(const Origin& key) { return key.hash(); }
     static bool equal(const Origin& a, const Origin& b) { return a == b; }
-    static const bool safeToCompareToEmptyOrDeleted = true;
+    static constexpr bool safeToCompareToEmptyOrDeleted = true;
 };
 
 } } // namespace JSC::Profiler
 
 namespace WTF {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGNodeType.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGNodeFlowProjection.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOSRAvailabilityAnalysisPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGNodeType.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2012-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 36     /* A constant in the CodeBlock&#39;s constant pool. */\
 37     macro(JSConstant, NodeResultJS) \
 38     \
 39     /* Constants with specific representations. */\
 40     macro(DoubleConstant, NodeResultDouble) \
 41     macro(Int52Constant, NodeResultInt52) \
 42     \
 43     /* Lazy JSValue constant. We don&#39;t know the JSValue bits of it yet. */\
 44     macro(LazyJSConstant, NodeResultJS) \
 45     \
 46     /* Marker to indicate that an operation was optimized entirely and all that is left */\
 47     /* is to make one node alias another. CSE will later usually eliminate this node, */\
 48     /* though it may choose not to if it would corrupt predictions (very rare). */\
 49     macro(Identity, NodeResultJS) \
 50     /* Used for debugging to force a profile to appear as anything we want. */ \
 51     macro(IdentityWithProfile, NodeResultJS | NodeMustGenerate) \
 52     \
 53     /* Nodes for handling functions (both as call and as construct). */\
 54     macro(ToThis, NodeResultJS) \
 55     macro(CreateThis, NodeResultJS) /* Note this is not MustGenerate since we&#39;re returning it anyway. */ \



 56     macro(GetCallee, NodeResultJS) \
 57     macro(SetCallee, NodeMustGenerate) \
 58     macro(GetArgumentCountIncludingThis, NodeResultInt32) \
 59     macro(SetArgumentCountIncludingThis, NodeMustGenerate) \
 60     \
 61     /* Nodes for local variable access. These nodes are linked together using Phi nodes. */\
 62     /* Any two nodes that are part of the same Phi graph will share the same */\
 63     /* VariableAccessData, and thus will share predictions. FIXME: We should come up with */\
 64     /* better names for a lot of these. https://bugs.webkit.org/show_bug.cgi?id=137307. */\
 65     /* Note that GetLocal is MustGenerate because it&#39;s our only way of knowing that some other */\
 66     /* basic block might have read a local variable in bytecode. We only remove GetLocals if it */\
 67     /* is redundant because of an earlier GetLocal or SetLocal in the same block. We could make */\
 68     /* these not MustGenerate and use a more sophisticated analysis to insert PhantomLocals in */\
 69     /* the same way that we insert Phantoms. That&#39;s hard and probably not profitable. See */\
 70     /* https://bugs.webkit.org/show_bug.cgi?id=144086 */\
 71     macro(GetLocal, NodeResultJS | NodeMustGenerate) \
 72     macro(SetLocal, 0) \
 73     \

 74     macro(PutStack, NodeMustGenerate) \
 75     macro(KillStack, NodeMustGenerate) \
 76     macro(GetStack, NodeResultJS) \
 77     \
 78     macro(MovHint, NodeMustGenerate) \
 79     macro(ZombieHint, NodeMustGenerate) \
 80     macro(ExitOK, NodeMustGenerate) /* Indicates that exit state is intact. */ \
 81     macro(Phantom, NodeMustGenerate) \
 82     macro(Check, NodeMustGenerate) /* Used if we want just a type check but not liveness. Non-checking uses will be removed. */\
 83     macro(CheckVarargs, NodeMustGenerate | NodeHasVarArgs) /* Used if we want just a type check but not liveness. Non-checking uses will be removed. */\
 84     macro(Upsilon, 0) \
 85     macro(Phi, 0) \
 86     macro(Flush, NodeMustGenerate) \
 87     macro(PhantomLocal, NodeMustGenerate) \
 88     \
 89     /* Hint that this is where bytecode thinks is a good place to OSR. Note that this */\
 90     /* will exist even in inlined loops. This has no execution semantics but it must */\
 91     /* survive all DCE. We treat this as being a can-exit because tier-up to FTL may */\
 92     /* want all state. */\
 93     macro(LoopHint, NodeMustGenerate) \
</pre>
<hr />
<pre>
106     /* Marker for an argument being set at the prologue of a function. The argument is guaranteed to be set after this node. */\
107     macro(SetArgumentDefinitely, 0) \
108     /* A marker like the above that we use to track variable liveness and OSR exit state. However, it&#39;s not guaranteed to be set. To verify it was set, you&#39;d need to check the actual argument length. We use this for varargs when we&#39;re unsure how many argument may actually end up on the stack. */\
109     macro(SetArgumentMaybe, 0) \
110     \
111     /* Marker of location in the IR where we may possibly perform jump replacement to */\
112     /* invalidate this code block. */\
113     macro(InvalidationPoint, NodeMustGenerate) \
114     \
115     /* Nodes for bitwise operations. */\
116     macro(ValueBitNot, NodeResultJS | NodeMustGenerate) \
117     macro(ArithBitNot, NodeResultInt32) \
118     macro(ValueBitAnd, NodeResultJS | NodeMustGenerate) \
119     macro(ArithBitAnd, NodeResultInt32) \
120     macro(ValueBitOr, NodeResultJS | NodeMustGenerate) \
121     macro(ArithBitOr, NodeResultInt32) \
122     macro(ValueBitXor, NodeResultJS | NodeMustGenerate) \
123     macro(ArithBitXor, NodeResultInt32) \
124     macro(ArithBitLShift, NodeResultInt32) \
125     macro(ValueBitLShift, NodeResultJS | NodeMustGenerate) \
<span class="line-modified">126     macro(BitRShift, NodeResultInt32) \</span>

127     macro(BitURShift, NodeResultInt32) \
128     /* Bitwise operators call ToInt32 on their operands. */\
129     macro(ValueToInt32, NodeResultInt32) \
130     /* Used to box the result of URShift nodes (result has range 0..2^32-1). */\
131     macro(UInt32ToNumber, NodeResultNumber) \
132     /* Converts booleans to numbers but passes everything else through. */\
133     macro(BooleanToNumber, NodeResultJS) \
134     \
135     /* Attempt to truncate a double to int32; this will exit if it can&#39;t do it. */\
136     macro(DoubleAsInt32, NodeResultInt32) \
137     \
138     /* Change the representation of a value. */\
139     macro(DoubleRep, NodeResultDouble) \
140     macro(Int52Rep, NodeResultInt52) \
141     macro(ValueRep, NodeResultJS) \
142     \
143     /* Bogus type asserting node. Useful for testing, disappears during Fixup. */\
144     macro(FiatInt52, NodeResultJS) \
145     \
146     /* Nodes for arithmetic operations. Note that if they do checks other than just type checks, */\
</pre>
<hr />
<pre>
154     macro(ArithClz32, NodeResultInt32 | NodeMustGenerate) \
155     macro(ArithSub, NodeResultNumber | NodeMustGenerate) \
156     macro(ArithNegate, NodeResultNumber | NodeMustGenerate) \
157     macro(ArithMul, NodeResultNumber | NodeMustGenerate) \
158     macro(ArithIMul, NodeResultInt32) \
159     macro(ArithDiv, NodeResultNumber | NodeMustGenerate) \
160     macro(ArithMod, NodeResultNumber | NodeMustGenerate) \
161     macro(ArithAbs, NodeResultNumber | NodeMustGenerate) \
162     macro(ArithMin, NodeResultNumber) \
163     macro(ArithMax, NodeResultNumber) \
164     macro(ArithFRound, NodeResultDouble | NodeMustGenerate) \
165     macro(ArithPow, NodeResultDouble) \
166     macro(ArithRandom, NodeResultDouble | NodeMustGenerate) \
167     macro(ArithRound, NodeResultNumber | NodeMustGenerate) \
168     macro(ArithFloor, NodeResultNumber | NodeMustGenerate) \
169     macro(ArithCeil, NodeResultNumber | NodeMustGenerate) \
170     macro(ArithTrunc, NodeResultNumber | NodeMustGenerate) \
171     macro(ArithSqrt, NodeResultDouble | NodeMustGenerate) \
172     macro(ArithUnary, NodeResultDouble | NodeMustGenerate) \
173     \
<span class="line-modified">174     /* BigInt is a valid operand for negate operations */\</span>



175     macro(ValueNegate, NodeResultJS | NodeMustGenerate) \
176     \
177     /* Add of values may either be arithmetic, or result in string concatenation. */\
178     macro(ValueAdd, NodeResultJS | NodeMustGenerate) \
179     \
180     macro(ValueSub, NodeResultJS | NodeMustGenerate) \
181     macro(ValueMul, NodeResultJS | NodeMustGenerate) \
182     macro(ValueDiv, NodeResultJS | NodeMustGenerate) \
183     macro(ValuePow, NodeResultJS | NodeMustGenerate) \
184     macro(ValueMod, NodeResultJS | NodeMustGenerate) \
185     \
186     /* Add of values that always convers its inputs to strings. May have two or three kids. */\
187     macro(StrCat, NodeResultJS | NodeMustGenerate) \
188     \
189     /* Property access. */\
190     /* PutByValAlias indicates a &#39;put&#39; aliases a prior write to the same property. */\
191     /* Since a put to &#39;length&#39; may invalidate optimizations here, */\
192     /* this must be the directly subsequent property put. Note that PutByVal */\
193     /* opcodes use VarArgs beause they may have up to 4 children. */\
194     macro(GetByVal, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
195     macro(GetByValWithThis, NodeResultJS | NodeMustGenerate) \
196     macro(GetMyArgumentByVal, NodeResultJS | NodeMustGenerate) \
197     macro(GetMyArgumentByValOutOfBounds, NodeResultJS | NodeMustGenerate) \

198     macro(LoadVarargs, NodeMustGenerate) \
199     macro(ForwardVarargs, NodeMustGenerate) \
200     macro(PutByValDirect, NodeMustGenerate | NodeHasVarArgs) \
201     macro(PutByVal, NodeMustGenerate | NodeHasVarArgs) \
202     macro(PutByValAlias, NodeMustGenerate | NodeHasVarArgs) \
203     macro(TryGetById, NodeResultJS) \
204     macro(GetById, NodeResultJS | NodeMustGenerate) \
205     macro(GetByIdFlush, NodeResultJS | NodeMustGenerate) \
206     macro(GetByIdWithThis, NodeResultJS | NodeMustGenerate) \
207     macro(GetByIdDirect, NodeResultJS | NodeMustGenerate) \
208     macro(GetByIdDirectFlush, NodeResultJS | NodeMustGenerate) \
209     macro(PutById, NodeMustGenerate) \
210     macro(PutByIdFlush, NodeMustGenerate) \
211     macro(PutByIdDirect, NodeMustGenerate) \
212     macro(PutByIdWithThis, NodeMustGenerate) \
213     macro(PutByValWithThis, NodeMustGenerate | NodeHasVarArgs) \
214     macro(PutGetterById, NodeMustGenerate) \
215     macro(PutSetterById, NodeMustGenerate) \
216     macro(PutGetterSetterById, NodeMustGenerate) \
217     macro(PutGetterByVal, NodeMustGenerate) \
218     macro(PutSetterByVal, NodeMustGenerate) \
219     macro(DefineDataProperty, NodeMustGenerate | NodeHasVarArgs) \
220     macro(DefineAccessorProperty, NodeMustGenerate | NodeHasVarArgs) \
221     macro(DeleteById, NodeResultBoolean | NodeMustGenerate) \
222     macro(DeleteByVal, NodeResultBoolean | NodeMustGenerate) \
223     macro(CheckStructure, NodeMustGenerate) \
224     macro(CheckStructureOrEmpty, NodeMustGenerate) \
225     macro(GetExecutable, NodeResultJS) \
226     macro(PutStructure, NodeMustGenerate) \
227     macro(AllocatePropertyStorage, NodeMustGenerate | NodeResultStorage) \
228     macro(ReallocatePropertyStorage, NodeMustGenerate | NodeResultStorage) \
229     macro(GetButterfly, NodeResultStorage) \
230     macro(NukeStructureAndSetButterfly, NodeMustGenerate) \
231     macro(CheckArray, NodeMustGenerate) \



232     macro(Arrayify, NodeMustGenerate) \
233     macro(ArrayifyToStructure, NodeMustGenerate) \
234     macro(GetIndexedPropertyStorage, NodeResultStorage) \
235     macro(ConstantStoragePointer, NodeResultStorage) \
236     macro(GetGetter, NodeResultJS) \
237     macro(GetSetter, NodeResultJS) \
238     macro(GetByOffset, NodeResultJS) \
239     macro(GetGetterSetterByOffset, NodeResultJS) \
240     macro(MultiGetByOffset, NodeResultJS | NodeMustGenerate) \
241     macro(PutByOffset, NodeMustGenerate) \
242     macro(MultiPutByOffset, NodeMustGenerate) \
243     macro(GetArrayLength, NodeResultInt32) \
244     macro(GetVectorLength, NodeResultInt32) \
245     macro(GetTypedArrayByteOffset, NodeResultInt32) \
246     macro(GetScope, NodeResultJS) \
247     macro(SkipScope, NodeResultJS) \
248     macro(ResolveScope, NodeResultJS | NodeMustGenerate) \
249     macro(ResolveScopeForHoistingFuncDeclInEval, NodeResultJS | NodeMustGenerate) \
250     macro(GetGlobalObject, NodeResultJS) \
251     macro(GetGlobalThis, NodeResultJS) \
252     macro(GetClosureVar, NodeResultJS) \
253     macro(PutClosureVar, NodeMustGenerate) \
254     macro(GetGlobalVar, NodeResultJS) \
255     macro(GetGlobalLexicalVariable, NodeResultJS) \
256     macro(PutGlobalVariable, NodeMustGenerate) \
257     macro(GetDynamicVar, NodeResultJS | NodeMustGenerate) \
258     macro(PutDynamicVar, NodeMustGenerate) \
259     macro(NotifyWrite, NodeMustGenerate) \
260     macro(GetRegExpObjectLastIndex, NodeResultJS) \
261     macro(SetRegExpObjectLastIndex, NodeMustGenerate) \
262     macro(RecordRegExpCachedResult, NodeMustGenerate | NodeHasVarArgs) \
263     macro(CheckCell, NodeMustGenerate) \
264     macro(CheckNotEmpty, NodeMustGenerate) \
265     macro(AssertNotEmpty, NodeMustGenerate) \
266     macro(CheckBadCell, NodeMustGenerate) \
267     macro(CheckInBounds, NodeMustGenerate | NodeResultJS) \
<span class="line-modified">268     macro(CheckStringIdent, NodeMustGenerate) \</span>
269     macro(CheckTypeInfoFlags, NodeMustGenerate) /* Takes an OpInfo with the flags you want to test are set */\
270     macro(CheckSubClass, NodeMustGenerate) \
271     macro(ParseInt, NodeMustGenerate | NodeResultJS) \
272     macro(GetPrototypeOf, NodeMustGenerate | NodeResultJS) \
273     macro(ObjectCreate, NodeMustGenerate | NodeResultJS) \
274     macro(ObjectKeys, NodeMustGenerate | NodeResultJS) \
275     \
276     /* Atomics object functions. */\
277     macro(AtomicsAdd, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
278     macro(AtomicsAnd, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
279     macro(AtomicsCompareExchange, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
280     macro(AtomicsExchange, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
281     macro(AtomicsIsLockFree, NodeResultBoolean) \
282     macro(AtomicsLoad, NodeResultJS | NodeMustGenerate) \
283     macro(AtomicsOr, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
284     macro(AtomicsStore, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
285     macro(AtomicsSub, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
286     macro(AtomicsXor, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
287     \
288     /* Optimizations for array mutation. */\
289     macro(ArrayPush, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
290     macro(ArrayPop, NodeResultJS | NodeMustGenerate) \
291     macro(ArraySlice, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
292     macro(ArrayIndexOf, NodeResultInt32 | NodeHasVarArgs) \
293     \
294     /* Optimizations for regular expression matching. */\
295     macro(RegExpExec, NodeResultJS | NodeMustGenerate) \
296     macro(RegExpExecNonGlobalOrSticky, NodeResultJS) \
297     macro(RegExpTest, NodeResultJS | NodeMustGenerate) \
298     macro(RegExpMatchFast, NodeResultJS | NodeMustGenerate) \
299     macro(RegExpMatchFastGlobal, NodeResultJS) \
300     macro(StringReplace, NodeResultJS | NodeMustGenerate) \
301     macro(StringReplaceRegExp, NodeResultJS | NodeMustGenerate) \
302     \
303     /* Optimizations for string access */ \
304     macro(StringCharCodeAt, NodeResultInt32) \

305     macro(StringCharAt, NodeResultJS) \
306     macro(StringFromCharCode, NodeResultJS | NodeMustGenerate) \
307     \
308     /* Nodes for comparison operations. */\
309     macro(CompareLess, NodeResultBoolean | NodeMustGenerate) \
310     macro(CompareLessEq, NodeResultBoolean | NodeMustGenerate) \
311     macro(CompareGreater, NodeResultBoolean | NodeMustGenerate) \
312     macro(CompareGreaterEq, NodeResultBoolean | NodeMustGenerate) \
313     macro(CompareBelow, NodeResultBoolean) \
314     macro(CompareBelowEq, NodeResultBoolean) \
315     macro(CompareEq, NodeResultBoolean | NodeMustGenerate) \
316     macro(CompareStrictEq, NodeResultBoolean) \
317     macro(CompareEqPtr, NodeResultBoolean) \
318     macro(SameValue, NodeResultBoolean) \
319     \
320     /* Calls. */\
321     macro(Call, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
322     macro(DirectCall, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
323     macro(Construct, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
324     macro(DirectConstruct, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
325     macro(CallVarargs, NodeResultJS | NodeMustGenerate) \
326     macro(CallForwardVarargs, NodeResultJS | NodeMustGenerate) \
327     macro(ConstructVarargs, NodeResultJS | NodeMustGenerate) \
328     macro(ConstructForwardVarargs, NodeResultJS | NodeMustGenerate) \
329     macro(TailCallInlinedCaller, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
330     macro(DirectTailCallInlinedCaller, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
331     macro(TailCallVarargsInlinedCaller, NodeResultJS | NodeMustGenerate) \
332     macro(TailCallForwardVarargsInlinedCaller, NodeResultJS | NodeMustGenerate) \
333     macro(CallEval, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
334     \
335     /* Shadow Chicken */\
336     macro(LogShadowChickenPrologue, NodeMustGenerate) \
337     macro(LogShadowChickenTail, NodeMustGenerate) \
338     \
339     /* Allocations. */\
340     macro(NewObject, NodeResultJS) \



341     macro(NewArray, NodeResultJS | NodeHasVarArgs) \
342     macro(NewArrayWithSpread, NodeResultJS | NodeHasVarArgs) \
343     macro(NewArrayWithSize, NodeResultJS | NodeMustGenerate) \
344     macro(NewArrayBuffer, NodeResultJS) \

345     macro(NewTypedArray, NodeResultJS | NodeMustGenerate) \
346     macro(NewRegexp, NodeResultJS) \
347     macro(NewSymbol, NodeResultJS) \
348     macro(NewStringObject, NodeResultJS) \
349     /* Rest Parameter */\
350     macro(GetRestLength, NodeResultInt32) \
351     macro(CreateRest, NodeResultJS | NodeMustGenerate) \
352     \
353     macro(Spread, NodeResultJS | NodeMustGenerate) \
354     /* Support for allocation sinking. */\
355     macro(PhantomNewObject, NodeResultJS | NodeMustGenerate) \
356     macro(PutHint, NodeMustGenerate) \
357     macro(CheckStructureImmediate, NodeMustGenerate) \
358     macro(MaterializeNewObject, NodeResultJS | NodeHasVarArgs) \
359     macro(PhantomNewFunction, NodeResultJS | NodeMustGenerate) \
360     macro(PhantomNewGeneratorFunction, NodeResultJS | NodeMustGenerate) \
361     macro(PhantomNewAsyncFunction, NodeResultJS | NodeMustGenerate) \
362     macro(PhantomNewAsyncGeneratorFunction, NodeResultJS | NodeMustGenerate) \


363     macro(PhantomCreateActivation, NodeResultJS | NodeMustGenerate) \
364     macro(MaterializeCreateActivation, NodeResultJS | NodeHasVarArgs) \
365     macro(PhantomNewRegexp, NodeResultJS | NodeMustGenerate) \
366     \
367     /* Nodes for misc operations. */\
368     macro(OverridesHasInstance, NodeMustGenerate | NodeResultBoolean) \
369     macro(InstanceOf, NodeMustGenerate | NodeResultBoolean) \
370     macro(InstanceOfCustom, NodeMustGenerate | NodeResultBoolean) \
371     macro(MatchStructure, NodeMustGenerate | NodeResultBoolean) \
372     \
373     macro(IsCellWithType, NodeResultBoolean) \
374     macro(IsEmpty, NodeResultBoolean) \
375     macro(IsUndefined, NodeResultBoolean) \
376     macro(IsUndefinedOrNull, NodeResultBoolean) \
377     macro(IsBoolean, NodeResultBoolean) \
378     macro(IsNumber, NodeResultBoolean) \
379     macro(NumberIsInteger, NodeResultBoolean) \
380     macro(IsObject, NodeResultBoolean) \
381     macro(IsObjectOrNull, NodeResultBoolean) \
382     macro(IsFunction, NodeResultBoolean) \
383     macro(IsTypedArrayView, NodeResultBoolean) \
384     macro(TypeOf, NodeResultJS) \
385     macro(LogicalNot, NodeResultBoolean) \
386     macro(ToPrimitive, NodeResultJS | NodeMustGenerate) \

387     macro(ToString, NodeResultJS | NodeMustGenerate) \
388     macro(ToNumber, NodeResultJS | NodeMustGenerate) \

389     macro(ToObject, NodeResultJS | NodeMustGenerate) \
390     macro(CallObjectConstructor, NodeResultJS) \
391     macro(CallStringConstructor, NodeResultJS | NodeMustGenerate) \
392     macro(NumberToStringWithRadix, NodeResultJS | NodeMustGenerate) \
393     macro(NumberToStringWithValidRadixConstant, NodeResultJS) \
394     macro(MakeRope, NodeResultJS) \
395     macro(InByVal, NodeResultBoolean | NodeMustGenerate) \
396     macro(InById, NodeResultBoolean | NodeMustGenerate) \
397     macro(ProfileType, NodeMustGenerate) \
398     macro(ProfileControlFlow, NodeMustGenerate) \
399     macro(SetFunctionName, NodeMustGenerate) \
400     macro(HasOwnProperty, NodeResultBoolean) \
401     \



402     macro(CreateActivation, NodeResultJS) \
403     macro(PushWithScope, NodeResultJS | NodeMustGenerate) \
404     \
405     macro(CreateDirectArguments, NodeResultJS) \
406     macro(PhantomDirectArguments, NodeResultJS | NodeMustGenerate) \
407     macro(PhantomCreateRest, NodeResultJS | NodeMustGenerate) \
408     macro(PhantomSpread, NodeResultJS | NodeMustGenerate) \
409     macro(PhantomNewArrayWithSpread, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
410     macro(PhantomNewArrayBuffer, NodeResultJS | NodeMustGenerate) \
411     macro(CreateScopedArguments, NodeResultJS) \
412     macro(CreateClonedArguments, NodeResultJS) \
413     macro(PhantomClonedArguments, NodeResultJS | NodeMustGenerate) \

414     macro(GetFromArguments, NodeResultJS) \
415     macro(PutToArguments, NodeMustGenerate) \
416     macro(GetArgument, NodeResultJS) \
417     \
418     macro(NewFunction, NodeResultJS) \
419     macro(NewGeneratorFunction, NodeResultJS) \
420     macro(NewAsyncGeneratorFunction, NodeResultJS) \
421     macro(NewAsyncFunction, NodeResultJS) \
422     \
423     /* Block terminals. */\
424     macro(Jump, NodeMustGenerate) \
425     macro(Branch, NodeMustGenerate) \
426     macro(Switch, NodeMustGenerate) \
427     macro(EntrySwitch, NodeMustGenerate) \
428     macro(Return, NodeMustGenerate) \
429     macro(TailCall, NodeMustGenerate | NodeHasVarArgs) \
430     macro(DirectTailCall, NodeMustGenerate | NodeHasVarArgs) \
431     macro(TailCallVarargs, NodeMustGenerate) \
432     macro(TailCallForwardVarargs, NodeMustGenerate) \
433     macro(Unreachable, NodeMustGenerate) \
</pre>
<hr />
<pre>
481     macro(WeakSetAdd, NodeMustGenerate) \
482     macro(WeakMapSet, NodeMustGenerate | NodeHasVarArgs) \
483     macro(ExtractValueFromWeakMapGet, NodeResultJS) \
484     \
485     macro(StringValueOf, NodeMustGenerate | NodeResultJS) \
486     macro(StringSlice, NodeResultJS) \
487     macro(ToLowerCase, NodeResultJS) \
488     /* Nodes for DOM JIT */\
489     macro(CallDOMGetter, NodeResultJS | NodeMustGenerate) \
490     macro(CallDOM, NodeResultJS | NodeMustGenerate) \
491     /* Metadata node that initializes the state for flushed argument types at an entrypoint in the program. */ \
492     /* Currently, we only use this for the blocks an EntrySwitch branches to at the root of the program. */ \
493     /* This is only used in SSA. */ \
494     macro(InitializeEntrypointArguments, NodeMustGenerate) \
495     \
496     /* Used for $vm performance debugging */ \
497     macro(CPUIntrinsic, NodeResultJS | NodeMustGenerate) \
498     \
499     /* Used to provide feedback to the IC profiler. */ \
500     macro(FilterCallLinkStatus, NodeMustGenerate) \
<span class="line-modified">501     macro(FilterGetByIdStatus, NodeMustGenerate) \</span>
502     macro(FilterInByIdStatus, NodeMustGenerate) \
503     macro(FilterPutByIdStatus, NodeMustGenerate) \
504     /* Data view access */ \
505     macro(DataViewGetInt, NodeMustGenerate | NodeResultJS) /* The gets are must generate for now because they do bounds checks */ \
506     macro(DataViewGetFloat, NodeMustGenerate | NodeResultDouble) \
507     macro(DataViewSet, NodeMustGenerate | NodeMustGenerate | NodeHasVarArgs) \



508 
509 
510 // This enum generates a monotonically increasing id for all Node types,
511 // and is used by the subsequent enum to fill out the id (as accessed via the NodeIdMask).
512 enum NodeType {
513 #define DFG_OP_ENUM(opcode, flags) opcode,
514     FOR_EACH_DFG_OP(DFG_OP_ENUM)
515 #undef DFG_OP_ENUM
516     LastNodeType
517 };
518 
519 // Specifies the default flags for each node.
520 inline NodeFlags defaultFlags(NodeType op)
521 {
522     switch (op) {
523 #define DFG_OP_ENUM(opcode, flags) case opcode: return flags;
524     FOR_EACH_DFG_OP(DFG_OP_ENUM)
525 #undef DFG_OP_ENUM
526     default:
527         RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
531 
532 inline bool isAtomicsIntrinsic(NodeType op)
533 {
534     switch (op) {
535     case AtomicsAdd:
536     case AtomicsAnd:
537     case AtomicsCompareExchange:
538     case AtomicsExchange:
539     case AtomicsLoad:
540     case AtomicsOr:
541     case AtomicsStore:
542     case AtomicsSub:
543     case AtomicsXor:
544     case AtomicsIsLockFree:
545         return true;
546     default:
547         return false;
548     }
549 }
550 
<span class="line-modified">551 static const unsigned maxNumExtraAtomicsArgs = 2;</span>
552 
553 inline unsigned numExtraAtomicsArgs(NodeType op)
554 {
555     switch (op) {
556     case AtomicsLoad:
557         return 0;
558     case AtomicsAdd:
559     case AtomicsAnd:
560     case AtomicsExchange:
561     case AtomicsOr:
562     case AtomicsStore:
563     case AtomicsSub:
564     case AtomicsXor:
565         return 1;
566     case AtomicsCompareExchange:
567         return 2;
568     default:
569         RELEASE_ASSERT_NOT_REACHED();
570         return 0;
571     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 36     /* A constant in the CodeBlock&#39;s constant pool. */\
 37     macro(JSConstant, NodeResultJS) \
 38     \
 39     /* Constants with specific representations. */\
 40     macro(DoubleConstant, NodeResultDouble) \
 41     macro(Int52Constant, NodeResultInt52) \
 42     \
 43     /* Lazy JSValue constant. We don&#39;t know the JSValue bits of it yet. */\
 44     macro(LazyJSConstant, NodeResultJS) \
 45     \
 46     /* Marker to indicate that an operation was optimized entirely and all that is left */\
 47     /* is to make one node alias another. CSE will later usually eliminate this node, */\
 48     /* though it may choose not to if it would corrupt predictions (very rare). */\
 49     macro(Identity, NodeResultJS) \
 50     /* Used for debugging to force a profile to appear as anything we want. */ \
 51     macro(IdentityWithProfile, NodeResultJS | NodeMustGenerate) \
 52     \
 53     /* Nodes for handling functions (both as call and as construct). */\
 54     macro(ToThis, NodeResultJS) \
 55     macro(CreateThis, NodeResultJS) /* Note this is not MustGenerate since we&#39;re returning it anyway. */ \
<span class="line-added"> 56     macro(CreatePromise, NodeResultJS | NodeMustGenerate) \</span>
<span class="line-added"> 57     macro(CreateGenerator, NodeResultJS | NodeMustGenerate) \</span>
<span class="line-added"> 58     macro(CreateAsyncGenerator, NodeResultJS | NodeMustGenerate) \</span>
 59     macro(GetCallee, NodeResultJS) \
 60     macro(SetCallee, NodeMustGenerate) \
 61     macro(GetArgumentCountIncludingThis, NodeResultInt32) \
 62     macro(SetArgumentCountIncludingThis, NodeMustGenerate) \
 63     \
 64     /* Nodes for local variable access. These nodes are linked together using Phi nodes. */\
 65     /* Any two nodes that are part of the same Phi graph will share the same */\
 66     /* VariableAccessData, and thus will share predictions. FIXME: We should come up with */\
 67     /* better names for a lot of these. https://bugs.webkit.org/show_bug.cgi?id=137307. */\
 68     /* Note that GetLocal is MustGenerate because it&#39;s our only way of knowing that some other */\
 69     /* basic block might have read a local variable in bytecode. We only remove GetLocals if it */\
 70     /* is redundant because of an earlier GetLocal or SetLocal in the same block. We could make */\
 71     /* these not MustGenerate and use a more sophisticated analysis to insert PhantomLocals in */\
 72     /* the same way that we insert Phantoms. That&#39;s hard and probably not profitable. See */\
 73     /* https://bugs.webkit.org/show_bug.cgi?id=144086 */\
 74     macro(GetLocal, NodeResultJS | NodeMustGenerate) \
 75     macro(SetLocal, 0) \
 76     \
<span class="line-added"> 77     /* These are used in SSA form to represent to track */\</span>
 78     macro(PutStack, NodeMustGenerate) \
 79     macro(KillStack, NodeMustGenerate) \
 80     macro(GetStack, NodeResultJS) \
 81     \
 82     macro(MovHint, NodeMustGenerate) \
 83     macro(ZombieHint, NodeMustGenerate) \
 84     macro(ExitOK, NodeMustGenerate) /* Indicates that exit state is intact. */ \
 85     macro(Phantom, NodeMustGenerate) \
 86     macro(Check, NodeMustGenerate) /* Used if we want just a type check but not liveness. Non-checking uses will be removed. */\
 87     macro(CheckVarargs, NodeMustGenerate | NodeHasVarArgs) /* Used if we want just a type check but not liveness. Non-checking uses will be removed. */\
 88     macro(Upsilon, 0) \
 89     macro(Phi, 0) \
 90     macro(Flush, NodeMustGenerate) \
 91     macro(PhantomLocal, NodeMustGenerate) \
 92     \
 93     /* Hint that this is where bytecode thinks is a good place to OSR. Note that this */\
 94     /* will exist even in inlined loops. This has no execution semantics but it must */\
 95     /* survive all DCE. We treat this as being a can-exit because tier-up to FTL may */\
 96     /* want all state. */\
 97     macro(LoopHint, NodeMustGenerate) \
</pre>
<hr />
<pre>
110     /* Marker for an argument being set at the prologue of a function. The argument is guaranteed to be set after this node. */\
111     macro(SetArgumentDefinitely, 0) \
112     /* A marker like the above that we use to track variable liveness and OSR exit state. However, it&#39;s not guaranteed to be set. To verify it was set, you&#39;d need to check the actual argument length. We use this for varargs when we&#39;re unsure how many argument may actually end up on the stack. */\
113     macro(SetArgumentMaybe, 0) \
114     \
115     /* Marker of location in the IR where we may possibly perform jump replacement to */\
116     /* invalidate this code block. */\
117     macro(InvalidationPoint, NodeMustGenerate) \
118     \
119     /* Nodes for bitwise operations. */\
120     macro(ValueBitNot, NodeResultJS | NodeMustGenerate) \
121     macro(ArithBitNot, NodeResultInt32) \
122     macro(ValueBitAnd, NodeResultJS | NodeMustGenerate) \
123     macro(ArithBitAnd, NodeResultInt32) \
124     macro(ValueBitOr, NodeResultJS | NodeMustGenerate) \
125     macro(ArithBitOr, NodeResultInt32) \
126     macro(ValueBitXor, NodeResultJS | NodeMustGenerate) \
127     macro(ArithBitXor, NodeResultInt32) \
128     macro(ArithBitLShift, NodeResultInt32) \
129     macro(ValueBitLShift, NodeResultJS | NodeMustGenerate) \
<span class="line-modified">130     macro(ArithBitRShift, NodeResultInt32) \</span>
<span class="line-added">131     macro(ValueBitRShift, NodeResultJS | NodeMustGenerate) \</span>
132     macro(BitURShift, NodeResultInt32) \
133     /* Bitwise operators call ToInt32 on their operands. */\
134     macro(ValueToInt32, NodeResultInt32) \
135     /* Used to box the result of URShift nodes (result has range 0..2^32-1). */\
136     macro(UInt32ToNumber, NodeResultNumber) \
137     /* Converts booleans to numbers but passes everything else through. */\
138     macro(BooleanToNumber, NodeResultJS) \
139     \
140     /* Attempt to truncate a double to int32; this will exit if it can&#39;t do it. */\
141     macro(DoubleAsInt32, NodeResultInt32) \
142     \
143     /* Change the representation of a value. */\
144     macro(DoubleRep, NodeResultDouble) \
145     macro(Int52Rep, NodeResultInt52) \
146     macro(ValueRep, NodeResultJS) \
147     \
148     /* Bogus type asserting node. Useful for testing, disappears during Fixup. */\
149     macro(FiatInt52, NodeResultJS) \
150     \
151     /* Nodes for arithmetic operations. Note that if they do checks other than just type checks, */\
</pre>
<hr />
<pre>
159     macro(ArithClz32, NodeResultInt32 | NodeMustGenerate) \
160     macro(ArithSub, NodeResultNumber | NodeMustGenerate) \
161     macro(ArithNegate, NodeResultNumber | NodeMustGenerate) \
162     macro(ArithMul, NodeResultNumber | NodeMustGenerate) \
163     macro(ArithIMul, NodeResultInt32) \
164     macro(ArithDiv, NodeResultNumber | NodeMustGenerate) \
165     macro(ArithMod, NodeResultNumber | NodeMustGenerate) \
166     macro(ArithAbs, NodeResultNumber | NodeMustGenerate) \
167     macro(ArithMin, NodeResultNumber) \
168     macro(ArithMax, NodeResultNumber) \
169     macro(ArithFRound, NodeResultDouble | NodeMustGenerate) \
170     macro(ArithPow, NodeResultDouble) \
171     macro(ArithRandom, NodeResultDouble | NodeMustGenerate) \
172     macro(ArithRound, NodeResultNumber | NodeMustGenerate) \
173     macro(ArithFloor, NodeResultNumber | NodeMustGenerate) \
174     macro(ArithCeil, NodeResultNumber | NodeMustGenerate) \
175     macro(ArithTrunc, NodeResultNumber | NodeMustGenerate) \
176     macro(ArithSqrt, NodeResultDouble | NodeMustGenerate) \
177     macro(ArithUnary, NodeResultDouble | NodeMustGenerate) \
178     \
<span class="line-modified">179     /* BigInt is a valid operand for these three operations */\</span>
<span class="line-added">180     /* Inc and Dec don&#39;t update their operand in-place, they are typically combined with some form of SetLocal */\</span>
<span class="line-added">181     macro(Inc, NodeResultJS | NodeMustGenerate) \</span>
<span class="line-added">182     macro(Dec, NodeResultJS | NodeMustGenerate) \</span>
183     macro(ValueNegate, NodeResultJS | NodeMustGenerate) \
184     \
185     /* Add of values may either be arithmetic, or result in string concatenation. */\
186     macro(ValueAdd, NodeResultJS | NodeMustGenerate) \
187     \
188     macro(ValueSub, NodeResultJS | NodeMustGenerate) \
189     macro(ValueMul, NodeResultJS | NodeMustGenerate) \
190     macro(ValueDiv, NodeResultJS | NodeMustGenerate) \
191     macro(ValuePow, NodeResultJS | NodeMustGenerate) \
192     macro(ValueMod, NodeResultJS | NodeMustGenerate) \
193     \
194     /* Add of values that always convers its inputs to strings. May have two or three kids. */\
195     macro(StrCat, NodeResultJS | NodeMustGenerate) \
196     \
197     /* Property access. */\
198     /* PutByValAlias indicates a &#39;put&#39; aliases a prior write to the same property. */\
199     /* Since a put to &#39;length&#39; may invalidate optimizations here, */\
200     /* this must be the directly subsequent property put. Note that PutByVal */\
201     /* opcodes use VarArgs beause they may have up to 4 children. */\
202     macro(GetByVal, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
203     macro(GetByValWithThis, NodeResultJS | NodeMustGenerate) \
204     macro(GetMyArgumentByVal, NodeResultJS | NodeMustGenerate) \
205     macro(GetMyArgumentByValOutOfBounds, NodeResultJS | NodeMustGenerate) \
<span class="line-added">206     macro(VarargsLength, NodeMustGenerate | NodeResultInt32) \</span>
207     macro(LoadVarargs, NodeMustGenerate) \
208     macro(ForwardVarargs, NodeMustGenerate) \
209     macro(PutByValDirect, NodeMustGenerate | NodeHasVarArgs) \
210     macro(PutByVal, NodeMustGenerate | NodeHasVarArgs) \
211     macro(PutByValAlias, NodeMustGenerate | NodeHasVarArgs) \
212     macro(TryGetById, NodeResultJS) \
213     macro(GetById, NodeResultJS | NodeMustGenerate) \
214     macro(GetByIdFlush, NodeResultJS | NodeMustGenerate) \
215     macro(GetByIdWithThis, NodeResultJS | NodeMustGenerate) \
216     macro(GetByIdDirect, NodeResultJS | NodeMustGenerate) \
217     macro(GetByIdDirectFlush, NodeResultJS | NodeMustGenerate) \
218     macro(PutById, NodeMustGenerate) \
219     macro(PutByIdFlush, NodeMustGenerate) \
220     macro(PutByIdDirect, NodeMustGenerate) \
221     macro(PutByIdWithThis, NodeMustGenerate) \
222     macro(PutByValWithThis, NodeMustGenerate | NodeHasVarArgs) \
223     macro(PutGetterById, NodeMustGenerate) \
224     macro(PutSetterById, NodeMustGenerate) \
225     macro(PutGetterSetterById, NodeMustGenerate) \
226     macro(PutGetterByVal, NodeMustGenerate) \
227     macro(PutSetterByVal, NodeMustGenerate) \
228     macro(DefineDataProperty, NodeMustGenerate | NodeHasVarArgs) \
229     macro(DefineAccessorProperty, NodeMustGenerate | NodeHasVarArgs) \
230     macro(DeleteById, NodeResultBoolean | NodeMustGenerate) \
231     macro(DeleteByVal, NodeResultBoolean | NodeMustGenerate) \
232     macro(CheckStructure, NodeMustGenerate) \
233     macro(CheckStructureOrEmpty, NodeMustGenerate) \
234     macro(GetExecutable, NodeResultJS) \
235     macro(PutStructure, NodeMustGenerate) \
236     macro(AllocatePropertyStorage, NodeMustGenerate | NodeResultStorage) \
237     macro(ReallocatePropertyStorage, NodeMustGenerate | NodeResultStorage) \
238     macro(GetButterfly, NodeResultStorage) \
239     macro(NukeStructureAndSetButterfly, NodeMustGenerate) \
240     macro(CheckArray, NodeMustGenerate) \
<span class="line-added">241     macro(CheckArrayOrEmpty, NodeMustGenerate) \</span>
<span class="line-added">242     /* This checks if the edge is a typed array and if it is neutered. */ \</span>
<span class="line-added">243     macro(CheckNeutered, NodeMustGenerate) \</span>
244     macro(Arrayify, NodeMustGenerate) \
245     macro(ArrayifyToStructure, NodeMustGenerate) \
246     macro(GetIndexedPropertyStorage, NodeResultStorage) \
247     macro(ConstantStoragePointer, NodeResultStorage) \
248     macro(GetGetter, NodeResultJS) \
249     macro(GetSetter, NodeResultJS) \
250     macro(GetByOffset, NodeResultJS) \
251     macro(GetGetterSetterByOffset, NodeResultJS) \
252     macro(MultiGetByOffset, NodeResultJS | NodeMustGenerate) \
253     macro(PutByOffset, NodeMustGenerate) \
254     macro(MultiPutByOffset, NodeMustGenerate) \
255     macro(GetArrayLength, NodeResultInt32) \
256     macro(GetVectorLength, NodeResultInt32) \
257     macro(GetTypedArrayByteOffset, NodeResultInt32) \
258     macro(GetScope, NodeResultJS) \
259     macro(SkipScope, NodeResultJS) \
260     macro(ResolveScope, NodeResultJS | NodeMustGenerate) \
261     macro(ResolveScopeForHoistingFuncDeclInEval, NodeResultJS | NodeMustGenerate) \
262     macro(GetGlobalObject, NodeResultJS) \
263     macro(GetGlobalThis, NodeResultJS) \
264     macro(GetClosureVar, NodeResultJS) \
265     macro(PutClosureVar, NodeMustGenerate) \
266     macro(GetGlobalVar, NodeResultJS) \
267     macro(GetGlobalLexicalVariable, NodeResultJS) \
268     macro(PutGlobalVariable, NodeMustGenerate) \
269     macro(GetDynamicVar, NodeResultJS | NodeMustGenerate) \
270     macro(PutDynamicVar, NodeMustGenerate) \
271     macro(NotifyWrite, NodeMustGenerate) \
272     macro(GetRegExpObjectLastIndex, NodeResultJS) \
273     macro(SetRegExpObjectLastIndex, NodeMustGenerate) \
274     macro(RecordRegExpCachedResult, NodeMustGenerate | NodeHasVarArgs) \
275     macro(CheckCell, NodeMustGenerate) \
276     macro(CheckNotEmpty, NodeMustGenerate) \
277     macro(AssertNotEmpty, NodeMustGenerate) \
278     macro(CheckBadCell, NodeMustGenerate) \
279     macro(CheckInBounds, NodeMustGenerate | NodeResultJS) \
<span class="line-modified">280     macro(CheckIdent, NodeMustGenerate) \</span>
281     macro(CheckTypeInfoFlags, NodeMustGenerate) /* Takes an OpInfo with the flags you want to test are set */\
282     macro(CheckSubClass, NodeMustGenerate) \
283     macro(ParseInt, NodeMustGenerate | NodeResultJS) \
284     macro(GetPrototypeOf, NodeMustGenerate | NodeResultJS) \
285     macro(ObjectCreate, NodeMustGenerate | NodeResultJS) \
286     macro(ObjectKeys, NodeMustGenerate | NodeResultJS) \
287     \
288     /* Atomics object functions. */\
289     macro(AtomicsAdd, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
290     macro(AtomicsAnd, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
291     macro(AtomicsCompareExchange, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
292     macro(AtomicsExchange, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
293     macro(AtomicsIsLockFree, NodeResultBoolean) \
294     macro(AtomicsLoad, NodeResultJS | NodeMustGenerate) \
295     macro(AtomicsOr, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
296     macro(AtomicsStore, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
297     macro(AtomicsSub, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
298     macro(AtomicsXor, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
299     \
300     /* Optimizations for array mutation. */\
301     macro(ArrayPush, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
302     macro(ArrayPop, NodeResultJS | NodeMustGenerate) \
303     macro(ArraySlice, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
304     macro(ArrayIndexOf, NodeResultInt32 | NodeHasVarArgs) \
305     \
306     /* Optimizations for regular expression matching. */\
307     macro(RegExpExec, NodeResultJS | NodeMustGenerate) \
308     macro(RegExpExecNonGlobalOrSticky, NodeResultJS) \
309     macro(RegExpTest, NodeResultJS | NodeMustGenerate) \
310     macro(RegExpMatchFast, NodeResultJS | NodeMustGenerate) \
311     macro(RegExpMatchFastGlobal, NodeResultJS) \
312     macro(StringReplace, NodeResultJS | NodeMustGenerate) \
313     macro(StringReplaceRegExp, NodeResultJS | NodeMustGenerate) \
314     \
315     /* Optimizations for string access */ \
316     macro(StringCharCodeAt, NodeResultInt32) \
<span class="line-added">317     macro(StringCodePointAt, NodeResultInt32) \</span>
318     macro(StringCharAt, NodeResultJS) \
319     macro(StringFromCharCode, NodeResultJS | NodeMustGenerate) \
320     \
321     /* Nodes for comparison operations. */\
322     macro(CompareLess, NodeResultBoolean | NodeMustGenerate) \
323     macro(CompareLessEq, NodeResultBoolean | NodeMustGenerate) \
324     macro(CompareGreater, NodeResultBoolean | NodeMustGenerate) \
325     macro(CompareGreaterEq, NodeResultBoolean | NodeMustGenerate) \
326     macro(CompareBelow, NodeResultBoolean) \
327     macro(CompareBelowEq, NodeResultBoolean) \
328     macro(CompareEq, NodeResultBoolean | NodeMustGenerate) \
329     macro(CompareStrictEq, NodeResultBoolean) \
330     macro(CompareEqPtr, NodeResultBoolean) \
331     macro(SameValue, NodeResultBoolean) \
332     \
333     /* Calls. */\
334     macro(Call, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
335     macro(DirectCall, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
336     macro(Construct, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
337     macro(DirectConstruct, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
338     macro(CallVarargs, NodeResultJS | NodeMustGenerate) \
339     macro(CallForwardVarargs, NodeResultJS | NodeMustGenerate) \
340     macro(ConstructVarargs, NodeResultJS | NodeMustGenerate) \
341     macro(ConstructForwardVarargs, NodeResultJS | NodeMustGenerate) \
342     macro(TailCallInlinedCaller, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
343     macro(DirectTailCallInlinedCaller, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
344     macro(TailCallVarargsInlinedCaller, NodeResultJS | NodeMustGenerate) \
345     macro(TailCallForwardVarargsInlinedCaller, NodeResultJS | NodeMustGenerate) \
346     macro(CallEval, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
347     \
348     /* Shadow Chicken */\
349     macro(LogShadowChickenPrologue, NodeMustGenerate) \
350     macro(LogShadowChickenTail, NodeMustGenerate) \
351     \
352     /* Allocations. */\
353     macro(NewObject, NodeResultJS) \
<span class="line-added">354     macro(NewPromise, NodeResultJS) \</span>
<span class="line-added">355     macro(NewGenerator, NodeResultJS) \</span>
<span class="line-added">356     macro(NewAsyncGenerator, NodeResultJS) \</span>
357     macro(NewArray, NodeResultJS | NodeHasVarArgs) \
358     macro(NewArrayWithSpread, NodeResultJS | NodeHasVarArgs) \
359     macro(NewArrayWithSize, NodeResultJS | NodeMustGenerate) \
360     macro(NewArrayBuffer, NodeResultJS) \
<span class="line-added">361     macro(NewArrayIterator, NodeResultJS) \</span>
362     macro(NewTypedArray, NodeResultJS | NodeMustGenerate) \
363     macro(NewRegexp, NodeResultJS) \
364     macro(NewSymbol, NodeResultJS) \
365     macro(NewStringObject, NodeResultJS) \
366     /* Rest Parameter */\
367     macro(GetRestLength, NodeResultInt32) \
368     macro(CreateRest, NodeResultJS | NodeMustGenerate) \
369     \
370     macro(Spread, NodeResultJS | NodeMustGenerate) \
371     /* Support for allocation sinking. */\
372     macro(PhantomNewObject, NodeResultJS | NodeMustGenerate) \
373     macro(PutHint, NodeMustGenerate) \
374     macro(CheckStructureImmediate, NodeMustGenerate) \
375     macro(MaterializeNewObject, NodeResultJS | NodeHasVarArgs) \
376     macro(PhantomNewFunction, NodeResultJS | NodeMustGenerate) \
377     macro(PhantomNewGeneratorFunction, NodeResultJS | NodeMustGenerate) \
378     macro(PhantomNewAsyncFunction, NodeResultJS | NodeMustGenerate) \
379     macro(PhantomNewAsyncGeneratorFunction, NodeResultJS | NodeMustGenerate) \
<span class="line-added">380     macro(PhantomNewArrayIterator, NodeResultJS | NodeMustGenerate) \</span>
<span class="line-added">381     macro(MaterializeNewInternalFieldObject, NodeResultJS | NodeHasVarArgs) \</span>
382     macro(PhantomCreateActivation, NodeResultJS | NodeMustGenerate) \
383     macro(MaterializeCreateActivation, NodeResultJS | NodeHasVarArgs) \
384     macro(PhantomNewRegexp, NodeResultJS | NodeMustGenerate) \
385     \
386     /* Nodes for misc operations. */\
387     macro(OverridesHasInstance, NodeMustGenerate | NodeResultBoolean) \
388     macro(InstanceOf, NodeMustGenerate | NodeResultBoolean) \
389     macro(InstanceOfCustom, NodeMustGenerate | NodeResultBoolean) \
390     macro(MatchStructure, NodeMustGenerate | NodeResultBoolean) \
391     \
392     macro(IsCellWithType, NodeResultBoolean) \
393     macro(IsEmpty, NodeResultBoolean) \
394     macro(IsUndefined, NodeResultBoolean) \
395     macro(IsUndefinedOrNull, NodeResultBoolean) \
396     macro(IsBoolean, NodeResultBoolean) \
397     macro(IsNumber, NodeResultBoolean) \
398     macro(NumberIsInteger, NodeResultBoolean) \
399     macro(IsObject, NodeResultBoolean) \
400     macro(IsObjectOrNull, NodeResultBoolean) \
401     macro(IsFunction, NodeResultBoolean) \
402     macro(IsTypedArrayView, NodeResultBoolean) \
403     macro(TypeOf, NodeResultJS) \
404     macro(LogicalNot, NodeResultBoolean) \
405     macro(ToPrimitive, NodeResultJS | NodeMustGenerate) \
<span class="line-added">406     macro(ToPropertyKey, NodeResultJS | NodeMustGenerate) \</span>
407     macro(ToString, NodeResultJS | NodeMustGenerate) \
408     macro(ToNumber, NodeResultJS | NodeMustGenerate) \
<span class="line-added">409     macro(ToNumeric, NodeResultJS | NodeMustGenerate) \</span>
410     macro(ToObject, NodeResultJS | NodeMustGenerate) \
411     macro(CallObjectConstructor, NodeResultJS) \
412     macro(CallStringConstructor, NodeResultJS | NodeMustGenerate) \
413     macro(NumberToStringWithRadix, NodeResultJS | NodeMustGenerate) \
414     macro(NumberToStringWithValidRadixConstant, NodeResultJS) \
415     macro(MakeRope, NodeResultJS) \
416     macro(InByVal, NodeResultBoolean | NodeMustGenerate) \
417     macro(InById, NodeResultBoolean | NodeMustGenerate) \
418     macro(ProfileType, NodeMustGenerate) \
419     macro(ProfileControlFlow, NodeMustGenerate) \
420     macro(SetFunctionName, NodeMustGenerate) \
421     macro(HasOwnProperty, NodeResultBoolean) \
422     \
<span class="line-added">423     macro(GetInternalField, NodeResultJS) \</span>
<span class="line-added">424     macro(PutInternalField, NodeMustGenerate) \</span>
<span class="line-added">425     \</span>
426     macro(CreateActivation, NodeResultJS) \
427     macro(PushWithScope, NodeResultJS | NodeMustGenerate) \
428     \
429     macro(CreateDirectArguments, NodeResultJS) \
430     macro(PhantomDirectArguments, NodeResultJS | NodeMustGenerate) \
431     macro(PhantomCreateRest, NodeResultJS | NodeMustGenerate) \
432     macro(PhantomSpread, NodeResultJS | NodeMustGenerate) \
433     macro(PhantomNewArrayWithSpread, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
434     macro(PhantomNewArrayBuffer, NodeResultJS | NodeMustGenerate) \
435     macro(CreateScopedArguments, NodeResultJS) \
436     macro(CreateClonedArguments, NodeResultJS) \
437     macro(PhantomClonedArguments, NodeResultJS | NodeMustGenerate) \
<span class="line-added">438     macro(CreateArgumentsButterfly, NodeResultJS) \</span>
439     macro(GetFromArguments, NodeResultJS) \
440     macro(PutToArguments, NodeMustGenerate) \
441     macro(GetArgument, NodeResultJS) \
442     \
443     macro(NewFunction, NodeResultJS) \
444     macro(NewGeneratorFunction, NodeResultJS) \
445     macro(NewAsyncGeneratorFunction, NodeResultJS) \
446     macro(NewAsyncFunction, NodeResultJS) \
447     \
448     /* Block terminals. */\
449     macro(Jump, NodeMustGenerate) \
450     macro(Branch, NodeMustGenerate) \
451     macro(Switch, NodeMustGenerate) \
452     macro(EntrySwitch, NodeMustGenerate) \
453     macro(Return, NodeMustGenerate) \
454     macro(TailCall, NodeMustGenerate | NodeHasVarArgs) \
455     macro(DirectTailCall, NodeMustGenerate | NodeHasVarArgs) \
456     macro(TailCallVarargs, NodeMustGenerate) \
457     macro(TailCallForwardVarargs, NodeMustGenerate) \
458     macro(Unreachable, NodeMustGenerate) \
</pre>
<hr />
<pre>
506     macro(WeakSetAdd, NodeMustGenerate) \
507     macro(WeakMapSet, NodeMustGenerate | NodeHasVarArgs) \
508     macro(ExtractValueFromWeakMapGet, NodeResultJS) \
509     \
510     macro(StringValueOf, NodeMustGenerate | NodeResultJS) \
511     macro(StringSlice, NodeResultJS) \
512     macro(ToLowerCase, NodeResultJS) \
513     /* Nodes for DOM JIT */\
514     macro(CallDOMGetter, NodeResultJS | NodeMustGenerate) \
515     macro(CallDOM, NodeResultJS | NodeMustGenerate) \
516     /* Metadata node that initializes the state for flushed argument types at an entrypoint in the program. */ \
517     /* Currently, we only use this for the blocks an EntrySwitch branches to at the root of the program. */ \
518     /* This is only used in SSA. */ \
519     macro(InitializeEntrypointArguments, NodeMustGenerate) \
520     \
521     /* Used for $vm performance debugging */ \
522     macro(CPUIntrinsic, NodeResultJS | NodeMustGenerate) \
523     \
524     /* Used to provide feedback to the IC profiler. */ \
525     macro(FilterCallLinkStatus, NodeMustGenerate) \
<span class="line-modified">526     macro(FilterGetByStatus, NodeMustGenerate) \</span>
527     macro(FilterInByIdStatus, NodeMustGenerate) \
528     macro(FilterPutByIdStatus, NodeMustGenerate) \
529     /* Data view access */ \
530     macro(DataViewGetInt, NodeMustGenerate | NodeResultJS) /* The gets are must generate for now because they do bounds checks */ \
531     macro(DataViewGetFloat, NodeMustGenerate | NodeResultDouble) \
532     macro(DataViewSet, NodeMustGenerate | NodeMustGenerate | NodeHasVarArgs) \
<span class="line-added">533     /* Date access */ \</span>
<span class="line-added">534     macro(DateGetInt32OrNaN, NodeResultJS) \</span>
<span class="line-added">535     macro(DateGetTime, NodeResultDouble) \</span>
536 
537 
538 // This enum generates a monotonically increasing id for all Node types,
539 // and is used by the subsequent enum to fill out the id (as accessed via the NodeIdMask).
540 enum NodeType {
541 #define DFG_OP_ENUM(opcode, flags) opcode,
542     FOR_EACH_DFG_OP(DFG_OP_ENUM)
543 #undef DFG_OP_ENUM
544     LastNodeType
545 };
546 
547 // Specifies the default flags for each node.
548 inline NodeFlags defaultFlags(NodeType op)
549 {
550     switch (op) {
551 #define DFG_OP_ENUM(opcode, flags) case opcode: return flags;
552     FOR_EACH_DFG_OP(DFG_OP_ENUM)
553 #undef DFG_OP_ENUM
554     default:
555         RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
559 
560 inline bool isAtomicsIntrinsic(NodeType op)
561 {
562     switch (op) {
563     case AtomicsAdd:
564     case AtomicsAnd:
565     case AtomicsCompareExchange:
566     case AtomicsExchange:
567     case AtomicsLoad:
568     case AtomicsOr:
569     case AtomicsStore:
570     case AtomicsSub:
571     case AtomicsXor:
572     case AtomicsIsLockFree:
573         return true;
574     default:
575         return false;
576     }
577 }
578 
<span class="line-modified">579 static constexpr unsigned maxNumExtraAtomicsArgs = 2;</span>
580 
581 inline unsigned numExtraAtomicsArgs(NodeType op)
582 {
583     switch (op) {
584     case AtomicsLoad:
585         return 0;
586     case AtomicsAdd:
587     case AtomicsAnd:
588     case AtomicsExchange:
589     case AtomicsOr:
590     case AtomicsStore:
591     case AtomicsSub:
592     case AtomicsXor:
593         return 1;
594     case AtomicsCompareExchange:
595         return 2;
596     default:
597         RELEASE_ASSERT_NOT_REACHED();
598         return 0;
599     }
</pre>
</td>
</tr>
</table>
<center><a href="DFGNodeFlowProjection.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOSRAvailabilityAnalysisPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLAbstractHeapRepository.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FTLAbstractHeapRepository.h&quot;
 28 
 29 #if ENABLE(FTL_JIT)
 30 
 31 #include &quot;B3CCallValue.h&quot;
 32 #include &quot;B3FenceValue.h&quot;
 33 #include &quot;B3MemoryValue.h&quot;
 34 #include &quot;B3PatchpointValue.h&quot;
 35 #include &quot;B3ValueInlines.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 36 #include &quot;DateInstance.h&quot;</span>
 37 #include &quot;DirectArguments.h&quot;
 38 #include &quot;FTLState.h&quot;
 39 #include &quot;GetterSetter.h&quot;
 40 #include &quot;JSPropertyNameEnumerator.h&quot;
 41 #include &quot;JSScope.h&quot;
 42 #include &quot;JSCInlines.h&quot;
 43 #include &quot;RegExpObject.h&quot;
 44 #include &quot;ScopedArguments.h&quot;
 45 #include &quot;ScopedArgumentsTable.h&quot;
 46 #include &quot;ShadowChicken.h&quot;
 47 
 48 namespace JSC { namespace FTL {
 49 
 50 AbstractHeapRepository::AbstractHeapRepository()
 51     : root(nullptr, &quot;jscRoot&quot;)
 52 
 53 #define ABSTRACT_HEAP_INITIALIZATION(name) , name(&amp;root, #name)
 54     FOR_EACH_ABSTRACT_HEAP(ABSTRACT_HEAP_INITIALIZATION)
 55 #undef ABSTRACT_HEAP_INITIALIZATION
 56 
 57 #define ABSTRACT_FIELD_INITIALIZATION(name, offset) , name(&amp;root, #name, offset)
 58     FOR_EACH_ABSTRACT_FIELD(ABSTRACT_FIELD_INITIALIZATION)
 59 #undef ABSTRACT_FIELD_INITIALIZATION
 60 
 61     , JSCell_freeListNext(JSCell_header)
 62     , ArrayStorage_publicLength(Butterfly_publicLength)
 63     , ArrayStorage_vectorLength(Butterfly_vectorLength)
 64 
 65 #define INDEXED_ABSTRACT_HEAP_INITIALIZATION(name, offset, size) , name(&amp;root, #name, offset, size)
 66     FOR_EACH_INDEXED_ABSTRACT_HEAP(INDEXED_ABSTRACT_HEAP_INITIALIZATION)
 67 #undef INDEXED_ABSTRACT_HEAP_INITIALIZATION
 68 
 69 #define NUMBERED_ABSTRACT_HEAP_INITIALIZATION(name) , name(&amp;root, #name)
 70     FOR_EACH_NUMBERED_ABSTRACT_HEAP(NUMBERED_ABSTRACT_HEAP_INITIALIZATION)
 71 #undef NUMBERED_ABSTRACT_HEAP_INITIALIZATION
 72 
 73     , JSString_value(JSRopeString_fiber0)
 74 
 75     , absolute(&amp;root, &quot;absolute&quot;)
 76 {
 77     // Make sure that our explicit assumptions about the StructureIDBlob match reality.
 78     RELEASE_ASSERT(!(JSCell_indexingTypeAndMisc.offset() &amp; (sizeof(int32_t) - 1)));
 79     RELEASE_ASSERT(JSCell_indexingTypeAndMisc.offset() + 1 == JSCell_typeInfoType.offset());
 80     RELEASE_ASSERT(JSCell_indexingTypeAndMisc.offset() + 2 == JSCell_typeInfoFlags.offset());
 81     RELEASE_ASSERT(JSCell_indexingTypeAndMisc.offset() + 3 == JSCell_cellState.offset());
 82 
 83     JSCell_structureID.changeParent(&amp;JSCell_header);
 84     JSCell_usefulBytes.changeParent(&amp;JSCell_header);
 85     JSCell_indexingTypeAndMisc.changeParent(&amp;JSCell_usefulBytes);
 86     JSCell_typeInfoType.changeParent(&amp;JSCell_usefulBytes);
 87     JSCell_typeInfoFlags.changeParent(&amp;JSCell_usefulBytes);
 88     JSCell_cellState.changeParent(&amp;JSCell_usefulBytes);
 89     JSRopeString_flags.changeParent(&amp;JSRopeString_fiber0);
 90     JSRopeString_length.changeParent(&amp;JSRopeString_fiber1);
 91 
 92     RELEASE_ASSERT(!JSCell_freeListNext.offset());
 93 }
 94 
 95 AbstractHeapRepository::~AbstractHeapRepository()
 96 {
 97 }
 98 
 99 void AbstractHeapRepository::decorateMemory(const AbstractHeap* heap, B3::Value* value)
100 {
101     m_heapForMemory.append(HeapForValue(heap, value));
102 }
103 
104 void AbstractHeapRepository::decorateCCallRead(const AbstractHeap* heap, B3::Value* value)
105 {
106     m_heapForCCallRead.append(HeapForValue(heap, value));
107 }
108 
109 void AbstractHeapRepository::decorateCCallWrite(const AbstractHeap* heap, B3::Value* value)
110 {
111     m_heapForCCallWrite.append(HeapForValue(heap, value));
112 }
113 
114 void AbstractHeapRepository::decoratePatchpointRead(const AbstractHeap* heap, B3::Value* value)
115 {
116     m_heapForPatchpointRead.append(HeapForValue(heap, value));
117 }
118 
119 void AbstractHeapRepository::decoratePatchpointWrite(const AbstractHeap* heap, B3::Value* value)
120 {
121     m_heapForPatchpointWrite.append(HeapForValue(heap, value));
122 }
123 
124 void AbstractHeapRepository::decorateFenceRead(const AbstractHeap* heap, B3::Value* value)
125 {
126     m_heapForFenceRead.append(HeapForValue(heap, value));
127 }
128 
129 void AbstractHeapRepository::decorateFenceWrite(const AbstractHeap* heap, B3::Value* value)
130 {
131     m_heapForFenceWrite.append(HeapForValue(heap, value));
132 }
133 
134 void AbstractHeapRepository::decorateFencedAccess(const AbstractHeap* heap, B3::Value* value)
135 {
136     m_heapForFencedAccess.append(HeapForValue(heap, value));
137 }
138 
139 void AbstractHeapRepository::computeRangesAndDecorateInstructions()
140 {
141     using namespace B3;
142     root.compute();
143 
144     if (verboseCompilationEnabled()) {
145         dataLog(&quot;Abstract Heap Repository:\n&quot;);
146         root.deepDump(WTF::dataFile());
147     }
148 
149     auto rangeFor = [&amp;] (const AbstractHeap* heap) -&gt; HeapRange {
150         if (heap)
151             return heap-&gt;range();
152         return HeapRange();
153     };
154 
155     for (HeapForValue entry : m_heapForMemory)
156         entry.value-&gt;as&lt;MemoryValue&gt;()-&gt;setRange(rangeFor(entry.heap));
157     for (HeapForValue entry : m_heapForCCallRead)
158         entry.value-&gt;as&lt;CCallValue&gt;()-&gt;effects.reads = rangeFor(entry.heap);
159     for (HeapForValue entry : m_heapForCCallWrite)
160         entry.value-&gt;as&lt;CCallValue&gt;()-&gt;effects.writes = rangeFor(entry.heap);
161     for (HeapForValue entry : m_heapForPatchpointRead)
162         entry.value-&gt;as&lt;PatchpointValue&gt;()-&gt;effects.reads = rangeFor(entry.heap);
163     for (HeapForValue entry : m_heapForPatchpointWrite)
164         entry.value-&gt;as&lt;PatchpointValue&gt;()-&gt;effects.writes = rangeFor(entry.heap);
165     for (HeapForValue entry : m_heapForFenceRead)
166         entry.value-&gt;as&lt;FenceValue&gt;()-&gt;read = rangeFor(entry.heap);
167     for (HeapForValue entry : m_heapForFenceWrite)
168         entry.value-&gt;as&lt;FenceValue&gt;()-&gt;write = rangeFor(entry.heap);
169     for (HeapForValue entry : m_heapForFencedAccess)
170         entry.value-&gt;as&lt;MemoryValue&gt;()-&gt;setFenceRange(rangeFor(entry.heap));
171 }
172 
173 } } // namespace JSC::FTL
174 
175 #endif // ENABLE(FTL_JIT)
176 
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
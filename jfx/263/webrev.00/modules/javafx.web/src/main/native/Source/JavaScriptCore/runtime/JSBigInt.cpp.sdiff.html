<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSAsyncGeneratorFunction.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBigInt.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2017 Caio Lima &lt;ticaiolima@gmail.com&gt;
<span class="line-modified">   3  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.</span>
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  44  * [3] https://golang.org/LICENSE
  45  */
  46 
  47 #include &quot;config.h&quot;
  48 #include &quot;JSBigInt.h&quot;
  49 
  50 #include &quot;BigIntObject.h&quot;
  51 #include &quot;CatchScope.h&quot;
  52 #include &quot;JSCInlines.h&quot;
  53 #include &quot;MathCommon.h&quot;
  54 #include &quot;ParseInt.h&quot;
  55 #include &lt;algorithm&gt;
  56 #include &lt;wtf/MathExtras.h&gt;
  57 
  58 #define STATIC_ASSERT(cond) static_assert(cond, &quot;JSBigInt assumes &quot; #cond)
  59 
  60 namespace JSC {
  61 
  62 const ClassInfo JSBigInt::s_info = { &quot;BigInt&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSBigInt) };
  63 
<span class="line-modified">  64 JSBigInt::JSBigInt(VM&amp; vm, Structure* structure, unsigned length)</span>
  65     : Base(vm, structure)
  66     , m_length(length)

  67 { }
  68 





  69 void JSBigInt::initialize(InitializationType initType)
  70 {
  71     if (initType == InitializationType::WithZero)
  72         memset(dataStorage(), 0, length() * sizeof(Digit));
  73 }
  74 
  75 Structure* JSBigInt::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  76 {
  77     return Structure::create(vm, globalObject, prototype, TypeInfo(BigIntType, StructureFlags), info());
  78 }
  79 
  80 JSBigInt* JSBigInt::createZero(VM&amp; vm)
  81 {
  82     JSBigInt* zeroBigInt = createWithLengthUnchecked(vm, 0);
  83     return zeroBigInt;
  84 }
  85 
<span class="line-modified">  86 inline size_t JSBigInt::allocationSize(unsigned length)</span>
  87 {
<span class="line-modified">  88     size_t sizeWithPadding = WTF::roundUpToMultipleOf&lt;sizeof(size_t)&gt;(sizeof(JSBigInt));</span>
<span class="line-removed">  89     return sizeWithPadding + length * sizeof(Digit);</span>
<span class="line-removed">  90 }</span>
<span class="line-removed">  91 </span>
<span class="line-removed">  92 JSBigInt* JSBigInt::tryCreateWithLength(ExecState* exec, unsigned length)</span>
<span class="line-removed">  93 {</span>
<span class="line-removed">  94     VM&amp; vm = exec-&gt;vm();</span>
  95     auto scope = DECLARE_THROW_SCOPE(vm);
  96 
  97     if (UNLIKELY(length &gt; maxLength)) {
<span class="line-modified">  98         throwOutOfMemoryError(exec, scope);</span>
  99         return nullptr;
 100     }
 101 
 102     scope.release();
 103 
 104     return createWithLengthUnchecked(vm, length);
 105 }
 106 
 107 JSBigInt* JSBigInt::createWithLengthUnchecked(VM&amp; vm, unsigned length)
 108 {
 109     ASSERT(length &lt;= maxLength);
<span class="line-modified"> 110     JSBigInt* bigInt = new (NotNull, allocateCell&lt;JSBigInt&gt;(vm.heap, allocationSize(length))) JSBigInt(vm, vm.bigIntStructure.get(), length);</span>

 111     bigInt-&gt;finishCreation(vm);
 112     return bigInt;
 113 }
 114 
 115 JSBigInt* JSBigInt::createFrom(VM&amp; vm, int32_t value)
 116 {
 117     if (!value)
 118         return createZero(vm);
 119 
 120     JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
 121     if (value &lt; 0) {
 122         bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(-1 * static_cast&lt;int64_t&gt;(value)));
 123         bigInt-&gt;setSign(true);
 124     } else
 125         bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
 126 
 127     return bigInt;
 128 }
 129 
 130 JSBigInt* JSBigInt::createFrom(VM&amp; vm, uint32_t value)
</pre>
<hr />
<pre>
 165     Digit lowBits  = static_cast&lt;Digit&gt;(tempValue &amp; 0xffffffff);
 166     Digit highBits = static_cast&lt;Digit&gt;((tempValue &gt;&gt; 32) &amp; 0xffffffff);
 167 
 168     bigInt-&gt;setDigit(0, lowBits);
 169     bigInt-&gt;setDigit(1, highBits);
 170     bigInt-&gt;setSign(sign);
 171 
 172     return bigInt;
 173 }
 174 
 175 JSBigInt* JSBigInt::createFrom(VM&amp; vm, bool value)
 176 {
 177     if (!value)
 178         return createZero(vm);
 179 
 180     JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
 181     bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
 182     return bigInt;
 183 }
 184 
<span class="line-modified"> 185 JSValue JSBigInt::toPrimitive(ExecState*, PreferredPrimitiveType) const</span>
 186 {
 187     return const_cast&lt;JSBigInt*&gt;(this);
 188 }
 189 
 190 Optional&lt;uint8_t&gt; JSBigInt::singleDigitValueForString()
 191 {
 192     if (isZero())
 193         return 0;
 194 
 195     if (length() == 1 &amp;&amp; !sign()) {
 196         Digit rDigit = digit(0);
 197         if (rDigit &lt;= 9)
 198             return static_cast&lt;uint8_t&gt;(rDigit);
 199     }
 200     return { };
 201 }
 202 
<span class="line-modified"> 203 JSBigInt* JSBigInt::parseInt(ExecState* exec, StringView s, ErrorParseMode parserMode)</span>
 204 {
 205     if (s.is8Bit())
<span class="line-modified"> 206         return parseInt(exec, s.characters8(), s.length(), parserMode);</span>
<span class="line-modified"> 207     return parseInt(exec, s.characters16(), s.length(), parserMode);</span>
 208 }
 209 
<span class="line-modified"> 210 JSBigInt* JSBigInt::parseInt(ExecState* exec, VM&amp; vm, StringView s, uint8_t radix, ErrorParseMode parserMode, ParseIntSign sign)</span>
 211 {
 212     if (s.is8Bit())
<span class="line-modified"> 213         return parseInt(exec, vm, s.characters8(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);</span>
<span class="line-modified"> 214     return parseInt(exec, vm, s.characters16(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);</span>
 215 }
 216 
<span class="line-modified"> 217 JSBigInt* JSBigInt::stringToBigInt(ExecState* exec, StringView s)</span>
 218 {
<span class="line-modified"> 219     return parseInt(exec, s, ErrorParseMode::IgnoreExceptions);</span>
 220 }
 221 
<span class="line-modified"> 222 String JSBigInt::toString(ExecState* exec, unsigned radix)</span>
 223 {
 224     if (this-&gt;isZero())
<span class="line-modified"> 225         return exec-&gt;vm().smallStrings.singleCharacterStringRep(&#39;0&#39;);</span>
 226 
 227     if (hasOneBitSet(radix))
<span class="line-modified"> 228         return toStringBasePowerOfTwo(exec-&gt;vm(), exec, this, radix);</span>
 229 
<span class="line-modified"> 230     return toStringGeneric(exec-&gt;vm(), exec, this, radix);</span>
 231 }
 232 
 233 String JSBigInt::tryGetString(VM&amp; vm, JSBigInt* bigInt, unsigned radix)
 234 {
 235     if (bigInt-&gt;isZero())
 236         return vm.smallStrings.singleCharacterStringRep(&#39;0&#39;);
 237 
 238     if (hasOneBitSet(radix))
 239         return toStringBasePowerOfTwo(vm, nullptr, bigInt, radix);
 240 
 241     return toStringGeneric(vm, nullptr, bigInt, radix);
 242 }
 243 
 244 // Multiplies {this} with {factor} and adds {summand} to the result.
 245 void JSBigInt::inplaceMultiplyAdd(Digit factor, Digit summand)
 246 {
 247     internalMultiplyAdd(this, factor, summand, length(), this);
 248 }
 249 
<span class="line-modified"> 250 JSBigInt* JSBigInt::exponentiate(ExecState* exec, JSBigInt* base, JSBigInt* exponent)</span>
 251 {
<span class="line-modified"> 252     VM&amp; vm = exec-&gt;vm();</span>
 253     auto scope = DECLARE_THROW_SCOPE(vm);
 254 
 255     if (exponent-&gt;sign()) {
<span class="line-modified"> 256         throwRangeError(exec, scope, &quot;Negative exponent is not allowed&quot;_s);</span>
 257         return nullptr;
 258     }
 259 
 260     // 2. If base is 0n and exponent is 0n, return 1n.
 261     if (exponent-&gt;isZero())
 262         return JSBigInt::createFrom(vm, 1);
 263 
 264     // 3. Return a BigInt representing the mathematical value of base raised
 265     //    to the power exponent.
 266     if (base-&gt;isZero())
 267         return base;
 268 
 269     if (base-&gt;length() == 1 &amp;&amp; base-&gt;digit(0) == 1) {
 270         // (-1) ** even_number == 1.
 271         if (base-&gt;sign() &amp;&amp; !(exponent-&gt;digit(0) &amp; 1))
 272             return JSBigInt::unaryMinus(vm, base);
 273 
 274         // (-1) ** odd_number == -1; 1 ** anything == 1.
 275         return base;
 276     }
 277 
 278     // For all bases &gt;= 2, very large exponents would lead to unrepresentable
 279     // results.
 280     static_assert(maxLengthBits &lt; std::numeric_limits&lt;Digit&gt;::max(), &quot;maxLengthBits needs to be less than digit::max()&quot;);
 281     if (exponent-&gt;length() &gt; 1) {
<span class="line-modified"> 282         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
 283         return nullptr;
 284     }
 285 
 286     Digit expValue = exponent-&gt;digit(0);
 287     if (expValue == 1)
 288         return base;
 289     if (expValue &gt;= maxLengthBits) {
<span class="line-modified"> 290         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
 291         return nullptr;
 292     }
 293 
 294     static_assert(maxLengthBits &lt;= maxInt, &quot;maxLengthBits needs to be &lt;= maxInt&quot;);
 295     int n = static_cast&lt;int&gt;(expValue);
 296     if (base-&gt;length() == 1 &amp;&amp; base-&gt;digit(0) == 2) {
 297         // Fast path for 2^n.
 298         int neededDigits = 1 + (n / digitBits);
<span class="line-modified"> 299         JSBigInt* result = JSBigInt::tryCreateWithLength(exec, neededDigits);</span>
 300         RETURN_IF_EXCEPTION(scope, nullptr);
 301 
 302         result-&gt;initialize(InitializationType::WithZero);
 303         // All bits are zero. Now set the n-th bit.
 304         Digit msd = static_cast&lt;Digit&gt;(1) &lt;&lt; (n % digitBits);
 305         result-&gt;setDigit(neededDigits - 1, msd);
 306         // Result is negative for odd powers of -2n.
 307         if (base-&gt;sign())
 308             result-&gt;setSign(static_cast&lt;bool&gt;(n &amp; 1));
 309 
 310         return result;
 311     }
 312 
 313     JSBigInt* result = nullptr;
 314     JSBigInt* runningSquare = base;
 315 
 316     // This implicitly sets the result&#39;s sign correctly.
 317     if (n &amp; 1)
 318         result = base;
 319 
 320     n &gt;&gt;= 1;
 321     for (; n; n &gt;&gt;= 1) {
<span class="line-modified"> 322         JSBigInt* maybeResult = JSBigInt::multiply(exec, runningSquare, runningSquare);</span>
 323         RETURN_IF_EXCEPTION(scope, nullptr);
 324         runningSquare = maybeResult;
 325         if (n &amp; 1) {
 326             if (!result)
 327                 result = runningSquare;
 328             else {
<span class="line-modified"> 329                 maybeResult = JSBigInt::multiply(exec, result, runningSquare);</span>
 330                 RETURN_IF_EXCEPTION(scope, nullptr);
 331                 result = maybeResult;
 332             }
 333         }
 334     }
 335 
 336     return result;
 337 }
 338 
<span class="line-modified"> 339 JSBigInt* JSBigInt::multiply(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
 340 {
<span class="line-modified"> 341     VM&amp; vm = exec-&gt;vm();</span>
 342     auto scope = DECLARE_THROW_SCOPE(vm);
 343 
 344     if (x-&gt;isZero())
 345         return x;
 346     if (y-&gt;isZero())
 347         return y;
 348 
 349     unsigned resultLength = x-&gt;length() + y-&gt;length();
<span class="line-modified"> 350     JSBigInt* result = JSBigInt::tryCreateWithLength(exec, resultLength);</span>
 351     RETURN_IF_EXCEPTION(scope, nullptr);
 352     result-&gt;initialize(InitializationType::WithZero);
 353 
 354     for (unsigned i = 0; i &lt; x-&gt;length(); i++)
 355         multiplyAccumulate(y, x-&gt;digit(i), result, i);
 356 
 357     result-&gt;setSign(x-&gt;sign() != y-&gt;sign());
 358     return result-&gt;rightTrim(vm);
 359 }
 360 
<span class="line-modified"> 361 JSBigInt* JSBigInt::divide(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
 362 {
 363     // 1. If y is 0n, throw a RangeError exception.
<span class="line-modified"> 364     VM&amp; vm = exec-&gt;vm();</span>
 365     auto scope = DECLARE_THROW_SCOPE(vm);
 366 
 367     if (y-&gt;isZero()) {
<span class="line-modified"> 368         throwRangeError(exec, scope, &quot;0 is an invalid divisor value.&quot;_s);</span>
 369         return nullptr;
 370     }
 371 
 372     // 2. Let quotient be the mathematical value of x divided by y.
 373     // 3. Return a BigInt representing quotient rounded towards 0 to the next
 374     //    integral value.
 375     if (absoluteCompare(x, y) == ComparisonResult::LessThan)
 376         return createZero(vm);
 377 
 378     JSBigInt* quotient = nullptr;
 379     bool resultSign = x-&gt;sign() != y-&gt;sign();
 380     if (y-&gt;length() == 1) {
 381         Digit divisor = y-&gt;digit(0);
 382         if (divisor == 1)
 383             return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
 384 
 385         Digit remainder;
 386         absoluteDivWithDigitDivisor(vm, x, divisor, &amp;quotient, remainder);
 387     } else {
<span class="line-modified"> 388         absoluteDivWithBigIntDivisor(exec, x, y, &amp;quotient, nullptr);</span>
 389         RETURN_IF_EXCEPTION(scope, nullptr);
 390     }
 391 
 392     quotient-&gt;setSign(resultSign);
 393     return quotient-&gt;rightTrim(vm);
 394 }
 395 
 396 JSBigInt* JSBigInt::copy(VM&amp; vm, JSBigInt* x)
 397 {
 398     ASSERT(!x-&gt;isZero());
 399 
 400     JSBigInt* result = JSBigInt::createWithLengthUnchecked(vm, x-&gt;length());
 401     std::copy(x-&gt;dataStorage(), x-&gt;dataStorage() + x-&gt;length(), result-&gt;dataStorage());
 402     result-&gt;setSign(x-&gt;sign());
 403     return result;
 404 }
 405 
 406 JSBigInt* JSBigInt::unaryMinus(VM&amp; vm, JSBigInt* x)
 407 {
 408     if (x-&gt;isZero())
 409         return x;
 410 
 411     JSBigInt* result = copy(vm, x);
 412     result-&gt;setSign(!x-&gt;sign());
 413     return result;
 414 }
 415 
<span class="line-modified"> 416 JSBigInt* JSBigInt::remainder(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
 417 {
 418     // 1. If y is 0n, throw a RangeError exception.
<span class="line-modified"> 419     VM&amp; vm = exec-&gt;vm();</span>
 420     auto scope = DECLARE_THROW_SCOPE(vm);
 421 
 422     if (y-&gt;isZero()) {
<span class="line-modified"> 423         throwRangeError(exec, scope, &quot;0 is an invalid divisor value.&quot;_s);</span>
 424         return nullptr;
 425     }
 426 
 427     // 2. Return the JSBigInt representing x modulo y.
 428     // See https://github.com/tc39/proposal-bigint/issues/84 though.
 429     if (absoluteCompare(x, y) == ComparisonResult::LessThan)
 430         return x;
 431 
 432     JSBigInt* remainder;
 433     if (y-&gt;length() == 1) {
 434         Digit divisor = y-&gt;digit(0);
 435         if (divisor == 1)
 436             return createZero(vm);
 437 
 438         Digit remainderDigit;
 439         absoluteDivWithDigitDivisor(vm, x, divisor, nullptr, remainderDigit);
 440         if (!remainderDigit)
 441             return createZero(vm);
 442 
 443         remainder = createWithLengthUnchecked(vm, 1);
 444         remainder-&gt;setDigit(0, remainderDigit);
 445     } else {
<span class="line-modified"> 446         absoluteDivWithBigIntDivisor(exec, x, y, nullptr, &amp;remainder);</span>
 447         RETURN_IF_EXCEPTION(scope, nullptr);
 448     }
 449 
 450     remainder-&gt;setSign(x-&gt;sign());
 451     return remainder-&gt;rightTrim(vm);
 452 }
 453 
<span class="line-modified"> 454 JSBigInt* JSBigInt::add(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>







 455 {
<span class="line-modified"> 456     VM&amp; vm = exec-&gt;vm();</span>







 457     bool xSign = x-&gt;sign();
 458 
 459     // x + y == x + y
 460     // -x + -y == -(x + y)
 461     if (xSign == y-&gt;sign())
<span class="line-modified"> 462         return absoluteAdd(exec, x, y, xSign);</span>
 463 
 464     // x + -y == x - y == -(y - x)
 465     // -x + y == y - x == -(x - y)
 466     ComparisonResult comparisonResult = absoluteCompare(x, y);
 467     if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
 468         return absoluteSub(vm, x, y, xSign);
 469 
 470     return absoluteSub(vm, y, x, !xSign);
 471 }
 472 
<span class="line-modified"> 473 JSBigInt* JSBigInt::sub(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
 474 {
<span class="line-modified"> 475     VM&amp; vm = exec-&gt;vm();</span>
 476     bool xSign = x-&gt;sign();
 477     if (xSign != y-&gt;sign()) {
 478         // x - (-y) == x + y
 479         // (-x) - y == -(x + y)
<span class="line-modified"> 480         return absoluteAdd(exec, x, y, xSign);</span>
 481     }
 482     // x - y == -(y - x)
 483     // (-x) - (-y) == y - x == -(x - y)
 484     ComparisonResult comparisonResult = absoluteCompare(x, y);
 485     if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
 486         return absoluteSub(vm, x, y, xSign);
 487 
 488     return absoluteSub(vm, y, x, !xSign);
 489 }
 490 
<span class="line-modified"> 491 JSBigInt* JSBigInt::bitwiseAnd(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
 492 {
<span class="line-modified"> 493     VM&amp; vm = exec-&gt;vm();</span>
 494     auto scope = DECLARE_THROW_SCOPE(vm);
 495 
 496     if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
 497         scope.release();
 498         return absoluteAnd(vm, x, y);
 499     }
 500 
 501     if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
 502         int resultLength = std::max(x-&gt;length(), y-&gt;length()) + 1;
 503         // (-x) &amp; (-y) == ~(x-1) &amp; ~(y-1) == ~((x-1) | (y-1))
 504         // == -(((x-1) | (y-1)) + 1)
<span class="line-modified"> 505         JSBigInt* result = absoluteSubOne(exec, x, resultLength);</span>
 506         RETURN_IF_EXCEPTION(scope, nullptr);
 507 
<span class="line-modified"> 508         JSBigInt* y1 = absoluteSubOne(exec, y, y-&gt;length());</span>
 509         RETURN_IF_EXCEPTION(scope, nullptr);
 510         result = absoluteOr(vm, result, y1);
 511         scope.release();
<span class="line-modified"> 512         return absoluteAddOne(exec, result, SignOption::Signed);</span>
 513     }
 514 
 515     ASSERT(x-&gt;sign() != y-&gt;sign());
 516     // Assume that x is the positive BigInt.
 517     if (x-&gt;sign())
 518         std::swap(x, y);
 519 
 520     // x &amp; (-y) == x &amp; ~(y-1) == x &amp; ~(y-1)
<span class="line-modified"> 521     JSBigInt* y1 = absoluteSubOne(exec, y, y-&gt;length());</span>
 522     RETURN_IF_EXCEPTION(scope, nullptr);
 523     return absoluteAndNot(vm, x, y1);
 524 }
 525 
<span class="line-modified"> 526 JSBigInt* JSBigInt::bitwiseOr(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
 527 {
<span class="line-modified"> 528     VM&amp; vm = exec-&gt;vm();</span>
 529     auto scope = DECLARE_THROW_SCOPE(vm);
 530 
 531     unsigned resultLength = std::max(x-&gt;length(), y-&gt;length());
 532 
 533     if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
 534         scope.release();
 535         return absoluteOr(vm, x, y);
 536     }
 537 
 538     if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
 539         // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) &amp; (y-1))
 540         // == -(((x-1) &amp; (y-1)) + 1)
<span class="line-modified"> 541         JSBigInt* result = absoluteSubOne(exec, x, resultLength);</span>
 542         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 543         JSBigInt* y1 = absoluteSubOne(exec, y, y-&gt;length());</span>
 544         RETURN_IF_EXCEPTION(scope, nullptr);
 545         result = absoluteAnd(vm, result, y1);
 546         RETURN_IF_EXCEPTION(scope, nullptr);
 547 
 548         scope.release();
<span class="line-modified"> 549         return absoluteAddOne(exec, result, SignOption::Signed);</span>
 550     }
 551 
 552     ASSERT(x-&gt;sign() != y-&gt;sign());
 553 
 554     // Assume that x is the positive BigInt.
 555     if (x-&gt;sign())
 556         std::swap(x, y);
 557 
 558     // x | (-y) == x | ~(y-1) == ~((y-1) &amp;~ x) == -(((y-1) &amp;~ x) + 1)
<span class="line-modified"> 559     JSBigInt* result = absoluteSubOne(exec, y, resultLength);</span>
 560     RETURN_IF_EXCEPTION(scope, nullptr);
 561     result = absoluteAndNot(vm, result, x);
 562 
 563     scope.release();
<span class="line-modified"> 564     return absoluteAddOne(exec, result, SignOption::Signed);</span>
 565 }
 566 
<span class="line-modified"> 567 JSBigInt* JSBigInt::bitwiseXor(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
 568 {
<span class="line-modified"> 569     VM&amp; vm = exec-&gt;vm();</span>
 570     auto scope = DECLARE_THROW_SCOPE(vm);
 571 
 572     if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
 573         scope.release();
 574         return absoluteXor(vm, x, y);
 575     }
 576 
 577     if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
 578         int resultLength = std::max(x-&gt;length(), y-&gt;length());
 579 
 580         // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)
<span class="line-modified"> 581         JSBigInt* result = absoluteSubOne(exec, x, resultLength);</span>
 582         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 583         JSBigInt* y1 = absoluteSubOne(exec, y, y-&gt;length());</span>
 584         RETURN_IF_EXCEPTION(scope, nullptr);
 585 
 586         scope.release();
 587         return absoluteXor(vm, result, y1);
 588     }
 589     ASSERT(x-&gt;sign() != y-&gt;sign());
 590     int resultLength = std::max(x-&gt;length(), y-&gt;length()) + 1;
 591 
 592     // Assume that x is the positive BigInt.
 593     if (x-&gt;sign())
 594         std::swap(x, y);
 595 
 596     // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)
<span class="line-modified"> 597     JSBigInt* result = absoluteSubOne(exec, y, resultLength);</span>
 598     RETURN_IF_EXCEPTION(scope, nullptr);
 599 
 600     result = absoluteXor(vm, result, x);
 601     scope.release();
<span class="line-modified"> 602     return absoluteAddOne(exec, result, SignOption::Signed);</span>
 603 }
 604 
<span class="line-modified"> 605 JSBigInt* JSBigInt::leftShift(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
 606 {
 607     if (y-&gt;isZero() || x-&gt;isZero())
 608         return x;
 609 
 610     if (y-&gt;sign())
<span class="line-modified"> 611         return rightShiftByAbsolute(exec, x, y);</span>
 612 
<span class="line-modified"> 613     return leftShiftByAbsolute(exec, x, y);</span>
 614 }
 615 
<span class="line-modified"> 616 JSBigInt* JSBigInt::signedRightShift(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
 617 {
 618     if (y-&gt;isZero() || x-&gt;isZero())
 619         return x;
 620 
 621     if (y-&gt;sign())
<span class="line-modified"> 622         return leftShiftByAbsolute(exec, x, y);</span>
 623 
<span class="line-modified"> 624     return rightShiftByAbsolute(exec, x, y);</span>
 625 }
 626 
<span class="line-modified"> 627 JSBigInt* JSBigInt::bitwiseNot(ExecState* exec, JSBigInt* x)</span>
 628 {
 629     if (x-&gt;sign()) {
 630         // ~(-x) == ~(~(x-1)) == x-1
<span class="line-modified"> 631         return absoluteSubOne(exec, x, x-&gt;length());</span>
 632     }
 633     // ~x == -x-1 == -(x+1)
<span class="line-modified"> 634     return absoluteAddOne(exec, x, SignOption::Signed);</span>
 635 }
 636 
 637 #if USE(JSVALUE32_64)
 638 #define HAVE_TWO_DIGIT 1
 639 typedef uint64_t TwoDigit;
 640 #elif HAVE(INT128_T)
 641 #define HAVE_TWO_DIGIT 1
 642 typedef __uint128_t TwoDigit;
 643 #else
 644 #define HAVE_TWO_DIGIT 0
 645 #endif
 646 
 647 // {carry} must point to an initialized Digit and will either be incremented
 648 // by one or left alone.
 649 inline JSBigInt::Digit JSBigInt::digitAdd(Digit a, Digit b, Digit&amp; carry)
 650 {
 651     Digit result = a + b;
 652     carry += static_cast&lt;bool&gt;(result &lt; a);
 653     return result;
 654 }
</pre>
<hr />
<pre>
 910 
 911 inline JSBigInt::ComparisonResult JSBigInt::absoluteCompare(JSBigInt* x, JSBigInt* y)
 912 {
 913     ASSERT(!x-&gt;length() || x-&gt;digit(x-&gt;length() - 1));
 914     ASSERT(!y-&gt;length() || y-&gt;digit(y-&gt;length() - 1));
 915 
 916     int diff = x-&gt;length() - y-&gt;length();
 917     if (diff)
 918         return diff &lt; 0 ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
 919 
 920     int i = x-&gt;length() - 1;
 921     while (i &gt;= 0 &amp;&amp; x-&gt;digit(i) == y-&gt;digit(i))
 922         i--;
 923 
 924     if (i &lt; 0)
 925         return ComparisonResult::Equal;
 926 
 927     return x-&gt;digit(i) &gt; y-&gt;digit(i) ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
 928 }
 929 
<span class="line-modified"> 930 JSBigInt* JSBigInt::absoluteAdd(ExecState* exec, JSBigInt* x, JSBigInt* y, bool resultSign)</span>
 931 {
<span class="line-modified"> 932     VM&amp; vm = exec-&gt;vm();</span>
 933 
 934     if (x-&gt;length() &lt; y-&gt;length())
<span class="line-modified"> 935         return absoluteAdd(exec, y, x, resultSign);</span>
 936 
 937     if (x-&gt;isZero()) {
 938         ASSERT(y-&gt;isZero());
 939         return x;
 940     }
 941 
 942     if (y-&gt;isZero())
 943         return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
 944 
<span class="line-modified"> 945     JSBigInt* result = JSBigInt::tryCreateWithLength(exec, x-&gt;length() + 1);</span>
 946     if (!result)
 947         return nullptr;
 948     Digit carry = 0;
 949     unsigned i = 0;
 950     for (; i &lt; y-&gt;length(); i++) {
 951         Digit newCarry = 0;
 952         Digit sum = digitAdd(x-&gt;digit(i), y-&gt;digit(i), newCarry);
 953         sum = digitAdd(sum, carry, newCarry);
 954         result-&gt;setDigit(i, sum);
 955         carry = newCarry;
 956     }
 957 
 958     for (; i &lt; x-&gt;length(); i++) {
 959         Digit newCarry = 0;
 960         Digit sum = digitAdd(x-&gt;digit(i), carry, newCarry);
 961         result-&gt;setDigit(i, sum);
 962         carry = newCarry;
 963     }
 964 
 965     result-&gt;setDigit(i, carry);
</pre>
<hr />
<pre>
1032     if (quotient != nullptr) {
1033         if (*quotient == nullptr)
1034             *quotient = JSBigInt::createWithLengthUnchecked(vm, length);
1035 
1036         for (int i = length - 1; i &gt;= 0; i--) {
1037             Digit q = digitDiv(remainder, x-&gt;digit(i), divisor, remainder);
1038             (*quotient)-&gt;setDigit(i, q);
1039         }
1040     } else {
1041         for (int i = length - 1; i &gt;= 0; i--)
1042             digitDiv(remainder, x-&gt;digit(i), divisor, remainder);
1043     }
1044 }
1045 
1046 // Divides {dividend} by {divisor}, returning the result in {quotient} and
1047 // {remainder}. Mathematically, the contract is:
1048 // quotient = (dividend - remainder) / divisor, with 0 &lt;= remainder &lt; divisor.
1049 // Both {quotient} and {remainder} are optional, for callers that are only
1050 // interested in one of them.
1051 // See Knuth, Volume 2, section 4.3.1, Algorithm D.
<span class="line-modified">1052 void JSBigInt::absoluteDivWithBigIntDivisor(ExecState* exec, JSBigInt* dividend, JSBigInt* divisor, JSBigInt** quotient, JSBigInt** remainder)</span>
1053 {
1054     ASSERT(divisor-&gt;length() &gt;= 2);
1055     ASSERT(dividend-&gt;length() &gt;= divisor-&gt;length());
<span class="line-modified">1056     VM&amp; vm = exec-&gt;vm();</span>
1057     auto scope = DECLARE_THROW_SCOPE(vm);
1058 
1059     // The unusual variable names inside this function are consistent with
1060     // Knuth&#39;s book, as well as with Go&#39;s implementation of this algorithm.
1061     // Maintaining this consistency is probably more useful than trying to
1062     // come up with more descriptive names for them.
1063     unsigned n = divisor-&gt;length();
1064     unsigned m = dividend-&gt;length() - n;
1065 
1066     // The quotient to be computed.
1067     JSBigInt* q = nullptr;
1068     if (quotient != nullptr)
<span class="line-modified">1069         q = createWithLengthUnchecked(exec-&gt;vm(), m + 1);</span>
1070 
1071     // In each iteration, {qhatv} holds {divisor} * {current quotient digit}.
1072     // &quot;v&quot; is the book&#39;s name for {divisor}, &quot;qhat&quot; the current quotient digit.
<span class="line-modified">1073     JSBigInt* qhatv = tryCreateWithLength(exec, n + 1);</span>
1074     RETURN_IF_EXCEPTION(scope, void());
1075 
1076     // D1.
1077     // Left-shift inputs so that the divisor&#39;s MSB is set. This is necessary
1078     // to prevent the digit-wise divisions (see digit_div call below) from
1079     // overflowing (they take a two digits wide input, and return a one digit
1080     // result).
1081     Digit lastDigit = divisor-&gt;digit(n - 1);
1082     unsigned shift = clz(lastDigit);
1083 
1084     if (shift &gt; 0) {
<span class="line-modified">1085         divisor = absoluteLeftShiftAlwaysCopy(exec, divisor, shift, LeftShiftMode::SameSizeResult);</span>
1086         RETURN_IF_EXCEPTION(scope, void());
1087     }
1088 
1089     // Holds the (continuously updated) remaining part of the dividend, which
1090     // eventually becomes the remainder.
<span class="line-modified">1091     JSBigInt* u = absoluteLeftShiftAlwaysCopy(exec, dividend, shift, LeftShiftMode::AlwaysAddOneDigit);</span>
1092     RETURN_IF_EXCEPTION(scope, void());
1093 
1094     // D2.
1095     // Iterate over the dividend&#39;s digit (like the &quot;grad school&quot; algorithm).
1096     // {vn1} is the divisor&#39;s most significant digit.
1097     Digit vn1 = divisor-&gt;digit(n - 1);
1098     for (int j = m; j &gt;= 0; j--) {
1099         // D3.
1100         // Estimate the current iteration&#39;s quotient digit (see Knuth for details).
1101         // {qhat} is the current quotient digit.
1102         Digit qhat = std::numeric_limits&lt;Digit&gt;::max();
1103 
1104         // {ujn} is the dividend&#39;s most significant remaining digit.
1105         Digit ujn = u-&gt;digit(j + n);
1106         if (ujn != vn1) {
1107             // {rhat} is the current iteration&#39;s remainder.
1108             Digit rhat = 0;
1109             // Estimate the current quotient digit by dividing the most significant
1110             // digits of dividend and divisor. The result will not be too small,
1111             // but could be a bit too large.
</pre>
<hr />
<pre>
1200 
1201 void JSBigInt::inplaceRightShift(unsigned shift)
1202 {
1203     ASSERT(shift &lt; digitBits);
1204     ASSERT(!(digit(0) &amp; ((static_cast&lt;Digit&gt;(1) &lt;&lt; shift) - 1)));
1205 
1206     if (!shift)
1207         return;
1208 
1209     Digit carry = digit(0) &gt;&gt; shift;
1210     unsigned last = length() - 1;
1211     for (unsigned i = 0; i &lt; last; i++) {
1212         Digit d = digit(i + 1);
1213         setDigit(i, (d &lt;&lt; (digitBits - shift)) | carry);
1214         carry = d &gt;&gt; shift;
1215     }
1216     setDigit(last, carry);
1217 }
1218 
1219 // Always copies the input, even when {shift} == 0.
<span class="line-modified">1220 JSBigInt* JSBigInt::absoluteLeftShiftAlwaysCopy(ExecState* exec, JSBigInt* x, unsigned shift, LeftShiftMode mode)</span>
1221 {
1222     ASSERT(shift &lt; digitBits);
1223     ASSERT(!x-&gt;isZero());
1224 
1225     unsigned n = x-&gt;length();
1226     unsigned resultLength = mode == LeftShiftMode::AlwaysAddOneDigit ? n + 1 : n;
<span class="line-modified">1227     JSBigInt* result = tryCreateWithLength(exec, resultLength);</span>
1228     if (!result)
1229         return nullptr;
1230 
1231     if (!shift) {
1232         for (unsigned i = 0; i &lt; n; i++)
1233             result-&gt;setDigit(i, x-&gt;digit(i));
1234         if (mode == LeftShiftMode::AlwaysAddOneDigit)
1235             result-&gt;setDigit(n, 0);
1236 
1237         return result;
1238     }
1239 
1240     Digit carry = 0;
1241     for (unsigned i = 0; i &lt; n; i++) {
1242         Digit d = x-&gt;digit(i);
1243         result-&gt;setDigit(i, (d &lt;&lt; shift) | carry);
1244         carry = d &gt;&gt; (digitBits - shift);
1245     }
1246 
1247     if (mode == LeftShiftMode::AlwaysAddOneDigit)
</pre>
<hr />
<pre>
1314     };
1315     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::Symmetric, digitOperation);
1316 }
1317 
1318 JSBigInt* JSBigInt::absoluteAndNot(VM&amp; vm, JSBigInt* x, JSBigInt* y)
1319 {
1320     auto digitOperation = [](Digit a, Digit b) {
1321         return a &amp; ~b;
1322     };
1323     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::NotSymmetric, digitOperation);
1324 }
1325 
1326 JSBigInt* JSBigInt::absoluteXor(VM&amp; vm, JSBigInt* x, JSBigInt* y)
1327 {
1328     auto digitOperation = [](Digit a, Digit b) {
1329         return a ^ b;
1330     };
1331     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::Symmetric, digitOperation);
1332 }
1333 
<span class="line-modified">1334 JSBigInt* JSBigInt::absoluteAddOne(ExecState* exec, JSBigInt* x, SignOption signOption)</span>
1335 {
1336     unsigned inputLength = x-&gt;length();
1337     // The addition will overflow into a new digit if all existing digits are
1338     // at maximum.
1339     bool willOverflow = true;
1340     for (unsigned i = 0; i &lt; inputLength; i++) {
1341         if (std::numeric_limits&lt;Digit&gt;::max() != x-&gt;digit(i)) {
1342             willOverflow = false;
1343             break;
1344         }
1345     }
1346 
1347     unsigned resultLength = inputLength + willOverflow;
<span class="line-modified">1348     JSBigInt* result = tryCreateWithLength(exec, resultLength);</span>
1349     if (!result)
1350         return nullptr;
1351 
1352     Digit carry = 1;
1353     for (unsigned i = 0; i &lt; inputLength; i++) {
1354         Digit newCarry = 0;
1355         result-&gt;setDigit(i, digitAdd(x-&gt;digit(i), carry, newCarry));
1356         carry = newCarry;
1357     }
1358     if (resultLength &gt; inputLength)
1359         result-&gt;setDigit(inputLength, carry);
1360     else
1361         ASSERT(!carry);
1362 
1363     result-&gt;setSign(signOption == SignOption::Signed);
<span class="line-modified">1364     return result-&gt;rightTrim(exec-&gt;vm());</span>
1365 }
1366 
<span class="line-modified">1367 JSBigInt* JSBigInt::absoluteSubOne(ExecState* exec, JSBigInt* x, unsigned resultLength)</span>
1368 {
1369     ASSERT(!x-&gt;isZero());
1370     ASSERT(resultLength &gt;= x-&gt;length());
<span class="line-modified">1371     VM&amp; vm = exec-&gt;vm();</span>
1372     auto scope = DECLARE_THROW_SCOPE(vm);
1373 
<span class="line-modified">1374     JSBigInt* result = tryCreateWithLength(exec, resultLength);</span>
1375     RETURN_IF_EXCEPTION(scope, nullptr);
1376 
1377     unsigned length = x-&gt;length();
1378     Digit borrow = 1;
1379     for (unsigned i = 0; i &lt; length; i++) {
1380         Digit newBorrow = 0;
1381         result-&gt;setDigit(i, digitSub(x-&gt;digit(i), borrow, newBorrow));
1382         borrow = newBorrow;
1383     }
1384     ASSERT(!borrow);
1385     for (unsigned i = length; i &lt; resultLength; i++)
1386         result-&gt;setDigit(i, borrow);
1387 
1388     return result-&gt;rightTrim(vm);
1389 }
1390 
<span class="line-modified">1391 JSBigInt* JSBigInt::leftShiftByAbsolute(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
1392 {
<span class="line-modified">1393     VM&amp; vm = exec-&gt;vm();</span>
1394     auto scope = DECLARE_THROW_SCOPE(vm);
1395 
1396     auto optionalShift = toShiftAmount(y);
1397     if (!optionalShift) {
<span class="line-modified">1398         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
1399         return nullptr;
1400     }
1401 
1402     Digit shift = *optionalShift;
1403     unsigned digitShift = static_cast&lt;unsigned&gt;(shift / digitBits);
1404     unsigned bitsShift = static_cast&lt;unsigned&gt;(shift % digitBits);
1405     unsigned length = x-&gt;length();
1406     bool grow = bitsShift &amp;&amp; (x-&gt;digit(length - 1) &gt;&gt; (digitBits - bitsShift));
1407     int resultLength = length + digitShift + grow;
1408     if (static_cast&lt;unsigned&gt;(resultLength) &gt; maxLength) {
<span class="line-modified">1409         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
1410         return nullptr;
1411     }
1412 
<span class="line-modified">1413     JSBigInt* result = tryCreateWithLength(exec, resultLength);</span>
1414     RETURN_IF_EXCEPTION(scope, nullptr);
1415     if (!bitsShift) {
1416         unsigned i = 0;
1417         for (; i &lt; digitShift; i++)
1418             result-&gt;setDigit(i, 0ul);
1419 
1420         for (; i &lt; static_cast&lt;unsigned&gt;(resultLength); i++)
1421             result-&gt;setDigit(i, x-&gt;digit(i - digitShift));
1422     } else {
1423         Digit carry = 0;
1424         for (unsigned i = 0; i &lt; digitShift; i++)
1425             result-&gt;setDigit(i, 0ul);
1426 
1427         for (unsigned i = 0; i &lt; length; i++) {
1428             Digit d = x-&gt;digit(i);
1429             result-&gt;setDigit(i + digitShift, (d &lt;&lt; bitsShift) | carry);
1430             carry = d &gt;&gt; (digitBits - bitsShift);
1431         }
1432 
1433         if (grow)
1434             result-&gt;setDigit(length + digitShift, carry);
1435         else
1436             ASSERT(!carry);
1437     }
1438 
1439     result-&gt;setSign(x-&gt;sign());
1440     return result-&gt;rightTrim(vm);
1441 }
1442 
<span class="line-modified">1443 JSBigInt* JSBigInt::rightShiftByAbsolute(ExecState* exec, JSBigInt* x, JSBigInt* y)</span>
1444 {
<span class="line-modified">1445     VM&amp; vm = exec-&gt;vm();</span>
1446     unsigned length = x-&gt;length();
1447     bool sign = x-&gt;sign();
1448     auto optionalShift = toShiftAmount(y);
1449     if (!optionalShift)
1450         return rightShiftByMaximum(vm, sign);
1451 
1452     Digit shift = *optionalShift;
1453     unsigned digitalShift = static_cast&lt;unsigned&gt;(shift / digitBits);
1454     unsigned bitsShift = static_cast&lt;unsigned&gt;(shift % digitBits);
1455     int resultLength = length - digitalShift;
1456     if (resultLength &lt;= 0)
1457         return rightShiftByMaximum(vm, sign);
1458 
1459     // For negative numbers, round down if any bit was shifted out (so that e.g.
1460     // -5n &gt;&gt; 1n == -3n and not -2n). Check now whether this will happen and
1461     // whether it can cause overflow into a new digit. If we allocate the result
1462     // large enough up front, it avoids having to do a second allocation later.
1463     bool mustRoundDown = false;
1464     if (sign) {
1465         const Digit mask = (static_cast&lt;Digit&gt;(1) &lt;&lt; bitsShift) - 1;
</pre>
<hr />
<pre>
1489     if (!bitsShift) {
1490         for (unsigned i = digitalShift; i &lt; length; i++)
1491             result-&gt;setDigit(i - digitalShift, x-&gt;digit(i));
1492     } else {
1493         Digit carry = x-&gt;digit(digitalShift) &gt;&gt; bitsShift;
1494         unsigned last = length - digitalShift - 1;
1495         for (unsigned i = 0; i &lt; last; i++) {
1496             Digit d = x-&gt;digit(i + digitalShift + 1);
1497             result-&gt;setDigit(i, (d &lt;&lt; (digitBits - bitsShift)) | carry);
1498             carry = d &gt;&gt; bitsShift;
1499         }
1500         result-&gt;setDigit(last, carry);
1501     }
1502 
1503     if (sign) {
1504         result-&gt;setSign(true);
1505         if (mustRoundDown) {
1506             // Since the result is negative, rounding down means adding one to
1507             // its absolute value. This cannot overflow.
1508             result = result-&gt;rightTrim(vm);
<span class="line-modified">1509             return absoluteAddOne(exec, result, SignOption::Signed);</span>
1510         }
1511     }
1512 
1513     return result-&gt;rightTrim(vm);
1514 }
1515 
1516 JSBigInt* JSBigInt::rightShiftByMaximum(VM&amp; vm, bool sign)
1517 {
1518     if (sign)
1519         return createFrom(vm, -1);
1520 
1521     return createZero(vm);
1522 }
1523 
1524 // Lookup table for the maximum number of bits required per character of a
1525 // base-N string representation of a number. To increase accuracy, the array
1526 // value is the actual value multiplied by 32. To generate this table:
1527 // for (var i = 0; i &lt;= 36; i++) { print(Math.ceil(Math.log2(i) * 32) + &quot;,&quot;); }
1528 constexpr uint8_t maxBitsPerCharTable[] = {
1529     0,   0,   32,  51,  64,  75,  83,  90,  96, // 0..8
</pre>
<hr />
<pre>
1547     // Maximum number of bits we can represent with one character. We&#39;ll use this
1548     // to find an appropriate chunk size below.
1549     uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
1550 
1551     // For estimating result length, we have to be pessimistic and work with
1552     // the minimum number of bits one character can represent.
1553     uint8_t minBitsPerChar = maxBitsPerChar - 1;
1554 
1555     // Perform the following computation with uint64_t to avoid overflows.
1556     uint64_t maximumCharactersRequired = bitLength;
1557     maximumCharactersRequired *= bitsPerCharTableMultiplier;
1558 
1559     // Round up.
1560     maximumCharactersRequired += minBitsPerChar - 1;
1561     maximumCharactersRequired /= minBitsPerChar;
1562     maximumCharactersRequired += sign;
1563 
1564     return maximumCharactersRequired;
1565 }
1566 
<span class="line-modified">1567 String JSBigInt::toStringBasePowerOfTwo(VM&amp; vm, ExecState* exec, JSBigInt* x, unsigned radix)</span>
1568 {
1569     ASSERT(hasOneBitSet(radix));
1570     ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 32);
1571     ASSERT(!x-&gt;isZero());
1572 
1573     const unsigned length = x-&gt;length();
1574     const bool sign = x-&gt;sign();
1575     const unsigned bitsPerChar = ctz(radix);
1576     const unsigned charMask = radix - 1;
1577     // Compute the length of the resulting string: divide the bit length of the
1578     // BigInt by the number of bits representable per character (rounding up).
1579     const Digit msd = x-&gt;digit(length - 1);
1580 
1581     const unsigned msdLeadingZeros = clz(msd);
1582 
1583     const size_t bitLength = length * digitBits - msdLeadingZeros;
1584     const size_t charsRequired = (bitLength + bitsPerChar - 1) / bitsPerChar + sign;
1585 
1586     if (charsRequired &gt; JSString::MaxLength) {
<span class="line-modified">1587         if (exec) {</span>
1588             auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1589             throwOutOfMemoryError(exec, scope);</span>
1590         }
1591         return String();
1592     }
1593 
1594     Vector&lt;LChar&gt; resultString(charsRequired);
1595     Digit digit = 0;
1596     // Keeps track of how many unprocessed bits there are in {digit}.
1597     unsigned availableBits = 0;
1598     int pos = static_cast&lt;int&gt;(charsRequired - 1);
1599     for (unsigned i = 0; i &lt; length - 1; i++) {
1600         Digit newDigit = x-&gt;digit(i);
1601         // Take any leftover bits from the last iteration into account.
1602         int current = (digit | (newDigit &lt;&lt; availableBits)) &amp; charMask;
1603         resultString[pos--] = radixDigits[current];
1604         int consumedBits = bitsPerChar - availableBits;
1605         digit = newDigit &gt;&gt; consumedBits;
1606         availableBits = digitBits - consumedBits;
1607         while (availableBits &gt;= bitsPerChar) {
1608             resultString[pos--] = radixDigits[digit &amp; charMask];
1609             digit &gt;&gt;= bitsPerChar;
1610             availableBits -= bitsPerChar;
1611         }
1612     }
1613     // Take any leftover bits from the last iteration into account.
1614     int current = (digit | (msd &lt;&lt; availableBits)) &amp; charMask;
1615     resultString[pos--] = radixDigits[current];
1616     digit = msd &gt;&gt; (bitsPerChar - availableBits);
1617     while (digit) {
1618         resultString[pos--] = radixDigits[digit &amp; charMask];
1619         digit &gt;&gt;= bitsPerChar;
1620     }
1621 
1622     if (sign)
1623         resultString[pos--] = &#39;-&#39;;
1624 
1625     ASSERT(pos == -1);
1626     return StringImpl::adopt(WTFMove(resultString));
1627 }
1628 
<span class="line-modified">1629 String JSBigInt::toStringGeneric(VM&amp; vm, ExecState* exec, JSBigInt* x, unsigned radix)</span>
1630 {
1631     // FIXME: [JSC] Revisit usage of Vector into JSBigInt::toString
1632     // https://bugs.webkit.org/show_bug.cgi?id=18067
1633     Vector&lt;LChar&gt; resultString;
1634 
1635     ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 36);
1636     ASSERT(!x-&gt;isZero());
1637 
1638     unsigned length = x-&gt;length();
1639     bool sign = x-&gt;sign();
1640 
1641     uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
1642     uint64_t maximumCharactersRequired = calculateMaximumCharactersRequired(length, radix, x-&gt;digit(length - 1), sign);
1643 
1644     if (maximumCharactersRequired &gt; JSString::MaxLength) {
<span class="line-modified">1645         if (exec) {</span>
1646             auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1647             throwOutOfMemoryError(exec, scope);</span>
1648         }
1649         return String();
1650     }
1651 
1652     Digit lastDigit;
1653     if (length == 1)
1654         lastDigit = x-&gt;digit(0);
1655     else {
1656         unsigned chunkChars = digitBits * bitsPerCharTableMultiplier / maxBitsPerChar;
1657         Digit chunkDivisor = digitPow(radix, chunkChars);
1658 
1659         // By construction of chunkChars, there can&#39;t have been overflow.
1660         ASSERT(chunkDivisor);
1661         unsigned nonZeroDigit = length - 1;
1662         ASSERT(x-&gt;digit(nonZeroDigit));
1663 
1664         // {rest} holds the part of the BigInt that we haven&#39;t looked at yet.
1665         // Not to be confused with &quot;remainder&quot;!
1666         JSBigInt* rest = nullptr;
1667 
</pre>
<hr />
<pre>
1720 
1721     int nonZeroIndex = m_length - 1;
1722     while (nonZeroIndex &gt;= 0 &amp;&amp; !digit(nonZeroIndex))
1723         nonZeroIndex--;
1724 
1725     if (nonZeroIndex &lt; 0)
1726         return createZero(vm);
1727 
1728     if (nonZeroIndex == static_cast&lt;int&gt;(m_length - 1))
1729         return this;
1730 
1731     unsigned newLength = nonZeroIndex + 1;
1732     JSBigInt* trimmedBigInt = createWithLengthUnchecked(vm, newLength);
1733     std::copy(dataStorage(), dataStorage() + newLength, trimmedBigInt-&gt;dataStorage());
1734 
1735     trimmedBigInt-&gt;setSign(this-&gt;sign());
1736 
1737     return trimmedBigInt;
1738 }
1739 
<span class="line-modified">1740 JSBigInt* JSBigInt::allocateFor(ExecState* exec, VM&amp; vm, unsigned radix, unsigned charcount)</span>
1741 {
1742     ASSERT(2 &lt;= radix &amp;&amp; radix &lt;= 36);
1743 
1744     size_t bitsPerChar = maxBitsPerCharTable[radix];
1745     size_t chars = charcount;
1746     const unsigned roundup = bitsPerCharTableMultiplier - 1;
1747     if (chars &lt;= (std::numeric_limits&lt;size_t&gt;::max() - roundup) / bitsPerChar) {
1748         size_t bitsMin = bitsPerChar * chars;
1749 
1750         // Divide by 32 (see table), rounding up.
1751         bitsMin = (bitsMin + roundup) &gt;&gt; bitsPerCharTableShift;
1752         if (bitsMin &lt;= static_cast&lt;size_t&gt;(maxInt)) {
1753             // Divide by kDigitsBits, rounding up.
1754             unsigned length = (bitsMin + digitBits - 1) / digitBits;
1755             if (length &lt;= maxLength) {
1756                 JSBigInt* result = JSBigInt::createWithLengthUnchecked(vm, length);
1757                 return result;
1758             }
1759         }
1760     }
1761 
<span class="line-modified">1762     if (exec) {</span>
1763         auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1764         throwOutOfMemoryError(exec, scope);</span>
1765     }
1766     return nullptr;
1767 }
1768 
1769 size_t JSBigInt::estimatedSize(JSCell* cell, VM&amp; vm)
1770 {
1771     return Base::estimatedSize(cell, vm) + jsCast&lt;JSBigInt*&gt;(cell)-&gt;m_length * sizeof(Digit);
1772 }
1773 
<span class="line-modified">1774 double JSBigInt::toNumber(ExecState* exec) const</span>
1775 {
<span class="line-modified">1776     VM&amp; vm = exec-&gt;vm();</span>
1777     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1778     throwTypeError(exec, scope, &quot;Conversion from &#39;BigInt&#39; to &#39;number&#39; is not allowed.&quot;_s);</span>
1779     return 0.0;
1780 }
1781 
<span class="line-modified">1782 bool JSBigInt::getPrimitiveNumber(ExecState* exec, double&amp; number, JSValue&amp; result) const</span>
1783 {
1784     result = this;
<span class="line-modified">1785     number = toNumber(exec);</span>
1786     return true;
1787 }
1788 
1789 template &lt;typename CharType&gt;
<span class="line-modified">1790 JSBigInt* JSBigInt::parseInt(ExecState* exec, CharType*  data, unsigned length, ErrorParseMode errorParseMode)</span>
1791 {
<span class="line-modified">1792     VM&amp; vm = exec-&gt;vm();</span>
1793 
1794     unsigned p = 0;
1795     while (p &lt; length &amp;&amp; isStrWhiteSpace(data[p]))
1796         ++p;
1797 
1798     // Check Radix from frist characters
1799     if (static_cast&lt;unsigned&gt;(p) + 1 &lt; static_cast&lt;unsigned&gt;(length) &amp;&amp; data[p] == &#39;0&#39;) {
1800         if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;b&#39;))
<span class="line-modified">1801             return parseInt(exec, vm, data, length, p + 2, 2, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
1802 
1803         if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;x&#39;))
<span class="line-modified">1804             return parseInt(exec, vm, data, length, p + 2, 16, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
1805 
1806         if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;o&#39;))
<span class="line-modified">1807             return parseInt(exec, vm, data, length, p + 2, 8, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
1808     }
1809 
1810     ParseIntSign sign = ParseIntSign::Unsigned;
1811     if (p &lt; length) {
1812         if (data[p] == &#39;+&#39;)
1813             ++p;
1814         else if (data[p] == &#39;-&#39;) {
1815             sign = ParseIntSign::Signed;
1816             ++p;
1817         }
1818     }
1819 
<span class="line-modified">1820     JSBigInt* result = parseInt(exec, vm, data, length, p, 10, errorParseMode, sign);</span>
1821 
1822     if (result &amp;&amp; !result-&gt;isZero())
1823         result-&gt;setSign(sign == ParseIntSign::Signed);
1824 
1825     return result;
1826 }
1827 
1828 template &lt;typename CharType&gt;
<span class="line-modified">1829 JSBigInt* JSBigInt::parseInt(ExecState* exec, VM&amp; vm, CharType* data, unsigned length, unsigned startIndex, unsigned radix, ErrorParseMode errorParseMode, ParseIntSign sign, ParseIntMode parseMode)</span>
1830 {
1831     ASSERT(length &gt;= 0);
1832     unsigned p = startIndex;
1833 
1834     auto scope = DECLARE_THROW_SCOPE(vm);
1835 
1836     if (parseMode != ParseIntMode::AllowEmptyString &amp;&amp; startIndex == length) {
<span class="line-modified">1837         ASSERT(exec);</span>
1838         if (errorParseMode == ErrorParseMode::ThrowExceptions)
<span class="line-modified">1839             throwVMError(exec, scope, createSyntaxError(exec, &quot;Failed to parse String to BigInt&quot;));</span>
1840         return nullptr;
1841     }
1842 
1843     // Skipping leading zeros
1844     while (p &lt; length &amp;&amp; data[p] == &#39;0&#39;)
1845         ++p;
1846 
1847     int endIndex = length - 1;
1848     // Removing trailing spaces
1849     while (endIndex &gt;= static_cast&lt;int&gt;(p) &amp;&amp; isStrWhiteSpace(data[endIndex]))
1850         --endIndex;
1851 
1852     length = endIndex + 1;
1853 
1854     if (p == length)
1855         return createZero(vm);
1856 
1857     unsigned limit0 = &#39;0&#39; + (radix &lt; 10 ? radix : 10);
1858     unsigned limita = &#39;a&#39; + (radix - 10);
1859     unsigned limitA = &#39;A&#39; + (radix - 10);
1860 
<span class="line-modified">1861     JSBigInt* result = allocateFor(exec, vm, radix, length - p);</span>
1862     RETURN_IF_EXCEPTION(scope, nullptr);



1863 
1864     result-&gt;initialize(InitializationType::WithZero);
1865 
1866     for (unsigned i = p; i &lt; length; i++, p++) {
1867         uint32_t digit;
1868         if (data[i] &gt;= &#39;0&#39; &amp;&amp; data[i] &lt; limit0)
1869             digit = data[i] - &#39;0&#39;;
1870         else if (data[i] &gt;= &#39;a&#39; &amp;&amp; data[i] &lt; limita)
1871             digit = data[i] - &#39;a&#39; + 10;
1872         else if (data[i] &gt;= &#39;A&#39; &amp;&amp; data[i] &lt; limitA)
1873             digit = data[i] - &#39;A&#39; + 10;
1874         else
1875             break;
1876 
1877         result-&gt;inplaceMultiplyAdd(static_cast&lt;Digit&gt;(radix), static_cast&lt;Digit&gt;(digit));
1878     }
1879 
1880     result-&gt;setSign(sign == ParseIntSign::Signed ? true : false);
1881     if (p == length)
1882         return result-&gt;rightTrim(vm);
1883 
<span class="line-modified">1884     ASSERT(exec);</span>
1885     if (errorParseMode == ErrorParseMode::ThrowExceptions)
<span class="line-modified">1886         throwVMError(exec, scope, createSyntaxError(exec, &quot;Failed to parse String to BigInt&quot;));</span>
1887 
1888     return nullptr;
1889 }
1890 
1891 inline JSBigInt::Digit JSBigInt::digit(unsigned n)
1892 {
1893     ASSERT(n &lt; length());
1894     return dataStorage()[n];
1895 }
1896 
1897 inline void JSBigInt::setDigit(unsigned n, Digit value)
1898 {
1899     ASSERT(n &lt; length());
1900     dataStorage()[n] = value;
1901 }
1902 
<span class="line-modified">1903 JSObject* JSBigInt::toObject(ExecState* exec, JSGlobalObject* globalObject) const</span>
1904 {
<span class="line-modified">1905     return BigIntObject::create(exec-&gt;vm(), globalObject, const_cast&lt;JSBigInt*&gt;(this));</span>
1906 }
1907 
1908 bool JSBigInt::equalsToNumber(JSValue numValue)
1909 {
1910     ASSERT(numValue.isNumber());
1911 
1912     if (numValue.isInt32()) {
1913         int value = numValue.asInt32();
1914         if (!value)
1915             return this-&gt;isZero();
1916 
1917         return (this-&gt;length() == 1) &amp;&amp; (this-&gt;sign() == (value &lt; 0)) &amp;&amp; (this-&gt;digit(0) == static_cast&lt;Digit&gt;(std::abs(static_cast&lt;int64_t&gt;(value))));
1918     }
1919 
1920     double value = numValue.asDouble();
1921     return compareToDouble(this, value) == ComparisonResult::Equal;
1922 }
1923 
1924 JSBigInt::ComparisonResult JSBigInt::compareToDouble(JSBigInt* x, double y)
1925 {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2017 Caio Lima &lt;ticaiolima@gmail.com&gt;
<span class="line-modified">   3  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.</span>
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  44  * [3] https://golang.org/LICENSE
  45  */
  46 
  47 #include &quot;config.h&quot;
  48 #include &quot;JSBigInt.h&quot;
  49 
  50 #include &quot;BigIntObject.h&quot;
  51 #include &quot;CatchScope.h&quot;
  52 #include &quot;JSCInlines.h&quot;
  53 #include &quot;MathCommon.h&quot;
  54 #include &quot;ParseInt.h&quot;
  55 #include &lt;algorithm&gt;
  56 #include &lt;wtf/MathExtras.h&gt;
  57 
  58 #define STATIC_ASSERT(cond) static_assert(cond, &quot;JSBigInt assumes &quot; #cond)
  59 
  60 namespace JSC {
  61 
  62 const ClassInfo JSBigInt::s_info = { &quot;BigInt&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSBigInt) };
  63 
<span class="line-modified">  64 JSBigInt::JSBigInt(VM&amp; vm, Structure* structure, Digit* data, unsigned length)</span>
  65     : Base(vm, structure)
  66     , m_length(length)
<span class="line-added">  67     , m_data(data, length)</span>
  68 { }
  69 
<span class="line-added">  70 void JSBigInt::destroy(JSCell* thisCell)</span>
<span class="line-added">  71 {</span>
<span class="line-added">  72     static_cast&lt;JSBigInt*&gt;(thisCell)-&gt;~JSBigInt();</span>
<span class="line-added">  73 }</span>
<span class="line-added">  74 </span>
  75 void JSBigInt::initialize(InitializationType initType)
  76 {
  77     if (initType == InitializationType::WithZero)
  78         memset(dataStorage(), 0, length() * sizeof(Digit));
  79 }
  80 
  81 Structure* JSBigInt::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  82 {
  83     return Structure::create(vm, globalObject, prototype, TypeInfo(BigIntType, StructureFlags), info());
  84 }
  85 
  86 JSBigInt* JSBigInt::createZero(VM&amp; vm)
  87 {
  88     JSBigInt* zeroBigInt = createWithLengthUnchecked(vm, 0);
  89     return zeroBigInt;
  90 }
  91 
<span class="line-modified">  92 JSBigInt* JSBigInt::tryCreateWithLength(JSGlobalObject* globalObject, unsigned length)</span>
  93 {
<span class="line-modified">  94     VM&amp; vm = globalObject-&gt;vm();</span>






  95     auto scope = DECLARE_THROW_SCOPE(vm);
  96 
  97     if (UNLIKELY(length &gt; maxLength)) {
<span class="line-modified">  98         throwOutOfMemoryError(globalObject, scope);</span>
  99         return nullptr;
 100     }
 101 
 102     scope.release();
 103 
 104     return createWithLengthUnchecked(vm, length);
 105 }
 106 
 107 JSBigInt* JSBigInt::createWithLengthUnchecked(VM&amp; vm, unsigned length)
 108 {
 109     ASSERT(length &lt;= maxLength);
<span class="line-modified"> 110     void* data = Gigacage::malloc(Gigacage::Primitive, length * sizeof(Digit));</span>
<span class="line-added"> 111     JSBigInt* bigInt = new (NotNull, allocateCell&lt;JSBigInt&gt;(vm.heap)) JSBigInt(vm, vm.bigIntStructure.get(), reinterpret_cast&lt;Digit*&gt;(data), length);</span>
 112     bigInt-&gt;finishCreation(vm);
 113     return bigInt;
 114 }
 115 
 116 JSBigInt* JSBigInt::createFrom(VM&amp; vm, int32_t value)
 117 {
 118     if (!value)
 119         return createZero(vm);
 120 
 121     JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
 122     if (value &lt; 0) {
 123         bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(-1 * static_cast&lt;int64_t&gt;(value)));
 124         bigInt-&gt;setSign(true);
 125     } else
 126         bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
 127 
 128     return bigInt;
 129 }
 130 
 131 JSBigInt* JSBigInt::createFrom(VM&amp; vm, uint32_t value)
</pre>
<hr />
<pre>
 166     Digit lowBits  = static_cast&lt;Digit&gt;(tempValue &amp; 0xffffffff);
 167     Digit highBits = static_cast&lt;Digit&gt;((tempValue &gt;&gt; 32) &amp; 0xffffffff);
 168 
 169     bigInt-&gt;setDigit(0, lowBits);
 170     bigInt-&gt;setDigit(1, highBits);
 171     bigInt-&gt;setSign(sign);
 172 
 173     return bigInt;
 174 }
 175 
 176 JSBigInt* JSBigInt::createFrom(VM&amp; vm, bool value)
 177 {
 178     if (!value)
 179         return createZero(vm);
 180 
 181     JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
 182     bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
 183     return bigInt;
 184 }
 185 
<span class="line-modified"> 186 JSValue JSBigInt::toPrimitive(JSGlobalObject*, PreferredPrimitiveType) const</span>
 187 {
 188     return const_cast&lt;JSBigInt*&gt;(this);
 189 }
 190 
 191 Optional&lt;uint8_t&gt; JSBigInt::singleDigitValueForString()
 192 {
 193     if (isZero())
 194         return 0;
 195 
 196     if (length() == 1 &amp;&amp; !sign()) {
 197         Digit rDigit = digit(0);
 198         if (rDigit &lt;= 9)
 199             return static_cast&lt;uint8_t&gt;(rDigit);
 200     }
 201     return { };
 202 }
 203 
<span class="line-modified"> 204 JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, StringView s, ErrorParseMode parserMode)</span>
 205 {
 206     if (s.is8Bit())
<span class="line-modified"> 207         return parseInt(globalObject, s.characters8(), s.length(), parserMode);</span>
<span class="line-modified"> 208     return parseInt(globalObject, s.characters16(), s.length(), parserMode);</span>
 209 }
 210 
<span class="line-modified"> 211 JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, VM&amp; vm, StringView s, uint8_t radix, ErrorParseMode parserMode, ParseIntSign sign)</span>
 212 {
 213     if (s.is8Bit())
<span class="line-modified"> 214         return parseInt(globalObject, vm, s.characters8(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);</span>
<span class="line-modified"> 215     return parseInt(globalObject, vm, s.characters16(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);</span>
 216 }
 217 
<span class="line-modified"> 218 JSBigInt* JSBigInt::stringToBigInt(JSGlobalObject* globalObject, StringView s)</span>
 219 {
<span class="line-modified"> 220     return parseInt(globalObject, s, ErrorParseMode::IgnoreExceptions);</span>
 221 }
 222 
<span class="line-modified"> 223 String JSBigInt::toString(JSGlobalObject* globalObject, unsigned radix)</span>
 224 {
 225     if (this-&gt;isZero())
<span class="line-modified"> 226         return globalObject-&gt;vm().smallStrings.singleCharacterStringRep(&#39;0&#39;);</span>
 227 
 228     if (hasOneBitSet(radix))
<span class="line-modified"> 229         return toStringBasePowerOfTwo(globalObject-&gt;vm(), globalObject, this, radix);</span>
 230 
<span class="line-modified"> 231     return toStringGeneric(globalObject-&gt;vm(), globalObject, this, radix);</span>
 232 }
 233 
 234 String JSBigInt::tryGetString(VM&amp; vm, JSBigInt* bigInt, unsigned radix)
 235 {
 236     if (bigInt-&gt;isZero())
 237         return vm.smallStrings.singleCharacterStringRep(&#39;0&#39;);
 238 
 239     if (hasOneBitSet(radix))
 240         return toStringBasePowerOfTwo(vm, nullptr, bigInt, radix);
 241 
 242     return toStringGeneric(vm, nullptr, bigInt, radix);
 243 }
 244 
 245 // Multiplies {this} with {factor} and adds {summand} to the result.
 246 void JSBigInt::inplaceMultiplyAdd(Digit factor, Digit summand)
 247 {
 248     internalMultiplyAdd(this, factor, summand, length(), this);
 249 }
 250 
<span class="line-modified"> 251 JSBigInt* JSBigInt::exponentiate(JSGlobalObject* globalObject, JSBigInt* base, JSBigInt* exponent)</span>
 252 {
<span class="line-modified"> 253     VM&amp; vm = globalObject-&gt;vm();</span>
 254     auto scope = DECLARE_THROW_SCOPE(vm);
 255 
 256     if (exponent-&gt;sign()) {
<span class="line-modified"> 257         throwRangeError(globalObject, scope, &quot;Negative exponent is not allowed&quot;_s);</span>
 258         return nullptr;
 259     }
 260 
 261     // 2. If base is 0n and exponent is 0n, return 1n.
 262     if (exponent-&gt;isZero())
 263         return JSBigInt::createFrom(vm, 1);
 264 
 265     // 3. Return a BigInt representing the mathematical value of base raised
 266     //    to the power exponent.
 267     if (base-&gt;isZero())
 268         return base;
 269 
 270     if (base-&gt;length() == 1 &amp;&amp; base-&gt;digit(0) == 1) {
 271         // (-1) ** even_number == 1.
 272         if (base-&gt;sign() &amp;&amp; !(exponent-&gt;digit(0) &amp; 1))
 273             return JSBigInt::unaryMinus(vm, base);
 274 
 275         // (-1) ** odd_number == -1; 1 ** anything == 1.
 276         return base;
 277     }
 278 
 279     // For all bases &gt;= 2, very large exponents would lead to unrepresentable
 280     // results.
 281     static_assert(maxLengthBits &lt; std::numeric_limits&lt;Digit&gt;::max(), &quot;maxLengthBits needs to be less than digit::max()&quot;);
 282     if (exponent-&gt;length() &gt; 1) {
<span class="line-modified"> 283         throwRangeError(globalObject, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
 284         return nullptr;
 285     }
 286 
 287     Digit expValue = exponent-&gt;digit(0);
 288     if (expValue == 1)
 289         return base;
 290     if (expValue &gt;= maxLengthBits) {
<span class="line-modified"> 291         throwRangeError(globalObject, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
 292         return nullptr;
 293     }
 294 
 295     static_assert(maxLengthBits &lt;= maxInt, &quot;maxLengthBits needs to be &lt;= maxInt&quot;);
 296     int n = static_cast&lt;int&gt;(expValue);
 297     if (base-&gt;length() == 1 &amp;&amp; base-&gt;digit(0) == 2) {
 298         // Fast path for 2^n.
 299         int neededDigits = 1 + (n / digitBits);
<span class="line-modified"> 300         JSBigInt* result = JSBigInt::tryCreateWithLength(globalObject, neededDigits);</span>
 301         RETURN_IF_EXCEPTION(scope, nullptr);
 302 
 303         result-&gt;initialize(InitializationType::WithZero);
 304         // All bits are zero. Now set the n-th bit.
 305         Digit msd = static_cast&lt;Digit&gt;(1) &lt;&lt; (n % digitBits);
 306         result-&gt;setDigit(neededDigits - 1, msd);
 307         // Result is negative for odd powers of -2n.
 308         if (base-&gt;sign())
 309             result-&gt;setSign(static_cast&lt;bool&gt;(n &amp; 1));
 310 
 311         return result;
 312     }
 313 
 314     JSBigInt* result = nullptr;
 315     JSBigInt* runningSquare = base;
 316 
 317     // This implicitly sets the result&#39;s sign correctly.
 318     if (n &amp; 1)
 319         result = base;
 320 
 321     n &gt;&gt;= 1;
 322     for (; n; n &gt;&gt;= 1) {
<span class="line-modified"> 323         JSBigInt* maybeResult = JSBigInt::multiply(globalObject, runningSquare, runningSquare);</span>
 324         RETURN_IF_EXCEPTION(scope, nullptr);
 325         runningSquare = maybeResult;
 326         if (n &amp; 1) {
 327             if (!result)
 328                 result = runningSquare;
 329             else {
<span class="line-modified"> 330                 maybeResult = JSBigInt::multiply(globalObject, result, runningSquare);</span>
 331                 RETURN_IF_EXCEPTION(scope, nullptr);
 332                 result = maybeResult;
 333             }
 334         }
 335     }
 336 
 337     return result;
 338 }
 339 
<span class="line-modified"> 340 JSBigInt* JSBigInt::multiply(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 341 {
<span class="line-modified"> 342     VM&amp; vm = globalObject-&gt;vm();</span>
 343     auto scope = DECLARE_THROW_SCOPE(vm);
 344 
 345     if (x-&gt;isZero())
 346         return x;
 347     if (y-&gt;isZero())
 348         return y;
 349 
 350     unsigned resultLength = x-&gt;length() + y-&gt;length();
<span class="line-modified"> 351     JSBigInt* result = JSBigInt::tryCreateWithLength(globalObject, resultLength);</span>
 352     RETURN_IF_EXCEPTION(scope, nullptr);
 353     result-&gt;initialize(InitializationType::WithZero);
 354 
 355     for (unsigned i = 0; i &lt; x-&gt;length(); i++)
 356         multiplyAccumulate(y, x-&gt;digit(i), result, i);
 357 
 358     result-&gt;setSign(x-&gt;sign() != y-&gt;sign());
 359     return result-&gt;rightTrim(vm);
 360 }
 361 
<span class="line-modified"> 362 JSBigInt* JSBigInt::divide(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 363 {
 364     // 1. If y is 0n, throw a RangeError exception.
<span class="line-modified"> 365     VM&amp; vm = globalObject-&gt;vm();</span>
 366     auto scope = DECLARE_THROW_SCOPE(vm);
 367 
 368     if (y-&gt;isZero()) {
<span class="line-modified"> 369         throwRangeError(globalObject, scope, &quot;0 is an invalid divisor value.&quot;_s);</span>
 370         return nullptr;
 371     }
 372 
 373     // 2. Let quotient be the mathematical value of x divided by y.
 374     // 3. Return a BigInt representing quotient rounded towards 0 to the next
 375     //    integral value.
 376     if (absoluteCompare(x, y) == ComparisonResult::LessThan)
 377         return createZero(vm);
 378 
 379     JSBigInt* quotient = nullptr;
 380     bool resultSign = x-&gt;sign() != y-&gt;sign();
 381     if (y-&gt;length() == 1) {
 382         Digit divisor = y-&gt;digit(0);
 383         if (divisor == 1)
 384             return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
 385 
 386         Digit remainder;
 387         absoluteDivWithDigitDivisor(vm, x, divisor, &amp;quotient, remainder);
 388     } else {
<span class="line-modified"> 389         absoluteDivWithBigIntDivisor(globalObject, x, y, &amp;quotient, nullptr);</span>
 390         RETURN_IF_EXCEPTION(scope, nullptr);
 391     }
 392 
 393     quotient-&gt;setSign(resultSign);
 394     return quotient-&gt;rightTrim(vm);
 395 }
 396 
 397 JSBigInt* JSBigInt::copy(VM&amp; vm, JSBigInt* x)
 398 {
 399     ASSERT(!x-&gt;isZero());
 400 
 401     JSBigInt* result = JSBigInt::createWithLengthUnchecked(vm, x-&gt;length());
 402     std::copy(x-&gt;dataStorage(), x-&gt;dataStorage() + x-&gt;length(), result-&gt;dataStorage());
 403     result-&gt;setSign(x-&gt;sign());
 404     return result;
 405 }
 406 
 407 JSBigInt* JSBigInt::unaryMinus(VM&amp; vm, JSBigInt* x)
 408 {
 409     if (x-&gt;isZero())
 410         return x;
 411 
 412     JSBigInt* result = copy(vm, x);
 413     result-&gt;setSign(!x-&gt;sign());
 414     return result;
 415 }
 416 
<span class="line-modified"> 417 JSBigInt* JSBigInt::remainder(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 418 {
 419     // 1. If y is 0n, throw a RangeError exception.
<span class="line-modified"> 420     VM&amp; vm = globalObject-&gt;vm();</span>
 421     auto scope = DECLARE_THROW_SCOPE(vm);
 422 
 423     if (y-&gt;isZero()) {
<span class="line-modified"> 424         throwRangeError(globalObject, scope, &quot;0 is an invalid divisor value.&quot;_s);</span>
 425         return nullptr;
 426     }
 427 
 428     // 2. Return the JSBigInt representing x modulo y.
 429     // See https://github.com/tc39/proposal-bigint/issues/84 though.
 430     if (absoluteCompare(x, y) == ComparisonResult::LessThan)
 431         return x;
 432 
 433     JSBigInt* remainder;
 434     if (y-&gt;length() == 1) {
 435         Digit divisor = y-&gt;digit(0);
 436         if (divisor == 1)
 437             return createZero(vm);
 438 
 439         Digit remainderDigit;
 440         absoluteDivWithDigitDivisor(vm, x, divisor, nullptr, remainderDigit);
 441         if (!remainderDigit)
 442             return createZero(vm);
 443 
 444         remainder = createWithLengthUnchecked(vm, 1);
 445         remainder-&gt;setDigit(0, remainderDigit);
 446     } else {
<span class="line-modified"> 447         absoluteDivWithBigIntDivisor(globalObject, x, y, nullptr, &amp;remainder);</span>
 448         RETURN_IF_EXCEPTION(scope, nullptr);
 449     }
 450 
 451     remainder-&gt;setSign(x-&gt;sign());
 452     return remainder-&gt;rightTrim(vm);
 453 }
 454 
<span class="line-modified"> 455 JSBigInt* JSBigInt::inc(JSGlobalObject* globalObject, JSBigInt* x)</span>
<span class="line-added"> 456 {</span>
<span class="line-added"> 457     // FIXME: we can probably do something a fair bit more efficient here</span>
<span class="line-added"> 458     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 459     return add(globalObject, x, vm.bigIntConstantOne.get());</span>
<span class="line-added"> 460 }</span>
<span class="line-added"> 461 </span>
<span class="line-added"> 462 JSBigInt* JSBigInt::dec(JSGlobalObject* globalObject, JSBigInt* x)</span>
 463 {
<span class="line-modified"> 464     // FIXME: we can probably do something a fair bit more efficient here</span>
<span class="line-added"> 465     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 466     return sub(globalObject, x, vm.bigIntConstantOne.get());</span>
<span class="line-added"> 467 }</span>
<span class="line-added"> 468 </span>
<span class="line-added"> 469 JSBigInt* JSBigInt::add(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
<span class="line-added"> 470 {</span>
<span class="line-added"> 471     VM&amp; vm = globalObject-&gt;vm();</span>
 472     bool xSign = x-&gt;sign();
 473 
 474     // x + y == x + y
 475     // -x + -y == -(x + y)
 476     if (xSign == y-&gt;sign())
<span class="line-modified"> 477         return absoluteAdd(globalObject, x, y, xSign);</span>
 478 
 479     // x + -y == x - y == -(y - x)
 480     // -x + y == y - x == -(x - y)
 481     ComparisonResult comparisonResult = absoluteCompare(x, y);
 482     if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
 483         return absoluteSub(vm, x, y, xSign);
 484 
 485     return absoluteSub(vm, y, x, !xSign);
 486 }
 487 
<span class="line-modified"> 488 JSBigInt* JSBigInt::sub(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 489 {
<span class="line-modified"> 490     VM&amp; vm = globalObject-&gt;vm();</span>
 491     bool xSign = x-&gt;sign();
 492     if (xSign != y-&gt;sign()) {
 493         // x - (-y) == x + y
 494         // (-x) - y == -(x + y)
<span class="line-modified"> 495         return absoluteAdd(globalObject, x, y, xSign);</span>
 496     }
 497     // x - y == -(y - x)
 498     // (-x) - (-y) == y - x == -(x - y)
 499     ComparisonResult comparisonResult = absoluteCompare(x, y);
 500     if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
 501         return absoluteSub(vm, x, y, xSign);
 502 
 503     return absoluteSub(vm, y, x, !xSign);
 504 }
 505 
<span class="line-modified"> 506 JSBigInt* JSBigInt::bitwiseAnd(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 507 {
<span class="line-modified"> 508     VM&amp; vm = globalObject-&gt;vm();</span>
 509     auto scope = DECLARE_THROW_SCOPE(vm);
 510 
 511     if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
 512         scope.release();
 513         return absoluteAnd(vm, x, y);
 514     }
 515 
 516     if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
 517         int resultLength = std::max(x-&gt;length(), y-&gt;length()) + 1;
 518         // (-x) &amp; (-y) == ~(x-1) &amp; ~(y-1) == ~((x-1) | (y-1))
 519         // == -(((x-1) | (y-1)) + 1)
<span class="line-modified"> 520         JSBigInt* result = absoluteSubOne(globalObject, x, resultLength);</span>
 521         RETURN_IF_EXCEPTION(scope, nullptr);
 522 
<span class="line-modified"> 523         JSBigInt* y1 = absoluteSubOne(globalObject, y, y-&gt;length());</span>
 524         RETURN_IF_EXCEPTION(scope, nullptr);
 525         result = absoluteOr(vm, result, y1);
 526         scope.release();
<span class="line-modified"> 527         return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
 528     }
 529 
 530     ASSERT(x-&gt;sign() != y-&gt;sign());
 531     // Assume that x is the positive BigInt.
 532     if (x-&gt;sign())
 533         std::swap(x, y);
 534 
 535     // x &amp; (-y) == x &amp; ~(y-1) == x &amp; ~(y-1)
<span class="line-modified"> 536     JSBigInt* y1 = absoluteSubOne(globalObject, y, y-&gt;length());</span>
 537     RETURN_IF_EXCEPTION(scope, nullptr);
 538     return absoluteAndNot(vm, x, y1);
 539 }
 540 
<span class="line-modified"> 541 JSBigInt* JSBigInt::bitwiseOr(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 542 {
<span class="line-modified"> 543     VM&amp; vm = globalObject-&gt;vm();</span>
 544     auto scope = DECLARE_THROW_SCOPE(vm);
 545 
 546     unsigned resultLength = std::max(x-&gt;length(), y-&gt;length());
 547 
 548     if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
 549         scope.release();
 550         return absoluteOr(vm, x, y);
 551     }
 552 
 553     if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
 554         // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) &amp; (y-1))
 555         // == -(((x-1) &amp; (y-1)) + 1)
<span class="line-modified"> 556         JSBigInt* result = absoluteSubOne(globalObject, x, resultLength);</span>
 557         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 558         JSBigInt* y1 = absoluteSubOne(globalObject, y, y-&gt;length());</span>
 559         RETURN_IF_EXCEPTION(scope, nullptr);
 560         result = absoluteAnd(vm, result, y1);
 561         RETURN_IF_EXCEPTION(scope, nullptr);
 562 
 563         scope.release();
<span class="line-modified"> 564         return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
 565     }
 566 
 567     ASSERT(x-&gt;sign() != y-&gt;sign());
 568 
 569     // Assume that x is the positive BigInt.
 570     if (x-&gt;sign())
 571         std::swap(x, y);
 572 
 573     // x | (-y) == x | ~(y-1) == ~((y-1) &amp;~ x) == -(((y-1) &amp;~ x) + 1)
<span class="line-modified"> 574     JSBigInt* result = absoluteSubOne(globalObject, y, resultLength);</span>
 575     RETURN_IF_EXCEPTION(scope, nullptr);
 576     result = absoluteAndNot(vm, result, x);
 577 
 578     scope.release();
<span class="line-modified"> 579     return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
 580 }
 581 
<span class="line-modified"> 582 JSBigInt* JSBigInt::bitwiseXor(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 583 {
<span class="line-modified"> 584     VM&amp; vm = globalObject-&gt;vm();</span>
 585     auto scope = DECLARE_THROW_SCOPE(vm);
 586 
 587     if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
 588         scope.release();
 589         return absoluteXor(vm, x, y);
 590     }
 591 
 592     if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
 593         int resultLength = std::max(x-&gt;length(), y-&gt;length());
 594 
 595         // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)
<span class="line-modified"> 596         JSBigInt* result = absoluteSubOne(globalObject, x, resultLength);</span>
 597         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 598         JSBigInt* y1 = absoluteSubOne(globalObject, y, y-&gt;length());</span>
 599         RETURN_IF_EXCEPTION(scope, nullptr);
 600 
 601         scope.release();
 602         return absoluteXor(vm, result, y1);
 603     }
 604     ASSERT(x-&gt;sign() != y-&gt;sign());
 605     int resultLength = std::max(x-&gt;length(), y-&gt;length()) + 1;
 606 
 607     // Assume that x is the positive BigInt.
 608     if (x-&gt;sign())
 609         std::swap(x, y);
 610 
 611     // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)
<span class="line-modified"> 612     JSBigInt* result = absoluteSubOne(globalObject, y, resultLength);</span>
 613     RETURN_IF_EXCEPTION(scope, nullptr);
 614 
 615     result = absoluteXor(vm, result, x);
 616     scope.release();
<span class="line-modified"> 617     return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
 618 }
 619 
<span class="line-modified"> 620 JSBigInt* JSBigInt::leftShift(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 621 {
 622     if (y-&gt;isZero() || x-&gt;isZero())
 623         return x;
 624 
 625     if (y-&gt;sign())
<span class="line-modified"> 626         return rightShiftByAbsolute(globalObject, x, y);</span>
 627 
<span class="line-modified"> 628     return leftShiftByAbsolute(globalObject, x, y);</span>
 629 }
 630 
<span class="line-modified"> 631 JSBigInt* JSBigInt::signedRightShift(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 632 {
 633     if (y-&gt;isZero() || x-&gt;isZero())
 634         return x;
 635 
 636     if (y-&gt;sign())
<span class="line-modified"> 637         return leftShiftByAbsolute(globalObject, x, y);</span>
 638 
<span class="line-modified"> 639     return rightShiftByAbsolute(globalObject, x, y);</span>
 640 }
 641 
<span class="line-modified"> 642 JSBigInt* JSBigInt::bitwiseNot(JSGlobalObject* globalObject, JSBigInt* x)</span>
 643 {
 644     if (x-&gt;sign()) {
 645         // ~(-x) == ~(~(x-1)) == x-1
<span class="line-modified"> 646         return absoluteSubOne(globalObject, x, x-&gt;length());</span>
 647     }
 648     // ~x == -x-1 == -(x+1)
<span class="line-modified"> 649     return absoluteAddOne(globalObject, x, SignOption::Signed);</span>
 650 }
 651 
 652 #if USE(JSVALUE32_64)
 653 #define HAVE_TWO_DIGIT 1
 654 typedef uint64_t TwoDigit;
 655 #elif HAVE(INT128_T)
 656 #define HAVE_TWO_DIGIT 1
 657 typedef __uint128_t TwoDigit;
 658 #else
 659 #define HAVE_TWO_DIGIT 0
 660 #endif
 661 
 662 // {carry} must point to an initialized Digit and will either be incremented
 663 // by one or left alone.
 664 inline JSBigInt::Digit JSBigInt::digitAdd(Digit a, Digit b, Digit&amp; carry)
 665 {
 666     Digit result = a + b;
 667     carry += static_cast&lt;bool&gt;(result &lt; a);
 668     return result;
 669 }
</pre>
<hr />
<pre>
 925 
 926 inline JSBigInt::ComparisonResult JSBigInt::absoluteCompare(JSBigInt* x, JSBigInt* y)
 927 {
 928     ASSERT(!x-&gt;length() || x-&gt;digit(x-&gt;length() - 1));
 929     ASSERT(!y-&gt;length() || y-&gt;digit(y-&gt;length() - 1));
 930 
 931     int diff = x-&gt;length() - y-&gt;length();
 932     if (diff)
 933         return diff &lt; 0 ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
 934 
 935     int i = x-&gt;length() - 1;
 936     while (i &gt;= 0 &amp;&amp; x-&gt;digit(i) == y-&gt;digit(i))
 937         i--;
 938 
 939     if (i &lt; 0)
 940         return ComparisonResult::Equal;
 941 
 942     return x-&gt;digit(i) &gt; y-&gt;digit(i) ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
 943 }
 944 
<span class="line-modified"> 945 JSBigInt* JSBigInt::absoluteAdd(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y, bool resultSign)</span>
 946 {
<span class="line-modified"> 947     VM&amp; vm = globalObject-&gt;vm();</span>
 948 
 949     if (x-&gt;length() &lt; y-&gt;length())
<span class="line-modified"> 950         return absoluteAdd(globalObject, y, x, resultSign);</span>
 951 
 952     if (x-&gt;isZero()) {
 953         ASSERT(y-&gt;isZero());
 954         return x;
 955     }
 956 
 957     if (y-&gt;isZero())
 958         return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
 959 
<span class="line-modified"> 960     JSBigInt* result = JSBigInt::tryCreateWithLength(globalObject, x-&gt;length() + 1);</span>
 961     if (!result)
 962         return nullptr;
 963     Digit carry = 0;
 964     unsigned i = 0;
 965     for (; i &lt; y-&gt;length(); i++) {
 966         Digit newCarry = 0;
 967         Digit sum = digitAdd(x-&gt;digit(i), y-&gt;digit(i), newCarry);
 968         sum = digitAdd(sum, carry, newCarry);
 969         result-&gt;setDigit(i, sum);
 970         carry = newCarry;
 971     }
 972 
 973     for (; i &lt; x-&gt;length(); i++) {
 974         Digit newCarry = 0;
 975         Digit sum = digitAdd(x-&gt;digit(i), carry, newCarry);
 976         result-&gt;setDigit(i, sum);
 977         carry = newCarry;
 978     }
 979 
 980     result-&gt;setDigit(i, carry);
</pre>
<hr />
<pre>
1047     if (quotient != nullptr) {
1048         if (*quotient == nullptr)
1049             *quotient = JSBigInt::createWithLengthUnchecked(vm, length);
1050 
1051         for (int i = length - 1; i &gt;= 0; i--) {
1052             Digit q = digitDiv(remainder, x-&gt;digit(i), divisor, remainder);
1053             (*quotient)-&gt;setDigit(i, q);
1054         }
1055     } else {
1056         for (int i = length - 1; i &gt;= 0; i--)
1057             digitDiv(remainder, x-&gt;digit(i), divisor, remainder);
1058     }
1059 }
1060 
1061 // Divides {dividend} by {divisor}, returning the result in {quotient} and
1062 // {remainder}. Mathematically, the contract is:
1063 // quotient = (dividend - remainder) / divisor, with 0 &lt;= remainder &lt; divisor.
1064 // Both {quotient} and {remainder} are optional, for callers that are only
1065 // interested in one of them.
1066 // See Knuth, Volume 2, section 4.3.1, Algorithm D.
<span class="line-modified">1067 void JSBigInt::absoluteDivWithBigIntDivisor(JSGlobalObject* globalObject, JSBigInt* dividend, JSBigInt* divisor, JSBigInt** quotient, JSBigInt** remainder)</span>
1068 {
1069     ASSERT(divisor-&gt;length() &gt;= 2);
1070     ASSERT(dividend-&gt;length() &gt;= divisor-&gt;length());
<span class="line-modified">1071     VM&amp; vm = globalObject-&gt;vm();</span>
1072     auto scope = DECLARE_THROW_SCOPE(vm);
1073 
1074     // The unusual variable names inside this function are consistent with
1075     // Knuth&#39;s book, as well as with Go&#39;s implementation of this algorithm.
1076     // Maintaining this consistency is probably more useful than trying to
1077     // come up with more descriptive names for them.
1078     unsigned n = divisor-&gt;length();
1079     unsigned m = dividend-&gt;length() - n;
1080 
1081     // The quotient to be computed.
1082     JSBigInt* q = nullptr;
1083     if (quotient != nullptr)
<span class="line-modified">1084         q = createWithLengthUnchecked(globalObject-&gt;vm(), m + 1);</span>
1085 
1086     // In each iteration, {qhatv} holds {divisor} * {current quotient digit}.
1087     // &quot;v&quot; is the book&#39;s name for {divisor}, &quot;qhat&quot; the current quotient digit.
<span class="line-modified">1088     JSBigInt* qhatv = tryCreateWithLength(globalObject, n + 1);</span>
1089     RETURN_IF_EXCEPTION(scope, void());
1090 
1091     // D1.
1092     // Left-shift inputs so that the divisor&#39;s MSB is set. This is necessary
1093     // to prevent the digit-wise divisions (see digit_div call below) from
1094     // overflowing (they take a two digits wide input, and return a one digit
1095     // result).
1096     Digit lastDigit = divisor-&gt;digit(n - 1);
1097     unsigned shift = clz(lastDigit);
1098 
1099     if (shift &gt; 0) {
<span class="line-modified">1100         divisor = absoluteLeftShiftAlwaysCopy(globalObject, divisor, shift, LeftShiftMode::SameSizeResult);</span>
1101         RETURN_IF_EXCEPTION(scope, void());
1102     }
1103 
1104     // Holds the (continuously updated) remaining part of the dividend, which
1105     // eventually becomes the remainder.
<span class="line-modified">1106     JSBigInt* u = absoluteLeftShiftAlwaysCopy(globalObject, dividend, shift, LeftShiftMode::AlwaysAddOneDigit);</span>
1107     RETURN_IF_EXCEPTION(scope, void());
1108 
1109     // D2.
1110     // Iterate over the dividend&#39;s digit (like the &quot;grad school&quot; algorithm).
1111     // {vn1} is the divisor&#39;s most significant digit.
1112     Digit vn1 = divisor-&gt;digit(n - 1);
1113     for (int j = m; j &gt;= 0; j--) {
1114         // D3.
1115         // Estimate the current iteration&#39;s quotient digit (see Knuth for details).
1116         // {qhat} is the current quotient digit.
1117         Digit qhat = std::numeric_limits&lt;Digit&gt;::max();
1118 
1119         // {ujn} is the dividend&#39;s most significant remaining digit.
1120         Digit ujn = u-&gt;digit(j + n);
1121         if (ujn != vn1) {
1122             // {rhat} is the current iteration&#39;s remainder.
1123             Digit rhat = 0;
1124             // Estimate the current quotient digit by dividing the most significant
1125             // digits of dividend and divisor. The result will not be too small,
1126             // but could be a bit too large.
</pre>
<hr />
<pre>
1215 
1216 void JSBigInt::inplaceRightShift(unsigned shift)
1217 {
1218     ASSERT(shift &lt; digitBits);
1219     ASSERT(!(digit(0) &amp; ((static_cast&lt;Digit&gt;(1) &lt;&lt; shift) - 1)));
1220 
1221     if (!shift)
1222         return;
1223 
1224     Digit carry = digit(0) &gt;&gt; shift;
1225     unsigned last = length() - 1;
1226     for (unsigned i = 0; i &lt; last; i++) {
1227         Digit d = digit(i + 1);
1228         setDigit(i, (d &lt;&lt; (digitBits - shift)) | carry);
1229         carry = d &gt;&gt; shift;
1230     }
1231     setDigit(last, carry);
1232 }
1233 
1234 // Always copies the input, even when {shift} == 0.
<span class="line-modified">1235 JSBigInt* JSBigInt::absoluteLeftShiftAlwaysCopy(JSGlobalObject* globalObject, JSBigInt* x, unsigned shift, LeftShiftMode mode)</span>
1236 {
1237     ASSERT(shift &lt; digitBits);
1238     ASSERT(!x-&gt;isZero());
1239 
1240     unsigned n = x-&gt;length();
1241     unsigned resultLength = mode == LeftShiftMode::AlwaysAddOneDigit ? n + 1 : n;
<span class="line-modified">1242     JSBigInt* result = tryCreateWithLength(globalObject, resultLength);</span>
1243     if (!result)
1244         return nullptr;
1245 
1246     if (!shift) {
1247         for (unsigned i = 0; i &lt; n; i++)
1248             result-&gt;setDigit(i, x-&gt;digit(i));
1249         if (mode == LeftShiftMode::AlwaysAddOneDigit)
1250             result-&gt;setDigit(n, 0);
1251 
1252         return result;
1253     }
1254 
1255     Digit carry = 0;
1256     for (unsigned i = 0; i &lt; n; i++) {
1257         Digit d = x-&gt;digit(i);
1258         result-&gt;setDigit(i, (d &lt;&lt; shift) | carry);
1259         carry = d &gt;&gt; (digitBits - shift);
1260     }
1261 
1262     if (mode == LeftShiftMode::AlwaysAddOneDigit)
</pre>
<hr />
<pre>
1329     };
1330     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::Symmetric, digitOperation);
1331 }
1332 
1333 JSBigInt* JSBigInt::absoluteAndNot(VM&amp; vm, JSBigInt* x, JSBigInt* y)
1334 {
1335     auto digitOperation = [](Digit a, Digit b) {
1336         return a &amp; ~b;
1337     };
1338     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::NotSymmetric, digitOperation);
1339 }
1340 
1341 JSBigInt* JSBigInt::absoluteXor(VM&amp; vm, JSBigInt* x, JSBigInt* y)
1342 {
1343     auto digitOperation = [](Digit a, Digit b) {
1344         return a ^ b;
1345     };
1346     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::Symmetric, digitOperation);
1347 }
1348 
<span class="line-modified">1349 JSBigInt* JSBigInt::absoluteAddOne(JSGlobalObject* globalObject, JSBigInt* x, SignOption signOption)</span>
1350 {
1351     unsigned inputLength = x-&gt;length();
1352     // The addition will overflow into a new digit if all existing digits are
1353     // at maximum.
1354     bool willOverflow = true;
1355     for (unsigned i = 0; i &lt; inputLength; i++) {
1356         if (std::numeric_limits&lt;Digit&gt;::max() != x-&gt;digit(i)) {
1357             willOverflow = false;
1358             break;
1359         }
1360     }
1361 
1362     unsigned resultLength = inputLength + willOverflow;
<span class="line-modified">1363     JSBigInt* result = tryCreateWithLength(globalObject, resultLength);</span>
1364     if (!result)
1365         return nullptr;
1366 
1367     Digit carry = 1;
1368     for (unsigned i = 0; i &lt; inputLength; i++) {
1369         Digit newCarry = 0;
1370         result-&gt;setDigit(i, digitAdd(x-&gt;digit(i), carry, newCarry));
1371         carry = newCarry;
1372     }
1373     if (resultLength &gt; inputLength)
1374         result-&gt;setDigit(inputLength, carry);
1375     else
1376         ASSERT(!carry);
1377 
1378     result-&gt;setSign(signOption == SignOption::Signed);
<span class="line-modified">1379     return result-&gt;rightTrim(globalObject-&gt;vm());</span>
1380 }
1381 
<span class="line-modified">1382 JSBigInt* JSBigInt::absoluteSubOne(JSGlobalObject* globalObject, JSBigInt* x, unsigned resultLength)</span>
1383 {
1384     ASSERT(!x-&gt;isZero());
1385     ASSERT(resultLength &gt;= x-&gt;length());
<span class="line-modified">1386     VM&amp; vm = globalObject-&gt;vm();</span>
1387     auto scope = DECLARE_THROW_SCOPE(vm);
1388 
<span class="line-modified">1389     JSBigInt* result = tryCreateWithLength(globalObject, resultLength);</span>
1390     RETURN_IF_EXCEPTION(scope, nullptr);
1391 
1392     unsigned length = x-&gt;length();
1393     Digit borrow = 1;
1394     for (unsigned i = 0; i &lt; length; i++) {
1395         Digit newBorrow = 0;
1396         result-&gt;setDigit(i, digitSub(x-&gt;digit(i), borrow, newBorrow));
1397         borrow = newBorrow;
1398     }
1399     ASSERT(!borrow);
1400     for (unsigned i = length; i &lt; resultLength; i++)
1401         result-&gt;setDigit(i, borrow);
1402 
1403     return result-&gt;rightTrim(vm);
1404 }
1405 
<span class="line-modified">1406 JSBigInt* JSBigInt::leftShiftByAbsolute(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
1407 {
<span class="line-modified">1408     VM&amp; vm = globalObject-&gt;vm();</span>
1409     auto scope = DECLARE_THROW_SCOPE(vm);
1410 
1411     auto optionalShift = toShiftAmount(y);
1412     if (!optionalShift) {
<span class="line-modified">1413         throwRangeError(globalObject, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
1414         return nullptr;
1415     }
1416 
1417     Digit shift = *optionalShift;
1418     unsigned digitShift = static_cast&lt;unsigned&gt;(shift / digitBits);
1419     unsigned bitsShift = static_cast&lt;unsigned&gt;(shift % digitBits);
1420     unsigned length = x-&gt;length();
1421     bool grow = bitsShift &amp;&amp; (x-&gt;digit(length - 1) &gt;&gt; (digitBits - bitsShift));
1422     int resultLength = length + digitShift + grow;
1423     if (static_cast&lt;unsigned&gt;(resultLength) &gt; maxLength) {
<span class="line-modified">1424         throwRangeError(globalObject, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
1425         return nullptr;
1426     }
1427 
<span class="line-modified">1428     JSBigInt* result = tryCreateWithLength(globalObject, resultLength);</span>
1429     RETURN_IF_EXCEPTION(scope, nullptr);
1430     if (!bitsShift) {
1431         unsigned i = 0;
1432         for (; i &lt; digitShift; i++)
1433             result-&gt;setDigit(i, 0ul);
1434 
1435         for (; i &lt; static_cast&lt;unsigned&gt;(resultLength); i++)
1436             result-&gt;setDigit(i, x-&gt;digit(i - digitShift));
1437     } else {
1438         Digit carry = 0;
1439         for (unsigned i = 0; i &lt; digitShift; i++)
1440             result-&gt;setDigit(i, 0ul);
1441 
1442         for (unsigned i = 0; i &lt; length; i++) {
1443             Digit d = x-&gt;digit(i);
1444             result-&gt;setDigit(i + digitShift, (d &lt;&lt; bitsShift) | carry);
1445             carry = d &gt;&gt; (digitBits - bitsShift);
1446         }
1447 
1448         if (grow)
1449             result-&gt;setDigit(length + digitShift, carry);
1450         else
1451             ASSERT(!carry);
1452     }
1453 
1454     result-&gt;setSign(x-&gt;sign());
1455     return result-&gt;rightTrim(vm);
1456 }
1457 
<span class="line-modified">1458 JSBigInt* JSBigInt::rightShiftByAbsolute(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
1459 {
<span class="line-modified">1460     VM&amp; vm = globalObject-&gt;vm();</span>
1461     unsigned length = x-&gt;length();
1462     bool sign = x-&gt;sign();
1463     auto optionalShift = toShiftAmount(y);
1464     if (!optionalShift)
1465         return rightShiftByMaximum(vm, sign);
1466 
1467     Digit shift = *optionalShift;
1468     unsigned digitalShift = static_cast&lt;unsigned&gt;(shift / digitBits);
1469     unsigned bitsShift = static_cast&lt;unsigned&gt;(shift % digitBits);
1470     int resultLength = length - digitalShift;
1471     if (resultLength &lt;= 0)
1472         return rightShiftByMaximum(vm, sign);
1473 
1474     // For negative numbers, round down if any bit was shifted out (so that e.g.
1475     // -5n &gt;&gt; 1n == -3n and not -2n). Check now whether this will happen and
1476     // whether it can cause overflow into a new digit. If we allocate the result
1477     // large enough up front, it avoids having to do a second allocation later.
1478     bool mustRoundDown = false;
1479     if (sign) {
1480         const Digit mask = (static_cast&lt;Digit&gt;(1) &lt;&lt; bitsShift) - 1;
</pre>
<hr />
<pre>
1504     if (!bitsShift) {
1505         for (unsigned i = digitalShift; i &lt; length; i++)
1506             result-&gt;setDigit(i - digitalShift, x-&gt;digit(i));
1507     } else {
1508         Digit carry = x-&gt;digit(digitalShift) &gt;&gt; bitsShift;
1509         unsigned last = length - digitalShift - 1;
1510         for (unsigned i = 0; i &lt; last; i++) {
1511             Digit d = x-&gt;digit(i + digitalShift + 1);
1512             result-&gt;setDigit(i, (d &lt;&lt; (digitBits - bitsShift)) | carry);
1513             carry = d &gt;&gt; bitsShift;
1514         }
1515         result-&gt;setDigit(last, carry);
1516     }
1517 
1518     if (sign) {
1519         result-&gt;setSign(true);
1520         if (mustRoundDown) {
1521             // Since the result is negative, rounding down means adding one to
1522             // its absolute value. This cannot overflow.
1523             result = result-&gt;rightTrim(vm);
<span class="line-modified">1524             return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
1525         }
1526     }
1527 
1528     return result-&gt;rightTrim(vm);
1529 }
1530 
1531 JSBigInt* JSBigInt::rightShiftByMaximum(VM&amp; vm, bool sign)
1532 {
1533     if (sign)
1534         return createFrom(vm, -1);
1535 
1536     return createZero(vm);
1537 }
1538 
1539 // Lookup table for the maximum number of bits required per character of a
1540 // base-N string representation of a number. To increase accuracy, the array
1541 // value is the actual value multiplied by 32. To generate this table:
1542 // for (var i = 0; i &lt;= 36; i++) { print(Math.ceil(Math.log2(i) * 32) + &quot;,&quot;); }
1543 constexpr uint8_t maxBitsPerCharTable[] = {
1544     0,   0,   32,  51,  64,  75,  83,  90,  96, // 0..8
</pre>
<hr />
<pre>
1562     // Maximum number of bits we can represent with one character. We&#39;ll use this
1563     // to find an appropriate chunk size below.
1564     uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
1565 
1566     // For estimating result length, we have to be pessimistic and work with
1567     // the minimum number of bits one character can represent.
1568     uint8_t minBitsPerChar = maxBitsPerChar - 1;
1569 
1570     // Perform the following computation with uint64_t to avoid overflows.
1571     uint64_t maximumCharactersRequired = bitLength;
1572     maximumCharactersRequired *= bitsPerCharTableMultiplier;
1573 
1574     // Round up.
1575     maximumCharactersRequired += minBitsPerChar - 1;
1576     maximumCharactersRequired /= minBitsPerChar;
1577     maximumCharactersRequired += sign;
1578 
1579     return maximumCharactersRequired;
1580 }
1581 
<span class="line-modified">1582 String JSBigInt::toStringBasePowerOfTwo(VM&amp; vm, JSGlobalObject* globalObject, JSBigInt* x, unsigned radix)</span>
1583 {
1584     ASSERT(hasOneBitSet(radix));
1585     ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 32);
1586     ASSERT(!x-&gt;isZero());
1587 
1588     const unsigned length = x-&gt;length();
1589     const bool sign = x-&gt;sign();
1590     const unsigned bitsPerChar = ctz(radix);
1591     const unsigned charMask = radix - 1;
1592     // Compute the length of the resulting string: divide the bit length of the
1593     // BigInt by the number of bits representable per character (rounding up).
1594     const Digit msd = x-&gt;digit(length - 1);
1595 
1596     const unsigned msdLeadingZeros = clz(msd);
1597 
1598     const size_t bitLength = length * digitBits - msdLeadingZeros;
1599     const size_t charsRequired = (bitLength + bitsPerChar - 1) / bitsPerChar + sign;
1600 
1601     if (charsRequired &gt; JSString::MaxLength) {
<span class="line-modified">1602         if (globalObject) {</span>
1603             auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1604             throwOutOfMemoryError(globalObject, scope);</span>
1605         }
1606         return String();
1607     }
1608 
1609     Vector&lt;LChar&gt; resultString(charsRequired);
1610     Digit digit = 0;
1611     // Keeps track of how many unprocessed bits there are in {digit}.
1612     unsigned availableBits = 0;
1613     int pos = static_cast&lt;int&gt;(charsRequired - 1);
1614     for (unsigned i = 0; i &lt; length - 1; i++) {
1615         Digit newDigit = x-&gt;digit(i);
1616         // Take any leftover bits from the last iteration into account.
1617         int current = (digit | (newDigit &lt;&lt; availableBits)) &amp; charMask;
1618         resultString[pos--] = radixDigits[current];
1619         int consumedBits = bitsPerChar - availableBits;
1620         digit = newDigit &gt;&gt; consumedBits;
1621         availableBits = digitBits - consumedBits;
1622         while (availableBits &gt;= bitsPerChar) {
1623             resultString[pos--] = radixDigits[digit &amp; charMask];
1624             digit &gt;&gt;= bitsPerChar;
1625             availableBits -= bitsPerChar;
1626         }
1627     }
1628     // Take any leftover bits from the last iteration into account.
1629     int current = (digit | (msd &lt;&lt; availableBits)) &amp; charMask;
1630     resultString[pos--] = radixDigits[current];
1631     digit = msd &gt;&gt; (bitsPerChar - availableBits);
1632     while (digit) {
1633         resultString[pos--] = radixDigits[digit &amp; charMask];
1634         digit &gt;&gt;= bitsPerChar;
1635     }
1636 
1637     if (sign)
1638         resultString[pos--] = &#39;-&#39;;
1639 
1640     ASSERT(pos == -1);
1641     return StringImpl::adopt(WTFMove(resultString));
1642 }
1643 
<span class="line-modified">1644 String JSBigInt::toStringGeneric(VM&amp; vm, JSGlobalObject* globalObject, JSBigInt* x, unsigned radix)</span>
1645 {
1646     // FIXME: [JSC] Revisit usage of Vector into JSBigInt::toString
1647     // https://bugs.webkit.org/show_bug.cgi?id=18067
1648     Vector&lt;LChar&gt; resultString;
1649 
1650     ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 36);
1651     ASSERT(!x-&gt;isZero());
1652 
1653     unsigned length = x-&gt;length();
1654     bool sign = x-&gt;sign();
1655 
1656     uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
1657     uint64_t maximumCharactersRequired = calculateMaximumCharactersRequired(length, radix, x-&gt;digit(length - 1), sign);
1658 
1659     if (maximumCharactersRequired &gt; JSString::MaxLength) {
<span class="line-modified">1660         if (globalObject) {</span>
1661             auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1662             throwOutOfMemoryError(globalObject, scope);</span>
1663         }
1664         return String();
1665     }
1666 
1667     Digit lastDigit;
1668     if (length == 1)
1669         lastDigit = x-&gt;digit(0);
1670     else {
1671         unsigned chunkChars = digitBits * bitsPerCharTableMultiplier / maxBitsPerChar;
1672         Digit chunkDivisor = digitPow(radix, chunkChars);
1673 
1674         // By construction of chunkChars, there can&#39;t have been overflow.
1675         ASSERT(chunkDivisor);
1676         unsigned nonZeroDigit = length - 1;
1677         ASSERT(x-&gt;digit(nonZeroDigit));
1678 
1679         // {rest} holds the part of the BigInt that we haven&#39;t looked at yet.
1680         // Not to be confused with &quot;remainder&quot;!
1681         JSBigInt* rest = nullptr;
1682 
</pre>
<hr />
<pre>
1735 
1736     int nonZeroIndex = m_length - 1;
1737     while (nonZeroIndex &gt;= 0 &amp;&amp; !digit(nonZeroIndex))
1738         nonZeroIndex--;
1739 
1740     if (nonZeroIndex &lt; 0)
1741         return createZero(vm);
1742 
1743     if (nonZeroIndex == static_cast&lt;int&gt;(m_length - 1))
1744         return this;
1745 
1746     unsigned newLength = nonZeroIndex + 1;
1747     JSBigInt* trimmedBigInt = createWithLengthUnchecked(vm, newLength);
1748     std::copy(dataStorage(), dataStorage() + newLength, trimmedBigInt-&gt;dataStorage());
1749 
1750     trimmedBigInt-&gt;setSign(this-&gt;sign());
1751 
1752     return trimmedBigInt;
1753 }
1754 
<span class="line-modified">1755 JSBigInt* JSBigInt::allocateFor(JSGlobalObject* globalObject, VM&amp; vm, unsigned radix, unsigned charcount)</span>
1756 {
1757     ASSERT(2 &lt;= radix &amp;&amp; radix &lt;= 36);
1758 
1759     size_t bitsPerChar = maxBitsPerCharTable[radix];
1760     size_t chars = charcount;
1761     const unsigned roundup = bitsPerCharTableMultiplier - 1;
1762     if (chars &lt;= (std::numeric_limits&lt;size_t&gt;::max() - roundup) / bitsPerChar) {
1763         size_t bitsMin = bitsPerChar * chars;
1764 
1765         // Divide by 32 (see table), rounding up.
1766         bitsMin = (bitsMin + roundup) &gt;&gt; bitsPerCharTableShift;
1767         if (bitsMin &lt;= static_cast&lt;size_t&gt;(maxInt)) {
1768             // Divide by kDigitsBits, rounding up.
1769             unsigned length = (bitsMin + digitBits - 1) / digitBits;
1770             if (length &lt;= maxLength) {
1771                 JSBigInt* result = JSBigInt::createWithLengthUnchecked(vm, length);
1772                 return result;
1773             }
1774         }
1775     }
1776 
<span class="line-modified">1777     if (globalObject) {</span>
1778         auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1779         throwOutOfMemoryError(globalObject, scope);</span>
1780     }
1781     return nullptr;
1782 }
1783 
1784 size_t JSBigInt::estimatedSize(JSCell* cell, VM&amp; vm)
1785 {
1786     return Base::estimatedSize(cell, vm) + jsCast&lt;JSBigInt*&gt;(cell)-&gt;m_length * sizeof(Digit);
1787 }
1788 
<span class="line-modified">1789 double JSBigInt::toNumber(JSGlobalObject* globalObject) const</span>
1790 {
<span class="line-modified">1791     VM&amp; vm = globalObject-&gt;vm();</span>
1792     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1793     throwTypeError(globalObject, scope, &quot;Conversion from &#39;BigInt&#39; to &#39;number&#39; is not allowed.&quot;_s);</span>
1794     return 0.0;
1795 }
1796 
<span class="line-modified">1797 bool JSBigInt::getPrimitiveNumber(JSGlobalObject* globalObject, double&amp; number, JSValue&amp; result) const</span>
1798 {
1799     result = this;
<span class="line-modified">1800     number = toNumber(globalObject);</span>
1801     return true;
1802 }
1803 
1804 template &lt;typename CharType&gt;
<span class="line-modified">1805 JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, CharType*  data, unsigned length, ErrorParseMode errorParseMode)</span>
1806 {
<span class="line-modified">1807     VM&amp; vm = globalObject-&gt;vm();</span>
1808 
1809     unsigned p = 0;
1810     while (p &lt; length &amp;&amp; isStrWhiteSpace(data[p]))
1811         ++p;
1812 
1813     // Check Radix from frist characters
1814     if (static_cast&lt;unsigned&gt;(p) + 1 &lt; static_cast&lt;unsigned&gt;(length) &amp;&amp; data[p] == &#39;0&#39;) {
1815         if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;b&#39;))
<span class="line-modified">1816             return parseInt(globalObject, vm, data, length, p + 2, 2, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
1817 
1818         if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;x&#39;))
<span class="line-modified">1819             return parseInt(globalObject, vm, data, length, p + 2, 16, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
1820 
1821         if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;o&#39;))
<span class="line-modified">1822             return parseInt(globalObject, vm, data, length, p + 2, 8, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
1823     }
1824 
1825     ParseIntSign sign = ParseIntSign::Unsigned;
1826     if (p &lt; length) {
1827         if (data[p] == &#39;+&#39;)
1828             ++p;
1829         else if (data[p] == &#39;-&#39;) {
1830             sign = ParseIntSign::Signed;
1831             ++p;
1832         }
1833     }
1834 
<span class="line-modified">1835     JSBigInt* result = parseInt(globalObject, vm, data, length, p, 10, errorParseMode, sign);</span>
1836 
1837     if (result &amp;&amp; !result-&gt;isZero())
1838         result-&gt;setSign(sign == ParseIntSign::Signed);
1839 
1840     return result;
1841 }
1842 
1843 template &lt;typename CharType&gt;
<span class="line-modified">1844 JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, VM&amp; vm, CharType* data, unsigned length, unsigned startIndex, unsigned radix, ErrorParseMode errorParseMode, ParseIntSign sign, ParseIntMode parseMode)</span>
1845 {
1846     ASSERT(length &gt;= 0);
1847     unsigned p = startIndex;
1848 
1849     auto scope = DECLARE_THROW_SCOPE(vm);
1850 
1851     if (parseMode != ParseIntMode::AllowEmptyString &amp;&amp; startIndex == length) {
<span class="line-modified">1852         ASSERT(globalObject);</span>
1853         if (errorParseMode == ErrorParseMode::ThrowExceptions)
<span class="line-modified">1854             throwVMError(globalObject, scope, createSyntaxError(globalObject, &quot;Failed to parse String to BigInt&quot;));</span>
1855         return nullptr;
1856     }
1857 
1858     // Skipping leading zeros
1859     while (p &lt; length &amp;&amp; data[p] == &#39;0&#39;)
1860         ++p;
1861 
1862     int endIndex = length - 1;
1863     // Removing trailing spaces
1864     while (endIndex &gt;= static_cast&lt;int&gt;(p) &amp;&amp; isStrWhiteSpace(data[endIndex]))
1865         --endIndex;
1866 
1867     length = endIndex + 1;
1868 
1869     if (p == length)
1870         return createZero(vm);
1871 
1872     unsigned limit0 = &#39;0&#39; + (radix &lt; 10 ? radix : 10);
1873     unsigned limita = &#39;a&#39; + (radix - 10);
1874     unsigned limitA = &#39;A&#39; + (radix - 10);
1875 
<span class="line-modified">1876     JSBigInt* result = allocateFor(globalObject, vm, radix, length - p);</span>
1877     RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-added">1878     // result can still be null if we don&#39;t have access to global object, as allocateFor cannot throw an exception in that case.</span>
<span class="line-added">1879     if (!result)</span>
<span class="line-added">1880         return nullptr;</span>
1881 
1882     result-&gt;initialize(InitializationType::WithZero);
1883 
1884     for (unsigned i = p; i &lt; length; i++, p++) {
1885         uint32_t digit;
1886         if (data[i] &gt;= &#39;0&#39; &amp;&amp; data[i] &lt; limit0)
1887             digit = data[i] - &#39;0&#39;;
1888         else if (data[i] &gt;= &#39;a&#39; &amp;&amp; data[i] &lt; limita)
1889             digit = data[i] - &#39;a&#39; + 10;
1890         else if (data[i] &gt;= &#39;A&#39; &amp;&amp; data[i] &lt; limitA)
1891             digit = data[i] - &#39;A&#39; + 10;
1892         else
1893             break;
1894 
1895         result-&gt;inplaceMultiplyAdd(static_cast&lt;Digit&gt;(radix), static_cast&lt;Digit&gt;(digit));
1896     }
1897 
1898     result-&gt;setSign(sign == ParseIntSign::Signed ? true : false);
1899     if (p == length)
1900         return result-&gt;rightTrim(vm);
1901 
<span class="line-modified">1902     ASSERT(globalObject);</span>
1903     if (errorParseMode == ErrorParseMode::ThrowExceptions)
<span class="line-modified">1904         throwVMError(globalObject, scope, createSyntaxError(globalObject, &quot;Failed to parse String to BigInt&quot;));</span>
1905 
1906     return nullptr;
1907 }
1908 
1909 inline JSBigInt::Digit JSBigInt::digit(unsigned n)
1910 {
1911     ASSERT(n &lt; length());
1912     return dataStorage()[n];
1913 }
1914 
1915 inline void JSBigInt::setDigit(unsigned n, Digit value)
1916 {
1917     ASSERT(n &lt; length());
1918     dataStorage()[n] = value;
1919 }
1920 
<span class="line-modified">1921 JSObject* JSBigInt::toObject(JSGlobalObject* globalObject) const</span>
1922 {
<span class="line-modified">1923     return BigIntObject::create(globalObject-&gt;vm(), globalObject, const_cast&lt;JSBigInt*&gt;(this));</span>
1924 }
1925 
1926 bool JSBigInt::equalsToNumber(JSValue numValue)
1927 {
1928     ASSERT(numValue.isNumber());
1929 
1930     if (numValue.isInt32()) {
1931         int value = numValue.asInt32();
1932         if (!value)
1933             return this-&gt;isZero();
1934 
1935         return (this-&gt;length() == 1) &amp;&amp; (this-&gt;sign() == (value &lt; 0)) &amp;&amp; (this-&gt;digit(0) == static_cast&lt;Digit&gt;(std::abs(static_cast&lt;int64_t&gt;(value))));
1936     }
1937 
1938     double value = numValue.asDouble();
1939     return compareToDouble(this, value) == ComparisonResult::Equal;
1940 }
1941 
1942 JSBigInt::ComparisonResult JSBigInt::compareToDouble(JSBigInt* x, double y)
1943 {
</pre>
</td>
</tr>
</table>
<center><a href="JSAsyncGeneratorFunction.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBigInt.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
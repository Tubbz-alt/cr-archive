<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasession/WebMediaSessionManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../mediarecorder/MediaRecorderErrorEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebMediaSessionManager.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasession/WebMediaSessionManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebMediaSessionManager.h&quot;
 28 
 29 #if ENABLE(WIRELESS_PLAYBACK_TARGET) &amp;&amp; !PLATFORM(IOS_FAMILY)
 30 
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;MediaPlaybackTargetPickerMock.h&quot;
 34 #include &quot;WebMediaSessionManagerClient.h&quot;


 35 #include &lt;wtf/text/StringBuilder.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 static const Seconds taskDelayInterval { 100_ms };
 40 






 41 struct ClientState {
 42     WTF_MAKE_STRUCT_FAST_ALLOCATED;
 43 
 44     explicit ClientState(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
 45         : client(client)
 46         , contextId(contextId)
 47     {
 48     }
 49 
 50     bool operator == (ClientState const&amp; other) const
 51     {
 52         return contextId == other.contextId &amp;&amp; &amp;client == &amp;other.client;
 53     }
 54 
 55     WebMediaSessionManagerClient&amp; client;
 56     uint64_t contextId { 0 };
 57     WebCore::MediaProducer::MediaStateFlags flags { WebCore::MediaProducer::IsNotPlaying };
 58     bool requestedPicker { false };
 59     bool previouslyRequestedPicker { false };
 60     bool configurationRequired { true };
 61     bool playedToEnd { false };
 62 };
 63 
 64 static bool flagsAreSet(MediaProducer::MediaStateFlags value, unsigned flags)
 65 {
 66     return value &amp; flags;
 67 }
 68 
<span class="line-modified"> 69 #if !LOG_DISABLED</span>
<span class="line-removed"> 70 static String mediaProducerStateString(MediaProducer::MediaStateFlags flags)</span>
 71 {
 72     StringBuilder string;
 73     if (flags &amp; MediaProducer::IsPlayingAudio)
<span class="line-modified"> 74         string.append(&quot;IsPlayingAudio + &quot;);</span>
 75     if (flags &amp; MediaProducer::IsPlayingVideo)
<span class="line-modified"> 76         string.append(&quot;IsPlayingVideo + &quot;);</span>
 77     if (flags &amp; MediaProducer::IsPlayingToExternalDevice)
<span class="line-modified"> 78         string.append(&quot;IsPlayingToExternalDevice + &quot;);</span>
 79     if (flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
<span class="line-modified"> 80         string.append(&quot;HasPlaybackTargetAvailabilityListener + &quot;);</span>
 81     if (flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring)
<span class="line-modified"> 82         string.append(&quot;RequiresPlaybackTargetMonitoring + &quot;);</span>
 83     if (flags &amp; MediaProducer::ExternalDeviceAutoPlayCandidate)
<span class="line-modified"> 84         string.append(&quot;ExternalDeviceAutoPlayCandidate + &quot;);</span>
 85     if (flags &amp; MediaProducer::DidPlayToEnd)
<span class="line-modified"> 86         string.append(&quot;DidPlayToEnd + &quot;);</span>
 87     if (flags &amp; MediaProducer::HasAudioOrVideo)
<span class="line-modified"> 88         string.append(&quot;HasAudioOrVideo + &quot;);</span>
 89     if (string.isEmpty())
 90         string.append(&quot;IsNotPlaying&quot;);
 91     else
<span class="line-modified"> 92         string.resize(string.length() - 2);</span>
 93 
<span class="line-modified"> 94     return string.toString();</span>
 95 }
<span class="line-removed"> 96 #endif</span>
 97 
<span class="line-modified"> 98 void WebMediaSessionManager::setMockMediaPlaybackTargetPickerEnabled(bool enabled)</span>








































 99 {
<span class="line-modified">100     LOG(Media, &quot;WebMediaSessionManager::setMockMediaPlaybackTargetPickerEnabled - enabled = %i&quot;, (int)enabled);</span>

101 












102     if (m_mockPickerEnabled == enabled)
103         return;
104 

105     m_mockPickerEnabled = enabled;
106 }
107 
108 void WebMediaSessionManager::setMockMediaPlaybackTargetPickerState(const String&amp; name, MediaPlaybackTargetContext::State state)
109 {
<span class="line-modified">110     LOG(Media, &quot;WebMediaSessionManager::setMockMediaPlaybackTargetPickerState - name = %s, state = %i&quot;, name.utf8().data(), (int)state);</span>
<span class="line-removed">111 </span>
112     mockPicker().setState(name, state);
113 }
114 






115 MediaPlaybackTargetPickerMock&amp; WebMediaSessionManager::mockPicker()
116 {
117     if (!m_pickerOverride)
118         m_pickerOverride = makeUnique&lt;MediaPlaybackTargetPickerMock&gt;(*this);
119 
120     return *m_pickerOverride.get();
121 }
122 
123 WebCore::MediaPlaybackTargetPicker&amp; WebMediaSessionManager::targetPicker()
124 {
125     if (m_mockPickerEnabled)
126         return mockPicker();
127 
128     return platformPicker();
129 }
130 
131 WebMediaSessionManager::WebMediaSessionManager()
132     : m_taskTimer(RunLoop::current(), this, &amp;WebMediaSessionManager::taskTimerFired)
133     , m_watchdogTimer(RunLoop::current(), this, &amp;WebMediaSessionManager::watchdogTimerFired)
134 {
135 }
136 
137 WebMediaSessionManager::~WebMediaSessionManager() = default;
138 
139 uint64_t WebMediaSessionManager::addPlaybackTargetPickerClient(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
140 {
141     size_t index = find(&amp;client, contextId);
142     ASSERT(index == notFound);
143     if (index != notFound)
144         return 0;
145 
<span class="line-modified">146     LOG(Media, &quot;WebMediaSessionManager::addPlaybackTargetPickerClient(%p + %llu)&quot;, &amp;client, contextId);</span>
<span class="line-removed">147 </span>
148     m_clientState.append(makeUnique&lt;ClientState&gt;(client, contextId));
149 
150     if (m_externalOutputDeviceAvailable || m_playbackTarget)
151         scheduleDelayedTask(InitialConfigurationTask | TargetClientsConfigurationTask);
152 
153     return contextId;
154 }
155 
156 void WebMediaSessionManager::removePlaybackTargetPickerClient(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
157 {
158     size_t index = find(&amp;client, contextId);
159     ASSERT(index != notFound);
160     if (index == notFound)
161         return;
162 
<span class="line-modified">163     LOG(Media, &quot;WebMediaSessionManager::removePlaybackTargetPickerClient(%p + %llu)&quot;, &amp;client, contextId);</span>
164 
165     m_clientState.remove(index);
166     scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
167 }
168 
169 void WebMediaSessionManager::removeAllPlaybackTargetPickerClients(WebMediaSessionManagerClient&amp; client)
170 {
171     if (m_clientState.isEmpty())
172         return;
173 
<span class="line-removed">174     LOG(Media, &quot;WebMediaSessionManager::removeAllPlaybackTargetPickerClients(%p)&quot;, &amp;client);</span>
<span class="line-removed">175 </span>
176     for (size_t i = m_clientState.size(); i &gt; 0; --i) {
<span class="line-modified">177         if (&amp;m_clientState[i - 1]-&gt;client == &amp;client)</span>

178             m_clientState.remove(i - 1);

179     }
180     scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
181 }
182 
183 void WebMediaSessionManager::showPlaybackTargetPicker(WebMediaSessionManagerClient&amp; client, uint64_t contextId, const IntRect&amp; rect, bool, bool useDarkAppearance)
184 {
185     size_t index = find(&amp;client, contextId);
186     ASSERT(index != notFound);
187     if (index == notFound)
188         return;
189 
190     auto&amp; clientRequestingPicker = m_clientState[index];
191     for (auto&amp; state : m_clientState) {
192         state-&gt;requestedPicker = state == clientRequestingPicker;
193         state-&gt;previouslyRequestedPicker = state == clientRequestingPicker;
194     }
195 


196     bool hasActiveRoute = flagsAreSet(m_clientState[index]-&gt;flags, MediaProducer::IsPlayingToExternalDevice);
<span class="line-removed">197     LOG(Media, &quot;WebMediaSessionManager::showPlaybackTargetPicker(%p + %llu) - hasActiveRoute = %i&quot;, &amp;client, contextId, (int)hasActiveRoute);</span>
198     targetPicker().showPlaybackTargetPicker(FloatRect(rect), hasActiveRoute, useDarkAppearance);
199 }
200 
201 void WebMediaSessionManager::clientStateDidChange(WebMediaSessionManagerClient&amp; client, uint64_t contextId, MediaProducer::MediaStateFlags newFlags)
202 {
203     size_t index = find(&amp;client, contextId);
204     ASSERT(index != notFound);
205     if (index == notFound)
206         return;
207 
208     auto&amp; changedClientState = m_clientState[index];
209     MediaProducer::MediaStateFlags oldFlags = changedClientState-&gt;flags;
210     if (newFlags == oldFlags)
211         return;
212 
<span class="line-modified">213     LOG(Media, &quot;WebMediaSessionManager::clientStateDidChange(%p + %llu) - new flags = %s, old flags = %s&quot;, &amp;client, contextId, mediaProducerStateString(newFlags).utf8().data(), mediaProducerStateString(oldFlags).utf8().data());</span>
214 
215     changedClientState-&gt;flags = newFlags;
216 
217     MediaProducer::MediaStateFlags updateConfigurationFlags = MediaProducer::RequiresPlaybackTargetMonitoring | MediaProducer::HasPlaybackTargetAvailabilityListener | MediaProducer::HasAudioOrVideo;
218     if ((oldFlags &amp; updateConfigurationFlags) != (newFlags &amp; updateConfigurationFlags))
219         scheduleDelayedTask(TargetMonitoringConfigurationTask);
220 
221     MediaProducer::MediaStateFlags playingToTargetFlags = MediaProducer::IsPlayingToExternalDevice | MediaProducer::IsPlayingVideo;
222     if ((oldFlags &amp; playingToTargetFlags) != (newFlags &amp; playingToTargetFlags)) {
223         if (flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo) &amp;&amp; !flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) &amp;&amp; flagsAreSet(newFlags, MediaProducer::DidPlayToEnd))
224             changedClientState-&gt;playedToEnd = true;
225         scheduleDelayedTask(WatchdogTimerConfigurationTask);
226     }
227 
228     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute() || !flagsAreSet(newFlags, MediaProducer::ExternalDeviceAutoPlayCandidate))
229         return;
230 
231     // Do not interrupt another element already playing to a device.
232     for (auto&amp; state : m_clientState) {
233         if (state == changedClientState)
234             continue;
235 
<span class="line-modified">236         if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo))</span>

237             return;

238     }
239 
240     // Do not begin playing to the device unless playback has just started.
<span class="line-modified">241     if (!flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) || flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo))</span>

242         return;

243 
244     for (auto&amp; state : m_clientState) {
245         if (state == changedClientState)
246             continue;

247         state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);
248     }
249 

250     changedClientState-&gt;client.setShouldPlayToPlaybackTarget(changedClientState-&gt;contextId, true);
251 
252     if (index &amp;&amp; m_clientState.size() &gt; 1)
253         std::swap(m_clientState.at(index), m_clientState.at(0));
254 }
255 
256 void WebMediaSessionManager::setPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
257 {

258     m_playbackTarget = WTFMove(target);
259     m_targetChanged = true;
260     scheduleDelayedTask(TargetClientsConfigurationTask);
261 }
262 
263 void WebMediaSessionManager::externalOutputDeviceAvailableDidChange(bool available)
264 {
<span class="line-modified">265     LOG(Media, &quot;WebMediaSessionManager::externalOutputDeviceAvailableDidChange - clients = %zu, available = %i&quot;, m_clientState.size(), (int)available);</span>
<span class="line-removed">266 </span>
267     m_externalOutputDeviceAvailable = available;
268     for (auto&amp; state : m_clientState)
269         state-&gt;client.externalOutputDeviceAvailableDidChange(state-&gt;contextId, available);
270 }
271 







272 void WebMediaSessionManager::configureNewClients()
273 {
274     for (auto&amp; state : m_clientState) {
275         if (!state-&gt;configurationRequired)
276             continue;
277 
278         state-&gt;configurationRequired = false;
279         if (m_externalOutputDeviceAvailable)
280             state-&gt;client.externalOutputDeviceAvailableDidChange(state-&gt;contextId, true);
281 
282         if (m_playbackTarget)
283             state-&gt;client.setPlaybackTarget(state-&gt;contextId, *m_playbackTarget.copyRef());
284     }
285 }
286 
287 void WebMediaSessionManager::configurePlaybackTargetClients()
288 {
289     if (m_clientState.isEmpty())
290         return;
291 
292     size_t indexOfClientThatRequestedPicker = notFound;
293     size_t indexOfLastClientToRequestPicker = notFound;
294     size_t indexOfClientWillPlayToTarget = notFound;
295     bool haveActiveRoute = m_playbackTarget &amp;&amp; m_playbackTarget-&gt;hasActiveRoute();
296 
297     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
298         auto&amp; state = m_clientState[i];
299 
<span class="line-modified">300         LOG(Media, &quot;WebMediaSessionManager::configurePlaybackTargetClients %zu - client (%p + %llu) requestedPicker = %i, flags = %s&quot;, i, &amp;state-&gt;client, state-&gt;contextId, state-&gt;requestedPicker, mediaProducerStateString(state-&gt;flags).utf8().data());</span>
301 
<span class="line-modified">302         if (m_targetChanged &amp;&amp; state-&gt;requestedPicker)</span>
303             indexOfClientThatRequestedPicker = i;
304 
305         if (indexOfClientWillPlayToTarget == notFound &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice))
306             indexOfClientWillPlayToTarget = i;
307 
308         if (indexOfClientWillPlayToTarget == notFound &amp;&amp; haveActiveRoute &amp;&amp; state-&gt;previouslyRequestedPicker)
309             indexOfLastClientToRequestPicker = i;
310     }
311 
312     if (indexOfClientThatRequestedPicker != notFound)
313         indexOfClientWillPlayToTarget = indexOfClientThatRequestedPicker;
314     if (indexOfClientWillPlayToTarget == notFound &amp;&amp; indexOfLastClientToRequestPicker != notFound)
315         indexOfClientWillPlayToTarget = indexOfLastClientToRequestPicker;
316     if (indexOfClientWillPlayToTarget == notFound &amp;&amp; haveActiveRoute &amp;&amp; flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::ExternalDeviceAutoPlayCandidate) &amp;&amp; !flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::IsPlayingVideo))
317         indexOfClientWillPlayToTarget = 0;
318 
<span class="line-removed">319     LOG(Media, &quot;WebMediaSessionManager::configurePlaybackTargetClients - indexOfClientWillPlayToTarget = %zu&quot;, indexOfClientWillPlayToTarget);</span>
<span class="line-removed">320 </span>
321     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
322         auto&amp; state = m_clientState[i];
323 
324         if (m_playbackTarget)
325             state-&gt;client.setPlaybackTarget(state-&gt;contextId, *m_playbackTarget.copyRef());
326 
<span class="line-modified">327         if (i != indexOfClientWillPlayToTarget || !haveActiveRoute)</span>

328             state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);






329 
330         state-&gt;configurationRequired = false;
<span class="line-modified">331         if (m_targetChanged)</span>
332             state-&gt;requestedPicker = false;
333     }
334 
335     if (haveActiveRoute &amp;&amp; indexOfClientWillPlayToTarget != notFound) {
336         auto&amp; state = m_clientState[indexOfClientWillPlayToTarget];
<span class="line-modified">337         if (!flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice))</span>

338             state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, true);

339     }
340 
341     m_targetChanged = false;
342     configureWatchdogTimer();
343 }
344 
345 void WebMediaSessionManager::configurePlaybackTargetMonitoring()
346 {
347     bool monitoringRequired = false;
348     bool hasAvailabilityListener = false;
349     bool haveClientWithMedia = false;
350     for (auto&amp; state : m_clientState) {

351         if (state-&gt;flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring) {
352             monitoringRequired = true;
353             break;
354         }
355         if (state-&gt;flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
356             hasAvailabilityListener = true;
357         if (state-&gt;flags &amp; MediaProducer::HasAudioOrVideo)
358             haveClientWithMedia = true;
359     }
360 
<span class="line-modified">361     LOG(Media, &quot;WebMediaSessionManager::configurePlaybackTargetMonitoring - monitoringRequired = %i&quot;, static_cast&lt;int&gt;(monitoringRequired || (hasAvailabilityListener &amp;&amp; haveClientWithMedia)));</span>
<span class="line-modified">362 </span>
<span class="line-removed">363     if (monitoringRequired || (hasAvailabilityListener &amp;&amp; haveClientWithMedia))</span>
364         targetPicker().startingMonitoringPlaybackTargets();
<span class="line-modified">365     else</span>

366         targetPicker().stopMonitoringPlaybackTargets();

367 }
368 
<span class="line-removed">369 #if !LOG_DISABLED</span>
<span class="line-removed">370 String WebMediaSessionManager::toString(ConfigurationTasks tasks)</span>
<span class="line-removed">371 {</span>
<span class="line-removed">372     StringBuilder string;</span>
<span class="line-removed">373     if (tasks &amp; InitialConfigurationTask)</span>
<span class="line-removed">374         string.append(&quot;InitialConfigurationTask + &quot;);</span>
<span class="line-removed">375     if (tasks &amp; TargetClientsConfigurationTask)</span>
<span class="line-removed">376         string.append(&quot;TargetClientsConfigurationTask + &quot;);</span>
<span class="line-removed">377     if (tasks &amp; TargetMonitoringConfigurationTask)</span>
<span class="line-removed">378         string.append(&quot;TargetMonitoringConfigurationTask + &quot;);</span>
<span class="line-removed">379     if (tasks &amp; WatchdogTimerConfigurationTask)</span>
<span class="line-removed">380         string.append(&quot;WatchdogTimerConfigurationTask + &quot;);</span>
<span class="line-removed">381     if (string.isEmpty())</span>
<span class="line-removed">382         string.append(&quot;NoTask&quot;);</span>
<span class="line-removed">383     else</span>
<span class="line-removed">384         string.resize(string.length() - 2);</span>
<span class="line-removed">385 </span>
<span class="line-removed">386     return string.toString();</span>
<span class="line-removed">387 }</span>
<span class="line-removed">388 #endif</span>
<span class="line-removed">389 </span>
390 void WebMediaSessionManager::scheduleDelayedTask(ConfigurationTasks tasks)
391 {
<span class="line-removed">392     LOG(Media, &quot;WebMediaSessionManager::scheduleDelayedTask - %s&quot;, toString(tasks).utf8().data());</span>
<span class="line-removed">393 </span>
394     m_taskFlags |= tasks;
395     m_taskTimer.startOneShot(taskDelayInterval);
396 }
397 
398 void WebMediaSessionManager::taskTimerFired()
399 {
<span class="line-removed">400     LOG(Media, &quot;WebMediaSessionManager::taskTimerFired - tasks = %s&quot;, toString(m_taskFlags).utf8().data());</span>
<span class="line-removed">401 </span>
402     if (m_taskFlags &amp; InitialConfigurationTask)
403         configureNewClients();
404     if (m_taskFlags &amp; TargetClientsConfigurationTask)
405         configurePlaybackTargetClients();
406     if (m_taskFlags &amp; TargetMonitoringConfigurationTask)
407         configurePlaybackTargetMonitoring();
408     if (m_taskFlags &amp; WatchdogTimerConfigurationTask)
409         configureWatchdogTimer();
410 
411     m_taskFlags = NoTask;
412 }
413 
414 size_t WebMediaSessionManager::find(WebMediaSessionManagerClient* client, uint64_t contextId)
415 {
416     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
417         if (m_clientState[i]-&gt;contextId == contextId &amp;&amp; &amp;m_clientState[i]-&gt;client == client)
418             return i;
419     }
420 
421     return notFound;
422 }
423 
424 void WebMediaSessionManager::configureWatchdogTimer()
425 {
426     static const Seconds watchdogTimerIntervalAfterPausing { 1_h };
427     static const Seconds watchdogTimerIntervalAfterPlayingToEnd { 8_min };
428 
429     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute()) {
<span class="line-modified">430         m_watchdogTimer.stop();</span>





431         return;
432     }
433 
434     bool stopTimer = false;
435     bool didPlayToEnd = false;
436     for (auto&amp; state : m_clientState) {



437         if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo))
438             stopTimer = true;
439         if (state-&gt;playedToEnd)
440             didPlayToEnd = true;
441         state-&gt;playedToEnd = false;
442     }
443 
444     if (stopTimer) {

445         m_currentWatchdogInterval = { };
446         m_watchdogTimer.stop();
<span class="line-removed">447         LOG(Media, &quot;WebMediaSessionManager::configureWatchdogTimer - timer stopped&quot;);</span>
448     } else {
449         Seconds interval = didPlayToEnd ? watchdogTimerIntervalAfterPlayingToEnd : watchdogTimerIntervalAfterPausing;
450         if (interval != m_currentWatchdogInterval || !m_watchdogTimer.isActive()) {
451             m_watchdogTimer.startOneShot(interval);
<span class="line-removed">452             LOG(Media, &quot;WebMediaSessionManager::configureWatchdogTimer - timer scheduled for %.0f seconds&quot;, interval.value());</span>
453         }

454         m_currentWatchdogInterval = interval;
455     }
456 }
457 
458 void WebMediaSessionManager::watchdogTimerFired()
459 {
<span class="line-removed">460     LOG(Media, &quot;WebMediaSessionManager::watchdogTimerFired&quot;);</span>
461     if (!m_playbackTarget)
462         return;
463 

464     targetPicker().invalidatePlaybackTargets();
465 }
466 
467 } // namespace WebCore
468 
469 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET) &amp;&amp; !PLATFORM(IOS_FAMILY)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebMediaSessionManager.h&quot;
 28 
 29 #if ENABLE(WIRELESS_PLAYBACK_TARGET) &amp;&amp; !PLATFORM(IOS_FAMILY)
 30 
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;MediaPlaybackTargetPickerMock.h&quot;
 34 #include &quot;WebMediaSessionManagerClient.h&quot;
<span class="line-added"> 35 #include &lt;wtf/Algorithms.h&gt;</span>
<span class="line-added"> 36 #include &lt;wtf/Logger.h&gt;</span>
 37 #include &lt;wtf/text/StringBuilder.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 static const Seconds taskDelayInterval { 100_ms };
 42 
<span class="line-added"> 43 #undef LOGIDENTIFIER</span>
<span class="line-added"> 44 #define LOGIDENTIFIER __func__</span>
<span class="line-added"> 45 </span>
<span class="line-added"> 46 #undef ALWAYS_LOG</span>
<span class="line-added"> 47 #define ALWAYS_LOG logger().logAlways</span>
<span class="line-added"> 48 </span>
 49 struct ClientState {
 50     WTF_MAKE_STRUCT_FAST_ALLOCATED;
 51 
 52     explicit ClientState(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
 53         : client(client)
 54         , contextId(contextId)
 55     {
 56     }
 57 
 58     bool operator == (ClientState const&amp; other) const
 59     {
 60         return contextId == other.contextId &amp;&amp; &amp;client == &amp;other.client;
 61     }
 62 
 63     WebMediaSessionManagerClient&amp; client;
 64     uint64_t contextId { 0 };
 65     WebCore::MediaProducer::MediaStateFlags flags { WebCore::MediaProducer::IsNotPlaying };
 66     bool requestedPicker { false };
 67     bool previouslyRequestedPicker { false };
 68     bool configurationRequired { true };
 69     bool playedToEnd { false };
 70 };
 71 
 72 static bool flagsAreSet(MediaProducer::MediaStateFlags value, unsigned flags)
 73 {
 74     return value &amp; flags;
 75 }
 76 
<span class="line-modified"> 77 String mediaProducerStateString(MediaProducer::MediaStateFlags flags)</span>

 78 {
 79     StringBuilder string;
 80     if (flags &amp; MediaProducer::IsPlayingAudio)
<span class="line-modified"> 81         string.append(&quot;IsPlayingAudio+&quot;);</span>
 82     if (flags &amp; MediaProducer::IsPlayingVideo)
<span class="line-modified"> 83         string.append(&quot;IsPlayingVideo+&quot;);</span>
 84     if (flags &amp; MediaProducer::IsPlayingToExternalDevice)
<span class="line-modified"> 85         string.append(&quot;IsPlayingToExternalDevice+&quot;);</span>
 86     if (flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
<span class="line-modified"> 87         string.append(&quot;HasTargetAvailabilityListener+&quot;);</span>
 88     if (flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring)
<span class="line-modified"> 89         string.append(&quot;RequiresTargetMonitoring+&quot;);</span>
 90     if (flags &amp; MediaProducer::ExternalDeviceAutoPlayCandidate)
<span class="line-modified"> 91         string.append(&quot;ExternalDeviceAutoPlayCandidate+&quot;);</span>
 92     if (flags &amp; MediaProducer::DidPlayToEnd)
<span class="line-modified"> 93         string.append(&quot;DidPlayToEnd+&quot;);</span>
 94     if (flags &amp; MediaProducer::HasAudioOrVideo)
<span class="line-modified"> 95         string.append(&quot;HasAudioOrVideo+&quot;);</span>
 96     if (string.isEmpty())
 97         string.append(&quot;IsNotPlaying&quot;);
 98     else
<span class="line-modified"> 99         string.resize(string.length() - 1);</span>
100 
<span class="line-modified">101     return makeString(&quot; { &quot;, string.toString(), &quot; }&quot;);</span>
102 }

103 
<span class="line-modified">104 class WebMediaSessionLogger {</span>
<span class="line-added">105     WTF_MAKE_NONCOPYABLE(WebMediaSessionLogger);</span>
<span class="line-added">106     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-added">107 public:</span>
<span class="line-added">108 </span>
<span class="line-added">109     static std::unique_ptr&lt;WebMediaSessionLogger&gt; create(WebMediaSessionManager&amp; manager)</span>
<span class="line-added">110     {</span>
<span class="line-added">111         return makeUnique&lt;WebMediaSessionLogger&gt;(manager);</span>
<span class="line-added">112     }</span>
<span class="line-added">113 </span>
<span class="line-added">114     template&lt;typename... Arguments&gt;</span>
<span class="line-added">115     inline void logAlways(const char* methodName, ClientState* state, const Arguments&amp;... arguments) const</span>
<span class="line-added">116     {</span>
<span class="line-added">117         if (!state-&gt;client.alwaysOnLoggingAllowed())</span>
<span class="line-added">118             return;</span>
<span class="line-added">119 </span>
<span class="line-added">120         m_logger-&gt;logAlways(LogMedia, makeString(&quot;WebMediaSessionManager::&quot;, methodName, &#39; &#39;), state-&gt;contextId, state-&gt;flags, arguments...);</span>
<span class="line-added">121     }</span>
<span class="line-added">122 </span>
<span class="line-added">123     template&lt;typename... Arguments&gt;</span>
<span class="line-added">124     inline void logAlways(const char* methodName, const Arguments&amp;... arguments) const</span>
<span class="line-added">125     {</span>
<span class="line-added">126         if (!m_manager.alwaysOnLoggingAllowed())</span>
<span class="line-added">127             return;</span>
<span class="line-added">128 </span>
<span class="line-added">129         m_logger-&gt;logAlways(LogMedia, makeString(&quot;WebMediaSessionManager::&quot;, methodName, &#39; &#39;), arguments...);</span>
<span class="line-added">130     }</span>
<span class="line-added">131 </span>
<span class="line-added">132 private:</span>
<span class="line-added">133     friend std::unique_ptr&lt;WebMediaSessionLogger&gt; std::make_unique&lt;WebMediaSessionLogger&gt;(WebMediaSessionManager&amp;);</span>
<span class="line-added">134     WebMediaSessionLogger(WebMediaSessionManager&amp; manager)</span>
<span class="line-added">135         : m_manager(manager)</span>
<span class="line-added">136         , m_logger(Logger::create(this))</span>
<span class="line-added">137     {</span>
<span class="line-added">138     }</span>
<span class="line-added">139 </span>
<span class="line-added">140     WebMediaSessionManager&amp; m_manager;</span>
<span class="line-added">141     Ref&lt;Logger&gt; m_logger;</span>
<span class="line-added">142 };</span>
<span class="line-added">143 </span>
<span class="line-added">144 WebMediaSessionLogger&amp; WebMediaSessionManager::logger()</span>
145 {
<span class="line-modified">146     if (!m_logger)</span>
<span class="line-added">147         m_logger = WebMediaSessionLogger::create(*this);</span>
148 
<span class="line-added">149     return *m_logger;</span>
<span class="line-added">150 }</span>
<span class="line-added">151 </span>
<span class="line-added">152 bool WebMediaSessionManager::alwaysOnLoggingAllowed() const</span>
<span class="line-added">153 {</span>
<span class="line-added">154     return allOf(m_clientState, [] (auto&amp; state) {</span>
<span class="line-added">155         return state-&gt;client.alwaysOnLoggingAllowed();</span>
<span class="line-added">156     });</span>
<span class="line-added">157 }</span>
<span class="line-added">158 </span>
<span class="line-added">159 void WebMediaSessionManager::setMockMediaPlaybackTargetPickerEnabled(bool enabled)</span>
<span class="line-added">160 {</span>
161     if (m_mockPickerEnabled == enabled)
162         return;
163 
<span class="line-added">164     ALWAYS_LOG(LOGIDENTIFIER);</span>
165     m_mockPickerEnabled = enabled;
166 }
167 
168 void WebMediaSessionManager::setMockMediaPlaybackTargetPickerState(const String&amp; name, MediaPlaybackTargetContext::State state)
169 {
<span class="line-modified">170     ALWAYS_LOG(LOGIDENTIFIER);</span>

171     mockPicker().setState(name, state);
172 }
173 
<span class="line-added">174 void WebMediaSessionManager::mockMediaPlaybackTargetPickerDismissPopup()</span>
<span class="line-added">175 {</span>
<span class="line-added">176     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">177     mockPicker().dismissPopup();</span>
<span class="line-added">178 }</span>
<span class="line-added">179 </span>
180 MediaPlaybackTargetPickerMock&amp; WebMediaSessionManager::mockPicker()
181 {
182     if (!m_pickerOverride)
183         m_pickerOverride = makeUnique&lt;MediaPlaybackTargetPickerMock&gt;(*this);
184 
185     return *m_pickerOverride.get();
186 }
187 
188 WebCore::MediaPlaybackTargetPicker&amp; WebMediaSessionManager::targetPicker()
189 {
190     if (m_mockPickerEnabled)
191         return mockPicker();
192 
193     return platformPicker();
194 }
195 
196 WebMediaSessionManager::WebMediaSessionManager()
197     : m_taskTimer(RunLoop::current(), this, &amp;WebMediaSessionManager::taskTimerFired)
198     , m_watchdogTimer(RunLoop::current(), this, &amp;WebMediaSessionManager::watchdogTimerFired)
199 {
200 }
201 
202 WebMediaSessionManager::~WebMediaSessionManager() = default;
203 
204 uint64_t WebMediaSessionManager::addPlaybackTargetPickerClient(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
205 {
206     size_t index = find(&amp;client, contextId);
207     ASSERT(index == notFound);
208     if (index != notFound)
209         return 0;
210 
<span class="line-modified">211     ALWAYS_LOG(LOGIDENTIFIER, contextId);</span>

212     m_clientState.append(makeUnique&lt;ClientState&gt;(client, contextId));
213 
214     if (m_externalOutputDeviceAvailable || m_playbackTarget)
215         scheduleDelayedTask(InitialConfigurationTask | TargetClientsConfigurationTask);
216 
217     return contextId;
218 }
219 
220 void WebMediaSessionManager::removePlaybackTargetPickerClient(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
221 {
222     size_t index = find(&amp;client, contextId);
223     ASSERT(index != notFound);
224     if (index == notFound)
225         return;
226 
<span class="line-modified">227     ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get());</span>
228 
229     m_clientState.remove(index);
230     scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
231 }
232 
233 void WebMediaSessionManager::removeAllPlaybackTargetPickerClients(WebMediaSessionManagerClient&amp; client)
234 {
235     if (m_clientState.isEmpty())
236         return;
237 


238     for (size_t i = m_clientState.size(); i &gt; 0; --i) {
<span class="line-modified">239         if (&amp;m_clientState[i - 1]-&gt;client == &amp;client) {</span>
<span class="line-added">240             ALWAYS_LOG(LOGIDENTIFIER, m_clientState[i - 1].get());</span>
241             m_clientState.remove(i - 1);
<span class="line-added">242         }</span>
243     }
244     scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
245 }
246 
247 void WebMediaSessionManager::showPlaybackTargetPicker(WebMediaSessionManagerClient&amp; client, uint64_t contextId, const IntRect&amp; rect, bool, bool useDarkAppearance)
248 {
249     size_t index = find(&amp;client, contextId);
250     ASSERT(index != notFound);
251     if (index == notFound)
252         return;
253 
254     auto&amp; clientRequestingPicker = m_clientState[index];
255     for (auto&amp; state : m_clientState) {
256         state-&gt;requestedPicker = state == clientRequestingPicker;
257         state-&gt;previouslyRequestedPicker = state == clientRequestingPicker;
258     }
259 
<span class="line-added">260     ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get());</span>
<span class="line-added">261 </span>
262     bool hasActiveRoute = flagsAreSet(m_clientState[index]-&gt;flags, MediaProducer::IsPlayingToExternalDevice);

263     targetPicker().showPlaybackTargetPicker(FloatRect(rect), hasActiveRoute, useDarkAppearance);
264 }
265 
266 void WebMediaSessionManager::clientStateDidChange(WebMediaSessionManagerClient&amp; client, uint64_t contextId, MediaProducer::MediaStateFlags newFlags)
267 {
268     size_t index = find(&amp;client, contextId);
269     ASSERT(index != notFound);
270     if (index == notFound)
271         return;
272 
273     auto&amp; changedClientState = m_clientState[index];
274     MediaProducer::MediaStateFlags oldFlags = changedClientState-&gt;flags;
275     if (newFlags == oldFlags)
276         return;
277 
<span class="line-modified">278     ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get(), &quot;new flags = &quot;, newFlags);</span>
279 
280     changedClientState-&gt;flags = newFlags;
281 
282     MediaProducer::MediaStateFlags updateConfigurationFlags = MediaProducer::RequiresPlaybackTargetMonitoring | MediaProducer::HasPlaybackTargetAvailabilityListener | MediaProducer::HasAudioOrVideo;
283     if ((oldFlags &amp; updateConfigurationFlags) != (newFlags &amp; updateConfigurationFlags))
284         scheduleDelayedTask(TargetMonitoringConfigurationTask);
285 
286     MediaProducer::MediaStateFlags playingToTargetFlags = MediaProducer::IsPlayingToExternalDevice | MediaProducer::IsPlayingVideo;
287     if ((oldFlags &amp; playingToTargetFlags) != (newFlags &amp; playingToTargetFlags)) {
288         if (flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo) &amp;&amp; !flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) &amp;&amp; flagsAreSet(newFlags, MediaProducer::DidPlayToEnd))
289             changedClientState-&gt;playedToEnd = true;
290         scheduleDelayedTask(WatchdogTimerConfigurationTask);
291     }
292 
293     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute() || !flagsAreSet(newFlags, MediaProducer::ExternalDeviceAutoPlayCandidate))
294         return;
295 
296     // Do not interrupt another element already playing to a device.
297     for (auto&amp; state : m_clientState) {
298         if (state == changedClientState)
299             continue;
300 
<span class="line-modified">301         if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo)) {</span>
<span class="line-added">302             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; returning early&quot;);</span>
303             return;
<span class="line-added">304         }</span>
305     }
306 
307     // Do not begin playing to the device unless playback has just started.
<span class="line-modified">308     if (!flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) || flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo)) {</span>
<span class="line-added">309         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning early, playback didn&#39;t just start&quot;);</span>
310         return;
<span class="line-added">311     }</span>
312 
313     for (auto&amp; state : m_clientState) {
314         if (state == changedClientState)
315             continue;
<span class="line-added">316         ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling setShouldPlayToPlaybackTarget(false)&quot;);</span>
317         state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);
318     }
319 
<span class="line-added">320     ALWAYS_LOG(LOGIDENTIFIER, changedClientState.get(), &quot; calling setShouldPlayToPlaybackTarget(true)&quot;);</span>
321     changedClientState-&gt;client.setShouldPlayToPlaybackTarget(changedClientState-&gt;contextId, true);
322 
323     if (index &amp;&amp; m_clientState.size() &gt; 1)
324         std::swap(m_clientState.at(index), m_clientState.at(0));
325 }
326 
327 void WebMediaSessionManager::setPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
328 {
<span class="line-added">329     ALWAYS_LOG(LOGIDENTIFIER, &quot;has active route = &quot;, target-&gt;hasActiveRoute());</span>
330     m_playbackTarget = WTFMove(target);
331     m_targetChanged = true;
332     scheduleDelayedTask(TargetClientsConfigurationTask);
333 }
334 
335 void WebMediaSessionManager::externalOutputDeviceAvailableDidChange(bool available)
336 {
<span class="line-modified">337     ALWAYS_LOG(LOGIDENTIFIER, available);</span>

338     m_externalOutputDeviceAvailable = available;
339     for (auto&amp; state : m_clientState)
340         state-&gt;client.externalOutputDeviceAvailableDidChange(state-&gt;contextId, available);
341 }
342 
<span class="line-added">343 void WebMediaSessionManager::playbackTargetPickerWasDismissed()</span>
<span class="line-added">344 {</span>
<span class="line-added">345     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">346     m_playbackTargetPickerDismissed = true;</span>
<span class="line-added">347     scheduleDelayedTask(TargetClientsConfigurationTask);</span>
<span class="line-added">348 }</span>
<span class="line-added">349 </span>
350 void WebMediaSessionManager::configureNewClients()
351 {
352     for (auto&amp; state : m_clientState) {
353         if (!state-&gt;configurationRequired)
354             continue;
355 
356         state-&gt;configurationRequired = false;
357         if (m_externalOutputDeviceAvailable)
358             state-&gt;client.externalOutputDeviceAvailableDidChange(state-&gt;contextId, true);
359 
360         if (m_playbackTarget)
361             state-&gt;client.setPlaybackTarget(state-&gt;contextId, *m_playbackTarget.copyRef());
362     }
363 }
364 
365 void WebMediaSessionManager::configurePlaybackTargetClients()
366 {
367     if (m_clientState.isEmpty())
368         return;
369 
370     size_t indexOfClientThatRequestedPicker = notFound;
371     size_t indexOfLastClientToRequestPicker = notFound;
372     size_t indexOfClientWillPlayToTarget = notFound;
373     bool haveActiveRoute = m_playbackTarget &amp;&amp; m_playbackTarget-&gt;hasActiveRoute();
374 
375     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
376         auto&amp; state = m_clientState[i];
377 
<span class="line-modified">378         ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot;, requestedPicker = &quot;, state-&gt;requestedPicker);</span>
379 
<span class="line-modified">380         if ((m_targetChanged || m_playbackTargetPickerDismissed) &amp;&amp; state-&gt;requestedPicker)</span>
381             indexOfClientThatRequestedPicker = i;
382 
383         if (indexOfClientWillPlayToTarget == notFound &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice))
384             indexOfClientWillPlayToTarget = i;
385 
386         if (indexOfClientWillPlayToTarget == notFound &amp;&amp; haveActiveRoute &amp;&amp; state-&gt;previouslyRequestedPicker)
387             indexOfLastClientToRequestPicker = i;
388     }
389 
390     if (indexOfClientThatRequestedPicker != notFound)
391         indexOfClientWillPlayToTarget = indexOfClientThatRequestedPicker;
392     if (indexOfClientWillPlayToTarget == notFound &amp;&amp; indexOfLastClientToRequestPicker != notFound)
393         indexOfClientWillPlayToTarget = indexOfLastClientToRequestPicker;
394     if (indexOfClientWillPlayToTarget == notFound &amp;&amp; haveActiveRoute &amp;&amp; flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::ExternalDeviceAutoPlayCandidate) &amp;&amp; !flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::IsPlayingVideo))
395         indexOfClientWillPlayToTarget = 0;
396 


397     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
398         auto&amp; state = m_clientState[i];
399 
400         if (m_playbackTarget)
401             state-&gt;client.setPlaybackTarget(state-&gt;contextId, *m_playbackTarget.copyRef());
402 
<span class="line-modified">403         if (i != indexOfClientWillPlayToTarget || !haveActiveRoute) {</span>
<span class="line-added">404             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling setShouldPlayToPlaybackTarget(false)&quot;);</span>
405             state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);
<span class="line-added">406         }</span>
<span class="line-added">407 </span>
<span class="line-added">408         if (state-&gt;requestedPicker &amp;&amp; m_playbackTargetPickerDismissed) {</span>
<span class="line-added">409             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling playbackTargetPickerWasDismissed&quot;);</span>
<span class="line-added">410             state-&gt;client.playbackTargetPickerWasDismissed(state-&gt;contextId);</span>
<span class="line-added">411         }</span>
412 
413         state-&gt;configurationRequired = false;
<span class="line-modified">414         if (m_targetChanged || m_playbackTargetPickerDismissed)</span>
415             state-&gt;requestedPicker = false;
416     }
417 
418     if (haveActiveRoute &amp;&amp; indexOfClientWillPlayToTarget != notFound) {
419         auto&amp; state = m_clientState[indexOfClientWillPlayToTarget];
<span class="line-modified">420         if (!flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice)) {</span>
<span class="line-added">421             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling setShouldPlayToPlaybackTarget(true)&quot;);</span>
422             state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, true);
<span class="line-added">423         }</span>
424     }
425 
426     m_targetChanged = false;
427     configureWatchdogTimer();
428 }
429 
430 void WebMediaSessionManager::configurePlaybackTargetMonitoring()
431 {
432     bool monitoringRequired = false;
433     bool hasAvailabilityListener = false;
434     bool haveClientWithMedia = false;
435     for (auto&amp; state : m_clientState) {
<span class="line-added">436         ALWAYS_LOG(LOGIDENTIFIER, state.get());</span>
437         if (state-&gt;flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring) {
438             monitoringRequired = true;
439             break;
440         }
441         if (state-&gt;flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
442             hasAvailabilityListener = true;
443         if (state-&gt;flags &amp; MediaProducer::HasAudioOrVideo)
444             haveClientWithMedia = true;
445     }
446 
<span class="line-modified">447     if (monitoringRequired || (hasAvailabilityListener &amp;&amp; haveClientWithMedia)) {</span>
<span class="line-modified">448         ALWAYS_LOG(LOGIDENTIFIER, &quot;starting monitoring&quot;);</span>

449         targetPicker().startingMonitoringPlaybackTargets();
<span class="line-modified">450     } else {</span>
<span class="line-added">451         ALWAYS_LOG(LOGIDENTIFIER, &quot;stopping monitoring&quot;);</span>
452         targetPicker().stopMonitoringPlaybackTargets();
<span class="line-added">453     }</span>
454 }
455 





















456 void WebMediaSessionManager::scheduleDelayedTask(ConfigurationTasks tasks)
457 {


458     m_taskFlags |= tasks;
459     m_taskTimer.startOneShot(taskDelayInterval);
460 }
461 
462 void WebMediaSessionManager::taskTimerFired()
463 {


464     if (m_taskFlags &amp; InitialConfigurationTask)
465         configureNewClients();
466     if (m_taskFlags &amp; TargetClientsConfigurationTask)
467         configurePlaybackTargetClients();
468     if (m_taskFlags &amp; TargetMonitoringConfigurationTask)
469         configurePlaybackTargetMonitoring();
470     if (m_taskFlags &amp; WatchdogTimerConfigurationTask)
471         configureWatchdogTimer();
472 
473     m_taskFlags = NoTask;
474 }
475 
476 size_t WebMediaSessionManager::find(WebMediaSessionManagerClient* client, uint64_t contextId)
477 {
478     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
479         if (m_clientState[i]-&gt;contextId == contextId &amp;&amp; &amp;m_clientState[i]-&gt;client == client)
480             return i;
481     }
482 
483     return notFound;
484 }
485 
486 void WebMediaSessionManager::configureWatchdogTimer()
487 {
488     static const Seconds watchdogTimerIntervalAfterPausing { 1_h };
489     static const Seconds watchdogTimerIntervalAfterPlayingToEnd { 8_min };
490 
491     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute()) {
<span class="line-modified">492         if (m_watchdogTimer.isActive()) {</span>
<span class="line-added">493             ALWAYS_LOG(LOGIDENTIFIER, &quot;stopping timer&quot;);</span>
<span class="line-added">494             m_currentWatchdogInterval = { };</span>
<span class="line-added">495             m_watchdogTimer.stop();</span>
<span class="line-added">496         }</span>
<span class="line-added">497 </span>
498         return;
499     }
500 
501     bool stopTimer = false;
502     bool didPlayToEnd = false;
503     for (auto&amp; state : m_clientState) {
<span class="line-added">504 </span>
<span class="line-added">505         ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; playedToEnd = &quot;, state-&gt;playedToEnd);</span>
<span class="line-added">506 </span>
507         if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo))
508             stopTimer = true;
509         if (state-&gt;playedToEnd)
510             didPlayToEnd = true;
511         state-&gt;playedToEnd = false;
512     }
513 
514     if (stopTimer) {
<span class="line-added">515         ALWAYS_LOG(LOGIDENTIFIER, &quot;stopping timer&quot;);</span>
516         m_currentWatchdogInterval = { };
517         m_watchdogTimer.stop();

518     } else {
519         Seconds interval = didPlayToEnd ? watchdogTimerIntervalAfterPlayingToEnd : watchdogTimerIntervalAfterPausing;
520         if (interval != m_currentWatchdogInterval || !m_watchdogTimer.isActive()) {
521             m_watchdogTimer.startOneShot(interval);

522         }
<span class="line-added">523         ALWAYS_LOG(LOGIDENTIFIER, &quot;timer scheduled for &quot;, interval.value(), &quot; seconds&quot;);</span>
524         m_currentWatchdogInterval = interval;
525     }
526 }
527 
528 void WebMediaSessionManager::watchdogTimerFired()
529 {

530     if (!m_playbackTarget)
531         return;
532 
<span class="line-added">533     ALWAYS_LOG(LOGIDENTIFIER);</span>
534     targetPicker().invalidatePlaybackTargets();
535 }
536 
537 } // namespace WebCore
538 
539 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET) &amp;&amp; !PLATFORM(IOS_FAMILY)
</pre>
</td>
</tr>
</table>
<center><a href="../mediarecorder/MediaRecorderErrorEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebMediaSessionManager.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
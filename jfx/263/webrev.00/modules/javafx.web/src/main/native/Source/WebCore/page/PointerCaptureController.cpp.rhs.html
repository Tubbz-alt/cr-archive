<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/PointerCaptureController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1.  Redistributions of source code must retain the above copyright
  8  *     notice, this list of conditions and the following disclaimer.
  9  * 2.  Redistributions in binary form must reproduce the above copyright
 10  *     notice, this list of conditions and the following disclaimer in the
 11  *     documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;PointerCaptureController.h&quot;
 27 
 28 #if ENABLE(POINTER_EVENTS)
 29 
 30 #include &quot;Document.h&quot;
 31 #include &quot;Element.h&quot;
 32 #include &quot;EventHandler.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;EventTarget.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 35 #include &quot;HitTestResult.h&quot;</span>
 36 #include &quot;Page.h&quot;
 37 #include &quot;PointerEvent.h&quot;
 38 #include &lt;wtf/CheckedArithmetic.h&gt;
 39 
 40 #if ENABLE(POINTER_LOCK)
 41 #include &quot;PointerLockController.h&quot;
 42 #endif
 43 
 44 namespace WebCore {
 45 
 46 PointerCaptureController::PointerCaptureController(Page&amp; page)
 47     : m_page(page)
 48 {
 49     reset();
 50 }
 51 
 52 Element* PointerCaptureController::pointerCaptureElement(Document* document, PointerID pointerId)
 53 {
 54     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
 55     if (iterator != m_activePointerIdsToCapturingData.end()) {
 56         auto pointerCaptureElement = iterator-&gt;value.targetOverride;
 57         if (pointerCaptureElement &amp;&amp; &amp;pointerCaptureElement-&gt;document() == document)
 58             return pointerCaptureElement.get();
 59     }
 60     return nullptr;
 61 }
 62 
 63 ExceptionOr&lt;void&gt; PointerCaptureController::setPointerCapture(Element* capturingTarget, PointerID pointerId)
 64 {
 65     // https://w3c.github.io/pointerevents/#setting-pointer-capture
 66 
 67     // 1. If the pointerId provided as the method&#39;s argument does not match any of the active pointers, then throw a DOMException with the name NotFoundError.
 68     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
 69     if (iterator == m_activePointerIdsToCapturingData.end())
 70         return Exception { NotFoundError };
 71 
 72     // 2. If the Element on which this method is invoked is not connected, throw an exception with the name InvalidStateError.
 73     if (!capturingTarget-&gt;isConnected())
 74         return Exception { InvalidStateError };
 75 
 76 #if ENABLE(POINTER_LOCK)
 77     // 3. If this method is invoked while the document has a locked element, throw an exception with the name InvalidStateError.
 78     if (auto* page = capturingTarget-&gt;document().page()) {
 79         if (page-&gt;pointerLockController().isLocked())
 80             return Exception { InvalidStateError };
 81     }
 82 #endif
 83 
 84     // 4. If the pointer is not in the active buttons state, then terminate these steps.
 85     // 5. For the specified pointerId, set the pending pointer capture target override to the Element on which this method was invoked.
 86     auto&amp; capturingData = iterator-&gt;value;
 87     if (capturingData.pointerIsPressed)
 88         capturingData.pendingTargetOverride = capturingTarget;
 89 
 90     return { };
 91 }
 92 
 93 ExceptionOr&lt;void&gt; PointerCaptureController::releasePointerCapture(Element* capturingTarget, PointerID pointerId)
 94 {
 95     // https://w3c.github.io/pointerevents/#releasing-pointer-capture
 96 
 97     // Pointer capture is released on an element explicitly by calling the element.releasePointerCapture(pointerId) method.
 98     // When this method is called, a user agent MUST run the following steps:
 99 
100     // 1. If the pointerId provided as the method&#39;s argument does not match any of the active pointers and these steps are not
101     // being invoked as a result of the implicit release of pointer capture, then throw a DOMException with the name NotFoundError.
102     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
103     if (iterator == m_activePointerIdsToCapturingData.end())
104         return Exception { NotFoundError };
105 
106     // 2. If hasPointerCapture is false for the Element with the specified pointerId, then terminate these steps.
107     if (!hasPointerCapture(capturingTarget, pointerId))
108         return { };
109 
110     // 3. For the specified pointerId, clear the pending pointer capture target override, if set.
111     iterator-&gt;value.pendingTargetOverride = nullptr;
112 
113     return { };
114 }
115 
116 bool PointerCaptureController::hasPointerCapture(Element* capturingTarget, PointerID pointerId)
117 {
118     // https://w3c.github.io/pointerevents/#dom-element-haspointercapture
119 
120     // Indicates whether the element on which this method is invoked has pointer capture for the pointer identified by the argument pointerId.
121     // In particular, returns true if the pending pointer capture target override for pointerId is set to the element on which this method is
122     // invoked, and false otherwise.
123 
124     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
125     return iterator != m_activePointerIdsToCapturingData.end() &amp;&amp; iterator-&gt;value.pendingTargetOverride == capturingTarget;
126 }
127 
128 void PointerCaptureController::pointerLockWasApplied()
129 {
130     // https://w3c.github.io/pointerevents/#implicit-release-of-pointer-capture
131 
132     // When a pointer lock is successfully applied on an element, a user agent MUST run the steps as if the releasePointerCapture()
133     // method has been called if any element is set to be captured or pending to be captured.
134     for (auto&amp; capturingData : m_activePointerIdsToCapturingData.values()) {
135         capturingData.pendingTargetOverride = nullptr;
136         capturingData.targetOverride = nullptr;
137     }
138 }
139 
140 void PointerCaptureController::elementWasRemoved(Element&amp; element)
141 {
142     for (auto&amp; keyAndValue : m_activePointerIdsToCapturingData) {
143         auto&amp; capturingData = keyAndValue.value;
144         if (capturingData.pendingTargetOverride == &amp;element || capturingData.targetOverride == &amp;element) {
145             // https://w3c.github.io/pointerevents/#implicit-release-of-pointer-capture
146             // When the pointer capture target override is no longer connected, the pending pointer capture target override and pointer capture target
147             // override nodes SHOULD be cleared and also a PointerEvent named lostpointercapture corresponding to the captured pointer SHOULD be fired
148             // at the document.
149             ASSERT(WTF::isInBounds&lt;PointerID&gt;(keyAndValue.key));
150             auto pointerId = static_cast&lt;PointerID&gt;(keyAndValue.key);
151             auto pointerType = capturingData.pointerType;
152             releasePointerCapture(&amp;element, pointerId);
<a name="2" id="anc2"></a><span class="line-modified">153             // FIXME: Spec doesn&#39;t specify which task source to use.</span>
<span class="line-added">154             element.document().queueTaskToDispatchEvent(TaskSource::UserInteraction, PointerEvent::create(eventNames().lostpointercaptureEvent, pointerId, pointerType));</span>
155             return;
156         }
157     }
158 }
159 
160 void PointerCaptureController::reset()
161 {
162     m_activePointerIdsToCapturingData.clear();
<a name="3" id="anc3"></a><span class="line-modified">163 </span>
164     CapturingData capturingData;
165     capturingData.pointerType = PointerEvent::mousePointerType();
166     m_activePointerIdsToCapturingData.add(mousePointerID, capturingData);
<a name="4" id="anc4"></a>
167 }
168 
169 void PointerCaptureController::touchWithIdentifierWasRemoved(PointerID pointerId)
170 {
171     m_activePointerIdsToCapturingData.remove(pointerId);
172 }
173 
174 bool PointerCaptureController::hasCancelledPointerEventForIdentifier(PointerID pointerId)
175 {
176     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
177     return iterator != m_activePointerIdsToCapturingData.end() &amp;&amp; iterator-&gt;value.cancelled;
178 }
179 
180 bool PointerCaptureController::preventsCompatibilityMouseEventsForIdentifier(PointerID pointerId)
181 {
182     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
183     return iterator != m_activePointerIdsToCapturingData.end() &amp;&amp; iterator-&gt;value.preventsCompatibilityMouseEvents;
184 }
185 
186 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
<a name="5" id="anc5"></a><span class="line-added">187 static bool hierarchyHasCapturingEventListeners(Element* target, const AtomString&amp; eventName)</span>
<span class="line-added">188 {</span>
<span class="line-added">189     for (ContainerNode* curr = target; curr; curr = curr-&gt;parentInComposedTree()) {</span>
<span class="line-added">190         if (curr-&gt;hasCapturingEventListeners(eventName))</span>
<span class="line-added">191             return true;</span>
<span class="line-added">192     }</span>
<span class="line-added">193     return false;</span>
<span class="line-added">194 }</span>
<span class="line-added">195 </span>
196 void PointerCaptureController::dispatchEventForTouchAtIndex(EventTarget&amp; target, const PlatformTouchEvent&amp; platformTouchEvent, unsigned index, bool isPrimary, WindowProxy&amp; view)
197 {
<a name="6" id="anc6"></a><span class="line-modified">198     ASSERT(is&lt;Element&gt;(target));</span>
<span class="line-modified">199 </span>
<span class="line-added">200     auto dispatchOverOrOutEvent = [&amp;](const String&amp; type, EventTarget* target) {</span>
<span class="line-added">201         dispatchEvent(PointerEvent::create(type, platformTouchEvent, index, isPrimary, view), target);</span>
202     };
203 
204     auto dispatchEnterOrLeaveEvent = [&amp;](const String&amp; type) {
<a name="7" id="anc7"></a>


205         auto* targetElement = &amp;downcast&lt;Element&gt;(target);
206 
207         bool hasCapturingListenerInHierarchy = false;
208         for (ContainerNode* curr = targetElement; curr; curr = curr-&gt;parentInComposedTree()) {
209             if (curr-&gt;hasCapturingEventListeners(type)) {
210                 hasCapturingListenerInHierarchy = true;
211                 break;
212             }
213         }
214 
215         Vector&lt;Ref&lt;Element&gt;, 32&gt; targetChain;
216         for (Element* element = targetElement; element; element = element-&gt;parentElementInComposedTree()) {
217             if (hasCapturingListenerInHierarchy || element-&gt;hasEventListeners(type))
218                 targetChain.append(*element);
219         }
220 
221         if (type == eventNames().pointerenterEvent) {
222             for (auto&amp; element : WTF::makeReversedRange(targetChain))
223                 dispatchEvent(PointerEvent::create(type, platformTouchEvent, index, isPrimary, view), element.ptr());
224         } else {
225             for (auto&amp; element : targetChain)
226                 dispatchEvent(PointerEvent::create(type, platformTouchEvent, index, isPrimary, view), element.ptr());
227         }
228     };
229 
230     auto pointerEvent = PointerEvent::create(platformTouchEvent, index, isPrimary, view);
231 
<a name="8" id="anc8"></a><span class="line-added">232     auto&amp; capturingData = ensureCapturingDataForPointerEvent(pointerEvent);</span>
<span class="line-added">233 </span>
<span class="line-added">234     // Check if the target changed, which would require dispatching boundary events.</span>
<span class="line-added">235     RefPtr&lt;Element&gt; previousTarget = capturingData.previousTarget;</span>
<span class="line-added">236     RefPtr&lt;Element&gt; currentTarget = downcast&lt;Element&gt;(&amp;target);</span>
<span class="line-added">237 </span>
<span class="line-added">238     capturingData.previousTarget = currentTarget;</span>
<span class="line-added">239 </span>
<span class="line-added">240     if (pointerEvent-&gt;type() == eventNames().pointermoveEvent &amp;&amp; previousTarget != currentTarget) {</span>
<span class="line-added">241         // The pointerenter and pointerleave events are only dispatched if there is a capturing event listener on an ancestor</span>
<span class="line-added">242         // or a normal event listener on the element itself since those events do not bubble.</span>
<span class="line-added">243         // This optimization is necessary since these events can cause O(n^2) capturing event-handler checks. This follows the</span>
<span class="line-added">244         // code for similar mouse events in EventHandler::updateMouseEventTargetNode().</span>
<span class="line-added">245         bool hasCapturingPointerEnterListener = hierarchyHasCapturingEventListeners(currentTarget.get(), eventNames().pointerenterEvent);</span>
<span class="line-added">246         bool hasCapturingPointerLeaveListener = hierarchyHasCapturingEventListeners(previousTarget.get(), eventNames().pointerleaveEvent);</span>
<span class="line-added">247 </span>
<span class="line-added">248         Vector&lt;Ref&lt;Element&gt;, 32&gt; leftElementsChain;</span>
<span class="line-added">249         for (Element* element = previousTarget.get(); element; element = element-&gt;parentElementInComposedTree())</span>
<span class="line-added">250             leftElementsChain.append(*element);</span>
<span class="line-added">251         Vector&lt;Ref&lt;Element&gt;, 32&gt; enteredElementsChain;</span>
<span class="line-added">252         for (Element* element = currentTarget.get(); element; element = element-&gt;parentElementInComposedTree())</span>
<span class="line-added">253             enteredElementsChain.append(*element);</span>
<span class="line-added">254 </span>
<span class="line-added">255         if (!leftElementsChain.isEmpty() &amp;&amp; !enteredElementsChain.isEmpty() &amp;&amp; leftElementsChain.last().ptr() == enteredElementsChain.last().ptr()) {</span>
<span class="line-added">256             size_t minHeight = std::min(leftElementsChain.size(), enteredElementsChain.size());</span>
<span class="line-added">257             size_t i;</span>
<span class="line-added">258             for (i = 0; i &lt; minHeight; ++i) {</span>
<span class="line-added">259                 if (leftElementsChain[leftElementsChain.size() - i - 1].ptr() != enteredElementsChain[enteredElementsChain.size() - i - 1].ptr())</span>
<span class="line-added">260                     break;</span>
<span class="line-added">261             }</span>
<span class="line-added">262             leftElementsChain.shrink(leftElementsChain.size() - i);</span>
<span class="line-added">263             enteredElementsChain.shrink(enteredElementsChain.size() - i);</span>
<span class="line-added">264         }</span>
<span class="line-added">265 </span>
<span class="line-added">266         if (previousTarget)</span>
<span class="line-added">267             dispatchOverOrOutEvent(eventNames().pointeroutEvent, previousTarget.get());</span>
<span class="line-added">268 </span>
<span class="line-added">269         for (auto&amp; chain : leftElementsChain) {</span>
<span class="line-added">270             if (hasCapturingPointerLeaveListener || chain-&gt;hasEventListeners(eventNames().pointerleaveEvent))</span>
<span class="line-added">271                 dispatchEvent(PointerEvent::create(eventNames().pointerleaveEvent, platformTouchEvent, index, isPrimary, view), chain.ptr());</span>
<span class="line-added">272         }</span>
<span class="line-added">273 </span>
<span class="line-added">274         if (currentTarget)</span>
<span class="line-added">275             dispatchOverOrOutEvent(eventNames().pointeroverEvent, currentTarget.get());</span>
<span class="line-added">276 </span>
<span class="line-added">277         for (auto&amp; chain : WTF::makeReversedRange(enteredElementsChain)) {</span>
<span class="line-added">278             if (hasCapturingPointerEnterListener || chain-&gt;hasEventListeners(eventNames().pointerenterEvent))</span>
<span class="line-added">279                 dispatchEvent(PointerEvent::create(eventNames().pointerenterEvent, platformTouchEvent, index, isPrimary, view), chain.ptr());</span>
<span class="line-added">280         }</span>
<span class="line-added">281     }</span>
<span class="line-added">282 </span>
283     if (pointerEvent-&gt;type() == eventNames().pointerdownEvent) {
284         // https://w3c.github.io/pointerevents/#the-pointerdown-event
285         // For input devices that do not support hover, a user agent MUST also fire a pointer event named pointerover followed by a pointer event named
286         // pointerenter prior to dispatching the pointerdown event.
<a name="9" id="anc9"></a><span class="line-modified">287         dispatchOverOrOutEvent(eventNames().pointeroverEvent, currentTarget.get());</span>
288         dispatchEnterOrLeaveEvent(eventNames().pointerenterEvent);
289     }
290 
291     dispatchEvent(pointerEvent, &amp;target);
292 
293     if (pointerEvent-&gt;type() == eventNames().pointerupEvent) {
294         // https://w3c.github.io/pointerevents/#the-pointerup-event
295         // For input devices that do not support hover, a user agent MUST also fire a pointer event named pointerout followed by a
296         // pointer event named pointerleave after dispatching the pointerup event.
<a name="10" id="anc10"></a><span class="line-modified">297         dispatchOverOrOutEvent(eventNames().pointeroutEvent, currentTarget.get());</span>
298         dispatchEnterOrLeaveEvent(eventNames().pointerleaveEvent);
<a name="11" id="anc11"></a><span class="line-added">299         capturingData.previousTarget = nullptr;</span>
300     }
301 }
302 #endif
303 
304 RefPtr&lt;PointerEvent&gt; PointerCaptureController::pointerEventForMouseEvent(const MouseEvent&amp; mouseEvent)
305 {
306     const auto&amp; type = mouseEvent.type();
307     const auto&amp; names = eventNames();
308 
309     auto iterator = m_activePointerIdsToCapturingData.find(mousePointerID);
310     ASSERT(iterator != m_activePointerIdsToCapturingData.end());
311     auto&amp; capturingData = iterator-&gt;value;
312 
313     short newButton = mouseEvent.button();
314     short button = (type == names.mousemoveEvent &amp;&amp; newButton == capturingData.previousMouseButton) ? -1 : newButton;
315 
316     // https://w3c.github.io/pointerevents/#chorded-button-interactions
317     // Some pointer devices, such as mouse or pen, support multiple buttons. In the Mouse Event model, each button
318     // press produces a mousedown and mouseup event. To better abstract this hardware difference and simplify
319     // cross-device input authoring, Pointer Events do not fire overlapping pointerdown and pointerup events
320     // for chorded button presses (depressing an additional button while another button on the pointer device is
321     // already depressed).
322     if (type == names.mousedownEvent || type == names.mouseupEvent) {
323         // We&#39;re already active and getting another mousedown, this means that we should dispatch
324         // a pointermove event and let the button state show the newly depressed button.
325         if (type == names.mousedownEvent &amp;&amp; capturingData.pointerIsPressed)
326             return PointerEvent::create(names.pointermoveEvent, button, mouseEvent);
327 
328         // We&#39;re active and the mouseup still has some pressed button, this means we should dispatch
329         // a pointermove event.
330         if (type == names.mouseupEvent &amp;&amp; capturingData.pointerIsPressed &amp;&amp; mouseEvent.buttons() &gt; 0)
331             return PointerEvent::create(names.pointermoveEvent, button, mouseEvent);
332     }
333 
334     capturingData.previousMouseButton = newButton;
335 
336     return PointerEvent::create(button, mouseEvent);
337 }
338 
339 void PointerCaptureController::dispatchEvent(PointerEvent&amp; event, EventTarget* target)
340 {
341     if (!target || event.target())
342         return;
343 
344     // https://w3c.github.io/pointerevents/#firing-events-using-the-pointerevent-interface
345     // If the event is not gotpointercapture or lostpointercapture, run Process Pending Pointer Capture steps for this PointerEvent.
346     // We only need to do this for non-mouse type since for mouse events this method will be called in Document::prepareMouseEvent().
347     if (event.pointerType() != PointerEvent::mousePointerType())
348         processPendingPointerCapture(event.pointerId());
349 
350     pointerEventWillBeDispatched(event, target);
351     target-&gt;dispatchEvent(event);
352     pointerEventWasDispatched(event);
353 }
354 
355 void PointerCaptureController::pointerEventWillBeDispatched(const PointerEvent&amp; event, EventTarget* target)
356 {
357     if (!is&lt;Element&gt;(target))
358         return;
359 
360     bool isPointerdown = event.type() == eventNames().pointerdownEvent;
361     bool isPointerup = event.type() == eventNames().pointerupEvent;
362     if (!isPointerdown &amp;&amp; !isPointerup)
363         return;
364 
365     auto pointerId = event.pointerId();
366 
367     if (event.pointerType() == PointerEvent::mousePointerType()) {
368         auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
369         if (iterator != m_activePointerIdsToCapturingData.end())
370             iterator-&gt;value.pointerIsPressed = isPointerdown;
371         return;
372     }
373 
374     if (!isPointerdown)
375         return;
376 
377     // https://w3c.github.io/pointerevents/#implicit-pointer-capture
378 
379     // Some input devices (such as touchscreens) implement a &quot;direct manipulation&quot; metaphor where a pointer is intended to act primarily on the UI
380     // element it became active upon (providing a physical illusion of direct contact, instead of indirect contact via a cursor that conceptually
381     // floats above the UI). Such devices are identified by the InputDeviceCapabilities.pointerMovementScrolls property and should have &quot;implicit
382     // pointer capture&quot; behavior as follows.
383 
384     // Direct manipulation devices should behave exactly as if setPointerCapture was called on the target element just before the invocation of any
385     // pointerdown listeners. The hasPointerCapture API may be used (eg. within any pointerdown listener) to determine whether this has occurred. If
386     // releasePointerCapture is not called for the pointer before the next pointer event is fired, then a gotpointercapture event will be dispatched
387     // to the target (as normal) indicating that capture is active.
388 
<a name="12" id="anc12"></a><span class="line-modified">389     auto&amp; capturingData = ensureCapturingDataForPointerEvent(event);</span>

390     capturingData.pointerIsPressed = true;
<a name="13" id="anc13"></a>
391     setPointerCapture(downcast&lt;Element&gt;(target), pointerId);
392 }
393 
<a name="14" id="anc14"></a><span class="line-added">394 PointerCaptureController::CapturingData&amp; PointerCaptureController::ensureCapturingDataForPointerEvent(const PointerEvent&amp; event)</span>
<span class="line-added">395 {</span>
<span class="line-added">396     return m_activePointerIdsToCapturingData.ensure(event.pointerId(), [&amp;event] {</span>
<span class="line-added">397         CapturingData capturingData;</span>
<span class="line-added">398         capturingData.pointerType = event.pointerType();</span>
<span class="line-added">399         return capturingData;</span>
<span class="line-added">400     }).iterator-&gt;value;</span>
<span class="line-added">401 }</span>
<span class="line-added">402 </span>
403 void PointerCaptureController::pointerEventWasDispatched(const PointerEvent&amp; event)
404 {
405     auto iterator = m_activePointerIdsToCapturingData.find(event.pointerId());
406     if (iterator != m_activePointerIdsToCapturingData.end()) {
407         auto&amp; capturingData = iterator-&gt;value;
408         capturingData.isPrimary = event.isPrimary();
409 
410         // Immediately after firing the pointerup or pointercancel events, a user agent MUST clear the pending pointer capture target
411         // override for the pointerId of the pointerup or pointercancel event that was just dispatched, and then run Process Pending
412         // Pointer Capture steps to fire lostpointercapture if necessary.
413         // https://w3c.github.io/pointerevents/#implicit-release-of-pointer-capture
414         if (event.type() == eventNames().pointerupEvent) {
415             capturingData.pendingTargetOverride = nullptr;
416             processPendingPointerCapture(event.pointerId());
417         }
418 
419         // If a mouse pointer has moved while it isn&#39;t pressed, make sure we reset the preventsCompatibilityMouseEvents flag since
420         // we could otherwise prevent compatibility mouse events while those are only supposed to be prevented while the pointer is pressed.
421         if (event.type() == eventNames().pointermoveEvent &amp;&amp; capturingData.pointerType == PointerEvent::mousePointerType() &amp;&amp; !capturingData.pointerIsPressed)
422             capturingData.preventsCompatibilityMouseEvents = false;
423 
424         // If the pointer event dispatched was pointerdown and the event was canceled, then set the PREVENT MOUSE EVENT flag for this pointerType.
425         // https://www.w3.org/TR/pointerevents/#mapping-for-devices-that-support-hover
426         if (event.type() == eventNames().pointerdownEvent)
427             capturingData.preventsCompatibilityMouseEvents = event.defaultPrevented();
428     }
429 }
430 
431 void PointerCaptureController::cancelPointer(PointerID pointerId, const IntPoint&amp; documentPoint)
432 {
433     // https://w3c.github.io/pointerevents/#the-pointercancel-event
434 
435     // A user agent MUST fire a pointer event named pointercancel in the following circumstances:
436     //
437     // The user agent has determined that a pointer is unlikely to continue to produce events (for example, because of a hardware event).
438     // After having fired the pointerdown event, if the pointer is subsequently used to manipulate the page viewport (e.g. panning or zooming).
439     // Immediately before drag operation starts [HTML], for the pointer that caused the drag operation.
440     // After firing the pointercancel event, a user agent MUST also fire a pointer event named pointerout followed by firing a pointer event named pointerleave.
441 
442     // https://w3c.github.io/pointerevents/#implicit-release-of-pointer-capture
443 
444     // Immediately after firing the pointerup or pointercancel events, a user agent MUST clear the pending pointer capture target
445     // override for the pointerId of the pointerup or pointercancel event that was just dispatched, and then run Process Pending
446     // Pointer Capture steps to fire lostpointercapture if necessary. After running Process Pending Pointer Capture steps, if the
447     // pointer supports hover, user agent MUST also send corresponding boundary events necessary to reflect the current position of
448     // the pointer with no capture.
449 
450     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
451     if (iterator == m_activePointerIdsToCapturingData.end())
452         return;
453 
454     auto&amp; capturingData = iterator-&gt;value;
455     if (capturingData.cancelled)
456         return;
457 
458     capturingData.pendingTargetOverride = nullptr;
459     capturingData.cancelled = true;
460 
<a name="15" id="anc15"></a><span class="line-added">461 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
<span class="line-added">462     capturingData.previousTarget = nullptr;</span>
<span class="line-added">463 #endif</span>
<span class="line-added">464 </span>
465     auto&amp; target = capturingData.targetOverride;
466     if (!target)
467         target = m_page.mainFrame().eventHandler().hitTestResultAtPoint(documentPoint, HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent | HitTestRequest::AllowChildFrameContent).innerNonSharedElement();
468 
469     if (!target)
470         return;
471 
472     // After firing the pointercancel event, a user agent MUST also fire a pointer event named pointerout
473     // followed by firing a pointer event named pointerleave.
474     auto isPrimary = capturingData.isPrimary ? PointerEvent::IsPrimary::Yes : PointerEvent::IsPrimary::No;
475     auto cancelEvent = PointerEvent::create(eventNames().pointercancelEvent, pointerId, capturingData.pointerType, isPrimary);
476     target-&gt;dispatchEvent(cancelEvent);
477     target-&gt;dispatchEvent(PointerEvent::create(eventNames().pointeroutEvent, pointerId, capturingData.pointerType, isPrimary));
478     target-&gt;dispatchEvent(PointerEvent::create(eventNames().pointerleaveEvent, pointerId, capturingData.pointerType, isPrimary));
479     processPendingPointerCapture(pointerId);
480 }
481 
482 void PointerCaptureController::processPendingPointerCapture(PointerID pointerId)
483 {
484     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
485     if (iterator == m_activePointerIdsToCapturingData.end())
486         return;
487 
488     if (m_processingPendingPointerCapture)
489         return;
490 
491     m_processingPendingPointerCapture = true;
492 
493     auto&amp; capturingData = iterator-&gt;value;
494 
495     // Cache the pending target override since it could be modified during the dispatch of events in this function.
496     auto pendingTargetOverride = capturingData.pendingTargetOverride;
497 
498     // https://w3c.github.io/pointerevents/#process-pending-pointer-capture
499     // 1. If the pointer capture target override for this pointer is set and is not equal to the pending pointer capture target override,
500     // then fire a pointer event named lostpointercapture at the pointer capture target override node.
501     if (capturingData.targetOverride &amp;&amp; capturingData.targetOverride != pendingTargetOverride) {
502         if (capturingData.targetOverride-&gt;isConnected())
503             capturingData.targetOverride-&gt;dispatchEvent(PointerEvent::createForPointerCapture(eventNames().lostpointercaptureEvent, pointerId, capturingData.isPrimary, capturingData.pointerType));
504         if (capturingData.pointerType == PointerEvent::mousePointerType()) {
505             if (auto* frame = capturingData.targetOverride-&gt;document().frame())
506                 frame-&gt;eventHandler().pointerCaptureElementDidChange(nullptr);
507         }
508     }
509 
510     // 2. If the pending pointer capture target override for this pointer is set and is not equal to the pointer capture target override,
511     // then fire a pointer event named gotpointercapture at the pending pointer capture target override.
512     if (capturingData.pendingTargetOverride &amp;&amp; capturingData.targetOverride != pendingTargetOverride) {
513         if (capturingData.pointerType == PointerEvent::mousePointerType()) {
514             if (auto* frame = pendingTargetOverride-&gt;document().frame())
515                 frame-&gt;eventHandler().pointerCaptureElementDidChange(pendingTargetOverride.get());
516         }
517         pendingTargetOverride-&gt;dispatchEvent(PointerEvent::createForPointerCapture(eventNames().gotpointercaptureEvent, pointerId, capturingData.isPrimary, capturingData.pointerType));
518     }
519 
520     // 3. Set the pointer capture target override to the pending pointer capture target override, if set. Otherwise, clear the pointer
521     // capture target override.
522     capturingData.targetOverride = pendingTargetOverride;
523 
524     m_processingPendingPointerCapture = false;
525 }
526 
527 } // namespace WebCore
528 
529 #endif // ENABLE(POINTER_EVENTS)
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
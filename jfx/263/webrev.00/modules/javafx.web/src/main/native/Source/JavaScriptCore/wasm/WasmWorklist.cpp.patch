diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmWorklist.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmWorklist.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmWorklist.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmWorklist.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2017 Apple Inc. All rights reserved.
+ * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -32,11 +32,11 @@
 #include "WasmPlan.h"
 
 namespace JSC { namespace Wasm {
 
 namespace WasmWorklistInternal {
-static const bool verbose = false;
+static constexpr bool verbose = false;
 }
 
 const char* Worklist::priorityString(Priority priority)
 {
     switch (priority) {
@@ -144,18 +144,22 @@
 
 void Worklist::enqueue(Ref<Plan> plan)
 {
     LockHolder locker(*m_lock);
 
-    if (!ASSERT_DISABLED) {
+    if (ASSERT_ENABLED) {
         for (const auto& element : m_queue)
             ASSERT_UNUSED(element, element.plan.get() != &plan.get());
     }
 
     dataLogLnIf(WasmWorklistInternal::verbose, "Enqueuing plan");
-    m_queue.enqueue({ Priority::Preparation, nextTicket(),  WTFMove(plan) });
-    m_planEnqueued->notifyOne(locker);
+    bool multiThreaded = plan->multiThreaded();
+    m_queue.enqueue({ multiThreaded ? Priority::Compilation : Priority::Preparation, nextTicket(),  WTFMove(plan) });
+    if (multiThreaded)
+        m_planEnqueued->notifyAll(locker);
+    else
+        m_planEnqueued->notifyOne(locker);
 }
 
 void Worklist::completePlanSynchronously(Plan& plan)
 {
     {

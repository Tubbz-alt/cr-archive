<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2008-2009, 2011, 2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;AccessibilityObject.h&quot;
  31 
  32 #include &quot;AXObjectCache.h&quot;
  33 #include &quot;AccessibilityRenderObject.h&quot;
  34 #include &quot;AccessibilityScrollView.h&quot;
  35 #include &quot;AccessibilityTable.h&quot;
  36 #include &quot;Chrome.h&quot;
  37 #include &quot;ChromeClient.h&quot;
  38 #include &quot;DOMTokenList.h&quot;
  39 #include &quot;Editing.h&quot;
  40 #include &quot;Editor.h&quot;
  41 #include &quot;ElementIterator.h&quot;
  42 #include &quot;Event.h&quot;
  43 #include &quot;EventDispatcher.h&quot;
  44 #include &quot;EventHandler.h&quot;
  45 #include &quot;EventNames.h&quot;
  46 #include &quot;FloatRect.h&quot;
  47 #include &quot;FocusController.h&quot;
  48 #include &quot;Frame.h&quot;
  49 #include &quot;FrameLoader.h&quot;
  50 #include &quot;FrameSelection.h&quot;
  51 #include &quot;HTMLDataListElement.h&quot;
  52 #include &quot;HTMLDetailsElement.h&quot;
  53 #include &quot;HTMLFormControlElement.h&quot;
  54 #include &quot;HTMLInputElement.h&quot;
  55 #include &quot;HTMLMediaElement.h&quot;
  56 #include &quot;HTMLNames.h&quot;
  57 #include &quot;HTMLParserIdioms.h&quot;
  58 #include &quot;HTMLTextAreaElement.h&quot;
  59 #include &quot;HitTestResult.h&quot;
  60 #include &quot;LocalizedStrings.h&quot;
  61 #include &quot;MathMLNames.h&quot;
  62 #include &quot;NodeList.h&quot;
  63 #include &quot;NodeTraversal.h&quot;
  64 #include &quot;Page.h&quot;
  65 #include &quot;RenderImage.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  66 #include &quot;RenderInline.h&quot;</span>
  67 #include &quot;RenderLayer.h&quot;
  68 #include &quot;RenderListItem.h&quot;
  69 #include &quot;RenderListMarker.h&quot;
  70 #include &quot;RenderMenuList.h&quot;
  71 #include &quot;RenderText.h&quot;
  72 #include &quot;RenderTextControl.h&quot;
  73 #include &quot;RenderTheme.h&quot;
  74 #include &quot;RenderView.h&quot;
  75 #include &quot;RenderWidget.h&quot;
  76 #include &quot;RenderedPosition.h&quot;
<a name="2" id="anc2"></a>
  77 #include &quot;Settings.h&quot;
  78 #include &quot;TextCheckerClient.h&quot;
  79 #include &quot;TextCheckingHelper.h&quot;
  80 #include &quot;TextIterator.h&quot;
  81 #include &quot;UserGestureIndicator.h&quot;
  82 #include &quot;VisibleUnits.h&quot;
  83 #include &lt;wtf/NeverDestroyed.h&gt;
  84 #include &lt;wtf/StdLibExtras.h&gt;
  85 #include &lt;wtf/text/StringBuilder.h&gt;
  86 #include &lt;wtf/text/StringView.h&gt;
  87 #include &lt;wtf/text/WTFString.h&gt;
  88 #include &lt;wtf/unicode/CharacterNames.h&gt;
  89 
  90 namespace WebCore {
  91 
  92 using namespace HTMLNames;
  93 
  94 AccessibilityObject::~AccessibilityObject()
  95 {
  96     ASSERT(isDetached());
  97 }
  98 
<a name="3" id="anc3"></a><span class="line-modified">  99 void AccessibilityObject::detachRemoteParts(AccessibilityDetachmentType detachmentType)</span>
 100 {
 101     // Menu close events need to notify the platform. No element is used in the notification because it&#39;s a destruction event.
<a name="4" id="anc4"></a><span class="line-modified"> 102     if (detachmentType == AccessibilityDetachmentType::ElementDestroyed &amp;&amp; roleValue() == AccessibilityRole::Menu) {</span>
<span class="line-modified"> 103         if (auto* cache = axObjectCache())</span>
<span class="line-added"> 104             cache-&gt;postNotification(nullptr, &amp;cache-&gt;document(), AXObjectCache::AXMenuClosed);</span>
<span class="line-added"> 105     }</span>
 106 
 107     // Clear any children and call detachFromParent on them so that
 108     // no children are left with dangling pointers to their parent.
 109     clearChildren();
<a name="5" id="anc5"></a>



 110 }
 111 
 112 bool AccessibilityObject::isDetached() const
 113 {
 114 #if ENABLE(ACCESSIBILITY)
 115     return !wrapper();
 116 #else
 117     return true;
 118 #endif
 119 }
 120 
<a name="6" id="anc6"></a>






















































































































































































 121 // ARIA marks elements as having their accessible name derive from either their contents, or their author provide name.
 122 bool AccessibilityObject::accessibleNameDerivesFromContent() const
 123 {
 124     // First check for objects specifically identified by ARIA.
 125     switch (ariaRoleAttribute()) {
 126     case AccessibilityRole::ApplicationAlert:
 127     case AccessibilityRole::ApplicationAlertDialog:
 128     case AccessibilityRole::ApplicationDialog:
 129     case AccessibilityRole::ApplicationGroup:
 130     case AccessibilityRole::ApplicationLog:
 131     case AccessibilityRole::ApplicationMarquee:
 132     case AccessibilityRole::ApplicationStatus:
 133     case AccessibilityRole::ApplicationTimer:
 134     case AccessibilityRole::ComboBox:
 135     case AccessibilityRole::Definition:
 136     case AccessibilityRole::Document:
 137     case AccessibilityRole::DocumentArticle:
 138     case AccessibilityRole::DocumentMath:
 139     case AccessibilityRole::DocumentNote:
 140     case AccessibilityRole::LandmarkRegion:
 141     case AccessibilityRole::LandmarkDocRegion:
 142     case AccessibilityRole::Form:
 143     case AccessibilityRole::Grid:
 144     case AccessibilityRole::Group:
 145     case AccessibilityRole::Image:
 146     case AccessibilityRole::List:
 147     case AccessibilityRole::ListBox:
 148     case AccessibilityRole::LandmarkBanner:
 149     case AccessibilityRole::LandmarkComplementary:
 150     case AccessibilityRole::LandmarkContentInfo:
 151     case AccessibilityRole::LandmarkNavigation:
 152     case AccessibilityRole::LandmarkMain:
 153     case AccessibilityRole::LandmarkSearch:
 154     case AccessibilityRole::Menu:
 155     case AccessibilityRole::MenuBar:
 156     case AccessibilityRole::ProgressIndicator:
 157     case AccessibilityRole::Meter:
 158     case AccessibilityRole::RadioGroup:
 159     case AccessibilityRole::ScrollBar:
 160     case AccessibilityRole::Slider:
 161     case AccessibilityRole::SpinButton:
 162     case AccessibilityRole::Splitter:
 163     case AccessibilityRole::Table:
 164     case AccessibilityRole::TabList:
 165     case AccessibilityRole::TabPanel:
 166     case AccessibilityRole::TextArea:
 167     case AccessibilityRole::TextField:
 168     case AccessibilityRole::Toolbar:
 169     case AccessibilityRole::TreeGrid:
 170     case AccessibilityRole::Tree:
 171     case AccessibilityRole::WebApplication:
 172         return false;
 173     default:
 174         break;
 175     }
 176 
 177     // Now check for generically derived elements now that we know the element does not match a specific ARIA role.
 178     switch (roleValue()) {
 179     case AccessibilityRole::Slider:
 180     case AccessibilityRole::ListBox:
 181         return false;
 182     default:
 183         break;
 184     }
 185 
 186     return true;
 187 }
 188 
 189 String AccessibilityObject::computedLabel()
 190 {
 191     // This method is being called by WebKit inspector, which may happen at any time, so we need to update our backing store now.
 192     // Also hold onto this object in case updateBackingStore deletes this node.
 193     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
 194     updateBackingStore();
 195     Vector&lt;AccessibilityText&gt; text;
 196     accessibilityText(text);
 197     if (text.size())
 198         return text[0].text;
 199     return String();
 200 }
 201 
 202 bool AccessibilityObject::isBlockquote() const
 203 {
 204     return roleValue() == AccessibilityRole::Blockquote;
 205 }
 206 
 207 bool AccessibilityObject::isTextControl() const
 208 {
 209     switch (roleValue()) {
 210     case AccessibilityRole::ComboBox:
 211     case AccessibilityRole::SearchField:
 212     case AccessibilityRole::TextArea:
 213     case AccessibilityRole::TextField:
 214         return true;
 215     default:
 216         return false;
 217     }
 218 }
 219 
 220 bool AccessibilityObject::isARIATextControl() const
 221 {
 222     return ariaRoleAttribute() == AccessibilityRole::TextArea || ariaRoleAttribute() == AccessibilityRole::TextField || ariaRoleAttribute() == AccessibilityRole::SearchField;
 223 }
 224 
 225 bool AccessibilityObject::isNonNativeTextControl() const
 226 {
 227     return (isARIATextControl() || hasContentEditableAttributeSet()) &amp;&amp; !isNativeTextControl();
 228 }
 229 
 230 bool AccessibilityObject::isLandmark() const
 231 {
 232     switch (roleValue()) {
 233     case AccessibilityRole::LandmarkBanner:
 234     case AccessibilityRole::LandmarkComplementary:
 235     case AccessibilityRole::LandmarkContentInfo:
 236     case AccessibilityRole::LandmarkDocRegion:
 237     case AccessibilityRole::LandmarkMain:
 238     case AccessibilityRole::LandmarkNavigation:
 239     case AccessibilityRole::LandmarkRegion:
 240     case AccessibilityRole::LandmarkSearch:
 241         return true;
 242     default:
 243         return false;
 244     }
 245 }
 246 
 247 bool AccessibilityObject::hasMisspelling() const
 248 {
 249     if (!node())
 250         return false;
 251 
 252     Frame* frame = node()-&gt;document().frame();
 253     if (!frame)
 254         return false;
 255 
 256     Editor&amp; editor = frame-&gt;editor();
 257 
 258     TextCheckerClient* textChecker = editor.textChecker();
 259     if (!textChecker)
 260         return false;
 261 
 262     bool isMisspelled = false;
 263 
 264     if (unifiedTextCheckerEnabled(frame)) {
 265         Vector&lt;TextCheckingResult&gt; results;
 266         checkTextOfParagraph(*textChecker, stringValue(), TextCheckingType::Spelling, results, frame-&gt;selection().selection());
 267         if (!results.isEmpty())
 268             isMisspelled = true;
 269         return isMisspelled;
 270     }
 271 
 272     int misspellingLength = 0;
 273     int misspellingLocation = -1;
 274     textChecker-&gt;checkSpellingOfString(stringValue(), &amp;misspellingLocation, &amp;misspellingLength);
 275     if (misspellingLength || misspellingLocation != -1)
 276         isMisspelled = true;
 277 
 278     return isMisspelled;
 279 }
 280 
<a name="7" id="anc7"></a><span class="line-added"> 281 RefPtr&lt;Range&gt; AccessibilityObject::getMisspellingRange(RefPtr&lt;Range&gt; const&amp; start, AccessibilitySearchDirection direction) const</span>
<span class="line-added"> 282 {</span>
<span class="line-added"> 283     auto node = this-&gt;node();</span>
<span class="line-added"> 284     if (!node)</span>
<span class="line-added"> 285         return nullptr;</span>
<span class="line-added"> 286 </span>
<span class="line-added"> 287     Frame* frame = node-&gt;document().frame();</span>
<span class="line-added"> 288     if (!frame)</span>
<span class="line-added"> 289         return nullptr;</span>
<span class="line-added"> 290 </span>
<span class="line-added"> 291     if (!unifiedTextCheckerEnabled(frame))</span>
<span class="line-added"> 292         return nullptr;</span>
<span class="line-added"> 293 </span>
<span class="line-added"> 294     Editor&amp; editor = frame-&gt;editor();</span>
<span class="line-added"> 295 </span>
<span class="line-added"> 296     TextCheckerClient* textChecker = editor.textChecker();</span>
<span class="line-added"> 297     if (!textChecker)</span>
<span class="line-added"> 298         return nullptr;</span>
<span class="line-added"> 299 </span>
<span class="line-added"> 300     Vector&lt;TextCheckingResult&gt; misspellings;</span>
<span class="line-added"> 301     checkTextOfParagraph(*textChecker, stringValue(), TextCheckingType::Spelling, misspellings, frame-&gt;selection().selection());</span>
<span class="line-added"> 302 </span>
<span class="line-added"> 303     // The returned misspellings are assumed to be ordered in the document</span>
<span class="line-added"> 304     // logical order, which should be matched by Range::compareBoundaryPoints.</span>
<span class="line-added"> 305     // So iterate forward or backwards depending on the desired search</span>
<span class="line-added"> 306     // direction to find the closest misspelling in that direction.</span>
<span class="line-added"> 307     if (direction == AccessibilitySearchDirection::Next) {</span>
<span class="line-added"> 308         for (const auto&amp; misspelling : misspellings) {</span>
<span class="line-added"> 309             auto misspellingRange = editor.rangeForTextCheckingResult(misspelling);</span>
<span class="line-added"> 310             if (!misspellingRange)</span>
<span class="line-added"> 311                 continue;</span>
<span class="line-added"> 312 </span>
<span class="line-added"> 313             if (misspellingRange-&gt;compareBoundaryPoints(Range::END_TO_END, *start).releaseReturnValue() &gt; 0)</span>
<span class="line-added"> 314                 return misspellingRange;</span>
<span class="line-added"> 315         }</span>
<span class="line-added"> 316     } else if (direction == AccessibilitySearchDirection::Previous) {</span>
<span class="line-added"> 317         for (auto rit = misspellings.rbegin(); rit != misspellings.rend(); ++rit) {</span>
<span class="line-added"> 318             auto misspellingRange = editor.rangeForTextCheckingResult(*rit);</span>
<span class="line-added"> 319             if (!misspellingRange)</span>
<span class="line-added"> 320                 continue;</span>
<span class="line-added"> 321 </span>
<span class="line-added"> 322             if (misspellingRange-&gt;compareBoundaryPoints(Range::START_TO_START, *start).releaseReturnValue() &lt; 0)</span>
<span class="line-added"> 323                 return misspellingRange;</span>
<span class="line-added"> 324         }</span>
<span class="line-added"> 325     }</span>
<span class="line-added"> 326 </span>
<span class="line-added"> 327     return nullptr;</span>
<span class="line-added"> 328 }</span>
<span class="line-added"> 329 </span>
 330 unsigned AccessibilityObject::blockquoteLevel() const
 331 {
 332     unsigned level = 0;
 333     for (Node* elementNode = node(); elementNode; elementNode = elementNode-&gt;parentNode()) {
 334         if (elementNode-&gt;hasTagName(blockquoteTag))
 335             ++level;
 336     }
 337 
 338     return level;
 339 }
 340 
<a name="8" id="anc8"></a><span class="line-modified"> 341 AXCoreObject* AccessibilityObject::parentObjectUnignored() const</span>
 342 {
<a name="9" id="anc9"></a><span class="line-modified"> 343     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [] (const AccessibilityObject&amp; object) {</span>
 344         return !object.accessibilityIsIgnored();
<a name="10" id="anc10"></a><span class="line-modified"> 345     });</span>
 346 }
 347 
 348 AccessibilityObject* AccessibilityObject::previousSiblingUnignored(int limit) const
 349 {
 350     AccessibilityObject* previous;
 351     ASSERT(limit &gt;= 0);
 352     for (previous = previousSibling(); previous &amp;&amp; previous-&gt;accessibilityIsIgnored(); previous = previous-&gt;previousSibling()) {
 353         limit--;
 354         if (limit &lt;= 0)
 355             break;
 356     }
 357     return previous;
 358 }
 359 
 360 FloatRect AccessibilityObject::convertFrameToSpace(const FloatRect&amp; frameRect, AccessibilityConversionSpace conversionSpace) const
 361 {
 362     ASSERT(isMainThread());
 363 
 364     // Find the appropriate scroll view to use to convert the contents to the window.
 365     const auto parentAccessibilityScrollView = ancestorAccessibilityScrollView(false /* includeSelf */);
 366     auto* parentScrollView = parentAccessibilityScrollView ? parentAccessibilityScrollView-&gt;scrollView() : nullptr;
 367 
 368     auto snappedFrameRect = snappedIntRect(IntRect(frameRect));
 369     if (parentScrollView)
 370         snappedFrameRect = parentScrollView-&gt;contentsToRootView(snappedFrameRect);
 371 
 372     if (conversionSpace == AccessibilityConversionSpace::Screen) {
 373         auto page = this-&gt;page();
 374         if (!page)
 375             return snappedFrameRect;
 376 
 377         // If we have an empty chrome client (like SVG) then we should use the page
 378         // of the scroll view parent to help us get to the screen rect.
 379         if (parentAccessibilityScrollView &amp;&amp; page-&gt;chrome().client().isEmptyChromeClient())
 380             page = parentAccessibilityScrollView-&gt;page();
 381 
 382         snappedFrameRect = page-&gt;chrome().rootViewToAccessibilityScreen(snappedFrameRect);
 383     }
 384 
 385     return snappedFrameRect;
 386 }
 387 
 388 FloatRect AccessibilityObject::relativeFrame() const
 389 {
 390     return convertFrameToSpace(elementRect(), AccessibilityConversionSpace::Page);
 391 }
 392 
 393 AccessibilityObject* AccessibilityObject::nextSiblingUnignored(int limit) const
 394 {
 395     AccessibilityObject* next;
 396     ASSERT(limit &gt;= 0);
 397     for (next = nextSibling(); next &amp;&amp; next-&gt;accessibilityIsIgnored(); next = next-&gt;nextSibling()) {
 398         limit--;
 399         if (limit &lt;= 0)
 400             break;
 401     }
 402     return next;
 403 }
 404 
 405 AccessibilityObject* AccessibilityObject::firstAccessibleObjectFromNode(const Node* node)
 406 {
 407     return WebCore::firstAccessibleObjectFromNode(node, [] (const AccessibilityObject&amp; accessible) {
 408         return !accessible.accessibilityIsIgnored();
 409     });
 410 }
 411 
 412 AccessibilityObject* firstAccessibleObjectFromNode(const Node* node, const WTF::Function&lt;bool(const AccessibilityObject&amp;)&gt;&amp; isAccessible)
 413 {
 414     if (!node)
 415         return nullptr;
 416 
 417     AXObjectCache* cache = node-&gt;document().axObjectCache();
 418     if (!cache)
 419         return nullptr;
 420 
 421     AccessibilityObject* accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
 422     while (accessibleObject &amp;&amp; !isAccessible(*accessibleObject)) {
 423         node = NodeTraversal::next(*node);
 424 
 425         while (node &amp;&amp; !node-&gt;renderer())
 426             node = NodeTraversal::nextSkippingChildren(*node);
 427 
 428         if (!node)
 429             return nullptr;
 430 
 431         accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
 432     }
 433 
 434     return accessibleObject;
 435 }
 436 
 437 bool AccessibilityObject::isDescendantOfRole(AccessibilityRole role) const
 438 {
<a name="11" id="anc11"></a><span class="line-modified"> 439     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [&amp;role] (const AccessibilityObject&amp; object) {</span>
 440         return object.roleValue() == role;
 441     }) != nullptr;
 442 }
 443 
<a name="12" id="anc12"></a><span class="line-modified"> 444 static void appendAccessibilityObject(AXCoreObject* object, AccessibilityObject::AccessibilityChildrenVector&amp; results)</span>
 445 {
 446     // Find the next descendant of this attachment object so search can continue through frames.
 447     if (object-&gt;isAttachment()) {
 448         Widget* widget = object-&gt;widgetForAttachmentView();
 449         if (!is&lt;FrameView&gt;(widget))
 450             return;
 451 
 452         Document* document = downcast&lt;FrameView&gt;(*widget).frame().document();
 453         if (!document || !document-&gt;hasLivingRenderTree())
 454             return;
 455 
 456         object = object-&gt;axObjectCache()-&gt;getOrCreate(document);
 457     }
 458 
 459     if (object)
 460         results.append(object);
 461 }
 462 
<a name="13" id="anc13"></a><span class="line-modified"> 463 void AccessibilityObject::insertChild(AXCoreObject* child, unsigned index)</span>
 464 {
 465     if (!child)
 466         return;
 467 
 468     // If the parent is asking for this child&#39;s children, then either it&#39;s the first time (and clearing is a no-op),
 469     // or its visibility has changed. In the latter case, this child may have a stale child cached.
 470     // This can prevent aria-hidden changes from working correctly. Hence, whenever a parent is getting children, ensure data is not stale.
 471     // Only clear the child&#39;s children when we know it&#39;s in the updating chain in order to avoid unnecessary work.
 472     if (child-&gt;needsToUpdateChildren() || m_subtreeDirty) {
 473         child-&gt;clearChildren();
 474         // Pass m_subtreeDirty flag down to the child so that children cache gets reset properly.
 475         if (m_subtreeDirty)
 476             child-&gt;setNeedsToUpdateSubtree();
 477     } else {
 478         // For some reason the grand children might be detached so that we need to regenerate the
 479         // children list of this child.
 480         for (const auto&amp; grandChild : child-&gt;children(false)) {
 481             if (grandChild-&gt;isDetachedFromParent()) {
 482                 child-&gt;clearChildren();
 483                 break;
 484             }
 485         }
 486     }
 487 
 488     setIsIgnoredFromParentDataForChild(child);
 489     if (child-&gt;accessibilityIsIgnored()) {
 490         const auto&amp; children = child-&gt;children();
 491         size_t length = children.size();
 492         for (size_t i = 0; i &lt; length; ++i)
 493             m_children.insert(index + i, children[i]);
 494     } else {
 495         ASSERT(child-&gt;parentObject() == this);
 496         m_children.insert(index, child);
 497     }
 498 
 499     // Reset the child&#39;s m_isIgnoredFromParentData since we are done adding that child and its children.
 500     child-&gt;clearIsIgnoredFromParentData();
 501 }
 502 
<a name="14" id="anc14"></a><span class="line-modified"> 503 void AccessibilityObject::addChild(AXCoreObject* child)</span>
 504 {
 505     insertChild(child, m_children.size());
 506 }
 507 
<a name="15" id="anc15"></a><span class="line-modified"> 508 static void appendChildrenToArray(AXCoreObject* object, bool isForward, AXCoreObject* startObject, AccessibilityObject::AccessibilityChildrenVector&amp; results)</span>
 509 {
 510     // A table&#39;s children includes elements whose own children are also the table&#39;s children (due to the way the Mac exposes tables).
 511     // The rows from the table should be queried, since those are direct descendants of the table, and they contain content.
 512     const auto&amp; searchChildren = is&lt;AccessibilityTable&gt;(*object) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*object).isExposableThroughAccessibility() ? downcast&lt;AccessibilityTable&gt;(*object).rows() : object-&gt;children();
 513 
 514     size_t childrenSize = searchChildren.size();
 515 
 516     size_t startIndex = isForward ? childrenSize : 0;
 517     size_t endIndex = isForward ? 0 : childrenSize;
 518 
 519     // If the startObject is ignored, we should use an accessible sibling as a start element instead.
 520     if (startObject &amp;&amp; startObject-&gt;accessibilityIsIgnored() &amp;&amp; startObject-&gt;isDescendantOfObject(object)) {
<a name="16" id="anc16"></a><span class="line-modified"> 521         AXCoreObject* parentObject = startObject-&gt;parentObject();</span>
 522         // Go up the parent chain to find the highest ancestor that&#39;s also being ignored.
 523         while (parentObject &amp;&amp; parentObject-&gt;accessibilityIsIgnored()) {
 524             if (parentObject == object)
 525                 break;
 526             startObject = parentObject;
 527             parentObject = parentObject-&gt;parentObject();
 528         }
 529         // Get the un-ignored sibling based on the search direction, and update the searchPosition.
 530         while (startObject &amp;&amp; startObject-&gt;accessibilityIsIgnored())
 531             startObject = isForward ? startObject-&gt;previousSibling() : startObject-&gt;nextSibling();
 532     }
 533 
 534     size_t searchPosition = startObject ? searchChildren.find(startObject) : WTF::notFound;
 535 
 536     if (searchPosition != WTF::notFound) {
 537         if (isForward)
 538             endIndex = searchPosition + 1;
 539         else
 540             endIndex = searchPosition;
 541     }
 542 
 543     // This is broken into two statements so that it&#39;s easier read.
 544     if (isForward) {
 545         for (size_t i = startIndex; i &gt; endIndex; i--)
 546             appendAccessibilityObject(searchChildren.at(i - 1).get(), results);
 547     } else {
 548         for (size_t i = startIndex; i &lt; endIndex; i++)
 549             appendAccessibilityObject(searchChildren.at(i).get(), results);
 550     }
 551 }
 552 
<a name="17" id="anc17"></a>













 553 void AccessibilityObject::findMatchingObjects(AccessibilitySearchCriteria* criteria, AccessibilityChildrenVector&amp; results)
 554 {
 555     ASSERT(criteria);
<a name="18" id="anc18"></a>
 556     if (!criteria)
 557         return;
 558 
 559     if (AXObjectCache* cache = axObjectCache())
 560         cache-&gt;startCachingComputedObjectAttributesUntilTreeMutates();
 561 
<a name="19" id="anc19"></a><span class="line-modified"> 562     criteria-&gt;anchorObject = this;</span>
<span class="line-modified"> 563     Accessibility::findMatchingObjects(*criteria, results);</span>















































 564 }
 565 
 566 // Returns the range that is fewer positions away from the reference range.
 567 // NOTE: The after range is expected to ACTUALLY be after the reference range and the before
 568 // range is expected to ACTUALLY be before. These are not checked for performance reasons.
 569 static RefPtr&lt;Range&gt; rangeClosestToRange(RefPtr&lt;Range&gt; const&amp; referenceRange, RefPtr&lt;Range&gt;&amp;&amp; afterRange, RefPtr&lt;Range&gt;&amp;&amp; beforeRange)
 570 {
 571     if (!referenceRange)
 572         return nullptr;
 573 
 574     // The treeScope for shadow nodes may not be the same scope as another element in a document.
 575     // Comparisons may fail in that case, which are expected behavior and should not assert.
 576     if (afterRange &amp;&amp; (referenceRange-&gt;endPosition().isNull() || ((afterRange-&gt;startPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;endPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 577         return nullptr;
 578     ASSERT(!afterRange || afterRange-&gt;compareBoundaryPoints(Range::START_TO_START, *referenceRange).releaseReturnValue() &gt;= 0);
 579 
 580     if (beforeRange &amp;&amp; (referenceRange-&gt;startPosition().isNull() || ((beforeRange-&gt;endPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;startPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 581         return nullptr;
 582     ASSERT(!beforeRange || beforeRange-&gt;compareBoundaryPoints(Range::START_TO_START, *referenceRange).releaseReturnValue() &lt;= 0);
 583 
 584     if (!afterRange &amp;&amp; !beforeRange)
 585         return nullptr;
 586     if (afterRange &amp;&amp; !beforeRange)
 587         return WTFMove(afterRange);
 588     if (!afterRange &amp;&amp; beforeRange)
 589         return WTFMove(beforeRange);
 590 
 591     unsigned positionsToAfterRange = Position::positionCountBetweenPositions(afterRange-&gt;startPosition(), referenceRange-&gt;endPosition());
 592     unsigned positionsToBeforeRange = Position::positionCountBetweenPositions(beforeRange-&gt;endPosition(), referenceRange-&gt;startPosition());
 593 
 594     return positionsToAfterRange &lt; positionsToBeforeRange ? afterRange : beforeRange;
 595 }
 596 
 597 RefPtr&lt;Range&gt; AccessibilityObject::rangeOfStringClosestToRangeInDirection(Range* referenceRange, AccessibilitySearchDirection searchDirection, Vector&lt;String&gt; const&amp; searchStrings) const
 598 {
 599     Frame* frame = this-&gt;frame();
 600     if (!frame)
 601         return nullptr;
 602 
 603     if (!referenceRange)
 604         return nullptr;
 605 
 606     bool isBackwardSearch = searchDirection == AccessibilitySearchDirection::Previous;
 607     FindOptions findOptions { AtWordStarts, AtWordEnds, CaseInsensitive, StartInSelection };
 608     if (isBackwardSearch)
 609         findOptions.add(FindOptionFlag::Backwards);
 610 
 611     RefPtr&lt;Range&gt; closestStringRange = nullptr;
 612     for (const auto&amp; searchString : searchStrings) {
 613         if (RefPtr&lt;Range&gt; searchStringRange = frame-&gt;editor().rangeOfString(searchString, referenceRange, findOptions)) {
 614             if (!closestStringRange)
 615                 closestStringRange = searchStringRange;
 616             else {
 617                 // If searching backward, use the trailing range edges to correctly determine which
 618                 // range is closest. Similarly, if searching forward, use the leading range edges.
 619                 Position closestStringPosition = isBackwardSearch ? closestStringRange-&gt;endPosition() : closestStringRange-&gt;startPosition();
 620                 Position searchStringPosition = isBackwardSearch ? searchStringRange-&gt;endPosition() : searchStringRange-&gt;startPosition();
 621 
 622                 int closestPositionOffset = closestStringPosition.computeOffsetInContainerNode();
 623                 int searchPositionOffset = searchStringPosition.computeOffsetInContainerNode();
 624                 Node* closestContainerNode = closestStringPosition.containerNode();
 625                 Node* searchContainerNode = searchStringPosition.containerNode();
 626 
 627                 short result = Range::compareBoundaryPoints(closestContainerNode, closestPositionOffset, searchContainerNode, searchPositionOffset).releaseReturnValue();
 628                 if ((!isBackwardSearch &amp;&amp; result &gt; 0) || (isBackwardSearch &amp;&amp; result &lt; 0))
 629                     closestStringRange = searchStringRange;
 630             }
 631         }
 632     }
 633     return closestStringRange;
 634 }
 635 
 636 // Returns the range of the entire document if there is no selection.
 637 RefPtr&lt;Range&gt; AccessibilityObject::selectionRange() const
 638 {
 639     Frame* frame = this-&gt;frame();
 640     if (!frame)
 641         return nullptr;
 642 
 643     const VisibleSelection&amp; selection = frame-&gt;selection().selection();
 644     if (!selection.isNone())
 645         return selection.firstRange();
 646 
 647     return Range::create(*frame-&gt;document());
 648 }
 649 
 650 RefPtr&lt;Range&gt; AccessibilityObject::elementRange() const
 651 {
 652     return AXObjectCache::rangeForNodeContents(node());
 653 }
 654 
 655 RefPtr&lt;Range&gt; AccessibilityObject::findTextRange(Vector&lt;String&gt; const&amp; searchStrings, RefPtr&lt;Range&gt; const&amp; start, AccessibilitySearchTextDirection direction) const
 656 {
 657     RefPtr&lt;Range&gt; found;
 658     if (direction == AccessibilitySearchTextDirection::Forward)
 659         found = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Next, searchStrings);
 660     else if (direction == AccessibilitySearchTextDirection::Backward)
 661         found = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Previous, searchStrings);
 662     else if (direction == AccessibilitySearchTextDirection::Closest) {
 663         auto foundAfter = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Next, searchStrings);
 664         auto foundBefore = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Previous, searchStrings);
 665         found = rangeClosestToRange(start.get(), WTFMove(foundAfter), WTFMove(foundBefore));
 666     }
 667 
 668     if (found) {
 669         // If the search started within a text control, ensure that the result is inside that element.
 670         if (element() &amp;&amp; element()-&gt;isTextField()) {
 671             if (!found-&gt;startContainer().isDescendantOrShadowDescendantOf(element())
 672                 || !found-&gt;endContainer().isDescendantOrShadowDescendantOf(element()))
 673                 return nullptr;
 674         }
 675     }
 676     return found;
 677 }
 678 
 679 Vector&lt;RefPtr&lt;Range&gt;&gt; AccessibilityObject::findTextRanges(AccessibilitySearchTextCriteria const&amp; criteria) const
 680 {
 681     Vector&lt;RefPtr&lt;Range&gt;&gt; result;
 682 
 683     // Determine start range.
 684     RefPtr&lt;Range&gt; startRange;
 685     if (criteria.start == AccessibilitySearchTextStartFrom::Selection)
 686         startRange = selectionRange();
 687     else
 688         startRange = elementRange();
 689 
 690     if (startRange) {
 691         // Collapse the range to the start unless searching from the end of the doc or searching backwards.
 692         if (criteria.start == AccessibilitySearchTextStartFrom::Begin)
 693             startRange-&gt;collapse(true);
 694         else if (criteria.start == AccessibilitySearchTextStartFrom::End)
 695             startRange-&gt;collapse(false);
 696         else
 697             startRange-&gt;collapse(criteria.direction != AccessibilitySearchTextDirection::Backward);
 698     } else
 699         return result;
 700 
 701     RefPtr&lt;Range&gt; found;
 702     switch (criteria.direction) {
 703     case AccessibilitySearchTextDirection::Forward:
 704     case AccessibilitySearchTextDirection::Backward:
 705     case AccessibilitySearchTextDirection::Closest:
 706         found = findTextRange(criteria.searchStrings, startRange, criteria.direction);
 707         if (found)
 708             result.append(found);
 709         break;
 710     case AccessibilitySearchTextDirection::All: {
 711         auto findAll = [&amp;](AccessibilitySearchTextDirection dir) {
 712             found = findTextRange(criteria.searchStrings, startRange, dir);
 713             while (found) {
 714                 result.append(found);
 715                 found = findTextRange(criteria.searchStrings, found, dir);
 716             }
 717         };
 718         findAll(AccessibilitySearchTextDirection::Forward);
 719         findAll(AccessibilitySearchTextDirection::Backward);
 720         break;
 721     }
 722     }
 723 
 724     return result;
 725 }
 726 
 727 Vector&lt;String&gt; AccessibilityObject::performTextOperation(AccessibilityTextOperation const&amp; operation)
 728 {
 729     Vector&lt;String&gt; result;
 730 
 731     if (operation.textRanges.isEmpty())
 732         return result;
 733 
 734     Frame* frame = this-&gt;frame();
 735     if (!frame)
 736         return result;
 737 
<a name="20" id="anc20"></a><span class="line-modified"> 738     for (const auto&amp; textRange : operation.textRanges) {</span>
 739         if (!frame-&gt;selection().setSelectedRange(textRange.get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes))
 740             continue;
 741 
 742         String text = textRange-&gt;text();
 743         String replacementString = operation.replacementText;
 744         bool replaceSelection = false;
 745         switch (operation.type) {
 746         case AccessibilityTextOperationType::Capitalize:
 747             replacementString = capitalize(text, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.
 748             replaceSelection = true;
 749             break;
 750         case AccessibilityTextOperationType::Uppercase:
 751             replacementString = text.convertToUppercaseWithoutLocale(); // FIXME: Needs locale to work correctly.
 752             replaceSelection = true;
 753             break;
 754         case AccessibilityTextOperationType::Lowercase:
 755             replacementString = text.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.
 756             replaceSelection = true;
 757             break;
 758         case AccessibilityTextOperationType::Replace: {
 759             replaceSelection = true;
 760             // When applying find and replace activities, we want to match the capitalization of the replaced text,
 761             // (unless we&#39;re replacing with an abbreviation.)
 762             if (text.length() &gt; 0
 763                 &amp;&amp; replacementString.length() &gt; 2
 764                 &amp;&amp; replacementString != replacementString.convertToUppercaseWithoutLocale()) {
 765                 if (text[0] == u_toupper(text[0]))
 766                     replacementString = capitalize(replacementString, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.
 767                 else
 768                     replacementString = replacementString.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.
 769             }
 770             break;
 771         }
 772         case AccessibilityTextOperationType::Select:
 773             break;
 774         }
 775 
 776         // A bit obvious, but worth noting the API contract for this method is that we should
 777         // return the replacement string when replacing, but the selected string if not.
 778         if (replaceSelection) {
 779             frame-&gt;editor().replaceSelectionWithText(replacementString, Editor::SelectReplacement::Yes, Editor::SmartReplace::Yes);
 780             result.append(replacementString);
 781         } else
 782             result.append(text);
 783     }
 784 
 785     return result;
 786 }
 787 
 788 bool AccessibilityObject::hasAttributesRequiredForInclusion() const
 789 {
 790     // These checks are simplified in the interest of execution speed.
 791     if (!getAttribute(aria_helpAttr).isEmpty()
 792         || !getAttribute(aria_describedbyAttr).isEmpty()
 793         || !getAttribute(altAttr).isEmpty()
 794         || !getAttribute(titleAttr).isEmpty())
 795         return true;
 796 
 797 #if ENABLE(MATHML)
 798     if (!getAttribute(MathMLNames::alttextAttr).isEmpty())
 799         return true;
 800 #endif
 801 
 802     return false;
 803 }
 804 
 805 bool AccessibilityObject::isARIAInput(AccessibilityRole ariaRole)
 806 {
 807     return ariaRole == AccessibilityRole::RadioButton || ariaRole == AccessibilityRole::CheckBox || ariaRole == AccessibilityRole::TextField || ariaRole == AccessibilityRole::Switch || ariaRole == AccessibilityRole::SearchField;
 808 }
 809 
 810 bool AccessibilityObject::isARIAControl(AccessibilityRole ariaRole)
 811 {
 812     return isARIAInput(ariaRole) || ariaRole == AccessibilityRole::TextArea || ariaRole == AccessibilityRole::Button || ariaRole == AccessibilityRole::ComboBox || ariaRole == AccessibilityRole::Slider || ariaRole == AccessibilityRole::ListBox;
 813 }
 814 
 815 bool AccessibilityObject::isRangeControl() const
 816 {
 817     switch (roleValue()) {
 818     case AccessibilityRole::Meter:
 819     case AccessibilityRole::ProgressIndicator:
 820     case AccessibilityRole::Slider:
 821     case AccessibilityRole::ScrollBar:
 822     case AccessibilityRole::SpinButton:
 823         return true;
 824     case AccessibilityRole::Splitter:
 825         return canSetFocusAttribute();
 826     default:
 827         return false;
 828     }
 829 }
 830 
 831 bool AccessibilityObject::isMeter() const
 832 {
 833     if (ariaRoleAttribute() == AccessibilityRole::Meter)
 834         return true;
 835 
 836 #if ENABLE(METER_ELEMENT)
 837     RenderObject* renderer = this-&gt;renderer();
 838     return renderer &amp;&amp; renderer-&gt;isMeter();
 839 #else
 840     return false;
 841 #endif
 842 }
 843 
 844 IntPoint AccessibilityObject::clickPoint()
 845 {
 846     LayoutRect rect = elementRect();
 847     return roundedIntPoint(LayoutPoint(rect.x() + rect.width() / 2, rect.y() + rect.height() / 2));
 848 }
 849 
 850 IntRect AccessibilityObject::boundingBoxForQuads(RenderObject* obj, const Vector&lt;FloatQuad&gt;&amp; quads)
 851 {
 852     ASSERT(obj);
 853     if (!obj)
 854         return IntRect();
 855 
 856     FloatRect result;
 857     for (const auto&amp; quad : quads) {
 858         FloatRect r = quad.enclosingBoundingBox();
 859         if (!r.isEmpty()) {
 860             if (obj-&gt;style().hasAppearance())
 861                 obj-&gt;theme().adjustRepaintRect(*obj, r);
 862             result.unite(r);
 863         }
 864     }
 865     return snappedIntRect(LayoutRect(result));
 866 }
 867 
 868 bool AccessibilityObject::press()
 869 {
 870     // The presence of the actionElement will confirm whether we should even attempt a press.
 871     Element* actionElem = actionElement();
 872     if (!actionElem)
 873         return false;
 874     if (Frame* f = actionElem-&gt;document().frame())
 875         f-&gt;loader().resetMultipleFormSubmissionProtection();
 876 
 877     // Hit test at this location to determine if there is a sub-node element that should act
 878     // as the target of the action.
 879     Element* hitTestElement = nullptr;
 880     Document* document = this-&gt;document();
 881     if (document) {
 882         HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AccessibilityHitTest);
 883         HitTestResult hitTestResult(clickPoint());
 884         document-&gt;hitTest(request, hitTestResult);
 885         if (auto* innerNode = hitTestResult.innerNode()) {
 886             if (auto* shadowHost = innerNode-&gt;shadowHost())
 887                 hitTestElement = shadowHost;
 888             else if (is&lt;Element&gt;(*innerNode))
 889                 hitTestElement = &amp;downcast&lt;Element&gt;(*innerNode);
 890             else
 891                 hitTestElement = innerNode-&gt;parentElement();
 892         }
 893     }
 894 
 895     // Prefer the actionElement instead of this node, if the actionElement is inside this node.
 896     Element* pressElement = this-&gt;element();
 897     if (!pressElement || actionElem-&gt;isDescendantOf(*pressElement))
 898         pressElement = actionElem;
 899 
 900     ASSERT(pressElement);
 901     // Prefer the hit test element, if it is inside the target element.
 902     if (hitTestElement &amp;&amp; hitTestElement-&gt;isDescendantOf(*pressElement))
 903         pressElement = hitTestElement;
 904 
 905     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document);
 906 
 907     bool dispatchedTouchEvent = false;
 908 #if PLATFORM(IOS_FAMILY)
 909     if (hasTouchEventListener())
 910         dispatchedTouchEvent = dispatchTouchEvent();
 911 #endif
 912     if (!dispatchedTouchEvent)
 913         pressElement-&gt;accessKeyAction(true);
 914 
 915     return true;
 916 }
 917 
 918 bool AccessibilityObject::dispatchTouchEvent()
 919 {
 920 #if ENABLE(IOS_TOUCH_EVENTS)
 921     if (auto* frame = mainFrame())
 922         return frame-&gt;eventHandler().dispatchSimulatedTouchEvent(clickPoint());
 923 #endif
 924     return false;
 925 }
 926 
 927 Frame* AccessibilityObject::frame() const
 928 {
 929     Node* node = this-&gt;node();
 930     return node ? node-&gt;document().frame() : nullptr;
 931 }
 932 
 933 Frame* AccessibilityObject::mainFrame() const
 934 {
 935     Document* document = topDocument();
 936     if (!document)
 937         return nullptr;
 938 
 939     Frame* frame = document-&gt;frame();
 940     if (!frame)
 941         return nullptr;
 942 
 943     return &amp;frame-&gt;mainFrame();
 944 }
 945 
 946 Document* AccessibilityObject::topDocument() const
 947 {
 948     if (!document())
 949         return nullptr;
 950     return &amp;document()-&gt;topDocument();
 951 }
 952 
 953 String AccessibilityObject::language() const
 954 {
 955     const AtomString&amp; lang = getAttribute(langAttr);
 956     if (!lang.isEmpty())
 957         return lang;
 958 
 959     AccessibilityObject* parent = parentObject();
 960 
 961     // as a last resort, fall back to the content language specified in the meta tag
 962     if (!parent) {
 963         Document* doc = document();
 964         if (doc)
 965             return doc-&gt;contentLanguage();
 966         return nullAtom();
 967     }
 968 
 969     return parent-&gt;language();
 970 }
 971 
 972 VisiblePositionRange AccessibilityObject::visiblePositionRangeForUnorderedPositions(const VisiblePosition&amp; visiblePos1, const VisiblePosition&amp; visiblePos2) const
 973 {
 974     if (visiblePos1.isNull() || visiblePos2.isNull())
 975         return VisiblePositionRange();
 976 
 977     // If there&#39;s no common tree scope between positions, return early.
 978     if (!commonTreeScope(visiblePos1.deepEquivalent().deprecatedNode(), visiblePos2.deepEquivalent().deprecatedNode()))
 979         return VisiblePositionRange();
 980 
 981     VisiblePosition startPos;
 982     VisiblePosition endPos;
 983     bool alreadyInOrder;
 984 
 985     // upstream is ordered before downstream for the same position
 986     if (visiblePos1 == visiblePos2 &amp;&amp; visiblePos2.affinity() == UPSTREAM)
 987         alreadyInOrder = false;
 988 
 989     // use selection order to see if the positions are in order
 990     else
 991         alreadyInOrder = VisibleSelection(visiblePos1, visiblePos2).isBaseFirst();
 992 
 993     if (alreadyInOrder) {
 994         startPos = visiblePos1;
 995         endPos = visiblePos2;
 996     } else {
 997         startPos = visiblePos2;
 998         endPos = visiblePos1;
 999     }
1000 
1001     return VisiblePositionRange(startPos, endPos);
1002 }
1003 
1004 VisiblePositionRange AccessibilityObject::positionOfLeftWord(const VisiblePosition&amp; visiblePos) const
1005 {
1006     VisiblePosition startPosition = startOfWord(visiblePos, LeftWordIfOnBoundary);
1007     VisiblePosition endPosition = endOfWord(startPosition);
1008     return VisiblePositionRange(startPosition, endPosition);
1009 }
1010 
1011 VisiblePositionRange AccessibilityObject::positionOfRightWord(const VisiblePosition&amp; visiblePos) const
1012 {
1013     VisiblePosition startPosition = startOfWord(visiblePos, RightWordIfOnBoundary);
1014     VisiblePosition endPosition = endOfWord(startPosition);
1015     return VisiblePositionRange(startPosition, endPosition);
1016 }
1017 
1018 static VisiblePosition updateAXLineStartForVisiblePosition(const VisiblePosition&amp; visiblePosition)
1019 {
1020     // A line in the accessibility sense should include floating objects, such as aligned image, as part of a line.
1021     // So let&#39;s update the position to include that.
1022     VisiblePosition tempPosition;
1023     VisiblePosition startPosition = visiblePosition;
1024     while (true) {
1025         tempPosition = startPosition.previous();
1026         if (tempPosition.isNull())
1027             break;
1028         Position p = tempPosition.deepEquivalent();
1029         RenderObject* renderer = p.deprecatedNode()-&gt;renderer();
1030         if (!renderer || (renderer-&gt;isRenderBlock() &amp;&amp; !p.deprecatedEditingOffset()))
1031             break;
1032         if (!RenderedPosition(tempPosition).isNull())
1033             break;
1034         startPosition = tempPosition;
1035     }
1036 
1037     return startPosition;
1038 }
1039 
1040 VisiblePositionRange AccessibilityObject::leftLineVisiblePositionRange(const VisiblePosition&amp; visiblePos) const
1041 {
1042     if (visiblePos.isNull())
1043         return VisiblePositionRange();
1044 
1045     // make a caret selection for the position before marker position (to make sure
1046     // we move off of a line start)
1047     VisiblePosition prevVisiblePos = visiblePos.previous();
1048     if (prevVisiblePos.isNull())
1049         return VisiblePositionRange();
1050 
1051     VisiblePosition startPosition = startOfLine(prevVisiblePos);
1052 
1053     // keep searching for a valid line start position.  Unless the VisiblePosition is at the very beginning, there should
1054     // always be a valid line range.  However, startOfLine will return null for position next to a floating object,
1055     // since floating object doesn&#39;t really belong to any line.
1056     // This check will reposition the marker before the floating object, to ensure we get a line start.
1057     if (startPosition.isNull()) {
1058         while (startPosition.isNull() &amp;&amp; prevVisiblePos.isNotNull()) {
1059             prevVisiblePos = prevVisiblePos.previous();
1060             startPosition = startOfLine(prevVisiblePos);
1061         }
1062     } else
1063         startPosition = updateAXLineStartForVisiblePosition(startPosition);
1064 
1065     VisiblePosition endPosition = endOfLine(prevVisiblePos);
1066     return VisiblePositionRange(startPosition, endPosition);
1067 }
1068 
1069 VisiblePositionRange AccessibilityObject::rightLineVisiblePositionRange(const VisiblePosition&amp; visiblePos) const
1070 {
1071     if (visiblePos.isNull())
1072         return VisiblePositionRange();
1073 
1074     // make sure we move off of a line end
1075     VisiblePosition nextVisiblePos = visiblePos.next();
1076     if (nextVisiblePos.isNull())
1077         return VisiblePositionRange();
1078 
1079     VisiblePosition startPosition = startOfLine(nextVisiblePos);
1080 
1081     // fetch for a valid line start position
1082     if (startPosition.isNull()) {
1083         startPosition = visiblePos;
1084         nextVisiblePos = nextVisiblePos.next();
1085     } else
1086         startPosition = updateAXLineStartForVisiblePosition(startPosition);
1087 
1088     VisiblePosition endPosition = endOfLine(nextVisiblePos);
1089 
1090     // as long as the position hasn&#39;t reached the end of the doc,  keep searching for a valid line end position
1091     // Unless the VisiblePosition is at the very end, there should always be a valid line range.  However, endOfLine will
1092     // return null for position by a floating object, since floating object doesn&#39;t really belong to any line.
1093     // This check will reposition the marker after the floating object, to ensure we get a line end.
1094     while (endPosition.isNull() &amp;&amp; nextVisiblePos.isNotNull()) {
1095         nextVisiblePos = nextVisiblePos.next();
1096         endPosition = endOfLine(nextVisiblePos);
1097     }
1098 
1099     return VisiblePositionRange(startPosition, endPosition);
1100 }
1101 
1102 VisiblePositionRange AccessibilityObject::sentenceForPosition(const VisiblePosition&amp; visiblePos) const
1103 {
1104     // FIXME: FO 2 IMPLEMENT (currently returns incorrect answer)
1105     // Related? &lt;rdar://problem/3927736&gt; Text selection broken in 8A336
1106     VisiblePosition startPosition = startOfSentence(visiblePos);
1107     VisiblePosition endPosition = endOfSentence(startPosition);
1108     return VisiblePositionRange(startPosition, endPosition);
1109 }
1110 
1111 VisiblePositionRange AccessibilityObject::paragraphForPosition(const VisiblePosition&amp; visiblePos) const
1112 {
1113     VisiblePosition startPosition = startOfParagraph(visiblePos);
1114     VisiblePosition endPosition = endOfParagraph(startPosition);
1115     return VisiblePositionRange(startPosition, endPosition);
1116 }
1117 
1118 static VisiblePosition startOfStyleRange(const VisiblePosition&amp; visiblePos)
1119 {
1120     RenderObject* renderer = visiblePos.deepEquivalent().deprecatedNode()-&gt;renderer();
1121     RenderObject* startRenderer = renderer;
1122     auto* style = &amp;renderer-&gt;style();
1123 
1124     // traverse backward by renderer to look for style change
1125     for (RenderObject* r = renderer-&gt;previousInPreOrder(); r; r = r-&gt;previousInPreOrder()) {
1126         // skip non-leaf nodes
1127         if (r-&gt;firstChildSlow())
1128             continue;
1129 
1130         // stop at style change
1131         if (&amp;r-&gt;style() != style)
1132             break;
1133 
1134         // remember match
1135         startRenderer = r;
1136     }
1137 
1138     return firstPositionInOrBeforeNode(startRenderer-&gt;node());
1139 }
1140 
1141 static VisiblePosition endOfStyleRange(const VisiblePosition&amp; visiblePos)
1142 {
1143     RenderObject* renderer = visiblePos.deepEquivalent().deprecatedNode()-&gt;renderer();
1144     RenderObject* endRenderer = renderer;
1145     const RenderStyle&amp; style = renderer-&gt;style();
1146 
1147     // traverse forward by renderer to look for style change
1148     for (RenderObject* r = renderer-&gt;nextInPreOrder(); r; r = r-&gt;nextInPreOrder()) {
1149         // skip non-leaf nodes
1150         if (r-&gt;firstChildSlow())
1151             continue;
1152 
1153         // stop at style change
1154         if (&amp;r-&gt;style() != &amp;style)
1155             break;
1156 
1157         // remember match
1158         endRenderer = r;
1159     }
1160 
1161     return lastPositionInOrAfterNode(endRenderer-&gt;node());
1162 }
1163 
1164 VisiblePositionRange AccessibilityObject::styleRangeForPosition(const VisiblePosition&amp; visiblePos) const
1165 {
1166     if (visiblePos.isNull())
1167         return VisiblePositionRange();
1168 
1169     return VisiblePositionRange(startOfStyleRange(visiblePos), endOfStyleRange(visiblePos));
1170 }
1171 
1172 // NOTE: Consider providing this utility method as AX API
1173 VisiblePositionRange AccessibilityObject::visiblePositionRangeForRange(const PlainTextRange&amp; range) const
1174 {
1175     unsigned textLength = getLengthForTextRange();
1176     if (range.start + range.length &gt; textLength)
1177         return VisiblePositionRange();
1178 
1179     VisiblePosition startPosition = visiblePositionForIndex(range.start);
1180     startPosition.setAffinity(DOWNSTREAM);
1181     VisiblePosition endPosition = visiblePositionForIndex(range.start + range.length);
1182     return VisiblePositionRange(startPosition, endPosition);
1183 }
1184 
1185 RefPtr&lt;Range&gt; AccessibilityObject::rangeForPlainTextRange(const PlainTextRange&amp; range) const
1186 {
1187     unsigned textLength = getLengthForTextRange();
1188     if (range.start + range.length &gt; textLength)
1189         return nullptr;
<a name="21" id="anc21"></a><span class="line-added">1190     // Avoid setting selection to uneditable parent node in FrameSelection::setSelectedRange. See webkit.org/b/206093.</span>
<span class="line-added">1191     if (range.isNull() &amp;&amp; !textLength)</span>
<span class="line-added">1192         return nullptr;</span>
1193 
1194     if (AXObjectCache* cache = axObjectCache()) {
1195         CharacterOffset start = cache-&gt;characterOffsetForIndex(range.start, this);
1196         CharacterOffset end = cache-&gt;characterOffsetForIndex(range.start + range.length, this);
1197         return cache-&gt;rangeForUnorderedCharacterOffsets(start, end);
1198     }
1199     return nullptr;
1200 }
1201 
1202 VisiblePositionRange AccessibilityObject::lineRangeForPosition(const VisiblePosition&amp; visiblePosition) const
1203 {
1204     VisiblePosition startPosition = startOfLine(visiblePosition);
1205     VisiblePosition endPosition = endOfLine(visiblePosition);
1206     return VisiblePositionRange(startPosition, endPosition);
1207 }
1208 
1209 bool AccessibilityObject::replacedNodeNeedsCharacter(Node* replacedNode)
1210 {
1211     // we should always be given a rendered node and a replaced node, but be safe
1212     // replaced nodes are either attachments (widgets) or images
1213     if (!replacedNode || !isRendererReplacedElement(replacedNode-&gt;renderer()) || replacedNode-&gt;isTextNode())
1214         return false;
1215 
1216     // create an AX object, but skip it if it is not supposed to be seen
1217     AccessibilityObject* object = replacedNode-&gt;renderer()-&gt;document().axObjectCache()-&gt;getOrCreate(replacedNode);
1218     if (object-&gt;accessibilityIsIgnored())
1219         return false;
1220 
1221     return true;
1222 }
1223 
1224 // Finds a RenderListItem parent give a node.
1225 static RenderListItem* renderListItemContainerForNode(Node* node)
1226 {
1227     for (; node; node = node-&gt;parentNode()) {
1228         RenderBoxModelObject* renderer = node-&gt;renderBoxModelObject();
1229         if (is&lt;RenderListItem&gt;(renderer))
1230             return downcast&lt;RenderListItem&gt;(renderer);
1231     }
1232     return nullptr;
1233 }
1234 
1235 static String listMarkerTextForNode(Node* node)
1236 {
1237     RenderListItem* listItem = renderListItemContainerForNode(node);
1238     if (!listItem)
1239         return String();
1240 
1241     // If this is in a list item, we need to manually add the text for the list marker
1242     // because a RenderListMarker does not have a Node equivalent and thus does not appear
1243     // when iterating text.
1244     return listItem-&gt;markerTextWithSuffix();
1245 }
1246 
1247 // Returns the text associated with a list marker if this node is contained within a list item.
1248 String AccessibilityObject::listMarkerTextForNodeAndPosition(Node* node, const VisiblePosition&amp; visiblePositionStart)
1249 {
1250     // If the range does not contain the start of the line, the list marker text should not be included.
1251     if (!isStartOfLine(visiblePositionStart))
1252         return String();
1253 
1254     // We should speak the list marker only for the first line.
1255     RenderListItem* listItem = renderListItemContainerForNode(node);
1256     if (!listItem)
1257         return String();
1258     if (!inSameLine(visiblePositionStart, firstPositionInNode(&amp;listItem-&gt;element())))
1259         return String();
1260 
1261     return listMarkerTextForNode(node);
1262 }
1263 
1264 String AccessibilityObject::stringForRange(RefPtr&lt;Range&gt; range) const
1265 {
1266     if (!range)
1267         return String();
1268 
1269     TextIterator it(range.get());
1270     if (it.atEnd())
1271         return String();
1272 
1273     StringBuilder builder;
1274     for (; !it.atEnd(); it.advance()) {
1275         // non-zero length means textual node, zero length means replaced node (AKA &quot;attachments&quot; in AX)
1276         if (it.text().length()) {
1277             // Add a textual representation for list marker text.
1278             // Don&#39;t add list marker text for new line character.
1279             if (it.text().length() != 1 || !isSpaceOrNewline(it.text()[0]))
1280                 builder.append(listMarkerTextForNodeAndPosition(it.node(), VisiblePosition(range-&gt;startPosition())));
1281             it.appendTextToStringBuilder(builder);
1282         } else {
1283             // locate the node and starting offset for this replaced range
1284             Node&amp; node = it.range()-&gt;startContainer();
1285             ASSERT(&amp;node == &amp;it.range()-&gt;endContainer());
1286             int offset = it.range()-&gt;startOffset();
1287             if (replacedNodeNeedsCharacter(node.traverseToChildAt(offset)))
1288                 builder.append(objectReplacementCharacter);
1289         }
1290     }
1291 
1292     return builder.toString();
1293 }
1294 
1295 String AccessibilityObject::stringForVisiblePositionRange(const VisiblePositionRange&amp; visiblePositionRange)
1296 {
1297     if (visiblePositionRange.isNull())
1298         return String();
1299 
1300     StringBuilder builder;
1301     RefPtr&lt;Range&gt; range = makeRange(visiblePositionRange.start, visiblePositionRange.end);
1302     for (TextIterator it(range.get()); !it.atEnd(); it.advance()) {
1303         // non-zero length means textual node, zero length means replaced node (AKA &quot;attachments&quot; in AX)
1304         if (it.text().length()) {
1305             // Add a textual representation for list marker text.
1306             builder.append(listMarkerTextForNodeAndPosition(it.node(), visiblePositionRange.start));
1307             it.appendTextToStringBuilder(builder);
1308         } else {
1309             // locate the node and starting offset for this replaced range
1310             Node&amp; node = it.range()-&gt;startContainer();
1311             ASSERT(&amp;node == &amp;it.range()-&gt;endContainer());
1312             int offset = it.range()-&gt;startOffset();
1313             if (replacedNodeNeedsCharacter(node.traverseToChildAt(offset)))
1314                 builder.append(objectReplacementCharacter);
1315         }
1316     }
1317 
1318     return builder.toString();
1319 }
1320 
1321 int AccessibilityObject::lengthForVisiblePositionRange(const VisiblePositionRange&amp; visiblePositionRange) const
1322 {
1323     // FIXME: Multi-byte support
1324     if (visiblePositionRange.isNull())
1325         return -1;
1326 
1327     int length = 0;
1328     RefPtr&lt;Range&gt; range = makeRange(visiblePositionRange.start, visiblePositionRange.end);
1329     for (TextIterator it(range.get()); !it.atEnd(); it.advance()) {
1330         // non-zero length means textual node, zero length means replaced node (AKA &quot;attachments&quot; in AX)
1331         if (it.text().length())
1332             length += it.text().length();
1333         else {
1334             // locate the node and starting offset for this replaced range
1335             Node&amp; node = it.range()-&gt;startContainer();
1336             ASSERT(&amp;node == &amp;it.range()-&gt;endContainer());
1337             int offset = it.range()-&gt;startOffset();
1338 
1339             if (replacedNodeNeedsCharacter(node.traverseToChildAt(offset)))
1340                 ++length;
1341         }
1342     }
1343 
1344     return length;
1345 }
1346 
1347 VisiblePosition AccessibilityObject::visiblePositionForBounds(const IntRect&amp; rect, AccessibilityVisiblePositionForBounds visiblePositionForBounds) const
1348 {
1349     if (rect.isEmpty())
1350         return VisiblePosition();
1351 
1352     auto* mainFrame = this-&gt;mainFrame();
1353     if (!mainFrame)
1354         return VisiblePosition();
1355 
1356     // FIXME: Add support for right-to-left languages.
1357     IntPoint corner = (visiblePositionForBounds == AccessibilityVisiblePositionForBounds::First) ? rect.minXMinYCorner() : rect.maxXMaxYCorner();
1358     VisiblePosition position = mainFrame-&gt;visiblePositionForPoint(corner);
1359 
1360     if (rect.contains(position.absoluteCaretBounds().center()))
1361         return position;
1362 
1363     // If the initial position is located outside the bounds adjust it incrementally as needed.
1364     VisiblePosition nextPosition = position.next();
1365     VisiblePosition previousPosition = position.previous();
1366     while (nextPosition.isNotNull() || previousPosition.isNotNull()) {
1367         if (rect.contains(nextPosition.absoluteCaretBounds().center()))
1368             return nextPosition;
1369         if (rect.contains(previousPosition.absoluteCaretBounds().center()))
1370             return previousPosition;
1371 
1372         nextPosition = nextPosition.next();
1373         previousPosition = previousPosition.previous();
1374     }
1375 
1376     return VisiblePosition();
1377 }
1378 
1379 VisiblePosition AccessibilityObject::nextWordEnd(const VisiblePosition&amp; visiblePos) const
1380 {
1381     if (visiblePos.isNull())
1382         return VisiblePosition();
1383 
1384     // make sure we move off of a word end
1385     VisiblePosition nextVisiblePos = visiblePos.next();
1386     if (nextVisiblePos.isNull())
1387         return VisiblePosition();
1388 
1389     return endOfWord(nextVisiblePos, LeftWordIfOnBoundary);
1390 }
1391 
1392 VisiblePosition AccessibilityObject::previousWordStart(const VisiblePosition&amp; visiblePos) const
1393 {
1394     if (visiblePos.isNull())
1395         return VisiblePosition();
1396 
1397     // make sure we move off of a word start
1398     VisiblePosition prevVisiblePos = visiblePos.previous();
1399     if (prevVisiblePos.isNull())
1400         return VisiblePosition();
1401 
1402     return startOfWord(prevVisiblePos, RightWordIfOnBoundary);
1403 }
1404 
1405 VisiblePosition AccessibilityObject::nextLineEndPosition(const VisiblePosition&amp; visiblePos) const
1406 {
1407     if (visiblePos.isNull())
1408         return VisiblePosition();
1409 
1410     // to make sure we move off of a line end
1411     VisiblePosition nextVisiblePos = visiblePos.next();
1412     if (nextVisiblePos.isNull())
1413         return VisiblePosition();
1414 
1415     VisiblePosition endPosition = endOfLine(nextVisiblePos);
1416 
1417     // as long as the position hasn&#39;t reached the end of the doc,  keep searching for a valid line end position
1418     // There are cases like when the position is next to a floating object that&#39;ll return null for end of line. This code will avoid returning null.
1419     while (endPosition.isNull() &amp;&amp; nextVisiblePos.isNotNull()) {
1420         nextVisiblePos = nextVisiblePos.next();
1421         endPosition = endOfLine(nextVisiblePos);
1422     }
1423 
1424     return endPosition;
1425 }
1426 
1427 VisiblePosition AccessibilityObject::previousLineStartPosition(const VisiblePosition&amp; visiblePos) const
1428 {
1429     if (visiblePos.isNull())
1430         return VisiblePosition();
1431 
1432     // make sure we move off of a line start
1433     VisiblePosition prevVisiblePos = visiblePos.previous();
1434     if (prevVisiblePos.isNull())
1435         return VisiblePosition();
1436 
1437     VisiblePosition startPosition = startOfLine(prevVisiblePos);
1438 
1439     // as long as the position hasn&#39;t reached the beginning of the doc,  keep searching for a valid line start position
1440     // There are cases like when the position is next to a floating object that&#39;ll return null for start of line. This code will avoid returning null.
1441     if (startPosition.isNull()) {
1442         while (startPosition.isNull() &amp;&amp; prevVisiblePos.isNotNull()) {
1443             prevVisiblePos = prevVisiblePos.previous();
1444             startPosition = startOfLine(prevVisiblePos);
1445         }
1446     } else
1447         startPosition = updateAXLineStartForVisiblePosition(startPosition);
1448 
1449     return startPosition;
1450 }
1451 
1452 VisiblePosition AccessibilityObject::nextSentenceEndPosition(const VisiblePosition&amp; visiblePos) const
1453 {
1454     // FIXME: FO 2 IMPLEMENT (currently returns incorrect answer)
1455     // Related? &lt;rdar://problem/3927736&gt; Text selection broken in 8A336
1456     if (visiblePos.isNull())
1457         return VisiblePosition();
1458 
1459     // make sure we move off of a sentence end
1460     VisiblePosition nextVisiblePos = visiblePos.next();
1461     if (nextVisiblePos.isNull())
1462         return VisiblePosition();
1463 
1464     // an empty line is considered a sentence. If it&#39;s skipped, then the sentence parser will not
1465     // see this empty line.  Instead, return the end position of the empty line.
1466     VisiblePosition endPosition;
1467 
1468     String lineString = plainText(makeRange(startOfLine(nextVisiblePos), endOfLine(nextVisiblePos)).get());
1469     if (lineString.isEmpty())
1470         endPosition = nextVisiblePos;
1471     else
1472         endPosition = endOfSentence(nextVisiblePos);
1473 
1474     return endPosition;
1475 }
1476 
1477 VisiblePosition AccessibilityObject::previousSentenceStartPosition(const VisiblePosition&amp; visiblePos) const
1478 {
1479     // FIXME: FO 2 IMPLEMENT (currently returns incorrect answer)
1480     // Related? &lt;rdar://problem/3927736&gt; Text selection broken in 8A336
1481     if (visiblePos.isNull())
1482         return VisiblePosition();
1483 
1484     // make sure we move off of a sentence start
1485     VisiblePosition previousVisiblePos = visiblePos.previous();
1486     if (previousVisiblePos.isNull())
1487         return VisiblePosition();
1488 
1489     // treat empty line as a separate sentence.
1490     VisiblePosition startPosition;
1491 
1492     String lineString = plainText(makeRange(startOfLine(previousVisiblePos), endOfLine(previousVisiblePos)).get());
1493     if (lineString.isEmpty())
1494         startPosition = previousVisiblePos;
1495     else
1496         startPosition = startOfSentence(previousVisiblePos);
1497 
1498     return startPosition;
1499 }
1500 
1501 VisiblePosition AccessibilityObject::nextParagraphEndPosition(const VisiblePosition&amp; visiblePos) const
1502 {
1503     if (visiblePos.isNull())
1504         return VisiblePosition();
1505 
1506     // make sure we move off of a paragraph end
1507     VisiblePosition nextPos = visiblePos.next();
1508     if (nextPos.isNull())
1509         return VisiblePosition();
1510 
1511     return endOfParagraph(nextPos);
1512 }
1513 
1514 VisiblePosition AccessibilityObject::previousParagraphStartPosition(const VisiblePosition&amp; visiblePos) const
1515 {
1516     if (visiblePos.isNull())
1517         return VisiblePosition();
1518 
1519     // make sure we move off of a paragraph start
1520     VisiblePosition previousPos = visiblePos.previous();
1521     if (previousPos.isNull())
1522         return VisiblePosition();
1523 
1524     return startOfParagraph(previousPos);
1525 }
1526 
1527 AccessibilityObject* AccessibilityObject::accessibilityObjectForPosition(const VisiblePosition&amp; visiblePos) const
1528 {
1529     if (visiblePos.isNull())
1530         return nullptr;
1531 
1532     RenderObject* obj = visiblePos.deepEquivalent().deprecatedNode()-&gt;renderer();
1533     if (!obj)
1534         return nullptr;
1535 
1536     return obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);
1537 }
1538 
1539 // If you call node-&gt;hasEditableStyle() since that will return true if an ancestor is editable.
1540 // This only returns true if this is the element that actually has the contentEditable attribute set.
1541 bool AccessibilityObject::hasContentEditableAttributeSet() const
1542 {
1543     return contentEditableAttributeIsEnabled(element());
1544 }
1545 
1546 bool AccessibilityObject::supportsReadOnly() const
1547 {
1548     AccessibilityRole role = roleValue();
1549 
1550     return role == AccessibilityRole::CheckBox
1551         || role == AccessibilityRole::ColumnHeader
1552         || role == AccessibilityRole::ComboBox
1553         || role == AccessibilityRole::Grid
1554         || role == AccessibilityRole::GridCell
1555         || role == AccessibilityRole::ListBox
1556         || role == AccessibilityRole::MenuItemCheckbox
1557         || role == AccessibilityRole::MenuItemRadio
1558         || role == AccessibilityRole::RadioGroup
1559         || role == AccessibilityRole::RowHeader
1560         || role == AccessibilityRole::SearchField
1561         || role == AccessibilityRole::Slider
1562         || role == AccessibilityRole::SpinButton
1563         || role == AccessibilityRole::Switch
1564         || role == AccessibilityRole::TextField
1565         || role == AccessibilityRole::TreeGrid
1566         || isPasswordField();
1567 }
1568 
1569 String AccessibilityObject::readOnlyValue() const
1570 {
1571     if (!hasAttribute(aria_readonlyAttr))
1572         return ariaRoleAttribute() != AccessibilityRole::Unknown &amp;&amp; supportsReadOnly() ? &quot;false&quot; : String();
1573 
1574     return getAttribute(aria_readonlyAttr).string().convertToASCIILowercase();
1575 }
1576 
1577 bool AccessibilityObject::supportsAutoComplete() const
1578 {
1579     return (isComboBox() || isARIATextControl()) &amp;&amp; hasAttribute(aria_autocompleteAttr);
1580 }
1581 
1582 String AccessibilityObject::autoCompleteValue() const
1583 {
1584     const AtomString&amp; autoComplete = getAttribute(aria_autocompleteAttr);
1585     if (equalLettersIgnoringASCIICase(autoComplete, &quot;inline&quot;)
1586         || equalLettersIgnoringASCIICase(autoComplete, &quot;list&quot;)
1587         || equalLettersIgnoringASCIICase(autoComplete, &quot;both&quot;))
1588         return autoComplete;
1589 
1590     return &quot;none&quot;;
1591 }
1592 
1593 bool AccessibilityObject::contentEditableAttributeIsEnabled(Element* element)
1594 {
1595     if (!element)
1596         return false;
1597 
1598     const AtomString&amp; contentEditableValue = element-&gt;attributeWithoutSynchronization(contenteditableAttr);
1599     if (contentEditableValue.isNull())
1600         return false;
1601 
1602     // Both &quot;true&quot; (case-insensitive) and the empty string count as true.
1603     return contentEditableValue.isEmpty() || equalLettersIgnoringASCIICase(contentEditableValue, &quot;true&quot;);
1604 }
1605 
1606 #if ENABLE(ACCESSIBILITY)
1607 int AccessibilityObject::lineForPosition(const VisiblePosition&amp; visiblePos) const
1608 {
1609     if (visiblePos.isNull() || !node())
1610         return -1;
1611 
1612     // If the position is not in the same editable region as this AX object, return -1.
1613     Node* containerNode = visiblePos.deepEquivalent().containerNode();
1614     if (!containerNode-&gt;containsIncludingShadowDOM(node()) &amp;&amp; !node()-&gt;containsIncludingShadowDOM(containerNode))
1615         return -1;
1616 
1617     int lineCount = -1;
1618     VisiblePosition currentVisiblePos = visiblePos;
1619     VisiblePosition savedVisiblePos;
1620 
1621     // move up until we get to the top
1622     // FIXME: This only takes us to the top of the rootEditableElement, not the top of the
1623     // top document.
1624     do {
1625         savedVisiblePos = currentVisiblePos;
1626         VisiblePosition prevVisiblePos = previousLinePosition(currentVisiblePos, 0, HasEditableAXRole);
1627         currentVisiblePos = prevVisiblePos;
1628         ++lineCount;
1629     }  while (currentVisiblePos.isNotNull() &amp;&amp; !(inSameLine(currentVisiblePos, savedVisiblePos)));
1630 
1631     return lineCount;
1632 }
1633 #endif
1634 
1635 // NOTE: Consider providing this utility method as AX API
1636 PlainTextRange AccessibilityObject::plainTextRangeForVisiblePositionRange(const VisiblePositionRange&amp; positionRange) const
1637 {
1638     int index1 = index(positionRange.start);
1639     int index2 = index(positionRange.end);
1640     if (index1 &lt; 0 || index2 &lt; 0 || index1 &gt; index2)
1641         return PlainTextRange();
1642 
1643     return PlainTextRange(index1, index2 - index1);
1644 }
1645 
1646 // The composed character range in the text associated with this accessibility object that
1647 // is specified by the given screen coordinates. This parameterized attribute returns the
1648 // complete range of characters (including surrogate pairs of multi-byte glyphs) at the given
1649 // screen coordinates.
1650 // NOTE: This varies from AppKit when the point is below the last line. AppKit returns an
1651 // an error in that case. We return textControl-&gt;text().length(), 1. Does this matter?
1652 PlainTextRange AccessibilityObject::doAXRangeForPosition(const IntPoint&amp; point) const
1653 {
1654     int i = index(visiblePositionForPoint(point));
1655     if (i &lt; 0)
1656         return PlainTextRange();
1657 
1658     return PlainTextRange(i, 1);
1659 }
1660 
1661 // Given a character index, the range of text associated with this accessibility object
1662 // over which the style in effect at that character index applies.
1663 PlainTextRange AccessibilityObject::doAXStyleRangeForIndex(unsigned index) const
1664 {
1665     VisiblePositionRange range = styleRangeForPosition(visiblePositionForIndex(index, false));
1666     return plainTextRangeForVisiblePositionRange(range);
1667 }
1668 
1669 // Given an indexed character, the line number of the text associated with this accessibility
1670 // object that contains the character.
1671 unsigned AccessibilityObject::doAXLineForIndex(unsigned index)
1672 {
1673     return lineForPosition(visiblePositionForIndex(index, false));
1674 }
1675 
1676 #if ENABLE(ACCESSIBILITY)
1677 void AccessibilityObject::updateBackingStore()
1678 {
1679     if (!axObjectCache())
1680         return;
1681 
1682     // Updating the layout may delete this object.
1683     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
1684     if (auto* document = this-&gt;document()) {
1685         if (!document-&gt;view()-&gt;layoutContext().isInRenderTreeLayout() &amp;&amp; !document-&gt;inRenderTreeUpdate() &amp;&amp; !document-&gt;inStyleRecalc())
1686             document-&gt;updateLayoutIgnorePendingStylesheets();
1687     }
1688 
1689     if (auto cache = axObjectCache())
1690         cache-&gt;performDeferredCacheUpdate();
1691 
1692     updateChildrenIfNecessary();
1693 }
1694 #endif
1695 
1696 const AccessibilityScrollView* AccessibilityObject::ancestorAccessibilityScrollView(bool includeSelf) const
1697 {
<a name="22" id="anc22"></a><span class="line-modified">1698     return downcast&lt;AccessibilityScrollView&gt;(Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, includeSelf, [] (const auto&amp; object) {</span>
1699         return is&lt;AccessibilityScrollView&gt;(object);
1700     }));
1701 }
1702 
1703 ScrollView* AccessibilityObject::scrollViewAncestor() const
1704 {
1705     if (auto parentScrollView = ancestorAccessibilityScrollView(true/* includeSelf */))
1706         return parentScrollView-&gt;scrollView();
1707 
1708     return nullptr;
1709 }
1710 
1711 Document* AccessibilityObject::document() const
1712 {
1713     FrameView* frameView = documentFrameView();
1714     if (!frameView)
1715         return nullptr;
1716 
1717     return frameView-&gt;frame().document();
1718 }
1719 
1720 Page* AccessibilityObject::page() const
1721 {
1722     Document* document = this-&gt;document();
1723     if (!document)
1724         return nullptr;
1725     return document-&gt;page();
1726 }
1727 
1728 FrameView* AccessibilityObject::documentFrameView() const
1729 {
1730     const AccessibilityObject* object = this;
1731     while (object &amp;&amp; !object-&gt;isAccessibilityRenderObject())
1732         object = object-&gt;parentObject();
1733 
1734     if (!object)
1735         return nullptr;
1736 
1737     return object-&gt;documentFrameView();
1738 }
1739 
1740 #if ENABLE(ACCESSIBILITY)
1741 const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityObject::children(bool updateChildrenIfNeeded)
1742 {
1743     if (updateChildrenIfNeeded)
1744         updateChildrenIfNecessary();
1745 
1746     return m_children;
1747 }
1748 #endif
1749 
1750 void AccessibilityObject::updateChildrenIfNecessary()
1751 {
1752     if (!hasChildren()) {
<a name="23" id="anc23"></a><span class="line-added">1753 #if HAVE(ACCESSIBILITY)</span>
1754         // Enable the cache in case we end up adding a lot of children, we don&#39;t want to recompute axIsIgnored each time.
1755         AXAttributeCacheEnabler enableCache(axObjectCache());
<a name="24" id="anc24"></a><span class="line-added">1756 #endif</span>
1757         addChildren();
1758     }
1759 }
1760 
1761 void AccessibilityObject::clearChildren()
1762 {
1763     // Some objects have weak pointers to their parents and those associations need to be detached.
1764     for (const auto&amp; child : m_children)
1765         child-&gt;detachFromParent();
1766 
1767     m_children.clear();
1768     m_haveChildren = false;
1769 }
1770 
1771 AccessibilityObject* AccessibilityObject::anchorElementForNode(Node* node)
1772 {
1773     RenderObject* obj = node-&gt;renderer();
1774     if (!obj)
1775         return nullptr;
1776 
1777     RefPtr&lt;AccessibilityObject&gt; axObj = obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);
1778     Element* anchor = axObj-&gt;anchorElement();
1779     if (!anchor)
1780         return nullptr;
1781 
1782     RenderObject* anchorRenderer = anchor-&gt;renderer();
1783     if (!anchorRenderer)
1784         return nullptr;
1785 
1786     return anchorRenderer-&gt;document().axObjectCache()-&gt;getOrCreate(anchorRenderer);
1787 }
1788 
1789 AccessibilityObject* AccessibilityObject::headingElementForNode(Node* node)
1790 {
1791     if (!node)
1792         return nullptr;
1793 
1794     RenderObject* renderObject = node-&gt;renderer();
1795     if (!renderObject)
1796         return nullptr;
1797 
1798     AccessibilityObject* axObject = renderObject-&gt;document().axObjectCache()-&gt;getOrCreate(renderObject);
1799 
<a name="25" id="anc25"></a><span class="line-modified">1800     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*axObject, true, [] (const AccessibilityObject&amp; object) {</span>
1801         return object.roleValue() == AccessibilityRole::Heading;
<a name="26" id="anc26"></a><span class="line-modified">1802     });</span>










1803 }
1804 
1805 void AccessibilityObject::ariaTreeRows(AccessibilityChildrenVector&amp; result)
1806 {
1807     for (const auto&amp; child : children()) {
1808         // Add tree items as the rows.
1809         if (child-&gt;roleValue() == AccessibilityRole::TreeItem)
1810             result.append(child);
1811 
1812         // Now see if this item also has rows hiding inside of it.
1813         child-&gt;ariaTreeRows(result);
1814     }
1815 }
1816 
1817 void AccessibilityObject::ariaTreeItemContent(AccessibilityChildrenVector&amp; result)
1818 {
1819     // The ARIA tree item content are the item that are not other tree items or their containing groups.
1820     for (const auto&amp; child : children()) {
1821         if (!child-&gt;isGroup() &amp;&amp; child-&gt;roleValue() != AccessibilityRole::TreeItem)
1822             result.append(child);
1823     }
1824 }
1825 
1826 void AccessibilityObject::ariaTreeItemDisclosedRows(AccessibilityChildrenVector&amp; result)
1827 {
1828     for (const auto&amp; obj : children()) {
1829         // Add tree items as the rows.
1830         if (obj-&gt;roleValue() == AccessibilityRole::TreeItem)
1831             result.append(obj);
1832         // If it&#39;s not a tree item, then descend into the group to find more tree items.
1833         else
1834             obj-&gt;ariaTreeRows(result);
1835     }
1836 }
1837 
1838 const String AccessibilityObject::defaultLiveRegionStatusForRole(AccessibilityRole role)
1839 {
1840     switch (role) {
1841     case AccessibilityRole::ApplicationAlertDialog:
1842     case AccessibilityRole::ApplicationAlert:
1843         return &quot;assertive&quot;_s;
1844     case AccessibilityRole::ApplicationLog:
1845     case AccessibilityRole::ApplicationStatus:
1846         return &quot;polite&quot;_s;
1847     case AccessibilityRole::ApplicationTimer:
1848     case AccessibilityRole::ApplicationMarquee:
1849         return &quot;off&quot;_s;
1850     default:
1851         return nullAtom();
1852     }
1853 }
1854 
1855 #if ENABLE(ACCESSIBILITY)
<a name="27" id="anc27"></a><span class="line-modified">1856 String AccessibilityObject::actionVerb() const</span>
1857 {
1858 #if !PLATFORM(IOS_FAMILY)
1859     // FIXME: Need to add verbs for select elements.
1860     static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
1861     static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
1862     static NeverDestroyed&lt;const String&gt; radioButtonAction(AXRadioButtonActionVerb());
1863     static NeverDestroyed&lt;const String&gt; checkedCheckBoxAction(AXCheckedCheckBoxActionVerb());
1864     static NeverDestroyed&lt;const String&gt; uncheckedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
1865     static NeverDestroyed&lt;const String&gt; linkAction(AXLinkActionVerb());
1866     static NeverDestroyed&lt;const String&gt; menuListAction(AXMenuListActionVerb());
1867     static NeverDestroyed&lt;const String&gt; menuListPopupAction(AXMenuListPopupActionVerb());
1868     static NeverDestroyed&lt;const String&gt; listItemAction(AXListItemActionVerb());
1869 
1870     switch (roleValue()) {
1871     case AccessibilityRole::Button:
1872     case AccessibilityRole::ToggleButton:
1873         return buttonAction;
1874     case AccessibilityRole::TextField:
1875     case AccessibilityRole::TextArea:
1876         return textFieldAction;
1877     case AccessibilityRole::RadioButton:
1878         return radioButtonAction;
1879     case AccessibilityRole::CheckBox:
1880     case AccessibilityRole::Switch:
1881         return isChecked() ? checkedCheckBoxAction : uncheckedCheckBoxAction;
1882     case AccessibilityRole::Link:
1883     case AccessibilityRole::WebCoreLink:
1884         return linkAction;
1885     case AccessibilityRole::PopUpButton:
1886         return menuListAction;
1887     case AccessibilityRole::MenuListPopup:
1888         return menuListPopupAction;
1889     case AccessibilityRole::ListItem:
1890         return listItemAction;
1891     default:
1892         return nullAtom();
1893     }
1894 #else
1895     return nullAtom();
1896 #endif
1897 }
1898 #endif
1899 
1900 bool AccessibilityObject::ariaIsMultiline() const
1901 {
1902     return equalLettersIgnoringASCIICase(getAttribute(aria_multilineAttr), &quot;true&quot;);
1903 }
1904 
1905 String AccessibilityObject::invalidStatus() const
1906 {
1907     String grammarValue = &quot;grammar&quot;_s;
1908     String falseValue = &quot;false&quot;_s;
1909     String spellingValue = &quot;spelling&quot;_s;
1910     String trueValue = &quot;true&quot;_s;
1911     String undefinedValue = &quot;undefined&quot;_s;
1912 
1913     // aria-invalid can return false (default), grammar, spelling, or true.
1914     String ariaInvalid = stripLeadingAndTrailingHTMLSpaces(getAttribute(aria_invalidAttr));
1915 
1916     if (ariaInvalid.isEmpty()) {
1917         // We should expose invalid status for input types.
1918         Node* node = this-&gt;node();
1919         if (node &amp;&amp; is&lt;HTMLInputElement&gt;(*node)) {
1920             HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
1921             if (input.hasBadInput() || input.typeMismatch())
1922                 return trueValue;
1923         }
1924         return falseValue;
1925     }
1926 
1927     // If &quot;false&quot;, &quot;undefined&quot; [sic, string value], empty, or missing, return &quot;false&quot;.
1928     if (ariaInvalid == falseValue || ariaInvalid == undefinedValue)
1929         return falseValue;
1930     // Besides true/false/undefined, the only tokens defined by WAI-ARIA 1.0...
1931     // ...for @aria-invalid are &quot;grammar&quot; and &quot;spelling&quot;.
1932     if (ariaInvalid == grammarValue)
1933         return grammarValue;
1934     if (ariaInvalid == spellingValue)
1935         return spellingValue;
1936     // Any other non empty string should be treated as &quot;true&quot;.
1937     return trueValue;
1938 }
1939 
1940 bool AccessibilityObject::supportsCurrent() const
1941 {
1942     return hasAttribute(aria_currentAttr);
1943 }
1944 
1945 AccessibilityCurrentState AccessibilityObject::currentState() const
1946 {
1947     // aria-current can return false (default), true, page, step, location, date or time.
1948     String currentStateValue = stripLeadingAndTrailingHTMLSpaces(getAttribute(aria_currentAttr));
1949 
1950     // If &quot;false&quot;, empty, or missing, return false state.
1951     if (currentStateValue.isEmpty() || currentStateValue == &quot;false&quot;)
1952         return AccessibilityCurrentState::False;
1953 
1954     if (currentStateValue == &quot;page&quot;)
1955         return AccessibilityCurrentState::Page;
1956     if (currentStateValue == &quot;step&quot;)
1957         return AccessibilityCurrentState::Step;
1958     if (currentStateValue == &quot;location&quot;)
1959         return AccessibilityCurrentState::Location;
1960     if (currentStateValue == &quot;date&quot;)
1961         return AccessibilityCurrentState::Date;
1962     if (currentStateValue == &quot;time&quot;)
1963         return AccessibilityCurrentState::Time;
1964 
1965     // Any value not included in the list of allowed values should be treated as &quot;true&quot;.
1966     return AccessibilityCurrentState::True;
1967 }
1968 
1969 String AccessibilityObject::currentValue() const
1970 {
1971     switch (currentState()) {
1972     case AccessibilityCurrentState::False:
1973         return &quot;false&quot;;
1974     case AccessibilityCurrentState::Page:
1975         return &quot;page&quot;;
1976     case AccessibilityCurrentState::Step:
1977         return &quot;step&quot;;
1978     case AccessibilityCurrentState::Location:
1979         return &quot;location&quot;;
1980     case AccessibilityCurrentState::Time:
1981         return &quot;time&quot;;
1982     case AccessibilityCurrentState::Date:
1983         return &quot;date&quot;;
1984     default:
1985     case AccessibilityCurrentState::True:
1986         return &quot;true&quot;;
1987     }
1988 }
1989 
1990 bool AccessibilityObject::isModalDescendant(Node* modalNode) const
1991 {
1992     Node* node = this-&gt;node();
1993     if (!modalNode || !node)
1994         return false;
1995 
1996     if (node == modalNode)
1997         return true;
1998 
1999     // ARIA 1.1 aria-modal, indicates whether an element is modal when displayed.
2000     // For the decendants of the modal object, they should also be considered as aria-modal=true.
2001     return node-&gt;isDescendantOf(*modalNode);
2002 }
2003 
2004 bool AccessibilityObject::isModalNode() const
2005 {
2006     if (AXObjectCache* cache = axObjectCache())
2007         return node() &amp;&amp; cache-&gt;modalNode() == node();
2008 
2009     return false;
2010 }
2011 
2012 bool AccessibilityObject::ignoredFromModalPresence() const
2013 {
2014     // We shouldn&#39;t ignore the top node.
2015     if (!node() || !node()-&gt;parentNode())
2016         return false;
2017 
2018     AXObjectCache* cache = axObjectCache();
2019     if (!cache)
2020         return false;
2021 
2022     // modalNode is the current displayed modal dialog.
2023     Node* modalNode = cache-&gt;modalNode();
2024     if (!modalNode)
2025         return false;
2026 
2027     // We only want to ignore the objects within the same frame as the modal dialog.
2028     if (modalNode-&gt;document().frame() != this-&gt;frame())
2029         return false;
2030 
2031     return !isModalDescendant(modalNode);
2032 }
2033 
2034 bool AccessibilityObject::hasTagName(const QualifiedName&amp; tagName) const
2035 {
2036     Node* node = this-&gt;node();
2037     return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(*node).hasTagName(tagName);
2038 }
2039 
2040 bool AccessibilityObject::hasAttribute(const QualifiedName&amp; attribute) const
2041 {
2042     Node* node = this-&gt;node();
2043     if (!is&lt;Element&gt;(node))
2044         return false;
2045 
2046     return downcast&lt;Element&gt;(*node).hasAttributeWithoutSynchronization(attribute);
2047 }
2048 
2049 const AtomString&amp; AccessibilityObject::getAttribute(const QualifiedName&amp; attribute) const
2050 {
2051     if (auto* element = this-&gt;element())
2052         return element-&gt;attributeWithoutSynchronization(attribute);
2053     return nullAtom();
2054 }
2055 
2056 bool AccessibilityObject::replaceTextInRange(const String&amp; replacementString, const PlainTextRange&amp; range)
2057 {
2058     if (!renderer() || !is&lt;Element&gt;(node()))
2059         return false;
2060 
2061     auto&amp; element = downcast&lt;Element&gt;(*renderer()-&gt;node());
2062 
2063     // We should use the editor&#39;s insertText to mimic typing into the field.
2064     // Also only do this when the field is in editing mode.
2065     auto&amp; frame = renderer()-&gt;frame();
2066     if (element.shouldUseInputMethod()) {
2067         frame.selection().setSelectedRange(rangeForPlainTextRange(range).get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes);
2068         frame.editor().replaceSelectionWithText(replacementString, Editor::SelectReplacement::No, Editor::SmartReplace::No);
2069         return true;
2070     }
2071 
2072     if (is&lt;HTMLInputElement&gt;(element)) {
2073         downcast&lt;HTMLInputElement&gt;(element).setRangeText(replacementString, range.start, range.length, &quot;&quot;);
2074         return true;
2075     }
2076     if (is&lt;HTMLTextAreaElement&gt;(element)) {
2077         downcast&lt;HTMLTextAreaElement&gt;(element).setRangeText(replacementString, range.start, range.length, &quot;&quot;);
2078         return true;
2079     }
2080 
2081     return false;
2082 }
2083 
2084 bool AccessibilityObject::insertText(const String&amp; text)
2085 {
2086     if (!renderer() || !is&lt;Element&gt;(node()))
2087         return false;
2088 
2089     auto&amp; element = downcast&lt;Element&gt;(*renderer()-&gt;node());
2090 
2091     // Only try to insert text if the field is in editing mode.
2092     if (!element.shouldUseInputMethod())
2093         return false;
2094 
2095     // Use Editor::insertText to mimic typing into the field.
2096     auto&amp; editor = renderer()-&gt;frame().editor();
2097     return editor.insertText(text, nullptr);
2098 }
2099 
2100 // Lacking concrete evidence of orientation, horizontal means width &gt; height. vertical is height &gt; width;
2101 AccessibilityOrientation AccessibilityObject::orientation() const
2102 {
2103     LayoutRect bounds = elementRect();
2104     if (bounds.size().width() &gt; bounds.size().height())
2105         return AccessibilityOrientation::Horizontal;
2106     if (bounds.size().height() &gt; bounds.size().width())
2107         return AccessibilityOrientation::Vertical;
2108 
2109     return AccessibilityOrientation::Undefined;
2110 }
2111 
<a name="28" id="anc28"></a><span class="line-modified">2112 bool AccessibilityObject::isDescendantOfObject(const AXCoreObject* axObject) const</span>
2113 {
2114     if (!axObject || !axObject-&gt;hasChildren())
2115         return false;
2116 
<a name="29" id="anc29"></a><span class="line-modified">2117     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [axObject] (const AccessibilityObject&amp; object) {</span>
2118         return &amp;object == axObject;
2119     }) != nullptr;
2120 }
2121 
<a name="30" id="anc30"></a><span class="line-modified">2122 bool AccessibilityObject::isAncestorOfObject(const AXCoreObject* axObject) const</span>
2123 {
2124     if (!axObject)
2125         return false;
2126 
2127     return this == axObject || axObject-&gt;isDescendantOfObject(this);
2128 }
2129 
2130 AccessibilityObject* AccessibilityObject::firstAnonymousBlockChild() const
2131 {
2132     for (AccessibilityObject* child = firstChild(); child; child = child-&gt;nextSibling()) {
2133         if (child-&gt;renderer() &amp;&amp; child-&gt;renderer()-&gt;isAnonymousBlock())
2134             return child;
2135     }
2136     return nullptr;
2137 }
2138 
2139 using ARIARoleMap = HashMap&lt;String, AccessibilityRole, ASCIICaseInsensitiveHash&gt;;
2140 using ARIAReverseRoleMap = HashMap&lt;AccessibilityRole, String, DefaultHash&lt;int&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;int&gt;&gt;;
2141 
2142 static ARIARoleMap* gAriaRoleMap = nullptr;
2143 static ARIAReverseRoleMap* gAriaReverseRoleMap = nullptr;
2144 
2145 struct RoleEntry {
2146     String ariaRole;
2147     AccessibilityRole webcoreRole;
2148 };
2149 
2150 static void initializeRoleMap()
2151 {
2152     if (gAriaRoleMap)
2153         return;
2154     ASSERT(!gAriaReverseRoleMap);
2155 
2156     const RoleEntry roles[] = {
2157         { &quot;alert&quot;, AccessibilityRole::ApplicationAlert },
2158         { &quot;alertdialog&quot;, AccessibilityRole::ApplicationAlertDialog },
2159         { &quot;application&quot;, AccessibilityRole::WebApplication },
2160         { &quot;article&quot;, AccessibilityRole::DocumentArticle },
2161         { &quot;banner&quot;, AccessibilityRole::LandmarkBanner },
2162         { &quot;blockquote&quot;, AccessibilityRole::Blockquote },
2163         { &quot;button&quot;, AccessibilityRole::Button },
2164         { &quot;caption&quot;, AccessibilityRole::Caption },
2165         { &quot;checkbox&quot;, AccessibilityRole::CheckBox },
2166         { &quot;complementary&quot;, AccessibilityRole::LandmarkComplementary },
2167         { &quot;contentinfo&quot;, AccessibilityRole::LandmarkContentInfo },
2168         { &quot;deletion&quot;, AccessibilityRole::Deletion },
2169         { &quot;dialog&quot;, AccessibilityRole::ApplicationDialog },
2170         { &quot;directory&quot;, AccessibilityRole::Directory },
2171         // The &#39;doc-*&#39; roles are defined the ARIA DPUB mobile: https://www.w3.org/TR/dpub-aam-1.0/
2172         // Editor&#39;s draft is currently at https://rawgit.com/w3c/aria/master/dpub-aam/dpub-aam.html
2173         { &quot;doc-abstract&quot;, AccessibilityRole::ApplicationTextGroup },
2174         { &quot;doc-acknowledgments&quot;, AccessibilityRole::LandmarkDocRegion },
2175         { &quot;doc-afterword&quot;, AccessibilityRole::LandmarkDocRegion },
2176         { &quot;doc-appendix&quot;, AccessibilityRole::LandmarkDocRegion },
2177         { &quot;doc-backlink&quot;, AccessibilityRole::WebCoreLink },
2178         { &quot;doc-biblioentry&quot;, AccessibilityRole::ListItem },
2179         { &quot;doc-bibliography&quot;, AccessibilityRole::LandmarkDocRegion },
2180         { &quot;doc-biblioref&quot;, AccessibilityRole::WebCoreLink },
2181         { &quot;doc-chapter&quot;, AccessibilityRole::LandmarkDocRegion },
2182         { &quot;doc-colophon&quot;, AccessibilityRole::ApplicationTextGroup },
2183         { &quot;doc-conclusion&quot;, AccessibilityRole::LandmarkDocRegion },
2184         { &quot;doc-cover&quot;, AccessibilityRole::Image },
2185         { &quot;doc-credit&quot;, AccessibilityRole::ApplicationTextGroup },
2186         { &quot;doc-credits&quot;, AccessibilityRole::LandmarkDocRegion },
2187         { &quot;doc-dedication&quot;, AccessibilityRole::ApplicationTextGroup },
2188         { &quot;doc-endnote&quot;, AccessibilityRole::ListItem },
2189         { &quot;doc-endnotes&quot;, AccessibilityRole::LandmarkDocRegion },
2190         { &quot;doc-epigraph&quot;, AccessibilityRole::ApplicationTextGroup },
2191         { &quot;doc-epilogue&quot;, AccessibilityRole::LandmarkDocRegion },
2192         { &quot;doc-errata&quot;, AccessibilityRole::LandmarkDocRegion },
2193         { &quot;doc-example&quot;, AccessibilityRole::ApplicationTextGroup },
2194         { &quot;doc-footnote&quot;, AccessibilityRole::Footnote },
2195         { &quot;doc-foreword&quot;, AccessibilityRole::LandmarkDocRegion },
2196         { &quot;doc-glossary&quot;, AccessibilityRole::LandmarkDocRegion },
2197         { &quot;doc-glossref&quot;, AccessibilityRole::WebCoreLink },
2198         { &quot;doc-index&quot;, AccessibilityRole::LandmarkNavigation },
2199         { &quot;doc-introduction&quot;, AccessibilityRole::LandmarkDocRegion },
2200         { &quot;doc-noteref&quot;, AccessibilityRole::WebCoreLink },
2201         { &quot;doc-notice&quot;, AccessibilityRole::DocumentNote },
2202         { &quot;doc-pagebreak&quot;, AccessibilityRole::Splitter },
2203         { &quot;doc-pagelist&quot;, AccessibilityRole::LandmarkNavigation },
2204         { &quot;doc-part&quot;, AccessibilityRole::LandmarkDocRegion },
2205         { &quot;doc-preface&quot;, AccessibilityRole::LandmarkDocRegion },
2206         { &quot;doc-prologue&quot;, AccessibilityRole::LandmarkDocRegion },
2207         { &quot;doc-pullquote&quot;, AccessibilityRole::ApplicationTextGroup },
2208         { &quot;doc-qna&quot;, AccessibilityRole::ApplicationTextGroup },
2209         { &quot;doc-subtitle&quot;, AccessibilityRole::Heading },
2210         { &quot;doc-tip&quot;, AccessibilityRole::DocumentNote },
2211         { &quot;doc-toc&quot;, AccessibilityRole::LandmarkNavigation },
2212         { &quot;figure&quot;, AccessibilityRole::Figure },
2213         // The mappings for &#39;graphics-*&#39; roles are defined in this spec: https://w3c.github.io/graphics-aam/
2214         { &quot;graphics-document&quot;, AccessibilityRole::GraphicsDocument },
2215         { &quot;graphics-object&quot;, AccessibilityRole::GraphicsObject },
2216         { &quot;graphics-symbol&quot;, AccessibilityRole::GraphicsSymbol },
2217         { &quot;grid&quot;, AccessibilityRole::Grid },
2218         { &quot;gridcell&quot;, AccessibilityRole::GridCell },
2219         { &quot;table&quot;, AccessibilityRole::Table },
2220         { &quot;cell&quot;, AccessibilityRole::Cell },
2221         { &quot;columnheader&quot;, AccessibilityRole::ColumnHeader },
2222         { &quot;combobox&quot;, AccessibilityRole::ComboBox },
2223         { &quot;definition&quot;, AccessibilityRole::Definition },
2224         { &quot;document&quot;, AccessibilityRole::Document },
2225         { &quot;feed&quot;, AccessibilityRole::Feed },
2226         { &quot;form&quot;, AccessibilityRole::Form },
2227         { &quot;rowheader&quot;, AccessibilityRole::RowHeader },
2228         { &quot;group&quot;, AccessibilityRole::ApplicationGroup },
2229         { &quot;heading&quot;, AccessibilityRole::Heading },
2230         { &quot;img&quot;, AccessibilityRole::Image },
2231         { &quot;insertion&quot;, AccessibilityRole::Insertion },
2232         { &quot;link&quot;, AccessibilityRole::WebCoreLink },
2233         { &quot;list&quot;, AccessibilityRole::List },
2234         { &quot;listitem&quot;, AccessibilityRole::ListItem },
2235         { &quot;listbox&quot;, AccessibilityRole::ListBox },
2236         { &quot;log&quot;, AccessibilityRole::ApplicationLog },
2237         { &quot;main&quot;, AccessibilityRole::LandmarkMain },
2238         { &quot;marquee&quot;, AccessibilityRole::ApplicationMarquee },
2239         { &quot;math&quot;, AccessibilityRole::DocumentMath },
2240         { &quot;menu&quot;, AccessibilityRole::Menu },
2241         { &quot;menubar&quot;, AccessibilityRole::MenuBar },
2242         { &quot;menuitem&quot;, AccessibilityRole::MenuItem },
2243         { &quot;menuitemcheckbox&quot;, AccessibilityRole::MenuItemCheckbox },
2244         { &quot;menuitemradio&quot;, AccessibilityRole::MenuItemRadio },
2245         { &quot;meter&quot;, AccessibilityRole::Meter },
2246         { &quot;none&quot;, AccessibilityRole::Presentational },
2247         { &quot;note&quot;, AccessibilityRole::DocumentNote },
2248         { &quot;navigation&quot;, AccessibilityRole::LandmarkNavigation },
2249         { &quot;option&quot;, AccessibilityRole::ListBoxOption },
2250         { &quot;paragraph&quot;, AccessibilityRole::Paragraph },
2251         { &quot;presentation&quot;, AccessibilityRole::Presentational },
2252         { &quot;progressbar&quot;, AccessibilityRole::ProgressIndicator },
2253         { &quot;radio&quot;, AccessibilityRole::RadioButton },
2254         { &quot;radiogroup&quot;, AccessibilityRole::RadioGroup },
2255         { &quot;region&quot;, AccessibilityRole::LandmarkRegion },
2256         { &quot;row&quot;, AccessibilityRole::Row },
2257         { &quot;rowgroup&quot;, AccessibilityRole::RowGroup },
2258         { &quot;scrollbar&quot;, AccessibilityRole::ScrollBar },
2259         { &quot;search&quot;, AccessibilityRole::LandmarkSearch },
2260         { &quot;searchbox&quot;, AccessibilityRole::SearchField },
2261         { &quot;separator&quot;, AccessibilityRole::Splitter },
2262         { &quot;slider&quot;, AccessibilityRole::Slider },
2263         { &quot;spinbutton&quot;, AccessibilityRole::SpinButton },
2264         { &quot;status&quot;, AccessibilityRole::ApplicationStatus },
2265         { &quot;subscript&quot;, AccessibilityRole::Subscript },
2266         { &quot;superscript&quot;, AccessibilityRole::Superscript },
2267         { &quot;switch&quot;, AccessibilityRole::Switch },
2268         { &quot;tab&quot;, AccessibilityRole::Tab },
2269         { &quot;tablist&quot;, AccessibilityRole::TabList },
2270         { &quot;tabpanel&quot;, AccessibilityRole::TabPanel },
2271         { &quot;text&quot;, AccessibilityRole::StaticText },
2272         { &quot;textbox&quot;, AccessibilityRole::TextArea },
2273         { &quot;term&quot;, AccessibilityRole::Term },
2274         { &quot;time&quot;, AccessibilityRole::Time },
2275         { &quot;timer&quot;, AccessibilityRole::ApplicationTimer },
2276         { &quot;toolbar&quot;, AccessibilityRole::Toolbar },
2277         { &quot;tooltip&quot;, AccessibilityRole::UserInterfaceTooltip },
2278         { &quot;tree&quot;, AccessibilityRole::Tree },
2279         { &quot;treegrid&quot;, AccessibilityRole::TreeGrid },
2280         { &quot;treeitem&quot;, AccessibilityRole::TreeItem }
2281     };
2282 
2283     gAriaRoleMap = new ARIARoleMap;
2284     gAriaReverseRoleMap = new ARIAReverseRoleMap;
2285     size_t roleLength = WTF_ARRAY_LENGTH(roles);
2286     for (size_t i = 0; i &lt; roleLength; ++i) {
2287         gAriaRoleMap-&gt;set(roles[i].ariaRole, roles[i].webcoreRole);
2288         gAriaReverseRoleMap-&gt;set(static_cast&lt;int&gt;(roles[i].webcoreRole), roles[i].ariaRole);
2289     }
2290 }
2291 
2292 static ARIARoleMap&amp; ariaRoleMap()
2293 {
2294     initializeRoleMap();
2295     return *gAriaRoleMap;
2296 }
2297 
2298 static ARIAReverseRoleMap&amp; reverseAriaRoleMap()
2299 {
2300     initializeRoleMap();
2301     return *gAriaReverseRoleMap;
2302 }
2303 
2304 AccessibilityRole AccessibilityObject::ariaRoleToWebCoreRole(const String&amp; value)
2305 {
2306     if (value.isNull() || value.isEmpty())
2307         return AccessibilityRole::Unknown;
2308 
2309     for (auto roleName : StringView(value).split(&#39; &#39;)) {
2310         AccessibilityRole role = ariaRoleMap().get&lt;ASCIICaseInsensitiveStringViewHashTranslator&gt;(roleName);
2311         if (static_cast&lt;int&gt;(role))
2312             return role;
2313     }
2314     return AccessibilityRole::Unknown;
2315 }
2316 
2317 String AccessibilityObject::computedRoleString() const
2318 {
2319     // FIXME: Need a few special cases that aren&#39;t in the RoleMap: option, etc. http://webkit.org/b/128296
2320     AccessibilityRole role = roleValue();
2321 
2322     if (role == AccessibilityRole::Image &amp;&amp; accessibilityIsIgnored())
2323         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Presentational));
2324 
2325     // We do not compute a role string for generic block elements with user-agent assigned roles.
2326     if (role == AccessibilityRole::Group || role == AccessibilityRole::TextGroup)
2327         return &quot;&quot;;
2328 
2329     // We do compute a role string for block elements with author-provided roles.
2330     if (role == AccessibilityRole::ApplicationTextGroup
2331         || role == AccessibilityRole::Footnote
2332         || role == AccessibilityRole::GraphicsObject)
2333         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::ApplicationGroup));
2334 
2335     if (role == AccessibilityRole::GraphicsDocument)
2336         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Document));
2337 
2338     if (role == AccessibilityRole::GraphicsSymbol)
2339         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Image));
2340 
2341     if (role == AccessibilityRole::HorizontalRule)
2342         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Splitter));
2343 
2344     if (role == AccessibilityRole::PopUpButton || role == AccessibilityRole::ToggleButton)
2345         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Button));
2346 
2347     if (role == AccessibilityRole::LandmarkDocRegion)
2348         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::LandmarkRegion));
2349 
2350     return reverseAriaRoleMap().get(static_cast&lt;int&gt;(role));
2351 }
2352 
2353 bool AccessibilityObject::hasHighlighting() const
2354 {
2355     for (Node* node = this-&gt;node(); node; node = node-&gt;parentNode()) {
2356         if (node-&gt;hasTagName(markTag))
2357             return true;
2358     }
2359 
2360     return false;
2361 }
2362 
<a name="31" id="anc31"></a><span class="line-added">2363 #if !PLATFORM(MAC)</span>
<span class="line-added">2364 String AccessibilityObject::rolePlatformString() const</span>
<span class="line-added">2365 {</span>
<span class="line-added">2366     // FIXME: implement in other platforms.</span>
<span class="line-added">2367     return String();</span>
<span class="line-added">2368 }</span>
<span class="line-added">2369 </span>
<span class="line-added">2370 String AccessibilityObject::rolePlatformDescription() const</span>
<span class="line-added">2371 {</span>
<span class="line-added">2372     // FIXME: implement in other platforms.</span>
<span class="line-added">2373     return String();</span>
<span class="line-added">2374 }</span>
<span class="line-added">2375 #endif</span>
<span class="line-added">2376 </span>
<span class="line-added">2377 String AccessibilityObject::ariaLandmarkRoleDescription() const</span>
<span class="line-added">2378 {</span>
<span class="line-added">2379     switch (roleValue()) {</span>
<span class="line-added">2380     case AccessibilityRole::LandmarkBanner:</span>
<span class="line-added">2381         return AXARIAContentGroupText(&quot;ARIALandmarkBanner&quot;);</span>
<span class="line-added">2382     case AccessibilityRole::LandmarkComplementary:</span>
<span class="line-added">2383         return AXARIAContentGroupText(&quot;ARIALandmarkComplementary&quot;);</span>
<span class="line-added">2384     case AccessibilityRole::LandmarkContentInfo:</span>
<span class="line-added">2385         return AXARIAContentGroupText(&quot;ARIALandmarkContentInfo&quot;);</span>
<span class="line-added">2386     case AccessibilityRole::LandmarkMain:</span>
<span class="line-added">2387         return AXARIAContentGroupText(&quot;ARIALandmarkMain&quot;);</span>
<span class="line-added">2388     case AccessibilityRole::LandmarkNavigation:</span>
<span class="line-added">2389         return AXARIAContentGroupText(&quot;ARIALandmarkNavigation&quot;);</span>
<span class="line-added">2390     case AccessibilityRole::LandmarkDocRegion:</span>
<span class="line-added">2391     case AccessibilityRole::LandmarkRegion:</span>
<span class="line-added">2392         return AXARIAContentGroupText(&quot;ARIALandmarkRegion&quot;);</span>
<span class="line-added">2393     case AccessibilityRole::LandmarkSearch:</span>
<span class="line-added">2394         return AXARIAContentGroupText(&quot;ARIALandmarkSearch&quot;);</span>
<span class="line-added">2395     case AccessibilityRole::ApplicationAlert:</span>
<span class="line-added">2396         return AXARIAContentGroupText(&quot;ARIAApplicationAlert&quot;);</span>
<span class="line-added">2397     case AccessibilityRole::ApplicationAlertDialog:</span>
<span class="line-added">2398         return AXARIAContentGroupText(&quot;ARIAApplicationAlertDialog&quot;);</span>
<span class="line-added">2399     case AccessibilityRole::ApplicationDialog:</span>
<span class="line-added">2400         return AXARIAContentGroupText(&quot;ARIAApplicationDialog&quot;);</span>
<span class="line-added">2401     case AccessibilityRole::ApplicationLog:</span>
<span class="line-added">2402         return AXARIAContentGroupText(&quot;ARIAApplicationLog&quot;);</span>
<span class="line-added">2403     case AccessibilityRole::ApplicationMarquee:</span>
<span class="line-added">2404         return AXARIAContentGroupText(&quot;ARIAApplicationMarquee&quot;);</span>
<span class="line-added">2405     case AccessibilityRole::ApplicationStatus:</span>
<span class="line-added">2406         return AXARIAContentGroupText(&quot;ARIAApplicationStatus&quot;);</span>
<span class="line-added">2407     case AccessibilityRole::ApplicationTimer:</span>
<span class="line-added">2408         return AXARIAContentGroupText(&quot;ARIAApplicationTimer&quot;);</span>
<span class="line-added">2409     case AccessibilityRole::Document:</span>
<span class="line-added">2410         return AXARIAContentGroupText(&quot;ARIADocument&quot;);</span>
<span class="line-added">2411     case AccessibilityRole::DocumentArticle:</span>
<span class="line-added">2412         return AXARIAContentGroupText(&quot;ARIADocumentArticle&quot;);</span>
<span class="line-added">2413     case AccessibilityRole::DocumentMath:</span>
<span class="line-added">2414         return AXARIAContentGroupText(&quot;ARIADocumentMath&quot;);</span>
<span class="line-added">2415     case AccessibilityRole::DocumentNote:</span>
<span class="line-added">2416         return AXARIAContentGroupText(&quot;ARIADocumentNote&quot;);</span>
<span class="line-added">2417     case AccessibilityRole::UserInterfaceTooltip:</span>
<span class="line-added">2418         return AXARIAContentGroupText(&quot;ARIAUserInterfaceTooltip&quot;);</span>
<span class="line-added">2419     case AccessibilityRole::TabPanel:</span>
<span class="line-added">2420         return AXARIAContentGroupText(&quot;ARIATabPanel&quot;);</span>
<span class="line-added">2421     case AccessibilityRole::WebApplication:</span>
<span class="line-added">2422         return AXARIAContentGroupText(&quot;ARIAWebApplication&quot;);</span>
<span class="line-added">2423     default:</span>
<span class="line-added">2424         return String();</span>
<span class="line-added">2425     }</span>
<span class="line-added">2426 }</span>
<span class="line-added">2427 </span>
2428 String AccessibilityObject::roleDescription() const
2429 {
<a name="32" id="anc32"></a><span class="line-modified">2430     // aria-roledescription takes precedence over any other rule.</span>
<span class="line-added">2431     String roleDescription = stripLeadingAndTrailingHTMLSpaces(getAttribute(aria_roledescriptionAttr));</span>
<span class="line-added">2432     if (!roleDescription.isEmpty())</span>
<span class="line-added">2433         return roleDescription;</span>
<span class="line-added">2434 </span>
<span class="line-added">2435     roleDescription = rolePlatformDescription();</span>
<span class="line-added">2436     if (!roleDescription.isEmpty())</span>
<span class="line-added">2437         return roleDescription;</span>
<span class="line-added">2438 </span>
<span class="line-added">2439     if (roleValue() == AccessibilityRole::Figure)</span>
<span class="line-added">2440         return AXFigureText();</span>
<span class="line-added">2441 </span>
<span class="line-added">2442     return roleDescription;</span>
2443 }
2444 
2445 bool nodeHasPresentationRole(Node* node)
2446 {
2447     return nodeHasRole(node, &quot;presentation&quot;) || nodeHasRole(node, &quot;none&quot;);
2448 }
2449 
2450 bool AccessibilityObject::supportsPressAction() const
2451 {
2452     if (isButton())
2453         return true;
2454     if (roleValue() == AccessibilityRole::Details)
2455         return true;
2456 
2457     Element* actionElement = this-&gt;actionElement();
2458     if (!actionElement)
2459         return false;
2460 
2461     // [Bug: 136247] Heuristic: element handlers that have more than one accessible descendant should not be exposed as supporting press.
2462     if (actionElement != element()) {
2463         if (AccessibilityObject* axObj = axObjectCache()-&gt;getOrCreate(actionElement)) {
2464             AccessibilityChildrenVector results;
2465             // Search within for immediate descendants that are static text. If we find more than one
2466             // then this is an event delegator actionElement and we should expose the press action.
2467             Vector&lt;AccessibilitySearchKey&gt; keys({ AccessibilitySearchKey::StaticText, AccessibilitySearchKey::Control, AccessibilitySearchKey::Graphic, AccessibilitySearchKey::Heading, AccessibilitySearchKey::Link });
2468             AccessibilitySearchCriteria criteria(axObj, AccessibilitySearchDirection::Next, emptyString(), 2, false, false);
2469             criteria.searchKeys = keys;
2470             axObj-&gt;findMatchingObjects(&amp;criteria, results);
2471             if (results.size() &gt; 1)
2472                 return false;
2473         }
2474     }
2475 
2476     // [Bug: 133613] Heuristic: If the action element is presentational, we shouldn&#39;t expose press as a supported action.
2477     return !nodeHasPresentationRole(actionElement);
2478 }
2479 
2480 bool AccessibilityObject::supportsDatetimeAttribute() const
2481 {
2482     return hasTagName(insTag) || hasTagName(delTag) || hasTagName(timeTag);
2483 }
2484 
<a name="33" id="anc33"></a><span class="line-modified">2485 String AccessibilityObject::datetimeAttributeValue() const</span>
2486 {
2487     return getAttribute(datetimeAttr);
2488 }
2489 
<a name="34" id="anc34"></a><span class="line-modified">2490 String AccessibilityObject::linkRelValue() const</span>
2491 {
2492     return getAttribute(relAttr);
2493 }
2494 
<a name="35" id="anc35"></a><span class="line-added">2495 bool AccessibilityObject::isInlineText() const</span>
<span class="line-added">2496 {</span>
<span class="line-added">2497     return is&lt;RenderInline&gt;(renderer());</span>
<span class="line-added">2498 }</span>
<span class="line-added">2499 </span>
2500 const String AccessibilityObject::keyShortcutsValue() const
2501 {
2502     return getAttribute(aria_keyshortcutsAttr);
2503 }
2504 
2505 Element* AccessibilityObject::element() const
2506 {
2507     Node* node = this-&gt;node();
2508     if (is&lt;Element&gt;(node))
2509         return downcast&lt;Element&gt;(node);
2510     return nullptr;
2511 }
2512 
2513 bool AccessibilityObject::isValueAutofillAvailable() const
2514 {
2515     if (!isNativeTextControl())
2516         return false;
2517 
2518     Node* node = this-&gt;node();
2519     if (!is&lt;HTMLInputElement&gt;(node))
2520         return false;
2521 
2522     return downcast&lt;HTMLInputElement&gt;(*node).isAutoFillAvailable() || downcast&lt;HTMLInputElement&gt;(*node).autoFillButtonType() != AutoFillButtonType::None;
2523 }
2524 
2525 AutoFillButtonType AccessibilityObject::valueAutofillButtonType() const
2526 {
2527     if (!isValueAutofillAvailable())
2528         return AutoFillButtonType::None;
2529 
2530     return downcast&lt;HTMLInputElement&gt;(*this-&gt;node()).autoFillButtonType();
2531 }
2532 
2533 bool AccessibilityObject::isValueAutofilled() const
2534 {
2535     if (!isNativeTextControl())
2536         return false;
2537 
2538     Node* node = this-&gt;node();
2539     if (!is&lt;HTMLInputElement&gt;(node))
2540         return false;
2541 
2542     return downcast&lt;HTMLInputElement&gt;(*node).isAutoFilled();
2543 }
2544 
2545 const String AccessibilityObject::placeholderValue() const
2546 {
2547     const AtomString&amp; placeholder = getAttribute(placeholderAttr);
2548     if (!placeholder.isEmpty())
2549         return placeholder;
2550 
2551     const AtomString&amp; ariaPlaceholder = getAttribute(aria_placeholderAttr);
2552     if (!ariaPlaceholder.isEmpty())
2553         return ariaPlaceholder;
2554 
2555     return nullAtom();
2556 }
2557 
2558 bool AccessibilityObject::isInsideLiveRegion(bool excludeIfOff) const
2559 {
2560     return liveRegionAncestor(excludeIfOff);
2561 }
2562 
2563 AccessibilityObject* AccessibilityObject::liveRegionAncestor(bool excludeIfOff) const
2564 {
<a name="36" id="anc36"></a><span class="line-modified">2565     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [excludeIfOff] (const AccessibilityObject&amp; object) {</span>
2566         return object.supportsLiveRegion(excludeIfOff);
<a name="37" id="anc37"></a><span class="line-modified">2567     });</span>
2568 }
2569 
2570 bool AccessibilityObject::supportsARIAAttributes() const
2571 {
2572     // This returns whether the element supports any global ARIA attributes.
2573     return supportsLiveRegion()
2574         || supportsARIADragging()
2575         || supportsARIADropping()
2576         || supportsARIAOwns()
2577         || hasAttribute(aria_atomicAttr)
2578         || hasAttribute(aria_busyAttr)
2579         || hasAttribute(aria_controlsAttr)
2580         || hasAttribute(aria_currentAttr)
2581         || hasAttribute(aria_describedbyAttr)
2582         || hasAttribute(aria_detailsAttr)
2583         || hasAttribute(aria_disabledAttr)
2584         || hasAttribute(aria_errormessageAttr)
2585         || hasAttribute(aria_flowtoAttr)
2586         || hasAttribute(aria_haspopupAttr)
2587         || hasAttribute(aria_invalidAttr)
2588         || hasAttribute(aria_labelAttr)
2589         || hasAttribute(aria_labelledbyAttr)
2590         || hasAttribute(aria_relevantAttr);
2591 }
2592 
2593 bool AccessibilityObject::liveRegionStatusIsEnabled(const AtomString&amp; liveRegionStatus)
2594 {
2595     return equalLettersIgnoringASCIICase(liveRegionStatus, &quot;polite&quot;) || equalLettersIgnoringASCIICase(liveRegionStatus, &quot;assertive&quot;);
2596 }
2597 
2598 bool AccessibilityObject::supportsLiveRegion(bool excludeIfOff) const
2599 {
2600     const AtomString&amp; liveRegionStatusValue = liveRegionStatus();
2601     return excludeIfOff ? liveRegionStatusIsEnabled(liveRegionStatusValue) : !liveRegionStatusValue.isEmpty();
2602 }
2603 
<a name="38" id="anc38"></a><span class="line-modified">2604 AXCoreObject* AccessibilityObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
2605 {
2606     // Send the hit test back into the sub-frame if necessary.
2607     if (isAttachment()) {
2608         Widget* widget = widgetForAttachmentView();
2609         // Normalize the point for the widget&#39;s bounds.
2610         if (widget &amp;&amp; widget-&gt;isFrameView()) {
2611             if (AXObjectCache* cache = axObjectCache())
2612                 return cache-&gt;getOrCreate(widget)-&gt;accessibilityHitTest(IntPoint(point - widget-&gt;frameRect().location()));
2613         }
2614     }
2615 
2616     // Check if there are any mock elements that need to be handled.
2617     for (const auto&amp; child : m_children) {
2618         if (child-&gt;isMockObject() &amp;&amp; child-&gt;elementRect().contains(point))
2619             return child-&gt;elementAccessibilityHitTest(point);
2620     }
2621 
2622     return const_cast&lt;AccessibilityObject*&gt;(this);
2623 }
2624 
2625 AXObjectCache* AccessibilityObject::axObjectCache() const
2626 {
2627     auto* document = this-&gt;document();
2628     return document ? document-&gt;axObjectCache() : nullptr;
2629 }
2630 
<a name="39" id="anc39"></a><span class="line-modified">2631 AXCoreObject* AccessibilityObject::focusedUIElement() const</span>
2632 {
2633     auto* page = this-&gt;page();
<a name="40" id="anc40"></a><span class="line-modified">2634     auto* axObjectCache = this-&gt;axObjectCache();</span>
<span class="line-added">2635     return page &amp;&amp; axObjectCache ? axObjectCache-&gt;focusedUIElementForPage(page) : nullptr;</span>
2636 }
2637 
2638 AccessibilitySortDirection AccessibilityObject::sortDirection() const
2639 {
2640     AccessibilityRole role = roleValue();
2641     if (role != AccessibilityRole::RowHeader &amp;&amp; role != AccessibilityRole::ColumnHeader)
2642         return AccessibilitySortDirection::Invalid;
2643 
2644     const AtomString&amp; sortAttribute = getAttribute(aria_sortAttr);
2645     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;ascending&quot;))
2646         return AccessibilitySortDirection::Ascending;
2647     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;descending&quot;))
2648         return AccessibilitySortDirection::Descending;
2649     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;other&quot;))
2650         return AccessibilitySortDirection::Other;
2651 
2652     return AccessibilitySortDirection::None;
2653 }
2654 
2655 bool AccessibilityObject::supportsRangeValue() const
2656 {
2657     return isProgressIndicator()
2658         || isSlider()
2659         || isScrollbar()
2660         || isSpinButton()
2661         || (isSplitter() &amp;&amp; canSetFocusAttribute())
2662         || isAttachmentElement();
2663 }
2664 
2665 bool AccessibilityObject::supportsHasPopup() const
2666 {
2667     return hasAttribute(aria_haspopupAttr) || isComboBox();
2668 }
2669 
2670 String AccessibilityObject::popupValue() const
2671 {
2672     static const NeverDestroyed&lt;HashSet&lt;String&gt;&gt; allowedPopupValues(std::initializer_list&lt;String&gt; {
2673         &quot;menu&quot;, &quot;listbox&quot;, &quot;tree&quot;, &quot;grid&quot;, &quot;dialog&quot;
2674     });
2675 
2676     auto hasPopup = getAttribute(aria_haspopupAttr).convertToASCIILowercase();
2677     if (hasPopup.isNull() || hasPopup.isEmpty()) {
2678         // In ARIA 1.1, the implicit value for combobox became &quot;listbox.&quot;
2679         if (isComboBox() || hasDatalist())
2680             return &quot;listbox&quot;;
2681         return &quot;false&quot;;
2682     }
2683 
2684     if (allowedPopupValues-&gt;contains(hasPopup))
2685         return hasPopup;
2686 
2687     // aria-haspopup specification states that true must be treated as menu.
2688     if (hasPopup == &quot;true&quot;)
2689         return &quot;menu&quot;;
2690 
2691     // The spec states that &quot;User agents must treat any value of aria-haspopup that is not
2692     // included in the list of allowed values, including an empty string, as if the value
2693     // false had been provided.&quot;
2694     return &quot;false&quot;;
2695 }
2696 
2697 bool AccessibilityObject::hasDatalist() const
2698 {
2699 #if ENABLE(DATALIST_ELEMENT)
2700     auto datalistId = getAttribute(listAttr);
2701     if (datalistId.isNull() || datalistId.isEmpty())
2702         return false;
2703 
2704     auto element = this-&gt;element();
2705     if (!element)
2706         return false;
2707 
2708     auto datalist = element-&gt;treeScope().getElementById(datalistId);
2709     return is&lt;HTMLDataListElement&gt;(datalist);
2710 #else
2711     return false;
2712 #endif
2713 }
2714 
2715 bool AccessibilityObject::supportsSetSize() const
2716 {
2717     return hasAttribute(aria_setsizeAttr);
2718 }
2719 
2720 bool AccessibilityObject::supportsPosInSet() const
2721 {
2722     return hasAttribute(aria_posinsetAttr);
2723 }
2724 
2725 int AccessibilityObject::setSize() const
2726 {
2727     return getAttribute(aria_setsizeAttr).toInt();
2728 }
2729 
2730 int AccessibilityObject::posInSet() const
2731 {
2732     return getAttribute(aria_posinsetAttr).toInt();
2733 }
2734 
<a name="41" id="anc41"></a><span class="line-modified">2735 String AccessibilityObject::identifierAttribute() const</span>
2736 {
2737     return getAttribute(idAttr);
2738 }
2739 
2740 void AccessibilityObject::classList(Vector&lt;String&gt;&amp; classList) const
2741 {
2742     Node* node = this-&gt;node();
2743     if (!is&lt;Element&gt;(node))
2744         return;
2745 
2746     Element* element = downcast&lt;Element&gt;(node);
2747     DOMTokenList&amp; list = element-&gt;classList();
2748     unsigned length = list.length();
2749     for (unsigned k = 0; k &lt; length; k++)
2750         classList.append(list.item(k).string());
2751 }
2752 
2753 bool AccessibilityObject::supportsPressed() const
2754 {
2755     const AtomString&amp; expanded = getAttribute(aria_pressedAttr);
2756     return equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;);
2757 }
2758 
2759 bool AccessibilityObject::supportsExpanded() const
2760 {
2761     // Undefined values should not result in this attribute being exposed to ATs according to ARIA.
2762     const AtomString&amp; expanded = getAttribute(aria_expandedAttr);
2763     if (equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;))
2764         return true;
2765     switch (roleValue()) {
2766     case AccessibilityRole::ComboBox:
2767     case AccessibilityRole::DisclosureTriangle:
2768     case AccessibilityRole::Details:
2769         return true;
2770     default:
2771         return false;
2772     }
2773 }
2774 
2775 bool AccessibilityObject::isExpanded() const
2776 {
2777     if (equalLettersIgnoringASCIICase(getAttribute(aria_expandedAttr), &quot;true&quot;))
2778         return true;
2779 
2780     if (is&lt;HTMLDetailsElement&gt;(node()))
2781         return downcast&lt;HTMLDetailsElement&gt;(node())-&gt;isOpen();
2782 
2783     // Summary element should use its details parent&#39;s expanded status.
2784     if (isSummary()) {
<a name="42" id="anc42"></a><span class="line-modified">2785         if (const AccessibilityObject* parent = Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [] (const AccessibilityObject&amp; object) {</span>
2786             return is&lt;HTMLDetailsElement&gt;(object.node());
2787         }))
2788             return parent-&gt;isExpanded();
2789     }
2790 
2791     return false;
2792 }
2793 
2794 bool AccessibilityObject::supportsChecked() const
2795 {
2796     switch (roleValue()) {
2797     case AccessibilityRole::CheckBox:
2798     case AccessibilityRole::MenuItemCheckbox:
2799     case AccessibilityRole::MenuItemRadio:
2800     case AccessibilityRole::RadioButton:
2801     case AccessibilityRole::Switch:
2802         return true;
2803     default:
2804         return false;
2805     }
2806 }
2807 
2808 AccessibilityButtonState AccessibilityObject::checkboxOrRadioValue() const
2809 {
2810     // If this is a real checkbox or radio button, AccessibilityRenderObject will handle.
2811     // If it&#39;s an ARIA checkbox, radio, or switch the aria-checked attribute should be used.
2812     // If it&#39;s a toggle button, the aria-pressed attribute is consulted.
2813 
2814     if (isToggleButton()) {
2815         const AtomString&amp; ariaPressed = getAttribute(aria_pressedAttr);
2816         if (equalLettersIgnoringASCIICase(ariaPressed, &quot;true&quot;))
2817             return AccessibilityButtonState::On;
2818         if (equalLettersIgnoringASCIICase(ariaPressed, &quot;mixed&quot;))
2819             return AccessibilityButtonState::Mixed;
2820         return AccessibilityButtonState::Off;
2821     }
2822 
2823     const AtomString&amp; result = getAttribute(aria_checkedAttr);
2824     if (equalLettersIgnoringASCIICase(result, &quot;true&quot;))
2825         return AccessibilityButtonState::On;
2826     if (equalLettersIgnoringASCIICase(result, &quot;mixed&quot;)) {
2827         // ARIA says that radio, menuitemradio, and switch elements must NOT expose button state mixed.
2828         AccessibilityRole ariaRole = ariaRoleAttribute();
2829         if (ariaRole == AccessibilityRole::RadioButton || ariaRole == AccessibilityRole::MenuItemRadio || ariaRole == AccessibilityRole::Switch)
2830             return AccessibilityButtonState::Off;
2831         return AccessibilityButtonState::Mixed;
2832     }
2833 
2834     if (isIndeterminate())
2835         return AccessibilityButtonState::Mixed;
2836 
2837     return AccessibilityButtonState::Off;
2838 }
2839 
2840 // This is a 1-dimensional scroll offset helper function that&#39;s applied
2841 // separately in the horizontal and vertical directions, because the
2842 // logic is the same. The goal is to compute the best scroll offset
2843 // in order to make an object visible within a viewport.
2844 //
2845 // If the object is already fully visible, returns the same scroll
2846 // offset.
2847 //
2848 // In case the whole object cannot fit, you can specify a
2849 // subfocus - a smaller region within the object that should
2850 // be prioritized. If the whole object can fit, the subfocus is
2851 // ignored.
2852 //
2853 // If possible, the object and subfocus are centered within the
2854 // viewport.
2855 //
2856 // Example 1: the object is already visible, so nothing happens.
2857 //   +----------Viewport---------+
2858 //                 +---Object---+
2859 //                 +--SubFocus--+
2860 //
2861 // Example 2: the object is not fully visible, so it&#39;s centered
2862 // within the viewport.
2863 //   Before:
2864 //   +----------Viewport---------+
2865 //                         +---Object---+
2866 //                         +--SubFocus--+
2867 //
2868 //   After:
2869 //                 +----------Viewport---------+
2870 //                         +---Object---+
2871 //                         +--SubFocus--+
2872 //
2873 // Example 3: the object is larger than the viewport, so the
2874 // viewport moves to show as much of the object as possible,
2875 // while also trying to center the subfocus.
2876 //   Before:
2877 //   +----------Viewport---------+
2878 //     +---------------Object--------------+
2879 //                         +-SubFocus-+
2880 //
2881 //   After:
2882 //             +----------Viewport---------+
2883 //     +---------------Object--------------+
2884 //                         +-SubFocus-+
2885 //
2886 // When constraints cannot be fully satisfied, the min
2887 // (left/top) position takes precedence over the max (right/bottom).
2888 //
2889 // Note that the return value represents the ideal new scroll offset.
2890 // This may be out of range - the calling function should clip this
2891 // to the available range.
2892 static int computeBestScrollOffset(int currentScrollOffset, int subfocusMin, int subfocusMax, int objectMin, int objectMax, int viewportMin, int viewportMax)
2893 {
2894     int viewportSize = viewportMax - viewportMin;
2895 
2896     // If the object size is larger than the viewport size, consider
2897     // only a portion that&#39;s as large as the viewport, centering on
2898     // the subfocus as much as possible.
2899     if (objectMax - objectMin &gt; viewportSize) {
2900         // Since it&#39;s impossible to fit the whole object in the
2901         // viewport, exit now if the subfocus is already within the viewport.
2902         if (subfocusMin - currentScrollOffset &gt;= viewportMin &amp;&amp; subfocusMax - currentScrollOffset &lt;= viewportMax)
2903             return currentScrollOffset;
2904 
2905         // Subfocus must be within focus.
2906         subfocusMin = std::max(subfocusMin, objectMin);
2907         subfocusMax = std::min(subfocusMax, objectMax);
2908 
2909         // Subfocus must be no larger than the viewport size; favor top/left.
2910         if (subfocusMax - subfocusMin &gt; viewportSize)
2911             subfocusMax = subfocusMin + viewportSize;
2912 
2913         // Compute the size of an object centered on the subfocus, the size of the viewport.
2914         int centeredObjectMin = (subfocusMin + subfocusMax - viewportSize) / 2;
2915         int centeredObjectMax = centeredObjectMin + viewportSize;
2916 
2917         objectMin = std::max(objectMin, centeredObjectMin);
2918         objectMax = std::min(objectMax, centeredObjectMax);
2919     }
2920 
2921     // Exit now if the focus is already within the viewport.
2922     if (objectMin - currentScrollOffset &gt;= viewportMin
2923         &amp;&amp; objectMax - currentScrollOffset &lt;= viewportMax)
2924         return currentScrollOffset;
2925 
2926     // Center the object in the viewport.
2927     return (objectMin + objectMax - viewportMin - viewportMax) / 2;
2928 }
2929 
<a name="43" id="anc43"></a><span class="line-modified">2930 bool AccessibilityObject::isOnScreen() const</span>
2931 {
2932     bool isOnscreen = true;
2933 
2934     // To figure out if the element is onscreen, we start by building of a stack starting with the
2935     // element, and then include every scrollable parent in the hierarchy.
2936     Vector&lt;const AccessibilityObject*&gt; objects;
2937 
2938     objects.append(this);
2939     for (AccessibilityObject* parentObject = this-&gt;parentObject(); parentObject; parentObject = parentObject-&gt;parentObject()) {
2940         if (parentObject-&gt;getScrollableAreaIfScrollable())
2941             objects.append(parentObject);
2942     }
2943 
2944     // Now, go back through that chain and make sure each inner object is within the
2945     // visible bounds of the outer object.
2946     size_t levels = objects.size() - 1;
2947 
2948     for (size_t i = levels; i &gt;= 1; i--) {
2949         const AccessibilityObject* outer = objects[i];
2950         const AccessibilityObject* inner = objects[i - 1];
2951         // FIXME: unclear if we need LegacyIOSDocumentVisibleRect.
2952         const IntRect outerRect = i &lt; levels ? snappedIntRect(outer-&gt;boundingBoxRect()) : outer-&gt;getScrollableAreaIfScrollable()-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
2953         const IntRect innerRect = snappedIntRect(inner-&gt;isAccessibilityScrollView() ? inner-&gt;parentObject()-&gt;boundingBoxRect() : inner-&gt;boundingBoxRect());
2954 
2955         if (!outerRect.intersects(innerRect)) {
2956             isOnscreen = false;
2957             break;
2958         }
2959     }
2960 
2961     return isOnscreen;
2962 }
2963 
2964 void AccessibilityObject::scrollToMakeVisible() const
2965 {
2966     scrollToMakeVisible({ SelectionRevealMode::Reveal, ScrollAlignment::alignCenterIfNeeded, ScrollAlignment::alignCenterIfNeeded, ShouldAllowCrossOriginScrolling::Yes });
2967 }
2968 
2969 void AccessibilityObject::scrollToMakeVisible(const ScrollRectToVisibleOptions&amp; options) const
2970 {
2971     if (isScrollView() &amp;&amp; parentObject())
2972         parentObject()-&gt;scrollToMakeVisible();
2973 
2974     if (auto* renderer = this-&gt;renderer())
2975         renderer-&gt;scrollRectToVisible(boundingBoxRect(), false, options);
2976 }
2977 
2978 void AccessibilityObject::scrollToMakeVisibleWithSubFocus(const IntRect&amp; subfocus) const
2979 {
2980     // Search up the parent chain until we find the first one that&#39;s scrollable.
2981     AccessibilityObject* scrollParent = parentObject();
2982     ScrollableArea* scrollableArea;
2983     for (scrollableArea = nullptr;
2984          scrollParent &amp;&amp; !(scrollableArea = scrollParent-&gt;getScrollableAreaIfScrollable());
2985          scrollParent = scrollParent-&gt;parentObject()) { }
2986     if (!scrollableArea)
2987         return;
2988 
2989     LayoutRect objectRect = boundingBoxRect();
2990     IntPoint scrollPosition = scrollableArea-&gt;scrollPosition();
2991     // FIXME: unclear if we need LegacyIOSDocumentVisibleRect.
2992     IntRect scrollVisibleRect = scrollableArea-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
2993 
2994     if (!scrollParent-&gt;isScrollView()) {
2995         objectRect.moveBy(scrollPosition);
2996         objectRect.moveBy(-snappedIntRect(scrollParent-&gt;elementRect()).location());
2997     }
2998 
2999     int desiredX = computeBestScrollOffset(
3000         scrollPosition.x(),
3001         objectRect.x() + subfocus.x(), objectRect.x() + subfocus.maxX(),
3002         objectRect.x(), objectRect.maxX(),
3003         0, scrollVisibleRect.width());
3004     int desiredY = computeBestScrollOffset(
3005         scrollPosition.y(),
3006         objectRect.y() + subfocus.y(), objectRect.y() + subfocus.maxY(),
3007         objectRect.y(), objectRect.maxY(),
3008         0, scrollVisibleRect.height());
3009 
3010     scrollParent-&gt;scrollTo(IntPoint(desiredX, desiredY));
3011 
3012     // Convert the subfocus into the coordinates of the scroll parent.
3013     IntRect newSubfocus = subfocus;
3014     IntRect newElementRect = snappedIntRect(elementRect());
3015     IntRect scrollParentRect = snappedIntRect(scrollParent-&gt;elementRect());
3016     newSubfocus.move(newElementRect.x(), newElementRect.y());
3017     newSubfocus.move(-scrollParentRect.x(), -scrollParentRect.y());
3018 
3019     // Recursively make sure the scroll parent itself is visible.
3020     if (scrollParent-&gt;parentObject())
3021         scrollParent-&gt;scrollToMakeVisibleWithSubFocus(newSubfocus);
3022 }
3023 
3024 void AccessibilityObject::scrollToGlobalPoint(const IntPoint&amp; globalPoint) const
3025 {
3026     // Search up the parent chain and create a vector of all scrollable parent objects
3027     // and ending with this object itself.
3028     Vector&lt;const AccessibilityObject*&gt; objects;
3029 
3030     objects.append(this);
3031     for (AccessibilityObject* parentObject = this-&gt;parentObject(); parentObject; parentObject = parentObject-&gt;parentObject()) {
3032         if (parentObject-&gt;getScrollableAreaIfScrollable())
3033             objects.append(parentObject);
3034     }
3035 
3036     objects.reverse();
3037 
3038     // Start with the outermost scrollable (the main window) and try to scroll the
3039     // next innermost object to the given point.
3040     int offsetX = 0, offsetY = 0;
3041     IntPoint point = globalPoint;
3042     size_t levels = objects.size() - 1;
3043     for (size_t i = 0; i &lt; levels; i++) {
3044         const AccessibilityObject* outer = objects[i];
3045         const AccessibilityObject* inner = objects[i + 1];
3046 
3047         ScrollableArea* scrollableArea = outer-&gt;getScrollableAreaIfScrollable();
3048 
3049         LayoutRect innerRect = inner-&gt;isAccessibilityScrollView() ? inner-&gt;parentObject()-&gt;boundingBoxRect() : inner-&gt;boundingBoxRect();
3050         LayoutRect objectRect = innerRect;
3051         IntPoint scrollPosition = scrollableArea-&gt;scrollPosition();
3052 
3053         // Convert the object rect into local coordinates.
3054         objectRect.move(offsetX, offsetY);
3055         if (!outer-&gt;isAccessibilityScrollView())
3056             objectRect.move(scrollPosition.x(), scrollPosition.y());
3057 
3058         int desiredX = computeBestScrollOffset(
3059             0,
3060             objectRect.x(), objectRect.maxX(),
3061             objectRect.x(), objectRect.maxX(),
3062             point.x(), point.x());
3063         int desiredY = computeBestScrollOffset(
3064             0,
3065             objectRect.y(), objectRect.maxY(),
3066             objectRect.y(), objectRect.maxY(),
3067             point.y(), point.y());
3068         outer-&gt;scrollTo(IntPoint(desiredX, desiredY));
3069 
3070         if (outer-&gt;isAccessibilityScrollView() &amp;&amp; !inner-&gt;isAccessibilityScrollView()) {
3071             // If outer object we just scrolled is a scroll view (main window or iframe) but the
3072             // inner object is not, keep track of the coordinate transformation to apply to
3073             // future nested calculations.
3074             scrollPosition = scrollableArea-&gt;scrollPosition();
3075             offsetX -= (scrollPosition.x() + point.x());
3076             offsetY -= (scrollPosition.y() + point.y());
3077             point.move(scrollPosition.x() - innerRect.x(),
3078                        scrollPosition.y() - innerRect.y());
3079         } else if (inner-&gt;isAccessibilityScrollView()) {
3080             // Otherwise, if the inner object is a scroll view, reset the coordinate transformation.
3081             offsetX = 0;
3082             offsetY = 0;
3083         }
3084     }
3085 }
3086 
3087 void AccessibilityObject::scrollAreaAndAncestor(std::pair&lt;ScrollableArea*, AccessibilityObject*&gt;&amp; scrollers) const
3088 {
3089     // Search up the parent chain until we find the first one that&#39;s scrollable.
3090     scrollers.first = nullptr;
3091     for (scrollers.second = parentObject(); scrollers.second; scrollers.second = scrollers.second-&gt;parentObject()) {
3092         if ((scrollers.first = scrollers.second-&gt;getScrollableAreaIfScrollable()))
3093             break;
3094     }
3095 }
3096 
3097 ScrollableArea* AccessibilityObject::scrollableAreaAncestor() const
3098 {
3099     std::pair&lt;ScrollableArea*, AccessibilityObject*&gt; scrollers;
3100     scrollAreaAndAncestor(scrollers);
3101     return scrollers.first;
3102 }
3103 
3104 IntPoint AccessibilityObject::scrollPosition() const
3105 {
3106     if (auto scroller = scrollableAreaAncestor())
3107         return scroller-&gt;scrollPosition();
3108 
3109     return IntPoint();
3110 }
3111 
3112 IntRect AccessibilityObject::scrollVisibleContentRect() const
3113 {
3114     if (auto scroller = scrollableAreaAncestor())
3115         return scroller-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
3116 
3117     return IntRect();
3118 }
3119 
3120 IntSize AccessibilityObject::scrollContentsSize() const
3121 {
3122     if (auto scroller = scrollableAreaAncestor())
3123         return scroller-&gt;contentsSize();
3124 
3125     return IntSize();
3126 }
3127 
3128 bool AccessibilityObject::scrollByPage(ScrollByPageDirection direction) const
3129 {
3130     std::pair&lt;ScrollableArea*, AccessibilityObject*&gt; scrollers;
3131     scrollAreaAndAncestor(scrollers);
3132     ScrollableArea* scrollableArea = scrollers.first;
3133     AccessibilityObject* scrollParent = scrollers.second;
3134 
3135     if (!scrollableArea)
3136         return false;
3137 
3138     IntPoint scrollPosition = scrollableArea-&gt;scrollPosition();
3139     IntPoint newScrollPosition = scrollPosition;
3140     IntSize scrollSize = scrollableArea-&gt;contentsSize();
3141     IntRect scrollVisibleRect = scrollableArea-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
3142     switch (direction) {
3143     case ScrollByPageDirection::Right: {
3144         int scrollAmount = scrollVisibleRect.size().width();
3145         int newX = scrollPosition.x() - scrollAmount;
3146         newScrollPosition.setX(std::max(newX, 0));
3147         break;
3148     }
3149     case ScrollByPageDirection::Left: {
3150         int scrollAmount = scrollVisibleRect.size().width();
3151         int newX = scrollAmount + scrollPosition.x();
3152         int maxX = scrollSize.width() - scrollAmount;
3153         newScrollPosition.setX(std::min(newX, maxX));
3154         break;
3155     }
3156     case ScrollByPageDirection::Up: {
3157         int scrollAmount = scrollVisibleRect.size().height();
3158         int newY = scrollPosition.y() - scrollAmount;
3159         newScrollPosition.setY(std::max(newY, 0));
3160         break;
3161     }
3162     case ScrollByPageDirection::Down: {
3163         int scrollAmount = scrollVisibleRect.size().height();
3164         int newY = scrollAmount + scrollPosition.y();
3165         int maxY = scrollSize.height() - scrollAmount;
3166         newScrollPosition.setY(std::min(newY, maxY));
3167         break;
3168     }
3169     }
3170 
3171     if (newScrollPosition != scrollPosition) {
3172         scrollParent-&gt;scrollTo(newScrollPosition);
3173         document()-&gt;updateLayoutIgnorePendingStylesheets();
3174         return true;
3175     }
3176 
3177     return false;
3178 }
3179 
3180 
3181 bool AccessibilityObject::lastKnownIsIgnoredValue()
3182 {
3183     if (m_lastKnownIsIgnoredValue == AccessibilityObjectInclusion::DefaultBehavior)
3184         m_lastKnownIsIgnoredValue = accessibilityIsIgnored() ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject;
3185 
3186     return m_lastKnownIsIgnoredValue == AccessibilityObjectInclusion::IgnoreObject;
3187 }
3188 
3189 void AccessibilityObject::setLastKnownIsIgnoredValue(bool isIgnored)
3190 {
3191     m_lastKnownIsIgnoredValue = isIgnored ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject;
3192 }
3193 
3194 void AccessibilityObject::notifyIfIgnoredValueChanged()
3195 {
3196     bool isIgnored = accessibilityIsIgnored();
3197     if (lastKnownIsIgnoredValue() != isIgnored) {
3198         if (AXObjectCache* cache = axObjectCache())
3199             cache-&gt;childrenChanged(parentObject());
3200         setLastKnownIsIgnoredValue(isIgnored);
3201     }
3202 }
3203 
3204 bool AccessibilityObject::pressedIsPresent() const
3205 {
3206     return !getAttribute(aria_pressedAttr).isEmpty();
3207 }
3208 
3209 TextIteratorBehavior AccessibilityObject::textIteratorBehaviorForTextRange() const
3210 {
3211     TextIteratorBehavior behavior = TextIteratorIgnoresStyleVisibility;
3212 
3213 #if USE(ATK)
3214     // We need to emit replaced elements for GTK, and present
3215     // them with the &#39;object replacement character&#39; (0xFFFC).
3216     behavior = static_cast&lt;TextIteratorBehavior&gt;(behavior | TextIteratorEmitsObjectReplacementCharacters);
3217 #endif
3218 
3219     return behavior;
3220 }
3221 
3222 AccessibilityRole AccessibilityObject::buttonRoleType() const
3223 {
3224     // If aria-pressed is present, then it should be exposed as a toggle button.
3225     // http://www.w3.org/TR/wai-aria/states_and_properties#aria-pressed
3226     if (pressedIsPresent())
3227         return AccessibilityRole::ToggleButton;
3228     if (hasPopup())
3229         return AccessibilityRole::PopUpButton;
3230     // We don&#39;t contemplate AccessibilityRole::RadioButton, as it depends on the input
3231     // type.
3232 
3233     return AccessibilityRole::Button;
3234 }
3235 
3236 bool AccessibilityObject::isButton() const
3237 {
3238     AccessibilityRole role = roleValue();
3239 
3240     return role == AccessibilityRole::Button || role == AccessibilityRole::PopUpButton || role == AccessibilityRole::ToggleButton;
3241 }
3242 
3243 bool AccessibilityObject::accessibilityIsIgnoredByDefault() const
3244 {
3245     return defaultObjectInclusion() == AccessibilityObjectInclusion::IgnoreObject;
3246 }
3247 
3248 // ARIA component of hidden definition.
3249 // http://www.w3.org/TR/wai-aria/terms#def_hidden
3250 bool AccessibilityObject::isAXHidden() const
3251 {
<a name="44" id="anc44"></a><span class="line-modified">3252     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [] (const AccessibilityObject&amp; object) {</span>
3253         return equalLettersIgnoringASCIICase(object.getAttribute(aria_hiddenAttr), &quot;true&quot;);
3254     }) != nullptr;
3255 }
3256 
3257 // DOM component of hidden definition.
3258 // http://www.w3.org/TR/wai-aria/terms#def_hidden
3259 bool AccessibilityObject::isDOMHidden() const
3260 {
3261     RenderObject* renderer = this-&gt;renderer();
3262     if (!renderer)
3263         return true;
3264 
3265     const RenderStyle&amp; style = renderer-&gt;style();
3266     return style.display() == DisplayType::None || style.visibility() != Visibility::Visible;
3267 }
3268 
3269 bool AccessibilityObject::isShowingValidationMessage() const
3270 {
3271     if (is&lt;HTMLFormControlElement&gt;(node()))
3272         return downcast&lt;HTMLFormControlElement&gt;(*node()).isShowingValidationMessage();
3273     return false;
3274 }
3275 
3276 String AccessibilityObject::validationMessage() const
3277 {
3278     if (is&lt;HTMLFormControlElement&gt;(node()))
3279         return downcast&lt;HTMLFormControlElement&gt;(*node()).validationMessage();
3280     return String();
3281 }
3282 
3283 AccessibilityObjectInclusion AccessibilityObject::defaultObjectInclusion() const
3284 {
3285     bool useParentData = !m_isIgnoredFromParentData.isNull();
3286 
3287     if (useParentData ? m_isIgnoredFromParentData.isAXHidden : isAXHidden())
3288         return AccessibilityObjectInclusion::IgnoreObject;
3289 
3290     if (ignoredFromModalPresence())
3291         return AccessibilityObjectInclusion::IgnoreObject;
3292 
3293     if (useParentData ? m_isIgnoredFromParentData.isPresentationalChildOfAriaRole : isPresentationalChildOfAriaRole())
3294         return AccessibilityObjectInclusion::IgnoreObject;
3295 
3296     return accessibilityPlatformIncludesObject();
3297 }
3298 
3299 bool AccessibilityObject::accessibilityIsIgnored() const
3300 {
3301     AXComputedObjectAttributeCache* attributeCache = nullptr;
3302     AXObjectCache* cache = axObjectCache();
3303     if (cache)
3304         attributeCache = cache-&gt;computedObjectAttributeCache();
3305 
3306     if (attributeCache) {
<a name="45" id="anc45"></a><span class="line-modified">3307         AccessibilityObjectInclusion ignored = attributeCache-&gt;getIgnored(objectID());</span>
3308         switch (ignored) {
3309         case AccessibilityObjectInclusion::IgnoreObject:
3310             return true;
3311         case AccessibilityObjectInclusion::IncludeObject:
3312             return false;
3313         case AccessibilityObjectInclusion::DefaultBehavior:
3314             break;
3315         }
3316     }
3317 
3318     bool result = computeAccessibilityIsIgnored();
3319 
3320     // In case computing axIsIgnored disables attribute caching, we should refetch the object to see if it exists.
3321     if (cache &amp;&amp; (attributeCache = cache-&gt;computedObjectAttributeCache()))
<a name="46" id="anc46"></a><span class="line-modified">3322         attributeCache-&gt;setIgnored(objectID(), result ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject);</span>
3323 
3324     return result;
3325 }
3326 
3327 void AccessibilityObject::elementsFromAttribute(Vector&lt;Element*&gt;&amp; elements, const QualifiedName&amp; attribute) const
3328 {
3329     Node* node = this-&gt;node();
3330     if (!node || !node-&gt;isElementNode())
3331         return;
3332 
3333     TreeScope&amp; treeScope = node-&gt;treeScope();
3334 
3335     const AtomString&amp; idList = getAttribute(attribute);
3336     if (idList.isEmpty())
3337         return;
3338 
3339     auto spaceSplitString = SpaceSplitString(idList, false);
3340     size_t length = spaceSplitString.size();
3341     for (size_t i = 0; i &lt; length; ++i) {
3342         if (auto* idElement = treeScope.getElementById(spaceSplitString[i]))
3343             elements.append(idElement);
3344     }
3345 }
3346 
3347 #if PLATFORM(COCOA)
3348 bool AccessibilityObject::preventKeyboardDOMEventDispatch() const
3349 {
3350     Frame* frame = this-&gt;frame();
3351     return frame &amp;&amp; frame-&gt;settings().preventKeyboardDOMEventDispatch();
3352 }
3353 
3354 void AccessibilityObject::setPreventKeyboardDOMEventDispatch(bool on)
3355 {
3356     Frame* frame = this-&gt;frame();
3357     if (!frame)
3358         return;
3359     frame-&gt;settings().setPreventKeyboardDOMEventDispatch(on);
3360 }
3361 #endif
3362 
3363 AccessibilityObject* AccessibilityObject::focusableAncestor()
3364 {
<a name="47" id="anc47"></a><span class="line-modified">3365     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [] (const AccessibilityObject&amp; object) {</span>
3366         return object.canSetFocusAttribute();
<a name="48" id="anc48"></a><span class="line-modified">3367     });</span>
3368 }
3369 
3370 AccessibilityObject* AccessibilityObject::editableAncestor()
3371 {
<a name="49" id="anc49"></a><span class="line-modified">3372     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [] (const AccessibilityObject&amp; object) {</span>
3373         return object.isTextControl();
<a name="50" id="anc50"></a><span class="line-modified">3374     });</span>
3375 }
3376 
3377 AccessibilityObject* AccessibilityObject::highestEditableAncestor()
3378 {
3379     AccessibilityObject* editableAncestor = this-&gt;editableAncestor();
3380     AccessibilityObject* previousEditableAncestor = nullptr;
3381     while (editableAncestor) {
3382         if (editableAncestor == previousEditableAncestor) {
3383             if (AccessibilityObject* parent = editableAncestor-&gt;parentObject()) {
3384                 editableAncestor = parent-&gt;editableAncestor();
3385                 continue;
3386             }
3387             break;
3388         }
3389         previousEditableAncestor = editableAncestor;
3390         editableAncestor = editableAncestor-&gt;editableAncestor();
3391     }
3392     return previousEditableAncestor;
3393 }
3394 
3395 AccessibilityObject* AccessibilityObject::radioGroupAncestor() const
3396 {
<a name="51" id="anc51"></a><span class="line-modified">3397     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, [] (const AccessibilityObject&amp; object) {</span>
3398         return object.isRadioGroup();
<a name="52" id="anc52"></a><span class="line-modified">3399     });</span>
<span class="line-added">3400 }</span>
<span class="line-added">3401 </span>
<span class="line-added">3402 String AccessibilityObject::documentURI() const</span>
<span class="line-added">3403 {</span>
<span class="line-added">3404     if (auto* document = this-&gt;document())</span>
<span class="line-added">3405         return document-&gt;documentURI();</span>
<span class="line-added">3406     return String();</span>
<span class="line-added">3407 }</span>
<span class="line-added">3408 </span>
<span class="line-added">3409 String AccessibilityObject::documentEncoding() const</span>
<span class="line-added">3410 {</span>
<span class="line-added">3411     if (auto* document = this-&gt;document())</span>
<span class="line-added">3412         return document-&gt;encoding();</span>
<span class="line-added">3413     return String();</span>
<span class="line-added">3414 }</span>
<span class="line-added">3415 </span>
<span class="line-added">3416 uint64_t AccessibilityObject::sessionID() const</span>
<span class="line-added">3417 {</span>
<span class="line-added">3418     if (auto* document = topDocument()) {</span>
<span class="line-added">3419         if (auto* page = document-&gt;page())</span>
<span class="line-added">3420             return page-&gt;sessionID().toUInt64();</span>
<span class="line-added">3421     }</span>
<span class="line-added">3422     return 0;</span>
<span class="line-added">3423 }</span>
<span class="line-added">3424 </span>
<span class="line-added">3425 String AccessibilityObject::tagName() const</span>
<span class="line-added">3426 {</span>
<span class="line-added">3427     if (Element* element = this-&gt;element())</span>
<span class="line-added">3428         return element-&gt;localName();</span>
<span class="line-added">3429 </span>
<span class="line-added">3430     return String();</span>
3431 }
3432 
3433 bool AccessibilityObject::isStyleFormatGroup() const
3434 {
3435     Node* node = this-&gt;node();
3436     if (!node)
3437         return false;
3438 
3439     return node-&gt;hasTagName(kbdTag) || node-&gt;hasTagName(codeTag)
3440     || node-&gt;hasTagName(preTag) || node-&gt;hasTagName(sampTag)
3441     || node-&gt;hasTagName(varTag) || node-&gt;hasTagName(citeTag)
3442     || node-&gt;hasTagName(insTag) || node-&gt;hasTagName(delTag)
3443     || node-&gt;hasTagName(supTag) || node-&gt;hasTagName(subTag);
3444 }
3445 
3446 bool AccessibilityObject::isFigureElement() const
3447 {
3448     Node* node = this-&gt;node();
3449     return node &amp;&amp; node-&gt;hasTagName(figureTag);
3450 }
3451 
3452 bool AccessibilityObject::isKeyboardFocusable() const
3453 {
3454     if (auto element = this-&gt;element())
3455         return element-&gt;isFocusable();
3456     return false;
3457 }
3458 
3459 bool AccessibilityObject::isOutput() const
3460 {
3461     Node* node = this-&gt;node();
3462     return node &amp;&amp; node-&gt;hasTagName(outputTag);
3463 }
3464 
3465 bool AccessibilityObject::isContainedByPasswordField() const
3466 {
3467     Node* node = this-&gt;node();
3468     if (!node)
3469         return false;
3470 
3471     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
3472         return false;
3473 
3474     Element* element = node-&gt;shadowHost();
3475     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*element).isPasswordField();
3476 }
3477 
<a name="53" id="anc53"></a><span class="line-modified">3478 AXCoreObject* AccessibilityObject::selectedListItem()</span>
3479 {
3480     for (const auto&amp; child : children()) {
3481         if (child-&gt;isListItem() &amp;&amp; (child-&gt;isSelected() || child-&gt;isActiveDescendantOfFocusedContainer()))
3482             return child.get();
3483     }
3484 
3485     return nullptr;
3486 }
3487 
3488 void AccessibilityObject::ariaElementsFromAttribute(AccessibilityChildrenVector&amp; children, const QualifiedName&amp; attributeName) const
3489 {
3490     Vector&lt;Element*&gt; elements;
3491     elementsFromAttribute(elements, attributeName);
3492     AXObjectCache* cache = axObjectCache();
3493     for (const auto&amp; element : elements) {
3494         if (AccessibilityObject* axObject = cache-&gt;getOrCreate(element))
3495             children.append(axObject);
3496     }
3497 }
3498 
3499 void AccessibilityObject::ariaElementsReferencedByAttribute(AccessibilityChildrenVector&amp; elements, const QualifiedName&amp; attribute) const
3500 {
3501     auto id = identifierAttribute();
3502     if (id.isEmpty())
3503         return;
3504 
3505     AXObjectCache* cache = axObjectCache();
3506     if (!cache)
3507         return;
3508 
3509     for (auto&amp; element : descendantsOfType&lt;Element&gt;(node()-&gt;treeScope().rootNode())) {
3510         const AtomString&amp; idList = element.attributeWithoutSynchronization(attribute);
3511         if (!SpaceSplitString(idList, false).contains(id))
3512             continue;
3513 
3514         if (AccessibilityObject* axObject = cache-&gt;getOrCreate(&amp;element))
3515             elements.append(axObject);
3516     }
3517 }
3518 
3519 bool AccessibilityObject::isActiveDescendantOfFocusedContainer() const
3520 {
3521     AccessibilityChildrenVector containers;
3522     ariaActiveDescendantReferencingElements(containers);
3523     for (auto&amp; container : containers) {
3524         if (container-&gt;isFocused())
3525             return true;
3526     }
3527 
3528     return false;
3529 }
3530 
3531 void AccessibilityObject::ariaActiveDescendantReferencingElements(AccessibilityChildrenVector&amp; containers) const
3532 {
3533     ariaElementsReferencedByAttribute(containers, aria_activedescendantAttr);
3534 }
3535 
3536 void AccessibilityObject::ariaControlsElements(AccessibilityChildrenVector&amp; ariaControls) const
3537 {
3538     ariaElementsFromAttribute(ariaControls, aria_controlsAttr);
3539 }
3540 
3541 void AccessibilityObject::ariaControlsReferencingElements(AccessibilityChildrenVector&amp; controllers) const
3542 {
3543     ariaElementsReferencedByAttribute(controllers, aria_controlsAttr);
3544 }
3545 
3546 void AccessibilityObject::ariaDescribedByElements(AccessibilityChildrenVector&amp; ariaDescribedBy) const
3547 {
3548     ariaElementsFromAttribute(ariaDescribedBy, aria_describedbyAttr);
3549 }
3550 
3551 void AccessibilityObject::ariaDescribedByReferencingElements(AccessibilityChildrenVector&amp; describers) const
3552 {
3553     ariaElementsReferencedByAttribute(describers, aria_describedbyAttr);
3554 }
3555 
3556 void AccessibilityObject::ariaDetailsElements(AccessibilityChildrenVector&amp; ariaDetails) const
3557 {
3558     ariaElementsFromAttribute(ariaDetails, aria_detailsAttr);
3559 }
3560 
3561 void AccessibilityObject::ariaDetailsReferencingElements(AccessibilityChildrenVector&amp; detailsFor) const
3562 {
3563     ariaElementsReferencedByAttribute(detailsFor, aria_detailsAttr);
3564 }
3565 
3566 void AccessibilityObject::ariaErrorMessageElements(AccessibilityChildrenVector&amp; ariaErrorMessage) const
3567 {
3568     ariaElementsFromAttribute(ariaErrorMessage, aria_errormessageAttr);
3569 }
3570 
3571 void AccessibilityObject::ariaErrorMessageReferencingElements(AccessibilityChildrenVector&amp; errorMessageFor) const
3572 {
3573     ariaElementsReferencedByAttribute(errorMessageFor, aria_errormessageAttr);
3574 }
3575 
3576 void AccessibilityObject::ariaFlowToElements(AccessibilityChildrenVector&amp; flowTo) const
3577 {
3578     ariaElementsFromAttribute(flowTo, aria_flowtoAttr);
3579 }
3580 
3581 void AccessibilityObject::ariaFlowToReferencingElements(AccessibilityChildrenVector&amp; flowFrom) const
3582 {
3583     ariaElementsReferencedByAttribute(flowFrom, aria_flowtoAttr);
3584 }
3585 
3586 void AccessibilityObject::ariaLabelledByElements(AccessibilityChildrenVector&amp; ariaLabelledBy) const
3587 {
3588     ariaElementsFromAttribute(ariaLabelledBy, aria_labelledbyAttr);
3589     if (!ariaLabelledBy.size())
3590         ariaElementsFromAttribute(ariaLabelledBy, aria_labeledbyAttr);
3591 }
3592 
3593 void AccessibilityObject::ariaLabelledByReferencingElements(AccessibilityChildrenVector&amp; labels) const
3594 {
3595     ariaElementsReferencedByAttribute(labels, aria_labelledbyAttr);
3596     if (!labels.size())
3597         ariaElementsReferencedByAttribute(labels, aria_labeledbyAttr);
3598 }
3599 
3600 void AccessibilityObject::ariaOwnsElements(AccessibilityChildrenVector&amp; axObjects) const
3601 {
3602     ariaElementsFromAttribute(axObjects, aria_ownsAttr);
3603 }
3604 
3605 void AccessibilityObject::ariaOwnsReferencingElements(AccessibilityChildrenVector&amp; owners) const
3606 {
3607     ariaElementsReferencedByAttribute(owners, aria_ownsAttr);
3608 }
3609 
<a name="54" id="anc54"></a><span class="line-modified">3610 void AccessibilityObject::setIsIgnoredFromParentDataForChild(AXCoreObject* child)</span>
3611 {
3612     if (!child)
3613         return;
3614 
3615     if (child-&gt;parentObject() != this) {
3616         child-&gt;clearIsIgnoredFromParentData();
3617         return;
3618     }
3619 
3620     AccessibilityIsIgnoredFromParentData result = AccessibilityIsIgnoredFromParentData(this);
3621     if (!m_isIgnoredFromParentData.isNull()) {
3622         result.isAXHidden = m_isIgnoredFromParentData.isAXHidden || equalLettersIgnoringASCIICase(child-&gt;getAttribute(aria_hiddenAttr), &quot;true&quot;);
3623         result.isPresentationalChildOfAriaRole = m_isIgnoredFromParentData.isPresentationalChildOfAriaRole || ariaRoleHasPresentationalChildren();
3624         result.isDescendantOfBarrenParent = m_isIgnoredFromParentData.isDescendantOfBarrenParent || !canHaveChildren();
3625     } else {
3626         result.isAXHidden = child-&gt;isAXHidden();
3627         result.isPresentationalChildOfAriaRole = child-&gt;isPresentationalChildOfAriaRole();
3628         result.isDescendantOfBarrenParent = child-&gt;isDescendantOfBarrenParent();
3629     }
3630 
3631     child-&gt;setIsIgnoredFromParentData(result);
3632 }
3633 
<a name="55" id="anc55"></a><span class="line-added">3634 namespace Accessibility {</span>
<span class="line-added">3635 </span>
<span class="line-added">3636 #if !PLATFORM(MAC)</span>
<span class="line-added">3637 // FIXME: implement in other platforms.</span>
<span class="line-added">3638 PlatformRoleMap createPlatformRoleMap() { return PlatformRoleMap(); }</span>
<span class="line-added">3639 #endif</span>
<span class="line-added">3640 </span>
<span class="line-added">3641 String roleToPlatformString(AccessibilityRole role)</span>
<span class="line-added">3642 {</span>
<span class="line-added">3643     static NeverDestroyed&lt;PlatformRoleMap&gt; roleMap = createPlatformRoleMap();</span>
<span class="line-added">3644     return roleMap-&gt;get(static_cast&lt;unsigned&gt;(role));</span>
<span class="line-added">3645 }</span>
<span class="line-added">3646 </span>
<span class="line-added">3647 static bool isAccessibilityObjectSearchMatchAtIndex(AXCoreObject* axObject, AccessibilitySearchCriteria const&amp; criteria, size_t index)</span>
<span class="line-added">3648 {</span>
<span class="line-added">3649     switch (criteria.searchKeys[index]) {</span>
<span class="line-added">3650     case AccessibilitySearchKey::AnyType:</span>
<span class="line-added">3651         // The AccessibilitySearchKey::AnyType matches any non-null AccessibilityObject.</span>
<span class="line-added">3652         return true;</span>
<span class="line-added">3653     case AccessibilitySearchKey::Article:</span>
<span class="line-added">3654         return axObject-&gt;roleValue() == AccessibilityRole::DocumentArticle;</span>
<span class="line-added">3655     case AccessibilitySearchKey::BlockquoteSameLevel:</span>
<span class="line-added">3656         return criteria.startObject</span>
<span class="line-added">3657             &amp;&amp; axObject-&gt;isBlockquote()</span>
<span class="line-added">3658             &amp;&amp; axObject-&gt;blockquoteLevel() == criteria.startObject-&gt;blockquoteLevel();</span>
<span class="line-added">3659     case AccessibilitySearchKey::Blockquote:</span>
<span class="line-added">3660         return axObject-&gt;isBlockquote();</span>
<span class="line-added">3661     case AccessibilitySearchKey::BoldFont:</span>
<span class="line-added">3662         return axObject-&gt;hasBoldFont();</span>
<span class="line-added">3663     case AccessibilitySearchKey::Button:</span>
<span class="line-added">3664         return axObject-&gt;isButton();</span>
<span class="line-added">3665     case AccessibilitySearchKey::CheckBox:</span>
<span class="line-added">3666         return axObject-&gt;isCheckbox();</span>
<span class="line-added">3667     case AccessibilitySearchKey::Control:</span>
<span class="line-added">3668         return axObject-&gt;isControl();</span>
<span class="line-added">3669     case AccessibilitySearchKey::DifferentType:</span>
<span class="line-added">3670         return criteria.startObject</span>
<span class="line-added">3671             &amp;&amp; axObject-&gt;roleValue() != criteria.startObject-&gt;roleValue();</span>
<span class="line-added">3672     case AccessibilitySearchKey::FontChange:</span>
<span class="line-added">3673         return criteria.startObject</span>
<span class="line-added">3674             &amp;&amp; !axObject-&gt;hasSameFont(criteria.startObject-&gt;renderer());</span>
<span class="line-added">3675     case AccessibilitySearchKey::FontColorChange:</span>
<span class="line-added">3676         return criteria.startObject</span>
<span class="line-added">3677             &amp;&amp; !axObject-&gt;hasSameFontColor(criteria.startObject-&gt;renderer());</span>
<span class="line-added">3678     case AccessibilitySearchKey::Frame:</span>
<span class="line-added">3679         return axObject-&gt;isWebArea();</span>
<span class="line-added">3680     case AccessibilitySearchKey::Graphic:</span>
<span class="line-added">3681         return axObject-&gt;isImage();</span>
<span class="line-added">3682     case AccessibilitySearchKey::HeadingLevel1:</span>
<span class="line-added">3683         return axObject-&gt;headingLevel() == 1;</span>
<span class="line-added">3684     case AccessibilitySearchKey::HeadingLevel2:</span>
<span class="line-added">3685         return axObject-&gt;headingLevel() == 2;</span>
<span class="line-added">3686     case AccessibilitySearchKey::HeadingLevel3:</span>
<span class="line-added">3687         return axObject-&gt;headingLevel() == 3;</span>
<span class="line-added">3688     case AccessibilitySearchKey::HeadingLevel4:</span>
<span class="line-added">3689         return axObject-&gt;headingLevel() == 4;</span>
<span class="line-added">3690     case AccessibilitySearchKey::HeadingLevel5:</span>
<span class="line-added">3691         return axObject-&gt;headingLevel() == 5;</span>
<span class="line-added">3692     case AccessibilitySearchKey::HeadingLevel6:</span>
<span class="line-added">3693         return axObject-&gt;headingLevel() == 6;</span>
<span class="line-added">3694     case AccessibilitySearchKey::HeadingSameLevel:</span>
<span class="line-added">3695         return criteria.startObject</span>
<span class="line-added">3696             &amp;&amp; axObject-&gt;isHeading()</span>
<span class="line-added">3697             &amp;&amp; axObject-&gt;headingLevel() == criteria.startObject-&gt;headingLevel();</span>
<span class="line-added">3698     case AccessibilitySearchKey::Heading:</span>
<span class="line-added">3699         return axObject-&gt;isHeading();</span>
<span class="line-added">3700     case AccessibilitySearchKey::Highlighted:</span>
<span class="line-added">3701         return axObject-&gt;hasHighlighting();</span>
<span class="line-added">3702     case AccessibilitySearchKey::KeyboardFocusable:</span>
<span class="line-added">3703         return axObject-&gt;isKeyboardFocusable();</span>
<span class="line-added">3704     case AccessibilitySearchKey::ItalicFont:</span>
<span class="line-added">3705         return axObject-&gt;hasItalicFont();</span>
<span class="line-added">3706     case AccessibilitySearchKey::Landmark:</span>
<span class="line-added">3707         return axObject-&gt;isLandmark();</span>
<span class="line-added">3708     case AccessibilitySearchKey::Link: {</span>
<span class="line-added">3709         bool isLink = axObject-&gt;isLink();</span>
<span class="line-added">3710 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">3711         if (!isLink)</span>
<span class="line-added">3712             isLink = axObject-&gt;isDescendantOfRole(AccessibilityRole::WebCoreLink);</span>
<span class="line-added">3713 #endif</span>
<span class="line-added">3714         return isLink;</span>
<span class="line-added">3715     }</span>
<span class="line-added">3716     case AccessibilitySearchKey::List:</span>
<span class="line-added">3717         return axObject-&gt;isList();</span>
<span class="line-added">3718     case AccessibilitySearchKey::LiveRegion:</span>
<span class="line-added">3719         return axObject-&gt;supportsLiveRegion();</span>
<span class="line-added">3720     case AccessibilitySearchKey::MisspelledWord:</span>
<span class="line-added">3721         return axObject-&gt;hasMisspelling();</span>
<span class="line-added">3722     case AccessibilitySearchKey::Outline:</span>
<span class="line-added">3723         return axObject-&gt;isTree();</span>
<span class="line-added">3724     case AccessibilitySearchKey::PlainText:</span>
<span class="line-added">3725         return axObject-&gt;hasPlainText();</span>
<span class="line-added">3726     case AccessibilitySearchKey::RadioGroup:</span>
<span class="line-added">3727         return axObject-&gt;isRadioGroup();</span>
<span class="line-added">3728     case AccessibilitySearchKey::SameType:</span>
<span class="line-added">3729         return criteria.startObject</span>
<span class="line-added">3730             &amp;&amp; axObject-&gt;roleValue() == criteria.startObject-&gt;roleValue();</span>
<span class="line-added">3731     case AccessibilitySearchKey::StaticText:</span>
<span class="line-added">3732         return axObject-&gt;isStaticText();</span>
<span class="line-added">3733     case AccessibilitySearchKey::StyleChange:</span>
<span class="line-added">3734         return criteria.startObject</span>
<span class="line-added">3735             &amp;&amp; !axObject-&gt;hasSameStyle(criteria.startObject-&gt;renderer());</span>
<span class="line-added">3736     case AccessibilitySearchKey::TableSameLevel:</span>
<span class="line-added">3737         return criteria.startObject</span>
<span class="line-added">3738             &amp;&amp; is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility()</span>
<span class="line-added">3739             &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).tableLevel() == criteria.startObject-&gt;tableLevel();</span>
<span class="line-added">3740     case AccessibilitySearchKey::Table:</span>
<span class="line-added">3741         return is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility();</span>
<span class="line-added">3742     case AccessibilitySearchKey::TextField:</span>
<span class="line-added">3743         return axObject-&gt;isTextControl();</span>
<span class="line-added">3744     case AccessibilitySearchKey::Underline:</span>
<span class="line-added">3745         return axObject-&gt;hasUnderline();</span>
<span class="line-added">3746     case AccessibilitySearchKey::UnvisitedLink:</span>
<span class="line-added">3747         return axObject-&gt;isUnvisited();</span>
<span class="line-added">3748     case AccessibilitySearchKey::VisitedLink:</span>
<span class="line-added">3749         return axObject-&gt;isVisited();</span>
<span class="line-added">3750     default:</span>
<span class="line-added">3751         return false;</span>
<span class="line-added">3752     }</span>
<span class="line-added">3753 }</span>
<span class="line-added">3754 </span>
<span class="line-added">3755 static bool isAccessibilityObjectSearchMatch(AXCoreObject* axObject, AccessibilitySearchCriteria const&amp; criteria)</span>
<span class="line-added">3756 {</span>
<span class="line-added">3757     if (!axObject)</span>
<span class="line-added">3758         return false;</span>
<span class="line-added">3759 </span>
<span class="line-added">3760     size_t length = criteria.searchKeys.size();</span>
<span class="line-added">3761     for (size_t i = 0; i &lt; length; ++i) {</span>
<span class="line-added">3762         if (isAccessibilityObjectSearchMatchAtIndex(axObject, criteria, i)) {</span>
<span class="line-added">3763             if (criteria.visibleOnly &amp;&amp; !axObject-&gt;isOnScreen())</span>
<span class="line-added">3764                 return false;</span>
<span class="line-added">3765             return true;</span>
<span class="line-added">3766         }</span>
<span class="line-added">3767     }</span>
<span class="line-added">3768     return false;</span>
<span class="line-added">3769 }</span>
<span class="line-added">3770 </span>
<span class="line-added">3771 static bool isAccessibilityTextSearchMatch(AXCoreObject* axObject, AccessibilitySearchCriteria const&amp; criteria)</span>
<span class="line-added">3772 {</span>
<span class="line-added">3773     if (!axObject)</span>
<span class="line-added">3774         return false;</span>
<span class="line-added">3775     return axObject-&gt;containsText(criteria.searchText);</span>
<span class="line-added">3776 }</span>
<span class="line-added">3777 </span>
<span class="line-added">3778 static bool objectMatchesSearchCriteriaWithResultLimit(AXCoreObject* object, AccessibilitySearchCriteria const&amp; criteria, AXCoreObject::AccessibilityChildrenVector&amp; results)</span>
<span class="line-added">3779 {</span>
<span class="line-added">3780     if (isAccessibilityObjectSearchMatch(object, criteria) &amp;&amp; isAccessibilityTextSearchMatch(object, criteria)) {</span>
<span class="line-added">3781         results.append(object);</span>
<span class="line-added">3782 </span>
<span class="line-added">3783         // Enough results were found to stop searching.</span>
<span class="line-added">3784         if (results.size() &gt;= criteria.resultsLimit)</span>
<span class="line-added">3785             return true;</span>
<span class="line-added">3786     }</span>
<span class="line-added">3787 </span>
<span class="line-added">3788     return false;</span>
<span class="line-added">3789 }</span>
<span class="line-added">3790 </span>
<span class="line-added">3791 void findMatchingObjects(AccessibilitySearchCriteria const&amp; criteria, AXCoreObject::AccessibilityChildrenVector&amp; results)</span>
<span class="line-added">3792 {</span>
<span class="line-added">3793     // This search algorithm only searches the elements before/after the starting object.</span>
<span class="line-added">3794     // It does this by stepping up the parent chain and at each level doing a DFS.</span>
<span class="line-added">3795 </span>
<span class="line-added">3796     // If there&#39;s no start object, it means we want to search everything.</span>
<span class="line-added">3797     AXCoreObject* startObject = criteria.startObject;</span>
<span class="line-added">3798     if (!startObject)</span>
<span class="line-added">3799         startObject = criteria.anchorObject;</span>
<span class="line-added">3800 </span>
<span class="line-added">3801     bool isForward = criteria.searchDirection == AccessibilitySearchDirection::Next;</span>
<span class="line-added">3802 </span>
<span class="line-added">3803     // The first iteration of the outer loop will examine the children of the start object for matches. However, when</span>
<span class="line-added">3804     // iterating backwards, the start object children should not be considered, so the loop is skipped ahead. We make an</span>
<span class="line-added">3805     // exception when no start object was specified because we want to search everything regardless of search direction.</span>
<span class="line-added">3806     AXCoreObject* previousObject = nullptr;</span>
<span class="line-added">3807     if (!isForward &amp;&amp; startObject != criteria.anchorObject) {</span>
<span class="line-added">3808         previousObject = startObject;</span>
<span class="line-added">3809         startObject = startObject-&gt;parentObjectUnignored();</span>
<span class="line-added">3810     }</span>
<span class="line-added">3811 </span>
<span class="line-added">3812     // The outer loop steps up the parent chain each time (unignored is important here because otherwise elements would be searched twice)</span>
<span class="line-added">3813     for (auto* stopSearchElement = criteria.anchorObject-&gt;parentObjectUnignored(); startObject &amp;&amp; startObject != stopSearchElement; startObject = startObject-&gt;parentObjectUnignored()) {</span>
<span class="line-added">3814         // Only append the children after/before the previous element, so that the search does not check elements that are</span>
<span class="line-added">3815         // already behind/ahead of start element.</span>
<span class="line-added">3816         AXCoreObject::AccessibilityChildrenVector searchStack;</span>
<span class="line-added">3817         if (!criteria.immediateDescendantsOnly || startObject == criteria.anchorObject)</span>
<span class="line-added">3818             appendChildrenToArray(startObject, isForward, previousObject, searchStack);</span>
<span class="line-added">3819 </span>
<span class="line-added">3820         // This now does a DFS at the current level of the parent.</span>
<span class="line-added">3821         while (!searchStack.isEmpty()) {</span>
<span class="line-added">3822             AXCoreObject* searchObject = searchStack.last().get();</span>
<span class="line-added">3823             searchStack.removeLast();</span>
<span class="line-added">3824 </span>
<span class="line-added">3825             if (objectMatchesSearchCriteriaWithResultLimit(searchObject, criteria, results))</span>
<span class="line-added">3826                 break;</span>
<span class="line-added">3827 </span>
<span class="line-added">3828             if (!criteria.immediateDescendantsOnly)</span>
<span class="line-added">3829                 appendChildrenToArray(searchObject, isForward, 0, searchStack);</span>
<span class="line-added">3830         }</span>
<span class="line-added">3831 </span>
<span class="line-added">3832         if (results.size() &gt;= criteria.resultsLimit)</span>
<span class="line-added">3833             break;</span>
<span class="line-added">3834 </span>
<span class="line-added">3835         // When moving backwards, the parent object needs to be checked, because technically it&#39;s &quot;before&quot; the starting element.</span>
<span class="line-added">3836         if (!isForward &amp;&amp; startObject != criteria.anchorObject &amp;&amp; objectMatchesSearchCriteriaWithResultLimit(startObject, criteria, results))</span>
<span class="line-added">3837             break;</span>
<span class="line-added">3838 </span>
<span class="line-added">3839         previousObject = startObject;</span>
<span class="line-added">3840     }</span>
<span class="line-added">3841 }</span>
<span class="line-added">3842 </span>
<span class="line-added">3843 } // namespace Accessibility</span>
<span class="line-added">3844 </span>
3845 } // namespace WebCore
<a name="56" id="anc56"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="56" type="hidden" />
</body>
</html>
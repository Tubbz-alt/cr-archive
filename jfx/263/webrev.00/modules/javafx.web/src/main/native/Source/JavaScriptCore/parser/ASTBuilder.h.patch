diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ASTBuilder.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ASTBuilder.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ASTBuilder.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ASTBuilder.h
@@ -120,15 +120,15 @@
     typedef DestructuringPatternNode* DestructuringPattern;
     typedef ArrayPatternNode* ArrayPattern;
     typedef ObjectPatternNode* ObjectPattern;
     typedef BindingNode* BindingPattern;
     typedef AssignmentElementNode* AssignmentElement;
-    static const bool CreatesAST = true;
-    static const bool NeedsFreeVariableInfo = true;
-    static const bool CanUseFunctionCache = true;
-    static const int  DontBuildKeywords = 0;
-    static const int  DontBuildStrings = 0;
+    static constexpr bool CreatesAST = true;
+    static constexpr bool NeedsFreeVariableInfo = true;
+    static constexpr bool CanUseFunctionCache = true;
+    static constexpr OptionSet<LexerFlags> DontBuildKeywords = { };
+    static constexpr OptionSet<LexerFlags> DontBuildStrings = { };
 
     ExpressionNode* makeBinaryNode(const JSTokenLocation&, int token, std::pair<ExpressionNode*, BinaryOpInfo>, std::pair<ExpressionNode*, BinaryOpInfo>);
     ExpressionNode* makeFunctionCallNode(const JSTokenLocation&, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition& divotStart, const JSTextPosition& divot, const JSTextPosition& divotEnd, size_t callOrApplyChildDepth, bool isOptionalCall);
 
     JSC::SourceElements* createSourceElements() { return new (m_parserArena) JSC::SourceElements(); }
@@ -198,12 +198,13 @@
     {
         if (m_vm.propertyNames->arguments == ident)
             usesArguments();
 
         if (ident.isSymbol()) {
-            if (BytecodeIntrinsicNode::EmitterType emitter = m_vm.bytecodeIntrinsicRegistry().lookup(ident))
-                return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Constant, location, emitter, ident, nullptr, start, start, end);
+            auto entry = m_vm.bytecodeIntrinsicRegistry().lookup(ident);
+            if (entry)
+                return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Constant, location, entry.value(), ident, nullptr, start, start, end);
         }
 
         return new (m_parserArena) ResolveNode(location, ident, start);
     }
     ExpressionNode* createObjectLiteral(const JSTokenLocation& location) { return new (m_parserArena) ObjectLiteralNode(location); }
@@ -402,10 +403,15 @@
         AwaitExprNode* node = new (m_parserArena) AwaitExprNode(location, argument);
         setExceptionLocation(node, start, divot, end);
         return node;
     }
 
+    DefineFieldNode* createDefineField(const JSTokenLocation& location, const Identifier* ident, ExpressionNode* initializer, DefineFieldNode::Type type)
+    {
+        return new (m_parserArena) DefineFieldNode(location, ident, initializer, type);
+    }
+
     ClassExprNode* createClassExpr(const JSTokenLocation& location, const ParserClassInfo<ASTBuilder>& classInfo, VariableEnvironment& classEnvironment, ExpressionNode* constructor,
         ExpressionNode* parentClass, PropertyListNode* classElements)
     {
         SourceCode source = m_sourceCode->subExpression(classInfo.startOffset, classInfo.endOffset, classInfo.startLine, classInfo.startColumn);
         return new (m_parserArena) ClassExprNode(location, *classInfo.className, source, classEnvironment, constructor, parentClass, classElements);
@@ -524,10 +530,11 @@
     PropertyNode* createProperty(VM& vm, ParserArena& parserArena, double propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)
     {
         return new (m_parserArena) PropertyNode(parserArena.identifierArena().makeNumericIdentifier(vm, propertyName), node, type, putType, superBinding, tag);
     }
     PropertyNode* createProperty(ExpressionNode* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag) { return new (m_parserArena) PropertyNode(propertyName, node, type, putType, superBinding, tag); }
+    PropertyNode* createProperty(const Identifier* identifier, ExpressionNode* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag) { return new (m_parserArena) PropertyNode(*identifier, propertyName, node, type, putType, superBinding, tag); }
     PropertyListNode* createPropertyList(const JSTokenLocation& location, PropertyNode* property) { return new (m_parserArena) PropertyListNode(location, property); }
     PropertyListNode* createPropertyList(const JSTokenLocation& location, PropertyNode* property, PropertyListNode* tail) { return new (m_parserArena) PropertyListNode(location, property, tail); }
 
     ElementNode* createElementList(int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elisions, expr); }
     ElementNode* createElementList(ElementNode* elems, int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elems, elisions, expr); }
@@ -918,10 +925,20 @@
     {
         tokenStackDepth--;
         m_unaryTokenStack.removeLast();
     }
 
+    int unaryTokenStackDepth() const
+    {
+        return m_unaryTokenStack.size();
+    }
+
+    void setUnaryTokenStackDepth(int oldDepth)
+    {
+        m_unaryTokenStack.shrink(oldDepth);
+    }
+
     void assignmentStackAppend(int& assignmentStackDepth, ExpressionNode* node, const JSTextPosition& start, const JSTextPosition& divot, int assignmentCount, Operator op)
     {
         assignmentStackDepth++;
         ASSERT(start.offset >= start.lineStartOffset);
         ASSERT(divot.offset >= divot.lineStartOffset);
@@ -1382,12 +1399,12 @@
         usesSuperCall();
 
     if (func->isBytecodeIntrinsicNode()) {
         ASSERT(!isOptionalCall);
         BytecodeIntrinsicNode* intrinsic = static_cast<BytecodeIntrinsicNode*>(func);
-        if (intrinsic->type() == BytecodeIntrinsicNode::Type::Constant)
-            return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Function, location, intrinsic->emitter(), intrinsic->identifier(), args, divot, divotStart, divotEnd);
+        if (intrinsic->type() == BytecodeIntrinsicNode::Type::Constant && intrinsic->entry().type() == BytecodeIntrinsicRegistry::Type::Emitter)
+            return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Function, location, intrinsic->entry(), intrinsic->identifier(), args, divot, divotStart, divotEnd);
     }
 
     if (func->isOptionalChain()) {
         OptionalChainNode* optionalChain = static_cast<OptionalChainNode*>(func);
         if (optionalChain->expr()->isLocation()) {

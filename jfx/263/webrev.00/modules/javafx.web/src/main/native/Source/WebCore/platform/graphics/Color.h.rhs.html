<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2003-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ColorSpace.h&quot;
 29 #include &quot;ExtendedColor.h&quot;
 30 #include &lt;algorithm&gt;
 31 #include &lt;cmath&gt;
 32 #include &lt;unicode/uchar.h&gt;
 33 #include &lt;wtf/Forward.h&gt;
 34 #include &lt;wtf/HashFunctions.h&gt;
 35 #include &lt;wtf/Optional.h&gt;
 36 #include &lt;wtf/text/LChar.h&gt;
 37 
 38 #if USE(CG)
 39 typedef struct CGColor* CGColorRef;
 40 #endif
 41 
 42 #if PLATFORM(WIN)
 43 struct _D3DCOLORVALUE;
 44 typedef _D3DCOLORVALUE D3DCOLORVALUE;
 45 typedef D3DCOLORVALUE D2D_COLOR_F;
 46 typedef D2D_COLOR_F D2D1_COLOR_F;
 47 struct D2D_VECTOR_4F;
 48 typedef D2D_VECTOR_4F D2D1_VECTOR_4F;
 49 #endif
 50 
 51 #if PLATFORM(GTK)
 52 typedef struct _GdkRGBA GdkRGBA;
 53 #endif
 54 
<a name="2" id="anc2"></a>



 55 namespace WebCore {
 56 
<a name="3" id="anc3"></a><span class="line-modified"> 57 // Color value with 8-bit components for red, green, blue, and alpha.</span>
<span class="line-added"> 58 // For historical reasons, stored as a 32-bit integer, with alpha in the high bits: ARGB.</span>
<span class="line-added"> 59 class SimpleColor {</span>
<span class="line-added"> 60 public:</span>
<span class="line-added"> 61     constexpr SimpleColor(uint32_t value = 0) : m_value { value } { }</span>
<span class="line-added"> 62 </span>
<span class="line-added"> 63     constexpr uint32_t value() const { return m_value; }</span>
<span class="line-added"> 64 </span>
<span class="line-added"> 65     constexpr uint8_t redComponent() const { return m_value &gt;&gt; 16; }</span>
<span class="line-added"> 66     constexpr uint8_t greenComponent() const { return m_value &gt;&gt; 8; }</span>
<span class="line-added"> 67     constexpr uint8_t blueComponent() const { return m_value; }</span>
<span class="line-added"> 68     constexpr uint8_t alphaComponent() const { return m_value &gt;&gt; 24; }</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70     constexpr bool isOpaque() const { return alphaComponent() == 0xFF; }</span>
<span class="line-added"> 71     constexpr bool isVisible() const { return alphaComponent(); }</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73     String serializationForHTML() const;</span>
<span class="line-added"> 74     String serializationForCSS() const;</span>
<span class="line-added"> 75     String serializationForRenderTreeAsText() const;</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77 private:</span>
<span class="line-added"> 78     uint32_t m_value { 0 };</span>
<span class="line-added"> 79 };</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81 bool operator==(SimpleColor, SimpleColor);</span>
<span class="line-added"> 82 bool operator!=(SimpleColor, SimpleColor);</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 // FIXME: Remove this after migrating to the new name.</span>
<span class="line-added"> 85 using RGBA32 = SimpleColor;</span>
 86 
 87 WEBCORE_EXPORT RGBA32 makeRGB(int r, int g, int b);
 88 WEBCORE_EXPORT RGBA32 makeRGBA(int r, int g, int b, int a);
 89 
 90 RGBA32 makePremultipliedRGBA(int r, int g, int b, int a, bool ceiling = true);
 91 RGBA32 makeUnPremultipliedRGBA(int r, int g, int b, int a);
 92 
 93 WEBCORE_EXPORT RGBA32 colorWithOverrideAlpha(RGBA32 color, float overrideAlpha);
 94 RGBA32 colorWithOverrideAlpha(RGBA32 color, Optional&lt;float&gt; overrideAlpha);
 95 
 96 WEBCORE_EXPORT RGBA32 makeRGBA32FromFloats(float r, float g, float b, float a);
<a name="4" id="anc4"></a><span class="line-modified"> 97 RGBA32 makeRGBAFromHSLA(float h, float s, float l, float a);</span>
 98 RGBA32 makeRGBAFromCMYKA(float c, float m, float y, float k, float a);
 99 
<a name="5" id="anc5"></a>




100 uint8_t roundAndClampColorChannel(int);
101 uint8_t roundAndClampColorChannel(float);
102 
<a name="6" id="anc6"></a>





















103 class Color {
104     WTF_MAKE_FAST_ALLOCATED;
105 public:
106     Color() { }
107 
108     // FIXME: Remove all these constructors and creation functions and replace the ones that are still needed with free functions.
109 
110     Color(RGBA32 color, bool valid = true)
111     {
112         if (valid)
113             setRGB(color);
114     }
115 
116     enum SemanticTag { Semantic };
<a name="7" id="anc7"></a>
117     Color(RGBA32 color, SemanticTag)
118     {
119         setRGB(color);
120         setIsSemantic();
121     }
122 
123     Color(int r, int g, int b)
124     {
125         setRGB(r, g, b);
126     }
127 
128     Color(int r, int g, int b, int a)
129     {
130         setRGB(makeRGBA(r, g, b, a));
131     }
132 
133     Color(float r, float g, float b, float a)
134     {
135         setRGB(makeRGBA32FromFloats(r, g, b, a));
136     }
137 
138     // Creates a new color from the specific CMYK and alpha values.
139     Color(float c, float m, float y, float k, float a)
140     {
141         setRGB(makeRGBAFromCMYKA(c, m, y, k, a));
142     }
143 
144     WEBCORE_EXPORT explicit Color(const String&amp;);
145     explicit Color(const char*);
146 
147     explicit Color(WTF::HashTableDeletedValueType)
148     {
149         static_assert(deletedHashValue &amp; invalidRGBAColor, &quot;Color&#39;s deleted hash value must not look like an ExtendedColor&quot;);
150         static_assert(!(deletedHashValue &amp; validRGBAColorBit), &quot;Color&#39;s deleted hash value must not look like a valid RGBA32 Color&quot;);
151         static_assert(deletedHashValue &amp; (1 &lt;&lt; 4), &quot;Color&#39;s deleted hash value must have some bits set that an RGBA32 Color wouldn&#39;t have&quot;);
152         m_colorData.rgbaAndFlags = deletedHashValue;
153         ASSERT(!isExtended());
154     }
155 
156     bool isHashTableDeletedValue() const
157     {
158         return m_colorData.rgbaAndFlags == deletedHashValue;
159     }
160 
161     explicit Color(WTF::HashTableEmptyValueType)
162     {
163         static_assert(emptyHashValue &amp; invalidRGBAColor, &quot;Color&#39;s empty hash value must not look like an ExtendedColor&quot;);
164         static_assert(emptyHashValue &amp; (1 &lt;&lt; 4), &quot;Color&#39;s deleted hash value must have some bits set that an RGBA32 Color wouldn&#39;t have&quot;);
165         m_colorData.rgbaAndFlags = emptyHashValue;
166         ASSERT(!isExtended());
167     }
168 
169     // This creates an ExtendedColor.
170     // FIXME: If the colorSpace is sRGB and the values can all be
171     // converted exactly to integers, we should make a normal Color.
172     WEBCORE_EXPORT Color(float r, float g, float b, float a, ColorSpace colorSpace);
173 
<a name="8" id="anc8"></a>
174     WEBCORE_EXPORT Color(const Color&amp;);
175     WEBCORE_EXPORT Color(Color&amp;&amp;);
176 
177     ~Color()
178     {
179         if (isExtended())
180             m_colorData.extendedColor-&gt;deref();
181     }
182 
<a name="9" id="anc9"></a>










183     // Returns the color serialized according to HTML5
184     // &lt;https://html.spec.whatwg.org/multipage/scripting.html#fill-and-stroke-styles&gt; (10 September 2015)
185     WEBCORE_EXPORT String serialized() const;
186 
187     WEBCORE_EXPORT String cssText() const;
188 
189     // Returns the color serialized as either #RRGGBB or #RRGGBBAA
190     String nameForRenderTreeAsText() const;
191 
192     bool isValid() const { return isExtended() || (m_colorData.rgbaAndFlags &amp; validRGBAColorBit); }
193 
<a name="10" id="anc10"></a><span class="line-modified">194     bool isOpaque() const { return isExtended() ? asExtended().alpha() == 1.0 : rgb().isOpaque(); }</span>
<span class="line-modified">195     bool isVisible() const { return isExtended() ? asExtended().alpha() &gt; 0.0 : rgb().isVisible(); }</span>
196 
<a name="11" id="anc11"></a><span class="line-modified">197     int red() const { return rgb().redComponent(); }</span>
<span class="line-modified">198     int green() const { return rgb().greenComponent(); }</span>
<span class="line-modified">199     int blue() const { return rgb().blueComponent(); }</span>
<span class="line-modified">200     int alpha() const { return rgb().alphaComponent(); }</span>
201 
<a name="12" id="anc12"></a><span class="line-modified">202     float alphaAsFloat() const { return isExtended() ? asExtended().alpha() : static_cast&lt;float&gt;(rgb().alphaComponent()) / 0xFF; }</span>
203 
204     RGBA32 rgb() const;
205 
206     // FIXME: Like operator==, this will give different values for ExtendedColors that
207     // should be identical, since the respective pointer will be different.
208     unsigned hash() const { return WTF::intHash(m_colorData.rgbaAndFlags); }
209 
210     // FIXME: ExtendedColor - these should be renamed (to be clear about their parameter types, or
211     // replaced with alternative accessors.
212     WEBCORE_EXPORT void getRGBA(float&amp; r, float&amp; g, float&amp; b, float&amp; a) const;
213     WEBCORE_EXPORT void getRGBA(double&amp; r, double&amp; g, double&amp; b, double&amp; a) const;
214     WEBCORE_EXPORT void getHSL(double&amp; h, double&amp; s, double&amp; l) const;
215     WEBCORE_EXPORT void getHSV(double&amp; h, double&amp; s, double&amp; v) const;
216 
217     Color light() const;
218     Color dark() const;
219 
220     bool isDark() const;
221 
222     // This is an implementation of Porter-Duff&#39;s &quot;source-over&quot; equation
223     Color blend(const Color&amp;) const;
224     Color blendWithWhite() const;
225 
226     Color colorWithAlphaMultipliedBy(float) const;
227 
228     // Returns a color that has the same RGB values, but with the given A.
229     Color colorWithAlpha(float) const;
230     Color opaqueColor() const { return colorWithAlpha(1.0f); }
231 
232     // True if the color originated from a CSS semantic color name.
233     bool isSemantic() const { return !isExtended() &amp;&amp; (m_colorData.rgbaAndFlags &amp; isSemanticRBGAColorBit); }
234 
235 #if PLATFORM(GTK)
236     Color(const GdkRGBA&amp;);
237     operator GdkRGBA() const;
238 #endif
239 
240 #if USE(CG)
241     WEBCORE_EXPORT Color(CGColorRef);
242     WEBCORE_EXPORT Color(CGColorRef, SemanticTag);
243 #endif
244 
245 #if PLATFORM(WIN)
246     WEBCORE_EXPORT Color(D2D1_COLOR_F);
247     WEBCORE_EXPORT operator D2D1_COLOR_F() const;
248     WEBCORE_EXPORT operator D2D1_VECTOR_4F() const;
249 #endif
250 
251     static bool parseHexColor(const String&amp;, RGBA32&amp;);
252     static bool parseHexColor(const StringView&amp;, RGBA32&amp;);
253     static bool parseHexColor(const LChar*, unsigned, RGBA32&amp;);
254     static bool parseHexColor(const UChar*, unsigned, RGBA32&amp;);
255 
<a name="13" id="anc13"></a><span class="line-modified">256     static constexpr SimpleColor black { 0xFF000000 };</span>
<span class="line-modified">257     static constexpr SimpleColor white { 0xFFFFFFFF };</span>
<span class="line-modified">258     static constexpr SimpleColor darkGray { 0xFF808080 };</span>
<span class="line-modified">259     static constexpr SimpleColor gray { 0xFFA0A0A0 };</span>
<span class="line-modified">260     static constexpr SimpleColor lightGray { 0xFFC0C0C0 };</span>
<span class="line-modified">261     static constexpr SimpleColor transparent { 0x00000000 };</span>
<span class="line-modified">262     static constexpr SimpleColor cyan { 0xFF00FFFF };</span>
<span class="line-modified">263     static constexpr SimpleColor yellow { 0xFFFFFF00 };</span>
264 
265 #if PLATFORM(IOS_FAMILY)
<a name="14" id="anc14"></a><span class="line-modified">266     static constexpr SimpleColor compositionFill { 0x3CAFC0E3 };</span>
267 #else
<a name="15" id="anc15"></a><span class="line-modified">268     static constexpr SimpleColor compositionFill { 0xFFE1DD55 };</span>
269 #endif
270 
271     bool isExtended() const
272     {
273         return !(m_colorData.rgbaAndFlags &amp; invalidRGBAColor);
274     }
275     WEBCORE_EXPORT ExtendedColor&amp; asExtended() const;
276 
277     WEBCORE_EXPORT Color&amp; operator=(const Color&amp;);
278     WEBCORE_EXPORT Color&amp; operator=(Color&amp;&amp;);
279 
280     friend bool operator==(const Color&amp; a, const Color&amp; b);
281     friend bool equalIgnoringSemanticColor(const Color&amp; a, const Color&amp; b);
282 
283     static bool isBlackColor(const Color&amp;);
284     static bool isWhiteColor(const Color&amp;);
285 
286 private:
287     void setRGB(int r, int g, int b) { setRGB(makeRGB(r, g, b)); }
288     void setRGB(RGBA32);
289     void setIsSemantic() { m_colorData.rgbaAndFlags |= isSemanticRBGAColorBit; }
290 
291     // 0x_______00 is an ExtendedColor pointer.
292     // 0x_______01 is an invalid RGBA32.
293     // 0x_______11 is a valid RGBA32.
294     static const uint64_t extendedColor = 0x0;
295     static const uint64_t invalidRGBAColor = 0x1;
296     static const uint64_t validRGBAColorBit = 0x2;
297     static const uint64_t validRGBAColor = 0x3;
298     static const uint64_t isSemanticRBGAColorBit = 0x4;
299 
300     static const uint64_t deletedHashValue = 0xFFFFFFFFFFFFFFFD;
301     static const uint64_t emptyHashValue = 0xFFFFFFFFFFFFFFFB;
302 
303     WEBCORE_EXPORT void tagAsValid();
304 
305     union {
306         uint64_t rgbaAndFlags { invalidRGBAColor };
307         ExtendedColor* extendedColor;
308     } m_colorData;
309 };
310 
311 // FIXME: These do not work for ExtendedColor because
312 // they become just pointer comparison.
313 bool operator==(const Color&amp;, const Color&amp;);
314 bool operator!=(const Color&amp;, const Color&amp;);
315 
316 Color colorFromPremultipliedARGB(RGBA32);
317 RGBA32 premultipliedARGBFromColor(const Color&amp;);
318 
319 Color blend(const Color&amp; from, const Color&amp; to, double progress, bool blendPremultiplied = true);
320 
321 int differenceSquared(const Color&amp;, const Color&amp;);
322 
323 uint16_t fastMultiplyBy255(uint16_t value);
324 uint16_t fastDivideBy255(uint16_t);
325 
326 #if USE(CG)
327 WEBCORE_EXPORT CGColorRef cachedCGColor(const Color&amp;);
328 #endif
329 
<a name="16" id="anc16"></a><span class="line-modified">330 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Color&amp;);</span>
<span class="line-modified">331 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, ColorSpace);</span>































332 
<a name="17" id="anc17"></a><span class="line-modified">333 inline bool operator==(SimpleColor a, SimpleColor b)</span>
334 {
<a name="18" id="anc18"></a><span class="line-modified">335     return a.value() == b.value();</span>
336 }
337 
<a name="19" id="anc19"></a><span class="line-modified">338 inline bool operator!=(SimpleColor a, SimpleColor b)</span>
339 {
<a name="20" id="anc20"></a><span class="line-modified">340     return !(a == b);</span>

341 }
342 
343 inline bool operator==(const Color&amp; a, const Color&amp; b)
344 {
345     return a.m_colorData.rgbaAndFlags == b.m_colorData.rgbaAndFlags;
346 }
347 
348 inline bool operator!=(const Color&amp; a, const Color&amp; b)
349 {
350     return !(a == b);
351 }
352 
353 inline bool equalIgnoringSemanticColor(const Color&amp; a, const Color&amp; b)
354 {
355     return (a.m_colorData.rgbaAndFlags &amp; ~Color::isSemanticRBGAColorBit) == (b.m_colorData.rgbaAndFlags &amp; ~Color::isSemanticRBGAColorBit);
356 }
357 
358 inline uint8_t roundAndClampColorChannel(int value)
359 {
360     return std::max(0, std::min(255, value));
361 }
362 
363 inline uint8_t roundAndClampColorChannel(float value)
364 {
365     return std::max(0.f, std::min(255.f, std::round(value)));
366 }
367 
368 inline uint16_t fastMultiplyBy255(uint16_t value)
369 {
370     return (value &lt;&lt; 8) - value;
371 }
372 
373 inline uint16_t fastDivideBy255(uint16_t value)
374 {
375     // While this is an approximate algorithm for division by 255, it gives perfectly accurate results for 16-bit values.
376     // FIXME: Since this gives accurate results for 16-bit values, we should get this optimization into compilers like clang.
377     uint16_t approximation = value &gt;&gt; 8;
378     uint16_t remainder = value - (approximation * 255) + 1;
379     return approximation + (remainder &gt;&gt; 8);
380 }
381 
382 inline RGBA32 colorWithOverrideAlpha(RGBA32 color, Optional&lt;float&gt; overrideAlpha)
383 {
384     return overrideAlpha ? colorWithOverrideAlpha(color, overrideAlpha.value()) : color;
385 }
386 
387 inline RGBA32 Color::rgb() const
388 {
389     // FIXME: We should ASSERT(!isExtended()) here, or produce
390     // an RGBA32 equivalent for an ExtendedColor. Ideally the former,
391     // so we can audit all the rgb() call sites to handle extended.
<a name="21" id="anc21"></a><span class="line-modified">392     return { static_cast&lt;uint32_t&gt;(m_colorData.rgbaAndFlags &gt;&gt; 32) };</span>
393 }
394 
395 inline void Color::setRGB(RGBA32 rgb)
396 {
<a name="22" id="anc22"></a><span class="line-modified">397     m_colorData.rgbaAndFlags = static_cast&lt;uint64_t&gt;(rgb.value()) &lt;&lt; 32;</span>
398     tagAsValid();
399 }
400 
401 inline bool Color::isBlackColor(const Color&amp; color)
402 {
403     if (color.isExtended()) {
404         const ExtendedColor&amp; extendedColor = color.asExtended();
405         return !extendedColor.red() &amp;&amp; !extendedColor.green() &amp;&amp; !extendedColor.blue() &amp;&amp; extendedColor.alpha() == 1;
406     }
407 
<a name="23" id="anc23"></a><span class="line-modified">408     return color.rgb() == Color::black;</span>
409 }
410 
411 inline bool Color::isWhiteColor(const Color&amp; color)
412 {
413     if (color.isExtended()) {
414         const ExtendedColor&amp; extendedColor = color.asExtended();
415         return extendedColor.red() == 1 &amp;&amp; extendedColor.green() == 1 &amp;&amp; extendedColor.blue() == 1 &amp;&amp; extendedColor.alpha() == 1;
416     }
417 
<a name="24" id="anc24"></a><span class="line-modified">418     return color.rgb() == Color::white;</span>
419 }
420 
<a name="25" id="anc25"></a>


421 } // namespace WebCore
422 
423 namespace WTF {
424 template&lt;&gt; struct DefaultHash&lt;WebCore::Color&gt;;
425 template&lt;&gt; struct HashTraits&lt;WebCore::Color&gt;;
426 }
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
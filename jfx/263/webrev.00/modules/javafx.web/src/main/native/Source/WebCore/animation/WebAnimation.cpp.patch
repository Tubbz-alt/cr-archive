diff a/modules/javafx.web/src/main/native/Source/WebCore/animation/WebAnimation.cpp b/modules/javafx.web/src/main/native/Source/WebCore/animation/WebAnimation.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/animation/WebAnimation.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/animation/WebAnimation.cpp
@@ -27,55 +27,104 @@
 #include "WebAnimation.h"
 
 #include "AnimationEffect.h"
 #include "AnimationPlaybackEvent.h"
 #include "AnimationTimeline.h"
+#include "CSSComputedStyleDeclaration.h"
+#include "DOMPromiseProxy.h"
+#include "DeclarativeAnimation.h"
 #include "Document.h"
 #include "DocumentTimeline.h"
+#include "EventLoop.h"
 #include "EventNames.h"
+#include "InspectorInstrumentation.h"
 #include "JSWebAnimation.h"
 #include "KeyframeEffect.h"
-#include "Microtasks.h"
+#include "KeyframeEffectStack.h"
+#include "Logging.h"
+#include "RenderElement.h"
+#include "StyledElement.h"
 #include "WebAnimationUtilities.h"
 #include <wtf/IsoMallocInlines.h>
+#include <wtf/Lock.h>
+#include <wtf/NeverDestroyed.h>
 #include <wtf/Optional.h>
+#include <wtf/text/TextStream.h>
 #include <wtf/text/WTFString.h>
 
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(WebAnimation);
 
+HashSet<WebAnimation*>& WebAnimation::instances(const LockHolder&)
+{
+    static NeverDestroyed<HashSet<WebAnimation*>> instances;
+    return instances;
+}
+
+Lock& WebAnimation::instancesMutex()
+{
+    static LazyNeverDestroyed<Lock> mutex;
+    static std::once_flag initializeMutex;
+    std::call_once(initializeMutex, [] {
+        mutex.construct();
+    });
+    return mutex.get();
+}
+
 Ref<WebAnimation> WebAnimation::create(Document& document, AnimationEffect* effect)
 {
     auto result = adoptRef(*new WebAnimation(document));
     result->setEffect(effect);
     result->setTimeline(&document.timeline());
+
+    InspectorInstrumentation::didCreateWebAnimation(result.get());
+
     return result;
 }
 
 Ref<WebAnimation> WebAnimation::create(Document& document, AnimationEffect* effect, AnimationTimeline* timeline)
 {
     auto result = adoptRef(*new WebAnimation(document));
     result->setEffect(effect);
     if (timeline)
         result->setTimeline(timeline);
+
+    InspectorInstrumentation::didCreateWebAnimation(result.get());
+
     return result;
 }
 
 WebAnimation::WebAnimation(Document& document)
     : ActiveDOMObject(document)
     , m_readyPromise(makeUniqueRef<ReadyPromise>(*this, &WebAnimation::readyPromiseResolve))
     , m_finishedPromise(makeUniqueRef<FinishedPromise>(*this, &WebAnimation::finishedPromiseResolve))
 {
     m_readyPromise->resolve(*this);
     suspendIfNeeded();
+
+    LockHolder lock(instancesMutex());
+    instances(lock).add(this);
 }
 
 WebAnimation::~WebAnimation()
 {
+    InspectorInstrumentation::willDestroyWebAnimation(*this);
+
     if (m_timeline)
         m_timeline->forgetAnimation(this);
+
+    LockHolder lock(instancesMutex());
+    ASSERT(instances(lock).contains(this));
+    instances(lock).remove(this);
+}
+
+void WebAnimation::contextDestroyed()
+{
+    InspectorInstrumentation::willDestroyWebAnimation(*this);
+
+    ActiveDOMObject::contextDestroyed();
 }
 
 void WebAnimation::remove()
 {
     // This object could be deleted after either clearing the effect or timeline relationship.
@@ -93,13 +142,23 @@
 {
     ASSERT(m_suspendCount > 0);
     --m_suspendCount;
 }
 
-void WebAnimation::effectTimingDidChange()
+void WebAnimation::effectTimingDidChange(Optional<ComputedEffectTiming> previousTiming)
 {
     timingDidChange(DidSeek::No, SynchronouslyNotify::Yes);
+
+    InspectorInstrumentation::didChangeWebAnimationEffectTiming(*this);
+
+    if (!previousTiming)
+        return;
+
+    auto* effect = this->effect();
+    ASSERT(effect);
+    if (previousTiming->progress != effect->getComputedTiming().progress)
+        effect->animationDidSeek();
 }
 
 void WebAnimation::setEffect(RefPtr<AnimationEffect>&& newEffect)
 {
     // 3.4.3. Setting the target effect of an animation
@@ -141,10 +200,15 @@
     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 
     invalidateEffect();
 }
 
+AnimationTimeline* WebAnimation::timeline() const
+{
+    return m_timeline.get();
+}
+
 void WebAnimation::setEffectInternal(RefPtr<AnimationEffect>&& newEffect, bool doNotRemoveFromTimeline)
 {
     if (m_effect == newEffect)
         return;
 
@@ -169,19 +233,21 @@
     if (m_effect) {
         m_effect->setAnimation(this);
         if (m_timeline && newTarget && previousTarget != newTarget)
             m_timeline->animationWasAddedToElement(*this, *newTarget);
     }
+
+    InspectorInstrumentation::didSetWebAnimationEffect(*this);
 }
 
 void WebAnimation::setTimeline(RefPtr<AnimationTimeline>&& timeline)
 {
     // 3.4.1. Setting the timeline of an animation
     // https://drafts.csswg.org/web-animations-1/#setting-the-timeline
 
     // 2. If new timeline is the same object as old timeline, abort this procedure.
-    if (timeline == m_timeline)
+    if (timeline == m_timeline.get())
         return;
 
     // 4. If the animation start time of animation is resolved, make animation's hold time unresolved.
     if (m_startTime)
         m_holdTime = WTF::nullopt;
@@ -202,40 +268,47 @@
 
     // This object could be deleted after clearing the timeline relationship.
     auto protectedThis = makeRef(*this);
     setTimelineInternal(WTFMove(timeline));
 
-    setSuspended(is<DocumentTimeline>(m_timeline) && downcast<DocumentTimeline>(*m_timeline).animationsAreSuspended());
+    setSuspended(is<DocumentTimeline>(m_timeline.get()) && downcast<DocumentTimeline>(*m_timeline).animationsAreSuspended());
 
     // 5. Run the procedure to update an animation's finished state for animation with the did seek flag set to false,
     // and the synchronously notify flag set to false.
     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 
     invalidateEffect();
 }
 
 void WebAnimation::setTimelineInternal(RefPtr<AnimationTimeline>&& timeline)
 {
-    if (m_timeline == timeline)
+    if (m_timeline.get() == timeline)
         return;
 
     if (m_timeline)
         m_timeline->removeAnimation(*this);
 
-    m_timeline = WTFMove(timeline);
+    m_timeline = makeWeakPtr(timeline.get());
+
+    if (m_effect)
+        m_effect->animationTimelineDidChange(m_timeline.get());
 }
 
 void WebAnimation::effectTargetDidChange(Element* previousTarget, Element* newTarget)
 {
-    if (!m_timeline)
-        return;
+    if (m_timeline) {
+        if (previousTarget)
+            m_timeline->animationWasRemovedFromElement(*this, *previousTarget);
+
+        if (newTarget)
+            m_timeline->animationWasAddedToElement(*this, *newTarget);
 
-    if (previousTarget)
-        m_timeline->animationWasRemovedFromElement(*this, *previousTarget);
+        // This could have changed whether we have replaced animations, so we may need to schedule an update.
+        m_timeline->animationTimingDidChange(*this);
+    }
 
-    if (newTarget)
-        m_timeline->animationWasAddedToElement(*this, *newTarget);
+    InspectorInstrumentation::didChangeWebAnimationEffectTarget(*this);
 }
 
 Optional<double> WebAnimation::startTime() const
 {
     if (!m_startTime)
@@ -340,10 +413,12 @@
     return (m_timeline->currentTime().value() - m_startTime.value()) * m_playbackRate;
 }
 
 ExceptionOr<void> WebAnimation::silentlySetCurrentTime(Optional<Seconds> seekTime)
 {
+    LOG_WITH_STREAM(Animations, stream << "WebAnimation " << this << " silentlySetCurrentTime " << seekTime);
+
     // 3.4.5. Setting the current time of an animation
     // https://drafts.csswg.org/web-animations-1/#setting-the-current-time-of-an-animation
 
     // 1. If seek time is an unresolved time value, then perform the following steps.
     if (!seekTime) {
@@ -378,10 +453,12 @@
     return { };
 }
 
 ExceptionOr<void> WebAnimation::setCurrentTime(Optional<Seconds> seekTime)
 {
+    LOG_WITH_STREAM(Animations, stream << "WebAnimation " << this << " setCurrentTime " << seekTime);
+
     // 3.4.5. Setting the current time of an animation
     // https://drafts.csswg.org/web-animations-1/#setting-the-current-time-of-an-animation
 
     // 1. Run the steps to silently set the current time of animation to seek time.
     auto silentResult = silentlySetCurrentTime(seekTime);
@@ -540,21 +617,23 @@
 
 Seconds WebAnimation::effectEndTime() const
 {
     // The target effect end of an animation is equal to the end time of the animation's target effect.
     // If the animation has no target effect, the target effect end is zero.
-    return m_effect ? m_effect->getBasicTiming().endTime : 0_s;
+    return m_effect ? m_effect->endTime() : 0_s;
 }
 
 void WebAnimation::cancel()
 {
     cancel(Silently::No);
     invalidateEffect();
 }
 
 void WebAnimation::cancel(Silently silently)
 {
+    LOG_WITH_STREAM(Animations, stream << "WebAnimation " << this << " cancel(silently " << (silently == Silently::Yes) << ") (current time is " << currentTime() << ")");
+
     // 3.4.16. Canceling an animation
     // https://drafts.csswg.org/web-animations-1/#canceling-an-animation-section
     //
     // An animation can be canceled which causes the current time to become unresolved hence removing any effects caused by the target effect.
     //
@@ -594,29 +673,40 @@
     m_startTime = WTF::nullopt;
 
     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 
     invalidateEffect();
+
+    if (m_effect)
+        m_effect->animationWasCanceled();
+}
+
+void WebAnimation::willChangeRenderer()
+{
+    if (is<KeyframeEffect>(m_effect))
+        downcast<KeyframeEffect>(*m_effect).willChangeRenderer();
 }
 
 void WebAnimation::enqueueAnimationPlaybackEvent(const AtomString& type, Optional<Seconds> currentTime, Optional<Seconds> timelineTime)
 {
-    auto event = AnimationPlaybackEvent::create(type, currentTime, timelineTime);
+    auto event = AnimationPlaybackEvent::create(type, currentTime, timelineTime, this);
     event->setTarget(this);
+    enqueueAnimationEvent(WTFMove(event));
+}
 
-    if (is<DocumentTimeline>(m_timeline)) {
+void WebAnimation::enqueueAnimationEvent(Ref<AnimationEventBase>&& event)
+{
+    if (is<DocumentTimeline>(m_timeline.get())) {
         // If animation has a document for timing, then append event to its document for timing's pending animation event queue along
         // with its target, animation. If animation is associated with an active timeline that defines a procedure to convert timeline times
         // to origin-relative time, let the scheduled event time be the result of applying that procedure to timeline time. Otherwise, the
         // scheduled event time is an unresolved time value.
-        downcast<DocumentTimeline>(*m_timeline).enqueueAnimationPlaybackEvent(WTFMove(event));
+        m_hasScheduledEventsDuringTick = true;
+        downcast<DocumentTimeline>(*m_timeline).enqueueAnimationEvent(WTFMove(event));
     } else {
         // Otherwise, queue a task to dispatch event at animation. The task source for this task is the DOM manipulation task source.
-        callOnMainThread([this, pendingActivity = makePendingActivity(*this), event = WTFMove(event)]() {
-            if (!m_isStopped)
-                this->dispatchEvent(event);
-        });
+        queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, WTFMove(event));
     }
 }
 
 void WebAnimation::resetPendingTasks(Silently silently)
 {
@@ -647,10 +737,12 @@
     m_readyPromise->resolve(*this);
 }
 
 ExceptionOr<void> WebAnimation::finish()
 {
+    LOG_WITH_STREAM(Animations, stream << "WebAnimation " << this << " finish (current time is " << currentTime() << ")");
+
     // 3.4.15. Finishing an animation
     // https://drafts.csswg.org/web-animations-1/#finishing-an-animation-section
 
     // An animation can be advanced to the natural end of its current playback direction by using the procedure to finish an animation for animation defined below:
     //
@@ -696,15 +788,21 @@
     invalidateEffect();
 
     return { };
 }
 
-void WebAnimation::timingDidChange(DidSeek didSeek, SynchronouslyNotify synchronouslyNotify)
+void WebAnimation::timingDidChange(DidSeek didSeek, SynchronouslyNotify synchronouslyNotify, Silently silently)
 {
     m_shouldSkipUpdatingFinishedStateWhenResolving = false;
     updateFinishedState(didSeek, synchronouslyNotify);
-    if (m_timeline)
+
+    if (is<KeyframeEffect>(m_effect)) {
+        updateRelevance();
+        downcast<KeyframeEffect>(*m_effect).animationTimingDidChange();
+    }
+
+    if (silently == Silently::No && m_timeline)
         m_timeline->animationTimingDidChange(*this);
 };
 
 void WebAnimation::invalidateEffect()
 {
@@ -775,16 +873,18 @@
             finishNotificationSteps();
         } else if (!m_finishNotificationStepsMicrotaskPending) {
             // Otherwise, if synchronously notify is false, queue a microtask to run finish notification steps for animation unless there
             // is already a microtask queued to run those steps for animation.
             m_finishNotificationStepsMicrotaskPending = true;
-            MicrotaskQueue::mainThreadQueue().append(makeUnique<VoidMicrotask>([this, protectedThis = makeRef(*this)] () {
-                if (m_finishNotificationStepsMicrotaskPending) {
-                    m_finishNotificationStepsMicrotaskPending = false;
-                    finishNotificationSteps();
-                }
-            }));
+            if (auto* context = scriptExecutionContext()) {
+                context->eventLoop().queueMicrotask([this, protectedThis = makeRef(*this)] {
+                    if (m_finishNotificationStepsMicrotaskPending) {
+                        m_finishNotificationStepsMicrotaskPending = false;
+                        finishNotificationSteps();
+                    }
+                });
+            }
         }
     }
 
     // 6. If current finished state is false and animation's current finished promise is already resolved, set animation's current
     // finished promise to a new (pending) Promise object.
@@ -824,10 +924,12 @@
     return play(AutoRewind::Yes);
 }
 
 ExceptionOr<void> WebAnimation::play(AutoRewind autoRewind)
 {
+    LOG_WITH_STREAM(Animations, stream << "WebAnimation " << this << " play(autoRewind " << (autoRewind == AutoRewind::Yes) << ") (current time is " << currentTime() << ")");
+
     // 3.4.10. Playing an animation
     // https://drafts.csswg.org/web-animations-1/#play-an-animation
 
     auto localTime = currentTime();
     auto endTime = effectEndTime();
@@ -892,15 +994,20 @@
     // 9. Run the procedure to update an animation's finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 
     invalidateEffect();
 
+    if (m_effect)
+        m_effect->animationDidPlay();
+
     return { };
 }
 
 void WebAnimation::runPendingPlayTask()
 {
+    LOG_WITH_STREAM(Animations, stream << "WebAnimation " << this << " runPendingPlayTask (current time is " << currentTime() << ")");
+
     // 3.4.10. Playing an animation, step 8.
     // https://drafts.csswg.org/web-animations-1/#play-an-animation
 
     m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 
@@ -950,17 +1057,19 @@
     // 4. Resolve animation's current ready promise with animation.
     if (!m_readyPromise->isFulfilled())
         m_readyPromise->resolve(*this);
 
     // 5. Run the procedure to update an animation's finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
-    timingDidChange(DidSeek::No, SynchronouslyNotify::No);
+    timingDidChange(DidSeek::No, SynchronouslyNotify::No, Silently::Yes);
 
     invalidateEffect();
 }
 
 ExceptionOr<void> WebAnimation::pause()
 {
+    LOG_WITH_STREAM(Animations, stream << "WebAnimation " << this << " pause (current time is " << currentTime() << ")");
+
     // 3.4.11. Pausing an animation
     // https://drafts.csswg.org/web-animations-1/#pause-an-animation
 
     // 1. If animation has a pending pause task, abort these steps.
     if (hasPendingPauseTask())
@@ -1011,10 +1120,12 @@
     return { };
 }
 
 ExceptionOr<void> WebAnimation::reverse()
 {
+    LOG_WITH_STREAM(Animations, stream << "WebAnimation " << this << " reverse (current time is " << currentTime() << ")");
+
     // 3.4.18. Reversing an animation
     // https://drafts.csswg.org/web-animations-1/#reverse-an-animation
 
     // The procedure to reverse an animation of animation animation is as follows:
 
@@ -1042,10 +1153,12 @@
     return { };
 }
 
 void WebAnimation::runPendingPauseTask()
 {
+    LOG_WITH_STREAM(Animations, stream << "WebAnimation " << this << " runPendingPauseTask (current time is " << currentTime() << ")");
+
     // 3.4.11. Pausing an animation, step 7.
     // https://drafts.csswg.org/web-animations-1/#pause-an-animation
 
     m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 
@@ -1076,37 +1189,44 @@
     if (!m_readyPromise->isFulfilled())
         m_readyPromise->resolve(*this);
 
     // 6. Run the procedure to update an animation's finished state for animation with the did seek flag set to false, and the
     //    synchronously notify flag set to false.
-    timingDidChange(DidSeek::No, SynchronouslyNotify::No);
+    timingDidChange(DidSeek::No, SynchronouslyNotify::No, Silently::Yes);
 
     invalidateEffect();
 }
 
 bool WebAnimation::isRunningAccelerated() const
 {
     return is<KeyframeEffect>(m_effect) && downcast<KeyframeEffect>(*m_effect).isRunningAccelerated();
 }
 
+bool WebAnimation::isCompletelyAccelerated() const
+{
+    return is<KeyframeEffect>(m_effect) && downcast<KeyframeEffect>(*m_effect).isCompletelyAccelerated();
+}
+
 bool WebAnimation::needsTick() const
 {
-    return pending() || playState() == PlayState::Running;
+    return pending() || playState() == PlayState::Running || m_hasScheduledEventsDuringTick;
 }
 
 void WebAnimation::tick()
 {
+    m_hasScheduledEventsDuringTick = false;
     updateFinishedState(DidSeek::No, SynchronouslyNotify::Yes);
     m_shouldSkipUpdatingFinishedStateWhenResolving = true;
 
     // Run pending tasks, if any.
     if (hasPendingPauseTask())
         runPendingPauseTask();
     if (hasPendingPlayTask())
         runPendingPlayTask();
 
-    invalidateEffect();
+    if (!isEffectInvalidationSuspended() && m_effect)
+        m_effect->animationDidTick();
 }
 
 void WebAnimation::resolve(RenderStyle& targetStyle)
 {
     if (!m_shouldSkipUpdatingFinishedStateWhenResolving)
@@ -1128,11 +1248,11 @@
         m_effect->animationSuspensionStateDidChange(isSuspended);
 }
 
 void WebAnimation::acceleratedStateDidChange()
 {
-    if (is<DocumentTimeline>(m_timeline))
+    if (is<DocumentTimeline>(m_timeline.get()))
         downcast<DocumentTimeline>(*m_timeline).animationAcceleratedRunningStateDidChange(*this);
 }
 
 void WebAnimation::applyPendingAcceleratedActions()
 {
@@ -1153,22 +1273,23 @@
 const char* WebAnimation::activeDOMObjectName() const
 {
     return "Animation";
 }
 
-bool WebAnimation::canSuspendForDocumentSuspension() const
+void WebAnimation::suspend(ReasonForSuspension)
 {
-    // Use the base class's implementation of hasPendingActivity() since we wouldn't want the custom implementation
-    // in this class designed to keep JS wrappers alive to interfere with the ability for a page using animations
-    // to enter the page cache.
-    return !ActiveDOMObject::hasPendingActivity();
+    setSuspended(true);
+}
+
+void WebAnimation::resume()
+{
+    setSuspended(false);
 }
 
 void WebAnimation::stop()
 {
     ActiveDOMObject::stop();
-    m_isStopped = true;
     removeAllEventListeners();
 }
 
 bool WebAnimation::hasPendingActivity() const
 {
@@ -1185,10 +1306,13 @@
 {
     // To be listed in getAnimations() an animation needs a target effect which is current or in effect.
     if (!m_effect)
         return false;
 
+    if (m_replaceState == ReplaceState::Removed)
+        return false;
+
     auto timing = m_effect->getBasicTiming();
 
     // An animation effect is in effect if its active time is not unresolved.
     if (timing.activeTime)
         return true;
@@ -1201,43 +1325,168 @@
     // - the animation effect is in the active phase, and
     // - the animation effect is associated with an animation that is not finished.
     return timing.phase == AnimationEffectPhase::Before || (timing.phase == AnimationEffectPhase::Active && playState() != PlayState::Finished);
 }
 
+bool WebAnimation::isReplaceable() const
+{
+    // An animation is replaceable if all of the following conditions are true:
+    // https://drafts.csswg.org/web-animations/#removing-replaced-animations
+
+    // The existence of the animation is not prescribed by markup. That is, it is not a CSS animation with an owning element,
+    // nor a CSS transition with an owning element.
+    if (isDeclarativeAnimation() && downcast<DeclarativeAnimation>(this)->owningElement())
+        return false;
+
+    // The animation's play state is finished.
+    if (playState() != PlayState::Finished)
+        return false;
+
+    // The animation's replace state is not removed.
+    if (m_replaceState == ReplaceState::Removed)
+        return false;
+
+    // The animation is associated with a monotonically increasing timeline.
+    if (!m_timeline)
+        return false;
+
+    // The animation has an associated target effect.
+    if (!m_effect)
+        return false;
+
+    // The target effect associated with the animation is in effect.
+    if (!m_effect->getBasicTiming().activeTime)
+        return false;
+
+    // The target effect has an associated target element.
+    if (!is<KeyframeEffect>(m_effect) || !downcast<KeyframeEffect>(m_effect.get())->target())
+        return false;
+
+    return true;
+}
+
+void WebAnimation::persist()
+{
+    auto previousReplaceState = std::exchange(m_replaceState, ReplaceState::Persisted);
+
+    if (previousReplaceState == ReplaceState::Removed && m_timeline) {
+        if (is<KeyframeEffect>(m_effect)) {
+            auto& keyframeEffect = downcast<KeyframeEffect>(*m_effect);
+            auto& target = *keyframeEffect.target();
+            m_timeline->animationWasAddedToElement(*this, target);
+            target.ensureKeyframeEffectStack().addEffect(keyframeEffect);
+        }
+    }
+}
+
+ExceptionOr<void> WebAnimation::commitStyles()
+{
+    // https://drafts.csswg.org/web-animations-1/#commit-computed-styles
+
+    // 1. Let targets be the set of all effect targets for animation effects associated with animation.
+    auto* effect = is<KeyframeEffect>(m_effect) ? downcast<KeyframeEffect>(m_effect.get()) : nullptr;
+    auto* target = effect ? effect->target() : nullptr;
+
+    // 2. For each target in targets:
+    //
+    // 2.1 If target is not an element capable of having a style attribute (for example, it is a pseudo-element or is an element in a
+    // document format for which style attributes are not defined) throw a "NoModificationAllowedError" DOMException and abort these steps.
+    if (!is<StyledElement>(target))
+        return Exception { NoModificationAllowedError };
+
+    auto& styledElement = downcast<StyledElement>(*target);
+
+    // 2.2 If, after applying any pending style changes, target is not being rendered, throw an "InvalidStateError" DOMException and abort these steps.
+    styledElement.document().updateStyleIfNeeded();
+    auto* renderer = styledElement.renderer();
+    if (!renderer)
+        return Exception { InvalidStateError };
+
+    // 2.3 Let inline style be the result of getting the CSS declaration block corresponding to target’s style attribute. If target does not have a style
+    // attribute, let inline style be a new empty CSS declaration block with the readonly flag unset and owner node set to target.
+
+    // 2.4 Let targeted properties be the set of physical longhand properties that are a target property for at least one animation effect associated with
+    // animation whose effect target is target.
+
+    auto& style = renderer->style();
+    auto computedStyleExtractor = ComputedStyleExtractor(&styledElement);
+    auto inlineStyle = styledElement.document().createCSSStyleDeclaration();
+    inlineStyle->setCssText(styledElement.getAttribute("style"));
+
+    auto& keyframeStack = styledElement.ensureKeyframeEffectStack();
+    auto* cssAnimationList = keyframeStack.cssAnimationList();
+
+    // 2.5 For each property, property, in targeted properties:
+    for (auto property : effect->animatedProperties()) {
+        // 1. Let partialEffectStack be a copy of the effect stack for property on target.
+        // 2. If animation's replace state is removed, add all animation effects associated with animation whose effect target is target and which include
+        // property as a target property to partialEffectStack.
+        // 3. Remove from partialEffectStack any animation effects whose associated animation has a higher composite order than animation.
+        // 4. Let effect value be the result of calculating the result of partialEffectStack for property using target's computed style (see § 5.4.3 Calculating
+        // the result of an effect stack).
+        // 5. Set a CSS declaration property for effect value in inline style.
+        // 6. Update style attribute for inline style.
+
+        // We actually perform those steps in a different way: instead of building a copy of the effect stack and then removing stuff, we iterate through the
+        // effect stack and stop when we've found this animation's effect or when we've found an effect associated with an animation with a higher composite order.
+        auto animatedStyle = RenderStyle::clonePtr(style);
+        for (const auto& effectInStack : keyframeStack.sortedEffects()) {
+            if (effectInStack->animation() != this && !compareAnimationsByCompositeOrder(*effectInStack->animation(), *this, cssAnimationList))
+                break;
+            if (effectInStack->animatedProperties().contains(property))
+                effectInStack->animation()->resolve(*animatedStyle);
+            if (effectInStack->animation() == this)
+                break;
+        }
+        if (m_replaceState == ReplaceState::Removed)
+            effect->animation()->resolve(*animatedStyle);
+        if (auto cssValue = computedStyleExtractor.valueForPropertyInStyle(*animatedStyle, property, renderer))
+            inlineStyle->setPropertyInternal(property, cssValue->cssText(), false);
+    }
+
+    styledElement.setAttribute("style", inlineStyle->cssText());
+
+    return { };
+}
+
 Seconds WebAnimation::timeToNextTick() const
 {
-    ASSERT(isRunningAccelerated());
+    ASSERT(effect());
 
     if (pending())
         return 0_s;
 
-    // If we're not running, there's no telling when we'll end.
-    if (playState() != PlayState::Running)
+    // If we're not running, or time is not advancing for this animation, there's no telling when we'll end.
+    auto playbackRate = effectivePlaybackRate();
+    if (playState() != PlayState::Running || !playbackRate)
         return Seconds::infinity();
 
-    // CSS Animations dispatch events for each iteration, so compute the time until
-    // the end of this iteration. Any other animation only cares about remaning total time.
-    if (isCSSAnimation()) {
-        auto* animationEffect = effect();
-        auto timing = animationEffect->getComputedTiming();
-        // If we're actively running, we need the time until the next iteration.
-        if (auto iterationProgress = timing.simpleIterationProgress)
-            return animationEffect->iterationDuration() * (1 - *iterationProgress);
-
-        // Otherwise we're probably in the before phase waiting to reach our start time.
-        if (auto animationCurrentTime = currentTime()) {
-            // If our current time is negative, we need to be scheduled to be resolved at the inverse
-            // of our current time, unless we fill backwards, in which case we want to invalidate as
-            // soon as possible.
-            auto localTime = animationCurrentTime.value();
-            if (localTime < 0_s)
-                return -localTime;
-            if (localTime < animationEffect->delay())
-                return animationEffect->delay() - localTime;
+    auto& effect = *this->effect();
+    auto timing = effect.getBasicTiming();
+    switch (timing.phase) {
+    case AnimationEffectPhase::Before:
+        // The animation is in its "before" phase, in this case we can wait until it enters its "active" phase.
+        return (effect.delay() - timing.localTime.value()) / playbackRate;
+    case AnimationEffectPhase::Active:
+        if (isCompletelyAccelerated() && isRunningAccelerated()) {
+            // Fully-accelerated running CSS Animations need to trigger "animationiteration" events, in this case we must wait until the next iteration.
+            if (isCSSAnimation()) {
+                if (auto iterationProgress = effect.getComputedTiming().simpleIterationProgress)
+                    return effect.iterationDuration() * (1 - *iterationProgress);
+            }
+            // Fully-accelerated running animations in the "active" phase can wait until they ended.
+            return (effect.endTime() - timing.localTime.value()) / playbackRate;
         }
-    } else if (auto animationCurrentTime = currentTime())
-        return effect()->getBasicTiming().endTime - *animationCurrentTime;
+        // Other animations in the "active" phase will need to update their animated value at the immediate next opportunity.
+        return 0_s;
+    case AnimationEffectPhase::After:
+        // The animation is in its after phase, which means it will no longer update its value, so it doens't need a tick.
+        return Seconds::infinity();
+    case AnimationEffectPhase::Idle:
+        ASSERT_NOT_REACHED();
+        return Seconds::infinity();
+    }
 
     ASSERT_NOT_REACHED();
     return Seconds::infinity();
 }
 

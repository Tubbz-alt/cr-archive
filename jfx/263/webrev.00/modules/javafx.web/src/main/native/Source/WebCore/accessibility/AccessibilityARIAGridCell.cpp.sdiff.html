<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityARIAGridCell.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityARIAGrid.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityARIAGridRow.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityARIAGridCell.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38 
 39 using namespace HTMLNames;
 40 
 41 AccessibilityARIAGridCell::AccessibilityARIAGridCell(RenderObject* renderer)
 42     : AccessibilityTableCell(renderer)
 43 {
 44 }
 45 
 46 AccessibilityARIAGridCell::~AccessibilityARIAGridCell() = default;
 47 
 48 Ref&lt;AccessibilityARIAGridCell&gt; AccessibilityARIAGridCell::create(RenderObject* renderer)
 49 {
 50     return adoptRef(*new AccessibilityARIAGridCell(renderer));
 51 }
 52 
 53 AccessibilityTable* AccessibilityARIAGridCell::parentTable() const
 54 {
 55     // ARIA gridcells may have multiple levels of unignored ancestors that are not the parent table,
 56     // including rows and interactive rowgroups. In addition, poorly-formed grids may contain elements
 57     // which pass the tests for inclusion.
<span class="line-modified"> 58     for (AccessibilityObject* parent = parentObjectUnignored(); parent; parent = parent-&gt;parentObjectUnignored()) {</span>
 59         if (is&lt;AccessibilityTable&gt;(*parent) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*parent).isExposableThroughAccessibility())
 60             return downcast&lt;AccessibilityTable&gt;(parent);
 61     }
 62 
 63     return nullptr;
 64 }
 65 
 66 void AccessibilityARIAGridCell::rowIndexRange(std::pair&lt;unsigned, unsigned&gt;&amp; rowRange) const
 67 {
<span class="line-modified"> 68     AccessibilityObject* parent = parentObjectUnignored();</span>
 69     if (!parent)
 70         return;
 71 
 72     if (is&lt;AccessibilityTableRow&gt;(*parent)) {
 73         // We already got a table row, use its API.
 74         rowRange.first = downcast&lt;AccessibilityTableRow&gt;(*parent).rowIndex();
 75     } else if (is&lt;AccessibilityTable&gt;(*parent) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*parent).isExposableThroughAccessibility()) {
 76         // We reached the parent table, so we need to inspect its
 77         // children to determine the row index for the cell in it.
 78         unsigned columnCount = downcast&lt;AccessibilityTable&gt;(*parent).columnCount();
 79         if (!columnCount)
 80             return;
 81 
 82         const auto&amp; siblings = parent-&gt;children();
 83         unsigned childrenSize = siblings.size();
 84         for (unsigned k = 0; k &lt; childrenSize; ++k) {
 85             if (siblings[k].get() == this) {
 86                 rowRange.first = k / columnCount;
 87                 break;
 88             }
 89         }
 90     }
 91 
 92     // ARIA 1.1, aria-rowspan attribute is intended for cells and gridcells which are not contained in a native table.
 93     // So we should check for that attribute here.
 94     rowRange.second = axRowSpanWithRowIndex(rowRange.first);
 95 }
 96 
 97 unsigned AccessibilityARIAGridCell::axRowSpanWithRowIndex(unsigned rowIndex) const
 98 {
 99     int rowSpan = AccessibilityTableCell::axRowSpan();
100     if (rowSpan == -1) {
101         std::pair&lt;unsigned, unsigned&gt; range;
102         AccessibilityTableCell::rowIndexRange(range);
103         return std::max(static_cast&lt;int&gt;(range.second), 1);
104     }
105 
<span class="line-modified">106     AccessibilityObject* parent = parentObjectUnignored();</span>
107     if (!parent)
108         return 1;
109 
110     // Setting the value to 0 indicates that the cell or gridcell is to span all the remaining rows in the row group.
111     if (!rowSpan) {
112         // rowSpan defaults to 1.
113         rowSpan = 1;
114         if (AccessibilityObject* parentRowGroup = this-&gt;parentRowGroup()) {
115             // If the row group is the parent table, we use total row count to calculate the span.
116             if (is&lt;AccessibilityTable&gt;(*parentRowGroup))
117                 rowSpan = downcast&lt;AccessibilityTable&gt;(*parentRowGroup).rowCount() - rowIndex;
118             // Otherwise, we have to get the index for the current row within the parent row group.
119             else if (is&lt;AccessibilityTableRow&gt;(*parent)) {
120                 const auto&amp; siblings = parentRowGroup-&gt;children();
121                 unsigned rowCount = siblings.size();
122                 for (unsigned k = 0; k &lt; rowCount; ++k) {
123                     if (siblings[k].get() == parent) {
124                         rowSpan = rowCount - k;
125                         break;
126                     }
127                 }
128             }
129         }
130     }
131 
132     return rowSpan;
133 }
134 
135 void AccessibilityARIAGridCell::columnIndexRange(std::pair&lt;unsigned, unsigned&gt;&amp; columnRange) const
136 {
<span class="line-modified">137     AccessibilityObject* parent = parentObjectUnignored();</span>
138     if (!parent)
139         return;
140 
141     if (!is&lt;AccessibilityTableRow&gt;(*parent)
142         &amp;&amp; !(is&lt;AccessibilityTable&gt;(*parent) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*parent).isExposableThroughAccessibility()))
143         return;
144 
145     const AccessibilityChildrenVector&amp; siblings = parent-&gt;children();
146     unsigned childrenSize = siblings.size();
147     unsigned indexWithSpan = 0;
148     for (unsigned k = 0; k &lt; childrenSize; ++k) {
149         auto child = siblings[k].get();
150         if (child == this) {
151             columnRange.first = indexWithSpan;
152             break;
153         }
154         indexWithSpan += is&lt;AccessibilityTableCell&gt;(*child) ? std::max(downcast&lt;AccessibilityTableCell&gt;(*child).axColumnSpan(), 1) : 1;
155     }
156 
157     // ARIA 1.1, aria-colspan attribute is intended for cells and gridcells which are not contained in a native table.
</pre>
</td>
<td>
<hr />
<pre>
 38 
 39 using namespace HTMLNames;
 40 
 41 AccessibilityARIAGridCell::AccessibilityARIAGridCell(RenderObject* renderer)
 42     : AccessibilityTableCell(renderer)
 43 {
 44 }
 45 
 46 AccessibilityARIAGridCell::~AccessibilityARIAGridCell() = default;
 47 
 48 Ref&lt;AccessibilityARIAGridCell&gt; AccessibilityARIAGridCell::create(RenderObject* renderer)
 49 {
 50     return adoptRef(*new AccessibilityARIAGridCell(renderer));
 51 }
 52 
 53 AccessibilityTable* AccessibilityARIAGridCell::parentTable() const
 54 {
 55     // ARIA gridcells may have multiple levels of unignored ancestors that are not the parent table,
 56     // including rows and interactive rowgroups. In addition, poorly-formed grids may contain elements
 57     // which pass the tests for inclusion.
<span class="line-modified"> 58     for (auto* parent = parentObjectUnignored(); parent; parent = parent-&gt;parentObjectUnignored()) {</span>
 59         if (is&lt;AccessibilityTable&gt;(*parent) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*parent).isExposableThroughAccessibility())
 60             return downcast&lt;AccessibilityTable&gt;(parent);
 61     }
 62 
 63     return nullptr;
 64 }
 65 
 66 void AccessibilityARIAGridCell::rowIndexRange(std::pair&lt;unsigned, unsigned&gt;&amp; rowRange) const
 67 {
<span class="line-modified"> 68     AXCoreObject* parent = parentObjectUnignored();</span>
 69     if (!parent)
 70         return;
 71 
 72     if (is&lt;AccessibilityTableRow&gt;(*parent)) {
 73         // We already got a table row, use its API.
 74         rowRange.first = downcast&lt;AccessibilityTableRow&gt;(*parent).rowIndex();
 75     } else if (is&lt;AccessibilityTable&gt;(*parent) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*parent).isExposableThroughAccessibility()) {
 76         // We reached the parent table, so we need to inspect its
 77         // children to determine the row index for the cell in it.
 78         unsigned columnCount = downcast&lt;AccessibilityTable&gt;(*parent).columnCount();
 79         if (!columnCount)
 80             return;
 81 
 82         const auto&amp; siblings = parent-&gt;children();
 83         unsigned childrenSize = siblings.size();
 84         for (unsigned k = 0; k &lt; childrenSize; ++k) {
 85             if (siblings[k].get() == this) {
 86                 rowRange.first = k / columnCount;
 87                 break;
 88             }
 89         }
 90     }
 91 
 92     // ARIA 1.1, aria-rowspan attribute is intended for cells and gridcells which are not contained in a native table.
 93     // So we should check for that attribute here.
 94     rowRange.second = axRowSpanWithRowIndex(rowRange.first);
 95 }
 96 
 97 unsigned AccessibilityARIAGridCell::axRowSpanWithRowIndex(unsigned rowIndex) const
 98 {
 99     int rowSpan = AccessibilityTableCell::axRowSpan();
100     if (rowSpan == -1) {
101         std::pair&lt;unsigned, unsigned&gt; range;
102         AccessibilityTableCell::rowIndexRange(range);
103         return std::max(static_cast&lt;int&gt;(range.second), 1);
104     }
105 
<span class="line-modified">106     AXCoreObject* parent = parentObjectUnignored();</span>
107     if (!parent)
108         return 1;
109 
110     // Setting the value to 0 indicates that the cell or gridcell is to span all the remaining rows in the row group.
111     if (!rowSpan) {
112         // rowSpan defaults to 1.
113         rowSpan = 1;
114         if (AccessibilityObject* parentRowGroup = this-&gt;parentRowGroup()) {
115             // If the row group is the parent table, we use total row count to calculate the span.
116             if (is&lt;AccessibilityTable&gt;(*parentRowGroup))
117                 rowSpan = downcast&lt;AccessibilityTable&gt;(*parentRowGroup).rowCount() - rowIndex;
118             // Otherwise, we have to get the index for the current row within the parent row group.
119             else if (is&lt;AccessibilityTableRow&gt;(*parent)) {
120                 const auto&amp; siblings = parentRowGroup-&gt;children();
121                 unsigned rowCount = siblings.size();
122                 for (unsigned k = 0; k &lt; rowCount; ++k) {
123                     if (siblings[k].get() == parent) {
124                         rowSpan = rowCount - k;
125                         break;
126                     }
127                 }
128             }
129         }
130     }
131 
132     return rowSpan;
133 }
134 
135 void AccessibilityARIAGridCell::columnIndexRange(std::pair&lt;unsigned, unsigned&gt;&amp; columnRange) const
136 {
<span class="line-modified">137     AXCoreObject* parent = parentObjectUnignored();</span>
138     if (!parent)
139         return;
140 
141     if (!is&lt;AccessibilityTableRow&gt;(*parent)
142         &amp;&amp; !(is&lt;AccessibilityTable&gt;(*parent) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*parent).isExposableThroughAccessibility()))
143         return;
144 
145     const AccessibilityChildrenVector&amp; siblings = parent-&gt;children();
146     unsigned childrenSize = siblings.size();
147     unsigned indexWithSpan = 0;
148     for (unsigned k = 0; k &lt; childrenSize; ++k) {
149         auto child = siblings[k].get();
150         if (child == this) {
151             columnRange.first = indexWithSpan;
152             break;
153         }
154         indexWithSpan += is&lt;AccessibilityTableCell&gt;(*child) ? std::max(downcast&lt;AccessibilityTableCell&gt;(*child).axColumnSpan(), 1) : 1;
155     }
156 
157     // ARIA 1.1, aria-colspan attribute is intended for cells and gridcells which are not contained in a native table.
</pre>
</td>
</tr>
</table>
<center><a href="AccessibilityARIAGrid.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityARIAGridRow.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
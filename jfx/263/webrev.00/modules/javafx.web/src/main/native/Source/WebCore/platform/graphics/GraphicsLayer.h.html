<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsLayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Color.h&quot;
 29 #include &quot;EventRegion.h&quot;
 30 #include &quot;FilterOperations.h&quot;
 31 #include &quot;FloatPoint.h&quot;
 32 #include &quot;FloatPoint3D.h&quot;
 33 #include &quot;FloatRoundedRect.h&quot;
 34 #include &quot;FloatSize.h&quot;
 35 #include &quot;GraphicsLayerClient.h&quot;
 36 #include &quot;Path.h&quot;
 37 #include &quot;PlatformLayer.h&quot;
 38 #include &quot;Region.h&quot;
 39 #include &quot;ScrollableArea.h&quot;
 40 #include &quot;TimingFunction.h&quot;
 41 #include &quot;TransformOperations.h&quot;
 42 #include &quot;WindRule.h&quot;
 43 #include &lt;wtf/Function.h&gt;
 44 #include &lt;wtf/TypeCasts.h&gt;
 45 
 46 #if ENABLE(CSS_COMPOSITING)
 47 #include &quot;GraphicsTypes.h&quot;
 48 #endif
 49 
 50 namespace WTF {
 51 class TextStream;
 52 }
 53 
 54 namespace WebCore {
 55 
 56 class Animation;
 57 class GraphicsContext;
 58 class GraphicsLayerFactory;
 59 class Image;
 60 class TiledBacking;
 61 class TimingFunction;
 62 class TransformationMatrix;
 63 
 64 namespace DisplayList {
 65 typedef unsigned AsTextFlags;
 66 }
 67 
 68 // Base class for animation values (also used for transitions). Here to
 69 // represent values for properties being animated via the GraphicsLayer,
 70 // without pulling in style-related data from outside of the platform directory.
 71 // FIXME: Should be moved to its own header file.
 72 class AnimationValue {
 73     WTF_MAKE_FAST_ALLOCATED;
 74 public:
 75     virtual ~AnimationValue() = default;
 76 
 77     double keyTime() const { return m_keyTime; }
 78     const TimingFunction* timingFunction() const { return m_timingFunction.get(); }
 79     virtual std::unique_ptr&lt;AnimationValue&gt; clone() const = 0;
 80 
 81 protected:
 82     AnimationValue(double keyTime, TimingFunction* timingFunction = nullptr)
 83         : m_keyTime(keyTime)
 84         , m_timingFunction(timingFunction)
 85     {
 86     }
 87 
 88     AnimationValue(const AnimationValue&amp; other)
 89         : m_keyTime(other.m_keyTime)
 90         , m_timingFunction(other.m_timingFunction ? RefPtr&lt;TimingFunction&gt; { other.m_timingFunction-&gt;clone() } : nullptr)
 91     {
 92     }
 93 
 94     AnimationValue(AnimationValue&amp;&amp;) = default;
 95 
 96 private:
 97     void operator=(const AnimationValue&amp;) = delete;
 98 
 99     double m_keyTime;
100     RefPtr&lt;TimingFunction&gt; m_timingFunction;
101 };
102 
103 // Used to store one float value of an animation.
104 // FIXME: Should be moved to its own header file.
105 class FloatAnimationValue : public AnimationValue {
106 public:
107     FloatAnimationValue(double keyTime, float value, TimingFunction* timingFunction = nullptr)
108         : AnimationValue(keyTime, timingFunction)
109         , m_value(value)
110     {
111     }
112 
113     std::unique_ptr&lt;AnimationValue&gt; clone() const override
114     {
115         return makeUnique&lt;FloatAnimationValue&gt;(*this);
116     }
117 
118     float value() const { return m_value; }
119 
120 private:
121     float m_value;
122 };
123 
124 // Used to store one transform value in a keyframe list.
125 // FIXME: Should be moved to its own header file.
126 class TransformAnimationValue : public AnimationValue {
127 public:
128     TransformAnimationValue(double keyTime, const TransformOperations&amp; value, TimingFunction* timingFunction = nullptr)
129         : AnimationValue(keyTime, timingFunction)
130         , m_value(value)
131     {
132     }
133 
134     std::unique_ptr&lt;AnimationValue&gt; clone() const override
135     {
136         return makeUnique&lt;TransformAnimationValue&gt;(*this);
137     }
138 
139     TransformAnimationValue(const TransformAnimationValue&amp; other)
140         : AnimationValue(other)
141     {
142         m_value.operations().reserveInitialCapacity(other.m_value.operations().size());
143         for (auto&amp; operation : other.m_value.operations())
144             m_value.operations().uncheckedAppend(operation-&gt;clone());
145     }
146 
147     TransformAnimationValue(TransformAnimationValue&amp;&amp;) = default;
148 
149     const TransformOperations&amp; value() const { return m_value; }
150 
151 private:
152     TransformOperations m_value;
153 };
154 
155 // Used to store one filter value in a keyframe list.
156 // FIXME: Should be moved to its own header file.
157 class FilterAnimationValue : public AnimationValue {
158 public:
159     FilterAnimationValue(double keyTime, const FilterOperations&amp; value, TimingFunction* timingFunction = nullptr)
160         : AnimationValue(keyTime, timingFunction)
161         , m_value(value)
162     {
163     }
164 
165     std::unique_ptr&lt;AnimationValue&gt; clone() const override
166     {
167         return makeUnique&lt;FilterAnimationValue&gt;(*this);
168     }
169 
170     FilterAnimationValue(const FilterAnimationValue&amp; other)
171         : AnimationValue(other)
172     {
173         m_value.operations().reserveInitialCapacity(other.m_value.operations().size());
174         for (auto&amp; operation : other.m_value.operations())
175             m_value.operations().uncheckedAppend(operation-&gt;clone());
176     }
177 
178     FilterAnimationValue(FilterAnimationValue&amp;&amp;) = default;
179 
180     const FilterOperations&amp; value() const { return m_value; }
181 
182 private:
183     FilterOperations m_value;
184 };
185 
186 // Used to store a series of values in a keyframe list.
187 // Values will all be of the same type, which can be inferred from the property.
188 // FIXME: Should be moved to its own header file.
189 class KeyframeValueList {
190 public:
191     explicit KeyframeValueList(AnimatedPropertyID property)
192         : m_property(property)
193     {
194     }
195 
196     KeyframeValueList(const KeyframeValueList&amp; other)
197         : m_property(other.property())
198     {
199         m_values.reserveInitialCapacity(other.m_values.size());
200         for (auto&amp; value : other.m_values)
201             m_values.uncheckedAppend(value-&gt;clone());
202     }
203 
204     KeyframeValueList(KeyframeValueList&amp;&amp;) = default;
205 
206     KeyframeValueList&amp; operator=(const KeyframeValueList&amp; other)
207     {
208         KeyframeValueList copy(other);
209         swap(copy);
210         return *this;
211     }
212 
213     KeyframeValueList&amp; operator=(KeyframeValueList&amp;&amp;) = default;
214 
215     void swap(KeyframeValueList&amp; other)
216     {
217         std::swap(m_property, other.m_property);
218         m_values.swap(other.m_values);
219     }
220 
221     AnimatedPropertyID property() const { return m_property; }
222 
223     size_t size() const { return m_values.size(); }
224     const AnimationValue&amp; at(size_t i) const { return *m_values.at(i); }
225 
226     // Insert, sorted by keyTime.
227     WEBCORE_EXPORT void insert(std::unique_ptr&lt;const AnimationValue&gt;);
228 
229 protected:
230     Vector&lt;std::unique_ptr&lt;const AnimationValue&gt;&gt; m_values;
231     AnimatedPropertyID m_property;
232 };
233 
234 // GraphicsLayer is an abstraction for a rendering surface with backing store,
235 // which may have associated transformation and animations.
236 
237 class GraphicsLayer : public RefCounted&lt;GraphicsLayer&gt; {
238     WTF_MAKE_FAST_ALLOCATED;
239 public:
240     enum class Type : uint8_t {
241         Normal,
242         PageTiledBacking,
243         ScrollContainer,
244         ScrolledContents,
245         Shape
246     };
247 
248     WEBCORE_EXPORT static Ref&lt;GraphicsLayer&gt; create(GraphicsLayerFactory*, GraphicsLayerClient&amp;, Type = Type::Normal);
249 
250     WEBCORE_EXPORT virtual ~GraphicsLayer();
251 
252     // Unparent, clear the client, and clear the RefPtr.
253     WEBCORE_EXPORT static void unparentAndClear(RefPtr&lt;GraphicsLayer&gt;&amp;);
254     // Clear the client, and clear the RefPtr, but leave parented.
255     WEBCORE_EXPORT static void clear(RefPtr&lt;GraphicsLayer&gt;&amp;);
256 
257     WEBCORE_EXPORT void clearClient();
258     WEBCORE_EXPORT void setClient(GraphicsLayerClient&amp;);
259 
260     Type type() const { return m_type; }
261 
262     virtual void initialize(Type) { }
263 
264     using PlatformLayerID = uint64_t;
265     virtual PlatformLayerID primaryLayerID() const { return 0; }
266 
267     GraphicsLayerClient&amp; client() const { return *m_client; }
268 
269     // Layer name. Only used to identify layers in debug output
270     const String&amp; name() const { return m_name; }
271     virtual void setName(const String&amp; name) { m_name = name; }
272     virtual String debugName() const;
273 
274     GraphicsLayer* parent() const { return m_parent; };
275     void setParent(GraphicsLayer*); // Internal use only.
276 
277     // Returns true if the layer has the given layer as an ancestor (excluding self).
278     bool hasAncestor(GraphicsLayer*) const;
279 
280     const Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; children() const { return m_children; }
281     Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; children() { return m_children; }
282 
283     // Returns true if the child list changed.
284     WEBCORE_EXPORT virtual bool setChildren(Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp;&amp;);
285 
286     // Add child layers. If the child is already parented, it will be removed from its old parent.
287     WEBCORE_EXPORT virtual void addChild(Ref&lt;GraphicsLayer&gt;&amp;&amp;);
288     WEBCORE_EXPORT virtual void addChildAtIndex(Ref&lt;GraphicsLayer&gt;&amp;&amp;, int index);
289     WEBCORE_EXPORT virtual void addChildAbove(Ref&lt;GraphicsLayer&gt;&amp;&amp;, GraphicsLayer* sibling);
290     WEBCORE_EXPORT virtual void addChildBelow(Ref&lt;GraphicsLayer&gt;&amp;&amp;, GraphicsLayer* sibling);
291     WEBCORE_EXPORT virtual bool replaceChild(GraphicsLayer* oldChild, Ref&lt;GraphicsLayer&gt;&amp;&amp; newChild);
292 
293     WEBCORE_EXPORT void removeAllChildren();
294     WEBCORE_EXPORT virtual void removeFromParent();
295 
296     // The parent() of a maskLayer is set to the layer being masked.
297     GraphicsLayer* maskLayer() const { return m_maskLayer.get(); }
298     virtual void setMaskLayer(RefPtr&lt;GraphicsLayer&gt;&amp;&amp;);
299 
300     void setIsMaskLayer(bool isMask) { m_isMaskLayer = isMask; }
301     bool isMaskLayer() const { return m_isMaskLayer; }
302 
303     // The given layer will replicate this layer and its children; the replica renders behind this layer.
304     WEBCORE_EXPORT virtual void setReplicatedByLayer(RefPtr&lt;GraphicsLayer&gt;&amp;&amp;);
305     // Whether this layer is being replicated by another layer.
306     bool isReplicated() const { return m_replicaLayer; }
307     // The layer that replicates this layer (if any).
308     GraphicsLayer* replicaLayer() const { return m_replicaLayer.get(); }
309 
310     const FloatPoint&amp; replicatedLayerPosition() const { return m_replicatedLayerPosition; }
311     void setReplicatedLayerPosition(const FloatPoint&amp; p) { m_replicatedLayerPosition = p; }
312 
313     enum ShouldSetNeedsDisplay {
314         DontSetNeedsDisplay,
315         SetNeedsDisplay
316     };
317 
318     // Offset is origin of the renderer minus origin of the graphics layer.
319     FloatSize offsetFromRenderer() const { return m_offsetFromRenderer; }
320     void setOffsetFromRenderer(const FloatSize&amp;, ShouldSetNeedsDisplay = SetNeedsDisplay);
321 
322     // Scroll offset of the content layer inside its scrolling parent layer.
323     ScrollOffset scrollOffset() const { return m_scrollOffset; }
324     void setScrollOffset(const ScrollOffset&amp;, ShouldSetNeedsDisplay = SetNeedsDisplay);
325 
326     // The position of the layer (the location of its top-left corner in its parent)
327     const FloatPoint&amp; position() const { return m_position; }
328     virtual void setPosition(const FloatPoint&amp; p) { m_approximatePosition = WTF::nullopt; m_position = p; }
329 
330     // approximatePosition, if set, overrides position() and is used during coverage rect computation.
331     FloatPoint approximatePosition() const { return m_approximatePosition ? m_approximatePosition.value() : m_position; }
332     virtual void setApproximatePosition(const FloatPoint&amp; p) { m_approximatePosition = p; }
333 
334     // For platforms that move underlying platform layers on a different thread for scrolling; just update the GraphicsLayer state.
335     virtual void syncPosition(const FloatPoint&amp; p) { m_position = p; }
336 
337     // Anchor point: (0, 0) is top left, (1, 1) is bottom right. The anchor point
338     // affects the origin of the transforms.
339     const FloatPoint3D&amp; anchorPoint() const { return m_anchorPoint; }
340     virtual void setAnchorPoint(const FloatPoint3D&amp; p) { m_anchorPoint = p; }
341 
342     // The size of the layer.
343     const FloatSize&amp; size() const { return m_size; }
344     WEBCORE_EXPORT virtual void setSize(const FloatSize&amp;);
345 
346     // The boundOrigin affects the offset at which content is rendered, and sublayers are positioned.
347     const FloatPoint&amp; boundsOrigin() const { return m_boundsOrigin; }
348     virtual void setBoundsOrigin(const FloatPoint&amp; origin) { m_boundsOrigin = origin; }
349 
350     // For platforms that move underlying platform layers on a different thread for scrolling; just update the GraphicsLayer state.
351     virtual void syncBoundsOrigin(const FloatPoint&amp; origin) { m_boundsOrigin = origin; }
352 
353     const TransformationMatrix&amp; transform() const;
354     virtual void setTransform(const TransformationMatrix&amp;);
355     bool hasNonIdentityTransform() const { return m_transform &amp;&amp; !m_transform-&gt;isIdentity(); }
356 
357     const TransformationMatrix&amp; childrenTransform() const;
358     virtual void setChildrenTransform(const TransformationMatrix&amp;);
359     bool hasNonIdentityChildrenTransform() const { return m_childrenTransform &amp;&amp; !m_childrenTransform-&gt;isIdentity(); }
360 
361     bool preserves3D() const { return m_preserves3D; }
362     virtual void setPreserves3D(bool b) { m_preserves3D = b; }
363 
364     bool masksToBounds() const { return m_masksToBounds; }
365     virtual void setMasksToBounds(bool b) { m_masksToBounds = b; }
366 
367     bool drawsContent() const { return m_drawsContent; }
368     virtual void setDrawsContent(bool b) { m_drawsContent = b; }
369 
370     bool contentsAreVisible() const { return m_contentsVisible; }
371     virtual void setContentsVisible(bool b) { m_contentsVisible = b; }
372 
373     bool userInteractionEnabled() const { return m_userInteractionEnabled; }
374     virtual void setUserInteractionEnabled(bool b) { m_userInteractionEnabled = b; }
375 
376     bool acceleratesDrawing() const { return m_acceleratesDrawing; }
377     virtual void setAcceleratesDrawing(bool b) { m_acceleratesDrawing = b; }
378 
379     bool usesDisplayListDrawing() const { return m_usesDisplayListDrawing; }
380     virtual void setUsesDisplayListDrawing(bool b) { m_usesDisplayListDrawing = b; }
381 
382     bool needsBackdrop() const { return !m_backdropFilters.isEmpty(); }
383 
384     // The color used to paint the layer background. Pass an invalid color to remove it.
385     // Note that this covers the entire layer. Use setContentsToSolidColor() if the color should
386     // only cover the contentsRect.
387     const Color&amp; backgroundColor() const { return m_backgroundColor; }
388     WEBCORE_EXPORT virtual void setBackgroundColor(const Color&amp;);
389 
390     // opaque means that we know the layer contents have no alpha
391     bool contentsOpaque() const { return m_contentsOpaque; }
392     virtual void setContentsOpaque(bool b) { m_contentsOpaque = b; }
393 
394     bool supportsSubpixelAntialiasedText() const { return m_supportsSubpixelAntialiasedText; }
395     virtual void setSupportsSubpixelAntialiasedText(bool b) { m_supportsSubpixelAntialiasedText = b; }
396 
397     bool backfaceVisibility() const { return m_backfaceVisibility; }
398     virtual void setBackfaceVisibility(bool b) { m_backfaceVisibility = b; }
399 
400     float opacity() const { return m_opacity; }
401     virtual void setOpacity(float opacity) { m_opacity = opacity; }
402 
403     const FilterOperations&amp; filters() const { return m_filters; }
404     // Returns true if filter can be rendered by the compositor.
405     virtual bool setFilters(const FilterOperations&amp; filters) { m_filters = filters; return true; }
406 
407     const FilterOperations&amp; backdropFilters() const { return m_backdropFilters; }
408     virtual bool setBackdropFilters(const FilterOperations&amp; filters) { m_backdropFilters = filters; return true; }
409 
410     virtual void setBackdropFiltersRect(const FloatRoundedRect&amp; backdropFiltersRect) { m_backdropFiltersRect = backdropFiltersRect; }
411     const FloatRoundedRect&amp; backdropFiltersRect() const { return m_backdropFiltersRect; }
412 
413 #if ENABLE(CSS_COMPOSITING)
414     BlendMode blendMode() const { return m_blendMode; }
415     virtual void setBlendMode(BlendMode blendMode) { m_blendMode = blendMode; }
416 #endif
417 
418     // Some GraphicsLayers paint only the foreground or the background content
419     OptionSet&lt;GraphicsLayerPaintingPhase&gt; paintingPhase() const { return m_paintingPhase; }
420     void setPaintingPhase(OptionSet&lt;GraphicsLayerPaintingPhase&gt;);
421 
422     enum ShouldClipToLayer {
423         DoNotClipToLayer,
424         ClipToLayer
425     };
426 
427     virtual void setNeedsDisplay() = 0;
428     // mark the given rect (in layer coords) as needing dispay. Never goes deep.
429     virtual void setNeedsDisplayInRect(const FloatRect&amp;, ShouldClipToLayer = ClipToLayer) = 0;
430 
431     virtual void setContentsNeedsDisplay() { };
432 
433     // The tile phase is relative to the GraphicsLayer bounds.
434     virtual void setContentsTilePhase(const FloatSize&amp; p) { m_contentsTilePhase = p; }
435     FloatSize contentsTilePhase() const { return m_contentsTilePhase; }
436 
437     virtual void setContentsTileSize(const FloatSize&amp; s) { m_contentsTileSize = s; }
438     FloatSize contentsTileSize() const { return m_contentsTileSize; }
439     bool hasContentsTiling() const { return !m_contentsTileSize.isEmpty(); }
440 
441     // Set that the position/size of the contents (image or video).
442     FloatRect contentsRect() const { return m_contentsRect; }
443     virtual void setContentsRect(const FloatRect&amp; r) { m_contentsRect = r; }
444 
445     // Set a rounded rect that will be used to clip the layer contents.
446     FloatRoundedRect contentsClippingRect() const { return m_contentsClippingRect; }
447     virtual void setContentsClippingRect(const FloatRoundedRect&amp; roundedRect) { m_contentsClippingRect = roundedRect; }
448 
449     // Set a rounded rect that is used to clip this layer and its descendants (implies setting masksToBounds).
450     // Returns false if the platform can&#39;t support this rounded clip, and we should fall back to painting a mask.
451     FloatRoundedRect maskToBoundsRect() const { return m_masksToBoundsRect; };
452     virtual bool setMasksToBoundsRect(const FloatRoundedRect&amp; roundedRect) { m_masksToBoundsRect = roundedRect; return false; }
453 
454     Path shapeLayerPath() const;
455     virtual void setShapeLayerPath(const Path&amp;);
456 
457     WindRule shapeLayerWindRule() const;
458     virtual void setShapeLayerWindRule(WindRule);
459 
460     const EventRegion&amp; eventRegion() const { return m_eventRegion; }
461     virtual void setEventRegion(EventRegion&amp;&amp;);
462 
463     // Transitions are identified by a special animation name that cannot clash with a keyframe identifier.
464     static String animationNameForTransition(AnimatedPropertyID);
465 
466     // Return true if the animation is handled by the compositing system. If this returns
467     // false, the animation will be run by CSSAnimationController.
468     // These methods handle both transitions and keyframe animations.
469     virtual bool addAnimation(const KeyframeValueList&amp;, const FloatSize&amp; /*boxSize*/, const Animation*, const String&amp; /*animationName*/, double /*timeOffset*/)  { return false; }
470     virtual void pauseAnimation(const String&amp; /*animationName*/, double /*timeOffset*/) { }
471     virtual void seekAnimation(const String&amp; /*animationName*/, double /*timeOffset*/) { }
472     virtual void removeAnimation(const String&amp; /*animationName*/) { }
473 
474     WEBCORE_EXPORT virtual void suspendAnimations(MonotonicTime);
475     WEBCORE_EXPORT virtual void resumeAnimations();
476 
477     virtual Vector&lt;std::pair&lt;String, double&gt;&gt; acceleratedAnimationsForTesting() const { return { }; }
478 
479     // Layer contents
480     virtual void setContentsToImage(Image*) { }
481     virtual bool shouldDirectlyCompositeImage(Image*) const { return true; }
482 #if PLATFORM(IOS_FAMILY)
483     virtual PlatformLayer* contentsLayerForMedia() const { return 0; }
484 #endif
485 
486     enum class ContentsLayerPurpose : uint8_t {
487         None = 0,
488         Image,
489         Media,
490         Canvas,
491         BackgroundColor,
492         Plugin,
493         EmbeddedView
494     };
495 
496     enum class ContentsLayerEmbeddedViewType : uint8_t {
497         None = 0,
498         EditableImage,
499     };
500 
501     using EmbeddedViewID = uint64_t;
502     static EmbeddedViewID nextEmbeddedViewID();
503 
504     // Pass an invalid color to remove the contents layer.
505     virtual void setContentsToSolidColor(const Color&amp;) { }
506     virtual void setContentsToEmbeddedView(GraphicsLayer::ContentsLayerEmbeddedViewType, EmbeddedViewID) { }
507     virtual void setContentsToPlatformLayer(PlatformLayer*, ContentsLayerPurpose) { }
508     virtual bool usesContentsLayer() const { return false; }
509 
510     // Callback from the underlying graphics system to draw layer contents.
511     void paintGraphicsLayerContents(GraphicsContext&amp;, const FloatRect&amp; clip, GraphicsLayerPaintBehavior = GraphicsLayerPaintNormal);
512 
513     // For hosting this GraphicsLayer in a native layer hierarchy.
514     virtual PlatformLayer* platformLayer() const { return 0; }
515 
516     enum class CompositingCoordinatesOrientation : uint8_t { TopDown, BottomUp };
517 
518     // Flippedness of the contents of this layer. Does not affect sublayer geometry.
519     virtual void setContentsOrientation(CompositingCoordinatesOrientation orientation) { m_contentsOrientation = orientation; }
520     CompositingCoordinatesOrientation contentsOrientation() const { return m_contentsOrientation; }
521 
522     void dumpLayer(WTF::TextStream&amp;, LayerTreeAsTextBehavior = LayerTreeAsTextBehaviorNormal) const;
523 
524     virtual void setShowDebugBorder(bool show) { m_showDebugBorder = show; }
525     bool isShowingDebugBorder() const { return m_showDebugBorder; }
526 
527     virtual void setShowRepaintCounter(bool show) { m_showRepaintCounter = show; }
528     bool isShowingRepaintCounter() const { return m_showRepaintCounter; }
529 
530     // FIXME: this is really a paint count.
531     int repaintCount() const { return m_repaintCount; }
532     int incrementRepaintCount() { return ++m_repaintCount; }
533 
534     virtual void setDebugBackgroundColor(const Color&amp;) { }
535     virtual void setDebugBorder(const Color&amp;, float /*borderWidth*/) { }
536 
537     enum class CustomAppearance : uint8_t {
538         None,
539         ScrollingOverhang,
540         ScrollingShadow,
541         LightBackdrop,
542         DarkBackdrop
543     };
544     virtual void setCustomAppearance(CustomAppearance customAppearance) { m_customAppearance = customAppearance; }
545     CustomAppearance customAppearance() const { return m_customAppearance; }
546 
547     // z-position is the z-equivalent of position(). It&#39;s only used for debugging purposes.
548     virtual float zPosition() const { return m_zPosition; }
549     WEBCORE_EXPORT virtual void setZPosition(float);
550 
551     WEBCORE_EXPORT virtual void distributeOpacity(float);
552     WEBCORE_EXPORT virtual float accumulatedOpacity() const;
553 
554     virtual FloatSize pixelAlignmentOffset() const { return FloatSize(); }
555 
556     virtual void setAppliesPageScale(bool appliesScale = true) { m_appliesPageScale = appliesScale; }
557     virtual bool appliesPageScale() const { return m_appliesPageScale; }
558 
559     float pageScaleFactor() const { return client().pageScaleFactor(); }
560     float deviceScaleFactor() const { return client().deviceScaleFactor(); }
561 
562     // Whether this layer can throw away backing store to save memory. False for layers that can be revealed by async scrolling.
563     virtual void setAllowsBackingStoreDetaching(bool) { }
564     virtual bool allowsBackingStoreDetaching() const { return true; }
565 
566     virtual void deviceOrPageScaleFactorChanged() { }
567     WEBCORE_EXPORT void noteDeviceOrPageScaleFactorChangedIncludingDescendants();
568 
569     void setIsInWindow(bool);
570 
571     // Some compositing systems may do internal batching to synchronize compositing updates
572     // with updates drawn into the window. These methods flush internal batched state on this layer
573     // and descendant layers, and this layer only.
574     virtual void flushCompositingState(const FloatRect&amp; /* clipRect */) { }
575     virtual void flushCompositingStateForThisLayerOnly() { }
576 
577     // If the exposed rect of this layer changes, returns true if this or descendant layers need a flush,
578     // for example to allocate new tiles.
579     virtual bool visibleRectChangeRequiresFlush(const FloatRect&amp; /* clipRect */) const { return false; }
580 
581     static FloatRect adjustCoverageRectForMovement(const FloatRect&amp; coverageRect, const FloatRect&amp; previousVisibleRect, const FloatRect&amp; currentVisibleRect);
582 
583     // Return a string with a human readable form of the layer tree, If debug is true
584     // pointers for the layers and timing data will be included in the returned string.
585     WEBCORE_EXPORT String layerTreeAsText(LayerTreeAsTextBehavior = LayerTreeAsTextBehaviorNormal) const;
586 
587     // For testing.
588     virtual String displayListAsText(DisplayList::AsTextFlags) const { return String(); }
589 
590     virtual void setIsTrackingDisplayListReplay(bool isTracking) { m_isTrackingDisplayListReplay = isTracking; }
591     virtual bool isTrackingDisplayListReplay() const { return m_isTrackingDisplayListReplay; }
592     virtual String replayDisplayListAsText(DisplayList::AsTextFlags) const { return String(); }
593 
594     // Return an estimate of the backing store memory cost (in bytes). May be incorrect for tiled layers.
595     WEBCORE_EXPORT virtual double backingStoreMemoryEstimate() const;
596 
597     virtual bool backingStoreAttached() const { return true; }
598     virtual bool backingStoreAttachedForTesting() const { return backingStoreAttached(); }
599 
600     virtual TiledBacking* tiledBacking() const { return 0; }
601 
602     void resetTrackedRepaints();
603     void addRepaintRect(const FloatRect&amp;);
604 
605     static bool supportsBackgroundColorContent();
606     static bool supportsLayerType(Type);
607     static bool supportsContentsTiling();
608     static bool supportsSubpixelAntialiasedLayerText();
609 
610     void updateDebugIndicators();
611 
612     virtual bool canThrottleLayerFlush() const { return false; }
613 
614     virtual bool isGraphicsLayerCA() const { return false; }
615     virtual bool isGraphicsLayerCARemote() const { return false; }
616     virtual bool isGraphicsLayerTextureMapper() const { return false; }
617     virtual bool isCoordinatedGraphicsLayer() const { return false; }
618 
619     const Optional&lt;FloatRect&gt;&amp; animationExtent() const { return m_animationExtent; }
620     void setAnimationExtent(Optional&lt;FloatRect&gt; animationExtent) { m_animationExtent = animationExtent; }
621 
622     static void traverse(GraphicsLayer&amp;, const WTF::Function&lt;void (GraphicsLayer&amp;)&gt;&amp;);
623 
624 protected:
625     WEBCORE_EXPORT explicit GraphicsLayer(Type, GraphicsLayerClient&amp;);
626 
627     // Should be called from derived class destructors. Should call willBeDestroyed() on super.
628     WEBCORE_EXPORT virtual void willBeDestroyed();
629     bool beingDestroyed() const { return m_beingDestroyed; }
630 
631     // This method is used by platform GraphicsLayer classes to clear the filters
632     // when compositing is not done in hardware. It is not virtual, so the caller
633     // needs to notifiy the change to the platform layer as needed.
634     void clearFilters() { m_filters.clear(); }
635     void clearBackdropFilters() { m_backdropFilters.clear(); }
636 
637     // Given a KeyframeValueList containing filterOperations, return true if the operations are valid.
638     static int validateFilterOperations(const KeyframeValueList&amp;);
639 
640     // Given a list of TransformAnimationValues, see if all the operations for each keyframe match. If so
641     // return the index of the KeyframeValueList entry that has that list of operations (it may not be
642     // the first entry because some keyframes might have an empty transform and those match any list).
643     // If the lists don&#39;t match return -1. On return, if hasBigRotation is true, functions contain
644     // rotations of &gt;= 180 degrees
645     static int validateTransformOperations(const KeyframeValueList&amp;, bool&amp; hasBigRotation);
646 
647     virtual bool shouldRepaintOnSizeChange() const { return drawsContent(); }
648 
649     virtual void setOpacityInternal(float) { }
650 
651     // The layer being replicated.
652     GraphicsLayer* replicatedLayer() const { return m_replicatedLayer; }
653     virtual void setReplicatedLayer(GraphicsLayer* layer) { m_replicatedLayer = layer; }
654 
655     void dumpProperties(WTF::TextStream&amp;, LayerTreeAsTextBehavior) const;
656     virtual void dumpAdditionalProperties(WTF::TextStream&amp;, LayerTreeAsTextBehavior) const { }
657 
658     WEBCORE_EXPORT virtual void getDebugBorderInfo(Color&amp;, float&amp; width) const;
659 
660     GraphicsLayerClient* m_client; // Always non-null.
661     String m_name;
662 
663     // Offset from the owning renderer
664     FloatSize m_offsetFromRenderer;
665 
666     // Scroll offset of the content layer inside its scrolling parent layer.
667     ScrollOffset m_scrollOffset;
668 
669     // Position is relative to the parent GraphicsLayer
670     FloatPoint m_position;
671 
672     // If set, overrides m_position. Only used for coverage computation.
673     Optional&lt;FloatPoint&gt; m_approximatePosition;
674 
675     FloatPoint3D m_anchorPoint { 0.5f, 0.5f, 0 };
676     FloatSize m_size;
677     FloatPoint m_boundsOrigin;
678 
679     std::unique_ptr&lt;TransformationMatrix&gt; m_transform;
680     std::unique_ptr&lt;TransformationMatrix&gt; m_childrenTransform;
681 
682     Color m_backgroundColor;
683     float m_opacity { 1 };
684     float m_zPosition { 0 };
685 
686     FilterOperations m_filters;
687     FilterOperations m_backdropFilters;
688 
689 #if ENABLE(CSS_COMPOSITING)
690     BlendMode m_blendMode { BlendMode::Normal };
691 #endif
692 
693     const Type m_type;
694     CustomAppearance m_customAppearance { CustomAppearance::None };
695     OptionSet&lt;GraphicsLayerPaintingPhase&gt; m_paintingPhase { GraphicsLayerPaintingPhase::Foreground, GraphicsLayerPaintingPhase::Background };
696     CompositingCoordinatesOrientation m_contentsOrientation { CompositingCoordinatesOrientation::TopDown }; // affects orientation of layer contents
697 
698     bool m_beingDestroyed : 1;
699     bool m_contentsOpaque : 1;
700     bool m_supportsSubpixelAntialiasedText : 1;
701     bool m_preserves3D: 1;
702     bool m_backfaceVisibility : 1;
703     bool m_masksToBounds : 1;
704     bool m_drawsContent : 1;
705     bool m_contentsVisible : 1;
706     bool m_acceleratesDrawing : 1;
707     bool m_usesDisplayListDrawing : 1;
708     bool m_appliesPageScale : 1; // Set for the layer which has the page scale applied to it.
709     bool m_showDebugBorder : 1;
710     bool m_showRepaintCounter : 1;
711     bool m_isMaskLayer : 1;
712     bool m_isTrackingDisplayListReplay : 1;
713     bool m_userInteractionEnabled : 1;
714     bool m_canDetachBackingStore : 1;
715 
716     int m_repaintCount { 0 };
717 
718     Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; m_children;
719     GraphicsLayer* m_parent { nullptr };
720 
721     RefPtr&lt;GraphicsLayer&gt; m_maskLayer { nullptr }; // Reference to mask layer.
722 
723     RefPtr&lt;GraphicsLayer&gt; m_replicaLayer { nullptr }; // A layer that replicates this layer. We only allow one, for now.
724                                    // The replica is not parented; this is the primary reference to it.
725     GraphicsLayer* m_replicatedLayer { nullptr }; // For a replica layer, a reference to the original layer.
726     FloatPoint m_replicatedLayerPosition; // For a replica layer, the position of the replica.
727 
728     FloatRect m_contentsRect;
729     FloatRoundedRect m_contentsClippingRect;
730     FloatRoundedRect m_masksToBoundsRect;
731     FloatSize m_contentsTilePhase;
732     FloatSize m_contentsTileSize;
733     FloatRoundedRect m_backdropFiltersRect;
734     Optional&lt;FloatRect&gt; m_animationExtent;
735 
736     EventRegion m_eventRegion;
737 #if USE(CA)
738     WindRule m_shapeLayerWindRule { WindRule::NonZero };
739     Path m_shapeLayerPath;
740 #endif
741 };
742 
743 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const WebCore::GraphicsLayerPaintingPhase);
744 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Vector&lt;GraphicsLayer::PlatformLayerID&gt;&amp;);
745 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const GraphicsLayer::CustomAppearance&amp;);
746 
747 } // namespace WebCore
748 
749 #define SPECIALIZE_TYPE_TRAITS_GRAPHICSLAYER(ToValueTypeName, predicate) \
750 SPECIALIZE_TYPE_TRAITS_BEGIN(ToValueTypeName) \
751     static bool isType(const WebCore::GraphicsLayer&amp; layer) { return layer.predicate; } \
752 SPECIALIZE_TYPE_TRAITS_END()
753 
754 #if ENABLE(TREE_DEBUGGING)
755 // Outside the WebCore namespace for ease of invocation from the debugger.
756 void showGraphicsLayerTree(const WebCore::GraphicsLayer* layer);
757 #endif
    </pre>
  </body>
</html>
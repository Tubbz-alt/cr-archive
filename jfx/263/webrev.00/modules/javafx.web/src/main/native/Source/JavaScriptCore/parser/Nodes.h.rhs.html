<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<a name="1" id="anc1"></a><span class="line-modified">   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   5  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   6  *  Copyright (C) 2007 Maks Orlovich
   7  *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   8  *
   9  *  This library is free software; you can redistribute it and/or
  10  *  modify it under the terms of the GNU Library General Public
  11  *  License as published by the Free Software Foundation; either
  12  *  version 2 of the License, or (at your option) any later version.
  13  *
  14  *  This library is distributed in the hope that it will be useful,
  15  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  *  Library General Public License for more details.
  18  *
  19  *  You should have received a copy of the GNU Library General Public License
  20  *  along with this library; see the file COPYING.LIB.  If not, write to
  21  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  *  Boston, MA 02110-1301, USA.
  23  *
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;BytecodeIntrinsicRegistry.h&quot;
  29 #include &quot;JITCode.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  30 #include &quot;Label.h&quot;</span>
  31 #include &quot;ParserArena.h&quot;
  32 #include &quot;ParserModes.h&quot;
  33 #include &quot;ParserTokens.h&quot;
  34 #include &quot;ResultType.h&quot;
  35 #include &quot;SourceCode.h&quot;
  36 #include &quot;SymbolTable.h&quot;
  37 #include &quot;VariableEnvironment.h&quot;
  38 #include &lt;wtf/MathExtras.h&gt;
  39 #include &lt;wtf/SmallPtrSet.h&gt;
  40 
  41 namespace JSC {
  42 
  43     enum OpcodeID : unsigned;
  44 
  45     class ArgumentListNode;
  46     class BytecodeGenerator;
  47     class FunctionMetadataNode;
  48     class FunctionParameters;
<a name="3" id="anc3"></a>
  49     class ModuleAnalyzer;
  50     class ModuleScopeData;
  51     class PropertyListNode;
  52     class ReadModifyResolveNode;
  53     class RegisterID;
  54     class ScopeNode;
  55 
  56     typedef SmallPtrSet&lt;UniquedStringImpl*&gt; UniquedStringImplPtrSet;
  57 
  58     enum Operator : uint8_t {
  59         OpEqual,
  60         OpPlusEq,
  61         OpMinusEq,
  62         OpMultEq,
  63         OpDivEq,
  64         OpPlusPlus,
  65         OpMinusMinus,
  66         OpAndEq,
  67         OpXOrEq,
  68         OpOrEq,
  69         OpModEq,
  70         OpPowEq,
  71         OpLShift,
  72         OpRShift,
  73         OpURShift
  74     };
  75 
  76     enum LogicalOperator : uint8_t {
  77         OpLogicalAnd,
  78         OpLogicalOr
  79     };
  80 
  81     enum FallThroughMode : uint8_t {
  82         FallThroughMeansTrue = 0,
  83         FallThroughMeansFalse = 1
  84     };
  85     inline FallThroughMode invert(FallThroughMode fallThroughMode) { return static_cast&lt;FallThroughMode&gt;(!fallThroughMode); }
  86 
  87     namespace DeclarationStacks {
  88         typedef Vector&lt;FunctionMetadataNode*&gt; FunctionStack;
  89     }
  90 
  91     struct SwitchInfo {
  92         enum SwitchType : uint8_t { SwitchNone, SwitchImmediate, SwitchCharacter, SwitchString };
  93         uint32_t bytecodeOffset;
  94         SwitchType switchType;
  95     };
  96 
  97     enum class AssignmentContext : uint8_t {
  98         DeclarationStatement,
  99         ConstDeclarationStatement,
 100         AssignmentExpression
 101     };
 102 
 103     class ParserArenaFreeable {
 104     public:
 105         // ParserArenaFreeable objects are freed when the arena is deleted.
 106         // Destructors are not called. Clients must not call delete on such objects.
 107         void* operator new(size_t, ParserArena&amp;);
 108     };
 109 
 110     class ParserArenaDeletable {
 111     public:
 112         virtual ~ParserArenaDeletable() { }
 113 
 114         // ParserArenaDeletable objects are deleted when the arena is deleted.
 115         // Clients must not call delete directly on such objects.
 116         template&lt;typename T&gt; void* operator new(size_t, ParserArena&amp;);
 117     };
 118 
 119 #define JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED_IMPL(__classToNew) \
 120         void* operator new(size_t size, ParserArena&amp; parserArena) \
 121         { \
 122             return ParserArenaDeletable::operator new&lt;__classToNew&gt;(size, parserArena); \
 123         }
 124 
 125 #define JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(__classToNew) \
 126     public: \
 127         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED_IMPL(__classToNew) \
 128     private: \
 129         typedef int __thisIsHereToForceASemicolonAfterThisMacro
 130 
<a name="4" id="anc4"></a><span class="line-added"> 131     DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ParserArenaRoot);</span>
 132     class ParserArenaRoot {
<a name="5" id="anc5"></a><span class="line-modified"> 133         WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(ParserArenaRoot);</span>
 134     protected:
 135         ParserArenaRoot(ParserArena&amp;);
 136 
 137     public:
 138         ParserArena&amp; parserArena() { return m_arena; }
 139         virtual ~ParserArenaRoot() { }
 140 
 141     protected:
 142         ParserArena m_arena;
 143     };
 144 
 145     class Node : public ParserArenaFreeable {
 146     protected:
 147         Node(const JSTokenLocation&amp;);
 148 
 149     public:
 150         virtual ~Node() { }
 151 
 152         int firstLine() const { return m_position.line; }
 153         int startOffset() const { return m_position.offset; }
 154         int endOffset() const { return m_endOffset; }
 155         int lineStartOffset() const { return m_position.lineStartOffset; }
 156         const JSTextPosition&amp; position() const { return m_position; }
 157         void setEndOffset(int offset) { m_endOffset = offset; }
 158         void setStartOffset(int offset) { m_position.offset = offset; }
 159 
 160         bool needsDebugHook() const { return m_needsDebugHook; }
 161         void setNeedsDebugHook() { m_needsDebugHook = true; }
 162 
 163     protected:
 164         JSTextPosition m_position;
 165         int m_endOffset { -1 };
 166         bool m_needsDebugHook { false };
 167     };
 168 
 169     class ExpressionNode : public Node {
 170     protected:
 171         ExpressionNode(const JSTokenLocation&amp;, ResultType = ResultType::unknownType());
 172 
 173     public:
 174         virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* destination = 0) = 0;
 175 
 176         virtual bool isNumber() const { return false; }
 177         virtual bool isString() const { return false; }
 178         virtual bool isBigInt() const { return false; }
 179         virtual bool isObjectLiteral() const { return false; }
 180         virtual bool isArrayLiteral() const { return false; }
 181         virtual bool isNull() const { return false; }
 182         virtual bool isPure(BytecodeGenerator&amp;) const { return false; }
 183         virtual bool isConstant() const { return false; }
 184         virtual bool isLocation() const { return false; }
 185         virtual bool isAssignmentLocation() const { return isLocation(); }
 186         virtual bool isResolveNode() const { return false; }
 187         virtual bool isAssignResolveNode() const { return false; }
 188         virtual bool isBracketAccessorNode() const { return false; }
 189         virtual bool isDotAccessorNode() const { return false; }
 190         virtual bool isDestructuringNode() const { return false; }
 191         virtual bool isBaseFuncExprNode() const { return false; }
 192         virtual bool isFuncExprNode() const { return false; }
 193         virtual bool isArrowFuncExprNode() const { return false; }
 194         virtual bool isClassExprNode() const { return false; }
 195         virtual bool isCommaNode() const { return false; }
 196         virtual bool isSimpleArray() const { return false; }
 197         virtual bool isAdd() const { return false; }
 198         virtual bool isSubtract() const { return false; }
 199         virtual bool isBoolean() const { return false; }
 200         virtual bool isSpreadExpression() const { return false; }
 201         virtual bool isSuperNode() const { return false; }
 202         virtual bool isImportNode() const { return false; }
 203         virtual bool isMetaProperty() const { return false; }
 204         virtual bool isNewTarget() const { return false; }
 205         virtual bool isImportMeta() const { return false; }
 206         virtual bool isBytecodeIntrinsicNode() const { return false; }
 207         virtual bool isBinaryOpNode() const { return false; }
 208         virtual bool isFunctionCall() const { return false; }
 209         virtual bool isDeleteNode() const { return false; }
 210         virtual bool isOptionalChain() const { return false; }
 211 
 212         virtual void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp;, Label&amp;, FallThroughMode);
 213 
 214         virtual ExpressionNode* stripUnaryPlus() { return this; }
 215 
 216         ResultType resultDescriptor() const { return m_resultType; }
 217 
 218         bool isOptionalChainBase() const { return m_isOptionalChainBase; }
 219         void setIsOptionalChainBase() { m_isOptionalChainBase = true; }
 220 
 221     private:
 222         ResultType m_resultType;
 223         bool m_isOptionalChainBase { false };
 224     };
 225 
 226     class StatementNode : public Node {
 227     protected:
 228         StatementNode(const JSTokenLocation&amp;);
 229 
 230     public:
 231         virtual void emitBytecode(BytecodeGenerator&amp;, RegisterID* destination = 0) = 0;
 232 
 233         void setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset);
 234         unsigned lastLine() const { return m_lastLine; }
 235 
 236         StatementNode* next() const { return m_next; }
 237         void setNext(StatementNode* next) { m_next = next; }
 238 
 239         virtual bool hasCompletionValue() const { return true; }
 240         virtual bool hasEarlyBreakOrContinue() const { return false; }
 241 
 242         virtual bool isEmptyStatement() const { return false; }
 243         virtual bool isDebuggerStatement() const { return false; }
 244         virtual bool isFunctionNode() const { return false; }
 245         virtual bool isReturnNode() const { return false; }
 246         virtual bool isExprStatement() const { return false; }
 247         virtual bool isBreak() const { return false; }
 248         virtual bool isContinue() const { return false; }
 249         virtual bool isLabel() const { return false; }
 250         virtual bool isBlock() const { return false; }
 251         virtual bool isFuncDeclNode() const { return false; }
 252         virtual bool isModuleDeclarationNode() const { return false; }
 253         virtual bool isForOfNode() const { return false; }
<a name="6" id="anc6"></a><span class="line-added"> 254         virtual bool isDefineFieldNode() const { return false; }</span>
 255 
 256     protected:
 257         int m_lastLine { -1 };
 258         StatementNode* m_next { nullptr };
 259     };
 260 
 261     class VariableEnvironmentNode : public ParserArenaDeletable {
 262         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(VariableEnvironmentNode);
 263     public:
 264         typedef DeclarationStacks::FunctionStack FunctionStack;
 265 
 266         VariableEnvironmentNode()
 267         {
 268         }
 269 
 270         VariableEnvironmentNode(VariableEnvironment&amp; lexicalDeclaredVariables);
 271         VariableEnvironmentNode(VariableEnvironment&amp; lexicalDeclaredVariables, FunctionStack&amp;&amp;);
 272 
 273         VariableEnvironment&amp; lexicalVariables() { return m_lexicalVariables; }
 274         FunctionStack&amp; functionStack() { return m_functionStack; }
 275 
 276     protected:
 277         VariableEnvironment m_lexicalVariables;
 278         FunctionStack m_functionStack;
 279     };
 280 
 281     class ConstantNode : public ExpressionNode {
 282     public:
 283         ConstantNode(const JSTokenLocation&amp;, ResultType);
 284         bool isPure(BytecodeGenerator&amp;) const override { return true; }
 285         bool isConstant() const  override { return true; }
 286         virtual JSValue jsValue(BytecodeGenerator&amp;) const = 0;
 287     private:
 288         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 289         void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode) override;
 290     };
 291 
 292     class NullNode final : public ConstantNode {
 293     public:
 294         NullNode(const JSTokenLocation&amp;);
 295 
 296     private:
 297         bool isNull() const override { return true; }
 298         JSValue jsValue(BytecodeGenerator&amp;) const override { return jsNull(); }
 299     };
 300 
 301     class BooleanNode final : public ConstantNode {
 302     public:
 303         BooleanNode(const JSTokenLocation&amp;, bool value);
 304         bool value() { return m_value; }
 305 
 306     private:
 307         bool isBoolean() const override { return true; }
 308         JSValue jsValue(BytecodeGenerator&amp;) const override { return jsBoolean(m_value); }
 309 
 310         bool m_value;
 311     };
 312 
 313     class NumberNode : public ConstantNode {
 314     public:
 315         NumberNode(const JSTokenLocation&amp;, double value);
 316         double value() const { return m_value; }
 317         virtual bool isIntegerNode() const = 0;
 318         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) final;
 319 
 320     private:
 321         bool isNumber() const final { return true; }
 322         JSValue jsValue(BytecodeGenerator&amp;) const override { return jsNumber(m_value); }
 323 
 324         double m_value;
 325     };
 326 
 327     class DoubleNode : public NumberNode {
 328     public:
 329         DoubleNode(const JSTokenLocation&amp;, double value);
 330 
 331     private:
 332         bool isIntegerNode() const override { return false; }
 333     };
 334 
 335     // An integer node represent a number represented as an integer (e.g. 42 instead of 42., 42.0, 42e0)
 336     class IntegerNode final : public DoubleNode {
 337     public:
 338         IntegerNode(const JSTokenLocation&amp;, double value);
 339         bool isIntegerNode() const final { return true; }
 340     };
 341 
 342     class StringNode final : public ConstantNode {
 343     public:
 344         StringNode(const JSTokenLocation&amp;, const Identifier&amp;);
 345         const Identifier&amp; value() { return m_value; }
 346 
 347     private:
 348         bool isString() const override { return true; }
 349         JSValue jsValue(BytecodeGenerator&amp;) const override;
 350 
 351         const Identifier&amp; m_value;
 352     };
 353 
 354     class BigIntNode final : public ConstantNode {
 355     public:
 356         BigIntNode(const JSTokenLocation&amp;, const Identifier&amp;, uint8_t radix);
 357         BigIntNode(const JSTokenLocation&amp;, const Identifier&amp;, uint8_t radix, bool sign);
 358         const Identifier&amp; value() { return m_value; }
 359 
 360         const Identifier&amp; identifier() const { return m_value; }
 361         uint8_t radix() const { return m_radix; }
 362         bool sign() const { return m_sign; }
 363 
 364     private:
 365         bool isBigInt() const final { return true; }
 366         JSValue jsValue(BytecodeGenerator&amp;) const final;
 367 
 368         const Identifier&amp; m_value;
 369         const uint8_t m_radix;
 370         const bool m_sign;
 371     };
 372 
 373     class ThrowableExpressionData {
 374     public:
<a name="7" id="anc7"></a><span class="line-modified"> 375         ThrowableExpressionData() = default;</span>





 376 
 377         ThrowableExpressionData(const JSTextPosition&amp; divot, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 378             : m_divot(divot)
 379             , m_divotStart(start)
 380             , m_divotEnd(end)
 381         {
<a name="8" id="anc8"></a><span class="line-modified"> 382             checkConsistency();</span>


 383         }
 384 
 385         void setExceptionSourceCode(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
 386         {
<a name="9" id="anc9"></a>


 387             m_divot = divot;
 388             m_divotStart = divotStart;
 389             m_divotEnd = divotEnd;
<a name="10" id="anc10"></a><span class="line-added"> 390             checkConsistency();</span>
 391         }
 392 
 393         const JSTextPosition&amp; divot() const { return m_divot; }
 394         const JSTextPosition&amp; divotStart() const { return m_divotStart; }
 395         const JSTextPosition&amp; divotEnd() const { return m_divotEnd; }
 396 
<a name="11" id="anc11"></a><span class="line-added"> 397         void checkConsistency() const</span>
<span class="line-added"> 398         {</span>
<span class="line-added"> 399             ASSERT(m_divot.offset &gt;= m_divot.lineStartOffset);</span>
<span class="line-added"> 400             ASSERT(m_divotStart.offset &gt;= m_divotStart.lineStartOffset);</span>
<span class="line-added"> 401             ASSERT(m_divotEnd.offset &gt;= m_divotEnd.lineStartOffset);</span>
<span class="line-added"> 402             ASSERT(m_divot.offset &gt;= m_divotStart.offset);</span>
<span class="line-added"> 403             ASSERT(m_divotEnd.offset &gt;= m_divot.offset);</span>
<span class="line-added"> 404         }</span>
 405     protected:
 406         RegisterID* emitThrowReferenceError(BytecodeGenerator&amp;, const String&amp; message);
 407 
 408     private:
 409         JSTextPosition m_divot;
 410         JSTextPosition m_divotStart;
 411         JSTextPosition m_divotEnd;
 412     };
 413 
 414     class ThrowableSubExpressionData : public ThrowableExpressionData {
 415     public:
 416         ThrowableSubExpressionData()
 417             : m_subexpressionDivotOffset(0)
 418             , m_subexpressionEndOffset(0)
 419             , m_subexpressionLineOffset(0)
 420             , m_subexpressionLineStartOffset(0)
 421         {
 422         }
 423 
 424         ThrowableSubExpressionData(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
 425             : ThrowableExpressionData(divot, divotStart, divotEnd)
 426             , m_subexpressionDivotOffset(0)
 427             , m_subexpressionEndOffset(0)
 428             , m_subexpressionLineOffset(0)
 429             , m_subexpressionLineStartOffset(0)
 430         {
 431         }
 432 
 433         void setSubexpressionInfo(const JSTextPosition&amp; subexpressionDivot, int subexpressionOffset)
 434         {
 435             ASSERT(subexpressionDivot.offset &lt;= divot().offset);
 436             // Overflow means we can&#39;t do this safely, so just point at the primary divot,
 437             // divotLine, or divotLineStart.
 438             if ((divot() - subexpressionDivot.offset) &amp; ~0xFFFF)
 439                 return;
 440             if ((divot().line - subexpressionDivot.line) &amp; ~0xFFFF)
 441                 return;
 442             if ((divot().lineStartOffset - subexpressionDivot.lineStartOffset) &amp; ~0xFFFF)
 443                 return;
 444             if ((divotEnd() - subexpressionOffset) &amp; ~0xFFFF)
 445                 return;
 446             m_subexpressionDivotOffset = divot() - subexpressionDivot.offset;
 447             m_subexpressionEndOffset = divotEnd() - subexpressionOffset;
 448             m_subexpressionLineOffset = divot().line - subexpressionDivot.line;
 449             m_subexpressionLineStartOffset = divot().lineStartOffset - subexpressionDivot.lineStartOffset;
 450         }
 451 
 452         JSTextPosition subexpressionDivot()
 453         {
 454             int newLine = divot().line - m_subexpressionLineOffset;
 455             int newOffset = divot().offset - m_subexpressionDivotOffset;
 456             int newLineStartOffset = divot().lineStartOffset - m_subexpressionLineStartOffset;
 457             return JSTextPosition(newLine, newOffset, newLineStartOffset);
 458         }
 459         JSTextPosition subexpressionStart() { return divotStart(); }
 460         JSTextPosition subexpressionEnd() { return divotEnd() - static_cast&lt;int&gt;(m_subexpressionEndOffset); }
 461 
 462     protected:
 463         uint16_t m_subexpressionDivotOffset;
 464         uint16_t m_subexpressionEndOffset;
 465         uint16_t m_subexpressionLineOffset;
 466         uint16_t m_subexpressionLineStartOffset;
 467     };
 468 
 469     class ThrowablePrefixedSubExpressionData : public ThrowableExpressionData {
 470     public:
 471         ThrowablePrefixedSubExpressionData()
 472             : m_subexpressionDivotOffset(0)
 473             , m_subexpressionStartOffset(0)
 474             , m_subexpressionLineOffset(0)
 475             , m_subexpressionLineStartOffset(0)
 476         {
 477         }
 478 
 479         ThrowablePrefixedSubExpressionData(const JSTextPosition&amp; divot, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 480             : ThrowableExpressionData(divot, start, end)
 481             , m_subexpressionDivotOffset(0)
 482             , m_subexpressionStartOffset(0)
 483             , m_subexpressionLineOffset(0)
 484             , m_subexpressionLineStartOffset(0)
 485         {
 486         }
 487 
 488         void setSubexpressionInfo(const JSTextPosition&amp; subexpressionDivot, int subexpressionOffset)
 489         {
 490             ASSERT(subexpressionDivot.offset &gt;= divot().offset);
 491             // Overflow means we can&#39;t do this safely, so just point at the primary divot,
 492             // divotLine, or divotLineStart.
 493             if ((subexpressionDivot.offset - divot()) &amp; ~0xFFFF)
 494                 return;
 495             if ((subexpressionDivot.line - divot().line) &amp; ~0xFFFF)
 496                 return;
 497             if ((subexpressionDivot.lineStartOffset - divot().lineStartOffset) &amp; ~0xFFFF)
 498                 return;
 499             if ((subexpressionOffset - divotStart()) &amp; ~0xFFFF)
 500                 return;
 501             m_subexpressionDivotOffset = subexpressionDivot.offset - divot();
 502             m_subexpressionStartOffset = subexpressionOffset - divotStart();
 503             m_subexpressionLineOffset = subexpressionDivot.line - divot().line;
 504             m_subexpressionLineStartOffset = subexpressionDivot.lineStartOffset - divot().lineStartOffset;
 505         }
 506 
 507         JSTextPosition subexpressionDivot()
 508         {
 509             int newLine = divot().line + m_subexpressionLineOffset;
 510             int newOffset = divot().offset + m_subexpressionDivotOffset;
 511             int newLineStartOffset = divot().lineStartOffset + m_subexpressionLineStartOffset;
 512             return JSTextPosition(newLine, newOffset, newLineStartOffset);
 513         }
 514         JSTextPosition subexpressionStart() { return divotStart() + static_cast&lt;int&gt;(m_subexpressionStartOffset); }
 515         JSTextPosition subexpressionEnd() { return divotEnd(); }
 516 
 517     protected:
 518         uint16_t m_subexpressionDivotOffset;
 519         uint16_t m_subexpressionStartOffset;
 520         uint16_t m_subexpressionLineOffset;
 521         uint16_t m_subexpressionLineStartOffset;
 522     };
 523 
 524     class TemplateExpressionListNode final : public ParserArenaFreeable {
 525     public:
 526         TemplateExpressionListNode(ExpressionNode*);
 527         TemplateExpressionListNode(TemplateExpressionListNode*, ExpressionNode*);
 528 
 529         ExpressionNode* value() { return m_node; }
 530         TemplateExpressionListNode* next() { return m_next; }
 531 
 532     private:
 533         TemplateExpressionListNode* m_next { nullptr };
 534         ExpressionNode* m_node { nullptr };
 535     };
 536 
 537     class TemplateStringNode final : public ExpressionNode {
 538     public:
 539         TemplateStringNode(const JSTokenLocation&amp;, const Identifier* cooked, const Identifier* raw);
 540 
 541         const Identifier* cooked() { return m_cooked; }
 542         const Identifier* raw() { return m_raw; }
 543 
 544     private:
 545         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 546 
 547         const Identifier* m_cooked;
 548         const Identifier* m_raw;
 549     };
 550 
 551     class TemplateStringListNode final : public ParserArenaFreeable {
 552     public:
 553         TemplateStringListNode(TemplateStringNode*);
 554         TemplateStringListNode(TemplateStringListNode*, TemplateStringNode*);
 555 
 556         TemplateStringNode* value() { return m_node; }
 557         TemplateStringListNode* next() { return m_next; }
 558 
 559     private:
 560         TemplateStringListNode* m_next { nullptr };
 561         TemplateStringNode* m_node { nullptr };
 562     };
 563 
 564     class TemplateLiteralNode final : public ExpressionNode {
 565     public:
 566         TemplateLiteralNode(const JSTokenLocation&amp;, TemplateStringListNode*);
 567         TemplateLiteralNode(const JSTokenLocation&amp;, TemplateStringListNode*, TemplateExpressionListNode*);
 568 
 569         TemplateStringListNode* templateStrings() const { return m_templateStrings; }
 570         TemplateExpressionListNode* templateExpressions() const { return m_templateExpressions; }
 571 
 572     private:
 573         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 574 
 575         TemplateStringListNode* m_templateStrings;
 576         TemplateExpressionListNode* m_templateExpressions;
 577     };
 578 
 579     class TaggedTemplateNode final : public ExpressionNode, public ThrowableExpressionData {
 580     public:
 581         TaggedTemplateNode(const JSTokenLocation&amp;, ExpressionNode*, TemplateLiteralNode*);
 582 
 583         TemplateLiteralNode* templateLiteral() const { return m_templateLiteral; }
 584 
 585     private:
 586         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 587 
 588         ExpressionNode* m_tag;
 589         TemplateLiteralNode* m_templateLiteral;
 590     };
 591 
 592     class RegExpNode final : public ExpressionNode, public ThrowableExpressionData {
 593     public:
 594         RegExpNode(const JSTokenLocation&amp;, const Identifier&amp; pattern, const Identifier&amp; flags);
 595 
 596     private:
 597         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 598 
 599         const Identifier&amp; m_pattern;
 600         const Identifier&amp; m_flags;
 601     };
 602 
 603     class ThisNode final : public ExpressionNode {
 604     public:
 605         ThisNode(const JSTokenLocation&amp;);
 606 
 607     private:
 608         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 609     };
 610 
 611     class SuperNode final : public ExpressionNode {
 612     public:
 613         SuperNode(const JSTokenLocation&amp;);
 614 
 615     private:
 616         bool isSuperNode() const override { return true; }
 617         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 618     };
 619 
 620     class ImportNode final : public ExpressionNode, public ThrowableExpressionData {
 621     public:
 622         ImportNode(const JSTokenLocation&amp;, ExpressionNode*);
 623 
 624     private:
 625         bool isImportNode() const override { return true; }
 626         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 627 
 628         ExpressionNode* m_expr;
 629     };
 630 
 631     class MetaPropertyNode : public ExpressionNode {
 632     public:
 633         MetaPropertyNode(const JSTokenLocation&amp;);
 634 
 635     private:
 636         bool isMetaProperty() const final { return true; }
 637     };
 638 
 639     class NewTargetNode final : public MetaPropertyNode {
 640     public:
 641         NewTargetNode(const JSTokenLocation&amp;);
 642 
 643     private:
 644         bool isNewTarget() const final { return true; }
 645         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 646     };
 647 
 648     class ImportMetaNode final : public MetaPropertyNode {
 649     public:
 650         ImportMetaNode(const JSTokenLocation&amp;, ExpressionNode*);
 651 
 652     private:
 653         bool isImportMeta() const final { return true; }
 654         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 655 
 656         ExpressionNode* m_expr;
 657     };
 658 
 659     class ResolveNode final : public ExpressionNode {
 660     public:
 661         ResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, const JSTextPosition&amp; start);
 662 
 663         const Identifier&amp; identifier() const { return m_ident; }
 664 
 665     private:
 666         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 667 
 668         bool isPure(BytecodeGenerator&amp;) const override;
 669         bool isLocation() const override { return true; }
 670         bool isResolveNode() const override { return true; }
 671 
 672         const Identifier&amp; m_ident;
 673         JSTextPosition m_start;
 674     };
 675 
 676     class ElementNode final : public ParserArenaFreeable {
 677     public:
 678         ElementNode(int elision, ExpressionNode*);
 679         ElementNode(ElementNode*, int elision, ExpressionNode*);
 680 
 681         int elision() const { return m_elision; }
 682         ExpressionNode* value() { return m_node; }
 683         ElementNode* next() { return m_next; }
 684 
 685     private:
 686         ElementNode* m_next { nullptr };
 687         ExpressionNode* m_node;
 688         int m_elision;
 689     };
 690 
 691     class ArrayNode final : public ExpressionNode {
 692     public:
 693         ArrayNode(const JSTokenLocation&amp;, int elision);
 694         ArrayNode(const JSTokenLocation&amp;, ElementNode*);
 695         ArrayNode(const JSTokenLocation&amp;, int elision, ElementNode*);
 696 
 697         bool isArrayLiteral() const override { return true; }
 698 
 699         ArgumentListNode* toArgumentList(ParserArena&amp;, int, int) const;
 700 
 701         ElementNode* elements() const { return m_element; }
 702     private:
 703         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 704 
 705         bool isSimpleArray() const override;
 706 
 707         ElementNode* m_element;
 708         int m_elision;
 709         bool m_optional;
 710     };
 711 
 712     enum class ClassElementTag : uint8_t { No, Instance, Static, LastTag };
 713     class PropertyNode final : public ParserArenaFreeable {
 714     public:
 715         enum Type : uint8_t { Constant = 1, Getter = 2, Setter = 4, Computed = 8, Shorthand = 16, Spread = 32 };
 716         enum PutType : uint8_t { Unknown, KnownDirect };
 717 
 718         PropertyNode(const Identifier&amp;, ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
 719         PropertyNode(ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
 720         PropertyNode(ExpressionNode* propertyName, ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
<a name="12" id="anc12"></a><span class="line-added"> 721         PropertyNode(const Identifier&amp;, ExpressionNode* propertyName, ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);</span>
 722 
 723         ExpressionNode* expressionName() const { return m_expression; }
 724         const Identifier* name() const { return m_name; }
 725 
 726         Type type() const { return static_cast&lt;Type&gt;(m_type); }
 727         bool needsSuperBinding() const { return m_needsSuperBinding; }
 728         bool isClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) != ClassElementTag::No; }
 729         bool isStaticClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) == ClassElementTag::Static; }
 730         bool isInstanceClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) == ClassElementTag::Instance; }
<a name="13" id="anc13"></a><span class="line-added"> 731         bool isClassField() const { return isClassProperty() &amp;&amp; !needsSuperBinding(); }</span>
<span class="line-added"> 732         bool isInstanceClassField() const { return isInstanceClassProperty() &amp;&amp; !needsSuperBinding(); }</span>
 733         bool isOverriddenByDuplicate() const { return m_isOverriddenByDuplicate; }
<a name="14" id="anc14"></a><span class="line-added"> 734         bool hasComputedName() const { return m_expression; }</span>
<span class="line-added"> 735         bool isComputedClassField() const { return isClassField() &amp;&amp; hasComputedName(); }</span>
 736         void setIsOverriddenByDuplicate() { m_isOverriddenByDuplicate = true; }
 737         PutType putType() const { return static_cast&lt;PutType&gt;(m_putType); }
 738 
 739     private:
 740         friend class PropertyListNode;
 741         const Identifier* m_name;
 742         ExpressionNode* m_expression;
 743         ExpressionNode* m_assign;
 744         unsigned m_type : 6;
 745         unsigned m_needsSuperBinding : 1;
 746         unsigned m_putType : 1;
 747         static_assert(1 &lt;&lt; 2 &gt; static_cast&lt;unsigned&gt;(ClassElementTag::LastTag), &quot;ClassElementTag shouldn&#39;t use more than two bits&quot;);
 748         unsigned m_classElementTag : 2;
<a name="15" id="anc15"></a><span class="line-modified"> 749         unsigned m_isOverriddenByDuplicate : 1;</span>
 750     };
 751 
 752     class PropertyListNode final : public ExpressionNode {
 753     public:
 754         PropertyListNode(const JSTokenLocation&amp;, PropertyNode*);
 755         PropertyListNode(const JSTokenLocation&amp;, PropertyNode*, PropertyListNode*);
 756 
 757         bool hasStaticallyNamedProperty(const Identifier&amp; propName);
<a name="16" id="anc16"></a><span class="line-added"> 758         bool isComputedClassField() const</span>
<span class="line-added"> 759         {</span>
<span class="line-added"> 760             return m_node-&gt;isComputedClassField();</span>
<span class="line-added"> 761         }</span>
<span class="line-added"> 762         bool isInstanceClassField() const</span>
<span class="line-added"> 763         {</span>
<span class="line-added"> 764             return m_node-&gt;isInstanceClassField();</span>
<span class="line-added"> 765         }</span>
<span class="line-added"> 766         bool hasInstanceFields() const;</span>
 767 
<a name="17" id="anc17"></a><span class="line-modified"> 768         static bool shouldCreateLexicalScopeForClass(PropertyListNode*);</span>
<span class="line-added"> 769 </span>
<span class="line-added"> 770         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID*, RegisterID*, Vector&lt;JSTextPosition&gt;*);</span>
 771 
 772     private:
 773         RegisterID* emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst = nullptr) override
 774         {
<a name="18" id="anc18"></a><span class="line-modified"> 775             return emitBytecode(generator, dst, nullptr, nullptr);</span>
 776         }
 777         void emitPutConstantProperty(BytecodeGenerator&amp;, RegisterID*, PropertyNode&amp;);
<a name="19" id="anc19"></a><span class="line-added"> 778         void emitSaveComputedFieldName(BytecodeGenerator&amp;, PropertyNode&amp;);</span>
 779 
 780         PropertyNode* m_node;
 781         PropertyListNode* m_next { nullptr };
 782     };
 783 
 784     class ObjectLiteralNode final : public ExpressionNode {
 785     public:
 786         ObjectLiteralNode(const JSTokenLocation&amp;);
 787         ObjectLiteralNode(const JSTokenLocation&amp;, PropertyListNode*);
 788         bool isObjectLiteral() const override { return true; }
 789 
 790     private:
 791         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 792 
 793         PropertyListNode* m_list;
 794     };
 795 
 796     class BracketAccessorNode final : public ExpressionNode, public ThrowableExpressionData {
 797     public:
 798         BracketAccessorNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, bool subscriptHasAssignments);
 799 
 800         ExpressionNode* base() const { return m_base; }
 801         ExpressionNode* subscript() const { return m_subscript; }
 802 
 803         bool subscriptHasAssignments() const { return m_subscriptHasAssignments; }
 804 
 805     private:
 806         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 807 
 808         bool isLocation() const override { return true; }
 809         bool isBracketAccessorNode() const override { return true; }
 810 
 811         ExpressionNode* m_base;
 812         ExpressionNode* m_subscript;
 813         bool m_subscriptHasAssignments;
 814     };
 815 
 816     class DotAccessorNode final : public ExpressionNode, public ThrowableExpressionData {
 817     public:
 818         DotAccessorNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;);
 819 
 820         ExpressionNode* base() const { return m_base; }
 821         const Identifier&amp; identifier() const { return m_ident; }
 822 
 823     private:
 824         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 825 
 826         bool isLocation() const override { return true; }
 827         bool isDotAccessorNode() const override { return true; }
 828 
 829         ExpressionNode* m_base;
 830         const Identifier&amp; m_ident;
 831     };
 832 
 833     class SpreadExpressionNode final : public ExpressionNode, public ThrowableExpressionData {
 834     public:
 835         SpreadExpressionNode(const JSTokenLocation&amp;, ExpressionNode*);
 836 
 837         ExpressionNode* expression() const { return m_expression; }
 838 
 839     private:
 840         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 841 
 842         bool isSpreadExpression() const override { return true; }
 843         ExpressionNode* m_expression;
 844     };
 845 
 846     class ObjectSpreadExpressionNode final : public ExpressionNode, public ThrowableExpressionData {
 847     public:
 848         ObjectSpreadExpressionNode(const JSTokenLocation&amp;, ExpressionNode*);
 849 
 850         ExpressionNode* expression() const { return m_expression; }
 851 
 852     private:
 853         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 854 
 855         ExpressionNode* m_expression;
 856     };
 857 
 858     class ArgumentListNode final : public ExpressionNode {
 859     public:
 860         ArgumentListNode(const JSTokenLocation&amp;, ExpressionNode*);
 861         ArgumentListNode(const JSTokenLocation&amp;, ArgumentListNode*, ExpressionNode*);
 862 
 863         ArgumentListNode* m_next { nullptr };
 864         ExpressionNode* m_expr;
 865 
 866     private:
 867         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 868     };
 869 
 870     class ArgumentsNode final : public ParserArenaFreeable {
 871     public:
 872         ArgumentsNode();
 873         ArgumentsNode(ArgumentListNode*);
 874 
 875         ArgumentListNode* m_listNode;
 876     };
 877 
 878     class NewExprNode final : public ExpressionNode, public ThrowableExpressionData {
 879     public:
 880         NewExprNode(const JSTokenLocation&amp;, ExpressionNode*);
 881         NewExprNode(const JSTokenLocation&amp;, ExpressionNode*, ArgumentsNode*);
 882 
 883     private:
 884         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 885 
 886         ExpressionNode* m_expr;
 887         ArgumentsNode* m_args;
 888     };
 889 
 890     class EvalFunctionCallNode final : public ExpressionNode, public ThrowableExpressionData {
 891     public:
 892         EvalFunctionCallNode(const JSTokenLocation&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 893 
 894     private:
 895         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 896 
 897         bool isFunctionCall() const override { return true; }
 898 
 899         ArgumentsNode* m_args;
 900     };
 901 
 902     class FunctionCallValueNode final : public ExpressionNode, public ThrowableExpressionData {
 903     public:
 904         FunctionCallValueNode(const JSTokenLocation&amp;, ExpressionNode*, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 905 
 906     private:
 907         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 908 
 909         bool isFunctionCall() const override { return true; }
 910 
 911         ExpressionNode* m_expr;
 912         ArgumentsNode* m_args;
 913     };
 914 
 915     class FunctionCallResolveNode final : public ExpressionNode, public ThrowableExpressionData {
 916     public:
 917         FunctionCallResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 918 
 919     private:
 920         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 921 
 922         bool isFunctionCall() const override { return true; }
 923 
 924         const Identifier&amp; m_ident;
 925         ArgumentsNode* m_args;
 926     };
 927 
 928     class FunctionCallBracketNode final : public ExpressionNode, public ThrowableSubExpressionData {
 929     public:
 930         FunctionCallBracketNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, bool subscriptHasAssignments, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 931 
 932     private:
 933         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 934 
 935         bool isFunctionCall() const override { return true; }
 936 
 937         ExpressionNode* m_base;
 938         ExpressionNode* m_subscript;
 939         ArgumentsNode* m_args;
 940         bool m_subscriptHasAssignments;
 941     };
 942 
 943     class FunctionCallDotNode : public ExpressionNode, public ThrowableSubExpressionData {
 944     public:
 945         FunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 946 
 947     private:
 948         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 949 
 950     protected:
 951         bool isFunctionCall() const override { return true; }
 952 
 953         ExpressionNode* m_base;
 954         const Identifier&amp; m_ident;
 955         ArgumentsNode* m_args;
 956     };
 957 
 958     class BytecodeIntrinsicNode final : public ExpressionNode, public ThrowableExpressionData {
 959     public:
 960         enum class Type : uint8_t {
 961             Constant,
 962             Function
 963         };
 964 
<a name="20" id="anc20"></a><span class="line-modified"> 965         BytecodeIntrinsicNode(Type, const JSTokenLocation&amp;, BytecodeIntrinsicRegistry::Entry, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);</span>


 966 
 967         bool isBytecodeIntrinsicNode() const override { return true; }
 968 
 969         Type type() const { return m_type; }
<a name="21" id="anc21"></a><span class="line-modified"> 970         BytecodeIntrinsicRegistry::Entry entry() const { return m_entry; }</span>
 971         const Identifier&amp; identifier() const { return m_ident; }
 972 
 973 #define JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS(name) RegisterID* emit_intrinsic_##name(BytecodeGenerator&amp;, RegisterID*);
 974         JSC_COMMON_BYTECODE_INTRINSIC_FUNCTIONS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
 975         JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
 976 #undef JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS
 977 
 978     private:
 979         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 980 
 981         bool isFunctionCall() const override { return m_type == Type::Function; }
 982 
<a name="22" id="anc22"></a><span class="line-modified"> 983         BytecodeIntrinsicRegistry::Entry m_entry;</span>
 984         const Identifier&amp; m_ident;
 985         ArgumentsNode* m_args;
 986         Type m_type;
 987     };
 988 
 989     class CallFunctionCallDotNode final : public FunctionCallDotNode {
 990     public:
 991         CallFunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, size_t distanceToInnermostCallOrApply);
 992 
 993     private:
 994         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 995         size_t m_distanceToInnermostCallOrApply;
 996     };
 997 
 998     class ApplyFunctionCallDotNode final : public FunctionCallDotNode {
 999     public:
1000         ApplyFunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, size_t distanceToInnermostCallOrApply);
1001 
1002     private:
1003         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1004         size_t m_distanceToInnermostCallOrApply;
1005     };
1006 
1007     class DeleteResolveNode final : public ExpressionNode, public ThrowableExpressionData {
1008     public:
1009         DeleteResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1010 
1011     private:
1012         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1013 
1014         bool isDeleteNode() const final { return true; }
1015 
1016         const Identifier&amp; m_ident;
1017     };
1018 
1019     class DeleteBracketNode final : public ExpressionNode, public ThrowableExpressionData {
1020     public:
1021         DeleteBracketNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1022 
1023     private:
1024         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1025 
1026         bool isDeleteNode() const final { return true; }
1027 
1028         ExpressionNode* m_base;
1029         ExpressionNode* m_subscript;
1030     };
1031 
1032     class DeleteDotNode final : public ExpressionNode, public ThrowableExpressionData {
1033     public:
1034         DeleteDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1035 
1036     private:
1037         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1038 
1039         bool isDeleteNode() const final { return true; }
1040 
1041         ExpressionNode* m_base;
1042         const Identifier&amp; m_ident;
1043     };
1044 
1045     class DeleteValueNode final : public ExpressionNode {
1046     public:
1047         DeleteValueNode(const JSTokenLocation&amp;, ExpressionNode*);
1048 
1049     private:
1050         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1051 
1052         bool isDeleteNode() const final { return true; }
1053 
1054         ExpressionNode* m_expr;
1055     };
1056 
1057     class VoidNode final : public ExpressionNode {
1058     public:
1059         VoidNode(const JSTokenLocation&amp;, ExpressionNode*);
1060 
1061     private:
1062         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1063 
1064         ExpressionNode* m_expr;
1065     };
1066 
1067     class TypeOfResolveNode final : public ExpressionNode {
1068     public:
1069         TypeOfResolveNode(const JSTokenLocation&amp;, const Identifier&amp;);
1070 
1071         const Identifier&amp; identifier() const { return m_ident; }
1072 
1073     private:
1074         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1075 
1076         const Identifier&amp; m_ident;
1077     };
1078 
1079     class TypeOfValueNode final : public ExpressionNode {
1080     public:
1081         TypeOfValueNode(const JSTokenLocation&amp;, ExpressionNode*);
1082 
1083     private:
1084         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1085 
1086         ExpressionNode* m_expr;
1087     };
1088 
1089     class PrefixNode : public ExpressionNode, public ThrowablePrefixedSubExpressionData {
1090     public:
1091         PrefixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1092 
1093     protected:
1094         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1095         virtual RegisterID* emitResolve(BytecodeGenerator&amp;, RegisterID* = 0);
1096         virtual RegisterID* emitBracket(BytecodeGenerator&amp;, RegisterID* = 0);
1097         virtual RegisterID* emitDot(BytecodeGenerator&amp;, RegisterID* = 0);
1098 
1099         ExpressionNode* m_expr;
1100         Operator m_operator;
1101     };
1102 
1103     class PostfixNode final : public PrefixNode {
1104     public:
1105         PostfixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1106 
1107     private:
1108         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1109         RegisterID* emitResolve(BytecodeGenerator&amp;, RegisterID* = 0) override;
1110         RegisterID* emitBracket(BytecodeGenerator&amp;, RegisterID* = 0) override;
1111         RegisterID* emitDot(BytecodeGenerator&amp;, RegisterID* = 0) override;
1112     };
1113 
1114     class UnaryOpNode : public ExpressionNode {
1115     public:
1116         UnaryOpNode(const JSTokenLocation&amp;, ResultType, ExpressionNode*, OpcodeID);
1117 
1118     protected:
1119         ExpressionNode* expr() { return m_expr; }
1120         const ExpressionNode* expr() const { return m_expr; }
1121         OpcodeID opcodeID() const { return m_opcodeID; }
1122 
1123     private:
1124         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1125 
1126         ExpressionNode* m_expr;
1127         OpcodeID m_opcodeID;
1128     };
1129 
1130     class UnaryPlusNode final : public UnaryOpNode {
1131     public:
1132         UnaryPlusNode(const JSTokenLocation&amp;, ExpressionNode*);
1133 
1134     private:
1135         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1136 
1137         ExpressionNode* stripUnaryPlus() override { return expr(); }
1138     };
1139 
1140     class NegateNode final : public UnaryOpNode {
1141     public:
1142         NegateNode(const JSTokenLocation&amp;, ExpressionNode*);
1143     };
1144 
1145     class BitwiseNotNode final : public UnaryOpNode {
1146     public:
1147         BitwiseNotNode(const JSTokenLocation&amp;, ExpressionNode*);
1148     };
1149 
1150     class LogicalNotNode final : public UnaryOpNode {
1151     public:
1152         LogicalNotNode(const JSTokenLocation&amp;, ExpressionNode*);
1153     private:
1154         void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode) override;
1155     };
1156 
1157     class BinaryOpNode : public ExpressionNode {
1158     public:
1159         BinaryOpNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);
1160         BinaryOpNode(const JSTokenLocation&amp;, ResultType, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);
1161 
1162         RegisterID* emitStrcat(BytecodeGenerator&amp; generator, RegisterID* destination, RegisterID* lhs = 0, ReadModifyResolveNode* emitExpressionInfoForMe = 0);
1163         void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode) override;
1164 
1165         ExpressionNode* lhs() { return m_expr1; };
1166         ExpressionNode* rhs() { return m_expr2; };
1167 
1168         bool isBinaryOpNode() const override { return true; }
1169 
1170     private:
1171         enum class UInt32Result : uint8_t { UInt32, Constant, };
1172 
1173         void tryFoldToBranch(BytecodeGenerator&amp;, TriState&amp; branchCondition, ExpressionNode*&amp; branchExpression);
1174         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1175 
1176     protected:
1177         OpcodeID opcodeID() const { return m_opcodeID; }
1178 
1179     protected:
1180         bool m_rightHasAssignments;
1181         bool m_shouldToUnsignedResult { true };
1182     private:
1183         OpcodeID m_opcodeID;
1184     protected:
1185         ExpressionNode* m_expr1;
1186         ExpressionNode* m_expr2;
1187     };
1188 
1189     class PowNode final : public BinaryOpNode {
1190     public:
1191         PowNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1192     };
1193 
1194     class MultNode final : public BinaryOpNode {
1195     public:
1196         MultNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1197     };
1198 
1199     class DivNode final : public BinaryOpNode {
1200     public:
1201         DivNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1202     };
1203 
1204     class ModNode final : public BinaryOpNode {
1205     public:
1206         ModNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1207     };
1208 
1209     class AddNode final : public BinaryOpNode {
1210     public:
1211         AddNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1212 
1213         bool isAdd() const override { return true; }
1214     };
1215 
1216     class SubNode final : public BinaryOpNode {
1217     public:
1218         SubNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1219 
1220         bool isSubtract() const override { return true; }
1221     };
1222 
1223     class LeftShiftNode final : public BinaryOpNode {
1224     public:
1225         LeftShiftNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1226     };
1227 
1228     class RightShiftNode final : public BinaryOpNode {
1229     public:
1230         RightShiftNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1231     };
1232 
1233     class UnsignedRightShiftNode final : public BinaryOpNode {
1234     public:
1235         UnsignedRightShiftNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1236     };
1237 
1238     class LessNode final : public BinaryOpNode {
1239     public:
1240         LessNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1241     };
1242 
1243     class GreaterNode final : public BinaryOpNode {
1244     public:
1245         GreaterNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1246     };
1247 
1248     class LessEqNode final : public BinaryOpNode {
1249     public:
1250         LessEqNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1251     };
1252 
1253     class GreaterEqNode final : public BinaryOpNode {
1254     public:
1255         GreaterEqNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1256     };
1257 
1258     class ThrowableBinaryOpNode : public BinaryOpNode, public ThrowableExpressionData {
1259     public:
1260         ThrowableBinaryOpNode(const JSTokenLocation&amp;, ResultType, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);
1261         ThrowableBinaryOpNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);
1262 
1263     private:
1264         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1265     };
1266 
1267     class InstanceOfNode final : public ThrowableBinaryOpNode {
1268     public:
1269         InstanceOfNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1270 
1271     private:
1272         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1273     };
1274 
1275     class InNode final : public ThrowableBinaryOpNode {
1276     public:
1277         InNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1278 
1279     private:
1280         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1281     };
1282 
1283     class EqualNode final : public BinaryOpNode {
1284     public:
1285         EqualNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1286 
1287     private:
1288         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1289     };
1290 
1291     class NotEqualNode final : public BinaryOpNode {
1292     public:
1293         NotEqualNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1294     };
1295 
1296     class StrictEqualNode final : public BinaryOpNode {
1297     public:
1298         StrictEqualNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1299 
1300     private:
1301         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1302     };
1303 
1304     class NotStrictEqualNode final : public BinaryOpNode {
1305     public:
1306         NotStrictEqualNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1307     };
1308 
1309     class BitAndNode final : public BinaryOpNode {
1310     public:
1311         BitAndNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1312     };
1313 
1314     class BitOrNode final : public BinaryOpNode {
1315     public:
1316         BitOrNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1317     };
1318 
1319     class BitXOrNode final : public BinaryOpNode {
1320     public:
1321         BitXOrNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1322     };
1323 
1324     // m_expr1 &amp;&amp; m_expr2, m_expr1 || m_expr2
1325     class LogicalOpNode final : public ExpressionNode {
1326     public:
1327         LogicalOpNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, LogicalOperator);
1328 
1329     private:
1330         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1331         void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode) override;
1332 
1333         LogicalOperator m_operator;
1334         ExpressionNode* m_expr1;
1335         ExpressionNode* m_expr2;
1336     };
1337 
1338     class CoalesceNode final : public ExpressionNode {
1339     public:
1340         CoalesceNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool);
1341 
1342     private:
1343         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = nullptr) final;
1344 
1345         ExpressionNode* m_expr1;
1346         ExpressionNode* m_expr2;
1347         bool m_hasAbsorbedOptionalChain;
1348     };
1349 
1350     class OptionalChainNode final : public ExpressionNode {
1351     public:
1352         OptionalChainNode(const JSTokenLocation&amp;, ExpressionNode*, bool);
1353 
1354         void setExpr(ExpressionNode* expr) { m_expr = expr; }
1355         ExpressionNode* expr() const { return m_expr; }
1356 
1357     private:
1358         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = nullptr) final;
1359 
1360         bool isOptionalChain() const final { return true; }
1361 
1362         ExpressionNode* m_expr;
1363         bool m_isOutermost;
1364     };
1365 
1366     // The ternary operator, &quot;m_logical ? m_expr1 : m_expr2&quot;
1367     class ConditionalNode final : public ExpressionNode {
1368     public:
1369         ConditionalNode(const JSTokenLocation&amp;, ExpressionNode* logical, ExpressionNode* expr1, ExpressionNode* expr2);
1370 
1371     private:
1372         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1373 
1374         ExpressionNode* m_logical;
1375         ExpressionNode* m_expr1;
1376         ExpressionNode* m_expr2;
1377     };
1378 
1379     class ReadModifyResolveNode final : public ExpressionNode, public ThrowableExpressionData {
1380     public:
1381         ReadModifyResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, Operator, ExpressionNode*  right, bool rightHasAssignments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1382 
1383     private:
1384         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1385 
1386         const Identifier&amp; m_ident;
1387         ExpressionNode* m_right;
1388         Operator m_operator;
1389         bool m_rightHasAssignments;
1390     };
1391 
1392     class AssignResolveNode final : public ExpressionNode, public ThrowableExpressionData {
1393     public:
1394         AssignResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, ExpressionNode* right, AssignmentContext);
1395         bool isAssignResolveNode() const override { return true; }
1396         const Identifier&amp; identifier() const { return m_ident; }
1397 
1398     private:
1399         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1400 
1401         const Identifier&amp; m_ident;
1402         ExpressionNode* m_right;
1403         AssignmentContext m_assignmentContext;
1404     };
1405 
1406     class ReadModifyBracketNode final : public ExpressionNode, public ThrowableSubExpressionData {
1407     public:
1408         ReadModifyBracketNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, Operator, ExpressionNode* right, bool subscriptHasAssignments, bool rightHasAssignments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1409 
1410     private:
1411         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1412 
1413         ExpressionNode* m_base;
1414         ExpressionNode* m_subscript;
1415         ExpressionNode* m_right;
1416         unsigned m_operator : 30;
1417         bool m_subscriptHasAssignments : 1;
1418         bool m_rightHasAssignments : 1;
1419     };
1420 
1421     class AssignBracketNode final : public ExpressionNode, public ThrowableExpressionData {
1422     public:
1423         AssignBracketNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, ExpressionNode* right, bool subscriptHasAssignments, bool rightHasAssignments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1424 
1425     private:
1426         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1427 
1428         ExpressionNode* m_base;
1429         ExpressionNode* m_subscript;
1430         ExpressionNode* m_right;
1431         bool m_subscriptHasAssignments : 1;
1432         bool m_rightHasAssignments : 1;
1433     };
1434 
1435     class AssignDotNode final : public ExpressionNode, public ThrowableExpressionData {
1436     public:
1437         AssignDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ExpressionNode* right, bool rightHasAssignments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1438 
1439     private:
1440         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1441 
1442         ExpressionNode* m_base;
1443         const Identifier&amp; m_ident;
1444         ExpressionNode* m_right;
1445         bool m_rightHasAssignments;
1446     };
1447 
1448     class ReadModifyDotNode final : public ExpressionNode, public ThrowableSubExpressionData {
1449     public:
1450         ReadModifyDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, Operator, ExpressionNode* right, bool rightHasAssignments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1451 
1452     private:
1453         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1454 
1455         ExpressionNode* m_base;
1456         const Identifier&amp; m_ident;
1457         ExpressionNode* m_right;
1458         unsigned m_operator : 31;
1459         bool m_rightHasAssignments : 1;
1460     };
1461 
1462     class AssignErrorNode final : public ExpressionNode, public ThrowableExpressionData {
1463     public:
1464         AssignErrorNode(const JSTokenLocation&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1465 
1466     private:
1467         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1468     };
1469 
1470     class CommaNode final : public ExpressionNode {
1471     public:
1472         CommaNode(const JSTokenLocation&amp;, ExpressionNode*);
1473 
1474         void setNext(CommaNode* next) { m_next = next; }
1475         CommaNode* next() { return m_next; }
1476 
1477     private:
1478         bool isCommaNode() const override { return true; }
1479         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1480 
1481         ExpressionNode* m_expr;
1482         CommaNode* m_next { nullptr };
1483     };
1484 
1485     class SourceElements final : public ParserArenaFreeable {
1486     public:
1487         SourceElements();
1488 
1489         void append(StatementNode*);
1490 
1491         StatementNode* singleStatement() const;
1492         StatementNode* lastStatement() const;
1493 
1494         bool hasCompletionValue() const;
1495         bool hasEarlyBreakOrContinue() const;
1496 
1497         void emitBytecode(BytecodeGenerator&amp;, RegisterID* destination);
1498         void analyzeModule(ModuleAnalyzer&amp;);
1499 
1500     private:
1501         StatementNode* m_head { nullptr };
1502         StatementNode* m_tail { nullptr };
1503     };
1504 
1505     class BlockNode final : public StatementNode, public VariableEnvironmentNode {
1506         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(BlockNode);
1507     public:
1508         BlockNode(const JSTokenLocation&amp;, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;);
1509 
1510         StatementNode* singleStatement() const;
1511         StatementNode* lastStatement() const;
1512 
1513     private:
1514         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1515 
1516         bool hasCompletionValue() const override;
1517         bool hasEarlyBreakOrContinue() const override;
1518 
1519         bool isBlock() const override { return true; }
1520 
1521         SourceElements* m_statements;
1522     };
1523 
1524     class EmptyStatementNode final : public StatementNode {
1525     public:
1526         EmptyStatementNode(const JSTokenLocation&amp;);
1527 
1528     private:
1529         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1530 
1531         bool hasCompletionValue() const override { return false; }
1532         bool isEmptyStatement() const override { return true; }
1533     };
1534 
1535     class DebuggerStatementNode final : public StatementNode {
1536     public:
1537         DebuggerStatementNode(const JSTokenLocation&amp;);
1538 
1539         bool hasCompletionValue() const override { return false; }
1540         bool isDebuggerStatement() const override { return true; }
1541 
1542     private:
1543         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1544     };
1545 
1546     class ExprStatementNode final : public StatementNode {
1547     public:
1548         ExprStatementNode(const JSTokenLocation&amp;, ExpressionNode*);
1549 
1550         ExpressionNode* expr() const { return m_expr; }
1551 
1552     private:
1553         bool isExprStatement() const override { return true; }
1554 
1555         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1556 
1557         ExpressionNode* m_expr;
1558     };
1559 
1560     class DeclarationStatement final : public StatementNode {
1561     public:
1562         DeclarationStatement(const JSTokenLocation&amp;, ExpressionNode*);
1563     private:
1564         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1565 
1566         bool hasCompletionValue() const override { return false; }
1567 
1568         ExpressionNode* m_expr;
1569     };
1570 
1571     class EmptyVarExpression final : public ExpressionNode {
1572     public:
1573         EmptyVarExpression(const JSTokenLocation&amp;, const Identifier&amp;);
1574 
1575     private:
1576         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1577 
1578         const Identifier&amp; m_ident;
1579     };
1580 
1581     class EmptyLetExpression final : public ExpressionNode {
1582     public:
1583         EmptyLetExpression(const JSTokenLocation&amp;, const Identifier&amp;);
1584 
1585     private:
1586         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1587 
1588         const Identifier&amp; m_ident;
1589     };
1590 
1591     class IfElseNode final : public StatementNode {
1592     public:
1593         IfElseNode(const JSTokenLocation&amp;, ExpressionNode* condition, StatementNode* ifBlock, StatementNode* elseBlock);
1594 
1595     private:
1596         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1597         bool tryFoldBreakAndContinue(BytecodeGenerator&amp;, StatementNode* ifBlock,
1598             Label*&amp; trueTarget, FallThroughMode&amp;);
1599 
1600         ExpressionNode* m_condition;
1601         StatementNode* m_ifBlock;
1602         StatementNode* m_elseBlock;
1603     };
1604 
1605     class DoWhileNode final : public StatementNode {
1606     public:
1607         DoWhileNode(const JSTokenLocation&amp;, StatementNode*, ExpressionNode*);
1608 
1609     private:
1610         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1611 
1612         StatementNode* m_statement;
1613         ExpressionNode* m_expr;
1614     };
1615 
1616     class WhileNode final : public StatementNode {
1617     public:
1618         WhileNode(const JSTokenLocation&amp;, ExpressionNode*, StatementNode*);
1619 
1620     private:
1621         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1622 
1623         ExpressionNode* m_expr;
1624         StatementNode* m_statement;
1625     };
1626 
1627     class ForNode final : public StatementNode, public VariableEnvironmentNode {
1628         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ForNode);
1629     public:
1630         ForNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, ExpressionNode* expr3, StatementNode*, VariableEnvironment&amp;);
1631 
1632     private:
1633         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1634 
1635         ExpressionNode* m_expr1;
1636         ExpressionNode* m_expr2;
1637         ExpressionNode* m_expr3;
1638         StatementNode* m_statement;
1639     };
1640 
1641     class DestructuringPatternNode;
1642 
1643     class EnumerationNode : public StatementNode, public ThrowableExpressionData, public VariableEnvironmentNode {
1644         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(EnumerationNode);
1645     public:
1646         EnumerationNode(const JSTokenLocation&amp;, ExpressionNode*, ExpressionNode*, StatementNode*, VariableEnvironment&amp;);
1647 
1648         ExpressionNode* lexpr() const { return m_lexpr; }
1649         ExpressionNode* expr() const { return m_expr; }
1650 
1651     protected:
1652         ExpressionNode* m_lexpr;
1653         ExpressionNode* m_expr;
1654         StatementNode* m_statement;
1655     };
1656 
1657     class ForInNode final : public EnumerationNode {
1658         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ForInNode);
1659     public:
1660         ForInNode(const JSTokenLocation&amp;, ExpressionNode*, ExpressionNode*, StatementNode*, VariableEnvironment&amp;);
1661 
1662     private:
1663         RegisterID* tryGetBoundLocal(BytecodeGenerator&amp;);
1664         void emitLoopHeader(BytecodeGenerator&amp;, RegisterID* propertyName);
1665 
1666         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1667     };
1668 
1669     class ForOfNode final : public EnumerationNode {
1670         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ForOfNode);
1671     public:
1672         ForOfNode(bool, const JSTokenLocation&amp;, ExpressionNode*, ExpressionNode*, StatementNode*, VariableEnvironment&amp;);
1673         bool isForOfNode() const override { return true; }
1674         bool isForAwait() const { return m_isForAwait; }
1675 
1676     private:
1677         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1678 
1679         const bool m_isForAwait;
1680     };
1681 
1682     class ContinueNode final : public StatementNode, public ThrowableExpressionData {
1683     public:
1684         ContinueNode(const JSTokenLocation&amp;, const Identifier&amp;);
1685         Label* trivialTarget(BytecodeGenerator&amp;);
1686 
1687     private:
1688         bool hasCompletionValue() const override { return false; }
1689         bool isContinue() const override { return true; }
1690         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1691 
1692         const Identifier&amp; m_ident;
1693     };
1694 
1695     class BreakNode final : public StatementNode, public ThrowableExpressionData {
1696     public:
1697         BreakNode(const JSTokenLocation&amp;, const Identifier&amp;);
1698         Label* trivialTarget(BytecodeGenerator&amp;);
1699 
1700     private:
1701         bool hasCompletionValue() const override { return false; }
1702         bool isBreak() const override { return true; }
1703         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1704 
1705         const Identifier&amp; m_ident;
1706     };
1707 
1708     class ReturnNode final : public StatementNode, public ThrowableExpressionData {
1709     public:
1710         ReturnNode(const JSTokenLocation&amp;, ExpressionNode* value);
1711 
1712         ExpressionNode* value() { return m_value; }
1713 
1714     private:
1715         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1716 
1717         bool isReturnNode() const override { return true; }
1718 
1719         ExpressionNode* m_value;
1720     };
1721 
1722     class WithNode final : public StatementNode {
1723     public:
1724         WithNode(const JSTokenLocation&amp;, ExpressionNode*, StatementNode*, const JSTextPosition&amp; divot, uint32_t expressionLength);
1725 
1726     private:
1727         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1728 
1729         ExpressionNode* m_expr;
1730         StatementNode* m_statement;
1731         JSTextPosition m_divot;
1732         uint32_t m_expressionLength;
1733     };
1734 
1735     class LabelNode final : public StatementNode, public ThrowableExpressionData {
1736     public:
1737         LabelNode(const JSTokenLocation&amp;, const Identifier&amp; name, StatementNode*);
1738 
1739         bool isLabel() const override { return true; }
1740 
1741     private:
1742         bool hasCompletionValue() const override { return m_statement-&gt;hasCompletionValue(); }
1743         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1744 
1745         const Identifier&amp; m_name;
1746         StatementNode* m_statement;
1747     };
1748 
1749     class ThrowNode final : public StatementNode, public ThrowableExpressionData {
1750     public:
1751         ThrowNode(const JSTokenLocation&amp;, ExpressionNode*);
1752 
1753     private:
1754         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1755 
1756         ExpressionNode* m_expr;
1757     };
1758 
1759     class TryNode final : public StatementNode, public VariableEnvironmentNode {
1760         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(TryNode);
1761     public:
1762         TryNode(const JSTokenLocation&amp;, StatementNode* tryBlock, DestructuringPatternNode* catchPattern, StatementNode* catchBlock, VariableEnvironment&amp; catchEnvironment, StatementNode* finallyBlock);
1763 
1764     private:
1765         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1766 
1767         StatementNode* m_tryBlock;
1768         DestructuringPatternNode* m_catchPattern;
1769         StatementNode* m_catchBlock;
1770         StatementNode* m_finallyBlock;
1771     };
1772 
1773     class ScopeNode : public StatementNode, public ParserArenaRoot, public VariableEnvironmentNode {
1774     public:
1775         // ScopeNode is never directly instantiate. The life-cycle of its derived classes are
1776         // managed using std::unique_ptr. Hence, though ScopeNode extends VariableEnvironmentNode,
1777         // which in turn extends ParserArenaDeletable, we don&#39;t want to use ParserArenaDeletable&#39;s
1778         // new for allocation.
1779         using ParserArenaRoot::operator new;
1780 
1781         ScopeNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, bool inStrictContext);
1782         ScopeNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, const SourceCode&amp;, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants);
1783 
1784         const SourceCode&amp; source() const { return m_source; }
1785         const String&amp; sourceURL() const { return m_source.provider()-&gt;url(); }
1786         intptr_t sourceID() const { return m_source.providerID(); }
1787 
1788         int startLine() const { return m_startLineNumber; }
1789         int startStartOffset() const { return m_startStartOffset; }
1790         int startLineStartOffset() const { return m_startLineStartOffset; }
1791 
1792         void setFeatures(CodeFeatures features) { m_features = features; }
1793         CodeFeatures features() { return m_features; }
1794         InnerArrowFunctionCodeFeatures innerArrowFunctionCodeFeatures() { return m_innerArrowFunctionCodeFeatures; }
1795         bool doAnyInnerArrowFunctionsUseAnyFeature() { return m_innerArrowFunctionCodeFeatures != NoInnerArrowFunctionFeatures; }
1796         bool doAnyInnerArrowFunctionsUseArguments() { return m_innerArrowFunctionCodeFeatures &amp; ArgumentsInnerArrowFunctionFeature; }
1797         bool doAnyInnerArrowFunctionsUseSuperCall() { return m_innerArrowFunctionCodeFeatures &amp; SuperCallInnerArrowFunctionFeature; }
1798         bool doAnyInnerArrowFunctionsUseSuperProperty() { return m_innerArrowFunctionCodeFeatures &amp; SuperPropertyInnerArrowFunctionFeature; }
1799         bool doAnyInnerArrowFunctionsUseEval() { return m_innerArrowFunctionCodeFeatures &amp; EvalInnerArrowFunctionFeature; }
1800         bool doAnyInnerArrowFunctionsUseThis() { return m_innerArrowFunctionCodeFeatures &amp; ThisInnerArrowFunctionFeature; }
1801         bool doAnyInnerArrowFunctionsUseNewTarget() { return m_innerArrowFunctionCodeFeatures &amp; NewTargetInnerArrowFunctionFeature; }
1802 
1803         bool usesEval() const { return m_features &amp; EvalFeature; }
1804         bool usesArguments() const { return (m_features &amp; ArgumentsFeature) &amp;&amp; !(m_features &amp; ShadowsArgumentsFeature); }
1805         bool usesArrowFunction() const { return m_features &amp; ArrowFunctionFeature; }
1806         bool isStrictMode() const { return m_features &amp; StrictModeFeature; }
1807         void setUsesArguments() { m_features |= ArgumentsFeature; }
1808         bool usesThis() const { return m_features &amp; ThisFeature; }
1809         bool usesSuperCall() const { return m_features &amp; SuperCallFeature; }
1810         bool usesSuperProperty() const { return m_features &amp; SuperPropertyFeature; }
1811         bool usesNewTarget() const { return m_features &amp; NewTargetFeature; }
1812         bool needsActivation() const { return (hasCapturedVariables()) || (m_features &amp; (EvalFeature | WithFeature)); }
1813         bool hasCapturedVariables() const { return m_varDeclarations.hasCapturedVariables(); }
1814         bool captures(UniquedStringImpl* uid) { return m_varDeclarations.captures(uid); }
1815         bool captures(const Identifier&amp; ident) { return captures(ident.impl()); }
1816         bool hasSloppyModeHoistedFunction(UniquedStringImpl* uid) const { return m_sloppyModeHoistedFunctions.contains(uid); }
1817 
1818         bool needsNewTargetRegisterForThisScope() const
1819         {
1820             return usesSuperCall() || usesNewTarget();
1821         }
1822 
1823         VariableEnvironment&amp; varDeclarations() { return m_varDeclarations; }
1824 
1825         int neededConstants()
1826         {
1827             // We may need 2 more constants than the count given by the parser,
1828             // because of the various uses of jsUndefined() and jsNull().
1829             return m_numConstants + 2;
1830         }
1831 
1832         StatementNode* singleStatement() const;
1833 
1834         bool hasCompletionValue() const override;
1835         bool hasEarlyBreakOrContinue() const override;
1836 
1837         void emitStatementsBytecode(BytecodeGenerator&amp;, RegisterID* destination);
1838 
1839         void analyzeModule(ModuleAnalyzer&amp;);
1840 
1841     protected:
1842         int m_startLineNumber;
1843         unsigned m_startStartOffset;
1844         unsigned m_startLineStartOffset;
1845 
1846     private:
1847         CodeFeatures m_features;
1848         InnerArrowFunctionCodeFeatures m_innerArrowFunctionCodeFeatures;
1849         SourceCode m_source;
1850         VariableEnvironment m_varDeclarations;
1851         UniquedStringImplPtrSet m_sloppyModeHoistedFunctions;
1852         int m_numConstants;
1853         SourceElements* m_statements;
1854     };
1855 
1856     class ProgramNode final : public ScopeNode {
1857     public:
1858         ProgramNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
1859 
1860         unsigned startColumn() const { return m_startColumn; }
1861         unsigned endColumn() const { return m_endColumn; }
1862 
<a name="23" id="anc23"></a><span class="line-modified">1863         static constexpr bool scopeIsFunction = false;</span>
1864 
1865     private:
1866         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1867         unsigned m_startColumn;
1868         unsigned m_endColumn;
1869     };
1870 
1871     class EvalNode final : public ScopeNode {
1872     public:
1873         EvalNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
1874 
1875         ALWAYS_INLINE unsigned startColumn() const { return 0; }
1876         unsigned endColumn() const { return m_endColumn; }
1877 
<a name="24" id="anc24"></a><span class="line-modified">1878         static constexpr bool scopeIsFunction = false;</span>
1879 
1880     private:
1881         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1882 
1883         unsigned m_endColumn;
1884     };
1885 
1886     class ModuleProgramNode final : public ScopeNode {
1887     public:
1888         ModuleProgramNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
1889 
1890         unsigned startColumn() const { return m_startColumn; }
1891         unsigned endColumn() const { return m_endColumn; }
1892 
<a name="25" id="anc25"></a><span class="line-modified">1893         static constexpr bool scopeIsFunction = false;</span>
1894 
1895         ModuleScopeData&amp; moduleScopeData()
1896         {
1897             return m_moduleScopeData;
1898         }
1899 
1900     private:
1901         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1902         unsigned m_startColumn;
1903         unsigned m_endColumn;
1904         Ref&lt;ModuleScopeData&gt; m_moduleScopeData;
1905     };
1906 
1907     class ModuleNameNode final : public Node {
1908     public:
1909         ModuleNameNode(const JSTokenLocation&amp;, const Identifier&amp; moduleName);
1910 
1911         const Identifier&amp; moduleName() { return m_moduleName; }
1912 
1913     private:
1914         const Identifier&amp; m_moduleName;
1915     };
1916 
1917     class ImportSpecifierNode final : public Node {
1918     public:
1919         ImportSpecifierNode(const JSTokenLocation&amp;, const Identifier&amp; importedName, const Identifier&amp; localName);
1920 
1921         const Identifier&amp; importedName() { return m_importedName; }
1922         const Identifier&amp; localName() { return m_localName; }
1923 
1924     private:
1925         const Identifier&amp; m_importedName;
1926         const Identifier&amp; m_localName;
1927     };
1928 
1929     class ImportSpecifierListNode final : public ParserArenaDeletable {
1930         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ImportSpecifierListNode);
1931     public:
1932         typedef Vector&lt;ImportSpecifierNode*, 3&gt; Specifiers;
1933 
1934         const Specifiers&amp; specifiers() const { return m_specifiers; }
1935         void append(ImportSpecifierNode* specifier)
1936         {
1937             m_specifiers.append(specifier);
1938         }
1939 
1940     private:
1941         Specifiers m_specifiers;
1942     };
1943 
1944     class ModuleDeclarationNode : public StatementNode {
1945     public:
1946         virtual void analyzeModule(ModuleAnalyzer&amp;) = 0;
1947         bool hasCompletionValue() const override { return false; }
1948         bool isModuleDeclarationNode() const override { return true; }
1949 
1950     protected:
1951         ModuleDeclarationNode(const JSTokenLocation&amp;);
1952     };
1953 
1954     class ImportDeclarationNode final : public ModuleDeclarationNode {
1955     public:
1956         ImportDeclarationNode(const JSTokenLocation&amp;, ImportSpecifierListNode*, ModuleNameNode*);
1957 
1958         ImportSpecifierListNode* specifierList() const { return m_specifierList; }
1959         ModuleNameNode* moduleName() const { return m_moduleName; }
1960 
1961     private:
1962         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1963         void analyzeModule(ModuleAnalyzer&amp;) override;
1964 
1965         ImportSpecifierListNode* m_specifierList;
1966         ModuleNameNode* m_moduleName;
1967     };
1968 
1969     class ExportAllDeclarationNode final : public ModuleDeclarationNode {
1970     public:
1971         ExportAllDeclarationNode(const JSTokenLocation&amp;, ModuleNameNode*);
1972 
1973         ModuleNameNode* moduleName() const { return m_moduleName; }
1974 
1975     private:
1976         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1977         void analyzeModule(ModuleAnalyzer&amp;) override;
1978 
1979         ModuleNameNode* m_moduleName;
1980     };
1981 
1982     class ExportDefaultDeclarationNode final : public ModuleDeclarationNode {
1983     public:
1984         ExportDefaultDeclarationNode(const JSTokenLocation&amp;, StatementNode*, const Identifier&amp; localName);
1985 
1986         const StatementNode&amp; declaration() const { return *m_declaration; }
1987         const Identifier&amp; localName() const { return m_localName; }
1988 
1989     private:
1990         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1991         void analyzeModule(ModuleAnalyzer&amp;) override;
1992         StatementNode* m_declaration;
1993         const Identifier&amp; m_localName;
1994     };
1995 
1996     class ExportLocalDeclarationNode final : public ModuleDeclarationNode {
1997     public:
1998         ExportLocalDeclarationNode(const JSTokenLocation&amp;, StatementNode*);
1999 
2000         const StatementNode&amp; declaration() const { return *m_declaration; }
2001 
2002     private:
2003         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2004         void analyzeModule(ModuleAnalyzer&amp;) override;
2005         StatementNode* m_declaration;
2006     };
2007 
2008     class ExportSpecifierNode final : public Node {
2009     public:
2010         ExportSpecifierNode(const JSTokenLocation&amp;, const Identifier&amp; localName, const Identifier&amp; exportedName);
2011 
2012         const Identifier&amp; exportedName() { return m_exportedName; }
2013         const Identifier&amp; localName() { return m_localName; }
2014 
2015     private:
2016         const Identifier&amp; m_localName;
2017         const Identifier&amp; m_exportedName;
2018     };
2019 
2020     class ExportSpecifierListNode final : public ParserArenaDeletable {
2021         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ExportSpecifierListNode);
2022     public:
2023         typedef Vector&lt;ExportSpecifierNode*, 3&gt; Specifiers;
2024 
2025         const Specifiers&amp; specifiers() const { return m_specifiers; }
2026         void append(ExportSpecifierNode* specifier)
2027         {
2028             m_specifiers.append(specifier);
2029         }
2030 
2031     private:
2032         Specifiers m_specifiers;
2033     };
2034 
2035     class ExportNamedDeclarationNode final : public ModuleDeclarationNode {
2036     public:
2037         ExportNamedDeclarationNode(const JSTokenLocation&amp;, ExportSpecifierListNode*, ModuleNameNode*);
2038 
2039         ExportSpecifierListNode* specifierList() const { return m_specifierList; }
2040         ModuleNameNode* moduleName() const { return m_moduleName; }
2041 
2042     private:
2043         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2044         void analyzeModule(ModuleAnalyzer&amp;) override;
2045         ExportSpecifierListNode* m_specifierList;
2046         ModuleNameNode* m_moduleName { nullptr };
2047     };
2048 
2049     class FunctionMetadataNode final : public ParserArenaDeletable, public Node {
2050         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(FunctionMetadataNode);
2051     public:
2052         FunctionMetadataNode(
2053             ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end,
2054             unsigned startColumn, unsigned endColumn, int functionKeywordStart,
2055             int functionNameStart, int parametersStart, bool isInStrictContext,
2056             ConstructorKind, SuperBinding, unsigned parameterCount,
2057             SourceParseMode, bool isArrowFunctionBodyExpression);
2058         FunctionMetadataNode(
2059             const JSTokenLocation&amp; start, const JSTokenLocation&amp; end,
2060             unsigned startColumn, unsigned endColumn, int functionKeywordStart,
2061             int functionNameStart, int parametersStart, bool isInStrictContext,
2062             ConstructorKind, SuperBinding, unsigned parameterCount,
2063             SourceParseMode, bool isArrowFunctionBodyExpression);
2064 
2065         void dump(PrintStream&amp;) const;
2066 
2067         void finishParsing(const SourceCode&amp;, const Identifier&amp;, FunctionMode);
2068 
2069         void overrideName(const Identifier&amp; ident) { m_ident = ident; }
2070         const Identifier&amp; ident() { return m_ident; }
2071         void setEcmaName(const Identifier&amp; ecmaName) { m_ecmaName = ecmaName; }
2072         const Identifier&amp; ecmaName() { return m_ident.isEmpty() ? m_ecmaName : m_ident; }
2073 
2074         FunctionMode functionMode() { return m_functionMode; }
2075 
2076         int functionNameStart() const { return m_functionNameStart; }
2077         int functionKeywordStart() const { return m_functionKeywordStart; }
2078         int parametersStart() const { return m_parametersStart; }
2079         unsigned startColumn() const { return m_startColumn; }
2080         unsigned endColumn() const { return m_endColumn; }
2081         unsigned parameterCount() const { return m_parameterCount; }
2082         SourceParseMode parseMode() const { return m_parseMode; }
2083 
2084         void setEndPosition(JSTextPosition);
2085 
2086         const SourceCode&amp; source() const { return m_source; }
2087         const SourceCode&amp; classSource() const { return m_classSource; }
2088         void setClassSource(const SourceCode&amp; source) { m_classSource = source; }
2089 
2090         int startStartOffset() const { return m_startStartOffset; }
2091         bool isInStrictContext() const { return m_isInStrictContext; }
2092         SuperBinding superBinding() { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
2093         ConstructorKind constructorKind() { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
<a name="26" id="anc26"></a><span class="line-added">2094         bool isConstructorAndNeedsClassFieldInitializer() const { return m_needsClassFieldInitializer; }</span>
<span class="line-added">2095         void setNeedsClassFieldInitializer(bool value)</span>
<span class="line-added">2096         {</span>
<span class="line-added">2097             ASSERT(!value || constructorKind() != ConstructorKind::None);</span>
<span class="line-added">2098             m_needsClassFieldInitializer = value;</span>
<span class="line-added">2099         }</span>
2100         bool isArrowFunctionBodyExpression() const { return m_isArrowFunctionBodyExpression; }
2101 
2102         void setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset)
2103         {
2104             m_lastLine = lastLine;
2105             m_position = JSTextPosition(firstLine, startOffset, lineStartOffset);
2106             ASSERT(m_position.offset &gt;= m_position.lineStartOffset);
2107         }
2108         unsigned lastLine() const { return m_lastLine; }
2109 
2110         bool operator==(const FunctionMetadataNode&amp;) const;
2111         bool operator!=(const FunctionMetadataNode&amp; other) const
2112         {
2113             return !(*this == other);
2114         }
2115 
2116     public:
2117         unsigned m_isInStrictContext : 1;
2118         unsigned m_superBinding : 1;
2119         unsigned m_constructorKind : 2;
<a name="27" id="anc27"></a><span class="line-added">2120         unsigned m_needsClassFieldInitializer : 1;</span>
2121         unsigned m_isArrowFunctionBodyExpression : 1;
2122         SourceParseMode m_parseMode;
2123         FunctionMode m_functionMode;
2124         Identifier m_ident;
2125         Identifier m_ecmaName;
2126         unsigned m_startColumn;
2127         unsigned m_endColumn;
2128         int m_functionKeywordStart;
2129         int m_functionNameStart;
2130         int m_parametersStart;
2131         SourceCode m_source;
2132         SourceCode m_classSource;
2133         int m_startStartOffset;
2134         unsigned m_parameterCount;
<a name="28" id="anc28"></a><span class="line-modified">2135         int m_lastLine { 0 };</span>
2136     };
2137 
2138     class FunctionNode final : public ScopeNode {
2139     public:
2140         FunctionNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
2141 
2142         FunctionParameters* parameters() const { return m_parameters; }
2143 
2144         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2145 
2146         bool isFunctionNode() const override { return true; }
2147 
2148         void finishParsing(const Identifier&amp;, FunctionMode);
2149 
2150         const Identifier&amp; ident() { return m_ident; }
2151 
2152         FunctionMode functionMode() const { return m_functionMode; }
2153 
2154         unsigned startColumn() const { return m_startColumn; }
2155         unsigned endColumn() const { return m_endColumn; }
2156 
<a name="29" id="anc29"></a><span class="line-modified">2157         static constexpr bool scopeIsFunction = true;</span>
2158 
2159     private:
2160         Identifier m_ident;
2161         FunctionMode m_functionMode;
2162         FunctionParameters* m_parameters;
2163         unsigned m_startColumn;
2164         unsigned m_endColumn;
2165     };
2166 
2167     class BaseFuncExprNode : public ExpressionNode {
2168     public:
2169         FunctionMetadataNode* metadata() { return m_metadata; }
2170 
2171         bool isBaseFuncExprNode() const override { return true; }
2172 
2173     protected:
2174         BaseFuncExprNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;, FunctionMode);
2175 
2176         FunctionMetadataNode* m_metadata;
2177     };
2178 
2179 
2180     class FuncExprNode : public BaseFuncExprNode {
2181     public:
2182         FuncExprNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;);
2183 
2184     protected:
2185         FuncExprNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;, FunctionMode);
2186 
2187     private:
2188         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2189 
2190         bool isFuncExprNode() const override { return true; }
2191     };
2192 
2193     class ArrowFuncExprNode final : public BaseFuncExprNode {
2194     public:
2195         ArrowFuncExprNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;);
2196 
2197     private:
2198         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2199 
2200         bool isArrowFuncExprNode() const override { return true; }
2201     };
2202 
2203     class MethodDefinitionNode final : public FuncExprNode {
2204     public:
2205         MethodDefinitionNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;);
2206 
2207     private:
2208         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2209     };
2210 
2211     class YieldExprNode final : public ExpressionNode, public ThrowableExpressionData {
2212     public:
2213         YieldExprNode(const JSTokenLocation&amp;, ExpressionNode* argument, bool delegate);
2214 
2215         ExpressionNode* argument() const { return m_argument; }
2216         bool delegate() const { return m_delegate; }
2217 
2218     private:
2219         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2220 
2221         ExpressionNode* m_argument;
2222         bool m_delegate;
2223     };
2224 
2225     class AwaitExprNode final : public ExpressionNode, public ThrowableExpressionData {
2226     public:
2227         AwaitExprNode(const JSTokenLocation&amp;, ExpressionNode* argument);
2228 
2229         ExpressionNode* argument() const { return m_argument; }
2230 
2231     private:
2232         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2233 
2234         ExpressionNode* m_argument;
2235     };
2236 
<a name="30" id="anc30"></a><span class="line-added">2237     class DefineFieldNode final : public StatementNode {</span>
<span class="line-added">2238     public:</span>
<span class="line-added">2239         enum class Type { Name, ComputedName };</span>
<span class="line-added">2240         DefineFieldNode(const JSTokenLocation&amp;, const Identifier*, ExpressionNode*, Type);</span>
<span class="line-added">2241 </span>
<span class="line-added">2242     private:</span>
<span class="line-added">2243         void emitBytecode(BytecodeGenerator&amp;, RegisterID* destination = nullptr) override;</span>
<span class="line-added">2244 </span>
<span class="line-added">2245         bool isDefineFieldNode() const override { return true; }</span>
<span class="line-added">2246 </span>
<span class="line-added">2247         const Identifier* m_ident;</span>
<span class="line-added">2248         ExpressionNode* m_assign;</span>
<span class="line-added">2249         Type m_type;</span>
<span class="line-added">2250     };</span>
<span class="line-added">2251 </span>
2252     class ClassExprNode final : public ExpressionNode, public VariableEnvironmentNode {
2253         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ClassExprNode);
2254     public:
2255         ClassExprNode(const JSTokenLocation&amp;, const Identifier&amp;, const SourceCode&amp; classSource,
2256             VariableEnvironment&amp; classEnvironment, ExpressionNode* constructorExpresssion,
2257             ExpressionNode* parentClass, PropertyListNode* classElements);
2258 
2259         const Identifier&amp; name() { return m_name; }
2260         const Identifier&amp; ecmaName() { return m_ecmaName ? *m_ecmaName : m_name; }
2261         void setEcmaName(const Identifier&amp; name) { m_ecmaName = m_name.isNull() ? &amp;name : &amp;m_name; }
2262 
2263         bool hasStaticProperty(const Identifier&amp; propName) { return m_classElements ? m_classElements-&gt;hasStaticallyNamedProperty(propName) : false; }
<a name="31" id="anc31"></a><span class="line-added">2264         bool hasInstanceFields() const { return m_classElements ? m_classElements-&gt;hasInstanceFields() : false; }</span>
2265 
2266     private:
2267         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2268 
2269         bool isClassExprNode() const override { return true; }
2270 
2271         SourceCode m_classSource;
2272         const Identifier&amp; m_name;
2273         const Identifier* m_ecmaName;
2274         ExpressionNode* m_constructorExpression;
2275         ExpressionNode* m_classHeritage;
2276         PropertyListNode* m_classElements;
<a name="32" id="anc32"></a><span class="line-added">2277         bool m_needsLexicalScope;</span>
2278     };
2279 
2280     class DestructuringPatternNode : public ParserArenaFreeable {
2281     public:
2282         virtual ~DestructuringPatternNode() { }
2283         virtual void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const = 0;
2284         virtual void bindValue(BytecodeGenerator&amp;, RegisterID* source) const = 0;
2285         virtual void toString(StringBuilder&amp;) const = 0;
2286 
2287         virtual bool isBindingNode() const { return false; }
2288         virtual bool isAssignmentElementNode() const { return false; }
2289         virtual bool isRestParameter() const { return false; }
2290         virtual RegisterID* emitDirectBinding(BytecodeGenerator&amp;, RegisterID*, ExpressionNode*) { return 0; }
2291 
2292     protected:
2293         DestructuringPatternNode();
2294     };
2295 
2296     class ArrayPatternNode final : public DestructuringPatternNode, public ParserArenaDeletable, public ThrowableExpressionData {
2297         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ArrayPatternNode);
2298     public:
2299         ArrayPatternNode();
2300         enum class BindingType : uint8_t {
2301             Elision,
2302             Element,
2303             RestElement
2304         };
2305 
2306         void appendIndex(BindingType bindingType, const JSTokenLocation&amp;, DestructuringPatternNode* node, ExpressionNode* defaultValue)
2307         {
2308             m_targetPatterns.append({ bindingType, node, defaultValue });
2309         }
2310 
2311     private:
2312         struct Entry {
2313             BindingType bindingType;
2314             DestructuringPatternNode* pattern;
2315             ExpressionNode* defaultValue;
2316         };
2317         void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const override;
2318         void bindValue(BytecodeGenerator&amp;, RegisterID*) const override;
2319         RegisterID* emitDirectBinding(BytecodeGenerator&amp;, RegisterID* dst, ExpressionNode*) override;
2320         void toString(StringBuilder&amp;) const override;
2321 
2322         Vector&lt;Entry&gt; m_targetPatterns;
2323     };
2324 
2325     class ObjectPatternNode final : public DestructuringPatternNode, public ParserArenaDeletable, public ThrowableExpressionData {
2326         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ObjectPatternNode);
2327     public:
2328         ObjectPatternNode();
2329         enum class BindingType : uint8_t {
2330             Element,
2331             RestElement
2332         };
2333         void appendEntry(const JSTokenLocation&amp;, const Identifier&amp; identifier, bool wasString, DestructuringPatternNode* pattern, ExpressionNode* defaultValue, BindingType bindingType)
2334         {
2335             m_targetPatterns.append(Entry{ identifier, nullptr, wasString, pattern, defaultValue, bindingType });
2336         }
2337 
2338         void appendEntry(VM&amp; vm, const JSTokenLocation&amp;, ExpressionNode* propertyExpression, DestructuringPatternNode* pattern, ExpressionNode* defaultValue, BindingType bindingType)
2339         {
2340             m_targetPatterns.append(Entry{ vm.propertyNames-&gt;nullIdentifier, propertyExpression, false, pattern, defaultValue, bindingType });
2341         }
2342 
2343         void setContainsRestElement(bool containsRestElement)
2344         {
2345             m_containsRestElement = containsRestElement;
2346         }
2347 
2348         void setContainsComputedProperty(bool containsComputedProperty)
2349         {
2350             m_containsComputedProperty = containsComputedProperty;
2351         }
2352 
2353     private:
2354         void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const override;
2355         void bindValue(BytecodeGenerator&amp;, RegisterID*) const override;
2356         void toString(StringBuilder&amp;) const override;
2357         struct Entry {
2358             const Identifier&amp; propertyName;
2359             ExpressionNode* propertyExpression;
2360             bool wasString;
2361             DestructuringPatternNode* pattern;
2362             ExpressionNode* defaultValue;
2363             BindingType bindingType;
2364         };
2365         bool m_containsRestElement { false };
2366         bool m_containsComputedProperty { false };
2367         Vector&lt;Entry&gt; m_targetPatterns;
2368     };
2369 
2370     class BindingNode final: public DestructuringPatternNode {
2371     public:
2372         BindingNode(const Identifier&amp; boundProperty, const JSTextPosition&amp; start, const JSTextPosition&amp; end, AssignmentContext);
2373         const Identifier&amp; boundProperty() const { return m_boundProperty; }
2374 
2375         const JSTextPosition&amp; divotStart() const { return m_divotStart; }
2376         const JSTextPosition&amp; divotEnd() const { return m_divotEnd; }
2377 
2378     private:
2379         void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const override;
2380         void bindValue(BytecodeGenerator&amp;, RegisterID*) const override;
2381         void toString(StringBuilder&amp;) const override;
2382 
2383         bool isBindingNode() const override { return true; }
2384 
2385         JSTextPosition m_divotStart;
2386         JSTextPosition m_divotEnd;
2387         const Identifier&amp; m_boundProperty;
2388         AssignmentContext m_bindingContext;
2389     };
2390 
2391     class RestParameterNode final : public DestructuringPatternNode {
2392     public:
2393         RestParameterNode(DestructuringPatternNode*, unsigned numParametersToSkip);
2394 
2395         bool isRestParameter() const override { return true; }
2396 
2397         void emit(BytecodeGenerator&amp;);
2398 
2399     private:
2400         void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const override;
2401         void bindValue(BytecodeGenerator&amp;, RegisterID*) const override;
2402         void toString(StringBuilder&amp;) const override;
2403 
2404         DestructuringPatternNode* m_pattern;
2405         unsigned m_numParametersToSkip;
2406     };
2407 
2408     class AssignmentElementNode final : public DestructuringPatternNode {
2409     public:
2410         AssignmentElementNode(ExpressionNode* assignmentTarget, const JSTextPosition&amp; start, const JSTextPosition&amp; end);
2411         const ExpressionNode* assignmentTarget() { return m_assignmentTarget; }
2412 
2413         const JSTextPosition&amp; divotStart() const { return m_divotStart; }
2414         const JSTextPosition&amp; divotEnd() const { return m_divotEnd; }
2415 
2416     private:
2417         void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const override;
2418         void bindValue(BytecodeGenerator&amp;, RegisterID*) const override;
2419         void toString(StringBuilder&amp;) const override;
2420 
2421         bool isAssignmentElementNode() const override { return true; }
2422 
2423         JSTextPosition m_divotStart;
2424         JSTextPosition m_divotEnd;
2425         ExpressionNode* m_assignmentTarget;
2426     };
2427 
2428     class DestructuringAssignmentNode final : public ExpressionNode {
2429     public:
2430         DestructuringAssignmentNode(const JSTokenLocation&amp;, DestructuringPatternNode*, ExpressionNode*);
2431         DestructuringPatternNode* bindings() { return m_bindings; }
2432 
2433     private:
2434         bool isAssignmentLocation() const override { return true; }
2435         bool isDestructuringNode() const override { return true; }
2436         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2437 
2438         DestructuringPatternNode* m_bindings;
2439         ExpressionNode* m_initializer;
2440     };
2441 
2442     class FunctionParameters final : public ParserArenaDeletable {
2443         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(FunctionParameters);
2444     public:
2445         FunctionParameters();
2446         ALWAYS_INLINE unsigned size() const { return m_patterns.size(); }
2447         ALWAYS_INLINE std::pair&lt;DestructuringPatternNode*, ExpressionNode*&gt; at(unsigned index) { return m_patterns[index]; }
2448         ALWAYS_INLINE void append(DestructuringPatternNode* pattern, ExpressionNode* defaultValue)
2449         {
2450             ASSERT(pattern);
2451 
2452             // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
2453             // This implements IsSimpleParameterList in the Ecma 2015 spec.
2454             // If IsSimpleParameterList is false, we will create a strict-mode like arguments object.
2455             // IsSimpleParameterList is false if the argument list contains any default parameter values,
2456             // a rest parameter, or any destructuring patterns.
2457             // If we do have default parameters, destructuring parameters, or a rest parameter, our parameters will be allocated in a different scope.
2458 
2459             bool hasDefaultParameterValue = defaultValue;
2460             bool isSimpleParameter = !hasDefaultParameterValue &amp;&amp; pattern-&gt;isBindingNode();
2461             m_isSimpleParameterList &amp;= isSimpleParameter;
2462 
2463             m_patterns.append(std::make_pair(pattern, defaultValue));
2464         }
2465         ALWAYS_INLINE bool isSimpleParameterList() const { return m_isSimpleParameterList; }
2466 
2467     private:
2468 
2469         Vector&lt;std::pair&lt;DestructuringPatternNode*, ExpressionNode*&gt;, 3&gt; m_patterns;
2470         bool m_isSimpleParameterList { true };
2471     };
2472 
2473     class FuncDeclNode final : public StatementNode {
2474     public:
2475         FuncDeclNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;);
2476 
2477         bool hasCompletionValue() const override { return false; }
2478         bool isFuncDeclNode() const override { return true; }
2479         FunctionMetadataNode* metadata() { return m_metadata; }
2480 
2481     private:
2482         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2483 
2484         FunctionMetadataNode* m_metadata;
2485     };
2486 
2487     class ClassDeclNode final : public StatementNode {
2488     public:
2489         ClassDeclNode(const JSTokenLocation&amp;, ExpressionNode* classExpression);
2490 
2491     private:
2492         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2493 
2494         bool hasCompletionValue() const override { return false; }
2495 
2496         ExpressionNode* m_classDeclaration;
2497     };
2498 
2499     class CaseClauseNode final : public ParserArenaFreeable {
2500     public:
2501         CaseClauseNode(ExpressionNode*, SourceElements* = 0);
2502 
2503         ExpressionNode* expr() const { return m_expr; }
2504 
2505         void emitBytecode(BytecodeGenerator&amp;, RegisterID* destination);
2506         void setStartOffset(int offset) { m_startOffset = offset; }
2507 
2508     private:
2509         ExpressionNode* m_expr;
2510         SourceElements* m_statements;
2511         int m_startOffset;
2512     };
2513 
2514     class ClauseListNode final : public ParserArenaFreeable {
2515     public:
2516         ClauseListNode(CaseClauseNode*);
2517         ClauseListNode(ClauseListNode*, CaseClauseNode*);
2518 
2519         CaseClauseNode* getClause() const { return m_clause; }
2520         ClauseListNode* getNext() const { return m_next; }
2521 
2522     private:
2523         CaseClauseNode* m_clause;
2524         ClauseListNode* m_next { nullptr };
2525     };
2526 
2527     class CaseBlockNode final : public ParserArenaFreeable {
2528     public:
2529         CaseBlockNode(ClauseListNode* list1, CaseClauseNode* defaultClause, ClauseListNode* list2);
2530 
2531         void emitBytecodeForBlock(BytecodeGenerator&amp;, RegisterID* input, RegisterID* destination);
2532 
2533     private:
2534         SwitchInfo::SwitchType tryTableSwitch(Vector&lt;ExpressionNode*, 8&gt;&amp; literalVector, int32_t&amp; min_num, int32_t&amp; max_num);
<a name="33" id="anc33"></a><span class="line-modified">2535         static constexpr size_t s_tableSwitchMinimum = 3;</span>
2536         ClauseListNode* m_list1;
2537         CaseClauseNode* m_defaultClause;
2538         ClauseListNode* m_list2;
2539     };
2540 
2541     class SwitchNode final : public StatementNode, public VariableEnvironmentNode {
2542         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(SwitchNode);
2543     public:
2544         SwitchNode(const JSTokenLocation&amp;, ExpressionNode*, CaseBlockNode*, VariableEnvironment&amp;, FunctionStack&amp;&amp;);
2545 
2546     private:
2547         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2548 
2549         ExpressionNode* m_expr;
2550         CaseBlockNode* m_block;
2551     };
2552 
2553     struct ElementList {
2554         ElementNode* head;
2555         ElementNode* tail;
2556     };
2557 
2558     struct PropertyList {
2559         PropertyListNode* head;
2560         PropertyListNode* tail;
2561     };
2562 
2563     struct ArgumentList {
2564         ArgumentListNode* head;
2565         ArgumentListNode* tail;
2566     };
2567 
2568     struct ClauseList {
2569         ClauseListNode* head;
2570         ClauseListNode* tail;
2571     };
2572 
2573 } // namespace JSC
<a name="34" id="anc34"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="34" type="hidden" />
</body>
</html>
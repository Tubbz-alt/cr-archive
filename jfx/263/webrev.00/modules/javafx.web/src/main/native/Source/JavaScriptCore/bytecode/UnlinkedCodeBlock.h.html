<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012-2019 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;BytecodeConventions.h&quot;
 29 #include &quot;CodeType.h&quot;
 30 #include &quot;DFGExitProfile.h&quot;
 31 #include &quot;ExpressionRangeInfo.h&quot;
 32 #include &quot;HandlerInfo.h&quot;
 33 #include &quot;Identifier.h&quot;
 34 #include &quot;InstructionStream.h&quot;
 35 #include &quot;JSCast.h&quot;
 36 #include &quot;LockDuringMarking.h&quot;
 37 #include &quot;Opcode.h&quot;
 38 #include &quot;ParserModes.h&quot;
 39 #include &quot;RegExp.h&quot;
 40 #include &quot;UnlinkedFunctionExecutable.h&quot;
 41 #include &quot;UnlinkedMetadataTable.h&quot;
 42 #include &quot;VirtualRegister.h&quot;
 43 #include &lt;algorithm&gt;
 44 #include &lt;wtf/BitVector.h&gt;
 45 #include &lt;wtf/HashSet.h&gt;
 46 #include &lt;wtf/RefCountedArray.h&gt;
 47 #include &lt;wtf/TriState.h&gt;
 48 #include &lt;wtf/Vector.h&gt;
 49 #include &lt;wtf/text/UniquedStringImpl.h&gt;
 50 
 51 namespace JSC {
 52 
 53 class BytecodeLivenessAnalysis;
 54 class BytecodeRewriter;
 55 class CodeBlock;
 56 class Debugger;
 57 class FunctionExecutable;
 58 class ParserError;
 59 class ScriptExecutable;
 60 class SourceCode;
 61 class SourceProvider;
 62 class UnlinkedCodeBlock;
 63 class UnlinkedCodeBlockGenerator;
 64 class UnlinkedFunctionCodeBlock;
 65 class UnlinkedFunctionExecutable;
 66 struct ExecutableInfo;
 67 enum class LinkTimeConstant : int32_t;
 68 
 69 template&lt;typename CodeBlockType&gt;
 70 class CachedCodeBlock;
 71 
 72 typedef unsigned UnlinkedValueProfile;
 73 typedef unsigned UnlinkedArrayProfile;
 74 typedef unsigned UnlinkedArrayAllocationProfile;
 75 typedef unsigned UnlinkedObjectAllocationProfile;
 76 typedef unsigned UnlinkedLLIntCallLinkInfo;
 77 using ConstantIdentifierSetEntry = std::pair&lt;IdentifierSet, unsigned&gt;;
 78 
 79 struct UnlinkedStringJumpTable {
 80     struct OffsetLocation {
 81         int32_t branchOffset;
 82     };
 83 
 84     typedef HashMap&lt;RefPtr&lt;StringImpl&gt;, OffsetLocation&gt; StringOffsetTable;
 85     StringOffsetTable offsetTable;
 86 
 87     inline int32_t offsetForValue(StringImpl* value, int32_t defaultOffset)
 88     {
 89         StringOffsetTable::const_iterator end = offsetTable.end();
 90         StringOffsetTable::const_iterator loc = offsetTable.find(value);
 91         if (loc == end)
 92             return defaultOffset;
 93         return loc-&gt;value.branchOffset;
 94     }
 95 
 96 };
 97 
 98 struct UnlinkedSimpleJumpTable {
 99     RefCountedArray&lt;int32_t&gt; branchOffsets;
100     int32_t min;
101 
102     int32_t offsetForValue(int32_t value, int32_t defaultOffset);
103     void add(int32_t key, int32_t offset)
104     {
105         if (!branchOffsets[key])
106             branchOffsets[key] = offset;
107     }
108 };
109 
110 class UnlinkedCodeBlock : public JSCell {
111 public:
112     typedef JSCell Base;
113     static constexpr unsigned StructureFlags = Base::StructureFlags;
114 
115     static constexpr bool needsDestruction = true;
116 
117     template&lt;typename, SubspaceAccess&gt;
118     static void subspaceFor(VM&amp;)
119     {
120         RELEASE_ASSERT_NOT_REACHED();
121     }
122 
123     enum { CallFunction, ApplyFunction };
124 
125     bool isConstructor() const { return m_isConstructor; }
126     bool isStrictMode() const { return m_isStrictMode; }
127     bool usesEval() const { return m_usesEval; }
128     SourceParseMode parseMode() const { return m_parseMode; }
129     bool isArrowFunction() const { return isArrowFunctionParseMode(parseMode()); }
130     DerivedContextType derivedContextType() const { return static_cast&lt;DerivedContextType&gt;(m_derivedContextType); }
131     EvalContextType evalContextType() const { return static_cast&lt;EvalContextType&gt;(m_evalContextType); }
132     bool isArrowFunctionContext() const { return m_isArrowFunctionContext; }
133     bool isClassContext() const { return m_isClassContext; }
134     bool hasTailCalls() const { return m_hasTailCalls; }
135     void setHasTailCalls() { m_hasTailCalls = true; }
136     bool allowDirectEvalCache() const { return !(m_features &amp; NoEvalCacheFeature); }
137 
138     bool hasExpressionInfo() { return m_expressionInfo.size(); }
139     const RefCountedArray&lt;ExpressionRangeInfo&gt;&amp; expressionInfo() { return m_expressionInfo; }
140 
141     bool hasCheckpoints() const { return m_hasCheckpoints; }
142     void setHasCheckpoints() { m_hasCheckpoints = true; }
143 
144     // Special registers
145     void setThisRegister(VirtualRegister thisRegister) { m_thisRegister = thisRegister; }
146     void setScopeRegister(VirtualRegister scopeRegister) { m_scopeRegister = scopeRegister; }
147 
148     // Parameter information
149     void setNumParameters(int newValue) { m_numParameters = newValue; }
150     unsigned numParameters() const { return m_numParameters; }
151 
152     // Constant Pools
153 
154     size_t numberOfIdentifiers() const { return m_identifiers.size(); }
155     const Identifier&amp; identifier(int index) const { return m_identifiers[index]; }
156     const RefCountedArray&lt;Identifier&gt;&amp; identifiers() const { return m_identifiers; }
157 
158     BitVector&amp; bitVector(size_t i) { ASSERT(m_rareData); return m_rareData-&gt;m_bitVectors[i]; }
159 
160     const RefCountedArray&lt;WriteBarrier&lt;Unknown&gt;&gt;&amp; constantRegisters() { return m_constantRegisters; }
161     const WriteBarrier&lt;Unknown&gt;&amp; constantRegister(VirtualRegister reg) const { return m_constantRegisters[reg.toConstantIndex()]; }
162     ALWAYS_INLINE JSValue getConstant(VirtualRegister reg) const { return m_constantRegisters[reg.toConstantIndex()].get(); }
163     const RefCountedArray&lt;SourceCodeRepresentation&gt;&amp; constantsSourceCodeRepresentation() { return m_constantsSourceCodeRepresentation; }
164 
165     unsigned numberOfConstantIdentifierSets() const { return m_rareData ? m_rareData-&gt;m_constantIdentifierSets.size() : 0; }
166     const RefCountedArray&lt;ConstantIdentifierSetEntry&gt;&amp; constantIdentifierSets() { ASSERT(m_rareData); return m_rareData-&gt;m_constantIdentifierSets; }
167 
168     // Jumps
169     size_t numberOfJumpTargets() const { return m_jumpTargets.size(); }
170     unsigned jumpTarget(int index) const { return m_jumpTargets[index]; }
171     unsigned lastJumpTarget() const { return m_jumpTargets.last(); }
172 
173     UnlinkedHandlerInfo* handlerForBytecodeIndex(BytecodeIndex, RequiredHandler = RequiredHandler::AnyHandler);
174     UnlinkedHandlerInfo* handlerForIndex(unsigned, RequiredHandler = RequiredHandler::AnyHandler);
175 
176     bool isBuiltinFunction() const { return m_isBuiltinFunction; }
177 
178     ConstructorKind constructorKind() const { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
179     SuperBinding superBinding() const { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
180     JSParserScriptMode scriptMode() const { return static_cast&lt;JSParserScriptMode&gt;(m_scriptMode); }
181 
182     const InstructionStream&amp; instructions() const;
183 
184     int numCalleeLocals() const { return m_numCalleeLocals; }
185     int numVars() const { return m_numVars; }
186 
187     // Jump Tables
188 
189     size_t numberOfSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_switchJumpTables.size() : 0; }
190     UnlinkedSimpleJumpTable&amp; switchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_switchJumpTables[tableIndex]; }
191 
192     size_t numberOfStringSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_stringSwitchJumpTables.size() : 0; }
193     UnlinkedStringJumpTable&amp; stringSwitchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_stringSwitchJumpTables[tableIndex]; }
194 
195     UnlinkedFunctionExecutable* functionDecl(int index) { return m_functionDecls[index].get(); }
196     size_t numberOfFunctionDecls() { return m_functionDecls.size(); }
197     UnlinkedFunctionExecutable* functionExpr(int index) { return m_functionExprs[index].get(); }
198     size_t numberOfFunctionExprs() { return m_functionExprs.size(); }
199 
200     // Exception handling support
201     size_t numberOfExceptionHandlers() const { return m_rareData ? m_rareData-&gt;m_exceptionHandlers.size() : 0; }
202     UnlinkedHandlerInfo&amp; exceptionHandler(int index) { ASSERT(m_rareData); return m_rareData-&gt;m_exceptionHandlers[index]; }
203 
204     CodeType codeType() const { return static_cast&lt;CodeType&gt;(m_codeType); }
205 
206     VirtualRegister thisRegister() const { return m_thisRegister; }
207     VirtualRegister scopeRegister() const { return m_scopeRegister; }
208 
209     bool hasRareData() const { return m_rareData.get(); }
210 
211     int lineNumberForBytecodeIndex(BytecodeIndex);
212 
213     void expressionRangeForBytecodeIndex(BytecodeIndex, int&amp; divot,
214         int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const;
215 
216     bool typeProfilerExpressionInfoForBytecodeOffset(unsigned bytecodeOffset, unsigned&amp; startDivot, unsigned&amp; endDivot);
217 
218     void recordParse(CodeFeatures features, bool hasCapturedVariables, unsigned lineCount, unsigned endColumn)
219     {
220         m_features = features;
221         m_hasCapturedVariables = hasCapturedVariables;
222         m_lineCount = lineCount;
223         // For the UnlinkedCodeBlock, startColumn is always 0.
224         m_endColumn = endColumn;
225     }
226 
227     StringImpl* sourceURLDirective() const { return m_sourceURLDirective.get(); }
228     StringImpl* sourceMappingURLDirective() const { return m_sourceMappingURLDirective.get(); }
229     void setSourceURLDirective(const String&amp; sourceURL) { m_sourceURLDirective = sourceURL.impl(); }
230     void setSourceMappingURLDirective(const String&amp; sourceMappingURL) { m_sourceMappingURLDirective = sourceMappingURL.impl(); }
231 
232     CodeFeatures codeFeatures() const { return m_features; }
233     bool hasCapturedVariables() const { return m_hasCapturedVariables; }
234     unsigned lineCount() const { return m_lineCount; }
235     ALWAYS_INLINE unsigned startColumn() const { return 0; }
236     unsigned endColumn() const { return m_endColumn; }
237 
238     const RefCountedArray&lt;InstructionStream::Offset&gt;&amp; opProfileControlFlowBytecodeOffsets() const
239     {
240         ASSERT(m_rareData);
241         return m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets;
242     }
243     bool hasOpProfileControlFlowBytecodeOffsets() const
244     {
245         return m_rareData &amp;&amp; !m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets.isEmpty();
246     }
247 
248     void dumpExpressionRangeInfo(); // For debugging purpose only.
249 
250     bool wasCompiledWithDebuggingOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::Debugger); }
251     bool wasCompiledWithTypeProfilerOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::TypeProfiler); }
252     bool wasCompiledWithControlFlowProfilerOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::ControlFlowProfiler); }
253     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode() const { return m_codeGenerationMode; }
254 
255     TriState didOptimize() const { return static_cast&lt;TriState&gt;(m_didOptimize); }
256     void setDidOptimize(TriState didOptimize) { m_didOptimize = static_cast&lt;unsigned&gt;(didOptimize); }
257 
258     static constexpr unsigned maxAge = 7;
259 
260     unsigned age() const { return m_age; }
261     void resetAge() { m_age = 0; }
262 
263     NeedsClassFieldInitializer needsClassFieldInitializer() const
264     {
265         if (m_rareData)
266             return static_cast&lt;NeedsClassFieldInitializer&gt;(m_rareData-&gt;m_needsClassFieldInitializer);
267         return NeedsClassFieldInitializer::No;
268     }
269 
270     void dump(PrintStream&amp;) const;
271 
272     BytecodeLivenessAnalysis&amp; livenessAnalysis(CodeBlock* codeBlock)
273     {
274         if (m_liveness)
275             return *m_liveness;
276         return livenessAnalysisSlow(codeBlock);
277     }
278 
279 #if ENABLE(DFG_JIT)
280     bool hasExitSite(const ConcurrentJSLocker&amp; locker, const DFG::FrequentExitSite&amp; site) const
281     {
282         return m_exitProfile.hasExitSite(locker, site);
283     }
284 
285     bool hasExitSite(const DFG::FrequentExitSite&amp; site)
286     {
287         ConcurrentJSLocker locker(m_lock);
288         return hasExitSite(locker, site);
289     }
290 
291     DFG::ExitProfile&amp; exitProfile() { return m_exitProfile; }
292 #endif
293 
294     UnlinkedMetadataTable&amp; metadata() { return m_metadata.get(); }
295 
296     size_t metadataSizeInBytes()
297     {
298         return m_metadata-&gt;sizeInBytes();
299     }
300 
301 
302 protected:
303     UnlinkedCodeBlock(VM&amp;, Structure*, CodeType, const ExecutableInfo&amp;, OptionSet&lt;CodeGenerationMode&gt;);
304 
305     template&lt;typename CodeBlockType&gt;
306     UnlinkedCodeBlock(Decoder&amp;, Structure*, const CachedCodeBlock&lt;CodeBlockType&gt;&amp;);
307 
308     ~UnlinkedCodeBlock();
309 
310     void finishCreation(VM&amp; vm)
311     {
312         Base::finishCreation(vm);
313     }
314 
315 private:
316     friend class BytecodeRewriter;
317     friend class UnlinkedCodeBlockGenerator;
318     template&lt;typename Traits&gt;
319     friend class BytecodeGeneratorBase;
320 
321     template&lt;typename CodeBlockType&gt;
322     friend class CachedCodeBlock;
323 
324     void createRareDataIfNecessary(const AbstractLocker&amp;)
325     {
326         if (!m_rareData)
327             m_rareData = makeUnique&lt;RareData&gt;();
328     }
329 
330     void getLineAndColumn(const ExpressionRangeInfo&amp;, unsigned&amp; line, unsigned&amp; column) const;
331     BytecodeLivenessAnalysis&amp; livenessAnalysisSlow(CodeBlock*);
332 
333 
334     VirtualRegister m_thisRegister;
335     VirtualRegister m_scopeRegister;
336 
337     unsigned m_usesEval : 1;
338     unsigned m_isStrictMode : 1;
339     unsigned m_isConstructor : 1;
340     unsigned m_hasCapturedVariables : 1;
341     unsigned m_isBuiltinFunction : 1;
342     unsigned m_superBinding : 1;
343     unsigned m_scriptMode: 1;
344     unsigned m_isArrowFunctionContext : 1;
345     unsigned m_isClassContext : 1;
346     unsigned m_hasTailCalls : 1;
347     unsigned m_constructorKind : 2;
348     unsigned m_derivedContextType : 2;
349     unsigned m_evalContextType : 2;
350     unsigned m_codeType : 2;
351     unsigned m_didOptimize : 2;
352     unsigned m_age : 3;
353     static_assert(((1U &lt;&lt; 3) - 1) &gt;= maxAge);
354     bool m_hasCheckpoints : 1;
355 public:
356     ConcurrentJSLock m_lock;
357 private:
358     CodeFeatures m_features { 0 };
359     SourceParseMode m_parseMode;
360     OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;
361 
362     unsigned m_lineCount { 0 };
363     unsigned m_endColumn { UINT_MAX };
364 
365     int m_numVars { 0 };
366     int m_numCalleeLocals { 0 };
367     int m_numParameters { 0 };
368 
369     PackedRefPtr&lt;StringImpl&gt; m_sourceURLDirective;
370     PackedRefPtr&lt;StringImpl&gt; m_sourceMappingURLDirective;
371 
372     RefCountedArray&lt;InstructionStream::Offset&gt; m_jumpTargets;
373     Ref&lt;UnlinkedMetadataTable&gt; m_metadata;
374     std::unique_ptr&lt;InstructionStream&gt; m_instructions;
375     std::unique_ptr&lt;BytecodeLivenessAnalysis&gt; m_liveness;
376 
377 
378 #if ENABLE(DFG_JIT)
379     DFG::ExitProfile m_exitProfile;
380 #endif
381 
382     // Constant Pools
383     RefCountedArray&lt;Identifier&gt; m_identifiers;
384     RefCountedArray&lt;WriteBarrier&lt;Unknown&gt;&gt; m_constantRegisters;
385     RefCountedArray&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;
386     using FunctionExpressionVector = RefCountedArray&lt;WriteBarrier&lt;UnlinkedFunctionExecutable&gt;&gt;;
387     FunctionExpressionVector m_functionDecls;
388     FunctionExpressionVector m_functionExprs;
389 
390 public:
391     struct RareData {
392         WTF_MAKE_STRUCT_FAST_ALLOCATED;
393 
394         RefCountedArray&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;
395 
396         // Jump Tables
397         RefCountedArray&lt;UnlinkedSimpleJumpTable&gt; m_switchJumpTables;
398         RefCountedArray&lt;UnlinkedStringJumpTable&gt; m_stringSwitchJumpTables;
399 
400         RefCountedArray&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;
401 
402         struct TypeProfilerExpressionRange {
403             unsigned m_startDivot;
404             unsigned m_endDivot;
405         };
406         HashMap&lt;unsigned, TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
407         RefCountedArray&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;
408         RefCountedArray&lt;BitVector&gt; m_bitVectors;
409         RefCountedArray&lt;ConstantIdentifierSetEntry&gt; m_constantIdentifierSets;
410 
411         unsigned m_needsClassFieldInitializer : 1;
412     };
413 
414     int outOfLineJumpOffset(InstructionStream::Offset);
415     int outOfLineJumpOffset(const InstructionStream::Ref&amp; instruction)
416     {
417         return outOfLineJumpOffset(instruction.offset());
418     }
419 
420 private:
421     using OutOfLineJumpTargets = HashMap&lt;InstructionStream::Offset, int&gt;;
422 
423     OutOfLineJumpTargets m_outOfLineJumpTargets;
424     std::unique_ptr&lt;RareData&gt; m_rareData;
425     RefCountedArray&lt;ExpressionRangeInfo&gt; m_expressionInfo;
426 
427 protected:
428     static void visitChildren(JSCell*, SlotVisitor&amp;);
429     static size_t estimatedSize(JSCell*, VM&amp;);
430 
431 public:
432     DECLARE_INFO;
433 };
434 
435 }
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCode.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCode.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCode.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCode.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2015-2020 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -32,21 +32,27 @@
 #include "AirDisassembler.h"
 #include "AirSpecial.h"
 #include "AirStackSlot.h"
 #include "AirTmp.h"
 #include "B3SparseCollection.h"
-#include "CCallHelpers.h"
+#include "GPRInfo.h"
+#include "MacroAssembler.h"
 #include "RegisterAtOffsetList.h"
 #include "StackAlignment.h"
+#include <wtf/HashSet.h>
 #include <wtf/IndexMap.h>
 #include <wtf/WeakRandom.h>
 
-namespace JSC { namespace B3 {
+namespace JSC {
+
+class CCallHelpers;
+
+namespace B3 {
 
 class Procedure;
 
-#if ASSERT_DISABLED
+#if !ASSERT_ENABLED
 IGNORE_RETURN_TYPE_WARNINGS_BEGIN
 #endif
 
 namespace Air {
 
@@ -61,10 +67,12 @@
 typedef SharedTask<WasmBoundsCheckGeneratorFunction> WasmBoundsCheckGenerator;
 
 typedef void PrologueGeneratorFunction(CCallHelpers&, Code&);
 typedef SharedTask<PrologueGeneratorFunction> PrologueGenerator;
 
+extern const char* const tierName;
+
 // This is an IR that is very close to the bare metal. It requires about 40x more bytes than the
 // generated machine code - for example if you're generating 1MB of machine code, you need about
 // 40MB of Air.
 
 class Code {
@@ -192,11 +200,11 @@
     {
         m_entrypoints = std::forward<Vector>(vector);
         RELEASE_ASSERT(m_entrypoints.size() == m_prologueGenerators.size());
     }
 
-    CCallHelpers::Label entrypointLabel(unsigned index) const
+    MacroAssembler::Label entrypointLabel(unsigned index) const
     {
         return m_entrypointLabels[index];
     }
 
     // This is used by generate().
@@ -222,11 +230,11 @@
 
     // This just tells you what the callee saves are.
     RegisterSet calleeSaveRegisters() const { return m_calleeSaveRegisters; }
 
     // Recomputes predecessors and deletes unreachable blocks.
-    void resetReachability();
+    JS_EXPORT_PRIVATE void resetReachability();
 
     JS_EXPORT_PRIVATE void dump(PrintStream&) const;
 
     unsigned size() const { return m_blocks.size(); }
     BasicBlock* at(unsigned index) const { return m_blocks[index].get(); }
@@ -379,21 +387,21 @@
     bool m_stackIsAllocated { false };
     RegisterAtOffsetList m_uncorrectedCalleeSaveRegisterAtOffsetList;
     RegisterSet m_calleeSaveRegisters;
     StackSlot* m_calleeSaveStackSlot { nullptr };
     Vector<FrequentedBlock> m_entrypoints; // This is empty until after lowerEntrySwitch().
-    Vector<CCallHelpers::Label> m_entrypointLabels; // This is empty until code generation.
+    Vector<MacroAssembler::Label> m_entrypointLabels; // This is empty until code generation.
     Vector<Ref<PrologueGenerator>, 1> m_prologueGenerators;
     RefPtr<WasmBoundsCheckGenerator> m_wasmBoundsCheckGenerator;
     const char* m_lastPhaseName;
     std::unique_ptr<Disassembler> m_disassembler;
     unsigned m_optLevel { defaultOptLevel() };
     Ref<PrologueGenerator> m_defaultPrologueGenerator;
 };
 
 } } } // namespace JSC::B3::Air
 
-#if ASSERT_DISABLED
+#if !ASSERT_ENABLED
 IGNORE_RETURN_TYPE_WARNINGS_END
 #endif
 
 #endif // ENABLE(B3_JIT)

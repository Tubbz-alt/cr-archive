<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/opengl/GraphicsContextGLOpenGLCommon.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2010, 2014 Apple Inc. All rights reserved.
   3  * Copyright (C) 2011 Google Inc. All rights reserved.
   4  * Copyright (C) 2012 ChangSeok Oh &lt;shivamidow@gmail.com&gt;
   5  * Copyright (C) 2012 Research In Motion Limited. All rights reserved.
   6  *
   7  * Redistribution and use in source and binary forms, with or without
   8  * modification, are permitted provided that the following conditions
   9  * are met:
  10  * 1. Redistributions of source code must retain the above copyright
  11  *    notice, this list of conditions and the following disclaimer.
  12  * 2. Redistributions in binary form must reproduce the above copyright
  13  *    notice, this list of conditions and the following disclaimer in the
  14  *    documentation and/or other materials provided with the distribution.
  15  *
  16  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  19  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  20  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  21  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  24  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;GraphicsContextGLOpenGL.h&quot;
  31 
  32 #if ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; (USE(OPENGL) || USE(OPENGL_ES))
  33 
  34 #if PLATFORM(IOS_FAMILY)
  35 #include &quot;GraphicsContextGLOpenGLESIOS.h&quot;
  36 #endif
  37 
  38 #if !PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
  39 #include &quot;ExtensionsGLOpenGLES.h&quot;
  40 #else
  41 #include &quot;ExtensionsGLOpenGL.h&quot;
  42 #endif
  43 #include &quot;ANGLEWebKitBridge.h&quot;
  44 #include &quot;GraphicsContext.h&quot;
  45 #include &quot;ImageBuffer.h&quot;
  46 #include &quot;ImageData.h&quot;
  47 #include &quot;IntRect.h&quot;
  48 #include &quot;IntSize.h&quot;
  49 #include &quot;Logging.h&quot;
  50 #include &quot;TemporaryOpenGLSetting.h&quot;
  51 #include &quot;WebGLRenderingContextBase.h&quot;
  52 #include &lt;JavaScriptCore/RegularExpression.h&gt;
  53 #include &lt;cstring&gt;
  54 #include &lt;wtf/HexNumber.h&gt;
  55 #include &lt;wtf/MainThread.h&gt;
  56 #include &lt;wtf/ThreadSpecific.h&gt;
  57 #include &lt;wtf/UniqueArray.h&gt;
  58 #include &lt;wtf/Vector.h&gt;
  59 #include &lt;wtf/text/CString.h&gt;
  60 #include &lt;wtf/text/StringBuilder.h&gt;
  61 
  62 #if PLATFORM(COCOA)
  63 
  64 #if USE(OPENGL_ES)
  65 #import &lt;OpenGLES/ES2/glext.h&gt;
  66 #import &lt;OpenGLES/ES3/gl.h&gt;
  67 // From &lt;OpenGLES/glext.h&gt;
  68 #define GL_RGBA32F_ARB                      0x8814
  69 #define GL_RGB32F_ARB                       0x8815
  70 #else
  71 #define GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED
  72 #include &lt;OpenGL/gl.h&gt;
  73 #include &lt;OpenGL/gl3.h&gt;
  74 #include &lt;OpenGL/gl3ext.h&gt;
  75 #undef GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED
  76 #endif
  77 
  78 #else
  79 
  80 #if USE(LIBEPOXY)
  81 #include &quot;EpoxyShims.h&quot;
  82 #elif USE(OPENGL_ES)
  83 #include &quot;OpenGLESShims.h&quot;
  84 #elif PLATFORM(GTK) || PLATFORM(WIN)
  85 #include &quot;OpenGLShims.h&quot;
  86 #endif
  87 
  88 #endif
  89 
  90 
  91 namespace WebCore {
  92 
  93 static ThreadSpecific&lt;ShaderNameHash*&gt;&amp; getCurrentNameHashMapForShader()
  94 {
  95     static std::once_flag onceFlag;
  96     static ThreadSpecific&lt;ShaderNameHash*&gt;* sharedNameHash;
  97     std::call_once(onceFlag, [] {
  98         sharedNameHash = new ThreadSpecific&lt;ShaderNameHash*&gt;;
  99     });
 100 
 101     return *sharedNameHash;
 102 }
 103 
 104 static void setCurrentNameHashMapForShader(ShaderNameHash* shaderNameHash)
 105 {
 106     *getCurrentNameHashMapForShader() = shaderNameHash;
 107 }
 108 
 109 // Hash function used by the ANGLE translator/compiler to do
 110 // symbol name mangling. Since this is a static method, before
 111 // calling compileShader we set currentNameHashMapForShader
 112 // to point to the map kept by the current instance of GraphicsContextGLOpenGL.
 113 
 114 static uint64_t nameHashForShader(const char* name, size_t length)
 115 {
 116     if (!length)
 117         return 0;
 118 
 119     CString nameAsCString = CString(name);
 120 
 121     // Look up name in our local map.
 122     ShaderNameHash*&amp; currentNameHashMapForShader = *getCurrentNameHashMapForShader();
 123     ShaderNameHash::iterator findResult = currentNameHashMapForShader-&gt;find(nameAsCString);
 124     if (findResult != currentNameHashMapForShader-&gt;end())
 125         return findResult-&gt;value;
 126 
 127     unsigned hashValue = nameAsCString.hash();
 128 
 129     // Convert the 32-bit hash from CString::hash into a 64-bit result
 130     // by shifting then adding the size of our table. Overflow would
 131     // only be a problem if we&#39;re already hashing to the same value (and
 132     // we&#39;re hoping that over the lifetime of the context we
 133     // don&#39;t have that many symbols).
 134 
 135     uint64_t result = hashValue;
 136     result = (result &lt;&lt; 32) + (currentNameHashMapForShader-&gt;size() + 1);
 137 
 138     currentNameHashMapForShader-&gt;set(nameAsCString, result);
 139     return result;
 140 }
 141 
 142 void GraphicsContextGLOpenGL::validateDepthStencil(const char* packedDepthStencilExtension)
 143 {
 144     auto attrs = contextAttributes();
 145 
 146     ExtensionsGL&amp; extensions = getExtensions();
 147     if (attrs.stencil) {
 148         if (extensions.supports(packedDepthStencilExtension)) {
 149             extensions.ensureEnabled(packedDepthStencilExtension);
 150             // Force depth if stencil is true.
 151             attrs.depth = true;
 152         } else
 153             attrs.stencil = false;
 154         setContextAttributes(attrs);
 155     }
 156     if (attrs.antialias &amp;&amp; !m_isForWebGL2) {
 157         if (!extensions.supports(&quot;GL_ANGLE_framebuffer_multisample&quot;)) {
 158             attrs.antialias = false;
 159             setContextAttributes(attrs);
 160         } else
 161             extensions.ensureEnabled(&quot;GL_ANGLE_framebuffer_multisample&quot;);
 162     }
 163 }
 164 
 165 void GraphicsContextGLOpenGL::paintRenderingResultsToCanvas(ImageBuffer* imageBuffer)
 166 {
 167     Checked&lt;int, RecordOverflow&gt; rowBytes = Checked&lt;int, RecordOverflow&gt;(m_currentWidth) * 4;
 168     if (rowBytes.hasOverflowed())
 169         return;
 170 
 171     Checked&lt;int, RecordOverflow&gt; totalBytesChecked = rowBytes * m_currentHeight;
 172     if (totalBytesChecked.hasOverflowed())
 173         return;
 174     int totalBytes = totalBytesChecked.unsafeGet();
 175 
 176     auto pixels = makeUniqueArray&lt;unsigned char&gt;(totalBytes);
 177     if (!pixels)
 178         return;
 179 
 180     readRenderingResults(pixels.get(), totalBytes);
 181 
 182     if (!contextAttributes().premultipliedAlpha) {
 183         for (int i = 0; i &lt; totalBytes; i += 4) {
 184             // Premultiply alpha.
 185             pixels[i + 0] = std::min(255, pixels[i + 0] * pixels[i + 3] / 255);
 186             pixels[i + 1] = std::min(255, pixels[i + 1] * pixels[i + 3] / 255);
 187             pixels[i + 2] = std::min(255, pixels[i + 2] * pixels[i + 3] / 255);
 188         }
 189     }
 190 
 191     paintToCanvas(pixels.get(), IntSize(m_currentWidth, m_currentHeight), imageBuffer-&gt;internalSize(), imageBuffer-&gt;context());
 192 
 193 #if PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
 194     presentRenderbuffer();
 195 #endif
 196 }
 197 
 198 bool GraphicsContextGLOpenGL::paintCompositedResultsToCanvas(ImageBuffer*)
 199 {
 200     // Not needed at the moment, so return that nothing was done.
 201     return false;
 202 }
 203 
 204 RefPtr&lt;ImageData&gt; GraphicsContextGLOpenGL::paintRenderingResultsToImageData()
 205 {
 206     // Reading premultiplied alpha would involve unpremultiplying, which is
 207     // lossy.
 208     if (contextAttributes().premultipliedAlpha)
 209         return nullptr;
 210 
 211     auto imageData = ImageData::create(IntSize(m_currentWidth, m_currentHeight));
 212     unsigned char* pixels = imageData-&gt;data()-&gt;data();
 213     Checked&lt;int, RecordOverflow&gt; totalBytesChecked = 4 * Checked&lt;int, RecordOverflow&gt;(m_currentWidth) * Checked&lt;int, RecordOverflow&gt;(m_currentHeight);
 214     if (totalBytesChecked.hasOverflowed())
 215         return imageData;
 216     int totalBytes = totalBytesChecked.unsafeGet();
 217 
 218     readRenderingResults(pixels, totalBytes);
 219 
 220     // Convert to RGBA.
 221     for (int i = 0; i &lt; totalBytes; i += 4)
 222         std::swap(pixels[i], pixels[i + 2]);
 223 
 224     return imageData;
 225 }
 226 
 227 void GraphicsContextGLOpenGL::prepareTexture()
 228 {
 229     if (m_layerComposited)
 230         return;
 231 
 232     makeContextCurrent();
 233 
 234 #if !USE(COORDINATED_GRAPHICS)
 235     TemporaryOpenGLSetting scopedScissor(GL_SCISSOR_TEST, GL_FALSE);
 236     TemporaryOpenGLSetting scopedDither(GL_DITHER, GL_FALSE);
 237 #endif
 238 
 239     if (contextAttributes().antialias)
 240         resolveMultisamplingIfNecessary();
 241 
 242 #if USE(COORDINATED_GRAPHICS)
 243     std::swap(m_texture, m_compositorTexture);
 244     std::swap(m_texture, m_intermediateTexture);
 245     ::glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);
 246     ::glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, m_texture, 0);
 247     glFlush();
 248 
 249     if (m_state.boundFBO != m_fbo)
 250         ::glBindFramebufferEXT(GraphicsContextGL::FRAMEBUFFER, m_state.boundFBO);
 251     else
 252         ::glBindFramebufferEXT(GraphicsContextGL::FRAMEBUFFER, m_fbo);
 253     return;
 254 #endif
 255 
 256     ::glActiveTexture(GL_TEXTURE0);
 257     ::glBindTexture(GL_TEXTURE_2D, m_state.boundTarget(GL_TEXTURE0) == GL_TEXTURE_2D ? m_state.boundTexture(GL_TEXTURE0) : 0);
 258     ::glActiveTexture(m_state.activeTextureUnit);
 259     if (m_state.boundFBO != m_fbo)
 260         ::glBindFramebufferEXT(GraphicsContextGL::FRAMEBUFFER, m_state.boundFBO);
 261     ::glFlush();
 262 }
 263 
 264 void GraphicsContextGLOpenGL::readRenderingResults(unsigned char *pixels, int pixelsSize)
 265 {
 266     if (pixelsSize &lt; m_currentWidth * m_currentHeight * 4)
 267         return;
 268 
 269     makeContextCurrent();
 270 
 271     bool mustRestoreFBO = false;
 272     if (contextAttributes().antialias) {
 273         resolveMultisamplingIfNecessary();
 274         ::glBindFramebufferEXT(GraphicsContextGL::FRAMEBUFFER, m_fbo);
 275         mustRestoreFBO = true;
 276     } else {
 277         if (m_state.boundFBO != m_fbo) {
 278             mustRestoreFBO = true;
 279             ::glBindFramebufferEXT(GraphicsContextGL::FRAMEBUFFER, m_fbo);
 280         }
 281     }
 282 
 283     GLint packAlignment = 4;
 284     bool mustRestorePackAlignment = false;
 285     ::glGetIntegerv(GL_PACK_ALIGNMENT, &amp;packAlignment);
 286     if (packAlignment &gt; 4) {
 287         ::glPixelStorei(GL_PACK_ALIGNMENT, 4);
 288         mustRestorePackAlignment = true;
 289     }
 290 
 291     readPixelsAndConvertToBGRAIfNecessary(0, 0, m_currentWidth, m_currentHeight, pixels);
 292 
 293     if (mustRestorePackAlignment)
 294         ::glPixelStorei(GL_PACK_ALIGNMENT, packAlignment);
 295 
 296     if (mustRestoreFBO)
 297         ::glBindFramebufferEXT(GraphicsContextGL::FRAMEBUFFER, m_state.boundFBO);
 298 }
 299 
 300 void GraphicsContextGLOpenGL::reshape(int width, int height)
 301 {
 302     if (!platformGraphicsContextGL())
 303         return;
 304 
 305     if (width == m_currentWidth &amp;&amp; height == m_currentHeight)
 306         return;
 307 
 308     ASSERT(width &gt;= 0 &amp;&amp; height &gt;= 0);
 309     if (width &lt; 0 || height &lt; 0)
 310         return;
 311 
 312     markContextChanged();
 313 
 314     m_currentWidth = width;
 315     m_currentHeight = height;
 316 
 317     makeContextCurrent();
 318     validateAttributes();
 319 
 320     TemporaryOpenGLSetting scopedScissor(GL_SCISSOR_TEST, GL_FALSE);
 321     TemporaryOpenGLSetting scopedDither(GL_DITHER, GL_FALSE);
 322 
 323     bool mustRestoreFBO = reshapeFBOs(IntSize(width, height));
 324 
 325     // Initialize renderbuffers to 0.
 326     GLfloat clearColor[] = {0, 0, 0, 0}, clearDepth = 0;
 327     GLint clearStencil = 0;
 328     GLboolean colorMask[] = {GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE}, depthMask = GL_TRUE;
 329     GLuint stencilMask = 0xffffffff, stencilMaskBack = 0xffffffff;
 330     GLbitfield clearMask = GL_COLOR_BUFFER_BIT;
 331     ::glGetFloatv(GL_COLOR_CLEAR_VALUE, clearColor);
 332     ::glClearColor(0, 0, 0, 0);
 333     ::glGetBooleanv(GL_COLOR_WRITEMASK, colorMask);
 334     ::glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
 335 
 336     auto attrs = contextAttributes();
 337 
 338     if (attrs.depth) {
 339         ::glGetFloatv(GL_DEPTH_CLEAR_VALUE, &amp;clearDepth);
 340         GraphicsContextGLOpenGL::clearDepth(1);
 341         ::glGetBooleanv(GL_DEPTH_WRITEMASK, &amp;depthMask);
 342         ::glDepthMask(GL_TRUE);
 343         clearMask |= GL_DEPTH_BUFFER_BIT;
 344     }
 345     if (attrs.stencil) {
 346         ::glGetIntegerv(GL_STENCIL_CLEAR_VALUE, &amp;clearStencil);
 347         ::glClearStencil(0);
 348         ::glGetIntegerv(GL_STENCIL_WRITEMASK, reinterpret_cast&lt;GLint*&gt;(&amp;stencilMask));
 349         ::glGetIntegerv(GL_STENCIL_BACK_WRITEMASK, reinterpret_cast&lt;GLint*&gt;(&amp;stencilMaskBack));
 350         ::glStencilMaskSeparate(GL_FRONT, 0xffffffff);
 351         ::glStencilMaskSeparate(GL_BACK, 0xffffffff);
 352         clearMask |= GL_STENCIL_BUFFER_BIT;
 353     }
 354 
 355     ::glClear(clearMask);
 356 
 357     ::glClearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
 358     ::glColorMask(colorMask[0], colorMask[1], colorMask[2], colorMask[3]);
 359     if (attrs.depth) {
 360         GraphicsContextGLOpenGL::clearDepth(clearDepth);
 361         ::glDepthMask(depthMask);
 362     }
 363     if (attrs.stencil) {
 364         ::glClearStencil(clearStencil);
 365         ::glStencilMaskSeparate(GL_FRONT, stencilMask);
 366         ::glStencilMaskSeparate(GL_BACK, stencilMaskBack);
 367     }
 368 
 369     if (mustRestoreFBO)
 370         ::glBindFramebufferEXT(GraphicsContextGL::FRAMEBUFFER, m_state.boundFBO);
 371 
 372     ::glFlush();
 373 }
 374 
 375 bool GraphicsContextGLOpenGL::checkVaryingsPacking(PlatformGLObject vertexShader, PlatformGLObject fragmentShader) const
 376 {
 377     ASSERT(m_shaderSourceMap.contains(vertexShader));
 378     ASSERT(m_shaderSourceMap.contains(fragmentShader));
 379     const auto&amp; vertexEntry = m_shaderSourceMap.find(vertexShader)-&gt;value;
 380     const auto&amp; fragmentEntry = m_shaderSourceMap.find(fragmentShader)-&gt;value;
 381 
 382     HashMap&lt;String, sh::ShaderVariable&gt; combinedVaryings;
 383     for (const auto&amp; vertexSymbol : vertexEntry.varyingMap) {
 384         const String&amp; symbolName = vertexSymbol.key;
 385         // The varying map includes variables for each index of an array variable.
 386         // We only want a single variable to represent the array.
 387         if (symbolName.endsWith(&quot;]&quot;))
 388             continue;
 389 
 390         // Don&#39;t count built in varyings.
 391         if (symbolName == &quot;gl_FragCoord&quot; || symbolName == &quot;gl_FrontFacing&quot; || symbolName == &quot;gl_PointCoord&quot;)
 392             continue;
 393 
 394         const auto&amp; fragmentSymbol = fragmentEntry.varyingMap.find(symbolName);
 395         if (fragmentSymbol != fragmentEntry.varyingMap.end())
 396             combinedVaryings.add(symbolName, fragmentSymbol-&gt;value);
 397     }
 398 
 399     size_t numVaryings = combinedVaryings.size();
 400     if (!numVaryings)
 401         return true;
 402 
 403     std::vector&lt;sh::ShaderVariable&gt; variables;
 404     variables.reserve(combinedVaryings.size());
 405     for (const auto&amp; varyingSymbol : combinedVaryings.values())
 406         variables.push_back(varyingSymbol);
 407 
 408     GCGLint maxVaryingVectors = 0;
 409 #if USE(OPENGL_ES)
 410     ::glGetIntegerv(MAX_VARYING_VECTORS, &amp;maxVaryingVectors);
 411 #else
 412     if (m_isForWebGL2)
 413         ::glGetIntegerv(GL_MAX_VARYING_VECTORS, &amp;maxVaryingVectors);
 414     else {
 415         GCGLint maxVaryingFloats = 0;
 416         ::glGetIntegerv(GL_MAX_VARYING_FLOATS, &amp;maxVaryingFloats);
 417         maxVaryingVectors = maxVaryingFloats / 4;
 418     }
 419 #endif
 420     return sh::CheckVariablesWithinPackingLimits(maxVaryingVectors, variables);
 421 }
 422 
 423 bool GraphicsContextGLOpenGL::precisionsMatch(PlatformGLObject vertexShader, PlatformGLObject fragmentShader) const
 424 {
 425     ASSERT(m_shaderSourceMap.contains(vertexShader));
 426     ASSERT(m_shaderSourceMap.contains(fragmentShader));
 427     const auto&amp; vertexEntry = m_shaderSourceMap.find(vertexShader)-&gt;value;
 428     const auto&amp; fragmentEntry = m_shaderSourceMap.find(fragmentShader)-&gt;value;
 429 
 430     HashMap&lt;String, sh::GLenum&gt; vertexSymbolPrecisionMap;
 431 
 432     for (const auto&amp; entry : vertexEntry.uniformMap) {
 433         const std::string&amp; mappedName = entry.value.mappedName;
 434         vertexSymbolPrecisionMap.add(String(mappedName.c_str(), mappedName.length()), entry.value.precision);
 435     }
 436 
 437     for (const auto&amp; entry : fragmentEntry.uniformMap) {
 438         const std::string&amp; mappedName = entry.value.mappedName;
 439         const auto&amp; vertexSymbol = vertexSymbolPrecisionMap.find(String(mappedName.c_str(), mappedName.length()));
 440         if (vertexSymbol != vertexSymbolPrecisionMap.end() &amp;&amp; vertexSymbol-&gt;value != entry.value.precision)
 441             return false;
 442     }
 443 
 444     return true;
 445 }
 446 
 447 IntSize GraphicsContextGLOpenGL::getInternalFramebufferSize() const
 448 {
 449     return IntSize(m_currentWidth, m_currentHeight);
 450 }
 451 
 452 void GraphicsContextGLOpenGL::activeTexture(GCGLenum texture)
 453 {
 454     makeContextCurrent();
 455     m_state.activeTextureUnit = texture;
 456     ::glActiveTexture(texture);
 457 }
 458 
 459 void GraphicsContextGLOpenGL::attachShader(PlatformGLObject program, PlatformGLObject shader)
 460 {
 461     ASSERT(program);
 462     ASSERT(shader);
 463     makeContextCurrent();
 464     m_shaderProgramSymbolCountMap.remove(program);
 465     ::glAttachShader(program, shader);
 466 }
 467 
 468 void GraphicsContextGLOpenGL::bindAttribLocation(PlatformGLObject program, GCGLuint index, const String&amp; name)
 469 {
 470     ASSERT(program);
 471     makeContextCurrent();
 472 
 473     String mappedName = mappedSymbolName(program, SHADER_SYMBOL_TYPE_ATTRIBUTE, name);
 474     LOG(WebGL, &quot;::bindAttribLocation is mapping %s to %s&quot;, name.utf8().data(), mappedName.utf8().data());
 475     ::glBindAttribLocation(program, index, mappedName.utf8().data());
 476 }
 477 
 478 void GraphicsContextGLOpenGL::bindBuffer(GCGLenum target, PlatformGLObject buffer)
 479 {
 480     makeContextCurrent();
 481     ::glBindBuffer(target, buffer);
 482 }
 483 
 484 void GraphicsContextGLOpenGL::bindFramebuffer(GCGLenum target, PlatformGLObject buffer)
 485 {
 486     makeContextCurrent();
 487     GLuint fbo;
 488     if (buffer)
 489         fbo = buffer;
 490     else
 491         fbo = (contextAttributes().antialias ? m_multisampleFBO : m_fbo);
 492     if (fbo != m_state.boundFBO) {
 493         ::glBindFramebufferEXT(target, fbo);
 494         m_state.boundFBO = fbo;
 495     }
 496 }
 497 
 498 void GraphicsContextGLOpenGL::bindRenderbuffer(GCGLenum target, PlatformGLObject renderbuffer)
 499 {
 500     makeContextCurrent();
 501     ::glBindRenderbufferEXT(target, renderbuffer);
 502 }
 503 
 504 
 505 void GraphicsContextGLOpenGL::bindTexture(GCGLenum target, PlatformGLObject texture)
 506 {
 507     makeContextCurrent();
 508     m_state.setBoundTexture(m_state.activeTextureUnit, texture, target);
 509     ::glBindTexture(target, texture);
 510 }
 511 
 512 void GraphicsContextGLOpenGL::blendColor(GCGLclampf red, GCGLclampf green, GCGLclampf blue, GCGLclampf alpha)
 513 {
 514     makeContextCurrent();
 515     ::glBlendColor(red, green, blue, alpha);
 516 }
 517 
 518 void GraphicsContextGLOpenGL::blendEquation(GCGLenum mode)
 519 {
 520     makeContextCurrent();
 521     ::glBlendEquation(mode);
 522 }
 523 
 524 void GraphicsContextGLOpenGL::blendEquationSeparate(GCGLenum modeRGB, GCGLenum modeAlpha)
 525 {
 526     makeContextCurrent();
 527     ::glBlendEquationSeparate(modeRGB, modeAlpha);
 528 }
 529 
 530 
 531 void GraphicsContextGLOpenGL::blendFunc(GCGLenum sfactor, GCGLenum dfactor)
 532 {
 533     makeContextCurrent();
 534     ::glBlendFunc(sfactor, dfactor);
 535 }
 536 
 537 void GraphicsContextGLOpenGL::blendFuncSeparate(GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha)
 538 {
 539     makeContextCurrent();
 540     ::glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
 541 }
 542 
 543 void GraphicsContextGLOpenGL::bufferData(GCGLenum target, GCGLsizeiptr size, GCGLenum usage)
 544 {
 545     makeContextCurrent();
 546     ::glBufferData(target, size, 0, usage);
 547 }
 548 
 549 void GraphicsContextGLOpenGL::bufferData(GCGLenum target, GCGLsizeiptr size, const void* data, GCGLenum usage)
 550 {
 551     makeContextCurrent();
 552     ::glBufferData(target, size, data, usage);
 553 }
 554 
 555 void GraphicsContextGLOpenGL::bufferSubData(GCGLenum target, GCGLintptr offset, GCGLsizeiptr size, const void* data)
 556 {
 557     makeContextCurrent();
 558     ::glBufferSubData(target, offset, size, data);
 559 }
 560 
 561 GCGLenum GraphicsContextGLOpenGL::checkFramebufferStatus(GCGLenum target)
 562 {
 563     makeContextCurrent();
 564     return ::glCheckFramebufferStatusEXT(target);
 565 }
 566 
 567 void GraphicsContextGLOpenGL::clearColor(GCGLclampf r, GCGLclampf g, GCGLclampf b, GCGLclampf a)
 568 {
 569     makeContextCurrent();
 570     ::glClearColor(r, g, b, a);
 571 }
 572 
 573 void GraphicsContextGLOpenGL::clear(GCGLbitfield mask)
 574 {
 575     makeContextCurrent();
 576     ::glClear(mask);
 577     checkGPUStatus();
 578 }
 579 
 580 void GraphicsContextGLOpenGL::clearStencil(GCGLint s)
 581 {
 582     makeContextCurrent();
 583     ::glClearStencil(s);
 584 }
 585 
 586 void GraphicsContextGLOpenGL::colorMask(GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha)
 587 {
 588     makeContextCurrent();
 589     ::glColorMask(red, green, blue, alpha);
 590 }
 591 
 592 void GraphicsContextGLOpenGL::compileShader(PlatformGLObject shader)
 593 {
 594     ASSERT(shader);
 595     makeContextCurrent();
 596 
 597     // Turn on name mapping. Due to the way ANGLE name hashing works, we
 598     // point a global hashmap to the map owned by this context.
 599     ShBuiltInResources ANGLEResources = m_compiler.getResources();
 600     ShHashFunction64 previousHashFunction = ANGLEResources.HashFunction;
 601     ANGLEResources.HashFunction = nameHashForShader;
 602 
 603     if (!nameHashMapForShaders)
 604         nameHashMapForShaders = makeUnique&lt;ShaderNameHash&gt;();
 605     setCurrentNameHashMapForShader(nameHashMapForShaders.get());
 606     m_compiler.setResources(ANGLEResources);
 607 
 608     String translatedShaderSource = m_extensions-&gt;getTranslatedShaderSourceANGLE(shader);
 609 
 610     ANGLEResources.HashFunction = previousHashFunction;
 611     m_compiler.setResources(ANGLEResources);
 612     setCurrentNameHashMapForShader(nullptr);
 613 
 614     if (!translatedShaderSource.length())
 615         return;
 616 
 617     const CString&amp; translatedShaderCString = translatedShaderSource.utf8();
 618     const char* translatedShaderPtr = translatedShaderCString.data();
 619     int translatedShaderLength = translatedShaderCString.length();
 620 
 621     LOG(WebGL, &quot;--- begin original shader source ---\n%s\n--- end original shader source ---\n&quot;, getShaderSource(shader).utf8().data());
 622     LOG(WebGL, &quot;--- begin translated shader source ---\n%s\n--- end translated shader source ---&quot;, translatedShaderPtr);
 623 
 624     ::glShaderSource(shader, 1, &amp;translatedShaderPtr, &amp;translatedShaderLength);
 625 
 626     ::glCompileShader(shader);
 627 
 628     int compileStatus;
 629 
 630     ::glGetShaderiv(shader, COMPILE_STATUS, &amp;compileStatus);
 631 
 632     ShaderSourceMap::iterator result = m_shaderSourceMap.find(shader);
 633     ShaderSourceEntry&amp; entry = result-&gt;value;
 634 
 635     // Populate the shader log
 636     GLint length = 0;
 637     ::glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;length);
 638 
 639     if (length) {
 640         GLsizei size = 0;
 641         Vector&lt;GLchar&gt; info(length);
 642         ::glGetShaderInfoLog(shader, length, &amp;size, info.data());
 643 
 644         PlatformGLObject shaders[2] = { shader, 0 };
 645         entry.log = getUnmangledInfoLog(shaders, 1, String(info.data(), size));
 646     }
 647 
 648     if (compileStatus != GL_TRUE) {
 649         entry.isValid = false;
 650         LOG(WebGL, &quot;Error: shader translator produced a shader that OpenGL would not compile.&quot;);
 651     }
 652 }
 653 
 654 void GraphicsContextGLOpenGL::compileShaderDirect(PlatformGLObject shader)
 655 {
 656     ASSERT(shader);
 657     makeContextCurrent();
 658 
 659     HashMap&lt;PlatformGLObject, ShaderSourceEntry&gt;::iterator result = m_shaderSourceMap.find(shader);
 660 
 661     if (result == m_shaderSourceMap.end())
 662         return;
 663 
 664     ShaderSourceEntry&amp; entry = result-&gt;value;
 665 
 666     const CString&amp; shaderSourceCString = entry.source.utf8();
 667     const char* shaderSourcePtr = shaderSourceCString.data();
 668     int shaderSourceLength = shaderSourceCString.length();
 669 
 670     LOG(WebGL, &quot;--- begin direct shader source ---\n%s\n--- end direct shader source ---\n&quot;, shaderSourcePtr);
 671 
 672     ::glShaderSource(shader, 1, &amp;shaderSourcePtr, &amp;shaderSourceLength);
 673 
 674     ::glCompileShader(shader);
 675 
 676     int compileStatus;
 677 
 678     ::glGetShaderiv(shader, COMPILE_STATUS, &amp;compileStatus);
 679 
 680     if (compileStatus == GL_TRUE) {
 681         entry.isValid = true;
 682         LOG(WebGL, &quot;Direct compilation of shader succeeded.&quot;);
 683     } else {
 684         entry.isValid = false;
 685         LOG(WebGL, &quot;Error: direct compilation of shader failed.&quot;);
 686     }
 687 }
 688 
 689 void GraphicsContextGLOpenGL::copyTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLint border)
 690 {
 691     makeContextCurrent();
 692     auto attrs = contextAttributes();
 693 
 694     if (attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO) {
 695         resolveMultisamplingIfNecessary(IntRect(x, y, width, height));
 696         ::glBindFramebufferEXT(GraphicsContextGL::FRAMEBUFFER, m_fbo);
 697     }
 698     ::glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
 699     if (attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO)
 700         ::glBindFramebufferEXT(GraphicsContextGL::FRAMEBUFFER, m_multisampleFBO);
 701 
 702 #if PLATFORM(MAC) &amp;&amp; USE(OPENGL)
 703     if (getExtensions().isIntel())
 704         m_needsFlushBeforeDeleteTextures = true;
 705 #endif
 706 }
 707 
 708 void GraphicsContextGLOpenGL::copyTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
 709 {
 710     makeContextCurrent();
 711     auto attrs = contextAttributes();
 712 
 713     if (attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO) {
 714         resolveMultisamplingIfNecessary(IntRect(x, y, width, height));
 715         ::glBindFramebufferEXT(GraphicsContextGL::FRAMEBUFFER, m_fbo);
 716     }
 717     ::glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
 718     if (attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO)
 719         ::glBindFramebufferEXT(GraphicsContextGL::FRAMEBUFFER, m_multisampleFBO);
 720 
 721 #if PLATFORM(MAC) &amp;&amp; USE(OPENGL)
 722     if (getExtensions().isIntel())
 723         m_needsFlushBeforeDeleteTextures = true;
 724 #endif
 725 }
 726 
 727 void GraphicsContextGLOpenGL::cullFace(GCGLenum mode)
 728 {
 729     makeContextCurrent();
 730     ::glCullFace(mode);
 731 }
 732 
 733 void GraphicsContextGLOpenGL::depthFunc(GCGLenum func)
 734 {
 735     makeContextCurrent();
 736     ::glDepthFunc(func);
 737 }
 738 
 739 void GraphicsContextGLOpenGL::depthMask(GCGLboolean flag)
 740 {
 741     makeContextCurrent();
 742     ::glDepthMask(flag);
 743 }
 744 
 745 void GraphicsContextGLOpenGL::detachShader(PlatformGLObject program, PlatformGLObject shader)
 746 {
 747     ASSERT(program);
 748     ASSERT(shader);
 749     makeContextCurrent();
 750     m_shaderProgramSymbolCountMap.remove(program);
 751     ::glDetachShader(program, shader);
 752 }
 753 
 754 void GraphicsContextGLOpenGL::disable(GCGLenum cap)
 755 {
 756     makeContextCurrent();
 757     ::glDisable(cap);
 758 }
 759 
 760 void GraphicsContextGLOpenGL::disableVertexAttribArray(GCGLuint index)
 761 {
 762     makeContextCurrent();
 763     ::glDisableVertexAttribArray(index);
 764 }
 765 
 766 void GraphicsContextGLOpenGL::drawArrays(GCGLenum mode, GCGLint first, GCGLsizei count)
 767 {
 768     makeContextCurrent();
 769     ::glDrawArrays(mode, first, count);
 770     checkGPUStatus();
 771 }
 772 
 773 void GraphicsContextGLOpenGL::drawElements(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLintptr offset)
 774 {
 775     makeContextCurrent();
 776     ::glDrawElements(mode, count, type, reinterpret_cast&lt;GLvoid*&gt;(static_cast&lt;intptr_t&gt;(offset)));
 777     checkGPUStatus();
 778 }
 779 
 780 void GraphicsContextGLOpenGL::enable(GCGLenum cap)
 781 {
 782     makeContextCurrent();
 783     ::glEnable(cap);
 784 }
 785 
 786 void GraphicsContextGLOpenGL::enableVertexAttribArray(GCGLuint index)
 787 {
 788     makeContextCurrent();
 789     ::glEnableVertexAttribArray(index);
 790 }
 791 
 792 void GraphicsContextGLOpenGL::finish()
 793 {
 794     makeContextCurrent();
 795     ::glFinish();
 796 #if PLATFORM(MAC) &amp;&amp; USE(OPENGL)
 797     m_needsFlushBeforeDeleteTextures = false;
 798 #endif
 799 }
 800 
 801 void GraphicsContextGLOpenGL::flush()
 802 {
 803     makeContextCurrent();
 804     ::glFlush();
 805 #if PLATFORM(MAC) &amp;&amp; USE(OPENGL)
 806     m_needsFlushBeforeDeleteTextures = false;
 807 #endif
 808 }
 809 
 810 void GraphicsContextGLOpenGL::framebufferRenderbuffer(GCGLenum target, GCGLenum attachment, GCGLenum renderbuffertarget, PlatformGLObject buffer)
 811 {
 812     makeContextCurrent();
 813     ::glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, buffer);
 814 }
 815 
 816 void GraphicsContextGLOpenGL::framebufferTexture2D(GCGLenum target, GCGLenum attachment, GCGLenum textarget, PlatformGLObject texture, GCGLint level)
 817 {
 818     makeContextCurrent();
 819     ::glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
 820     m_state.textureSeedCount.add(m_state.currentBoundTexture());
 821 }
 822 
 823 void GraphicsContextGLOpenGL::frontFace(GCGLenum mode)
 824 {
 825     makeContextCurrent();
 826     ::glFrontFace(mode);
 827 }
 828 
 829 void GraphicsContextGLOpenGL::generateMipmap(GCGLenum target)
 830 {
 831     makeContextCurrent();
 832     ::glGenerateMipmap(target);
 833 }
 834 
 835 bool GraphicsContextGLOpenGL::getActiveAttribImpl(PlatformGLObject program, GCGLuint index, ActiveInfo&amp; info)
 836 {
 837     if (!program) {
 838         synthesizeGLError(INVALID_VALUE);
 839         return false;
 840     }
 841     makeContextCurrent();
 842     GLint maxAttributeSize = 0;
 843     ::glGetProgramiv(program, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &amp;maxAttributeSize);
 844     Vector&lt;GLchar&gt; name(maxAttributeSize); // GL_ACTIVE_ATTRIBUTE_MAX_LENGTH includes null termination.
 845     GLsizei nameLength = 0;
 846     GLint size = 0;
 847     GLenum type = 0;
 848     ::glGetActiveAttrib(program, index, maxAttributeSize, &amp;nameLength, &amp;size, &amp;type, name.data());
 849     if (!nameLength)
 850         return false;
 851 
 852     String originalName = originalSymbolName(program, SHADER_SYMBOL_TYPE_ATTRIBUTE, String(name.data(), nameLength));
 853 
 854 #ifndef NDEBUG
 855     String uniformName(name.data(), nameLength);
 856     LOG(WebGL, &quot;Program %d is mapping active attribute %d from &#39;%s&#39; to &#39;%s&#39;&quot;, program, index, uniformName.utf8().data(), originalName.utf8().data());
 857 #endif
 858 
 859     info.name = originalName;
 860     info.type = type;
 861     info.size = size;
 862     return true;
 863 }
 864 
 865 bool GraphicsContextGLOpenGL::getActiveAttrib(PlatformGLObject program, GCGLuint index, ActiveInfo&amp; info)
 866 {
 867     GCGLint symbolCount;
 868     auto result = m_shaderProgramSymbolCountMap.find(program);
 869     if (result == m_shaderProgramSymbolCountMap.end()) {
 870         getNonBuiltInActiveSymbolCount(program, GraphicsContextGL::ACTIVE_ATTRIBUTES, &amp;symbolCount);
 871         result = m_shaderProgramSymbolCountMap.find(program);
 872     }
 873 
 874     ActiveShaderSymbolCounts&amp; symbolCounts = result-&gt;value;
 875     GCGLuint rawIndex = (index &lt; symbolCounts.filteredToActualAttributeIndexMap.size()) ? symbolCounts.filteredToActualAttributeIndexMap[index] : -1;
 876 
 877     return getActiveAttribImpl(program, rawIndex, info);
 878 }
 879 
 880 bool GraphicsContextGLOpenGL::getActiveUniformImpl(PlatformGLObject program, GCGLuint index, ActiveInfo&amp; info)
 881 {
 882     if (!program) {
 883         synthesizeGLError(INVALID_VALUE);
 884         return false;
 885     }
 886 
 887     makeContextCurrent();
 888     GLint maxUniformSize = 0;
 889     ::glGetProgramiv(program, GL_ACTIVE_UNIFORM_MAX_LENGTH, &amp;maxUniformSize);
 890 
 891     Vector&lt;GLchar&gt; name(maxUniformSize); // GL_ACTIVE_UNIFORM_MAX_LENGTH includes null termination.
 892     GLsizei nameLength = 0;
 893     GLint size = 0;
 894     GLenum type = 0;
 895     ::glGetActiveUniform(program, index, maxUniformSize, &amp;nameLength, &amp;size, &amp;type, name.data());
 896     if (!nameLength)
 897         return false;
 898 
 899     String originalName = originalSymbolName(program, SHADER_SYMBOL_TYPE_UNIFORM, String(name.data(), nameLength));
 900 
 901 #ifndef NDEBUG
 902     String uniformName(name.data(), nameLength);
 903     LOG(WebGL, &quot;Program %d is mapping active uniform %d from &#39;%s&#39; to &#39;%s&#39;&quot;, program, index, uniformName.utf8().data(), originalName.utf8().data());
 904 #endif
 905 
 906     info.name = originalName;
 907     info.type = type;
 908     info.size = size;
 909     return true;
 910 }
 911 
 912 bool GraphicsContextGLOpenGL::getActiveUniform(PlatformGLObject program, GCGLuint index, ActiveInfo&amp; info)
 913 {
 914     GCGLint symbolCount;
 915     auto result = m_shaderProgramSymbolCountMap.find(program);
 916     if (result == m_shaderProgramSymbolCountMap.end()) {
 917         getNonBuiltInActiveSymbolCount(program, GraphicsContextGL::ACTIVE_UNIFORMS, &amp;symbolCount);
 918         result = m_shaderProgramSymbolCountMap.find(program);
 919     }
 920 
 921     ActiveShaderSymbolCounts&amp; symbolCounts = result-&gt;value;
 922     GCGLuint rawIndex = (index &lt; symbolCounts.filteredToActualUniformIndexMap.size()) ? symbolCounts.filteredToActualUniformIndexMap[index] : -1;
 923 
 924     return getActiveUniformImpl(program, rawIndex, info);
 925 }
 926 
 927 void GraphicsContextGLOpenGL::getAttachedShaders(PlatformGLObject program, GCGLsizei maxCount, GCGLsizei* count, PlatformGLObject* shaders)
 928 {
 929     if (!program) {
 930         synthesizeGLError(INVALID_VALUE);
 931         return;
 932     }
 933     makeContextCurrent();
 934     ::glGetAttachedShaders(program, maxCount, count, shaders);
 935 }
 936 
 937 static String generateHashedName(const String&amp; name)
 938 {
 939     if (name.isEmpty())
 940         return name;
 941     uint64_t number = nameHashForShader(name.utf8().data(), name.length());
 942     return makeString(&quot;webgl_&quot;, hex(number, Lowercase));
 943 }
 944 
 945 Optional&lt;String&gt; GraphicsContextGLOpenGL::mappedSymbolInShaderSourceMap(PlatformGLObject shader, ANGLEShaderSymbolType symbolType, const String&amp; name)
 946 {
 947     auto result = m_shaderSourceMap.find(shader);
 948     if (result == m_shaderSourceMap.end())
 949         return WTF::nullopt;
 950 
 951     const auto&amp; symbolMap = result-&gt;value.symbolMap(symbolType);
 952     auto symbolEntry = symbolMap.find(name);
 953     if (symbolEntry == symbolMap.end())
 954         return WTF::nullopt;
 955 
 956     auto&amp; mappedName = symbolEntry-&gt;value.mappedName;
 957     return String(mappedName.c_str(), mappedName.length());
 958 }
 959 
 960 String GraphicsContextGLOpenGL::mappedSymbolName(PlatformGLObject program, ANGLEShaderSymbolType symbolType, const String&amp; name)
 961 {
 962     GCGLsizei count = 0;
 963     PlatformGLObject shaders[2] = { };
 964     getAttachedShaders(program, 2, &amp;count, shaders);
 965 
 966     for (GCGLsizei i = 0; i &lt; count; ++i) {
 967         auto mappedName = mappedSymbolInShaderSourceMap(shaders[i], symbolType, name);
 968         if (mappedName)
 969             return mappedName.value();
 970     }
 971 
 972     // We might have detached or deleted the shaders after linking.
 973     auto result = m_linkedShaderMap.find(program);
 974     if (result != m_linkedShaderMap.end()) {
 975         auto linkedShaders = result-&gt;value;
 976         auto mappedName = mappedSymbolInShaderSourceMap(linkedShaders.first, symbolType, name);
 977         if (mappedName)
 978             return mappedName.value();
 979         mappedName = mappedSymbolInShaderSourceMap(linkedShaders.second, symbolType, name);
 980         if (mappedName)
 981             return mappedName.value();
 982     }
 983 
 984     if (symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE &amp;&amp; !name.isEmpty()) {
 985         // Attributes are a special case: they may be requested before any shaders have been compiled,
 986         // and aren&#39;t even required to be used in any shader program.
 987         if (!nameHashMapForShaders)
 988             nameHashMapForShaders = makeUnique&lt;ShaderNameHash&gt;();
 989         setCurrentNameHashMapForShader(nameHashMapForShaders.get());
 990 
 991         auto generatedName = generateHashedName(name);
 992 
 993         setCurrentNameHashMapForShader(nullptr);
 994 
 995         m_possiblyUnusedAttributeMap.set(generatedName, name);
 996 
 997         return generatedName;
 998     }
 999 
1000     return name;
1001 }
1002 
1003 Optional&lt;String&gt; GraphicsContextGLOpenGL::originalSymbolInShaderSourceMap(PlatformGLObject shader, ANGLEShaderSymbolType symbolType, const String&amp; name)
1004 {
1005     auto result = m_shaderSourceMap.find(shader);
1006     if (result == m_shaderSourceMap.end())
1007         return WTF::nullopt;
1008 
1009     const auto&amp; symbolMap = result-&gt;value.symbolMap(symbolType);
1010     for (const auto&amp; symbolEntry : symbolMap) {
1011         if (name == symbolEntry.value.mappedName.c_str())
1012             return symbolEntry.key;
1013     }
1014     return WTF::nullopt;
1015 }
1016 
1017 String GraphicsContextGLOpenGL::originalSymbolName(PlatformGLObject program, ANGLEShaderSymbolType symbolType, const String&amp; name)
1018 {
1019     GCGLsizei count;
1020     PlatformGLObject shaders[2];
1021     getAttachedShaders(program, 2, &amp;count, shaders);
1022 
1023     for (GCGLsizei i = 0; i &lt; count; ++i) {
1024         auto originalName = originalSymbolInShaderSourceMap(shaders[i], symbolType, name);
1025         if (originalName)
1026             return originalName.value();
1027     }
1028 
1029     // We might have detached or deleted the shaders after linking.
1030     auto result = m_linkedShaderMap.find(program);
1031     if (result != m_linkedShaderMap.end()) {
1032         auto linkedShaders = result-&gt;value;
1033         auto originalName = originalSymbolInShaderSourceMap(linkedShaders.first, symbolType, name);
1034         if (originalName)
1035             return originalName.value();
1036         originalName = originalSymbolInShaderSourceMap(linkedShaders.second, symbolType, name);
1037         if (originalName)
1038             return originalName.value();
1039     }
1040 
1041     if (symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE &amp;&amp; !name.isEmpty()) {
1042         // Attributes are a special case: they may be requested before any shaders have been compiled,
1043         // and aren&#39;t even required to be used in any shader program.
1044 
1045         const auto&amp; cached = m_possiblyUnusedAttributeMap.find(name);
1046         if (cached != m_possiblyUnusedAttributeMap.end())
1047             return cached-&gt;value;
1048     }
1049 
1050     return name;
1051 }
1052 
1053 String GraphicsContextGLOpenGL::mappedSymbolName(PlatformGLObject shaders[2], size_t count, const String&amp; name)
1054 {
1055     for (size_t symbolType = 0; symbolType &lt;= static_cast&lt;size_t&gt;(SHADER_SYMBOL_TYPE_VARYING); ++symbolType) {
1056         for (size_t i = 0; i &lt; count; ++i) {
1057             ShaderSourceMap::iterator result = m_shaderSourceMap.find(shaders[i]);
1058             if (result == m_shaderSourceMap.end())
1059                 continue;
1060 
1061             const ShaderSymbolMap&amp; symbolMap = result-&gt;value.symbolMap(static_cast&lt;enum ANGLEShaderSymbolType&gt;(symbolType));
1062             for (const auto&amp; symbolEntry : symbolMap) {
1063                 if (name == symbolEntry.value.mappedName.c_str())
1064                     return symbolEntry.key;
1065             }
1066         }
1067     }
1068     return name;
1069 }
1070 
1071 int GraphicsContextGLOpenGL::getAttribLocation(PlatformGLObject program, const String&amp; name)
1072 {
1073     if (!program)
1074         return -1;
1075 
1076     makeContextCurrent();
1077 
1078     String mappedName = mappedSymbolName(program, SHADER_SYMBOL_TYPE_ATTRIBUTE, name);
1079     LOG(WebGL, &quot;::glGetAttribLocation is mapping %s to %s&quot;, name.utf8().data(), mappedName.utf8().data());
1080     return ::glGetAttribLocation(program, mappedName.utf8().data());
1081 }
1082 
1083 int GraphicsContextGLOpenGL::getAttribLocationDirect(PlatformGLObject program, const String&amp; name)
1084 {
1085     if (!program)
1086         return -1;
1087 
1088     makeContextCurrent();
1089 
1090     return ::glGetAttribLocation(program, name.utf8().data());
1091 }
1092 
1093 bool GraphicsContextGLOpenGL::moveErrorsToSyntheticErrorList()
1094 {
1095     makeContextCurrent();
1096     bool movedAnError = false;
1097 
1098     // Set an arbitrary limit of 100 here to avoid creating a hang if
1099     // a problem driver has a bug that causes it to never clear the error.
1100     // Otherwise, we would just loop until we got NO_ERROR.
1101     for (unsigned i = 0; i &lt; 100; ++i) {
1102         GCGLenum error = glGetError();
1103         if (error == NO_ERROR)
1104             break;
1105         m_syntheticErrors.add(error);
1106         movedAnError = true;
1107     }
1108 
1109     return movedAnError;
1110 }
1111 
1112 GCGLenum GraphicsContextGLOpenGL::getError()
1113 {
1114     if (!m_syntheticErrors.isEmpty()) {
1115         // Need to move the current errors to the synthetic error list in case
1116         // that error is already there, since the expected behavior of both
1117         // glGetError and getError is to only report each error code once.
1118         moveErrorsToSyntheticErrorList();
1119         return m_syntheticErrors.takeFirst();
1120     }
1121 
1122     makeContextCurrent();
1123     return ::glGetError();
1124 }
1125 
1126 String GraphicsContextGLOpenGL::getString(GCGLenum name)
1127 {
1128     makeContextCurrent();
1129     return String(reinterpret_cast&lt;const char*&gt;(::glGetString(name)));
1130 }
1131 
1132 void GraphicsContextGLOpenGL::hint(GCGLenum target, GCGLenum mode)
1133 {
1134     makeContextCurrent();
1135     ::glHint(target, mode);
1136 }
1137 
1138 GCGLboolean GraphicsContextGLOpenGL::isBuffer(PlatformGLObject buffer)
1139 {
1140     if (!buffer)
1141         return GL_FALSE;
1142 
1143     makeContextCurrent();
1144     return ::glIsBuffer(buffer);
1145 }
1146 
1147 GCGLboolean GraphicsContextGLOpenGL::isEnabled(GCGLenum cap)
1148 {
1149     makeContextCurrent();
1150     return ::glIsEnabled(cap);
1151 }
1152 
1153 GCGLboolean GraphicsContextGLOpenGL::isFramebuffer(PlatformGLObject framebuffer)
1154 {
1155     if (!framebuffer)
1156         return GL_FALSE;
1157 
1158     makeContextCurrent();
1159     return ::glIsFramebufferEXT(framebuffer);
1160 }
1161 
1162 GCGLboolean GraphicsContextGLOpenGL::isProgram(PlatformGLObject program)
1163 {
1164     if (!program)
1165         return GL_FALSE;
1166 
1167     makeContextCurrent();
1168     return ::glIsProgram(program);
1169 }
1170 
1171 GCGLboolean GraphicsContextGLOpenGL::isRenderbuffer(PlatformGLObject renderbuffer)
1172 {
1173     if (!renderbuffer)
1174         return GL_FALSE;
1175 
1176     makeContextCurrent();
1177     return ::glIsRenderbufferEXT(renderbuffer);
1178 }
1179 
1180 GCGLboolean GraphicsContextGLOpenGL::isShader(PlatformGLObject shader)
1181 {
1182     if (!shader)
1183         return GL_FALSE;
1184 
1185     makeContextCurrent();
1186     return ::glIsShader(shader);
1187 }
1188 
1189 GCGLboolean GraphicsContextGLOpenGL::isTexture(PlatformGLObject texture)
1190 {
1191     if (!texture)
1192         return GL_FALSE;
1193 
1194     makeContextCurrent();
1195     return ::glIsTexture(texture);
1196 }
1197 
1198 void GraphicsContextGLOpenGL::lineWidth(GCGLfloat width)
1199 {
1200     makeContextCurrent();
1201     ::glLineWidth(width);
1202 }
1203 
1204 void GraphicsContextGLOpenGL::linkProgram(PlatformGLObject program)
1205 {
1206     ASSERT(program);
1207     makeContextCurrent();
1208 
1209     GCGLsizei count = 0;
1210     PlatformGLObject shaders[2] = { };
1211     getAttachedShaders(program, 2, &amp;count, shaders);
1212 
1213     if (count == 2)
1214         m_linkedShaderMap.set(program, std::make_pair(shaders[0], shaders[1]));
1215 
1216     ::glLinkProgram(program);
1217 }
1218 
1219 void GraphicsContextGLOpenGL::pixelStorei(GCGLenum pname, GCGLint param)
1220 {
1221     makeContextCurrent();
1222     ::glPixelStorei(pname, param);
1223 }
1224 
1225 void GraphicsContextGLOpenGL::polygonOffset(GCGLfloat factor, GCGLfloat units)
1226 {
1227     makeContextCurrent();
1228     ::glPolygonOffset(factor, units);
1229 }
1230 
1231 void GraphicsContextGLOpenGL::sampleCoverage(GCGLclampf value, GCGLboolean invert)
1232 {
1233     makeContextCurrent();
1234     ::glSampleCoverage(value, invert);
1235 }
1236 
1237 void GraphicsContextGLOpenGL::scissor(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
1238 {
1239     makeContextCurrent();
1240     ::glScissor(x, y, width, height);
1241 }
1242 
1243 void GraphicsContextGLOpenGL::shaderSource(PlatformGLObject shader, const String&amp; string)
1244 {
1245     ASSERT(shader);
1246 
1247     makeContextCurrent();
1248 
1249     ShaderSourceEntry entry;
1250 
1251     entry.source = string;
1252 
1253     m_shaderSourceMap.set(shader, entry);
1254 }
1255 
1256 void GraphicsContextGLOpenGL::stencilFunc(GCGLenum func, GCGLint ref, GCGLuint mask)
1257 {
1258     makeContextCurrent();
1259     ::glStencilFunc(func, ref, mask);
1260 }
1261 
1262 void GraphicsContextGLOpenGL::stencilFuncSeparate(GCGLenum face, GCGLenum func, GCGLint ref, GCGLuint mask)
1263 {
1264     makeContextCurrent();
1265     ::glStencilFuncSeparate(face, func, ref, mask);
1266 }
1267 
1268 void GraphicsContextGLOpenGL::stencilMask(GCGLuint mask)
1269 {
1270     makeContextCurrent();
1271     ::glStencilMask(mask);
1272 }
1273 
1274 void GraphicsContextGLOpenGL::stencilMaskSeparate(GCGLenum face, GCGLuint mask)
1275 {
1276     makeContextCurrent();
1277     ::glStencilMaskSeparate(face, mask);
1278 }
1279 
1280 void GraphicsContextGLOpenGL::stencilOp(GCGLenum fail, GCGLenum zfail, GCGLenum zpass)
1281 {
1282     makeContextCurrent();
1283     ::glStencilOp(fail, zfail, zpass);
1284 }
1285 
1286 void GraphicsContextGLOpenGL::stencilOpSeparate(GCGLenum face, GCGLenum fail, GCGLenum zfail, GCGLenum zpass)
1287 {
1288     makeContextCurrent();
1289     ::glStencilOpSeparate(face, fail, zfail, zpass);
1290 }
1291 
1292 void GraphicsContextGLOpenGL::texParameterf(GCGLenum target, GCGLenum pname, GCGLfloat value)
1293 {
1294     makeContextCurrent();
1295     ::glTexParameterf(target, pname, value);
1296 }
1297 
1298 void GraphicsContextGLOpenGL::texParameteri(GCGLenum target, GCGLenum pname, GCGLint value)
1299 {
1300     makeContextCurrent();
1301     ::glTexParameteri(target, pname, value);
1302 }
1303 
1304 void GraphicsContextGLOpenGL::uniform1f(GCGLint location, GCGLfloat v0)
1305 {
1306     makeContextCurrent();
1307     ::glUniform1f(location, v0);
1308 }
1309 
1310 void GraphicsContextGLOpenGL::uniform1fv(GCGLint location, GCGLsizei size, const GCGLfloat* array)
1311 {
1312     makeContextCurrent();
1313     ::glUniform1fv(location, size, array);
1314 }
1315 
1316 void GraphicsContextGLOpenGL::uniform2f(GCGLint location, GCGLfloat v0, GCGLfloat v1)
1317 {
1318     makeContextCurrent();
1319     ::glUniform2f(location, v0, v1);
1320 }
1321 
1322 void GraphicsContextGLOpenGL::uniform2fv(GCGLint location, GCGLsizei size, const GCGLfloat* array)
1323 {
1324     // FIXME: length needs to be a multiple of 2.
1325     makeContextCurrent();
1326     ::glUniform2fv(location, size, array);
1327 }
1328 
1329 void GraphicsContextGLOpenGL::uniform3f(GCGLint location, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2)
1330 {
1331     makeContextCurrent();
1332     ::glUniform3f(location, v0, v1, v2);
1333 }
1334 
1335 void GraphicsContextGLOpenGL::uniform3fv(GCGLint location, GCGLsizei size, const GCGLfloat* array)
1336 {
1337     // FIXME: length needs to be a multiple of 3.
1338     makeContextCurrent();
1339     ::glUniform3fv(location, size, array);
1340 }
1341 
1342 void GraphicsContextGLOpenGL::uniform4f(GCGLint location, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2, GCGLfloat v3)
1343 {
1344     makeContextCurrent();
1345     ::glUniform4f(location, v0, v1, v2, v3);
1346 }
1347 
1348 void GraphicsContextGLOpenGL::uniform4fv(GCGLint location, GCGLsizei size, const GCGLfloat* array)
1349 {
1350     // FIXME: length needs to be a multiple of 4.
1351     makeContextCurrent();
1352     ::glUniform4fv(location, size, array);
1353 }
1354 
1355 void GraphicsContextGLOpenGL::uniform1i(GCGLint location, GCGLint v0)
1356 {
1357     makeContextCurrent();
1358     ::glUniform1i(location, v0);
1359 }
1360 
1361 void GraphicsContextGLOpenGL::uniform1iv(GCGLint location, GCGLsizei size, const GCGLint* array)
1362 {
1363     makeContextCurrent();
1364     ::glUniform1iv(location, size, array);
1365 }
1366 
1367 void GraphicsContextGLOpenGL::uniform2i(GCGLint location, GCGLint v0, GCGLint v1)
1368 {
1369     makeContextCurrent();
1370     ::glUniform2i(location, v0, v1);
1371 }
1372 
1373 void GraphicsContextGLOpenGL::uniform2iv(GCGLint location, GCGLsizei size, const GCGLint* array)
1374 {
1375     // FIXME: length needs to be a multiple of 2.
1376     makeContextCurrent();
1377     ::glUniform2iv(location, size, array);
1378 }
1379 
1380 void GraphicsContextGLOpenGL::uniform3i(GCGLint location, GCGLint v0, GCGLint v1, GCGLint v2)
1381 {
1382     makeContextCurrent();
1383     ::glUniform3i(location, v0, v1, v2);
1384 }
1385 
1386 void GraphicsContextGLOpenGL::uniform3iv(GCGLint location, GCGLsizei size, const GCGLint* array)
1387 {
1388     // FIXME: length needs to be a multiple of 3.
1389     makeContextCurrent();
1390     ::glUniform3iv(location, size, array);
1391 }
1392 
1393 void GraphicsContextGLOpenGL::uniform4i(GCGLint location, GCGLint v0, GCGLint v1, GCGLint v2, GCGLint v3)
1394 {
1395     makeContextCurrent();
1396     ::glUniform4i(location, v0, v1, v2, v3);
1397 }
1398 
1399 void GraphicsContextGLOpenGL::uniform4iv(GCGLint location, GCGLsizei size, const GCGLint* array)
1400 {
1401     // FIXME: length needs to be a multiple of 4.
1402     makeContextCurrent();
1403     ::glUniform4iv(location, size, array);
1404 }
1405 
1406 void GraphicsContextGLOpenGL::uniformMatrix2fv(GCGLint location, GCGLsizei size, GCGLboolean transpose, const GCGLfloat* array)
1407 {
1408     // FIXME: length needs to be a multiple of 4.
1409     makeContextCurrent();
1410     ::glUniformMatrix2fv(location, size, transpose, array);
1411 }
1412 
1413 void GraphicsContextGLOpenGL::uniformMatrix3fv(GCGLint location, GCGLsizei size, GCGLboolean transpose, const GCGLfloat* array)
1414 {
1415     // FIXME: length needs to be a multiple of 9.
1416     makeContextCurrent();
1417     ::glUniformMatrix3fv(location, size, transpose, array);
1418 }
1419 
1420 void GraphicsContextGLOpenGL::uniformMatrix4fv(GCGLint location, GCGLsizei size, GCGLboolean transpose, const GCGLfloat* array)
1421 {
1422     // FIXME: length needs to be a multiple of 16.
1423     makeContextCurrent();
1424     ::glUniformMatrix4fv(location, size, transpose, array);
1425 }
1426 
1427 void GraphicsContextGLOpenGL::useProgram(PlatformGLObject program)
1428 {
1429     makeContextCurrent();
1430     ::glUseProgram(program);
1431 }
1432 
1433 void GraphicsContextGLOpenGL::validateProgram(PlatformGLObject program)
1434 {
1435     ASSERT(program);
1436 
1437     makeContextCurrent();
1438     ::glValidateProgram(program);
1439 }
1440 
1441 void GraphicsContextGLOpenGL::vertexAttrib1f(GCGLuint index, GCGLfloat v0)
1442 {
1443     makeContextCurrent();
1444     ::glVertexAttrib1f(index, v0);
1445 }
1446 
1447 void GraphicsContextGLOpenGL::vertexAttrib1fv(GCGLuint index, const GCGLfloat* array)
1448 {
1449     makeContextCurrent();
1450     ::glVertexAttrib1fv(index, array);
1451 }
1452 
1453 void GraphicsContextGLOpenGL::vertexAttrib2f(GCGLuint index, GCGLfloat v0, GCGLfloat v1)
1454 {
1455     makeContextCurrent();
1456     ::glVertexAttrib2f(index, v0, v1);
1457 }
1458 
1459 void GraphicsContextGLOpenGL::vertexAttrib2fv(GCGLuint index, const GCGLfloat* array)
1460 {
1461     makeContextCurrent();
1462     ::glVertexAttrib2fv(index, array);
1463 }
1464 
1465 void GraphicsContextGLOpenGL::vertexAttrib3f(GCGLuint index, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2)
1466 {
1467     makeContextCurrent();
1468     ::glVertexAttrib3f(index, v0, v1, v2);
1469 }
1470 
1471 void GraphicsContextGLOpenGL::vertexAttrib3fv(GCGLuint index, const GCGLfloat* array)
1472 {
1473     makeContextCurrent();
1474     ::glVertexAttrib3fv(index, array);
1475 }
1476 
1477 void GraphicsContextGLOpenGL::vertexAttrib4f(GCGLuint index, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2, GCGLfloat v3)
1478 {
1479     makeContextCurrent();
1480     ::glVertexAttrib4f(index, v0, v1, v2, v3);
1481 }
1482 
1483 void GraphicsContextGLOpenGL::vertexAttrib4fv(GCGLuint index, const GCGLfloat* array)
1484 {
1485     makeContextCurrent();
1486     ::glVertexAttrib4fv(index, array);
1487 }
1488 
1489 void GraphicsContextGLOpenGL::vertexAttribPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLboolean normalized, GCGLsizei stride, GCGLintptr offset)
1490 {
1491     makeContextCurrent();
1492     ::glVertexAttribPointer(index, size, type, normalized, stride, reinterpret_cast&lt;GLvoid*&gt;(static_cast&lt;intptr_t&gt;(offset)));
1493 }
1494 
1495 void GraphicsContextGLOpenGL::viewport(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
1496 {
1497     makeContextCurrent();
1498     ::glViewport(x, y, width, height);
1499 }
1500 
1501 PlatformGLObject GraphicsContextGLOpenGL::createVertexArray()
1502 {
1503     makeContextCurrent();
1504     GLuint array = 0;
1505 #if (!USE(OPENGL_ES) &amp;&amp; (PLATFORM(GTK) || PLATFORM(WIN))) || PLATFORM(COCOA)
1506     ::glGenVertexArrays(1, &amp;array);
1507 #endif
1508     return array;
1509 }
1510 
1511 void GraphicsContextGLOpenGL::deleteVertexArray(PlatformGLObject array)
1512 {
1513     if (!array)
1514         return;
1515 
1516     makeContextCurrent();
1517 #if (!USE(OPENGL_ES) &amp;&amp; (PLATFORM(GTK) || PLATFORM(WIN))) || PLATFORM(COCOA)
1518     ::glDeleteVertexArrays(1, &amp;array);
1519 #endif
1520 }
1521 
1522 GCGLboolean GraphicsContextGLOpenGL::isVertexArray(PlatformGLObject array)
1523 {
1524     if (!array)
1525         return GL_FALSE;
1526 
1527     makeContextCurrent();
1528 #if (!USE(OPENGL_ES) &amp;&amp; (PLATFORM(GTK) || PLATFORM(WIN))) || PLATFORM(COCOA)
1529     return ::glIsVertexArray(array);
1530 #endif
1531     return GL_FALSE;
1532 }
1533 
1534 void GraphicsContextGLOpenGL::bindVertexArray(PlatformGLObject array)
1535 {
1536     makeContextCurrent();
1537 #if (!USE(OPENGL_ES) &amp;&amp; (PLATFORM(GTK) || PLATFORM(WIN))) || PLATFORM(COCOA)
1538     ::glBindVertexArray(array);
1539 #else
1540     UNUSED_PARAM(array);
1541 #endif
1542 }
1543 
1544 void GraphicsContextGLOpenGL::getBooleanv(GCGLenum pname, GCGLboolean* value)
1545 {
1546     makeContextCurrent();
1547     ::glGetBooleanv(pname, value);
1548 }
1549 
1550 void GraphicsContextGLOpenGL::getBufferParameteriv(GCGLenum target, GCGLenum pname, GCGLint* value)
1551 {
1552     makeContextCurrent();
1553     ::glGetBufferParameteriv(target, pname, value);
1554 }
1555 
1556 void GraphicsContextGLOpenGL::getFloatv(GCGLenum pname, GCGLfloat* value)
1557 {
1558     makeContextCurrent();
1559     ::glGetFloatv(pname, value);
1560 }
1561 
1562 void GraphicsContextGLOpenGL::getInteger64v(GCGLenum pname, GCGLint64* value)
1563 {
1564     UNUSED_PARAM(pname);
1565     makeContextCurrent();
1566     *value = 0;
1567     // FIXME 141178: Before enabling this we must first switch over to using gl3.h and creating and initialing the WebGL2 context using OpenGL ES 3.0.
1568     // ::glGetInteger64v(pname, value);
1569 }
1570 
1571 void GraphicsContextGLOpenGL::getFramebufferAttachmentParameteriv(GCGLenum target, GCGLenum attachment, GCGLenum pname, GCGLint* value)
1572 {
1573     makeContextCurrent();
1574     if (attachment == DEPTH_STENCIL_ATTACHMENT)
1575         attachment = DEPTH_ATTACHMENT; // Or STENCIL_ATTACHMENT, either works.
1576     ::glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, value);
1577 }
1578 
1579 void GraphicsContextGLOpenGL::getProgramiv(PlatformGLObject program, GCGLenum pname, GCGLint* value)
1580 {
1581     makeContextCurrent();
1582     ::glGetProgramiv(program, pname, value);
1583 }
1584 
1585 void GraphicsContextGLOpenGL::getNonBuiltInActiveSymbolCount(PlatformGLObject program, GCGLenum pname, GCGLint* value)
1586 {
1587     ASSERT(ACTIVE_ATTRIBUTES == pname || ACTIVE_UNIFORMS == pname);
1588     if (!value)
1589         return;
1590 
1591     makeContextCurrent();
1592     const auto&amp; result = m_shaderProgramSymbolCountMap.find(program);
1593     if (result != m_shaderProgramSymbolCountMap.end()) {
1594         *value = result-&gt;value.countForType(pname);
1595         return;
1596     }
1597 
1598     m_shaderProgramSymbolCountMap.set(program, ActiveShaderSymbolCounts());
1599     ActiveShaderSymbolCounts&amp; symbolCounts = m_shaderProgramSymbolCountMap.find(program)-&gt;value;
1600 
1601     // Retrieve the active attributes, build a filtered count, and a mapping of
1602     // our internal attributes indexes to the real unfiltered indexes inside OpenGL.
1603     GCGLint attributeCount = 0;
1604     ::glGetProgramiv(program, ACTIVE_ATTRIBUTES, &amp;attributeCount);
1605     for (GCGLint i = 0; i &lt; attributeCount; ++i) {
1606         ActiveInfo info;
1607         getActiveAttribImpl(program, i, info);
1608         if (info.name.startsWith(&quot;gl_&quot;))
1609             continue;
1610 
1611         symbolCounts.filteredToActualAttributeIndexMap.append(i);
1612     }
1613 
1614     // Do the same for uniforms.
1615     GCGLint uniformCount = 0;
1616     ::glGetProgramiv(program, ACTIVE_UNIFORMS, &amp;uniformCount);
1617     for (GCGLint i = 0; i &lt; uniformCount; ++i) {
1618         ActiveInfo info;
1619         getActiveUniformImpl(program, i, info);
1620         if (info.name.startsWith(&quot;gl_&quot;))
1621             continue;
1622 
1623         symbolCounts.filteredToActualUniformIndexMap.append(i);
1624     }
1625 
1626     *value = symbolCounts.countForType(pname);
1627 }
1628 
1629 String GraphicsContextGLOpenGL::getUnmangledInfoLog(PlatformGLObject shaders[2], GCGLsizei count, const String&amp; log)
1630 {
1631     LOG(WebGL, &quot;Original ShaderInfoLog:\n%s&quot;, log.utf8().data());
1632 
1633     JSC::Yarr::RegularExpression regExp(&quot;webgl_[0123456789abcdefABCDEF]+&quot;);
1634 
1635     StringBuilder processedLog;
1636 
1637     // ANGLE inserts a &quot;#extension&quot; line into the shader source that
1638     // causes a warning in some compilers. There is no point showing
1639     // this warning to the user since they didn&#39;t write the code that
1640     // is causing it.
1641     static const NeverDestroyed&lt;String&gt; angleWarning { &quot;WARNING: 0:1: extension &#39;GL_ARB_gpu_shader5&#39; is not supported\n&quot;_s };
1642     int startFrom = log.startsWith(angleWarning) ? angleWarning.get().length() : 0;
1643     int matchedLength = 0;
1644 
1645     do {
1646         int start = regExp.match(log, startFrom, &amp;matchedLength);
1647         if (start == -1)
1648             break;
1649 
1650         processedLog.append(log.substring(startFrom, start - startFrom));
1651         startFrom = start + matchedLength;
1652 
1653         const String&amp; mangledSymbol = log.substring(start, matchedLength);
1654         const String&amp; mappedSymbol = mappedSymbolName(shaders, count, mangledSymbol);
1655         LOG(WebGL, &quot;Demangling: %s to %s&quot;, mangledSymbol.utf8().data(), mappedSymbol.utf8().data());
1656         processedLog.append(mappedSymbol);
1657     } while (startFrom &lt; static_cast&lt;int&gt;(log.length()));
1658 
1659     processedLog.append(log.substring(startFrom, log.length() - startFrom));
1660 
1661     LOG(WebGL, &quot;Unmangled ShaderInfoLog:\n%s&quot;, processedLog.toString().utf8().data());
1662     return processedLog.toString();
1663 }
1664 
1665 String GraphicsContextGLOpenGL::getProgramInfoLog(PlatformGLObject program)
1666 {
1667     ASSERT(program);
1668 
1669     makeContextCurrent();
1670     GLint length = 0;
1671     ::glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;length);
1672     if (!length)
1673         return String();
1674 
1675     GLsizei size = 0;
1676     Vector&lt;GLchar&gt; info(length);
1677     ::glGetProgramInfoLog(program, length, &amp;size, info.data());
1678 
1679     GCGLsizei count;
1680     PlatformGLObject shaders[2];
1681     getAttachedShaders(program, 2, &amp;count, shaders);
1682 
1683     return getUnmangledInfoLog(shaders, count, String(info.data(), size));
1684 }
1685 
1686 void GraphicsContextGLOpenGL::getRenderbufferParameteriv(GCGLenum target, GCGLenum pname, GCGLint* value)
1687 {
1688     makeContextCurrent();
1689     ::glGetRenderbufferParameterivEXT(target, pname, value);
1690 }
1691 
1692 void GraphicsContextGLOpenGL::getShaderiv(PlatformGLObject shader, GCGLenum pname, GCGLint* value)
1693 {
1694     ASSERT(shader);
1695 
1696     makeContextCurrent();
1697 
1698     const auto&amp; result = m_shaderSourceMap.find(shader);
1699 
1700     switch (pname) {
1701     case DELETE_STATUS:
1702     case SHADER_TYPE:
1703         ::glGetShaderiv(shader, pname, value);
1704         break;
1705     case COMPILE_STATUS:
1706         if (result == m_shaderSourceMap.end()) {
1707             *value = static_cast&lt;int&gt;(false);
1708             return;
1709         }
1710         *value = static_cast&lt;int&gt;(result-&gt;value.isValid);
1711         break;
1712     case INFO_LOG_LENGTH:
1713         if (result == m_shaderSourceMap.end()) {
1714             *value = 0;
1715             return;
1716         }
1717         *value = getShaderInfoLog(shader).length();
1718         break;
1719     case SHADER_SOURCE_LENGTH:
1720         *value = getShaderSource(shader).length();
1721         break;
1722     default:
1723         synthesizeGLError(INVALID_ENUM);
1724     }
1725 }
1726 
1727 String GraphicsContextGLOpenGL::getShaderInfoLog(PlatformGLObject shader)
1728 {
1729     ASSERT(shader);
1730 
1731     makeContextCurrent();
1732 
1733     const auto&amp; result = m_shaderSourceMap.find(shader);
1734     if (result == m_shaderSourceMap.end())
1735         return String();
1736 
1737     const ShaderSourceEntry&amp; entry = result-&gt;value;
1738     if (!entry.isValid)
1739         return entry.log;
1740 
1741     GLint length = 0;
1742     ::glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;length);
1743     if (!length)
1744         return String();
1745 
1746     GLsizei size = 0;
1747     Vector&lt;GLchar&gt; info(length);
1748     ::glGetShaderInfoLog(shader, length, &amp;size, info.data());
1749 
1750     PlatformGLObject shaders[2] = { shader, 0 };
1751     return getUnmangledInfoLog(shaders, 1, String(info.data(), size));
1752 }
1753 
1754 String GraphicsContextGLOpenGL::getShaderSource(PlatformGLObject shader)
1755 {
1756     ASSERT(shader);
1757 
1758     makeContextCurrent();
1759 
1760     const auto&amp; result = m_shaderSourceMap.find(shader);
1761     if (result == m_shaderSourceMap.end())
1762         return String();
1763 
1764     return result-&gt;value.source;
1765 }
1766 
1767 void GraphicsContextGLOpenGL::getTexParameterfv(GCGLenum target, GCGLenum pname, GCGLfloat* value)
1768 {
1769     makeContextCurrent();
1770     ::glGetTexParameterfv(target, pname, value);
1771 }
1772 
1773 void GraphicsContextGLOpenGL::getTexParameteriv(GCGLenum target, GCGLenum pname, GCGLint* value)
1774 {
1775     makeContextCurrent();
1776     ::glGetTexParameteriv(target, pname, value);
1777 }
1778 
1779 void GraphicsContextGLOpenGL::getUniformfv(PlatformGLObject program, GCGLint location, GCGLfloat* value)
1780 {
1781     makeContextCurrent();
1782     ::glGetUniformfv(program, location, value);
1783 }
1784 
1785 void GraphicsContextGLOpenGL::getUniformiv(PlatformGLObject program, GCGLint location, GCGLint* value)
1786 {
1787     makeContextCurrent();
1788     ::glGetUniformiv(program, location, value);
1789 }
1790 
1791 GCGLint GraphicsContextGLOpenGL::getUniformLocation(PlatformGLObject program, const String&amp; name)
1792 {
1793     ASSERT(program);
1794 
1795     makeContextCurrent();
1796 
1797     String mappedName = mappedSymbolName(program, SHADER_SYMBOL_TYPE_UNIFORM, name);
1798     LOG(WebGL, &quot;::getUniformLocation is mapping %s to %s&quot;, name.utf8().data(), mappedName.utf8().data());
1799     return ::glGetUniformLocation(program, mappedName.utf8().data());
1800 }
1801 
1802 void GraphicsContextGLOpenGL::getVertexAttribfv(GCGLuint index, GCGLenum pname, GCGLfloat* value)
1803 {
1804     makeContextCurrent();
1805     ::glGetVertexAttribfv(index, pname, value);
1806 }
1807 
1808 void GraphicsContextGLOpenGL::getVertexAttribiv(GCGLuint index, GCGLenum pname, GCGLint* value)
1809 {
1810     makeContextCurrent();
1811     ::glGetVertexAttribiv(index, pname, value);
1812 }
1813 
1814 GCGLsizeiptr GraphicsContextGLOpenGL::getVertexAttribOffset(GCGLuint index, GCGLenum pname)
1815 {
1816     makeContextCurrent();
1817 
1818     GLvoid* pointer = 0;
1819     ::glGetVertexAttribPointerv(index, pname, &amp;pointer);
1820     return static_cast&lt;GCGLsizeiptr&gt;(reinterpret_cast&lt;intptr_t&gt;(pointer));
1821 }
1822 
1823 void GraphicsContextGLOpenGL::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoff, GCGLint yoff, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, const void* pixels)
1824 {
1825     makeContextCurrent();
1826 
1827 #if !USE(OPENGL_ES)
1828     if (type == HALF_FLOAT_OES)
1829         type = GL_HALF_FLOAT_ARB;
1830 #endif
1831 
1832     if (m_usingCoreProfile)  {
1833         // There are some format values used in WebGL that are deprecated when using a core profile, so we need
1834         // to adapt them, as we do in GraphicsContextGLOpenGL::texImage2D().
1835         switch (format) {
1836         case ALPHA:
1837             // We are using GL_RED to back GL_ALPHA, so do it here as well.
1838             format = RED;
1839             break;
1840         case LUMINANCE_ALPHA:
1841             // We are using GL_RG to back GL_LUMINANCE_ALPHA, so do it here as well.
1842             format = RG;
1843             break;
1844         default:
1845             break;
1846         }
1847     }
1848 
1849     // FIXME: we will need to deal with PixelStore params when dealing with image buffers that differ from the subimage size.
1850     ::glTexSubImage2D(target, level, xoff, yoff, width, height, format, type, pixels);
1851     m_state.textureSeedCount.add(m_state.currentBoundTexture());
1852 }
1853 
1854 void GraphicsContextGLOpenGL::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, const void* data)
1855 {
1856     makeContextCurrent();
1857     ::glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
1858     m_state.textureSeedCount.add(m_state.currentBoundTexture());
1859 }
1860 
1861 void GraphicsContextGLOpenGL::compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLsizei imageSize, const void* data)
1862 {
1863     makeContextCurrent();
1864     ::glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
1865     m_state.textureSeedCount.add(m_state.currentBoundTexture());
1866 }
1867 
1868 PlatformGLObject GraphicsContextGLOpenGL::createBuffer()
1869 {
1870     makeContextCurrent();
1871     GLuint o = 0;
1872     glGenBuffers(1, &amp;o);
1873     return o;
1874 }
1875 
1876 PlatformGLObject GraphicsContextGLOpenGL::createFramebuffer()
1877 {
1878     makeContextCurrent();
1879     GLuint o = 0;
1880     glGenFramebuffersEXT(1, &amp;o);
1881     return o;
1882 }
1883 
1884 PlatformGLObject GraphicsContextGLOpenGL::createProgram()
1885 {
1886     makeContextCurrent();
1887     return glCreateProgram();
1888 }
1889 
1890 PlatformGLObject GraphicsContextGLOpenGL::createRenderbuffer()
1891 {
1892     makeContextCurrent();
1893     GLuint o = 0;
1894     glGenRenderbuffersEXT(1, &amp;o);
1895     return o;
1896 }
1897 
1898 PlatformGLObject GraphicsContextGLOpenGL::createShader(GCGLenum type)
1899 {
1900     makeContextCurrent();
1901     return glCreateShader((type == FRAGMENT_SHADER) ? GL_FRAGMENT_SHADER : GL_VERTEX_SHADER);
1902 }
1903 
1904 PlatformGLObject GraphicsContextGLOpenGL::createTexture()
1905 {
1906     makeContextCurrent();
1907     GLuint o = 0;
1908     glGenTextures(1, &amp;o);
1909     m_state.textureSeedCount.add(o);
1910     return o;
1911 }
1912 
1913 void GraphicsContextGLOpenGL::deleteBuffer(PlatformGLObject buffer)
1914 {
1915     makeContextCurrent();
1916     glDeleteBuffers(1, &amp;buffer);
1917 }
1918 
1919 void GraphicsContextGLOpenGL::deleteFramebuffer(PlatformGLObject framebuffer)
1920 {
1921     makeContextCurrent();
1922     if (framebuffer == m_state.boundFBO) {
1923         // Make sure the framebuffer is not going to be used for drawing
1924         // operations after it gets deleted.
1925         bindFramebuffer(FRAMEBUFFER, 0);
1926     }
1927     glDeleteFramebuffersEXT(1, &amp;framebuffer);
1928 }
1929 
1930 void GraphicsContextGLOpenGL::deleteProgram(PlatformGLObject program)
1931 {
1932     makeContextCurrent();
1933     m_shaderProgramSymbolCountMap.remove(program);
1934     glDeleteProgram(program);
1935 }
1936 
1937 void GraphicsContextGLOpenGL::deleteRenderbuffer(PlatformGLObject renderbuffer)
1938 {
1939     makeContextCurrent();
1940     glDeleteRenderbuffersEXT(1, &amp;renderbuffer);
1941 }
1942 
1943 void GraphicsContextGLOpenGL::deleteShader(PlatformGLObject shader)
1944 {
1945     makeContextCurrent();
1946     glDeleteShader(shader);
1947 }
1948 
1949 void GraphicsContextGLOpenGL::deleteTexture(PlatformGLObject texture)
1950 {
1951     makeContextCurrent();
1952 #if PLATFORM(MAC) &amp;&amp; USE(OPENGL)
1953     if (m_needsFlushBeforeDeleteTextures)
1954         flush();
1955 #endif
1956     m_state.boundTextureMap.removeIf([texture] (auto&amp; keyValue) {
1957         return keyValue.value.first == texture;
1958     });
1959     glDeleteTextures(1, &amp;texture);
1960     m_state.textureSeedCount.removeAll(texture);
1961 }
1962 
1963 void GraphicsContextGLOpenGL::synthesizeGLError(GCGLenum error)
1964 {
1965     // Need to move the current errors to the synthetic error list to
1966     // preserve the order of errors, so a caller to getError will get
1967     // any errors from glError before the error we are synthesizing.
1968     moveErrorsToSyntheticErrorList();
1969     m_syntheticErrors.add(error);
1970 }
1971 
1972 void GraphicsContextGLOpenGL::markContextChanged()
1973 {
1974     m_layerComposited = false;
1975 }
1976 
1977 void GraphicsContextGLOpenGL::markLayerComposited()
1978 {
1979     m_layerComposited = true;
1980 
1981     for (auto* client : copyToVector(m_clients))
1982         client-&gt;didComposite();
1983 }
1984 
1985 bool GraphicsContextGLOpenGL::layerComposited() const
1986 {
1987     return m_layerComposited;
1988 }
1989 
1990 void GraphicsContextGLOpenGL::forceContextLost()
1991 {
1992     for (auto* client : copyToVector(m_clients))
1993         client-&gt;forceContextLost();
1994 }
1995 
1996 void GraphicsContextGLOpenGL::recycleContext()
1997 {
1998     for (auto* client : copyToVector(m_clients))
1999         client-&gt;recycleContext();
2000 }
2001 
2002 void GraphicsContextGLOpenGL::dispatchContextChangedNotification()
2003 {
2004     for (auto* client : copyToVector(m_clients))
2005         client-&gt;dispatchContextChangedNotification();
2006 }
2007 
2008 void GraphicsContextGLOpenGL::texImage2DDirect(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels)
2009 {
2010     makeContextCurrent();
2011     ::glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
2012     m_state.textureSeedCount.add(m_state.currentBoundTexture());
2013 }
2014 
2015 void GraphicsContextGLOpenGL::drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount)
2016 {
2017     getExtensions().drawArraysInstanced(mode, first, count, primcount);
2018     checkGPUStatus();
2019 }
2020 
2021 void GraphicsContextGLOpenGL::drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLintptr offset, GCGLsizei primcount)
2022 {
2023     getExtensions().drawElementsInstanced(mode, count, type, offset, primcount);
2024     checkGPUStatus();
2025 }
2026 
2027 void GraphicsContextGLOpenGL::vertexAttribDivisor(GCGLuint index, GCGLuint divisor)
2028 {
2029     getExtensions().vertexAttribDivisor(index, divisor);
2030 }
2031 
2032 #if HAVE(OPENGL_4) &amp;&amp; ENABLE(WEBGL2)
2033 void GraphicsContextGLOpenGL::primitiveRestartIndex(GCGLuint index)
2034 {
2035     makeContextCurrent();
2036     ::glPrimitiveRestartIndex(index);
2037 }
2038 #endif
2039 
2040 void GraphicsContextGLOpenGL::bufferData(GCGLenum target, const void* data, GCGLenum usage, GCGLuint srcOffset, GCGLuint length)
2041 {
2042     UNUSED_PARAM(target);
2043     UNUSED_PARAM(data);
2044     UNUSED_PARAM(usage);
2045     UNUSED_PARAM(srcOffset);
2046     UNUSED_PARAM(length);
2047 }
2048 
2049 void GraphicsContextGLOpenGL::bufferSubData(GCGLenum target, GCGLintptr dstByteOffset, const void* srcData, GCGLuint srcOffset, GCGLuint length)
2050 {
2051     UNUSED_PARAM(target);
2052     UNUSED_PARAM(dstByteOffset);
2053     UNUSED_PARAM(srcData);
2054     UNUSED_PARAM(srcOffset);
2055     UNUSED_PARAM(length);
2056 }
2057 
2058 #if HAVE(OPENGL_4) || HAVE(OPENGL_ES_3)
2059 void GraphicsContextGLOpenGL::copyBufferSubData(GCGLenum readTarget, GCGLenum writeTarget, GCGLintptr readOffset, GCGLintptr writeOffset, GCGLsizeiptr size)
2060 {
2061     makeContextCurrent();
2062     ::glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
2063 }
2064 #elif !USE(ANGLE)
2065 void GraphicsContextGLOpenGL::copyBufferSubData(GCGLenum, GCGLenum, GCGLintptr, GCGLintptr, GCGLsizeiptr)
2066 {
2067 }
2068 #endif
2069 
2070 void GraphicsContextGLOpenGL::getBufferSubData(GCGLenum target, GCGLintptr srcByteOffset, const void* dstData, GCGLuint dstOffset, GCGLuint length)
2071 {
2072     UNUSED_PARAM(target);
2073     UNUSED_PARAM(srcByteOffset);
2074     UNUSED_PARAM(dstData);
2075     UNUSED_PARAM(dstOffset);
2076     UNUSED_PARAM(length);
2077 }
2078 
2079 #if HAVE(OPENGL_4) || HAVE(OPENGL_ES_3)
2080 void* GraphicsContextGLOpenGL::mapBufferRange(GCGLenum target, GCGLintptr offset, GCGLsizeiptr length, GCGLbitfield access)
2081 {
2082     makeContextCurrent();
2083     return ::glMapBufferRange(target, offset, length, access);
2084 }
2085 
2086 GCGLboolean GraphicsContextGLOpenGL::unmapBuffer(GCGLenum target)
2087 {
2088     makeContextCurrent();
2089     return ::glUnmapBuffer(target);
2090 }
2091 #elif !USE(ANGLE)
2092 void* GraphicsContextGLOpenGL::mapBufferRange(GCGLenum, GCGLintptr, GCGLsizeiptr, GCGLbitfield)
2093 {
2094     return nullptr;
2095 }
2096 
2097 GCGLboolean GraphicsContextGLOpenGL::unmapBuffer(GCGLenum)
2098 {
2099     return false;
2100 }
2101 #endif
2102 
2103 void GraphicsContextGLOpenGL::blitFramebuffer(GCGLint srcX0, GCGLint srcY0, GCGLint srcX1, GCGLint srcY1, GCGLint dstX0, GCGLint dstY0, GCGLint dstX1, GCGLint dstY1, GCGLbitfield mask, GCGLenum filter)
2104 {
2105     UNUSED_PARAM(srcX0);
2106     UNUSED_PARAM(srcY0);
2107     UNUSED_PARAM(srcX1);
2108     UNUSED_PARAM(srcY1);
2109     UNUSED_PARAM(dstX0);
2110     UNUSED_PARAM(dstY0);
2111     UNUSED_PARAM(dstX1);
2112     UNUSED_PARAM(dstY1);
2113     UNUSED_PARAM(mask);
2114     UNUSED_PARAM(filter);
2115 }
2116 
2117 void GraphicsContextGLOpenGL::framebufferTextureLayer(GCGLenum target, GCGLenum attachment, PlatformGLObject texture, GCGLint level, GCGLint layer)
2118 {
2119     UNUSED_PARAM(target);
2120     UNUSED_PARAM(attachment);
2121     UNUSED_PARAM(texture);
2122     UNUSED_PARAM(level);
2123     UNUSED_PARAM(layer);
2124 }
2125 
2126 void GraphicsContextGLOpenGL::invalidateFramebuffer(GCGLenum target, const Vector&lt;GCGLenum&gt;&amp; attachments)
2127 {
2128     UNUSED_PARAM(target);
2129     UNUSED_PARAM(attachments);
2130 }
2131 
2132 void GraphicsContextGLOpenGL::invalidateSubFramebuffer(GCGLenum target, const Vector&lt;GCGLenum&gt;&amp; attachments, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
2133 {
2134     UNUSED_PARAM(target);
2135     UNUSED_PARAM(attachments);
2136     UNUSED_PARAM(x);
2137     UNUSED_PARAM(y);
2138     UNUSED_PARAM(width);
2139     UNUSED_PARAM(height);
2140 }
2141 
2142 void GraphicsContextGLOpenGL::readBuffer(GCGLenum src)
2143 {
2144     UNUSED_PARAM(src);
2145 }
2146 
2147 #if HAVE(OPENGL_4) || HAVE(OPENGL_ES_3)
2148 void GraphicsContextGLOpenGL::getInternalformativ(GCGLenum target, GCGLenum internalformat, GCGLenum pname, GCGLsizei bufSize, GCGLint* params)
2149 {
2150 #if USE(OPENGL_ES)
2151     makeContextCurrent();
2152     ::glGetInternalformativ(target, internalformat, pname, bufSize, params);
2153 #else
2154     UNUSED_PARAM(target);
2155     UNUSED_PARAM(internalformat);
2156     UNUSED_PARAM(pname);
2157     UNUSED_PARAM(bufSize);
2158     UNUSED_PARAM(params);
2159 #endif
2160 }
2161 
2162 void GraphicsContextGLOpenGL::renderbufferStorageMultisample(GCGLenum target, GCGLsizei samples, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)
2163 {
2164     makeContextCurrent();
2165     ::glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
2166 }
2167 
2168 void GraphicsContextGLOpenGL::texStorage2D(GCGLenum target, GCGLsizei levels, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)
2169 {
2170     makeContextCurrent();
2171     ::glTexStorage2D(target, levels, internalformat, width, height);
2172     m_state.textureSeedCount.add(m_state.currentBoundTexture());
2173 }
2174 
2175 void GraphicsContextGLOpenGL::texStorage3D(GCGLenum target, GCGLsizei levels, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth)
2176 {
2177     makeContextCurrent();
2178     ::glTexStorage3D(target, levels, internalformat, width, height, depth);
2179     m_state.textureSeedCount.add(m_state.currentBoundTexture());
2180 }
2181 #elif !USE(ANGLE)
2182 void GraphicsContextGLOpenGL::getInternalformativ(GCGLenum, GCGLenum, GCGLenum, GCGLsizei, GCGLint*)
2183 {
2184 }
2185 
2186 void GraphicsContextGLOpenGL::renderbufferStorageMultisample(GCGLenum, GCGLsizei, GCGLenum, GCGLsizei, GCGLsizei)
2187 {
2188 }
2189 
2190 void GraphicsContextGLOpenGL::texStorage2D(GCGLenum, GCGLsizei, GCGLenum, GCGLsizei, GCGLsizei)
2191 {
2192 }
2193 
2194 void GraphicsContextGLOpenGL::texStorage3D(GCGLenum, GCGLsizei, GCGLenum, GCGLsizei, GCGLsizei, GCGLsizei)
2195 {
2196 }
2197 #endif
2198 
2199 void GraphicsContextGLOpenGL::texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, GCGLintptr pboOffset)
2200 {
2201     UNUSED_PARAM(target);
2202     UNUSED_PARAM(level);
2203     UNUSED_PARAM(internalformat);
2204     UNUSED_PARAM(width);
2205     UNUSED_PARAM(height);
2206     UNUSED_PARAM(depth);
2207     UNUSED_PARAM(border);
2208     UNUSED_PARAM(format);
2209     UNUSED_PARAM(type);
2210     UNUSED_PARAM(pboOffset);
2211 }
2212 
2213 void GraphicsContextGLOpenGL::texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels)
2214 {
2215     UNUSED_PARAM(target);
2216     UNUSED_PARAM(level);
2217     UNUSED_PARAM(internalformat);
2218     UNUSED_PARAM(width);
2219     UNUSED_PARAM(height);
2220     UNUSED_PARAM(depth);
2221     UNUSED_PARAM(border);
2222     UNUSED_PARAM(format);
2223     UNUSED_PARAM(type);
2224     UNUSED_PARAM(pixels);
2225 }
2226 
2227 void GraphicsContextGLOpenGL::texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, const void* srcData, GCGLuint srcOffset)
2228 {
2229     UNUSED_PARAM(target);
2230     UNUSED_PARAM(level);
2231     UNUSED_PARAM(internalformat);
2232     UNUSED_PARAM(width);
2233     UNUSED_PARAM(height);
2234     UNUSED_PARAM(depth);
2235     UNUSED_PARAM(border);
2236     UNUSED_PARAM(format);
2237     UNUSED_PARAM(type);
2238     UNUSED_PARAM(srcData);
2239     UNUSED_PARAM(srcOffset);
2240 }
2241 
2242 void GraphicsContextGLOpenGL::texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, GCGLintptr pboOffset)
2243 {
2244     UNUSED_PARAM(target);
2245     UNUSED_PARAM(level);
2246     UNUSED_PARAM(xoffset);
2247     UNUSED_PARAM(yoffset);
2248     UNUSED_PARAM(zoffset);
2249     UNUSED_PARAM(width);
2250     UNUSED_PARAM(height);
2251     UNUSED_PARAM(depth);
2252     UNUSED_PARAM(format);
2253     UNUSED_PARAM(type);
2254     UNUSED_PARAM(pboOffset);
2255 }
2256 
2257 void GraphicsContextGLOpenGL::texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, const void* srcData, GCGLuint srcOffset)
2258 {
2259     UNUSED_PARAM(target);
2260     UNUSED_PARAM(level);
2261     UNUSED_PARAM(xoffset);
2262     UNUSED_PARAM(yoffset);
2263     UNUSED_PARAM(zoffset);
2264     UNUSED_PARAM(width);
2265     UNUSED_PARAM(height);
2266     UNUSED_PARAM(depth);
2267     UNUSED_PARAM(format);
2268     UNUSED_PARAM(type);
2269     UNUSED_PARAM(srcData);
2270     UNUSED_PARAM(srcOffset);
2271 }
2272 
2273 void GraphicsContextGLOpenGL::copyTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
2274 {
2275     UNUSED_PARAM(target);
2276     UNUSED_PARAM(level);
2277     UNUSED_PARAM(xoffset);
2278     UNUSED_PARAM(yoffset);
2279     UNUSED_PARAM(zoffset);
2280     UNUSED_PARAM(x);
2281     UNUSED_PARAM(y);
2282     UNUSED_PARAM(width);
2283     UNUSED_PARAM(height);
2284 }
2285 
2286 void GraphicsContextGLOpenGL::compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLsizei imageSize, GCGLintptr offset)
2287 {
2288     UNUSED_PARAM(target);
2289     UNUSED_PARAM(level);
2290     UNUSED_PARAM(internalformat);
2291     UNUSED_PARAM(width);
2292     UNUSED_PARAM(height);
2293     UNUSED_PARAM(depth);
2294     UNUSED_PARAM(border);
2295     UNUSED_PARAM(imageSize);
2296     UNUSED_PARAM(offset);
2297 }
2298 
2299 void GraphicsContextGLOpenGL::compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride)
2300 {
2301     UNUSED_PARAM(target);
2302     UNUSED_PARAM(level);
2303     UNUSED_PARAM(internalformat);
2304     UNUSED_PARAM(width);
2305     UNUSED_PARAM(height);
2306     UNUSED_PARAM(depth);
2307     UNUSED_PARAM(border);
2308     UNUSED_PARAM(srcData);
2309     UNUSED_PARAM(srcOffset);
2310     UNUSED_PARAM(srcLengthOverride);
2311 }
2312 
2313 void GraphicsContextGLOpenGL::compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLsizei imageSize, GCGLintptr offset)
2314 {
2315     UNUSED_PARAM(target);
2316     UNUSED_PARAM(level);
2317     UNUSED_PARAM(xoffset);
2318     UNUSED_PARAM(yoffset);
2319     UNUSED_PARAM(zoffset);
2320     UNUSED_PARAM(width);
2321     UNUSED_PARAM(height);
2322     UNUSED_PARAM(depth);
2323     UNUSED_PARAM(format);
2324     UNUSED_PARAM(imageSize);
2325     UNUSED_PARAM(offset);
2326 }
2327 
2328 void GraphicsContextGLOpenGL::compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride)
2329 {
2330     UNUSED_PARAM(target);
2331     UNUSED_PARAM(level);
2332     UNUSED_PARAM(xoffset);
2333     UNUSED_PARAM(yoffset);
2334     UNUSED_PARAM(zoffset);
2335     UNUSED_PARAM(width);
2336     UNUSED_PARAM(height);
2337     UNUSED_PARAM(depth);
2338     UNUSED_PARAM(format);
2339     UNUSED_PARAM(srcData);
2340     UNUSED_PARAM(srcOffset);
2341     UNUSED_PARAM(srcLengthOverride);
2342 }
2343 
2344 GCGLint GraphicsContextGLOpenGL::getFragDataLocation(PlatformGLObject program, const String&amp; name)
2345 {
2346     UNUSED_PARAM(program);
2347     UNUSED_PARAM(name);
2348 
2349     return 0;
2350 }
2351 
2352 void GraphicsContextGLOpenGL::uniform1ui(GCGLint location, GCGLuint v0)
2353 {
2354     UNUSED_PARAM(location);
2355     UNUSED_PARAM(v0);
2356 }
2357 
2358 void GraphicsContextGLOpenGL::uniform2ui(GCGLint location, GCGLuint v0, GCGLuint v1)
2359 {
2360     UNUSED_PARAM(location);
2361     UNUSED_PARAM(v0);
2362     UNUSED_PARAM(v1);
2363 }
2364 
2365 void GraphicsContextGLOpenGL::uniform3ui(GCGLint location, GCGLuint v0, GCGLuint v1, GCGLuint v2)
2366 {
2367     UNUSED_PARAM(location);
2368     UNUSED_PARAM(v0);
2369     UNUSED_PARAM(v1);
2370     UNUSED_PARAM(v2);
2371 }
2372 
2373 void GraphicsContextGLOpenGL::uniform4ui(GCGLint location, GCGLuint v0, GCGLuint v1, GCGLuint v2, GCGLuint v3)
2374 {
2375     UNUSED_PARAM(location);
2376     UNUSED_PARAM(v0);
2377     UNUSED_PARAM(v1);
2378     UNUSED_PARAM(v2);
2379     UNUSED_PARAM(v3);
2380 }
2381 
2382 void GraphicsContextGLOpenGL::uniform1uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength)
2383 {
2384     UNUSED_PARAM(location);
2385     UNUSED_PARAM(data);
2386     UNUSED_PARAM(srcOffset);
2387     UNUSED_PARAM(srcLength);
2388 }
2389 
2390 void GraphicsContextGLOpenGL::uniform2uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength)
2391 {
2392     UNUSED_PARAM(location);
2393     UNUSED_PARAM(data);
2394     UNUSED_PARAM(srcOffset);
2395     UNUSED_PARAM(srcLength);
2396 }
2397 
2398 void GraphicsContextGLOpenGL::uniform3uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength)
2399 {
2400     UNUSED_PARAM(location);
2401     UNUSED_PARAM(data);
2402     UNUSED_PARAM(srcOffset);
2403     UNUSED_PARAM(srcLength);
2404 }
2405 
2406 void GraphicsContextGLOpenGL::uniform4uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength)
2407 {
2408     UNUSED_PARAM(location);
2409     UNUSED_PARAM(data);
2410     UNUSED_PARAM(srcOffset);
2411     UNUSED_PARAM(srcLength);
2412 }
2413 
2414 void GraphicsContextGLOpenGL::uniformMatrix2x3fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2415 {
2416     UNUSED_PARAM(location);
2417     UNUSED_PARAM(transpose);
2418     UNUSED_PARAM(data);
2419     UNUSED_PARAM(srcOffset);
2420     UNUSED_PARAM(srcLength);
2421 }
2422 
2423 void GraphicsContextGLOpenGL::uniformMatrix3x2fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2424 {
2425     UNUSED_PARAM(location);
2426     UNUSED_PARAM(transpose);
2427     UNUSED_PARAM(data);
2428     UNUSED_PARAM(srcOffset);
2429     UNUSED_PARAM(srcLength);
2430 }
2431 
2432 void GraphicsContextGLOpenGL::uniformMatrix2x4fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2433 {
2434     UNUSED_PARAM(location);
2435     UNUSED_PARAM(transpose);
2436     UNUSED_PARAM(data);
2437     UNUSED_PARAM(srcOffset);
2438     UNUSED_PARAM(srcLength);
2439 }
2440 
2441 void GraphicsContextGLOpenGL::uniformMatrix4x2fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2442 {
2443     UNUSED_PARAM(location);
2444     UNUSED_PARAM(transpose);
2445     UNUSED_PARAM(data);
2446     UNUSED_PARAM(srcOffset);
2447     UNUSED_PARAM(srcLength);
2448 }
2449 
2450 void GraphicsContextGLOpenGL::uniformMatrix3x4fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2451 {
2452     UNUSED_PARAM(location);
2453     UNUSED_PARAM(transpose);
2454     UNUSED_PARAM(data);
2455     UNUSED_PARAM(srcOffset);
2456     UNUSED_PARAM(srcLength);
2457 }
2458 
2459 void GraphicsContextGLOpenGL::uniformMatrix4x3fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2460 {
2461     UNUSED_PARAM(location);
2462     UNUSED_PARAM(transpose);
2463     UNUSED_PARAM(data);
2464     UNUSED_PARAM(srcOffset);
2465     UNUSED_PARAM(srcLength);
2466 }
2467 
2468 void GraphicsContextGLOpenGL::vertexAttribI4i(GCGLuint index, GCGLint x, GCGLint y, GCGLint z, GCGLint w)
2469 {
2470     UNUSED_PARAM(index);
2471     UNUSED_PARAM(x);
2472     UNUSED_PARAM(y);
2473     UNUSED_PARAM(z);
2474     UNUSED_PARAM(w);
2475 }
2476 
2477 void GraphicsContextGLOpenGL::vertexAttribI4iv(GCGLuint index, const GCGLint* values)
2478 {
2479     UNUSED_PARAM(index);
2480     UNUSED_PARAM(values);
2481 }
2482 
2483 void GraphicsContextGLOpenGL::vertexAttribI4ui(GCGLuint index, GCGLuint x, GCGLuint y, GCGLuint z, GCGLuint w)
2484 {
2485     UNUSED_PARAM(index);
2486     UNUSED_PARAM(x);
2487     UNUSED_PARAM(y);
2488     UNUSED_PARAM(z);
2489     UNUSED_PARAM(w);
2490 }
2491 
2492 void GraphicsContextGLOpenGL::vertexAttribI4uiv(GCGLuint index, const GCGLuint* values)
2493 {
2494     UNUSED_PARAM(index);
2495     UNUSED_PARAM(values);
2496 }
2497 
2498 void GraphicsContextGLOpenGL::vertexAttribIPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLsizei stride, GCGLintptr offset)
2499 {
2500     UNUSED_PARAM(index);
2501     UNUSED_PARAM(size);
2502     UNUSED_PARAM(type);
2503     UNUSED_PARAM(stride);
2504     UNUSED_PARAM(offset);
2505 }
2506 
2507 void GraphicsContextGLOpenGL::drawRangeElements(GCGLenum mode, GCGLuint start, GCGLuint end, GCGLsizei count, GCGLenum type, GCGLintptr offset)
2508 {
2509     UNUSED_PARAM(mode);
2510     UNUSED_PARAM(start);
2511     UNUSED_PARAM(end);
2512     UNUSED_PARAM(count);
2513     UNUSED_PARAM(type);
2514     UNUSED_PARAM(offset);
2515 }
2516 
2517 void GraphicsContextGLOpenGL::drawBuffers(const Vector&lt;GCGLenum&gt;&amp; buffers)
2518 {
2519     UNUSED_PARAM(buffers);
2520 }
2521 
2522 void GraphicsContextGLOpenGL::clearBufferiv(GCGLenum buffer, GCGLint drawbuffer, const GCGLint* values, GCGLuint srcOffset)
2523 {
2524     UNUSED_PARAM(buffer);
2525     UNUSED_PARAM(drawbuffer);
2526     UNUSED_PARAM(values);
2527     UNUSED_PARAM(srcOffset);
2528 }
2529 
2530 void GraphicsContextGLOpenGL::clearBufferuiv(GCGLenum buffer, GCGLint drawbuffer, const GCGLuint* values, GCGLuint srcOffset)
2531 {
2532     UNUSED_PARAM(buffer);
2533     UNUSED_PARAM(drawbuffer);
2534     UNUSED_PARAM(values);
2535     UNUSED_PARAM(srcOffset);
2536 }
2537 
2538 void GraphicsContextGLOpenGL::clearBufferfv(GCGLenum buffer, GCGLint drawbuffer, const GCGLfloat* values, GCGLuint srcOffset)
2539 {
2540     UNUSED_PARAM(buffer);
2541     UNUSED_PARAM(drawbuffer);
2542     UNUSED_PARAM(values);
2543     UNUSED_PARAM(srcOffset);
2544 }
2545 
2546 void GraphicsContextGLOpenGL::clearBufferfi(GCGLenum buffer, GCGLint drawbuffer, GCGLfloat depth, GCGLint stencil)
2547 {
2548     UNUSED_PARAM(buffer);
2549     UNUSED_PARAM(drawbuffer);
2550     UNUSED_PARAM(depth);
2551     UNUSED_PARAM(stencil);
2552 }
2553 
2554 PlatformGLObject GraphicsContextGLOpenGL::createQuery()
2555 {
2556     return 0;
2557 }
2558 
2559 void GraphicsContextGLOpenGL::deleteQuery(PlatformGLObject query)
2560 {
2561     UNUSED_PARAM(query);
2562 }
2563 
2564 GCGLboolean GraphicsContextGLOpenGL::isQuery(PlatformGLObject query)
2565 {
2566     UNUSED_PARAM(query);
2567 
2568     return false;
2569 }
2570 
2571 void GraphicsContextGLOpenGL::beginQuery(GCGLenum target, PlatformGLObject query)
2572 {
2573     UNUSED_PARAM(target);
2574     UNUSED_PARAM(query);
2575 }
2576 
2577 void GraphicsContextGLOpenGL::endQuery(GCGLenum target)
2578 {
2579     UNUSED_PARAM(target);
2580 }
2581 
2582 PlatformGLObject GraphicsContextGLOpenGL::getQuery(GCGLenum target, GCGLenum pname)
2583 {
2584     UNUSED_PARAM(target);
2585     UNUSED_PARAM(pname);
2586 
2587     return 0;
2588 }
2589 
2590 void GraphicsContextGLOpenGL::getQueryObjectuiv(PlatformGLObject query, GCGLenum pname, GCGLuint* value)
2591 {
2592     UNUSED_PARAM(query);
2593     UNUSED_PARAM(pname);
2594     UNUSED_PARAM(value);
2595 }
2596 
2597 PlatformGLObject GraphicsContextGLOpenGL::createSampler()
2598 {
2599     return 0;
2600 }
2601 
2602 void GraphicsContextGLOpenGL::deleteSampler(PlatformGLObject sampler)
2603 {
2604     UNUSED_PARAM(sampler);
2605 }
2606 
2607 GCGLboolean GraphicsContextGLOpenGL::isSampler(PlatformGLObject sampler)
2608 {
2609     UNUSED_PARAM(sampler);
2610 
2611     return false;
2612 }
2613 
2614 void GraphicsContextGLOpenGL::bindSampler(GCGLuint unit, PlatformGLObject sampler)
2615 {
2616     UNUSED_PARAM(unit);
2617     UNUSED_PARAM(sampler);
2618 }
2619 
2620 void GraphicsContextGLOpenGL::samplerParameteri(PlatformGLObject sampler, GCGLenum pname, GCGLint param)
2621 {
2622     UNUSED_PARAM(sampler);
2623     UNUSED_PARAM(pname);
2624     UNUSED_PARAM(param);
2625 }
2626 
2627 void GraphicsContextGLOpenGL::samplerParameterf(PlatformGLObject sampler, GCGLenum pname, GCGLfloat param)
2628 {
2629     UNUSED_PARAM(sampler);
2630     UNUSED_PARAM(pname);
2631     UNUSED_PARAM(param);
2632 }
2633 
2634 void GraphicsContextGLOpenGL::getSamplerParameterfv(PlatformGLObject sampler, GCGLenum pname, GCGLfloat* value)
2635 {
2636     UNUSED_PARAM(sampler);
2637     UNUSED_PARAM(pname);
2638     UNUSED_PARAM(value);
2639 }
2640 
2641 void GraphicsContextGLOpenGL::getSamplerParameteriv(PlatformGLObject sampler, GCGLenum pname, GCGLint* value)
2642 {
2643     UNUSED_PARAM(sampler);
2644     UNUSED_PARAM(pname);
2645     UNUSED_PARAM(value);
2646 }
2647 
2648 PlatformGLObject GraphicsContextGLOpenGL::fenceSync(GCGLenum condition, GCGLbitfield flags)
2649 {
2650     UNUSED_PARAM(condition);
2651     UNUSED_PARAM(flags);
2652 
2653     return 0;
2654 }
2655 
2656 GCGLboolean GraphicsContextGLOpenGL::isSync(PlatformGLObject sync)
2657 {
2658     UNUSED_PARAM(sync);
2659 
2660     return false;
2661 }
2662 
2663 void GraphicsContextGLOpenGL::deleteSync(PlatformGLObject sync)
2664 {
2665     UNUSED_PARAM(sync);
2666 }
2667 
2668 GCGLenum GraphicsContextGLOpenGL::clientWaitSync(PlatformGLObject sync, GCGLbitfield flags, GCGLuint64 timeout)
2669 {
2670     UNUSED_PARAM(sync);
2671     UNUSED_PARAM(flags);
2672     UNUSED_PARAM(timeout);
2673 
2674     return 0;
2675 }
2676 
2677 void GraphicsContextGLOpenGL::waitSync(PlatformGLObject sync, GCGLbitfield flags, GCGLint64 timeout)
2678 {
2679     UNUSED_PARAM(sync);
2680     UNUSED_PARAM(flags);
2681     UNUSED_PARAM(timeout);
2682 }
2683 
2684 void GraphicsContextGLOpenGL::getSynciv(PlatformGLObject sync, GCGLenum pname, GCGLsizei bufSize, GCGLint *value)
2685 {
2686     UNUSED_PARAM(sync);
2687     UNUSED_PARAM(pname);
2688     UNUSED_PARAM(bufSize);
2689     UNUSED_PARAM(value);
2690 }
2691 
2692 PlatformGLObject GraphicsContextGLOpenGL::createTransformFeedback()
2693 {
2694     return 0;
2695 }
2696 
2697 void GraphicsContextGLOpenGL::deleteTransformFeedback(PlatformGLObject id)
2698 {
2699     UNUSED_PARAM(id);
2700 }
2701 
2702 GCGLboolean GraphicsContextGLOpenGL::isTransformFeedback(PlatformGLObject id)
2703 {
2704     UNUSED_PARAM(id);
2705 
2706     return false;
2707 }
2708 
2709 void GraphicsContextGLOpenGL::bindTransformFeedback(GCGLenum target, PlatformGLObject id)
2710 {
2711     UNUSED_PARAM(target);
2712     UNUSED_PARAM(id);
2713 }
2714 
2715 void GraphicsContextGLOpenGL::beginTransformFeedback(GCGLenum primitiveMode)
2716 {
2717     UNUSED_PARAM(primitiveMode);
2718 }
2719 
2720 void GraphicsContextGLOpenGL::endTransformFeedback()
2721 {
2722 }
2723 
2724 void GraphicsContextGLOpenGL::transformFeedbackVaryings(PlatformGLObject program, const Vector&lt;String&gt;&amp; varyings, GCGLenum bufferMode)
2725 {
2726     UNUSED_PARAM(program);
2727     UNUSED_PARAM(varyings);
2728     UNUSED_PARAM(bufferMode);
2729 }
2730 
2731 void GraphicsContextGLOpenGL::getTransformFeedbackVarying(PlatformGLObject program, GCGLuint index, ActiveInfo&amp;)
2732 {
2733     UNUSED_PARAM(program);
2734     UNUSED_PARAM(index);
2735 }
2736 
2737 void GraphicsContextGLOpenGL::pauseTransformFeedback()
2738 {
2739 }
2740 
2741 void GraphicsContextGLOpenGL::resumeTransformFeedback()
2742 {
2743 }
2744 
2745 void GraphicsContextGLOpenGL::bindBufferBase(GCGLenum target, GCGLuint index, PlatformGLObject buffer)
2746 {
2747     UNUSED_PARAM(target);
2748     UNUSED_PARAM(index);
2749     UNUSED_PARAM(buffer);
2750 }
2751 
2752 void GraphicsContextGLOpenGL::bindBufferRange(GCGLenum target, GCGLuint index, PlatformGLObject buffer, GCGLintptr offset, GCGLsizeiptr size)
2753 {
2754     UNUSED_PARAM(target);
2755     UNUSED_PARAM(index);
2756     UNUSED_PARAM(buffer);
2757     UNUSED_PARAM(offset);
2758     UNUSED_PARAM(size);
2759 }
2760 
2761 Vector&lt;GCGLuint&gt; GraphicsContextGLOpenGL::getUniformIndices(PlatformGLObject program, const Vector&lt;String&gt;&amp; uniformNames)
2762 {
2763     UNUSED_PARAM(program);
2764     UNUSED_PARAM(uniformNames);
2765 
2766     return { };
2767 }
2768 
2769 #if HAVE(OPENGL_4) || HAVE(OPENGL_ES_3)
2770 void GraphicsContextGLOpenGL::getActiveUniforms(PlatformGLObject program, const Vector&lt;GCGLuint&gt;&amp; uniformIndices, GCGLenum pname, Vector&lt;GCGLint&gt;&amp; params)
2771 {
2772     ASSERT(program);
2773     makeContextCurrent();
2774 
2775     ::glGetActiveUniformsiv(program, uniformIndices.size(), uniformIndices.data(), pname, params.data());
2776 }
2777 
2778 GCGLuint GraphicsContextGLOpenGL::getUniformBlockIndex(PlatformGLObject program, const String&amp; uniformBlockName)
2779 {
2780     UNUSED_PARAM(program);
2781     UNUSED_PARAM(uniformBlockName);
2782 
2783     return 0;
2784 }
2785 
2786 void GraphicsContextGLOpenGL::getActiveUniformBlockiv(PlatformGLObject program, GCGLuint uniformBlockIndex, GCGLenum pname, GCGLint* params)
2787 {
2788     UNUSED_PARAM(program);
2789     UNUSED_PARAM(uniformBlockIndex);
2790     UNUSED_PARAM(pname);
2791     UNUSED_PARAM(params);
2792 }
2793 
2794 String GraphicsContextGLOpenGL::getActiveUniformBlockName(PlatformGLObject program, GCGLuint uniformBlockIndex)
2795 {
2796     UNUSED_PARAM(program);
2797     UNUSED_PARAM(uniformBlockIndex);
2798 
2799     return emptyString();
2800 }
2801 
2802 void GraphicsContextGLOpenGL::uniformBlockBinding(PlatformGLObject program, GCGLuint uniformBlockIndex, GCGLuint uniformBlockBinding)
2803 {
2804     UNUSED_PARAM(program);
2805     UNUSED_PARAM(uniformBlockIndex);
2806     UNUSED_PARAM(uniformBlockBinding);
2807 }
2808 #elif !USE(ANGLE)
2809 void GraphicsContextGLOpenGL::getActiveUniforms(PlatformGLObject, const Vector&lt;GCGLuint&gt;&amp;, GCGLenum, Vector&lt;GCGLint&gt;&amp;)
2810 {
2811 }
2812 
2813 GCGLuint GraphicsContextGLOpenGL::getUniformBlockIndex(PlatformGLObject, const String&amp;)
2814 {
2815     return 0;
2816 }
2817 
2818 void GraphicsContextGLOpenGL::getActiveUniformBlockiv(PlatformGLObject, GCGLuint, GCGLenum, GCGLint*)
2819 {
2820 }
2821 
2822 String GraphicsContextGLOpenGL::getActiveUniformBlockName(PlatformGLObject, GCGLuint)
2823 {
2824     return emptyString();
2825 }
2826 
2827 void GraphicsContextGLOpenGL::uniformBlockBinding(PlatformGLObject, GCGLuint, GCGLuint)
2828 {
2829 }
2830 #endif
2831 
2832 void GraphicsContextGLOpenGL::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, GCGLintptr pboOffset)
2833 {
2834     UNUSED_PARAM(target);
2835     UNUSED_PARAM(level);
2836     UNUSED_PARAM(xoffset);
2837     UNUSED_PARAM(yoffset);
2838     UNUSED_PARAM(width);
2839     UNUSED_PARAM(height);
2840     UNUSED_PARAM(format);
2841     UNUSED_PARAM(type);
2842     UNUSED_PARAM(pboOffset);
2843 }
2844 
2845 void GraphicsContextGLOpenGL::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, const void* srcData, GCGLuint srcOffset)
2846 {
2847     UNUSED_PARAM(target);
2848     UNUSED_PARAM(level);
2849     UNUSED_PARAM(xoffset);
2850     UNUSED_PARAM(yoffset);
2851     UNUSED_PARAM(width);
2852     UNUSED_PARAM(height);
2853     UNUSED_PARAM(format);
2854     UNUSED_PARAM(type);
2855     UNUSED_PARAM(srcData);
2856     UNUSED_PARAM(srcOffset);
2857 }
2858 
2859 void GraphicsContextGLOpenGL::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, GCGLintptr offset)
2860 {
2861     UNUSED_PARAM(target);
2862     UNUSED_PARAM(level);
2863     UNUSED_PARAM(internalformat);
2864     UNUSED_PARAM(width);
2865     UNUSED_PARAM(height);
2866     UNUSED_PARAM(border);
2867     UNUSED_PARAM(imageSize);
2868     UNUSED_PARAM(offset);
2869 }
2870 
2871 void GraphicsContextGLOpenGL::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride)
2872 {
2873     UNUSED_PARAM(target);
2874     UNUSED_PARAM(level);
2875     UNUSED_PARAM(internalformat);
2876     UNUSED_PARAM(width);
2877     UNUSED_PARAM(height);
2878     UNUSED_PARAM(border);
2879     UNUSED_PARAM(srcData);
2880     UNUSED_PARAM(srcOffset);
2881     UNUSED_PARAM(srcLengthOverride);
2882 }
2883 
2884 void GraphicsContextGLOpenGL::compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLsizei imageSize, GCGLintptr offset)
2885 {
2886     UNUSED_PARAM(target);
2887     UNUSED_PARAM(level);
2888     UNUSED_PARAM(xoffset);
2889     UNUSED_PARAM(yoffset);
2890     UNUSED_PARAM(width);
2891     UNUSED_PARAM(height);
2892     UNUSED_PARAM(format);
2893     UNUSED_PARAM(imageSize);
2894     UNUSED_PARAM(offset);
2895 }
2896 
2897 void GraphicsContextGLOpenGL::compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride)
2898 {
2899     UNUSED_PARAM(target);
2900     UNUSED_PARAM(level);
2901     UNUSED_PARAM(xoffset);
2902     UNUSED_PARAM(yoffset);
2903     UNUSED_PARAM(width);
2904     UNUSED_PARAM(height);
2905     UNUSED_PARAM(format);
2906     UNUSED_PARAM(srcData);
2907     UNUSED_PARAM(srcOffset);
2908     UNUSED_PARAM(srcLengthOverride);
2909 }
2910 
2911 void GraphicsContextGLOpenGL::uniform1fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2912 {
2913     UNUSED_PARAM(location);
2914     UNUSED_PARAM(data);
2915     UNUSED_PARAM(srcOffset);
2916     UNUSED_PARAM(srcLength);
2917 }
2918 
2919 void GraphicsContextGLOpenGL::uniform2fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2920 {
2921     UNUSED_PARAM(location);
2922     UNUSED_PARAM(data);
2923     UNUSED_PARAM(srcOffset);
2924     UNUSED_PARAM(srcLength);
2925 }
2926 
2927 void GraphicsContextGLOpenGL::uniform3fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2928 {
2929     UNUSED_PARAM(location);
2930     UNUSED_PARAM(data);
2931     UNUSED_PARAM(srcOffset);
2932     UNUSED_PARAM(srcLength);
2933 }
2934 
2935 void GraphicsContextGLOpenGL::uniform4fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2936 {
2937     UNUSED_PARAM(location);
2938     UNUSED_PARAM(data);
2939     UNUSED_PARAM(srcOffset);
2940     UNUSED_PARAM(srcLength);
2941 }
2942 
2943 void GraphicsContextGLOpenGL::uniform1iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength)
2944 {
2945     UNUSED_PARAM(location);
2946     UNUSED_PARAM(data);
2947     UNUSED_PARAM(srcOffset);
2948     UNUSED_PARAM(srcLength);
2949 }
2950 
2951 void GraphicsContextGLOpenGL::uniform2iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength)
2952 {
2953     UNUSED_PARAM(location);
2954     UNUSED_PARAM(data);
2955     UNUSED_PARAM(srcOffset);
2956     UNUSED_PARAM(srcLength);
2957 }
2958 
2959 void GraphicsContextGLOpenGL::uniform3iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength)
2960 {
2961     UNUSED_PARAM(location);
2962     UNUSED_PARAM(data);
2963     UNUSED_PARAM(srcOffset);
2964     UNUSED_PARAM(srcLength);
2965 }
2966 
2967 void GraphicsContextGLOpenGL::uniform4iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength)
2968 {
2969     UNUSED_PARAM(location);
2970     UNUSED_PARAM(data);
2971     UNUSED_PARAM(srcOffset);
2972     UNUSED_PARAM(srcLength);
2973 }
2974 
2975 void GraphicsContextGLOpenGL::uniformMatrix2fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2976 {
2977     UNUSED_PARAM(location);
2978     UNUSED_PARAM(transpose);
2979     UNUSED_PARAM(data);
2980     UNUSED_PARAM(srcOffset);
2981     UNUSED_PARAM(srcLength);
2982 }
2983 
2984 void GraphicsContextGLOpenGL::uniformMatrix3fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2985 {
2986     UNUSED_PARAM(location);
2987     UNUSED_PARAM(transpose);
2988     UNUSED_PARAM(data);
2989     UNUSED_PARAM(srcOffset);
2990     UNUSED_PARAM(srcLength);
2991 }
2992 
2993 void GraphicsContextGLOpenGL::uniformMatrix4fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2994 {
2995     UNUSED_PARAM(location);
2996     UNUSED_PARAM(transpose);
2997     UNUSED_PARAM(data);
2998     UNUSED_PARAM(srcOffset);
2999     UNUSED_PARAM(srcLength);
3000 }
3001 
3002 void GraphicsContextGLOpenGL::readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, GCGLintptr offset)
3003 {
3004     UNUSED_PARAM(x);
3005     UNUSED_PARAM(y);
3006     UNUSED_PARAM(width);
3007     UNUSED_PARAM(height);
3008     UNUSED_PARAM(format);
3009     UNUSED_PARAM(type);
3010     UNUSED_PARAM(offset);
3011 }
3012 
3013 void GraphicsContextGLOpenGL::readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, const void* dstData, GCGLuint dstOffset)
3014 {
3015     UNUSED_PARAM(x);
3016     UNUSED_PARAM(y);
3017     UNUSED_PARAM(width);
3018     UNUSED_PARAM(height);
3019     UNUSED_PARAM(format);
3020     UNUSED_PARAM(type);
3021     UNUSED_PARAM(dstData);
3022     UNUSED_PARAM(dstOffset);
3023 }
3024 
3025 
3026 }
3027 
3028 #endif // ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; (USE(OPENGL) || USE(OPENGL_ES))
    </pre>
  </body>
</html>
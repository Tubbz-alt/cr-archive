diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/webauthn/AuthenticatorCoordinator.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/webauthn/AuthenticatorCoordinator.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/webauthn/AuthenticatorCoordinator.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/webauthn/AuthenticatorCoordinator.cpp
@@ -30,33 +30,31 @@
 
 #include "AbortSignal.h"
 #include "AuthenticatorAssertionResponse.h"
 #include "AuthenticatorAttestationResponse.h"
 #include "AuthenticatorCoordinatorClient.h"
+#include "AuthenticatorResponseData.h"
+#include "Document.h"
 #include "JSBasicCredential.h"
+#include "JSDOMPromiseDeferred.h"
 #include "PublicKeyCredential.h"
 #include "PublicKeyCredentialCreationOptions.h"
-#include "PublicKeyCredentialData.h"
 #include "PublicKeyCredentialRequestOptions.h"
 #include "RegistrableDomain.h"
-#include "SchemeRegistry.h"
+#include "LegacySchemeRegistry.h"
 #include "SecurityOrigin.h"
+#include "WebAuthenticationConstants.h"
 #include <pal/crypto/CryptoDigest.h>
 #include <wtf/JSONValues.h>
 #include <wtf/NeverDestroyed.h>
 #include <wtf/text/Base64.h>
 
 namespace WebCore {
 
 namespace AuthenticatorCoordinatorInternal {
 
-enum class ClientDataType {
-    Create,
-    Get
-};
-
-// FIXME(181948): Add token binding ID and extensions.
+// FIXME(181948): Add token binding ID.
 static Ref<ArrayBuffer> produceClientDataJson(ClientDataType type, const BufferSource& challenge, const SecurityOrigin& origin)
 {
     auto object = JSON::Object::create();
     switch (type) {
     case ClientDataType::Create:
@@ -97,11 +95,11 @@
 // https://bugzilla.mozilla.org/show_bug.cgi?id=1244959#c8
 // https://bugs.chromium.org/p/chromium/issues/detail?id=818303
 static String processAppIdExtension(const SecurityOrigin& facetId, const String& appId)
 {
     // Step 1. Skipped since facetId should always be secure origins.
-    ASSERT(SchemeRegistry::shouldTreatURLSchemeAsSecure(facetId.protocol()));
+    ASSERT(LegacySchemeRegistry::shouldTreatURLSchemeAsSecure(facetId.protocol()));
 
     // Step 2. Follow Chrome and Firefox to use the origin directly without adding a trailing slash.
     if (appId.isEmpty())
         return facetId.toString();
 
@@ -110,10 +108,20 @@
     if (!appIdURL.isValid() || facetId.protocol() != appIdURL.protocol() || (RegistrableDomain(appIdURL) != RegistrableDomain::uncheckedCreateFromHost(facetId.host()) && !needsAppIdQuirks(facetId.host(), appId)))
         return String();
     return appId;
 }
 
+// The default behaviour for google.com is to always turn on the legacy AppID support.
+static bool processGoogleLegacyAppIdSupportExtension(const Optional<AuthenticationExtensionsClientInputs>& extensions, const String& rpId)
+{
+    if (rpId != "google.com"_s)
+        return false;
+    if (!extensions)
+        return true;
+    return extensions->googleLegacyAppidSupport;
+}
+
 } // namespace AuthenticatorCoordinatorInternal
 
 AuthenticatorCoordinator::AuthenticatorCoordinator(std::unique_ptr<AuthenticatorCoordinatorClient>&& client)
     : m_client(WTFMove(client))
 {
@@ -122,16 +130,18 @@
 void AuthenticatorCoordinator::setClient(std::unique_ptr<AuthenticatorCoordinatorClient>&& client)
 {
     m_client = WTFMove(client);
 }
 
-void AuthenticatorCoordinator::create(const SecurityOrigin& callerOrigin, const PublicKeyCredentialCreationOptions& options, bool sameOriginWithAncestors, RefPtr<AbortSignal>&& abortSignal, CredentialPromise&& promise) const
+void AuthenticatorCoordinator::create(const Document& document, const PublicKeyCredentialCreationOptions& options, bool sameOriginWithAncestors, RefPtr<AbortSignal>&& abortSignal, CredentialPromise&& promise) const
 {
     using namespace AuthenticatorCoordinatorInternal;
 
+    const auto& callerOrigin = document.securityOrigin();
+    auto* frame = document.frame();
+    ASSERT(frame);
     // The following implements https://www.w3.org/TR/webauthn/#createCredential as of 5 December 2017.
-    // Extensions are not supported. Skip Step 11-12.
     // Step 1, 3, 16 are handled by the caller.
     // Step 2.
     if (!sameOriginWithAncestors) {
         promise.reject(Exception { NotAllowedError, "The origin of the document is not the same as its ancestors."_s });
         return;
@@ -159,42 +169,49 @@
     if (options.pubKeyCredParams.isEmpty()) {
         promise.reject(Exception { NotSupportedError, "No desired properties of the to be created credential are provided."_s });
         return;
     }
 
+    // Step 11-12.
+    // Only Google Legacy AppID Support Extension is supported.
+    options.extensions = AuthenticationExtensionsClientInputs { String(), processGoogleLegacyAppIdSupportExtension(options.extensions, options.rp.id) };
+
     // Step 13-15.
     auto clientDataJson = produceClientDataJson(ClientDataType::Create, options.challenge, callerOrigin);
     auto clientDataJsonHash = produceClientDataJsonHash(clientDataJson);
 
     // Step 4, 17-21.
     if (!m_client) {
         promise.reject(Exception { UnknownError, "Unknown internal error."_s });
         return;
     }
 
-    auto completionHandler = [clientDataJson = WTFMove(clientDataJson), promise = WTFMove(promise), abortSignal = WTFMove(abortSignal)] (const WebCore::PublicKeyCredentialData& data, const WebCore::ExceptionData& exception) mutable {
+    auto callback = [clientDataJson = WTFMove(clientDataJson), promise = WTFMove(promise), abortSignal = WTFMove(abortSignal)] (AuthenticatorResponseData&& data, ExceptionData&& exception) mutable {
         if (abortSignal && abortSignal->aborted()) {
             promise.reject(Exception { AbortError, "Aborted by AbortSignal."_s });
             return;
         }
 
-        data.clientDataJSON = WTFMove(clientDataJson);
-        if (auto publicKeyCredential = PublicKeyCredential::tryCreate(data)) {
-            promise.resolve(publicKeyCredential.get());
+        if (auto response = AuthenticatorResponse::tryCreate(WTFMove(data))) {
+            response->setClientDataJSON(WTFMove(clientDataJson));
+            promise.resolve(PublicKeyCredential::create(response.releaseNonNull()).ptr());
             return;
         }
         ASSERT(!exception.message.isNull());
         promise.reject(exception.toException());
     };
     // Async operations are dispatched and handled in the messenger.
-    m_client->makeCredential(clientDataJsonHash, options, WTFMove(completionHandler));
+    m_client->makeCredential(*frame, callerOrigin, clientDataJsonHash, options, WTFMove(callback));
 }
 
-void AuthenticatorCoordinator::discoverFromExternalSource(const SecurityOrigin& callerOrigin, const PublicKeyCredentialRequestOptions& options, bool sameOriginWithAncestors, RefPtr<AbortSignal>&& abortSignal, CredentialPromise&& promise) const
+void AuthenticatorCoordinator::discoverFromExternalSource(const Document& document, const PublicKeyCredentialRequestOptions& options, bool sameOriginWithAncestors, RefPtr<AbortSignal>&& abortSignal, CredentialPromise&& promise) const
 {
     using namespace AuthenticatorCoordinatorInternal;
 
+    auto& callerOrigin = document.securityOrigin();
+    auto* frame = document.frame();
+    ASSERT(frame);
     // The following implements https://www.w3.org/TR/webauthn/#createCredential as of 5 December 2017.
     // Step 1, 3, 13 are handled by the caller.
     // Step 2.
     if (!sameOriginWithAncestors) {
         promise.reject(Exception { NotAllowedError, "The origin of the document is not the same as its ancestors."_s });
@@ -237,26 +254,26 @@
     if (!m_client) {
         promise.reject(Exception { UnknownError, "Unknown internal error."_s });
         return;
     }
 
-    auto completionHandler = [clientDataJson = WTFMove(clientDataJson), promise = WTFMove(promise), abortSignal = WTFMove(abortSignal)] (const WebCore::PublicKeyCredentialData& data, const WebCore::ExceptionData& exception) mutable {
+    auto callback = [clientDataJson = WTFMove(clientDataJson), promise = WTFMove(promise), abortSignal = WTFMove(abortSignal)] (AuthenticatorResponseData&& data, ExceptionData&& exception) mutable {
         if (abortSignal && abortSignal->aborted()) {
             promise.reject(Exception { AbortError, "Aborted by AbortSignal."_s });
             return;
         }
 
-        data.clientDataJSON = WTFMove(clientDataJson);
-        if (auto publicKeyCredential = PublicKeyCredential::tryCreate(data)) {
-            promise.resolve(publicKeyCredential.get());
+        if (auto response = AuthenticatorResponse::tryCreate(WTFMove(data))) {
+            response->setClientDataJSON(WTFMove(clientDataJson));
+            promise.resolve(PublicKeyCredential::create(response.releaseNonNull()).ptr());
             return;
         }
         ASSERT(!exception.message.isNull());
         promise.reject(exception.toException());
     };
     // Async operations are dispatched and handled in the messenger.
-    m_client->getAssertion(clientDataJsonHash, options, WTFMove(completionHandler));
+    m_client->getAssertion(*frame, callerOrigin, clientDataJsonHash, options, WTFMove(callback));
 }
 
 void AuthenticatorCoordinator::isUserVerifyingPlatformAuthenticatorAvailable(DOMPromiseDeferred<IDLBoolean>&& promise) const
 {
     // The following implements https://www.w3.org/TR/webauthn/#isUserVerifyingPlatformAuthenticatorAvailable

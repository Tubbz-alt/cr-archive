<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MIMETypeCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MIMETypeCache.h&quot;
 28 
 29 #include &quot;ContentType.h&quot;
 30 
 31 namespace WebCore {
 32 
 33 HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; MIMETypeCache::supportedTypes()
 34 {
 35     if (!m_supportedTypes) {
 36         m_supportedTypes = HashSet&lt;String, ASCIICaseInsensitiveHash&gt; { };
 37         initializeCache(*m_supportedTypes);
 38     }
 39 
 40     return *m_supportedTypes;
 41 }
 42 
 43 bool MIMETypeCache::supportsContainerType(const String&amp; containerType)
 44 {
 45     if (!isAvailable() || containerType.isEmpty())
 46         return false;
 47 
 48     if (isUnsupportedContainerType(containerType))
 49         return false;
 50 
 51     if (staticContainerTypeList().contains(containerType))
 52         return true;
 53 
 54     return supportedTypes().contains(containerType);
 55 }
 56 
 57 MediaPlayerEnums::SupportsType MIMETypeCache::canDecodeType(const String&amp; mimeType)
 58 {
 59     if (mimeType.isEmpty())
 60         return MediaPlayerEnums::SupportsType::IsNotSupported;
 61 
 62     if (m_cachedResults) {
 63         auto it = m_cachedResults-&gt;find(mimeType);
 64         if (it != m_cachedResults-&gt;end())
 65             return it-&gt;value;
 66     }
 67 
 68     auto result = MediaPlayerEnums::SupportsType::IsNotSupported;
 69     do {
 70         if (!isAvailable() || mimeType.isEmpty())
 71             break;
 72 
 73         auto contentType = ContentType { mimeType };
 74         auto containerType = contentType.containerType();
 75         if (!supportsContainerType(containerType))
 76             break;
 77 
 78         result = MediaPlayerEnums::SupportsType::MayBeSupported;
 79         if (contentType.codecs().isEmpty())
 80             break;
 81 
 82         if (canDecodeExtendedType(contentType))
 83             result = MediaPlayerEnums::SupportsType::IsSupported;
 84     } while (0);
 85 
 86     if (!m_cachedResults)
 87         m_cachedResults = HashMap&lt;String, MediaPlayerEnums::SupportsType, ASCIICaseInsensitiveHash&gt;();
 88     m_cachedResults-&gt;add(mimeType, result);
 89 
 90     return result;
 91 }
 92 
 93 void MIMETypeCache::addSupportedTypes(const Vector&lt;String&gt;&amp; newTypes)
 94 {
 95     if (!m_supportedTypes)
 96         m_supportedTypes = HashSet&lt;String, ASCIICaseInsensitiveHash&gt; { };
 97 
 98     for (auto&amp; type : newTypes)
 99         m_supportedTypes-&gt;add(type);
100 }
101 
102 const HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; MIMETypeCache::staticContainerTypeList()
103 {
104     static const auto cache = makeNeverDestroyed(HashSet&lt;String, ASCIICaseInsensitiveHash&gt; { });
105     return cache;
106 }
107 
108 bool MIMETypeCache::isUnsupportedContainerType(const String&amp;)
109 {
110     return false;
111 }
112 
113 bool MIMETypeCache::isAvailable() const
114 {
115     return true;
116 }
117 
118 bool MIMETypeCache::isEmpty() const
119 {
120     return m_supportedTypes &amp;&amp; m_supportedTypes-&gt;isEmpty();
121 }
122 
123 void MIMETypeCache::initializeCache(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp;)
124 {
125 }
126 
127 bool MIMETypeCache::canDecodeExtendedType(const ContentType&amp;)
128 {
129     return false;
130 }
131 
132 }
    </pre>
  </body>
</html>
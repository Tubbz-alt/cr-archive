<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFlexibleBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions are
  6  * met:
  7  *
  8  *     * Redistributions of source code must retain the above copyright
  9  * notice, this list of conditions and the following disclaimer.
 10  *     * Redistributions in binary form must reproduce the above
 11  * copyright notice, this list of conditions and the following disclaimer
 12  * in the documentation and/or other materials provided with the
 13  * distribution.
 14  *     * Neither the name of Google Inc. nor the names of its
 15  * contributors may be used to endorse or promote products derived from
 16  * this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #pragma once
 32 
 33 #include &quot;OrderIterator.h&quot;
 34 #include &quot;RenderBlock.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 class FlexItem;
 39 
 40 class RenderFlexibleBox : public RenderBlock {
 41     WTF_MAKE_ISO_ALLOCATED(RenderFlexibleBox);
 42 public:
 43     RenderFlexibleBox(Element&amp;, RenderStyle&amp;&amp;);
 44     RenderFlexibleBox(Document&amp;, RenderStyle&amp;&amp;);
 45     virtual ~RenderFlexibleBox();
 46 
 47     bool isFlexibleBox() const override { return true; }
 48 
 49     const char* renderName() const override;
 50 
 51     bool avoidsFloats() const final { return true; }
 52     bool canDropAnonymousBlockChild() const final { return false; }
 53     void layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight = 0_lu) final;
 54 
 55     int baselinePosition(FontBaseline, bool firstLine, LineDirectionMode, LinePositionMode = PositionOnContainingLine) const override;
 56     Optional&lt;int&gt; firstLineBaseline() const override;
 57     Optional&lt;int&gt; inlineBlockBaseline(LineDirectionMode) const override;
 58 
 59     void styleDidChange(StyleDifference, const RenderStyle*) override;
 60     void paintChildren(PaintInfo&amp; forSelf, const LayoutPoint&amp;, PaintInfo&amp; forChild, bool usePrintRect) override;
 61 
 62     bool isHorizontalFlow() const;
 63 
 64     const OrderIterator&amp; orderIterator() const { return m_orderIterator; }
 65 
 66     bool isTopLayoutOverflowAllowed() const override;
 67     bool isLeftLayoutOverflowAllowed() const override;
 68 
 69     virtual bool isFlexibleBoxImpl() const { return false; };
 70 
 71     Optional&lt;LayoutUnit&gt; crossSizeForPercentageResolution(const RenderBox&amp;);
 72     Optional&lt;LayoutUnit&gt; mainSizeForPercentageResolution(const RenderBox&amp;);
 73     Optional&lt;LayoutUnit&gt; childLogicalHeightForPercentageResolution(const RenderBox&amp;);
 74 
 75     void clearCachedMainSizeForChild(const RenderBox&amp; child);
 76 
 77     LayoutUnit cachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child) const;
 78     void setCachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child, LayoutUnit);
 79     void clearCachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child);
 80 
 81     LayoutUnit staticMainAxisPositionForPositionedChild(const RenderBox&amp;);
 82     LayoutUnit staticCrossAxisPositionForPositionedChild(const RenderBox&amp;);
 83 
 84     LayoutUnit staticInlinePositionForPositionedChild(const RenderBox&amp;);
 85     LayoutUnit staticBlockPositionForPositionedChild(const RenderBox&amp;);
 86 
 87     // Returns true if the position changed. In that case, the child will have to
 88     // be laid out again.
 89     bool setStaticPositionForPositionedLayout(const RenderBox&amp;);
 90 
 91 protected:
 92     void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const override;
 93     void computePreferredLogicalWidths() override;
 94 
 95     bool shouldResetChildLogicalHeightBeforeLayout(const RenderBox&amp;) const override { return m_shouldResetChildLogicalHeightBeforeLayout; }
 96 
 97 private:
 98     enum FlexSign {
 99         PositiveFlexibility,
100         NegativeFlexibility,
101     };
102 
103     enum ChildLayoutType { LayoutIfNeeded, ForceLayout, NeverLayout };
104 
105     enum class SizeDefiniteness { Definite, Indefinite, Unknown };
106 
107     // Use an inline capacity of 8, since flexbox containers usually have less than 8 children.
108     typedef Vector&lt;LayoutRect, 8&gt; ChildFrameRects;
109 
110     struct LineContext;
111 
112     bool hasOrthogonalFlow(const RenderBox&amp; child) const;
113     bool isColumnFlow() const;
114     bool isLeftToRightFlow() const;
115     bool isMultiline() const;
116     Length flexBasisForChild(const RenderBox&amp; child) const;
117     LayoutUnit crossAxisExtentForChild(const RenderBox&amp; child) const;
118     LayoutUnit crossAxisIntrinsicExtentForChild(const RenderBox&amp; child) const;
119     LayoutUnit childIntrinsicLogicalHeight(const RenderBox&amp; child) const;
120     LayoutUnit childIntrinsicLogicalWidth(const RenderBox&amp; child) const;
121     LayoutUnit mainAxisExtentForChild(const RenderBox&amp; child) const;
122     LayoutUnit mainAxisContentExtentForChildIncludingScrollbar(const RenderBox&amp; child) const;
123     LayoutUnit crossAxisExtent() const;
124     LayoutUnit mainAxisExtent() const;
125     LayoutUnit crossAxisContentExtent() const;
126     LayoutUnit mainAxisContentExtent(LayoutUnit contentLogicalHeight);
127     Optional&lt;LayoutUnit&gt; computeMainAxisExtentForChild(const RenderBox&amp; child, SizeType, const Length&amp; size);
128     WritingMode transformedWritingMode() const;
129     LayoutUnit flowAwareBorderStart() const;
130     LayoutUnit flowAwareBorderEnd() const;
131     LayoutUnit flowAwareBorderBefore() const;
132     LayoutUnit flowAwareBorderAfter() const;
133     LayoutUnit flowAwarePaddingStart() const;
134     LayoutUnit flowAwarePaddingEnd() const;
135     LayoutUnit flowAwarePaddingBefore() const;
136     LayoutUnit flowAwarePaddingAfter() const;
137     LayoutUnit flowAwareMarginStartForChild(const RenderBox&amp; child) const;
138     LayoutUnit flowAwareMarginEndForChild(const RenderBox&amp; child) const;
139     LayoutUnit flowAwareMarginBeforeForChild(const RenderBox&amp; child) const;
140     LayoutUnit crossAxisMarginExtentForChild(const RenderBox&amp; child) const;
141     LayoutUnit crossAxisScrollbarExtent() const;
142     LayoutUnit crossAxisScrollbarExtentForChild(const RenderBox&amp; child) const;
143     LayoutPoint flowAwareLocationForChild(const RenderBox&amp; child) const;
144     bool useChildAspectRatio(const RenderBox&amp; child) const;
145     LayoutUnit computeMainSizeFromAspectRatioUsing(const RenderBox&amp; child, Length crossSizeLength) const;
146     void setFlowAwareLocationForChild(RenderBox&amp; child, const LayoutPoint&amp;);
147     LayoutUnit computeInnerFlexBaseSizeForChild(RenderBox&amp; child, LayoutUnit mainAxisBorderAndPadding, bool relayoutChildren);
148     void adjustAlignmentForChild(RenderBox&amp; child, LayoutUnit);
149     ItemPosition alignmentForChild(const RenderBox&amp; child) const;
150     bool mainAxisLengthIsDefinite(const RenderBox&amp; child, const Length&amp; flexBasis) const;
151     bool crossAxisLengthIsDefinite(const RenderBox&amp; child, const Length&amp; flexBasis) const;
152     bool needToStretchChildLogicalHeight(const RenderBox&amp; child) const;
153     bool childHasIntrinsicMainAxisSize(const RenderBox&amp; child) const;
154     Overflow mainAxisOverflowForChild(const RenderBox&amp; child) const;
155     Overflow crossAxisOverflowForChild(const RenderBox&amp; child) const;
156     void cacheChildMainSize(const RenderBox&amp; child);
157 
158     void layoutFlexItems(bool relayoutChildren);
159     LayoutUnit autoMarginOffsetInMainAxis(const Vector&lt;FlexItem&gt;&amp;, LayoutUnit&amp; availableFreeSpace);
160     void updateAutoMarginsInMainAxis(RenderBox&amp; child, LayoutUnit autoMarginOffset);
161     bool hasAutoMarginsInCrossAxis(const RenderBox&amp; child) const;
162     bool updateAutoMarginsInCrossAxis(RenderBox&amp; child, LayoutUnit availableAlignmentSpace);
163     void repositionLogicalHeightDependentFlexItems(Vector&lt;LineContext&gt;&amp;);
164     LayoutUnit clientLogicalBottomAfterRepositioning();
165 
166     LayoutUnit availableAlignmentSpaceForChild(LayoutUnit lineCrossAxisExtent, const RenderBox&amp; child);
167     LayoutUnit marginBoxAscentForChild(const RenderBox&amp; child);
168 
169     LayoutUnit computeChildMarginValue(Length margin);
170     void prepareOrderIteratorAndMargins();
171     LayoutUnit adjustChildSizeForMinAndMax(const RenderBox&amp; child, LayoutUnit childSize);
172     LayoutUnit adjustChildSizeForAspectRatioCrossAxisMinAndMax(const RenderBox&amp; child, LayoutUnit childSize);
173     FlexItem constructFlexItem(RenderBox&amp;, bool relayoutChildren);
174 
175     void freezeInflexibleItems(FlexSign, Vector&lt;FlexItem&gt;&amp; children, LayoutUnit&amp; remainingFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink);
176     bool resolveFlexibleLengths(FlexSign, Vector&lt;FlexItem&gt;&amp;, LayoutUnit initialFreeSpace, LayoutUnit&amp; remainingFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink);
177     void freezeViolations(Vector&lt;FlexItem*&gt;&amp;, LayoutUnit&amp; availableFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink);
178 
179     void resetAutoMarginsAndLogicalTopInCrossAxis(RenderBox&amp; child);
180     void setOverrideMainAxisContentSizeForChild(RenderBox&amp; child, LayoutUnit childPreferredSize);
181     void prepareChildForPositionedLayout(RenderBox&amp; child);
182     void layoutAndPlaceChildren(LayoutUnit&amp; crossAxisOffset, Vector&lt;FlexItem&gt;&amp;, LayoutUnit availableFreeSpace, bool relayoutChildren, Vector&lt;LineContext&gt;&amp;);
183     void layoutColumnReverse(const Vector&lt;FlexItem&gt;&amp;, LayoutUnit crossAxisOffset, LayoutUnit availableFreeSpace);
184     void alignFlexLines(Vector&lt;LineContext&gt;&amp;);
185     void alignChildren(const Vector&lt;LineContext&gt;&amp;);
186     void applyStretchAlignmentToChild(RenderBox&amp; child, LayoutUnit lineCrossAxisExtent);
187     void flipForRightToLeftColumn(const Vector&lt;LineContext&gt;&amp; lineContexts);
188     void flipForWrapReverse(const Vector&lt;LineContext&gt;&amp;, LayoutUnit crossAxisStartEdge);
189 
190     void appendChildFrameRects(ChildFrameRects&amp;);
191     void repaintChildrenDuringLayoutIfMoved(const ChildFrameRects&amp;);
192 
193     bool hasPercentHeightDescendants(const RenderBox&amp;) const;
194 
195     // This is used to cache the preferred size for orthogonal flow children so we
196     // don&#39;t have to relayout to get it
197     HashMap&lt;const RenderBox*, LayoutUnit&gt; m_intrinsicSizeAlongMainAxis;
198 
199     // This is used to cache the intrinsic size on the cross axis to avoid
200     // relayouts when stretching.
201     HashMap&lt;const RenderBox*, LayoutUnit&gt; m_intrinsicContentLogicalHeights;
202 
203     // This set is used to keep track of which children we laid out in this
204     // current layout iteration. We need it because the ones in this set may
205     // need an additional layout pass for correct stretch alignment handling, as
206     // the first layout likely did not use the correct value for percentage
207     // sizing of children.
208     HashSet&lt;const RenderBox*&gt; m_relaidOutChildren;
209 
210     mutable OrderIterator m_orderIterator { *this };
211     int m_numberOfInFlowChildrenOnFirstLine { -1 };
212 
213     // This is SizeIsUnknown outside of layoutBlock()
214     mutable SizeDefiniteness m_hasDefiniteHeight { SizeDefiniteness::Unknown };
215     bool m_inLayout { false };
216     bool m_shouldResetChildLogicalHeightBeforeLayout { false };
217 };
218 
219 } // namespace WebCore
220 
221 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderFlexibleBox, isFlexibleBox())
    </pre>
  </body>
</html>
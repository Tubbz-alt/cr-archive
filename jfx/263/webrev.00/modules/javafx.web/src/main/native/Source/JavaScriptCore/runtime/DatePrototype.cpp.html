<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DatePrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   4  *  Copyright (C) 2008, 2009 Torch Mobile, Inc. All rights reserved.
   5  *  Copyright (C) 2010 Torch Mobile (Beijing) Co. Ltd. All rights reserved.
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
  20  *  USA
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;DatePrototype.h&quot;
  26 
  27 #include &quot;DateConversion.h&quot;
  28 #include &quot;DateInstance.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;JSCBuiltins.h&quot;
  31 #include &quot;JSDateMath.h&quot;
  32 #include &quot;JSGlobalObject.h&quot;
  33 #include &quot;JSObject.h&quot;
  34 #include &quot;JSString.h&quot;
  35 #include &quot;Lookup.h&quot;
  36 #include &quot;ObjectPrototype.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &lt;limits.h&gt;
  39 #include &lt;locale.h&gt;
  40 #include &lt;math.h&gt;
  41 #include &lt;stdlib.h&gt;
  42 #include &lt;time.h&gt;
  43 #include &lt;wtf/Assertions.h&gt;
  44 #include &lt;wtf/MathExtras.h&gt;
  45 
  46 #if HAVE(LANGINFO_H)
  47 #include &lt;langinfo.h&gt;
  48 #endif
  49 
  50 #if HAVE(SYS_PARAM_H)
  51 #include &lt;sys/param.h&gt;
  52 #endif
  53 
  54 #if HAVE(SYS_TIME_H)
  55 #include &lt;sys/time.h&gt;
  56 #endif
  57 
  58 #if HAVE(SYS_TIMEB_H)
  59 #include &lt;sys/timeb.h&gt;
  60 #endif
  61 
  62 #if !(OS(DARWIN) &amp;&amp; USE(CF))
  63 #include &lt;unicode/udat.h&gt;
  64 #endif
  65 
  66 #if USE(CF)
  67 #include &lt;CoreFoundation/CoreFoundation.h&gt;
  68 #endif
  69 
  70 namespace JSC {
  71 
  72 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDate(JSGlobalObject*, CallFrame*);
  73 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDay(JSGlobalObject*, CallFrame*);
  74 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetFullYear(JSGlobalObject*, CallFrame*);
  75 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetHours(JSGlobalObject*, CallFrame*);
  76 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMilliSeconds(JSGlobalObject*, CallFrame*);
  77 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMinutes(JSGlobalObject*, CallFrame*);
  78 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMonth(JSGlobalObject*, CallFrame*);
  79 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetSeconds(JSGlobalObject*, CallFrame*);
  80 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetTimezoneOffset(JSGlobalObject*, CallFrame*);
  81 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDate(JSGlobalObject*, CallFrame*);
  82 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDay(JSGlobalObject*, CallFrame*);
  83 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCFullYear(JSGlobalObject*, CallFrame*);
  84 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCHours(JSGlobalObject*, CallFrame*);
  85 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMilliseconds(JSGlobalObject*, CallFrame*);
  86 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMinutes(JSGlobalObject*, CallFrame*);
  87 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMonth(JSGlobalObject*, CallFrame*);
  88 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCSeconds(JSGlobalObject*, CallFrame*);
  89 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetYear(JSGlobalObject*, CallFrame*);
  90 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetDate(JSGlobalObject*, CallFrame*);
  91 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetFullYear(JSGlobalObject*, CallFrame*);
  92 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetHours(JSGlobalObject*, CallFrame*);
  93 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMilliSeconds(JSGlobalObject*, CallFrame*);
  94 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMinutes(JSGlobalObject*, CallFrame*);
  95 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMonth(JSGlobalObject*, CallFrame*);
  96 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetSeconds(JSGlobalObject*, CallFrame*);
  97 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetTime(JSGlobalObject*, CallFrame*);
  98 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCDate(JSGlobalObject*, CallFrame*);
  99 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCFullYear(JSGlobalObject*, CallFrame*);
 100 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCHours(JSGlobalObject*, CallFrame*);
 101 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMilliseconds(JSGlobalObject*, CallFrame*);
 102 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMinutes(JSGlobalObject*, CallFrame*);
 103 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMonth(JSGlobalObject*, CallFrame*);
 104 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCSeconds(JSGlobalObject*, CallFrame*);
 105 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetYear(JSGlobalObject*, CallFrame*);
 106 EncodedJSValue JSC_HOST_CALL dateProtoFuncToDateString(JSGlobalObject*, CallFrame*);
 107 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleDateString(JSGlobalObject*, CallFrame*);
 108 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleString(JSGlobalObject*, CallFrame*);
 109 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleTimeString(JSGlobalObject*, CallFrame*);
 110 EncodedJSValue JSC_HOST_CALL dateProtoFuncToPrimitiveSymbol(JSGlobalObject*, CallFrame*);
 111 EncodedJSValue JSC_HOST_CALL dateProtoFuncToString(JSGlobalObject*, CallFrame*);
 112 EncodedJSValue JSC_HOST_CALL dateProtoFuncToTimeString(JSGlobalObject*, CallFrame*);
 113 EncodedJSValue JSC_HOST_CALL dateProtoFuncToUTCString(JSGlobalObject*, CallFrame*);
 114 EncodedJSValue JSC_HOST_CALL dateProtoFuncToISOString(JSGlobalObject*, CallFrame*);
 115 EncodedJSValue JSC_HOST_CALL dateProtoFuncToJSON(JSGlobalObject*, CallFrame*);
 116 
 117 }
 118 
 119 #include &quot;DatePrototype.lut.h&quot;
 120 
 121 namespace JSC {
 122 
 123 enum LocaleDateTimeFormat { LocaleDateAndTime, LocaleDate, LocaleTime };
 124 
 125 #if OS(DARWIN) &amp;&amp; USE(CF)
 126 
 127 // FIXME: Since this is superior to the strftime-based version, why limit this to OS(DARWIN)?
 128 // Instead we should consider using this whenever USE(CF) is true.
 129 
 130 static CFDateFormatterStyle styleFromArgString(const String&amp; string, CFDateFormatterStyle defaultStyle)
 131 {
 132     if (string == &quot;short&quot;)
 133         return kCFDateFormatterShortStyle;
 134     if (string == &quot;medium&quot;)
 135         return kCFDateFormatterMediumStyle;
 136     if (string == &quot;long&quot;)
 137         return kCFDateFormatterLongStyle;
 138     if (string == &quot;full&quot;)
 139         return kCFDateFormatterFullStyle;
 140     return defaultStyle;
 141 }
 142 
 143 static JSCell* formatLocaleDate(JSGlobalObject* globalObject, CallFrame* callFrame, DateInstance*, double timeInMilliseconds, LocaleDateTimeFormat format)
 144 {
 145     VM&amp; vm = globalObject-&gt;vm();
 146     CFDateFormatterStyle dateStyle = (format != LocaleTime ? kCFDateFormatterLongStyle : kCFDateFormatterNoStyle);
 147     CFDateFormatterStyle timeStyle = (format != LocaleDate ? kCFDateFormatterLongStyle : kCFDateFormatterNoStyle);
 148 
 149     bool useCustomFormat = false;
 150     String customFormatString;
 151 
 152     String arg0String = callFrame-&gt;argument(0).toWTFString(globalObject);
 153     if (arg0String == &quot;custom&quot; &amp;&amp; !callFrame-&gt;argument(1).isUndefined()) {
 154         useCustomFormat = true;
 155         customFormatString = callFrame-&gt;argument(1).toWTFString(globalObject);
 156     } else if (format == LocaleDateAndTime &amp;&amp; !callFrame-&gt;argument(1).isUndefined()) {
 157         dateStyle = styleFromArgString(arg0String, dateStyle);
 158         timeStyle = styleFromArgString(callFrame-&gt;argument(1).toWTFString(globalObject), timeStyle);
 159     } else if (format != LocaleTime &amp;&amp; !callFrame-&gt;argument(0).isUndefined())
 160         dateStyle = styleFromArgString(arg0String, dateStyle);
 161     else if (format != LocaleDate &amp;&amp; !callFrame-&gt;argument(0).isUndefined())
 162         timeStyle = styleFromArgString(arg0String, timeStyle);
 163 
 164     CFAbsoluteTime absoluteTime = floor(timeInMilliseconds / msPerSecond) - kCFAbsoluteTimeIntervalSince1970;
 165 
 166     auto formatter = adoptCF(CFDateFormatterCreate(kCFAllocatorDefault, adoptCF(CFLocaleCopyCurrent()).get(), dateStyle, timeStyle));
 167     if (useCustomFormat)
 168         CFDateFormatterSetFormat(formatter.get(), customFormatString.createCFString().get());
 169     return jsNontrivialString(vm, adoptCF(CFDateFormatterCreateStringWithAbsoluteTime(kCFAllocatorDefault, formatter.get(), absoluteTime)).get());
 170 }
 171 
 172 #elif !UCONFIG_NO_FORMATTING
 173 
 174 static JSCell* formatLocaleDate(JSGlobalObject* globalObject, CallFrame*, DateInstance*, double timeInMilliseconds, LocaleDateTimeFormat format)
 175 {
 176     VM&amp; vm = globalObject-&gt;vm();
 177     UDateFormatStyle timeStyle = (format != LocaleDate ? UDAT_LONG : UDAT_NONE);
 178     UDateFormatStyle dateStyle = (format != LocaleTime ? UDAT_LONG : UDAT_NONE);
 179 
 180     UErrorCode status = U_ZERO_ERROR;
 181     UDateFormat* df = udat_open(timeStyle, dateStyle, 0, 0, -1, 0, 0, &amp;status);
 182     if (!df)
 183         return jsEmptyString(vm);
 184 
 185     UChar buffer[128];
 186     int32_t length;
 187     length = udat_format(df, timeInMilliseconds, buffer, 128, 0, &amp;status);
 188     udat_close(df);
 189     if (status != U_ZERO_ERROR)
 190         return jsEmptyString(vm);
 191 
 192     return jsNontrivialString(vm, String(buffer, length));
 193 }
 194 
 195 #else
 196 
 197 static JSCell* formatLocaleDate(JSGlobalObject* globalObject, CallFrame* callFrame, const GregorianDateTime&amp; gdt, LocaleDateTimeFormat format)
 198 {
 199     VM&amp; vm = globalObject-&gt;vm();
 200 #if OS(WINDOWS)
 201     SYSTEMTIME systemTime;
 202     memset(&amp;systemTime, 0, sizeof(systemTime));
 203     systemTime.wYear = gdt.year();
 204     systemTime.wMonth = gdt.month() + 1;
 205     systemTime.wDay = gdt.monthDay();
 206     systemTime.wDayOfWeek = gdt.weekDay();
 207     systemTime.wHour = gdt.hour();
 208     systemTime.wMinute = gdt.minute();
 209     systemTime.wSecond = gdt.second();
 210 
 211     Vector&lt;UChar, 128&gt; buffer;
 212     size_t length = 0;
 213 
 214     if (format == LocaleDate) {
 215         buffer.resize(GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, 0, 0));
 216         length = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, buffer.data(), buffer.size());
 217     } else if (format == LocaleTime) {
 218         buffer.resize(GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, 0, 0));
 219         length = GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, buffer.data(), buffer.size());
 220     } else if (format == LocaleDateAndTime) {
 221         buffer.resize(GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, 0, 0) + GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, 0, 0));
 222         length = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, buffer.data(), buffer.size());
 223         if (length) {
 224             buffer[length - 1] = &#39; &#39;;
 225             length += GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, buffer.data() + length, buffer.size() - length);
 226         }
 227     } else
 228         RELEASE_ASSERT_NOT_REACHED();
 229 
 230     //  Remove terminating null character.
 231     if (length)
 232         length--;
 233 
 234     return jsNontrivialString(vm, String(buffer.data(), length));
 235 
 236 #else // OS(WINDOWS)
 237 
 238 #if HAVE(LANGINFO_H)
 239     static const nl_item formats[] = { D_T_FMT, D_FMT, T_FMT };
 240 #else
 241     static const char* const formatStrings[] = { &quot;%#c&quot;, &quot;%#x&quot;, &quot;%X&quot; };
 242 #endif
 243 
 244     // Offset year if needed
 245     struct tm localTM = gdt;
 246     int year = gdt.year();
 247     bool yearNeedsOffset = year &lt; 1900 || year &gt; 2038;
 248     if (yearNeedsOffset)
 249         localTM.tm_year = equivalentYearForDST(year) - 1900;
 250 
 251 #if HAVE(LANGINFO_H)
 252     // We do not allow strftime to generate dates with 2-digits years,
 253     // both to avoid ambiguity, and a crash in strncpy, for years that
 254     // need offset.
 255     char* formatString = strdup(nl_langinfo(formats[format]));
 256     char* yPos = strchr(formatString, &#39;y&#39;);
 257     if (yPos)
 258         *yPos = &#39;Y&#39;;
 259 #endif
 260 
 261     // Do the formatting
 262     const int bufsize = 128;
 263     char timebuffer[bufsize];
 264 
 265 #if HAVE(LANGINFO_H)
 266     size_t ret = strftime(timebuffer, bufsize, formatString, &amp;localTM);
 267     free(formatString);
 268 #else
 269     size_t ret = strftime(timebuffer, bufsize, formatStrings[format], &amp;localTM);
 270 #endif
 271 
 272     if (ret == 0)
 273         return jsEmptyString(vm);
 274 
 275     // Copy original into the buffer
 276     if (yearNeedsOffset &amp;&amp; format != LocaleTime) {
 277         static const int yearLen = 5;   // FIXME will be a problem in the year 10,000
 278         char yearString[yearLen];
 279 
 280         snprintf(yearString, yearLen, &quot;%d&quot;, localTM.tm_year + 1900);
 281         char* yearLocation = strstr(timebuffer, yearString);
 282         snprintf(yearString, yearLen, &quot;%d&quot;, year);
 283 
 284         strncpy(yearLocation, yearString, yearLen - 1);
 285     }
 286 
 287     // Convert multi-byte result to UNICODE.
 288     // If __STDC_ISO_10646__ is defined, wide character represents
 289     // UTF-16 (or UTF-32) code point. In most modern Unix like system
 290     // (e.g. Linux with glibc 2.2 and above) the macro is defined,
 291     // and wide character represents UTF-32 code point.
 292     // Here we static_cast potential UTF-32 to UTF-16, it should be
 293     // safe because date and (or) time related characters in different languages
 294     // should be in UNICODE BMP. If mbstowcs fails, we just fall
 295     // back on using multi-byte result as-is.
 296 #ifdef __STDC_ISO_10646__
 297     UChar buffer[bufsize];
 298     wchar_t tempbuffer[bufsize];
 299     size_t length = mbstowcs(tempbuffer, timebuffer, bufsize - 1);
 300     if (length != static_cast&lt;size_t&gt;(-1)) {
 301         for (size_t i = 0; i &lt; length; ++i)
 302             buffer[i] = static_cast&lt;UChar&gt;(tempbuffer[i]);
 303         return jsNontrivialString(vm, String(buffer, length));
 304     }
 305 #endif
 306 
 307     return jsNontrivialString(vm, timebuffer);
 308 #endif // OS(WINDOWS)
 309 }
 310 
 311 static JSCell* formatLocaleDate(JSGlobalObject* globalObject, CallFrame* callFrame, DateInstance* dateObject, double, LocaleDateTimeFormat format)
 312 {
 313     VM&amp; vm = globalObject-&gt;vm();
 314     const GregorianDateTime* gregorianDateTime = dateObject-&gt;gregorianDateTime(vm);
 315     if (!gregorianDateTime)
 316         return jsNontrivialString(vm, &quot;Invalid Date&quot;_s);
 317     return formatLocaleDate(globalObject, callFrame, *gregorianDateTime, format);
 318 }
 319 
 320 #endif // OS(DARWIN) &amp;&amp; USE(CF)
 321 
 322 static EncodedJSValue formateDateInstance(JSGlobalObject* globalObject, CallFrame* callFrame, DateTimeFormat format, bool asUTCVariant)
 323 {
 324     VM&amp; vm = globalObject-&gt;vm();
 325     auto scope = DECLARE_THROW_SCOPE(vm);
 326     JSValue thisValue = callFrame-&gt;thisValue();
 327     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 328     if (UNLIKELY(!thisDateObj))
 329         return throwVMTypeError(globalObject, scope);
 330 
 331     const GregorianDateTime* gregorianDateTime = asUTCVariant
 332         ? thisDateObj-&gt;gregorianDateTimeUTC(vm)
 333         : thisDateObj-&gt;gregorianDateTime(vm);
 334     if (!gregorianDateTime)
 335         return JSValue::encode(jsNontrivialString(vm, String(&quot;Invalid Date&quot;_s)));
 336 
 337     return JSValue::encode(jsNontrivialString(vm, formatDateTime(*gregorianDateTime, format, asUTCVariant)));
 338 }
 339 
 340 // Converts a list of arguments sent to a Date member function into milliseconds, updating
 341 // ms (representing milliseconds) and t (representing the rest of the date structure) appropriately.
 342 //
 343 // Format of member function: f([hour,] [min,] [sec,] [ms])
 344 static bool fillStructuresUsingTimeArgs(JSGlobalObject* globalObject, CallFrame* callFrame, int maxArgs, double* ms, GregorianDateTime* t)
 345 {
 346     VM&amp; vm = globalObject-&gt;vm();
 347     auto scope = DECLARE_THROW_SCOPE(vm);
 348 
 349     double milliseconds = 0;
 350     bool ok = true;
 351     int idx = 0;
 352     int numArgs = callFrame-&gt;argumentCount();
 353 
 354     // JS allows extra trailing arguments -- ignore them
 355     if (numArgs &gt; maxArgs)
 356         numArgs = maxArgs;
 357 
 358     // hours
 359     if (maxArgs &gt;= 4 &amp;&amp; idx &lt; numArgs) {
 360         t-&gt;setHour(0);
 361         double hours = callFrame-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(globalObject);
 362         RETURN_IF_EXCEPTION(scope, false);
 363         ok = std::isfinite(hours);
 364         milliseconds += hours * msPerHour;
 365     }
 366 
 367     // minutes
 368     if (maxArgs &gt;= 3 &amp;&amp; idx &lt; numArgs &amp;&amp; ok) {
 369         t-&gt;setMinute(0);
 370         double minutes = callFrame-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(globalObject);
 371         RETURN_IF_EXCEPTION(scope, false);
 372         ok = std::isfinite(minutes);
 373         milliseconds += minutes * msPerMinute;
 374     }
 375 
 376     // seconds
 377     if (maxArgs &gt;= 2 &amp;&amp; idx &lt; numArgs &amp;&amp; ok) {
 378         t-&gt;setSecond(0);
 379         double seconds = callFrame-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(globalObject);
 380         RETURN_IF_EXCEPTION(scope, false);
 381         ok = std::isfinite(seconds);
 382         milliseconds += seconds * msPerSecond;
 383     }
 384 
 385     if (!ok)
 386         return false;
 387 
 388     // milliseconds
 389     if (idx &lt; numArgs) {
 390         double millis = callFrame-&gt;uncheckedArgument(idx).toIntegerPreserveNaN(globalObject);
 391         RETURN_IF_EXCEPTION(scope, false);
 392         ok = std::isfinite(millis);
 393         milliseconds += millis;
 394     } else
 395         milliseconds += *ms;
 396 
 397     *ms = milliseconds;
 398     return ok;
 399 }
 400 
 401 // Converts a list of arguments sent to a Date member function into years, months, and milliseconds, updating
 402 // ms (representing milliseconds) and t (representing the rest of the date structure) appropriately.
 403 //
 404 // Format of member function: f([years,] [months,] [days])
 405 static bool fillStructuresUsingDateArgs(JSGlobalObject* globalObject, CallFrame* callFrame, int maxArgs, double *ms, GregorianDateTime *t)
 406 {
 407     VM&amp; vm = globalObject-&gt;vm();
 408     auto scope = DECLARE_THROW_SCOPE(vm);
 409 
 410     int idx = 0;
 411     bool ok = true;
 412     int numArgs = callFrame-&gt;argumentCount();
 413 
 414     // JS allows extra trailing arguments -- ignore them
 415     if (numArgs &gt; maxArgs)
 416         numArgs = maxArgs;
 417 
 418     // years
 419     if (maxArgs &gt;= 3 &amp;&amp; idx &lt; numArgs) {
 420         double years = callFrame-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(globalObject);
 421         RETURN_IF_EXCEPTION(scope, false);
 422         ok = std::isfinite(years);
 423         t-&gt;setYear(toInt32(years));
 424     }
 425     // months
 426     if (maxArgs &gt;= 2 &amp;&amp; idx &lt; numArgs &amp;&amp; ok) {
 427         double months = callFrame-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(globalObject);
 428         RETURN_IF_EXCEPTION(scope, false);
 429         ok = std::isfinite(months);
 430         t-&gt;setMonth(toInt32(months));
 431     }
 432     // days
 433     if (idx &lt; numArgs &amp;&amp; ok) {
 434         double days = callFrame-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(globalObject);
 435         RETURN_IF_EXCEPTION(scope, false);
 436         ok = std::isfinite(days);
 437         t-&gt;setMonthDay(0);
 438         *ms += days * msPerDay;
 439     }
 440 
 441     return ok;
 442 }
 443 
 444 const ClassInfo DatePrototype::s_info = {&quot;Object&quot;, &amp;JSNonFinalObject::s_info, &amp;dateTable, nullptr, CREATE_METHOD_TABLE(DatePrototype)};
 445 
 446 /* Source for DatePrototype.lut.h
 447 @begin dateTable
 448   toString              dateProtoFuncToString                DontEnum|Function       0
 449   toISOString           dateProtoFuncToISOString             DontEnum|Function       0
 450   toDateString          dateProtoFuncToDateString            DontEnum|Function       0
 451   toTimeString          dateProtoFuncToTimeString            DontEnum|Function       0
 452   toLocaleString        dateProtoFuncToLocaleString          DontEnum|Function       0
 453   toLocaleDateString    dateProtoFuncToLocaleDateString      DontEnum|Function       0
 454   toLocaleTimeString    dateProtoFuncToLocaleTimeString      DontEnum|Function       0
 455   valueOf               dateProtoFuncGetTime                 DontEnum|Function       0  DatePrototypeGetTimeIntrinsic
 456   getTime               dateProtoFuncGetTime                 DontEnum|Function       0  DatePrototypeGetTimeIntrinsic
 457   getFullYear           dateProtoFuncGetFullYear             DontEnum|Function       0  DatePrototypeGetFullYearIntrinsic
 458   getUTCFullYear        dateProtoFuncGetUTCFullYear          DontEnum|Function       0  DatePrototypeGetUTCFullYearIntrinsic
 459   getMonth              dateProtoFuncGetMonth                DontEnum|Function       0  DatePrototypeGetMonthIntrinsic
 460   getUTCMonth           dateProtoFuncGetUTCMonth             DontEnum|Function       0  DatePrototypeGetUTCMonthIntrinsic
 461   getDate               dateProtoFuncGetDate                 DontEnum|Function       0  DatePrototypeGetDateIntrinsic
 462   getUTCDate            dateProtoFuncGetUTCDate              DontEnum|Function       0  DatePrototypeGetUTCDateIntrinsic
 463   getDay                dateProtoFuncGetDay                  DontEnum|Function       0  DatePrototypeGetDayIntrinsic
 464   getUTCDay             dateProtoFuncGetUTCDay               DontEnum|Function       0  DatePrototypeGetUTCDayIntrinsic
 465   getHours              dateProtoFuncGetHours                DontEnum|Function       0  DatePrototypeGetHoursIntrinsic
 466   getUTCHours           dateProtoFuncGetUTCHours             DontEnum|Function       0  DatePrototypeGetUTCHoursIntrinsic
 467   getMinutes            dateProtoFuncGetMinutes              DontEnum|Function       0  DatePrototypeGetMinutesIntrinsic
 468   getUTCMinutes         dateProtoFuncGetUTCMinutes           DontEnum|Function       0  DatePrototypeGetUTCMinutesIntrinsic
 469   getSeconds            dateProtoFuncGetSeconds              DontEnum|Function       0  DatePrototypeGetSecondsIntrinsic
 470   getUTCSeconds         dateProtoFuncGetUTCSeconds           DontEnum|Function       0  DatePrototypeGetUTCSecondsIntrinsic
 471   getMilliseconds       dateProtoFuncGetMilliSeconds         DontEnum|Function       0  DatePrototypeGetMillisecondsIntrinsic
 472   getUTCMilliseconds    dateProtoFuncGetUTCMilliseconds      DontEnum|Function       0  DatePrototypeGetUTCMillisecondsIntrinsic
 473   getTimezoneOffset     dateProtoFuncGetTimezoneOffset       DontEnum|Function       0  DatePrototypeGetTimezoneOffsetIntrinsic
 474   getYear               dateProtoFuncGetYear                 DontEnum|Function       0  DatePrototypeGetYearIntrinsic
 475   setTime               dateProtoFuncSetTime                 DontEnum|Function       1
 476   setMilliseconds       dateProtoFuncSetMilliSeconds         DontEnum|Function       1
 477   setUTCMilliseconds    dateProtoFuncSetUTCMilliseconds      DontEnum|Function       1
 478   setSeconds            dateProtoFuncSetSeconds              DontEnum|Function       2
 479   setUTCSeconds         dateProtoFuncSetUTCSeconds           DontEnum|Function       2
 480   setMinutes            dateProtoFuncSetMinutes              DontEnum|Function       3
 481   setUTCMinutes         dateProtoFuncSetUTCMinutes           DontEnum|Function       3
 482   setHours              dateProtoFuncSetHours                DontEnum|Function       4
 483   setUTCHours           dateProtoFuncSetUTCHours             DontEnum|Function       4
 484   setDate               dateProtoFuncSetDate                 DontEnum|Function       1
 485   setUTCDate            dateProtoFuncSetUTCDate              DontEnum|Function       1
 486   setMonth              dateProtoFuncSetMonth                DontEnum|Function       2
 487   setUTCMonth           dateProtoFuncSetUTCMonth             DontEnum|Function       2
 488   setFullYear           dateProtoFuncSetFullYear             DontEnum|Function       3
 489   setUTCFullYear        dateProtoFuncSetUTCFullYear          DontEnum|Function       3
 490   setYear               dateProtoFuncSetYear                 DontEnum|Function       1
 491   toJSON                dateProtoFuncToJSON                  DontEnum|Function       1
 492 @end
 493 */
 494 
 495 // ECMA 15.9.4
 496 
 497 DatePrototype::DatePrototype(VM&amp; vm, Structure* structure)
 498     : Base(vm, structure)
 499 {
 500 }
 501 
 502 void DatePrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 503 {
 504     Base::finishCreation(vm);
 505     ASSERT(inherits(vm, info()));
 506 
 507     Identifier toUTCStringName = Identifier::fromString(vm, &quot;toUTCString&quot;_s);
 508     JSFunction* toUTCStringFunction = JSFunction::create(vm, globalObject, 0, toUTCStringName.string(), dateProtoFuncToUTCString);
 509     putDirectWithoutTransition(vm, toUTCStringName, toUTCStringFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 510     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;toGMTString&quot;_s), toUTCStringFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 511 
 512 #if ENABLE(INTL)
 513     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleString&quot;, datePrototypeToLocaleStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 514     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleDateString&quot;, datePrototypeToLocaleDateStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 515     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleTimeString&quot;, datePrototypeToLocaleTimeStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 516 #endif
 517 
 518     JSFunction* toPrimitiveFunction = JSFunction::create(vm, globalObject, 1, &quot;[Symbol.toPrimitive]&quot;_s, dateProtoFuncToPrimitiveSymbol, NoIntrinsic);
 519     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toPrimitiveSymbol, toPrimitiveFunction, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 520 
 521     // The constructor will be added later, after DateConstructor has been built.
 522 }
 523 
 524 // Functions
 525 
 526 EncodedJSValue JSC_HOST_CALL dateProtoFuncToString(JSGlobalObject* globalObject, CallFrame* callFrame)
 527 {
 528     const bool asUTCVariant = false;
 529     return formateDateInstance(globalObject, callFrame, DateTimeFormatDateAndTime, asUTCVariant);
 530 }
 531 
 532 EncodedJSValue JSC_HOST_CALL dateProtoFuncToUTCString(JSGlobalObject* globalObject, CallFrame* callFrame)
 533 {
 534     const bool asUTCVariant = true;
 535     return formateDateInstance(globalObject, callFrame, DateTimeFormatDateAndTime, asUTCVariant);
 536 }
 537 
 538 EncodedJSValue JSC_HOST_CALL dateProtoFuncToISOString(JSGlobalObject* globalObject, CallFrame* callFrame)
 539 {
 540     VM&amp; vm = globalObject-&gt;vm();
 541     auto scope = DECLARE_THROW_SCOPE(vm);
 542     JSValue thisValue = callFrame-&gt;thisValue();
 543     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 544     if (UNLIKELY(!thisDateObj))
 545         return throwVMTypeError(globalObject, scope);
 546 
 547     if (!std::isfinite(thisDateObj-&gt;internalNumber()))
 548         return throwVMError(globalObject, scope, createRangeError(globalObject, &quot;Invalid Date&quot;_s));
 549 
 550     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(vm);
 551     if (!gregorianDateTime)
 552         return JSValue::encode(jsNontrivialString(vm, String(&quot;Invalid Date&quot;_s)));
 553     // Maximum amount of space we need in buffer: 7 (max. digits in year) + 2 * 5 (2 characters each for month, day, hour, minute, second) + 4 (. + 3 digits for milliseconds)
 554     // 6 for formatting and one for null termination = 28. We add one extra character to allow us to force null termination.
 555     char buffer[28];
 556     // If the year is outside the bounds of 0 and 9999 inclusive we want to use the extended year format (ES 15.9.1.15.1).
 557     int ms = static_cast&lt;int&gt;(fmod(thisDateObj-&gt;internalNumber(), msPerSecond));
 558     if (ms &lt; 0)
 559         ms += msPerSecond;
 560 
 561     int charactersWritten;
 562     if (gregorianDateTime-&gt;year() &gt; 9999 || gregorianDateTime-&gt;year() &lt; 0)
 563         charactersWritten = snprintf(buffer, sizeof(buffer), &quot;%+07d-%02d-%02dT%02d:%02d:%02d.%03dZ&quot;, gregorianDateTime-&gt;year(), gregorianDateTime-&gt;month() + 1, gregorianDateTime-&gt;monthDay(), gregorianDateTime-&gt;hour(), gregorianDateTime-&gt;minute(), gregorianDateTime-&gt;second(), ms);
 564     else
 565         charactersWritten = snprintf(buffer, sizeof(buffer), &quot;%04d-%02d-%02dT%02d:%02d:%02d.%03dZ&quot;, gregorianDateTime-&gt;year(), gregorianDateTime-&gt;month() + 1, gregorianDateTime-&gt;monthDay(), gregorianDateTime-&gt;hour(), gregorianDateTime-&gt;minute(), gregorianDateTime-&gt;second(), ms);
 566 
 567     ASSERT(charactersWritten &gt; 0 &amp;&amp; static_cast&lt;unsigned&gt;(charactersWritten) &lt; sizeof(buffer));
 568     if (static_cast&lt;unsigned&gt;(charactersWritten) &gt;= sizeof(buffer))
 569         return JSValue::encode(jsEmptyString(vm));
 570 
 571     return JSValue::encode(jsNontrivialString(vm, String(buffer, charactersWritten)));
 572 }
 573 
 574 EncodedJSValue JSC_HOST_CALL dateProtoFuncToDateString(JSGlobalObject* globalObject, CallFrame* callFrame)
 575 {
 576     const bool asUTCVariant = false;
 577     return formateDateInstance(globalObject, callFrame, DateTimeFormatDate, asUTCVariant);
 578 }
 579 
 580 EncodedJSValue JSC_HOST_CALL dateProtoFuncToTimeString(JSGlobalObject* globalObject, CallFrame* callFrame)
 581 {
 582     const bool asUTCVariant = false;
 583     return formateDateInstance(globalObject, callFrame, DateTimeFormatTime, asUTCVariant);
 584 }
 585 
 586 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleString(JSGlobalObject* globalObject, CallFrame* callFrame)
 587 {
 588     VM&amp; vm = globalObject-&gt;vm();
 589     auto scope = DECLARE_THROW_SCOPE(vm);
 590     JSValue thisValue = callFrame-&gt;thisValue();
 591     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 592     if (UNLIKELY(!thisDateObj))
 593         return throwVMTypeError(globalObject, scope);
 594 
 595     return JSValue::encode(formatLocaleDate(globalObject, callFrame, thisDateObj, thisDateObj-&gt;internalNumber(), LocaleDateAndTime));
 596 }
 597 
 598 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleDateString(JSGlobalObject* globalObject, CallFrame* callFrame)
 599 {
 600     VM&amp; vm = globalObject-&gt;vm();
 601     auto scope = DECLARE_THROW_SCOPE(vm);
 602     JSValue thisValue = callFrame-&gt;thisValue();
 603     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 604     if (UNLIKELY(!thisDateObj))
 605         return throwVMTypeError(globalObject, scope);
 606 
 607     return JSValue::encode(formatLocaleDate(globalObject, callFrame, thisDateObj, thisDateObj-&gt;internalNumber(), LocaleDate));
 608 }
 609 
 610 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleTimeString(JSGlobalObject* globalObject, CallFrame* callFrame)
 611 {
 612     VM&amp; vm = globalObject-&gt;vm();
 613     auto scope = DECLARE_THROW_SCOPE(vm);
 614     JSValue thisValue = callFrame-&gt;thisValue();
 615     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 616     if (UNLIKELY(!thisDateObj))
 617         return throwVMTypeError(globalObject, scope);
 618 
 619     return JSValue::encode(formatLocaleDate(globalObject, callFrame, thisDateObj, thisDateObj-&gt;internalNumber(), LocaleTime));
 620 }
 621 
 622 EncodedJSValue JSC_HOST_CALL dateProtoFuncToPrimitiveSymbol(JSGlobalObject* globalObject, CallFrame* callFrame)
 623 {
 624     VM&amp; vm = globalObject-&gt;vm();
 625     auto scope = DECLARE_THROW_SCOPE(vm);
 626     JSValue thisValue = callFrame-&gt;thisValue();
 627     if (!thisValue.isObject())
 628         return throwVMTypeError(globalObject, scope, &quot;Date.prototype[Symbol.toPrimitive] expected |this| to be an object.&quot;);
 629     JSObject* thisObject = jsCast&lt;JSObject*&gt;(thisValue);
 630 
 631     if (!callFrame-&gt;argumentCount())
 632         return throwVMTypeError(globalObject, scope, &quot;Date.prototype[Symbol.toPrimitive] expected a first argument.&quot;);
 633 
 634     JSValue hintValue = callFrame-&gt;uncheckedArgument(0);
 635     PreferredPrimitiveType type = toPreferredPrimitiveType(globalObject, hintValue);
 636     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 637 
 638     if (type == NoPreference)
 639         type = PreferString;
 640 
 641     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;ordinaryToPrimitive(globalObject, type)));
 642 }
 643 
 644 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetTime(JSGlobalObject* globalObject, CallFrame* callFrame)
 645 {
 646     VM&amp; vm = globalObject-&gt;vm();
 647     auto scope = DECLARE_THROW_SCOPE(vm);
 648     JSValue thisValue = callFrame-&gt;thisValue();
 649     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 650     if (UNLIKELY(!thisDateObj))
 651         return throwVMTypeError(globalObject, scope);
 652 
 653     return JSValue::encode(jsNumber(thisDateObj-&gt;internalNumber()));
 654 }
 655 
 656 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetFullYear(JSGlobalObject* globalObject, CallFrame* callFrame)
 657 {
 658     VM&amp; vm = globalObject-&gt;vm();
 659     auto scope = DECLARE_THROW_SCOPE(vm);
 660     JSValue thisValue = callFrame-&gt;thisValue();
 661     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 662     if (UNLIKELY(!thisDateObj))
 663         return throwVMTypeError(globalObject, scope);
 664 
 665     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(vm);
 666     if (!gregorianDateTime)
 667         return JSValue::encode(jsNaN());
 668     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));
 669 }
 670 
 671 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCFullYear(JSGlobalObject* globalObject, CallFrame* callFrame)
 672 {
 673     VM&amp; vm = globalObject-&gt;vm();
 674     auto scope = DECLARE_THROW_SCOPE(vm);
 675     JSValue thisValue = callFrame-&gt;thisValue();
 676     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 677     if (UNLIKELY(!thisDateObj))
 678         return throwVMTypeError(globalObject, scope);
 679 
 680     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(vm);
 681     if (!gregorianDateTime)
 682         return JSValue::encode(jsNaN());
 683     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));
 684 }
 685 
 686 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMonth(JSGlobalObject* globalObject, CallFrame* callFrame)
 687 {
 688     VM&amp; vm = globalObject-&gt;vm();
 689     auto scope = DECLARE_THROW_SCOPE(vm);
 690     JSValue thisValue = callFrame-&gt;thisValue();
 691     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 692     if (UNLIKELY(!thisDateObj))
 693         return throwVMTypeError(globalObject, scope);
 694 
 695     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(vm);
 696     if (!gregorianDateTime)
 697         return JSValue::encode(jsNaN());
 698     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));
 699 }
 700 
 701 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMonth(JSGlobalObject* globalObject, CallFrame* callFrame)
 702 {
 703     VM&amp; vm = globalObject-&gt;vm();
 704     auto scope = DECLARE_THROW_SCOPE(vm);
 705     JSValue thisValue = callFrame-&gt;thisValue();
 706     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 707     if (UNLIKELY(!thisDateObj))
 708         return throwVMTypeError(globalObject, scope);
 709 
 710     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(vm);
 711     if (!gregorianDateTime)
 712         return JSValue::encode(jsNaN());
 713     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));
 714 }
 715 
 716 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDate(JSGlobalObject* globalObject, CallFrame* callFrame)
 717 {
 718     VM&amp; vm = globalObject-&gt;vm();
 719     auto scope = DECLARE_THROW_SCOPE(vm);
 720     JSValue thisValue = callFrame-&gt;thisValue();
 721     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 722     if (UNLIKELY(!thisDateObj))
 723         return throwVMTypeError(globalObject, scope);
 724 
 725     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(vm);
 726     if (!gregorianDateTime)
 727         return JSValue::encode(jsNaN());
 728     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));
 729 }
 730 
 731 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDate(JSGlobalObject* globalObject, CallFrame* callFrame)
 732 {
 733     VM&amp; vm = globalObject-&gt;vm();
 734     auto scope = DECLARE_THROW_SCOPE(vm);
 735     JSValue thisValue = callFrame-&gt;thisValue();
 736     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 737     if (UNLIKELY(!thisDateObj))
 738         return throwVMTypeError(globalObject, scope);
 739 
 740     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(vm);
 741     if (!gregorianDateTime)
 742         return JSValue::encode(jsNaN());
 743     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));
 744 }
 745 
 746 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDay(JSGlobalObject* globalObject, CallFrame* callFrame)
 747 {
 748     VM&amp; vm = globalObject-&gt;vm();
 749     auto scope = DECLARE_THROW_SCOPE(vm);
 750     JSValue thisValue = callFrame-&gt;thisValue();
 751     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 752     if (UNLIKELY(!thisDateObj))
 753         return throwVMTypeError(globalObject, scope);
 754 
 755     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(vm);
 756     if (!gregorianDateTime)
 757         return JSValue::encode(jsNaN());
 758     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));
 759 }
 760 
 761 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDay(JSGlobalObject* globalObject, CallFrame* callFrame)
 762 {
 763     VM&amp; vm = globalObject-&gt;vm();
 764     auto scope = DECLARE_THROW_SCOPE(vm);
 765     JSValue thisValue = callFrame-&gt;thisValue();
 766     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 767     if (UNLIKELY(!thisDateObj))
 768         return throwVMTypeError(globalObject, scope);
 769 
 770     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(vm);
 771     if (!gregorianDateTime)
 772         return JSValue::encode(jsNaN());
 773     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));
 774 }
 775 
 776 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetHours(JSGlobalObject* globalObject, CallFrame* callFrame)
 777 {
 778     VM&amp; vm = globalObject-&gt;vm();
 779     auto scope = DECLARE_THROW_SCOPE(vm);
 780     JSValue thisValue = callFrame-&gt;thisValue();
 781     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 782     if (UNLIKELY(!thisDateObj))
 783         return throwVMTypeError(globalObject, scope);
 784 
 785     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(vm);
 786     if (!gregorianDateTime)
 787         return JSValue::encode(jsNaN());
 788     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));
 789 }
 790 
 791 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCHours(JSGlobalObject* globalObject, CallFrame* callFrame)
 792 {
 793     VM&amp; vm = globalObject-&gt;vm();
 794     auto scope = DECLARE_THROW_SCOPE(vm);
 795     JSValue thisValue = callFrame-&gt;thisValue();
 796     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 797     if (UNLIKELY(!thisDateObj))
 798         return throwVMTypeError(globalObject, scope);
 799 
 800     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(vm);
 801     if (!gregorianDateTime)
 802         return JSValue::encode(jsNaN());
 803     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));
 804 }
 805 
 806 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMinutes(JSGlobalObject* globalObject, CallFrame* callFrame)
 807 {
 808     VM&amp; vm = globalObject-&gt;vm();
 809     auto scope = DECLARE_THROW_SCOPE(vm);
 810     JSValue thisValue = callFrame-&gt;thisValue();
 811     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 812     if (UNLIKELY(!thisDateObj))
 813         return throwVMTypeError(globalObject, scope);
 814 
 815     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(vm);
 816     if (!gregorianDateTime)
 817         return JSValue::encode(jsNaN());
 818     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));
 819 }
 820 
 821 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMinutes(JSGlobalObject* globalObject, CallFrame* callFrame)
 822 {
 823     VM&amp; vm = globalObject-&gt;vm();
 824     auto scope = DECLARE_THROW_SCOPE(vm);
 825     JSValue thisValue = callFrame-&gt;thisValue();
 826     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 827     if (UNLIKELY(!thisDateObj))
 828         return throwVMTypeError(globalObject, scope);
 829 
 830     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(vm);
 831     if (!gregorianDateTime)
 832         return JSValue::encode(jsNaN());
 833     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));
 834 }
 835 
 836 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetSeconds(JSGlobalObject* globalObject, CallFrame* callFrame)
 837 {
 838     VM&amp; vm = globalObject-&gt;vm();
 839     auto scope = DECLARE_THROW_SCOPE(vm);
 840     JSValue thisValue = callFrame-&gt;thisValue();
 841     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 842     if (UNLIKELY(!thisDateObj))
 843         return throwVMTypeError(globalObject, scope);
 844 
 845     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(vm);
 846     if (!gregorianDateTime)
 847         return JSValue::encode(jsNaN());
 848     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));
 849 }
 850 
 851 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCSeconds(JSGlobalObject* globalObject, CallFrame* callFrame)
 852 {
 853     VM&amp; vm = globalObject-&gt;vm();
 854     auto scope = DECLARE_THROW_SCOPE(vm);
 855     JSValue thisValue = callFrame-&gt;thisValue();
 856     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 857     if (UNLIKELY(!thisDateObj))
 858         return throwVMTypeError(globalObject, scope);
 859 
 860     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(vm);
 861     if (!gregorianDateTime)
 862         return JSValue::encode(jsNaN());
 863     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));
 864 }
 865 
 866 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMilliSeconds(JSGlobalObject* globalObject, CallFrame* callFrame)
 867 {
 868     VM&amp; vm = globalObject-&gt;vm();
 869     auto scope = DECLARE_THROW_SCOPE(vm);
 870     JSValue thisValue = callFrame-&gt;thisValue();
 871     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 872     if (UNLIKELY(!thisDateObj))
 873         return throwVMTypeError(globalObject, scope);
 874 
 875     double milli = thisDateObj-&gt;internalNumber();
 876     if (std::isnan(milli))
 877         return JSValue::encode(jsNaN());
 878 
 879     double secs = floor(milli / msPerSecond);
 880     double ms = milli - secs * msPerSecond;
 881     // Since timeClip makes internalNumber integer milliseconds, this result is always int32_t.
 882     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(ms)));
 883 }
 884 
 885 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMilliseconds(JSGlobalObject* globalObject, CallFrame* callFrame)
 886 {
 887     VM&amp; vm = globalObject-&gt;vm();
 888     auto scope = DECLARE_THROW_SCOPE(vm);
 889     JSValue thisValue = callFrame-&gt;thisValue();
 890     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 891     if (UNLIKELY(!thisDateObj))
 892         return throwVMTypeError(globalObject, scope);
 893 
 894     double milli = thisDateObj-&gt;internalNumber();
 895     if (std::isnan(milli))
 896         return JSValue::encode(jsNaN());
 897 
 898     double secs = floor(milli / msPerSecond);
 899     double ms = milli - secs * msPerSecond;
 900     // Since timeClip makes internalNumber integer milliseconds, this result is always int32_t.
 901     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(ms)));
 902 }
 903 
 904 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetTimezoneOffset(JSGlobalObject* globalObject, CallFrame* callFrame)
 905 {
 906     VM&amp; vm = globalObject-&gt;vm();
 907     auto scope = DECLARE_THROW_SCOPE(vm);
 908     JSValue thisValue = callFrame-&gt;thisValue();
 909     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 910     if (UNLIKELY(!thisDateObj))
 911         return throwVMTypeError(globalObject, scope);
 912 
 913     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(vm);
 914     if (!gregorianDateTime)
 915         return JSValue::encode(jsNaN());
 916     return JSValue::encode(jsNumber(-gregorianDateTime-&gt;utcOffsetInMinute()));
 917 }
 918 
 919 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetTime(JSGlobalObject* globalObject, CallFrame* callFrame)
 920 {
 921     VM&amp; vm = globalObject-&gt;vm();
 922     auto scope = DECLARE_THROW_SCOPE(vm);
 923     JSValue thisValue = callFrame-&gt;thisValue();
 924     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 925     if (UNLIKELY(!thisDateObj))
 926         return throwVMTypeError(globalObject, scope);
 927 
 928     double milli = timeClip(callFrame-&gt;argument(0).toNumber(globalObject));
 929     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 930     thisDateObj-&gt;setInternalNumber(milli);
 931     return JSValue::encode(jsNumber(milli));
 932 }
 933 
 934 static EncodedJSValue setNewValueFromTimeArgs(JSGlobalObject* globalObject, CallFrame* callFrame, int numArgsToUse, WTF::TimeType inputTimeType)
 935 {
 936     VM&amp; vm = globalObject-&gt;vm();
 937     auto scope = DECLARE_THROW_SCOPE(vm);
 938     JSValue thisValue = callFrame-&gt;thisValue();
 939     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 940     if (UNLIKELY(!thisDateObj))
 941         return throwVMTypeError(globalObject, scope);
 942 
 943     double milli = thisDateObj-&gt;internalNumber();
 944 
 945     if (!callFrame-&gt;argumentCount() || std::isnan(milli)) {
 946         thisDateObj-&gt;setInternalNumber(PNaN);
 947         return JSValue::encode(jsNaN());
 948     }
 949 
 950     double secs = floor(milli / msPerSecond);
 951     double ms = milli - secs * msPerSecond;
 952 
 953     const GregorianDateTime* other = inputTimeType == WTF::UTCTime
 954         ? thisDateObj-&gt;gregorianDateTimeUTC(vm)
 955         : thisDateObj-&gt;gregorianDateTime(vm);
 956     if (!other)
 957         return JSValue::encode(jsNaN());
 958 
 959     GregorianDateTime gregorianDateTime(*other);
 960     bool success = fillStructuresUsingTimeArgs(globalObject, callFrame, numArgsToUse, &amp;ms, &amp;gregorianDateTime);
 961     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 962     if (!success) {
 963         thisDateObj-&gt;setInternalNumber(PNaN);
 964         return JSValue::encode(jsNaN());
 965     }
 966 
 967     double newUTCDate = gregorianDateTimeToMS(vm, gregorianDateTime, ms, inputTimeType);
 968     double result = timeClip(newUTCDate);
 969     thisDateObj-&gt;setInternalNumber(result);
 970     return JSValue::encode(jsNumber(result));
 971 }
 972 
 973 static EncodedJSValue setNewValueFromDateArgs(JSGlobalObject* globalObject, CallFrame* callFrame, int numArgsToUse, WTF::TimeType inputTimeType)
 974 {
 975     VM&amp; vm = globalObject-&gt;vm();
 976     auto scope = DECLARE_THROW_SCOPE(vm);
 977     JSValue thisValue = callFrame-&gt;thisValue();
 978     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 979     if (UNLIKELY(!thisDateObj))
 980         return throwVMTypeError(globalObject, scope);
 981 
 982     if (!callFrame-&gt;argumentCount()) {
 983         thisDateObj-&gt;setInternalNumber(PNaN);
 984         return JSValue::encode(jsNaN());
 985     }
 986 
 987     double milli = thisDateObj-&gt;internalNumber();
 988     double ms = 0;
 989 
 990     GregorianDateTime gregorianDateTime;
 991     if (numArgsToUse == 3 &amp;&amp; std::isnan(milli))
 992         msToGregorianDateTime(vm, 0, WTF::UTCTime, gregorianDateTime);
 993     else {
 994         ms = milli - floor(milli / msPerSecond) * msPerSecond;
 995         const GregorianDateTime* other = inputTimeType == WTF::UTCTime
 996             ? thisDateObj-&gt;gregorianDateTimeUTC(vm)
 997             : thisDateObj-&gt;gregorianDateTime(vm);
 998         if (!other)
 999             return JSValue::encode(jsNaN());
1000         gregorianDateTime = *other;
1001     }
1002 
1003     bool success = fillStructuresUsingDateArgs(globalObject, callFrame, numArgsToUse, &amp;ms, &amp;gregorianDateTime);
1004     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1005     if (!success) {
1006         thisDateObj-&gt;setInternalNumber(PNaN);
1007         return JSValue::encode(jsNaN());
1008     }
1009 
1010     double newUTCDate = gregorianDateTimeToMS(vm, gregorianDateTime, ms, inputTimeType);
1011     double result = timeClip(newUTCDate);
1012     thisDateObj-&gt;setInternalNumber(result);
1013     return JSValue::encode(jsNumber(result));
1014 }
1015 
1016 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMilliSeconds(JSGlobalObject* globalObject, CallFrame* callFrame)
1017 {
1018     return setNewValueFromTimeArgs(globalObject, callFrame, 1, WTF::LocalTime);
1019 }
1020 
1021 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMilliseconds(JSGlobalObject* globalObject, CallFrame* callFrame)
1022 {
1023     return setNewValueFromTimeArgs(globalObject, callFrame, 1, WTF::UTCTime);
1024 }
1025 
1026 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetSeconds(JSGlobalObject* globalObject, CallFrame* callFrame)
1027 {
1028     return setNewValueFromTimeArgs(globalObject, callFrame, 2, WTF::LocalTime);
1029 }
1030 
1031 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCSeconds(JSGlobalObject* globalObject, CallFrame* callFrame)
1032 {
1033     return setNewValueFromTimeArgs(globalObject, callFrame, 2, WTF::UTCTime);
1034 }
1035 
1036 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMinutes(JSGlobalObject* globalObject, CallFrame* callFrame)
1037 {
1038     return setNewValueFromTimeArgs(globalObject, callFrame, 3, WTF::LocalTime);
1039 }
1040 
1041 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMinutes(JSGlobalObject* globalObject, CallFrame* callFrame)
1042 {
1043     return setNewValueFromTimeArgs(globalObject, callFrame, 3, WTF::UTCTime);
1044 }
1045 
1046 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetHours(JSGlobalObject* globalObject, CallFrame* callFrame)
1047 {
1048     return setNewValueFromTimeArgs(globalObject, callFrame, 4, WTF::LocalTime);
1049 }
1050 
1051 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCHours(JSGlobalObject* globalObject, CallFrame* callFrame)
1052 {
1053     return setNewValueFromTimeArgs(globalObject, callFrame, 4, WTF::UTCTime);
1054 }
1055 
1056 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetDate(JSGlobalObject* globalObject, CallFrame* callFrame)
1057 {
1058     return setNewValueFromDateArgs(globalObject, callFrame, 1, WTF::LocalTime);
1059 }
1060 
1061 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCDate(JSGlobalObject* globalObject, CallFrame* callFrame)
1062 {
1063     return setNewValueFromDateArgs(globalObject, callFrame, 1, WTF::UTCTime);
1064 }
1065 
1066 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMonth(JSGlobalObject* globalObject, CallFrame* callFrame)
1067 {
1068     return setNewValueFromDateArgs(globalObject, callFrame, 2, WTF::LocalTime);
1069 }
1070 
1071 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMonth(JSGlobalObject* globalObject, CallFrame* callFrame)
1072 {
1073     return setNewValueFromDateArgs(globalObject, callFrame, 2, WTF::UTCTime);
1074 }
1075 
1076 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetFullYear(JSGlobalObject* globalObject, CallFrame* callFrame)
1077 {
1078     return setNewValueFromDateArgs(globalObject, callFrame, 3, WTF::LocalTime);
1079 }
1080 
1081 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCFullYear(JSGlobalObject* globalObject, CallFrame* callFrame)
1082 {
1083     return setNewValueFromDateArgs(globalObject, callFrame, 3, WTF::UTCTime);
1084 }
1085 
1086 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetYear(JSGlobalObject* globalObject, CallFrame* callFrame)
1087 {
1088     VM&amp; vm = globalObject-&gt;vm();
1089     auto scope = DECLARE_THROW_SCOPE(vm);
1090     JSValue thisValue = callFrame-&gt;thisValue();
1091     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
1092     if (UNLIKELY(!thisDateObj))
1093         return throwVMTypeError(globalObject, scope);
1094 
1095     if (!callFrame-&gt;argumentCount()) {
1096         thisDateObj-&gt;setInternalNumber(PNaN);
1097         return JSValue::encode(jsNaN());
1098     }
1099 
1100     double milli = thisDateObj-&gt;internalNumber();
1101     double ms = 0;
1102 
1103     GregorianDateTime gregorianDateTime;
1104     if (std::isnan(milli))
1105         // Based on ECMA 262 B.2.5 (setYear)
1106         // the time must be reset to +0 if it is NaN.
1107         msToGregorianDateTime(vm, 0, WTF::UTCTime, gregorianDateTime);
1108     else {
1109         double secs = floor(milli / msPerSecond);
1110         ms = milli - secs * msPerSecond;
1111         if (const GregorianDateTime* other = thisDateObj-&gt;gregorianDateTime(vm))
1112             gregorianDateTime = *other;
1113     }
1114 
1115     double year = callFrame-&gt;argument(0).toIntegerPreserveNaN(globalObject);
1116     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1117     if (!std::isfinite(year)) {
1118         thisDateObj-&gt;setInternalNumber(PNaN);
1119         return JSValue::encode(jsNaN());
1120     }
1121 
1122     gregorianDateTime.setYear(toInt32((year &gt;= 0 &amp;&amp; year &lt;= 99) ? (year + 1900) : year));
1123     double timeInMilliseconds = gregorianDateTimeToMS(vm, gregorianDateTime, ms, WTF::LocalTime);
1124     double result = timeClip(timeInMilliseconds);
1125     thisDateObj-&gt;setInternalNumber(result);
1126     return JSValue::encode(jsNumber(result));
1127 }
1128 
1129 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetYear(JSGlobalObject* globalObject, CallFrame* callFrame)
1130 {
1131     VM&amp; vm = globalObject-&gt;vm();
1132     auto scope = DECLARE_THROW_SCOPE(vm);
1133     JSValue thisValue = callFrame-&gt;thisValue();
1134     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
1135     if (UNLIKELY(!thisDateObj))
1136         return throwVMTypeError(globalObject, scope);
1137 
1138     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(vm);
1139     if (!gregorianDateTime)
1140         return JSValue::encode(jsNaN());
1141 
1142     // NOTE: IE returns the full year even in getYear.
1143     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year() - 1900));
1144 }
1145 
1146 EncodedJSValue JSC_HOST_CALL dateProtoFuncToJSON(JSGlobalObject* globalObject, CallFrame* callFrame)
1147 {
1148     VM&amp; vm = globalObject-&gt;vm();
1149     auto scope = DECLARE_THROW_SCOPE(vm);
1150     JSValue thisValue = callFrame-&gt;thisValue();
1151     JSObject* object = thisValue.toObject(globalObject);
1152     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1153 
1154     JSValue timeValue = object-&gt;toPrimitive(globalObject, PreferNumber);
1155     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1156     if (timeValue.isNumber() &amp;&amp; !std::isfinite(timeValue.asNumber()))
1157         return JSValue::encode(jsNull());
1158 
1159     JSValue toISOValue = object-&gt;get(globalObject, vm.propertyNames-&gt;toISOString);
1160     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1161 
1162     CallData callData;
1163     CallType callType = getCallData(vm, toISOValue, callData);
1164     if (callType == CallType::None)
1165         return throwVMTypeError(globalObject, scope, &quot;toISOString is not a function&quot;_s);
1166 
1167     JSValue result = call(globalObject, asObject(toISOValue), callType, callData, object, *vm.emptyList);
1168     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1169     return JSValue::encode(result);
1170 }
1171 
1172 } // namespace JSC
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WTF/wtf/HashTable.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HashTable.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HashTraits.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/HashTable.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (C) 2005, 2006, 2007, 2008, 2011, 2012, 2015 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2005-2019 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2008 David Levin &lt;levin@chromium.org&gt;
   *
   * This library is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Library General Public
   * License as published by the Free Software Foundation; either
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,10 +26,11 @@</span>
  #include &lt;mutex&gt;
  #include &lt;string.h&gt;
  #include &lt;type_traits&gt;
  #include &lt;utility&gt;
  #include &lt;wtf/Assertions.h&gt;
<span class="udiff-line-added">+ #include &lt;wtf/DebugHeap.h&gt;</span>
  #include &lt;wtf/FastMalloc.h&gt;
  #include &lt;wtf/HashTraits.h&gt;
  #include &lt;wtf/Lock.h&gt;
  #include &lt;wtf/MathExtras.h&gt;
  #include &lt;wtf/RandomNumber.h&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -43,10 +44,12 @@</span>
  #include &lt;wtf/DataLog.h&gt;
  #endif
  
  namespace WTF {
  
<span class="udiff-line-added">+ DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(HashTable);</span>
<span class="udiff-line-added">+ </span>
  // Enables internal WTF consistency checks that are invoked automatically. Non-WTF callers can call checkTableConsistency() even if internal checks are disabled.
  #define CHECK_HASHTABLE_CONSISTENCY 0
  
  #ifdef NDEBUG
  #define CHECK_HASHTABLE_ITERATORS 0
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -298,10 +301,51 @@</span>
          bool isNewEntry;
  
          explicit operator bool() const { return isNewEntry; }
      };
  
<span class="udiff-line-added">+     // HashTableCapacityForSize computes the upper power of two capacity to hold the size parameter.</span>
<span class="udiff-line-added">+     // This is done at compile time to initialize the HashTraits.</span>
<span class="udiff-line-added">+     template&lt;unsigned size&gt;</span>
<span class="udiff-line-added">+     struct HashTableCapacityForSize {</span>
<span class="udiff-line-added">+         // Load-factor for small table is 75%.</span>
<span class="udiff-line-added">+         static constexpr unsigned smallMaxLoadNumerator = 3;</span>
<span class="udiff-line-added">+         static constexpr unsigned smallMaxLoadDenominator = 4;</span>
<span class="udiff-line-added">+         // Load-factor for large table is 50%.</span>
<span class="udiff-line-added">+         static constexpr unsigned largeMaxLoadNumerator = 1;</span>
<span class="udiff-line-added">+         static constexpr unsigned largeMaxLoadDenominator = 2;</span>
<span class="udiff-line-added">+         static constexpr unsigned maxSmallTableCapacity = 1024;</span>
<span class="udiff-line-added">+         static constexpr unsigned minLoad = 6;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         static constexpr bool shouldExpand(uint64_t keyAndDeleteCount, uint64_t tableSize)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             if (tableSize &lt;= maxSmallTableCapacity)</span>
<span class="udiff-line-added">+                 return keyAndDeleteCount * smallMaxLoadDenominator &gt;= tableSize * smallMaxLoadNumerator;</span>
<span class="udiff-line-added">+             return keyAndDeleteCount * largeMaxLoadDenominator &gt;= tableSize * largeMaxLoadNumerator;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         static constexpr unsigned capacityForSize(uint32_t sizeArg)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             if (!sizeArg)</span>
<span class="udiff-line-added">+                 return 0;</span>
<span class="udiff-line-added">+             constexpr unsigned maxCapacity = 1U &lt;&lt; 31;</span>
<span class="udiff-line-added">+             UNUSED_PARAM(maxCapacity);</span>
<span class="udiff-line-added">+             ASSERT_UNDER_CONSTEXPR_CONTEXT(sizeArg &lt;= maxCapacity);</span>
<span class="udiff-line-added">+             uint32_t capacity = roundUpToPowerOfTwo(sizeArg);</span>
<span class="udiff-line-added">+             ASSERT_UNDER_CONSTEXPR_CONTEXT(capacity &lt;= maxCapacity);</span>
<span class="udiff-line-added">+             if (shouldExpand(sizeArg, capacity)) {</span>
<span class="udiff-line-added">+                 ASSERT_UNDER_CONSTEXPR_CONTEXT((static_cast&lt;uint64_t&gt;(capacity) * 2) &lt;= maxCapacity);</span>
<span class="udiff-line-added">+                 return capacity * 2;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return capacity;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         static constexpr unsigned value = capacityForSize(size);</span>
<span class="udiff-line-added">+         static_assert(size &gt; 0, &quot;HashTableNonZeroMinimumCapacity&quot;);</span>
<span class="udiff-line-added">+         static_assert(!static_cast&lt;unsigned&gt;(value &gt;&gt; 31), &quot;HashTableNoCapacityOverflow&quot;);</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      class HashTable {
      public:
          typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
          typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -309,10 +353,12 @@</span>
          typedef Key KeyType;
          typedef Value ValueType;
          typedef IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType;
          typedef HashTableAddResult&lt;iterator&gt; AddResult;
  
<span class="udiff-line-added">+         using HashTableSizePolicy = HashTableCapacityForSize&lt;1&gt;;</span>
<span class="udiff-line-added">+ </span>
  #if DUMP_HASHTABLE_STATS_PER_TABLE
          struct Stats {
              WTF_MAKE_STRUCT_FAST_ALLOCATED;
  
              Stats()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -379,11 +425,11 @@</span>
  #else
              invalidateIterators();
  #endif
  
              if (m_table)
<span class="udiff-line-modified-removed">-                 deallocateTable(m_table, m_tableSize);</span>
<span class="udiff-line-modified-added">+                 deallocateTable(m_table);</span>
  #if CHECK_HASHTABLE_USE_AFTER_DESTRUCTION
              m_table = (ValueType*)(uintptr_t)0xbbadbeef;
  #endif
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -396,44 +442,45 @@</span>
  
          // When the hash table is empty, just return the same iterator for end as for begin.
          // This is more efficient because we don&#39;t have to skip all the empty and deleted
          // buckets, and iterating an empty table is a common case that&#39;s worth optimizing.
          iterator begin() { return isEmpty() ? end() : makeIterator(m_table); }
<span class="udiff-line-modified-removed">-         iterator end() { return makeKnownGoodIterator(m_table + m_tableSize); }</span>
<span class="udiff-line-modified-added">+         iterator end() { return makeKnownGoodIterator(m_table + tableSize()); }</span>
          const_iterator begin() const { return isEmpty() ? end() : makeConstIterator(m_table); }
<span class="udiff-line-modified-removed">-         const_iterator end() const { return makeKnownGoodConstIterator(m_table + m_tableSize); }</span>
<span class="udiff-line-modified-added">+         const_iterator end() const { return makeKnownGoodConstIterator(m_table + tableSize()); }</span>
  
          iterator random()
          {
              if (isEmpty())
                  return end();
  
              while (1) {
<span class="udiff-line-modified-removed">-                 auto&amp; bucket = m_table[weakRandomUint32() &amp; m_tableSizeMask];</span>
<span class="udiff-line-modified-added">+                 auto&amp; bucket = m_table[weakRandomUint32() &amp; tableSizeMask()];</span>
                  if (!isEmptyOrDeletedBucket(bucket))
                      return makeKnownGoodIterator(&amp;bucket);
              };
          }
  
          const_iterator random() const { return static_cast&lt;const_iterator&gt;(const_cast&lt;HashTable*&gt;(this)-&gt;random()); }
  
<span class="udiff-line-modified-removed">-         unsigned size() const { return m_keyCount; }</span>
<span class="udiff-line-modified-removed">-         unsigned capacity() const { return m_tableSize; }</span>
<span class="udiff-line-modified-removed">-         bool isEmpty() const { return !m_keyCount; }</span>
<span class="udiff-line-modified-added">+         unsigned size() const { return keyCount(); }</span>
<span class="udiff-line-modified-added">+         unsigned capacity() const { return tableSize(); }</span>
<span class="udiff-line-modified-added">+         bool isEmpty() const { return !keyCount(); }</span>
  
          void reserveInitialCapacity(unsigned keyCount)
          {
              ASSERT(!m_table);
<span class="udiff-line-modified-removed">-             ASSERT(!m_tableSize);</span>
<span class="udiff-line-removed">-             ASSERT(!m_deletedCount);</span>
<span class="udiff-line-modified-added">+             ASSERT(!tableSize());</span>
  
              unsigned minimumTableSize = KeyTraits::minimumTableSize;
              unsigned newTableSize = std::max(minimumTableSize, computeBestTableSize(keyCount));
  
<span class="udiff-line-removed">-             m_tableSize = newTableSize;</span>
<span class="udiff-line-removed">-             m_tableSizeMask = newTableSize - 1;</span>
              m_table = allocateTable(newTableSize);
<span class="udiff-line-added">+             setTableSize(newTableSize);</span>
<span class="udiff-line-added">+             setTableSizeMask(newTableSize - 1);</span>
<span class="udiff-line-added">+             setDeletedCount(0);</span>
<span class="udiff-line-added">+             setKeyCount(0);</span>
          }
  
          AddResult add(const ValueType&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); }
          AddResult add(ValueType&amp;&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -466,11 +513,11 @@</span>
  
          ValueType* lookup(const Key&amp; key) { return lookup&lt;IdentityTranslatorType&gt;(key); }
          template&lt;typename HashTranslator, typename T&gt; ValueType* lookup(const T&amp;);
          template&lt;typename HashTranslator, typename T&gt; ValueType* inlineLookup(const T&amp;);
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
          void checkTableConsistency() const;
  #else
          static void checkTableConsistency() { }
  #endif
  #if CHECK_HASHTABLE_CONSISTENCY
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -481,11 +528,11 @@</span>
          static void internalCheckTableConsistency() { }
  #endif
  
      private:
          static ValueType* allocateTable(unsigned size);
<span class="udiff-line-modified-removed">-         static void deallocateTable(ValueType* table, unsigned size);</span>
<span class="udiff-line-modified-added">+         static void deallocateTable(ValueType* table);</span>
  
          typedef std::pair&lt;ValueType*, bool&gt; LookupType;
          typedef std::pair&lt;LookupType, unsigned&gt; FullLookupType;
  
          LookupType lookupForWriting(const Key&amp; key) { return lookupForWriting&lt;IdentityTranslatorType&gt;(key); };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -499,15 +546,15 @@</span>
          void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);
          void removeAndInvalidate(ValueType*);
          void remove(ValueType*);
  
          static constexpr unsigned computeBestTableSize(unsigned keyCount);
<span class="udiff-line-modified-removed">-         bool shouldExpand() const { return (m_keyCount + m_deletedCount) * m_maxLoad &gt;= m_tableSize; }</span>
<span class="udiff-line-modified-removed">-         bool mustRehashInPlace() const { return m_keyCount * m_minLoad &lt; m_tableSize * 2; }</span>
<span class="udiff-line-modified-removed">-         bool shouldShrink() const { return m_keyCount * m_minLoad &lt; m_tableSize &amp;&amp; m_tableSize &gt; KeyTraits::minimumTableSize; }</span>
<span class="udiff-line-modified-added">+         bool shouldExpand() const { return HashTableSizePolicy::shouldExpand(keyCount() + deletedCount(), tableSize()); }</span>
<span class="udiff-line-modified-added">+         bool mustRehashInPlace() const { return keyCount() * minLoad &lt; tableSize() * 2; }</span>
<span class="udiff-line-modified-added">+         bool shouldShrink() const { return keyCount() * minLoad &lt; tableSize() &amp;&amp; tableSize() &gt; KeyTraits::minimumTableSize; }</span>
          ValueType* expand(ValueType* entry = nullptr);
<span class="udiff-line-modified-removed">-         void shrink() { rehash(m_tableSize / 2, nullptr); }</span>
<span class="udiff-line-modified-added">+         void shrink() { rehash(tableSize() / 2, nullptr); }</span>
          void shrinkToBestSize();
  
          void deleteReleasedWeakBuckets();
  
          ValueType* rehash(unsigned newTableSize, ValueType* entry);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -517,16 +564,16 @@</span>
          static void deleteBucket(ValueType&amp; bucket) { hashTraitsDeleteBucket&lt;Traits&gt;(bucket); }
  
          FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)
              { return FullLookupType(LookupType(position, found), hash); }
  
<span class="udiff-line-modified-removed">-         iterator makeIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize); }</span>
<span class="udiff-line-modified-removed">-         const_iterator makeConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize); }</span>
<span class="udiff-line-modified-removed">-         iterator makeKnownGoodIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }</span>
<span class="udiff-line-modified-removed">-         const_iterator makeKnownGoodConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }</span>
<span class="udiff-line-modified-added">+         iterator makeIterator(ValueType* pos) { return iterator(this, pos, m_table + tableSize()); }</span>
<span class="udiff-line-modified-added">+         const_iterator makeConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + tableSize()); }</span>
<span class="udiff-line-modified-added">+         iterator makeKnownGoodIterator(ValueType* pos) { return iterator(this, pos, m_table + tableSize(), HashItemKnownGood); }</span>
<span class="udiff-line-modified-added">+         const_iterator makeKnownGoodConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + tableSize(), HashItemKnownGood); }</span>
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
          void checkTableConsistencyExceptSize() const;
  #else
          static void checkTableConsistencyExceptSize() { }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -534,18 +581,35 @@</span>
          void invalidateIterators();
  #else
          static void invalidateIterators() { }
  #endif
  
<span class="udiff-line-modified-removed">-         static const unsigned m_maxLoad = 2;</span>
<span class="udiff-line-modified-removed">-         static const unsigned m_minLoad = 6;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         ValueType* m_table;</span>
<span class="udiff-line-modified-removed">-         unsigned m_tableSize;</span>
<span class="udiff-line-modified-removed">-         unsigned m_tableSizeMask;</span>
<span class="udiff-line-modified-removed">-         unsigned m_keyCount;</span>
<span class="udiff-line-modified-removed">-         unsigned m_deletedCount;</span>
<span class="udiff-line-modified-added">+         // Load-factor for small table is 75%.</span>
<span class="udiff-line-modified-added">+         static constexpr unsigned smallMaxLoadNumerator = HashTableSizePolicy::smallMaxLoadNumerator;</span>
<span class="udiff-line-modified-added">+         static constexpr unsigned smallMaxLoadDenominator = HashTableSizePolicy::smallMaxLoadDenominator;</span>
<span class="udiff-line-modified-added">+         // Load-factor for large table is 50%.</span>
<span class="udiff-line-modified-added">+         static constexpr unsigned largeMaxLoadNumerator = HashTableSizePolicy::largeMaxLoadNumerator;</span>
<span class="udiff-line-modified-added">+         static constexpr unsigned largeMaxLoadDenominator = HashTableSizePolicy::largeMaxLoadDenominator;</span>
<span class="udiff-line-modified-added">+         static constexpr unsigned maxSmallTableCapacity = HashTableSizePolicy::maxSmallTableCapacity;</span>
<span class="udiff-line-modified-added">+         static constexpr unsigned minLoad = HashTableSizePolicy::minLoad;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         static constexpr int tableSizeOffset = -1;</span>
<span class="udiff-line-added">+         static constexpr int tableSizeMaskOffset = -2;</span>
<span class="udiff-line-added">+         static constexpr int keyCountOffset = -3;</span>
<span class="udiff-line-added">+         static constexpr int deletedCountOffset = -4;</span>
<span class="udiff-line-added">+         static constexpr unsigned metadataSize = 4 * sizeof(unsigned);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         unsigned tableSize() const { return m_table ? reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[tableSizeOffset] : 0; }</span>
<span class="udiff-line-added">+         void setTableSize(unsigned size) const { ASSERT(m_table); reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[tableSizeOffset] = size; }</span>
<span class="udiff-line-added">+         unsigned tableSizeMask() const { ASSERT(m_table); return m_table ? reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[tableSizeMaskOffset] : 0; }</span>
<span class="udiff-line-added">+         void setTableSizeMask(unsigned mask) { ASSERT(m_table); reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[tableSizeMaskOffset] = mask; }</span>
<span class="udiff-line-added">+         unsigned keyCount() const { return m_table ? reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[keyCountOffset] : 0; }</span>
<span class="udiff-line-added">+         void setKeyCount(unsigned count) const { ASSERT(m_table); reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[keyCountOffset] = count; }</span>
<span class="udiff-line-added">+         unsigned deletedCount() const { ASSERT(m_table); return reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[deletedCountOffset]; }</span>
<span class="udiff-line-added">+         void setDeletedCount(unsigned count) const { ASSERT(m_table); reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[deletedCountOffset] = count; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ValueType* m_table { nullptr };</span>
  
  #if CHECK_HASHTABLE_ITERATORS
      public:
          // All access to m_iterators should be guarded with m_mutex.
          mutable const_iterator* m_iterators;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -557,55 +621,13 @@</span>
      public:
          mutable std::unique_ptr&lt;Stats&gt; m_stats;
  #endif
      };
  
<span class="udiff-line-removed">-     // Set all the bits to one after the most significant bit: 00110101010 -&gt; 00111111111.</span>
<span class="udiff-line-removed">-     template&lt;unsigned size&gt; struct OneifyLowBits;</span>
<span class="udiff-line-removed">-     template&lt;&gt;</span>
<span class="udiff-line-removed">-     struct OneifyLowBits&lt;0&gt; {</span>
<span class="udiff-line-removed">-         static const unsigned value = 0;</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">-     template&lt;unsigned number&gt;</span>
<span class="udiff-line-removed">-     struct OneifyLowBits {</span>
<span class="udiff-line-removed">-         static const unsigned value = number | OneifyLowBits&lt;(number &gt;&gt; 1)&gt;::value;</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">-     // Compute the first power of two integer that is an upper bound of the parameter &#39;number&#39;.</span>
<span class="udiff-line-removed">-     template&lt;unsigned number&gt;</span>
<span class="udiff-line-removed">-     struct UpperPowerOfTwoBound {</span>
<span class="udiff-line-removed">-         static const unsigned value = (OneifyLowBits&lt;number - 1&gt;::value + 1) * 2;</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Because power of two numbers are the limit of maxLoad, their capacity is twice the</span>
<span class="udiff-line-removed">-     // UpperPowerOfTwoBound, or 4 times their values.</span>
<span class="udiff-line-removed">-     template&lt;unsigned size, bool isPowerOfTwo&gt; struct HashTableCapacityForSizeSplitter;</span>
<span class="udiff-line-removed">-     template&lt;unsigned size&gt;</span>
<span class="udiff-line-removed">-     struct HashTableCapacityForSizeSplitter&lt;size, true&gt; {</span>
<span class="udiff-line-removed">-         static const unsigned value = size * 4;</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">-     template&lt;unsigned size&gt;</span>
<span class="udiff-line-removed">-     struct HashTableCapacityForSizeSplitter&lt;size, false&gt; {</span>
<span class="udiff-line-removed">-         static const unsigned value = UpperPowerOfTwoBound&lt;size&gt;::value;</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // HashTableCapacityForSize computes the upper power of two capacity to hold the size parameter.</span>
<span class="udiff-line-removed">-     // This is done at compile time to initialize the HashTraits.</span>
<span class="udiff-line-removed">-     template&lt;unsigned size&gt;</span>
<span class="udiff-line-removed">-     struct HashTableCapacityForSize {</span>
<span class="udiff-line-removed">-         static const unsigned value = HashTableCapacityForSizeSplitter&lt;size, !(size &amp; (size - 1))&gt;::value;</span>
<span class="udiff-line-removed">-         COMPILE_ASSERT(size &gt; 0, HashTableNonZeroMinimumCapacity);</span>
<span class="udiff-line-removed">-         COMPILE_ASSERT(!static_cast&lt;unsigned&gt;(value &gt;&gt; 31), HashTableNoCapacityOverflow);</span>
<span class="udiff-line-removed">-         COMPILE_ASSERT(value &gt; (2 * size), HashTableCapacityHoldsContentSize);</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable()
<span class="udiff-line-modified-removed">-         : m_table(0)</span>
<span class="udiff-line-removed">-         , m_tableSize(0)</span>
<span class="udiff-line-removed">-         , m_tableSizeMask(0)</span>
<span class="udiff-line-removed">-         , m_keyCount(0)</span>
<span class="udiff-line-removed">-         , m_deletedCount(0)</span>
<span class="udiff-line-modified-added">+         : m_table(nullptr)</span>
  #if CHECK_HASHTABLE_ITERATORS
          , m_iterators(0)
          , m_mutex(makeUnique&lt;Lock&gt;())
  #endif
  #if DUMP_HASHTABLE_STATS_PER_TABLE
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -622,19 +644,19 @@</span>
          key ^= (key &lt;&lt; 2);
          key ^= (key &gt;&gt; 20);
          return key;
      }
  
<span class="udiff-line-modified-removed">- #if ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if !ASSERT_ENABLED</span>
  
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      template&lt;typename HashTranslator, typename T&gt;
      inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp;)
      {
      }
  
<span class="udiff-line-modified-removed">- #else</span>
<span class="udiff-line-modified-added">+ #else // ASSERT_ENABLED</span>
  
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      template&lt;typename HashTranslator, typename T&gt;
      void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp; key)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -646,11 +668,11 @@</span>
          ValueType&amp; deletedValue = *deletedValuePtr;
          Traits::constructDeletedValue(deletedValue);
          ASSERT(!HashTranslator::equal(Extractor::extract(deletedValue), key));
      }
  
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+ #endif // ASSERT_ENABLED</span>
  
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      template&lt;typename HashTranslator, typename T&gt;
      inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::lookup(const T&amp; key) -&gt; ValueType*
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -662,18 +684,18 @@</span>
      ALWAYS_INLINE auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::inlineLookup(const T&amp; key) -&gt; ValueType*
      {
          checkKey&lt;HashTranslator&gt;(key);
  
          unsigned k = 0;
<span class="udiff-line-removed">-         unsigned sizeMask = m_tableSizeMask;</span>
          ValueType* table = m_table;
<span class="udiff-line-added">+         if (!table)</span>
<span class="udiff-line-added">+             return nullptr;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         unsigned sizeMask = tableSizeMask();</span>
          unsigned h = HashTranslator::hash(key);
          unsigned i = h &amp; sizeMask;
  
<span class="udiff-line-removed">-         if (!table)</span>
<span class="udiff-line-removed">-             return 0;</span>
<span class="udiff-line-removed">- </span>
  #if DUMP_HASHTABLE_STATS
          ++HashTableStats::numAccesses;
          unsigned probeCount = 0;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -720,11 +742,11 @@</span>
          ASSERT(m_table);
          checkKey&lt;HashTranslator&gt;(key);
  
          unsigned k = 0;
          ValueType* table = m_table;
<span class="udiff-line-modified-removed">-         unsigned sizeMask = m_tableSizeMask;</span>
<span class="udiff-line-modified-added">+         unsigned sizeMask = tableSizeMask();</span>
          unsigned h = HashTranslator::hash(key);
          unsigned i = h &amp; sizeMask;
  
  #if DUMP_HASHTABLE_STATS
          ++HashTableStats::numAccesses;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -781,11 +803,11 @@</span>
          ASSERT(m_table);
          checkKey&lt;HashTranslator&gt;(key);
  
          unsigned k = 0;
          ValueType* table = m_table;
<span class="udiff-line-modified-removed">-         unsigned sizeMask = m_tableSizeMask;</span>
<span class="udiff-line-modified-added">+         unsigned sizeMask = tableSizeMask();</span>
          unsigned h = HashTranslator::hash(key);
          unsigned i = h &amp; sizeMask;
  
  #if DUMP_HASHTABLE_STATS
          ++HashTableStats::numAccesses;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -847,11 +869,11 @@</span>
  
          internalCheckTableConsistency();
  
          unsigned k = 0;
          ValueType* table = m_table;
<span class="udiff-line-modified-removed">-         unsigned sizeMask = m_tableSizeMask;</span>
<span class="udiff-line-modified-added">+         unsigned sizeMask = tableSizeMask();</span>
          unsigned h = HashTranslator::hash(key);
          unsigned i = h &amp; sizeMask;
  
  #if DUMP_HASHTABLE_STATS
          ++HashTableStats::numAccesses;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -928,11 +950,11 @@</span>
  
          ASSERT(m_table);
  
          unsigned k = 0;
          ValueType* table = m_table;
<span class="udiff-line-modified-removed">-         unsigned sizeMask = m_tableSizeMask;</span>
<span class="udiff-line-modified-added">+         unsigned sizeMask = tableSizeMask();</span>
          unsigned h = HashTranslator::hash(key);
          unsigned i = h &amp; sizeMask;
  
  #if DUMP_HASHTABLE_STATS
          ++HashTableStats::numAccesses;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -982,15 +1004,15 @@</span>
          }
  
          if (deletedEntry) {
              initializeBucket(*deletedEntry);
              entry = deletedEntry;
<span class="udiff-line-modified-removed">-             --m_deletedCount;</span>
<span class="udiff-line-modified-added">+             setDeletedCount(deletedCount() - 1);</span>
          }
  
          HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra));
<span class="udiff-line-modified-removed">-         ++m_keyCount;</span>
<span class="udiff-line-modified-added">+         setKeyCount(keyCount() + 1);</span>
  
          if (shouldExpand())
              entry = expand(entry);
  
          internalCheckTableConsistency();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1020,15 +1042,15 @@</span>
          if (found)
              return AddResult(makeKnownGoodIterator(entry), false);
  
          if (isDeletedBucket(*entry)) {
              initializeBucket(*entry);
<span class="udiff-line-modified-removed">-             --m_deletedCount;</span>
<span class="udiff-line-modified-added">+             setDeletedCount(deletedCount() - 1);</span>
          }
  
          HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra), h);
<span class="udiff-line-modified-removed">-         ++m_keyCount;</span>
<span class="udiff-line-modified-added">+         setKeyCount(keyCount() + 1);</span>
  
          if (shouldExpand())
              entry = expand(entry);
  
          internalCheckTableConsistency();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1118,12 +1140,12 @@</span>
  #if DUMP_HASHTABLE_STATS_PER_TABLE
          ++m_stats-&gt;numRemoves;
  #endif
  
          deleteBucket(*pos);
<span class="udiff-line-modified-removed">-         ++m_deletedCount;</span>
<span class="udiff-line-modified-removed">-         --m_keyCount;</span>
<span class="udiff-line-modified-added">+         setDeletedCount(deletedCount() + 1);</span>
<span class="udiff-line-modified-added">+         setKeyCount(keyCount() - 1);</span>
  
          if (shouldShrink())
              shrink();
  
          internalCheckTableConsistency();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1170,23 +1192,25 @@</span>
          // make a function call, which prevents the compiler from keeping
          // the values in register.
          unsigned removedBucketCount = 0;
          ValueType* table = m_table;
  
<span class="udiff-line-modified-removed">-         for (unsigned i = m_tableSize; i--;) {</span>
<span class="udiff-line-modified-added">+         for (unsigned i = tableSize(); i--;) {</span>
              ValueType&amp; bucket = table[i];
              if (isEmptyOrDeletedBucket(bucket))
                  continue;
  
              if (!functor(bucket))
                  continue;
  
              deleteBucket(bucket);
              ++removedBucketCount;
          }
<span class="udiff-line-modified-removed">-         m_deletedCount += removedBucketCount;</span>
<span class="udiff-line-modified-removed">-         m_keyCount -= removedBucketCount;</span>
<span class="udiff-line-modified-added">+         if (removedBucketCount) {</span>
<span class="udiff-line-modified-added">+             setDeletedCount(deletedCount() + removedBucketCount);</span>
<span class="udiff-line-added">+             setKeyCount(keyCount() - removedBucketCount);</span>
<span class="udiff-line-added">+         }</span>
  
          if (shouldShrink())
              shrinkToBestSize();
  
          internalCheckTableConsistency();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1194,89 +1218,114 @@</span>
      }
  
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::allocateTable(unsigned size) -&gt; ValueType*
      {
<span class="udiff-line-added">+         static_assert(!(metadataSize % alignof(ValueType)));</span>
<span class="udiff-line-added">+ </span>
          // would use a template member function with explicit specializations here, but
          // gcc doesn&#39;t appear to support that
          if (Traits::emptyValueIsZero)
<span class="udiff-line-modified-removed">-             return static_cast&lt;ValueType*&gt;(fastZeroedMalloc(size * sizeof(ValueType)));</span>
<span class="udiff-line-modified-removed">-         ValueType* result = static_cast&lt;ValueType*&gt;(fastMalloc(size * sizeof(ValueType)));</span>
<span class="udiff-line-modified-added">+             return reinterpret_cast_ptr&lt;ValueType*&gt;(static_cast&lt;char*&gt;(HashTableMalloc::zeroedMalloc(metadataSize + size * sizeof(ValueType))) + metadataSize);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+         ValueType* result = reinterpret_cast_ptr&lt;ValueType*&gt;(static_cast&lt;char*&gt;(HashTableMalloc::malloc(metadataSize + size * sizeof(ValueType))) + metadataSize);</span>
          for (unsigned i = 0; i &lt; size; i++)
              initializeBucket(result[i]);
          return result;
      }
  
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
<span class="udiff-line-modified-removed">-     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deallocateTable(ValueType* table, unsigned size)</span>
<span class="udiff-line-modified-added">+     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deallocateTable(ValueType* table)</span>
      {
<span class="udiff-line-added">+         unsigned size = reinterpret_cast_ptr&lt;unsigned*&gt;(table)[tableSizeOffset];</span>
          for (unsigned i = 0; i &lt; size; ++i) {
              if (!isDeletedBucket(table[i]))
                  table[i].~ValueType();
          }
<span class="udiff-line-modified-removed">-         fastFree(table);</span>
<span class="udiff-line-modified-added">+         HashTableMalloc::free(reinterpret_cast&lt;char*&gt;(table) - metadataSize);</span>
      }
  
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::expand(ValueType* entry) -&gt; ValueType*
      {
          if (KeyTraits::hasIsReleasedWeakValueFunction)
              deleteReleasedWeakBuckets();
  
          unsigned newSize;
<span class="udiff-line-modified-removed">-         if (m_tableSize == 0)</span>
<span class="udiff-line-modified-added">+         unsigned oldSize = tableSize();</span>
<span class="udiff-line-added">+         if (!oldSize)</span>
              newSize = KeyTraits::minimumTableSize;
          else if (mustRehashInPlace())
<span class="udiff-line-modified-removed">-             newSize = m_tableSize;</span>
<span class="udiff-line-modified-added">+             newSize = oldSize;</span>
          else
<span class="udiff-line-modified-removed">-             newSize = m_tableSize * 2;</span>
<span class="udiff-line-modified-added">+             newSize = oldSize * 2;</span>
  
          return rehash(newSize, entry);
      }
  
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      constexpr unsigned HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::computeBestTableSize(unsigned keyCount)
      {
<span class="udiff-line-modified-removed">-         unsigned bestTableSize = WTF::roundUpToPowerOfTwo(keyCount) * 2;</span>
<span class="udiff-line-modified-added">+         unsigned bestTableSize = WTF::roundUpToPowerOfTwo(keyCount);</span>
  
<span class="udiff-line-modified-removed">-         // With maxLoad at 1/2 and minLoad at 1/6, our average load is 2/6.</span>
<span class="udiff-line-removed">-         // If we are getting halfway between 2/6 and 1/2 (past 5/12), we double the size to avoid being too close to</span>
<span class="udiff-line-removed">-         // loadMax and bring the ratio close to 2/6. This give us a load in the bounds [3/12, 5/12).</span>
<span class="udiff-line-removed">-         bool aboveThreeQuarterLoad = keyCount * 12 &gt;= bestTableSize * 5;</span>
<span class="udiff-line-removed">-         if (aboveThreeQuarterLoad)</span>
<span class="udiff-line-modified-added">+         if (HashTableSizePolicy::shouldExpand(keyCount, bestTableSize))</span>
              bestTableSize *= 2;
  
<span class="udiff-line-added">+         auto aboveThresholdForEagerExpansion = [](double loadFactor, unsigned keyCount, unsigned tableSize)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             // Here is the rationale behind this calculation, using 3/4 load-factor.</span>
<span class="udiff-line-added">+             // With maxLoad at 3/4 and minLoad at 1/6, our average load is 11/24.</span>
<span class="udiff-line-added">+             // If we are getting half-way between 11/24 and 3/4, we double the size</span>
<span class="udiff-line-added">+             // to avoid being too close to loadMax and bring the ratio close to 11/24. This</span>
<span class="udiff-line-added">+             // give us a load in the bounds [9/24, 15/24).</span>
<span class="udiff-line-added">+             double maxLoadRatio = loadFactor;</span>
<span class="udiff-line-added">+             double minLoadRatio = 1.0 / minLoad;</span>
<span class="udiff-line-added">+             double averageLoadRatio = (maxLoadRatio + minLoadRatio) / 2;</span>
<span class="udiff-line-added">+             double halfWayBetweenAverageAndMaxLoadRatio = (averageLoadRatio + maxLoadRatio) / 2;</span>
<span class="udiff-line-added">+             return keyCount &gt;= tableSize * halfWayBetweenAverageAndMaxLoadRatio;</span>
<span class="udiff-line-added">+         };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (bestTableSize &lt;= maxSmallTableCapacity) {</span>
<span class="udiff-line-added">+             constexpr double smallLoadFactor = static_cast&lt;double&gt;(smallMaxLoadNumerator) / smallMaxLoadDenominator;</span>
<span class="udiff-line-added">+             if (aboveThresholdForEagerExpansion(smallLoadFactor, keyCount, bestTableSize))</span>
<span class="udiff-line-added">+                 bestTableSize *= 2;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             constexpr double largeLoadFactor = static_cast&lt;double&gt;(largeMaxLoadNumerator) / largeMaxLoadDenominator;</span>
<span class="udiff-line-added">+             if (aboveThresholdForEagerExpansion(largeLoadFactor, keyCount, bestTableSize))</span>
<span class="udiff-line-added">+                 bestTableSize *= 2;</span>
<span class="udiff-line-added">+         }</span>
          unsigned minimumTableSize = KeyTraits::minimumTableSize;
          return std::max(bestTableSize, minimumTableSize);
      }
  
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::shrinkToBestSize()
      {
          unsigned minimumTableSize = KeyTraits::minimumTableSize;
<span class="udiff-line-modified-removed">-         rehash(std::max(minimumTableSize, computeBestTableSize(m_keyCount)), nullptr);</span>
<span class="udiff-line-modified-added">+         rehash(std::max(minimumTableSize, computeBestTableSize(keyCount())), nullptr);</span>
      }
  
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deleteReleasedWeakBuckets()
      {
<span class="udiff-line-modified-removed">-         for (unsigned i = 0; i &lt; m_tableSize; ++i) {</span>
<span class="udiff-line-modified-added">+         unsigned tableSize = this-&gt;tableSize();</span>
<span class="udiff-line-added">+         for (unsigned i = 0; i &lt; tableSize; ++i) {</span>
              auto&amp; entry = m_table[i];
              if (isReleasedWeakBucket(entry)) {
                  deleteBucket(entry);
<span class="udiff-line-modified-removed">-                 ++m_deletedCount;</span>
<span class="udiff-line-modified-removed">-                 --m_keyCount;</span>
<span class="udiff-line-modified-added">+                 setDeletedCount(deletedCount() + 1);</span>
<span class="udiff-line-modified-added">+                 setKeyCount(keyCount() - 1);</span>
              }
          }
      }
  
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::rehash(unsigned newTableSize, ValueType* entry) -&gt; ValueType*
      {
          internalCheckTableConsistencyExceptSize();
  
<span class="udiff-line-modified-removed">-         unsigned oldTableSize = m_tableSize;</span>
<span class="udiff-line-modified-added">+         unsigned oldTableSize = tableSize();</span>
          ValueType* oldTable = m_table;
  
  #if DUMP_HASHTABLE_STATS
          if (oldTableSize != 0)
              ++HashTableStats::numRehashes;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1285,13 +1334,16 @@</span>
  #if DUMP_HASHTABLE_STATS_PER_TABLE
          if (oldTableSize != 0)
              ++m_stats-&gt;numRehashes;
  #endif
  
<span class="udiff-line-modified-removed">-         m_tableSize = newTableSize;</span>
<span class="udiff-line-removed">-         m_tableSizeMask = newTableSize - 1;</span>
<span class="udiff-line-modified-added">+         unsigned oldKeyCount = keyCount();</span>
          m_table = allocateTable(newTableSize);
<span class="udiff-line-added">+         setTableSize(newTableSize);</span>
<span class="udiff-line-added">+         setTableSizeMask(newTableSize - 1);</span>
<span class="udiff-line-added">+         setDeletedCount(0);</span>
<span class="udiff-line-added">+         setKeyCount(oldKeyCount);</span>
  
          Value* newEntry = nullptr;
          for (unsigned i = 0; i != oldTableSize; ++i) {
              auto&amp; oldEntry = oldTable[i];
              if (isDeletedBucket(oldEntry)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1306,11 +1358,11 @@</span>
              }
  
              if (isReleasedWeakBucket(oldEntry)) {
                  ASSERT(std::addressof(oldEntry) != entry);
                  oldEntry.~ValueType();
<span class="udiff-line-modified-removed">-                 --m_keyCount;</span>
<span class="udiff-line-modified-added">+                 setKeyCount(keyCount() - 1);</span>
                  continue;
              }
  
              Value* reinsertedEntry = reinsert(WTFMove(oldEntry));
              oldEntry.~ValueType();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1318,13 +1370,12 @@</span>
                  ASSERT(!newEntry);
                  newEntry = reinsertedEntry;
              }
          }
  
<span class="udiff-line-modified-removed">-         m_deletedCount = 0;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-         fastFree(oldTable);</span>
<span class="udiff-line-modified-added">+         if (oldTable)</span>
<span class="udiff-line-modified-added">+             HashTableMalloc::free(reinterpret_cast&lt;char*&gt;(oldTable) - metadataSize);</span>
  
          internalCheckTableConsistency();
          return newEntry;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1333,25 +1384,17 @@</span>
      {
          invalidateIterators();
          if (!m_table)
              return;
  
<span class="udiff-line-modified-removed">-         deallocateTable(m_table, m_tableSize);</span>
<span class="udiff-line-modified-removed">-         m_table = 0;</span>
<span class="udiff-line-removed">-         m_tableSize = 0;</span>
<span class="udiff-line-removed">-         m_tableSizeMask = 0;</span>
<span class="udiff-line-removed">-         m_keyCount = 0;</span>
<span class="udiff-line-removed">-         m_deletedCount = 0;</span>
<span class="udiff-line-modified-added">+         deallocateTable(m_table);</span>
<span class="udiff-line-modified-added">+         m_table = nullptr;</span>
      }
  
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(const HashTable&amp; other)
          : m_table(nullptr)
<span class="udiff-line-removed">-         , m_tableSize(0)</span>
<span class="udiff-line-removed">-         , m_tableSizeMask(0)</span>
<span class="udiff-line-removed">-         , m_keyCount(0)</span>
<span class="udiff-line-removed">-         , m_deletedCount(0)</span>
  #if CHECK_HASHTABLE_ITERATORS
          , m_iterators(nullptr)
          , m_mutex(makeUnique&lt;Lock&gt;())
  #endif
  #if DUMP_HASHTABLE_STATS_PER_TABLE
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1360,14 +1403,16 @@</span>
      {
          unsigned otherKeyCount = other.size();
          if (!otherKeyCount)
              return;
  
<span class="udiff-line-modified-removed">-         m_tableSize = computeBestTableSize(otherKeyCount);</span>
<span class="udiff-line-modified-removed">-         m_tableSizeMask = m_tableSize - 1;</span>
<span class="udiff-line-modified-removed">-         m_keyCount = otherKeyCount;</span>
<span class="udiff-line-modified-removed">-         m_table = allocateTable(m_tableSize);</span>
<span class="udiff-line-modified-added">+         unsigned bestTableSize = computeBestTableSize(otherKeyCount);</span>
<span class="udiff-line-modified-added">+         m_table = allocateTable(bestTableSize);</span>
<span class="udiff-line-modified-added">+         setTableSize(bestTableSize);</span>
<span class="udiff-line-modified-added">+         setTableSizeMask(bestTableSize - 1);</span>
<span class="udiff-line-added">+         setKeyCount(otherKeyCount);</span>
<span class="udiff-line-added">+         setDeletedCount(0);</span>
  
          for (const auto&amp; otherValue : other)
              addUniqueForInitialization&lt;IdentityTranslatorType&gt;(Extractor::extract(otherValue), otherValue);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1376,14 +1421,10 @@</span>
      {
          invalidateIterators();
          other.invalidateIterators();
  
          std::swap(m_table, other.m_table);
<span class="udiff-line-removed">-         std::swap(m_tableSize, other.m_tableSize);</span>
<span class="udiff-line-removed">-         std::swap(m_tableSizeMask, other.m_tableSizeMask);</span>
<span class="udiff-line-removed">-         std::swap(m_keyCount, other.m_keyCount);</span>
<span class="udiff-line-removed">-         std::swap(m_deletedCount, other.m_deletedCount);</span>
  
  #if DUMP_HASHTABLE_STATS_PER_TABLE
          m_stats.swap(other.m_stats);
  #endif
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1403,21 +1444,11 @@</span>
          , m_mutex(makeUnique&lt;Lock&gt;())
  #endif
      {
          other.invalidateIterators();
  
<span class="udiff-line-modified-removed">-         m_table = other.m_table;</span>
<span class="udiff-line-removed">-         m_tableSize = other.m_tableSize;</span>
<span class="udiff-line-removed">-         m_tableSizeMask = other.m_tableSizeMask;</span>
<span class="udiff-line-removed">-         m_keyCount = other.m_keyCount;</span>
<span class="udiff-line-removed">-         m_deletedCount = other.m_deletedCount;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         other.m_table = nullptr;</span>
<span class="udiff-line-removed">-         other.m_tableSize = 0;</span>
<span class="udiff-line-removed">-         other.m_tableSizeMask = 0;</span>
<span class="udiff-line-removed">-         other.m_keyCount = 0;</span>
<span class="udiff-line-removed">-         other.m_deletedCount = 0;</span>
<span class="udiff-line-modified-added">+         m_table = std::exchange(other.m_table, nullptr);</span>
  
  #if DUMP_HASHTABLE_STATS_PER_TABLE
          m_stats = WTFMove(other.m_stats);
          other.m_stats = nullptr;
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1429,11 +1460,11 @@</span>
          HashTable temp = WTFMove(other);
          swap(temp);
          return *this;
      }
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
  
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkTableConsistency() const
      {
          checkTableConsistencyExceptSize();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1447,11 +1478,12 @@</span>
          if (!m_table)
              return;
  
          unsigned count = 0;
          unsigned deletedCount = 0;
<span class="udiff-line-modified-removed">-         for (unsigned j = 0; j &lt; m_tableSize; ++j) {</span>
<span class="udiff-line-modified-added">+         unsigned tableSize = this-&gt;tableSize();</span>
<span class="udiff-line-added">+         for (unsigned j = 0; j &lt; tableSize; ++j) {</span>
              ValueType* entry = m_table + j;
              if (isEmptyBucket(*entry))
                  continue;
  
              if (isDeletedBucket(*entry)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1465,18 +1497,18 @@</span>
              ++count;
  
              ValueCheck&lt;Key&gt;::checkConsistency(key);
          }
  
<span class="udiff-line-modified-removed">-         ASSERT(count == m_keyCount);</span>
<span class="udiff-line-modified-removed">-         ASSERT(deletedCount == m_deletedCount);</span>
<span class="udiff-line-modified-removed">-         ASSERT(m_tableSize &gt;= KeyTraits::minimumTableSize);</span>
<span class="udiff-line-modified-removed">-         ASSERT(m_tableSizeMask);</span>
<span class="udiff-line-modified-removed">-         ASSERT(m_tableSize == m_tableSizeMask + 1);</span>
<span class="udiff-line-modified-added">+         ASSERT(count == keyCount());</span>
<span class="udiff-line-modified-added">+         ASSERT(deletedCount == this-&gt;deletedCount());</span>
<span class="udiff-line-modified-added">+         ASSERT(this-&gt;tableSize() &gt;= KeyTraits::minimumTableSize);</span>
<span class="udiff-line-modified-added">+         ASSERT(tableSizeMask());</span>
<span class="udiff-line-modified-added">+         ASSERT(this-&gt;tableSize() == tableSizeMask() + 1);</span>
      }
  
<span class="udiff-line-modified-removed">- #endif // ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #endif // ASSERT_ENABLED</span>
  
  #if CHECK_HASHTABLE_ITERATORS
  
      template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
      void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::invalidateIterators()
</pre>
<center><a href="HashTable.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HashTraits.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLFramebuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLFramebuffer.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
 31 #include &quot;ExtensionsGL.h&quot;
 32 #include &quot;WebGLContextGroup.h&quot;
 33 #include &quot;WebGLDrawBuffers.h&quot;
 34 #include &quot;WebGLRenderingContextBase.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 namespace {
 39 
 40     class WebGLRenderbufferAttachment : public WebGLFramebuffer::WebGLAttachment {
 41     public:
 42         static Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; create(WebGLRenderbuffer*);
 43 
 44     private:
 45         WebGLRenderbufferAttachment(WebGLRenderbuffer*);
 46         GCGLsizei getWidth() const override;
 47         GCGLsizei getHeight() const override;
 48         GCGLenum getFormat() const override;
 49         WebGLSharedObject* getObject() const override;
 50         bool isSharedObject(WebGLSharedObject*) const override;
 51         bool isValid() const override;
 52         bool isInitialized() const override;
 53         void setInitialized() override;
 54         void onDetached(GraphicsContextGLOpenGL*) override;
 55         void attach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;
 56         void unattach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;
 57 
 58         WebGLRenderbufferAttachment() { };
 59 
 60         RefPtr&lt;WebGLRenderbuffer&gt; m_renderbuffer;
 61     };
 62 
 63     Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; WebGLRenderbufferAttachment::create(WebGLRenderbuffer* renderbuffer)
 64     {
 65         return adoptRef(*new WebGLRenderbufferAttachment(renderbuffer));
 66     }
 67 
 68     WebGLRenderbufferAttachment::WebGLRenderbufferAttachment(WebGLRenderbuffer* renderbuffer)
 69         : m_renderbuffer(renderbuffer)
 70     {
 71     }
 72 
 73     GCGLsizei WebGLRenderbufferAttachment::getWidth() const
 74     {
 75         return m_renderbuffer-&gt;getWidth();
 76     }
 77 
 78     GCGLsizei WebGLRenderbufferAttachment::getHeight() const
 79     {
 80         return m_renderbuffer-&gt;getHeight();
 81     }
 82 
 83     GCGLenum WebGLRenderbufferAttachment::getFormat() const
 84     {
 85         return m_renderbuffer-&gt;getInternalFormat();
 86     }
 87 
 88     WebGLSharedObject* WebGLRenderbufferAttachment::getObject() const
 89     {
 90         return m_renderbuffer-&gt;object() ? m_renderbuffer.get() : 0;
 91     }
 92 
 93     bool WebGLRenderbufferAttachment::isSharedObject(WebGLSharedObject* object) const
 94     {
 95         return object == m_renderbuffer;
 96     }
 97 
 98     bool WebGLRenderbufferAttachment::isValid() const
 99     {
100         return m_renderbuffer-&gt;object();
101     }
102 
103     bool WebGLRenderbufferAttachment::isInitialized() const
104     {
105         return m_renderbuffer-&gt;object() &amp;&amp; m_renderbuffer-&gt;isInitialized();
106     }
107 
108     void WebGLRenderbufferAttachment::setInitialized()
109     {
110         if (m_renderbuffer-&gt;object())
111             m_renderbuffer-&gt;setInitialized();
112     }
113 
114     void WebGLRenderbufferAttachment::onDetached(GraphicsContextGLOpenGL* context)
115     {
116         m_renderbuffer-&gt;onDetached(context);
117     }
118 
119     void WebGLRenderbufferAttachment::attach(GraphicsContextGLOpenGL* context, GCGLenum attachment)
120     {
121         PlatformGLObject object = objectOrZero(m_renderbuffer.get());
122         context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, attachment, GraphicsContextGL::RENDERBUFFER, object);
123     }
124 
125     void WebGLRenderbufferAttachment::unattach(GraphicsContextGLOpenGL* context, GCGLenum attachment)
126     {
127 #if !USE(ANGLE)
128         if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {
129             context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::RENDERBUFFER, 0);
130             context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::RENDERBUFFER, 0);
131         } else
132 #endif
133             context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, attachment, GraphicsContextGL::RENDERBUFFER, 0);
134     }
135 
136     class WebGLTextureAttachment : public WebGLFramebuffer::WebGLAttachment {
137     public:
138         static Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; create(WebGLTexture*, GCGLenum target, GCGLint level);
139 
140     private:
141         WebGLTextureAttachment(WebGLTexture*, GCGLenum target, GCGLint level);
142         GCGLsizei getWidth() const override;
143         GCGLsizei getHeight() const override;
144         GCGLenum getFormat() const override;
145         WebGLSharedObject* getObject() const override;
146         bool isSharedObject(WebGLSharedObject*) const override;
147         bool isValid() const override;
148         bool isInitialized() const override;
149         void setInitialized() override;
150         void onDetached(GraphicsContextGLOpenGL*) override;
151         void attach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;
152         void unattach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;
153 
154         WebGLTextureAttachment() { };
155 
156         RefPtr&lt;WebGLTexture&gt; m_texture;
157         GCGLenum m_target;
158         GCGLint m_level;
159     };
160 
161     Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; WebGLTextureAttachment::create(WebGLTexture* texture, GCGLenum target, GCGLint level)
162     {
163         return adoptRef(*new WebGLTextureAttachment(texture, target, level));
164     }
165 
166     WebGLTextureAttachment::WebGLTextureAttachment(WebGLTexture* texture, GCGLenum target, GCGLint level)
167         : m_texture(texture)
168         , m_target(target)
169         , m_level(level)
170     {
171     }
172 
173     GCGLsizei WebGLTextureAttachment::getWidth() const
174     {
175         return m_texture-&gt;getWidth(m_target, m_level);
176     }
177 
178     GCGLsizei WebGLTextureAttachment::getHeight() const
179     {
180         return m_texture-&gt;getHeight(m_target, m_level);
181     }
182 
183     GCGLenum WebGLTextureAttachment::getFormat() const
184     {
185         return m_texture-&gt;getInternalFormat(m_target, m_level);
186     }
187 
188     WebGLSharedObject* WebGLTextureAttachment::getObject() const
189     {
190         return m_texture-&gt;object() ? m_texture.get() : 0;
191     }
192 
193     bool WebGLTextureAttachment::isSharedObject(WebGLSharedObject* object) const
194     {
195         return object == m_texture;
196     }
197 
198     bool WebGLTextureAttachment::isValid() const
199     {
200         return m_texture-&gt;object();
201     }
202 
203     bool WebGLTextureAttachment::isInitialized() const
204     {
205         // Textures are assumed to be initialized.
206         return true;
207     }
208 
209     void WebGLTextureAttachment::setInitialized()
210     {
211         // Textures are assumed to be initialized.
212     }
213 
214     void WebGLTextureAttachment::onDetached(GraphicsContextGLOpenGL* context)
215     {
216         m_texture-&gt;onDetached(context);
217     }
218 
219     void WebGLTextureAttachment::attach(GraphicsContextGLOpenGL* context, GCGLenum attachment)
220     {
221         PlatformGLObject object = objectOrZero(m_texture.get());
222         context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, attachment, m_target, object, m_level);
223     }
224 
225     void WebGLTextureAttachment::unattach(GraphicsContextGLOpenGL* context, GCGLenum attachment)
226     {
227 #if !USE(ANGLE)
228         if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {
229             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, m_target, 0, m_level);
230             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, m_target, 0, m_level);
231         } else
232 #endif
233             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, attachment, m_target, 0, m_level);
234     }
235 
236     bool isAttachmentComplete(WebGLFramebuffer::WebGLAttachment* attachedObject, GCGLenum attachment, const char** reason)
237     {
238         ASSERT(attachedObject &amp;&amp; attachedObject-&gt;isValid());
239         ASSERT(reason);
240         GCGLenum format = attachedObject-&gt;getFormat();
241         unsigned need = GraphicsContextGLOpenGL::getClearBitsByAttachmentType(attachment);
242         unsigned have = GraphicsContextGLOpenGL::getClearBitsByFormat(format);
243 
244         if ((need &amp; have) != need) {
245             *reason = &quot;attachment type is not correct for attachment&quot;;
246             return false;
247         }
248         if (!attachedObject-&gt;getWidth() || !attachedObject-&gt;getHeight()) {
249             *reason = &quot;attachment has a 0 dimension&quot;;
250             return false;
251         }
252         if ((attachment == GraphicsContextGL::DEPTH_ATTACHMENT || attachment == GraphicsContextGL::STENCIL_ATTACHMENT)
253             &amp;&amp; format == GraphicsContextGL::DEPTH_STENCIL) {
254           *reason = &quot;attachment DEPTH_STENCIL not allowed on DEPTH or STENCIL attachment&quot;;
255           return false;
256         }
257         return true;
258     }
259 
260 } // anonymous namespace
261 
262 WebGLFramebuffer::WebGLAttachment::WebGLAttachment() = default;
263 
264 WebGLFramebuffer::WebGLAttachment::~WebGLAttachment() = default;
265 
266 Ref&lt;WebGLFramebuffer&gt; WebGLFramebuffer::create(WebGLRenderingContextBase&amp; ctx)
267 {
268     return adoptRef(*new WebGLFramebuffer(ctx));
269 }
270 
271 WebGLFramebuffer::WebGLFramebuffer(WebGLRenderingContextBase&amp; ctx)
272     : WebGLContextObject(ctx)
273     , m_hasEverBeenBound(false)
274 {
275     setObject(ctx.graphicsContextGL()-&gt;createFramebuffer());
276 }
277 
278 WebGLFramebuffer::~WebGLFramebuffer()
279 {
280     deleteObject(0);
281 }
282 
283 void WebGLFramebuffer::setAttachmentForBoundFramebuffer(GCGLenum attachment, GCGLenum texTarget, WebGLTexture* texture, GCGLint level)
284 {
285     ASSERT(isBound());
286     removeAttachmentFromBoundFramebuffer(attachment);
287     if (!object())
288         return;
289     if (texture &amp;&amp; texture-&gt;object()) {
290         m_attachments.add(attachment, WebGLTextureAttachment::create(texture, texTarget, level));
291         drawBuffersIfNecessary(false);
292         texture-&gt;onAttached();
293     }
294 }
295 
296 void WebGLFramebuffer::setAttachmentForBoundFramebuffer(GCGLenum attachment, WebGLRenderbuffer* renderbuffer)
297 {
298     ASSERT(isBound());
299     removeAttachmentFromBoundFramebuffer(attachment);
300     if (!object())
301         return;
302     if (renderbuffer &amp;&amp; renderbuffer-&gt;object()) {
303         m_attachments.add(attachment, WebGLRenderbufferAttachment::create(renderbuffer));
304         drawBuffersIfNecessary(false);
305         renderbuffer-&gt;onAttached();
306     }
307 }
308 
309 void WebGLFramebuffer::attach(GCGLenum attachment, GCGLenum attachmentPoint)
310 {
311     ASSERT(isBound());
312     RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
313     if (attachmentObject)
314         attachmentObject-&gt;attach(context()-&gt;graphicsContextGL(), attachmentPoint);
315 }
316 
317 WebGLSharedObject* WebGLFramebuffer::getAttachmentObject(GCGLenum attachment) const
318 {
319     if (!object())
320         return 0;
321     RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
322     return attachmentObject ? attachmentObject-&gt;getObject() : 0;
323 }
324 
325 WebGLFramebuffer::WebGLAttachment* WebGLFramebuffer::getAttachment(GCGLenum attachment) const
326 {
327     const AttachmentMap::const_iterator it = m_attachments.find(attachment);
328     return (it != m_attachments.end()) ? it-&gt;value.get() : 0;
329 }
330 
331 void WebGLFramebuffer::removeAttachmentFromBoundFramebuffer(GCGLenum attachment)
332 {
333     ASSERT(isBound());
334     if (!object())
335         return;
336 
337     RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
338     if (attachmentObject) {
339         attachmentObject-&gt;onDetached(context()-&gt;graphicsContextGL());
340         m_attachments.remove(attachment);
341         drawBuffersIfNecessary(false);
342 #if !USE(ANGLE)
343         switch (attachment) {
344         case GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT:
345             attach(GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::DEPTH_ATTACHMENT);
346             attach(GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::STENCIL_ATTACHMENT);
347             break;
348         case GraphicsContextGL::DEPTH_ATTACHMENT:
349             attach(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT, GraphicsContextGL::DEPTH_ATTACHMENT);
350             break;
351         case GraphicsContextGL::STENCIL_ATTACHMENT:
352             attach(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT, GraphicsContextGL::STENCIL_ATTACHMENT);
353             break;
354         }
355 #endif
356     }
357 }
358 
359 void WebGLFramebuffer::removeAttachmentFromBoundFramebuffer(WebGLSharedObject* attachment)
360 {
361     ASSERT(isBound());
362     if (!object())
363         return;
364     if (!attachment)
365         return;
366 
367     bool checkMore = true;
368     do {
369         checkMore = false;
370         for (auto&amp; entry : m_attachments) {
371             RefPtr&lt;WebGLAttachment&gt; attachmentObject = entry.value.get();
372             if (attachmentObject-&gt;isSharedObject(attachment)) {
373                 GCGLenum attachmentType = entry.key;
374                 attachmentObject-&gt;unattach(context()-&gt;graphicsContextGL(), attachmentType);
375                 removeAttachmentFromBoundFramebuffer(attachmentType);
376                 checkMore = true;
377                 break;
378             }
379         }
380     } while (checkMore);
381 }
382 
383 GCGLsizei WebGLFramebuffer::getColorBufferWidth() const
384 {
385     if (!object())
386         return 0;
387     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::COLOR_ATTACHMENT0);
388     if (!attachment)
389         return 0;
390 
391     return attachment-&gt;getWidth();
392 }
393 
394 GCGLsizei WebGLFramebuffer::getColorBufferHeight() const
395 {
396     if (!object())
397         return 0;
398     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::COLOR_ATTACHMENT0);
399     if (!attachment)
400         return 0;
401 
402     return attachment-&gt;getHeight();
403 }
404 
405 GCGLenum WebGLFramebuffer::getColorBufferFormat() const
406 {
407     if (!object())
408         return 0;
409     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::COLOR_ATTACHMENT0);
410     if (!attachment)
411         return 0;
412     return attachment-&gt;getFormat();
413 }
414 
415 GCGLenum WebGLFramebuffer::checkStatus(const char** reason) const
416 {
417     unsigned int count = 0;
418     GCGLsizei width = 0, height = 0;
419     bool haveDepth = false;
420     bool haveStencil = false;
421     bool haveDepthStencil = false;
422     for (auto&amp; entry : m_attachments) {
423         RefPtr&lt;WebGLAttachment&gt; attachment = entry.value.get();
424         if (!isAttachmentComplete(attachment.get(), entry.key, reason))
425             return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
426         if (!attachment-&gt;isValid()) {
427             *reason = &quot;attachment is not valid&quot;;
428             return GraphicsContextGL::FRAMEBUFFER_UNSUPPORTED;
429         }
430         GCGLenum attachmentFormat = attachment-&gt;getFormat();
431 
432         // Attaching an SRGB_EXT format attachment to a framebuffer is invalid.
433         if (attachmentFormat == ExtensionsGL::SRGB_EXT)
434             attachmentFormat = 0;
435 
436         if (!attachmentFormat) {
437             *reason = &quot;attachment is an unsupported format&quot;;
438             return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
439         }
440         switch (entry.key) {
441         case GraphicsContextGL::DEPTH_ATTACHMENT:
442             haveDepth = true;
443             break;
444         case GraphicsContextGL::STENCIL_ATTACHMENT:
445             haveStencil = true;
446             break;
447         case GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT:
448             haveDepthStencil = true;
449             break;
450         }
451         if (!count) {
452             width = attachment-&gt;getWidth();
453             height = attachment-&gt;getHeight();
454         } else {
455             if (width != attachment-&gt;getWidth() || height != attachment-&gt;getHeight()) {
456                 *reason = &quot;attachments do not have the same dimensions&quot;;
457                 return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
458             }
459         }
460         ++count;
461     }
462     if (!count) {
463         *reason = &quot;no attachments&quot;;
464         return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
465     }
466     if (!width || !height) {
467         *reason = &quot;framebuffer has a 0 dimension&quot;;
468         return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
469     }
470     // WebGL specific: no conflicting DEPTH/STENCIL/DEPTH_STENCIL attachments.
471     if ((haveDepthStencil &amp;&amp; (haveDepth || haveStencil)) || (haveDepth &amp;&amp; haveStencil)) {
472         *reason = &quot;conflicting DEPTH/STENCIL/DEPTH_STENCIL attachments&quot;;
473         return GraphicsContextGL::FRAMEBUFFER_UNSUPPORTED;
474     }
475     return GraphicsContextGL::FRAMEBUFFER_COMPLETE;
476 }
477 
478 bool WebGLFramebuffer::onAccess(GraphicsContextGLOpenGL* context3d, const char** reason)
479 {
480     if (checkStatus(reason) != GraphicsContextGL::FRAMEBUFFER_COMPLETE)
481         return false;
482     return initializeAttachments(context3d, reason);
483 }
484 
485 bool WebGLFramebuffer::hasStencilBuffer() const
486 {
487     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::STENCIL_ATTACHMENT);
488     if (!attachment)
489         attachment = getAttachment(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT);
490     return attachment &amp;&amp; attachment-&gt;isValid();
491 }
492 
493 void WebGLFramebuffer::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject object)
494 {
495     for (auto&amp; attachment : m_attachments.values())
496         attachment-&gt;onDetached(context3d);
497 
498     context3d-&gt;deleteFramebuffer(object);
499 }
500 
501 bool WebGLFramebuffer::initializeAttachments(GraphicsContextGLOpenGL* g3d, const char** reason)
502 {
503     ASSERT(object());
504     GCGLbitfield mask = 0;
505 
506     for (auto&amp; entry : m_attachments) {
507         GCGLenum attachmentType = entry.key;
508         RefPtr&lt;WebGLAttachment&gt; attachment = entry.value.get();
509         if (!attachment-&gt;isInitialized())
510             mask |= GraphicsContextGLOpenGL::getClearBitsByAttachmentType(attachmentType);
511     }
512     if (!mask)
513         return true;
514 
515     // We only clear un-initialized renderbuffers when they are ready to be
516     // read, i.e., when the framebuffer is complete.
517     if (g3d-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {
518         *reason = &quot;framebuffer not complete&quot;;
519         return false;
520     }
521 
522     bool initColor = mask &amp; GraphicsContextGL::COLOR_BUFFER_BIT;
523     bool initDepth = mask &amp; GraphicsContextGL::DEPTH_BUFFER_BIT;
524     bool initStencil = mask &amp; GraphicsContextGL::STENCIL_BUFFER_BIT;
525 
526     GCGLfloat colorClearValue[] = {0, 0, 0, 0}, depthClearValue = 0;
527     GCGLint stencilClearValue = 0;
528     GCGLboolean colorMask[] = {0, 0, 0, 0}, depthMask = 0;
529     GCGLuint stencilMask = 0xffffffff;
530     GCGLboolean isScissorEnabled = 0;
531     GCGLboolean isDitherEnabled = 0;
532     if (initColor) {
533         g3d-&gt;getFloatv(GraphicsContextGL::COLOR_CLEAR_VALUE, colorClearValue);
534         g3d-&gt;getBooleanv(GraphicsContextGL::COLOR_WRITEMASK, colorMask);
535         g3d-&gt;clearColor(0, 0, 0, 0);
536         g3d-&gt;colorMask(true, true, true, true);
537     }
538     if (initDepth) {
539         g3d-&gt;getFloatv(GraphicsContextGL::DEPTH_CLEAR_VALUE, &amp;depthClearValue);
540         g3d-&gt;getBooleanv(GraphicsContextGL::DEPTH_WRITEMASK, &amp;depthMask);
541         g3d-&gt;clearDepth(1.0f);
542         g3d-&gt;depthMask(true);
543     }
544     if (initStencil) {
545         g3d-&gt;getIntegerv(GraphicsContextGL::STENCIL_CLEAR_VALUE, &amp;stencilClearValue);
546         g3d-&gt;getIntegerv(GraphicsContextGL::STENCIL_WRITEMASK, reinterpret_cast&lt;GCGLint*&gt;(&amp;stencilMask));
547         g3d-&gt;clearStencil(0);
548         g3d-&gt;stencilMask(0xffffffff);
549     }
550     isScissorEnabled = g3d-&gt;isEnabled(GraphicsContextGL::SCISSOR_TEST);
551     g3d-&gt;disable(GraphicsContextGL::SCISSOR_TEST);
552     isDitherEnabled = g3d-&gt;isEnabled(GraphicsContextGL::DITHER);
553     g3d-&gt;disable(GraphicsContextGL::DITHER);
554 
555     g3d-&gt;clear(mask);
556 
557     if (initColor) {
558         g3d-&gt;clearColor(colorClearValue[0], colorClearValue[1], colorClearValue[2], colorClearValue[3]);
559         g3d-&gt;colorMask(colorMask[0], colorMask[1], colorMask[2], colorMask[3]);
560     }
561     if (initDepth) {
562         g3d-&gt;clearDepth(depthClearValue);
563         g3d-&gt;depthMask(depthMask);
564     }
565     if (initStencil) {
566         g3d-&gt;clearStencil(stencilClearValue);
567         g3d-&gt;stencilMask(stencilMask);
568     }
569     if (isScissorEnabled)
570         g3d-&gt;enable(GraphicsContextGL::SCISSOR_TEST);
571     else
572         g3d-&gt;disable(GraphicsContextGL::SCISSOR_TEST);
573     if (isDitherEnabled)
574         g3d-&gt;enable(GraphicsContextGL::DITHER);
575     else
576         g3d-&gt;disable(GraphicsContextGL::DITHER);
577 
578     for (AttachmentMap::iterator it = m_attachments.begin(); it != m_attachments.end(); ++it) {
579         GCGLenum attachmentType = it-&gt;key;
580         auto attachment = it-&gt;value;
581         GCGLbitfield bits = GraphicsContextGLOpenGL::getClearBitsByAttachmentType(attachmentType);
582         if (bits &amp; mask)
583             attachment-&gt;setInitialized();
584     }
585     return true;
586 }
587 
588 bool WebGLFramebuffer::isBound() const
589 {
590     return (context()-&gt;m_framebufferBinding.get() == this) || (context()-&gt;m_readFramebufferBinding.get() == this);
591 }
592 
593 void WebGLFramebuffer::drawBuffers(const Vector&lt;GCGLenum&gt;&amp; bufs)
594 {
595     m_drawBuffers = bufs;
596     m_filteredDrawBuffers.resize(m_drawBuffers.size());
597     for (auto&amp; buffer : m_filteredDrawBuffers)
598         buffer = GraphicsContextGL::NONE;
599     drawBuffersIfNecessary(true);
600 }
601 
602 void WebGLFramebuffer::drawBuffersIfNecessary(bool force)
603 {
604 #if ENABLE(WEBGL2)
605     // FIXME: The logic here seems wrong. If we don&#39;t have WebGL 2 enabled at all, then
606     // we skip the m_webglDrawBuffers check. But if we do have WebGL 2 enabled, then we
607     // perform this check, for WebGL 1 contexts only.
608     if (!context()-&gt;m_webglDrawBuffers &amp;&amp; !context()-&gt;isWebGL2())
609         return;
610 #endif
611     bool reset = force;
612     // This filtering works around graphics driver bugs on Mac OS X.
613     for (size_t i = 0; i &lt; m_drawBuffers.size(); ++i) {
614         if (m_drawBuffers[i] != GraphicsContextGL::NONE &amp;&amp; getAttachment(m_drawBuffers[i])) {
615             if (m_filteredDrawBuffers[i] != m_drawBuffers[i]) {
616                 m_filteredDrawBuffers[i] = m_drawBuffers[i];
617                 reset = true;
618             }
619         } else {
620             if (m_filteredDrawBuffers[i] != GraphicsContextGL::NONE) {
621                 m_filteredDrawBuffers[i] = GraphicsContextGL::NONE;
622                 reset = true;
623             }
624         }
625     }
626     if (reset) {
627         context()-&gt;graphicsContextGL()-&gt;getExtensions().drawBuffersEXT(
628             m_filteredDrawBuffers.size(), m_filteredDrawBuffers.data());
629     }
630 }
631 
632 GCGLenum WebGLFramebuffer::getDrawBuffer(GCGLenum drawBuffer)
633 {
634     int index = static_cast&lt;int&gt;(drawBuffer - ExtensionsGL::DRAW_BUFFER0_EXT);
635     ASSERT(index &gt;= 0);
636     if (index &lt; static_cast&lt;int&gt;(m_drawBuffers.size()))
637         return m_drawBuffers[index];
638     if (drawBuffer == ExtensionsGL::DRAW_BUFFER0_EXT)
639         return GraphicsContextGL::COLOR_ATTACHMENT0;
640     return GraphicsContextGL::NONE;
641 }
642 
643 }
644 
645 #endif // ENABLE(WEBGL)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/GenericEventQueue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GCReachableRef.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GenericEventQueue.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/GenericEventQueue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,35 ***</span>
  #include &quot;Timer.h&quot;
  #include &lt;wtf/MainThread.h&gt;
  
  namespace WebCore {
  
<span class="line-modified">! GenericEventQueue::GenericEventQueue(EventTarget&amp; owner)</span>
<span class="line-modified">!     : m_owner(owner)</span>
<span class="line-modified">!     , m_isClosed(false)</span>
  {
  }
  
<span class="line-modified">! GenericEventQueue::~GenericEventQueue() = default;</span>
<span class="line-removed">- </span>
<span class="line-removed">- void GenericEventQueue::enqueueEvent(RefPtr&lt;Event&gt;&amp;&amp; event)</span>
  {
      if (m_isClosed)
          return;
  
      if (event-&gt;target() == &amp;m_owner)
          event-&gt;setTarget(nullptr);
  
      m_pendingEvents.append(WTFMove(event));
  
<span class="line-modified">!     if (m_isSuspended)</span>
          return;
  
<span class="line-modified">!     m_taskQueue.enqueueTask(std::bind(&amp;GenericEventQueue::dispatchOneEvent, this));</span>
  }
  
<span class="line-modified">! void GenericEventQueue::dispatchOneEvent()</span>
  {
      ASSERT(!m_pendingEvents.isEmpty());
  
      Ref&lt;EventTarget&gt; protect(m_owner);
      RefPtr&lt;Event&gt; event = m_pendingEvents.takeFirst();
<span class="line-new-header">--- 34,34 ---</span>
  #include &quot;Timer.h&quot;
  #include &lt;wtf/MainThread.h&gt;
  
  namespace WebCore {
  
<span class="line-modified">! MainThreadGenericEventQueue::MainThreadGenericEventQueue(EventTarget&amp; owner)</span>
<span class="line-modified">!     : ActiveDOMObject(owner.scriptExecutionContext())</span>
<span class="line-modified">!     , m_owner(owner)</span>
<span class="line-added">+     , m_taskQueue(makeUniqueRef&lt;GenericTaskQueue&lt;Timer&gt;&gt;())</span>
  {
  }
  
<span class="line-modified">! void MainThreadGenericEventQueue::enqueueEvent(RefPtr&lt;Event&gt;&amp;&amp; event)</span>
  {
      if (m_isClosed)
          return;
  
      if (event-&gt;target() == &amp;m_owner)
          event-&gt;setTarget(nullptr);
  
      m_pendingEvents.append(WTFMove(event));
  
<span class="line-modified">!     if (isSuspendedOrPausedByClient())</span>
          return;
  
<span class="line-modified">!     m_taskQueue-&gt;enqueueTask(std::bind(&amp;MainThreadGenericEventQueue::dispatchOneEvent, this));</span>
  }
  
<span class="line-modified">! void MainThreadGenericEventQueue::dispatchOneEvent()</span>
  {
      ASSERT(!m_pendingEvents.isEmpty());
  
      Ref&lt;EventTarget&gt; protect(m_owner);
      RefPtr&lt;Event&gt; event = m_pendingEvents.takeFirst();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,53 ***</span>
          &quot;An attempt to dispatch an event on a stopped target by EventTargetInterface=%d (nodeName=%s target=%p owner=%p)&quot;,
          m_owner.eventTargetInterface(), m_owner.isNode() ? static_cast&lt;Node&amp;&gt;(m_owner).nodeName().ascii().data() : &quot;&quot;, &amp;target, &amp;m_owner);
      target.dispatchEvent(*event);
  }
  
<span class="line-modified">! void GenericEventQueue::close()</span>
  {
      m_isClosed = true;
  
<span class="line-modified">!     m_taskQueue.close();</span>
      m_pendingEvents.clear();
  }
  
<span class="line-modified">! void GenericEventQueue::cancelAllEvents()</span>
  {
<span class="line-modified">!     m_taskQueue.cancelAllTasks();</span>
      m_pendingEvents.clear();
  }
  
<span class="line-modified">! bool GenericEventQueue::hasPendingEvents() const</span>
  {
      return !m_pendingEvents.isEmpty();
  }
  
<span class="line-modified">! bool GenericEventQueue::hasPendingEventsOfType(const AtomString&amp; type) const</span>
  {
      for (auto&amp; event : m_pendingEvents) {
          if (event-&gt;type() == type)
              return true;
      }
  
      return false;
  }
  
<span class="line-modified">! void GenericEventQueue::suspend()</span>
  {
<span class="line-modified">!     ASSERT(!m_isSuspended);</span>
      m_isSuspended = true;
<span class="line-modified">!     m_taskQueue.cancelAllTasks();</span>
  }
  
<span class="line-modified">! void GenericEventQueue::resume()</span>
  {
      if (!m_isSuspended)
          return;
  
      m_isSuspended = false;
  
      for (unsigned i = 0; i &lt; m_pendingEvents.size(); ++i)
<span class="line-modified">!         m_taskQueue.enqueueTask(std::bind(&amp;GenericEventQueue::dispatchOneEvent, this));</span>
  }
  
  }
<span class="line-new-header">--- 70,91 ---</span>
          &quot;An attempt to dispatch an event on a stopped target by EventTargetInterface=%d (nodeName=%s target=%p owner=%p)&quot;,
          m_owner.eventTargetInterface(), m_owner.isNode() ? static_cast&lt;Node&amp;&gt;(m_owner).nodeName().ascii().data() : &quot;&quot;, &amp;target, &amp;m_owner);
      target.dispatchEvent(*event);
  }
  
<span class="line-modified">! void MainThreadGenericEventQueue::close()</span>
  {
      m_isClosed = true;
  
<span class="line-modified">!     m_taskQueue-&gt;close();</span>
      m_pendingEvents.clear();
  }
  
<span class="line-modified">! void MainThreadGenericEventQueue::cancelAllEvents()</span>
  {
<span class="line-modified">!     m_taskQueue-&gt;cancelAllTasks();</span>
      m_pendingEvents.clear();
  }
  
<span class="line-modified">! bool MainThreadGenericEventQueue::hasPendingEvents() const</span>
  {
      return !m_pendingEvents.isEmpty();
  }
  
<span class="line-modified">! bool MainThreadGenericEventQueue::hasPendingEventsOfType(const AtomString&amp; type) const</span>
  {
      for (auto&amp; event : m_pendingEvents) {
          if (event-&gt;type() == type)
              return true;
      }
  
      return false;
  }
  
<span class="line-modified">! void MainThreadGenericEventQueue::setPaused(bool shouldPause)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_isPausedByClient == shouldPause)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_isPausedByClient = shouldPause;</span>
<span class="line-added">+     if (shouldPause)</span>
<span class="line-added">+         m_taskQueue-&gt;cancelAllTasks();</span>
<span class="line-added">+     else</span>
<span class="line-added">+         rescheduleAllEventsIfNeeded();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void MainThreadGenericEventQueue::suspend(ReasonForSuspension)</span>
  {
<span class="line-modified">!     if (m_isSuspended)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      m_isSuspended = true;
<span class="line-modified">!     m_taskQueue-&gt;cancelAllTasks();</span>
  }
  
<span class="line-modified">! void MainThreadGenericEventQueue::resume()</span>
  {
      if (!m_isSuspended)
          return;
  
      m_isSuspended = false;
<span class="line-added">+     rescheduleAllEventsIfNeeded();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void MainThreadGenericEventQueue::rescheduleAllEventsIfNeeded()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (isSuspendedOrPausedByClient())</span>
<span class="line-added">+         return;</span>
  
      for (unsigned i = 0; i &lt; m_pendingEvents.size(); ++i)
<span class="line-modified">!         m_taskQueue-&gt;enqueueTask(std::bind(&amp;MainThreadGenericEventQueue::dispatchOneEvent, this));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void MainThreadGenericEventQueue::stop()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     close();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const char* MainThreadGenericEventQueue::activeDOMObjectName() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return &quot;MainThreadGenericEventQueue&quot;;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ UniqueRef&lt;MainThreadGenericEventQueue&gt; MainThreadGenericEventQueue::create(EventTarget&amp; eventTarget)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto eventQueue = makeUniqueRef&lt;MainThreadGenericEventQueue&gt;(eventTarget);</span>
<span class="line-added">+     eventQueue-&gt;suspendIfNeeded();</span>
<span class="line-added">+     return eventQueue;</span>
  }
  
  }
</pre>
<center><a href="GCReachableRef.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GenericEventQueue.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
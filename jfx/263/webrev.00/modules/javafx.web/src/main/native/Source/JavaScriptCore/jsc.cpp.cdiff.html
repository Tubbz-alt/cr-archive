<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="jit/UnusedPointer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="llint/LLIntData.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,13 ***</span>
<span class="line-new-header">--- 25,15 ---</span>
  #include &quot;ArrayBuffer.h&quot;
  #include &quot;ArrayPrototype.h&quot;
  #include &quot;BuiltinNames.h&quot;
  #include &quot;ButterflyInlines.h&quot;
  #include &quot;BytecodeCacheError.h&quot;
<span class="line-added">+ #include &quot;CallFrameInlines.h&quot;</span>
  #include &quot;CatchScope.h&quot;
  #include &quot;CodeBlock.h&quot;
  #include &quot;CodeCache.h&quot;
<span class="line-added">+ #include &quot;CompilerTimingScope.h&quot;</span>
  #include &quot;Completion.h&quot;
  #include &quot;ConfigFile.h&quot;
  #include &quot;Disassembler.h&quot;
  #include &quot;Exception.h&quot;
  #include &quot;ExceptionHelpers.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,34 ***</span>
  #include &quot;JSArrayBuffer.h&quot;
  #include &quot;JSBigInt.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSFunction.h&quot;
  #include &quot;JSInternalPromise.h&quot;
<span class="line-removed">- #include &quot;JSInternalPromiseDeferred.h&quot;</span>
  #include &quot;JSLock.h&quot;
  #include &quot;JSModuleLoader.h&quot;
  #include &quot;JSNativeStdFunction.h&quot;
  #include &quot;JSONObject.h&quot;
  #include &quot;JSSourceCode.h&quot;
  #include &quot;JSString.h&quot;
  #include &quot;JSTypedArrays.h&quot;
  #include &quot;JSWebAssemblyInstance.h&quot;
  #include &quot;JSWebAssemblyMemory.h&quot;
  #include &quot;LLIntThunks.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  #include &quot;ParserError.h&quot;
  #include &quot;ProfilerDatabase.h&quot;
<span class="line-modified">! #include &quot;PromiseDeferredTimer.h&quot;</span>
  #include &quot;ProtoCallFrame.h&quot;
  #include &quot;ReleaseHeapAccessScope.h&quot;
  #include &quot;SamplingProfiler.h&quot;
  #include &quot;StackVisitor.h&quot;
  #include &quot;StructureInlines.h&quot;
  #include &quot;StructureRareDataInlines.h&quot;
  #include &quot;SuperSampler.h&quot;
  #include &quot;TestRunnerUtils.h&quot;
  #include &quot;TypedArrayInlines.h&quot;
  #include &quot;WasmCapabilities.h&quot;
  #include &quot;WasmContext.h&quot;
  #include &quot;WasmFaultSignalHandler.h&quot;
  #include &quot;WasmMemory.h&quot;
  #include &lt;locale.h&gt;
<span class="line-new-header">--- 46,35 ---</span>
  #include &quot;JSArrayBuffer.h&quot;
  #include &quot;JSBigInt.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSFunction.h&quot;
  #include &quot;JSInternalPromise.h&quot;
  #include &quot;JSLock.h&quot;
  #include &quot;JSModuleLoader.h&quot;
  #include &quot;JSNativeStdFunction.h&quot;
  #include &quot;JSONObject.h&quot;
<span class="line-added">+ #include &quot;JSObjectInlines.h&quot;</span>
  #include &quot;JSSourceCode.h&quot;
  #include &quot;JSString.h&quot;
  #include &quot;JSTypedArrays.h&quot;
  #include &quot;JSWebAssemblyInstance.h&quot;
  #include &quot;JSWebAssemblyMemory.h&quot;
  #include &quot;LLIntThunks.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  #include &quot;ParserError.h&quot;
  #include &quot;ProfilerDatabase.h&quot;
<span class="line-modified">! #include &quot;PromiseTimer.h&quot;</span>
  #include &quot;ProtoCallFrame.h&quot;
  #include &quot;ReleaseHeapAccessScope.h&quot;
  #include &quot;SamplingProfiler.h&quot;
  #include &quot;StackVisitor.h&quot;
  #include &quot;StructureInlines.h&quot;
  #include &quot;StructureRareDataInlines.h&quot;
  #include &quot;SuperSampler.h&quot;
  #include &quot;TestRunnerUtils.h&quot;
  #include &quot;TypedArrayInlines.h&quot;
<span class="line-added">+ #include &quot;VMInspector.h&quot;</span>
  #include &quot;WasmCapabilities.h&quot;
  #include &quot;WasmContext.h&quot;
  #include &quot;WasmFaultSignalHandler.h&quot;
  #include &quot;WasmMemory.h&quot;
  #include &lt;locale.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 82,10 ***</span>
<span class="line-new-header">--- 85,11 ---</span>
  #include &lt;sys/stat.h&gt;
  #include &lt;sys/types.h&gt;
  #include &lt;thread&gt;
  #include &lt;type_traits&gt;
  #include &lt;wtf/Box.h&gt;
<span class="line-added">+ #include &lt;wtf/CPUTime.h&gt;</span>
  #include &lt;wtf/CommaPrinter.h&gt;
  #include &lt;wtf/FileSystem.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/MemoryPressureHandler.h&gt;
  #include &lt;wtf/MonotonicTime.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,17 ***</span>
  #include &lt;crtdbg.h&gt;
  #include &lt;mmsystem.h&gt;
  #include &lt;windows.h&gt;
  #endif
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)</span>
  #include &lt;fenv.h&gt;
  #include &lt;arm/arch.h&gt;
  #endif
  
  #if OS(DARWIN)
  #include &lt;wtf/spi/darwin/ProcessMemoryFootprint.h&gt;
  struct MemoryFootprint : ProcessMemoryFootprint {
      MemoryFootprint(const ProcessMemoryFootprint&amp; src)
          : ProcessMemoryFootprint(src)
      {
      }
<span class="line-new-header">--- 134,22 ---</span>
  #include &lt;crtdbg.h&gt;
  #include &lt;mmsystem.h&gt;
  #include &lt;windows.h&gt;
  #endif
  
<span class="line-modified">! #if OS(DARWIN) &amp;&amp; CPU(ARM_THUMB2)</span>
  #include &lt;fenv.h&gt;
  #include &lt;arm/arch.h&gt;
  #endif
  
  #if OS(DARWIN)
  #include &lt;wtf/spi/darwin/ProcessMemoryFootprint.h&gt;
<span class="line-added">+ #elif OS(LINUX)</span>
<span class="line-added">+ #include &lt;wtf/linux/ProcessMemoryFootprint.h&gt;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if OS(DARWIN) || OS(LINUX)</span>
  struct MemoryFootprint : ProcessMemoryFootprint {
      MemoryFootprint(const ProcessMemoryFootprint&amp; src)
          : ProcessMemoryFootprint(src)
      {
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,11 ***</span>
          : Base(vm, structure)
      {
      }
  
      typedef JSNonFinalObject Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags | JSC::MasqueradesAsUndefined;</span>
  
      static Masquerader* create(VM&amp; vm, JSGlobalObject* globalObject)
      {
          globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(vm, &quot;Masquerading object allocated&quot;);
          Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-new-header">--- 202,11 ---</span>
          : Base(vm, structure)
      {
      }
  
      typedef JSNonFinalObject Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags | JSC::MasqueradesAsUndefined;</span>
  
      static Masquerader* create(VM&amp; vm, JSGlobalObject* globalObject)
      {
          globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(vm, &quot;Masquerading object allocated&quot;);
          Structure* structure = createStructure(vm, globalObject, jsNull());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,11 ***</span>
  class GlobalObject;
  class Workers;
  
  template&lt;typename Func&gt;
  int runJSC(const CommandLine&amp;, bool isWorker, const Func&amp;);
<span class="line-modified">! static void checkException(ExecState*, GlobalObject*, bool isLastFile, bool hasException, JSValue, CommandLine&amp;, bool&amp; success);</span>
  
  class Message : public ThreadSafeRefCounted&lt;Message&gt; {
  public:
      Message(ArrayBufferContents&amp;&amp;, int32_t);
      ~Message();
<span class="line-new-header">--- 237,11 ---</span>
  class GlobalObject;
  class Workers;
  
  template&lt;typename Func&gt;
  int runJSC(const CommandLine&amp;, bool isWorker, const Func&amp;);
<span class="line-modified">! static void checkException(GlobalObject*, bool isLastFile, bool hasException, JSValue, CommandLine&amp;, bool&amp; success);</span>
  
  class Message : public ThreadSafeRefCounted&lt;Message&gt; {
  public:
      Message(ArrayBufferContents&amp;&amp;, int32_t);
      ~Message();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,107 ***</span>
      SentinelLinkedList&lt;Worker, BasicRawSentinelNode&lt;Worker&gt;&gt; m_workers;
      Deque&lt;String&gt; m_reports;
  };
  
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState*);</span>
<span class="line-modified">! </span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDebug(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionJSCStack(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGCAndSweep(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFullGC(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionForceGCSlowPaths(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionHeapSize(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionAddressOf(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionVersion(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionRun(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionRunString(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionLoad(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionReadline(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState*);</span>
<span class="line-modified">! static NO_RETURN_WITH_VALUE EncodedJSValue JSC_HOST_CALL functionQuit(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState*);</span>
  #if ENABLE(SAMPLING_PROFILER)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState*);</span>
  #endif
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*);</span>
  
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState*);</span>
  #endif
  
  #if ENABLE(SAMPLING_FLAGS)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(ExecState*);</span>
  #endif
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*);</span>
<span class="line-modified">! </span>
<span class="line-removed">- static EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState*);</span>
  
  struct Script {
      enum class StrictMode {
          Strict,
          Sloppy
<span class="line-new-header">--- 295,106 ---</span>
      SentinelLinkedList&lt;Worker, BasicRawSentinelNode&lt;Worker&gt;&gt; m_workers;
      Deque&lt;String&gt; m_reports;
  };
  
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! </span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDebug(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDescribe(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDescribeArray(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionJSCStack(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGCAndSweep(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFullGC(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionEdenGC(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionHeapSize(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionAddressOf(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionVersion(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionRun(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionRunString(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionLoad(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionLoadString(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionReadFile(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCheckSyntax(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionReadline(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionPreciseTime(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionNoDFG(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionNoFTL(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCallerIsOMGCompiled(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionJSCOptions(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static NO_RETURN_WITH_VALUE EncodedJSValue JSC_HOST_CALL functionQuit(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFalse(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionUndefined1(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionUndefined2(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIsInt32(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIsPureNaN(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionEffectful42(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIdentity(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(JSGlobalObject*, CallFrame*);</span>
  #if ENABLE(SAMPLING_PROFILER)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(JSGlobalObject*, CallFrame*);</span>
  #endif
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionMaxArguments(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(JSGlobalObject*, CallFrame*);</span>
  
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(JSGlobalObject*, CallFrame*);</span>
  #endif
  
  #if ENABLE(SAMPLING_FLAGS)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(JSGlobalObject*, CallFrame*);</span>
  #endif
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIsRope(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionWaitForReport(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionHeapCapacity(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionMallocInALoop(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! </span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(JSGlobalObject*, CallFrame*);</span>
  
  struct Script {
      enum class StrictMode {
          Strict,
          Sloppy
</pre>
<hr />
<pre>
<span class="line-old-header">*** 476,11 ***</span>
  static inline String stringFromUTF(const Vector&amp; utf8)
  {
      return String::fromUTF8WithLatin1Fallback(utf8.data(), utf8.size());
  }
  
<span class="line-modified">! class GlobalObject : public JSGlobalObject {</span>
  private:
      GlobalObject(VM&amp;, Structure*);
  
  public:
      typedef JSGlobalObject Base;
<span class="line-new-header">--- 484,11 ---</span>
  static inline String stringFromUTF(const Vector&amp; utf8)
  {
      return String::fromUTF8WithLatin1Fallback(utf8.data(), utf8.size());
  }
  
<span class="line-modified">! class GlobalObject final : public JSGlobalObject {</span>
  private:
      GlobalObject(VM&amp;, Structure*);
  
  public:
      typedef JSGlobalObject Base;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 490,12 ***</span>
          GlobalObject* object = new (NotNull, allocateCell&lt;GlobalObject&gt;(vm.heap)) GlobalObject(vm, structure);
          object-&gt;finishCreation(vm, arguments);
          return object;
      }
  
<span class="line-removed">-     static const bool needsDestruction = false;</span>
<span class="line-removed">- </span>
      DECLARE_INFO;
      static const GlobalObjectMethodTable s_globalObjectMethodTable;
  
      static Structure* createStructure(VM&amp; vm, JSValue prototype)
      {
<span class="line-new-header">--- 498,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 516,11 ***</span>
          addFunction(vm, &quot;printErr&quot;, functionPrintStdErr, 1);
          addFunction(vm, &quot;quit&quot;, functionQuit, 0);
          addFunction(vm, &quot;gc&quot;, functionGCAndSweep, 0);
          addFunction(vm, &quot;fullGC&quot;, functionFullGC, 0);
          addFunction(vm, &quot;edenGC&quot;, functionEdenGC, 0);
<span class="line-removed">-         addFunction(vm, &quot;forceGCSlowPaths&quot;, functionForceGCSlowPaths, 0);</span>
          addFunction(vm, &quot;gcHeapSize&quot;, functionHeapSize, 0);
          addFunction(vm, &quot;MemoryFootprint&quot;, functionCreateMemoryFootprint, 0);
          addFunction(vm, &quot;resetMemoryPeak&quot;, functionResetMemoryPeak, 0);
          addFunction(vm, &quot;addressOf&quot;, functionAddressOf, 1);
          addFunction(vm, &quot;version&quot;, functionVersion, 1);
<span class="line-new-header">--- 522,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 539,10 ***</span>
<span class="line-new-header">--- 544,11 ---</span>
          addFunction(vm, &quot;noInline&quot;, functionNeverInlineFunction, 1);
          addFunction(vm, &quot;noDFG&quot;, functionNoDFG, 1);
          addFunction(vm, &quot;noFTL&quot;, functionNoFTL, 1);
          addFunction(vm, &quot;noOSRExitFuzzing&quot;, functionNoOSRExitFuzzing, 1);
          addFunction(vm, &quot;numberOfDFGCompiles&quot;, functionNumberOfDFGCompiles, 1);
<span class="line-added">+         addFunction(vm, &quot;callerIsOMGCompiled&quot;, functionCallerIsOMGCompiled, 0);</span>
          addFunction(vm, &quot;jscOptions&quot;, functionJSCOptions, 0);
          addFunction(vm, &quot;optimizeNextInvocation&quot;, functionOptimizeNextInvocation, 1);
          addFunction(vm, &quot;reoptimizationRetryCount&quot;, functionReoptimizationRetryCount, 1);
          addFunction(vm, &quot;transferArrayBuffer&quot;, functionTransferArrayBuffer, 1);
          addFunction(vm, &quot;failNextNewCodeBlock&quot;, functionFailNextNewCodeBlock, 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 596,13 ***</span>
  #if ENABLE(WEBASSEMBLY)
          addFunction(vm, &quot;WebAssemblyMemoryMode&quot;, functionWebAssemblyMemoryMode, 1);
  #endif
  
          if (!arguments.isEmpty()) {
<span class="line-modified">!             JSArray* array = constructEmptyArray(globalExec(), 0);</span>
              for (size_t i = 0; i &lt; arguments.size(); ++i)
<span class="line-modified">!                 array-&gt;putDirectIndex(globalExec(), i, jsString(vm, arguments[i]));</span>
              putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);
          }
  
          putDirect(vm, Identifier::fromString(vm, &quot;console&quot;), jsUndefined());
  
<span class="line-new-header">--- 602,13 ---</span>
  #if ENABLE(WEBASSEMBLY)
          addFunction(vm, &quot;WebAssemblyMemoryMode&quot;, functionWebAssemblyMemoryMode, 1);
  #endif
  
          if (!arguments.isEmpty()) {
<span class="line-modified">!             JSArray* array = constructEmptyArray(this, 0);</span>
              for (size_t i = 0; i &lt; arguments.size(); ++i)
<span class="line-modified">!                 array-&gt;putDirectIndex(this, i, jsString(vm, arguments[i]));</span>
              putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);
          }
  
          putDirect(vm, Identifier::fromString(vm, &quot;console&quot;), jsUndefined());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 611,11 ***</span>
          JSObject* dollar = JSFinalObject::create(vm, plainObjectStructure);
          putDirect(vm, Identifier::fromString(vm, &quot;$&quot;), dollar);
          putDirect(vm, Identifier::fromString(vm, &quot;$262&quot;), dollar);
  
          addFunction(vm, dollar, &quot;createRealm&quot;, functionDollarCreateRealm, 0);
<span class="line-modified">!         addFunction(vm, dollar, &quot;detachArrayBuffer&quot;, functionDollarDetachArrayBuffer, 1);</span>
          addFunction(vm, dollar, &quot;evalScript&quot;, functionDollarEvalScript, 1);
  
          dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;global&quot;), this);
  
          JSObject* agent = JSFinalObject::create(vm, plainObjectStructure);
<span class="line-new-header">--- 617,11 ---</span>
          JSObject* dollar = JSFinalObject::create(vm, plainObjectStructure);
          putDirect(vm, Identifier::fromString(vm, &quot;$&quot;), dollar);
          putDirect(vm, Identifier::fromString(vm, &quot;$262&quot;), dollar);
  
          addFunction(vm, dollar, &quot;createRealm&quot;, functionDollarCreateRealm, 0);
<span class="line-modified">!         addFunction(vm, dollar, &quot;detachArrayBuffer&quot;, functionTransferArrayBuffer, 1);</span>
          addFunction(vm, dollar, &quot;evalScript&quot;, functionDollarEvalScript, 1);
  
          dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;global&quot;), this);
  
          JSObject* agent = JSFinalObject::create(vm, plainObjectStructure);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 653,15 ***</span>
      void addFunction(VM&amp; vm, const char* name, NativeFunction function, unsigned arguments)
      {
          addFunction(vm, this, name, function, arguments);
      }
  
<span class="line-modified">!     static JSInternalPromise* moduleLoaderImportModule(JSGlobalObject*, ExecState*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);</span>
<span class="line-modified">!     static Identifier moduleLoaderResolve(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
<span class="line-modified">!     static JSInternalPromise* moduleLoaderFetch(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
<span class="line-modified">!     static JSObject* moduleLoaderCreateImportMetaProperties(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);</span>
  };
  
  static bool supportsRichSourceInfo = true;
  static bool shellSupportsRichSourceInfo(const JSGlobalObject*)
  {
      return supportsRichSourceInfo;
<span class="line-new-header">--- 659,16 ---</span>
      void addFunction(VM&amp; vm, const char* name, NativeFunction function, unsigned arguments)
      {
          addFunction(vm, this, name, function, arguments);
      }
  
<span class="line-modified">!     static JSInternalPromise* moduleLoaderImportModule(JSGlobalObject*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);</span>
<span class="line-modified">!     static Identifier moduleLoaderResolve(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
<span class="line-modified">!     static JSInternalPromise* moduleLoaderFetch(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
<span class="line-modified">!     static JSObject* moduleLoaderCreateImportMetaProperties(JSGlobalObject*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);</span>
  };
<span class="line-added">+ STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(GlobalObject, JSGlobalObject);</span>
  
  static bool supportsRichSourceInfo = true;
  static bool shellSupportsRichSourceInfo(const JSGlobalObject*)
  {
      return supportsRichSourceInfo;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 814,81 ***</span>
      if (!directoryName)
          return fileName;
      return resolvePath(directoryName.value(), ModuleName(fileName.impl()));
  }
  
<span class="line-modified">! JSInternalPromise* GlobalObject::moduleLoaderImportModule(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSString* moduleNameValue, JSValue parameters, const SourceOrigin&amp; sourceOrigin)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
      auto reject = [&amp;] (JSValue rejectionReason) {
          catchScope.clearException();
<span class="line-modified">!         auto result = deferred-&gt;reject(exec, rejectionReason);</span>
          catchScope.clearException();
<span class="line-modified">!         return result;</span>
      };
  
      if (sourceOrigin.isNull())
<span class="line-modified">!         return reject(createError(exec, &quot;Could not resolve the module specifier.&quot;_s));</span>
  
<span class="line-modified">!     const auto&amp; referrer = sourceOrigin.string();</span>
<span class="line-modified">!     const auto&amp; moduleName = moduleNameValue-&gt;value(exec);</span>
      if (UNLIKELY(catchScope.exception()))
          return reject(catchScope.exception());
  
      auto directoryName = extractDirectoryName(referrer.impl());
      if (!directoryName)
<span class="line-modified">!         return reject(createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));</span>
  
<span class="line-modified">!     auto result = JSC::importModule(exec, Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());</span>
      if (UNLIKELY(catchScope.exception()))
          return reject(catchScope.exception());
      return result;
  }
  
<span class="line-modified">! Identifier GlobalObject::moduleLoaderResolve(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue keyValue, JSValue referrerValue, JSValue)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      scope.releaseAssertNoException();
<span class="line-modified">!     const Identifier key = keyValue.toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (key.isSymbol())
          return key;
  
      if (referrerValue.isUndefined()) {
          auto directoryName = currentWorkingDirectory();
          if (!directoryName) {
<span class="line-modified">!             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));</span>
              return { };
          }
          return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
      }
  
<span class="line-modified">!     const Identifier referrer = referrerValue.toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (referrer.isSymbol()) {
          auto directoryName = currentWorkingDirectory();
          if (!directoryName) {
<span class="line-modified">!             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));</span>
              return { };
          }
          return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
      }
  
      // If the referrer exists, we assume that the referrer is the correct absolute path.
      auto directoryName = extractDirectoryName(referrer.impl());
      if (!directoryName) {
<span class="line-modified">!         throwException(exec, scope, createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));</span>
          return { };
      }
      return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
  }
  
<span class="line-new-header">--- 821,81 ---</span>
      if (!directoryName)
          return fileName;
      return resolvePath(directoryName.value(), ModuleName(fileName.impl()));
  }
  
<span class="line-modified">! JSInternalPromise* GlobalObject::moduleLoaderImportModule(JSGlobalObject* globalObject, JSModuleLoader*, JSString* moduleNameValue, JSValue parameters, const SourceOrigin&amp; sourceOrigin)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
      auto reject = [&amp;] (JSValue rejectionReason) {
          catchScope.clearException();
<span class="line-modified">!         promise-&gt;reject(globalObject, rejectionReason);</span>
          catchScope.clearException();
<span class="line-modified">!         return promise;</span>
      };
  
      if (sourceOrigin.isNull())
<span class="line-modified">!         return reject(createError(globalObject, &quot;Could not resolve the module specifier.&quot;_s));</span>
  
<span class="line-modified">!     auto referrer = sourceOrigin.string();</span>
<span class="line-modified">!     auto moduleName = moduleNameValue-&gt;value(globalObject);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
      if (UNLIKELY(catchScope.exception()))
          return reject(catchScope.exception());
  
      auto directoryName = extractDirectoryName(referrer.impl());
      if (!directoryName)
<span class="line-modified">!         return reject(createError(globalObject, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));</span>
  
<span class="line-modified">!     auto result = JSC::importModule(globalObject, Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());</span>
      if (UNLIKELY(catchScope.exception()))
          return reject(catchScope.exception());
      return result;
  }
  
<span class="line-modified">! Identifier GlobalObject::moduleLoaderResolve(JSGlobalObject* globalObject, JSModuleLoader*, JSValue keyValue, JSValue referrerValue, JSValue)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      scope.releaseAssertNoException();
<span class="line-modified">!     const Identifier key = keyValue.toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (key.isSymbol())
          return key;
  
      if (referrerValue.isUndefined()) {
          auto directoryName = currentWorkingDirectory();
          if (!directoryName) {
<span class="line-modified">!             throwException(globalObject, scope, createError(globalObject, &quot;Could not resolve the current working directory.&quot;_s));</span>
              return { };
          }
          return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
      }
  
<span class="line-modified">!     const Identifier referrer = referrerValue.toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (referrer.isSymbol()) {
          auto directoryName = currentWorkingDirectory();
          if (!directoryName) {
<span class="line-modified">!             throwException(globalObject, scope, createError(globalObject, &quot;Could not resolve the current working directory.&quot;_s));</span>
              return { };
          }
          return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
      }
  
      // If the referrer exists, we assume that the referrer is the correct absolute path.
      auto directoryName = extractDirectoryName(referrer.impl());
      if (!directoryName) {
<span class="line-modified">!         throwException(globalObject, scope, createError(globalObject, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));</span>
          return { };
      }
      return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1150,33 ***</span>
      fclose(f);
  
      return result;
  }
  
<span class="line-modified">! JSInternalPromise* GlobalObject::moduleLoaderFetch(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSValue, JSValue)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">-     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
      auto reject = [&amp;] (JSValue rejectionReason) {
          catchScope.clearException();
<span class="line-modified">!         auto result = deferred-&gt;reject(exec, rejectionReason);</span>
          catchScope.clearException();
<span class="line-modified">!         return result;</span>
      };
  
<span class="line-modified">!     String moduleKey = key.toWTFString(exec);</span>
      if (UNLIKELY(catchScope.exception()))
          return reject(catchScope.exception());
  
      // Here, now we consider moduleKey as the fileName.
      Vector&lt;uint8_t&gt; buffer;
      if (!fetchModuleFromLocalFileSystem(moduleKey, buffer))
<span class="line-modified">!         return reject(createError(exec, makeString(&quot;Could not open file &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));</span>
  
  
      URL moduleURL = URL({ }, moduleKey);
  #if ENABLE(WEBASSEMBLY)
      // FileSystem does not have mime-type header. The JSC shell recognizes WebAssembly&#39;s magic header.
<span class="line-new-header">--- 1157,31 ---</span>
      fclose(f);
  
      return result;
  }
  
<span class="line-modified">! JSInternalPromise* GlobalObject::moduleLoaderFetch(JSGlobalObject* globalObject, JSModuleLoader*, JSValue key, JSValue, JSValue)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     JSInternalPromise* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
      auto reject = [&amp;] (JSValue rejectionReason) {
          catchScope.clearException();
<span class="line-modified">!         promise-&gt;reject(globalObject, rejectionReason);</span>
          catchScope.clearException();
<span class="line-modified">!         return promise;</span>
      };
  
<span class="line-modified">!     String moduleKey = key.toWTFString(globalObject);</span>
      if (UNLIKELY(catchScope.exception()))
          return reject(catchScope.exception());
  
      // Here, now we consider moduleKey as the fileName.
      Vector&lt;uint8_t&gt; buffer;
      if (!fetchModuleFromLocalFileSystem(moduleKey, buffer))
<span class="line-modified">!         return reject(createError(globalObject, makeString(&quot;Could not open file &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));</span>
  
  
      URL moduleURL = URL({ }, moduleKey);
  #if ENABLE(WEBASSEMBLY)
      // FileSystem does not have mime-type header. The JSC shell recognizes WebAssembly&#39;s magic header.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1184,80 ***</span>
          if (buffer[0] == &#39;\0&#39; &amp;&amp; buffer[1] == &#39;a&#39; &amp;&amp; buffer[2] == &#39;s&#39; &amp;&amp; buffer[3] == &#39;m&#39;) {
              auto source = SourceCode(WebAssemblySourceProvider::create(WTFMove(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL)));
              catchScope.releaseAssertNoException();
              auto sourceCode = JSSourceCode::create(vm, WTFMove(source));
              catchScope.releaseAssertNoException();
<span class="line-modified">!             auto result = deferred-&gt;resolve(exec, sourceCode);</span>
              catchScope.clearException();
<span class="line-modified">!             return result;</span>
          }
      }
  #endif
  
      auto sourceCode = JSSourceCode::create(vm, jscSource(stringFromUTF(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL), TextPosition(), SourceProviderSourceType::Module));
      catchScope.releaseAssertNoException();
<span class="line-modified">!     auto result = deferred-&gt;resolve(exec, sourceCode);</span>
      catchScope.clearException();
<span class="line-modified">!     return result;</span>
  }
  
<span class="line-modified">! JSObject* GlobalObject::moduleLoaderCreateImportMetaProperties(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSModuleRecord*, JSValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* metaProperties = constructEmptyObject(exec, globalObject-&gt;nullPrototypeObjectStructure());</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      metaProperties-&gt;putDirect(vm, Identifier::fromString(vm, &quot;filename&quot;), key);
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      return metaProperties;
  }
  
<span class="line-modified">! static CString cStringFromViewWithString(ExecState* exec, ThrowScope&amp; scope, StringViewWithUnderlyingString&amp; viewWithString)</span>
  {
      Expected&lt;CString, UTF8ConversionError&gt; expectedString = viewWithString.view.tryGetUtf8();
      if (expectedString)
          return expectedString.value();
      switch (expectedString.error()) {
      case UTF8ConversionError::OutOfMemory:
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          break;
      case UTF8ConversionError::IllegalSource:
<span class="line-modified">!         scope.throwException(exec, createError(exec, &quot;Illegal source encountered during UTF8 conversion&quot;));</span>
          break;
      case UTF8ConversionError::SourceExhausted:
<span class="line-modified">!         scope.throwException(exec, createError(exec, &quot;Source exhausted during UTF8 conversion&quot;));</span>
          break;
      default:
          RELEASE_ASSERT_NOT_REACHED();
      }
      return { };
  }
  
<span class="line-modified">! static EncodedJSValue printInternal(ExecState* exec, FILE* out)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (asyncTestExpectedPasses) {
<span class="line-modified">!         JSValue value = exec-&gt;argument(0);</span>
<span class="line-modified">!         if (value.isString() &amp;&amp; WTF::equal(asString(value)-&gt;value(exec).impl(), &quot;Test262:AsyncTestComplete&quot;)) {</span>
              asyncTestPasses++;
              return JSValue::encode(jsUndefined());
          }
      }
  
<span class="line-modified">!     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
          if (i)
              if (EOF == fputc(&#39; &#39;, out))
                  goto fail;
  
<span class="line-modified">!         auto viewWithString = exec-&gt;uncheckedArgument(i).toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!         auto string = cStringFromViewWithString(exec, scope, viewWithString);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (fprintf(out, &quot;%s&quot;, string.data()) &lt; 0)
              goto fail;
      }
  
<span class="line-new-header">--- 1189,80 ---</span>
          if (buffer[0] == &#39;\0&#39; &amp;&amp; buffer[1] == &#39;a&#39; &amp;&amp; buffer[2] == &#39;s&#39; &amp;&amp; buffer[3] == &#39;m&#39;) {
              auto source = SourceCode(WebAssemblySourceProvider::create(WTFMove(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL)));
              catchScope.releaseAssertNoException();
              auto sourceCode = JSSourceCode::create(vm, WTFMove(source));
              catchScope.releaseAssertNoException();
<span class="line-modified">!             promise-&gt;resolve(globalObject, sourceCode);</span>
              catchScope.clearException();
<span class="line-modified">!             return promise;</span>
          }
      }
  #endif
  
      auto sourceCode = JSSourceCode::create(vm, jscSource(stringFromUTF(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL), TextPosition(), SourceProviderSourceType::Module));
      catchScope.releaseAssertNoException();
<span class="line-modified">!     promise-&gt;resolve(globalObject, sourceCode);</span>
      catchScope.clearException();
<span class="line-modified">!     return promise;</span>
  }
  
<span class="line-modified">! JSObject* GlobalObject::moduleLoaderCreateImportMetaProperties(JSGlobalObject* globalObject, JSModuleLoader*, JSValue key, JSModuleRecord*, JSValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* metaProperties = constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure());</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      metaProperties-&gt;putDirect(vm, Identifier::fromString(vm, &quot;filename&quot;), key);
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      return metaProperties;
  }
  
<span class="line-modified">! static CString cStringFromViewWithString(JSGlobalObject* globalObject, ThrowScope&amp; scope, StringViewWithUnderlyingString&amp; viewWithString)</span>
  {
      Expected&lt;CString, UTF8ConversionError&gt; expectedString = viewWithString.view.tryGetUtf8();
      if (expectedString)
          return expectedString.value();
      switch (expectedString.error()) {
      case UTF8ConversionError::OutOfMemory:
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          break;
      case UTF8ConversionError::IllegalSource:
<span class="line-modified">!         scope.throwException(globalObject, createError(globalObject, &quot;Illegal source encountered during UTF8 conversion&quot;));</span>
          break;
      case UTF8ConversionError::SourceExhausted:
<span class="line-modified">!         scope.throwException(globalObject, createError(globalObject, &quot;Source exhausted during UTF8 conversion&quot;));</span>
          break;
      default:
          RELEASE_ASSERT_NOT_REACHED();
      }
      return { };
  }
  
<span class="line-modified">! static EncodedJSValue printInternal(JSGlobalObject* globalObject, CallFrame* callFrame, FILE* out)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (asyncTestExpectedPasses) {
<span class="line-modified">!         JSValue value = callFrame-&gt;argument(0);</span>
<span class="line-modified">!         if (value.isString() &amp;&amp; WTF::equal(asString(value)-&gt;value(globalObject).impl(), &quot;Test262:AsyncTestComplete&quot;)) {</span>
              asyncTestPasses++;
              return JSValue::encode(jsUndefined());
          }
      }
  
<span class="line-modified">!     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
          if (i)
              if (EOF == fputc(&#39; &#39;, out))
                  goto fail;
  
<span class="line-modified">!         auto viewWithString = callFrame-&gt;uncheckedArgument(i).toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!         auto string = cStringFromViewWithString(globalObject, scope, viewWithString);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (fprintf(out, &quot;%s&quot;, string.data()) &lt; 0)
              goto fail;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1265,51 ***</span>
  fail:
      fflush(out);
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState* exec) { return printInternal(exec, stdout); }</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState* exec) { return printInternal(exec, stderr); }</span>
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDebug(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto viewWithString = exec-&gt;argument(0).toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     auto string = cStringFromViewWithString(exec, scope, viewWithString);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      fprintf(stderr, &quot;--&gt; %s\n&quot;, string.data());
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     return JSValue::encode(jsString(vm, toString(exec-&gt;argument(0))));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));</span>
      if (!object)
          return JSValue::encode(jsNontrivialString(vm, &quot;&lt;not object&gt;&quot;_s));
      return JSValue::encode(jsNontrivialString(vm, toString(&quot;&lt;Butterfly: &quot;, RawPointer(object-&gt;butterfly()), &quot;; public length: &quot;, object-&gt;getArrayLength(), &quot;; vector length: &quot;, object-&gt;getVectorLength(), &quot;&gt;&quot;)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">!         Seconds seconds = Seconds(exec-&gt;argument(0).toNumber(exec));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          sleep(seconds);
      }
  
      return JSValue::encode(jsUndefined());
<span class="line-new-header">--- 1270,51 ---</span>
  fail:
      fflush(out);
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionPrintStdOut(JSGlobalObject* globalObject, CallFrame* callFrame) { return printInternal(globalObject, callFrame, stdout); }</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionPrintStdErr(JSGlobalObject* globalObject, CallFrame* callFrame) { return printInternal(globalObject, callFrame, stderr); }</span>
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDebug(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto viewWithString = callFrame-&gt;argument(0).toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     auto string = cStringFromViewWithString(globalObject, scope, viewWithString);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      fprintf(stderr, &quot;--&gt; %s\n&quot;, string.data());
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDescribe(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     return JSValue::encode(jsString(vm, toString(callFrame-&gt;argument(0))));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDescribeArray(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(0));</span>
      if (!object)
          return JSValue::encode(jsNontrivialString(vm, &quot;&lt;not object&gt;&quot;_s));
      return JSValue::encode(jsNontrivialString(vm, toString(&quot;&lt;Butterfly: &quot;, RawPointer(object-&gt;butterfly()), &quot;; public length: &quot;, object-&gt;getArrayLength(), &quot;; vector length: &quot;, object-&gt;getVectorLength(), &quot;&gt;&quot;)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionSleepSeconds(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">!         Seconds seconds = Seconds(callFrame-&gt;argument(0).toNumber(globalObject));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          sleep(seconds);
      }
  
      return JSValue::encode(jsUndefined());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1330,56 ***</span>
  
  private:
      StringBuilder&amp; m_trace;
  };
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionJSCStack(ExecState* exec)</span>
  {
      StringBuilder trace;
      trace.appendLiteral(&quot;--&gt; Stack trace:\n&quot;);
  
      FunctionJSCStackFunctor functor(trace);
<span class="line-modified">!     exec-&gt;iterate(functor);</span>
      fprintf(stderr, &quot;%s&quot;, trace.toString().utf8().data());
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionGCAndSweep(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      vm.heap.collectNow(Sync, CollectionScope::Full);
      return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionFullGC(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      vm.heap.collectSync(CollectionScope::Full);
      return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      vm.heap.collectSync(CollectionScope::Eden);
      return JSValue::encode(jsNumber(vm.heap.sizeAfterLastEdenCollection()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionForceGCSlowPaths(ExecState*)</span>
  {
<span class="line-modified">!     // It&#39;s best for this to be the first thing called in the</span>
<span class="line-removed">-     // JS program so the option is set to true before we JIT.</span>
<span class="line-removed">-     Options::forceGCSlowPaths() = true;</span>
<span class="line-removed">-     return JSValue::encode(jsUndefined());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- EncodedJSValue JSC_HOST_CALL functionHeapSize(ExecState* exec)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      return JSValue::encode(jsNumber(vm.heap.size()));
  }
  
  class JSCMemoryFootprint : public JSDestructibleObject {
<span class="line-new-header">--- 1335,49 ---</span>
  
  private:
      StringBuilder&amp; m_trace;
  };
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionJSCStack(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      StringBuilder trace;
      trace.appendLiteral(&quot;--&gt; Stack trace:\n&quot;);
  
      FunctionJSCStackFunctor functor(trace);
<span class="line-modified">!     callFrame-&gt;iterate(vm, functor);</span>
      fprintf(stderr, &quot;%s&quot;, trace.toString().utf8().data());
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionGCAndSweep(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      vm.heap.collectNow(Sync, CollectionScope::Full);
      return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionFullGC(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      vm.heap.collectSync(CollectionScope::Full);
      return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionEdenGC(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      vm.heap.collectSync(CollectionScope::Eden);
      return JSValue::encode(jsNumber(vm.heap.sizeAfterLastEdenCollection()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionHeapSize(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      return JSValue::encode(jsNumber(vm.heap.size()));
  }
  
  class JSCMemoryFootprint : public JSDestructibleObject {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1426,307 ***</span>
      }
  };
  
  const ClassInfo JSCMemoryFootprint::s_info = { &quot;MemoryFootprint&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCMemoryFootprint) };
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     return JSValue::encode(JSCMemoryFootprint::create(vm, exec-&gt;lexicalGlobalObject()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*)</span>
  {
      MemoryFootprint::resetPeak();
      return JSValue::encode(jsUndefined());
  }
  
  // This function is not generally very helpful in 64-bit code as the tag and payload
  // share a register. But in 32-bit JITed code the tag may not be checked if an
  // optimization removes type checking requirements, such as in ===.
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionAddressOf(ExecState* exec)</span>
  {
<span class="line-modified">!     JSValue value = exec-&gt;argument(0);</span>
      if (!value.isCell())
          return JSValue::encode(jsUndefined());
      // Need to cast to uint64_t so bitwise_cast will play along.
      uint64_t asNumber = reinterpret_cast&lt;uint64_t&gt;(value.asCell());
      EncodedJSValue returnValue = JSValue::encode(jsNumber(bitwise_cast&lt;double&gt;(asNumber)));
      return returnValue;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionVersion(ExecState*)</span>
  {
      // We need this function for compatibility with the Mozilla JS tests but for now
      // we don&#39;t actually do any version-specific handling
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionRun(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String fileName = exec-&gt;argument(0).toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      Vector&lt;char&gt; script;
      if (!fetchScriptFromLocalFileSystem(fileName, script))
<span class="line-modified">!         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));</span>
  
<span class="line-modified">!     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());</span>
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
<span class="line-modified">!     globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
  
      NakedPtr&lt;Exception&gt; exception;
      StopWatch stopWatch;
      stopWatch.start();
<span class="line-modified">!     evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);</span>
      stopWatch.stop();
  
      if (exception) {
<span class="line-modified">!         throwException(globalObject-&gt;globalExec(), scope, exception);</span>
          return JSValue::encode(jsUndefined());
      }
  
      return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionRunString(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String source = exec-&gt;argument(0).toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());</span>
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
<span class="line-modified">!     globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
  
      NakedPtr&lt;Exception&gt; exception;
<span class="line-modified">!     evaluate(globalObject-&gt;globalExec(), jscSource(source, exec-&gt;callerSourceOrigin()), JSValue(), exception);</span>
  
      if (exception) {
<span class="line-modified">!         scope.throwException(globalObject-&gt;globalExec(), exception);</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     return JSValue::encode(globalObject);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionLoad(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String fileName = exec-&gt;argument(0).toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      Vector&lt;char&gt; script;
      if (!fetchScriptFromLocalFileSystem(fileName, script))
<span class="line-modified">!         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
  
      NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);</span>
      if (evaluationException)
<span class="line-modified">!         throwException(exec, scope, evaluationException);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String sourceCode = exec-&gt;argument(0).toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
  
      NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);</span>
      if (evaluationException)
<span class="line-modified">!         throwException(exec, scope, evaluationException);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String fileName = exec-&gt;argument(0).toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      bool isBinary = false;
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt; 1) {</span>
<span class="line-modified">!         String type = exec-&gt;argument(1).toWTFString(exec);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (type != &quot;binary&quot;)
<span class="line-modified">!             return throwVMError(exec, scope, &quot;Expected &#39;binary&#39; as second argument.&quot;);</span>
          isBinary = true;
      }
  
      RefPtr&lt;Uint8Array&gt; content = fillBufferWithContentsOfFile(fileName);
      if (!content)
<span class="line-modified">!         return throwVMError(exec, scope, &quot;Could not open file.&quot;);</span>
  
      if (!isBinary)
          return JSValue::encode(jsString(vm, String::fromUTF8WithLatin1Fallback(content-&gt;data(), content-&gt;length())));
  
<span class="line-modified">!     Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;typedArrayStructure(TypeUint8);</span>
      JSObject* result = JSUint8Array::create(vm, structure, WTFMove(content));
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String fileName = exec-&gt;argument(0).toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      Vector&lt;char&gt; script;
      if (!fetchScriptFromLocalFileSystem(fileName, script))
<span class="line-modified">!         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
  
      StopWatch stopWatch;
      stopWatch.start();
  
      JSValue syntaxException;
<span class="line-modified">!     bool validSyntax = checkSyntax(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), &amp;syntaxException);</span>
      stopWatch.stop();
  
      if (!validSyntax)
<span class="line-modified">!         throwException(exec, scope, syntaxException);</span>
      return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
  }
  
  #if ENABLE(SAMPLING_FLAGS)
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState* exec)</span>
  {
<span class="line-modified">!     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         unsigned flag = static_cast&lt;unsigned&gt;(exec-&gt;uncheckedArgument(i).toNumber(exec));</span>
          if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
              SamplingFlags::setFlag(flag);
      }
      return JSValue::encode(jsNull());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(ExecState* exec)</span>
  {
<span class="line-modified">!     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         unsigned flag = static_cast&lt;unsigned&gt;(exec-&gt;uncheckedArgument(i).toNumber(exec));</span>
          if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
              SamplingFlags::clearFlag(flag);
      }
      return JSValue::encode(jsNull());
  }
  #endif
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(ExecState* exec)</span>
  {
<span class="line-modified">!     return JSValue::encode(jsNumber(exec-&gt;lexicalGlobalObject()-&gt;weakRandom().seed()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     unsigned seed = exec-&gt;argument(0).toUInt32(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     exec-&gt;lexicalGlobalObject()-&gt;weakRandom().setSeed(seed);</span>
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState* exec)</span>
  {
<span class="line-modified">!     JSValue argument = exec-&gt;argument(0);</span>
      if (!argument.isString())
          return JSValue::encode(jsBoolean(false));
      const StringImpl* impl = asString(argument)-&gt;tryGetValueImpl();
      return JSValue::encode(jsBoolean(!impl));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState* state)</span>
  {
<span class="line-modified">!     SourceOrigin sourceOrigin = state-&gt;callerSourceOrigin();</span>
      if (sourceOrigin.isNull())
          return JSValue::encode(jsNull());
<span class="line-modified">!     return JSValue::encode(jsString(state-&gt;vm(), sourceOrigin.string()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionReadline(ExecState* exec)</span>
  {
      Vector&lt;char, 256&gt; line;
      int c;
      while ((c = getchar()) != EOF) {
          // FIXME: Should we also break on \r?
          if (c == &#39;\n&#39;)
              break;
          line.append(c);
      }
      line.append(&#39;\0&#39;);
<span class="line-modified">!     return JSValue::encode(jsString(exec-&gt;vm(), line.data()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*)</span>
  {
      return JSValue::encode(jsNumber(WallTime::now().secondsSinceEpoch().value()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState* exec)</span>
  {
<span class="line-modified">!     return JSValue::encode(setNeverInline(exec));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState* exec)</span>
  {
<span class="line-modified">!     return JSValue::encode(setNeverOptimize(exec));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount()) {</span>
<span class="line-modified">!         FunctionExecutable* executable = getExecutableForFunction(exec-&gt;argument(0));</span>
          if (executable)
              executable-&gt;setNeverFTLOptimize(true);
      }
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState* exec)</span>
  {
<span class="line-modified">!     return JSValue::encode(setCannotUseOSRExitFuzzing(exec));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState* exec)</span>
  {
<span class="line-modified">!     return JSValue::encode(optimizeNextInvocation(exec));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState* exec)</span>
  {
<span class="line-modified">!     return JSValue::encode(numberOfDFGCompiles(exec));</span>
  }
  
  Message::Message(ArrayBufferContents&amp;&amp; contents, int32_t index)
      : m_contents(WTFMove(contents))
      , m_index(index)
<span class="line-new-header">--- 1424,328 ---</span>
      }
  };
  
  const ClassInfo JSCMemoryFootprint::s_info = { &quot;MemoryFootprint&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCMemoryFootprint) };
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     return JSValue::encode(JSCMemoryFootprint::create(vm, globalObject));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(JSGlobalObject*, CallFrame*)</span>
  {
      MemoryFootprint::resetPeak();
      return JSValue::encode(jsUndefined());
  }
  
  // This function is not generally very helpful in 64-bit code as the tag and payload
  // share a register. But in 32-bit JITed code the tag may not be checked if an
  // optimization removes type checking requirements, such as in ===.
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionAddressOf(JSGlobalObject*, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     JSValue value = callFrame-&gt;argument(0);</span>
      if (!value.isCell())
          return JSValue::encode(jsUndefined());
      // Need to cast to uint64_t so bitwise_cast will play along.
      uint64_t asNumber = reinterpret_cast&lt;uint64_t&gt;(value.asCell());
      EncodedJSValue returnValue = JSValue::encode(jsNumber(bitwise_cast&lt;double&gt;(asNumber)));
      return returnValue;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionVersion(JSGlobalObject*, CallFrame*)</span>
  {
      // We need this function for compatibility with the Mozilla JS tests but for now
      // we don&#39;t actually do any version-specific handling
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionRun(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String fileName = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      Vector&lt;char&gt; script;
      if (!fetchScriptFromLocalFileSystem(fileName, script))
<span class="line-modified">!         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Could not open file.&quot;_s)));</span>
  
<span class="line-modified">!     GlobalObject* realm = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());</span>
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(realm, 0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     for (unsigned i = 1; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         array-&gt;putDirectIndex(realm, i - 1, callFrame-&gt;uncheckedArgument(i));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
<span class="line-modified">!     realm-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
  
      NakedPtr&lt;Exception&gt; exception;
      StopWatch stopWatch;
      stopWatch.start();
<span class="line-modified">!     evaluate(realm, jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);</span>
      stopWatch.stop();
  
      if (exception) {
<span class="line-modified">!         throwException(realm, scope, exception);</span>
          return JSValue::encode(jsUndefined());
      }
  
      return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionRunString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String source = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     GlobalObject* realm = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());</span>
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(realm, 0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     for (unsigned i = 1; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         array-&gt;putDirectIndex(realm, i - 1, callFrame-&gt;uncheckedArgument(i));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
<span class="line-modified">!     realm-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
  
      NakedPtr&lt;Exception&gt; exception;
<span class="line-modified">!     evaluate(realm, jscSource(source, callFrame-&gt;callerSourceOrigin(vm)), JSValue(), exception);</span>
  
      if (exception) {
<span class="line-modified">!         scope.throwException(realm, exception);</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     return JSValue::encode(realm);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionLoad(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String fileName = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      Vector&lt;char&gt; script;
      if (!fetchScriptFromLocalFileSystem(fileName, script))
<span class="line-modified">!         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Could not open file.&quot;_s)));</span>
  
      NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!     JSValue result = evaluate(globalObject, jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);</span>
      if (evaluationException)
<span class="line-modified">!         throwException(globalObject, scope, evaluationException);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionLoadString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String sourceCode = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!     JSValue result = evaluate(globalObject, jscSource(sourceCode, callFrame-&gt;callerSourceOrigin(vm)), JSValue(), evaluationException);</span>
      if (evaluationException)
<span class="line-modified">!         throwException(globalObject, scope, evaluationException);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionReadFile(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String fileName = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      bool isBinary = false;
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt; 1) {</span>
<span class="line-modified">!         String type = callFrame-&gt;argument(1).toWTFString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (type != &quot;binary&quot;)
<span class="line-modified">!             return throwVMError(globalObject, scope, &quot;Expected &#39;binary&#39; as second argument.&quot;);</span>
          isBinary = true;
      }
  
      RefPtr&lt;Uint8Array&gt; content = fillBufferWithContentsOfFile(fileName);
      if (!content)
<span class="line-modified">!         return throwVMError(globalObject, scope, &quot;Could not open file.&quot;);</span>
  
      if (!isBinary)
          return JSValue::encode(jsString(vm, String::fromUTF8WithLatin1Fallback(content-&gt;data(), content-&gt;length())));
  
<span class="line-modified">!     Structure* structure = globalObject-&gt;typedArrayStructure(TypeUint8);</span>
      JSObject* result = JSUint8Array::create(vm, structure, WTFMove(content));
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionCheckSyntax(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String fileName = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      Vector&lt;char&gt; script;
      if (!fetchScriptFromLocalFileSystem(fileName, script))
<span class="line-modified">!         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Could not open file.&quot;_s)));</span>
  
      StopWatch stopWatch;
      stopWatch.start();
  
      JSValue syntaxException;
<span class="line-modified">!     bool validSyntax = checkSyntax(globalObject, jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), &amp;syntaxException);</span>
      stopWatch.stop();
  
      if (!validSyntax)
<span class="line-modified">!         throwException(globalObject, scope, syntaxException);</span>
      return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
  }
  
  #if ENABLE(SAMPLING_FLAGS)
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(JSGlobalObject*, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         unsigned flag = static_cast&lt;unsigned&gt;(callFrame-&gt;uncheckedArgument(i).toNumber(globalObject));</span>
          if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
              SamplingFlags::setFlag(flag);
      }
      return JSValue::encode(jsNull());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(JSGlobalObject*, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         unsigned flag = static_cast&lt;unsigned&gt;(callFrame-&gt;uncheckedArgument(i).toNumber(globalObject));</span>
          if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
              SamplingFlags::clearFlag(flag);
      }
      return JSValue::encode(jsNull());
  }
  #endif
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     return JSValue::encode(jsNumber(globalObject-&gt;weakRandom().seed()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     unsigned seed = callFrame-&gt;argument(0).toUInt32(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     globalObject-&gt;weakRandom().setSeed(seed);</span>
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionIsRope(JSGlobalObject*, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     JSValue argument = callFrame-&gt;argument(0);</span>
      if (!argument.isString())
          return JSValue::encode(jsBoolean(false));
      const StringImpl* impl = asString(argument)-&gt;tryGetValueImpl();
      return JSValue::encode(jsBoolean(!impl));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     SourceOrigin sourceOrigin = callFrame-&gt;callerSourceOrigin(vm);</span>
      if (sourceOrigin.isNull())
          return JSValue::encode(jsNull());
<span class="line-modified">!     return JSValue::encode(jsString(vm, sourceOrigin.string()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionReadline(JSGlobalObject* globalObject, CallFrame*)</span>
  {
      Vector&lt;char, 256&gt; line;
      int c;
      while ((c = getchar()) != EOF) {
          // FIXME: Should we also break on \r?
          if (c == &#39;\n&#39;)
              break;
          line.append(c);
      }
      line.append(&#39;\0&#39;);
<span class="line-modified">!     return JSValue::encode(jsString(globalObject-&gt;vm(), line.data()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionPreciseTime(JSGlobalObject*, CallFrame*)</span>
  {
      return JSValue::encode(jsNumber(WallTime::now().secondsSinceEpoch().value()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return JSValue::encode(setNeverInline(globalObject, callFrame));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionNoDFG(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return JSValue::encode(setNeverOptimize(globalObject, callFrame));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionNoFTL(JSGlobalObject*, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount()) {</span>
<span class="line-modified">!         FunctionExecutable* executable = getExecutableForFunction(callFrame-&gt;argument(0));</span>
          if (executable)
              executable-&gt;setNeverFTLOptimize(true);
      }
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return JSValue::encode(setCannotUseOSRExitFuzzing(globalObject, callFrame));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return JSValue::encode(optimizeNextInvocation(globalObject, callFrame));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return JSValue::encode(numberOfDFGCompiles(globalObject, callFrame));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL functionCallerIsOMGCompiled(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!Options::useBBQTierUpChecks())</span>
<span class="line-added">+         return JSValue::encode(jsBoolean(true));</span>
<span class="line-added">+ </span>
<span class="line-added">+     CallerFunctor wasmToJSFrame;</span>
<span class="line-added">+     StackVisitor::visit(callFrame, vm, wasmToJSFrame);</span>
<span class="line-added">+     if (!wasmToJSFrame.callerFrame()-&gt;isAnyWasmCallee())</span>
<span class="line-added">+         return throwVMError(globalObject, scope, &quot;caller is not a wasm-&gt;js import function&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // We have a wrapper frame that we generate for imports. If we ever can direct call from wasm we would need to change this.</span>
<span class="line-added">+     ASSERT(!wasmToJSFrame.callerFrame()-&gt;callee().isWasm());</span>
<span class="line-added">+     CallerFunctor wasmFrame;</span>
<span class="line-added">+     StackVisitor::visit(wasmToJSFrame.callerFrame(), vm, wasmFrame);</span>
<span class="line-added">+     ASSERT(wasmFrame.callerFrame()-&gt;callee().isWasm());</span>
<span class="line-added">+ #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">+     auto mode = wasmFrame.callerFrame()-&gt;callee().asWasmCallee()-&gt;compilationMode();</span>
<span class="line-added">+     return JSValue::encode(jsBoolean(mode == Wasm::CompilationMode::OMGMode || mode == Wasm::CompilationMode::OMGForOSREntryMode));</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     RELEASE_ASSERT_NOT_REACHED();</span>
  }
  
  Message::Message(ArrayBufferContents&amp;&amp; contents, int32_t index)
      : m_contents(WTFMove(contents))
      , m_index(index)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1836,49 ***</span>
              result = new Workers();
          });
      return *result;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      GlobalObject* result = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
      return JSValue::encode(result-&gt;getDirect(vm, Identifier::fromString(vm, &quot;$&quot;)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState* exec)</span>
  {
<span class="line-modified">!     return functionTransferArrayBuffer(exec);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState* exec)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String sourceCode = exec-&gt;argument(0).toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     GlobalObject* globalObject = jsDynamicCast&lt;GlobalObject*&gt;(vm,</span>
<span class="line-modified">!         exec-&gt;thisValue().get(exec, Identifier::fromString(vm, &quot;global&quot;)));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     if (!globalObject)</span>
<span class="line-modified">!         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected global to point to a global object&quot;_s)));</span>
  
      NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);</span>
      if (evaluationException)
<span class="line-modified">!         throwException(exec, scope, evaluationException);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String sourceCode = exec-&gt;argument(0).toWTFString(exec).isolatedCopy();</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      Lock didStartLock;
      Condition didStartCondition;
      bool didStart = false;
<span class="line-new-header">--- 1855,44 ---</span>
              result = new Workers();
          });
      return *result;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      GlobalObject* result = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
      return JSValue::encode(result-&gt;getDirect(vm, Identifier::fromString(vm, &quot;$&quot;)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String sourceCode = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     GlobalObject* realm = jsDynamicCast&lt;GlobalObject*&gt;(vm,</span>
<span class="line-modified">!         callFrame-&gt;thisValue().get(globalObject, Identifier::fromString(vm, &quot;global&quot;)));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     if (!realm)</span>
<span class="line-modified">!         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Expected global to point to a global object&quot;_s)));</span>
  
      NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!     JSValue result = evaluate(realm, jscSource(sourceCode, callFrame-&gt;callerSourceOrigin(vm)), JSValue(), evaluationException);</span>
      if (evaluationException)
<span class="line-modified">!         throwException(globalObject, scope, evaluationException);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String sourceCode = callFrame-&gt;argument(0).toWTFString(globalObject).isolatedCopy();</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      Lock didStartLock;
      Condition didStartCondition;
      bool didStart = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1898,14 ***</span>
                          didStartCondition.notifyOne();
                      }
  
                      NakedPtr&lt;Exception&gt; evaluationException;
                      JSValue result;
<span class="line-modified">!                     result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, SourceOrigin(&quot;worker&quot;_s)), JSValue(), evaluationException);</span>
                      if (evaluationException)
                          result = evaluationException-&gt;value();
<span class="line-modified">!                     checkException(globalObject-&gt;globalExec(), globalObject, true, evaluationException, result, commandLine, success);</span>
                      if (!success)
                          exit(1);
                  });
          })-&gt;detach();
  
<span class="line-new-header">--- 1912,14 ---</span>
                          didStartCondition.notifyOne();
                      }
  
                      NakedPtr&lt;Exception&gt; evaluationException;
                      JSValue result;
<span class="line-modified">!                     result = evaluate(globalObject, jscSource(sourceCode, SourceOrigin(&quot;worker&quot;_s)), JSValue(), evaluationException);</span>
                      if (evaluationException)
                          result = evaluationException-&gt;value();
<span class="line-modified">!                     checkException(globalObject, true, evaluationException, result, commandLine, success);</span>
                      if (!success)
                          exit(1);
                  });
          })-&gt;detach();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1916,75 ***</span>
      }
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue callback = exec-&gt;argument(0);</span>
      CallData callData;
      CallType callType = getCallData(vm, callback, callData);
      if (callType == CallType::None)
<span class="line-modified">!         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected callback&quot;_s)));</span>
  
      RefPtr&lt;Message&gt; message;
      {
          ReleaseHeapAccessScope releaseAccess(vm.heap);
          message = Worker::current().dequeue();
      }
  
      auto nativeBuffer = ArrayBuffer::create(message-&gt;releaseContents());
      ArrayBufferSharingMode sharingMode = nativeBuffer-&gt;sharingMode();
<span class="line-modified">!     JSArrayBuffer* jsBuffer = JSArrayBuffer::create(vm, exec-&gt;lexicalGlobalObject()-&gt;arrayBufferStructure(sharingMode), WTFMove(nativeBuffer));</span>
  
      MarkedArgumentBuffer args;
      args.append(jsBuffer);
      args.append(jsNumber(message-&gt;index()));
      if (UNLIKELY(args.hasOverflowed()))
<span class="line-modified">!         return JSValue::encode(throwOutOfMemoryError(exec, scope));</span>
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, callback, callType, callData, jsNull(), args)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String report = exec-&gt;argument(0).toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      Workers::singleton().report(report);
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">!         Seconds seconds = Seconds::fromMilliseconds(exec-&gt;argument(0).toNumber(exec));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          sleep(seconds);
      }
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, exec-&gt;argument(0));</span>
      if (!jsBuffer || !jsBuffer-&gt;isShared())
<span class="line-modified">!         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected SharedArrayBuffer&quot;_s)));</span>
  
<span class="line-modified">!     int32_t index = exec-&gt;argument(1).toInt32(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      Workers::singleton().broadcast(
          [&amp;] (const AbstractLocker&amp; locker, Worker&amp; worker) {
              ArrayBuffer* nativeBuffer = jsBuffer-&gt;impl();
<span class="line-new-header">--- 1930,75 ---</span>
      }
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue callback = callFrame-&gt;argument(0);</span>
      CallData callData;
      CallType callType = getCallData(vm, callback, callData);
      if (callType == CallType::None)
<span class="line-modified">!         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Expected callback&quot;_s)));</span>
  
      RefPtr&lt;Message&gt; message;
      {
          ReleaseHeapAccessScope releaseAccess(vm.heap);
          message = Worker::current().dequeue();
      }
  
      auto nativeBuffer = ArrayBuffer::create(message-&gt;releaseContents());
      ArrayBufferSharingMode sharingMode = nativeBuffer-&gt;sharingMode();
<span class="line-modified">!     JSArrayBuffer* jsBuffer = JSArrayBuffer::create(vm, globalObject-&gt;arrayBufferStructure(sharingMode), WTFMove(nativeBuffer));</span>
  
      MarkedArgumentBuffer args;
      args.append(jsBuffer);
      args.append(jsNumber(message-&gt;index()));
      if (UNLIKELY(args.hasOverflowed()))
<span class="line-modified">!         return JSValue::encode(throwOutOfMemoryError(globalObject, scope));</span>
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(call(globalObject, callback, callType, callData, jsNull(), args)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String report = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      Workers::singleton().report(report);
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">!         Seconds seconds = Seconds::fromMilliseconds(callFrame-&gt;argument(0).toNumber(globalObject));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          sleep(seconds);
      }
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, callFrame-&gt;argument(0));</span>
      if (!jsBuffer || !jsBuffer-&gt;isShared())
<span class="line-modified">!         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Expected SharedArrayBuffer&quot;_s)));</span>
  
<span class="line-modified">!     int32_t index = callFrame-&gt;argument(1).toInt32(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      Workers::singleton().broadcast(
          [&amp;] (const AbstractLocker&amp; locker, Worker&amp; worker) {
              ArrayBuffer* nativeBuffer = jsBuffer-&gt;impl();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1995,34 ***</span>
          });
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      String string = Workers::singleton().tryGetReport();
      if (!string)
          return JSValue::encode(jsNull());
  
      return JSValue::encode(jsString(vm, string));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*)</span>
  {
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*)</span>
  {
      return JSValue::encode(jsNumber(MonotonicTime::now().secondsSinceEpoch().milliseconds()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      String string;
      {
          ReleaseHeapAccessScope releaseAccess(vm.heap);
          string = Workers::singleton().getReport();
<span class="line-new-header">--- 2009,34 ---</span>
          });
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
      String string = Workers::singleton().tryGetReport();
      if (!string)
          return JSValue::encode(jsNull());
  
      return JSValue::encode(jsString(vm, string));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(JSGlobalObject*, CallFrame*)</span>
  {
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(JSGlobalObject*, CallFrame*)</span>
  {
      return JSValue::encode(jsNumber(MonotonicTime::now().secondsSinceEpoch().milliseconds()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionWaitForReport(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
      String string;
      {
          ReleaseHeapAccessScope releaseAccess(vm.heap);
          string = Workers::singleton().getReport();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2031,51 ***</span>
          return JSValue::encode(jsNull());
  
      return JSValue::encode(jsString(vm, string));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      return JSValue::encode(jsNumber(vm.heap.capacity()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      double sleepTimeMs = 0;
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">!         sleepTimeMs = exec-&gt;argument(0).toNumber(exec);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
      vm.heap.releaseAccess();
      if (sleepTimeMs)
          sleep(Seconds::fromMilliseconds(sleepTimeMs));
      vm.heap.acquireAccess();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*)</span>
  {
      supportsRichSourceInfo = false;
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*)</span>
  {
      Vector&lt;void*&gt; ptrs;
      for (unsigned i = 0; i &lt; 5000; ++i)
          ptrs.append(fastMalloc(1024 * 2));
      for (void* ptr : ptrs)
          fastFree(ptr);
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*)</span>
  {
  #if ENABLE(JIT)
      return JSValue::encode(jsNumber(JIT::totalCompileTime().milliseconds()));
  #else
      return JSValue::encode(jsNumber(0));
<span class="line-new-header">--- 2045,51 ---</span>
          return JSValue::encode(jsNull());
  
      return JSValue::encode(jsString(vm, string));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionHeapCapacity(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      return JSValue::encode(jsNumber(vm.heap.capacity()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      double sleepTimeMs = 0;
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">!         sleepTimeMs = callFrame-&gt;argument(0).toNumber(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
      vm.heap.releaseAccess();
      if (sleepTimeMs)
          sleep(Seconds::fromMilliseconds(sleepTimeMs));
      vm.heap.acquireAccess();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(JSGlobalObject*, CallFrame*)</span>
  {
      supportsRichSourceInfo = false;
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionMallocInALoop(JSGlobalObject*, CallFrame*)</span>
  {
      Vector&lt;void*&gt; ptrs;
      for (unsigned i = 0; i &lt; 5000; ++i)
          ptrs.append(fastMalloc(1024 * 2));
      for (void* ptr : ptrs)
          fastFree(ptr);
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(JSGlobalObject*, CallFrame*)</span>
  {
  #if ENABLE(JIT)
      return JSValue::encode(jsNumber(JIT::totalCompileTime().milliseconds()));
  #else
      return JSValue::encode(jsNumber(0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2089,88 ***</span>
  typename std::enable_if&lt;std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp; vm, JSObject* optionsObject, const Identifier&amp; identifier, ValueType value)
  {
      optionsObject-&gt;putDirect(vm, identifier, JSValue(value));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSObject* optionsObject = constructEmptyObject(exec);</span>
<span class="line-modified">! #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \</span>
      addOption(vm, optionsObject, Identifier::fromString(vm, #name_), Options::name_());
<span class="line-modified">!     JSC_OPTIONS(FOR_EACH_OPTION)</span>
<span class="line-modified">! #undef FOR_EACH_OPTION</span>
      return JSValue::encode(optionsObject);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     CodeBlock* block = getSomeBaselineCodeBlockForFunction(exec-&gt;argument(0));</span>
      if (!block)
          return JSValue::encode(jsNumber(0));
  
      return JSValue::encode(jsNumber(block-&gt;reoptimizationRetryCounter()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
<span class="line-modified">!         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Not enough arguments&quot;_s)));</span>
  
<span class="line-modified">!     JSArrayBuffer* buffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, exec-&gt;argument(0));</span>
      if (!buffer)
<span class="line-modified">!         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected an array buffer&quot;_s)));</span>
  
      ArrayBufferContents dummyContents;
      buffer-&gt;impl()-&gt;transferTo(vm, dummyContents);
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      vm.setFailNextNewCodeBlock();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionQuit(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      vm.codeCache()-&gt;write(vm);
  
      jscExit(EXIT_SUCCESS);
  
  #if COMPILER(MSVC)
      // Without this, Visual Studio will complain that this method does not return a value.
      return JSValue::encode(jsUndefined());
  #endif
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*) { return JSValue::encode(jsBoolean(false)); }</span>
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*) { return JSValue::encode(jsUndefined()); }</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*) { return JSValue::encode(jsUndefined()); }</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState* exec)</span>
  {
<span class="line-modified">!     for (size_t i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         if (!exec-&gt;argument(i).isInt32())</span>
              return JSValue::encode(jsBoolean(false));
      }
      return JSValue::encode(jsBoolean(true));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState* exec)</span>
  {
<span class="line-modified">!     for (size_t i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         JSValue value = exec-&gt;argument(i);</span>
          if (!value.isNumber())
              return JSValue::encode(jsBoolean(false));
          double number = value.asNumber();
          if (!std::isnan(number))
              return JSValue::encode(jsBoolean(false));
<span class="line-new-header">--- 2103,88 ---</span>
  typename std::enable_if&lt;std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp; vm, JSObject* optionsObject, const Identifier&amp; identifier, ValueType value)
  {
      optionsObject-&gt;putDirect(vm, identifier, JSValue(value));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionJSCOptions(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSObject* optionsObject = constructEmptyObject(globalObject);</span>
<span class="line-modified">! #define READ_OPTION(type_, name_, defaultValue_, availability_, description_) \</span>
      addOption(vm, optionsObject, Identifier::fromString(vm, #name_), Options::name_());
<span class="line-modified">!     FOR_EACH_JSC_OPTION(READ_OPTION)</span>
<span class="line-modified">! #undef READ_OPTION</span>
      return JSValue::encode(optionsObject);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(JSGlobalObject*, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     CodeBlock* block = getSomeBaselineCodeBlockForFunction(callFrame-&gt;argument(0));</span>
      if (!block)
          return JSValue::encode(jsNumber(0));
  
      return JSValue::encode(jsNumber(block-&gt;reoptimizationRetryCounter()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1)</span>
<span class="line-modified">!         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Not enough arguments&quot;_s)));</span>
  
<span class="line-modified">!     JSArrayBuffer* buffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, callFrame-&gt;argument(0));</span>
      if (!buffer)
<span class="line-modified">!         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Expected an array buffer&quot;_s)));</span>
  
      ArrayBufferContents dummyContents;
      buffer-&gt;impl()-&gt;transferTo(vm, dummyContents);
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      vm.setFailNextNewCodeBlock();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionQuit(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      vm.codeCache()-&gt;write(vm);
  
      jscExit(EXIT_SUCCESS);
  
  #if COMPILER(MSVC)
      // Without this, Visual Studio will complain that this method does not return a value.
      return JSValue::encode(jsUndefined());
  #endif
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionFalse(JSGlobalObject*, CallFrame*) { return JSValue::encode(jsBoolean(false)); }</span>
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionUndefined1(JSGlobalObject*, CallFrame*) { return JSValue::encode(jsUndefined()); }</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionUndefined2(JSGlobalObject*, CallFrame*) { return JSValue::encode(jsUndefined()); }</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionIsInt32(JSGlobalObject*, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     for (size_t i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         if (!callFrame-&gt;argument(i).isInt32())</span>
              return JSValue::encode(jsBoolean(false));
      }
      return JSValue::encode(jsBoolean(true));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionIsPureNaN(JSGlobalObject*, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     for (size_t i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         JSValue value = callFrame-&gt;argument(i);</span>
          if (!value.isNumber())
              return JSValue::encode(jsBoolean(false));
          double number = value.asNumber();
          if (!std::isnan(number))
              return JSValue::encode(jsBoolean(false));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2178,115 ***</span>
              return JSValue::encode(jsBoolean(false));
      }
      return JSValue::encode(jsBoolean(true));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState* exec) { return JSValue::encode(exec-&gt;argument(0)); }</span>
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*)</span>
  {
      return JSValue::encode(jsNumber(42));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     return JSValue::encode(Masquerader::create(vm, exec-&gt;lexicalGlobalObject()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState* exec)</span>
  {
<span class="line-modified">!     JSValue value = exec-&gt;argument(0);</span>
      if (value.isObject())
<span class="line-modified">!         return JSValue::encode(jsBoolean(asObject(value)-&gt;hasCustomProperties(exec-&gt;vm())));</span>
      return JSValue::encode(jsBoolean(false));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      vm.dumpTypeProfilerData();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      vm.drainMicrotasks();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      vm.finalizeSynchronousJSExecution();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*)</span>
  {
  #if USE(JSVALUE64)
      return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
  #else
      return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
  #endif
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      return JSValue::encode(GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String source = exec-&gt;argument(0).toWTFString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      StopWatch stopWatch;
      stopWatch.start();
  
      ParserError error;
<span class="line-modified">!     bool validSyntax = checkModuleSyntax(exec, jscSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      stopWatch.stop();
  
      if (!validSyntax)
<span class="line-modified">!         throwException(exec, scope, jsNontrivialString(vm, toString(&quot;SyntaxError: &quot;, error.message(), &quot;:&quot;, error.line())));</span>
      return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*)</span>
  {
  #if ENABLE(SAMPLING_PROFILER)
      return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
  #else
      return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
  #endif
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler());
      snapshotBuilder.buildSnapshot();
  
      String jsonString = snapshotBuilder.json();
<span class="line-modified">!     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));</span>
      scope.releaseAssertNoException();
      return result;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
      String jsonString;
      {
          DeferGCForAWhile deferGC(vm.heap); // Prevent concurrent GC from interfering with the full GC that the snapshot does.
<span class="line-new-header">--- 2192,115 ---</span>
              return JSValue::encode(jsBoolean(false));
      }
      return JSValue::encode(jsBoolean(true));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionIdentity(JSGlobalObject*, CallFrame* callFrame) { return JSValue::encode(callFrame-&gt;argument(0)); }</span>
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionEffectful42(JSGlobalObject*, CallFrame*)</span>
  {
      return JSValue::encode(jsNumber(42));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     return JSValue::encode(Masquerader::create(vm, globalObject));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     JSValue value = callFrame-&gt;argument(0);</span>
      if (value.isObject())
<span class="line-modified">!         return JSValue::encode(jsBoolean(asObject(value)-&gt;hasCustomProperties(globalObject-&gt;vm())));</span>
      return JSValue::encode(jsBoolean(false));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      vm.dumpTypeProfilerData();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      vm.drainMicrotasks();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      vm.finalizeSynchronousJSExecution();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(JSGlobalObject*, CallFrame*)</span>
  {
  #if USE(JSVALUE64)
      return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
  #else
      return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
  #endif
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      return JSValue::encode(GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String source = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      StopWatch stopWatch;
      stopWatch.start();
  
      ParserError error;
<span class="line-modified">!     bool validSyntax = checkModuleSyntax(globalObject, jscSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      stopWatch.stop();
  
      if (!validSyntax)
<span class="line-modified">!         throwException(globalObject, scope, jsNontrivialString(vm, toString(&quot;SyntaxError: &quot;, error.message(), &quot;:&quot;, error.line())));</span>
      return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(JSGlobalObject*, CallFrame*)</span>
  {
  #if ENABLE(SAMPLING_PROFILER)
      return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
  #else
      return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
  #endif
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler());
      snapshotBuilder.buildSnapshot();
  
      String jsonString = snapshotBuilder.json();
<span class="line-modified">!     EncodedJSValue result = JSValue::encode(JSONParse(globalObject, jsonString));</span>
      scope.releaseAssertNoException();
      return result;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
      String jsonString;
      {
          DeferGCForAWhile deferGC(vm.heap); // Prevent concurrent GC from interfering with the full GC that the snapshot does.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2298,107 ***</span>
      }
      scope.releaseAssertNoException();
      return JSValue::encode(jsString(vm, jsonString));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*)</span>
  {
      resetSuperSamplerState();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(i)))</span>
              object-&gt;ensureArrayStorage(vm);
      }
      return JSValue::encode(jsUndefined());
  }
  
  #if ENABLE(SAMPLING_PROFILER)
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      SamplingProfiler&amp; samplingProfiler = vm.ensureSamplingProfiler(WTF::Stopwatch::create());
      samplingProfiler.noticeCurrentThreadAsJSCExecutionThread();
      samplingProfiler.start();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!vm.samplingProfiler())
<span class="line-modified">!         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Sampling profiler was never started&quot;_s)));</span>
  
      String jsonString = vm.samplingProfiler()-&gt;stackTracesAsJSON();
<span class="line-modified">!     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));</span>
      scope.releaseAssertNoException();
      return result;
  }
  #endif // ENABLE(SAMPLING_PROFILER)
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*)</span>
  {
      return JSValue::encode(jsNumber(JSC::maxArguments));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue numberOfAsyncPasses = exec-&gt;argument(0);</span>
      if (!numberOfAsyncPasses.isUInt32())
<span class="line-modified">!         return throwVMError(exec, scope, &quot;Expected first argument to be a uint32&quot;_s);</span>
  
      asyncTestExpectedPasses += numberOfAsyncPasses.asUInt32();
      return encodedJSUndefined();
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*)</span>
  {
      asyncTestPasses++;
      return encodedJSUndefined();
  }
  
  #if ENABLE(WEBASSEMBLY)
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!Wasm::isSupported())
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode should only be called if the useWebAssembly option is set&quot;_s);</span>
  
<span class="line-modified">!     if (JSObject* object = exec-&gt;argument(0).getObject()) {</span>
          if (auto* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, object))
              return JSValue::encode(jsString(vm, makeString(memory-&gt;memory().mode())));
          if (auto* instance = jsDynamicCast&lt;JSWebAssemblyInstance*&gt;(vm, object))
              return JSValue::encode(jsString(vm, makeString(instance-&gt;memoryMode())));
      }
  
<span class="line-modified">!     return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance&quot;_s);</span>
  }
  
  #endif // ENABLE(WEBASSEMBLY)
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSObject* object = exec-&gt;argument(0).getObject();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!object || !object-&gt;isFunction(vm))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
  
<span class="line-modified">!     exec-&gt;lexicalGlobalObject()-&gt;setUnhandledRejectionCallback(vm, object);</span>
      return JSValue::encode(jsUndefined());
  }
  
  // Use SEH for Release builds only to get rid of the crash report dialog
  // (luckily the same tests fail in Release and Debug builds so far). Need to
<span class="line-new-header">--- 2312,107 ---</span>
      }
      scope.releaseAssertNoException();
      return JSValue::encode(jsString(vm, jsonString));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(JSGlobalObject*, CallFrame*)</span>
  {
      resetSuperSamplerState();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(i)))</span>
              object-&gt;ensureArrayStorage(vm);
      }
      return JSValue::encode(jsUndefined());
  }
  
  #if ENABLE(SAMPLING_PROFILER)
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      SamplingProfiler&amp; samplingProfiler = vm.ensureSamplingProfiler(WTF::Stopwatch::create());
      samplingProfiler.noticeCurrentThreadAsJSCExecutionThread();
      samplingProfiler.start();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!vm.samplingProfiler())
<span class="line-modified">!         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Sampling profiler was never started&quot;_s)));</span>
  
      String jsonString = vm.samplingProfiler()-&gt;stackTracesAsJSON();
<span class="line-modified">!     EncodedJSValue result = JSValue::encode(JSONParse(globalObject, jsonString));</span>
      scope.releaseAssertNoException();
      return result;
  }
  #endif // ENABLE(SAMPLING_PROFILER)
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionMaxArguments(JSGlobalObject*, CallFrame*)</span>
  {
      return JSValue::encode(jsNumber(JSC::maxArguments));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue numberOfAsyncPasses = callFrame-&gt;argument(0);</span>
      if (!numberOfAsyncPasses.isUInt32())
<span class="line-modified">!         return throwVMError(globalObject, scope, &quot;Expected first argument to be a uint32&quot;_s);</span>
  
      asyncTestExpectedPasses += numberOfAsyncPasses.asUInt32();
      return encodedJSUndefined();
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(JSGlobalObject*, CallFrame*)</span>
  {
      asyncTestPasses++;
      return encodedJSUndefined();
  }
  
  #if ENABLE(WEBASSEMBLY)
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!Wasm::isSupported())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;WebAssemblyMemoryMode should only be called if the useWebAssembly option is set&quot;_s);</span>
  
<span class="line-modified">!     if (JSObject* object = callFrame-&gt;argument(0).getObject()) {</span>
          if (auto* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, object))
              return JSValue::encode(jsString(vm, makeString(memory-&gt;memory().mode())));
          if (auto* instance = jsDynamicCast&lt;JSWebAssemblyInstance*&gt;(vm, object))
              return JSValue::encode(jsString(vm, makeString(instance-&gt;memoryMode())));
      }
  
<span class="line-modified">!     return throwVMTypeError(globalObject, scope, &quot;WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance&quot;_s);</span>
  }
  
  #endif // ENABLE(WEBASSEMBLY)
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSObject* object = callFrame-&gt;argument(0).getObject();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!object || !object-&gt;isFunction(vm))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
  
<span class="line-modified">!     globalObject-&gt;setUnhandledRejectionCallback(vm, object);</span>
      return JSValue::encode(jsUndefined());
  }
  
  // Use SEH for Release builds only to get rid of the crash report dialog
  // (luckily the same tests fail in Release and Debug builds so far). Need to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2415,31 ***</span>
  
  int jscmain(int argc, char** argv);
  
  static double s_desiredTimeout;
  static double s_timeoutMultiplier = 1.0;
  
<span class="line-modified">! static void startTimeoutThreadIfNeeded()</span>
  {
      if (char* timeoutString = getenv(&quot;JSCTEST_timeout&quot;)) {
          if (sscanf(timeoutString, &quot;%lf&quot;, &amp;s_desiredTimeout) != 1) {
              dataLog(&quot;WARNING: timeout string is malformed, got &quot;, timeoutString,
                  &quot; but expected a number. Not using a timeout.\n&quot;);
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             Thread::create(&quot;jsc Timeout Thread&quot;, [] () {</span>
<span class="line-removed">-                 Seconds timeoutDuration(s_desiredTimeout * s_timeoutMultiplier);</span>
<span class="line-removed">-                 sleep(timeoutDuration);</span>
<span class="line-removed">-                 dataLog(&quot;Timed out after &quot;, timeoutDuration, &quot; seconds!\n&quot;);</span>
<span class="line-removed">-                 CRASH();</span>
<span class="line-removed">-             });</span>
<span class="line-removed">-         }</span>
      }
  }
  
  int main(int argc, char** argv)
  {
<span class="line-modified">! #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)</span>
      // Enabled IEEE754 denormal support.
      fenv_t env;
      fegetenv( &amp;env );
      env.__fpscr &amp;= ~0x01000000u;
      fesetenv( &amp;env );
<span class="line-new-header">--- 2429,65 ---</span>
  
  int jscmain(int argc, char** argv);
  
  static double s_desiredTimeout;
  static double s_timeoutMultiplier = 1.0;
<span class="line-added">+ static Seconds s_timeoutDuration;</span>
<span class="line-added">+ static Seconds s_maxAllowedCPUTime;</span>
<span class="line-added">+ static VM* s_vm;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void startTimeoutTimer(Seconds duration)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Thread::create(&quot;jsc Timeout Thread&quot;, [=] () {</span>
<span class="line-added">+         sleep(duration);</span>
<span class="line-added">+         VMInspector::forEachVM([&amp;] (VM&amp; vm) -&gt; VMInspector::FunctorStatus {</span>
<span class="line-added">+             if (&amp;vm != s_vm)</span>
<span class="line-added">+                 return VMInspector::FunctorStatus::Continue;</span>
<span class="line-added">+             vm.notifyNeedShellTimeoutCheck();</span>
<span class="line-added">+             return VMInspector::FunctorStatus::Done;</span>
<span class="line-added">+         });</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! static void timeoutCheckCallback(VM&amp; vm)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     RELEASE_ASSERT(&amp;vm == s_vm);</span>
<span class="line-added">+     auto cpuTime = CPUTime::forCurrentThread();</span>
<span class="line-added">+     if (cpuTime &gt;= s_maxAllowedCPUTime) {</span>
<span class="line-added">+         dataLog(&quot;Timed out after &quot;, s_timeoutDuration, &quot; seconds!\n&quot;);</span>
<span class="line-added">+         CRASH();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     auto remainingTime = s_maxAllowedCPUTime - cpuTime;</span>
<span class="line-added">+     startTimeoutTimer(remainingTime);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void initializeTimeoutIfNeeded()</span>
  {
      if (char* timeoutString = getenv(&quot;JSCTEST_timeout&quot;)) {
          if (sscanf(timeoutString, &quot;%lf&quot;, &amp;s_desiredTimeout) != 1) {
              dataLog(&quot;WARNING: timeout string is malformed, got &quot;, timeoutString,
                  &quot; but expected a number. Not using a timeout.\n&quot;);
<span class="line-modified">!         } else</span>
<span class="line-modified">!             g_jscConfig.shellTimeoutCheckCallback = timeoutCheckCallback;</span>
      }
  }
  
<span class="line-added">+ static void startTimeoutThreadIfNeeded(VM&amp; vm)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!g_jscConfig.shellTimeoutCheckCallback)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     s_vm = &amp;vm;</span>
<span class="line-added">+     s_timeoutDuration = Seconds(s_desiredTimeout * s_timeoutMultiplier);</span>
<span class="line-added">+     s_maxAllowedCPUTime = CPUTime::forCurrentThread() + s_timeoutDuration;</span>
<span class="line-added">+     Seconds timeoutDuration(s_desiredTimeout * s_timeoutMultiplier);</span>
<span class="line-added">+     startTimeoutTimer(timeoutDuration);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  int main(int argc, char** argv)
  {
<span class="line-modified">! #if OS(DARWIN) &amp;&amp; CPU(ARM_THUMB2)</span>
      // Enabled IEEE754 denormal support.
      fenv_t env;
      fegetenv( &amp;env );
      env.__fpscr &amp;= ~0x01000000u;
      fesetenv( &amp;env );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2501,11 ***</span>
              scope.clearException(); \
              return; \
          } \
      } while (false)
  
<span class="line-modified">!     auto exceptionString = exception.toWTFString(globalObject-&gt;globalExec());</span>
      Expected&lt;CString, UTF8ConversionError&gt; expectedCString = exceptionString.tryGetUtf8();
      if (expectedCString)
          printf(&quot;Exception: %s\n&quot;, expectedCString.value().data());
      else
          printf(&quot;Exception: &lt;out of memory while extracting exception string&gt;\n&quot;);
<span class="line-new-header">--- 2549,12 ---</span>
              scope.clearException(); \
              return; \
          } \
      } while (false)
  
<span class="line-modified">!     auto exceptionString = exception.toWTFString(globalObject);</span>
<span class="line-added">+     CHECK_EXCEPTION();</span>
      Expected&lt;CString, UTF8ConversionError&gt; expectedCString = exceptionString.tryGetUtf8();
      if (expectedCString)
          printf(&quot;Exception: %s\n&quot;, expectedCString.value().data());
      else
          printf(&quot;Exception: &lt;out of memory while extracting exception string&gt;\n&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2517,29 ***</span>
      Identifier lineNumberID = Identifier::fromString(vm, &quot;line&quot;);
      CHECK_EXCEPTION();
      Identifier stackID = Identifier::fromString(vm, &quot;stack&quot;);
      CHECK_EXCEPTION();
  
<span class="line-modified">!     JSValue nameValue = exception.get(globalObject-&gt;globalExec(), nameID);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     JSValue fileNameValue = exception.get(globalObject-&gt;globalExec(), fileNameID);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     JSValue lineNumberValue = exception.get(globalObject-&gt;globalExec(), lineNumberID);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     JSValue stackValue = exception.get(globalObject-&gt;globalExec(), stackID);</span>
      CHECK_EXCEPTION();
  
<span class="line-modified">!     if (nameValue.toWTFString(globalObject-&gt;globalExec()) == &quot;SyntaxError&quot;</span>
<span class="line-modified">!         &amp;&amp; (!fileNameValue.isUndefinedOrNull() || !lineNumberValue.isUndefinedOrNull())) {</span>
<span class="line-modified">!         printf(</span>
<span class="line-modified">!             &quot;at %s:%s\n&quot;,</span>
<span class="line-modified">!             fileNameValue.toWTFString(globalObject-&gt;globalExec()).utf8().data(),</span>
<span class="line-modified">!             lineNumberValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());</span>
      }
  
      if (!stackValue.isUndefinedOrNull()) {
<span class="line-modified">!         auto stackString = stackValue.toWTFString(globalObject-&gt;globalExec());</span>
          if (stackString.length())
              printf(&quot;%s\n&quot;, stackString.utf8().data());
      }
  
  #undef CHECK_EXCEPTION
<span class="line-new-header">--- 2566,33 ---</span>
      Identifier lineNumberID = Identifier::fromString(vm, &quot;line&quot;);
      CHECK_EXCEPTION();
      Identifier stackID = Identifier::fromString(vm, &quot;stack&quot;);
      CHECK_EXCEPTION();
  
<span class="line-modified">!     JSValue nameValue = exception.get(globalObject, nameID);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     JSValue fileNameValue = exception.get(globalObject, fileNameID);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     JSValue lineNumberValue = exception.get(globalObject, lineNumberID);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     JSValue stackValue = exception.get(globalObject, stackID);</span>
      CHECK_EXCEPTION();
  
<span class="line-modified">!     auto nameString = nameValue.toWTFString(globalObject);</span>
<span class="line-modified">!     CHECK_EXCEPTION();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (nameString == &quot;SyntaxError&quot; &amp;&amp; (!fileNameValue.isUndefinedOrNull() || !lineNumberValue.isUndefinedOrNull())) {</span>
<span class="line-modified">!         auto fileNameString = fileNameValue.toWTFString(globalObject);</span>
<span class="line-modified">!         CHECK_EXCEPTION();</span>
<span class="line-added">+         auto lineNumberString = lineNumberValue.toWTFString(globalObject);</span>
<span class="line-added">+         CHECK_EXCEPTION();</span>
<span class="line-added">+         printf(&quot;at %s:%s\n&quot;, fileNameString.utf8().data(), lineNumberString.utf8().data());</span>
      }
  
      if (!stackValue.isUndefinedOrNull()) {
<span class="line-modified">!         auto stackString = stackValue.toWTFString(globalObject);</span>
<span class="line-added">+         CHECK_EXCEPTION();</span>
          if (stackString.length())
              printf(&quot;%s\n&quot;, stackString.utf8().data());
      }
  
  #undef CHECK_EXCEPTION
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2553,18 ***</span>
      if (!exception) {
          printf(&quot;Expected uncaught exception with name &#39;%s&#39; but none was thrown\n&quot;, expectedExceptionName.utf8().data());
          return false;
      }
  
<span class="line-modified">!     ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-removed">-     JSValue exceptionClass = globalObject-&gt;get(exec, Identifier::fromString(vm, expectedExceptionName));</span>
      if (!exceptionClass.isObject() || scope.exception()) {
          printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class is not defined\n&quot;, expectedExceptionName.utf8().data());
          return false;
      }
  
<span class="line-modified">!     bool isInstanceOfExpectedException = jsCast&lt;JSObject*&gt;(exceptionClass)-&gt;hasInstance(exec, exception);</span>
      if (scope.exception()) {
          printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class fails performing hasInstance\n&quot;, expectedExceptionName.utf8().data());
          return false;
      }
      if (isInstanceOfExpectedException) {
<span class="line-new-header">--- 2606,17 ---</span>
      if (!exception) {
          printf(&quot;Expected uncaught exception with name &#39;%s&#39; but none was thrown\n&quot;, expectedExceptionName.utf8().data());
          return false;
      }
  
<span class="line-modified">!     JSValue exceptionClass = globalObject-&gt;get(globalObject, Identifier::fromString(vm, expectedExceptionName));</span>
      if (!exceptionClass.isObject() || scope.exception()) {
          printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class is not defined\n&quot;, expectedExceptionName.utf8().data());
          return false;
      }
  
<span class="line-modified">!     bool isInstanceOfExpectedException = jsCast&lt;JSObject*&gt;(exceptionClass)-&gt;hasInstance(globalObject, exception);</span>
      if (scope.exception()) {
          printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class fails performing hasInstance\n&quot;, expectedExceptionName.utf8().data());
          return false;
      }
      if (isInstanceOfExpectedException) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2576,11 ***</span>
      printf(&quot;Expected uncaught exception with name &#39;%s&#39; but exception value is not instance of this exception class\n&quot;, expectedExceptionName.utf8().data());
      dumpException(globalObject, exception);
      return false;
  }
  
<span class="line-modified">! static void checkException(ExecState* exec, GlobalObject* globalObject, bool isLastFile, bool hasException, JSValue value, CommandLine&amp; options, bool&amp; success)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
  
      if (options.m_treatWatchdogExceptionAsSuccess &amp;&amp; value.inherits&lt;TerminatedExecutionError&gt;(vm)) {
          ASSERT(hasException);
<span class="line-new-header">--- 2628,11 ---</span>
      printf(&quot;Expected uncaught exception with name &#39;%s&#39; but exception value is not instance of this exception class\n&quot;, expectedExceptionName.utf8().data());
      dumpException(globalObject, exception);
      return false;
  }
  
<span class="line-modified">! static void checkException(GlobalObject* globalObject, bool isLastFile, bool hasException, JSValue value, CommandLine&amp; options, bool&amp; success)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
  
      if (options.m_treatWatchdogExceptionAsSuccess &amp;&amp; value.inherits&lt;TerminatedExecutionError&gt;(vm)) {
          ASSERT(hasException);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2588,11 ***</span>
      }
  
      if (!options.m_uncaughtExceptionName || !isLastFile) {
          success = success &amp;&amp; !hasException;
          if (options.m_dump &amp;&amp; !hasException)
<span class="line-modified">!             printf(&quot;End: %s\n&quot;, value.toWTFString(exec).utf8().data());</span>
          if (hasException)
              dumpException(globalObject, value);
      } else
          success = success &amp;&amp; checkUncaughtException(vm, globalObject, (hasException) ? value : JSValue(), options);
  }
<span class="line-new-header">--- 2640,11 ---</span>
      }
  
      if (!options.m_uncaughtExceptionName || !isLastFile) {
          success = success &amp;&amp; !hasException;
          if (options.m_dump &amp;&amp; !hasException)
<span class="line-modified">!             printf(&quot;End: %s\n&quot;, value.toWTFString(globalObject).utf8().data());</span>
          if (hasException)
              dumpException(globalObject, value);
      } else
          success = success &amp;&amp; checkUncaughtException(vm, globalObject, (hasException) ? value : JSValue(), options);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2601,13 ***</span>
  {
      Vector&lt;Script&gt;&amp; scripts = options.m_scripts;
      String fileName;
      Vector&lt;char&gt; scriptBuffer;
  
<span class="line-removed">-     if (options.m_dump)</span>
<span class="line-removed">-         JSC::Options::dumpGeneratedBytecodes() = true;</span>
<span class="line-removed">- </span>
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
  #if ENABLE(SAMPLING_FLAGS)
      SamplingFlags::start();
<span class="line-new-header">--- 2653,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2620,11 ***</span>
              fileName = scripts[i].argument;
              if (scripts[i].strictMode == Script::StrictMode::Strict)
                  scriptBuffer.append(&quot;\&quot;use strict\&quot;;\n&quot;, strlen(&quot;\&quot;use strict\&quot;;\n&quot;));
  
              if (isModule) {
<span class="line-modified">!                 promise = loadAndEvaluateModule(globalObject-&gt;globalExec(), fileName, jsUndefined(), jsUndefined());</span>
                  scope.releaseAssertNoException();
              } else {
                  if (!fetchScriptFromLocalFileSystem(fileName, scriptBuffer)) {
                      success = false; // fail early so we can catch missing files
                      return;
<span class="line-new-header">--- 2669,11 ---</span>
              fileName = scripts[i].argument;
              if (scripts[i].strictMode == Script::StrictMode::Strict)
                  scriptBuffer.append(&quot;\&quot;use strict\&quot;;\n&quot;, strlen(&quot;\&quot;use strict\&quot;;\n&quot;));
  
              if (isModule) {
<span class="line-modified">!                 promise = loadAndEvaluateModule(globalObject, fileName, jsUndefined(), jsUndefined());</span>
                  scope.releaseAssertNoException();
              } else {
                  if (!fetchScriptFromLocalFileSystem(fileName, scriptBuffer)) {
                      success = false; // fail early so we can catch missing files
                      return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2639,34 ***</span>
  
          bool isLastFile = i == scripts.size() - 1;
          if (isModule) {
              if (!promise) {
                  // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
<span class="line-modified">!                 promise = loadAndEvaluateModule(globalObject-&gt;globalExec(), jscSource(stringFromUTF(scriptBuffer), SourceOrigin { absolutePath(fileName) }, URL({ }, fileName), TextPosition(), SourceProviderSourceType::Module), jsUndefined());</span>
              }
              scope.clearException();
  
<span class="line-modified">!             JSFunction* fulfillHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](ExecState* exec) {</span>
<span class="line-modified">!                 checkException(exec, jsCast&lt;GlobalObject*&gt;(exec-&gt;lexicalGlobalObject()), isLastFile, false, exec-&gt;argument(0), options, success);</span>
                  return JSValue::encode(jsUndefined());
              });
  
<span class="line-modified">!             JSFunction* rejectHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](ExecState* exec) {</span>
<span class="line-modified">!                 checkException(exec, jsCast&lt;GlobalObject*&gt;(exec-&gt;lexicalGlobalObject()), isLastFile, true, exec-&gt;argument(0), options, success);</span>
                  return JSValue::encode(jsUndefined());
              });
  
<span class="line-modified">!             promise-&gt;then(globalObject-&gt;globalExec(), fulfillHandler, rejectHandler);</span>
              scope.releaseAssertNoException();
              vm.drainMicrotasks();
          } else {
              NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!             JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(scriptBuffer, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);</span>
              scope.assertNoException();
              if (evaluationException)
                  returnValue = evaluationException-&gt;value();
<span class="line-modified">!             checkException(globalObject-&gt;globalExec(), globalObject, isLastFile, evaluationException, returnValue, options, success);</span>
          }
  
          scriptBuffer.clear();
          scope.clearException();
      }
<span class="line-new-header">--- 2688,34 ---</span>
  
          bool isLastFile = i == scripts.size() - 1;
          if (isModule) {
              if (!promise) {
                  // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
<span class="line-modified">!                 promise = loadAndEvaluateModule(globalObject, jscSource(stringFromUTF(scriptBuffer), SourceOrigin { absolutePath(fileName) }, URL({ }, fileName), TextPosition(), SourceProviderSourceType::Module), jsUndefined());</span>
              }
              scope.clearException();
  
<span class="line-modified">!             JSFunction* fulfillHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](JSGlobalObject* globalObject, CallFrame* callFrame) {</span>
<span class="line-modified">!                 checkException(jsCast&lt;GlobalObject*&gt;(globalObject), isLastFile, false, callFrame-&gt;argument(0), options, success);</span>
                  return JSValue::encode(jsUndefined());
              });
  
<span class="line-modified">!             JSFunction* rejectHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](JSGlobalObject* globalObject, CallFrame* callFrame) {</span>
<span class="line-modified">!                 checkException(jsCast&lt;GlobalObject*&gt;(globalObject), isLastFile, true, callFrame-&gt;argument(0), options, success);</span>
                  return JSValue::encode(jsUndefined());
              });
  
<span class="line-modified">!             promise-&gt;then(globalObject, fulfillHandler, rejectHandler);</span>
              scope.releaseAssertNoException();
              vm.drainMicrotasks();
          } else {
              NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!             JSValue returnValue = evaluate(globalObject, jscSource(scriptBuffer, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);</span>
              scope.assertNoException();
              if (evaluationException)
                  returnValue = evaluationException-&gt;value();
<span class="line-modified">!             checkException(globalObject, isLastFile, evaluationException, returnValue, options, success);</span>
          }
  
          scriptBuffer.clear();
          scope.clearException();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2715,11 ***</span>
              continue;
          }
  
  
          NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(source, sourceOrigin), JSValue(), evaluationException);</span>
  #else
          printf(&quot;%s&quot;, interactivePrompt);
          Vector&lt;char, 256&gt; line;
          int c;
          while ((c = getchar()) != EOF) {
<span class="line-new-header">--- 2764,11 ---</span>
              continue;
          }
  
  
          NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!         JSValue returnValue = evaluate(globalObject, jscSource(source, sourceOrigin), JSValue(), evaluationException);</span>
  #else
          printf(&quot;%s&quot;, interactivePrompt);
          Vector&lt;char, 256&gt; line;
          int c;
          while ((c = getchar()) != EOF) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2730,16 ***</span>
          }
          if (line.isEmpty())
              break;
  
          NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(line, sourceOrigin, sourceOrigin.string()), JSValue(), evaluationException);</span>
  #endif
          if (evaluationException)
<span class="line-modified">!             printf(&quot;Exception: %s\n&quot;, evaluationException-&gt;value().toWTFString(globalObject-&gt;globalExec()).utf8().data());</span>
          else
<span class="line-modified">!             printf(&quot;%s\n&quot;, returnValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());</span>
  
          scope.clearException();
          vm.drainMicrotasks();
      }
      printf(&quot;\n&quot;);
<span class="line-new-header">--- 2779,16 ---</span>
          }
          if (line.isEmpty())
              break;
  
          NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!         JSValue returnValue = evaluate(globalObject, jscSource(line, sourceOrigin, sourceOrigin.string()), JSValue(), evaluationException);</span>
  #endif
          if (evaluationException)
<span class="line-modified">!             printf(&quot;Exception: %s\n&quot;, evaluationException-&gt;value().toWTFString(globalObject).utf8().data());</span>
          else
<span class="line-modified">!             printf(&quot;%s\n&quot;, returnValue.toWTFString(globalObject).utf8().data());</span>
  
          scope.clearException();
          vm.drainMicrotasks();
      }
      printf(&quot;\n&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2882,10 ***</span>
<span class="line-new-header">--- 2931,14 ---</span>
          }
          if (!strcmp(arg, &quot;--destroy-vm&quot;)) {
              m_destroyVM = true;
              continue;
          }
<span class="line-added">+         if (!strcmp(arg, &quot;--disableOptionsFreezingForTesting&quot;)) {</span>
<span class="line-added">+             Config::disableFreezingForTesting();</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
  
          static const char* timeoutMultiplierOptStr = &quot;--timeoutMultiplier=&quot;;
          static const unsigned timeoutMultiplierOptStrLength = strlen(timeoutMultiplierOptStr);
          if (!strncmp(arg, timeoutMultiplierOptStr, timeoutMultiplierOptStrLength)) {
              const char* valueStr = &amp;arg[timeoutMultiplierOptStrLength];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2982,19 ***</span>
      bool success = true;
      GlobalObject* globalObject = nullptr;
      {
          JSLockHolder locker(vm);
  
          if (options.m_profile &amp;&amp; !vm.m_perBytecodeProfiler)
              vm.m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(vm);
  
          globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), options.m_arguments);
          globalObject-&gt;setRemoteDebuggingEnabled(options.m_enableRemoteDebugging);
          func(vm, globalObject, success);
          vm.drainMicrotasks();
      }
<span class="line-modified">!     vm.promiseDeferredTimer-&gt;runRunLoop();</span>
      {
          JSLockHolder locker(vm);
          if (options.m_interactive &amp;&amp; success)
              runInteractive(globalObject);
      }
<span class="line-new-header">--- 3035,20 ---</span>
      bool success = true;
      GlobalObject* globalObject = nullptr;
      {
          JSLockHolder locker(vm);
  
<span class="line-added">+         startTimeoutThreadIfNeeded(vm);</span>
          if (options.m_profile &amp;&amp; !vm.m_perBytecodeProfiler)
              vm.m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(vm);
  
          globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), options.m_arguments);
          globalObject-&gt;setRemoteDebuggingEnabled(options.m_enableRemoteDebugging);
          func(vm, globalObject, success);
          vm.drainMicrotasks();
      }
<span class="line-modified">!     vm.promiseTimer-&gt;runRunLoop();</span>
      {
          JSLockHolder locker(vm);
          if (options.m_interactive &amp;&amp; success)
              runInteractive(globalObject);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3034,10 ***</span>
<span class="line-new-header">--- 3088,13 ---</span>
          for (auto&amp; entry : compileTimeStats)
              compileTimeKeys.append(entry.key);
          std::sort(compileTimeKeys.begin(), compileTimeKeys.end());
          for (const CString&amp; key : compileTimeKeys)
              printf(&quot;%40s: %.3lf ms\n&quot;, key.data(), compileTimeStats.get(key).milliseconds());
<span class="line-added">+ </span>
<span class="line-added">+         if (Options::reportTotalPhaseTimes())</span>
<span class="line-added">+             logTotalPhaseTimes();</span>
      }
  #endif
  
      if (Options::gcAtEnd()) {
          // We need to hold the API lock to do a GC.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3068,27 ***</span>
  }
  
  int jscmain(int argc, char** argv)
  {
      // Need to override and enable restricted options before we start parsing options below.
<span class="line-modified">!     Options::enableRestrictedOptions(true);</span>
  
      WTF::initializeMainThread();
  
      // Note that the options parsing can affect VM creation, and thus
      // comes first.
      CommandLine options(argc, argv);
  
      processConfigFile(Options::configFile(), &quot;jsc&quot;);
  
      // Initialize JSC before getting VM.
      JSC::initializeThreading();
<span class="line-modified">!     startTimeoutThreadIfNeeded();</span>
  #if ENABLE(WEBASSEMBLY)
      JSC::Wasm::enableFastMemory();
  #endif
<span class="line-modified">!     Gigacage::disableDisablingPrimitiveGigacageIfShouldBeEnabled();</span>
  
  #if PLATFORM(COCOA)
      auto&amp; memoryPressureHandler = MemoryPressureHandler::singleton();
      {
          dispatch_queue_t queue = dispatch_queue_create(&quot;jsc shell memory pressure handler&quot;, DISPATCH_QUEUE_SERIAL);
<span class="line-new-header">--- 3125,38 ---</span>
  }
  
  int jscmain(int argc, char** argv)
  {
      // Need to override and enable restricted options before we start parsing options below.
<span class="line-modified">!     Config::enableRestrictedOptions();</span>
  
      WTF::initializeMainThread();
  
      // Note that the options parsing can affect VM creation, and thus
      // comes first.
      CommandLine options(argc, argv);
  
      processConfigFile(Options::configFile(), &quot;jsc&quot;);
<span class="line-added">+     if (options.m_dump)</span>
<span class="line-added">+         JSC::Options::dumpGeneratedBytecodes() = true;</span>
  
      // Initialize JSC before getting VM.
      JSC::initializeThreading();
<span class="line-modified">!     initializeTimeoutIfNeeded();</span>
  #if ENABLE(WEBASSEMBLY)
      JSC::Wasm::enableFastMemory();
  #endif
<span class="line-modified">! </span>
<span class="line-added">+     bool gigacageDisableRequested = false;</span>
<span class="line-added">+ #if GIGACAGE_ENABLED &amp;&amp; !COMPILER(MSVC)</span>
<span class="line-added">+     if (char* gigacageEnabled = getenv(&quot;GIGACAGE_ENABLED&quot;)) {</span>
<span class="line-added">+         if (!strcasecmp(gigacageEnabled, &quot;no&quot;) || !strcasecmp(gigacageEnabled, &quot;false&quot;) || !strcasecmp(gigacageEnabled, &quot;0&quot;))</span>
<span class="line-added">+             gigacageDisableRequested = true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     if (!gigacageDisableRequested)</span>
<span class="line-added">+         Gigacage::forbidDisablingPrimitiveGigacage();</span>
  
  #if PLATFORM(COCOA)
      auto&amp; memoryPressureHandler = MemoryPressureHandler::singleton();
      {
          dispatch_queue_t queue = dispatch_queue_create(&quot;jsc shell memory pressure handler&quot;, DISPATCH_QUEUE_SERIAL);
</pre>
<center><a href="jit/UnusedPointer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="llint/LLIntData.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
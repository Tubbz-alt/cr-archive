<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCJSValueInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;CatchScope.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;ExceptionHelpers.h&quot;
  31 #include &quot;Identifier.h&quot;
  32 #include &quot;InternalFunction.h&quot;
  33 #include &quot;JSBigInt.h&quot;
  34 #include &quot;JSCJSValue.h&quot;
  35 #include &quot;JSCellInlines.h&quot;
  36 #include &quot;JSFunction.h&quot;
  37 #include &quot;JSObject.h&quot;
  38 #include &quot;JSProxy.h&quot;
  39 #include &quot;JSStringInlines.h&quot;
  40 #include &quot;MathCommon.h&quot;
  41 #include &lt;wtf/Variant.h&gt;
  42 #include &lt;wtf/text/StringImpl.h&gt;
  43 
  44 namespace JSC {
  45 
  46 ALWAYS_INLINE int32_t JSValue::toInt32(JSGlobalObject* globalObject) const
  47 {
  48     if (isInt32())
  49         return asInt32();
  50     return JSC::toInt32(toNumber(globalObject));
  51 }
  52 
  53 inline uint32_t JSValue::toUInt32(JSGlobalObject* globalObject) const
  54 {
  55     // See comment on JSC::toUInt32, in JSCJSValue.h.
  56     return toInt32(globalObject);
  57 }
  58 
  59 inline uint32_t JSValue::toIndex(JSGlobalObject* globalObject, const char* errorName) const
  60 {
  61     VM&amp; vm = getVM(globalObject);
  62     auto scope = DECLARE_THROW_SCOPE(vm);
  63 
  64     double d = toNumber(globalObject);
  65     RETURN_IF_EXCEPTION(scope, 0);
  66     if (d &lt;= -1) {
  67         throwException(globalObject, scope, createRangeError(globalObject, makeString(errorName, &quot; cannot be negative&quot;)));
  68         return 0;
  69     }
  70     if (d &gt; std::numeric_limits&lt;unsigned&gt;::max()) {
  71         throwException(globalObject, scope, createRangeError(globalObject, makeString(errorName, &quot; too large&quot;)));
  72         return 0;
  73     }
  74 
  75     if (isInt32())
  76         return asInt32();
  77     RELEASE_AND_RETURN(scope, JSC::toInt32(d));
  78 }
  79 
  80 inline bool JSValue::isUInt32() const
  81 {
  82     return isInt32() &amp;&amp; asInt32() &gt;= 0;
  83 }
  84 
  85 inline uint32_t JSValue::asUInt32() const
  86 {
  87     ASSERT(isUInt32());
  88     return asInt32();
  89 }
  90 
  91 inline double JSValue::asNumber() const
  92 {
  93     ASSERT(isNumber());
  94     return isInt32() ? asInt32() : asDouble();
  95 }
  96 
  97 inline JSValue jsNaN()
  98 {
  99     return JSValue(JSValue::EncodeAsDouble, PNaN);
 100 }
 101 
 102 inline JSValue::JSValue(char i)
 103 {
 104     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 105 }
 106 
 107 inline JSValue::JSValue(unsigned char i)
 108 {
 109     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 110 }
 111 
 112 inline JSValue::JSValue(short i)
 113 {
 114     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 115 }
 116 
 117 inline JSValue::JSValue(unsigned short i)
 118 {
 119     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 120 }
 121 
 122 inline JSValue::JSValue(unsigned i)
 123 {
 124     if (static_cast&lt;int32_t&gt;(i) &lt; 0) {
 125         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 126         return;
 127     }
 128     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 129 }
 130 
 131 inline JSValue::JSValue(long i)
 132 {
 133     if (static_cast&lt;int32_t&gt;(i) != i) {
 134         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 135         return;
 136     }
 137     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 138 }
 139 
 140 inline JSValue::JSValue(unsigned long i)
 141 {
 142     if (static_cast&lt;uint32_t&gt;(i) != i) {
 143         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 144         return;
 145     }
 146     *this = JSValue(static_cast&lt;uint32_t&gt;(i));
 147 }
 148 
 149 inline JSValue::JSValue(long long i)
 150 {
 151     if (static_cast&lt;int32_t&gt;(i) != i) {
 152         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 153         return;
 154     }
 155     *this = JSValue(static_cast&lt;int32_t&gt;(i));
 156 }
 157 
 158 inline JSValue::JSValue(unsigned long long i)
 159 {
 160     if (static_cast&lt;uint32_t&gt;(i) != i) {
 161         *this = JSValue(EncodeAsDouble, static_cast&lt;double&gt;(i));
 162         return;
 163     }
 164     *this = JSValue(static_cast&lt;uint32_t&gt;(i));
 165 }
 166 
 167 inline JSValue::JSValue(double d)
 168 {
 169     if (canBeStrictInt32(d)) {
 170         *this = JSValue(static_cast&lt;int32_t&gt;(d));
 171         return;
 172     }
 173     *this = JSValue(EncodeAsDouble, d);
 174 }
 175 
 176 inline EncodedJSValue JSValue::encode(JSValue value)
 177 {
 178     return value.u.asInt64;
 179 }
 180 
 181 inline JSValue JSValue::decode(EncodedJSValue encodedJSValue)
 182 {
 183     JSValue v;
 184     v.u.asInt64 = encodedJSValue;
 185     return v;
 186 }
 187 
 188 #if USE(JSVALUE32_64)
 189 inline JSValue::JSValue()
 190 {
 191     u.asBits.tag = EmptyValueTag;
 192     u.asBits.payload = 0;
 193 }
 194 
 195 inline JSValue::JSValue(JSNullTag)
 196 {
 197     u.asBits.tag = NullTag;
 198     u.asBits.payload = 0;
 199 }
 200 
 201 inline JSValue::JSValue(JSUndefinedTag)
 202 {
 203     u.asBits.tag = UndefinedTag;
 204     u.asBits.payload = 0;
 205 }
 206 
 207 inline JSValue::JSValue(JSTrueTag)
 208 {
 209     u.asBits.tag = BooleanTag;
 210     u.asBits.payload = 1;
 211 }
 212 
 213 inline JSValue::JSValue(JSFalseTag)
 214 {
 215     u.asBits.tag = BooleanTag;
 216     u.asBits.payload = 0;
 217 }
 218 
 219 inline JSValue::JSValue(HashTableDeletedValueTag)
 220 {
 221     u.asBits.tag = DeletedValueTag;
 222     u.asBits.payload = 0;
 223 }
 224 
 225 inline JSValue::JSValue(JSCell* ptr)
 226 {
 227     if (ptr)
 228         u.asBits.tag = CellTag;
 229     else
 230         u.asBits.tag = EmptyValueTag;
 231     u.asBits.payload = reinterpret_cast&lt;int32_t&gt;(ptr);
 232 }
 233 
 234 inline JSValue::JSValue(const JSCell* ptr)
 235 {
 236     if (ptr)
 237         u.asBits.tag = CellTag;
 238     else
 239         u.asBits.tag = EmptyValueTag;
 240     u.asBits.payload = reinterpret_cast&lt;int32_t&gt;(const_cast&lt;JSCell*&gt;(ptr));
 241 }
 242 
 243 inline JSValue::operator bool() const
 244 {
 245     ASSERT(tag() != DeletedValueTag);
 246     return tag() != EmptyValueTag;
 247 }
 248 
 249 inline bool JSValue::operator==(const JSValue&amp; other) const
 250 {
 251     return u.asInt64 == other.u.asInt64;
 252 }
 253 
 254 inline bool JSValue::operator!=(const JSValue&amp; other) const
 255 {
 256     return u.asInt64 != other.u.asInt64;
 257 }
 258 
 259 inline bool JSValue::isEmpty() const
 260 {
 261     return tag() == EmptyValueTag;
 262 }
 263 
 264 inline bool JSValue::isUndefined() const
 265 {
 266     return tag() == UndefinedTag;
 267 }
 268 
 269 inline bool JSValue::isNull() const
 270 {
 271     return tag() == NullTag;
 272 }
 273 
 274 inline bool JSValue::isUndefinedOrNull() const
 275 {
 276     return isUndefined() || isNull();
 277 }
 278 
 279 inline bool JSValue::isCell() const
 280 {
 281     return tag() == CellTag;
 282 }
 283 
 284 inline bool JSValue::isInt32() const
 285 {
 286     return tag() == Int32Tag;
 287 }
 288 
 289 inline bool JSValue::isDouble() const
 290 {
 291     return tag() &lt; LowestTag;
 292 }
 293 
 294 inline bool JSValue::isTrue() const
 295 {
 296     return tag() == BooleanTag &amp;&amp; payload();
 297 }
 298 
 299 inline bool JSValue::isFalse() const
 300 {
 301     return tag() == BooleanTag &amp;&amp; !payload();
 302 }
 303 
 304 inline uint32_t JSValue::tag() const
 305 {
 306     return u.asBits.tag;
 307 }
 308 
 309 inline int32_t JSValue::payload() const
 310 {
 311     return u.asBits.payload;
 312 }
 313 
 314 inline int32_t JSValue::asInt32() const
 315 {
 316     ASSERT(isInt32());
 317     return u.asBits.payload;
 318 }
 319 
 320 inline double JSValue::asDouble() const
 321 {
 322     ASSERT(isDouble());
 323     return u.asDouble;
 324 }
 325 
 326 ALWAYS_INLINE JSCell* JSValue::asCell() const
 327 {
 328     ASSERT(isCell());
 329     return reinterpret_cast&lt;JSCell*&gt;(u.asBits.payload);
 330 }
 331 
 332 ALWAYS_INLINE JSValue::JSValue(EncodeAsDoubleTag, double d)
 333 {
 334     ASSERT(!isImpureNaN(d));
 335     u.asDouble = d;
 336 }
 337 
 338 inline JSValue::JSValue(int i)
 339 {
 340     u.asBits.tag = Int32Tag;
 341     u.asBits.payload = i;
 342 }
 343 
 344 inline JSValue::JSValue(int32_t tag, int32_t payload)
 345 {
 346     u.asBits.tag = tag;
 347     u.asBits.payload = payload;
 348 }
 349 
 350 inline bool JSValue::isNumber() const
 351 {
 352     return isInt32() || isDouble();
 353 }
 354 
 355 inline bool JSValue::isBoolean() const
 356 {
 357     return tag() == BooleanTag;
 358 }
 359 
 360 inline bool JSValue::asBoolean() const
 361 {
 362     ASSERT(isBoolean());
 363     return payload();
 364 }
 365 
 366 #else // !USE(JSVALUE32_64) i.e. USE(JSVALUE64)
 367 
 368 // 0x0 can never occur naturally because it has a tag of 00, indicating a pointer value, but a payload of 0x0, which is in the (invalid) zero page.
 369 inline JSValue::JSValue()
 370 {
 371     u.asInt64 = ValueEmpty;
 372 }
 373 
 374 // 0x4 can never occur naturally because it has a tag of 00, indicating a pointer value, but a payload of 0x4, which is in the (invalid) zero page.
 375 inline JSValue::JSValue(HashTableDeletedValueTag)
 376 {
 377     u.asInt64 = ValueDeleted;
 378 }
 379 
 380 inline JSValue::JSValue(JSCell* ptr)
 381 {
 382     u.asInt64 = reinterpret_cast&lt;uintptr_t&gt;(ptr);
 383 }
 384 
 385 inline JSValue::JSValue(const JSCell* ptr)
 386 {
 387     u.asInt64 = reinterpret_cast&lt;uintptr_t&gt;(const_cast&lt;JSCell*&gt;(ptr));
 388 }
 389 
 390 inline JSValue::operator bool() const
 391 {
 392     return u.asInt64;
 393 }
 394 
 395 inline bool JSValue::operator==(const JSValue&amp; other) const
 396 {
 397     return u.asInt64 == other.u.asInt64;
 398 }
 399 
 400 inline bool JSValue::operator!=(const JSValue&amp; other) const
 401 {
 402     return u.asInt64 != other.u.asInt64;
 403 }
 404 
 405 inline bool JSValue::isEmpty() const
 406 {
 407     return u.asInt64 == ValueEmpty;
 408 }
 409 
 410 inline bool JSValue::isUndefined() const
 411 {
 412     return asValue() == JSValue(JSUndefined);
 413 }
 414 
 415 inline bool JSValue::isNull() const
 416 {
 417     return asValue() == JSValue(JSNull);
 418 }
 419 
 420 inline bool JSValue::isTrue() const
 421 {
 422     return asValue() == JSValue(JSTrue);
 423 }
 424 
 425 inline bool JSValue::isFalse() const
 426 {
 427     return asValue() == JSValue(JSFalse);
 428 }
 429 
 430 inline bool JSValue::asBoolean() const
 431 {
 432     ASSERT(isBoolean());
 433     return asValue() == JSValue(JSTrue);
 434 }
 435 
 436 inline int32_t JSValue::asInt32() const
 437 {
 438     ASSERT(isInt32());
 439     return static_cast&lt;int32_t&gt;(u.asInt64);
 440 }
 441 
 442 inline bool JSValue::isDouble() const
 443 {
 444     return isNumber() &amp;&amp; !isInt32();
 445 }
 446 
 447 inline JSValue::JSValue(JSNullTag)
 448 {
 449     u.asInt64 = ValueNull;
 450 }
 451 
 452 inline JSValue::JSValue(JSUndefinedTag)
 453 {
 454     u.asInt64 = ValueUndefined;
 455 }
 456 
 457 inline JSValue::JSValue(JSTrueTag)
 458 {
 459     u.asInt64 = ValueTrue;
 460 }
 461 
 462 inline JSValue::JSValue(JSFalseTag)
 463 {
 464     u.asInt64 = ValueFalse;
 465 }
 466 
 467 inline bool JSValue::isUndefinedOrNull() const
 468 {
 469     // Undefined and null share the same value, bar the &#39;undefined&#39; bit in the extended tag.
 470     return (u.asInt64 &amp; ~UndefinedTag) == ValueNull;
 471 }
 472 
 473 inline bool JSValue::isBoolean() const
 474 {
 475     return (u.asInt64 &amp; ~1) == ValueFalse;
 476 }
 477 
 478 inline bool JSValue::isCell() const
 479 {
 480     return !(u.asInt64 &amp; NotCellMask);
 481 }
 482 
 483 inline bool JSValue::isInt32() const
 484 {
 485     return (u.asInt64 &amp; NumberTag) == NumberTag;
 486 }
 487 
 488 inline int64_t reinterpretDoubleToInt64(double value)
 489 {
 490     return bitwise_cast&lt;int64_t&gt;(value);
 491 }
 492 inline double reinterpretInt64ToDouble(int64_t value)
 493 {
 494     return bitwise_cast&lt;double&gt;(value);
 495 }
 496 
 497 ALWAYS_INLINE JSValue::JSValue(EncodeAsDoubleTag, double d)
 498 {
 499     ASSERT(!isImpureNaN(d));
 500     u.asInt64 = reinterpretDoubleToInt64(d) + JSValue::DoubleEncodeOffset;
 501 }
 502 
 503 inline JSValue::JSValue(int i)
 504 {
 505     u.asInt64 = JSValue::NumberTag | static_cast&lt;uint32_t&gt;(i);
 506 }
 507 
 508 inline double JSValue::asDouble() const
 509 {
 510     ASSERT(isDouble());
 511     return reinterpretInt64ToDouble(u.asInt64 - JSValue::DoubleEncodeOffset);
 512 }
 513 
 514 inline bool JSValue::isNumber() const
 515 {
 516     return u.asInt64 &amp; JSValue::NumberTag;
 517 }
 518 
 519 ALWAYS_INLINE JSCell* JSValue::asCell() const
 520 {
 521     ASSERT(isCell());
 522     return u.ptr;
 523 }
 524 
 525 #endif // USE(JSVALUE64)
 526 
 527 inline int64_t tryConvertToInt52(double number)
 528 {
 529     if (number != number)
 530         return JSValue::notInt52;
 531 #if OS(WINDOWS) &amp;&amp; CPU(X86)
 532     // The VS Compiler for 32-bit builds generates a floating point error when attempting to cast
 533     // from an infinity to a 64-bit integer. We leave this routine with the floating point error
 534     // left in a register, causing undefined behavior in later floating point operations.
 535     //
 536     // To avoid this issue, we check for infinity here, and return false in that case.
 537     if (std::isinf(number))
 538         return JSValue::notInt52;
 539 #endif
 540     int64_t asInt64 = static_cast&lt;int64_t&gt;(number);
 541     if (asInt64 != number)
 542         return JSValue::notInt52;
 543     if (!asInt64 &amp;&amp; std::signbit(number))
 544         return JSValue::notInt52;
 545     if (asInt64 &gt;= (static_cast&lt;int64_t&gt;(1) &lt;&lt; (JSValue::numberOfInt52Bits - 1)))
 546         return JSValue::notInt52;
 547     if (asInt64 &lt; -(static_cast&lt;int64_t&gt;(1) &lt;&lt; (JSValue::numberOfInt52Bits - 1)))
 548         return JSValue::notInt52;
 549     return asInt64;
 550 }
 551 
 552 inline bool isInt52(double number)
 553 {
 554     return tryConvertToInt52(number) != JSValue::notInt52;
 555 }
 556 
 557 inline bool JSValue::isAnyInt() const
 558 {
 559     if (isInt32())
 560         return true;
 561     if (!isNumber())
 562         return false;
 563     return isInt52(asDouble());
 564 }
 565 
 566 inline int64_t JSValue::asAnyInt() const
 567 {
 568     ASSERT(isAnyInt());
 569     if (isInt32())
 570         return asInt32();
 571     return static_cast&lt;int64_t&gt;(asDouble());
 572 }
 573 
 574 inline bool JSValue::isInt32AsAnyInt() const
 575 {
 576     if (!isAnyInt())
 577         return false;
 578     int64_t value = asAnyInt();
 579     return value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX;
 580 }
 581 
 582 inline int32_t JSValue::asInt32AsAnyInt() const
 583 {
 584     ASSERT(isInt32AsAnyInt());
 585     if (isInt32())
 586         return asInt32();
 587     return static_cast&lt;int32_t&gt;(asDouble());
 588 }
 589 
 590 inline bool JSValue::isUInt32AsAnyInt() const
 591 {
 592     if (!isAnyInt())
 593         return false;
 594     int64_t value = asAnyInt();
 595     return value &gt;= 0 &amp;&amp; value &lt;= UINT32_MAX;
 596 }
 597 
 598 inline uint32_t JSValue::asUInt32AsAnyInt() const
 599 {
 600     ASSERT(isUInt32AsAnyInt());
 601     if (isUInt32())
 602         return asUInt32();
 603     return static_cast&lt;uint32_t&gt;(asDouble());
 604 }
 605 
 606 inline bool JSValue::isString() const
 607 {
 608     return isCell() &amp;&amp; asCell()-&gt;isString();
 609 }
 610 
 611 inline bool JSValue::isBigInt() const
 612 {
 613     return isCell() &amp;&amp; asCell()-&gt;isBigInt();
 614 }
 615 
 616 inline bool JSValue::isSymbol() const
 617 {
 618     return isCell() &amp;&amp; asCell()-&gt;isSymbol();
 619 }
 620 
 621 inline bool JSValue::isPrimitive() const
 622 {
 623     return !isCell() || asCell()-&gt;isString() || asCell()-&gt;isSymbol() || asCell()-&gt;isBigInt();
 624 }
 625 
 626 inline bool JSValue::isGetterSetter() const
 627 {
 628     return isCell() &amp;&amp; asCell()-&gt;isGetterSetter();
 629 }
 630 
 631 inline bool JSValue::isCustomGetterSetter() const
 632 {
 633     return isCell() &amp;&amp; asCell()-&gt;isCustomGetterSetter();
 634 }
 635 
 636 inline bool JSValue::isObject() const
 637 {
 638     return isCell() &amp;&amp; asCell()-&gt;isObject();
 639 }
 640 
 641 inline bool JSValue::getString(JSGlobalObject* globalObject, String&amp; s) const
 642 {
 643     return isCell() &amp;&amp; asCell()-&gt;getString(globalObject, s);
 644 }
 645 
 646 inline String JSValue::getString(JSGlobalObject* globalObject) const
 647 {
 648     return isCell() ? asCell()-&gt;getString(globalObject) : String();
 649 }
 650 
 651 template &lt;typename Base&gt; String HandleConverter&lt;Base, Unknown&gt;::getString(JSGlobalObject* globalObject) const
 652 {
 653     return jsValue().getString(globalObject);
 654 }
 655 
 656 inline JSObject* JSValue::getObject() const
 657 {
 658     return isCell() ? asCell()-&gt;getObject() : 0;
 659 }
 660 
 661 ALWAYS_INLINE bool JSValue::getUInt32(uint32_t&amp; v) const
 662 {
 663     if (isInt32()) {
 664         int32_t i = asInt32();
 665         v = static_cast&lt;uint32_t&gt;(i);
 666         return i &gt;= 0;
 667     }
 668     if (isDouble()) {
 669         double d = asDouble();
 670         v = static_cast&lt;uint32_t&gt;(d);
 671         return v == d;
 672     }
 673     return false;
 674 }
 675 
 676 ALWAYS_INLINE Identifier JSValue::toPropertyKey(JSGlobalObject* globalObject) const
 677 {
 678     VM&amp; vm = getVM(globalObject);
 679     auto scope = DECLARE_THROW_SCOPE(vm);
 680 
 681     if (isString())
 682         RELEASE_AND_RETURN(scope, asString(*this)-&gt;toIdentifier(globalObject));
 683 
 684     JSValue primitive = toPrimitive(globalObject, PreferString);
 685     RETURN_IF_EXCEPTION(scope, vm.propertyNames-&gt;emptyIdentifier);
 686     if (primitive.isSymbol())
 687         RELEASE_AND_RETURN(scope, Identifier::fromUid(asSymbol(primitive)-&gt;privateName()));
 688 
 689     auto string = primitive.toString(globalObject);
 690     RETURN_IF_EXCEPTION(scope, { });
 691     RELEASE_AND_RETURN(scope, string-&gt;toIdentifier(globalObject));
 692 }
 693 
 694 ALWAYS_INLINE JSValue JSValue::toPropertyKeyValue(JSGlobalObject* globalObject) const
 695 {
 696     VM&amp; vm = getVM(globalObject);
 697     auto scope = DECLARE_THROW_SCOPE(vm);
 698 
 699     if (isString() || isSymbol())
 700         return *this;
 701 
 702     JSValue primitive = toPrimitive(globalObject, PreferString);
 703     RETURN_IF_EXCEPTION(scope, JSValue());
 704     if (primitive.isSymbol())
 705         return primitive;
 706 
 707     RELEASE_AND_RETURN(scope, primitive.toString(globalObject));
 708 }
 709 
 710 inline JSValue JSValue::toPrimitive(JSGlobalObject* globalObject, PreferredPrimitiveType preferredType) const
 711 {
 712     return isCell() ? asCell()-&gt;toPrimitive(globalObject, preferredType) : asValue();
 713 }
 714 
 715 inline PreferredPrimitiveType toPreferredPrimitiveType(JSGlobalObject* globalObject, JSValue value)
 716 {
 717     VM&amp; vm = getVM(globalObject);
 718     auto scope = DECLARE_THROW_SCOPE(vm);
 719 
 720     if (!value.isString()) {
 721         throwTypeError(globalObject, scope, &quot;Primitive hint is not a string.&quot;_s);
 722         return NoPreference;
 723     }
 724 
 725     StringImpl* hintString = asString(value)-&gt;value(globalObject).impl();
 726     RETURN_IF_EXCEPTION(scope, NoPreference);
 727 
 728     if (WTF::equal(hintString, &quot;default&quot;))
 729         return NoPreference;
 730     if (WTF::equal(hintString, &quot;number&quot;))
 731         return PreferNumber;
 732     if (WTF::equal(hintString, &quot;string&quot;))
 733         return PreferString;
 734 
 735     throwTypeError(globalObject, scope, &quot;Expected primitive hint to match one of &#39;default&#39;, &#39;number&#39;, &#39;string&#39;.&quot;_s);
 736     return NoPreference;
 737 }
 738 
 739 inline bool JSValue::getPrimitiveNumber(JSGlobalObject* globalObject, double&amp; number, JSValue&amp; value)
 740 {
 741     if (isInt32()) {
 742         number = asInt32();
 743         value = *this;
 744         return true;
 745     }
 746     if (isDouble()) {
 747         number = asDouble();
 748         value = *this;
 749         return true;
 750     }
 751     if (isCell())
 752         return asCell()-&gt;getPrimitiveNumber(globalObject, number, value);
 753     if (isTrue()) {
 754         number = 1.0;
 755         value = *this;
 756         return true;
 757     }
 758     if (isFalse() || isNull()) {
 759         number = 0.0;
 760         value = *this;
 761         return true;
 762     }
 763     ASSERT(isUndefined());
 764     number = PNaN;
 765     value = *this;
 766     return true;
 767 }
 768 
 769 ALWAYS_INLINE double JSValue::toNumber(JSGlobalObject* globalObject) const
 770 {
 771     if (isInt32())
 772         return asInt32();
 773     if (isDouble())
 774         return asDouble();
 775     return toNumberSlowCase(globalObject);
 776 }
 777 
 778 ALWAYS_INLINE Variant&lt;JSBigInt*, double&gt; JSValue::toNumeric(JSGlobalObject* globalObject) const
 779 {
 780     if (isInt32())
 781         return asInt32();
 782     if (isDouble())
 783         return asDouble();
 784     if (isBigInt())
 785         return asBigInt(*this);
 786 
 787     VM&amp; vm = getVM(globalObject);
 788     auto scope = DECLARE_THROW_SCOPE(vm);
 789     JSValue primValue = this-&gt;toPrimitive(globalObject, PreferNumber);
 790     RETURN_IF_EXCEPTION(scope, 0);
 791     if (primValue.isBigInt())
 792         return asBigInt(primValue);
 793     double value = primValue.toNumber(globalObject);
 794     RETURN_IF_EXCEPTION(scope, 0);
 795     return value;
 796 }
 797 
 798 ALWAYS_INLINE Variant&lt;JSBigInt*, int32_t&gt; JSValue::toBigIntOrInt32(JSGlobalObject* globalObject) const
 799 {
 800     if (isInt32())
 801         return asInt32();
 802     if (isDouble() &amp;&amp; canBeInt32(asDouble()))
 803         return static_cast&lt;int32_t&gt;(asDouble());
 804     if (isBigInt())
 805         return asBigInt(*this);
 806 
 807     VM&amp; vm = getVM(globalObject);
 808     auto scope = DECLARE_THROW_SCOPE(vm);
 809     JSValue primValue = this-&gt;toPrimitive(globalObject, PreferNumber);
 810     RETURN_IF_EXCEPTION(scope, 0);
 811     if (primValue.isBigInt())
 812         return asBigInt(primValue);
 813     int32_t value = primValue.toInt32(globalObject);
 814     RETURN_IF_EXCEPTION(scope, 0);
 815     return value;
 816 }
 817 
 818 inline JSObject* JSValue::toObject(JSGlobalObject* globalObject) const
 819 {
 820     return isCell() ? asCell()-&gt;toObject(globalObject) : toObjectSlowCase(globalObject);
 821 }
 822 
 823 inline bool JSValue::isFunction(VM&amp; vm) const
 824 {
 825     if (!isCell())
 826         return false;
 827     return asCell()-&gt;isFunction(vm);
 828 }
 829 
 830 inline bool JSValue::isCallable(VM&amp; vm, CallType&amp; callType, CallData&amp; callData) const
 831 {
 832     if (!isCell())
 833         return false;
 834     return asCell()-&gt;isCallable(vm, callType, callData);
 835 }
 836 
 837 inline bool JSValue::isConstructor(VM&amp; vm) const
 838 {
 839     if (!isCell())
 840         return false;
 841     return asCell()-&gt;isConstructor(vm);
 842 }
 843 
 844 inline bool JSValue::isConstructor(VM&amp; vm, ConstructType&amp; constructType, ConstructData&amp; constructData) const
 845 {
 846     if (!isCell())
 847         return false;
 848     return asCell()-&gt;isConstructor(vm, constructType, constructData);
 849 }
 850 
 851 // this method is here to be after the inline declaration of JSCell::inherits
 852 inline bool JSValue::inherits(VM&amp; vm, const ClassInfo* classInfo) const
 853 {
 854     return isCell() &amp;&amp; asCell()-&gt;inherits(vm, classInfo);
 855 }
 856 
 857 template&lt;typename Target&gt;
 858 inline bool JSValue::inherits(VM&amp; vm) const
 859 {
 860     return isCell() &amp;&amp; asCell()-&gt;inherits&lt;Target&gt;(vm);
 861 }
 862 
 863 inline const ClassInfo* JSValue::classInfoOrNull(VM&amp; vm) const
 864 {
 865     return isCell() ? asCell()-&gt;classInfo(vm) : nullptr;
 866 }
 867 
 868 inline JSValue JSValue::toThis(JSGlobalObject* globalObject, ECMAMode ecmaMode) const
 869 {
 870     return isCell() ? asCell()-&gt;methodTable(getVM(globalObject))-&gt;toThis(asCell(), globalObject, ecmaMode) : toThisSlowCase(globalObject, ecmaMode);
 871 }
 872 
 873 ALWAYS_INLINE JSValue JSValue::get(JSGlobalObject* globalObject, PropertyName propertyName) const
 874 {
 875     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
 876     return get(globalObject, propertyName, slot);
 877 }
 878 
 879 ALWAYS_INLINE JSValue JSValue::get(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot) const
 880 {
 881     auto scope = DECLARE_THROW_SCOPE(getVM(globalObject));
 882     bool hasSlot = getPropertySlot(globalObject, propertyName, slot);
 883     EXCEPTION_ASSERT(!scope.exception() || !hasSlot);
 884     if (!hasSlot)
 885         return jsUndefined();
 886     RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));
 887 }
 888 
 889 template&lt;typename CallbackWhenNoException&gt;
 890 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSValue::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, CallbackWhenNoException callback) const
 891 {
 892     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
 893     return getPropertySlot(globalObject, propertyName, slot, callback);
 894 }
 895 
 896 template&lt;typename CallbackWhenNoException&gt;
 897 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSValue::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot, CallbackWhenNoException callback) const
 898 {
 899     auto scope = DECLARE_THROW_SCOPE(getVM(globalObject));
 900     bool found = getPropertySlot(globalObject, propertyName, slot);
 901     RETURN_IF_EXCEPTION(scope, { });
 902     RELEASE_AND_RETURN(scope, callback(found, slot));
 903 }
 904 
 905 ALWAYS_INLINE bool JSValue::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot) const
 906 {
 907     auto scope = DECLARE_THROW_SCOPE(getVM(globalObject));
 908     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 909     // and if it&#39;s a string there are special properties to check first.
 910     JSObject* object;
 911     if (UNLIKELY(!isObject())) {
 912         if (isString()) {
 913             bool hasProperty = asString(*this)-&gt;getStringPropertySlot(globalObject, propertyName, slot);
 914             RETURN_IF_EXCEPTION(scope, false);
 915             if (hasProperty)
 916                 return true;
 917         }
 918         object = synthesizePrototype(globalObject);
 919         EXCEPTION_ASSERT(!!scope.exception() == !object);
 920         if (UNLIKELY(!object))
 921             return false;
 922     } else
 923         object = asObject(asCell());
 924 
 925     RELEASE_AND_RETURN(scope, object-&gt;getPropertySlot(globalObject, propertyName, slot));
 926 }
 927 
 928 ALWAYS_INLINE bool JSValue::getOwnPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot) const
 929 {
 930     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 931     // and if it&#39;s a string there are special properties to check first.
 932     auto scope = DECLARE_THROW_SCOPE(getVM(globalObject));
 933     if (UNLIKELY(!isObject())) {
 934         if (isString())
 935             RELEASE_AND_RETURN(scope, asString(*this)-&gt;getStringPropertySlot(globalObject, propertyName, slot));
 936 
 937         if (isUndefinedOrNull())
 938             throwException(globalObject, scope, createNotAnObjectError(globalObject, *this));
 939         return false;
 940     }
 941     RELEASE_AND_RETURN(scope, asObject(asCell())-&gt;getOwnPropertySlotInline(globalObject, propertyName, slot));
 942 }
 943 
 944 ALWAYS_INLINE JSValue JSValue::get(JSGlobalObject* globalObject, unsigned propertyName) const
 945 {
 946     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
 947     return get(globalObject, propertyName, slot);
 948 }
 949 
 950 ALWAYS_INLINE JSValue JSValue::get(JSGlobalObject* globalObject, unsigned propertyName, PropertySlot&amp; slot) const
 951 {
 952     auto scope = DECLARE_THROW_SCOPE(getVM(globalObject));
 953     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 954     // and if it&#39;s a string there are special properties to check first.
 955     JSObject* object;
 956     if (UNLIKELY(!isObject())) {
 957         if (isString()) {
 958             bool hasProperty = asString(*this)-&gt;getStringPropertySlot(globalObject, propertyName, slot);
 959             RETURN_IF_EXCEPTION(scope, { });
 960             if (hasProperty)
 961                 RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));
 962         }
 963         object = synthesizePrototype(globalObject);
 964         EXCEPTION_ASSERT(!!scope.exception() == !object);
 965         if (UNLIKELY(!object))
 966             return JSValue();
 967     } else
 968         object = asObject(asCell());
 969 
 970     bool hasSlot = object-&gt;getPropertySlot(globalObject, propertyName, slot);
 971     EXCEPTION_ASSERT(!scope.exception() || !hasSlot);
 972     if (!hasSlot)
 973         return jsUndefined();
 974     RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));
 975 }
 976 
 977 ALWAYS_INLINE JSValue JSValue::get(JSGlobalObject* globalObject, uint64_t propertyName) const
 978 {
 979     if (LIKELY(propertyName &lt;= std::numeric_limits&lt;unsigned&gt;::max()))
 980         return get(globalObject, static_cast&lt;unsigned&gt;(propertyName));
 981     return get(globalObject, Identifier::from(getVM(globalObject), static_cast&lt;double&gt;(propertyName)));
 982 }
 983 
 984 inline bool JSValue::put(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 985 {
 986     if (UNLIKELY(!isCell()))
 987         return putToPrimitive(globalObject, propertyName, value, slot);
 988 
 989     return asCell()-&gt;methodTable(getVM(globalObject))-&gt;put(asCell(), globalObject, propertyName, value, slot);
 990 }
 991 
 992 ALWAYS_INLINE bool JSValue::putInline(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 993 {
 994     if (UNLIKELY(!isCell()))
 995         return putToPrimitive(globalObject, propertyName, value, slot);
 996     return asCell()-&gt;putInline(globalObject, propertyName, value, slot);
 997 }
 998 
 999 inline bool JSValue::putByIndex(JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool shouldThrow)
1000 {
1001     if (UNLIKELY(!isCell()))
1002         return putToPrimitiveByIndex(globalObject, propertyName, value, shouldThrow);
1003 
1004     return asCell()-&gt;methodTable(getVM(globalObject))-&gt;putByIndex(asCell(), globalObject, propertyName, value, shouldThrow);
1005 }
1006 
1007 inline Structure* JSValue::structureOrNull() const
1008 {
1009     if (isCell())
1010         return asCell()-&gt;structure();
1011     return nullptr;
1012 }
1013 
1014 inline JSValue JSValue::structureOrUndefined() const
1015 {
1016     if (isCell())
1017         return JSValue(asCell()-&gt;structure());
1018     return jsUndefined();
1019 }
1020 
1021 // ECMA 11.9.3
1022 inline bool JSValue::equal(JSGlobalObject* globalObject, JSValue v1, JSValue v2)
1023 {
1024     if (v1.isInt32() &amp;&amp; v2.isInt32())
1025         return v1 == v2;
1026 
1027     return equalSlowCase(globalObject, v1, v2);
1028 }
1029 
1030 ALWAYS_INLINE bool JSValue::equalSlowCaseInline(JSGlobalObject* globalObject, JSValue v1, JSValue v2)
1031 {
1032     VM&amp; vm = getVM(globalObject);
1033     auto scope = DECLARE_THROW_SCOPE(vm);
1034     do {
1035         if (v1.isNumber() &amp;&amp; v2.isNumber())
1036             return v1.asNumber() == v2.asNumber();
1037 
1038         bool s1 = v1.isString();
1039         bool s2 = v2.isString();
1040         if (s1 &amp;&amp; s2)
1041             RELEASE_AND_RETURN(scope, asString(v1)-&gt;equal(globalObject, asString(v2)));
1042 
1043         if (v1.isBigInt() &amp;&amp; s2) {
1044             String v2String = asString(v2)-&gt;value(globalObject);
1045             RETURN_IF_EXCEPTION(scope, false);
1046             JSBigInt* n = JSBigInt::stringToBigInt(globalObject, v2String);
1047             RETURN_IF_EXCEPTION(scope, false);
1048             if (!n)
1049                 return false;
1050 
1051             v2 = JSValue(n);
1052             continue;
1053         }
1054 
1055         if (s1 &amp;&amp; v2.isBigInt()) {
1056             String v1String = asString(v1)-&gt;value(globalObject);
1057             RETURN_IF_EXCEPTION(scope, false);
1058             JSBigInt* n = JSBigInt::stringToBigInt(globalObject, v1String);
1059             RETURN_IF_EXCEPTION(scope, false);
1060             if (!n)
1061                 return false;
1062 
1063             v1 = JSValue(n);
1064             continue;
1065         }
1066 
1067         if (v1.isUndefinedOrNull()) {
1068             if (v2.isUndefinedOrNull())
1069                 return true;
1070             if (!v2.isCell())
1071                 return false;
1072             return v2.asCell()-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject);
1073         }
1074 
1075         if (v2.isUndefinedOrNull()) {
1076             if (!v1.isCell())
1077                 return false;
1078             return v1.asCell()-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject);
1079         }
1080 
1081         if (v1.isObject()) {
1082             if (v2.isObject())
1083                 return v1 == v2;
1084             JSValue p1 = v1.toPrimitive(globalObject);
1085             RETURN_IF_EXCEPTION(scope, false);
1086             v1 = p1;
1087             if (v1.isInt32() &amp;&amp; v2.isInt32())
1088                 return v1 == v2;
1089             continue;
1090         }
1091 
1092         if (v2.isObject()) {
1093             JSValue p2 = v2.toPrimitive(globalObject);
1094             RETURN_IF_EXCEPTION(scope, false);
1095             v2 = p2;
1096             if (v1.isInt32() &amp;&amp; v2.isInt32())
1097                 return v1 == v2;
1098             continue;
1099         }
1100 
1101         bool sym1 = v1.isSymbol();
1102         bool sym2 = v2.isSymbol();
1103         if (sym1 || sym2) {
1104             if (sym1 &amp;&amp; sym2)
1105                 return asSymbol(v1) == asSymbol(v2);
1106             return false;
1107         }
1108 
1109         if (s1 || s2) {
1110             double d1 = v1.toNumber(globalObject);
1111             RETURN_IF_EXCEPTION(scope, false);
1112             double d2 = v2.toNumber(globalObject);
1113             RETURN_IF_EXCEPTION(scope, false);
1114             return d1 == d2;
1115         }
1116 
1117         if (v1.isBoolean()) {
1118             if (v2.isNumber())
1119                 return static_cast&lt;double&gt;(v1.asBoolean()) == v2.asNumber();
1120             else if (v2.isBigInt()) {
1121                 v1 = JSValue(v1.toNumber(globalObject));
1122                 continue;
1123             }
1124         } else if (v2.isBoolean()) {
1125             if (v1.isNumber())
1126                 return v1.asNumber() == static_cast&lt;double&gt;(v2.asBoolean());
1127             else if (v1.isBigInt()) {
1128                 v2 = JSValue(v2.toNumber(globalObject));
1129                 continue;
1130             }
1131         }
1132 
1133         if (v1.isBigInt() &amp;&amp; v2.isBigInt())
1134             return JSBigInt::equals(asBigInt(v1), asBigInt(v2));
1135 
1136         if (v1.isBigInt() &amp;&amp; v2.isNumber())
1137             return asBigInt(v1)-&gt;equalsToNumber(v2);
1138 
1139         if (v2.isBigInt() &amp;&amp; v1.isNumber())
1140             return asBigInt(v2)-&gt;equalsToNumber(v1);
1141 
1142         return v1 == v2;
1143     } while (true);
1144 }
1145 
1146 // ECMA 11.9.3
1147 ALWAYS_INLINE bool JSValue::strictEqualSlowCaseInline(JSGlobalObject* globalObject, JSValue v1, JSValue v2)
1148 {
1149     ASSERT(v1.isCell() &amp;&amp; v2.isCell());
1150 
1151     if (v1.asCell()-&gt;isString() &amp;&amp; v2.asCell()-&gt;isString())
1152         return asString(v1)-&gt;equal(globalObject, asString(v2));
1153     if (v1.isBigInt() &amp;&amp; v2.isBigInt())
1154         return JSBigInt::equals(asBigInt(v1), asBigInt(v2));
1155     return v1 == v2;
1156 }
1157 
1158 inline bool JSValue::strictEqual(JSGlobalObject* globalObject, JSValue v1, JSValue v2)
1159 {
1160     if (v1.isInt32() &amp;&amp; v2.isInt32())
1161         return v1 == v2;
1162 
1163     if (v1.isNumber() &amp;&amp; v2.isNumber())
1164         return v1.asNumber() == v2.asNumber();
1165 
1166     if (!v1.isCell() || !v2.isCell())
1167         return v1 == v2;
1168 
1169     return strictEqualSlowCaseInline(globalObject, v1, v2);
1170 }
1171 
1172 inline int32_t JSValue::asInt32ForArithmetic() const
1173 {
1174     if (isBoolean())
1175         return asBoolean();
1176     return asInt32();
1177 }
1178 
1179 inline TriState JSValue::pureStrictEqual(JSValue v1, JSValue v2)
1180 {
1181     if (v1.isInt32() &amp;&amp; v2.isInt32())
1182         return triState(v1 == v2);
1183 
1184     if (v1.isNumber() &amp;&amp; v2.isNumber())
1185         return triState(v1.asNumber() == v2.asNumber());
1186 
1187     if (!v1.isCell() || !v2.isCell())
1188         return triState(v1 == v2);
1189 
1190     if (v1.asCell()-&gt;isString() &amp;&amp; v2.asCell()-&gt;isString()) {
1191         const StringImpl* v1String = asString(v1)-&gt;tryGetValueImpl();
1192         const StringImpl* v2String = asString(v2)-&gt;tryGetValueImpl();
1193         if (!v1String || !v2String)
1194             return MixedTriState;
1195         return triState(WTF::equal(*v1String, *v2String));
1196     }
1197 
1198     return triState(v1 == v2);
1199 }
1200 
1201 inline TriState JSValue::pureToBoolean() const
1202 {
1203     if (isInt32())
1204         return asInt32() ? TrueTriState : FalseTriState;
1205     if (isDouble())
1206         return isNotZeroAndOrdered(asDouble()) ? TrueTriState : FalseTriState; // false for NaN
1207     if (isCell())
1208         return asCell()-&gt;pureToBoolean();
1209     return isTrue() ? TrueTriState : FalseTriState;
1210 }
1211 
1212 ALWAYS_INLINE bool JSValue::requireObjectCoercible(JSGlobalObject* globalObject) const
1213 {
1214     VM&amp; vm = getVM(globalObject);
1215     auto scope = DECLARE_THROW_SCOPE(vm);
1216 
1217     if (!isUndefinedOrNull())
1218         return true;
1219     throwException(globalObject, scope, createNotAnObjectError(globalObject, *this));
1220     return false;
1221 }
1222 
1223 ALWAYS_INLINE bool isThisValueAltered(const PutPropertySlot&amp; slot, JSObject* baseObject)
1224 {
1225     JSValue thisValue = slot.thisValue();
1226     if (LIKELY(thisValue == baseObject))
1227         return false;
1228 
1229     if (!thisValue.isObject())
1230         return true;
1231     JSObject* thisObject = asObject(thisValue);
1232     // Only PureForwardingProxyType can be seen as the same to the original target object.
1233     if (thisObject-&gt;type() == PureForwardingProxyType &amp;&amp; jsCast&lt;JSProxy*&gt;(thisObject)-&gt;target() == baseObject)
1234         return false;
1235     return true;
1236 }
1237 
1238 // See section 7.2.9: https://tc39.github.io/ecma262/#sec-samevalue
1239 ALWAYS_INLINE bool sameValue(JSGlobalObject* globalObject, JSValue a, JSValue b)
1240 {
1241     if (!a.isNumber())
1242         return JSValue::strictEqual(globalObject, a, b);
1243     if (!b.isNumber())
1244         return false;
1245     double x = a.asNumber();
1246     double y = b.asNumber();
1247     bool xIsNaN = std::isnan(x);
1248     bool yIsNaN = std::isnan(y);
1249     if (xIsNaN || yIsNaN)
1250         return xIsNaN &amp;&amp; yIsNaN;
1251     return bitwise_cast&lt;uint64_t&gt;(x) == bitwise_cast&lt;uint64_t&gt;(y);
1252 }
1253 
1254 } // namespace JSC
    </pre>
  </body>
</html>
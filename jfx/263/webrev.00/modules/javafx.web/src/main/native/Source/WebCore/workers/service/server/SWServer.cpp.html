<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;SWServer.h&quot;
  28 
  29 #if ENABLE(SERVICE_WORKER)
  30 
  31 #include &quot;ExceptionCode.h&quot;
  32 #include &quot;ExceptionData.h&quot;
  33 #include &quot;Logging.h&quot;
  34 #include &quot;RegistrationStore.h&quot;
  35 #include &quot;SWOriginStore.h&quot;
  36 #include &quot;SWServerJobQueue.h&quot;
  37 #include &quot;SWServerRegistration.h&quot;
  38 #include &quot;SWServerToContextConnection.h&quot;
  39 #include &quot;SWServerWorker.h&quot;
  40 #include &quot;SecurityOrigin.h&quot;
  41 #include &quot;ServiceWorkerClientType.h&quot;
  42 #include &quot;ServiceWorkerContextData.h&quot;
  43 #include &quot;ServiceWorkerFetchResult.h&quot;
  44 #include &quot;ServiceWorkerJobData.h&quot;
  45 #include &lt;wtf/CompletionHandler.h&gt;
  46 #include &lt;wtf/MemoryPressureHandler.h&gt;
  47 #include &lt;wtf/NeverDestroyed.h&gt;
  48 #include &lt;wtf/text/WTFString.h&gt;
  49 
  50 namespace WebCore {
  51 
  52 static Seconds terminationDelay { 10_s };
  53 
  54 SWServer::Connection::Connection(SWServer&amp; server, Identifier identifier)
  55     : m_server(server)
  56     , m_identifier(identifier)
  57 {
  58 }
  59 
  60 HashSet&lt;SWServer*&gt;&amp; SWServer::allServers()
  61 {
  62     static NeverDestroyed&lt;HashSet&lt;SWServer*&gt;&gt; servers;
  63     return servers;
  64 }
  65 
  66 SWServer::~SWServer()
  67 {
  68     // Destroy the remaining connections before the SWServer gets destroyed since they have a raw pointer
  69     // to the server and since they try to unregister clients from the server in their destructor.
  70     auto connections = WTFMove(m_connections);
  71     connections.clear();
  72 
  73     for (auto&amp; callback : std::exchange(m_importCompletedCallbacks, { }))
  74         callback();
  75 
  76     Vector&lt;SWServerWorker*&gt; runningWorkers;
  77     for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
  78         if (worker-&gt;isRunning())
  79             runningWorkers.append(worker.ptr());
  80     }
  81     for (auto&amp; runningWorker : runningWorkers)
  82         terminateWorker(*runningWorker);
  83 
  84     allServers().remove(this);
  85 }
  86 
  87 SWServerWorker* SWServer::workerByID(ServiceWorkerIdentifier identifier) const
  88 {
  89     auto* worker = SWServerWorker::existingWorkerForIdentifier(identifier);
  90     ASSERT(!worker || worker-&gt;server() == this);
  91     return worker;
  92 }
  93 
  94 Optional&lt;ServiceWorkerClientData&gt; SWServer::serviceWorkerClientWithOriginByID(const ClientOrigin&amp; clientOrigin, const ServiceWorkerClientIdentifier&amp; clientIdentifier) const
  95 {
  96     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
  97     if (iterator == m_clientIdentifiersPerOrigin.end())
  98         return WTF::nullopt;
  99 
 100     if (!iterator-&gt;value.identifiers.contains(clientIdentifier))
 101         return WTF::nullopt;
 102 
 103     auto clientIterator = m_clientsById.find(clientIdentifier);
 104     ASSERT(clientIterator != m_clientsById.end());
 105     return clientIterator-&gt;value;
 106 }
 107 
 108 String SWServer::serviceWorkerClientUserAgent(const ClientOrigin&amp; clientOrigin) const
 109 {
 110     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
 111     if (iterator == m_clientIdentifiersPerOrigin.end())
 112         return String();
 113     return iterator-&gt;value.userAgent;
 114 }
 115 
 116 SWServerWorker* SWServer::activeWorkerFromRegistrationID(ServiceWorkerRegistrationIdentifier identifier)
 117 {
 118     auto* registration = m_registrations.get(identifier);
 119     return registration ? registration-&gt;activeWorker() : nullptr;
 120 }
 121 
 122 SWServerRegistration* SWServer::getRegistration(const ServiceWorkerRegistrationKey&amp; registrationKey)
 123 {
 124     return m_scopeToRegistrationMap.get(registrationKey).get();
 125 }
 126 
 127 void SWServer::registrationStoreImportComplete()
 128 {
 129     ASSERT(!m_importCompleted);
 130     m_importCompleted = true;
 131     m_originStore-&gt;importComplete();
 132 
 133     auto clearCallbacks = WTFMove(m_clearCompletionCallbacks);
 134     for (auto&amp; callback : clearCallbacks)
 135         callback();
 136 
 137     performGetOriginsWithRegistrationsCallbacks();
 138 
 139     for (auto&amp; callback : std::exchange(m_importCompletedCallbacks, { }))
 140         callback();
 141 }
 142 
 143 void SWServer::whenImportIsCompleted(CompletionHandler&lt;void()&gt;&amp;&amp; callback)
 144 {
 145     ASSERT(!m_importCompleted);
 146     m_importCompletedCallbacks.append(WTFMove(callback));
 147 }
 148 
 149 
 150 void SWServer::registrationStoreDatabaseFailedToOpen()
 151 {
 152     if (!m_importCompleted)
 153         registrationStoreImportComplete();
 154 }
 155 
 156 void SWServer::addRegistrationFromStore(ServiceWorkerContextData&amp;&amp; data)
 157 {
 158     // Pages should not have been able to make a new registration to this key while the import was still taking place.
 159     ASSERT(!m_scopeToRegistrationMap.contains(data.registration.key));
 160 
 161     auto registration = makeUnique&lt;SWServerRegistration&gt;(*this, data.registration.key, data.registration.updateViaCache, data.registration.scopeURL, data.scriptURL);
 162     registration-&gt;setLastUpdateTime(data.registration.lastUpdateTime);
 163     auto registrationPtr = registration.get();
 164     addRegistration(WTFMove(registration));
 165 
 166     auto worker = SWServerWorker::create(*this, *registrationPtr, data.scriptURL, data.script, data.contentSecurityPolicy, WTFMove(data.referrerPolicy), data.workerType, data.serviceWorkerIdentifier, WTFMove(data.scriptResourceMap));
 167     registrationPtr-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Active, worker.ptr());
 168     worker-&gt;setState(ServiceWorkerState::Activated);
 169 }
 170 
 171 void SWServer::addRegistration(std::unique_ptr&lt;SWServerRegistration&gt;&amp;&amp; registration)
 172 {
 173     m_originStore-&gt;add(registration-&gt;key().topOrigin());
 174     auto registrationID = registration-&gt;identifier();
 175     ASSERT(!m_scopeToRegistrationMap.contains(registration-&gt;key()));
 176     m_scopeToRegistrationMap.set(registration-&gt;key(), makeWeakPtr(*registration));
 177     auto addResult1 = m_registrations.add(registrationID, WTFMove(registration));
 178     ASSERT_UNUSED(addResult1, addResult1.isNewEntry);
 179 }
 180 
 181 void SWServer::removeRegistration(ServiceWorkerRegistrationIdentifier registrationID)
 182 {
 183     auto registration = m_registrations.take(registrationID);
 184     ASSERT(registration);
 185 
 186     auto it = m_scopeToRegistrationMap.find(registration-&gt;key());
 187     if (it != m_scopeToRegistrationMap.end() &amp;&amp; it-&gt;value == registration.get())
 188         m_scopeToRegistrationMap.remove(it);
 189 
 190     m_originStore-&gt;remove(registration-&gt;key().topOrigin());
 191     if (m_registrationStore)
 192         m_registrationStore-&gt;removeRegistration(registration-&gt;key());
 193 }
 194 
 195 Vector&lt;ServiceWorkerRegistrationData&gt; SWServer::getRegistrations(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
 196 {
 197     Vector&lt;SWServerRegistration*&gt; matchingRegistrations;
 198     for (auto&amp; item : m_scopeToRegistrationMap) {
 199         if (item.key.originIsMatching(topOrigin, clientURL)) {
 200             auto* registration = item.value.get();
 201             ASSERT(registration);
 202             if (registration)
 203                 matchingRegistrations.append(registration);
 204         }
 205     }
 206     // The specification mandates that registrations are returned in the insertion order.
 207     std::sort(matchingRegistrations.begin(), matchingRegistrations.end(), [](auto&amp; a, auto&amp; b) {
 208         return a-&gt;creationTime() &lt; b-&gt;creationTime();
 209     });
 210     Vector&lt;ServiceWorkerRegistrationData&gt; matchingRegistrationDatas;
 211     matchingRegistrationDatas.reserveInitialCapacity(matchingRegistrations.size());
 212     for (auto* registration : matchingRegistrations)
 213         matchingRegistrationDatas.uncheckedAppend(registration-&gt;data());
 214     return matchingRegistrationDatas;
 215 }
 216 
 217 void SWServer::clearAll(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 218 {
 219     if (!m_importCompleted) {
 220         m_clearCompletionCallbacks.append([this, completionHandler = WTFMove(completionHandler)] () mutable {
 221             ASSERT(m_importCompleted);
 222             clearAll(WTFMove(completionHandler));
 223         });
 224         return;
 225     }
 226 
 227     m_jobQueues.clear();
 228     while (!m_registrations.isEmpty())
 229         m_registrations.begin()-&gt;value-&gt;clear();
 230     m_pendingContextDatas.clear();
 231     m_originStore-&gt;clearAll();
 232     if (m_registrationStore)
 233         m_registrationStore-&gt;clearAll(WTFMove(completionHandler));
 234 }
 235 
 236 void SWServer::startSuspension(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 237 {
 238     if (!m_registrationStore) {
 239         completionHandler();
 240         return;
 241     }
 242     m_registrationStore-&gt;startSuspension(WTFMove(completionHandler));
 243 }
 244 
 245 void SWServer::endSuspension()
 246 {
 247     if (m_registrationStore)
 248         m_registrationStore-&gt;endSuspension();
 249 }
 250 
 251 void SWServer::clear(const SecurityOriginData&amp; securityOrigin, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 252 {
 253     if (!m_importCompleted) {
 254         m_clearCompletionCallbacks.append([this, securityOrigin, completionHandler = WTFMove(completionHandler)] () mutable {
 255             ASSERT(m_importCompleted);
 256             clear(securityOrigin, WTFMove(completionHandler));
 257         });
 258         return;
 259     }
 260 
 261     m_jobQueues.removeIf([&amp;](auto&amp; keyAndValue) {
 262         return keyAndValue.key.relatesToOrigin(securityOrigin);
 263     });
 264 
 265     Vector&lt;SWServerRegistration*&gt; registrationsToRemove;
 266     for (auto&amp; registration : m_registrations.values()) {
 267         if (registration-&gt;key().relatesToOrigin(securityOrigin))
 268             registrationsToRemove.append(registration.get());
 269     }
 270 
 271     for (auto&amp; contextDatas : m_pendingContextDatas.values()) {
 272         contextDatas.removeAllMatching([&amp;](auto&amp; contextData) {
 273             return contextData.registration.key.relatesToOrigin(securityOrigin);
 274         });
 275     }
 276 
 277     if (registrationsToRemove.isEmpty()) {
 278         completionHandler();
 279         return;
 280     }
 281 
 282     // Calling SWServerRegistration::clear() takes care of updating m_registrations, m_originStore and m_registrationStore.
 283     for (auto* registration : registrationsToRemove)
 284         registration-&gt;clear();
 285 
 286     if (m_registrationStore)
 287         m_registrationStore-&gt;flushChanges(WTFMove(completionHandler));
 288 }
 289 
 290 void SWServer::Connection::finishFetchingScriptInServer(const ServiceWorkerFetchResult&amp; result)
 291 {
 292     m_server.scriptFetchFinished(result);
 293 }
 294 
 295 void SWServer::Connection::didResolveRegistrationPromise(const ServiceWorkerRegistrationKey&amp; key)
 296 {
 297     m_server.didResolveRegistrationPromise(this, key);
 298 }
 299 
 300 void SWServer::Connection::addServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
 301 {
 302     m_server.addClientServiceWorkerRegistration(*this, identifier);
 303 }
 304 
 305 void SWServer::Connection::removeServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
 306 {
 307     m_server.removeClientServiceWorkerRegistration(*this, identifier);
 308 }
 309 
 310 void SWServer::Connection::syncTerminateWorker(ServiceWorkerIdentifier identifier)
 311 {
 312     if (auto* worker = m_server.workerByID(identifier))
 313         m_server.syncTerminateWorker(*worker);
 314 }
 315 
 316 SWServer::SWServer(UniqueRef&lt;SWOriginStore&gt;&amp;&amp; originStore, bool processTerminationDelayEnabled, String&amp;&amp; registrationDatabaseDirectory, PAL::SessionID sessionID, SoftUpdateCallback&amp;&amp; softUpdateCallback, CreateContextConnectionCallback&amp;&amp; callback)
 317     : m_originStore(WTFMove(originStore))
 318     , m_sessionID(sessionID)
 319     , m_isProcessTerminationDelayEnabled(processTerminationDelayEnabled)
 320     , m_createContextConnectionCallback(WTFMove(callback))
 321     , m_softUpdateCallback(WTFMove(softUpdateCallback))
 322 {
 323     RELEASE_LOG_IF(registrationDatabaseDirectory.isEmpty() &amp;&amp; !m_sessionID.isEphemeral(), ServiceWorker, &quot;No path to store the service worker registrations&quot;);
 324     if (!m_sessionID.isEphemeral())
 325         m_registrationStore = makeUnique&lt;RegistrationStore&gt;(*this, WTFMove(registrationDatabaseDirectory));
 326     else
 327         registrationStoreImportComplete();
 328 
 329     UNUSED_PARAM(registrationDatabaseDirectory);
 330     allServers().add(this);
 331 }
 332 
 333 // https://w3c.github.io/ServiceWorker/#schedule-job-algorithm
 334 void SWServer::scheduleJob(ServiceWorkerJobData&amp;&amp; jobData)
 335 {
 336     ASSERT(m_connections.contains(jobData.connectionIdentifier()) || jobData.connectionIdentifier() == Process::identifier());
 337 
 338     auto&amp; jobQueue = *m_jobQueues.ensure(jobData.registrationKey(), [this, &amp;jobData] {
 339         return makeUnique&lt;SWServerJobQueue&gt;(*this, jobData.registrationKey());
 340     }).iterator-&gt;value;
 341 
 342     if (!jobQueue.size()) {
 343         jobQueue.enqueueJob(WTFMove(jobData));
 344         jobQueue.runNextJob();
 345         return;
 346     }
 347     auto&amp; lastJob = jobQueue.lastJob();
 348     if (jobData.isEquivalent(lastJob)) {
 349         // FIXME: Per the spec, check if this job is equivalent to the last job on the queue.
 350         // If it is, stack it along with that job. For now, we just make sure to not call soft-update too often.
 351         if (jobData.type == ServiceWorkerJobType::Update &amp;&amp; jobData.connectionIdentifier() == Process::identifier())
 352             return;
 353     }
 354 
 355     jobQueue.enqueueJob(WTFMove(jobData));
 356     if (jobQueue.size() == 1)
 357         jobQueue.runNextJob();
 358 }
 359 
 360 void SWServer::rejectJob(const ServiceWorkerJobData&amp; jobData, const ExceptionData&amp; exceptionData)
 361 {
 362     LOG(ServiceWorker, &quot;Rejected ServiceWorker job %s in server&quot;, jobData.identifier().loggingString().utf8().data());
 363     auto* connection = m_connections.get(jobData.connectionIdentifier());
 364     if (!connection)
 365         return;
 366 
 367     connection-&gt;rejectJobInClient(jobData.identifier().jobIdentifier, exceptionData);
 368 }
 369 
 370 void SWServer::resolveRegistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationData&amp; registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
 371 {
 372     LOG(ServiceWorker, &quot;Resolved ServiceWorker job %s in server with registration %s&quot;, jobData.identifier().loggingString().utf8().data(), registrationData.identifier.loggingString().utf8().data());
 373     auto* connection = m_connections.get(jobData.connectionIdentifier());
 374     if (!connection) {
 375         if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes &amp;&amp; jobData.connectionIdentifier() == Process::identifier())
 376             didResolveRegistrationPromise(nullptr, registrationData.key);
 377         return;
 378     }
 379 
 380     connection-&gt;resolveRegistrationJobInClient(jobData.identifier().jobIdentifier, registrationData, shouldNotifyWhenResolved);
 381 }
 382 
 383 void SWServer::resolveUnregistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationKey&amp; registrationKey, bool unregistrationResult)
 384 {
 385     auto* connection = m_connections.get(jobData.connectionIdentifier());
 386     if (!connection)
 387         return;
 388 
 389     connection-&gt;resolveUnregistrationJobInClient(jobData.identifier().jobIdentifier, registrationKey, unregistrationResult);
 390 }
 391 
 392 URL static inline originURL(const SecurityOrigin&amp; origin)
 393 {
 394     URL url;
 395     url.setProtocol(origin.protocol());
 396     url.setHost(origin.host());
 397     if (origin.port())
 398         url.setPort(*origin.port());
 399     return url;
 400 }
 401 
 402 void SWServer::startScriptFetch(const ServiceWorkerJobData&amp; jobData, bool shouldRefreshCache)
 403 {
 404     LOG(ServiceWorker, &quot;Server issuing startScriptFetch for current job %s in client&quot;, jobData.identifier().loggingString().utf8().data());
 405     auto* connection = m_connections.get(jobData.connectionIdentifier());
 406     if (connection) {
 407         connection-&gt;startScriptFetchInClient(jobData.identifier().jobIdentifier, jobData.registrationKey(), shouldRefreshCache ? FetchOptions::Cache::NoCache : FetchOptions::Cache::Default);
 408         return;
 409     }
 410     if (jobData.connectionIdentifier() == Process::identifier()) {
 411         ASSERT(jobData.type == ServiceWorkerJobType::Update);
 412         // This is a soft-update job, create directly a network load to fetch the script.
 413         ResourceRequest request { jobData.scriptURL };
 414 
 415         auto topOrigin = jobData.topOrigin.securityOrigin();
 416         auto origin = SecurityOrigin::create(jobData.scriptURL);
 417 
 418         request.setDomainForCachePartition(topOrigin-&gt;domainForCachePartition());
 419         request.setAllowCookies(true);
 420         request.setFirstPartyForCookies(originURL(topOrigin));
 421 
 422         request.setHTTPHeaderField(HTTPHeaderName::Origin, origin-&gt;toString());
 423         request.setHTTPHeaderField(HTTPHeaderName::ServiceWorker, &quot;script&quot;_s);
 424         request.setHTTPReferrer(originURL(origin));
 425         request.setHTTPUserAgent(serviceWorkerClientUserAgent(ClientOrigin { jobData.topOrigin, SecurityOrigin::create(jobData.scriptURL)-&gt;data() }));
 426         request.setPriority(ResourceLoadPriority::Low);
 427 
 428         m_softUpdateCallback(ServiceWorkerJobData { jobData }, shouldRefreshCache, WTFMove(request), [this, weakThis = makeWeakPtr(this)](auto&amp; result) {
 429             if (!weakThis)
 430                 return;
 431             scriptFetchFinished(result);
 432         });
 433         return;
 434     }
 435     ASSERT_WITH_MESSAGE(connection, &quot;If the connection was lost, this job should have been cancelled&quot;);
 436 }
 437 
 438 void SWServer::scriptFetchFinished(const ServiceWorkerFetchResult&amp; result)
 439 {
 440     LOG(ServiceWorker, &quot;Server handling scriptFetchFinished for current job %s in client&quot;, result.jobDataIdentifier.loggingString().utf8().data());
 441 
 442     ASSERT(m_connections.contains(result.jobDataIdentifier.connectionIdentifier) || result.jobDataIdentifier.connectionIdentifier == Process::identifier());
 443 
 444     auto jobQueue = m_jobQueues.get(result.registrationKey);
 445     if (!jobQueue)
 446         return;
 447 
 448     jobQueue-&gt;scriptFetchFinished(result);
 449 }
 450 
 451 void SWServer::scriptContextFailedToStart(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, const String&amp; message)
 452 {
 453     if (!jobDataIdentifier)
 454         return;
 455 
 456     RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::scriptContextFailedToStart: Failed to start SW for job %s, error: %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data(), message.utf8().data());
 457 
 458     auto* jobQueue = m_jobQueues.get(worker.registrationKey());
 459     if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*jobDataIdentifier)) {
 460         // The job which started this worker has been canceled, terminate this worker.
 461         terminatePreinstallationWorker(worker);
 462         return;
 463     }
 464     jobQueue-&gt;scriptContextFailedToStart(*jobDataIdentifier, worker.identifier(), message);
 465 }
 466 
 467 void SWServer::scriptContextStarted(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker)
 468 {
 469     if (!jobDataIdentifier)
 470         return;
 471 
 472     auto* jobQueue = m_jobQueues.get(worker.registrationKey());
 473     if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*jobDataIdentifier)) {
 474         // The job which started this worker has been canceled, terminate this worker.
 475         terminatePreinstallationWorker(worker);
 476         return;
 477     }
 478     jobQueue-&gt;scriptContextStarted(*jobDataIdentifier, worker.identifier());
 479 }
 480 
 481 void SWServer::terminatePreinstallationWorker(SWServerWorker&amp; worker)
 482 {
 483     worker.terminate();
 484     auto* registration = worker.registration();
 485     if (registration &amp;&amp; registration-&gt;preInstallationWorker() == &amp;worker)
 486         registration-&gt;setPreInstallationWorker(nullptr);
 487 }
 488 
 489 void SWServer::didFinishInstall(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, bool wasSuccessful)
 490 {
 491     if (!jobDataIdentifier)
 492         return;
 493 
 494     if (wasSuccessful)
 495         RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Successfuly finished SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
 496     else
 497         RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Failed SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
 498 
 499     if (auto* jobQueue = m_jobQueues.get(worker.registrationKey()))
 500         jobQueue-&gt;didFinishInstall(*jobDataIdentifier, worker, wasSuccessful);
 501 }
 502 
 503 void SWServer::didFinishActivation(SWServerWorker&amp; worker)
 504 {
 505     RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishActivation: Finished activation for service worker %llu&quot;, this, worker.identifier().toUInt64());
 506 
 507     auto* registration = worker.registration();
 508     if (!registration)
 509         return;
 510 
 511     if (m_registrationStore)
 512         m_registrationStore-&gt;updateRegistration(worker.contextData());
 513     registration-&gt;didFinishActivation(worker.identifier());
 514 }
 515 
 516 // https://w3c.github.io/ServiceWorker/#clients-getall
 517 void SWServer::matchAll(SWServerWorker&amp; worker, const ServiceWorkerClientQueryOptions&amp; options, ServiceWorkerClientsMatchAllCallback&amp;&amp; callback)
 518 {
 519     // FIXME: Support reserved client filtering.
 520     // FIXME: Support WindowClient additional properties.
 521 
 522     Vector&lt;ServiceWorkerClientData&gt; matchingClients;
 523     forEachClientForOrigin(worker.origin(), [&amp;](auto&amp; clientData) {
 524         if (!options.includeUncontrolled) {
 525             auto registrationIdentifier = m_clientToControllingRegistration.get(clientData.identifier);
 526             if (worker.data().registrationIdentifier != registrationIdentifier)
 527                 return;
 528             if (&amp;worker != this-&gt;activeWorkerFromRegistrationID(registrationIdentifier))
 529                 return;
 530         }
 531         if (options.type != ServiceWorkerClientType::All &amp;&amp; options.type != clientData.type)
 532             return;
 533         matchingClients.append(clientData);
 534     });
 535     callback(WTFMove(matchingClients));
 536 }
 537 
 538 void SWServer::forEachClientForOrigin(const ClientOrigin&amp; origin, const WTF::Function&lt;void(ServiceWorkerClientData&amp;)&gt;&amp; apply)
 539 {
 540     auto iterator = m_clientIdentifiersPerOrigin.find(origin);
 541     if (iterator == m_clientIdentifiersPerOrigin.end())
 542         return;
 543 
 544     for (auto&amp; clientIdentifier : iterator-&gt;value.identifiers) {
 545         auto clientIterator = m_clientsById.find(clientIdentifier);
 546         ASSERT(clientIterator != m_clientsById.end());
 547         apply(clientIterator-&gt;value);
 548     }
 549 }
 550 
 551 void SWServer::claim(SWServerWorker&amp; worker)
 552 {
 553     auto&amp; origin = worker.origin();
 554     forEachClientForOrigin(origin, [&amp;](auto&amp; clientData) {
 555         auto* registration = this-&gt;doRegistrationMatching(origin.topOrigin, clientData.url);
 556         if (!(registration &amp;&amp; registration-&gt;key() == worker.registrationKey()))
 557             return;
 558 
 559         auto result = m_clientToControllingRegistration.add(clientData.identifier, registration-&gt;identifier());
 560         if (!result.isNewEntry) {
 561             auto previousIdentifier = result.iterator-&gt;value;
 562             if (previousIdentifier == registration-&gt;identifier())
 563                 return;
 564             result.iterator-&gt;value = registration-&gt;identifier();
 565             if (auto* controllingRegistration = m_registrations.get(previousIdentifier))
 566                 controllingRegistration-&gt;removeClientUsingRegistration(clientData.identifier);
 567         }
 568         registration-&gt;controlClient(clientData.identifier);
 569     });
 570 }
 571 
 572 void SWServer::didResolveRegistrationPromise(Connection* connection, const ServiceWorkerRegistrationKey&amp; registrationKey)
 573 {
 574     ASSERT_UNUSED(connection, !connection || m_connections.contains(connection-&gt;identifier()));
 575 
 576     if (auto* jobQueue = m_jobQueues.get(registrationKey))
 577         jobQueue-&gt;didResolveRegistrationPromise();
 578 }
 579 
 580 void SWServer::addClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
 581 {
 582     auto* registration = m_registrations.get(identifier);
 583     if (!registration) {
 584         LOG_ERROR(&quot;Request to add client-side ServiceWorkerRegistration to non-existent server-side registration&quot;);
 585         return;
 586     }
 587 
 588     registration-&gt;addClientServiceWorkerRegistration(connection.identifier());
 589 }
 590 
 591 void SWServer::removeClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
 592 {
 593     if (auto* registration = m_registrations.get(identifier))
 594         registration-&gt;removeClientServiceWorkerRegistration(connection.identifier());
 595 }
 596 
 597 void SWServer::updateWorker(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, SWServerRegistration&amp; registration, const URL&amp; url, const String&amp; script, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, const String&amp; referrerPolicy, WorkerType type, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt;&amp;&amp; scriptResourceMap)
 598 {
 599     tryInstallContextData({ jobDataIdentifier, registration.data(), ServiceWorkerIdentifier::generate(), script, contentSecurityPolicy, referrerPolicy, url, type, false, WTFMove(scriptResourceMap) });
 600 }
 601 
 602 void SWServer::tryInstallContextData(ServiceWorkerContextData&amp;&amp; data)
 603 {
 604     RegistrableDomain registrableDomain(data.scriptURL);
 605     auto* connection = contextConnectionForRegistrableDomain(registrableDomain);
 606     if (!connection) {
 607         m_pendingContextDatas.ensure(registrableDomain, [] {
 608             return Vector&lt;ServiceWorkerContextData&gt; { };
 609         }).iterator-&gt;value.append(WTFMove(data));
 610 
 611         createContextConnection(registrableDomain);
 612         return;
 613     }
 614 
 615     installContextData(data);
 616 }
 617 
 618 void SWServer::contextConnectionCreated(SWServerToContextConnection&amp; contextConnection)
 619 {
 620     for (auto&amp; connection : m_connections.values())
 621         connection-&gt;contextConnectionCreated(contextConnection);
 622 
 623     auto pendingContextDatas = m_pendingContextDatas.take(contextConnection.registrableDomain());
 624     for (auto&amp; data : pendingContextDatas)
 625         installContextData(data);
 626 
 627     auto serviceWorkerRunRequests = m_serviceWorkerRunRequests.take(contextConnection.registrableDomain());
 628     for (auto&amp; item : serviceWorkerRunRequests) {
 629         bool success = runServiceWorker(item.key);
 630         for (auto&amp; callback : item.value)
 631             callback(success ? &amp;contextConnection : nullptr);
 632     }
 633 }
 634 
 635 void SWServer::installContextData(const ServiceWorkerContextData&amp; data)
 636 {
 637     ASSERT_WITH_MESSAGE(!data.loadedFromDisk, &quot;Workers we just read from disk should only be launched as needed&quot;);
 638 
 639     if (data.jobDataIdentifier) {
 640         // Abort if the job that scheduled this has been cancelled.
 641         auto* jobQueue = m_jobQueues.get(data.registration.key);
 642         if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*data.jobDataIdentifier))
 643             return;
 644     }
 645 
 646     auto* registration = m_scopeToRegistrationMap.get(data.registration.key).get();
 647     auto worker = SWServerWorker::create(*this, *registration, data.scriptURL, data.script, data.contentSecurityPolicy, String { data.referrerPolicy }, data.workerType, data.serviceWorkerIdentifier, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt; { data.scriptResourceMap });
 648 
 649     auto* connection = worker-&gt;contextConnection();
 650     ASSERT(connection);
 651 
 652     registration-&gt;setPreInstallationWorker(worker.ptr());
 653     worker-&gt;setState(SWServerWorker::State::Running);
 654     auto userAgent = worker-&gt;userAgent();
 655     auto result = m_runningOrTerminatingWorkers.add(data.serviceWorkerIdentifier, WTFMove(worker));
 656     ASSERT_UNUSED(result, result.isNewEntry);
 657 
 658     connection-&gt;installServiceWorkerContext(data, userAgent);
 659 }
 660 
 661 void SWServer::runServiceWorkerIfNecessary(ServiceWorkerIdentifier identifier, RunServiceWorkerCallback&amp;&amp; callback)
 662 {
 663     auto* worker = workerByID(identifier);
 664     if (!worker) {
 665         callback(nullptr);
 666         return;
 667     }
 668 
 669     auto* contextConnection = worker-&gt;contextConnection();
 670     if (worker-&gt;isRunning()) {
 671         ASSERT(contextConnection);
 672         callback(contextConnection);
 673         return;
 674     }
 675 
 676     if (worker-&gt;state() == ServiceWorkerState::Redundant) {
 677         callback(nullptr);
 678         return;
 679     }
 680 
 681     if (!contextConnection) {
 682         auto&amp; serviceWorkerRunRequestsForOrigin = m_serviceWorkerRunRequests.ensure(worker-&gt;registrableDomain(), [] {
 683             return HashMap&lt;ServiceWorkerIdentifier, Vector&lt;RunServiceWorkerCallback&gt;&gt; { };
 684         }).iterator-&gt;value;
 685         serviceWorkerRunRequestsForOrigin.ensure(identifier, [&amp;] {
 686             return Vector&lt;RunServiceWorkerCallback&gt; { };
 687         }).iterator-&gt;value.append(WTFMove(callback));
 688 
 689         createContextConnection(worker-&gt;registrableDomain());
 690         return;
 691     }
 692 
 693     bool success = runServiceWorker(identifier);
 694     callback(success ? contextConnection : nullptr);
 695 }
 696 
 697 bool SWServer::runServiceWorker(ServiceWorkerIdentifier identifier)
 698 {
 699     auto* worker = workerByID(identifier);
 700     if (!worker)
 701         return false;
 702 
 703     // If the registration for a worker has been removed then the request to run
 704     // the worker is moot.
 705     if (!worker-&gt;registration())
 706         return false;
 707 
 708     auto addResult = m_runningOrTerminatingWorkers.add(identifier, *worker);
 709     ASSERT_UNUSED(addResult, addResult.isNewEntry || worker-&gt;isTerminating());
 710 
 711     worker-&gt;setState(SWServerWorker::State::Running);
 712 
 713     auto* contextConnection = worker-&gt;contextConnection();
 714     ASSERT(contextConnection);
 715 
 716     contextConnection-&gt;installServiceWorkerContext(worker-&gt;contextData(), worker-&gt;userAgent());
 717 
 718     return true;
 719 }
 720 
 721 void SWServer::terminateWorker(SWServerWorker&amp; worker)
 722 {
 723     terminateWorkerInternal(worker, Asynchronous);
 724 }
 725 
 726 void SWServer::syncTerminateWorker(SWServerWorker&amp; worker)
 727 {
 728     terminateWorkerInternal(worker, Synchronous);
 729 }
 730 
 731 void SWServer::terminateWorkerInternal(SWServerWorker&amp; worker, TerminationMode mode)
 732 {
 733     ASSERT(m_runningOrTerminatingWorkers.get(worker.identifier()) == &amp;worker);
 734     ASSERT(worker.isRunning());
 735 
 736     RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::terminateWorkerInternal: Terminating service worker %llu&quot;, this, worker.identifier().toUInt64());
 737 
 738     worker.setState(SWServerWorker::State::Terminating);
 739 
 740     auto* contextConnection = worker.contextConnection();
 741     ASSERT(contextConnection);
 742     if (!contextConnection) {
 743         LOG_ERROR(&quot;Request to terminate a worker whose context connection does not exist&quot;);
 744         workerContextTerminated(worker);
 745         return;
 746     }
 747 
 748     switch (mode) {
 749     case Asynchronous:
 750         contextConnection-&gt;terminateWorker(worker.identifier());
 751         break;
 752     case Synchronous:
 753         contextConnection-&gt;syncTerminateWorker(worker.identifier());
 754         break;
 755     };
 756 }
 757 
 758 void SWServer::markAllWorkersForRegistrableDomainAsTerminated(const RegistrableDomain&amp; registrableDomain)
 759 {
 760     Vector&lt;SWServerWorker*&gt; terminatedWorkers;
 761     for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
 762         if (worker-&gt;registrableDomain() == registrableDomain)
 763             terminatedWorkers.append(worker.ptr());
 764     }
 765     for (auto&amp; terminatedWorker : terminatedWorkers)
 766         workerContextTerminated(*terminatedWorker);
 767 }
 768 
 769 void SWServer::workerContextTerminated(SWServerWorker&amp; worker)
 770 {
 771     worker.setState(SWServerWorker::State::NotRunning);
 772 
 773     if (auto* jobQueue = m_jobQueues.get(worker.registrationKey()))
 774         jobQueue-&gt;cancelJobsFromServiceWorker(worker.identifier());
 775 
 776     // At this point if no registrations are referencing the worker then it will be destroyed,
 777     // removing itself from the m_workersByID map.
 778     auto result = m_runningOrTerminatingWorkers.take(worker.identifier());
 779     ASSERT_UNUSED(result, result &amp;&amp; result-&gt;ptr() == &amp;worker);
 780 }
 781 
 782 void SWServer::fireInstallEvent(SWServerWorker&amp; worker)
 783 {
 784     auto* contextConnection = worker.contextConnection();
 785     if (!contextConnection) {
 786         LOG_ERROR(&quot;Request to fire install event on a worker whose context connection does not exist&quot;);
 787         return;
 788     }
 789 
 790     contextConnection-&gt;fireInstallEvent(worker.identifier());
 791 }
 792 
 793 void SWServer::fireActivateEvent(SWServerWorker&amp; worker)
 794 {
 795     auto* contextConnection = worker.contextConnection();
 796     if (!contextConnection) {
 797         LOG_ERROR(&quot;Request to fire install event on a worker whose context connection does not exist&quot;);
 798         return;
 799     }
 800 
 801     contextConnection-&gt;fireActivateEvent(worker.identifier());
 802 }
 803 
 804 void SWServer::addConnection(std::unique_ptr&lt;Connection&gt;&amp;&amp; connection)
 805 {
 806     auto identifier = connection-&gt;identifier();
 807     ASSERT(!m_connections.contains(identifier));
 808     m_connections.add(identifier, WTFMove(connection));
 809 }
 810 
 811 void SWServer::removeConnection(SWServerConnectionIdentifier connectionIdentifier)
 812 {
 813     ASSERT(m_connections.contains(connectionIdentifier));
 814     m_connections.remove(connectionIdentifier);
 815 
 816     for (auto&amp; registration : m_registrations.values())
 817         registration-&gt;unregisterServerConnection(connectionIdentifier);
 818 
 819     for (auto&amp; jobQueue : m_jobQueues.values())
 820         jobQueue-&gt;cancelJobsFromConnection(connectionIdentifier);
 821 }
 822 
 823 SWServerRegistration* SWServer::doRegistrationMatching(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
 824 {
 825     ASSERT(isImportCompleted());
 826     SWServerRegistration* selectedRegistration = nullptr;
 827     for (auto&amp; pair : m_scopeToRegistrationMap) {
 828         if (!pair.key.isMatching(topOrigin, clientURL))
 829             continue;
 830         if (!selectedRegistration || selectedRegistration-&gt;key().scopeLength() &lt; pair.key.scopeLength())
 831             selectedRegistration = pair.value.get();
 832     }
 833 
 834     return selectedRegistration;
 835 }
 836 
 837 SWServerRegistration* SWServer::registrationFromServiceWorkerIdentifier(ServiceWorkerIdentifier identifier)
 838 {
 839     auto iterator = m_runningOrTerminatingWorkers.find(identifier);
 840     if (iterator == m_runningOrTerminatingWorkers.end())
 841         return nullptr;
 842     return iterator-&gt;value-&gt;registration();
 843 }
 844 
 845 void SWServer::registerServiceWorkerClient(ClientOrigin&amp;&amp; clientOrigin, ServiceWorkerClientData&amp;&amp; data, const Optional&lt;ServiceWorkerRegistrationIdentifier&gt;&amp; controllingServiceWorkerRegistrationIdentifier, String&amp;&amp; userAgent)
 846 {
 847     auto clientIdentifier = data.identifier;
 848 
 849     ASSERT(!m_clientsById.contains(clientIdentifier));
 850     m_clientsById.add(clientIdentifier, WTFMove(data));
 851 
 852     auto&amp; clientIdentifiersForOrigin = m_clientIdentifiersPerOrigin.ensure(clientOrigin, [] {
 853         return Clients { };
 854     }).iterator-&gt;value;
 855 
 856     ASSERT(!clientIdentifiersForOrigin.identifiers.contains(clientIdentifier));
 857     clientIdentifiersForOrigin.identifiers.append(clientIdentifier);
 858 
 859     if (!clientIdentifiersForOrigin.userAgent.isNull() &amp;&amp; clientIdentifiersForOrigin.userAgent != userAgent)
 860         RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::registerServiceWorkerClient: Service worker has clients using different user agents&quot;, this);
 861     clientIdentifiersForOrigin.userAgent = WTFMove(userAgent);
 862 
 863     clientIdentifiersForOrigin.terminateServiceWorkersTimer = nullptr;
 864 
 865     m_clientsByRegistrableDomain.ensure(clientOrigin.clientRegistrableDomain(), [] {
 866         return HashSet&lt;ServiceWorkerClientIdentifier&gt; { };
 867     }).iterator-&gt;value.add(clientIdentifier);
 868 
 869     if (!controllingServiceWorkerRegistrationIdentifier)
 870         return;
 871 
 872     auto* controllingRegistration = m_registrations.get(*controllingServiceWorkerRegistrationIdentifier);
 873     if (!controllingRegistration || !controllingRegistration-&gt;activeWorker())
 874         return;
 875 
 876     controllingRegistration-&gt;addClientUsingRegistration(clientIdentifier);
 877     ASSERT(!m_clientToControllingRegistration.contains(clientIdentifier));
 878     m_clientToControllingRegistration.add(clientIdentifier, *controllingServiceWorkerRegistrationIdentifier);
 879 }
 880 
 881 void SWServer::unregisterServiceWorkerClient(const ClientOrigin&amp; clientOrigin, ServiceWorkerClientIdentifier clientIdentifier)
 882 {
 883     auto clientRegistrableDomain = clientOrigin.clientRegistrableDomain();
 884 
 885     bool wasRemoved = m_clientsById.remove(clientIdentifier);
 886     ASSERT_UNUSED(wasRemoved, wasRemoved);
 887 
 888     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
 889     ASSERT(iterator != m_clientIdentifiersPerOrigin.end());
 890 
 891     auto&amp; clientIdentifiers = iterator-&gt;value.identifiers;
 892     clientIdentifiers.removeFirstMatching([&amp;] (const auto&amp; identifier) {
 893         return clientIdentifier == identifier;
 894     });
 895 
 896     if (clientIdentifiers.isEmpty()) {
 897         ASSERT(!iterator-&gt;value.terminateServiceWorkersTimer);
 898         iterator-&gt;value.terminateServiceWorkersTimer = makeUnique&lt;Timer&gt;([clientOrigin, clientRegistrableDomain, this] {
 899             Vector&lt;SWServerWorker*&gt; workersToTerminate;
 900             for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
 901                 if (worker-&gt;isRunning() &amp;&amp; worker-&gt;origin() == clientOrigin)
 902                     workersToTerminate.append(worker.ptr());
 903             }
 904             for (auto* worker : workersToTerminate)
 905                 terminateWorker(*worker);
 906 
 907             if (!m_clientsByRegistrableDomain.contains(clientRegistrableDomain)) {
 908                 if (auto* connection = contextConnectionForRegistrableDomain(clientRegistrableDomain)) {
 909                     removeContextConnection(*connection);
 910                     connection-&gt;connectionIsNoLongerNeeded();
 911                 }
 912             }
 913 
 914             m_clientIdentifiersPerOrigin.remove(clientOrigin);
 915         });
 916         iterator-&gt;value.terminateServiceWorkersTimer-&gt;startOneShot(m_isProcessTerminationDelayEnabled &amp;&amp; !MemoryPressureHandler::singleton().isUnderMemoryPressure() ? terminationDelay : 0_s);
 917     }
 918 
 919     auto clientsByRegistrableDomainIterator = m_clientsByRegistrableDomain.find(clientRegistrableDomain);
 920     ASSERT(clientsByRegistrableDomainIterator != m_clientsByRegistrableDomain.end());
 921     auto&amp; clientsForRegistrableDomain = clientsByRegistrableDomainIterator-&gt;value;
 922     clientsForRegistrableDomain.remove(clientIdentifier);
 923     if (clientsForRegistrableDomain.isEmpty())
 924         m_clientsByRegistrableDomain.remove(clientsByRegistrableDomainIterator);
 925 
 926     auto registrationIterator = m_clientToControllingRegistration.find(clientIdentifier);
 927     if (registrationIterator == m_clientToControllingRegistration.end())
 928         return;
 929 
 930     if (auto* registration = m_registrations.get(registrationIterator-&gt;value))
 931         registration-&gt;removeClientUsingRegistration(clientIdentifier);
 932 
 933     m_clientToControllingRegistration.remove(registrationIterator);
 934 }
 935 
 936 void SWServer::handleLowMemoryWarning()
 937 {
 938     // Accelerating the delayed termination of unused service workers due to memory pressure.
 939     if (m_isProcessTerminationDelayEnabled) {
 940         for (auto&amp; clients : m_clientIdentifiersPerOrigin.values()) {
 941             if (clients.terminateServiceWorkersTimer)
 942                 clients.terminateServiceWorkersTimer-&gt;startOneShot(0_s);
 943         }
 944     }
 945 }
 946 
 947 void SWServer::removeFromScopeToRegistrationMap(const ServiceWorkerRegistrationKey&amp; key)
 948 {
 949     m_scopeToRegistrationMap.remove(key);
 950 }
 951 
 952 bool SWServer::needsContextConnectionForRegistrableDomain(const RegistrableDomain&amp; registrableDomain) const
 953 {
 954     return m_clientsByRegistrableDomain.contains(registrableDomain);
 955 }
 956 
 957 void SWServer::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
 958 {
 959     for (auto&amp; connection : m_connections.values())
 960         connection-&gt;resolveRegistrationReadyRequests(registration);
 961 }
 962 
 963 void SWServer::Connection::whenRegistrationReady(uint64_t registrationReadyRequestIdentifier, const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
 964 {
 965     if (auto* registration = doRegistrationMatching(topOrigin, clientURL)) {
 966         if (registration-&gt;activeWorker()) {
 967             registrationReady(registrationReadyRequestIdentifier, registration-&gt;data());
 968             return;
 969         }
 970     }
 971     m_registrationReadyRequests.append({ topOrigin, clientURL, registrationReadyRequestIdentifier });
 972 }
 973 
 974 void SWServer::Connection::storeRegistrationsOnDisk(CompletionHandler&lt;void()&gt;&amp;&amp; callback)
 975 {
 976     if (!m_server.m_registrationStore) {
 977         callback();
 978         return;
 979     }
 980     m_server.m_registrationStore-&gt;closeDatabase(WTFMove(callback));
 981 }
 982 
 983 void SWServer::Connection::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
 984 {
 985     m_registrationReadyRequests.removeAllMatching([&amp;](auto&amp; request) {
 986         if (!registration.key().isMatching(request.topOrigin, request.clientURL))
 987             return false;
 988 
 989         this-&gt;registrationReady(request.identifier, registration.data());
 990         return true;
 991     });
 992 }
 993 
 994 void SWServer::getOriginsWithRegistrations(Function&lt;void(const HashSet&lt;SecurityOriginData&gt;&amp;)&gt;&amp;&amp; callback)
 995 {
 996     m_getOriginsWithRegistrationsCallbacks.append(WTFMove(callback));
 997 
 998     if (m_importCompleted)
 999         performGetOriginsWithRegistrationsCallbacks();
1000 }
1001 
1002 void SWServer::performGetOriginsWithRegistrationsCallbacks()
1003 {
1004     ASSERT(isMainThread());
1005     ASSERT(m_importCompleted);
1006 
1007     if (m_getOriginsWithRegistrationsCallbacks.isEmpty())
1008         return;
1009 
1010     HashSet&lt;SecurityOriginData&gt; originsWithRegistrations;
1011     for (auto&amp; key : m_scopeToRegistrationMap.keys()) {
1012         originsWithRegistrations.add(key.topOrigin());
1013         originsWithRegistrations.add(SecurityOriginData { key.scope().protocol().toString(), key.scope().host().toString(), key.scope().port() });
1014     }
1015 
1016     auto callbacks = WTFMove(m_getOriginsWithRegistrationsCallbacks);
1017     for (auto&amp; callback : callbacks)
1018         callback(originsWithRegistrations);
1019 }
1020 
1021 void SWServer::addContextConnection(SWServerToContextConnection&amp; connection)
1022 {
1023     RELEASE_LOG(ServiceWorker, &quot;SWServer::addContextConnection&quot;);
1024 
1025     ASSERT(!m_contextConnections.contains(connection.registrableDomain()));
1026 
1027     m_contextConnections.add(connection.registrableDomain(), &amp;connection);
1028 
1029     contextConnectionCreated(connection);
1030 }
1031 
1032 void SWServer::removeContextConnection(SWServerToContextConnection&amp; connection)
1033 {
1034     RELEASE_LOG(ServiceWorker, &quot;SWServer::removeContextConnection&quot;);
1035 
1036     auto&amp; registrableDomain = connection.registrableDomain();
1037 
1038     ASSERT(m_contextConnections.get(registrableDomain) == &amp;connection);
1039 
1040     m_contextConnections.remove(registrableDomain);
1041     markAllWorkersForRegistrableDomainAsTerminated(registrableDomain);
1042     if (needsContextConnectionForRegistrableDomain(registrableDomain))
1043         createContextConnection(registrableDomain);
1044 }
1045 
1046 void SWServer::createContextConnection(const RegistrableDomain&amp; registrableDomain)
1047 {
1048     ASSERT(!m_contextConnections.contains(registrableDomain));
1049     if (m_pendingConnectionDomains.contains(registrableDomain))
1050         return;
1051 
1052     RELEASE_LOG(ServiceWorker, &quot;SWServer::createContextConnection will create a connection&quot;);
1053 
1054     m_pendingConnectionDomains.add(registrableDomain);
1055     m_createContextConnectionCallback(registrableDomain, [this, weakThis = makeWeakPtr(this), registrableDomain] {
1056         if (!weakThis)
1057             return;
1058 
1059         RELEASE_LOG(ServiceWorker, &quot;SWServer::createContextConnection should now have created a connection&quot;);
1060 
1061         ASSERT(m_pendingConnectionDomains.contains(registrableDomain));
1062         m_pendingConnectionDomains.remove(registrableDomain);
1063 
1064         if (m_contextConnections.contains(registrableDomain))
1065             return;
1066 
1067         if (needsContextConnectionForRegistrableDomain(registrableDomain))
1068             createContextConnection(registrableDomain);
1069     });
1070 }
1071 
1072 bool SWServer::canHandleScheme(StringView scheme) const
1073 {
1074     if (scheme.isNull())
1075         return false;
1076     if (!equalLettersIgnoringASCIICase(scheme.substring(0, 4), &quot;http&quot;))
1077         return false;
1078     if (scheme.length() == 5 &amp;&amp; isASCIIAlphaCaselessEqual(scheme[4], &#39;s&#39;))
1079         return true;
1080     return scheme.length() == 4;
1081 }
1082 
1083 // https://w3c.github.io/ServiceWorker/#soft-update
1084 void SWServer::softUpdate(SWServerRegistration&amp; registration)
1085 {
1086     ServiceWorkerJobData jobData(Process::identifier(), ServiceWorkerIdentifier::generate());
1087     jobData.scriptURL = registration.scriptURL();
1088     jobData.topOrigin = registration.key().topOrigin();
1089     jobData.scopeURL = registration.scopeURLWithoutFragment();
1090     jobData.type = ServiceWorkerJobType::Update;
1091     scheduleJob(WTFMove(jobData));
1092 }
1093 
1094 } // namespace WebCore
1095 
1096 #endif // ENABLE(SERVICE_WORKER)
    </pre>
  </body>
</html>
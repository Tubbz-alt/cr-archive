<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/editing/markup.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="atk/FrameSelectionAtk.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../features.json.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/markup.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 174,16 ***</span>
          item.element-&gt;removeAttribute(item.attributeName);
  }
  
  std::unique_ptr&lt;Page&gt; createPageForSanitizingWebContent()
  {
<span class="line-modified">!     auto pageConfiguration = pageConfigurationWithEmptyClients();</span>
  
      auto page = makeUnique&lt;Page&gt;(WTFMove(pageConfiguration));
<span class="line-removed">-     page-&gt;setIsForSanitizingWebContent();</span>
      page-&gt;settings().setMediaEnabled(false);
      page-&gt;settings().setScriptEnabled(false);
      page-&gt;settings().setPluginsEnabled(false);
      page-&gt;settings().setAcceleratedCompositingEnabled(false);
  
      Frame&amp; frame = page-&gt;mainFrame();
      frame.setView(FrameView::create(frame, IntSize { 800, 600 }));
<span class="line-new-header">--- 174,16 ---</span>
          item.element-&gt;removeAttribute(item.attributeName);
  }
  
  std::unique_ptr&lt;Page&gt; createPageForSanitizingWebContent()
  {
<span class="line-modified">!     auto pageConfiguration = pageConfigurationWithEmptyClients(PAL::SessionID::defaultSessionID());</span>
  
      auto page = makeUnique&lt;Page&gt;(WTFMove(pageConfiguration));
      page-&gt;settings().setMediaEnabled(false);
      page-&gt;settings().setScriptEnabled(false);
<span class="line-added">+     page-&gt;settings().setParserScriptingFlagPolicy(SettingsBase::ParserScriptingFlagPolicy::Enabled);</span>
      page-&gt;settings().setPluginsEnabled(false);
      page-&gt;settings().setAcceleratedCompositingEnabled(false);
  
      Frame&amp; frame = page-&gt;mainFrame();
      frame.setView(FrameView::create(frame, IntSize { 800, 600 }));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,11 ***</span>
  class StyledMarkupAccumulator final : public MarkupAccumulator {
  public:
      enum RangeFullySelectsNode { DoesFullySelectNode, DoesNotFullySelectNode };
  
      StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs, SerializeComposedTree,
<span class="line-modified">!         AnnotateForInterchange, MSOListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized = nullptr);</span>
  
      Node* serializeNodes(const Position&amp; start, const Position&amp; end);
      void wrapWithNode(Node&amp;, bool convertBlocksToInlines = false, RangeFullySelectsNode = DoesFullySelectNode);
      void wrapWithStyleNode(StyleProperties*, Document&amp;, bool isBlock = false);
      String takeResults();
<span class="line-new-header">--- 220,11 ---</span>
  class StyledMarkupAccumulator final : public MarkupAccumulator {
  public:
      enum RangeFullySelectsNode { DoesFullySelectNode, DoesNotFullySelectNode };
  
      StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs, SerializeComposedTree,
<span class="line-modified">!         AnnotateForInterchange, StandardFontFamilySerializationMode, MSOListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized = nullptr);</span>
  
      Node* serializeNodes(const Position&amp; start, const Position&amp; end);
      void wrapWithNode(Node&amp;, bool convertBlocksToInlines = false, RangeFullySelectsNode = DoesFullySelectNode);
      void wrapWithStyleNode(StyleProperties*, Document&amp;, bool isBlock = false);
      String takeResults();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,25 ***</span>
      const AnnotateForInterchange m_annotate;
      RefPtr&lt;Node&gt; m_highestNodeToBeSerialized;
      RefPtr&lt;EditingStyle&gt; m_wrappingStyle;
      bool m_useComposedTree;
      bool m_needsPositionStyleConversion;
      bool m_needRelativeStyleWrapper { false };
      bool m_needClearingDiv { false };
<span class="line-removed">-     bool m_shouldPreserveMSOList;</span>
      bool m_inMSOList { false };
  };
  
  inline StyledMarkupAccumulator::StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
<span class="line-modified">!     AnnotateForInterchange annotate, MSOListMode msoListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized)</span>
      : MarkupAccumulator(nodes, urlsToResolve)
      , m_start(start)
      , m_end(end)
      , m_annotate(annotate)
      , m_highestNodeToBeSerialized(highestNodeToBeSerialized)
      , m_useComposedTree(serializeComposedTree == SerializeComposedTree::Yes)
      , m_needsPositionStyleConversion(needsPositionStyleConversion)
      , m_shouldPreserveMSOList(msoListMode == MSOListMode::Preserve)
  {
  }
  
  void StyledMarkupAccumulator::wrapWithNode(Node&amp; node, bool convertBlocksToInlines, RangeFullySelectsNode rangeFullySelectsNode)
<span class="line-new-header">--- 316,27 ---</span>
      const AnnotateForInterchange m_annotate;
      RefPtr&lt;Node&gt; m_highestNodeToBeSerialized;
      RefPtr&lt;EditingStyle&gt; m_wrappingStyle;
      bool m_useComposedTree;
      bool m_needsPositionStyleConversion;
<span class="line-added">+     StandardFontFamilySerializationMode m_standardFontFamilySerializationMode;</span>
<span class="line-added">+     bool m_shouldPreserveMSOList;</span>
      bool m_needRelativeStyleWrapper { false };
      bool m_needClearingDiv { false };
      bool m_inMSOList { false };
  };
  
  inline StyledMarkupAccumulator::StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
<span class="line-modified">!     AnnotateForInterchange annotate, StandardFontFamilySerializationMode standardFontFamilySerializationMode, MSOListMode msoListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized)</span>
      : MarkupAccumulator(nodes, urlsToResolve)
      , m_start(start)
      , m_end(end)
      , m_annotate(annotate)
      , m_highestNodeToBeSerialized(highestNodeToBeSerialized)
      , m_useComposedTree(serializeComposedTree == SerializeComposedTree::Yes)
      , m_needsPositionStyleConversion(needsPositionStyleConversion)
<span class="line-added">+     , m_standardFontFamilySerializationMode(standardFontFamilySerializationMode)</span>
      , m_shouldPreserveMSOList(msoListMode == MSOListMode::Preserve)
  {
  }
  
  void StyledMarkupAccumulator::wrapWithNode(Node&amp; node, bool convertBlocksToInlines, RangeFullySelectsNode rangeFullySelectsNode)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,11 ***</span>
          if (is&lt;StyledElement&gt;(element) &amp;&amp; downcast&lt;StyledElement&gt;(element).inlineStyle())
              newInlineStyle-&gt;overrideWithStyle(*downcast&lt;StyledElement&gt;(element).inlineStyle());
  
          if (shouldAnnotateOrForceInline) {
              if (shouldAnnotate())
<span class="line-modified">!                 newInlineStyle-&gt;mergeStyleFromRulesForSerialization(downcast&lt;HTMLElement&gt;(*const_cast&lt;Element*&gt;(&amp;element)));</span>
  
              if (addDisplayInline)
                  newInlineStyle-&gt;forceInline();
  
              if (m_needsPositionStyleConversion) {
<span class="line-new-header">--- 531,11 ---</span>
          if (is&lt;StyledElement&gt;(element) &amp;&amp; downcast&lt;StyledElement&gt;(element).inlineStyle())
              newInlineStyle-&gt;overrideWithStyle(*downcast&lt;StyledElement&gt;(element).inlineStyle());
  
          if (shouldAnnotateOrForceInline) {
              if (shouldAnnotate())
<span class="line-modified">!                 newInlineStyle-&gt;mergeStyleFromRulesForSerialization(downcast&lt;HTMLElement&gt;(*const_cast&lt;Element*&gt;(&amp;element)), m_standardFontFamilySerializationMode);</span>
  
              if (addDisplayInline)
                  newInlineStyle-&gt;forceInline();
  
              if (m_needsPositionStyleConversion) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 577,11 ***</span>
          Node* lastClosed = traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::DoNotEmitString);
          m_highestNodeToBeSerialized = lastClosed;
      }
  
      if (m_highestNodeToBeSerialized &amp;&amp; m_highestNodeToBeSerialized-&gt;parentNode())
<span class="line-modified">!         m_wrappingStyle = EditingStyle::wrappingStyleForSerialization(*m_highestNodeToBeSerialized-&gt;parentNode(), shouldAnnotate());</span>
  
      return traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::EmitString);
  }
  
  Node* StyledMarkupAccumulator::traverseNodesForSerialization(Node* startNode, Node* pastEnd, NodeTraversalMode traversalMode)
<span class="line-new-header">--- 579,11 ---</span>
          Node* lastClosed = traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::DoNotEmitString);
          m_highestNodeToBeSerialized = lastClosed;
      }
  
      if (m_highestNodeToBeSerialized &amp;&amp; m_highestNodeToBeSerialized-&gt;parentNode())
<span class="line-modified">!         m_wrappingStyle = EditingStyle::wrappingStyleForSerialization(*m_highestNodeToBeSerialized-&gt;parentNode(), shouldAnnotate(), m_standardFontFamilySerializationMode);</span>
  
      return traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::EmitString);
  }
  
  Node* StyledMarkupAccumulator::traverseNodesForSerialization(Node* startNode, Node* pastEnd, NodeTraversalMode traversalMode)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 820,11 ***</span>
  
      return specialCommonAncestor;
  }
  
  static String serializePreservingVisualAppearanceInternal(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
<span class="line-modified">!     AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, MSOListMode msoListMode)</span>
  {
      static NeverDestroyed&lt;const String&gt; interchangeNewlineString(MAKE_STATIC_STRING_IMPL(&quot;&lt;br class=\&quot;&quot; AppleInterchangeNewline &quot;\&quot;&gt;&quot;));
  
      if (!comparePositions(start, end))
          return emptyString();
<span class="line-new-header">--- 822,11 ---</span>
  
      return specialCommonAncestor;
  }
  
  static String serializePreservingVisualAppearanceInternal(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
<span class="line-modified">!     AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, StandardFontFamilySerializationMode standardFontFamilySerializationMode, MSOListMode msoListMode)</span>
  {
      static NeverDestroyed&lt;const String&gt; interchangeNewlineString(MAKE_STATIC_STRING_IMPL(&quot;&lt;br class=\&quot;&quot; AppleInterchangeNewline &quot;\&quot;&gt;&quot;));
  
      if (!comparePositions(start, end))
          return emptyString();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 846,11 ***</span>
          fullySelectedRoot = body;
      bool needsPositionStyleConversion = body &amp;&amp; fullySelectedRoot == body &amp;&amp; document.settings().shouldConvertPositionStyleOnCopy();
  
      Node* specialCommonAncestor = highestAncestorToWrapMarkup(start, end, *commonAncestor, annotate);
  
<span class="line-modified">!     StyledMarkupAccumulator accumulator(start, end, nodes, urlsToResolve, serializeComposedTree, annotate, msoListMode, needsPositionStyleConversion, specialCommonAncestor);</span>
  
      Position startAdjustedForInterchangeNewline = start;
      if (annotate == AnnotateForInterchange::Yes &amp;&amp; needInterchangeNewlineAfter(visibleStart)) {
          if (visibleStart == visibleEnd.previous())
              return interchangeNewlineString;
<span class="line-new-header">--- 848,11 ---</span>
          fullySelectedRoot = body;
      bool needsPositionStyleConversion = body &amp;&amp; fullySelectedRoot == body &amp;&amp; document.settings().shouldConvertPositionStyleOnCopy();
  
      Node* specialCommonAncestor = highestAncestorToWrapMarkup(start, end, *commonAncestor, annotate);
  
<span class="line-modified">!     StyledMarkupAccumulator accumulator(start, end, nodes, urlsToResolve, serializeComposedTree, annotate, standardFontFamilySerializationMode, msoListMode, needsPositionStyleConversion, specialCommonAncestor);</span>
  
      Position startAdjustedForInterchangeNewline = start;
      if (annotate == AnnotateForInterchange::Yes &amp;&amp; needInterchangeNewlineAfter(visibleStart)) {
          if (visibleStart == visibleEnd.previous())
              return interchangeNewlineString;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 915,17 ***</span>
  }
  
  String serializePreservingVisualAppearance(const Range&amp; range, Vector&lt;Node*&gt;* nodes, AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, ResolveURLs urlsToReslve)
  {
      return serializePreservingVisualAppearanceInternal(range.startPosition(), range.endPosition(), nodes, urlsToReslve, SerializeComposedTree::No,
<span class="line-modified">!         annotate, convertBlocksToInlines, MSOListMode::DoNotPreserve);</span>
  }
  
  String serializePreservingVisualAppearance(const VisibleSelection&amp; selection, ResolveURLs resolveURLs, SerializeComposedTree serializeComposedTree, Vector&lt;Node*&gt;* nodes)
  {
      return serializePreservingVisualAppearanceInternal(selection.start(), selection.end(), nodes, resolveURLs, serializeComposedTree,
<span class="line-modified">!         AnnotateForInterchange::Yes, ConvertBlocksToInlines::No, MSOListMode::DoNotPreserve);</span>
  }
  
  
  static bool shouldPreserveMSOLists(const String&amp; markup)
  {
<span class="line-new-header">--- 917,17 ---</span>
  }
  
  String serializePreservingVisualAppearance(const Range&amp; range, Vector&lt;Node*&gt;* nodes, AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, ResolveURLs urlsToReslve)
  {
      return serializePreservingVisualAppearanceInternal(range.startPosition(), range.endPosition(), nodes, urlsToReslve, SerializeComposedTree::No,
<span class="line-modified">!         annotate, convertBlocksToInlines, StandardFontFamilySerializationMode::Keep, MSOListMode::DoNotPreserve);</span>
  }
  
  String serializePreservingVisualAppearance(const VisibleSelection&amp; selection, ResolveURLs resolveURLs, SerializeComposedTree serializeComposedTree, Vector&lt;Node*&gt;* nodes)
  {
      return serializePreservingVisualAppearanceInternal(selection.start(), selection.end(), nodes, resolveURLs, serializeComposedTree,
<span class="line-modified">!         AnnotateForInterchange::Yes, ConvertBlocksToInlines::No, StandardFontFamilySerializationMode::Keep, MSOListMode::DoNotPreserve);</span>
  }
  
  
  static bool shouldPreserveMSOLists(const String&amp; markup)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 948,11 ***</span>
      ASSERT(bodyElement);
      bodyElement-&gt;appendChild(fragment.get());
  
      // SerializeComposedTree::No because there can&#39;t be a shadow tree in the pasted fragment.
      auto result = serializePreservingVisualAppearanceInternal(firstPositionInNode(bodyElement.get()), lastPositionInNode(bodyElement.get()), nullptr,
<span class="line-modified">!         ResolveURLs::YesExcludingLocalFileURLsForPrivacy, SerializeComposedTree::No, AnnotateForInterchange::Yes, ConvertBlocksToInlines::No,  msoListMode);</span>
  
      if (msoListMode == MSOListMode::Preserve) {
          StringBuilder builder;
          builder.appendLiteral(&quot;&lt;html xmlns:o=\&quot;urn:schemas-microsoft-com:office:office\&quot;\n&quot;
              &quot;xmlns:w=\&quot;urn:schemas-microsoft-com:office:word\&quot;\n&quot;
<span class="line-new-header">--- 950,11 ---</span>
      ASSERT(bodyElement);
      bodyElement-&gt;appendChild(fragment.get());
  
      // SerializeComposedTree::No because there can&#39;t be a shadow tree in the pasted fragment.
      auto result = serializePreservingVisualAppearanceInternal(firstPositionInNode(bodyElement.get()), lastPositionInNode(bodyElement.get()), nullptr,
<span class="line-modified">!         ResolveURLs::YesExcludingLocalFileURLsForPrivacy, SerializeComposedTree::No, AnnotateForInterchange::Yes, ConvertBlocksToInlines::No,  StandardFontFamilySerializationMode::Strip, msoListMode);</span>
  
      if (msoListMode == MSOListMode::Preserve) {
          StringBuilder builder;
          builder.appendLiteral(&quot;&lt;html xmlns:o=\&quot;urn:schemas-microsoft-com:office:office\&quot;\n&quot;
              &quot;xmlns:w=\&quot;urn:schemas-microsoft-com:office:word\&quot;\n&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 981,13 ***</span>
          attachment-&gt;setUniqueIdentifier(attachment-&gt;attributeWithoutSynchronization(webkitattachmentidAttr));
  
          auto attachmentPath = attachment-&gt;attachmentPath();
          auto blobURL = attachment-&gt;blobURL();
          if (!attachmentPath.isEmpty())
<span class="line-modified">!             attachment-&gt;setFile(File::create(fragment.document().sessionID(), attachmentPath));</span>
          else if (!blobURL.isEmpty())
<span class="line-modified">!             attachment-&gt;setFile(File::deserialize(fragment.document().sessionID(), { }, blobURL, attachment-&gt;attachmentType(), attachment-&gt;attachmentTitle()));</span>
  
          // Remove temporary attributes that were previously added in StyledMarkupAccumulator::appendCustomAttributes.
          attachment-&gt;removeAttribute(webkitattachmentidAttr);
          attachment-&gt;removeAttribute(webkitattachmentpathAttr);
          attachment-&gt;removeAttribute(webkitattachmentbloburlAttr);
<span class="line-new-header">--- 983,13 ---</span>
          attachment-&gt;setUniqueIdentifier(attachment-&gt;attributeWithoutSynchronization(webkitattachmentidAttr));
  
          auto attachmentPath = attachment-&gt;attachmentPath();
          auto blobURL = attachment-&gt;blobURL();
          if (!attachmentPath.isEmpty())
<span class="line-modified">!             attachment-&gt;setFile(File::create(attachmentPath));</span>
          else if (!blobURL.isEmpty())
<span class="line-modified">!             attachment-&gt;setFile(File::deserialize({ }, blobURL, attachment-&gt;attachmentType(), attachment-&gt;attachmentTitle()));</span>
  
          // Remove temporary attributes that were previously added in StyledMarkupAccumulator::appendCustomAttributes.
          attachment-&gt;removeAttribute(webkitattachmentidAttr);
          attachment-&gt;removeAttribute(webkitattachmentpathAttr);
          attachment-&gt;removeAttribute(webkitattachmentbloburlAttr);
</pre>
<center><a href="atk/FrameSelectionAtk.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../features.json.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
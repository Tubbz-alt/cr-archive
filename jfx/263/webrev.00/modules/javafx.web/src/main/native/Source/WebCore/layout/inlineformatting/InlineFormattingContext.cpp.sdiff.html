<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../floats/FloatingState.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineFormattingContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 


 31 #include &quot;InlineFormattingState.h&quot;
<span class="line-removed"> 32 #include &quot;InlineLineBreaker.h&quot;</span>
 33 #include &quot;InlineTextItem.h&quot;

 34 #include &quot;LayoutBox.h&quot;
 35 #include &quot;LayoutContainer.h&quot;

 36 #include &quot;LayoutState.h&quot;
 37 #include &quot;Logging.h&quot;
<span class="line-modified"> 38 #include &quot;Textutil.h&quot;</span>

 39 #include &lt;wtf/IsoMallocInlines.h&gt;
 40 #include &lt;wtf/text/TextStream.h&gt;
 41 
 42 namespace WebCore {
 43 namespace Layout {
 44 
 45 WTF_MAKE_ISO_ALLOCATED_IMPL(InlineFormattingContext);
 46 
<span class="line-modified"> 47 InlineFormattingContext::InlineFormattingContext(const Box&amp; formattingContextRoot, InlineFormattingState&amp; formattingState)</span>
 48     : FormattingContext(formattingContextRoot, formattingState)
 49 {
 50 }
 51 
<span class="line-modified"> 52 static inline const Box* nextInPreOrder(const Box&amp; layoutBox, const Container&amp; stayWithin)</span>
 53 {
<span class="line-modified"> 54     const Box* nextInPreOrder = nullptr;</span>
<span class="line-modified"> 55     if (!layoutBox.establishesFormattingContext() &amp;&amp; is&lt;Container&gt;(layoutBox) &amp;&amp; downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())</span>
<span class="line-modified"> 56         return downcast&lt;Container&gt;(layoutBox).firstInFlowOrFloatingChild();</span>







 57 
<span class="line-modified"> 58     for (nextInPreOrder = &amp;layoutBox; nextInPreOrder &amp;&amp; nextInPreOrder != &amp;stayWithin; nextInPreOrder = nextInPreOrder-&gt;parent()) {</span>
 59         if (auto* nextSibling = nextInPreOrder-&gt;nextInFlowOrFloatingSibling())
 60             return nextSibling;
 61     }
 62     return nullptr;
 63 }
 64 
<span class="line-modified"> 65 void InlineFormattingContext::layout() const</span>
 66 {
<span class="line-modified"> 67     if (!is&lt;Container&gt;(root()))</span>
<span class="line-modified"> 68         return;</span>
<span class="line-removed"> 69 </span>
<span class="line-removed"> 70     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());</span>
<span class="line-removed"> 71     if (!root.hasInFlowOrFloatingChild())</span>
<span class="line-removed"> 72         return;</span>
 73 
<span class="line-modified"> 74     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Start] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified"> 75     auto availableWidth = layoutState().displayBoxForLayoutBox(root).contentBoxWidth();</span>
<span class="line-modified"> 76     auto usedValues = UsedHorizontalValues { availableWidth };</span>
<span class="line-modified"> 77     auto* layoutBox = root.firstInFlowOrFloatingChild();</span>
<span class="line-removed"> 78     // Compute width/height for non-text content and margin/border/padding for inline containers.</span>
 79     while (layoutBox) {
<span class="line-modified"> 80         if (layoutBox-&gt;establishesFormattingContext())</span>
<span class="line-modified"> 81             layoutFormattingContextRoot(*layoutBox, usedValues);</span>
<span class="line-modified"> 82         else if (is&lt;Container&gt;(*layoutBox))</span>
<span class="line-modified"> 83             computeMarginBorderAndPaddingForInlineContainer(downcast&lt;Container&gt;(*layoutBox), usedValues);</span>
<span class="line-modified"> 84         else if (layoutBox-&gt;isReplaced())</span>
<span class="line-modified"> 85             computeWidthAndHeightForReplacedInlineBox(*layoutBox, usedValues);</span>
<span class="line-modified"> 86         else {</span>
<span class="line-modified"> 87             ASSERT(layoutBox-&gt;isInlineLevelBox());</span>
<span class="line-modified"> 88             initializeMarginBorderAndPaddingForGenericInlineBox(*layoutBox);</span>
<span class="line-modified"> 89         }</span>
<span class="line-modified"> 90         layoutBox = nextInPreOrder(*layoutBox, root);</span>



























 91     }
 92 
<span class="line-modified"> 93     // FIXME: This is such a waste when intrinsic width computation already collected the inline items.</span>
<span class="line-removed"> 94     formattingState().inlineItems().clear();</span>
<span class="line-removed"> 95     formattingState().inlineRuns().clear();</span>
 96 
<span class="line-modified"> 97     collectInlineContent();</span>
<span class="line-modified"> 98     InlineLayout(*this).layout(formattingState().inlineItems(), availableWidth);</span>
<span class="line-modified"> 99     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[End] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root &lt;&lt; &quot;)&quot;);</span>
100 }
101 
<span class="line-modified">102 FormattingContext::IntrinsicWidthConstraints InlineFormattingContext::computedIntrinsicWidthConstraints() const</span>






































103 {
104     auto&amp; layoutState = this-&gt;layoutState();
105     ASSERT(!formattingState().intrinsicWidthConstraints());
106 
<span class="line-modified">107     if (!is&lt;Container&gt;(root()) || !downcast&lt;Container&gt;(root()).hasInFlowOrFloatingChild()) {</span>
<span class="line-modified">108         auto constraints = Geometry::constrainByMinMaxWidth(root(), { });</span>
109         formattingState().setIntrinsicWidthConstraints(constraints);
110         return constraints;
111     }
112 
<span class="line-removed">113     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());</span>
114     Vector&lt;const Box*&gt; formattingContextRootList;
<span class="line-modified">115     auto usedValues = UsedHorizontalValues { };</span>
<span class="line-modified">116     auto* layoutBox = root.firstInFlowOrFloatingChild();</span>

117     while (layoutBox) {
<span class="line-modified">118         if (layoutBox-&gt;establishesFormattingContext()) {</span>








119             formattingContextRootList.append(layoutBox);



120             computeIntrinsicWidthForFormattingRoot(*layoutBox);
<span class="line-modified">121         } else if (layoutBox-&gt;isReplaced() || is&lt;Container&gt;(*layoutBox)) {</span>
<span class="line-modified">122             computeBorderAndPadding(*layoutBox, usedValues);</span>
<span class="line-modified">123             // inline-block and replaced.</span>
<span class="line-modified">124             auto needsWidthComputation = layoutBox-&gt;isReplaced();</span>
<span class="line-modified">125             if (needsWidthComputation)</span>
<span class="line-modified">126                 computeWidthAndMargin(*layoutBox, usedValues);</span>
<span class="line-removed">127             else {</span>
<span class="line-removed">128                 // Simple inline container with no intrinsic width &lt;span&gt;.</span>
<span class="line-removed">129                 computeHorizontalMargin(*layoutBox, usedValues);</span>
<span class="line-removed">130             }</span>
<span class="line-removed">131         }</span>
<span class="line-removed">132         layoutBox = nextInPreOrder(*layoutBox, root);</span>
133     }
134 
<span class="line-modified">135     collectInlineContent();</span>
136 
137     auto maximumLineWidth = [&amp;](auto availableWidth) {
138         // Switch to the min/max formatting root width values before formatting the lines.
139         for (auto* formattingRoot : formattingContextRootList) {
140             auto intrinsicWidths = layoutState.formattingStateForBox(*formattingRoot).intrinsicWidthConstraintsForBox(*formattingRoot);
<span class="line-modified">141             auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*formattingRoot);</span>
142             auto contentWidth = (availableWidth ? intrinsicWidths-&gt;maximum : intrinsicWidths-&gt;minimum) - displayBox.horizontalMarginBorderAndPadding();
143             displayBox.setContentBoxWidth(contentWidth);
144         }
<span class="line-modified">145         return InlineLayout(*this).computedIntrinsicWidth(formattingState().inlineItems(), availableWidth);</span>
146     };
147 
<span class="line-modified">148     auto constraints = Geometry::constrainByMinMaxWidth(root, { maximumLineWidth(0), maximumLineWidth(LayoutUnit::max()) });</span>
149     formattingState().setIntrinsicWidthConstraints(constraints);
150     return constraints;
151 }
152 
<span class="line-modified">153 void InlineFormattingContext::initializeMarginBorderAndPaddingForGenericInlineBox(const Box&amp; layoutBox) const</span>
154 {
<span class="line-modified">155     ASSERT(layoutBox.isAnonymous() || layoutBox.isLineBreakBox());</span>
<span class="line-modified">156     auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">157 </span>
<span class="line-modified">158     displayBox.setVerticalMargin({ { }, { } });</span>
<span class="line-modified">159     displayBox.setHorizontalMargin({ });</span>
<span class="line-modified">160     displayBox.setBorder({ { }, { } });</span>
<span class="line-modified">161     displayBox.setPadding({ });</span>
<span class="line-modified">162 }</span>
<span class="line-modified">163 </span>
<span class="line-modified">164 void InlineFormattingContext::computeMarginBorderAndPaddingForInlineContainer(const Container&amp; container, UsedHorizontalValues usedValues) const</span>
<span class="line-modified">165 {</span>
<span class="line-modified">166     computeHorizontalMargin(container, usedValues);</span>
<span class="line-modified">167     computeBorderAndPadding(container, usedValues);</span>
<span class="line-modified">168     // Inline containers (&lt;span&gt;) have 0 vertical margins.</span>
<span class="line-modified">169     layoutState().displayBoxForLayoutBox(container).setVerticalMargin({ { }, { } });</span>


170 }
171 
<span class="line-modified">172 void InlineFormattingContext::computeIntrinsicWidthForFormattingRoot(const Box&amp; formattingRoot) const</span>
173 {
174     ASSERT(formattingRoot.establishesFormattingContext());
<span class="line-modified">175     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified">176 </span>
<span class="line-removed">177     auto usedValues = UsedHorizontalValues { };</span>
<span class="line-removed">178     computeBorderAndPadding(formattingRoot, usedValues);</span>
<span class="line-removed">179     computeHorizontalMargin(formattingRoot, usedValues);</span>
<span class="line-removed">180 </span>
<span class="line-removed">181     IntrinsicWidthConstraints constraints;</span>
<span class="line-removed">182     if (auto fixedWidth = Geometry::fixedValue(formattingRoot.style().logicalWidth()))</span>
183         constraints = { *fixedWidth, *fixedWidth };
<span class="line-modified">184     else</span>
<span class="line-modified">185         constraints = layoutState.createFormattingContext(formattingRoot)-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-modified">186     constraints = Geometry::constrainByMinMaxWidth(formattingRoot, constraints);</span>
<span class="line-modified">187     constraints.expand(layoutState.displayBoxForLayoutBox(formattingRoot).horizontalMarginBorderAndPadding());</span>
188     formattingState().setIntrinsicWidthConstraintsForBox(formattingRoot, constraints);
189 }
190 
<span class="line-modified">191 void InlineFormattingContext::computeHorizontalMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const</span>
192 {
<span class="line-modified">193     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
<span class="line-modified">194     auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);</span>
195     displayBox.setHorizontalComputedMargin(computedHorizontalMargin);
196     displayBox.setHorizontalMargin({ computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) });
197 }
198 
<span class="line-modified">199 void InlineFormattingContext::computeWidthAndMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const</span>
200 {
<span class="line-modified">201     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified">202     WidthAndMargin widthAndMargin;</span>

203     if (layoutBox.isFloatingPositioned())
<span class="line-modified">204         widthAndMargin = Geometry::floatingWidthAndMargin(layoutState, layoutBox, usedValues);</span>
205     else if (layoutBox.isInlineBlockBox())
<span class="line-modified">206         widthAndMargin = Geometry::inlineBlockWidthAndMargin(layoutState, layoutBox, usedValues);</span>
207     else if (layoutBox.replaced())
<span class="line-modified">208         widthAndMargin = Geometry::inlineReplacedWidthAndMargin(layoutState, layoutBox, usedValues);</span>
209     else
210         ASSERT_NOT_REACHED();
211 
<span class="line-modified">212     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">213     displayBox.setContentBoxWidth(widthAndMargin.width);</span>
<span class="line-modified">214     displayBox.setHorizontalMargin(widthAndMargin.usedMargin);</span>
<span class="line-modified">215     displayBox.setHorizontalComputedMargin(widthAndMargin.computedMargin);</span>
216 }
217 
<span class="line-modified">218 void InlineFormattingContext::computeHeightAndMargin(const Box&amp; layoutBox) const</span>
219 {
<span class="line-modified">220     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified">221 </span>
<span class="line-modified">222     HeightAndMargin heightAndMargin;</span>
223     if (layoutBox.isFloatingPositioned())
<span class="line-modified">224         heightAndMargin = Geometry::floatingHeightAndMargin(layoutState, layoutBox, { }, UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() });</span>
225     else if (layoutBox.isInlineBlockBox())
<span class="line-modified">226         heightAndMargin = Geometry::inlineBlockHeightAndMargin(layoutState, layoutBox);</span>
227     else if (layoutBox.replaced())
<span class="line-modified">228         heightAndMargin = Geometry::inlineReplacedHeightAndMargin(layoutState, layoutBox, { });</span>
229     else
230         ASSERT_NOT_REACHED();
231 
<span class="line-modified">232     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">233     displayBox.setContentBoxHeight(heightAndMargin.height);</span>
<span class="line-modified">234     displayBox.setVerticalMargin({ heightAndMargin.nonCollapsedMargin, { } });</span>
<span class="line-removed">235 }</span>
<span class="line-removed">236 </span>
<span class="line-removed">237 void InlineFormattingContext::layoutFormattingContextRoot(const Box&amp; root, UsedHorizontalValues usedValues) const</span>
<span class="line-removed">238 {</span>
<span class="line-removed">239     ASSERT(root.isFloatingPositioned() || root.isInlineBlockBox());</span>
<span class="line-removed">240     ASSERT(usedValues.containingBlockWidth);</span>
<span class="line-removed">241 </span>
<span class="line-removed">242     computeBorderAndPadding(root, usedValues);</span>
<span class="line-removed">243     computeWidthAndMargin(root, usedValues);</span>
<span class="line-removed">244     // This is similar to static positioning in block formatting context. We just need to initialize the top left position.</span>
<span class="line-removed">245     layoutState().displayBoxForLayoutBox(root).setTopLeft({ 0, 0 });</span>
<span class="line-removed">246     // Swich over to the new formatting context (the one that the root creates).</span>
<span class="line-removed">247     auto formattingContext = layoutState().createFormattingContext(root);</span>
<span class="line-removed">248     formattingContext-&gt;layout();</span>
<span class="line-removed">249     // Come back and finalize the root&#39;s height and margin.</span>
<span class="line-removed">250     computeHeightAndMargin(root);</span>
<span class="line-removed">251     // Now that we computed the root&#39;s height, we can go back and layout the out-of-flow content.</span>
<span class="line-removed">252     formattingContext-&gt;layoutOutOfFlowContent();</span>
253 }
254 
<span class="line-modified">255 void InlineFormattingContext::computeWidthAndHeightForReplacedInlineBox(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const</span>
256 {
<span class="line-modified">257     ASSERT(!layoutBox.isContainer());</span>
<span class="line-modified">258     ASSERT(!layoutBox.establishesFormattingContext());</span>
<span class="line-modified">259     ASSERT(layoutBox.replaced());</span>
<span class="line-removed">260     ASSERT(usedValues.containingBlockWidth);</span>
<span class="line-removed">261 </span>
<span class="line-removed">262     computeBorderAndPadding(layoutBox, usedValues);</span>
<span class="line-removed">263     computeWidthAndMargin(layoutBox, usedValues);</span>
<span class="line-removed">264     computeHeightAndMargin(layoutBox);</span>
<span class="line-removed">265 }</span>
<span class="line-removed">266 </span>
<span class="line-removed">267 void InlineFormattingContext::collectInlineContent() const</span>
<span class="line-removed">268 {</span>
<span class="line-removed">269     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());</span>
270     // Traverse the tree and create inline items out of containers and leaf nodes. This essentially turns the tree inline structure into a flat one.
271     // &lt;span&gt;text&lt;span&gt;&lt;/span&gt;&lt;img&gt;&lt;/span&gt; -&gt; [ContainerStart][InlineBox][ContainerStart][ContainerEnd][InlineBox][ContainerEnd]
<span class="line-modified">272     auto&amp; formattingState = this-&gt;formattingState();</span>
273     LayoutQueue layoutQueue;
<span class="line-modified">274     layoutQueue.append(root.firstInFlowOrFloatingChild());</span>
275     while (!layoutQueue.isEmpty()) {
<span class="line-removed">276         auto treatAsInlineContainer = [](auto&amp; layoutBox) {</span>
<span class="line-removed">277             return is&lt;Container&gt;(layoutBox) &amp;&amp; !layoutBox.establishesFormattingContext();</span>
<span class="line-removed">278         };</span>
279         while (true) {
280             auto&amp; layoutBox = *layoutQueue.last();
<span class="line-modified">281             if (!treatAsInlineContainer(layoutBox))</span>

282                 break;
<span class="line-modified">283             // This is the start of an inline container (e.g. &lt;span&gt;).</span>
<span class="line-modified">284             formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::ContainerStart));</span>
<span class="line-modified">285             auto&amp; container = downcast&lt;Container&gt;(layoutBox);</span>
<span class="line-modified">286             if (!container.hasInFlowOrFloatingChild())</span>
287                 break;
<span class="line-modified">288             layoutQueue.append(container.firstInFlowOrFloatingChild());</span>
289         }
290 
291         while (!layoutQueue.isEmpty()) {
292             auto&amp; layoutBox = *layoutQueue.takeLast();
<span class="line-modified">293             // This is the end of an inline container (e.g. &lt;/span&gt;).</span>
<span class="line-modified">294             if (treatAsInlineContainer(layoutBox))</span>
<span class="line-removed">295                 formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::ContainerEnd));</span>
<span class="line-removed">296             else if (layoutBox.isLineBreakBox())</span>
<span class="line-removed">297                 formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::HardLineBreak));</span>
298             else if (layoutBox.isFloatingPositioned())
<span class="line-modified">299                 formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::Float));</span>
<span class="line-modified">300             else {</span>
<span class="line-modified">301                 ASSERT(layoutBox.isInlineLevelBox());</span>
<span class="line-modified">302                 if (layoutBox.hasTextContent())</span>
<span class="line-modified">303                     InlineTextItem::createAndAppendTextItems(formattingState.inlineItems(), layoutBox);</span>
<span class="line-modified">304                 else</span>
<span class="line-modified">305                     formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::Box));</span>
<span class="line-modified">306             }</span>


307 
308             if (auto* nextSibling = layoutBox.nextInFlowOrFloatingSibling()) {
309                 layoutQueue.append(nextSibling);
310                 break;
311             }
312         }
313     }
314 }
315 









































































































































































































316 }
317 }
318 
319 #endif
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
<span class="line-added"> 31 #include &quot;FloatingContext.h&quot;</span>
<span class="line-added"> 32 #include &quot;FontCascade.h&quot;</span>
 33 #include &quot;InlineFormattingState.h&quot;

 34 #include &quot;InlineTextItem.h&quot;
<span class="line-added"> 35 #include &quot;InvalidationState.h&quot;</span>
 36 #include &quot;LayoutBox.h&quot;
 37 #include &quot;LayoutContainer.h&quot;
<span class="line-added"> 38 #include &quot;LayoutContext.h&quot;</span>
 39 #include &quot;LayoutState.h&quot;
 40 #include &quot;Logging.h&quot;
<span class="line-modified"> 41 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="line-added"> 42 #include &quot;TextUtil.h&quot;</span>
 43 #include &lt;wtf/IsoMallocInlines.h&gt;
 44 #include &lt;wtf/text/TextStream.h&gt;
 45 
 46 namespace WebCore {
 47 namespace Layout {
 48 
 49 WTF_MAKE_ISO_ALLOCATED_IMPL(InlineFormattingContext);
 50 
<span class="line-modified"> 51 InlineFormattingContext::InlineFormattingContext(const Container&amp; formattingContextRoot, InlineFormattingState&amp; formattingState)</span>
 52     : FormattingContext(formattingContextRoot, formattingState)
 53 {
 54 }
 55 
<span class="line-modified"> 56 static inline const Box* nextInlineLevelBoxToLayout(const Box&amp; layoutBox, const Container&amp; stayWithin)</span>
 57 {
<span class="line-modified"> 58     // Atomic inline-level boxes and floats are opaque boxes meaning that they are</span>
<span class="line-modified"> 59     // responsible for their own content (do not need to descend into their subtrees).</span>
<span class="line-modified"> 60     // Only inline boxes may have relevant descendant content.</span>
<span class="line-added"> 61     if (layoutBox.isInlineBox()) {</span>
<span class="line-added"> 62         if (is&lt;Container&gt;(layoutBox) &amp;&amp; downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild()) {</span>
<span class="line-added"> 63             // Anonymous inline boxes/line breaks can&#39;t have descendant content by definition.</span>
<span class="line-added"> 64             ASSERT(!layoutBox.isAnonymous() &amp;&amp; !layoutBox.isLineBreakBox());</span>
<span class="line-added"> 65             return downcast&lt;Container&gt;(layoutBox).firstInFlowOrFloatingChild();</span>
<span class="line-added"> 66         }</span>
<span class="line-added"> 67     }</span>
 68 
<span class="line-modified"> 69     for (auto* nextInPreOrder = &amp;layoutBox; nextInPreOrder &amp;&amp; nextInPreOrder != &amp;stayWithin; nextInPreOrder = nextInPreOrder-&gt;parent()) {</span>
 70         if (auto* nextSibling = nextInPreOrder-&gt;nextInFlowOrFloatingSibling())
 71             return nextSibling;
 72     }
 73     return nullptr;
 74 }
 75 
<span class="line-modified"> 76 void InlineFormattingContext::layoutInFlowContent(InvalidationState&amp; invalidationState, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints)</span>
 77 {
<span class="line-modified"> 78     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Start] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root() &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified"> 79     ASSERT(root().hasInFlowOrFloatingChild());</span>




 80 
<span class="line-modified"> 81     invalidateFormattingState(invalidationState);</span>
<span class="line-modified"> 82     auto* layoutBox = root().firstInFlowOrFloatingChild();</span>
<span class="line-modified"> 83     // 1. Visit each inline box and partially compute their geometry (margins, paddings and borders).</span>
<span class="line-modified"> 84     // 2. Collect the inline items (flatten the the layout tree) and place them on lines in bidirectional order.</span>

 85     while (layoutBox) {
<span class="line-modified"> 86         ASSERT(layoutBox-&gt;isInlineLevelBox());</span>
<span class="line-modified"> 87 </span>
<span class="line-modified"> 88         if (layoutBox-&gt;isAtomicInlineLevelBox()) {</span>
<span class="line-modified"> 89             // Inline-blocks, inline-tables and replaced elements (img, video) can be sized but not yet positioned.</span>
<span class="line-modified"> 90             computeBorderAndPadding(*layoutBox, horizontalConstraints);</span>
<span class="line-modified"> 91             computeWidthAndMargin(*layoutBox, horizontalConstraints);</span>
<span class="line-modified"> 92             auto createsFormattingContext = layoutBox-&gt;isInlineBlockBox() || layoutBox-&gt;isInlineTableBox();</span>
<span class="line-modified"> 93             auto hasInFlowOrFloatingChild = is&lt;Container&gt;(*layoutBox) &amp;&amp; downcast&lt;Container&gt;(*layoutBox).hasInFlowOrFloatingChild();</span>
<span class="line-modified"> 94             if (createsFormattingContext &amp;&amp; hasInFlowOrFloatingChild) {</span>
<span class="line-modified"> 95                 auto formattingContext = LayoutContext::createFormattingContext(downcast&lt;Container&gt;(*layoutBox), layoutState());</span>
<span class="line-modified"> 96                 formattingContext-&gt;layoutInFlowContent(invalidationState, horizontalConstraints, verticalConstraints);</span>
<span class="line-added"> 97             }</span>
<span class="line-added"> 98             computeHeightAndMargin(*layoutBox, horizontalConstraints);</span>
<span class="line-added"> 99             if (createsFormattingContext &amp;&amp; is&lt;Container&gt;(*layoutBox) &amp;&amp; downcast&lt;Container&gt;(*layoutBox).hasChild()) {</span>
<span class="line-added">100                 auto&amp; displayBox = geometryForBox(*layoutBox);</span>
<span class="line-added">101                 auto horizontalConstraintsForOutOfFlow = Geometry::horizontalConstraintsForOutOfFlow(displayBox);</span>
<span class="line-added">102                 auto verticalConstraintsForOutOfFlow = Geometry::verticalConstraintsForOutOfFlow(displayBox);</span>
<span class="line-added">103                 auto formattingContext = LayoutContext::createFormattingContext(downcast&lt;Container&gt;(*layoutBox), layoutState());</span>
<span class="line-added">104                 formattingContext-&gt;layoutOutOfFlowContent(invalidationState, horizontalConstraintsForOutOfFlow, verticalConstraintsForOutOfFlow);</span>
<span class="line-added">105             }</span>
<span class="line-added">106         } else if (layoutBox-&gt;isInlineBox()) {</span>
<span class="line-added">107             if (layoutBox-&gt;isAnonymous() || layoutBox-&gt;isLineBreakBox()) {</span>
<span class="line-added">108                 // Text wrapper boxes are anonymous inline level boxes. Their computed border/padding/margins are 0.</span>
<span class="line-added">109                 auto&amp; displayBox = formattingState().displayBox(*layoutBox);</span>
<span class="line-added">110                 displayBox.setVerticalMargin({ { }, { } });</span>
<span class="line-added">111                 displayBox.setHorizontalMargin({ });</span>
<span class="line-added">112                 displayBox.setBorder({ { }, { } });</span>
<span class="line-added">113                 displayBox.setPadding({ });</span>
<span class="line-added">114             } else {</span>
<span class="line-added">115                 // Inline boxes (&lt;span&gt;) can&#39;t get sized/positioned yet. At this point we can only compute their margins, borders and paddings.</span>
<span class="line-added">116                 computeBorderAndPadding(*layoutBox, horizontalConstraints);</span>
<span class="line-added">117                 computeHorizontalMargin(*layoutBox, horizontalConstraints);</span>
<span class="line-added">118                 formattingState().displayBox(*layoutBox).setVerticalMargin({ { }, { } });</span>
<span class="line-added">119             }</span>
<span class="line-added">120         } else</span>
<span class="line-added">121             ASSERT_NOT_REACHED();</span>
<span class="line-added">122 </span>
<span class="line-added">123         layoutBox = nextInlineLevelBoxToLayout(*layoutBox, root());</span>
124     }
125 
<span class="line-modified">126     collectInlineContentIfNeeded();</span>


127 
<span class="line-modified">128     auto&amp; inlineItems = formattingState().inlineItems();</span>
<span class="line-modified">129     lineLayout(inlineItems, { 0, inlineItems.size() }, horizontalConstraints, verticalConstraints);</span>
<span class="line-modified">130     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[End] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root() &lt;&lt; &quot;)&quot;);</span>
131 }
132 
<span class="line-modified">133 void InlineFormattingContext::lineLayout(InlineItems&amp; inlineItems, LineLayoutContext::InlineItemRange layoutRange, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints)</span>
<span class="line-added">134 {</span>
<span class="line-added">135     auto lineLogicalTop = verticalConstraints.logicalTop;</span>
<span class="line-added">136     Optional&lt;unsigned&gt; partialLeadingContentLength;</span>
<span class="line-added">137     auto lineBuilder = LineBuilder { *this, root().style().textAlign(), LineBuilder::IntrinsicSizing::No };</span>
<span class="line-added">138     auto lineLayoutContext = LineLayoutContext { *this, root(), inlineItems };</span>
<span class="line-added">139 </span>
<span class="line-added">140     while (!layoutRange.isEmpty()) {</span>
<span class="line-added">141         lineBuilder.initialize(constraintsForLine(horizontalConstraints, lineLogicalTop));</span>
<span class="line-added">142         auto lineContent = lineLayoutContext.layoutLine(lineBuilder, layoutRange, partialLeadingContentLength);</span>
<span class="line-added">143         setDisplayBoxesForLine(lineContent, horizontalConstraints);</span>
<span class="line-added">144 </span>
<span class="line-added">145         partialLeadingContentLength = { };</span>
<span class="line-added">146         if (lineContent.trailingInlineItemIndex) {</span>
<span class="line-added">147             lineLogicalTop = lineContent.lineBox.logicalBottom();</span>
<span class="line-added">148             // When the trailing content is partial, we need to reuse the last InlinItem.</span>
<span class="line-added">149             if (lineContent.partialContent) {</span>
<span class="line-added">150                 layoutRange.start = *lineContent.trailingInlineItemIndex;</span>
<span class="line-added">151                 // Turn previous line&#39;s overflow content length into the next line&#39;s leading content partial length.</span>
<span class="line-added">152                 // &quot;sp&lt;-&gt;litcontent&quot; -&gt; overflow length: 10 -&gt; leading partial content length: 10.</span>
<span class="line-added">153                 partialLeadingContentLength = lineContent.partialContent-&gt;overflowContentLength;</span>
<span class="line-added">154             } else</span>
<span class="line-added">155                 layoutRange.start = *lineContent.trailingInlineItemIndex + 1;</span>
<span class="line-added">156             continue;</span>
<span class="line-added">157         }</span>
<span class="line-added">158         // Floats prevented us placing any content on the line.</span>
<span class="line-added">159         ASSERT(lineBuilder.hasIntrusiveFloat());</span>
<span class="line-added">160         // Move the next line below the intrusive float.</span>
<span class="line-added">161         auto floatingContext = FloatingContext { root(), *this, formattingState().floatingState() };</span>
<span class="line-added">162         auto floatConstraints = floatingContext.constraints(lineLogicalTop, toLayoutUnit(lineContent.lineBox.logicalBottom()) );</span>
<span class="line-added">163         ASSERT(floatConstraints.left || floatConstraints.right);</span>
<span class="line-added">164         static auto inifitePoint = PointInContextRoot::max();</span>
<span class="line-added">165         // In case of left and right constraints, we need to pick the one that&#39;s closer to the current line.</span>
<span class="line-added">166         lineLogicalTop = std::min(floatConstraints.left.valueOr(inifitePoint).y, floatConstraints.right.valueOr(inifitePoint).y);</span>
<span class="line-added">167         ASSERT(lineLogicalTop &lt; inifitePoint.y);</span>
<span class="line-added">168     }</span>
<span class="line-added">169 }</span>
<span class="line-added">170 </span>
<span class="line-added">171 FormattingContext::IntrinsicWidthConstraints InlineFormattingContext::computedIntrinsicWidthConstraints()</span>
172 {
173     auto&amp; layoutState = this-&gt;layoutState();
174     ASSERT(!formattingState().intrinsicWidthConstraints());
175 
<span class="line-modified">176     if (!root().hasInFlowOrFloatingChild()) {</span>
<span class="line-modified">177         auto constraints = geometry().constrainByMinMaxWidth(root(), { });</span>
178         formattingState().setIntrinsicWidthConstraints(constraints);
179         return constraints;
180     }
181 

182     Vector&lt;const Box*&gt; formattingContextRootList;
<span class="line-modified">183     auto horizontalConstraints = HorizontalConstraints { 0_lu, 0_lu };</span>
<span class="line-modified">184     auto* layoutBox = root().firstInFlowOrFloatingChild();</span>
<span class="line-added">185     // In order to compute the max/min widths, we need to compute margins, borders and paddings for certain inline boxes first.</span>
186     while (layoutBox) {
<span class="line-modified">187         if (layoutBox-&gt;isAnonymous()) {</span>
<span class="line-added">188             layoutBox = nextInlineLevelBoxToLayout(*layoutBox, root());</span>
<span class="line-added">189             continue;</span>
<span class="line-added">190         }</span>
<span class="line-added">191         if (layoutBox-&gt;isReplaced()) {</span>
<span class="line-added">192             computeBorderAndPadding(*layoutBox, horizontalConstraints);</span>
<span class="line-added">193             computeWidthAndMargin(*layoutBox, horizontalConstraints);</span>
<span class="line-added">194         } else if (layoutBox-&gt;isFloatingPositioned() || layoutBox-&gt;isAtomicInlineLevelBox()) {</span>
<span class="line-added">195             ASSERT(layoutBox-&gt;establishesFormattingContext());</span>
196             formattingContextRootList.append(layoutBox);
<span class="line-added">197 </span>
<span class="line-added">198             computeBorderAndPadding(*layoutBox, horizontalConstraints);</span>
<span class="line-added">199             computeHorizontalMargin(*layoutBox, horizontalConstraints);</span>
200             computeIntrinsicWidthForFormattingRoot(*layoutBox);
<span class="line-modified">201         } else if (layoutBox-&gt;isInlineBox()) {</span>
<span class="line-modified">202             computeBorderAndPadding(*layoutBox, horizontalConstraints);</span>
<span class="line-modified">203             computeHorizontalMargin(*layoutBox, horizontalConstraints);</span>
<span class="line-modified">204         } else</span>
<span class="line-modified">205             ASSERT_NOT_REACHED();</span>
<span class="line-modified">206         layoutBox = nextInlineLevelBoxToLayout(*layoutBox, root());</span>






207     }
208 
<span class="line-modified">209     collectInlineContentIfNeeded();</span>
210 
211     auto maximumLineWidth = [&amp;](auto availableWidth) {
212         // Switch to the min/max formatting root width values before formatting the lines.
213         for (auto* formattingRoot : formattingContextRootList) {
214             auto intrinsicWidths = layoutState.formattingStateForBox(*formattingRoot).intrinsicWidthConstraintsForBox(*formattingRoot);
<span class="line-modified">215             auto&amp; displayBox = formattingState().displayBox(*formattingRoot);</span>
216             auto contentWidth = (availableWidth ? intrinsicWidths-&gt;maximum : intrinsicWidths-&gt;minimum) - displayBox.horizontalMarginBorderAndPadding();
217             displayBox.setContentBoxWidth(contentWidth);
218         }
<span class="line-modified">219         return computedIntrinsicWidthForConstraint({ 0_lu, toLayoutUnit(availableWidth) });</span>
220     };
221 
<span class="line-modified">222     auto constraints = geometry().constrainByMinMaxWidth(root(), { toLayoutUnit(maximumLineWidth(0)), toLayoutUnit(maximumLineWidth(maxInlineLayoutUnit())) });</span>
223     formattingState().setIntrinsicWidthConstraints(constraints);
224     return constraints;
225 }
226 
<span class="line-modified">227 InlineLayoutUnit InlineFormattingContext::computedIntrinsicWidthForConstraint(const HorizontalConstraints&amp; horizontalConstraints) const</span>
228 {
<span class="line-modified">229     auto&amp; inlineItems = formattingState().inlineItems();</span>
<span class="line-modified">230     auto maximumLineWidth = InlineLayoutUnit { };</span>
<span class="line-modified">231     auto lineBuilder = LineBuilder { *this, root().style().textAlign(), LineBuilder::IntrinsicSizing::Yes };</span>
<span class="line-modified">232     auto lineLayoutContext = LineLayoutContext { *this, root(), inlineItems };</span>
<span class="line-modified">233     auto layoutRange = LineLayoutContext::InlineItemRange { 0 , inlineItems.size() };</span>
<span class="line-modified">234     while (!layoutRange.isEmpty()) {</span>
<span class="line-modified">235         // Only the horiztonal available width is constrained when computing intrinsic width.</span>
<span class="line-modified">236         lineBuilder.initialize(LineBuilder::Constraints { { }, horizontalConstraints.logicalWidth, false, { } });</span>
<span class="line-modified">237         auto lineContent = lineLayoutContext.layoutLine(lineBuilder, layoutRange , { });</span>
<span class="line-modified">238 </span>
<span class="line-modified">239         layoutRange.start = *lineContent.trailingInlineItemIndex + 1;</span>
<span class="line-modified">240         InlineLayoutUnit floatsWidth = 0;</span>
<span class="line-modified">241         for (auto&amp; floatItem : lineContent.floats)</span>
<span class="line-modified">242             floatsWidth += geometryForBox(floatItem-&gt;layoutBox()).marginBoxWidth();</span>
<span class="line-modified">243         maximumLineWidth = std::max(maximumLineWidth, floatsWidth + lineContent.lineBox.logicalWidth());</span>
<span class="line-added">244     }</span>
<span class="line-added">245     return maximumLineWidth;</span>
246 }
247 
<span class="line-modified">248 void InlineFormattingContext::computeIntrinsicWidthForFormattingRoot(const Box&amp; formattingRoot)</span>
249 {
250     ASSERT(formattingRoot.establishesFormattingContext());
<span class="line-modified">251     auto constraints = IntrinsicWidthConstraints { };</span>
<span class="line-modified">252     if (auto fixedWidth = geometry().fixedValue(formattingRoot.style().logicalWidth()))</span>






253         constraints = { *fixedWidth, *fixedWidth };
<span class="line-modified">254     else if (is&lt;Container&gt;(formattingRoot) &amp;&amp; downcast&lt;Container&gt;(formattingRoot).hasInFlowOrFloatingChild())</span>
<span class="line-modified">255         constraints = LayoutContext::createFormattingContext(downcast&lt;Container&gt;(formattingRoot), layoutState())-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-modified">256     constraints = geometry().constrainByMinMaxWidth(formattingRoot, constraints);</span>
<span class="line-modified">257     constraints.expand(geometryForBox(formattingRoot).horizontalMarginBorderAndPadding());</span>
258     formattingState().setIntrinsicWidthConstraintsForBox(formattingRoot, constraints);
259 }
260 
<span class="line-modified">261 void InlineFormattingContext::computeHorizontalMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints)</span>
262 {
<span class="line-modified">263     auto computedHorizontalMargin = geometry().computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
<span class="line-modified">264     auto&amp; displayBox = formattingState().displayBox(layoutBox);</span>
265     displayBox.setHorizontalComputedMargin(computedHorizontalMargin);
266     displayBox.setHorizontalMargin({ computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) });
267 }
268 
<span class="line-modified">269 void InlineFormattingContext::computeWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints)</span>
270 {
<span class="line-modified">271     ContentWidthAndMargin contentWidthAndMargin;</span>
<span class="line-modified">272     // FIXME: Add support for min/max-width.</span>
<span class="line-added">273     auto usedWidth = OverrideHorizontalValues { };</span>
274     if (layoutBox.isFloatingPositioned())
<span class="line-modified">275         contentWidthAndMargin = geometry().floatingWidthAndMargin(layoutBox, horizontalConstraints, usedWidth);</span>
276     else if (layoutBox.isInlineBlockBox())
<span class="line-modified">277         contentWidthAndMargin = geometry().inlineBlockWidthAndMargin(layoutBox, horizontalConstraints, usedWidth);</span>
278     else if (layoutBox.replaced())
<span class="line-modified">279         contentWidthAndMargin = geometry().inlineReplacedWidthAndMargin(layoutBox, horizontalConstraints, usedWidth);</span>
280     else
281         ASSERT_NOT_REACHED();
282 
<span class="line-modified">283     auto&amp; displayBox = formattingState().displayBox(layoutBox);</span>
<span class="line-modified">284     displayBox.setContentBoxWidth(contentWidthAndMargin.contentWidth);</span>
<span class="line-modified">285     displayBox.setHorizontalMargin(contentWidthAndMargin.usedMargin);</span>
<span class="line-modified">286     displayBox.setHorizontalComputedMargin(contentWidthAndMargin.computedMargin);</span>
287 }
288 
<span class="line-modified">289 void InlineFormattingContext::computeHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints)</span>
290 {
<span class="line-modified">291     ContentHeightAndMargin contentHeightAndMargin;</span>
<span class="line-modified">292     // FIXME: Add min/max-height support.</span>
<span class="line-modified">293     auto usedHeight = OverrideVerticalValues { };</span>
294     if (layoutBox.isFloatingPositioned())
<span class="line-modified">295         contentHeightAndMargin = geometry().floatingHeightAndMargin(layoutBox, horizontalConstraints, usedHeight);</span>
296     else if (layoutBox.isInlineBlockBox())
<span class="line-modified">297         contentHeightAndMargin = geometry().inlineBlockHeightAndMargin(layoutBox, horizontalConstraints, usedHeight);</span>
298     else if (layoutBox.replaced())
<span class="line-modified">299         contentHeightAndMargin = geometry().inlineReplacedHeightAndMargin(layoutBox, horizontalConstraints, { }, usedHeight);</span>
300     else
301         ASSERT_NOT_REACHED();
302 
<span class="line-modified">303     auto&amp; displayBox = formattingState().displayBox(layoutBox);</span>
<span class="line-modified">304     displayBox.setContentBoxHeight(contentHeightAndMargin.contentHeight);</span>
<span class="line-modified">305     displayBox.setVerticalMargin({ contentHeightAndMargin.nonCollapsedMargin, { } });</span>


















306 }
307 
<span class="line-modified">308 void InlineFormattingContext::collectInlineContentIfNeeded()</span>
309 {
<span class="line-modified">310     auto&amp; formattingState = this-&gt;formattingState();</span>
<span class="line-modified">311     if (!formattingState.inlineItems().isEmpty())</span>
<span class="line-modified">312         return;</span>










313     // Traverse the tree and create inline items out of containers and leaf nodes. This essentially turns the tree inline structure into a flat one.
314     // &lt;span&gt;text&lt;span&gt;&lt;/span&gt;&lt;img&gt;&lt;/span&gt; -&gt; [ContainerStart][InlineBox][ContainerStart][ContainerEnd][InlineBox][ContainerEnd]
<span class="line-modified">315     ASSERT(root().hasInFlowOrFloatingChild());</span>
316     LayoutQueue layoutQueue;
<span class="line-modified">317     layoutQueue.append(root().firstInFlowOrFloatingChild());</span>
318     while (!layoutQueue.isEmpty()) {



319         while (true) {
320             auto&amp; layoutBox = *layoutQueue.last();
<span class="line-modified">321             auto isBoxWithInlineContent = layoutBox.isInlineBox() &amp;&amp; !layoutBox.isAnonymous() &amp;&amp; !layoutBox.isLineBreakBox();</span>
<span class="line-added">322             if (!isBoxWithInlineContent)</span>
323                 break;
<span class="line-modified">324             // This is the start of an inline box (e.g. &lt;span&gt;).</span>
<span class="line-modified">325             formattingState.addInlineItem({ layoutBox, InlineItem::Type::ContainerStart });</span>
<span class="line-modified">326             auto&amp; inlineBoxWithInlineContent = downcast&lt;Container&gt;(layoutBox);</span>
<span class="line-modified">327             if (!inlineBoxWithInlineContent.hasInFlowOrFloatingChild())</span>
328                 break;
<span class="line-modified">329             layoutQueue.append(inlineBoxWithInlineContent.firstInFlowOrFloatingChild());</span>
330         }
331 
332         while (!layoutQueue.isEmpty()) {
333             auto&amp; layoutBox = *layoutQueue.takeLast();
<span class="line-modified">334             if (layoutBox.isLineBreakBox())</span>
<span class="line-modified">335                 formattingState.addInlineItem({ layoutBox, InlineItem::Type::HardLineBreak });</span>



336             else if (layoutBox.isFloatingPositioned())
<span class="line-modified">337                 formattingState.addInlineItem({ layoutBox, InlineItem::Type::Float });</span>
<span class="line-modified">338             else if (layoutBox.isAtomicInlineLevelBox())</span>
<span class="line-modified">339                 formattingState.addInlineItem({ layoutBox, InlineItem::Type::Box });</span>
<span class="line-modified">340             else if (layoutBox.isAnonymous()) {</span>
<span class="line-modified">341                 ASSERT(layoutBox.hasTextContent());</span>
<span class="line-modified">342                 InlineTextItem::createAndAppendTextItems(formattingState.inlineItems(), layoutBox);</span>
<span class="line-modified">343             } else if (layoutBox.isInlineBox())</span>
<span class="line-modified">344                 formattingState.addInlineItem({ layoutBox, InlineItem::Type::ContainerEnd });</span>
<span class="line-added">345             else</span>
<span class="line-added">346                 ASSERT_NOT_REACHED();</span>
347 
348             if (auto* nextSibling = layoutBox.nextInFlowOrFloatingSibling()) {
349                 layoutQueue.append(nextSibling);
350                 break;
351             }
352         }
353     }
354 }
355 
<span class="line-added">356 LineBuilder::Constraints InlineFormattingContext::constraintsForLine(const HorizontalConstraints&amp; horizontalConstraints, InlineLayoutUnit lineLogicalTop)</span>
<span class="line-added">357 {</span>
<span class="line-added">358     auto lineLogicalLeft = horizontalConstraints.logicalLeft;</span>
<span class="line-added">359     auto lineLogicalRight = lineLogicalLeft + horizontalConstraints.logicalWidth;</span>
<span class="line-added">360     auto lineHeightAndBaseline = quirks().lineHeightConstraints(root());</span>
<span class="line-added">361     auto lineIsConstrainedByFloat = false;</span>
<span class="line-added">362 </span>
<span class="line-added">363     auto floatingContext = FloatingContext { root(), *this, formattingState().floatingState() };</span>
<span class="line-added">364     // Check for intruding floats and adjust logical left/available width for this line accordingly.</span>
<span class="line-added">365     if (!floatingContext.isEmpty()) {</span>
<span class="line-added">366         // FIXME: Add support for variable line height, where the intrusive floats should be probed as the line height grows.</span>
<span class="line-added">367         auto floatConstraints = floatingContext.constraints(toLayoutUnit(lineLogicalTop), toLayoutUnit(lineLogicalTop + lineHeightAndBaseline.height));</span>
<span class="line-added">368         // Check if these constraints actually put limitation on the line.</span>
<span class="line-added">369         if (floatConstraints.left &amp;&amp; floatConstraints.left-&gt;x &lt;= lineLogicalLeft)</span>
<span class="line-added">370             floatConstraints.left = { };</span>
<span class="line-added">371 </span>
<span class="line-added">372         if (floatConstraints.right &amp;&amp; floatConstraints.right-&gt;x &gt;= lineLogicalRight)</span>
<span class="line-added">373             floatConstraints.right = { };</span>
<span class="line-added">374 </span>
<span class="line-added">375         lineIsConstrainedByFloat = floatConstraints.left || floatConstraints.right;</span>
<span class="line-added">376 </span>
<span class="line-added">377         if (floatConstraints.left &amp;&amp; floatConstraints.right) {</span>
<span class="line-added">378             ASSERT(floatConstraints.left-&gt;x &lt;= floatConstraints.right-&gt;x);</span>
<span class="line-added">379             lineLogicalRight = floatConstraints.right-&gt;x;</span>
<span class="line-added">380             lineLogicalLeft = floatConstraints.left-&gt;x;</span>
<span class="line-added">381         } else if (floatConstraints.left) {</span>
<span class="line-added">382             ASSERT(floatConstraints.left-&gt;x &gt;= lineLogicalLeft);</span>
<span class="line-added">383             lineLogicalLeft = floatConstraints.left-&gt;x;</span>
<span class="line-added">384         } else if (floatConstraints.right) {</span>
<span class="line-added">385             ASSERT(floatConstraints.right-&gt;x &gt;= lineLogicalLeft);</span>
<span class="line-added">386             lineLogicalRight = floatConstraints.right-&gt;x;</span>
<span class="line-added">387         }</span>
<span class="line-added">388     }</span>
<span class="line-added">389 </span>
<span class="line-added">390     auto computedTextIndent = [&amp;] {</span>
<span class="line-added">391         // text-indent property specifies the indentation applied to lines of inline content in a block.</span>
<span class="line-added">392         // The indent is treated as a margin applied to the start edge of the line box.</span>
<span class="line-added">393         // Unless otherwise specified, only lines that are the first formatted line of an element are affected.</span>
<span class="line-added">394         // For example, the first line of an anonymous block box is only affected if it is the first child of its parent element.</span>
<span class="line-added">395         // FIXME: Add support for each-line.</span>
<span class="line-added">396         // [Integration] root()-&gt;parent() would normally produce a valid layout box.</span>
<span class="line-added">397         auto&amp; root = this-&gt;root();</span>
<span class="line-added">398         auto isFormattingContextRootCandidateToTextIndent = !root.isAnonymous();</span>
<span class="line-added">399         if (root.isAnonymous()) {</span>
<span class="line-added">400             // Unless otherwise specified by the each-line and/or hanging keywords, only lines that are the first formatted line</span>
<span class="line-added">401             // of an element are affected.</span>
<span class="line-added">402             // For example, the first line of an anonymous block box is only affected if it is the first child of its parent element.</span>
<span class="line-added">403             isFormattingContextRootCandidateToTextIndent = RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()</span>
<span class="line-added">404                 ? layoutState().isIntegratedRootBoxFirstChild()</span>
<span class="line-added">405                 : root.parent()-&gt;firstInFlowChild() == &amp;root;</span>
<span class="line-added">406         }</span>
<span class="line-added">407         if (!isFormattingContextRootCandidateToTextIndent)</span>
<span class="line-added">408             return InlineLayoutUnit { };</span>
<span class="line-added">409         auto invertLineRange = false;</span>
<span class="line-added">410 #if ENABLE(CSS3_TEXT)</span>
<span class="line-added">411         invertLineRange = root.style().textIndentType() == TextIndentType::Hanging;</span>
<span class="line-added">412 #endif</span>
<span class="line-added">413         auto isFirstLine = formattingState().ensureDisplayInlineContent().lineBoxes.isEmpty();</span>
<span class="line-added">414         // text-indent: hanging inverts which lines are affected.</span>
<span class="line-added">415         // inverted line range -&gt; all the lines except the first one.</span>
<span class="line-added">416         // !inverted line range -&gt; first line gets the indent.</span>
<span class="line-added">417         auto shouldIndent = invertLineRange != isFirstLine;</span>
<span class="line-added">418         if (!shouldIndent)</span>
<span class="line-added">419             return InlineLayoutUnit { };</span>
<span class="line-added">420         return geometry().computedTextIndent(root, horizontalConstraints).valueOr(InlineLayoutUnit { });</span>
<span class="line-added">421     };</span>
<span class="line-added">422     lineLogicalLeft += computedTextIndent();</span>
<span class="line-added">423     return LineBuilder::Constraints { { lineLogicalLeft, lineLogicalTop }, lineLogicalRight - lineLogicalLeft, lineIsConstrainedByFloat, lineHeightAndBaseline };</span>
<span class="line-added">424 }</span>
<span class="line-added">425 </span>
<span class="line-added">426 void InlineFormattingContext::setDisplayBoxesForLine(const LineLayoutContext::LineContent&amp; lineContent, const HorizontalConstraints&amp; horizontalConstraints)</span>
<span class="line-added">427 {</span>
<span class="line-added">428     auto&amp; formattingState = this-&gt;formattingState();</span>
<span class="line-added">429     auto&amp; lineBox = lineContent.lineBox;</span>
<span class="line-added">430 </span>
<span class="line-added">431     if (!lineContent.floats.isEmpty()) {</span>
<span class="line-added">432         auto floatingContext = FloatingContext { root(), *this, formattingState.floatingState() };</span>
<span class="line-added">433         // Move floats to their final position.</span>
<span class="line-added">434         for (const auto&amp; floatItem : lineContent.floats) {</span>
<span class="line-added">435             auto&amp; floatBox = floatItem-&gt;layoutBox();</span>
<span class="line-added">436             auto&amp; displayBox = formattingState.displayBox(floatBox);</span>
<span class="line-added">437             // Set static position first.</span>
<span class="line-added">438             displayBox.setTopLeft({ lineBox.logicalLeft(), lineBox.logicalTop() });</span>
<span class="line-added">439             // Float it.</span>
<span class="line-added">440             displayBox.setTopLeft(floatingContext.positionForFloat(floatBox));</span>
<span class="line-added">441             floatingContext.append(floatBox);</span>
<span class="line-added">442         }</span>
<span class="line-added">443     }</span>
<span class="line-added">444 </span>
<span class="line-added">445     auto initialContaingBlockSize = LayoutSize { };</span>
<span class="line-added">446     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()) {</span>
<span class="line-added">447         // ICB is not the real ICB when lyoutFormattingContextIntegrationEnabled is on.</span>
<span class="line-added">448         initialContaingBlockSize = layoutState().viewportSize();</span>
<span class="line-added">449     } else</span>
<span class="line-added">450         initialContaingBlockSize = geometryForBox(root().initialContainingBlock(), EscapeReason::StrokeOverflowNeedsViewportGeometry).contentBox().size();</span>
<span class="line-added">451     auto&amp; inlineContent = formattingState.ensureDisplayInlineContent();</span>
<span class="line-added">452     auto lineIndex = inlineContent.lineBoxes.size();</span>
<span class="line-added">453     auto lineInkOverflow = lineBox.scrollableOverflow();</span>
<span class="line-added">454     Optional&lt;unsigned&gt; lastTextItemIndex;</span>
<span class="line-added">455     // Compute box final geometry.</span>
<span class="line-added">456     auto&amp; lineRuns = lineContent.runList;</span>
<span class="line-added">457     for (unsigned index = 0; index &lt; lineRuns.size(); ++index) {</span>
<span class="line-added">458         auto&amp; lineRun = lineRuns.at(index);</span>
<span class="line-added">459         auto&amp; logicalRect = lineRun.logicalRect();</span>
<span class="line-added">460         auto&amp; layoutBox = lineRun.layoutBox();</span>
<span class="line-added">461         auto&amp; displayBox = formattingState.displayBox(layoutBox);</span>
<span class="line-added">462 </span>
<span class="line-added">463         // Add final display runs to state first.</span>
<span class="line-added">464         // Inline level containers (&lt;span&gt;) don&#39;t generate display runs and neither do completely collapsed runs.</span>
<span class="line-added">465         auto initiatesInlineRun = !lineRun.isContainerStart() &amp;&amp; !lineRun.isContainerEnd();</span>
<span class="line-added">466         if (initiatesInlineRun) {</span>
<span class="line-added">467             auto computedInkOverflow = [&amp;] {</span>
<span class="line-added">468                 // FIXME: Add support for non-text ink overflow.</span>
<span class="line-added">469                 if (!lineRun.isText())</span>
<span class="line-added">470                     return logicalRect;</span>
<span class="line-added">471                 auto&amp; style = lineRun.style();</span>
<span class="line-added">472                 auto inkOverflow = logicalRect;</span>
<span class="line-added">473                 auto strokeOverflow = std::ceil(style.computedStrokeWidth(ceiledIntSize(initialContaingBlockSize)));</span>
<span class="line-added">474                 inkOverflow.inflate(strokeOverflow);</span>
<span class="line-added">475 </span>
<span class="line-added">476                 auto letterSpacing = style.fontCascade().letterSpacing();</span>
<span class="line-added">477                 if (letterSpacing &lt; 0) {</span>
<span class="line-added">478                     // Last letter&#39;s negative spacing shrinks logical rect. Push it to ink overflow.</span>
<span class="line-added">479                     inkOverflow.expandHorizontally(-letterSpacing);</span>
<span class="line-added">480                 }</span>
<span class="line-added">481                 return inkOverflow;</span>
<span class="line-added">482             };</span>
<span class="line-added">483             auto inkOverflow = computedInkOverflow();</span>
<span class="line-added">484             lineInkOverflow.expandToContain(inkOverflow);</span>
<span class="line-added">485             inlineContent.runs.append({ lineIndex, lineRun.layoutBox(), logicalRect, inkOverflow, lineRun.textContext() });</span>
<span class="line-added">486         }</span>
<span class="line-added">487 </span>
<span class="line-added">488         if (lineRun.isLineBreak()) {</span>
<span class="line-added">489             displayBox.setTopLeft(toLayoutPoint(logicalRect.topLeft()));</span>
<span class="line-added">490             displayBox.setContentBoxWidth(toLayoutUnit(logicalRect.width()));</span>
<span class="line-added">491             displayBox.setContentBoxHeight(toLayoutUnit(logicalRect.height()));</span>
<span class="line-added">492             continue;</span>
<span class="line-added">493         }</span>
<span class="line-added">494 </span>
<span class="line-added">495         // Inline level box (replaced or inline-block)</span>
<span class="line-added">496         if (lineRun.isBox()) {</span>
<span class="line-added">497             auto topLeft = logicalRect.topLeft();</span>
<span class="line-added">498             if (layoutBox.isInFlowPositioned())</span>
<span class="line-added">499                 topLeft += geometry().inFlowPositionedPositionOffset(layoutBox, horizontalConstraints);</span>
<span class="line-added">500             displayBox.setTopLeft(toLayoutPoint(topLeft));</span>
<span class="line-added">501             continue;</span>
<span class="line-added">502         }</span>
<span class="line-added">503 </span>
<span class="line-added">504         // Inline level container start (&lt;span&gt;)</span>
<span class="line-added">505         if (lineRun.isContainerStart()) {</span>
<span class="line-added">506             displayBox.setTopLeft(toLayoutPoint(logicalRect.topLeft()));</span>
<span class="line-added">507             continue;</span>
<span class="line-added">508         }</span>
<span class="line-added">509 </span>
<span class="line-added">510         // Inline level container end (&lt;/span&gt;)</span>
<span class="line-added">511         if (lineRun.isContainerEnd()) {</span>
<span class="line-added">512             if (layoutBox.isInFlowPositioned()) {</span>
<span class="line-added">513                 auto inflowOffset = geometry().inFlowPositionedPositionOffset(layoutBox, horizontalConstraints);</span>
<span class="line-added">514                 displayBox.moveHorizontally(inflowOffset.width());</span>
<span class="line-added">515                 displayBox.moveVertically(inflowOffset.height());</span>
<span class="line-added">516             }</span>
<span class="line-added">517             auto marginBoxWidth = logicalRect.left() - displayBox.left();</span>
<span class="line-added">518             auto contentBoxWidth = marginBoxWidth - (displayBox.marginStart() + displayBox.borderLeft() + displayBox.paddingLeft().valueOr(0));</span>
<span class="line-added">519             // FIXME fix it for multiline.</span>
<span class="line-added">520             displayBox.setContentBoxWidth(toLayoutUnit(contentBoxWidth));</span>
<span class="line-added">521             displayBox.setContentBoxHeight(toLayoutUnit(logicalRect.height()));</span>
<span class="line-added">522             continue;</span>
<span class="line-added">523         }</span>
<span class="line-added">524 </span>
<span class="line-added">525         if (lineRun.isText()) {</span>
<span class="line-added">526             lastTextItemIndex = inlineContent.runs.size() - 1;</span>
<span class="line-added">527             auto firstRunForLayoutBox = !index || &amp;lineRuns[index - 1].layoutBox() != &amp;layoutBox;</span>
<span class="line-added">528             if (firstRunForLayoutBox) {</span>
<span class="line-added">529                 // Setup display box for the associated layout box.</span>
<span class="line-added">530                 displayBox.setTopLeft(toLayoutPoint(logicalRect.topLeft()));</span>
<span class="line-added">531                 displayBox.setContentBoxWidth(toLayoutUnit(logicalRect.width()));</span>
<span class="line-added">532                 displayBox.setContentBoxHeight(toLayoutUnit(logicalRect.height()));</span>
<span class="line-added">533             } else {</span>
<span class="line-added">534                 // FIXME fix it for multirun/multiline.</span>
<span class="line-added">535                 displayBox.setContentBoxWidth(toLayoutUnit(displayBox.contentBoxWidth() + logicalRect.width()));</span>
<span class="line-added">536             }</span>
<span class="line-added">537             continue;</span>
<span class="line-added">538         }</span>
<span class="line-added">539         ASSERT_NOT_REACHED();</span>
<span class="line-added">540     }</span>
<span class="line-added">541     // Make sure the trailing text run gets a hyphen when it needs one.</span>
<span class="line-added">542     if (lineContent.partialContent &amp;&amp; lineContent.partialContent-&gt;trailingContentNeedsHyphen)</span>
<span class="line-added">543         inlineContent.runs[*lastTextItemIndex].textContext()-&gt;setNeedsHyphen();</span>
<span class="line-added">544     // FIXME: This is where the logical to physical translate should happen.</span>
<span class="line-added">545     auto&amp; baseline = lineBox.baseline();</span>
<span class="line-added">546     inlineContent.lineBoxes.append({ lineBox.logicalRect(), lineBox.scrollableOverflow(), lineInkOverflow, { baseline.ascent(), baseline.descent() }, lineBox.baselineOffset(), lineBox.isConsideredEmpty() });</span>
<span class="line-added">547 }</span>
<span class="line-added">548 </span>
<span class="line-added">549 void InlineFormattingContext::invalidateFormattingState(const InvalidationState&amp;)</span>
<span class="line-added">550 {</span>
<span class="line-added">551     // Find out what we need to invalidate. This is where we add some smarts to do partial line layout.</span>
<span class="line-added">552     // For now let&#39;s just clear the runs.</span>
<span class="line-added">553     formattingState().clearDisplayInlineContent();</span>
<span class="line-added">554     // FIXME: This is also where we would delete inline items if their content changed.</span>
<span class="line-added">555 }</span>
<span class="line-added">556 </span>
557 }
558 }
559 
560 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../floats/FloatingState.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineFormattingContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
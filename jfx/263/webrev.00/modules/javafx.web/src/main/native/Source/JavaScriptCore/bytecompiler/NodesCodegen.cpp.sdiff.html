<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/NodesCodegen.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Label.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegisterID.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/NodesCodegen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  13 *  version 2 of the License, or (at your option) any later version.
  14 *
  15 *  This library is distributed in the hope that it will be useful,
  16 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  17 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18 *  Library General Public License for more details.
  19 *
  20 *  You should have received a copy of the GNU Library General Public License
  21 *  along with this library; see the file COPYING.LIB.  If not, write to
  22 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23 *  Boston, MA 02110-1301, USA.
  24 *
  25 */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Nodes.h&quot;
  29 #include &quot;NodeConstructors.h&quot;
  30 
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeGenerator.h&quot;

  33 #include &quot;CallFrame.h&quot;
  34 #include &quot;JIT.h&quot;


  35 #include &quot;JSCInlines.h&quot;
  36 #include &quot;JSFunction.h&quot;
<span class="line-modified">  37 #include &quot;JSGeneratorFunction.h&quot;</span>
  38 #include &quot;JSGlobalObject.h&quot;
  39 #include &quot;JSImmutableButterfly.h&quot;

  40 #include &quot;LabelScope.h&quot;
  41 #include &quot;Lexer.h&quot;
  42 #include &quot;Parser.h&quot;
  43 #include &quot;StackAlignment.h&quot;
  44 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  45 #include &quot;YarrFlags.h&quot;
  46 #include &lt;wtf/Assertions.h&gt;
  47 #include &lt;wtf/Threading.h&gt;
  48 #include &lt;wtf/text/StringBuilder.h&gt;
  49 
  50 namespace JSC {
  51 
  52 /*
  53     Details of the emitBytecode function.
  54 
  55     Return value: The register holding the production&#39;s value.
  56              dst: An optional parameter specifying the most efficient destination at
  57                   which to store the production&#39;s value. The callee must honor dst.
  58 
  59     The dst argument provides for a crude form of copy propagation. For example,
</pre>
<hr />
<pre>
  98 
  99     if (UNLIKELY(needsDebugHook())) {
 100         if (value != MixedTriState)
 101             generator.emitDebugHook(this);
 102     }
 103 
 104     if (value == MixedTriState)
 105         ExpressionNode::emitBytecodeInConditionContext(generator, trueTarget, falseTarget, fallThroughMode);
 106     else if (value == TrueTriState &amp;&amp; fallThroughMode == FallThroughMeansFalse)
 107         generator.emitJump(trueTarget);
 108     else if (value == FalseTriState &amp;&amp; fallThroughMode == FallThroughMeansTrue)
 109         generator.emitJump(falseTarget);
 110 
 111     // All other cases are unconditional fall-throughs, like &quot;if (true)&quot;.
 112 }
 113 
 114 RegisterID* ConstantNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 115 {
 116     if (dst == generator.ignoredResult())
 117         return 0;
<span class="line-modified"> 118     return generator.emitLoad(dst, jsValue(generator));</span>





 119 }
 120 
 121 JSValue StringNode::jsValue(BytecodeGenerator&amp; generator) const
 122 {
 123     return generator.addStringConstant(m_value);
 124 }
 125 
 126 JSValue BigIntNode::jsValue(BytecodeGenerator&amp; generator) const
 127 {
 128     return generator.addBigIntConstant(m_value, m_radix, m_sign);
 129 }
 130 
 131 // ------------------------------ NumberNode ----------------------------------
 132 
 133 RegisterID* NumberNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 134 {
 135     if (dst == generator.ignoredResult())
 136         return nullptr;
 137     return generator.emitLoad(dst, jsValue(generator), isIntegerNode() ? SourceCodeRepresentation::Integer : SourceCodeRepresentation::Double);
 138 }
</pre>
<hr />
<pre>
 148     ASSERT(flags.hasValue());
 149     RegExp* regExp = RegExp::create(generator.vm(), m_pattern.string(), flags.value());
 150     if (regExp-&gt;isValid())
 151         return generator.emitNewRegExp(generator.finalDestination(dst), regExp);
 152 
 153     const char* messageCharacters = regExp-&gt;errorMessage();
 154     const Identifier&amp; message = generator.parserArena().identifierArena().makeIdentifier(generator.vm(), bitwise_cast&lt;const LChar*&gt;(messageCharacters), strlen(messageCharacters));
 155     generator.emitThrowStaticError(ErrorType::SyntaxError, message);
 156     return generator.emitLoad(generator.finalDestination(dst), jsUndefined());
 157 }
 158 
 159 // ------------------------------ ThisNode -------------------------------------
 160 
 161 RegisterID* ThisNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 162 {
 163     generator.ensureThis();
 164     if (dst == generator.ignoredResult())
 165         return 0;
 166 
 167     RegisterID* result = generator.move(dst, generator.thisRegister());
<span class="line-modified"> 168     static const unsigned thisLength = 4;</span>
<span class="line-modified"> 169     generator.emitProfileType(generator.thisRegister(), position(), JSTextPosition(-1, position().offset + thisLength, -1));</span>
 170     return result;
 171 }
 172 
 173 // ------------------------------ SuperNode -------------------------------------
 174 
 175 static RegisterID* emitHomeObjectForCallee(BytecodeGenerator&amp; generator)
 176 {
<span class="line-modified"> 177     if (generator.isDerivedClassContext() || generator.isDerivedConstructorContext()) {</span>
 178         RegisterID* derivedConstructor = generator.emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();
 179         return generator.emitGetById(generator.newTemporary(), derivedConstructor, generator.propertyNames().builtinNames().homeObjectPrivateName());
 180     }
 181 
 182     RegisterID callee;
 183     callee.setIndex(CallFrameSlot::callee);
 184     return generator.emitGetById(generator.newTemporary(), &amp;callee, generator.propertyNames().builtinNames().homeObjectPrivateName());
 185 }
 186 
 187 static RegisterID* emitSuperBaseForCallee(BytecodeGenerator&amp; generator)
 188 {
 189     RefPtr&lt;RegisterID&gt; homeObject = emitHomeObjectForCallee(generator);
 190     return generator.emitGetById(generator.newTemporary(), homeObject.get(), generator.propertyNames().underscoreProto);
 191 }
 192 
 193 static RegisterID* emitGetSuperFunctionForConstruct(BytecodeGenerator&amp; generator)
 194 {
 195     if (generator.isDerivedConstructorContext())
 196         return generator.emitGetById(generator.newTemporary(), generator.emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment(), generator.propertyNames().underscoreProto);
 197 
 198     RegisterID callee;
 199     callee.setIndex(CallFrameSlot::callee);
 200     return generator.emitGetById(generator.newTemporary(), &amp;callee, generator.propertyNames().underscoreProto);
 201 }
 202 
 203 RegisterID* SuperNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 204 {
 205     RegisterID* result = emitSuperBaseForCallee(generator);
 206     return generator.move(generator.finalDestination(dst), result);
 207 }
 208 
 209 // ------------------------------ ImportNode -------------------------------------
 210 
 211 RegisterID* ImportNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 212 {
<span class="line-modified"> 213     RefPtr&lt;RegisterID&gt; importModule = generator.emitGetGlobalPrivate(generator.newTemporary(), generator.propertyNames().builtinNames().importModulePrivateName());</span>
 214     CallArguments arguments(generator, nullptr, 1);
 215     generator.emitLoad(arguments.thisRegister(), jsUndefined());
 216     generator.emitNode(arguments.argumentRegister(0), m_expr);
 217     return generator.emitCall(generator.finalDestination(dst, importModule.get()), importModule.get(), NoExpectedFunction, arguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);
 218 }
 219 
 220 // ------------------------------ NewTargetNode ----------------------------------
 221 
 222 RegisterID* NewTargetNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 223 {
 224     if (dst == generator.ignoredResult())
 225         return nullptr;
 226 
 227     return generator.move(dst, generator.newTarget());
 228 }
 229 
 230 // ------------------------------ ImportMetaNode ---------------------------------
 231 
 232 RegisterID* ImportMetaNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 233 {
 234     return generator.emitNode(dst, m_expr);
 235 }
 236 
 237 // ------------------------------ ResolveNode ----------------------------------
 238 
 239 bool ResolveNode::isPure(BytecodeGenerator&amp; generator) const
 240 {
 241     return generator.variable(m_ident).offset().isStack();
 242 }
 243 
 244 RegisterID* ResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 245 {
 246     Variable var = generator.variable(m_ident);
 247     if (RegisterID* local = var.local()) {
 248         generator.emitTDZCheckIfNecessary(var, local, nullptr);
 249         if (dst == generator.ignoredResult())
 250             return nullptr;
 251 
<span class="line-modified"> 252         generator.emitProfileType(local, var, m_position, JSTextPosition(-1, m_position.offset + m_ident.length(), -1));</span>
 253         return generator.move(dst, local);
 254     }
 255 
 256     JSTextPosition divot = m_start + m_ident.length();
 257     generator.emitExpressionInfo(divot, m_start, divot);
 258     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(dst, var);
 259     RegisterID* finalDest = generator.finalDestination(dst);
 260     RefPtr&lt;RegisterID&gt; uncheckedResult = generator.newTemporary();
 261     generator.emitGetFromScope(uncheckedResult.get(), scope.get(), var, ThrowIfNotFound);
 262     generator.emitTDZCheckIfNecessary(var, uncheckedResult.get(), nullptr);
 263     generator.move(finalDest, uncheckedResult.get());
<span class="line-modified"> 264     generator.emitProfileType(finalDest, var, m_position, JSTextPosition(-1, m_position.offset + m_ident.length(), -1));</span>
 265     return finalDest;
 266 }
 267 
 268 // ------------------------------ TemplateStringNode -----------------------------------
 269 
 270 RegisterID* TemplateStringNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 271 {
 272     if (dst == generator.ignoredResult())
 273         return nullptr;
 274     ASSERT(cooked());
 275     return generator.emitLoad(dst, JSValue(generator.addStringConstant(*cooked())));
 276 }
 277 
 278 // ------------------------------ TemplateLiteralNode -----------------------------------
 279 
 280 RegisterID* TemplateLiteralNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 281 {
 282     if (!m_templateExpressions) {
 283         TemplateStringNode* templateString = m_templateStrings-&gt;value();
 284         ASSERT_WITH_MESSAGE(!m_templateStrings-&gt;next(), &quot;Only one template element exists because there&#39;s no expression in a given template literal.&quot;);
</pre>
<hr />
<pre>
 521 
 522 RegisterID* ObjectLiteralNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 523 {
 524     if (!m_list) {
 525         if (dst == generator.ignoredResult())
 526             return 0;
 527         return generator.emitNewObject(generator.finalDestination(dst));
 528     }
 529     RefPtr&lt;RegisterID&gt; newObj = generator.emitNewObject(generator.tempDestination(dst));
 530     generator.emitNode(newObj.get(), m_list);
 531     return generator.move(dst, newObj.get());
 532 }
 533 
 534 // ------------------------------ PropertyListNode -----------------------------
 535 
 536 static inline void emitPutHomeObject(BytecodeGenerator&amp; generator, RegisterID* function, RegisterID* homeObject)
 537 {
 538     generator.emitPutById(function, generator.propertyNames().builtinNames().homeObjectPrivateName(), homeObject);
 539 }
 540 
<span class="line-modified"> 541 RegisterID* PropertyListNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dstOrConstructor, RegisterID* prototype)</span>
 542 {
 543     // Fast case: this loop just handles regular value properties.
 544     PropertyListNode* p = this;
 545     RegisterID* dst = nullptr;
 546     for (; p &amp;&amp; (p-&gt;m_node-&gt;m_type &amp; PropertyNode::Constant); p = p-&gt;m_next) {
 547         dst = p-&gt;m_node-&gt;isInstanceClassProperty() ? prototype : dstOrConstructor;










 548         emitPutConstantProperty(generator, dst, *p-&gt;m_node);
 549     }
 550 
 551     // Were there any get/set properties?
 552     if (p) {
 553         // Build a list of getter/setter pairs to try to put them at the same time. If we encounter
 554         // a computed property or a spread, just emit everything as that may override previous values.
 555         bool canOverrideProperties = false;
 556 
 557         typedef std::pair&lt;PropertyNode*, PropertyNode*&gt; GetterSetterPair;
 558         typedef HashMap&lt;UniquedStringImpl*, GetterSetterPair, IdentifierRepHash&gt; GetterSetterMap;
 559         GetterSetterMap instanceMap;
 560         GetterSetterMap staticMap;
 561 
 562         // Build a map, pairing get/set values together.
 563         for (PropertyListNode* q = p; q; q = q-&gt;m_next) {
 564             PropertyNode* node = q-&gt;m_node;
 565             if (node-&gt;m_type &amp; PropertyNode::Computed || node-&gt;m_type &amp; PropertyNode::Spread) {
 566                 canOverrideProperties = true;
 567                 break;
</pre>
<hr />
<pre>
 575             GetterSetterMap&amp; map = node-&gt;isStaticClassProperty() ? staticMap : instanceMap;
 576             GetterSetterMap::AddResult result = map.add(node-&gt;name()-&gt;impl(), pair);
 577             auto&amp; resultPair = result.iterator-&gt;value;
 578             if (!result.isNewEntry) {
 579                 if (resultPair.first-&gt;m_type == node-&gt;m_type) {
 580                     resultPair.first-&gt;setIsOverriddenByDuplicate();
 581                     resultPair.first = node;
 582                 } else {
 583                     if (resultPair.second)
 584                         resultPair.second-&gt;setIsOverriddenByDuplicate();
 585                     resultPair.second = node;
 586                 }
 587             }
 588         }
 589 
 590         // Iterate over the remaining properties in the list.
 591         for (; p; p = p-&gt;m_next) {
 592             PropertyNode* node = p-&gt;m_node;
 593             dst = node-&gt;isInstanceClassProperty() ? prototype : dstOrConstructor;
 594 










 595             // Handle regular values.
 596             if (node-&gt;m_type &amp; PropertyNode::Constant) {
 597                 emitPutConstantProperty(generator, dst, *node);
 598                 continue;
 599             } else if (node-&gt;m_type &amp; PropertyNode::Spread) {
 600                 generator.emitNode(dst, node-&gt;m_assign);
 601                 continue;
 602             }
 603 
 604             RefPtr&lt;RegisterID&gt; value = generator.emitNode(node-&gt;m_assign);
 605             bool needsSuperBinding = node-&gt;needsSuperBinding();
 606             if (needsSuperBinding)
 607                 emitPutHomeObject(generator, value.get(), dst);
 608 
 609             unsigned attributes = node-&gt;isClassProperty() ? (PropertyAttribute::Accessor | PropertyAttribute::DontEnum) : static_cast&lt;unsigned&gt;(PropertyAttribute::Accessor);
 610 
 611             ASSERT(node-&gt;m_type &amp; (PropertyNode::Getter | PropertyNode::Setter));
 612 
 613             // This is a get/set property which may be overridden by a computed property or spread later.
 614             if (canOverrideProperties) {
</pre>
<hr />
<pre>
 696         generator.emitSetFunctionNameIfNeeded(node.m_assign, value.get(), propertyNameRegister.get());
 697         generator.emitCallDefineProperty(newObj, propertyNameRegister.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable, m_position);
 698         return;
 699     }
 700     if (const auto* identifier = node.name()) {
 701         Optional&lt;uint32_t&gt; optionalIndex = parseIndex(*identifier);
 702         if (!optionalIndex) {
 703             generator.emitDirectPutById(newObj, *identifier, value.get(), node.putType());
 704             return;
 705         }
 706 
 707         RefPtr&lt;RegisterID&gt; index = generator.emitLoad(nullptr, jsNumber(optionalIndex.value()));
 708         generator.emitDirectPutByVal(newObj, index.get(), value.get());
 709         return;
 710     }
 711     RefPtr&lt;RegisterID&gt; propertyName = generator.emitNode(node.m_expression);
 712     generator.emitSetFunctionNameIfNeeded(node.m_assign, value.get(), propertyName.get());
 713     generator.emitDirectPutByVal(newObj, propertyName.get(), value.get());
 714 }
 715 

















 716 // ------------------------------ BracketAccessorNode --------------------------------
 717 
 718 static bool isNonIndexStringElement(ExpressionNode&amp; element)
 719 {
 720     return element.isString() &amp;&amp; !parseIndex(static_cast&lt;StringNode&amp;&gt;(element).value());
 721 }
 722 
 723 RegisterID* BracketAccessorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 724 {
 725     if (m_base-&gt;isSuperNode()) {
 726         RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
 727         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 728         RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
 729 
 730         if (isNonIndexStringElement(*m_subscript)) {
 731             const Identifier&amp; id = static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value();
 732             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 733             generator.emitGetById(finalDest.get(), superBase.get(), thisValue.get(), id);
 734         } else  {
 735             RefPtr&lt;RegisterID&gt; subscript = generator.emitNodeForProperty(m_subscript);
</pre>
<hr />
<pre>
 903         ASSERT(generator.isConstructor() || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 904         ASSERT(generator.constructorKind() == ConstructorKind::Extends || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 905         RegisterID* ret = generator.emitConstruct(returnValue.get(), func.get(), generator.newTarget(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd());
 906 
 907         bool isConstructorKindDerived = generator.constructorKind() == ConstructorKind::Extends;
 908         bool doWeUseArrowFunctionInConstructor = isConstructorKindDerived &amp;&amp; generator.needsToUpdateArrowFunctionContext();
 909 
 910         if (generator.isDerivedConstructorContext() || (doWeUseArrowFunctionInConstructor &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction()))
 911             generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
 912 
 913         Ref&lt;Label&gt; thisIsEmptyLabel = generator.newLabel();
 914         generator.emitJumpIfTrue(generator.emitIsEmpty(generator.newTemporary(), generator.thisRegister()), thisIsEmptyLabel.get());
 915         generator.emitThrowReferenceError(&quot;&#39;super()&#39; can&#39;t be called more than once in a constructor.&quot;_s);
 916         generator.emitLabel(thisIsEmptyLabel.get());
 917 
 918         generator.move(generator.thisRegister(), ret);
 919 
 920         if (generator.isDerivedConstructorContext() || doWeUseArrowFunctionInConstructor)
 921             generator.emitPutThisToArrowFunctionContextScope();
 922 







 923         return ret;
 924     }
 925 
 926     RefPtr&lt;RegisterID&gt; func = generator.emitNode(m_expr);
 927     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 928     if (isOptionalChainBase())
 929         generator.emitOptionalCheck(func.get());
 930 
 931     CallArguments callArguments(generator, m_args);
 932     generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 933     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 934     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
 935     return ret;
 936 }
 937 
 938 // ------------------------------ FunctionCallResolveNode ----------------------------------
 939 
 940 RegisterID* FunctionCallResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 941 {
<span class="line-modified"> 942     if (UNLIKELY(m_ident == generator.vm().propertyNames-&gt;builtinNames().assertPrivateName())) {</span>
<span class="line-modified"> 943         if (ASSERT_DISABLED)</span>
 944             return generator.move(dst, generator.emitLoad(nullptr, jsUndefined()));
 945     }
 946 
 947     ExpectedFunction expectedFunction = generator.expectedFunctionForIdentifier(m_ident);
 948 
 949     Variable var = generator.variable(m_ident);
 950     RefPtr&lt;RegisterID&gt; local = var.local();
 951     RefPtr&lt;RegisterID&gt; func;
 952     if (local) {
 953         generator.emitTDZCheckIfNecessary(var, local.get(), nullptr);
 954         func = generator.move(generator.tempDestination(dst), local.get());
 955     } else
 956         func = generator.newTemporary();
 957     CallArguments callArguments(generator, m_args);
 958 
 959     if (local) {
 960         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 961         // This passes NoExpectedFunction because we expect that if the function is in a
 962         // local variable, then it&#39;s not one of our built-in constructors.
 963         expectedFunction = NoExpectedFunction;
</pre>
<hr />
<pre>
 967         generator.move(
 968             callArguments.thisRegister(),
 969             generator.emitResolveScope(callArguments.thisRegister(), var));
 970         generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);
 971         generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);
 972     }
 973 
 974     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 975     if (isOptionalChainBase())
 976         generator.emitOptionalCheck(func.get());
 977 
 978     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 979     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
 980     return ret;
 981 }
 982 
 983 // ------------------------------ BytecodeIntrinsicNode ----------------------------------
 984 
 985 RegisterID* BytecodeIntrinsicNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 986 {
<span class="line-modified"> 987     return (this-&gt;*m_emitter)(generator, dst);</span>




 988 }
 989 
 990 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
 991 {
 992     ArgumentListNode* node = m_args-&gt;m_listNode;
 993     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
 994     node = node-&gt;m_next;
 995     ASSERT(node-&gt;m_expr-&gt;isString());
 996     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
 997     ASSERT(!node-&gt;m_next);
 998     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), ident);
 999 }
1000 
1001 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirectPrivate(BytecodeGenerator&amp; generator, RegisterID* dst)
1002 {
1003     ArgumentListNode* node = m_args-&gt;m_listNode;
1004     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1005     node = node-&gt;m_next;
1006     ASSERT(node-&gt;m_expr-&gt;isString());
1007     SymbolImpl* symbol = generator.vm().propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());
1008     ASSERT(symbol);
1009     ASSERT(!node-&gt;m_next);
1010     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol));
1011 }
1012 








































































































































1013 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_argument(BytecodeGenerator&amp; generator, RegisterID* dst)
1014 {
1015     ArgumentListNode* node = m_args-&gt;m_listNode;
1016     ASSERT(node-&gt;m_expr-&gt;isNumber());
1017     double value = static_cast&lt;NumberNode*&gt;(node-&gt;m_expr)-&gt;value();
1018     int32_t index = static_cast&lt;int32_t&gt;(value);
1019     ASSERT(value == index);
1020     ASSERT(index &gt;= 0);
1021     ASSERT(!node-&gt;m_next);
1022 
1023     // The body functions of generator and async have different mechanism for arguments.
1024     ASSERT(generator.parseMode() != SourceParseMode::GeneratorBodyMode);
1025     ASSERT(!isAsyncFunctionBodyParseMode(generator.parseMode()));
1026 
1027     return generator.emitGetArgument(generator.finalDestination(dst), index);
1028 }
1029 
1030 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_argumentCount(BytecodeGenerator&amp; generator, RegisterID* dst)
1031 {
1032     ASSERT(!m_args-&gt;m_listNode);
</pre>
<hr />
<pre>
1062 
1063     ASSERT(!node-&gt;m_next);
1064 
1065     return generator.move(dst, generator.emitDirectPutById(base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol), value.get(), PropertyNode::KnownDirect));
1066 }
1067 
1068 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByValDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
1069 {
1070     ArgumentListNode* node = m_args-&gt;m_listNode;
1071     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1072     node = node-&gt;m_next;
1073     RefPtr&lt;RegisterID&gt; index = generator.emitNodeForProperty(node);
1074     node = node-&gt;m_next;
1075     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1076 
1077     ASSERT(!node-&gt;m_next);
1078 
1079     return generator.move(dst, generator.emitDirectPutByVal(base.get(), index.get(), value.get()));
1080 }
1081 
















































































1082 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_tailCallForwardArguments(BytecodeGenerator&amp; generator, RegisterID* dst)
1083 {
1084     ArgumentListNode* node = m_args-&gt;m_listNode;
1085     RefPtr&lt;RegisterID&gt; function = generator.emitNode(node);
1086     node = node-&gt;m_next;
1087     RefPtr&lt;RegisterID&gt; thisRegister = generator.emitNode(node);
1088     ASSERT(!node-&gt;m_next);
1089 
1090     RefPtr&lt;RegisterID&gt; finalDst = generator.finalDestination(dst);
1091     return generator.emitCallForwardArgumentsInTailPosition(finalDst.get(), function.get(), thisRegister.get(), generator.newTemporary(), 0, divot(), divotStart(), divotEnd(), DebuggableCall::No);
1092 }
1093 
1094 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_throwTypeError(BytecodeGenerator&amp; generator, RegisterID* dst)
1095 {
1096     ArgumentListNode* node = m_args-&gt;m_listNode;
1097     ASSERT(!node-&gt;m_next);
1098     if (node-&gt;m_expr-&gt;isString()) {
1099         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1100         generator.emitThrowTypeError(ident);
1101     } else {
</pre>
<hr />
<pre>
1176     }
1177     return generator.move(dst, generator.emitToObject(temp.get(), src.get(), generator.vm().propertyNames-&gt;emptyIdentifier));
1178 }
1179 
1180 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_idWithProfile(BytecodeGenerator&amp; generator, RegisterID* dst)
1181 {
1182     ArgumentListNode* node = m_args-&gt;m_listNode;
1183     RefPtr&lt;RegisterID&gt; idValue = generator.newTemporary();
1184     generator.emitNode(idValue.get(), node);
1185     SpeculatedType speculation = SpecNone;
1186     while (node-&gt;m_next) {
1187         node = node-&gt;m_next;
1188         ASSERT(node-&gt;m_expr-&gt;isString());
1189         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1190         speculation |= speculationFromString(ident.utf8().data());
1191     }
1192 
1193     return generator.move(dst, generator.emitIdWithProfile(idValue.get(), speculation));
1194 }
1195 
<span class="line-modified">1196 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isJSArray(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
<span class="line-modified">1197 {</span>
<span class="line-modified">1198     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-modified">1199     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
<span class="line-modified">1200     ASSERT(!node-&gt;m_next);</span>
<span class="line-modified">1201 </span>
<span class="line-modified">1202     return generator.move(dst, generator.emitIsJSArray(generator.tempDestination(dst), src.get()));</span>
<span class="line-modified">1203 }</span>
<span class="line-removed">1204 </span>
<span class="line-removed">1205 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isProxyObject(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
<span class="line-removed">1206 {</span>
<span class="line-removed">1207     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-removed">1208     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
<span class="line-removed">1209     ASSERT(!node-&gt;m_next);</span>
<span class="line-removed">1210 </span>
<span class="line-removed">1211     return generator.move(dst, generator.emitIsProxyObject(generator.tempDestination(dst), src.get()));</span>
<span class="line-removed">1212 }</span>
<span class="line-removed">1213 </span>
<span class="line-removed">1214 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isRegExpObject(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
<span class="line-removed">1215 {</span>
<span class="line-removed">1216     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-removed">1217     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
<span class="line-removed">1218     ASSERT(!node-&gt;m_next);</span>
<span class="line-removed">1219 </span>
<span class="line-removed">1220     return generator.move(dst, generator.emitIsRegExpObject(generator.tempDestination(dst), src.get()));</span>
<span class="line-removed">1221 }</span>
<span class="line-removed">1222 </span>
<span class="line-removed">1223 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isObject(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-removed">1224 {</span>
<span class="line-removed">1225     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-removed">1226     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
<span class="line-removed">1227     ASSERT(!node-&gt;m_next);</span>
<span class="line-removed">1228 </span>
<span class="line-removed">1229     return generator.move(dst, generator.emitIsObject(generator.tempDestination(dst), src.get()));</span>
<span class="line-removed">1230 }</span>
1231 
<span class="line-modified">1232 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isDerivedArray(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
<span class="line-modified">1233 {</span>
<span class="line-modified">1234     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-modified">1235     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
<span class="line-modified">1236     ASSERT(!node-&gt;m_next);</span>








1237 
<span class="line-modified">1238     return generator.move(dst, generator.emitIsDerivedArray(generator.tempDestination(dst), src.get()));</span>
<span class="line-removed">1239 }</span>
1240 
<span class="line-modified">1241 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isMap(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
1242 {
1243     ArgumentListNode* node = m_args-&gt;m_listNode;
<span class="line-modified">1244     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
1245     ASSERT(!node-&gt;m_next);
1246 
<span class="line-modified">1247     return generator.move(dst, generator.emitIsMap(generator.tempDestination(dst), src.get()));</span>


1248 }
1249 
<span class="line-modified">1250 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isSet(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
1251 {
1252     ArgumentListNode* node = m_args-&gt;m_listNode;
<span class="line-modified">1253     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>


1254     ASSERT(!node-&gt;m_next);
1255 
<span class="line-modified">1256     return generator.move(dst, generator.emitIsSet(generator.tempDestination(dst), src.get()));</span>
1257 }
1258 
<span class="line-modified">1259 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isUndefinedOrNull(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
1260 {
<span class="line-modified">1261     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-modified">1262     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
<span class="line-modified">1263     ASSERT(!node-&gt;m_next);</span>
<span class="line-modified">1264 </span>
<span class="line-modified">1265     return generator.move(dst, generator.emitIsUndefinedOrNull(generator.tempDestination(dst), src.get()));</span>
1266 }
1267 
<span class="line-modified">1268 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_newArrayWithSize(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
1269 {
<span class="line-modified">1270     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-modified">1271     RefPtr&lt;RegisterID&gt; size = generator.emitNode(node);</span>
<span class="line-removed">1272     ASSERT(!node-&gt;m_next);</span>
<span class="line-removed">1273 </span>
<span class="line-removed">1274     RefPtr&lt;RegisterID&gt; finalDestination = generator.finalDestination(dst);</span>
<span class="line-removed">1275     generator.emitNewArrayWithSize(finalDestination.get(), size.get());</span>
<span class="line-removed">1276     return finalDestination.get();</span>
1277 }
1278 
1279 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_defineEnumerableWritableConfigurableDataProperty(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1280 {
1281     ArgumentListNode* node = m_args-&gt;m_listNode;
1282     RefPtr&lt;RegisterID&gt; newObj = generator.emitNode(node);
1283     node = node-&gt;m_next;
1284     RefPtr&lt;RegisterID&gt; propertyNameRegister = generator.emitNode(node);
1285     node = node-&gt;m_next;
1286     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1287     ASSERT(!node-&gt;m_next);
1288 
1289     generator.emitCallDefineProperty(newObj.get(), propertyNameRegister.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable | BytecodeGenerator::PropertyEnumerable, m_position);
1290     return dst;
1291 }
1292 
1293 #define JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS(name) \
1294     RegisterID* BytecodeIntrinsicNode::emit_intrinsic_##name(BytecodeGenerator&amp; generator, RegisterID* dst) \
1295     { \
1296         ASSERT(!m_args); \
</pre>
<hr />
<pre>
1587         generator.emitLabel(realCall.get());
1588         CallArguments callArguments(generator, m_args);
1589         generator.move(callArguments.thisRegister(), base.get());
1590         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1591         generator.emitLabel(end.get());
1592     }
1593     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1594     return returnValue.get();
1595 }
1596 
1597 // ------------------------------ PostfixNode ----------------------------------
1598 
1599 static RegisterID* emitIncOrDec(BytecodeGenerator&amp; generator, RegisterID* srcDst, Operator oper)
1600 {
1601     return (oper == OpPlusPlus) ? generator.emitInc(srcDst) : generator.emitDec(srcDst);
1602 }
1603 
1604 static RegisterID* emitPostIncOrDec(BytecodeGenerator&amp; generator, RegisterID* dst, RegisterID* srcDst, Operator oper)
1605 {
1606     if (dst == srcDst)
<span class="line-modified">1607         return generator.emitToNumber(generator.finalDestination(dst), srcDst);</span>
<span class="line-modified">1608     RefPtr&lt;RegisterID&gt; tmp = generator.emitToNumber(generator.tempDestination(dst), srcDst);</span>
<span class="line-modified">1609     emitIncOrDec(generator, srcDst, oper);</span>



1610     return generator.move(dst, tmp.get());
1611 }
1612 
1613 RegisterID* PostfixNode::emitResolve(BytecodeGenerator&amp; generator, RegisterID* dst)
1614 {
1615     if (dst == generator.ignoredResult())
1616         return PrefixNode::emitResolve(generator, dst);
1617 
1618     ASSERT(m_expr-&gt;isResolveNode());
1619     ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(m_expr);
1620     const Identifier&amp; ident = resolve-&gt;identifier();
1621 
1622     Variable var = generator.variable(ident);
1623     if (RegisterID* local = var.local()) {
1624         generator.emitTDZCheckIfNecessary(var, local, nullptr);
1625         RefPtr&lt;RegisterID&gt; localReg = local;
1626         if (var.isReadOnly()) {
1627             generator.emitReadOnlyExceptionIfNeeded(var);
1628             localReg = generator.move(generator.tempDestination(dst), local);
1629         }
</pre>
<hr />
<pre>
1940         return emitResolve(generator, dst);
1941 
1942     if (m_expr-&gt;isBracketAccessorNode())
1943         return emitBracket(generator, dst);
1944 
1945     if (m_expr-&gt;isDotAccessorNode())
1946         return emitDot(generator, dst);
1947 
1948     ASSERT(m_expr-&gt;isFunctionCall());
1949     return emitThrowReferenceError(generator, m_operator == OpPlusPlus
1950         ? &quot;Prefix ++ operator applied to value that is not a reference.&quot;_s
1951         : &quot;Prefix -- operator applied to value that is not a reference.&quot;_s);
1952 }
1953 
1954 // ------------------------------ Unary Operation Nodes -----------------------------------
1955 
1956 RegisterID* UnaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1957 {
1958     RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
1959     generator.emitExpressionInfo(position(), position(), position());
<span class="line-modified">1960     return generator.emitUnaryOp(opcodeID(), generator.finalDestination(dst), src.get(), OperandTypes(m_expr-&gt;resultDescriptor()));</span>
1961 }
1962 
1963 // ------------------------------ UnaryPlusNode -----------------------------------
1964 
1965 RegisterID* UnaryPlusNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1966 {
1967     ASSERT(opcodeID() == op_to_number);
1968     RefPtr&lt;RegisterID&gt; src = generator.emitNode(expr());
1969     generator.emitExpressionInfo(position(), position(), position());
1970     return generator.emitToNumber(generator.finalDestination(dst), src.get());
1971 }
1972 
1973 // ------------------------------ LogicalNotNode -----------------------------------
1974 
1975 void LogicalNotNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
1976 {
1977     if (UNLIKELY(needsDebugHook()))
1978         generator.emitDebugHook(this);
1979 
1980     // Reverse the true and false targets.
</pre>
<hr />
<pre>
2787 void BlockNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2788 {
2789     if (!m_statements)
2790         return;
2791     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested);
2792     m_statements-&gt;emitBytecode(generator, dst);
2793     generator.popLexicalScope(this);
2794 }
2795 
2796 // ------------------------------ EmptyStatementNode ---------------------------
2797 
2798 void EmptyStatementNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
2799 {
2800     RELEASE_ASSERT(needsDebugHook());
2801 }
2802 
2803 // ------------------------------ DebuggerStatementNode ---------------------------
2804 
2805 void DebuggerStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2806 {
<span class="line-modified">2807     generator.emitDebugHook(DidReachBreakpoint, position());</span>
2808 }
2809 
2810 // ------------------------------ ExprStatementNode ----------------------------
2811 
2812 void ExprStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2813 {
2814     ASSERT(m_expr);
2815     generator.emitNode(dst, m_expr);
2816 }
2817 
2818 // ------------------------------ DeclarationStatement ----------------------------
2819 
2820 void DeclarationStatement::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2821 {
2822     ASSERT(m_expr);
2823     generator.emitNode(m_expr);
2824 }
2825 
2826 // ------------------------------ EmptyVarExpression ----------------------------
2827 
2828 RegisterID* EmptyVarExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2829 {
2830     // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
2831     if (!generator.shouldEmitTypeProfilerHooks())
2832         return nullptr;
2833 
2834     Variable var = generator.variable(m_ident);
2835     if (RegisterID* local = var.local())
<span class="line-modified">2836         generator.emitProfileType(local, var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));</span>
2837     else {
2838         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2839         RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, DoNotThrowIfNotFound);
<span class="line-modified">2840         generator.emitProfileType(value.get(), var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));</span>
2841     }
2842 
2843     return nullptr;
2844 }
2845 
2846 // ------------------------------ EmptyLetExpression ----------------------------
2847 
2848 RegisterID* EmptyLetExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2849 {
2850     // Lexical declarations like &#39;let&#39; must move undefined into their variables so we don&#39;t
2851     // get TDZ errors for situations like this: `let x; x;`
2852     Variable var = generator.variable(m_ident);
2853     if (RegisterID* local = var.local()) {
2854         generator.emitLoad(local, jsUndefined());
<span class="line-modified">2855         generator.emitProfileType(local, var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));</span>
2856     } else {
2857         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2858         RefPtr&lt;RegisterID&gt; value = generator.emitLoad(nullptr, jsUndefined());
2859         generator.emitPutToScope(scope.get(), var, value.get(), generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::Initialization);
<span class="line-modified">2860         generator.emitProfileType(value.get(), var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));</span>
2861     }
2862 
2863     generator.liftTDZCheckIfPossible(var);
2864 
2865     // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
2866     return nullptr;
2867 }
2868 
2869 // ------------------------------ IfElseNode ---------------------------------------
2870 
2871 static inline StatementNode* singleStatement(StatementNode* statementNode)
2872 {
2873     if (statementNode-&gt;isBlock())
2874         return static_cast&lt;BlockNode*&gt;(statementNode)-&gt;singleStatement();
2875     return statementNode;
2876 }
2877 
2878 bool IfElseNode::tryFoldBreakAndContinue(BytecodeGenerator&amp; generator, StatementNode* ifBlock,
2879     Label*&amp; trueTarget, FallThroughMode&amp; fallThroughMode)
2880 {
</pre>
<hr />
<pre>
3057     return nullptr;
3058 }
3059 
3060 void ForInNode::emitLoopHeader(BytecodeGenerator&amp; generator, RegisterID* propertyName)
3061 {
3062     auto lambdaEmitResolveVariable = [&amp;] (const Identifier&amp; ident) {
3063         Variable var = generator.variable(ident);
3064         if (RegisterID* local = var.local()) {
3065             if (var.isReadOnly())
3066                 generator.emitReadOnlyExceptionIfNeeded(var);
3067             generator.move(local, propertyName);
3068         } else {
3069             if (generator.isStrictMode())
3070                 generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3071             if (var.isReadOnly())
3072                 generator.emitReadOnlyExceptionIfNeeded(var);
3073             RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
3074             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3075             generator.emitPutToScope(scope.get(), var, propertyName, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
3076         }
<span class="line-modified">3077         generator.emitProfileType(propertyName, var, m_lexpr-&gt;position(), JSTextPosition(-1, m_lexpr-&gt;position().offset + ident.length(), -1));</span>
3078     };
3079 
3080     if (m_lexpr-&gt;isResolveNode()) {
3081         const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
3082         lambdaEmitResolveVariable(ident);
3083         return;
3084     }
3085 
3086     if (m_lexpr-&gt;isAssignResolveNode()) {
3087         const Identifier&amp; ident = static_cast&lt;AssignResolveNode*&gt;(m_lexpr)-&gt;identifier();
3088         lambdaEmitResolveVariable(ident);
3089         return;
3090     }
3091 
3092     if (m_lexpr-&gt;isDotAccessorNode()) {
3093         DotAccessorNode* assignNode = static_cast&lt;DotAccessorNode*&gt;(m_lexpr);
3094         const Identifier&amp; ident = assignNode-&gt;identifier();
3095         RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3096         generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3097         if (assignNode-&gt;base()-&gt;isSuperNode()) {
</pre>
<hr />
<pre>
3314     RegisterID* forLoopSymbolTable = nullptr;
3315     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested, &amp;forLoopSymbolTable);
3316     auto extractor = scopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;([this, dst](BytecodeGenerator&amp; generator, RegisterID* value)
3317     {
3318         if (m_lexpr-&gt;isResolveNode()) {
3319             const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
3320             Variable var = generator.variable(ident);
3321             if (RegisterID* local = var.local()) {
3322                 if (var.isReadOnly())
3323                     generator.emitReadOnlyExceptionIfNeeded(var);
3324                 generator.move(local, value);
3325             } else {
3326                 if (generator.isStrictMode())
3327                     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3328                 if (var.isReadOnly())
3329                     generator.emitReadOnlyExceptionIfNeeded(var);
3330                 RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
3331                 generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3332                 generator.emitPutToScope(scope.get(), var, value, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
3333             }
<span class="line-modified">3334             generator.emitProfileType(value, var, m_lexpr-&gt;position(), JSTextPosition(-1, m_lexpr-&gt;position().offset + ident.length(), -1));</span>
3335         } else if (m_lexpr-&gt;isDotAccessorNode()) {
3336             DotAccessorNode* assignNode = static_cast&lt;DotAccessorNode*&gt;(m_lexpr);
3337             const Identifier&amp; ident = assignNode-&gt;identifier();
3338             RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3339 
3340             generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3341             if (assignNode-&gt;base()-&gt;isSuperNode()) {
3342                 RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
3343                 generator.emitPutById(base.get(), thisValue.get(), ident, value);
3344             } else
3345                 generator.emitPutById(base.get(), ident, value);
3346             generator.emitProfileType(value, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3347         } else if (m_lexpr-&gt;isBracketAccessorNode()) {
3348             BracketAccessorNode* assignNode = static_cast&lt;BracketAccessorNode*&gt;(m_lexpr);
3349             RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3350             RegisterID* subscript = generator.emitNodeForProperty(assignNode-&gt;subscript());
3351 
3352             generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3353             if (assignNode-&gt;base()-&gt;isSuperNode()) {
3354                 RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
</pre>
<hr />
<pre>
3897         ASSERT(expr-&gt;isFuncExprNode());
3898         FuncExprNode* funcExpr = static_cast&lt;FuncExprNode*&gt;(expr);
3899 
3900         RefPtr&lt;RegisterID&gt; next = generator.newTemporary();
3901         generator.emitNode(next.get(), funcExpr);
3902 
3903         if (generator.superBinding() == SuperBinding::Needed || (generator.parseMode() == SourceParseMode::AsyncArrowFunctionMode &amp;&amp; generator.isSuperUsedInInnerArrowFunction())) {
3904             RefPtr&lt;RegisterID&gt; homeObject = emitHomeObjectForCallee(generator);
3905             emitPutHomeObject(generator, next.get(), homeObject.get());
3906         }
3907 
3908         if (generator.parseMode() == SourceParseMode::AsyncArrowFunctionMode &amp;&amp; generator.isThisUsedInInnerArrowFunction())
3909             generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
3910 
3911         generator.emitPutGeneratorFields(next.get());
3912 
3913         ASSERT(startOffset() &gt;= lineStartOffset());
3914         generator.emitDebugHook(WillLeaveCallFrame, lastLine(), startOffset(), lineStartOffset());
3915 
3916         // load and call @asyncFunctionResume
<span class="line-modified">3917         auto var = generator.variable(generator.propertyNames().builtinNames().asyncFunctionResumePrivateName());</span>
<span class="line-removed">3918         RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();</span>
<span class="line-removed">3919         generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));</span>
<span class="line-removed">3920         RefPtr&lt;RegisterID&gt; asyncFunctionResume = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);</span>
3921 
3922         CallArguments args(generator, nullptr, 4);
3923         unsigned argumentCount = 0;
3924         generator.emitLoad(args.thisRegister(), jsUndefined());
3925         generator.move(args.argumentRegister(argumentCount++), generator.generatorRegister());
<span class="line-modified">3926         generator.move(args.argumentRegister(argumentCount++), generator.promiseCapabilityRegister());</span>
3927         generator.emitLoad(args.argumentRegister(argumentCount++), jsUndefined());
<span class="line-modified">3928         generator.emitLoad(args.argumentRegister(argumentCount++), jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode)));</span>
3929         // JSTextPosition(int _line, int _offset, int _lineStartOffset)
3930         JSTextPosition divot(firstLine(), startOffset(), lineStartOffset());
3931 
3932         RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
3933         generator.emitCallInTailPosition(result.get(), asyncFunctionResume.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
3934         generator.emitReturn(result.get());
3935         break;
3936     }
3937 
3938     case SourceParseMode::AsyncGeneratorBodyMode:
3939     case SourceParseMode::AsyncArrowFunctionBodyMode:
3940     case SourceParseMode::AsyncFunctionBodyMode:
3941     case SourceParseMode::GeneratorBodyMode: {
3942         Ref&lt;Label&gt; generatorBodyLabel = generator.newLabel();
3943         {
3944             RefPtr&lt;RegisterID&gt; condition = generator.newTemporary();
<span class="line-modified">3945             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));</span>
3946             generator.emitJumpIfTrue(condition.get(), generatorBodyLabel.get());
3947 
3948             Ref&lt;Label&gt; throwLabel = generator.newLabel();
<span class="line-modified">3949             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ThrowMode))));</span>
3950             generator.emitJumpIfTrue(condition.get(), throwLabel.get());
3951 
3952             generator.emitReturn(generator.generatorValueRegister());
3953 
3954             generator.emitLabel(throwLabel.get());
3955             generator.emitThrow(generator.generatorValueRegister());
3956         }
3957 
3958         generator.emitLabel(generatorBodyLabel.get());
3959 
3960         emitStatementsBytecode(generator, generator.ignoredResult());
3961 
3962         Ref&lt;Label&gt; done = generator.newLabel();
3963         generator.emitLabel(done.get());
3964         generator.emitReturn(generator.emitLoad(nullptr, jsUndefined()));
3965         break;
3966     }
3967 
3968     default: {
3969         emitStatementsBytecode(generator, generator.ignoredResult());
3970 
3971         StatementNode* singleStatement = this-&gt;singleStatement();
3972         ReturnNode* returnNode = 0;
3973 
3974         // Check for a return statement at the end of a function composed of a single block.
3975         if (singleStatement &amp;&amp; singleStatement-&gt;isBlock()) {
3976             StatementNode* lastStatementInBlock = static_cast&lt;BlockNode*&gt;(singleStatement)-&gt;lastStatement();
3977             if (lastStatementInBlock &amp;&amp; lastStatementInBlock-&gt;isReturnNode())
3978                 returnNode = static_cast&lt;ReturnNode*&gt;(lastStatementInBlock);
3979         }
3980 
3981         // If there is no return we must automatically insert one.
3982         if (!returnNode) {
3983             if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction())
3984                 generator.emitLoadThisFromArrowFunctionLexicalEnvironment(); // Arrow function can invoke &#39;super&#39; in constructor and before leave constructor we need load &#39;this&#39; from lexical arrow function environment
3985 
<span class="line-modified">3986             RegisterID* r0 = generator.isConstructor() ? generator.thisRegister() : generator.emitLoad(0, jsUndefined());</span>




3987             generator.emitProfileType(r0, ProfileTypeBytecodeFunctionReturnStatement); // Do not emit expression info for this profile because it&#39;s not in the user&#39;s source code.
3988             ASSERT(startOffset() &gt;= lineStartOffset());
3989             generator.emitWillLeaveCallFrameDebugHook();
3990             generator.emitReturn(r0);
3991             return;
3992         }
3993         break;
3994     }
3995     }
3996 }
3997 
3998 // ------------------------------ FuncDeclNode ---------------------------------
3999 
4000 void FuncDeclNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
4001 {
4002     generator.hoistSloppyModeFunctionIfNecessary(metadata()-&gt;ident());
4003 }
4004 
4005 // ------------------------------ FuncExprNode ---------------------------------
4006 
</pre>
<hr />
<pre>
4017 }
4018 
4019 // ------------------------------ MethodDefinitionNode ---------------------------------
4020 
4021 RegisterID* MethodDefinitionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4022 {
4023     return generator.emitNewMethodDefinition(generator.finalDestination(dst), this);
4024 }
4025 
4026 // ------------------------------ YieldExprNode --------------------------------
4027 
4028 RegisterID* YieldExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4029 {
4030     if (!delegate()) {
4031         RefPtr&lt;RegisterID&gt; arg = nullptr;
4032         if (argument()) {
4033             arg = generator.newTemporary();
4034             generator.emitNode(arg.get(), argument());
4035         } else
4036             arg = generator.emitLoad(nullptr, jsUndefined());
<span class="line-modified">4037         RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Yield);</span>
4038         if (dst == generator.ignoredResult())
4039             return nullptr;
4040         return generator.move(generator.finalDestination(dst), value.get());
4041     }
4042     RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
4043     generator.emitNode(arg.get(), argument());
4044     RefPtr&lt;RegisterID&gt; value = generator.emitDelegateYield(arg.get(), this);
4045     if (dst == generator.ignoredResult())
4046         return nullptr;
4047     return generator.move(generator.finalDestination(dst), value.get());
4048 }
4049 
4050 // ------------------------------ AwaitExprNode --------------------------------
4051 
4052 RegisterID* AwaitExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4053 {
4054     RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
4055     generator.emitNode(arg.get(), argument());
<span class="line-modified">4056     RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Await);</span>
4057     if (dst == generator.ignoredResult())
4058         return nullptr;
4059     return generator.move(generator.finalDestination(dst), value.get());
4060 }
4061 










































4062 // ------------------------------ ClassDeclNode ---------------------------------
4063 
4064 void ClassDeclNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
4065 {
4066     generator.emitNode(m_classDeclaration);
4067 }
4068 
4069 // ------------------------------ ClassExprNode ---------------------------------
4070 
4071 RegisterID* ClassExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4072 {
<span class="line-modified">4073     if (!m_name.isNull())</span>
4074         generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested);
4075 
4076     RefPtr&lt;RegisterID&gt; superclass;
4077     if (m_classHeritage) {
4078         superclass = generator.newTemporary();
4079         generator.emitNode(superclass.get(), m_classHeritage);
4080     }
4081 
4082     RefPtr&lt;RegisterID&gt; constructor = generator.tempDestination(dst);
4083     bool needsHomeObject = false;
4084 


4085     if (m_constructorExpression) {
4086         ASSERT(m_constructorExpression-&gt;isFuncExprNode());
4087         FunctionMetadataNode* metadata = static_cast&lt;FuncExprNode*&gt;(m_constructorExpression)-&gt;metadata();
4088         metadata-&gt;setEcmaName(ecmaName());
4089         metadata-&gt;setClassSource(m_classSource);

4090         constructor = generator.emitNode(constructor.get(), m_constructorExpression);
4091         needsHomeObject = m_classHeritage || metadata-&gt;superBinding() == SuperBinding::Needed;
4092     } else
<span class="line-modified">4093         constructor = generator.emitNewDefaultConstructor(constructor.get(), m_classHeritage ? ConstructorKind::Extends : ConstructorKind::Base, m_name, ecmaName(), m_classSource);</span>
4094 
4095     const auto&amp; propertyNames = generator.propertyNames();
4096     RefPtr&lt;RegisterID&gt; prototype = generator.emitNewObject(generator.newTemporary());
4097 
4098     if (superclass) {
4099         RefPtr&lt;RegisterID&gt; protoParent = generator.newTemporary();
4100         generator.emitLoad(protoParent.get(), jsNull());
4101 
4102         RefPtr&lt;RegisterID&gt; tempRegister = generator.newTemporary();
4103 
4104         // FIXME: Throw TypeError if it&#39;s a generator function.
4105         Ref&lt;Label&gt; superclassIsUndefinedLabel = generator.newLabel();
4106         generator.emitJumpIfTrue(generator.emitIsUndefined(tempRegister.get(), superclass.get()), superclassIsUndefinedLabel.get());
4107 
4108         Ref&lt;Label&gt; superclassIsNullLabel = generator.newLabel();
4109         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpEqNull&gt;(tempRegister.get(), superclass.get()), superclassIsNullLabel.get());
4110 
4111         Ref&lt;Label&gt; superclassIsObjectLabel = generator.newLabel();
4112         generator.emitJumpIfTrue(generator.emitIsObject(tempRegister.get(), superclass.get()), superclassIsObjectLabel.get());
4113         generator.emitLabel(superclassIsUndefinedLabel.get());
</pre>
<hr />
<pre>
4119         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpIsObjectOrNull&gt;(tempRegister.get(), protoParent.get()), protoParentIsObjectOrNullLabel.get());
4120         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpIsFunction&gt;(tempRegister.get(), protoParent.get()), protoParentIsObjectOrNullLabel.get());
4121         generator.emitThrowTypeError(&quot;The value of the superclass&#39;s prototype property is not an object.&quot;_s);
4122         generator.emitLabel(protoParentIsObjectOrNullLabel.get());
4123 
4124         generator.emitDirectPutById(constructor.get(), generator.propertyNames().underscoreProto, superclass.get(), PropertyNode::Unknown);
4125         generator.emitLabel(superclassIsNullLabel.get());
4126         generator.emitDirectPutById(prototype.get(), generator.propertyNames().underscoreProto, protoParent.get(), PropertyNode::Unknown);
4127     }
4128 
4129     if (needsHomeObject)
4130         emitPutHomeObject(generator, constructor.get(), prototype.get());
4131 
4132     RefPtr&lt;RegisterID&gt; constructorNameRegister = generator.emitLoad(nullptr, propertyNames.constructor);
4133     generator.emitCallDefineProperty(prototype.get(), constructorNameRegister.get(), constructor.get(), nullptr, nullptr,
4134         BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable, m_position);
4135 
4136     RefPtr&lt;RegisterID&gt; prototypeNameRegister = generator.emitLoad(nullptr, propertyNames.prototype);
4137     generator.emitCallDefineProperty(constructor.get(), prototypeNameRegister.get(), prototype.get(), nullptr, nullptr, 0, m_position);
4138 
<span class="line-modified">4139     if (m_classElements)</span>
<span class="line-modified">4140         generator.emitDefineClassElements(m_classElements, constructor.get(), prototype.get());</span>







4141 
<span class="line-modified">4142     if (!m_name.isNull()) {</span>
<span class="line-modified">4143         Variable classNameVar = generator.variable(m_name);</span>
<span class="line-modified">4144         RELEASE_ASSERT(classNameVar.isResolved());</span>
<span class="line-modified">4145         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, classNameVar);</span>
<span class="line-modified">4146         generator.emitPutToScope(scope.get(), classNameVar, constructor.get(), ThrowIfNotFound, InitializationMode::Initialization);</span>






4147         generator.popLexicalScope(this);
4148     }
4149 
4150     return generator.move(generator.finalDestination(dst, constructor.get()), constructor.get());
4151 }
4152 
4153 // ------------------------------ ImportDeclarationNode -----------------------
4154 
4155 void ImportDeclarationNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4156 {
4157     // Do nothing at runtime.
4158 }
4159 
4160 // ------------------------------ ExportAllDeclarationNode --------------------
4161 
4162 void ExportAllDeclarationNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4163 {
4164     // Do nothing at runtime.
4165 }
4166 
</pre>
<hr />
<pre>
4375         if (m_targetPatterns[i].wasString)
4376             builder.appendQuotedJSONString(m_targetPatterns[i].propertyName.string());
4377         else
4378             builder.append(m_targetPatterns[i].propertyName.string());
4379         builder.append(&#39;:&#39;);
4380         m_targetPatterns[i].pattern-&gt;toString(builder);
4381         if (i &lt; m_targetPatterns.size() - 1)
4382             builder.append(&#39;,&#39;);
4383     }
4384     builder.append(&#39;}&#39;);
4385 }
4386 
4387 void ObjectPatternNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* rhs) const
4388 {
4389     generator.emitRequireObjectCoercible(rhs, &quot;Right side of assignment cannot be destructured&quot;_s);
4390 
4391     RefPtr&lt;RegisterID&gt; excludedList;
4392     IdentifierSet excludedSet;
4393     RefPtr&lt;RegisterID&gt; addMethod;
4394     if (m_containsRestElement &amp;&amp; m_containsComputedProperty) {
<span class="line-modified">4395         auto var = generator.variable(generator.propertyNames().builtinNames().SetPrivateName());</span>
<span class="line-removed">4396 </span>
<span class="line-removed">4397         RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();</span>
<span class="line-removed">4398         generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));</span>
<span class="line-removed">4399         RefPtr&lt;RegisterID&gt; setConstructor = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);</span>
4400 
4401         CallArguments args(generator, nullptr, 0);
4402         excludedList = generator.emitConstruct(generator.newTemporary(), setConstructor.get(), setConstructor.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd());
4403 
4404         addMethod = generator.emitGetById(generator.newTemporary(), excludedList.get(), generator.propertyNames().builtinNames().addPrivateName());
4405     }
4406 
4407     BytecodeGenerator::PreservedTDZStack preservedTDZStack;
4408     generator.preserveTDZStack(preservedTDZStack);
4409 
4410     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4411         const auto&amp; target = m_targetPatterns[i];
4412         if (target.bindingType == BindingType::Element) {
4413             RefPtr&lt;RegisterID&gt; temp = generator.newTemporary();
4414             RefPtr&lt;RegisterID&gt; propertyName;
4415             if (!target.propertyExpression) {
4416                 Optional&lt;uint32_t&gt; optionalIndex = parseIndex(target.propertyName);
4417                 if (!optionalIndex)
4418                     generator.emitGetById(temp.get(), rhs, target.propertyName);
4419                 else {
</pre>
<hr />
<pre>
4430                     if (!target.propertyExpression)
4431                         propertyName = generator.emitLoad(nullptr, target.propertyName);
4432 
4433                     CallArguments args(generator, nullptr, 1);
4434                     generator.move(args.thisRegister(), excludedList.get());
4435                     generator.move(args.argumentRegister(0), propertyName.get());
4436                     generator.emitCall(generator.newTemporary(), addMethod.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4437                 } else
4438                     excludedSet.add(target.propertyName.impl());
4439             }
4440 
4441             if (target.defaultValue)
4442                 assignDefaultValueIfUndefined(generator, temp.get(), target.defaultValue);
4443             target.pattern-&gt;bindValue(generator, temp.get());
4444         } else {
4445             ASSERT(target.bindingType == BindingType::RestElement);
4446             ASSERT(i == m_targetPatterns.size() - 1);
4447             RefPtr&lt;RegisterID&gt; newObject = generator.emitNewObject(generator.newTemporary());
4448 
4449             // load and call @copyDataProperties
<span class="line-modified">4450             auto var = generator.variable(generator.propertyNames().builtinNames().copyDataPropertiesPrivateName());</span>
<span class="line-removed">4451 </span>
<span class="line-removed">4452             RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();</span>
<span class="line-removed">4453             generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));</span>
<span class="line-removed">4454             RefPtr&lt;RegisterID&gt; copyDataProperties = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);</span>
4455 
4456             CallArguments args(generator, nullptr, 3);
4457             generator.emitLoad(args.thisRegister(), jsUndefined());
4458             generator.move(args.argumentRegister(0), newObject.get());
4459             generator.move(args.argumentRegister(1), rhs);
4460             if (m_containsComputedProperty)
4461                 generator.move(args.argumentRegister(2), excludedList.get());
4462             else {
4463                 RefPtr&lt;RegisterID&gt; excludedSetReg = generator.emitLoad(generator.newTemporary(), excludedSet);
4464                 generator.move(args.argumentRegister(2), excludedSetReg.get());
4465             }
4466 
4467             RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
4468             generator.emitCall(result.get(), copyDataProperties.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4469             target.pattern-&gt;bindValue(generator, result.get());
4470         }
4471     }
4472 
4473     generator.restoreTDZStack(preservedTDZStack);
4474 }
</pre>
<hr />
<pre>
4607 void RestParameterNode::emit(BytecodeGenerator&amp; generator)
4608 {
4609     RefPtr&lt;RegisterID&gt; temp = generator.newTemporary();
4610     generator.emitRestParameter(temp.get(), m_numParametersToSkip);
4611     m_pattern-&gt;bindValue(generator, temp.get());
4612 }
4613 
4614 
4615 RegisterID* SpreadExpressionNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4616 {
4617     RELEASE_ASSERT_NOT_REACHED();
4618     return 0;
4619 }
4620 
4621 RegisterID* ObjectSpreadExpressionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4622 {
4623     RefPtr&lt;RegisterID&gt; src = generator.newTemporary();
4624     generator.emitNode(src.get(), m_expression);
4625 
4626     // load and call @copyDataPropertiesNoExclusions
<span class="line-modified">4627     auto var = generator.variable(generator.propertyNames().builtinNames().copyDataPropertiesNoExclusionsPrivateName());</span>
<span class="line-removed">4628 </span>
<span class="line-removed">4629     RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();</span>
<span class="line-removed">4630     generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));</span>
<span class="line-removed">4631     RefPtr&lt;RegisterID&gt; copyDataProperties = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);</span>
4632 
4633     CallArguments args(generator, nullptr, 2);
4634     generator.emitLoad(args.thisRegister(), jsUndefined());
4635     generator.move(args.argumentRegister(0), dst);
4636     generator.move(args.argumentRegister(1), src.get());
4637 
4638     generator.emitCall(generator.newTemporary(), copyDataProperties.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4639 
4640     return dst;
4641 }
4642 
4643 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  13 *  version 2 of the License, or (at your option) any later version.
  14 *
  15 *  This library is distributed in the hope that it will be useful,
  16 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  17 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18 *  Library General Public License for more details.
  19 *
  20 *  You should have received a copy of the GNU Library General Public License
  21 *  along with this library; see the file COPYING.LIB.  If not, write to
  22 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23 *  Boston, MA 02110-1301, USA.
  24 *
  25 */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Nodes.h&quot;
  29 #include &quot;NodeConstructors.h&quot;
  30 
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeGenerator.h&quot;
<span class="line-added">  33 #include &quot;BytecodeGeneratorBaseInlines.h&quot;</span>
  34 #include &quot;CallFrame.h&quot;
  35 #include &quot;JIT.h&quot;
<span class="line-added">  36 #include &quot;JSArrayIterator.h&quot;</span>
<span class="line-added">  37 #include &quot;JSAsyncGenerator.h&quot;</span>
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;JSFunction.h&quot;
<span class="line-modified">  40 #include &quot;JSGenerator.h&quot;</span>
  41 #include &quot;JSGlobalObject.h&quot;
  42 #include &quot;JSImmutableButterfly.h&quot;
<span class="line-added">  43 #include &quot;JSStringIterator.h&quot;</span>
  44 #include &quot;LabelScope.h&quot;
  45 #include &quot;Lexer.h&quot;
  46 #include &quot;Parser.h&quot;
  47 #include &quot;StackAlignment.h&quot;
  48 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  49 #include &quot;YarrFlags.h&quot;
  50 #include &lt;wtf/Assertions.h&gt;
  51 #include &lt;wtf/Threading.h&gt;
  52 #include &lt;wtf/text/StringBuilder.h&gt;
  53 
  54 namespace JSC {
  55 
  56 /*
  57     Details of the emitBytecode function.
  58 
  59     Return value: The register holding the production&#39;s value.
  60              dst: An optional parameter specifying the most efficient destination at
  61                   which to store the production&#39;s value. The callee must honor dst.
  62 
  63     The dst argument provides for a crude form of copy propagation. For example,
</pre>
<hr />
<pre>
 102 
 103     if (UNLIKELY(needsDebugHook())) {
 104         if (value != MixedTriState)
 105             generator.emitDebugHook(this);
 106     }
 107 
 108     if (value == MixedTriState)
 109         ExpressionNode::emitBytecodeInConditionContext(generator, trueTarget, falseTarget, fallThroughMode);
 110     else if (value == TrueTriState &amp;&amp; fallThroughMode == FallThroughMeansFalse)
 111         generator.emitJump(trueTarget);
 112     else if (value == FalseTriState &amp;&amp; fallThroughMode == FallThroughMeansTrue)
 113         generator.emitJump(falseTarget);
 114 
 115     // All other cases are unconditional fall-throughs, like &quot;if (true)&quot;.
 116 }
 117 
 118 RegisterID* ConstantNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 119 {
 120     if (dst == generator.ignoredResult())
 121         return 0;
<span class="line-modified"> 122     JSValue constant = jsValue(generator);</span>
<span class="line-added"> 123     if (UNLIKELY(!constant)) {</span>
<span class="line-added"> 124         // This can happen if we try to parse a string or BigInt so enormous that we OOM.</span>
<span class="line-added"> 125         return generator.emitThrowExpressionTooDeepException();</span>
<span class="line-added"> 126     }</span>
<span class="line-added"> 127     return generator.emitLoad(dst, constant);</span>
 128 }
 129 
 130 JSValue StringNode::jsValue(BytecodeGenerator&amp; generator) const
 131 {
 132     return generator.addStringConstant(m_value);
 133 }
 134 
 135 JSValue BigIntNode::jsValue(BytecodeGenerator&amp; generator) const
 136 {
 137     return generator.addBigIntConstant(m_value, m_radix, m_sign);
 138 }
 139 
 140 // ------------------------------ NumberNode ----------------------------------
 141 
 142 RegisterID* NumberNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 143 {
 144     if (dst == generator.ignoredResult())
 145         return nullptr;
 146     return generator.emitLoad(dst, jsValue(generator), isIntegerNode() ? SourceCodeRepresentation::Integer : SourceCodeRepresentation::Double);
 147 }
</pre>
<hr />
<pre>
 157     ASSERT(flags.hasValue());
 158     RegExp* regExp = RegExp::create(generator.vm(), m_pattern.string(), flags.value());
 159     if (regExp-&gt;isValid())
 160         return generator.emitNewRegExp(generator.finalDestination(dst), regExp);
 161 
 162     const char* messageCharacters = regExp-&gt;errorMessage();
 163     const Identifier&amp; message = generator.parserArena().identifierArena().makeIdentifier(generator.vm(), bitwise_cast&lt;const LChar*&gt;(messageCharacters), strlen(messageCharacters));
 164     generator.emitThrowStaticError(ErrorType::SyntaxError, message);
 165     return generator.emitLoad(generator.finalDestination(dst), jsUndefined());
 166 }
 167 
 168 // ------------------------------ ThisNode -------------------------------------
 169 
 170 RegisterID* ThisNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 171 {
 172     generator.ensureThis();
 173     if (dst == generator.ignoredResult())
 174         return 0;
 175 
 176     RegisterID* result = generator.move(dst, generator.thisRegister());
<span class="line-modified"> 177     static const unsigned thisLength = strlen(&quot;this&quot;);</span>
<span class="line-modified"> 178     generator.emitProfileType(generator.thisRegister(), position(), position() + thisLength);</span>
 179     return result;
 180 }
 181 
 182 // ------------------------------ SuperNode -------------------------------------
 183 
 184 static RegisterID* emitHomeObjectForCallee(BytecodeGenerator&amp; generator)
 185 {
<span class="line-modified"> 186     if ((generator.isDerivedClassContext() || generator.isDerivedConstructorContext()) &amp;&amp; generator.parseMode() != SourceParseMode::InstanceFieldInitializerMode) {</span>
 187         RegisterID* derivedConstructor = generator.emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();
 188         return generator.emitGetById(generator.newTemporary(), derivedConstructor, generator.propertyNames().builtinNames().homeObjectPrivateName());
 189     }
 190 
 191     RegisterID callee;
 192     callee.setIndex(CallFrameSlot::callee);
 193     return generator.emitGetById(generator.newTemporary(), &amp;callee, generator.propertyNames().builtinNames().homeObjectPrivateName());
 194 }
 195 
 196 static RegisterID* emitSuperBaseForCallee(BytecodeGenerator&amp; generator)
 197 {
 198     RefPtr&lt;RegisterID&gt; homeObject = emitHomeObjectForCallee(generator);
 199     return generator.emitGetById(generator.newTemporary(), homeObject.get(), generator.propertyNames().underscoreProto);
 200 }
 201 
 202 static RegisterID* emitGetSuperFunctionForConstruct(BytecodeGenerator&amp; generator)
 203 {
 204     if (generator.isDerivedConstructorContext())
 205         return generator.emitGetById(generator.newTemporary(), generator.emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment(), generator.propertyNames().underscoreProto);
 206 
 207     RegisterID callee;
 208     callee.setIndex(CallFrameSlot::callee);
 209     return generator.emitGetById(generator.newTemporary(), &amp;callee, generator.propertyNames().underscoreProto);
 210 }
 211 
 212 RegisterID* SuperNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 213 {
 214     RegisterID* result = emitSuperBaseForCallee(generator);
 215     return generator.move(generator.finalDestination(dst), result);
 216 }
 217 
 218 // ------------------------------ ImportNode -------------------------------------
 219 
 220 RegisterID* ImportNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 221 {
<span class="line-modified"> 222     RefPtr&lt;RegisterID&gt; importModule = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::importModule);</span>
 223     CallArguments arguments(generator, nullptr, 1);
 224     generator.emitLoad(arguments.thisRegister(), jsUndefined());
 225     generator.emitNode(arguments.argumentRegister(0), m_expr);
 226     return generator.emitCall(generator.finalDestination(dst, importModule.get()), importModule.get(), NoExpectedFunction, arguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);
 227 }
 228 
 229 // ------------------------------ NewTargetNode ----------------------------------
 230 
 231 RegisterID* NewTargetNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 232 {
 233     if (dst == generator.ignoredResult())
 234         return nullptr;
 235 
 236     return generator.move(dst, generator.newTarget());
 237 }
 238 
 239 // ------------------------------ ImportMetaNode ---------------------------------
 240 
 241 RegisterID* ImportMetaNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 242 {
 243     return generator.emitNode(dst, m_expr);
 244 }
 245 
 246 // ------------------------------ ResolveNode ----------------------------------
 247 
 248 bool ResolveNode::isPure(BytecodeGenerator&amp; generator) const
 249 {
 250     return generator.variable(m_ident).offset().isStack();
 251 }
 252 
 253 RegisterID* ResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 254 {
 255     Variable var = generator.variable(m_ident);
 256     if (RegisterID* local = var.local()) {
 257         generator.emitTDZCheckIfNecessary(var, local, nullptr);
 258         if (dst == generator.ignoredResult())
 259             return nullptr;
 260 
<span class="line-modified"> 261         generator.emitProfileType(local, var, m_position, m_position + m_ident.length());</span>
 262         return generator.move(dst, local);
 263     }
 264 
 265     JSTextPosition divot = m_start + m_ident.length();
 266     generator.emitExpressionInfo(divot, m_start, divot);
 267     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(dst, var);
 268     RegisterID* finalDest = generator.finalDestination(dst);
 269     RefPtr&lt;RegisterID&gt; uncheckedResult = generator.newTemporary();
 270     generator.emitGetFromScope(uncheckedResult.get(), scope.get(), var, ThrowIfNotFound);
 271     generator.emitTDZCheckIfNecessary(var, uncheckedResult.get(), nullptr);
 272     generator.move(finalDest, uncheckedResult.get());
<span class="line-modified"> 273     generator.emitProfileType(finalDest, var, m_position, m_position + m_ident.length());</span>
 274     return finalDest;
 275 }
 276 
 277 // ------------------------------ TemplateStringNode -----------------------------------
 278 
 279 RegisterID* TemplateStringNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 280 {
 281     if (dst == generator.ignoredResult())
 282         return nullptr;
 283     ASSERT(cooked());
 284     return generator.emitLoad(dst, JSValue(generator.addStringConstant(*cooked())));
 285 }
 286 
 287 // ------------------------------ TemplateLiteralNode -----------------------------------
 288 
 289 RegisterID* TemplateLiteralNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 290 {
 291     if (!m_templateExpressions) {
 292         TemplateStringNode* templateString = m_templateStrings-&gt;value();
 293         ASSERT_WITH_MESSAGE(!m_templateStrings-&gt;next(), &quot;Only one template element exists because there&#39;s no expression in a given template literal.&quot;);
</pre>
<hr />
<pre>
 530 
 531 RegisterID* ObjectLiteralNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 532 {
 533     if (!m_list) {
 534         if (dst == generator.ignoredResult())
 535             return 0;
 536         return generator.emitNewObject(generator.finalDestination(dst));
 537     }
 538     RefPtr&lt;RegisterID&gt; newObj = generator.emitNewObject(generator.tempDestination(dst));
 539     generator.emitNode(newObj.get(), m_list);
 540     return generator.move(dst, newObj.get());
 541 }
 542 
 543 // ------------------------------ PropertyListNode -----------------------------
 544 
 545 static inline void emitPutHomeObject(BytecodeGenerator&amp; generator, RegisterID* function, RegisterID* homeObject)
 546 {
 547     generator.emitPutById(function, generator.propertyNames().builtinNames().homeObjectPrivateName(), homeObject);
 548 }
 549 
<span class="line-modified"> 550 RegisterID* PropertyListNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dstOrConstructor, RegisterID* prototype, Vector&lt;JSTextPosition&gt;* instanceFieldLocations)</span>
 551 {
 552     // Fast case: this loop just handles regular value properties.
 553     PropertyListNode* p = this;
 554     RegisterID* dst = nullptr;
 555     for (; p &amp;&amp; (p-&gt;m_node-&gt;m_type &amp; PropertyNode::Constant); p = p-&gt;m_next) {
 556         dst = p-&gt;m_node-&gt;isInstanceClassProperty() ? prototype : dstOrConstructor;
<span class="line-added"> 557 </span>
<span class="line-added"> 558         if (p-&gt;isComputedClassField())</span>
<span class="line-added"> 559             emitSaveComputedFieldName(generator, *p-&gt;m_node);</span>
<span class="line-added"> 560 </span>
<span class="line-added"> 561         if (p-&gt;isInstanceClassField()) {</span>
<span class="line-added"> 562             ASSERT(instanceFieldLocations);</span>
<span class="line-added"> 563             instanceFieldLocations-&gt;append(p-&gt;position());</span>
<span class="line-added"> 564             continue;</span>
<span class="line-added"> 565         }</span>
<span class="line-added"> 566 </span>
 567         emitPutConstantProperty(generator, dst, *p-&gt;m_node);
 568     }
 569 
 570     // Were there any get/set properties?
 571     if (p) {
 572         // Build a list of getter/setter pairs to try to put them at the same time. If we encounter
 573         // a computed property or a spread, just emit everything as that may override previous values.
 574         bool canOverrideProperties = false;
 575 
 576         typedef std::pair&lt;PropertyNode*, PropertyNode*&gt; GetterSetterPair;
 577         typedef HashMap&lt;UniquedStringImpl*, GetterSetterPair, IdentifierRepHash&gt; GetterSetterMap;
 578         GetterSetterMap instanceMap;
 579         GetterSetterMap staticMap;
 580 
 581         // Build a map, pairing get/set values together.
 582         for (PropertyListNode* q = p; q; q = q-&gt;m_next) {
 583             PropertyNode* node = q-&gt;m_node;
 584             if (node-&gt;m_type &amp; PropertyNode::Computed || node-&gt;m_type &amp; PropertyNode::Spread) {
 585                 canOverrideProperties = true;
 586                 break;
</pre>
<hr />
<pre>
 594             GetterSetterMap&amp; map = node-&gt;isStaticClassProperty() ? staticMap : instanceMap;
 595             GetterSetterMap::AddResult result = map.add(node-&gt;name()-&gt;impl(), pair);
 596             auto&amp; resultPair = result.iterator-&gt;value;
 597             if (!result.isNewEntry) {
 598                 if (resultPair.first-&gt;m_type == node-&gt;m_type) {
 599                     resultPair.first-&gt;setIsOverriddenByDuplicate();
 600                     resultPair.first = node;
 601                 } else {
 602                     if (resultPair.second)
 603                         resultPair.second-&gt;setIsOverriddenByDuplicate();
 604                     resultPair.second = node;
 605                 }
 606             }
 607         }
 608 
 609         // Iterate over the remaining properties in the list.
 610         for (; p; p = p-&gt;m_next) {
 611             PropertyNode* node = p-&gt;m_node;
 612             dst = node-&gt;isInstanceClassProperty() ? prototype : dstOrConstructor;
 613 
<span class="line-added"> 614             if (p-&gt;isComputedClassField())</span>
<span class="line-added"> 615                 emitSaveComputedFieldName(generator, *p-&gt;m_node);</span>
<span class="line-added"> 616 </span>
<span class="line-added"> 617             if (p-&gt;isInstanceClassField()) {</span>
<span class="line-added"> 618                 ASSERT(instanceFieldLocations);</span>
<span class="line-added"> 619                 ASSERT(node-&gt;m_type &amp; PropertyNode::Constant);</span>
<span class="line-added"> 620                 instanceFieldLocations-&gt;append(p-&gt;position());</span>
<span class="line-added"> 621                 continue;</span>
<span class="line-added"> 622             }</span>
<span class="line-added"> 623 </span>
 624             // Handle regular values.
 625             if (node-&gt;m_type &amp; PropertyNode::Constant) {
 626                 emitPutConstantProperty(generator, dst, *node);
 627                 continue;
 628             } else if (node-&gt;m_type &amp; PropertyNode::Spread) {
 629                 generator.emitNode(dst, node-&gt;m_assign);
 630                 continue;
 631             }
 632 
 633             RefPtr&lt;RegisterID&gt; value = generator.emitNode(node-&gt;m_assign);
 634             bool needsSuperBinding = node-&gt;needsSuperBinding();
 635             if (needsSuperBinding)
 636                 emitPutHomeObject(generator, value.get(), dst);
 637 
 638             unsigned attributes = node-&gt;isClassProperty() ? (PropertyAttribute::Accessor | PropertyAttribute::DontEnum) : static_cast&lt;unsigned&gt;(PropertyAttribute::Accessor);
 639 
 640             ASSERT(node-&gt;m_type &amp; (PropertyNode::Getter | PropertyNode::Setter));
 641 
 642             // This is a get/set property which may be overridden by a computed property or spread later.
 643             if (canOverrideProperties) {
</pre>
<hr />
<pre>
 725         generator.emitSetFunctionNameIfNeeded(node.m_assign, value.get(), propertyNameRegister.get());
 726         generator.emitCallDefineProperty(newObj, propertyNameRegister.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable, m_position);
 727         return;
 728     }
 729     if (const auto* identifier = node.name()) {
 730         Optional&lt;uint32_t&gt; optionalIndex = parseIndex(*identifier);
 731         if (!optionalIndex) {
 732             generator.emitDirectPutById(newObj, *identifier, value.get(), node.putType());
 733             return;
 734         }
 735 
 736         RefPtr&lt;RegisterID&gt; index = generator.emitLoad(nullptr, jsNumber(optionalIndex.value()));
 737         generator.emitDirectPutByVal(newObj, index.get(), value.get());
 738         return;
 739     }
 740     RefPtr&lt;RegisterID&gt; propertyName = generator.emitNode(node.m_expression);
 741     generator.emitSetFunctionNameIfNeeded(node.m_assign, value.get(), propertyName.get());
 742     generator.emitDirectPutByVal(newObj, propertyName.get(), value.get());
 743 }
 744 
<span class="line-added"> 745 void PropertyListNode::emitSaveComputedFieldName(BytecodeGenerator&amp; generator, PropertyNode&amp; node)</span>
<span class="line-added"> 746 {</span>
<span class="line-added"> 747     ASSERT(node.isComputedClassField());</span>
<span class="line-added"> 748     RefPtr&lt;RegisterID&gt; propertyExpr;</span>
<span class="line-added"> 749 </span>
<span class="line-added"> 750     // The &#39;name&#39; refers to a synthetic numeric variable name in the private name scope, where the property key is saved for later use.</span>
<span class="line-added"> 751     const Identifier&amp; description = *node.name();</span>
<span class="line-added"> 752     Variable var = generator.variable(description);</span>
<span class="line-added"> 753     ASSERT(!var.local());</span>
<span class="line-added"> 754 </span>
<span class="line-added"> 755     propertyExpr = generator.emitNode(node.m_expression);</span>
<span class="line-added"> 756     RegisterID* propertyName = generator.emitToPropertyKey(generator.newTemporary(), propertyExpr.get());</span>
<span class="line-added"> 757 </span>
<span class="line-added"> 758     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);</span>
<span class="line-added"> 759     generator.emitPutToScope(scope.get(), var, propertyName, ThrowIfNotFound, InitializationMode::ConstInitialization);</span>
<span class="line-added"> 760 }</span>
<span class="line-added"> 761 </span>
 762 // ------------------------------ BracketAccessorNode --------------------------------
 763 
 764 static bool isNonIndexStringElement(ExpressionNode&amp; element)
 765 {
 766     return element.isString() &amp;&amp; !parseIndex(static_cast&lt;StringNode&amp;&gt;(element).value());
 767 }
 768 
 769 RegisterID* BracketAccessorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 770 {
 771     if (m_base-&gt;isSuperNode()) {
 772         RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
 773         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 774         RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
 775 
 776         if (isNonIndexStringElement(*m_subscript)) {
 777             const Identifier&amp; id = static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value();
 778             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 779             generator.emitGetById(finalDest.get(), superBase.get(), thisValue.get(), id);
 780         } else  {
 781             RefPtr&lt;RegisterID&gt; subscript = generator.emitNodeForProperty(m_subscript);
</pre>
<hr />
<pre>
 949         ASSERT(generator.isConstructor() || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 950         ASSERT(generator.constructorKind() == ConstructorKind::Extends || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 951         RegisterID* ret = generator.emitConstruct(returnValue.get(), func.get(), generator.newTarget(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd());
 952 
 953         bool isConstructorKindDerived = generator.constructorKind() == ConstructorKind::Extends;
 954         bool doWeUseArrowFunctionInConstructor = isConstructorKindDerived &amp;&amp; generator.needsToUpdateArrowFunctionContext();
 955 
 956         if (generator.isDerivedConstructorContext() || (doWeUseArrowFunctionInConstructor &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction()))
 957             generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
 958 
 959         Ref&lt;Label&gt; thisIsEmptyLabel = generator.newLabel();
 960         generator.emitJumpIfTrue(generator.emitIsEmpty(generator.newTemporary(), generator.thisRegister()), thisIsEmptyLabel.get());
 961         generator.emitThrowReferenceError(&quot;&#39;super()&#39; can&#39;t be called more than once in a constructor.&quot;_s);
 962         generator.emitLabel(thisIsEmptyLabel.get());
 963 
 964         generator.move(generator.thisRegister(), ret);
 965 
 966         if (generator.isDerivedConstructorContext() || doWeUseArrowFunctionInConstructor)
 967             generator.emitPutThisToArrowFunctionContextScope();
 968 
<span class="line-added"> 969         // Initialize instance fields after super-call.</span>
<span class="line-added"> 970         if (Options::useClassFields() &amp;&amp; generator.needsClassFieldInitializer() == NeedsClassFieldInitializer::Yes) {</span>
<span class="line-added"> 971             ASSERT(generator.isConstructor() || generator.isDerivedConstructorContext());</span>
<span class="line-added"> 972             func = generator.emitLoadDerivedConstructor();</span>
<span class="line-added"> 973             generator.emitInstanceFieldInitializationIfNeeded(generator.thisRegister(), func.get(), divot(), divotStart(), divotEnd());</span>
<span class="line-added"> 974         }</span>
<span class="line-added"> 975 </span>
 976         return ret;
 977     }
 978 
 979     RefPtr&lt;RegisterID&gt; func = generator.emitNode(m_expr);
 980     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 981     if (isOptionalChainBase())
 982         generator.emitOptionalCheck(func.get());
 983 
 984     CallArguments callArguments(generator, m_args);
 985     generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 986     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 987     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
 988     return ret;
 989 }
 990 
 991 // ------------------------------ FunctionCallResolveNode ----------------------------------
 992 
 993 RegisterID* FunctionCallResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 994 {
<span class="line-modified"> 995     if (!ASSERT_ENABLED) {</span>
<span class="line-modified"> 996         if (UNLIKELY(m_ident == generator.vm().propertyNames-&gt;builtinNames().assertPrivateName()))</span>
 997             return generator.move(dst, generator.emitLoad(nullptr, jsUndefined()));
 998     }
 999 
1000     ExpectedFunction expectedFunction = generator.expectedFunctionForIdentifier(m_ident);
1001 
1002     Variable var = generator.variable(m_ident);
1003     RefPtr&lt;RegisterID&gt; local = var.local();
1004     RefPtr&lt;RegisterID&gt; func;
1005     if (local) {
1006         generator.emitTDZCheckIfNecessary(var, local.get(), nullptr);
1007         func = generator.move(generator.tempDestination(dst), local.get());
1008     } else
1009         func = generator.newTemporary();
1010     CallArguments callArguments(generator, m_args);
1011 
1012     if (local) {
1013         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
1014         // This passes NoExpectedFunction because we expect that if the function is in a
1015         // local variable, then it&#39;s not one of our built-in constructors.
1016         expectedFunction = NoExpectedFunction;
</pre>
<hr />
<pre>
1020         generator.move(
1021             callArguments.thisRegister(),
1022             generator.emitResolveScope(callArguments.thisRegister(), var));
1023         generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);
1024         generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);
1025     }
1026 
1027     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
1028     if (isOptionalChainBase())
1029         generator.emitOptionalCheck(func.get());
1030 
1031     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1032     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1033     return ret;
1034 }
1035 
1036 // ------------------------------ BytecodeIntrinsicNode ----------------------------------
1037 
1038 RegisterID* BytecodeIntrinsicNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1039 {
<span class="line-modified">1040     if (m_entry.type() == BytecodeIntrinsicRegistry::Type::Emitter)</span>
<span class="line-added">1041         return (this-&gt;*m_entry.emitter())(generator, dst);</span>
<span class="line-added">1042     if (dst == generator.ignoredResult())</span>
<span class="line-added">1043         return nullptr;</span>
<span class="line-added">1044     return generator.moveLinkTimeConstant(dst, m_entry.linkTimeConstant());</span>
1045 }
1046 
1047 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
1048 {
1049     ArgumentListNode* node = m_args-&gt;m_listNode;
1050     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1051     node = node-&gt;m_next;
1052     ASSERT(node-&gt;m_expr-&gt;isString());
1053     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1054     ASSERT(!node-&gt;m_next);
1055     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), ident);
1056 }
1057 
1058 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirectPrivate(BytecodeGenerator&amp; generator, RegisterID* dst)
1059 {
1060     ArgumentListNode* node = m_args-&gt;m_listNode;
1061     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1062     node = node-&gt;m_next;
1063     ASSERT(node-&gt;m_expr-&gt;isString());
1064     SymbolImpl* symbol = generator.vm().propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());
1065     ASSERT(symbol);
1066     ASSERT(!node-&gt;m_next);
1067     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol));
1068 }
1069 
<span class="line-added">1070 static JSPromise::Field promiseInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">1071 {</span>
<span class="line-added">1072     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">1073     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_promiseFieldFlags)</span>
<span class="line-added">1074         return JSPromise::Field::Flags;</span>
<span class="line-added">1075     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_promiseFieldReactionsOrResult)</span>
<span class="line-added">1076         return JSPromise::Field::ReactionsOrResult;</span>
<span class="line-added">1077     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1078     return JSPromise::Field::Flags;</span>
<span class="line-added">1079 }</span>
<span class="line-added">1080 </span>
<span class="line-added">1081 static JSGenerator::Field generatorInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">1082 {</span>
<span class="line-added">1083     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">1084     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldState)</span>
<span class="line-added">1085         return JSGenerator::Field::State;</span>
<span class="line-added">1086     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldNext)</span>
<span class="line-added">1087         return JSGenerator::Field::Next;</span>
<span class="line-added">1088     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldThis)</span>
<span class="line-added">1089         return JSGenerator::Field::This;</span>
<span class="line-added">1090     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldFrame)</span>
<span class="line-added">1091         return JSGenerator::Field::Frame;</span>
<span class="line-added">1092     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1093     return JSGenerator::Field::State;</span>
<span class="line-added">1094 }</span>
<span class="line-added">1095 </span>
<span class="line-added">1096 static JSAsyncGenerator::Field asyncGeneratorInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">1097 {</span>
<span class="line-added">1098     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">1099     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldState)</span>
<span class="line-added">1100         return JSAsyncGenerator::Field::State;</span>
<span class="line-added">1101     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldNext)</span>
<span class="line-added">1102         return JSAsyncGenerator::Field::Next;</span>
<span class="line-added">1103     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldThis)</span>
<span class="line-added">1104         return JSAsyncGenerator::Field::This;</span>
<span class="line-added">1105     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldFrame)</span>
<span class="line-added">1106         return JSAsyncGenerator::Field::Frame;</span>
<span class="line-added">1107     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_asyncGeneratorFieldSuspendReason)</span>
<span class="line-added">1108         return JSAsyncGenerator::Field::SuspendReason;</span>
<span class="line-added">1109     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_asyncGeneratorFieldQueueFirst)</span>
<span class="line-added">1110         return JSAsyncGenerator::Field::QueueFirst;</span>
<span class="line-added">1111     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_asyncGeneratorFieldQueueLast)</span>
<span class="line-added">1112         return JSAsyncGenerator::Field::QueueLast;</span>
<span class="line-added">1113     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1114     return JSAsyncGenerator::Field::State;</span>
<span class="line-added">1115 }</span>
<span class="line-added">1116 </span>
<span class="line-added">1117 static JSArrayIterator::Field arrayIteratorInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">1118 {</span>
<span class="line-added">1119     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">1120     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_arrayIteratorFieldIndex)</span>
<span class="line-added">1121         return JSArrayIterator::Field::Index;</span>
<span class="line-added">1122     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_arrayIteratorFieldIteratedObject)</span>
<span class="line-added">1123         return JSArrayIterator::Field::IteratedObject;</span>
<span class="line-added">1124     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_arrayIteratorFieldKind)</span>
<span class="line-added">1125         return JSArrayIterator::Field::Kind;</span>
<span class="line-added">1126     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1127     return JSArrayIterator::Field::Index;</span>
<span class="line-added">1128 }</span>
<span class="line-added">1129 </span>
<span class="line-added">1130 static JSStringIterator::Field stringIteratorInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">1131 {</span>
<span class="line-added">1132     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">1133     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_stringIteratorFieldIndex)</span>
<span class="line-added">1134         return JSStringIterator::Field::Index;</span>
<span class="line-added">1135     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_stringIteratorFieldIteratedString)</span>
<span class="line-added">1136         return JSStringIterator::Field::IteratedString;</span>
<span class="line-added">1137     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1138     return JSStringIterator::Field::Index;</span>
<span class="line-added">1139 }</span>
<span class="line-added">1140 </span>
<span class="line-added">1141 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getPromiseInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1142 {</span>
<span class="line-added">1143     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1144     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1145     node = node-&gt;m_next;</span>
<span class="line-added">1146     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1147     unsigned index = static_cast&lt;unsigned&gt;(promiseInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1148     ASSERT(index &lt; JSPromise::numberOfInternalFields);</span>
<span class="line-added">1149     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1150 </span>
<span class="line-added">1151     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">1152 }</span>
<span class="line-added">1153 </span>
<span class="line-added">1154 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getGeneratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1155 {</span>
<span class="line-added">1156     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1157     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1158     node = node-&gt;m_next;</span>
<span class="line-added">1159     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1160     unsigned index = static_cast&lt;unsigned&gt;(generatorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1161     ASSERT(index &lt; JSGenerator::numberOfInternalFields);</span>
<span class="line-added">1162     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1163 </span>
<span class="line-added">1164     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">1165 }</span>
<span class="line-added">1166 </span>
<span class="line-added">1167 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getAsyncGeneratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1168 {</span>
<span class="line-added">1169     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1170     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1171     node = node-&gt;m_next;</span>
<span class="line-added">1172     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1173     unsigned index = static_cast&lt;unsigned&gt;(asyncGeneratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1174     ASSERT(index &lt; JSAsyncGenerator::numberOfInternalFields);</span>
<span class="line-added">1175     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1176 </span>
<span class="line-added">1177     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">1178 }</span>
<span class="line-added">1179 </span>
<span class="line-added">1180 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getArrayIteratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1181 {</span>
<span class="line-added">1182     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1183     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1184     node = node-&gt;m_next;</span>
<span class="line-added">1185     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1186     unsigned index = static_cast&lt;unsigned&gt;(arrayIteratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1187     ASSERT(index &lt; JSArrayIterator::numberOfInternalFields);</span>
<span class="line-added">1188     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1189 </span>
<span class="line-added">1190     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">1191 }</span>
<span class="line-added">1192 </span>
<span class="line-added">1193 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getStringIteratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1194 {</span>
<span class="line-added">1195     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1196     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1197     node = node-&gt;m_next;</span>
<span class="line-added">1198     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1199     unsigned index = static_cast&lt;unsigned&gt;(stringIteratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1200     ASSERT(index &lt; JSStringIterator::numberOfInternalFields);</span>
<span class="line-added">1201     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1202 </span>
<span class="line-added">1203     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">1204 }</span>
<span class="line-added">1205 </span>
1206 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_argument(BytecodeGenerator&amp; generator, RegisterID* dst)
1207 {
1208     ArgumentListNode* node = m_args-&gt;m_listNode;
1209     ASSERT(node-&gt;m_expr-&gt;isNumber());
1210     double value = static_cast&lt;NumberNode*&gt;(node-&gt;m_expr)-&gt;value();
1211     int32_t index = static_cast&lt;int32_t&gt;(value);
1212     ASSERT(value == index);
1213     ASSERT(index &gt;= 0);
1214     ASSERT(!node-&gt;m_next);
1215 
1216     // The body functions of generator and async have different mechanism for arguments.
1217     ASSERT(generator.parseMode() != SourceParseMode::GeneratorBodyMode);
1218     ASSERT(!isAsyncFunctionBodyParseMode(generator.parseMode()));
1219 
1220     return generator.emitGetArgument(generator.finalDestination(dst), index);
1221 }
1222 
1223 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_argumentCount(BytecodeGenerator&amp; generator, RegisterID* dst)
1224 {
1225     ASSERT(!m_args-&gt;m_listNode);
</pre>
<hr />
<pre>
1255 
1256     ASSERT(!node-&gt;m_next);
1257 
1258     return generator.move(dst, generator.emitDirectPutById(base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol), value.get(), PropertyNode::KnownDirect));
1259 }
1260 
1261 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByValDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
1262 {
1263     ArgumentListNode* node = m_args-&gt;m_listNode;
1264     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1265     node = node-&gt;m_next;
1266     RefPtr&lt;RegisterID&gt; index = generator.emitNodeForProperty(node);
1267     node = node-&gt;m_next;
1268     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1269 
1270     ASSERT(!node-&gt;m_next);
1271 
1272     return generator.move(dst, generator.emitDirectPutByVal(base.get(), index.get(), value.get()));
1273 }
1274 
<span class="line-added">1275 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putPromiseInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1276 {</span>
<span class="line-added">1277     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1278     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1279     node = node-&gt;m_next;</span>
<span class="line-added">1280     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1281     unsigned index = static_cast&lt;unsigned&gt;(promiseInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1282     ASSERT(index &lt; JSPromise::numberOfInternalFields);</span>
<span class="line-added">1283     node = node-&gt;m_next;</span>
<span class="line-added">1284     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">1285 </span>
<span class="line-added">1286     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1287 </span>
<span class="line-added">1288     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">1289 }</span>
<span class="line-added">1290 </span>
<span class="line-added">1291 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putGeneratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1292 {</span>
<span class="line-added">1293     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1294     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1295     node = node-&gt;m_next;</span>
<span class="line-added">1296     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1297     unsigned index = static_cast&lt;unsigned&gt;(generatorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1298     ASSERT(index &lt; JSGenerator::numberOfInternalFields);</span>
<span class="line-added">1299     node = node-&gt;m_next;</span>
<span class="line-added">1300     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">1301 </span>
<span class="line-added">1302     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1303 </span>
<span class="line-added">1304     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">1305 }</span>
<span class="line-added">1306 </span>
<span class="line-added">1307 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putAsyncGeneratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1308 {</span>
<span class="line-added">1309     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1310     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1311     node = node-&gt;m_next;</span>
<span class="line-added">1312     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1313     unsigned index = static_cast&lt;unsigned&gt;(asyncGeneratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1314     ASSERT(index &lt; JSAsyncGenerator::numberOfInternalFields);</span>
<span class="line-added">1315     node = node-&gt;m_next;</span>
<span class="line-added">1316     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">1317 </span>
<span class="line-added">1318     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1319 </span>
<span class="line-added">1320     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">1321 }</span>
<span class="line-added">1322 </span>
<span class="line-added">1323 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putArrayIteratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1324 {</span>
<span class="line-added">1325     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1326     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1327     node = node-&gt;m_next;</span>
<span class="line-added">1328     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1329     unsigned index = static_cast&lt;unsigned&gt;(arrayIteratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1330     ASSERT(index &lt; JSArrayIterator::numberOfInternalFields);</span>
<span class="line-added">1331     node = node-&gt;m_next;</span>
<span class="line-added">1332     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">1333 </span>
<span class="line-added">1334     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1335 </span>
<span class="line-added">1336     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">1337 }</span>
<span class="line-added">1338 </span>
<span class="line-added">1339 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putStringIteratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1340 {</span>
<span class="line-added">1341     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1342     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1343     node = node-&gt;m_next;</span>
<span class="line-added">1344     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1345     unsigned index = static_cast&lt;unsigned&gt;(stringIteratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1346     ASSERT(index &lt; JSStringIterator::numberOfInternalFields);</span>
<span class="line-added">1347     node = node-&gt;m_next;</span>
<span class="line-added">1348     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">1349 </span>
<span class="line-added">1350     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1351 </span>
<span class="line-added">1352     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">1353 }</span>
<span class="line-added">1354 </span>
1355 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_tailCallForwardArguments(BytecodeGenerator&amp; generator, RegisterID* dst)
1356 {
1357     ArgumentListNode* node = m_args-&gt;m_listNode;
1358     RefPtr&lt;RegisterID&gt; function = generator.emitNode(node);
1359     node = node-&gt;m_next;
1360     RefPtr&lt;RegisterID&gt; thisRegister = generator.emitNode(node);
1361     ASSERT(!node-&gt;m_next);
1362 
1363     RefPtr&lt;RegisterID&gt; finalDst = generator.finalDestination(dst);
1364     return generator.emitCallForwardArgumentsInTailPosition(finalDst.get(), function.get(), thisRegister.get(), generator.newTemporary(), 0, divot(), divotStart(), divotEnd(), DebuggableCall::No);
1365 }
1366 
1367 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_throwTypeError(BytecodeGenerator&amp; generator, RegisterID* dst)
1368 {
1369     ArgumentListNode* node = m_args-&gt;m_listNode;
1370     ASSERT(!node-&gt;m_next);
1371     if (node-&gt;m_expr-&gt;isString()) {
1372         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1373         generator.emitThrowTypeError(ident);
1374     } else {
</pre>
<hr />
<pre>
1449     }
1450     return generator.move(dst, generator.emitToObject(temp.get(), src.get(), generator.vm().propertyNames-&gt;emptyIdentifier));
1451 }
1452 
1453 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_idWithProfile(BytecodeGenerator&amp; generator, RegisterID* dst)
1454 {
1455     ArgumentListNode* node = m_args-&gt;m_listNode;
1456     RefPtr&lt;RegisterID&gt; idValue = generator.newTemporary();
1457     generator.emitNode(idValue.get(), node);
1458     SpeculatedType speculation = SpecNone;
1459     while (node-&gt;m_next) {
1460         node = node-&gt;m_next;
1461         ASSERT(node-&gt;m_expr-&gt;isString());
1462         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1463         speculation |= speculationFromString(ident.utf8().data());
1464     }
1465 
1466     return generator.move(dst, generator.emitIdWithProfile(idValue.get(), speculation));
1467 }
1468 
<span class="line-modified">1469 #define CREATE_INTRINSIC_FOR_BRAND_CHECK(lowerName, upperName) \</span>
<span class="line-modified">1470     RegisterID* BytecodeIntrinsicNode::emit_intrinsic_##lowerName(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst) \</span>
<span class="line-modified">1471     {                                                                                                                      \</span>
<span class="line-modified">1472         ArgumentListNode* node = m_args-&gt;m_listNode;                                                                       \</span>
<span class="line-modified">1473         RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);                                                                 \</span>
<span class="line-modified">1474         ASSERT(!node-&gt;m_next);                                                                                             \</span>
<span class="line-modified">1475         return generator.move(dst, generator.emit##upperName(generator.tempDestination(dst), src.get()));                  \</span>
<span class="line-modified">1476     }</span>



























1477 
<span class="line-modified">1478 CREATE_INTRINSIC_FOR_BRAND_CHECK(isObject, IsObject)</span>
<span class="line-modified">1479 CREATE_INTRINSIC_FOR_BRAND_CHECK(isJSArray, IsJSArray)</span>
<span class="line-modified">1480 CREATE_INTRINSIC_FOR_BRAND_CHECK(isProxyObject, IsProxyObject)</span>
<span class="line-modified">1481 CREATE_INTRINSIC_FOR_BRAND_CHECK(isDerivedArray, IsDerivedArray)</span>
<span class="line-modified">1482 CREATE_INTRINSIC_FOR_BRAND_CHECK(isGenerator, IsGenerator)</span>
<span class="line-added">1483 CREATE_INTRINSIC_FOR_BRAND_CHECK(isAsyncGenerator, IsAsyncGenerator)</span>
<span class="line-added">1484 CREATE_INTRINSIC_FOR_BRAND_CHECK(isPromise, IsPromise)</span>
<span class="line-added">1485 CREATE_INTRINSIC_FOR_BRAND_CHECK(isRegExpObject, IsRegExpObject)</span>
<span class="line-added">1486 CREATE_INTRINSIC_FOR_BRAND_CHECK(isMap, IsMap)</span>
<span class="line-added">1487 CREATE_INTRINSIC_FOR_BRAND_CHECK(isSet, IsSet)</span>
<span class="line-added">1488 CREATE_INTRINSIC_FOR_BRAND_CHECK(isStringIterator, IsStringIterator)</span>
<span class="line-added">1489 CREATE_INTRINSIC_FOR_BRAND_CHECK(isArrayIterator, IsArrayIterator)</span>
<span class="line-added">1490 CREATE_INTRINSIC_FOR_BRAND_CHECK(isUndefinedOrNull, IsUndefinedOrNull)</span>
1491 
<span class="line-modified">1492 #undef CREATE_INTRINSIC_FOR_BRAND_CHECK</span>

1493 
<span class="line-modified">1494 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_newArrayWithSize(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
1495 {
1496     ArgumentListNode* node = m_args-&gt;m_listNode;
<span class="line-modified">1497     RefPtr&lt;RegisterID&gt; size = generator.emitNode(node);</span>
1498     ASSERT(!node-&gt;m_next);
1499 
<span class="line-modified">1500     RefPtr&lt;RegisterID&gt; finalDestination = generator.finalDestination(dst);</span>
<span class="line-added">1501     generator.emitNewArrayWithSize(finalDestination.get(), size.get());</span>
<span class="line-added">1502     return finalDestination.get();</span>
1503 }
1504 
<span class="line-modified">1505 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_createPromise(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
1506 {
1507     ArgumentListNode* node = m_args-&gt;m_listNode;
<span class="line-modified">1508     RefPtr&lt;RegisterID&gt; newTarget = generator.emitNode(node);</span>
<span class="line-added">1509     node = node-&gt;m_next;</span>
<span class="line-added">1510     bool isInternalPromise = static_cast&lt;BooleanNode*&gt;(node-&gt;m_expr)-&gt;value();</span>
1511     ASSERT(!node-&gt;m_next);
1512 
<span class="line-modified">1513     return generator.emitCreatePromise(generator.finalDestination(dst), newTarget.get(), isInternalPromise);</span>
1514 }
1515 
<span class="line-modified">1516 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_newPromise(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
1517 {
<span class="line-modified">1518     ASSERT(!m_args-&gt;m_listNode);</span>
<span class="line-modified">1519     RefPtr&lt;RegisterID&gt; finalDestination = generator.finalDestination(dst);</span>
<span class="line-modified">1520     bool isInternalPromise = false;</span>
<span class="line-modified">1521     generator.emitNewPromise(finalDestination.get(), isInternalPromise);</span>
<span class="line-modified">1522     return finalDestination.get();</span>
1523 }
1524 
<span class="line-modified">1525 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_createArgumentsButterfly(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
1526 {
<span class="line-modified">1527     ASSERT(!m_args-&gt;m_listNode);</span>
<span class="line-modified">1528     return generator.emitCreateArgumentsButterfly(generator.finalDestination(dst));</span>





1529 }
1530 
1531 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_defineEnumerableWritableConfigurableDataProperty(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1532 {
1533     ArgumentListNode* node = m_args-&gt;m_listNode;
1534     RefPtr&lt;RegisterID&gt; newObj = generator.emitNode(node);
1535     node = node-&gt;m_next;
1536     RefPtr&lt;RegisterID&gt; propertyNameRegister = generator.emitNode(node);
1537     node = node-&gt;m_next;
1538     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1539     ASSERT(!node-&gt;m_next);
1540 
1541     generator.emitCallDefineProperty(newObj.get(), propertyNameRegister.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable | BytecodeGenerator::PropertyEnumerable, m_position);
1542     return dst;
1543 }
1544 
1545 #define JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS(name) \
1546     RegisterID* BytecodeIntrinsicNode::emit_intrinsic_##name(BytecodeGenerator&amp; generator, RegisterID* dst) \
1547     { \
1548         ASSERT(!m_args); \
</pre>
<hr />
<pre>
1839         generator.emitLabel(realCall.get());
1840         CallArguments callArguments(generator, m_args);
1841         generator.move(callArguments.thisRegister(), base.get());
1842         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1843         generator.emitLabel(end.get());
1844     }
1845     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1846     return returnValue.get();
1847 }
1848 
1849 // ------------------------------ PostfixNode ----------------------------------
1850 
1851 static RegisterID* emitIncOrDec(BytecodeGenerator&amp; generator, RegisterID* srcDst, Operator oper)
1852 {
1853     return (oper == OpPlusPlus) ? generator.emitInc(srcDst) : generator.emitDec(srcDst);
1854 }
1855 
1856 static RegisterID* emitPostIncOrDec(BytecodeGenerator&amp; generator, RegisterID* dst, RegisterID* srcDst, Operator oper)
1857 {
1858     if (dst == srcDst)
<span class="line-modified">1859         return generator.emitToNumeric(generator.finalDestination(dst), srcDst);</span>
<span class="line-modified">1860     RefPtr&lt;RegisterID&gt; tmp = generator.emitToNumeric(generator.newTemporary(), srcDst);</span>
<span class="line-modified">1861     RefPtr&lt;RegisterID&gt; result = generator.tempDestination(srcDst);</span>
<span class="line-added">1862     generator.move(result.get(), tmp.get());</span>
<span class="line-added">1863     emitIncOrDec(generator, result.get(), oper);</span>
<span class="line-added">1864     generator.move(srcDst, result.get());</span>
1865     return generator.move(dst, tmp.get());
1866 }
1867 
1868 RegisterID* PostfixNode::emitResolve(BytecodeGenerator&amp; generator, RegisterID* dst)
1869 {
1870     if (dst == generator.ignoredResult())
1871         return PrefixNode::emitResolve(generator, dst);
1872 
1873     ASSERT(m_expr-&gt;isResolveNode());
1874     ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(m_expr);
1875     const Identifier&amp; ident = resolve-&gt;identifier();
1876 
1877     Variable var = generator.variable(ident);
1878     if (RegisterID* local = var.local()) {
1879         generator.emitTDZCheckIfNecessary(var, local, nullptr);
1880         RefPtr&lt;RegisterID&gt; localReg = local;
1881         if (var.isReadOnly()) {
1882             generator.emitReadOnlyExceptionIfNeeded(var);
1883             localReg = generator.move(generator.tempDestination(dst), local);
1884         }
</pre>
<hr />
<pre>
2195         return emitResolve(generator, dst);
2196 
2197     if (m_expr-&gt;isBracketAccessorNode())
2198         return emitBracket(generator, dst);
2199 
2200     if (m_expr-&gt;isDotAccessorNode())
2201         return emitDot(generator, dst);
2202 
2203     ASSERT(m_expr-&gt;isFunctionCall());
2204     return emitThrowReferenceError(generator, m_operator == OpPlusPlus
2205         ? &quot;Prefix ++ operator applied to value that is not a reference.&quot;_s
2206         : &quot;Prefix -- operator applied to value that is not a reference.&quot;_s);
2207 }
2208 
2209 // ------------------------------ Unary Operation Nodes -----------------------------------
2210 
2211 RegisterID* UnaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2212 {
2213     RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
2214     generator.emitExpressionInfo(position(), position(), position());
<span class="line-modified">2215     return generator.emitUnaryOp(opcodeID(), generator.finalDestination(dst), src.get(), m_expr-&gt;resultDescriptor());</span>
2216 }
2217 
2218 // ------------------------------ UnaryPlusNode -----------------------------------
2219 
2220 RegisterID* UnaryPlusNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2221 {
2222     ASSERT(opcodeID() == op_to_number);
2223     RefPtr&lt;RegisterID&gt; src = generator.emitNode(expr());
2224     generator.emitExpressionInfo(position(), position(), position());
2225     return generator.emitToNumber(generator.finalDestination(dst), src.get());
2226 }
2227 
2228 // ------------------------------ LogicalNotNode -----------------------------------
2229 
2230 void LogicalNotNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
2231 {
2232     if (UNLIKELY(needsDebugHook()))
2233         generator.emitDebugHook(this);
2234 
2235     // Reverse the true and false targets.
</pre>
<hr />
<pre>
3042 void BlockNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3043 {
3044     if (!m_statements)
3045         return;
3046     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested);
3047     m_statements-&gt;emitBytecode(generator, dst);
3048     generator.popLexicalScope(this);
3049 }
3050 
3051 // ------------------------------ EmptyStatementNode ---------------------------
3052 
3053 void EmptyStatementNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
3054 {
3055     RELEASE_ASSERT(needsDebugHook());
3056 }
3057 
3058 // ------------------------------ DebuggerStatementNode ---------------------------
3059 
3060 void DebuggerStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3061 {
<span class="line-modified">3062     generator.emitDebugHook(DidReachDebuggerStatement, position());</span>
3063 }
3064 
3065 // ------------------------------ ExprStatementNode ----------------------------
3066 
3067 void ExprStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3068 {
3069     ASSERT(m_expr);
3070     generator.emitNode(dst, m_expr);
3071 }
3072 
3073 // ------------------------------ DeclarationStatement ----------------------------
3074 
3075 void DeclarationStatement::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3076 {
3077     ASSERT(m_expr);
3078     generator.emitNode(m_expr);
3079 }
3080 
3081 // ------------------------------ EmptyVarExpression ----------------------------
3082 
3083 RegisterID* EmptyVarExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3084 {
3085     // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
3086     if (!generator.shouldEmitTypeProfilerHooks())
3087         return nullptr;
3088 
3089     Variable var = generator.variable(m_ident);
3090     if (RegisterID* local = var.local())
<span class="line-modified">3091         generator.emitProfileType(local, var, position(), position() + m_ident.length());</span>
3092     else {
3093         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
3094         RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, DoNotThrowIfNotFound);
<span class="line-modified">3095         generator.emitProfileType(value.get(), var, position(), position() + m_ident.length());</span>
3096     }
3097 
3098     return nullptr;
3099 }
3100 
3101 // ------------------------------ EmptyLetExpression ----------------------------
3102 
3103 RegisterID* EmptyLetExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3104 {
3105     // Lexical declarations like &#39;let&#39; must move undefined into their variables so we don&#39;t
3106     // get TDZ errors for situations like this: `let x; x;`
3107     Variable var = generator.variable(m_ident);
3108     if (RegisterID* local = var.local()) {
3109         generator.emitLoad(local, jsUndefined());
<span class="line-modified">3110         generator.emitProfileType(local, var, position(), position() + m_ident.length());</span>
3111     } else {
3112         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
3113         RefPtr&lt;RegisterID&gt; value = generator.emitLoad(nullptr, jsUndefined());
3114         generator.emitPutToScope(scope.get(), var, value.get(), generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::Initialization);
<span class="line-modified">3115         generator.emitProfileType(value.get(), var, position(), position() + m_ident.length());</span>
3116     }
3117 
3118     generator.liftTDZCheckIfPossible(var);
3119 
3120     // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
3121     return nullptr;
3122 }
3123 
3124 // ------------------------------ IfElseNode ---------------------------------------
3125 
3126 static inline StatementNode* singleStatement(StatementNode* statementNode)
3127 {
3128     if (statementNode-&gt;isBlock())
3129         return static_cast&lt;BlockNode*&gt;(statementNode)-&gt;singleStatement();
3130     return statementNode;
3131 }
3132 
3133 bool IfElseNode::tryFoldBreakAndContinue(BytecodeGenerator&amp; generator, StatementNode* ifBlock,
3134     Label*&amp; trueTarget, FallThroughMode&amp; fallThroughMode)
3135 {
</pre>
<hr />
<pre>
3312     return nullptr;
3313 }
3314 
3315 void ForInNode::emitLoopHeader(BytecodeGenerator&amp; generator, RegisterID* propertyName)
3316 {
3317     auto lambdaEmitResolveVariable = [&amp;] (const Identifier&amp; ident) {
3318         Variable var = generator.variable(ident);
3319         if (RegisterID* local = var.local()) {
3320             if (var.isReadOnly())
3321                 generator.emitReadOnlyExceptionIfNeeded(var);
3322             generator.move(local, propertyName);
3323         } else {
3324             if (generator.isStrictMode())
3325                 generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3326             if (var.isReadOnly())
3327                 generator.emitReadOnlyExceptionIfNeeded(var);
3328             RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
3329             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3330             generator.emitPutToScope(scope.get(), var, propertyName, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
3331         }
<span class="line-modified">3332         generator.emitProfileType(propertyName, var, m_lexpr-&gt;position(), m_lexpr-&gt;position() + ident.length());</span>
3333     };
3334 
3335     if (m_lexpr-&gt;isResolveNode()) {
3336         const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
3337         lambdaEmitResolveVariable(ident);
3338         return;
3339     }
3340 
3341     if (m_lexpr-&gt;isAssignResolveNode()) {
3342         const Identifier&amp; ident = static_cast&lt;AssignResolveNode*&gt;(m_lexpr)-&gt;identifier();
3343         lambdaEmitResolveVariable(ident);
3344         return;
3345     }
3346 
3347     if (m_lexpr-&gt;isDotAccessorNode()) {
3348         DotAccessorNode* assignNode = static_cast&lt;DotAccessorNode*&gt;(m_lexpr);
3349         const Identifier&amp; ident = assignNode-&gt;identifier();
3350         RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3351         generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3352         if (assignNode-&gt;base()-&gt;isSuperNode()) {
</pre>
<hr />
<pre>
3569     RegisterID* forLoopSymbolTable = nullptr;
3570     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested, &amp;forLoopSymbolTable);
3571     auto extractor = scopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;([this, dst](BytecodeGenerator&amp; generator, RegisterID* value)
3572     {
3573         if (m_lexpr-&gt;isResolveNode()) {
3574             const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
3575             Variable var = generator.variable(ident);
3576             if (RegisterID* local = var.local()) {
3577                 if (var.isReadOnly())
3578                     generator.emitReadOnlyExceptionIfNeeded(var);
3579                 generator.move(local, value);
3580             } else {
3581                 if (generator.isStrictMode())
3582                     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3583                 if (var.isReadOnly())
3584                     generator.emitReadOnlyExceptionIfNeeded(var);
3585                 RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
3586                 generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3587                 generator.emitPutToScope(scope.get(), var, value, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
3588             }
<span class="line-modified">3589             generator.emitProfileType(value, var, m_lexpr-&gt;position(), m_lexpr-&gt;position() + ident.length());</span>
3590         } else if (m_lexpr-&gt;isDotAccessorNode()) {
3591             DotAccessorNode* assignNode = static_cast&lt;DotAccessorNode*&gt;(m_lexpr);
3592             const Identifier&amp; ident = assignNode-&gt;identifier();
3593             RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3594 
3595             generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3596             if (assignNode-&gt;base()-&gt;isSuperNode()) {
3597                 RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
3598                 generator.emitPutById(base.get(), thisValue.get(), ident, value);
3599             } else
3600                 generator.emitPutById(base.get(), ident, value);
3601             generator.emitProfileType(value, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3602         } else if (m_lexpr-&gt;isBracketAccessorNode()) {
3603             BracketAccessorNode* assignNode = static_cast&lt;BracketAccessorNode*&gt;(m_lexpr);
3604             RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3605             RegisterID* subscript = generator.emitNodeForProperty(assignNode-&gt;subscript());
3606 
3607             generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3608             if (assignNode-&gt;base()-&gt;isSuperNode()) {
3609                 RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
</pre>
<hr />
<pre>
4152         ASSERT(expr-&gt;isFuncExprNode());
4153         FuncExprNode* funcExpr = static_cast&lt;FuncExprNode*&gt;(expr);
4154 
4155         RefPtr&lt;RegisterID&gt; next = generator.newTemporary();
4156         generator.emitNode(next.get(), funcExpr);
4157 
4158         if (generator.superBinding() == SuperBinding::Needed || (generator.parseMode() == SourceParseMode::AsyncArrowFunctionMode &amp;&amp; generator.isSuperUsedInInnerArrowFunction())) {
4159             RefPtr&lt;RegisterID&gt; homeObject = emitHomeObjectForCallee(generator);
4160             emitPutHomeObject(generator, next.get(), homeObject.get());
4161         }
4162 
4163         if (generator.parseMode() == SourceParseMode::AsyncArrowFunctionMode &amp;&amp; generator.isThisUsedInInnerArrowFunction())
4164             generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
4165 
4166         generator.emitPutGeneratorFields(next.get());
4167 
4168         ASSERT(startOffset() &gt;= lineStartOffset());
4169         generator.emitDebugHook(WillLeaveCallFrame, lastLine(), startOffset(), lineStartOffset());
4170 
4171         // load and call @asyncFunctionResume
<span class="line-modified">4172         RefPtr&lt;RegisterID&gt; asyncFunctionResume = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::asyncFunctionResume);</span>



4173 
4174         CallArguments args(generator, nullptr, 4);
4175         unsigned argumentCount = 0;
4176         generator.emitLoad(args.thisRegister(), jsUndefined());
4177         generator.move(args.argumentRegister(argumentCount++), generator.generatorRegister());
<span class="line-modified">4178         generator.move(args.argumentRegister(argumentCount++), generator.promiseRegister());</span>
4179         generator.emitLoad(args.argumentRegister(argumentCount++), jsUndefined());
<span class="line-modified">4180         generator.emitLoad(args.argumentRegister(argumentCount++), jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::NormalMode)));</span>
4181         // JSTextPosition(int _line, int _offset, int _lineStartOffset)
4182         JSTextPosition divot(firstLine(), startOffset(), lineStartOffset());
4183 
4184         RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
4185         generator.emitCallInTailPosition(result.get(), asyncFunctionResume.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
4186         generator.emitReturn(result.get());
4187         break;
4188     }
4189 
4190     case SourceParseMode::AsyncGeneratorBodyMode:
4191     case SourceParseMode::AsyncArrowFunctionBodyMode:
4192     case SourceParseMode::AsyncFunctionBodyMode:
4193     case SourceParseMode::GeneratorBodyMode: {
4194         Ref&lt;Label&gt; generatorBodyLabel = generator.newLabel();
4195         {
4196             RefPtr&lt;RegisterID&gt; condition = generator.newTemporary();
<span class="line-modified">4197             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::NormalMode))));</span>
4198             generator.emitJumpIfTrue(condition.get(), generatorBodyLabel.get());
4199 
4200             Ref&lt;Label&gt; throwLabel = generator.newLabel();
<span class="line-modified">4201             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::ThrowMode))));</span>
4202             generator.emitJumpIfTrue(condition.get(), throwLabel.get());
4203 
4204             generator.emitReturn(generator.generatorValueRegister());
4205 
4206             generator.emitLabel(throwLabel.get());
4207             generator.emitThrow(generator.generatorValueRegister());
4208         }
4209 
4210         generator.emitLabel(generatorBodyLabel.get());
4211 
4212         emitStatementsBytecode(generator, generator.ignoredResult());
4213 
4214         Ref&lt;Label&gt; done = generator.newLabel();
4215         generator.emitLabel(done.get());
4216         generator.emitReturn(generator.emitLoad(nullptr, jsUndefined()));
4217         break;
4218     }
4219 
4220     default: {
4221         emitStatementsBytecode(generator, generator.ignoredResult());
4222 
4223         StatementNode* singleStatement = this-&gt;singleStatement();
4224         ReturnNode* returnNode = 0;
4225 
4226         // Check for a return statement at the end of a function composed of a single block.
4227         if (singleStatement &amp;&amp; singleStatement-&gt;isBlock()) {
4228             StatementNode* lastStatementInBlock = static_cast&lt;BlockNode*&gt;(singleStatement)-&gt;lastStatement();
4229             if (lastStatementInBlock &amp;&amp; lastStatementInBlock-&gt;isReturnNode())
4230                 returnNode = static_cast&lt;ReturnNode*&gt;(lastStatementInBlock);
4231         }
4232 
4233         // If there is no return we must automatically insert one.
4234         if (!returnNode) {
4235             if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction())
4236                 generator.emitLoadThisFromArrowFunctionLexicalEnvironment(); // Arrow function can invoke &#39;super&#39; in constructor and before leave constructor we need load &#39;this&#39; from lexical arrow function environment
4237 
<span class="line-modified">4238             RegisterID* r0 = nullptr;</span>
<span class="line-added">4239             if (generator.isConstructor() &amp;&amp; generator.constructorKind() != ConstructorKind::Naked)</span>
<span class="line-added">4240                 r0 = generator.thisRegister();</span>
<span class="line-added">4241             else</span>
<span class="line-added">4242                 r0 = generator.emitLoad(0, jsUndefined());</span>
4243             generator.emitProfileType(r0, ProfileTypeBytecodeFunctionReturnStatement); // Do not emit expression info for this profile because it&#39;s not in the user&#39;s source code.
4244             ASSERT(startOffset() &gt;= lineStartOffset());
4245             generator.emitWillLeaveCallFrameDebugHook();
4246             generator.emitReturn(r0);
4247             return;
4248         }
4249         break;
4250     }
4251     }
4252 }
4253 
4254 // ------------------------------ FuncDeclNode ---------------------------------
4255 
4256 void FuncDeclNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
4257 {
4258     generator.hoistSloppyModeFunctionIfNecessary(metadata()-&gt;ident());
4259 }
4260 
4261 // ------------------------------ FuncExprNode ---------------------------------
4262 
</pre>
<hr />
<pre>
4273 }
4274 
4275 // ------------------------------ MethodDefinitionNode ---------------------------------
4276 
4277 RegisterID* MethodDefinitionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4278 {
4279     return generator.emitNewMethodDefinition(generator.finalDestination(dst), this);
4280 }
4281 
4282 // ------------------------------ YieldExprNode --------------------------------
4283 
4284 RegisterID* YieldExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4285 {
4286     if (!delegate()) {
4287         RefPtr&lt;RegisterID&gt; arg = nullptr;
4288         if (argument()) {
4289             arg = generator.newTemporary();
4290             generator.emitNode(arg.get(), argument());
4291         } else
4292             arg = generator.emitLoad(nullptr, jsUndefined());
<span class="line-modified">4293         RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGenerator::AsyncGeneratorSuspendReason::Yield);</span>
4294         if (dst == generator.ignoredResult())
4295             return nullptr;
4296         return generator.move(generator.finalDestination(dst), value.get());
4297     }
4298     RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
4299     generator.emitNode(arg.get(), argument());
4300     RefPtr&lt;RegisterID&gt; value = generator.emitDelegateYield(arg.get(), this);
4301     if (dst == generator.ignoredResult())
4302         return nullptr;
4303     return generator.move(generator.finalDestination(dst), value.get());
4304 }
4305 
4306 // ------------------------------ AwaitExprNode --------------------------------
4307 
4308 RegisterID* AwaitExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4309 {
4310     RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
4311     generator.emitNode(arg.get(), argument());
<span class="line-modified">4312     RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGenerator::AsyncGeneratorSuspendReason::Await);</span>
4313     if (dst == generator.ignoredResult())
4314         return nullptr;
4315     return generator.move(generator.finalDestination(dst), value.get());
4316 }
4317 
<span class="line-added">4318 // ------------------------------ DefineFieldNode ---------------------------------</span>
<span class="line-added">4319 </span>
<span class="line-added">4320 void DefineFieldNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)</span>
<span class="line-added">4321 {</span>
<span class="line-added">4322     RefPtr&lt;RegisterID&gt; value = generator.newTemporary();</span>
<span class="line-added">4323 </span>
<span class="line-added">4324     if (!m_assign)</span>
<span class="line-added">4325         generator.emitLoad(value.get(), jsUndefined());</span>
<span class="line-added">4326     else {</span>
<span class="line-added">4327         generator.emitNode(value.get(), m_assign);</span>
<span class="line-added">4328         if (m_ident)</span>
<span class="line-added">4329             generator.emitSetFunctionNameIfNeeded(m_assign, value.get(), *m_ident);</span>
<span class="line-added">4330     }</span>
<span class="line-added">4331 </span>
<span class="line-added">4332     switch (m_type) {</span>
<span class="line-added">4333     case DefineFieldNode::Type::Name: {</span>
<span class="line-added">4334         // FIXME: Improve performance of public class fields</span>
<span class="line-added">4335         // https://bugs.webkit.org/show_bug.cgi?id=198330</span>
<span class="line-added">4336         RefPtr&lt;RegisterID&gt; propertyName = generator.emitLoad(nullptr, *m_ident);</span>
<span class="line-added">4337         generator.emitCallDefineProperty(generator.thisRegister(), propertyName.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable | BytecodeGenerator::PropertyEnumerable, m_position);</span>
<span class="line-added">4338         break;</span>
<span class="line-added">4339     }</span>
<span class="line-added">4340     case DefineFieldNode::Type::ComputedName: {</span>
<span class="line-added">4341         // FIXME: Improve performance of public class fields</span>
<span class="line-added">4342         // https://bugs.webkit.org/show_bug.cgi?id=198330</span>
<span class="line-added">4343 </span>
<span class="line-added">4344         // For ComputedNames, the expression has already been evaluated earlier during evaluation of a ClassExprNode.</span>
<span class="line-added">4345         // Here, `m_ident` refers to an integer ID in a class lexical scope, containing the value already converted to an Expression.</span>
<span class="line-added">4346         Variable var = generator.variable(*m_ident);</span>
<span class="line-added">4347         ASSERT_WITH_MESSAGE(!var.local(), &quot;Computed names must be stored in captured variables&quot;);</span>
<span class="line-added">4348 </span>
<span class="line-added">4349         generator.emitExpressionInfo(position(), position(), position() + 1);</span>
<span class="line-added">4350         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(generator.newTemporary(), var);</span>
<span class="line-added">4351         RefPtr&lt;RegisterID&gt; privateName = generator.newTemporary();</span>
<span class="line-added">4352         generator.emitGetFromScope(privateName.get(), scope.get(), var, ThrowIfNotFound);</span>
<span class="line-added">4353         generator.emitProfileType(privateName.get(), var, m_position, m_position + m_ident-&gt;length());</span>
<span class="line-added">4354         generator.emitCallDefineProperty(generator.thisRegister(), privateName.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable | BytecodeGenerator::PropertyEnumerable, m_position);</span>
<span class="line-added">4355         break;</span>
<span class="line-added">4356     }</span>
<span class="line-added">4357     }</span>
<span class="line-added">4358 }</span>
<span class="line-added">4359 </span>
4360 // ------------------------------ ClassDeclNode ---------------------------------
4361 
4362 void ClassDeclNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
4363 {
4364     generator.emitNode(m_classDeclaration);
4365 }
4366 
4367 // ------------------------------ ClassExprNode ---------------------------------
4368 
4369 RegisterID* ClassExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4370 {
<span class="line-modified">4371     if (m_needsLexicalScope)</span>
4372         generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested);
4373 
4374     RefPtr&lt;RegisterID&gt; superclass;
4375     if (m_classHeritage) {
4376         superclass = generator.newTemporary();
4377         generator.emitNode(superclass.get(), m_classHeritage);
4378     }
4379 
4380     RefPtr&lt;RegisterID&gt; constructor = generator.tempDestination(dst);
4381     bool needsHomeObject = false;
4382 
<span class="line-added">4383     auto needsClassFieldInitializer = this-&gt;hasInstanceFields() ? NeedsClassFieldInitializer::Yes : NeedsClassFieldInitializer::No;</span>
<span class="line-added">4384 </span>
4385     if (m_constructorExpression) {
4386         ASSERT(m_constructorExpression-&gt;isFuncExprNode());
4387         FunctionMetadataNode* metadata = static_cast&lt;FuncExprNode*&gt;(m_constructorExpression)-&gt;metadata();
4388         metadata-&gt;setEcmaName(ecmaName());
4389         metadata-&gt;setClassSource(m_classSource);
<span class="line-added">4390         metadata-&gt;setNeedsClassFieldInitializer(needsClassFieldInitializer == NeedsClassFieldInitializer::Yes);</span>
4391         constructor = generator.emitNode(constructor.get(), m_constructorExpression);
4392         needsHomeObject = m_classHeritage || metadata-&gt;superBinding() == SuperBinding::Needed;
4393     } else
<span class="line-modified">4394         constructor = generator.emitNewDefaultConstructor(constructor.get(), m_classHeritage ? ConstructorKind::Extends : ConstructorKind::Base, m_name, ecmaName(), m_classSource, needsClassFieldInitializer);</span>
4395 
4396     const auto&amp; propertyNames = generator.propertyNames();
4397     RefPtr&lt;RegisterID&gt; prototype = generator.emitNewObject(generator.newTemporary());
4398 
4399     if (superclass) {
4400         RefPtr&lt;RegisterID&gt; protoParent = generator.newTemporary();
4401         generator.emitLoad(protoParent.get(), jsNull());
4402 
4403         RefPtr&lt;RegisterID&gt; tempRegister = generator.newTemporary();
4404 
4405         // FIXME: Throw TypeError if it&#39;s a generator function.
4406         Ref&lt;Label&gt; superclassIsUndefinedLabel = generator.newLabel();
4407         generator.emitJumpIfTrue(generator.emitIsUndefined(tempRegister.get(), superclass.get()), superclassIsUndefinedLabel.get());
4408 
4409         Ref&lt;Label&gt; superclassIsNullLabel = generator.newLabel();
4410         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpEqNull&gt;(tempRegister.get(), superclass.get()), superclassIsNullLabel.get());
4411 
4412         Ref&lt;Label&gt; superclassIsObjectLabel = generator.newLabel();
4413         generator.emitJumpIfTrue(generator.emitIsObject(tempRegister.get(), superclass.get()), superclassIsObjectLabel.get());
4414         generator.emitLabel(superclassIsUndefinedLabel.get());
</pre>
<hr />
<pre>
4420         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpIsObjectOrNull&gt;(tempRegister.get(), protoParent.get()), protoParentIsObjectOrNullLabel.get());
4421         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpIsFunction&gt;(tempRegister.get(), protoParent.get()), protoParentIsObjectOrNullLabel.get());
4422         generator.emitThrowTypeError(&quot;The value of the superclass&#39;s prototype property is not an object.&quot;_s);
4423         generator.emitLabel(protoParentIsObjectOrNullLabel.get());
4424 
4425         generator.emitDirectPutById(constructor.get(), generator.propertyNames().underscoreProto, superclass.get(), PropertyNode::Unknown);
4426         generator.emitLabel(superclassIsNullLabel.get());
4427         generator.emitDirectPutById(prototype.get(), generator.propertyNames().underscoreProto, protoParent.get(), PropertyNode::Unknown);
4428     }
4429 
4430     if (needsHomeObject)
4431         emitPutHomeObject(generator, constructor.get(), prototype.get());
4432 
4433     RefPtr&lt;RegisterID&gt; constructorNameRegister = generator.emitLoad(nullptr, propertyNames.constructor);
4434     generator.emitCallDefineProperty(prototype.get(), constructorNameRegister.get(), constructor.get(), nullptr, nullptr,
4435         BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable, m_position);
4436 
4437     RefPtr&lt;RegisterID&gt; prototypeNameRegister = generator.emitLoad(nullptr, propertyNames.prototype);
4438     generator.emitCallDefineProperty(constructor.get(), prototypeNameRegister.get(), prototype.get(), nullptr, nullptr, 0, m_position);
4439 
<span class="line-modified">4440     if (m_classElements) {</span>
<span class="line-modified">4441         Vector&lt;JSTextPosition&gt; instanceFieldLocations;</span>
<span class="line-added">4442         generator.emitDefineClassElements(m_classElements, constructor.get(), prototype.get(), instanceFieldLocations);</span>
<span class="line-added">4443         if (!instanceFieldLocations.isEmpty()) {</span>
<span class="line-added">4444             RefPtr&lt;RegisterID&gt; instanceFieldInitializer = generator.emitNewInstanceFieldInitializerFunction(generator.newTemporary(), WTFMove(instanceFieldLocations), m_classHeritage);</span>
<span class="line-added">4445 </span>
<span class="line-added">4446             // FIXME: Skip this if the initializer function isn&#39;t going to need a home object (no eval or super properties)</span>
<span class="line-added">4447             // https://bugs.webkit.org/show_bug.cgi?id=196867</span>
<span class="line-added">4448             emitPutHomeObject(generator, instanceFieldInitializer.get(), prototype.get());</span>
4449 
<span class="line-modified">4450             generator.emitDirectPutById(constructor.get(), generator.propertyNames().builtinNames().instanceFieldInitializerPrivateName(), instanceFieldInitializer.get(), PropertyNode::Unknown);</span>
<span class="line-modified">4451         }</span>
<span class="line-modified">4452     }</span>
<span class="line-modified">4453 </span>
<span class="line-modified">4454     if (m_needsLexicalScope) {</span>
<span class="line-added">4455         if (!m_name.isNull()) {</span>
<span class="line-added">4456             Variable classNameVar = generator.variable(m_name);</span>
<span class="line-added">4457             RELEASE_ASSERT(classNameVar.isResolved());</span>
<span class="line-added">4458             RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, classNameVar);</span>
<span class="line-added">4459             generator.emitPutToScope(scope.get(), classNameVar, constructor.get(), ThrowIfNotFound, InitializationMode::Initialization);</span>
<span class="line-added">4460         }</span>
4461         generator.popLexicalScope(this);
4462     }
4463 
4464     return generator.move(generator.finalDestination(dst, constructor.get()), constructor.get());
4465 }
4466 
4467 // ------------------------------ ImportDeclarationNode -----------------------
4468 
4469 void ImportDeclarationNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4470 {
4471     // Do nothing at runtime.
4472 }
4473 
4474 // ------------------------------ ExportAllDeclarationNode --------------------
4475 
4476 void ExportAllDeclarationNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4477 {
4478     // Do nothing at runtime.
4479 }
4480 
</pre>
<hr />
<pre>
4689         if (m_targetPatterns[i].wasString)
4690             builder.appendQuotedJSONString(m_targetPatterns[i].propertyName.string());
4691         else
4692             builder.append(m_targetPatterns[i].propertyName.string());
4693         builder.append(&#39;:&#39;);
4694         m_targetPatterns[i].pattern-&gt;toString(builder);
4695         if (i &lt; m_targetPatterns.size() - 1)
4696             builder.append(&#39;,&#39;);
4697     }
4698     builder.append(&#39;}&#39;);
4699 }
4700 
4701 void ObjectPatternNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* rhs) const
4702 {
4703     generator.emitRequireObjectCoercible(rhs, &quot;Right side of assignment cannot be destructured&quot;_s);
4704 
4705     RefPtr&lt;RegisterID&gt; excludedList;
4706     IdentifierSet excludedSet;
4707     RefPtr&lt;RegisterID&gt; addMethod;
4708     if (m_containsRestElement &amp;&amp; m_containsComputedProperty) {
<span class="line-modified">4709         RefPtr&lt;RegisterID&gt; setConstructor = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::Set);</span>




4710 
4711         CallArguments args(generator, nullptr, 0);
4712         excludedList = generator.emitConstruct(generator.newTemporary(), setConstructor.get(), setConstructor.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd());
4713 
4714         addMethod = generator.emitGetById(generator.newTemporary(), excludedList.get(), generator.propertyNames().builtinNames().addPrivateName());
4715     }
4716 
4717     BytecodeGenerator::PreservedTDZStack preservedTDZStack;
4718     generator.preserveTDZStack(preservedTDZStack);
4719 
4720     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4721         const auto&amp; target = m_targetPatterns[i];
4722         if (target.bindingType == BindingType::Element) {
4723             RefPtr&lt;RegisterID&gt; temp = generator.newTemporary();
4724             RefPtr&lt;RegisterID&gt; propertyName;
4725             if (!target.propertyExpression) {
4726                 Optional&lt;uint32_t&gt; optionalIndex = parseIndex(target.propertyName);
4727                 if (!optionalIndex)
4728                     generator.emitGetById(temp.get(), rhs, target.propertyName);
4729                 else {
</pre>
<hr />
<pre>
4740                     if (!target.propertyExpression)
4741                         propertyName = generator.emitLoad(nullptr, target.propertyName);
4742 
4743                     CallArguments args(generator, nullptr, 1);
4744                     generator.move(args.thisRegister(), excludedList.get());
4745                     generator.move(args.argumentRegister(0), propertyName.get());
4746                     generator.emitCall(generator.newTemporary(), addMethod.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4747                 } else
4748                     excludedSet.add(target.propertyName.impl());
4749             }
4750 
4751             if (target.defaultValue)
4752                 assignDefaultValueIfUndefined(generator, temp.get(), target.defaultValue);
4753             target.pattern-&gt;bindValue(generator, temp.get());
4754         } else {
4755             ASSERT(target.bindingType == BindingType::RestElement);
4756             ASSERT(i == m_targetPatterns.size() - 1);
4757             RefPtr&lt;RegisterID&gt; newObject = generator.emitNewObject(generator.newTemporary());
4758 
4759             // load and call @copyDataProperties
<span class="line-modified">4760             RefPtr&lt;RegisterID&gt; copyDataProperties = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::copyDataProperties);</span>




4761 
4762             CallArguments args(generator, nullptr, 3);
4763             generator.emitLoad(args.thisRegister(), jsUndefined());
4764             generator.move(args.argumentRegister(0), newObject.get());
4765             generator.move(args.argumentRegister(1), rhs);
4766             if (m_containsComputedProperty)
4767                 generator.move(args.argumentRegister(2), excludedList.get());
4768             else {
4769                 RefPtr&lt;RegisterID&gt; excludedSetReg = generator.emitLoad(generator.newTemporary(), excludedSet);
4770                 generator.move(args.argumentRegister(2), excludedSetReg.get());
4771             }
4772 
4773             RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
4774             generator.emitCall(result.get(), copyDataProperties.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4775             target.pattern-&gt;bindValue(generator, result.get());
4776         }
4777     }
4778 
4779     generator.restoreTDZStack(preservedTDZStack);
4780 }
</pre>
<hr />
<pre>
4913 void RestParameterNode::emit(BytecodeGenerator&amp; generator)
4914 {
4915     RefPtr&lt;RegisterID&gt; temp = generator.newTemporary();
4916     generator.emitRestParameter(temp.get(), m_numParametersToSkip);
4917     m_pattern-&gt;bindValue(generator, temp.get());
4918 }
4919 
4920 
4921 RegisterID* SpreadExpressionNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4922 {
4923     RELEASE_ASSERT_NOT_REACHED();
4924     return 0;
4925 }
4926 
4927 RegisterID* ObjectSpreadExpressionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4928 {
4929     RefPtr&lt;RegisterID&gt; src = generator.newTemporary();
4930     generator.emitNode(src.get(), m_expression);
4931 
4932     // load and call @copyDataPropertiesNoExclusions
<span class="line-modified">4933     RefPtr&lt;RegisterID&gt; copyDataProperties = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::copyDataPropertiesNoExclusions);</span>




4934 
4935     CallArguments args(generator, nullptr, 2);
4936     generator.emitLoad(args.thisRegister(), jsUndefined());
4937     generator.move(args.argumentRegister(0), dst);
4938     generator.move(args.argumentRegister(1), src.get());
4939 
4940     generator.emitCall(generator.newTemporary(), copyDataProperties.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4941 
4942     return dst;
4943 }
4944 
4945 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="Label.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegisterID.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSSegmentedVariableObject.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSSegmentedVariableObject.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSSegmentedVariableObject.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSSegmentedVariableObject.h
@@ -48,23 +48,18 @@
 // exact dimensions of the variables array at all times.
 
 class JSSegmentedVariableObject : public JSSymbolTableObject {
     friend class JIT;
     friend class LLIntOffsetsExtractor;
-
 public:
     using Base = JSSymbolTableObject;
 
     DECLARE_INFO;
 
-    static const bool needsDestruction = true;
-
+    static constexpr bool needsDestruction = true;
     template<typename CellType, SubspaceAccess>
-    static CompleteSubspace* subspaceFor(VM& vm)
-    {
-        return &vm.cellSpace;
-    }
+    static void subspaceFor(VM&) { RELEASE_ASSERT_NOT_REACHED(); }
 
     bool isValidScopeOffset(ScopeOffset offset)
     {
         return !!offset && offset.offset() < m_variables.size();
     }
@@ -80,11 +75,11 @@
     // in debug code (like bytecode dumping).
     JS_EXPORT_PRIVATE ScopeOffset findVariableIndex(void*);
 
     WriteBarrier<Unknown>* assertVariableIsInThisObject(WriteBarrier<Unknown>* variablePointer)
     {
-        if (!ASSERT_DISABLED)
+        if (ASSERT_ENABLED)
             findVariableIndex(variablePointer);
         return variablePointer;
     }
 
     // Adds numberOfRegistersToAdd registers, initializes them to Undefined, and returns
@@ -92,24 +87,19 @@
     JS_EXPORT_PRIVATE ScopeOffset addVariables(unsigned numberOfVariablesToAdd, JSValue);
 
     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&);
     JS_EXPORT_PRIVATE static void analyzeHeap(JSCell*, HeapAnalyzer&);
 
-    static void destroy(JSCell*);
-
-    const ClassInfo* classInfo() const { return m_classInfo; }
-
 protected:
     JSSegmentedVariableObject(VM&, Structure*, JSScope*);
 
     ~JSSegmentedVariableObject();
 
     void finishCreation(VM&);
 
 private:
     SegmentedVector<WriteBarrier<Unknown>, 16> m_variables;
-    const ClassInfo* m_classInfo;
 #ifndef NDEBUG
     bool m_alreadyDestroyed { false }; // We use these assertions to check that we aren't doing ancient hacks that result in this being destroyed more than once.
 #endif
 };
 

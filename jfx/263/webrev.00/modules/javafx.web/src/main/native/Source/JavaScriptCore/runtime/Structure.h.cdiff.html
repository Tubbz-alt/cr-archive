<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Structure.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Structure.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructureChain.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Structure.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,18 ***</span>
  #include &quot;ConcurrentJSLock.h&quot;
  #include &quot;IndexingType.h&quot;
  #include &quot;JSCJSValue.h&quot;
  #include &quot;JSCast.h&quot;
  #include &quot;JSType.h&quot;
  #include &quot;PropertyName.h&quot;
  #include &quot;PropertyNameArray.h&quot;
  #include &quot;PropertyOffset.h&quot;
  #include &quot;PutPropertySlot.h&quot;
  #include &quot;StructureIDBlob.h&quot;
  #include &quot;StructureRareData.h&quot;
  #include &quot;StructureTransitionTable.h&quot;
<span class="line-modified">! #include &quot;JSTypeInfo.h&quot;</span>
  #include &quot;Watchpoint.h&quot;
  #include &quot;WriteBarrierInlines.h&quot;
  #include &lt;wtf/PrintStream.h&gt;
  
  namespace WTF {
<span class="line-new-header">--- 29,19 ---</span>
  #include &quot;ConcurrentJSLock.h&quot;
  #include &quot;IndexingType.h&quot;
  #include &quot;JSCJSValue.h&quot;
  #include &quot;JSCast.h&quot;
  #include &quot;JSType.h&quot;
<span class="line-added">+ #include &quot;JSTypeInfo.h&quot;</span>
  #include &quot;PropertyName.h&quot;
  #include &quot;PropertyNameArray.h&quot;
  #include &quot;PropertyOffset.h&quot;
  #include &quot;PutPropertySlot.h&quot;
  #include &quot;StructureIDBlob.h&quot;
  #include &quot;StructureRareData.h&quot;
  #include &quot;StructureTransitionTable.h&quot;
<span class="line-modified">! #include &quot;TinyBloomFilter.h&quot;</span>
  #include &quot;Watchpoint.h&quot;
  #include &quot;WriteBarrierInlines.h&quot;
  #include &lt;wtf/PrintStream.h&gt;
  
  namespace WTF {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,19 ***</span>
  class StructureChain;
  class StructureShape;
  class SlotVisitor;
  class JSString;
  struct DumpContext;
  
  // The out-of-line property storage capacity to use when first allocating out-of-line
  // storage. Note that all objects start out without having any out-of-line storage;
  // this comes into play only on the first property store that exhausts inline storage.
<span class="line-modified">! static const unsigned initialOutOfLineCapacity = 4;</span>
  
  // The factor by which to grow out-of-line storage when it is exhausted, after the
  // initial allocation.
<span class="line-modified">! static const unsigned outOfLineGrowthFactor = 2;</span>
  
  struct PropertyMapEntry {
      UniquedStringImpl* key;
      PropertyOffset offset;
      uint8_t attributes;
<span class="line-new-header">--- 60,21 ---</span>
  class StructureChain;
  class StructureShape;
  class SlotVisitor;
  class JSString;
  struct DumpContext;
<span class="line-added">+ struct HashTable;</span>
<span class="line-added">+ struct HashTableValue;</span>
  
  // The out-of-line property storage capacity to use when first allocating out-of-line
  // storage. Note that all objects start out without having any out-of-line storage;
  // this comes into play only on the first property store that exhausts inline storage.
<span class="line-modified">! static constexpr unsigned initialOutOfLineCapacity = 4;</span>
  
  // The factor by which to grow out-of-line storage when it is exhausted, after the
  // initial allocation.
<span class="line-modified">! static constexpr unsigned outOfLineGrowthFactor = 2;</span>
  
  struct PropertyMapEntry {
      UniquedStringImpl* key;
      PropertyOffset offset;
      uint8_t attributes;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,15 ***</span>
  private:
      const Structure* m_structure;
  };
  
  class Structure final : public JSCell {
  public:
      friend class StructureTransitionTable;
  
      typedef JSCell Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
  
      enum PolyProtoTag { PolyProto };
      static Structure* create(VM&amp;, JSGlobalObject*, JSValue prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType = NonArray, unsigned inlineCapacity = 0);
      static Structure* create(PolyProtoTag, VM&amp;, JSGlobalObject*, JSObject* prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType = NonArray, unsigned inlineCapacity = 0);
  
<span class="line-new-header">--- 121,17 ---</span>
  private:
      const Structure* m_structure;
  };
  
  class Structure final : public JSCell {
<span class="line-added">+     static constexpr uint16_t shortInvalidOffset = std::numeric_limits&lt;uint16_t&gt;::max() - 1;</span>
<span class="line-added">+     static constexpr uint16_t useRareDataFlag = std::numeric_limits&lt;uint16_t&gt;::max();</span>
  public:
      friend class StructureTransitionTable;
  
      typedef JSCell Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
  
      enum PolyProtoTag { PolyProto };
      static Structure* create(VM&amp;, JSGlobalObject*, JSValue prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType = NonArray, unsigned inlineCapacity = 0);
      static Structure* create(PolyProtoTag, VM&amp;, JSGlobalObject*, JSObject* prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType = NonArray, unsigned inlineCapacity = 0);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,15 ***</span>
  
      JS_EXPORT_PRIVATE static Structure* addPropertyTransition(VM&amp;, Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;);
      JS_EXPORT_PRIVATE static Structure* addNewPropertyTransition(VM&amp;, Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;, PutPropertySlot::Context = PutPropertySlot::UnknownContext, DeferredStructureTransitionWatchpointFire* = nullptr);
      static Structure* addPropertyTransitionToExistingStructureConcurrently(Structure*, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp;);
      JS_EXPORT_PRIVATE static Structure* addPropertyTransitionToExistingStructure(Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;);
<span class="line-modified">!     static Structure* removePropertyTransition(VM&amp;, Structure*, PropertyName, PropertyOffset&amp;);</span>
      static Structure* changePrototypeTransition(VM&amp;, Structure*, JSValue prototype, DeferredStructureTransitionWatchpointFire&amp;);
      JS_EXPORT_PRIVATE static Structure* attributeChangeTransition(VM&amp;, Structure*, PropertyName, unsigned attributes);
      JS_EXPORT_PRIVATE static Structure* toCacheableDictionaryTransition(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire* = nullptr);
<span class="line-modified">!     static Structure* toUncacheableDictionaryTransition(VM&amp;, Structure*);</span>
      JS_EXPORT_PRIVATE static Structure* sealTransition(VM&amp;, Structure*);
      JS_EXPORT_PRIVATE static Structure* freezeTransition(VM&amp;, Structure*);
      static Structure* preventExtensionsTransition(VM&amp;, Structure*);
      static Structure* nonPropertyTransition(VM&amp;, Structure*, NonPropertyTransition);
      JS_EXPORT_PRIVATE static Structure* nonPropertyTransitionSlow(VM&amp;, Structure*, NonPropertyTransition);
<span class="line-new-header">--- 187,17 ---</span>
  
      JS_EXPORT_PRIVATE static Structure* addPropertyTransition(VM&amp;, Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;);
      JS_EXPORT_PRIVATE static Structure* addNewPropertyTransition(VM&amp;, Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;, PutPropertySlot::Context = PutPropertySlot::UnknownContext, DeferredStructureTransitionWatchpointFire* = nullptr);
      static Structure* addPropertyTransitionToExistingStructureConcurrently(Structure*, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp;);
      JS_EXPORT_PRIVATE static Structure* addPropertyTransitionToExistingStructure(Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;);
<span class="line-modified">!     static Structure* removeNewPropertyTransition(VM&amp;, Structure*, PropertyName, PropertyOffset&amp;, DeferredStructureTransitionWatchpointFire* = nullptr);</span>
<span class="line-added">+     static Structure* removePropertyTransition(VM&amp;, Structure*, PropertyName, PropertyOffset&amp;, DeferredStructureTransitionWatchpointFire* = nullptr);</span>
<span class="line-added">+     static Structure* removePropertyTransitionFromExistingStructure(VM&amp;, Structure*, PropertyName, PropertyOffset&amp;, DeferredStructureTransitionWatchpointFire* = nullptr);</span>
      static Structure* changePrototypeTransition(VM&amp;, Structure*, JSValue prototype, DeferredStructureTransitionWatchpointFire&amp;);
      JS_EXPORT_PRIVATE static Structure* attributeChangeTransition(VM&amp;, Structure*, PropertyName, unsigned attributes);
      JS_EXPORT_PRIVATE static Structure* toCacheableDictionaryTransition(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire* = nullptr);
<span class="line-modified">!     static Structure* toUncacheableDictionaryTransition(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire* = nullptr);</span>
      JS_EXPORT_PRIVATE static Structure* sealTransition(VM&amp;, Structure*);
      JS_EXPORT_PRIVATE static Structure* freezeTransition(VM&amp;, Structure*);
      static Structure* preventExtensionsTransition(VM&amp;, Structure*);
      static Structure* nonPropertyTransition(VM&amp;, Structure*, NonPropertyTransition);
      JS_EXPORT_PRIVATE static Structure* nonPropertyTransitionSlow(VM&amp;, Structure*, NonPropertyTransition);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 199,11 ***</span>
      JS_EXPORT_PRIVATE bool isFrozen(VM&amp;);
      bool isStructureExtensible() const { return !didPreventExtensions(); }
  
      JS_EXPORT_PRIVATE Structure* flattenDictionaryStructure(VM&amp;, JSObject*);
  
<span class="line-modified">!     static const bool needsDestruction = true;</span>
      static void destroy(JSCell*);
  
      // Versions that take a func will call it after making the change but while still holding
      // the lock. The callback is not called if there is no change being made, like if you call
      // removePropertyWithoutTransition() and the property is not found.
<span class="line-new-header">--- 206,11 ---</span>
      JS_EXPORT_PRIVATE bool isFrozen(VM&amp;);
      bool isStructureExtensible() const { return !didPreventExtensions(); }
  
      JS_EXPORT_PRIVATE Structure* flattenDictionaryStructure(VM&amp;, JSObject*);
  
<span class="line-modified">!     static constexpr bool needsDestruction = true;</span>
      static void destroy(JSCell*);
  
      // Versions that take a func will call it after making the change but while still holding
      // the lock. The callback is not called if there is no change being made, like if you call
      // removePropertyWithoutTransition() and the property is not found.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 243,11 ***</span>
      bool isImmutablePrototypeExoticObject()
      {
          return typeInfo().isImmutablePrototypeExoticObject();
      }
  
<span class="line-modified">!     // We use SlowPath in GetByIdStatus for structures that may get new impure properties later to prevent</span>
      // DFG from inlining property accesses since structures don&#39;t transition when a new impure property appears.
      bool takesSlowPathInDFGForImpureProperty()
      {
          return typeInfo().getOwnPropertySlotIsImpure();
      }
<span class="line-new-header">--- 250,11 ---</span>
      bool isImmutablePrototypeExoticObject()
      {
          return typeInfo().isImmutablePrototypeExoticObject();
      }
  
<span class="line-modified">!     // We use SlowPath in GetByStatus for structures that may get new impure properties later to prevent</span>
      // DFG from inlining property accesses since structures don&#39;t transition when a new impure property appears.
      bool takesSlowPathInDFGForImpureProperty()
      {
          return typeInfo().getOwnPropertySlotIsImpure();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 290,11 ***</span>
      JSObject* storedPrototypeObject() const;
      Structure* storedPrototypeStructure() const;
      JSValue prototypeForLookup(JSGlobalObject*) const;
      JSValue prototypeForLookup(JSGlobalObject*, JSCell* base) const;
      StructureChain* prototypeChain(VM&amp;, JSGlobalObject*, JSObject* base) const;
<span class="line-modified">!     StructureChain* prototypeChain(ExecState*, JSObject* base) const;</span>
      static void visitChildren(JSCell*, SlotVisitor&amp;);
  
      // A Structure is cheap to mark during GC if doing so would only add a small and bounded amount
      // to our heap footprint. For example, if the structure refers to a global object that is not
      // yet marked, then as far as we know, the decision to mark this Structure would lead to a large
<span class="line-new-header">--- 297,11 ---</span>
      JSObject* storedPrototypeObject() const;
      Structure* storedPrototypeStructure() const;
      JSValue prototypeForLookup(JSGlobalObject*) const;
      JSValue prototypeForLookup(JSGlobalObject*, JSCell* base) const;
      StructureChain* prototypeChain(VM&amp;, JSGlobalObject*, JSObject* base) const;
<span class="line-modified">!     StructureChain* prototypeChain(JSGlobalObject*, JSObject* base) const;</span>
      static void visitChildren(JSCell*, SlotVisitor&amp;);
  
      // A Structure is cheap to mark during GC if doing so would only add a small and bounded amount
      // to our heap footprint. For example, if the structure refers to a global object that is not
      // yet marked, then as far as we know, the decision to mark this Structure would lead to a large
</pre>
<hr />
<pre>
<span class="line-old-header">*** 348,17 ***</span>
              return static_cast&lt;StructureRareData*&gt;(cell)-&gt;previousID();
          return static_cast&lt;Structure*&gt;(cell);
      }
      bool transitivelyTransitionedFrom(Structure* structureToFind);
  
<span class="line-modified">!     PropertyOffset lastOffset() const { return m_offset; }</span>
  
<span class="line-modified">!     void setLastOffset(PropertyOffset offset) { m_offset = offset; }</span>
  
<span class="line-modified">!     static unsigned outOfLineCapacity(PropertyOffset lastOffset)</span>
      {
<span class="line-modified">!         unsigned outOfLineSize = Structure::outOfLineSize(lastOffset);</span>
  
          // This algorithm completely determines the out-of-line property storage growth algorithm.
          // The JSObject code will only trigger a resize if the value returned by this algorithm
          // changed between the new and old structure. So, it&#39;s important to keep this simple because
          // it&#39;s on a fast path.
<span class="line-new-header">--- 355,63 ---</span>
              return static_cast&lt;StructureRareData*&gt;(cell)-&gt;previousID();
          return static_cast&lt;Structure*&gt;(cell);
      }
      bool transitivelyTransitionedFrom(Structure* structureToFind);
  
<span class="line-modified">!     PropertyOffset maxOffset() const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         uint16_t maxOffset = m_maxOffset;</span>
<span class="line-added">+         if (maxOffset == shortInvalidOffset)</span>
<span class="line-added">+             return invalidOffset;</span>
<span class="line-added">+         if (maxOffset == useRareDataFlag)</span>
<span class="line-added">+             return rareData()-&gt;m_maxOffset;</span>
<span class="line-added">+         return maxOffset;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void setMaxOffset(VM&amp; vm, PropertyOffset offset)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (offset == invalidOffset)</span>
<span class="line-added">+             m_maxOffset = shortInvalidOffset;</span>
<span class="line-added">+         else if (offset &lt; useRareDataFlag &amp;&amp; offset &lt; shortInvalidOffset)</span>
<span class="line-added">+             m_maxOffset = offset;</span>
<span class="line-added">+         else if (m_maxOffset == useRareDataFlag)</span>
<span class="line-added">+             rareData()-&gt;m_maxOffset = offset;</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             ensureRareData(vm)-&gt;m_maxOffset = offset;</span>
<span class="line-added">+             WTF::storeStoreFence();</span>
<span class="line-added">+             m_maxOffset = useRareDataFlag;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     PropertyOffset transitionOffset() const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         uint16_t transitionOffset = m_transitionOffset;</span>
<span class="line-added">+         if (transitionOffset == shortInvalidOffset)</span>
<span class="line-added">+             return invalidOffset;</span>
<span class="line-added">+         if (transitionOffset == useRareDataFlag)</span>
<span class="line-added">+             return rareData()-&gt;m_transitionOffset;</span>
<span class="line-added">+         return transitionOffset;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     void setTransitionOffset(VM&amp; vm, PropertyOffset offset)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (offset == invalidOffset)</span>
<span class="line-added">+             m_transitionOffset = shortInvalidOffset;</span>
<span class="line-added">+         else if (offset &lt; useRareDataFlag &amp;&amp; offset &lt; shortInvalidOffset)</span>
<span class="line-added">+             m_transitionOffset = offset;</span>
<span class="line-added">+         else if (m_transitionOffset == useRareDataFlag)</span>
<span class="line-added">+             rareData()-&gt;m_transitionOffset = offset;</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             ensureRareData(vm)-&gt;m_transitionOffset = offset;</span>
<span class="line-added">+             WTF::storeStoreFence();</span>
<span class="line-added">+             m_transitionOffset = useRareDataFlag;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     static unsigned outOfLineCapacity(PropertyOffset maxOffset)</span>
      {
<span class="line-modified">!         unsigned outOfLineSize = Structure::outOfLineSize(maxOffset);</span>
  
          // This algorithm completely determines the out-of-line property storage growth algorithm.
          // The JSObject code will only trigger a resize if the value returned by this algorithm
          // changed between the new and old structure. So, it&#39;s important to keep this simple because
          // it&#39;s on a fast path.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 372,22 ***</span>
          ASSERT(outOfLineSize &gt; initialOutOfLineCapacity);
          COMPILE_ASSERT(outOfLineGrowthFactor == 2, outOfLineGrowthFactor_is_two);
          return WTF::roundUpToPowerOfTwo(outOfLineSize);
      }
  
<span class="line-modified">!     static unsigned outOfLineSize(PropertyOffset lastOffset)</span>
      {
<span class="line-modified">!         return numberOfOutOfLineSlotsForLastOffset(lastOffset);</span>
      }
  
      unsigned outOfLineCapacity() const
      {
<span class="line-modified">!         return outOfLineCapacity(m_offset);</span>
      }
      unsigned outOfLineSize() const
      {
<span class="line-modified">!         return outOfLineSize(m_offset);</span>
      }
      bool hasInlineStorage() const
      {
          return !!m_inlineCapacity;
      }
<span class="line-new-header">--- 425,22 ---</span>
          ASSERT(outOfLineSize &gt; initialOutOfLineCapacity);
          COMPILE_ASSERT(outOfLineGrowthFactor == 2, outOfLineGrowthFactor_is_two);
          return WTF::roundUpToPowerOfTwo(outOfLineSize);
      }
  
<span class="line-modified">!     static unsigned outOfLineSize(PropertyOffset maxOffset)</span>
      {
<span class="line-modified">!         return numberOfOutOfLineSlotsForMaxOffset(maxOffset);</span>
      }
  
      unsigned outOfLineCapacity() const
      {
<span class="line-modified">!         return outOfLineCapacity(maxOffset());</span>
      }
      unsigned outOfLineSize() const
      {
<span class="line-modified">!         return outOfLineSize(maxOffset());</span>
      }
      bool hasInlineStorage() const
      {
          return !!m_inlineCapacity;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 395,26 ***</span>
      {
          return m_inlineCapacity;
      }
      unsigned inlineSize() const
      {
<span class="line-modified">!         return std::min&lt;unsigned&gt;(m_offset + 1, m_inlineCapacity);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     unsigned totalStorageSize() const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return numberOfSlotsForLastOffset(m_offset, m_inlineCapacity);</span>
      }
      unsigned totalStorageCapacity() const
      {
          ASSERT(structure()-&gt;classInfo() == info());
          return outOfLineCapacity() + inlineCapacity();
      }
  
      bool isValidOffset(PropertyOffset offset) const
      {
          return JSC::isValidOffset(offset)
<span class="line-modified">!             &amp;&amp; offset &lt;= m_offset</span>
              &amp;&amp; (offset &lt; m_inlineCapacity || offset &gt;= firstOutOfLineOffset);
      }
  
      bool hijacksIndexingHeader() const
      {
<span class="line-new-header">--- 448,22 ---</span>
      {
          return m_inlineCapacity;
      }
      unsigned inlineSize() const
      {
<span class="line-modified">!         return std::min&lt;unsigned&gt;(maxOffset() + 1, m_inlineCapacity);</span>
      }
      unsigned totalStorageCapacity() const
      {
          ASSERT(structure()-&gt;classInfo() == info());
          return outOfLineCapacity() + inlineCapacity();
      }
  
      bool isValidOffset(PropertyOffset offset) const
      {
          return JSC::isValidOffset(offset)
<span class="line-modified">!             &amp;&amp; offset &lt;= maxOffset()</span>
              &amp;&amp; (offset &lt; m_inlineCapacity || offset &gt;= firstOutOfLineOffset);
      }
  
      bool hijacksIndexingHeader() const
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 463,19 ***</span>
          setHasCustomGetterSetterProperties(true);
          if (!is__proto__)
              setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
      }
  
<span class="line-removed">-     bool isEmpty() const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         ASSERT(checkOffsetConsistency());</span>
<span class="line-removed">-         return !JSC::isValidOffset(m_offset);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      void setCachedPropertyNameEnumerator(VM&amp;, JSPropertyNameEnumerator*);
      JSPropertyNameEnumerator* cachedPropertyNameEnumerator() const;
<span class="line-modified">!     bool canCachePropertyNameEnumerator() const;</span>
      bool canAccessPropertiesQuicklyForEnumeration() const;
  
      void setCachedOwnKeys(VM&amp;, JSImmutableButterfly*);
      JSImmutableButterfly* cachedOwnKeys() const;
      JSImmutableButterfly* cachedOwnKeysIgnoringSentinel() const;
<span class="line-new-header">--- 512,13 ---</span>
          setHasCustomGetterSetterProperties(true);
          if (!is__proto__)
              setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
      }
  
      void setCachedPropertyNameEnumerator(VM&amp;, JSPropertyNameEnumerator*);
      JSPropertyNameEnumerator* cachedPropertyNameEnumerator() const;
<span class="line-modified">!     bool canCachePropertyNameEnumerator(VM&amp;) const;</span>
      bool canAccessPropertiesQuicklyForEnumeration() const;
  
      void setCachedOwnKeys(VM&amp;, JSImmutableButterfly*);
      JSImmutableButterfly* cachedOwnKeys() const;
      JSImmutableButterfly* cachedOwnKeysIgnoringSentinel() const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 488,11 ***</span>
          if (!hasRareData())
              return 0;
          return rareData()-&gt;objectToStringValue();
      }
  
<span class="line-modified">!     void setObjectToStringValue(ExecState*, VM&amp;, JSString* value, PropertySlot toStringTagSymbolSlot);</span>
  
      const ClassInfo* classInfo() const { return m_classInfo; }
  
      static ptrdiff_t structureIDOffset()
      {
<span class="line-new-header">--- 531,11 ---</span>
          if (!hasRareData())
              return 0;
          return rareData()-&gt;objectToStringValue();
      }
  
<span class="line-modified">!     void setObjectToStringValue(JSGlobalObject*, VM&amp;, JSString* value, PropertySlot toStringTagSymbolSlot);</span>
  
      const ClassInfo* classInfo() const { return m_classInfo; }
  
      static ptrdiff_t structureIDOffset()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 614,10 ***</span>
<span class="line-new-header">--- 657,16 ---</span>
  
      unsigned propertyHash() const { return m_propertyHash; }
  
      static bool shouldConvertToPolyProto(const Structure* a, const Structure* b);
  
<span class="line-added">+     struct PropertyHashEntry {</span>
<span class="line-added">+         const HashTable* table;</span>
<span class="line-added">+         const HashTableValue* value;</span>
<span class="line-added">+     };</span>
<span class="line-added">+     Optional&lt;PropertyHashEntry&gt; findPropertyHashEntry(PropertyName) const;</span>
<span class="line-added">+ </span>
      DECLARE_EXPORT_INFO;
  
  private:
      typedef enum {
          NoneDictionaryKind = 0,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 625,12 ***</span>
          UncachedDictionaryKind = 2
      } DictionaryKind;
  
  public:
  #define DEFINE_BITFIELD(type, lowerName, upperName, width, offset) \
<span class="line-modified">!     static const uint32_t s_##lowerName##Shift = offset;\</span>
<span class="line-modified">!     static const uint32_t s_##lowerName##Mask = ((1 &lt;&lt; (width - 1)) | ((1 &lt;&lt; (width - 1)) - 1));\</span>
      type lowerName() const { return static_cast&lt;type&gt;((m_bitField &gt;&gt; offset) &amp; s_##lowerName##Mask); }\
      void set##upperName(type newValue) \
      {\
          m_bitField &amp;= ~(s_##lowerName##Mask &lt;&lt; offset);\
          m_bitField |= (newValue &amp; s_##lowerName##Mask) &lt;&lt; offset;\
<span class="line-new-header">--- 674,13 ---</span>
          UncachedDictionaryKind = 2
      } DictionaryKind;
  
  public:
  #define DEFINE_BITFIELD(type, lowerName, upperName, width, offset) \
<span class="line-modified">!     static constexpr uint32_t s_##lowerName##Shift = offset;\</span>
<span class="line-modified">!     static constexpr uint32_t s_##lowerName##Mask = ((1 &lt;&lt; (width - 1)) | ((1 &lt;&lt; (width - 1)) - 1));\</span>
<span class="line-added">+     static constexpr uint32_t s_bitWidthOf##upperName = width;\</span>
      type lowerName() const { return static_cast&lt;type&gt;((m_bitField &gt;&gt; offset) &amp; s_##lowerName##Mask); }\
      void set##upperName(type newValue) \
      {\
          m_bitField &amp;= ~(s_##lowerName##Mask &lt;&lt; offset);\
          m_bitField |= (newValue &amp; s_##lowerName##Mask) &lt;&lt; offset;\
</pre>
<hr />
<pre>
<span class="line-old-header">*** 639,21 ***</span>
      DEFINE_BITFIELD(DictionaryKind, dictionaryKind, DictionaryKind, 2, 0);
      DEFINE_BITFIELD(bool, isPinnedPropertyTable, IsPinnedPropertyTable, 1, 2);
      DEFINE_BITFIELD(bool, hasGetterSetterProperties, HasGetterSetterProperties, 1, 3);
      DEFINE_BITFIELD(bool, hasReadOnlyOrGetterSetterPropertiesExcludingProto, HasReadOnlyOrGetterSetterPropertiesExcludingProto, 1, 4);
      DEFINE_BITFIELD(bool, isQuickPropertyAccessAllowedForEnumeration, IsQuickPropertyAccessAllowedForEnumeration, 1, 5);
<span class="line-modified">!     DEFINE_BITFIELD(unsigned, attributesInPrevious, AttributesInPrevious, 14, 6);</span>
      DEFINE_BITFIELD(bool, didPreventExtensions, DidPreventExtensions, 1, 20);
      DEFINE_BITFIELD(bool, didTransition, DidTransition, 1, 21);
      DEFINE_BITFIELD(bool, staticPropertiesReified, StaticPropertiesReified, 1, 22);
      DEFINE_BITFIELD(bool, hasBeenFlattenedBefore, HasBeenFlattenedBefore, 1, 23);
      DEFINE_BITFIELD(bool, hasCustomGetterSetterProperties, HasCustomGetterSetterProperties, 1, 24);
      DEFINE_BITFIELD(bool, didWatchInternalProperties, DidWatchInternalProperties, 1, 25);
      DEFINE_BITFIELD(bool, transitionWatchpointIsLikelyToBeFired, TransitionWatchpointIsLikelyToBeFired, 1, 26);
      DEFINE_BITFIELD(bool, hasBeenDictionary, HasBeenDictionary, 1, 27);
<span class="line-modified">!     DEFINE_BITFIELD(bool, isAddingPropertyForTransition, IsAddingPropertyForTransition, 1, 28);</span>
      DEFINE_BITFIELD(bool, hasUnderscoreProtoPropertyExcludingOriginalProto, HasUnderscoreProtoPropertyExcludingOriginalProto, 1, 29);
  
  private:
      friend class LLIntOffsetsExtractor;
  
      JS_EXPORT_PRIVATE Structure(VM&amp;, JSGlobalObject*, JSValue prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType, unsigned inlineCapacity);
<span class="line-new-header">--- 689,24 ---</span>
      DEFINE_BITFIELD(DictionaryKind, dictionaryKind, DictionaryKind, 2, 0);
      DEFINE_BITFIELD(bool, isPinnedPropertyTable, IsPinnedPropertyTable, 1, 2);
      DEFINE_BITFIELD(bool, hasGetterSetterProperties, HasGetterSetterProperties, 1, 3);
      DEFINE_BITFIELD(bool, hasReadOnlyOrGetterSetterPropertiesExcludingProto, HasReadOnlyOrGetterSetterPropertiesExcludingProto, 1, 4);
      DEFINE_BITFIELD(bool, isQuickPropertyAccessAllowedForEnumeration, IsQuickPropertyAccessAllowedForEnumeration, 1, 5);
<span class="line-modified">!     DEFINE_BITFIELD(unsigned, transitionPropertyAttributes, TransitionPropertyAttributes, 14, 6);</span>
      DEFINE_BITFIELD(bool, didPreventExtensions, DidPreventExtensions, 1, 20);
      DEFINE_BITFIELD(bool, didTransition, DidTransition, 1, 21);
      DEFINE_BITFIELD(bool, staticPropertiesReified, StaticPropertiesReified, 1, 22);
      DEFINE_BITFIELD(bool, hasBeenFlattenedBefore, HasBeenFlattenedBefore, 1, 23);
      DEFINE_BITFIELD(bool, hasCustomGetterSetterProperties, HasCustomGetterSetterProperties, 1, 24);
      DEFINE_BITFIELD(bool, didWatchInternalProperties, DidWatchInternalProperties, 1, 25);
      DEFINE_BITFIELD(bool, transitionWatchpointIsLikelyToBeFired, TransitionWatchpointIsLikelyToBeFired, 1, 26);
      DEFINE_BITFIELD(bool, hasBeenDictionary, HasBeenDictionary, 1, 27);
<span class="line-modified">!     DEFINE_BITFIELD(bool, protectPropertyTableWhileTransitioning, ProtectPropertyTableWhileTransitioning, 1, 28);</span>
      DEFINE_BITFIELD(bool, hasUnderscoreProtoPropertyExcludingOriginalProto, HasUnderscoreProtoPropertyExcludingOriginalProto, 1, 29);
<span class="line-added">+     DEFINE_BITFIELD(bool, isPropertyDeletionTransition, IsPropertyDeletionTransition, 1, 30);</span>
<span class="line-added">+ </span>
<span class="line-added">+     static_assert(s_bitWidthOfTransitionPropertyAttributes &lt;= sizeof(TransitionPropertyAttributes) * 8);</span>
  
  private:
      friend class LLIntOffsetsExtractor;
  
      JS_EXPORT_PRIVATE Structure(VM&amp;, JSGlobalObject*, JSValue prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType, unsigned inlineCapacity);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 674,13 ***</span>
  
      enum class ShouldPin { No, Yes };
      template&lt;ShouldPin, typename Func&gt;
      PropertyOffset add(VM&amp;, PropertyName, unsigned attributes, const Func&amp;);
      PropertyOffset add(VM&amp;, PropertyName, unsigned attributes);
<span class="line-modified">!     template&lt;typename Func&gt;</span>
<span class="line-modified">!     PropertyOffset remove(PropertyName, const Func&amp;);</span>
<span class="line-modified">!     PropertyOffset remove(PropertyName);</span>
  
      void checkConsistency();
  
      // This may grab the lock, or not. Do not call when holding the Structure&#39;s lock.
      PropertyTable* ensurePropertyTableIfNotEmpty(VM&amp; vm)
<span class="line-new-header">--- 727,13 ---</span>
  
      enum class ShouldPin { No, Yes };
      template&lt;ShouldPin, typename Func&gt;
      PropertyOffset add(VM&amp;, PropertyName, unsigned attributes, const Func&amp;);
      PropertyOffset add(VM&amp;, PropertyName, unsigned attributes);
<span class="line-modified">!     template&lt;ShouldPin, typename Func&gt;</span>
<span class="line-modified">!     PropertyOffset remove(VM&amp;, PropertyName, const Func&amp;);</span>
<span class="line-modified">!     PropertyOffset remove(VM&amp;, PropertyName);</span>
  
      void checkConsistency();
  
      // This may grab the lock, or not. Do not call when holding the Structure&#39;s lock.
      PropertyTable* ensurePropertyTableIfNotEmpty(VM&amp; vm)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 721,14 ***</span>
              rareData()-&gt;clearPreviousID();
          else
              m_previousOrRareData.clear();
      }
  
<span class="line-modified">!     int transitionCount() const</span>
      {
<span class="line-modified">!         // Since the number of transitions is always the same as m_offset, we keep the size of Structure down by not storing both.</span>
<span class="line-modified">!         return numberOfSlotsForLastOffset(m_offset, m_inlineCapacity);</span>
      }
  
      bool isValid(JSGlobalObject*, StructureChain* cachedPrototypeChain, JSObject* base) const;
  
      // You have to hold the structure lock to do these.
<span class="line-new-header">--- 774,15 ---</span>
              rareData()-&gt;clearPreviousID();
          else
              m_previousOrRareData.clear();
      }
  
<span class="line-modified">!     int transitionCountEstimate() const</span>
      {
<span class="line-modified">!         // Since the number of transitions is often the same as the last offset (except if there are deletes)</span>
<span class="line-modified">!         // we keep the size of Structure down by not storing both.</span>
<span class="line-added">+         return numberOfSlotsForMaxOffset(maxOffset(), m_inlineCapacity);</span>
      }
  
      bool isValid(JSGlobalObject*, StructureChain* cachedPrototypeChain, JSObject* base) const;
  
      // You have to hold the structure lock to do these.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 746,12 ***</span>
  
      JS_EXPORT_PRIVATE void allocateRareData(VM&amp;);
  
      void startWatchingInternalProperties(VM&amp;);
  
<span class="line-modified">!     static const int s_maxTransitionLength = 64;</span>
<span class="line-modified">!     static const int s_maxTransitionLengthForNonEvalPutById = 512;</span>
  
      // These need to be properly aligned at the beginning of the &#39;Structure&#39;
      // part of the object.
      StructureIDBlob m_blob;
      TypeInfo::OutOfLineTypeFlags m_outOfLineTypeFlags;
<span class="line-new-header">--- 800,12 ---</span>
  
      JS_EXPORT_PRIVATE void allocateRareData(VM&amp;);
  
      void startWatchingInternalProperties(VM&amp;);
  
<span class="line-modified">!     static constexpr int s_maxTransitionLength = 64;</span>
<span class="line-modified">!     static constexpr int s_maxTransitionLengthForNonEvalPutById = 512;</span>
  
      // These need to be properly aligned at the beginning of the &#39;Structure&#39;
      // part of the object.
      StructureIDBlob m_blob;
      TypeInfo::OutOfLineTypeFlags m_outOfLineTypeFlags;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 766,11 ***</span>
      WriteBarrier&lt;Unknown&gt; m_prototype;
      mutable WriteBarrier&lt;StructureChain&gt; m_cachedPrototypeChain;
  
      WriteBarrier&lt;JSCell&gt; m_previousOrRareData;
  
<span class="line-modified">!     RefPtr&lt;UniquedStringImpl&gt; m_nameInPrevious;</span>
  
      const ClassInfo* m_classInfo;
  
      StructureTransitionTable m_transitionTable;
  
<span class="line-new-header">--- 820,11 ---</span>
      WriteBarrier&lt;Unknown&gt; m_prototype;
      mutable WriteBarrier&lt;StructureChain&gt; m_cachedPrototypeChain;
  
      WriteBarrier&lt;JSCell&gt; m_previousOrRareData;
  
<span class="line-modified">!     RefPtr&lt;UniquedStringImpl&gt; m_transitionPropertyName;</span>
  
      const ClassInfo* m_classInfo;
  
      StructureTransitionTable m_transitionTable;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 780,12 ***</span>
  
      mutable InlineWatchpointSet m_transitionWatchpointSet;
  
      COMPILE_ASSERT(firstOutOfLineOffset &lt; 256, firstOutOfLineOffset_fits);
  
<span class="line-modified">!     // m_offset does not account for anonymous slots</span>
<span class="line-modified">!     PropertyOffset m_offset;</span>
  
      uint32_t m_propertyHash;
  };
  
  } // namespace JSC
<span class="line-new-header">--- 834,16 ---</span>
  
      mutable InlineWatchpointSet m_transitionWatchpointSet;
  
      COMPILE_ASSERT(firstOutOfLineOffset &lt; 256, firstOutOfLineOffset_fits);
  
<span class="line-modified">!     uint16_t m_transitionOffset;</span>
<span class="line-modified">!     uint16_t m_maxOffset;</span>
  
      uint32_t m_propertyHash;
<span class="line-added">+     TinyBloomFilter m_seenProperties;</span>
<span class="line-added">+ </span>
<span class="line-added">+     friend class VMInspector;</span>
<span class="line-added">+     friend class JSDollarVMHelper;</span>
  };
  
  } // namespace JSC
</pre>
<center><a href="Structure.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructureChain.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
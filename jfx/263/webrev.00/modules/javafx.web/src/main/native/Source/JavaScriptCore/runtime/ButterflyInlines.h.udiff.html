<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ButterflyInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Butterfly.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CachePayload.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ButterflyInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (C) 2012-2018 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,11 +23,11 @@</span>
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  #pragma once
  
<span class="udiff-line-modified-removed">- #include &quot;ArrayStorage.h&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;ArrayStorageInlines.h&quot;</span>
  #include &quot;Butterfly.h&quot;
  #include &quot;JSObject.h&quot;
  #include &quot;Structure.h&quot;
  #include &quot;VM.h&quot;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102,11 +102,11 @@</span>
      if (!base)
          return nullptr;
      Butterfly* result = fromBase(base, preCapacity, propertyCapacity);
      if (hasIndexingHeader)
          *result-&gt;indexingHeader() = indexingHeader;
<span class="udiff-line-modified-removed">-     memset(result-&gt;propertyStorage() - propertyCapacity, 0, propertyCapacity * sizeof(EncodedJSValue));</span>
<span class="udiff-line-modified-added">+     gcSafeZeroMemory(result-&gt;propertyStorage() - propertyCapacity, propertyCapacity * sizeof(EncodedJSValue));</span>
      return result;
  }
  
  inline Butterfly* Butterfly::create(VM&amp; vm, JSObject* intendedOwner, size_t preCapacity, size_t propertyCapacity, bool hasIndexingHeader, const IndexingHeader&amp; indexingHeader, size_t indexingPayloadSizeInBytes)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -137,17 +137,16 @@</span>
  
      size_t preCapacity = oldButterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
      size_t indexingPayloadSizeInBytes = oldButterfly-&gt;indexingHeader()-&gt;indexingPayloadSizeInBytes(structure);
      bool hasIndexingHeader = structure-&gt;hasIndexingHeader(intendedOwner);
      Butterfly* result = createUninitialized(vm, intendedOwner, preCapacity, newPropertyCapacity, hasIndexingHeader, indexingPayloadSizeInBytes);
<span class="udiff-line-modified-removed">-     memcpy(</span>
<span class="udiff-line-modified-added">+     gcSafeMemcpy(</span>
          result-&gt;propertyStorage() - oldPropertyCapacity,
          oldButterfly-&gt;propertyStorage() - oldPropertyCapacity,
          totalSize(0, oldPropertyCapacity, hasIndexingHeader, indexingPayloadSizeInBytes));
<span class="udiff-line-modified-removed">-     memset(</span>
<span class="udiff-line-modified-added">+     gcSafeZeroMemory(</span>
          result-&gt;propertyStorage() - newPropertyCapacity,
<span class="udiff-line-removed">-         0,</span>
          (newPropertyCapacity - oldPropertyCapacity) * sizeof(EncodedJSValue));
      return result;
  }
  
  inline Butterfly* Butterfly::createOrGrowArrayRight(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -177,11 +176,11 @@</span>
      size_t newSize = totalSize(0, propertyCapacity, true, newIndexingPayloadSizeInBytes);
      void* newBase = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(vm, newSize, nullptr, AllocationFailureMode::ReturnNull);
      if (!newBase)
          return nullptr;
      // FIXME: This probably shouldn&#39;t be a memcpy.
<span class="udiff-line-modified-removed">-     memcpy(newBase, theBase, oldSize);</span>
<span class="udiff-line-modified-added">+     gcSafeMemcpy(static_cast&lt;JSValue*&gt;(newBase), static_cast&lt;JSValue*&gt;(theBase), oldSize);</span>
      return fromBase(newBase, 0, propertyCapacity);
  }
  
  inline Butterfly* Butterfly::growArrayRight(
      VM&amp; vm, JSObject* intendedOwner, Structure* oldStructure,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -205,25 +204,25 @@</span>
      void* theBase = base(0, propertyCapacity);
      size_t oldSize = totalSize(0, propertyCapacity, hadIndexingHeader, oldIndexingPayloadSizeInBytes);
      size_t newSize = totalSize(0, propertyCapacity, true, newIndexingPayloadSizeInBytes);
      ASSERT(newSize &gt;= oldSize);
  
<span class="udiff-line-modified-removed">-     // We can eagerly destroy butterfly backed by LargeAllocation if (1) concurrent collector is not active and (2) the butterfly does not contain any property storage.</span>
<span class="udiff-line-modified-added">+     // We can eagerly destroy butterfly backed by PreciseAllocation if (1) concurrent collector is not active and (2) the butterfly does not contain any property storage.</span>
      // This is because during deallocation concurrent collector can access butterfly and DFG concurrent compilers accesses properties.
      // Objects with no properties are common in arrays, and we are focusing on very large array crafted by repeating Array#push, so... that&#39;s fine!
<span class="udiff-line-modified-removed">-     bool canRealloc = !propertyCapacity &amp;&amp; !vm.heap.mutatorShouldBeFenced() &amp;&amp; bitwise_cast&lt;HeapCell*&gt;(theBase)-&gt;isLargeAllocation();</span>
<span class="udiff-line-modified-added">+     bool canRealloc = !propertyCapacity &amp;&amp; !vm.heap.mutatorShouldBeFenced() &amp;&amp; bitwise_cast&lt;HeapCell*&gt;(theBase)-&gt;isPreciseAllocation();</span>
      if (canRealloc) {
<span class="udiff-line-modified-removed">-         void* newBase = vm.jsValueGigacageAuxiliarySpace.reallocateLargeAllocationNonVirtual(vm, bitwise_cast&lt;HeapCell*&gt;(theBase), newSize, &amp;deferralContext, AllocationFailureMode::ReturnNull);</span>
<span class="udiff-line-modified-added">+         void* newBase = vm.jsValueGigacageAuxiliarySpace.reallocatePreciseAllocationNonVirtual(vm, bitwise_cast&lt;HeapCell*&gt;(theBase), newSize, &amp;deferralContext, AllocationFailureMode::ReturnNull);</span>
          if (!newBase)
              return nullptr;
          return fromBase(newBase, 0, propertyCapacity);
      }
  
      void* newBase = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(vm, newSize, &amp;deferralContext, AllocationFailureMode::ReturnNull);
      if (!newBase)
          return nullptr;
<span class="udiff-line-modified-removed">-     memcpy(newBase, theBase, oldSize);</span>
<span class="udiff-line-modified-added">+     gcSafeMemcpy(static_cast&lt;JSValue*&gt;(newBase), static_cast&lt;JSValue*&gt;(theBase), oldSize);</span>
      return fromBase(newBase, 0, propertyCapacity);
  }
  
  inline Butterfly* Butterfly::resizeArray(
      VM&amp; vm, JSObject* intendedOwner, size_t propertyCapacity, bool oldHasIndexingHeader,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -236,11 +235,11 @@</span>
      void* to = result-&gt;propertyStorage() - propertyCapacity;
      void* from = propertyStorage() - propertyCapacity;
      size_t size = std::min(
          totalSize(0, propertyCapacity, oldHasIndexingHeader, oldIndexingPayloadSizeInBytes),
          totalSize(0, propertyCapacity, newHasIndexingHeader, newIndexingPayloadSizeInBytes));
<span class="udiff-line-modified-removed">-     memcpy(to, from, size);</span>
<span class="udiff-line-modified-added">+     gcSafeMemcpy(static_cast&lt;JSValue*&gt;(to), static_cast&lt;JSValue*&gt;(from), size);</span>
      return result;
  }
  
  inline Butterfly* Butterfly::resizeArray(
      VM&amp; vm, JSObject* intendedOwner, Structure* structure, size_t newPreCapacity,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -263,11 +262,11 @@</span>
      // moving a small amount of memory in the common case so the throughput of memmove won&#39;t
      // amortize the overhead of calling it. And no, we cannot rely on the C++ compiler to
      // inline memmove (particularly since the size argument is likely to be variable), nor can
      // we rely on the compiler to recognize the ordering of the pointer arguments (since
      // propertyCapacity is variable and could cause wrap-around as far as the compiler knows).
<span class="udiff-line-modified-removed">-     memmove(</span>
<span class="udiff-line-modified-added">+     gcSafeMemmove(</span>
          propertyStorage() - numberOfSlots - propertyCapacity,
          propertyStorage() - propertyCapacity,
          sizeof(EncodedJSValue) * propertyCapacity + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));
      return IndexingHeader::fromEndOf(propertyStorage() - numberOfSlots)-&gt;butterfly();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -275,11 +274,11 @@</span>
  inline Butterfly* Butterfly::shift(Structure* structure, size_t numberOfSlots)
  {
      ASSERT(hasAnyArrayStorage(structure-&gt;indexingType()));
      unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
      // FIXME: See comment in unshift(), above.
<span class="udiff-line-modified-removed">-     memmove(</span>
<span class="udiff-line-modified-added">+     gcSafeMemmove(</span>
          propertyStorage() - propertyCapacity + numberOfSlots,
          propertyStorage() - propertyCapacity,
          sizeof(EncodedJSValue) * propertyCapacity + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));
      return IndexingHeader::fromEndOf(propertyStorage() + numberOfSlots)-&gt;butterfly();
  }
</pre>
<center><a href="Butterfly.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CachePayload.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
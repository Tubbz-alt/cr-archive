<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/ChromeClient.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006-2018 Apple, Inc. All rights reserved.
  3  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
  4  * Copyright (C) 2012 Samsung Electronics. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;AXObjectCache.h&quot;
 25 #include &quot;AutoplayEvent.h&quot;
 26 #include &quot;Cursor.h&quot;
 27 #include &quot;DatabaseDetails.h&quot;
 28 #include &quot;DeviceOrientationOrMotionPermissionState.h&quot;
 29 #include &quot;DisabledAdaptations.h&quot;
 30 #include &quot;DisplayRefreshMonitor.h&quot;
 31 #include &quot;DocumentStorageAccess.h&quot;
 32 #include &quot;FocusDirection.h&quot;
 33 #include &quot;FrameLoader.h&quot;
 34 #include &quot;GraphicsContext.h&quot;
 35 #include &quot;GraphicsLayer.h&quot;
 36 #include &quot;HTMLMediaElementEnums.h&quot;
 37 #include &quot;HostWindow.h&quot;
 38 #include &quot;Icon.h&quot;
 39 #include &quot;InputMode.h&quot;
 40 #include &quot;LayerFlushThrottleState.h&quot;
 41 #include &quot;MediaProducer.h&quot;
 42 #include &quot;PopupMenu.h&quot;
 43 #include &quot;PopupMenuClient.h&quot;
 44 #include &quot;RegistrableDomain.h&quot;
 45 #include &quot;RenderEmbeddedObject.h&quot;
 46 #include &quot;ScrollTypes.h&quot;
 47 #include &quot;ScrollingCoordinator.h&quot;
 48 #include &quot;SearchPopupMenu.h&quot;
 49 #include &quot;WebCoreKeyboardUIMode.h&quot;
 50 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
 51 #include &lt;wtf/Assertions.h&gt;
 52 #include &lt;wtf/CompletionHandler.h&gt;
 53 #include &lt;wtf/Forward.h&gt;
 54 #include &lt;wtf/Seconds.h&gt;
 55 
 56 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 57 #include &quot;MediaPlaybackTargetContext.h&quot;
 58 #endif
 59 
 60 #if PLATFORM(IOS_FAMILY)
 61 #include &quot;PlatformLayer.h&quot;
 62 #include &quot;WKContentObservation.h&quot;
 63 #define NSResponder WAKResponder
 64 #ifndef __OBJC__
 65 class WAKResponder;
 66 #else
 67 @class WAKResponder;
 68 #endif
 69 #endif
 70 
 71 OBJC_CLASS NSResponder;
 72 
 73 namespace WebCore {
 74 
 75 class AccessibilityObject;
 76 class ColorChooser;
 77 class ColorChooserClient;
 78 class DataListSuggestionPicker;
 79 class DataListSuggestionsClient;
 80 class DateTimeChooser;
 81 class DateTimeChooserClient;
 82 class Element;
 83 class FileChooser;
 84 class FileIconLoader;
 85 class FloatRect;
 86 class Frame;
 87 class FrameLoadRequest;
 88 class Geolocation;
 89 class GraphicsLayer;
 90 class GraphicsLayerFactory;
 91 class HTMLImageElement;
 92 class HTMLInputElement;
 93 class HTMLMediaElement;
 94 class HTMLVideoElement;
 95 class HitTestResult;
 96 class IntRect;
 97 class MediaSessionMetadata;
 98 class NavigationAction;
 99 class Node;
100 class Page;
101 class PopupMenuClient;
102 class SecurityOrigin;
103 class ViewportConstraints;
104 class Widget;
105 
106 #if ENABLE(VIDEO) &amp;&amp; USE(GSTREAMER)
107 class MediaPlayerRequestInstallMissingPluginsCallback;
108 #endif
109 
110 struct ContentRuleListResults;
111 struct DateTimeChooserParameters;
112 struct GraphicsDeviceAdapter;
113 struct MockWebAuthenticationConfiguration;
114 struct ShareDataWithParsedURL;
115 struct ViewportArguments;
116 struct WindowFeatures;
117 
118 enum class RouteSharingPolicy : uint8_t;
119 
120 class ChromeClient {
121 public:
122     virtual void chromeDestroyed() = 0;
123 
124     virtual void setWindowRect(const FloatRect&amp;) = 0;
125     virtual FloatRect windowRect() = 0;
126 
127     virtual FloatRect pageRect() = 0;
128 
129     virtual void focus() = 0;
130     virtual void unfocus() = 0;
131 
132     virtual bool canTakeFocus(FocusDirection) = 0;
133     virtual void takeFocus(FocusDirection) = 0;
134 
135     virtual void focusedElementChanged(Element*) = 0;
136     virtual void focusedFrameChanged(Frame*) = 0;
137 
138     // The Frame pointer provides the ChromeClient with context about which
139     // Frame wants to create the new Page. Also, the newly created window
140     // should not be shown to the user until the ChromeClient of the newly
141     // created Page has its show method called.
142     // The FrameLoadRequest parameter is only for ChromeClient to check if the
143     // request could be fulfilled. The ChromeClient should not load the request.
144     virtual Page* createWindow(Frame&amp;, const FrameLoadRequest&amp;, const WindowFeatures&amp;, const NavigationAction&amp;) = 0;
145     virtual void show() = 0;
146 
147     virtual bool canRunModal() = 0;
148     virtual void runModal() = 0;
149 
150     virtual void setToolbarsVisible(bool) = 0;
151     virtual bool toolbarsVisible() = 0;
152 
153     virtual void setStatusbarVisible(bool) = 0;
154     virtual bool statusbarVisible() = 0;
155 
156     virtual void setScrollbarsVisible(bool) = 0;
157     virtual bool scrollbarsVisible() = 0;
158 
159     virtual void setMenubarVisible(bool) = 0;
160     virtual bool menubarVisible() = 0;
161 
162     virtual void setResizable(bool) = 0;
163 
164     virtual void addMessageToConsole(MessageSource, MessageLevel, const String&amp; message, unsigned lineNumber, unsigned columnNumber, const String&amp; sourceID) = 0;
165 
166     virtual bool canRunBeforeUnloadConfirmPanel() = 0;
167     virtual bool runBeforeUnloadConfirmPanel(const String&amp; message, Frame&amp;) = 0;
168 
169     virtual void closeWindowSoon() = 0;
170 
171     virtual void runJavaScriptAlert(Frame&amp;, const String&amp;) = 0;
172     virtual bool runJavaScriptConfirm(Frame&amp;, const String&amp;) = 0;
173     virtual bool runJavaScriptPrompt(Frame&amp;, const String&amp; message, const String&amp; defaultValue, String&amp; result) = 0;
174     virtual void setStatusbarText(const String&amp;) = 0;
175     virtual KeyboardUIMode keyboardUIMode() = 0;
176 
177     virtual bool supportsImmediateInvalidation() { return false; }
178     virtual void invalidateRootView(const IntRect&amp;) = 0;
179     virtual void invalidateContentsAndRootView(const IntRect&amp;) = 0;
180     virtual void invalidateContentsForSlowScroll(const IntRect&amp;) = 0;
181     virtual void scroll(const IntSize&amp;, const IntRect&amp;, const IntRect&amp;) = 0;
182 
183     virtual IntPoint screenToRootView(const IntPoint&amp;) const = 0;
184     virtual IntRect rootViewToScreen(const IntRect&amp;) const = 0;
185     virtual IntPoint accessibilityScreenToRootView(const IntPoint&amp;) const = 0;
186     virtual IntRect rootViewToAccessibilityScreen(const IntRect&amp;) const = 0;
187 
188     virtual void didFinishLoadingImageForElement(HTMLImageElement&amp;) = 0;
189 
190     virtual PlatformPageClient platformPageClient() const = 0;
191 
192     virtual void setCursor(const Cursor&amp;) = 0;
193     virtual void setCursorHiddenUntilMouseMoves(bool) = 0;
194     virtual bool supportsSettingCursor() { return true; }
195 
196     virtual bool shouldUseMouseEventForSelection(const PlatformMouseEvent&amp;) { return true; }
197 
198     virtual FloatSize screenSize() const { return const_cast&lt;ChromeClient&amp;&gt;(*this).windowRect().size(); }
199     virtual FloatSize availableScreenSize() const { return const_cast&lt;ChromeClient&amp;&gt;(*this).windowRect().size(); }
200     virtual FloatSize overrideScreenSize() const { return const_cast&lt;ChromeClient&amp;&gt;(*this).windowRect().size(); }
201 
202     virtual void dispatchDisabledAdaptationsDidChange(const OptionSet&lt;DisabledAdaptations&gt;&amp;) const { }
203     virtual void dispatchViewportPropertiesDidChange(const ViewportArguments&amp;) const { }
204 
205     virtual void contentsSizeChanged(Frame&amp;, const IntSize&amp;) const = 0;
206     virtual void intrinsicContentsSizeChanged(const IntSize&amp;) const = 0;
207     virtual void scrollRectIntoView(const IntRect&amp;) const { }; // Currently only Mac has a non empty implementation.
208 
209     virtual bool shouldUnavailablePluginMessageBeButton(RenderEmbeddedObject::PluginUnavailabilityReason) const { return false; }
210     virtual void unavailablePluginButtonClicked(Element&amp;, RenderEmbeddedObject::PluginUnavailabilityReason) const { }
211     virtual void mouseDidMoveOverElement(const HitTestResult&amp;, unsigned modifierFlags, const String&amp; toolTip, TextDirection) = 0;
212 
213     virtual void print(Frame&amp;) = 0;
214 
215     virtual Color underlayColor() const { return Color(); }
216 
217     virtual void pageExtendedBackgroundColorDidChange(Color) const { }
218 
219     virtual void exceededDatabaseQuota(Frame&amp;, const String&amp; databaseName, DatabaseDetails) = 0;
220 
221     // Callback invoked when the application cache fails to save a cache object
222     // because storing it would grow the database file past its defined maximum
223     // size or past the amount of free space on the device.
224     // The chrome client would need to take some action such as evicting some
225     // old caches.
226     virtual void reachedMaxAppCacheSize(int64_t spaceNeeded) = 0;
227 
228     // Callback invoked when the application cache origin quota is reached. This
229     // means that the resources attempting to be cached via the manifest are
230     // more than allowed on this origin. This callback allows the chrome client
231     // to take action, such as prompting the user to ask to increase the quota
232     // for this origin. The totalSpaceNeeded parameter is the total amount of
233     // storage, in bytes, needed to store the new cache along with all of the
234     // other existing caches for the origin that would not be replaced by
235     // the new cache.
236     virtual void reachedApplicationCacheOriginQuota(SecurityOrigin&amp;, int64_t totalSpaceNeeded) = 0;
237 
238 #if ENABLE(IOS_TOUCH_EVENTS)
239     virtual void didPreventDefaultForEvent() = 0;
240 #endif
241 
242     virtual Seconds eventThrottlingDelay() { return 0_s; };
243 
244 #if PLATFORM(IOS_FAMILY)
245     virtual void didReceiveMobileDocType(bool) = 0;
246     virtual void setNeedsScrollNotifications(Frame&amp;, bool) = 0;
247     virtual void didFinishContentChangeObserving(Frame&amp;, WKContentChange) = 0;
248     virtual void notifyRevealedSelectionByScrollingFrame(Frame&amp;) = 0;
249 
250     enum LayoutType { NormalLayout, Scroll };
251     virtual void didLayout(LayoutType = NormalLayout) = 0;
252     virtual void didStartOverflowScroll() = 0;
253     virtual void didEndOverflowScroll() = 0;
254 
255     // FIXME: Remove this functionality. This functionality was added to workaround an issue (&lt;rdar://problem/5973875&gt;)
256     // where the unconfirmed text in a text area would be removed when a person clicks in the text area before a
257     // suggestion is shown. We should fix this issue in &lt;rdar://problem/5975559&gt;.
258     virtual void suppressFormNotifications() = 0;
259     virtual void restoreFormNotifications() = 0;
260 
261     virtual void didFlushCompositingLayers() { }
262 
263     virtual bool fetchCustomFixedPositionLayoutRect(IntRect&amp;) { return false; }
264 
265     virtual void updateViewportConstrainedLayers(HashMap&lt;PlatformLayer*, std::unique_ptr&lt;ViewportConstraints&gt;&gt;&amp;, const HashMap&lt;PlatformLayer*, PlatformLayer*&gt;&amp;) { }
266 
267     virtual void addOrUpdateScrollingLayer(Node*, PlatformLayer* scrollingLayer, PlatformLayer* contentsLayer, const IntSize&amp; scrollSize, bool allowHorizontalScrollbar, bool allowVerticalScrollbar) = 0;
268     virtual void removeScrollingLayer(Node*, PlatformLayer* scrollingLayer, PlatformLayer* contentsLayer) = 0;
269 
270     virtual void webAppOrientationsUpdated() = 0;
271     virtual void showPlaybackTargetPicker(bool hasVideo, RouteSharingPolicy, const String&amp;) = 0;
272 #endif
273 
274 #if ENABLE(ORIENTATION_EVENTS)
275     virtual int deviceOrientation() const = 0;
276 #endif
277 
278 #if ENABLE(INPUT_TYPE_COLOR)
279     virtual std::unique_ptr&lt;ColorChooser&gt; createColorChooser(ColorChooserClient&amp;, const Color&amp;) = 0;
280 #endif
281 
282 #if ENABLE(DATALIST_ELEMENT)
283     virtual std::unique_ptr&lt;DataListSuggestionPicker&gt; createDataListSuggestionPicker(DataListSuggestionsClient&amp;) = 0;
284 #endif
285 
286     virtual void runOpenPanel(Frame&amp;, FileChooser&amp;) = 0;
287     virtual void showShareSheet(ShareDataWithParsedURL&amp;, WTF::CompletionHandler&lt;void(bool)&gt;&amp;&amp; callback) { callback(false); }
288 
289     // Asynchronous request to load an icon for specified filenames.
290     virtual void loadIconForFiles(const Vector&lt;String&gt;&amp;, FileIconLoader&amp;) = 0;
291 
292     virtual void elementDidFocus(Element&amp;) { }
293     virtual void elementDidBlur(Element&amp;) { }
294     virtual void elementDidRefocus(Element&amp;) { }
295 
296     virtual void focusedElementDidChangeInputMode(Element&amp;, InputMode) { }
297 
298     virtual bool shouldPaintEntireContents() const { return false; }
299     virtual bool hasStablePageScaleFactor() const { return true; }
300 
301     // Allows ports to customize the type of graphics layers created by this page.
302     virtual GraphicsLayerFactory* graphicsLayerFactory() const { return nullptr; }
303 
304 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
305     virtual RefPtr&lt;DisplayRefreshMonitor&gt; createDisplayRefreshMonitor(PlatformDisplayID) const { return nullptr; }
306 #endif
307 
308     // Pass nullptr as the GraphicsLayer to detatch the root layer.
309     virtual void attachRootGraphicsLayer(Frame&amp;, GraphicsLayer*) = 0;
310     virtual void attachViewOverlayGraphicsLayer(GraphicsLayer*) = 0;
311     // Sets a flag to specify that the next time content is drawn to the window,
312     // the changes appear on the screen in synchrony with updates to GraphicsLayers.
313     virtual void setNeedsOneShotDrawingSynchronization() = 0;
314     // Sets a flag to specify that the view needs to be updated, so we need
315     // to do an eager layout before the drawing.
316     virtual void scheduleCompositingLayerFlush() = 0;
317     virtual bool needsImmediateRenderingUpdate() const { return false; }
318     // Returns whether or not the client can render the composited layer,
319     // regardless of the settings.
320     virtual bool allowsAcceleratedCompositing() const { return true; }
321 
322     enum CompositingTrigger {
323         ThreeDTransformTrigger = 1 &lt;&lt; 0,
324         VideoTrigger = 1 &lt;&lt; 1,
325         PluginTrigger = 1 &lt;&lt; 2,
326         CanvasTrigger = 1 &lt;&lt; 3,
327         AnimationTrigger = 1 &lt;&lt; 4,
328         FilterTrigger = 1 &lt;&lt; 5,
329         ScrollableNonMainFrameTrigger = 1 &lt;&lt; 6,
330         AnimatedOpacityTrigger = 1 &lt;&lt; 7,
331         AllTriggers = 0xFFFFFFFF
332     };
333     typedef unsigned CompositingTriggerFlags;
334 
335     // Returns a bitfield indicating conditions that can trigger the compositor.
336     virtual CompositingTriggerFlags allowedCompositingTriggers() const { return static_cast&lt;CompositingTriggerFlags&gt;(AllTriggers); }
337 
338     // Returns true if layer tree updates are disabled.
339     virtual bool layerTreeStateIsFrozen() const { return false; }
340     virtual bool layerFlushThrottlingIsActive() const { return false; }
341 
342     virtual bool adjustLayerFlushThrottling(LayerFlushThrottleState::Flags) { return false; }
343 
344     virtual RefPtr&lt;ScrollingCoordinator&gt; createScrollingCoordinator(Page&amp;) const { return nullptr; }
345 
346 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
347     virtual GraphicsDeviceAdapter* graphicsDeviceAdapter() const { return nullptr; }
348 #endif
349 
350     virtual bool supportsVideoFullscreen(HTMLMediaElementEnums::VideoFullscreenMode) { return false; }
351     virtual bool supportsVideoFullscreenStandby() { return false; }
352 
353 #if ENABLE(VIDEO)
354     virtual void enterVideoFullscreenForVideoElement(HTMLVideoElement&amp;, HTMLMediaElementEnums::VideoFullscreenMode, bool standby) { UNUSED_PARAM(standby); }
355     virtual void setUpPlaybackControlsManager(HTMLMediaElement&amp;) { }
356     virtual void clearPlaybackControlsManager() { }
357 #endif
358 
359     virtual void exitVideoFullscreenForVideoElement(HTMLVideoElement&amp;) { }
360     virtual void exitVideoFullscreenToModeWithoutAnimation(HTMLVideoElement&amp;, HTMLMediaElementEnums::VideoFullscreenMode) { }
361     virtual bool requiresFullscreenForVideoPlayback() { return false; }
362 
363 #if ENABLE(FULLSCREEN_API)
364     virtual bool supportsFullScreenForElement(const Element&amp;, bool) { return false; }
365     virtual void enterFullScreenForElement(Element&amp;) { }
366     virtual void exitFullScreenForElement(Element*) { }
367     virtual void setRootFullScreenLayer(GraphicsLayer*) { }
368 #endif
369 
370 #if USE(COORDINATED_GRAPHICS)
371     virtual IntRect visibleRectForTiledBackingStore() const { return IntRect(); }
372 #endif
373 
374 #if PLATFORM(COCOA)
375     virtual NSResponder *firstResponder() { return nullptr; }
376     virtual void makeFirstResponder(NSResponder *) { }
377     // Focuses on the containing view associated with this page.
378     virtual void makeFirstResponder() { }
379     virtual void assistiveTechnologyMakeFirstResponder() { }
380 #endif
381 
382     virtual bool testProcessIncomingSyncMessagesWhenWaitingForSyncReply() { return true; }
383 
384 #if PLATFORM(IOS_FAMILY)
385     // FIXME: Come up with a more descriptive name for this function and make it platform independent (if possible).
386     virtual bool isStopping() = 0;
387 #endif
388 
389     virtual void enableSuddenTermination() { }
390     virtual void disableSuddenTermination() { }
391 
392     virtual void contentRuleListNotification(const URL&amp;, const ContentRuleListResults&amp;) { };
393 
394 #if PLATFORM(WIN)
395     virtual void setLastSetCursorToCurrentCursor() = 0;
396     virtual void AXStartFrameLoad() = 0;
397     virtual void AXFinishFrameLoad() = 0;
398 #endif
399 
400     virtual bool selectItemWritingDirectionIsNatural() = 0;
401     virtual bool selectItemAlignmentFollowsMenuWritingDirection() = 0;
402     // Checks if there is an opened popup, called by RenderMenuList::showPopup().
403     virtual RefPtr&lt;PopupMenu&gt; createPopupMenu(PopupMenuClient&amp;) const = 0;
404     virtual RefPtr&lt;SearchPopupMenu&gt; createSearchPopupMenu(PopupMenuClient&amp;) const = 0;
405 
406     virtual void postAccessibilityNotification(AccessibilityObject&amp;, AXObjectCache::AXNotification) { }
407 
408     virtual void notifyScrollerThumbIsVisibleInRect(const IntRect&amp;) { }
409     virtual void recommendedScrollbarStyleDidChange(ScrollbarStyle) { }
410 
411     virtual Optional&lt;ScrollbarOverlayStyle&gt; preferredScrollbarOverlayStyle() { return WTF::nullopt; }
412 
413     virtual void wheelEventHandlersChanged(bool hasHandlers) = 0;
414 
415     virtual bool isSVGImageChromeClient() const { return false; }
416 
417 #if ENABLE(POINTER_LOCK)
418     virtual bool requestPointerLock() { return false; }
419     virtual void requestPointerUnlock() { }
420 #endif
421 
422     virtual FloatSize minimumWindowSize() const { return FloatSize(100, 100); };
423 
424     virtual bool isEmptyChromeClient() const { return false; }
425 
426     virtual String plugInStartLabelTitle(const String&amp; mimeType) const { UNUSED_PARAM(mimeType); return String(); }
427     virtual String plugInStartLabelSubtitle(const String&amp; mimeType) const { UNUSED_PARAM(mimeType); return String(); }
428     virtual String plugInExtraStyleSheet() const { return String(); }
429     virtual String plugInExtraScript() const { return String(); }
430 
431     virtual void didAssociateFormControls(const Vector&lt;RefPtr&lt;Element&gt;&gt;&amp;, Frame&amp;) { };
432     virtual bool shouldNotifyOnFormChanges() { return false; };
433 
434     virtual void didAddHeaderLayer(GraphicsLayer&amp;) { }
435     virtual void didAddFooterLayer(GraphicsLayer&amp;) { }
436 
437     virtual bool shouldUseTiledBackingForFrameView(const FrameView&amp;) const { return false; }
438 
439     virtual void isPlayingMediaDidChange(MediaProducer::MediaStateFlags, uint64_t) { }
440     virtual void handleAutoplayEvent(AutoplayEvent, OptionSet&lt;AutoplayEventFlags&gt;) { }
441 
442 #if ENABLE(MEDIA_SESSION)
443     virtual void hasMediaSessionWithActiveMediaElementsDidChange(bool) { }
444     virtual void mediaSessionMetadataDidChange(const MediaSessionMetadata&amp;) { }
445     virtual void focusedContentMediaElementDidChange(uint64_t) { }
446 #endif
447 
448 #if ENABLE(WEB_CRYPTO)
449     virtual bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp;, Vector&lt;uint8_t&gt;&amp;) const { return false; }
450     virtual bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp;, Vector&lt;uint8_t&gt;&amp;) const { return false; }
451 #endif
452 
453 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; PLATFORM(MAC)
454     virtual void handleTelephoneNumberClick(const String&amp;, const IntPoint&amp;) { }
455 #endif
456 
457 #if ENABLE(SERVICE_CONTROLS)
458     virtual void handleSelectionServiceClick(FrameSelection&amp;, const Vector&lt;String&gt;&amp;, const IntPoint&amp;) { }
459     virtual bool hasRelevantSelectionServices(bool /*isTextOnly*/) const { return false; }
460 #endif
461 
462     virtual bool shouldDispatchFakeMouseMoveEvents() const { return true; }
463 
464     virtual void handleAutoFillButtonClick(HTMLInputElement&amp;) { }
465 
466     virtual void inputElementDidResignStrongPasswordAppearance(HTMLInputElement&amp;) { };
467 
468 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
469     virtual void addPlaybackTargetPickerClient(uint64_t /*contextId*/) { }
470     virtual void removePlaybackTargetPickerClient(uint64_t /*contextId*/) { }
471     virtual void showPlaybackTargetPicker(uint64_t /*contextId*/, const IntPoint&amp;, bool /*isVideo*/) { }
472     virtual void playbackTargetPickerClientStateDidChange(uint64_t /*contextId*/, MediaProducer::MediaStateFlags) { }
473     virtual void setMockMediaPlaybackTargetPickerEnabled(bool)  { }
474     virtual void setMockMediaPlaybackTargetPickerState(const String&amp;, MediaPlaybackTargetContext::State) { }
475     virtual void mockMediaPlaybackTargetPickerDismissPopup() { }
476 #endif
477 
478     virtual void imageOrMediaDocumentSizeChanged(const IntSize&amp;) { }
479 
480 #if ENABLE(VIDEO) &amp;&amp; USE(GSTREAMER)
481     virtual void requestInstallMissingMediaPlugins(const String&amp; /*details*/, const String&amp; /*description*/, MediaPlayerRequestInstallMissingPluginsCallback&amp;) { }
482 #endif
483 
484     virtual void didInvalidateDocumentMarkerRects() { }
485 
486     virtual void reportProcessCPUTime(Seconds, ActivityStateForCPUSampling) { }
487     virtual RefPtr&lt;Icon&gt; createIconForFiles(const Vector&lt;String&gt;&amp; /* filenames */) = 0;
488 
489 #if ENABLE(RESOURCE_LOAD_STATISTICS)
490     virtual void hasStorageAccess(RegistrableDomain&amp;&amp; /*subFrameDomain*/, RegistrableDomain&amp;&amp; /*topFrameDomain*/, Frame&amp;, WTF::CompletionHandler&lt;void(bool)&gt;&amp;&amp; completionHandler) { completionHandler(false); }
491     virtual void requestStorageAccess(RegistrableDomain&amp;&amp; /*subFrameDomain*/, RegistrableDomain&amp;&amp; /*topFrameDomain*/, Frame&amp;, WTF::CompletionHandler&lt;void(StorageAccessWasGranted, StorageAccessPromptWasShown)&gt;&amp;&amp; completionHandler) { completionHandler(StorageAccessWasGranted::No, StorageAccessPromptWasShown::No); }
492 #endif
493 
494 #if ENABLE(DEVICE_ORIENTATION)
495     virtual void shouldAllowDeviceOrientationAndMotionAccess(Frame&amp;, bool /* mayPrompt */, WTF::CompletionHandler&lt;void(DeviceOrientationOrMotionPermissionState)&gt;&amp;&amp; callback) { callback(DeviceOrientationOrMotionPermissionState::Denied); }
496 #endif
497 
498     virtual void didInsertMenuElement(HTMLMenuElement&amp;) { }
499     virtual void didRemoveMenuElement(HTMLMenuElement&amp;) { }
500     virtual void didInsertMenuItemElement(HTMLMenuItemElement&amp;) { }
501     virtual void didRemoveMenuItemElement(HTMLMenuItemElement&amp;) { }
502 
503     virtual String signedPublicKeyAndChallengeString(unsigned, const String&amp;, const URL&amp;) const { return emptyString(); }
504 
505     virtual void associateEditableImageWithAttachment(GraphicsLayer::EmbeddedViewID, const String&amp;) { }
506     virtual void didCreateEditableImage(GraphicsLayer::EmbeddedViewID) { }
507     virtual void didDestroyEditableImage(GraphicsLayer::EmbeddedViewID) { }
508 
509     virtual void configureLoggingChannel(const String&amp;, WTFLogChannelState, WTFLogLevel) { }
510 
511     virtual bool userIsInteracting() const { return false; }
512     virtual void setUserIsInteracting(bool) { }
513 
514 #if ENABLE(WEB_AUTHN)
515     virtual void setMockWebAuthenticationConfiguration(const MockWebAuthenticationConfiguration&amp;) { }
516 #endif
517 
518 protected:
519     virtual ~ChromeClient() = default;
520 };
521 
522 } // namespace WebCore
    </pre>
  </body>
</html>
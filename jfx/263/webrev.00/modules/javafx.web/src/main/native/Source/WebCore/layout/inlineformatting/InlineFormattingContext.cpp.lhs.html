<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
<a name="1" id="anc1"></a>

 31 #include &quot;InlineFormattingState.h&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 32 #include &quot;InlineLineBreaker.h&quot;</span>
 33 #include &quot;InlineTextItem.h&quot;
<a name="3" id="anc3"></a>
 34 #include &quot;LayoutBox.h&quot;
 35 #include &quot;LayoutContainer.h&quot;
<a name="4" id="anc4"></a>
 36 #include &quot;LayoutState.h&quot;
 37 #include &quot;Logging.h&quot;
<a name="5" id="anc5"></a><span class="line-modified"> 38 #include &quot;Textutil.h&quot;</span>

 39 #include &lt;wtf/IsoMallocInlines.h&gt;
 40 #include &lt;wtf/text/TextStream.h&gt;
 41 
 42 namespace WebCore {
 43 namespace Layout {
 44 
 45 WTF_MAKE_ISO_ALLOCATED_IMPL(InlineFormattingContext);
 46 
<a name="6" id="anc6"></a><span class="line-modified"> 47 InlineFormattingContext::InlineFormattingContext(const Box&amp; formattingContextRoot, InlineFormattingState&amp; formattingState)</span>
 48     : FormattingContext(formattingContextRoot, formattingState)
 49 {
 50 }
 51 
<a name="7" id="anc7"></a><span class="line-modified"> 52 static inline const Box* nextInPreOrder(const Box&amp; layoutBox, const Container&amp; stayWithin)</span>
 53 {
<a name="8" id="anc8"></a><span class="line-modified"> 54     const Box* nextInPreOrder = nullptr;</span>
<span class="line-modified"> 55     if (!layoutBox.establishesFormattingContext() &amp;&amp; is&lt;Container&gt;(layoutBox) &amp;&amp; downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())</span>
<span class="line-modified"> 56         return downcast&lt;Container&gt;(layoutBox).firstInFlowOrFloatingChild();</span>







 57 
<a name="9" id="anc9"></a><span class="line-modified"> 58     for (nextInPreOrder = &amp;layoutBox; nextInPreOrder &amp;&amp; nextInPreOrder != &amp;stayWithin; nextInPreOrder = nextInPreOrder-&gt;parent()) {</span>
 59         if (auto* nextSibling = nextInPreOrder-&gt;nextInFlowOrFloatingSibling())
 60             return nextSibling;
 61     }
 62     return nullptr;
 63 }
 64 
<a name="10" id="anc10"></a><span class="line-modified"> 65 void InlineFormattingContext::layout() const</span>
 66 {
<a name="11" id="anc11"></a><span class="line-modified"> 67     if (!is&lt;Container&gt;(root()))</span>
<span class="line-modified"> 68         return;</span>
<span class="line-removed"> 69 </span>
<span class="line-removed"> 70     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());</span>
<span class="line-removed"> 71     if (!root.hasInFlowOrFloatingChild())</span>
<span class="line-removed"> 72         return;</span>
 73 
<a name="12" id="anc12"></a><span class="line-modified"> 74     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Start] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified"> 75     auto availableWidth = layoutState().displayBoxForLayoutBox(root).contentBoxWidth();</span>
<span class="line-modified"> 76     auto usedValues = UsedHorizontalValues { availableWidth };</span>
<span class="line-modified"> 77     auto* layoutBox = root.firstInFlowOrFloatingChild();</span>
<span class="line-removed"> 78     // Compute width/height for non-text content and margin/border/padding for inline containers.</span>
 79     while (layoutBox) {
<a name="13" id="anc13"></a><span class="line-modified"> 80         if (layoutBox-&gt;establishesFormattingContext())</span>
<span class="line-modified"> 81             layoutFormattingContextRoot(*layoutBox, usedValues);</span>
<span class="line-modified"> 82         else if (is&lt;Container&gt;(*layoutBox))</span>
<span class="line-modified"> 83             computeMarginBorderAndPaddingForInlineContainer(downcast&lt;Container&gt;(*layoutBox), usedValues);</span>
<span class="line-modified"> 84         else if (layoutBox-&gt;isReplaced())</span>
<span class="line-modified"> 85             computeWidthAndHeightForReplacedInlineBox(*layoutBox, usedValues);</span>
<span class="line-modified"> 86         else {</span>
<span class="line-modified"> 87             ASSERT(layoutBox-&gt;isInlineLevelBox());</span>
<span class="line-modified"> 88             initializeMarginBorderAndPaddingForGenericInlineBox(*layoutBox);</span>
<span class="line-modified"> 89         }</span>
<span class="line-modified"> 90         layoutBox = nextInPreOrder(*layoutBox, root);</span>



























 91     }
 92 
<a name="14" id="anc14"></a><span class="line-modified"> 93     // FIXME: This is such a waste when intrinsic width computation already collected the inline items.</span>
<span class="line-removed"> 94     formattingState().inlineItems().clear();</span>
<span class="line-removed"> 95     formattingState().inlineRuns().clear();</span>
 96 
<a name="15" id="anc15"></a><span class="line-modified"> 97     collectInlineContent();</span>
<span class="line-modified"> 98     InlineLayout(*this).layout(formattingState().inlineItems(), availableWidth);</span>
<span class="line-modified"> 99     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[End] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root &lt;&lt; &quot;)&quot;);</span>
100 }
101 
<a name="16" id="anc16"></a><span class="line-modified">102 FormattingContext::IntrinsicWidthConstraints InlineFormattingContext::computedIntrinsicWidthConstraints() const</span>






































103 {
104     auto&amp; layoutState = this-&gt;layoutState();
105     ASSERT(!formattingState().intrinsicWidthConstraints());
106 
<a name="17" id="anc17"></a><span class="line-modified">107     if (!is&lt;Container&gt;(root()) || !downcast&lt;Container&gt;(root()).hasInFlowOrFloatingChild()) {</span>
<span class="line-modified">108         auto constraints = Geometry::constrainByMinMaxWidth(root(), { });</span>
109         formattingState().setIntrinsicWidthConstraints(constraints);
110         return constraints;
111     }
112 
<a name="18" id="anc18"></a><span class="line-removed">113     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());</span>
114     Vector&lt;const Box*&gt; formattingContextRootList;
<a name="19" id="anc19"></a><span class="line-modified">115     auto usedValues = UsedHorizontalValues { };</span>
<span class="line-modified">116     auto* layoutBox = root.firstInFlowOrFloatingChild();</span>

117     while (layoutBox) {
<a name="20" id="anc20"></a><span class="line-modified">118         if (layoutBox-&gt;establishesFormattingContext()) {</span>








119             formattingContextRootList.append(layoutBox);
<a name="21" id="anc21"></a>


120             computeIntrinsicWidthForFormattingRoot(*layoutBox);
<a name="22" id="anc22"></a><span class="line-modified">121         } else if (layoutBox-&gt;isReplaced() || is&lt;Container&gt;(*layoutBox)) {</span>
<span class="line-modified">122             computeBorderAndPadding(*layoutBox, usedValues);</span>
<span class="line-modified">123             // inline-block and replaced.</span>
<span class="line-modified">124             auto needsWidthComputation = layoutBox-&gt;isReplaced();</span>
<span class="line-modified">125             if (needsWidthComputation)</span>
<span class="line-modified">126                 computeWidthAndMargin(*layoutBox, usedValues);</span>
<span class="line-removed">127             else {</span>
<span class="line-removed">128                 // Simple inline container with no intrinsic width &lt;span&gt;.</span>
<span class="line-removed">129                 computeHorizontalMargin(*layoutBox, usedValues);</span>
<span class="line-removed">130             }</span>
<span class="line-removed">131         }</span>
<span class="line-removed">132         layoutBox = nextInPreOrder(*layoutBox, root);</span>
133     }
134 
<a name="23" id="anc23"></a><span class="line-modified">135     collectInlineContent();</span>
136 
137     auto maximumLineWidth = [&amp;](auto availableWidth) {
138         // Switch to the min/max formatting root width values before formatting the lines.
139         for (auto* formattingRoot : formattingContextRootList) {
140             auto intrinsicWidths = layoutState.formattingStateForBox(*formattingRoot).intrinsicWidthConstraintsForBox(*formattingRoot);
<a name="24" id="anc24"></a><span class="line-modified">141             auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*formattingRoot);</span>
142             auto contentWidth = (availableWidth ? intrinsicWidths-&gt;maximum : intrinsicWidths-&gt;minimum) - displayBox.horizontalMarginBorderAndPadding();
143             displayBox.setContentBoxWidth(contentWidth);
144         }
<a name="25" id="anc25"></a><span class="line-modified">145         return InlineLayout(*this).computedIntrinsicWidth(formattingState().inlineItems(), availableWidth);</span>
146     };
147 
<a name="26" id="anc26"></a><span class="line-modified">148     auto constraints = Geometry::constrainByMinMaxWidth(root, { maximumLineWidth(0), maximumLineWidth(LayoutUnit::max()) });</span>
149     formattingState().setIntrinsicWidthConstraints(constraints);
150     return constraints;
151 }
152 
<a name="27" id="anc27"></a><span class="line-modified">153 void InlineFormattingContext::initializeMarginBorderAndPaddingForGenericInlineBox(const Box&amp; layoutBox) const</span>
154 {
<a name="28" id="anc28"></a><span class="line-modified">155     ASSERT(layoutBox.isAnonymous() || layoutBox.isLineBreakBox());</span>
<span class="line-modified">156     auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">157 </span>
<span class="line-modified">158     displayBox.setVerticalMargin({ { }, { } });</span>
<span class="line-modified">159     displayBox.setHorizontalMargin({ });</span>
<span class="line-modified">160     displayBox.setBorder({ { }, { } });</span>
<span class="line-modified">161     displayBox.setPadding({ });</span>
<span class="line-modified">162 }</span>
<span class="line-modified">163 </span>
<span class="line-modified">164 void InlineFormattingContext::computeMarginBorderAndPaddingForInlineContainer(const Container&amp; container, UsedHorizontalValues usedValues) const</span>
<span class="line-modified">165 {</span>
<span class="line-modified">166     computeHorizontalMargin(container, usedValues);</span>
<span class="line-modified">167     computeBorderAndPadding(container, usedValues);</span>
<span class="line-modified">168     // Inline containers (&lt;span&gt;) have 0 vertical margins.</span>
<span class="line-modified">169     layoutState().displayBoxForLayoutBox(container).setVerticalMargin({ { }, { } });</span>


170 }
171 
<a name="29" id="anc29"></a><span class="line-modified">172 void InlineFormattingContext::computeIntrinsicWidthForFormattingRoot(const Box&amp; formattingRoot) const</span>
173 {
174     ASSERT(formattingRoot.establishesFormattingContext());
<a name="30" id="anc30"></a><span class="line-modified">175     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified">176 </span>
<span class="line-removed">177     auto usedValues = UsedHorizontalValues { };</span>
<span class="line-removed">178     computeBorderAndPadding(formattingRoot, usedValues);</span>
<span class="line-removed">179     computeHorizontalMargin(formattingRoot, usedValues);</span>
<span class="line-removed">180 </span>
<span class="line-removed">181     IntrinsicWidthConstraints constraints;</span>
<span class="line-removed">182     if (auto fixedWidth = Geometry::fixedValue(formattingRoot.style().logicalWidth()))</span>
183         constraints = { *fixedWidth, *fixedWidth };
<a name="31" id="anc31"></a><span class="line-modified">184     else</span>
<span class="line-modified">185         constraints = layoutState.createFormattingContext(formattingRoot)-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-modified">186     constraints = Geometry::constrainByMinMaxWidth(formattingRoot, constraints);</span>
<span class="line-modified">187     constraints.expand(layoutState.displayBoxForLayoutBox(formattingRoot).horizontalMarginBorderAndPadding());</span>
188     formattingState().setIntrinsicWidthConstraintsForBox(formattingRoot, constraints);
189 }
190 
<a name="32" id="anc32"></a><span class="line-modified">191 void InlineFormattingContext::computeHorizontalMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const</span>
192 {
<a name="33" id="anc33"></a><span class="line-modified">193     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
<span class="line-modified">194     auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);</span>
195     displayBox.setHorizontalComputedMargin(computedHorizontalMargin);
196     displayBox.setHorizontalMargin({ computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) });
197 }
198 
<a name="34" id="anc34"></a><span class="line-modified">199 void InlineFormattingContext::computeWidthAndMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const</span>
200 {
<a name="35" id="anc35"></a><span class="line-modified">201     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified">202     WidthAndMargin widthAndMargin;</span>

203     if (layoutBox.isFloatingPositioned())
<a name="36" id="anc36"></a><span class="line-modified">204         widthAndMargin = Geometry::floatingWidthAndMargin(layoutState, layoutBox, usedValues);</span>
205     else if (layoutBox.isInlineBlockBox())
<a name="37" id="anc37"></a><span class="line-modified">206         widthAndMargin = Geometry::inlineBlockWidthAndMargin(layoutState, layoutBox, usedValues);</span>
207     else if (layoutBox.replaced())
<a name="38" id="anc38"></a><span class="line-modified">208         widthAndMargin = Geometry::inlineReplacedWidthAndMargin(layoutState, layoutBox, usedValues);</span>
209     else
210         ASSERT_NOT_REACHED();
211 
<a name="39" id="anc39"></a><span class="line-modified">212     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">213     displayBox.setContentBoxWidth(widthAndMargin.width);</span>
<span class="line-modified">214     displayBox.setHorizontalMargin(widthAndMargin.usedMargin);</span>
<span class="line-modified">215     displayBox.setHorizontalComputedMargin(widthAndMargin.computedMargin);</span>
216 }
217 
<a name="40" id="anc40"></a><span class="line-modified">218 void InlineFormattingContext::computeHeightAndMargin(const Box&amp; layoutBox) const</span>
219 {
<a name="41" id="anc41"></a><span class="line-modified">220     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified">221 </span>
<span class="line-modified">222     HeightAndMargin heightAndMargin;</span>
223     if (layoutBox.isFloatingPositioned())
<a name="42" id="anc42"></a><span class="line-modified">224         heightAndMargin = Geometry::floatingHeightAndMargin(layoutState, layoutBox, { }, UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() });</span>
225     else if (layoutBox.isInlineBlockBox())
<a name="43" id="anc43"></a><span class="line-modified">226         heightAndMargin = Geometry::inlineBlockHeightAndMargin(layoutState, layoutBox);</span>
227     else if (layoutBox.replaced())
<a name="44" id="anc44"></a><span class="line-modified">228         heightAndMargin = Geometry::inlineReplacedHeightAndMargin(layoutState, layoutBox, { });</span>
229     else
230         ASSERT_NOT_REACHED();
231 
<a name="45" id="anc45"></a><span class="line-modified">232     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">233     displayBox.setContentBoxHeight(heightAndMargin.height);</span>
<span class="line-modified">234     displayBox.setVerticalMargin({ heightAndMargin.nonCollapsedMargin, { } });</span>
<span class="line-removed">235 }</span>
<span class="line-removed">236 </span>
<span class="line-removed">237 void InlineFormattingContext::layoutFormattingContextRoot(const Box&amp; root, UsedHorizontalValues usedValues) const</span>
<span class="line-removed">238 {</span>
<span class="line-removed">239     ASSERT(root.isFloatingPositioned() || root.isInlineBlockBox());</span>
<span class="line-removed">240     ASSERT(usedValues.containingBlockWidth);</span>
<span class="line-removed">241 </span>
<span class="line-removed">242     computeBorderAndPadding(root, usedValues);</span>
<span class="line-removed">243     computeWidthAndMargin(root, usedValues);</span>
<span class="line-removed">244     // This is similar to static positioning in block formatting context. We just need to initialize the top left position.</span>
<span class="line-removed">245     layoutState().displayBoxForLayoutBox(root).setTopLeft({ 0, 0 });</span>
<span class="line-removed">246     // Swich over to the new formatting context (the one that the root creates).</span>
<span class="line-removed">247     auto formattingContext = layoutState().createFormattingContext(root);</span>
<span class="line-removed">248     formattingContext-&gt;layout();</span>
<span class="line-removed">249     // Come back and finalize the root&#39;s height and margin.</span>
<span class="line-removed">250     computeHeightAndMargin(root);</span>
<span class="line-removed">251     // Now that we computed the root&#39;s height, we can go back and layout the out-of-flow content.</span>
<span class="line-removed">252     formattingContext-&gt;layoutOutOfFlowContent();</span>
253 }
254 
<a name="46" id="anc46"></a><span class="line-modified">255 void InlineFormattingContext::computeWidthAndHeightForReplacedInlineBox(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const</span>
256 {
<a name="47" id="anc47"></a><span class="line-modified">257     ASSERT(!layoutBox.isContainer());</span>
<span class="line-modified">258     ASSERT(!layoutBox.establishesFormattingContext());</span>
<span class="line-modified">259     ASSERT(layoutBox.replaced());</span>
<span class="line-removed">260     ASSERT(usedValues.containingBlockWidth);</span>
<span class="line-removed">261 </span>
<span class="line-removed">262     computeBorderAndPadding(layoutBox, usedValues);</span>
<span class="line-removed">263     computeWidthAndMargin(layoutBox, usedValues);</span>
<span class="line-removed">264     computeHeightAndMargin(layoutBox);</span>
<span class="line-removed">265 }</span>
<span class="line-removed">266 </span>
<span class="line-removed">267 void InlineFormattingContext::collectInlineContent() const</span>
<span class="line-removed">268 {</span>
<span class="line-removed">269     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());</span>
270     // Traverse the tree and create inline items out of containers and leaf nodes. This essentially turns the tree inline structure into a flat one.
271     // &lt;span&gt;text&lt;span&gt;&lt;/span&gt;&lt;img&gt;&lt;/span&gt; -&gt; [ContainerStart][InlineBox][ContainerStart][ContainerEnd][InlineBox][ContainerEnd]
<a name="48" id="anc48"></a><span class="line-modified">272     auto&amp; formattingState = this-&gt;formattingState();</span>
273     LayoutQueue layoutQueue;
<a name="49" id="anc49"></a><span class="line-modified">274     layoutQueue.append(root.firstInFlowOrFloatingChild());</span>
275     while (!layoutQueue.isEmpty()) {
<a name="50" id="anc50"></a><span class="line-removed">276         auto treatAsInlineContainer = [](auto&amp; layoutBox) {</span>
<span class="line-removed">277             return is&lt;Container&gt;(layoutBox) &amp;&amp; !layoutBox.establishesFormattingContext();</span>
<span class="line-removed">278         };</span>
279         while (true) {
280             auto&amp; layoutBox = *layoutQueue.last();
<a name="51" id="anc51"></a><span class="line-modified">281             if (!treatAsInlineContainer(layoutBox))</span>

282                 break;
<a name="52" id="anc52"></a><span class="line-modified">283             // This is the start of an inline container (e.g. &lt;span&gt;).</span>
<span class="line-modified">284             formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::ContainerStart));</span>
<span class="line-modified">285             auto&amp; container = downcast&lt;Container&gt;(layoutBox);</span>
<span class="line-modified">286             if (!container.hasInFlowOrFloatingChild())</span>
287                 break;
<a name="53" id="anc53"></a><span class="line-modified">288             layoutQueue.append(container.firstInFlowOrFloatingChild());</span>
289         }
290 
291         while (!layoutQueue.isEmpty()) {
292             auto&amp; layoutBox = *layoutQueue.takeLast();
<a name="54" id="anc54"></a><span class="line-modified">293             // This is the end of an inline container (e.g. &lt;/span&gt;).</span>
<span class="line-modified">294             if (treatAsInlineContainer(layoutBox))</span>
<span class="line-removed">295                 formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::ContainerEnd));</span>
<span class="line-removed">296             else if (layoutBox.isLineBreakBox())</span>
<span class="line-removed">297                 formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::HardLineBreak));</span>
298             else if (layoutBox.isFloatingPositioned())
<a name="55" id="anc55"></a><span class="line-modified">299                 formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::Float));</span>
<span class="line-modified">300             else {</span>
<span class="line-modified">301                 ASSERT(layoutBox.isInlineLevelBox());</span>
<span class="line-modified">302                 if (layoutBox.hasTextContent())</span>
<span class="line-modified">303                     InlineTextItem::createAndAppendTextItems(formattingState.inlineItems(), layoutBox);</span>
<span class="line-modified">304                 else</span>
<span class="line-modified">305                     formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::Box));</span>
<span class="line-modified">306             }</span>


307 
308             if (auto* nextSibling = layoutBox.nextInFlowOrFloatingSibling()) {
309                 layoutQueue.append(nextSibling);
310                 break;
311             }
312         }
313     }
314 }
315 
<a name="56" id="anc56"></a>








































































































































































































316 }
317 }
318 
319 #endif
<a name="57" id="anc57"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="57" type="hidden" />
</body>
</html>
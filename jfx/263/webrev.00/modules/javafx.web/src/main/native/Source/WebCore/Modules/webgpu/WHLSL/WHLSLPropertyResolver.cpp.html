<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLPropertyResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLPropertyResolver.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;WHLSLAST.h&quot;
 32 #include &quot;WHLSLProgram.h&quot;
 33 #include &quot;WHLSLReplaceWith.h&quot;
 34 #include &quot;WHLSLVisitor.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 namespace WHLSL {
 39 
 40 class PropertyResolver : public Visitor {
 41     void handleLeftHandSideBase(UniqueRef&lt;AST::Expression&gt; base, UniqueRef&lt;AST::Expression&gt;&amp; slot, Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; expressions)
 42     {
 43         if (!base-&gt;mayBeEffectful()) {
 44             slot = WTFMove(base);
 45             return;
 46         }
 47 
 48         auto leftAddressSpace = base-&gt;typeAnnotation().leftAddressSpace();
 49         RELEASE_ASSERT(leftAddressSpace);
 50         CodeLocation codeLocation = base-&gt;codeLocation();
 51         Ref&lt;AST::UnnamedType&gt; baseType = base-&gt;resolvedType();
 52         Ref&lt;AST::PointerType&gt; pointerType = AST::PointerType::create(codeLocation, *leftAddressSpace, baseType.copyRef());
 53 
 54         UniqueRef&lt;AST::VariableDeclaration&gt; pointerVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(codeLocation, AST::Qualifiers { }, pointerType.ptr(), String(), nullptr, nullptr);
 55 
 56         auto makeVariableReference = [&amp;] {
 57             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));
 58             variableReference-&gt;setType(pointerType.copyRef());
 59             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });
 60             return variableReference;
 61         };
 62 
 63         {
 64             auto pointerOfBase = makeUniqueRef&lt;AST::MakePointerExpression&gt;(codeLocation, WTFMove(base), AST::AddressEscapeMode::DoesNotEscape);
 65             pointerOfBase-&gt;setType(pointerType.copyRef());
 66             pointerOfBase-&gt;setTypeAnnotation(AST::RightValue());
 67 
 68             auto assignment = makeUniqueRef&lt;AST::AssignmentExpression&gt;(codeLocation, makeVariableReference(), WTFMove(pointerOfBase));
 69             assignment-&gt;setType(pointerType.copyRef());
 70             assignment-&gt;setTypeAnnotation(AST::RightValue());
 71 
 72             expressions.append(WTFMove(assignment));
 73         }
 74 
 75         {
 76             auto dereference = makeUniqueRef&lt;AST::DereferenceExpression&gt;(codeLocation, makeVariableReference());
 77             dereference-&gt;setType(baseType.copyRef());
 78             dereference-&gt;setTypeAnnotation(AST::LeftValue { *leftAddressSpace });
 79 
 80             slot = WTFMove(dereference);
 81         }
 82 
 83         m_variables.append(WTFMove(pointerVariable));
 84     }
 85 
 86     void handlePropertyAccess(AST::PropertyAccessExpression&amp; propertyAccess, Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; expressions)
 87     {
 88         AST::PropertyAccessExpression* currentPtr = &amp;propertyAccess;
 89         // a.b[c].d will go into this array as [.d, [c], .b]
 90         Vector&lt;std::reference_wrapper&lt;AST::PropertyAccessExpression&gt;&gt; chain;
 91 
 92         while (true) {
 93             AST::PropertyAccessExpression&amp; current = *currentPtr;
 94             chain.append(current);
 95             if (is&lt;AST::IndexExpression&gt;(current))
 96                 checkErrorAndVisit(downcast&lt;AST::IndexExpression&gt;(current).indexExpression());
 97             if (!is&lt;AST::PropertyAccessExpression&gt;(current.base()))
 98                 break;
 99             currentPtr = &amp;downcast&lt;AST::PropertyAccessExpression&gt;(current.base());
100         }
101 
102         AST::PropertyAccessExpression&amp; current = *currentPtr;
103 
104         checkErrorAndVisit(current.base());
105 
106         CodeLocation baseCodeLocation = current.base().codeLocation();
107 
108         if (current.base().typeAnnotation().isRightValue()) {
109             UniqueRef&lt;AST::VariableDeclaration&gt; copy = makeUniqueRef&lt;AST::VariableDeclaration&gt;(baseCodeLocation, AST::Qualifiers { }, &amp;current.base().resolvedType(), String(), nullptr, nullptr);
110             Ref&lt;AST::UnnamedType&gt; baseType = current.base().resolvedType();
111 
112             auto makeVariableReference = [&amp;] {
113                 auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(copy));
114                 variableReference-&gt;setType(baseType.copyRef());
115                 variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });
116                 return variableReference;
117             };
118 
119             auto assignment = makeUniqueRef&lt;AST::AssignmentExpression&gt;(baseCodeLocation, makeVariableReference(), current.takeBase());
120             assignment-&gt;setType(baseType.copyRef());
121             assignment-&gt;setTypeAnnotation(AST::RightValue());
122 
123             expressions.append(WTFMove(assignment));
124 
125             current.baseReference() = makeVariableReference();
126 
127             m_variables.append(WTFMove(copy));
128         } else
129             handleLeftHandSideBase(current.takeBase(), current.baseReference(), expressions);
130 
131         for (size_t i = chain.size(); i--; ) {
132             auto&amp; access = chain[i].get();
133             if (is&lt;AST::IndexExpression&gt;(access) &amp;&amp; downcast&lt;AST::IndexExpression&gt;(access).indexExpression().mayBeEffectful()) {
134                 auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(access);
135 
136                 Ref&lt;AST::UnnamedType&gt; indexType = indexExpression.indexExpression().resolvedType();
137 
138                 UniqueRef&lt;AST::VariableDeclaration&gt; indexVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(access.codeLocation(), AST::Qualifiers { }, indexType.ptr(), String(), nullptr, nullptr);
139 
140                 auto makeVariableReference = [&amp;] {
141                     auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(indexVariable));
142                     variableReference-&gt;setType(indexType.copyRef());
143                     variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });
144                     return variableReference;
145                 };
146 
147                 {
148                     auto assignment = makeUniqueRef&lt;AST::AssignmentExpression&gt;(baseCodeLocation, makeVariableReference(), indexExpression.takeIndex());
149                     assignment-&gt;setType(indexType.copyRef());
150                     assignment-&gt;setTypeAnnotation(AST::RightValue());
151 
152                     expressions.append(WTFMove(assignment));
153                 }
154 
155                 indexExpression.indexReference() = makeVariableReference();
156 
157                 m_variables.append(WTFMove(indexVariable));
158             }
159         }
160     }
161 
162     void handlePropertyAccess(AST::PropertyAccessExpression&amp; propertyAccess)
163     {
164         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
165 
166         handlePropertyAccess(propertyAccess, expressions);
167 
168         Ref&lt;AST::UnnamedType&gt; accessType = propertyAccess.resolvedType();
169 
170         AST::CommaExpression* comma;
171         CodeLocation codeLocation = propertyAccess.codeLocation();
172         if (is&lt;AST::IndexExpression&gt;(propertyAccess)) {
173             auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(propertyAccess);
174 
175             auto newIndexExpression = makeUniqueRef&lt;AST::IndexExpression&gt;(codeLocation, indexExpression.takeBase(), indexExpression.takeIndex());
176             newIndexExpression-&gt;setType(indexExpression.resolvedType());
177             newIndexExpression-&gt;setTypeAnnotation(AST::TypeAnnotation(indexExpression.typeAnnotation()));
178 
179             expressions.append(WTFMove(newIndexExpression));
180 
181             comma = AST::replaceWith&lt;AST::CommaExpression&gt;(indexExpression, codeLocation, WTFMove(expressions));
182         } else {
183             RELEASE_ASSERT(is&lt;AST::DotExpression&gt;(propertyAccess));
184             auto&amp; dotExpression = downcast&lt;AST::DotExpression&gt;(propertyAccess);
185 
186             auto newDotExpression = makeUniqueRef&lt;AST::DotExpression&gt;(codeLocation, dotExpression.takeBase(), String(dotExpression.fieldName()));
187             newDotExpression-&gt;setType(dotExpression.resolvedType());
188             newDotExpression-&gt;setTypeAnnotation(AST::TypeAnnotation(dotExpression.typeAnnotation()));
189 
190             expressions.append(WTFMove(newDotExpression));
191 
192             comma = AST::replaceWith&lt;AST::CommaExpression&gt;(dotExpression, codeLocation, WTFMove(expressions));
193         }
194 
195         comma-&gt;setType(WTFMove(accessType));
196         comma-&gt;setTypeAnnotation(AST::RightValue());
197     }
198 
199 public:
200     void visit(AST::DotExpression&amp; dotExpression) override
201     {
202         handlePropertyAccess(dotExpression);
203     }
204 
205     void visit(AST::IndexExpression&amp; indexExpression) override
206     {
207         handlePropertyAccess(indexExpression);
208     }
209 
210     void visit(AST::ReadModifyWriteExpression&amp; readModifyWrite) override
211     {
212         checkErrorAndVisit(readModifyWrite.newValueExpression());
213         checkErrorAndVisit(readModifyWrite.resultExpression());
214 
215         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
216 
217         CodeLocation codeLocation = readModifyWrite.codeLocation();
218 
219         Ref&lt;AST::UnnamedType&gt; type = readModifyWrite.resolvedType();
220 
221         if (is&lt;AST::PropertyAccessExpression&gt;(readModifyWrite.leftValue()))
222             handlePropertyAccess(downcast&lt;AST::PropertyAccessExpression&gt;(readModifyWrite.leftValue()), expressions);
223         else
224             handleLeftHandSideBase(readModifyWrite.takeLeftValue(), readModifyWrite.leftValueReference(), expressions);
225 
226         {
227             UniqueRef&lt;AST::ReadModifyWriteExpression&gt; newReadModifyWrite = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(
228                 readModifyWrite.codeLocation(), readModifyWrite.takeLeftValue(), readModifyWrite.takeOldValue(), readModifyWrite.takeNewValue());
229             newReadModifyWrite-&gt;setNewValueExpression(readModifyWrite.takeNewValueExpression());
230             newReadModifyWrite-&gt;setResultExpression(readModifyWrite.takeResultExpression());
231             newReadModifyWrite-&gt;setType(type.copyRef());
232             newReadModifyWrite-&gt;setTypeAnnotation(AST::TypeAnnotation(readModifyWrite.typeAnnotation()));
233 
234             expressions.append(WTFMove(newReadModifyWrite));
235         }
236 
237         auto* comma = AST::replaceWith&lt;AST::CommaExpression&gt;(readModifyWrite, codeLocation, WTFMove(expressions));
238         comma-&gt;setType(WTFMove(type));
239         comma-&gt;setTypeAnnotation(AST::RightValue());
240     }
241 
242     void visit(AST::FunctionDefinition&amp; functionDefinition) override
243     {
244         RELEASE_ASSERT(m_variables.isEmpty());
245 
246         checkErrorAndVisit(static_cast&lt;AST::FunctionDeclaration&amp;&gt;(functionDefinition));
247         checkErrorAndVisit(functionDefinition.block());
248 
249         if (!m_variables.isEmpty()) {
250             functionDefinition.block().statements().insert(0,
251                 makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(functionDefinition.block().codeLocation(), WTFMove(m_variables)));
252         }
253     }
254 
255 private:
256     AST::VariableDeclarations m_variables;
257 };
258 
259 void resolveProperties(Program&amp; program)
260 {
261     // The goal of this phase is two allow two things:
262     // 1. For property access expressions, metal codegen should be allowed to evaluate
263     // the base, and if it&#39;s an index expression, the index, as many times as needed.
264     // So this patch ensures that if Metal evaluates such things, effects aren&#39;t performed
265     // more than once.
266     //
267     // 2. For ReadModifyWrite expressions, metal codegen should be able to evaluate the
268     // leftValueExpression as many times as it&#39;d like without performing the effects of
269     // leftValueExpression more than once.
270     //
271     // We do these things because it&#39;s convenient for metal codegen to be able to rely on
272     // this with the way it structures the generated code.
273     PropertyResolver resolver;
274     for (auto&amp; function : program.functionDefinitions())
275         resolver.visit(function);
276 }
277 
278 } // namespace WHLSL
279 
280 } // namespace WebCore
281 
282 #endif // ENABLE(WEBGPU)
    </pre>
  </body>
</html>
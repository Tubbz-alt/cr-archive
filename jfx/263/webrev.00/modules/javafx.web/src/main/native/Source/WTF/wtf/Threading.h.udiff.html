<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WTF/wtf/Threading.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Threading.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ThreadingPrimitives.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/Threading.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -50,10 +50,14 @@</span>
  
  #if USE(PTHREADS) &amp;&amp; !OS(DARWIN)
  #include &lt;signal.h&gt;
  #endif
  
<span class="udiff-line-added">+ #if OS(WINDOWS)</span>
<span class="udiff-line-added">+ #include &lt;array&gt;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  namespace WTF {
  
  class AbstractLocker;
  class ThreadMessageData;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104,10 +108,29 @@</span>
      // that the thread information is alive. While Thread::current() is not safe if it is called
      // from the destructor of the other TLS data, currentID() always returns meaningful thread ID.
      WTF_EXPORT_PRIVATE static ThreadIdentifier currentID();
  
      ThreadIdentifier id() const { return m_id; }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     class SpecificStorage {</span>
<span class="udiff-line-added">+     public:</span>
<span class="udiff-line-added">+         using DestroyFunction = void (*)(void*);</span>
<span class="udiff-line-added">+         WTF_EXPORT_PRIVATE static bool allocateKey(int&amp; key, DestroyFunction);</span>
<span class="udiff-line-added">+         WTF_EXPORT_PRIVATE void* get(int key);</span>
<span class="udiff-line-added">+         WTF_EXPORT_PRIVATE void set(int key, void* value);</span>
<span class="udiff-line-added">+         void destroySlots();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private:</span>
<span class="udiff-line-added">+         static constexpr size_t s_maxKeys = 32;</span>
<span class="udiff-line-added">+         static Atomic&lt;int&gt; s_numberOfKeys;</span>
<span class="udiff-line-added">+         static std::array&lt;Atomic&lt;DestroyFunction&gt;, s_maxKeys&gt; s_destroyFunctions;</span>
<span class="udiff-line-added">+         std::array&lt;void*, s_maxKeys&gt; m_slots { };</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     SpecificStorage&amp; specificStorage() { return m_specificStorage; };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     class ThreadHolder;</span>
  #endif
  
      WTF_EXPORT_PRIVATE void changePriority(int);
      WTF_EXPORT_PRIVATE int waitForCompletion();
      WTF_EXPORT_PRIVATE void detach();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -141,11 +164,10 @@</span>
      // Called in the thread during initialization.
      // Helpful for platforms where the thread name must be set from within the thread.
      static void initializeCurrentThreadInternal(const char* threadName);
      static void initializeCurrentThreadEvenIfNonWTFCreated();
  
<span class="udiff-line-removed">-     WTF_EXPORT_PRIVATE static const unsigned lockSpinLimit;</span>
      WTF_EXPORT_PRIVATE static void yield();
  
      WTF_EXPORT_PRIVATE static bool exchangeIsCompilationThread(bool newValue);
      WTF_EXPORT_PRIVATE static void registerGCThread(GCThreadType);
      WTF_EXPORT_PRIVATE static bool mayBeGCThread();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -249,41 +271,37 @@</span>
  
      // These functions are only called from ThreadGroup.
      ThreadGroupAddResult addToThreadGroup(const AbstractLocker&amp; threadGroupLocker, ThreadGroup&amp;);
      void removeFromThreadGroup(const AbstractLocker&amp; threadGroupLocker, ThreadGroup&amp;);
  
<span class="udiff-line-modified-removed">-     // The Thread instance is ref&#39;ed and held in thread-specific storage. It will be deref&#39;ed by destructTLS at thread destruction time.</span>
<span class="udiff-line-modified-removed">-     // For pthread, it employs pthreads-specific 2-pass destruction to reliably remove Thread.</span>
<span class="udiff-line-removed">-     // For Windows, we use thread_local to defer thread TLS destruction. It assumes regular ThreadSpecific</span>
<span class="udiff-line-removed">-     // types don&#39;t use multiple-pass destruction.</span>
<span class="udiff-line-modified-added">+     // For pthread, the Thread instance is ref&#39;ed and held in thread-specific storage. It will be deref&#39;ed by destructTLS at thread destruction time.</span>
<span class="udiff-line-modified-added">+     // It employs pthreads-specific 2-pass destruction to reliably remove Thread.</span>
  
<span class="udiff-line-modified-removed">- #if !HAVE(FAST_TLS)</span>
<span class="udiff-line-modified-added">+ #if !HAVE(FAST_TLS) &amp;&amp; !OS(WINDOWS)</span>
      static WTF_EXPORT_PRIVATE ThreadSpecificKey s_key;
      // One time initialization for this class as a whole.
      // This method must be called before initializeTLS() and it is not thread-safe.
      static void initializeTLSKey();
  #endif
<span class="udiff-line-added">+     // This thread-specific destructor is called 2 times when thread terminates:</span>
<span class="udiff-line-added">+     // - first, when all the other thread-specific destructors are called, it simply remembers it was &#39;destroyed once&#39;</span>
<span class="udiff-line-added">+     // and (1) re-sets itself into the thread-specific slot or (2) constructs thread local value to call it again later.</span>
<span class="udiff-line-added">+     // - second, after all thread-specific destructors were invoked, it gets called again - this time, we deref the</span>
<span class="udiff-line-added">+     // Thread in the TLS, completing the cleanup.</span>
<span class="udiff-line-added">+     static void destructTLS(void* data);</span>
  
      // Creates and puts an instance of Thread into thread-specific storage.
      static Thread&amp; initializeTLS(Ref&lt;Thread&gt;&amp;&amp;);
      WTF_EXPORT_PRIVATE static Thread&amp; initializeCurrentTLS();
  
      // Returns nullptr if thread-specific storage was not initialized.
<span class="udiff-line-removed">-     static Thread* currentMayBeNull();</span>
<span class="udiff-line-removed">- </span>
  #if OS(WINDOWS)
<span class="udiff-line-modified-removed">-     WTF_EXPORT_PRIVATE static Thread* currentDying();</span>
<span class="udiff-line-modified-removed">-     static RefPtr&lt;Thread&gt; get(ThreadIdentifier);</span>
<span class="udiff-line-modified-added">+     WTF_EXPORT_PRIVATE static Thread* currentMayBeNull();</span>
<span class="udiff-line-modified-added">+ #else</span>
<span class="udiff-line-added">+     static Thread* currentMayBeNull();</span>
  #endif
  
<span class="udiff-line-removed">-     // This thread-specific destructor is called 2 times when thread terminates:</span>
<span class="udiff-line-removed">-     // - first, when all the other thread-specific destructors are called, it simply remembers it was &#39;destroyed once&#39;</span>
<span class="udiff-line-removed">-     // and (1) re-sets itself into the thread-specific slot or (2) constructs thread local value to call it again later.</span>
<span class="udiff-line-removed">-     // - second, after all thread-specific destructors were invoked, it gets called again - this time, we remove the</span>
<span class="udiff-line-removed">-     // Thread from the threadMap, completing the cleanup.</span>
<span class="udiff-line-removed">-     static void THREAD_SPECIFIC_CALL destructTLS(void* data);</span>
<span class="udiff-line-removed">- </span>
      JoinableState m_joinableState { Joinable };
      bool m_isShuttingDown : 1;
      bool m_didExit : 1;
      bool m_isDestroyedOnce : 1;
      bool m_isCompilationThread: 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -302,10 +320,14 @@</span>
  #elif USE(PTHREADS)
      PlatformRegisters* m_platformRegisters { nullptr };
      unsigned m_suspendCount { 0 };
  #endif
  
<span class="udiff-line-added">+ #if OS(WINDOWS)</span>
<span class="udiff-line-added">+     SpecificStorage m_specificStorage;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
      AtomStringTable* m_currentAtomStringTable { nullptr };
      AtomStringTable m_defaultAtomStringTable;
  
  #if ENABLE(STACK_STATS)
      StackStats::PerThreadStats m_stackStats;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -323,38 +345,36 @@</span>
      , m_isCompilationThread(false)
      , m_gcThreadType(static_cast&lt;unsigned&gt;(GCThreadType::None))
  {
  }
  
<span class="udiff-line-added">+ #if !OS(WINDOWS)</span>
  inline Thread* Thread::currentMayBeNull()
  {
  #if !HAVE(FAST_TLS)
      ASSERT(s_key != InvalidThreadSpecificKey);
      return static_cast&lt;Thread*&gt;(threadSpecificGet(s_key));
  #else
      return static_cast&lt;Thread*&gt;(_pthread_getspecific_direct(WTF_THREAD_DATA_KEY));
  #endif
  }
<span class="udiff-line-added">+ #endif</span>
  
  inline Thread&amp; Thread::current()
  {
      // WRT WebCore:
      //    Thread::current() is used on main thread before it could possibly be used
      //    on secondary ones, so there is no need for synchronization here.
      // WRT JavaScriptCore:
      //    Thread::initializeTLSKey() is initially called from initializeThreading(), ensuring
      //    this is initially called in a std::call_once locked context.
<span class="udiff-line-modified-removed">- #if !HAVE(FAST_TLS)</span>
<span class="udiff-line-modified-added">+ #if !HAVE(FAST_TLS) &amp;&amp; !OS(WINDOWS)</span>
      if (UNLIKELY(Thread::s_key == InvalidThreadSpecificKey))
          WTF::initializeThreading();
  #endif
      if (auto* thread = currentMayBeNull())
          return *thread;
<span class="udiff-line-removed">- #if OS(WINDOWS)</span>
<span class="udiff-line-removed">-     if (auto* thread = currentDying())</span>
<span class="udiff-line-removed">-         return *thread;</span>
<span class="udiff-line-removed">- #endif</span>
      return initializeCurrentTLS();
  }
  
  } // namespace WTF
  
</pre>
<center><a href="Threading.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ThreadingPrimitives.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
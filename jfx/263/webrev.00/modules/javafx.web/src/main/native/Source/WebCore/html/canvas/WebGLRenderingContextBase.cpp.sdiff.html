<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLRenderingContext.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContextBase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WebGLRenderingContextBase.h&quot;
  28 
  29 #if ENABLE(WEBGL)
  30 
  31 #include &quot;ANGLEInstancedArrays.h&quot;
  32 #include &quot;CachedImage.h&quot;
  33 #include &quot;DOMWindow.h&quot;
  34 #include &quot;DiagnosticLoggingClient.h&quot;
  35 #include &quot;DiagnosticLoggingKeys.h&quot;
  36 #include &quot;Document.h&quot;
  37 #include &quot;EXTBlendMinMax.h&quot;
  38 #include &quot;EXTFragDepth.h&quot;
  39 #include &quot;EXTShaderTextureLOD.h&quot;
  40 #include &quot;EXTTextureFilterAnisotropic.h&quot;
  41 #include &quot;EXTsRGB.h&quot;
  42 #include &quot;EventNames.h&quot;
<span class="line-modified">  43 #include &quot;Extensions3D.h&quot;</span>
  44 #include &quot;Frame.h&quot;
  45 #include &quot;FrameLoader.h&quot;
  46 #include &quot;FrameLoaderClient.h&quot;
  47 #include &quot;FrameView.h&quot;
  48 #include &quot;GraphicsContext.h&quot;
  49 #include &quot;HTMLCanvasElement.h&quot;
  50 #include &quot;HTMLImageElement.h&quot;
  51 #include &quot;HTMLVideoElement.h&quot;
  52 #include &quot;ImageBuffer.h&quot;
  53 #include &quot;ImageData.h&quot;
  54 #include &quot;InspectorInstrumentation.h&quot;
  55 #include &quot;IntSize.h&quot;
  56 #include &quot;JSExecState.h&quot;
  57 #include &quot;Logging.h&quot;
  58 #include &quot;NotImplemented.h&quot;
  59 #include &quot;OESElementIndexUint.h&quot;
  60 #include &quot;OESStandardDerivatives.h&quot;
  61 #include &quot;OESTextureFloat.h&quot;
  62 #include &quot;OESTextureFloatLinear.h&quot;
  63 #include &quot;OESTextureHalfFloat.h&quot;
  64 #include &quot;OESTextureHalfFloatLinear.h&quot;
  65 #include &quot;OESVertexArrayObject.h&quot;
<span class="line-removed">  66 #include &quot;OffscreenCanvas.h&quot;</span>
  67 #include &quot;Page.h&quot;
  68 #include &quot;RenderBox.h&quot;
  69 #include &quot;RuntimeEnabledFeatures.h&quot;
  70 #include &quot;Settings.h&quot;
  71 #include &quot;WebGL2RenderingContext.h&quot;
  72 #include &quot;WebGLActiveInfo.h&quot;
  73 #include &quot;WebGLBuffer.h&quot;
  74 #include &quot;WebGLCompressedTextureASTC.h&quot;
  75 #include &quot;WebGLCompressedTextureATC.h&quot;


  76 #include &quot;WebGLCompressedTexturePVRTC.h&quot;
  77 #include &quot;WebGLCompressedTextureS3TC.h&quot;
  78 #include &quot;WebGLContextAttributes.h&quot;
  79 #include &quot;WebGLContextEvent.h&quot;
  80 #include &quot;WebGLContextGroup.h&quot;
  81 #include &quot;WebGLDebugRendererInfo.h&quot;
  82 #include &quot;WebGLDebugShaders.h&quot;
  83 #include &quot;WebGLDepthTexture.h&quot;
  84 #include &quot;WebGLDrawBuffers.h&quot;
  85 #include &quot;WebGLFramebuffer.h&quot;
  86 #include &quot;WebGLLoseContext.h&quot;
  87 #include &quot;WebGLProgram.h&quot;
  88 #include &quot;WebGLRenderbuffer.h&quot;
  89 #include &quot;WebGLRenderingContext.h&quot;
  90 #include &quot;WebGLShader.h&quot;
  91 #include &quot;WebGLShaderPrecisionFormat.h&quot;
  92 #include &quot;WebGLTexture.h&quot;
  93 #include &quot;WebGLUniformLocation.h&quot;
  94 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
  95 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  96 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  97 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  98 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  99 #include &lt;JavaScriptCore/Uint32Array.h&gt;
 100 #include &lt;wtf/CheckedArithmetic.h&gt;
 101 #include &lt;wtf/HashMap.h&gt;
 102 #include &lt;wtf/HexNumber.h&gt;
 103 #include &lt;wtf/IsoMallocInlines.h&gt;
 104 #include &lt;wtf/Lock.h&gt;
 105 #include &lt;wtf/StdLibExtras.h&gt;
 106 #include &lt;wtf/UniqueArray.h&gt;
 107 #include &lt;wtf/text/CString.h&gt;
 108 #include &lt;wtf/text/StringBuilder.h&gt;
 109 




 110 namespace WebCore {
 111 
 112 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGLRenderingContextBase);
 113 
 114 static const Seconds secondsBetweenRestoreAttempts { 1_s };
 115 const int maxGLErrorsAllowedToConsole = 256;
 116 static const Seconds checkContextLossHandlingDelay { 3_s };
 117 
 118 namespace {
 119 
<span class="line-modified"> 120     GC3Dint clamp(GC3Dint value, GC3Dint min, GC3Dint max)</span>
 121     {
 122         if (value &lt; min)
 123             value = min;
 124         if (value &gt; max)
 125             value = max;
 126         return value;
 127     }
 128 
 129     // Return true if a character belongs to the ASCII subset as defined in
 130     // GLSL ES 1.0 spec section 3.1.
 131     bool validateCharacter(unsigned char c)
 132     {
 133         // Printing characters are valid except &quot; $ ` @ \ &#39; DEL.
 134         if (c &gt;= 32 &amp;&amp; c &lt;= 126
 135             &amp;&amp; c != &#39;&quot;&#39; &amp;&amp; c != &#39;$&#39; &amp;&amp; c != &#39;`&#39; &amp;&amp; c != &#39;@&#39; &amp;&amp; c != &#39;\\&#39; &amp;&amp; c != &#39;\&#39;&#39;)
 136             return true;
 137         // Horizontal tab, line feed, vertical tab, form feed, carriage return
 138         // are also valid.
 139         if (c &gt;= 9 &amp;&amp; c &lt;= 13)
 140             return true;
</pre>
<hr />
<pre>
 317             break;
 318 
 319         case InMultiLineComment:
 320             if (c == &#39;*&#39; &amp;&amp; peek(temp) &amp;&amp; temp == &#39;/&#39;) {
 321                 emit(&#39;*&#39;);
 322                 emit(&#39;/&#39;);
 323                 m_parseState = MiddleOfLine;
 324                 advance();
 325                 break;
 326             }
 327 
 328             // Swallow all other characters. Unclear whether we may
 329             // want or need to just emit a space per character to try
 330             // to preserve column numbers for debugging purposes.
 331             break;
 332         }
 333     }
 334 } // namespace anonymous
 335 
 336 // Returns false if no clipping is necessary, i.e., x, y, width, height stay the same.
<span class="line-modified"> 337 static bool clip2D(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height,</span>
<span class="line-modified"> 338     GC3Dsizei sourceWidth, GC3Dsizei sourceHeight,</span>
<span class="line-modified"> 339     GC3Dint* clippedX, GC3Dint* clippedY, GC3Dsizei* clippedWidth, GC3Dsizei*clippedHeight)</span>
 340 {
 341     ASSERT(clippedX &amp;&amp; clippedY &amp;&amp; clippedWidth &amp;&amp; clippedHeight);
 342 
<span class="line-modified"> 343     GC3Dint left = std::max(x, 0);</span>
<span class="line-modified"> 344     GC3Dint top = std::max(y, 0);</span>
<span class="line-modified"> 345     GC3Dint right = 0;</span>
<span class="line-modified"> 346     GC3Dint bottom = 0;</span>
 347 
<span class="line-modified"> 348     Checked&lt;GC3Dint, RecordOverflow&gt; checkedInputRight = Checked&lt;GC3Dint&gt;(x) + Checked&lt;GC3Dsizei&gt;(width);</span>
<span class="line-modified"> 349     Checked&lt;GC3Dint, RecordOverflow&gt; checkedInputBottom = Checked&lt;GC3Dint&gt;(y) + Checked&lt;GC3Dsizei&gt;(height);</span>
 350     if (!checkedInputRight.hasOverflowed() &amp;&amp; !checkedInputBottom.hasOverflowed()) {
 351         right = std::min(checkedInputRight.unsafeGet(), sourceWidth);
 352         bottom = std::min(checkedInputBottom.unsafeGet(), sourceHeight);
 353     }
 354 
 355     if (left &gt;= right || top &gt;= bottom) {
 356         *clippedX = 0;
 357         *clippedY = 0;
 358         *clippedWidth = 0;
 359         *clippedHeight = 0;
 360         return true;
 361     }
 362 
 363     *clippedX = left;
 364     *clippedY = top;
 365     *clippedWidth = right - left;
 366     *clippedHeight = bottom - top;
 367 
 368     return (*clippedX != x || *clippedY != y || *clippedWidth != width || *clippedHeight != height);
 369 }
 370 
<span class="line-removed"> 371 class WebGLRenderingContextLostCallback : public GraphicsContext3D::ContextLostCallback {</span>
<span class="line-removed"> 372     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-removed"> 373 public:</span>
<span class="line-removed"> 374     explicit WebGLRenderingContextLostCallback(WebGLRenderingContextBase* cb) : m_context(cb) { }</span>
<span class="line-removed"> 375     virtual ~WebGLRenderingContextLostCallback() = default;</span>
<span class="line-removed"> 376 </span>
<span class="line-removed"> 377     void onContextLost() override { m_context-&gt;forceLostContext(WebGLRenderingContext::RealLostContext); }</span>
<span class="line-removed"> 378 private:</span>
<span class="line-removed"> 379     WebGLRenderingContextBase* m_context;</span>
<span class="line-removed"> 380 };</span>
<span class="line-removed"> 381 </span>
<span class="line-removed"> 382 class WebGLRenderingContextErrorMessageCallback : public GraphicsContext3D::ErrorMessageCallback {</span>
<span class="line-removed"> 383     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-removed"> 384 public:</span>
<span class="line-removed"> 385     explicit WebGLRenderingContextErrorMessageCallback(WebGLRenderingContextBase* cb) : m_context(cb) { }</span>
<span class="line-removed"> 386     virtual ~WebGLRenderingContextErrorMessageCallback() = default;</span>
<span class="line-removed"> 387 </span>
<span class="line-removed"> 388     void onErrorMessage(const String&amp; message, GC3Dint) override</span>
<span class="line-removed"> 389     {</span>
<span class="line-removed"> 390         if (m_context-&gt;m_synthesizedErrorsToConsole)</span>
<span class="line-removed"> 391             m_context-&gt;printToConsole(MessageLevel::Error, message);</span>
<span class="line-removed"> 392     }</span>
<span class="line-removed"> 393 private:</span>
<span class="line-removed"> 394     WebGLRenderingContextBase* m_context;</span>
<span class="line-removed"> 395 };</span>
<span class="line-removed"> 396 </span>
 397 class InspectorScopedShaderProgramHighlight {
 398 public:
 399     InspectorScopedShaderProgramHighlight(WebGLRenderingContextBase&amp; context, WebGLProgram* program)
 400         : m_context(context)
 401         , m_program(program)
 402     {
 403         showHightlight();
 404     }
 405 
 406     ~InspectorScopedShaderProgramHighlight()
 407     {
 408         hideHighlight();
 409     }
 410 
 411 private:
 412     void showHightlight()
 413     {
<span class="line-modified"> 414         if (!m_program || LIKELY(!InspectorInstrumentation::isShaderProgramHighlighted(m_context, *m_program)))</span>
 415             return;
 416 
<span class="line-modified"> 417         if (hasBufferBinding(GraphicsContext3D::FRAMEBUFFER_BINDING)) {</span>
<span class="line-modified"> 418             if (!hasBufferBinding(GraphicsContext3D::RENDERBUFFER_BINDING))</span>
 419                 return;
<span class="line-modified"> 420             if (hasFramebufferParameterAttachment(GraphicsContext3D::DEPTH_ATTACHMENT))</span>
 421                 return;
<span class="line-modified"> 422             if (hasFramebufferParameterAttachment(GraphicsContext3D::STENCIL_ATTACHMENT))</span>
 423                 return;
 424 #if ENABLE(WEBGL2)
<span class="line-modified"> 425             if (hasFramebufferParameterAttachment(GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT))</span>
 426                 return;
 427 #endif
 428         }
 429 
<span class="line-modified"> 430         saveBlendValue(GraphicsContext3D::BLEND_COLOR, m_savedBlend.color);</span>
<span class="line-modified"> 431         saveBlendValue(GraphicsContext3D::BLEND_EQUATION_RGB, m_savedBlend.equationRGB);</span>
<span class="line-modified"> 432         saveBlendValue(GraphicsContext3D::BLEND_EQUATION_ALPHA, m_savedBlend.equationAlpha);</span>
<span class="line-modified"> 433         saveBlendValue(GraphicsContext3D::BLEND_SRC_RGB, m_savedBlend.srcRGB);</span>
<span class="line-modified"> 434         saveBlendValue(GraphicsContext3D::BLEND_SRC_ALPHA, m_savedBlend.srcAlpha);</span>
<span class="line-modified"> 435         saveBlendValue(GraphicsContext3D::BLEND_DST_RGB, m_savedBlend.dstRGB);</span>
<span class="line-modified"> 436         saveBlendValue(GraphicsContext3D::BLEND_DST_ALPHA, m_savedBlend.dstAlpha);</span>
<span class="line-modified"> 437         saveBlendValue(GraphicsContext3D::BLEND, m_savedBlend.enabled);</span>
<span class="line-modified"> 438 </span>
<span class="line-modified"> 439         static const GC3Dfloat red = 111.0 / 255.0;</span>
<span class="line-modified"> 440         static const GC3Dfloat green = 168.0 / 255.0;</span>
<span class="line-modified"> 441         static const GC3Dfloat blue = 220.0 / 255.0;</span>
<span class="line-modified"> 442         static const GC3Dfloat alpha = 2.0 / 3.0;</span>
<span class="line-modified"> 443 </span>
<span class="line-modified"> 444         m_context.enable(GraphicsContext3D::BLEND);</span>
 445         m_context.blendColor(red, green, blue, alpha);
<span class="line-modified"> 446         m_context.blendEquation(GraphicsContext3D::FUNC_ADD);</span>
<span class="line-modified"> 447         m_context.blendFunc(GraphicsContext3D::CONSTANT_COLOR, GraphicsContext3D::ONE_MINUS_SRC_ALPHA);</span>
 448 
 449         m_didApply = true;
 450     }
 451 
 452     void hideHighlight()
 453     {
 454         if (!m_didApply)
 455             return;
 456 
 457         if (!m_savedBlend.enabled)
<span class="line-modified"> 458             m_context.disable(GraphicsContext3D::BLEND);</span>
 459 
 460         const RefPtr&lt;Float32Array&gt;&amp; color = m_savedBlend.color;
 461         m_context.blendColor(color-&gt;item(0), color-&gt;item(1), color-&gt;item(2), color-&gt;item(3));
 462         m_context.blendEquationSeparate(m_savedBlend.equationRGB, m_savedBlend.equationAlpha);
 463         m_context.blendFuncSeparate(m_savedBlend.srcRGB, m_savedBlend.dstRGB, m_savedBlend.srcAlpha, m_savedBlend.dstAlpha);
 464 
 465         m_savedBlend.color = nullptr;
 466 
 467         m_didApply = false;
 468     }
 469 
 470     template &lt;typename T&gt;
<span class="line-modified"> 471     void saveBlendValue(GC3Denum attachment, T&amp; destination)</span>
 472     {
 473         WebGLAny param = m_context.getParameter(attachment);
 474         if (WTF::holds_alternative&lt;T&gt;(param))
 475             destination = WTF::get&lt;T&gt;(param);
 476     }
 477 
<span class="line-modified"> 478     bool hasBufferBinding(GC3Denum pname)</span>
 479     {
 480         WebGLAny binding = m_context.getParameter(pname);
<span class="line-modified"> 481         if (pname == GraphicsContext3D::FRAMEBUFFER_BINDING)</span>
 482             return WTF::holds_alternative&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding);
<span class="line-modified"> 483         if (pname == GraphicsContext3D::RENDERBUFFER_BINDING)</span>
 484             return WTF::holds_alternative&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding);
 485         return false;
 486     }
 487 
<span class="line-modified"> 488     bool hasFramebufferParameterAttachment(GC3Denum attachment)</span>
 489     {
<span class="line-modified"> 490         WebGLAny attachmentParameter = m_context.getFramebufferAttachmentParameter(GraphicsContext3D::FRAMEBUFFER, attachment, GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE);</span>
 491         if (!WTF::holds_alternative&lt;unsigned&gt;(attachmentParameter))
 492             return false;
<span class="line-modified"> 493         if (WTF::get&lt;unsigned&gt;(attachmentParameter) != static_cast&lt;unsigned&gt;(GraphicsContext3D::RENDERBUFFER))</span>
 494             return false;
 495         return true;
 496     }
 497 
 498     struct {
 499         RefPtr&lt;Float32Array&gt; color;
 500         unsigned equationRGB { 0 };
 501         unsigned equationAlpha { 0 };
 502         unsigned srcRGB { 0 };
 503         unsigned srcAlpha { 0 };
 504         unsigned dstRGB { 0 };
 505         unsigned dstAlpha { 0 };
 506         bool enabled { false };
 507     } m_savedBlend;
 508 
 509     WebGLRenderingContextBase&amp; m_context;
 510     WebGLProgram* m_program { nullptr };
 511     bool m_didApply { false };
 512 };
 513 
<span class="line-modified"> 514 static bool isHighPerformanceContext(const RefPtr&lt;GraphicsContext3D&gt;&amp; context)</span>
 515 {
 516     return context-&gt;powerPreferenceUsedForCreation() == WebGLPowerPreference::HighPerformance;
 517 }
 518 
 519 std::unique_ptr&lt;WebGLRenderingContextBase&gt; WebGLRenderingContextBase::create(CanvasBase&amp; canvas, WebGLContextAttributes&amp; attributes, const String&amp; type)
 520 {
 521 #if ENABLE(WEBGL2)
 522     if (type == &quot;webgl2&quot; &amp;&amp; !RuntimeEnabledFeatures::sharedFeatures().webGL2Enabled())
 523         return nullptr;
 524 #else
 525     UNUSED_PARAM(type);
 526 #endif
 527 
 528     bool isPendingPolicyResolution = false;
 529     HostWindow* hostWindow = nullptr;
 530 
 531     auto* canvasElement = is&lt;HTMLCanvasElement&gt;(canvas) ? &amp;downcast&lt;HTMLCanvasElement&gt;(canvas) : nullptr;
 532 
 533     if (canvasElement) {
 534         Document&amp; document = canvasElement-&gt;document();
</pre>
<hr />
<pre>
 546 
 547         Document&amp; topDocument = document.topDocument();
 548         Page* page = topDocument.page();
 549         bool forcingPendingPolicy = frame-&gt;settings().isForcePendingWebGLPolicy();
 550 
 551         if (forcingPendingPolicy || (page &amp;&amp; !topDocument.url().isLocalFile())) {
 552             WebGLLoadPolicy policy = forcingPendingPolicy ? WebGLPendingCreation : page-&gt;mainFrame().loader().client().webGLPolicyForURL(topDocument.url());
 553 
 554             if (policy == WebGLBlockCreation) {
 555                 LOG(WebGL, &quot;The policy for this URL (%s) is to block WebGL.&quot;, topDocument.url().host().utf8().data());
 556                 return nullptr;
 557             }
 558 
 559             if (policy == WebGLPendingCreation) {
 560                 LOG(WebGL, &quot;WebGL policy is pending. May need to be resolved later.&quot;);
 561                 isPendingPolicyResolution = true;
 562             }
 563         }
 564 
 565         if (frame-&gt;settings().forceWebGLUsesLowPower()) {
<span class="line-modified"> 566             if (attributes.powerPreference == GraphicsContext3DPowerPreference::HighPerformance)</span>
 567                 LOG(WebGL, &quot;Overriding powerPreference from high-performance to low-power.&quot;);
<span class="line-modified"> 568             attributes.powerPreference = GraphicsContext3DPowerPreference::LowPower;</span>
 569         }
 570 
 571         if (page)
 572             attributes.devicePixelRatio = page-&gt;deviceScaleFactor();
 573 
 574         hostWindow = document.view()-&gt;root()-&gt;hostWindow();
 575     }
 576 
 577     attributes.noExtensions = true;
 578     attributes.shareResources = false;
 579 
 580     attributes.initialPowerPreference = attributes.powerPreference;
 581 
 582 
 583 #if ENABLE(WEBGL2)
 584     if (type == &quot;webgl2&quot;)
 585         attributes.isWebGL2 = true;
 586 #endif
 587 
 588     if (isPendingPolicyResolution) {
 589         LOG(WebGL, &quot;Create a WebGL context that looks real, but will require a policy resolution if used.&quot;);
 590         std::unique_ptr&lt;WebGLRenderingContextBase&gt; renderingContext = nullptr;
 591 #if ENABLE(WEBGL2)
 592         if (type == &quot;webgl2&quot;)
 593             renderingContext = WebGL2RenderingContext::create(canvas, attributes);
 594         else
 595 #endif
 596             renderingContext = WebGLRenderingContext::create(canvas, attributes);
 597         renderingContext-&gt;suspendIfNeeded();
 598         return renderingContext;
 599     }
 600 
<span class="line-modified"> 601     auto context = GraphicsContext3D::create(attributes, hostWindow);</span>
 602     if (!context || !context-&gt;makeContextCurrent()) {
 603         if (canvasElement) {
 604             canvasElement-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextcreationerrorEvent,
 605                 Event::CanBubble::No, Event::IsCancelable::Yes, &quot;Could not create a WebGL context.&quot;));
 606         }
 607         return nullptr;
 608     }
 609 
 610     auto&amp; extensions = context-&gt;getExtensions();
 611     if (extensions.supports(&quot;GL_EXT_debug_marker&quot;_s))
 612         extensions.pushGroupMarkerEXT(&quot;WebGLRenderingContext&quot;_s);
 613 
<span class="line-modified"> 614 #if ENABLE(WEBGL2) &amp;&amp; PLATFORM(MAC)</span>
 615     // glTexStorage() was only added to Core in OpenGL 4.2.
 616     // However, according to https://developer.apple.com/opengl/capabilities/ all Apple GPUs support this extension.
 617     if (attributes.isWebGL2 &amp;&amp; !extensions.supports(&quot;GL_ARB_texture_storage&quot;))
 618         return nullptr;
 619 #endif
 620 
 621     std::unique_ptr&lt;WebGLRenderingContextBase&gt; renderingContext;
 622 #if ENABLE(WEBGL2)
 623     if (type == &quot;webgl2&quot;)
 624         renderingContext = WebGL2RenderingContext::create(canvas, context.releaseNonNull(), attributes);
 625     else
 626 #endif
 627         renderingContext = WebGLRenderingContext::create(canvas, context.releaseNonNull(), attributes);
 628     renderingContext-&gt;suspendIfNeeded();
 629 
 630     return renderingContext;
 631 }
 632 
 633 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, WebGLContextAttributes attributes)
 634     : GPUBasedCanvasRenderingContext(canvas)
<span class="line-modified"> 635     , m_dispatchContextLostEventTimer(*this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)</span>
<span class="line-modified"> 636     , m_restoreTimer(*this, &amp;WebGLRenderingContextBase::maybeRestoreContext)</span>

 637     , m_attributes(attributes)
 638     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 639     , m_isPendingPolicyResolution(true)
 640     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 641 {




 642     registerWithWebGLStateTracker();
 643     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 644 }
 645 
<span class="line-modified"> 646 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, WebGLContextAttributes attributes)</span>
 647     : GPUBasedCanvasRenderingContext(canvas)
 648     , m_context(WTFMove(context))
<span class="line-modified"> 649     , m_dispatchContextLostEventTimer(*this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)</span>
<span class="line-modified"> 650     , m_restoreTimer(*this, &amp;WebGLRenderingContextBase::maybeRestoreContext)</span>

 651     , m_generatedImageCache(4)
 652     , m_attributes(attributes)
 653     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 654     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 655 {




 656     m_contextGroup = WebGLContextGroup::create();
 657     m_contextGroup-&gt;addContext(*this);
 658 
 659     m_context-&gt;addClient(*this);
 660 
<span class="line-modified"> 661     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_VIEWPORT_DIMS, m_maxViewportDims);</span>
 662 
 663     setupFlags();
 664     initializeNewContext();
 665     registerWithWebGLStateTracker();
 666     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 667 
 668     addActivityStateChangeObserverIfNecessary();
 669 }
 670 
 671 WebGLCanvas WebGLRenderingContextBase::canvas()
 672 {
 673     auto&amp; base = canvasBase();

 674     if (is&lt;OffscreenCanvas&gt;(base))
 675         return &amp;downcast&lt;OffscreenCanvas&gt;(base);

 676     return &amp;downcast&lt;HTMLCanvasElement&gt;(base);
 677 }
 678 

 679 OffscreenCanvas* WebGLRenderingContextBase::offscreenCanvas()
 680 {
 681     auto&amp; base = canvasBase();
 682     if (!is&lt;OffscreenCanvas&gt;(base))
 683         return nullptr;
 684     return &amp;downcast&lt;OffscreenCanvas&gt;(base);
 685 }

 686 
 687 // We check for context loss handling after a few seconds to give the JS a chance to register the event listeners
 688 // and to discard temporary GL contexts (e.g. feature detection).
 689 void WebGLRenderingContextBase::checkForContextLossHandling()
 690 {
 691     auto canvas = htmlCanvas();
 692     if (!canvas)
 693         return;
 694 
 695     if (!canvas-&gt;renderer())
 696         return;
 697 
 698     auto* page = canvas-&gt;document().page();
 699     if (!page)
 700         return;
 701 
 702     bool handlesContextLoss = canvas-&gt;hasEventListeners(eventNames().webglcontextlostEvent) &amp;&amp; canvas-&gt;hasEventListeners(eventNames().webglcontextrestoredEvent);
 703     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::pageHandlesWebGLContextLossKey(), handlesContextLoss ? DiagnosticLoggingKeys::yesKey() : DiagnosticLoggingKeys::noKey(), ShouldSample::No);
 704 }
 705 
</pre>
<hr />
<pre>
 713     if (!page)
 714         return;
 715 
 716     auto* tracker = page-&gt;webGLStateTracker();
 717     if (!tracker)
 718         return;
 719 
 720     m_trackerToken = tracker-&gt;token(m_attributes.initialPowerPreference);
 721 }
 722 
 723 void WebGLRenderingContextBase::initializeNewContext()
 724 {
 725     ASSERT(!m_contextLost);
 726     m_needsUpdate = true;
 727     m_markedCanvasDirty = false;
 728     m_activeTextureUnit = 0;
 729     m_packAlignment = 4;
 730     m_unpackAlignment = 4;
 731     m_unpackFlipY = false;
 732     m_unpackPremultiplyAlpha = false;
<span class="line-modified"> 733     m_unpackColorspaceConversion = GraphicsContext3D::BROWSER_DEFAULT_WEBGL;</span>
 734     m_boundArrayBuffer = nullptr;
 735     m_currentProgram = nullptr;
 736     m_framebufferBinding = nullptr;
 737     m_readFramebufferBinding = nullptr;
 738     m_renderbufferBinding = nullptr;
 739     m_depthMask = true;
 740     m_stencilEnabled = false;
 741     m_stencilMask = 0xFFFFFFFF;
 742     m_stencilMaskBack = 0xFFFFFFFF;
 743     m_stencilFuncRef = 0;
 744     m_stencilFuncRefBack = 0;
 745     m_stencilFuncMask = 0xFFFFFFFF;
 746     m_stencilFuncMaskBack = 0xFFFFFFFF;
 747     m_layerCleared = false;
 748     m_numGLErrorsToConsoleAllowed = maxGLErrorsAllowedToConsole;
 749 
 750     m_clearColor[0] = m_clearColor[1] = m_clearColor[2] = m_clearColor[3] = 0;
 751     m_scissorEnabled = false;
 752     m_clearDepth = 1;
 753     m_clearStencil = 0;
 754     m_colorMask[0] = m_colorMask[1] = m_colorMask[2] = m_colorMask[3] = true;
 755 
<span class="line-modified"> 756     GC3Dint numCombinedTextureImageUnits = 0;</span>
<span class="line-modified"> 757     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_COMBINED_TEXTURE_IMAGE_UNITS, &amp;numCombinedTextureImageUnits);</span>
 758     m_textureUnits.clear();
 759     m_textureUnits.resize(numCombinedTextureImageUnits);
<span class="line-modified"> 760     for (GC3Dint i = 0; i &lt; numCombinedTextureImageUnits; ++i)</span>
 761         m_unrenderableTextureUnits.add(i);
 762 
<span class="line-modified"> 763     GC3Dint numVertexAttribs = 0;</span>
<span class="line-modified"> 764     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_VERTEX_ATTRIBS, &amp;numVertexAttribs);</span>
 765     m_maxVertexAttribs = numVertexAttribs;
 766 
 767     m_maxTextureSize = 0;
<span class="line-modified"> 768     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_TEXTURE_SIZE, &amp;m_maxTextureSize);</span>
 769     m_maxTextureLevel = WebGLTexture::computeLevelCount(m_maxTextureSize, m_maxTextureSize);
 770     m_maxCubeMapTextureSize = 0;
<span class="line-modified"> 771     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_CUBE_MAP_TEXTURE_SIZE, &amp;m_maxCubeMapTextureSize);</span>
 772     m_maxCubeMapTextureLevel = WebGLTexture::computeLevelCount(m_maxCubeMapTextureSize, m_maxCubeMapTextureSize);
 773     m_maxRenderbufferSize = 0;
<span class="line-modified"> 774     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_RENDERBUFFER_SIZE, &amp;m_maxRenderbufferSize);</span>
 775 
 776     // These two values from EXT_draw_buffers are lazily queried.
 777     m_maxDrawBuffers = 0;
 778     m_maxColorAttachments = 0;
 779 
<span class="line-modified"> 780     m_backDrawBuffer = GraphicsContext3D::BACK;</span>
 781     m_drawBuffersWebGLRequirementsChecked = false;
 782     m_drawBuffersSupported = false;
 783 
 784     m_vertexAttribValue.resize(m_maxVertexAttribs);
 785 
 786     if (!isGLES2NPOTStrict())
 787         createFallbackBlackTextures1x1();
 788 
 789     IntSize canvasSize = clampedCanvasSize();
 790     m_context-&gt;reshape(canvasSize.width(), canvasSize.height());
 791     m_context-&gt;viewport(0, 0, canvasSize.width(), canvasSize.height());
 792     m_context-&gt;scissor(0, 0, canvasSize.width(), canvasSize.height());
<span class="line-removed"> 793 </span>
<span class="line-removed"> 794     m_context-&gt;setContextLostCallback(makeUnique&lt;WebGLRenderingContextLostCallback&gt;(this));</span>
<span class="line-removed"> 795     m_context-&gt;setErrorMessageCallback(makeUnique&lt;WebGLRenderingContextErrorMessageCallback&gt;(this));</span>
 796 }
 797 
 798 void WebGLRenderingContextBase::setupFlags()
 799 {
 800     ASSERT(m_context);
 801 
 802     auto canvas = htmlCanvas();
 803     if (canvas) {
 804         if (Page* page = canvas-&gt;document().page())
 805             m_synthesizedErrorsToConsole = page-&gt;settings().webGLErrorsToConsoleEnabled();
 806     }
 807 
 808     m_isGLES2Compliant = m_context-&gt;isGLES2Compliant();
 809     if (m_isGLES2Compliant) {
 810         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_texture_npot&quot;);
<span class="line-modified"> 811         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_packed_depth_stencil&quot;);</span>
 812     } else {
 813         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_ARB_texture_non_power_of_two&quot;);
<span class="line-modified"> 814         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_packed_depth_stencil&quot;);</span>
 815     }
 816     m_isRobustnessEXTSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_robustness&quot;);
 817 }
 818 
<span class="line-modified"> 819 void WebGLRenderingContextBase::addCompressedTextureFormat(GC3Denum format)</span>
 820 {
 821     if (!m_compressedTextureFormats.contains(format))
 822         m_compressedTextureFormats.append(format);
 823 }
 824 
 825 void WebGLRenderingContextBase::addActivityStateChangeObserverIfNecessary()
 826 {
 827     // We are only interested in visibility changes for contexts
 828     // that are using the high-performance GPU.
 829     if (!isHighPerformanceContext(m_context))
 830         return;
 831 
 832     auto* canvas = htmlCanvas();
 833     if (!canvas)
 834         return;
 835 
 836     auto* page = canvas-&gt;document().page();
 837     if (!page)
 838         return;
 839 
</pre>
<hr />
<pre>
 860     // they will be freed before the last context is removed from the context group.
 861     m_boundArrayBuffer = nullptr;
 862     m_defaultVertexArrayObject = nullptr;
 863     m_boundVertexArrayObject = nullptr;
 864     m_vertexAttrib0Buffer = nullptr;
 865     m_currentProgram = nullptr;
 866     m_framebufferBinding = nullptr;
 867     m_readFramebufferBinding = nullptr;
 868     m_renderbufferBinding = nullptr;
 869 
 870     for (auto&amp; textureUnit : m_textureUnits) {
 871         textureUnit.texture2DBinding = nullptr;
 872         textureUnit.textureCubeMapBinding = nullptr;
 873     }
 874 
 875     m_blackTexture2D = nullptr;
 876     m_blackTextureCubeMap = nullptr;
 877 
 878     if (!m_isPendingPolicyResolution) {
 879         detachAndRemoveAllObjects();
<span class="line-modified"> 880         destroyGraphicsContext3D();</span>
 881         m_contextGroup-&gt;removeContext(*this);
 882     }
 883 
 884     {
 885         LockHolder lock(WebGLProgram::instancesMutex());
 886         for (auto&amp; entry : WebGLProgram::instances(lock)) {
 887             if (entry.value == this) {
 888                 // Don&#39;t remove any WebGLProgram from the instances list, as they may still exist.
 889                 // Only remove the association with a WebGL context.
 890                 entry.value = nullptr;
 891             }
 892         }
 893     }
 894 }
 895 
<span class="line-modified"> 896 void WebGLRenderingContextBase::destroyGraphicsContext3D()</span>
 897 {
 898     if (m_isPendingPolicyResolution)
 899         return;
 900 
 901     removeActivityStateChangeObserver();
 902 
 903     if (m_context) {
 904         m_context-&gt;removeClient(*this);
<span class="line-removed"> 905         m_context-&gt;setContextLostCallback(nullptr);</span>
<span class="line-removed"> 906         m_context-&gt;setErrorMessageCallback(nullptr);</span>
 907         m_context = nullptr;
 908     }
 909 }
 910 
 911 void WebGLRenderingContextBase::markContextChanged()
 912 {
 913     if (m_framebufferBinding)
 914         return;
 915 
 916     m_context-&gt;markContextChanged();
 917 
 918     m_layerCleared = false;
 919 
 920     auto* canvas = htmlCanvas();
 921     if (!canvas)
 922         return;
 923 
 924     RenderBox* renderBox = canvas-&gt;renderBox();
 925     if (isAccelerated() &amp;&amp; renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing()) {
 926         m_markedCanvasDirty = true;
</pre>
<hr />
<pre>
 932             canvas-&gt;didDraw(FloatRect(FloatPoint(0, 0), clampedCanvasSize()));
 933         }
 934     }
 935 }
 936 
 937 void WebGLRenderingContextBase::markContextChangedAndNotifyCanvasObserver()
 938 {
 939     markContextChanged();
 940     if (!isAccelerated())
 941         return;
 942 
 943     auto* canvas = htmlCanvas();
 944     if (!canvas)
 945         return;
 946 
 947     RenderBox* renderBox = canvas-&gt;renderBox();
 948     if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing())
 949         canvas-&gt;notifyObserversCanvasChanged(FloatRect(FloatPoint(0, 0), clampedCanvasSize()));
 950 }
 951 
<span class="line-modified"> 952 bool WebGLRenderingContextBase::clearIfComposited(GC3Dbitfield mask)</span>
 953 {
 954     if (isContextLostOrPending())
 955         return false;
 956 
 957     if (!m_context-&gt;layerComposited() || m_layerCleared
 958         || m_attributes.preserveDrawingBuffer || (mask &amp;&amp; m_framebufferBinding)
 959         || m_preventBufferClearForInspector)
 960         return false;
 961 
 962     auto contextAttributes = getContextAttributes();
 963     ASSERT(contextAttributes);
 964 
 965     // Determine if it&#39;s possible to combine the clear the user asked for and this clear.
 966     bool combinedClear = mask &amp;&amp; !m_scissorEnabled;
 967 
<span class="line-modified"> 968     m_context-&gt;disable(GraphicsContext3D::SCISSOR_TEST);</span>
<span class="line-modified"> 969     if (combinedClear &amp;&amp; (mask &amp; GraphicsContext3D::COLOR_BUFFER_BIT))</span>
 970         m_context-&gt;clearColor(m_colorMask[0] ? m_clearColor[0] : 0,
 971                               m_colorMask[1] ? m_clearColor[1] : 0,
 972                               m_colorMask[2] ? m_clearColor[2] : 0,
 973                               m_colorMask[3] ? m_clearColor[3] : 0);
<span class="line-modified"> 974     else</span>
 975         m_context-&gt;clearColor(0, 0, 0, 0);
 976     m_context-&gt;colorMask(true, true, true, true);
<span class="line-modified"> 977     GC3Dbitfield clearMask = GraphicsContext3D::COLOR_BUFFER_BIT;</span>
 978     if (contextAttributes-&gt;depth) {
<span class="line-modified"> 979         if (!combinedClear || !m_depthMask || !(mask &amp; GraphicsContext3D::DEPTH_BUFFER_BIT))</span>
 980             m_context-&gt;clearDepth(1.0f);
<span class="line-modified"> 981         clearMask |= GraphicsContext3D::DEPTH_BUFFER_BIT;</span>
 982         m_context-&gt;depthMask(true);
 983     }
 984     if (contextAttributes-&gt;stencil) {
<span class="line-modified"> 985         if (combinedClear &amp;&amp; (mask &amp; GraphicsContext3D::STENCIL_BUFFER_BIT))</span>
 986             m_context-&gt;clearStencil(m_clearStencil &amp; m_stencilMask);
 987         else
 988             m_context-&gt;clearStencil(0);
<span class="line-modified"> 989         clearMask |= GraphicsContext3D::STENCIL_BUFFER_BIT;</span>
<span class="line-modified"> 990         m_context-&gt;stencilMaskSeparate(GraphicsContext3D::FRONT, 0xFFFFFFFF);</span>
 991     }
 992     if (m_framebufferBinding)
<span class="line-modified"> 993         m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, 0);</span>
 994     m_context-&gt;clear(clearMask);
 995 
 996     restoreStateAfterClear();
 997     if (m_framebufferBinding)
<span class="line-modified"> 998         m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));</span>
 999     m_layerCleared = true;
1000 
1001     return combinedClear;
1002 }
1003 
1004 void WebGLRenderingContextBase::restoreStateAfterClear()
1005 {
1006     // Restore the state that the context set.
1007     if (m_scissorEnabled)
<span class="line-modified">1008         m_context-&gt;enable(GraphicsContext3D::SCISSOR_TEST);</span>
1009     m_context-&gt;clearColor(m_clearColor[0], m_clearColor[1],
1010                           m_clearColor[2], m_clearColor[3]);
1011     m_context-&gt;colorMask(m_colorMask[0], m_colorMask[1],
1012                          m_colorMask[2], m_colorMask[3]);
1013     m_context-&gt;clearDepth(m_clearDepth);
1014     m_context-&gt;clearStencil(m_clearStencil);
<span class="line-modified">1015     m_context-&gt;stencilMaskSeparate(GraphicsContext3D::FRONT, m_stencilMask);</span>
1016     m_context-&gt;depthMask(m_depthMask);
1017 }
1018 
1019 void WebGLRenderingContextBase::markLayerComposited()
1020 {
1021     if (isContextLostOrPending())
1022         return;
1023     m_context-&gt;markLayerComposited();
1024 }
1025 
1026 void WebGLRenderingContextBase::paintRenderingResultsToCanvas()
1027 {
1028     if (isContextLostOrPending())
1029         return;
1030 
1031     auto* canvas = htmlCanvas();
1032     if (!canvas)
1033         return;
1034 
1035     if (canvas-&gt;document().printing())
</pre>
<hr />
<pre>
1057 RefPtr&lt;ImageData&gt; WebGLRenderingContextBase::paintRenderingResultsToImageData()
1058 {
1059     if (isContextLostOrPending())
1060         return nullptr;
1061     clearIfComposited();
1062     return m_context-&gt;paintRenderingResultsToImageData();
1063 }
1064 
1065 WebGLTexture::TextureExtensionFlag WebGLRenderingContextBase::textureExtensionFlags() const
1066 {
1067     return static_cast&lt;WebGLTexture::TextureExtensionFlag&gt;((m_oesTextureFloatLinear ? WebGLTexture::TextureExtensionFloatLinearEnabled : 0) | (m_oesTextureHalfFloatLinear ? WebGLTexture::TextureExtensionHalfFloatLinearEnabled : 0));
1068 }
1069 
1070 void WebGLRenderingContextBase::reshape(int width, int height)
1071 {
1072     if (isContextLostOrPending())
1073         return;
1074 
1075     // This is an approximation because at WebGLRenderingContext level we don&#39;t
1076     // know if the underlying FBO uses textures or renderbuffers.
<span class="line-modified">1077     GC3Dint maxSize = std::min(m_maxTextureSize, m_maxRenderbufferSize);</span>
<span class="line-modified">1078     GC3Dint maxWidth = std::min(maxSize, m_maxViewportDims[0]);</span>
<span class="line-modified">1079     GC3Dint maxHeight = std::min(maxSize, m_maxViewportDims[1]);</span>
1080     width = clamp(width, 1, maxWidth);
1081     height = clamp(height, 1, maxHeight);
1082 
1083     if (m_needsUpdate) {
1084         notifyCanvasContentChanged();
1085         m_needsUpdate = false;
1086     }
1087 
1088     // We don&#39;t have to mark the canvas as dirty, since the newly created image buffer will also start off
1089     // clear (and this matches what reshape will do).
1090     m_context-&gt;reshape(width, height);
1091 
1092     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
<span class="line-modified">1093     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, objectOrZero(textureUnit.texture2DBinding.get()));</span>
1094     if (textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(textureExtensionFlags()))
1095         m_unrenderableTextureUnits.add(m_activeTextureUnit);
<span class="line-modified">1096     m_context-&gt;bindRenderbuffer(GraphicsContext3D::RENDERBUFFER, objectOrZero(m_renderbufferBinding.get()));</span>
1097     if (m_framebufferBinding)
<span class="line-modified">1098       m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));</span>
1099 }
1100 
1101 int WebGLRenderingContextBase::drawingBufferWidth() const
1102 {
1103     if (isContextLost())
1104         return 0;
1105 
1106     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution)
1107         return 0;
1108 
1109     return m_context-&gt;getInternalFramebufferSize().width();
1110 }
1111 
1112 int WebGLRenderingContextBase::drawingBufferHeight() const
1113 {
1114     if (isContextLost())
1115         return 0;
1116 
1117     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution)
1118         return 0;
1119 
1120     return m_context-&gt;getInternalFramebufferSize().height();
1121 }
1122 
<span class="line-modified">1123 unsigned WebGLRenderingContextBase::sizeInBytes(GC3Denum type)</span>
1124 {
1125     switch (type) {
<span class="line-modified">1126     case GraphicsContext3D::BYTE:</span>
<span class="line-modified">1127         return sizeof(GC3Dbyte);</span>
<span class="line-modified">1128     case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="line-modified">1129         return sizeof(GC3Dubyte);</span>
<span class="line-modified">1130     case GraphicsContext3D::SHORT:</span>
<span class="line-modified">1131         return sizeof(GC3Dshort);</span>
<span class="line-modified">1132     case GraphicsContext3D::UNSIGNED_SHORT:</span>
<span class="line-modified">1133         return sizeof(GC3Dushort);</span>
<span class="line-modified">1134     case GraphicsContext3D::INT:</span>
<span class="line-modified">1135         return sizeof(GC3Dint);</span>
<span class="line-modified">1136     case GraphicsContext3D::UNSIGNED_INT:</span>
<span class="line-modified">1137         return sizeof(GC3Duint);</span>
<span class="line-modified">1138     case GraphicsContext3D::FLOAT:</span>
<span class="line-modified">1139         return sizeof(GC3Dfloat);</span>
1140     }
1141     ASSERT_NOT_REACHED();
1142     return 0;
1143 }
1144 
<span class="line-modified">1145 void WebGLRenderingContextBase::activeTexture(GC3Denum texture)</span>
1146 {
1147     if (isContextLostOrPending())
1148         return;
<span class="line-modified">1149     if (texture - GraphicsContext3D::TEXTURE0 &gt;= m_textureUnits.size()) {</span>
<span class="line-modified">1150         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;activeTexture&quot;, &quot;texture unit out of range&quot;);</span>
1151         return;
1152     }
<span class="line-modified">1153     m_activeTextureUnit = texture - GraphicsContext3D::TEXTURE0;</span>
1154     m_context-&gt;activeTexture(texture);
1155 }
1156 
1157 void WebGLRenderingContextBase::attachShader(WebGLProgram* program, WebGLShader* shader)
1158 {
1159     if (isContextLostOrPending() || !validateWebGLObject(&quot;attachShader&quot;, program) || !validateWebGLObject(&quot;attachShader&quot;, shader))
1160         return;
1161     if (!program-&gt;attachShader(shader)) {
<span class="line-modified">1162         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;attachShader&quot;, &quot;shader attachment already has shader&quot;);</span>
1163         return;
1164     }
1165     m_context-&gt;attachShader(objectOrZero(program), objectOrZero(shader));
1166     shader-&gt;onAttached();
1167 }
1168 
<span class="line-modified">1169 void WebGLRenderingContextBase::bindAttribLocation(WebGLProgram* program, GC3Duint index, const String&amp; name)</span>
1170 {
1171     if (isContextLostOrPending() || !validateWebGLObject(&quot;bindAttribLocation&quot;, program))
1172         return;
1173     if (!validateLocationLength(&quot;bindAttribLocation&quot;, name))
1174         return;
1175     if (!validateString(&quot;bindAttribLocation&quot;, name))
1176         return;
1177     if (isPrefixReserved(name)) {
<span class="line-modified">1178         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bindAttribLocation&quot;, &quot;reserved prefix&quot;);</span>
1179         return;
1180     }
1181     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">1182         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bindAttribLocation&quot;, &quot;index out of range&quot;);</span>
1183         return;
1184     }
1185     m_context-&gt;bindAttribLocation(objectOrZero(program), index, name);
1186 }
1187 
1188 bool WebGLRenderingContextBase::checkObjectToBeBound(const char* functionName, WebGLObject* object, bool&amp; deleted)
1189 {
1190     deleted = false;
1191     if (isContextLostOrPending())
1192         return false;
1193     if (object) {
1194         if (!object-&gt;validate(contextGroup(), *this)) {
<span class="line-modified">1195             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;object not from this context&quot;);</span>
1196             return false;
1197         }
1198         deleted = !object-&gt;object();
1199     }
1200     return true;
1201 }
1202 
<span class="line-modified">1203 void WebGLRenderingContextBase::bindBuffer(GC3Denum target, WebGLBuffer* buffer)</span>
1204 {
1205     bool deleted;
<span class="line-modified">1206     if (!checkObjectToBeBound(&quot;bindBuffer&quot;, buffer, deleted))</span>
<span class="line-modified">1207         return;</span>
1208     if (deleted)
1209         buffer = nullptr;
<span class="line-modified">1210     if (buffer &amp;&amp; buffer-&gt;getTarget() &amp;&amp; buffer-&gt;getTarget() != target) {</span>
<span class="line-modified">1211         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bindBuffer&quot;, &quot;buffers can not be used with multiple targets&quot;);</span>
<span class="line-modified">1212         return;</span>








1213     }
<span class="line-modified">1214     if (target == GraphicsContext3D::ARRAY_BUFFER)</span>

1215         m_boundArrayBuffer = buffer;
<span class="line-modified">1216     else if (target == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)</span>
1217         m_boundVertexArrayObject-&gt;setElementArrayBuffer(buffer);
1218     else {
1219         bool success = false;
1220 #if ENABLE(WEBGL2)
1221         if (isWebGL2()) {
1222             success = true;
1223             switch (target) {
<span class="line-modified">1224             case GraphicsContext3D::COPY_READ_BUFFER:</span>
1225                 m_boundCopyReadBuffer = buffer;
1226                 break;
<span class="line-modified">1227             case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
1228                 m_boundCopyWriteBuffer = buffer;
1229                 break;
<span class="line-modified">1230             case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
1231                 m_boundPixelPackBuffer = buffer;
1232                 break;
<span class="line-modified">1233             case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
1234                 m_boundPixelUnpackBuffer = buffer;
1235                 break;
<span class="line-modified">1236             case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
1237                 m_boundTransformFeedbackBuffer = buffer;
1238                 break;
<span class="line-modified">1239             case GraphicsContext3D::UNIFORM_BUFFER:</span>
1240                 m_boundUniformBuffer = buffer;
1241                 break;
1242             default:
1243                 success = false;
1244                 break;
1245             }
1246         }
1247 #endif
1248         if (!success) {
<span class="line-modified">1249             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindBuffer&quot;, &quot;invalid target&quot;);</span>
<span class="line-modified">1250             return;</span>
1251         }
1252     }
1253 








1254     m_context-&gt;bindBuffer(target, objectOrZero(buffer));
<span class="line-removed">1255     if (buffer)</span>
<span class="line-removed">1256         buffer-&gt;setTarget(target, isWebGL2());</span>
1257 }
1258 
<span class="line-modified">1259 void WebGLRenderingContextBase::bindFramebuffer(GC3Denum target, WebGLFramebuffer* buffer)</span>
1260 {
1261     bool deleted;
1262     if (!checkObjectToBeBound(&quot;bindFramebuffer&quot;, buffer, deleted))
1263         return;
1264     if (deleted)
1265         buffer = 0;
1266 
1267     bool isWebGL2DrawFramebufferTarget = false;
1268 #if ENABLE(WEBGL2)
<span class="line-modified">1269     isWebGL2DrawFramebufferTarget = isWebGL2() &amp;&amp; target == GraphicsContext3D::DRAW_FRAMEBUFFER;</span>
1270 #endif
1271     bool success = false;
1272 
<span class="line-modified">1273     if (target == GraphicsContext3D::FRAMEBUFFER || isWebGL2DrawFramebufferTarget) {</span>
1274         m_framebufferBinding = buffer;
1275         success = true;
1276     }
1277 #if ENABLE(WEBGL2)
<span class="line-modified">1278     if (isWebGL2() &amp;&amp; (target == GraphicsContext3D::FRAMEBUFFER || target == GraphicsContext3D::READ_FRAMEBUFFER)) {</span>
1279         m_readFramebufferBinding = buffer;
1280         success = true;
1281     }
1282 #endif
1283 
1284     if (!success) {
<span class="line-modified">1285         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindFramebuffer&quot;, &quot;invalid target&quot;);</span>
1286         return;
1287     }
1288 
1289     m_context-&gt;bindFramebuffer(target, objectOrZero(buffer));
1290     if (buffer)
1291         buffer-&gt;setHasEverBeenBound();
1292     applyStencilTest();
1293 }
1294 
<span class="line-modified">1295 void WebGLRenderingContextBase::bindRenderbuffer(GC3Denum target, WebGLRenderbuffer* renderBuffer)</span>
1296 {
1297     bool deleted;
1298     if (!checkObjectToBeBound(&quot;bindRenderbuffer&quot;, renderBuffer, deleted))
1299         return;
1300     if (deleted)
1301         renderBuffer = 0;
<span class="line-modified">1302     if (target != GraphicsContext3D::RENDERBUFFER) {</span>
<span class="line-modified">1303         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindRenderbuffer&quot;, &quot;invalid target&quot;);</span>
1304         return;
1305     }
1306     m_renderbufferBinding = renderBuffer;
1307     m_context-&gt;bindRenderbuffer(target, objectOrZero(renderBuffer));
1308     if (renderBuffer)
1309         renderBuffer-&gt;setHasEverBeenBound();
1310 }
1311 
<span class="line-modified">1312 void WebGLRenderingContextBase::bindTexture(GC3Denum target, WebGLTexture* texture)</span>
1313 {
1314     bool deleted;
1315     if (!checkObjectToBeBound(&quot;bindTexture&quot;, texture, deleted))
1316         return;
1317     if (deleted)
1318         texture = nullptr;
1319     if (texture &amp;&amp; texture-&gt;getTarget() &amp;&amp; texture-&gt;getTarget() != target) {
<span class="line-modified">1320         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bindTexture&quot;, &quot;textures can not be used with multiple targets&quot;);</span>
1321         return;
1322     }
<span class="line-modified">1323     GC3Dint maxLevel = 0;</span>
1324     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
<span class="line-modified">1325     if (target == GraphicsContext3D::TEXTURE_2D) {</span>
1326         textureUnit.texture2DBinding = texture;
1327         maxLevel = m_maxTextureLevel;
1328         if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
1329             m_unrenderableTextureUnits.add(m_activeTextureUnit);
1330         else
1331             m_unrenderableTextureUnits.remove(m_activeTextureUnit);
<span class="line-modified">1332     } else if (target == GraphicsContext3D::TEXTURE_CUBE_MAP) {</span>
1333         textureUnit.textureCubeMapBinding = texture;
1334         maxLevel = m_maxCubeMapTextureLevel;
1335         if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
1336             m_unrenderableTextureUnits.add(m_activeTextureUnit);
1337         else
1338             m_unrenderableTextureUnits.remove(m_activeTextureUnit);
1339     } else {
<span class="line-modified">1340         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindTexture&quot;, &quot;invalid target&quot;);</span>
1341         return;
1342     }
1343     m_context-&gt;bindTexture(target, objectOrZero(texture));
1344     if (texture)
1345         texture-&gt;setTarget(target, maxLevel);
1346 
1347     // Note: previously we used to automatically set the TEXTURE_WRAP_R
1348     // repeat mode to CLAMP_TO_EDGE for cube map textures, because OpenGL
1349     // ES 2.0 doesn&#39;t expose this flag (a bug in the specification) and
1350     // otherwise the application has no control over the seams in this
1351     // dimension. However, it appears that supporting this properly on all
1352     // platforms is fairly involved (will require a HashMap from texture ID
1353     // in all ports), and we have not had any complaints, so the logic has
1354     // been removed.
1355 }
1356 
<span class="line-modified">1357 void WebGLRenderingContextBase::blendColor(GC3Dfloat red, GC3Dfloat green, GC3Dfloat blue, GC3Dfloat alpha)</span>
1358 {
1359     if (isContextLostOrPending())
1360         return;
1361     m_context-&gt;blendColor(red, green, blue, alpha);
1362 }
1363 
<span class="line-modified">1364 void WebGLRenderingContextBase::blendEquation(GC3Denum mode)</span>
1365 {
1366     if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, mode))
1367         return;
1368     m_context-&gt;blendEquation(mode);
1369 }
1370 
<span class="line-modified">1371 void WebGLRenderingContextBase::blendEquationSeparate(GC3Denum modeRGB, GC3Denum modeAlpha)</span>
1372 {
1373     if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, modeRGB) || !validateBlendEquation(&quot;blendEquation&quot;, modeAlpha))
1374         return;
1375     m_context-&gt;blendEquationSeparate(modeRGB, modeAlpha);
1376 }
1377 
1378 
<span class="line-modified">1379 void WebGLRenderingContextBase::blendFunc(GC3Denum sfactor, GC3Denum dfactor)</span>
1380 {
1381     if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, sfactor, dfactor))
1382         return;
1383     m_context-&gt;blendFunc(sfactor, dfactor);
1384 }
1385 
<span class="line-modified">1386 void WebGLRenderingContextBase::blendFuncSeparate(GC3Denum srcRGB, GC3Denum dstRGB, GC3Denum srcAlpha, GC3Denum dstAlpha)</span>
1387 {
1388     // Note: Alpha does not have the same restrictions as RGB.
1389     if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, srcRGB, dstRGB))
1390         return;
1391     m_context-&gt;blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
1392 }
1393 
<span class="line-modified">1394 void WebGLRenderingContextBase::bufferData(GC3Denum target, long long size, GC3Denum usage)</span>
1395 {
1396     if (isContextLostOrPending())
1397         return;
1398     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
1399     if (!buffer)
1400         return;
1401     if (size &lt; 0) {
<span class="line-modified">1402         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;size &lt; 0&quot;);</span>
1403         return;
1404     }
1405     if (!size) {
<span class="line-modified">1406         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;size == 0&quot;);</span>
1407         return;
1408     }
<span class="line-modified">1409     if (!buffer-&gt;associateBufferData(static_cast&lt;GC3Dsizeiptr&gt;(size))) {</span>
<span class="line-modified">1410         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);</span>
1411         return;
1412     }
1413 
1414     m_context-&gt;moveErrorsToSyntheticErrorList();
<span class="line-modified">1415     m_context-&gt;bufferData(target, static_cast&lt;GC3Dsizeiptr&gt;(size), usage);</span>
1416     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1417         // The bufferData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1418         buffer-&gt;disassociateBufferData();
1419     }
1420 }
1421 
<span class="line-modified">1422 void WebGLRenderingContextBase::bufferData(GC3Denum target, Optional&lt;BufferDataSource&gt;&amp;&amp; data, GC3Denum usage)</span>
1423 {
1424     if (isContextLostOrPending())
1425         return;
1426     if (!data) {
<span class="line-modified">1427         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;null data&quot;);</span>
1428         return;
1429     }
1430     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
1431     if (!buffer)
1432         return;
1433 
1434     WTF::visit([&amp;](auto&amp; data) {
1435         if (!buffer-&gt;associateBufferData(data.get())) {
<span class="line-modified">1436             this-&gt;synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);</span>
1437             return;
1438         }
1439 
1440         m_context-&gt;moveErrorsToSyntheticErrorList();
1441         m_context-&gt;bufferData(target, data-&gt;byteLength(), data-&gt;data(), usage);
1442         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1443             // The bufferData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1444             buffer-&gt;disassociateBufferData();
1445         }
1446     }, data.value());
1447 }
1448 
<span class="line-modified">1449 void WebGLRenderingContextBase::bufferSubData(GC3Denum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp; data)</span>
1450 {
1451     if (isContextLostOrPending())
1452         return;
<span class="line-modified">1453     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferSubData&quot;, target, GraphicsContext3D::STATIC_DRAW);</span>
1454     if (!buffer)
1455         return;
1456     if (offset &lt; 0) {
<span class="line-modified">1457         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset &lt; 0&quot;);</span>
1458         return;
1459     }
1460     if (!data)
1461         return;
1462 
1463     WTF::visit([&amp;](auto&amp; data) {
<span class="line-modified">1464         if (!buffer-&gt;associateBufferSubData(static_cast&lt;GC3Dintptr&gt;(offset), data.get())) {</span>
<span class="line-modified">1465             this-&gt;synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset out of range&quot;);</span>
1466             return;
1467         }
1468 
1469         m_context-&gt;moveErrorsToSyntheticErrorList();
<span class="line-modified">1470         m_context-&gt;bufferSubData(target, static_cast&lt;GC3Dintptr&gt;(offset), data-&gt;byteLength(), data-&gt;data());</span>
1471         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1472             // The bufferSubData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1473             buffer-&gt;disassociateBufferData();
1474         }
1475     }, data.value());
1476 }
1477 
<span class="line-modified">1478 GC3Denum WebGLRenderingContextBase::checkFramebufferStatus(GC3Denum target)</span>
1479 {
1480     if (isContextLostOrPending())
<span class="line-modified">1481         return GraphicsContext3D::FRAMEBUFFER_UNSUPPORTED;</span>
<span class="line-modified">1482     if (target != GraphicsContext3D::FRAMEBUFFER) {</span>
1483 #if ENABLE(WEBGL2)
<span class="line-modified">1484         if (isWebGL1() || (target != GraphicsContext3D::DRAW_FRAMEBUFFER &amp;&amp; target != GraphicsContext3D::READ_FRAMEBUFFER)) {</span>
1485 #endif
<span class="line-modified">1486             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;checkFramebufferStatus&quot;, &quot;invalid target&quot;);</span>
1487             return 0;
1488 #if ENABLE(WEBGL2)
1489         }
1490 #endif
1491     }
1492 
<span class="line-modified">1493     auto targetFramebuffer = (target == GraphicsContext3D::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
1494 
1495     if (!targetFramebuffer || !targetFramebuffer-&gt;object())
<span class="line-modified">1496         return GraphicsContext3D::FRAMEBUFFER_COMPLETE;</span>
1497     const char* reason = &quot;framebuffer incomplete&quot;;
<span class="line-modified">1498     GC3Denum result = targetFramebuffer-&gt;checkStatus(&amp;reason);</span>
<span class="line-modified">1499     if (result != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
1500         String str = &quot;WebGL: checkFramebufferStatus:&quot; + String(reason);
1501         printToConsole(MessageLevel::Warning, str);
1502         return result;
1503     }
1504     result = m_context-&gt;checkFramebufferStatus(target);
1505     return result;
1506 }
1507 
<span class="line-modified">1508 void WebGLRenderingContextBase::clearColor(GC3Dfloat r, GC3Dfloat g, GC3Dfloat b, GC3Dfloat a)</span>
1509 {
1510     if (isContextLostOrPending())
1511         return;
1512     if (std::isnan(r))
1513         r = 0;
1514     if (std::isnan(g))
1515         g = 0;
1516     if (std::isnan(b))
1517         b = 0;
1518     if (std::isnan(a))
1519         a = 1;
1520     m_clearColor[0] = r;
1521     m_clearColor[1] = g;
1522     m_clearColor[2] = b;
1523     m_clearColor[3] = a;
1524     m_context-&gt;clearColor(r, g, b, a);
1525 }
1526 
<span class="line-modified">1527 void WebGLRenderingContextBase::clearDepth(GC3Dfloat depth)</span>
1528 {
1529     if (isContextLostOrPending())
1530         return;
1531     m_clearDepth = depth;
1532     m_context-&gt;clearDepth(depth);
1533 }
1534 
<span class="line-modified">1535 void WebGLRenderingContextBase::clearStencil(GC3Dint s)</span>
1536 {
1537     if (isContextLostOrPending())
1538         return;
1539     m_clearStencil = s;
1540     m_context-&gt;clearStencil(s);
1541 }
1542 
<span class="line-modified">1543 void WebGLRenderingContextBase::colorMask(GC3Dboolean red, GC3Dboolean green, GC3Dboolean blue, GC3Dboolean alpha)</span>
1544 {
1545     if (isContextLostOrPending())
1546         return;
1547     m_colorMask[0] = red;
1548     m_colorMask[1] = green;
1549     m_colorMask[2] = blue;
1550     m_colorMask[3] = alpha;
1551     m_context-&gt;colorMask(red, green, blue, alpha);
1552 }
1553 
1554 void WebGLRenderingContextBase::compileShader(WebGLShader* shader)
1555 {
1556     if (isContextLostOrPending() || !validateWebGLObject(&quot;compileShader&quot;, shader))
1557         return;
1558     m_context-&gt;compileShader(objectOrZero(shader));
<span class="line-modified">1559     GC3Dint value;</span>
<span class="line-modified">1560     m_context-&gt;getShaderiv(objectOrZero(shader), GraphicsContext3D::COMPILE_STATUS, &amp;value);</span>
1561     shader-&gt;setValid(value);
1562 
1563     auto* canvas = htmlCanvas();
1564 
1565     if (canvas &amp;&amp; m_synthesizedErrorsToConsole &amp;&amp; !value) {
1566         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
1567 
1568         for (auto&amp; error : getShaderInfoLog(shader).split(&#39;\n&#39;))
1569             canvas-&gt;document().addConsoleMessage(makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Error, &quot;WebGL: &quot; + error, stackTrace.copyRef()));
1570     }
1571 }
1572 
<span class="line-modified">1573 void WebGLRenderingContextBase::compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, ArrayBufferView&amp; data)</span>
1574 {
1575     if (isContextLostOrPending())
1576         return;
1577     if (!validateTexFuncLevel(&quot;compressedTexImage2D&quot;, target, level))
1578         return;
1579 
1580     if (!validateCompressedTexFormat(internalformat)) {
<span class="line-modified">1581         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;compressedTexImage2D&quot;, &quot;invalid internalformat&quot;);</span>
1582         return;
1583     }
1584     if (border) {
<span class="line-modified">1585         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;compressedTexImage2D&quot;, &quot;border not 0&quot;);</span>
1586         return;
1587     }
1588     if (!validateCompressedTexDimensions(&quot;compressedTexImage2D&quot;, target, level, width, height, internalformat))
1589         return;
1590     if (!validateCompressedTexFuncData(&quot;compressedTexImage2D&quot;, width, height, internalformat, data))
1591         return;
1592 
1593     auto tex = validateTextureBinding(&quot;compressedTexImage2D&quot;, target, true);
1594     if (!tex)
1595         return;
1596     if (!validateNPOTTextureLevel(width, height, level, &quot;compressedTexImage2D&quot;))
1597         return;
1598     m_context-&gt;moveErrorsToSyntheticErrorList();
1599     m_context-&gt;compressedTexImage2D(target, level, internalformat, width, height,
1600         border, data.byteLength(), data.baseAddress());
1601     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1602         // The compressedTexImage2D function failed. Tell the WebGLTexture it doesn&#39;t have the data for this level.
1603         tex-&gt;markInvalid(target, level);
1604         return;
1605     }
1606 
<span class="line-modified">1607     tex-&gt;setLevelInfo(target, level, internalformat, width, height, GraphicsContext3D::UNSIGNED_BYTE);</span>
1608     tex-&gt;setCompressed();
1609 }
1610 
<span class="line-modified">1611 void WebGLRenderingContextBase::compressedTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; data)</span>
1612 {
1613     if (isContextLostOrPending())
1614         return;
1615     if (!validateTexFuncLevel(&quot;compressedTexSubImage2D&quot;, target, level))
1616         return;
1617     if (!validateCompressedTexFormat(format)) {
<span class="line-modified">1618         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;compressedTexSubImage2D&quot;, &quot;invalid format&quot;);</span>
1619         return;
1620     }
1621     if (!validateCompressedTexFuncData(&quot;compressedTexSubImage2D&quot;, width, height, format, data))
1622         return;
1623 
1624     auto tex = validateTextureBinding(&quot;compressedTexSubImage2D&quot;, target, true);
1625     if (!tex)
1626         return;
1627 
1628     if (format != tex-&gt;getInternalFormat(target, level)) {
<span class="line-modified">1629         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;compressedTexSubImage2D&quot;, &quot;format does not match texture format&quot;);</span>
1630         return;
1631     }
1632 
1633     if (!validateCompressedTexSubDimensions(&quot;compressedTexSubImage2D&quot;, target, level, xoffset, yoffset, width, height, format, tex.get()))
1634         return;
1635 
<span class="line-modified">1636     graphicsContext3D()-&gt;compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data.byteLength(), data.baseAddress());</span>
1637     tex-&gt;setCompressed();
1638 }
1639 
<span class="line-modified">1640 bool WebGLRenderingContextBase::validateSettableTexInternalFormat(const char* functionName, GC3Denum internalFormat)</span>
1641 {
1642     switch (internalFormat) {
<span class="line-modified">1643     case GraphicsContext3D::DEPTH_COMPONENT:</span>
<span class="line-modified">1644     case GraphicsContext3D::DEPTH_STENCIL:</span>
<span class="line-modified">1645     case GraphicsContext3D::DEPTH_COMPONENT16:</span>
<span class="line-modified">1646     case GraphicsContext3D::DEPTH_COMPONENT24:</span>
<span class="line-modified">1647     case GraphicsContext3D::DEPTH_COMPONENT32F:</span>
<span class="line-modified">1648     case GraphicsContext3D::DEPTH24_STENCIL8:</span>
<span class="line-modified">1649     case GraphicsContext3D::DEPTH32F_STENCIL8:</span>
<span class="line-modified">1650     case GraphicsContext3D::STENCIL_INDEX8:</span>
<span class="line-modified">1651         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;format can not be set, only rendered to&quot;);</span>
1652         return false;
1653     default:
1654         return true;
1655     }
1656 }
1657 
<span class="line-modified">1658 void WebGLRenderingContextBase::copyTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)</span>
1659 {
1660     if (isContextLostOrPending())
1661         return;
1662     if (!validateTexFuncLevel(&quot;copyTexSubImage2D&quot;, target, level))
1663         return;
1664     auto tex = validateTextureBinding(&quot;copyTexSubImage2D&quot;, target, true);
1665     if (!tex)
1666         return;
1667     if (!validateSize(&quot;copyTexSubImage2D&quot;, xoffset, yoffset) || !validateSize(&quot;copyTexSubImage2D&quot;, width, height))
1668         return;
1669     // Before checking if it is in the range, check if overflow happens first.
1670     if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
<span class="line-modified">1671         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);</span>
1672         return;
1673     }
1674     if (xoffset + width &gt; tex-&gt;getWidth(target, level) || yoffset + height &gt; tex-&gt;getHeight(target, level)) {
<span class="line-modified">1675         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;rectangle out of range&quot;);</span>
1676         return;
1677     }
<span class="line-modified">1678     GC3Denum internalFormat = tex-&gt;getInternalFormat(target, level);</span>
1679     if (!validateSettableTexInternalFormat(&quot;copyTexSubImage2D&quot;, internalFormat))
1680         return;
1681     if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
<span class="line-modified">1682         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;copyTexSubImage2D&quot;, &quot;framebuffer is incompatible format&quot;);</span>
1683         return;
1684     }
1685     const char* reason = &quot;framebuffer incomplete&quot;;
<span class="line-modified">1686     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {</span>
<span class="line-modified">1687         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexSubImage2D&quot;, reason);</span>
1688         return;
1689     }
1690     clearIfComposited();
1691 
<span class="line-modified">1692     GC3Dint clippedX, clippedY;</span>
<span class="line-modified">1693     GC3Dsizei clippedWidth, clippedHeight;</span>
1694     if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
<span class="line-modified">1695         GC3Denum format;</span>
<span class="line-modified">1696         GC3Denum type;</span>
<span class="line-modified">1697         if (!GraphicsContext3D::possibleFormatAndTypeForInternalFormat(tex-&gt;getInternalFormat(target, level), format, type)) {</span>
<span class="line-modified">1698             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;copyTexSubImage2D&quot;, &quot;Texture has unknown internal format&quot;);</span>
1699             return;
1700         }
1701         UniqueArray&lt;unsigned char&gt; zero;
1702         if (width &amp;&amp; height) {
1703             unsigned size;
<span class="line-modified">1704             GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;size, nullptr);</span>
<span class="line-modified">1705             if (error != GraphicsContext3D::NO_ERROR) {</span>
1706                 synthesizeGLError(error, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);
1707                 return;
1708             }
1709             zero = makeUniqueArray&lt;unsigned char&gt;(size);
1710             if (!zero) {
<span class="line-modified">1711                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;out of memory&quot;);</span>
1712                 return;
1713             }
1714             memset(zero.get(), 0, size);
1715         }
1716         m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, zero.get());
1717         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0)
1718             m_context-&gt;copyTexSubImage2D(target, level, xoffset + clippedX - x, yoffset + clippedY - y, clippedX, clippedY, clippedWidth, clippedHeight);
1719     } else
1720         m_context-&gt;copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
1721 }
1722 
1723 RefPtr&lt;WebGLBuffer&gt; WebGLRenderingContextBase::createBuffer()
1724 {
1725     if (isContextLostOrPending())
1726         return nullptr;
1727     auto buffer = WebGLBuffer::create(*this);
1728     addSharedObject(buffer.get());
1729     return buffer;
1730 }
1731 
</pre>
<hr />
<pre>
1737     addContextObject(buffer.get());
1738     return buffer;
1739 }
1740 
1741 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::createTexture()
1742 {
1743     if (isContextLostOrPending())
1744         return nullptr;
1745     auto texture = WebGLTexture::create(*this);
1746     addSharedObject(texture.get());
1747     return texture;
1748 }
1749 
1750 RefPtr&lt;WebGLProgram&gt; WebGLRenderingContextBase::createProgram()
1751 {
1752     if (isContextLostOrPending())
1753         return nullptr;
1754     auto program = WebGLProgram::create(*this);
1755     addSharedObject(program.get());
1756 
<span class="line-modified">1757     InspectorInstrumentation::didCreateProgram(*this, program.get());</span>
1758 
1759     return program;
1760 }
1761 
1762 RefPtr&lt;WebGLRenderbuffer&gt; WebGLRenderingContextBase::createRenderbuffer()
1763 {
1764     if (isContextLostOrPending())
1765         return nullptr;
1766     auto buffer = WebGLRenderbuffer::create(*this);
1767     addSharedObject(buffer.get());
1768     return buffer;
1769 }
1770 
<span class="line-modified">1771 RefPtr&lt;WebGLShader&gt; WebGLRenderingContextBase::createShader(GC3Denum type)</span>
1772 {
1773     if (isContextLostOrPending())
1774         return nullptr;
<span class="line-modified">1775     if (type != GraphicsContext3D::VERTEX_SHADER &amp;&amp; type != GraphicsContext3D::FRAGMENT_SHADER) {</span>
<span class="line-modified">1776         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;createShader&quot;, &quot;invalid shader type&quot;);</span>
1777         return nullptr;
1778     }
1779 
1780     auto shader = WebGLShader::create(*this, type);
1781     addSharedObject(shader.get());
1782     return shader;
1783 }
1784 
<span class="line-modified">1785 void WebGLRenderingContextBase::cullFace(GC3Denum mode)</span>
1786 {
1787     if (isContextLostOrPending())
1788         return;
1789     m_context-&gt;cullFace(mode);
1790 }
1791 
1792 bool WebGLRenderingContextBase::deleteObject(WebGLObject* object)
1793 {
1794     if (isContextLostOrPending() || !object)
1795         return false;
1796     if (!object-&gt;validate(contextGroup(), *this)) {
<span class="line-modified">1797         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;delete&quot;, &quot;object does not belong to this context&quot;);</span>
1798         return false;
1799     }
1800     if (object-&gt;isDeleted())
1801         return false;
1802     if (object-&gt;object())
1803         // We need to pass in context here because we want
1804         // things in this context unbound.
<span class="line-modified">1805         object-&gt;deleteObject(graphicsContext3D());</span>
1806     return true;
1807 }
1808 

















1809 void WebGLRenderingContextBase::deleteBuffer(WebGLBuffer* buffer)
1810 {
1811     if (!deleteObject(buffer))
1812         return;
<span class="line-removed">1813     if (m_boundArrayBuffer == buffer)</span>
<span class="line-removed">1814         m_boundArrayBuffer = nullptr;</span>
1815 
<span class="line-modified">1816     m_boundVertexArrayObject-&gt;unbindBuffer(*buffer);</span>
1817 }
1818 
1819 void WebGLRenderingContextBase::deleteFramebuffer(WebGLFramebuffer* framebuffer)
1820 {
1821     if (!deleteObject(framebuffer))
1822         return;
1823 #if ENABLE(WEBGL2)
1824     if (isWebGL2() &amp;&amp; framebuffer == m_readFramebufferBinding) {
1825         m_readFramebufferBinding = nullptr;
<span class="line-modified">1826         m_context-&gt;bindFramebuffer(GraphicsContext3D::READ_FRAMEBUFFER, 0);</span>
1827     }
1828 #endif
1829     if (framebuffer == m_framebufferBinding) {
1830         m_framebufferBinding = nullptr;
1831 #if ENABLE(WEBGL2)
1832         if (isWebGL2())
<span class="line-modified">1833             m_context-&gt;bindFramebuffer(GraphicsContext3D::DRAW_FRAMEBUFFER, 0);</span>
1834         else
1835 #endif
<span class="line-modified">1836             m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, 0);</span>
1837     }
1838 }
1839 
1840 void WebGLRenderingContextBase::deleteProgram(WebGLProgram* program)
1841 {
1842     if (program)
<span class="line-modified">1843         InspectorInstrumentation::willDeleteProgram(*this, *program);</span>
1844 
1845     deleteObject(program);
1846     // We don&#39;t reset m_currentProgram to 0 here because the deletion of the
1847     // current program is delayed.
1848 }
1849 
1850 void WebGLRenderingContextBase::deleteRenderbuffer(WebGLRenderbuffer* renderbuffer)
1851 {
1852     if (!deleteObject(renderbuffer))
1853         return;
1854     if (renderbuffer == m_renderbufferBinding)
1855         m_renderbufferBinding = nullptr;
1856     if (m_framebufferBinding)
1857         m_framebufferBinding-&gt;removeAttachmentFromBoundFramebuffer(renderbuffer);
1858 }
1859 
1860 void WebGLRenderingContextBase::deleteShader(WebGLShader* shader)
1861 {
1862     deleteObject(shader);
1863 }
</pre>
<hr />
<pre>
1866 {
1867     if (!deleteObject(texture))
1868         return;
1869 
1870     unsigned current = 0;
1871     for (auto&amp; textureUnit : m_textureUnits) {
1872         if (texture == textureUnit.texture2DBinding) {
1873             textureUnit.texture2DBinding = nullptr;
1874             m_unrenderableTextureUnits.remove(current);
1875         }
1876         if (texture == textureUnit.textureCubeMapBinding) {
1877             textureUnit.textureCubeMapBinding = nullptr;
1878             m_unrenderableTextureUnits.remove(current);
1879         }
1880         ++current;
1881     }
1882     if (m_framebufferBinding)
1883         m_framebufferBinding-&gt;removeAttachmentFromBoundFramebuffer(texture);
1884 }
1885 
<span class="line-modified">1886 void WebGLRenderingContextBase::depthFunc(GC3Denum func)</span>
1887 {
1888     if (isContextLostOrPending())
1889         return;
1890     m_context-&gt;depthFunc(func);
1891 }
1892 
<span class="line-modified">1893 void WebGLRenderingContextBase::depthMask(GC3Dboolean flag)</span>
1894 {
1895     if (isContextLostOrPending())
1896         return;
1897     m_depthMask = flag;
1898     m_context-&gt;depthMask(flag);
1899 }
1900 
<span class="line-modified">1901 void WebGLRenderingContextBase::depthRange(GC3Dfloat zNear, GC3Dfloat zFar)</span>
1902 {
1903     if (isContextLostOrPending())
1904         return;
1905     if (zNear &gt; zFar) {
<span class="line-modified">1906         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;depthRange&quot;, &quot;zNear &gt; zFar&quot;);</span>
1907         return;
1908     }
1909     m_context-&gt;depthRange(zNear, zFar);
1910 }
1911 
1912 void WebGLRenderingContextBase::detachShader(WebGLProgram* program, WebGLShader* shader)
1913 {
1914     if (isContextLostOrPending() || !validateWebGLObject(&quot;detachShader&quot;, program) || !validateWebGLObject(&quot;detachShader&quot;, shader))
1915         return;
1916     if (!program-&gt;detachShader(shader)) {
<span class="line-modified">1917         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;detachShader&quot;, &quot;shader not attached&quot;);</span>
1918         return;
1919     }
1920     m_context-&gt;detachShader(objectOrZero(program), objectOrZero(shader));
<span class="line-modified">1921     shader-&gt;onDetached(graphicsContext3D());</span>
1922 }
1923 
<span class="line-modified">1924 void WebGLRenderingContextBase::disable(GC3Denum cap)</span>
1925 {
1926     if (isContextLostOrPending() || !validateCapability(&quot;disable&quot;, cap))
1927         return;
<span class="line-modified">1928     if (cap == GraphicsContext3D::STENCIL_TEST) {</span>
1929         m_stencilEnabled = false;
1930         applyStencilTest();
1931         return;
1932     }
<span class="line-modified">1933     if (cap == GraphicsContext3D::SCISSOR_TEST)</span>
1934         m_scissorEnabled = false;
1935     m_context-&gt;disable(cap);
1936 }
1937 
<span class="line-modified">1938 void WebGLRenderingContextBase::disableVertexAttribArray(GC3Duint index)</span>
1939 {
1940     if (isContextLostOrPending())
1941         return;
1942     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">1943         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;disableVertexAttribArray&quot;, &quot;index out of range&quot;);</span>
1944         return;
1945     }
1946 
1947     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
1948     state.enabled = false;
1949 
1950     if (index &gt; 0 || isGLES2Compliant())
1951         m_context-&gt;disableVertexAttribArray(index);
1952 }
1953 
<span class="line-modified">1954 bool WebGLRenderingContextBase::validateNPOTTextureLevel(GC3Dsizei width, GC3Dsizei height, GC3Dint level, const char* functionName)</span>
1955 {
1956     if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
<span class="line-modified">1957         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level &gt; 0 not power of 2&quot;);</span>
1958         return false;
1959     }
1960 
1961     return true;
1962 }
1963 
<span class="line-modified">1964 bool WebGLRenderingContextBase::validateElementArraySize(GC3Dsizei count, GC3Denum type, GC3Dintptr offset)</span>
1965 {
1966     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
1967 
1968     if (!elementArrayBuffer)
1969         return false;
1970 
1971     if (offset &lt; 0)
1972         return false;
1973 
<span class="line-modified">1974     if (type == GraphicsContext3D::UNSIGNED_INT) {</span>
1975         // For an unsigned int array, offset must be divisible by 4 for alignment reasons.
1976         if (offset % 4)
1977             return false;
1978 
1979         // Make uoffset an element offset.
1980         offset /= 4;
1981 
<span class="line-modified">1982         GC3Dsizeiptr n = elementArrayBuffer-&gt;byteLength() / 4;</span>
1983         if (offset &gt; n || count &gt; n - offset)
1984             return false;
<span class="line-modified">1985     } else if (type == GraphicsContext3D::UNSIGNED_SHORT) {</span>
1986         // For an unsigned short array, offset must be divisible by 2 for alignment reasons.
1987         if (offset % 2)
1988             return false;
1989 
1990         // Make uoffset an element offset.
1991         offset /= 2;
1992 
<span class="line-modified">1993         GC3Dsizeiptr n = elementArrayBuffer-&gt;byteLength() / 2;</span>
1994         if (offset &gt; n || count &gt; n - offset)
1995             return false;
<span class="line-modified">1996     } else if (type == GraphicsContext3D::UNSIGNED_BYTE) {</span>
<span class="line-modified">1997         GC3Dsizeiptr n = elementArrayBuffer-&gt;byteLength();</span>
1998         if (offset &gt; n || count &gt; n - offset)
1999             return false;
2000     }
2001     return true;
2002 }
2003 
<span class="line-modified">2004 bool WebGLRenderingContextBase::validateIndexArrayPrecise(GC3Dsizei count, GC3Denum type, GC3Dintptr offset, unsigned&amp; numElementsRequired)</span>
2005 {
2006     ASSERT(count &gt;= 0 &amp;&amp; offset &gt;= 0);
2007     unsigned maxIndex = 0;
2008 
2009     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
2010 
2011     if (!elementArrayBuffer)
2012         return false;
2013 
2014     if (!count) {
2015         numElementsRequired = 0;
2016         return true;
2017     }
2018 
2019     auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
2020     if (!buffer)
2021         return false;
2022 
2023     switch (type) {
<span class="line-modified">2024     case GraphicsContext3D::UNSIGNED_INT:</span>
<span class="line-modified">2025         maxIndex = getMaxIndex&lt;GC3Duint&gt;(buffer, offset, count);</span>
2026         break;
<span class="line-modified">2027     case GraphicsContext3D::UNSIGNED_SHORT:</span>
<span class="line-modified">2028         maxIndex = getMaxIndex&lt;GC3Dushort&gt;(buffer, offset, count);</span>
2029         break;
<span class="line-modified">2030     case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="line-modified">2031         maxIndex = getMaxIndex&lt;GC3Dubyte&gt;(buffer, offset, count);</span>
2032         break;
2033     }
2034 
2035     // Then set the maxiumum index in the index array and make sure it is valid.
2036     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex, 1, 1);
2037     if (!checkedNumElementsRequired)
2038         return false;
2039     numElementsRequired = checkedNumElementsRequired.value();
2040     return true;
2041 }
2042 
2043 bool WebGLRenderingContextBase::validateVertexAttributes(unsigned elementCount, unsigned primitiveCount)
2044 {
<span class="line-modified">2045 #if !USE(ANGLE)</span>



2046     if (!m_currentProgram)
2047         return false;
2048 
2049     // Look in each enabled vertex attrib and check if they&#39;ve been bound to a buffer.
2050     for (unsigned i = 0; i &lt; m_maxVertexAttribs; ++i) {
2051         if (!m_boundVertexArrayObject-&gt;getVertexAttribState(i).validateBinding())
2052             return false;
2053     }
2054 
2055     if (!elementCount)
2056         return true;
2057 
2058     // Look in each consumed vertex attrib (by the current program).
2059     bool sawNonInstancedAttrib = false;
2060     bool sawEnabledAttrib = false;
2061     int numActiveAttribLocations = m_currentProgram-&gt;numActiveAttribLocations();
2062     for (int i = 0; i &lt; numActiveAttribLocations; ++i) {
2063         int loc = m_currentProgram-&gt;getActiveAttribLocation(i);
2064         if (loc &gt;= 0 &amp;&amp; loc &lt; static_cast&lt;int&gt;(m_maxVertexAttribs)) {
2065             const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(loc);
</pre>
<hr />
<pre>
2086                         return false;
2087                 }
2088             }
2089         }
2090     }
2091 
2092     if (!sawNonInstancedAttrib &amp;&amp; sawEnabledAttrib)
2093         return false;
2094 
2095     bool usingSimulatedArrayBuffer = m_currentProgram-&gt;isUsingVertexAttrib0();
2096 
2097     // Guard against access into non-existent buffers.
2098     if (elementCount &amp;&amp; !sawEnabledAttrib &amp;&amp; !usingSimulatedArrayBuffer)
2099         return false;
2100 
2101     if (elementCount &amp;&amp; sawEnabledAttrib) {
2102         if (!m_boundArrayBuffer &amp;&amp; !m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
2103             if (usingSimulatedArrayBuffer) {
2104                 auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
2105                 if (state.enabled &amp;&amp; state.isBound()) {
<span class="line-modified">2106                     if (state.bufferBinding-&gt;getTarget() == GraphicsContext3D::ARRAY_BUFFER || state.bufferBinding-&gt;getTarget() == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)</span>
2107                         return !!state.bufferBinding-&gt;byteLength();
2108                 }
2109             }
2110             return false;
2111         }
2112     }
2113 #endif
2114 
2115     return true;
2116 }
2117 
2118 bool WebGLRenderingContextBase::validateWebGLObject(const char* functionName, WebGLObject* object)
2119 {
2120     if (!object || !object-&gt;object()) {
<span class="line-modified">2121         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no object or object deleted&quot;);</span>
2122         return false;
2123     }
2124     if (!object-&gt;validate(contextGroup(), *this)) {
<span class="line-modified">2125         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;object does not belong to this context&quot;);</span>
2126         return false;
2127     }
2128     return true;
2129 }
2130 
<span class="line-modified">2131 bool WebGLRenderingContextBase::validateDrawArrays(const char* functionName, GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primitiveCount)</span>
2132 {
2133     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
2134         return false;
2135 
2136     if (!validateStencilSettings(functionName))
2137         return false;
2138 
2139     if (first &lt; 0 || count &lt; 0) {
<span class="line-modified">2140         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;first or count &lt; 0&quot;);</span>
2141         return false;
2142     }
2143 
2144     if (!count) {
2145         markContextChanged();
2146         return false;
2147     }
2148 
2149     if (primitiveCount &lt; 0) {
<span class="line-modified">2150         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);</span>
2151         return false;
2152     }
2153 
2154     // Ensure we have a valid rendering state.
<span class="line-modified">2155     Checked&lt;GC3Dint, RecordOverflow&gt; checkedSum = Checked&lt;GC3Dint, RecordOverflow&gt;(first) + Checked&lt;GC3Dint, RecordOverflow&gt;(count);</span>
<span class="line-modified">2156     Checked&lt;GC3Dint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);</span>
2157     if (checkedSum.hasOverflowed() || checkedPrimitiveCount.hasOverflowed() || !validateVertexAttributes(checkedSum.unsafeGet(), checkedPrimitiveCount.unsafeGet())) {
<span class="line-modified">2158         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
2159         return false;
2160     }
2161     if (!validateSimulatedVertexAttrib0(checkedSum.unsafeGet() - 1)) {
<span class="line-modified">2162         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);</span>
2163         return false;
2164     }
2165 
2166     const char* reason = &quot;framebuffer incomplete&quot;;
<span class="line-modified">2167     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {</span>
<span class="line-modified">2168         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);</span>
2169         return false;
2170     }
2171 
2172     return true;
2173 }
2174 
<span class="line-modified">2175 bool WebGLRenderingContextBase::validateDrawElements(const char* functionName, GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, unsigned&amp; numElements, GC3Dsizei primitiveCount)</span>
2176 {
2177     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
2178         return false;
2179 
2180     if (!validateStencilSettings(functionName))
2181         return false;
2182 
2183     switch (type) {
<span class="line-modified">2184     case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="line-modified">2185     case GraphicsContext3D::UNSIGNED_SHORT:</span>
2186         break;
<span class="line-modified">2187     case GraphicsContext3D::UNSIGNED_INT:</span>
2188         if (m_oesElementIndexUint || isWebGL2())
2189             break;
<span class="line-modified">2190         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid type&quot;);</span>
2191         return false;
2192     default:
<span class="line-modified">2193         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid type&quot;);</span>
2194         return false;
2195     }
2196 
2197     if (count &lt; 0 || offset &lt; 0) {
<span class="line-modified">2198         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;count or offset &lt; 0&quot;);</span>
2199         return false;
2200     }
2201 
2202     if (!count) {
2203         markContextChanged();
2204         return false;
2205     }
2206 
2207     if (primitiveCount &lt; 0) {
<span class="line-modified">2208         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);</span>
2209         return false;
2210     }
2211 
2212     if (!m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
<span class="line-modified">2213         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;no ELEMENT_ARRAY_BUFFER bound&quot;);</span>
2214         return false;
2215     }
2216 
2217     // Ensure we have a valid rendering state.
<span class="line-modified">2218     if (!validateElementArraySize(count, type, static_cast&lt;GC3Dintptr&gt;(offset))) {</span>
<span class="line-modified">2219         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;request out of bounds for current ELEMENT_ARRAY_BUFFER&quot;);</span>
2220         return false;
2221     }
2222     if (!count)
2223         return false;
2224 
<span class="line-modified">2225     Checked&lt;GC3Dint, RecordOverflow&gt; checkedCount(count);</span>
<span class="line-modified">2226     Checked&lt;GC3Dint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);</span>
2227     if (checkedCount.hasOverflowed() || checkedPrimitiveCount.hasOverflowed()) {
<span class="line-modified">2228         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
2229         return false;
2230     }
2231 
2232     if (!validateIndexArrayConservative(type, numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {
<span class="line-modified">2233         if (!validateIndexArrayPrecise(checkedCount.unsafeGet(), type, static_cast&lt;GC3Dintptr&gt;(offset), numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {</span>
<span class="line-modified">2234             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
2235             return false;
2236         }
2237     }
2238 
2239     if (!validateSimulatedVertexAttrib0(numElements)) {
<span class="line-modified">2240         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);</span>
2241         return false;
2242     }
2243 
2244     const char* reason = &quot;framebuffer incomplete&quot;;
<span class="line-modified">2245     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {</span>
<span class="line-modified">2246         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);</span>
2247         return false;
2248     }
2249 
2250     return true;
2251 }
2252 
<span class="line-modified">2253 void WebGLRenderingContextBase::drawArrays(GC3Denum mode, GC3Dint first, GC3Dsizei count)</span>
2254 {
2255     if (!validateDrawArrays(&quot;drawArrays&quot;, mode, first, count, 0))
2256         return;
2257 
<span class="line-modified">2258     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isShaderProgramDisabled(*this, *m_currentProgram))</span>
2259         return;
2260 
2261     clearIfComposited();
2262 
2263     bool vertexAttrib0Simulated = false;
2264     if (!isGLES2Compliant()) {
2265         auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
2266         if (!simulateVertexAttrib0Status) {
2267             // We were unable to simulate the attribute buffer.
<span class="line-modified">2268             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawArrays&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
2269             return;
2270         }
2271         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
2272     }
2273     bool usesFallbackTexture = false;
2274     if (!isGLES2NPOTStrict())
2275         usesFallbackTexture = checkTextureCompleteness(&quot;drawArrays&quot;, true);
2276 
2277     {
2278         InspectorScopedShaderProgramHighlight scopedHighlight(*this, m_currentProgram.get());
2279 
2280         m_context-&gt;drawArrays(mode, first, count);
2281     }
2282 
2283     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
2284         restoreStatesAfterVertexAttrib0Simulation();
2285     if (usesFallbackTexture)
2286         checkTextureCompleteness(&quot;drawArrays&quot;, false);
2287     markContextChangedAndNotifyCanvasObserver();
2288 }
2289 
2290 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
<span class="line-modified">2291 static GC3Duint getRestartIndex(GC3Denum type)</span>
2292 {
2293     switch (type) {
<span class="line-modified">2294     case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="line-modified">2295         return std::numeric_limits&lt;GC3Dubyte&gt;::max();</span>
<span class="line-modified">2296     case GraphicsContext3D::UNSIGNED_SHORT:</span>
<span class="line-modified">2297         return std::numeric_limits&lt;GC3Dushort&gt;::max();</span>
<span class="line-modified">2298     case GraphicsContext3D::UNSIGNED_INT:</span>
<span class="line-modified">2299         return std::numeric_limits&lt;GC3Duint&gt;::max();</span>
2300     }
2301 
2302     return 0;
2303 }
2304 #endif
2305 
<span class="line-modified">2306 void WebGLRenderingContextBase::drawElements(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset)</span>
2307 {
2308     unsigned numElements = 0;
2309     if (!validateDrawElements(&quot;drawElements&quot;, mode, count, type, offset, numElements, 0))
2310         return;
2311 
<span class="line-modified">2312     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isShaderProgramDisabled(*this, *m_currentProgram))</span>
2313         return;
2314 
2315     clearIfComposited();
2316 
2317     bool vertexAttrib0Simulated = false;
2318     if (!isGLES2Compliant()) {
2319         if (!numElements)
<span class="line-modified">2320             validateIndexArrayPrecise(count, type, static_cast&lt;GC3Dintptr&gt;(offset), numElements);</span>
2321         auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
2322         if (!simulateVertexAttrib0Status) {
2323             // We were unable to simulate the attribute buffer.
<span class="line-modified">2324             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawElements&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
2325             return;
2326         }
2327         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
2328     }
2329 
2330     bool usesFallbackTexture = false;
2331     if (!isGLES2NPOTStrict())
2332         usesFallbackTexture = checkTextureCompleteness(&quot;drawElements&quot;, true);
2333 
2334 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
2335     if (isWebGL2())
2336         m_context-&gt;primitiveRestartIndex(getRestartIndex(type));
2337 #endif
2338 
2339     {
2340         InspectorScopedShaderProgramHighlight scopedHighlight(*this, m_currentProgram.get());
2341 
<span class="line-modified">2342         m_context-&gt;drawElements(mode, count, type, static_cast&lt;GC3Dintptr&gt;(offset));</span>
2343     }
2344 
2345     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
2346         restoreStatesAfterVertexAttrib0Simulation();
2347     if (usesFallbackTexture)
2348         checkTextureCompleteness(&quot;drawElements&quot;, false);
2349     markContextChangedAndNotifyCanvasObserver();
2350 }
2351 
<span class="line-modified">2352 void WebGLRenderingContextBase::enable(GC3Denum cap)</span>
2353 {
2354     if (isContextLostOrPending() || !validateCapability(&quot;enable&quot;, cap))
2355         return;
<span class="line-modified">2356     if (cap == GraphicsContext3D::STENCIL_TEST) {</span>
2357         m_stencilEnabled = true;
2358         applyStencilTest();
2359         return;
2360     }
<span class="line-modified">2361     if (cap == GraphicsContext3D::SCISSOR_TEST)</span>
2362         m_scissorEnabled = true;
2363     m_context-&gt;enable(cap);
2364 }
2365 
<span class="line-modified">2366 void WebGLRenderingContextBase::enableVertexAttribArray(GC3Duint index)</span>
2367 {
2368     if (isContextLostOrPending())
2369         return;
2370     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">2371         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;enableVertexAttribArray&quot;, &quot;index out of range&quot;);</span>
2372         return;
2373     }
2374 
2375     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
2376     state.enabled = true;
2377 
2378     m_context-&gt;enableVertexAttribArray(index);
2379 }
2380 
2381 void WebGLRenderingContextBase::finish()
2382 {
2383     if (isContextLostOrPending())
2384         return;
2385     m_context-&gt;finish();
2386 }
2387 
2388 void WebGLRenderingContextBase::flush()
2389 {
2390     if (isContextLostOrPending())
2391         return;
2392     m_context-&gt;flush();
2393 }
2394 
<span class="line-modified">2395 void WebGLRenderingContextBase::framebufferRenderbuffer(GC3Denum target, GC3Denum attachment, GC3Denum renderbuffertarget, WebGLRenderbuffer* buffer)</span>
2396 {
2397     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferRenderbuffer&quot;, target, attachment))
2398         return;
<span class="line-modified">2399     if (renderbuffertarget != GraphicsContext3D::RENDERBUFFER) {</span>
<span class="line-modified">2400         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;framebufferRenderbuffer&quot;, &quot;invalid target&quot;);</span>
2401         return;
2402     }
2403     if (buffer &amp;&amp; !buffer-&gt;validate(contextGroup(), *this)) {
<span class="line-modified">2404         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no buffer or buffer not from this context&quot;);</span>




2405         return;
2406     }
2407 
<span class="line-modified">2408     auto targetFramebuffer = (target == GraphicsContext3D::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
2409 
2410     // Don&#39;t allow the default framebuffer to be mutated; all current
2411     // implementations use an FBO internally in place of the default
2412     // FBO.
2413     if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
<span class="line-modified">2414         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no framebuffer bound&quot;);</span>
2415         return;
2416     }
<span class="line-modified">2417     Platform3DObject bufferObject = objectOrZero(buffer);</span>
<span class="line-modified">2418     switch (attachment) {</span>
<span class="line-modified">2419     case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:</span>
<span class="line-modified">2420         m_context-&gt;framebufferRenderbuffer(target, GraphicsContext3D::DEPTH_ATTACHMENT, renderbuffertarget, bufferObject);</span>
<span class="line-modified">2421         m_context-&gt;framebufferRenderbuffer(target, GraphicsContext3D::STENCIL_ATTACHMENT, renderbuffertarget, bufferObject);</span>
<span class="line-modified">2422         break;</span>
<span class="line-modified">2423     default:</span>
2424         m_context-&gt;framebufferRenderbuffer(target, attachment, renderbuffertarget, bufferObject);
<span class="line-removed">2425     }</span>
2426     targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, buffer);
2427     applyStencilTest();
2428 }
2429 
<span class="line-modified">2430 void WebGLRenderingContextBase::framebufferTexture2D(GC3Denum target, GC3Denum attachment, GC3Denum textarget, WebGLTexture* texture, GC3Dint level)</span>
2431 {
2432     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferTexture2D&quot;, target, attachment))
2433         return;
2434     if (level &amp;&amp; isWebGL1()) {
<span class="line-modified">2435         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;framebufferTexture2D&quot;, &quot;level not 0&quot;);</span>
2436         return;
2437     }
2438     if (texture &amp;&amp; !texture-&gt;validate(contextGroup(), *this)) {
<span class="line-modified">2439         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no texture or texture not from this context&quot;);</span>
2440         return;
2441     }
2442 
<span class="line-modified">2443     auto targetFramebuffer = (target == GraphicsContext3D::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
2444 
2445     // Don&#39;t allow the default framebuffer to be mutated; all current
2446     // implementations use an FBO internally in place of the default
2447     // FBO.
2448     if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
<span class="line-modified">2449         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no framebuffer bound&quot;);</span>
2450         return;
2451     }
<span class="line-modified">2452     Platform3DObject textureObject = objectOrZero(texture);</span>
<span class="line-modified">2453     switch (attachment) {</span>
<span class="line-modified">2454     case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:</span>
<span class="line-modified">2455         m_context-&gt;framebufferTexture2D(target, GraphicsContext3D::DEPTH_ATTACHMENT, textarget, textureObject, level);</span>
<span class="line-modified">2456         m_context-&gt;framebufferTexture2D(target, GraphicsContext3D::STENCIL_ATTACHMENT, textarget, textureObject, level);</span>
<span class="line-modified">2457         break;</span>
<span class="line-modified">2458     case GraphicsContext3D::DEPTH_ATTACHMENT:</span>
<span class="line-modified">2459         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);</span>
<span class="line-removed">2460         break;</span>
<span class="line-removed">2461     case GraphicsContext3D::STENCIL_ATTACHMENT:</span>
<span class="line-removed">2462         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);</span>
<span class="line-removed">2463         break;</span>
<span class="line-removed">2464     default:</span>
2465         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);
<span class="line-modified">2466     }</span>
2467     targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, textarget, texture, level);
2468     applyStencilTest();
2469 }
2470 
<span class="line-modified">2471 void WebGLRenderingContextBase::frontFace(GC3Denum mode)</span>
2472 {
2473     if (isContextLostOrPending())
2474         return;
2475     m_context-&gt;frontFace(mode);
2476 }
2477 
<span class="line-modified">2478 void WebGLRenderingContextBase::generateMipmap(GC3Denum target)</span>
2479 {
2480     if (isContextLostOrPending())
2481         return;
2482     auto tex = validateTextureBinding(&quot;generateMipmap&quot;, target, false);
2483     if (!tex)
2484         return;
2485     if (!tex-&gt;canGenerateMipmaps()) {
<span class="line-modified">2486         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;level 0 not power of 2 or not all the same size&quot;);</span>
2487         return;
2488     }
2489     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=123916. Compressed textures should be allowed in WebGL 2:
2490     if (tex-&gt;isCompressed()) {
<span class="line-modified">2491         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;trying to generate mipmaps from compressed texture&quot;);</span>
2492         return;
2493     }
2494     if (!validateSettableTexInternalFormat(&quot;generateMipmap&quot;, tex-&gt;getInternalFormat(target, 0)))
2495         return;
2496 
2497     // generateMipmap won&#39;t work properly if minFilter is not NEAREST_MIPMAP_LINEAR
2498     // on Mac.  Remove the hack once this driver bug is fixed.
2499 #if OS(DARWIN)
2500     bool needToResetMinFilter = false;
<span class="line-modified">2501     if (tex-&gt;getMinFilter() != GraphicsContext3D::NEAREST_MIPMAP_LINEAR) {</span>
<span class="line-modified">2502         m_context-&gt;texParameteri(target, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::NEAREST_MIPMAP_LINEAR);</span>
2503         needToResetMinFilter = true;
2504     }
2505 #endif
2506     m_context-&gt;generateMipmap(target);
2507 #if OS(DARWIN)
2508     if (needToResetMinFilter)
<span class="line-modified">2509         m_context-&gt;texParameteri(target, GraphicsContext3D::TEXTURE_MIN_FILTER, tex-&gt;getMinFilter());</span>
2510 #endif
2511     tex-&gt;generateMipmapLevelInfo();
2512 }
2513 
<span class="line-modified">2514 RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveAttrib(WebGLProgram* program, GC3Duint index)</span>
2515 {
2516     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveAttrib&quot;, program))
2517         return nullptr;
<span class="line-modified">2518     ActiveInfo info;</span>
2519     if (!m_context-&gt;getActiveAttrib(objectOrZero(program), index, info))
2520         return nullptr;
2521 
2522     LOG(WebGL, &quot;Returning active attribute %d: %s&quot;, index, info.name.utf8().data());
2523 
2524     return WebGLActiveInfo::create(info.name, info.type, info.size);
2525 }
2526 
<span class="line-modified">2527 RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveUniform(WebGLProgram* program, GC3Duint index)</span>
2528 {
2529     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveUniform&quot;, program))
2530         return nullptr;
<span class="line-modified">2531     ActiveInfo info;</span>
2532     if (!m_context-&gt;getActiveUniform(objectOrZero(program), index, info))
2533         return nullptr;
2534     if (!isGLES2Compliant())
2535         if (info.size &gt; 1 &amp;&amp; !info.name.endsWith(&quot;[0]&quot;))
2536             info.name.append(&quot;[0]&quot;);
2537 
2538     LOG(WebGL, &quot;Returning active uniform %d: %s&quot;, index, info.name.utf8().data());
2539 
2540     return WebGLActiveInfo::create(info.name, info.type, info.size);
2541 }
2542 
2543 Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; WebGLRenderingContextBase::getAttachedShaders(WebGLProgram* program)
2544 {
2545     if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttachedShaders&quot;, program))
2546         return WTF::nullopt;
2547 
<span class="line-modified">2548     const GC3Denum shaderTypes[] = {</span>
<span class="line-modified">2549         GraphicsContext3D::VERTEX_SHADER,</span>
<span class="line-modified">2550         GraphicsContext3D::FRAGMENT_SHADER</span>
2551     };
2552     Vector&lt;RefPtr&lt;WebGLShader&gt;&gt; shaderObjects;
2553     for (auto shaderType : shaderTypes) {
2554         RefPtr&lt;WebGLShader&gt; shader = program-&gt;getAttachedShader(shaderType);
2555         if (shader)
2556             shaderObjects.append(shader);
2557     }
2558     return shaderObjects;
2559 }
2560 
<span class="line-modified">2561 GC3Dint WebGLRenderingContextBase::getAttribLocation(WebGLProgram* program, const String&amp; name)</span>
2562 {
2563     if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttribLocation&quot;, program))
2564         return -1;
2565     if (!validateLocationLength(&quot;getAttribLocation&quot;, name))
2566         return -1;
2567     if (!validateString(&quot;getAttribLocation&quot;, name))
2568         return -1;
2569     if (isPrefixReserved(name))
2570         return -1;
2571     if (!program-&gt;getLinkStatus()) {
<span class="line-modified">2572         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getAttribLocation&quot;, &quot;program not linked&quot;);</span>
2573         return -1;
2574     }
2575     return m_context-&gt;getAttribLocation(objectOrZero(program), name);
2576 }
2577 
<span class="line-modified">2578 WebGLAny WebGLRenderingContextBase::getBufferParameter(GC3Denum target, GC3Denum pname)</span>
2579 {
2580     if (isContextLostOrPending())
2581         return nullptr;
2582 
2583     bool valid = false;
<span class="line-modified">2584     if (target == GraphicsContext3D::ARRAY_BUFFER || target == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)</span>
2585         valid = true;
2586 #if ENABLE(WEBGL2)
2587     if (isWebGL2()) {
2588         switch (target) {
<span class="line-modified">2589         case GraphicsContext3D::COPY_READ_BUFFER:</span>
<span class="line-modified">2590         case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
<span class="line-modified">2591         case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">2592         case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">2593         case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">2594         case GraphicsContext3D::UNIFORM_BUFFER:</span>
2595             valid = true;
2596         }
2597     }
2598 #endif
2599     if (!valid) {
<span class="line-modified">2600         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid target&quot;);</span>
2601         return nullptr;
2602     }
2603 
<span class="line-modified">2604     if (pname != GraphicsContext3D::BUFFER_SIZE &amp;&amp; pname != GraphicsContext3D::BUFFER_USAGE) {</span>
<span class="line-modified">2605         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
2606         return nullptr;
2607     }
2608 
<span class="line-modified">2609     GC3Dint value = 0;</span>
2610     m_context-&gt;getBufferParameteriv(target, pname, &amp;value);
<span class="line-modified">2611     if (pname == GraphicsContext3D::BUFFER_SIZE)</span>
2612         return value;
2613     return static_cast&lt;unsigned&gt;(value);
2614 }
2615 
2616 Optional&lt;WebGLContextAttributes&gt; WebGLRenderingContextBase::getContextAttributes()
2617 {
2618     if (isContextLostOrPending())
2619         return WTF::nullopt;
2620 
2621     // Also, we need to enforce requested values of &quot;false&quot; for depth
2622     // and stencil, regardless of the properties of the underlying
<span class="line-modified">2623     // GraphicsContext3D.</span>
2624 
<span class="line-modified">2625     auto attributes = m_context-&gt;getContextAttributes();</span>
2626     if (!m_attributes.depth)
2627         attributes.depth = false;
2628     if (!m_attributes.stencil)
2629         attributes.stencil = false;
2630     return attributes;
2631 }
2632 
<span class="line-modified">2633 GC3Denum WebGLRenderingContextBase::getError()</span>
2634 {
2635     if (m_isPendingPolicyResolution)
<span class="line-modified">2636         return GraphicsContext3D::NO_ERROR;</span>
2637     return m_context-&gt;getError();
2638 }
2639 
<span class="line-modified">2640 WebGLAny WebGLRenderingContextBase::getProgramParameter(WebGLProgram* program, GC3Denum pname)</span>
2641 {
2642     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramParameter&quot;, program))
2643         return nullptr;
2644 
<span class="line-modified">2645     GC3Dint value = 0;</span>
2646     switch (pname) {
<span class="line-modified">2647     case GraphicsContext3D::DELETE_STATUS:</span>
2648         return program-&gt;isDeleted();
<span class="line-modified">2649     case GraphicsContext3D::VALIDATE_STATUS:</span>
2650         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2651         return static_cast&lt;bool&gt;(value);
<span class="line-modified">2652     case GraphicsContext3D::LINK_STATUS:</span>
2653         return program-&gt;getLinkStatus();
<span class="line-modified">2654     case GraphicsContext3D::ATTACHED_SHADERS:</span>
2655         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2656         return value;
<span class="line-modified">2657     case GraphicsContext3D::ACTIVE_ATTRIBUTES:</span>
<span class="line-modified">2658     case GraphicsContext3D::ACTIVE_UNIFORMS:</span>
2659 #if USE(ANGLE)
2660         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2661 #else
2662         m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), pname, &amp;value);
2663 #endif // USE(ANGLE)
2664         return value;
2665     default:
<span class="line-modified">2666         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getProgramParameter&quot;, &quot;invalid parameter name&quot;);</span>













2667         return nullptr;
2668     }
2669 }
2670 
2671 String WebGLRenderingContextBase::getProgramInfoLog(WebGLProgram* program)
2672 {
2673     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramInfoLog&quot;, program))
2674         return String();
2675     return ensureNotNull(m_context-&gt;getProgramInfoLog(objectOrZero(program)));
2676 }
2677 
<span class="line-modified">2678 WebGLAny WebGLRenderingContextBase::getRenderbufferParameter(GC3Denum target, GC3Denum pname)</span>
2679 {
2680     if (isContextLostOrPending())
2681         return nullptr;
<span class="line-modified">2682     if (target != GraphicsContext3D::RENDERBUFFER) {</span>
<span class="line-modified">2683         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid target&quot;);</span>
2684         return nullptr;
2685     }
2686     if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
<span class="line-modified">2687         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getRenderbufferParameter&quot;, &quot;no renderbuffer bound&quot;);</span>
2688         return nullptr;
2689     }
2690 
<span class="line-modified">2691     if (m_renderbufferBinding-&gt;getInternalFormat() == GraphicsContext3D::DEPTH_STENCIL</span>
2692         &amp;&amp; !m_renderbufferBinding-&gt;isValid()) {
2693         ASSERT(!isDepthStencilSupported());
2694         int value = 0;
2695         switch (pname) {
<span class="line-modified">2696         case GraphicsContext3D::RENDERBUFFER_WIDTH:</span>
2697             value = m_renderbufferBinding-&gt;getWidth();
2698             break;
<span class="line-modified">2699         case GraphicsContext3D::RENDERBUFFER_HEIGHT:</span>
2700             value = m_renderbufferBinding-&gt;getHeight();
2701             break;
<span class="line-modified">2702         case GraphicsContext3D::RENDERBUFFER_RED_SIZE:</span>
<span class="line-modified">2703         case GraphicsContext3D::RENDERBUFFER_GREEN_SIZE:</span>
<span class="line-modified">2704         case GraphicsContext3D::RENDERBUFFER_BLUE_SIZE:</span>
<span class="line-modified">2705         case GraphicsContext3D::RENDERBUFFER_ALPHA_SIZE:</span>
2706             value = 0;
2707             break;
<span class="line-modified">2708         case GraphicsContext3D::RENDERBUFFER_DEPTH_SIZE:</span>
2709             value = 24;
2710             break;
<span class="line-modified">2711         case GraphicsContext3D::RENDERBUFFER_STENCIL_SIZE:</span>
2712             value = 8;
2713             break;
<span class="line-modified">2714         case GraphicsContext3D::RENDERBUFFER_INTERNAL_FORMAT:</span>
2715             return m_renderbufferBinding-&gt;getInternalFormat();
2716         default:
<span class="line-modified">2717             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
2718             return nullptr;
2719         }
2720         return value;
2721     }
2722 
<span class="line-modified">2723     GC3Dint value = 0;</span>
2724     switch (pname) {
<span class="line-modified">2725     case GraphicsContext3D::RENDERBUFFER_WIDTH:</span>
<span class="line-modified">2726     case GraphicsContext3D::RENDERBUFFER_HEIGHT:</span>
<span class="line-modified">2727     case GraphicsContext3D::RENDERBUFFER_RED_SIZE:</span>
<span class="line-modified">2728     case GraphicsContext3D::RENDERBUFFER_GREEN_SIZE:</span>
<span class="line-modified">2729     case GraphicsContext3D::RENDERBUFFER_BLUE_SIZE:</span>
<span class="line-modified">2730     case GraphicsContext3D::RENDERBUFFER_ALPHA_SIZE:</span>
<span class="line-modified">2731     case GraphicsContext3D::RENDERBUFFER_DEPTH_SIZE:</span>
<span class="line-modified">2732     case GraphicsContext3D::RENDERBUFFER_STENCIL_SIZE:</span>
2733         m_context-&gt;getRenderbufferParameteriv(target, pname, &amp;value);
2734         return value;
<span class="line-modified">2735     case GraphicsContext3D::RENDERBUFFER_INTERNAL_FORMAT:</span>
2736         return m_renderbufferBinding-&gt;getInternalFormat();
2737     default:
<span class="line-modified">2738         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
2739         return nullptr;
2740     }
2741 }
2742 
<span class="line-modified">2743 WebGLAny WebGLRenderingContextBase::getShaderParameter(WebGLShader* shader, GC3Denum pname)</span>
2744 {
2745     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderParameter&quot;, shader))
2746         return nullptr;
<span class="line-modified">2747     GC3Dint value = 0;</span>
2748     switch (pname) {
<span class="line-modified">2749     case GraphicsContext3D::DELETE_STATUS:</span>
2750         return shader-&gt;isDeleted();
<span class="line-modified">2751     case GraphicsContext3D::COMPILE_STATUS:</span>
2752         m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
2753         return static_cast&lt;bool&gt;(value);
<span class="line-modified">2754     case GraphicsContext3D::SHADER_TYPE:</span>
2755         m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
2756         return static_cast&lt;unsigned&gt;(value);
2757     default:
<span class="line-modified">2758         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getShaderParameter&quot;, &quot;invalid parameter name&quot;);</span>
2759         return nullptr;
2760     }
2761 }
2762 
2763 String WebGLRenderingContextBase::getShaderInfoLog(WebGLShader* shader)
2764 {
2765     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderInfoLog&quot;, shader))
2766         return String();
2767     return ensureNotNull(m_context-&gt;getShaderInfoLog(objectOrZero(shader)));
2768 }
2769 
<span class="line-modified">2770 RefPtr&lt;WebGLShaderPrecisionFormat&gt; WebGLRenderingContextBase::getShaderPrecisionFormat(GC3Denum shaderType, GC3Denum precisionType)</span>
2771 {
2772     if (isContextLostOrPending())
2773         return nullptr;
2774     switch (shaderType) {
<span class="line-modified">2775     case GraphicsContext3D::VERTEX_SHADER:</span>
<span class="line-modified">2776     case GraphicsContext3D::FRAGMENT_SHADER:</span>
2777         break;
2778     default:
<span class="line-modified">2779         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid shader type&quot;);</span>
2780         return nullptr;
2781     }
2782     switch (precisionType) {
<span class="line-modified">2783     case GraphicsContext3D::LOW_FLOAT:</span>
<span class="line-modified">2784     case GraphicsContext3D::MEDIUM_FLOAT:</span>
<span class="line-modified">2785     case GraphicsContext3D::HIGH_FLOAT:</span>
<span class="line-modified">2786     case GraphicsContext3D::LOW_INT:</span>
<span class="line-modified">2787     case GraphicsContext3D::MEDIUM_INT:</span>
<span class="line-modified">2788     case GraphicsContext3D::HIGH_INT:</span>
2789         break;
2790     default:
<span class="line-modified">2791         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid precision type&quot;);</span>
2792         return nullptr;
2793     }
2794 
<span class="line-modified">2795     GC3Dint range[2] = {0, 0};</span>
<span class="line-modified">2796     GC3Dint precision = 0;</span>
2797     m_context-&gt;getShaderPrecisionFormat(shaderType, precisionType, range, &amp;precision);
2798     return WebGLShaderPrecisionFormat::create(range[0], range[1], precision);
2799 }
2800 
2801 String WebGLRenderingContextBase::getShaderSource(WebGLShader* shader)
2802 {
2803     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderSource&quot;, shader))
2804         return String();
2805     return ensureNotNull(shader-&gt;getSource());
2806 }
2807 
<span class="line-modified">2808 WebGLAny WebGLRenderingContextBase::getTexParameter(GC3Denum target, GC3Denum pname)</span>
2809 {
2810     if (isContextLostOrPending())
2811         return nullptr;
2812     auto tex = validateTextureBinding(&quot;getTexParameter&quot;, target, false);
2813     if (!tex)
2814         return nullptr;
<span class="line-modified">2815     GC3Dint value = 0;</span>

2816     switch (pname) {
<span class="line-modified">2817     case GraphicsContext3D::TEXTURE_MAG_FILTER:</span>
<span class="line-modified">2818     case GraphicsContext3D::TEXTURE_MIN_FILTER:</span>
<span class="line-modified">2819     case GraphicsContext3D::TEXTURE_WRAP_S:</span>
<span class="line-modified">2820     case GraphicsContext3D::TEXTURE_WRAP_T:</span>
2821         m_context-&gt;getTexParameteriv(target, pname, &amp;value);
2822         return static_cast&lt;unsigned&gt;(value);
<span class="line-modified">2823     case Extensions3D::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
2824         if (m_extTextureFilterAnisotropic) {
<span class="line-modified">2825             m_context-&gt;getTexParameteriv(target, pname, &amp;value);</span>
<span class="line-modified">2826             return static_cast&lt;unsigned&gt;(value);</span>
2827         }
<span class="line-modified">2828         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);</span>
2829         return nullptr;
2830     default:
<span class="line-modified">2831         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name&quot;);</span>
2832         return nullptr;
2833     }
2834 }
2835 
2836 WebGLAny WebGLRenderingContextBase::getUniform(WebGLProgram* program, const WebGLUniformLocation* uniformLocation)
2837 {
2838     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniform&quot;, program))
2839         return nullptr;
2840     if (!uniformLocation || uniformLocation-&gt;program() != program) {
<span class="line-modified">2841         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getUniform&quot;, &quot;no uniformlocation or not valid for this program&quot;);</span>
2842         return nullptr;
2843     }
<span class="line-modified">2844     GC3Dint location = uniformLocation-&gt;location();</span>
2845 
<span class="line-modified">2846     GC3Denum baseType;</span>
2847     unsigned length;
2848     switch (uniformLocation-&gt;type()) {
<span class="line-modified">2849     case GraphicsContext3D::BOOL:</span>
<span class="line-modified">2850         baseType = GraphicsContext3D::BOOL;</span>
2851         length = 1;
2852         break;
<span class="line-modified">2853     case GraphicsContext3D::BOOL_VEC2:</span>
<span class="line-modified">2854         baseType = GraphicsContext3D::BOOL;</span>
2855         length = 2;
2856         break;
<span class="line-modified">2857     case GraphicsContext3D::BOOL_VEC3:</span>
<span class="line-modified">2858         baseType = GraphicsContext3D::BOOL;</span>
2859         length = 3;
2860         break;
<span class="line-modified">2861     case GraphicsContext3D::BOOL_VEC4:</span>
<span class="line-modified">2862         baseType = GraphicsContext3D::BOOL;</span>
2863         length = 4;
2864         break;
<span class="line-modified">2865     case GraphicsContext3D::INT:</span>
<span class="line-modified">2866         baseType = GraphicsContext3D::INT;</span>
2867         length = 1;
2868         break;
<span class="line-modified">2869     case GraphicsContext3D::INT_VEC2:</span>
<span class="line-modified">2870         baseType = GraphicsContext3D::INT;</span>
2871         length = 2;
2872         break;
<span class="line-modified">2873     case GraphicsContext3D::INT_VEC3:</span>
<span class="line-modified">2874         baseType = GraphicsContext3D::INT;</span>
2875         length = 3;
2876         break;
<span class="line-modified">2877     case GraphicsContext3D::INT_VEC4:</span>
<span class="line-modified">2878         baseType = GraphicsContext3D::INT;</span>
2879         length = 4;
2880         break;
<span class="line-modified">2881     case GraphicsContext3D::FLOAT:</span>
<span class="line-modified">2882         baseType = GraphicsContext3D::FLOAT;</span>
2883         length = 1;
2884         break;
<span class="line-modified">2885     case GraphicsContext3D::FLOAT_VEC2:</span>
<span class="line-modified">2886         baseType = GraphicsContext3D::FLOAT;</span>
2887         length = 2;
2888         break;
<span class="line-modified">2889     case GraphicsContext3D::FLOAT_VEC3:</span>
<span class="line-modified">2890         baseType = GraphicsContext3D::FLOAT;</span>
2891         length = 3;
2892         break;
<span class="line-modified">2893     case GraphicsContext3D::FLOAT_VEC4:</span>
<span class="line-modified">2894         baseType = GraphicsContext3D::FLOAT;</span>
2895         length = 4;
2896         break;
<span class="line-modified">2897     case GraphicsContext3D::FLOAT_MAT2:</span>
<span class="line-modified">2898         baseType = GraphicsContext3D::FLOAT;</span>
2899         length = 4;
2900         break;
<span class="line-modified">2901     case GraphicsContext3D::FLOAT_MAT3:</span>
<span class="line-modified">2902         baseType = GraphicsContext3D::FLOAT;</span>
2903         length = 9;
2904         break;
<span class="line-modified">2905     case GraphicsContext3D::FLOAT_MAT4:</span>
<span class="line-modified">2906         baseType = GraphicsContext3D::FLOAT;</span>
2907         length = 16;
2908         break;
<span class="line-modified">2909     case GraphicsContext3D::SAMPLER_2D:</span>
<span class="line-modified">2910     case GraphicsContext3D::SAMPLER_CUBE:</span>
<span class="line-modified">2911         baseType = GraphicsContext3D::INT;</span>
2912         length = 1;
2913         break;
2914     default:
2915         // Can&#39;t handle this type
<span class="line-modified">2916         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getUniform&quot;, &quot;unhandled type&quot;);</span>
2917         return nullptr;
2918     }
2919     switch (baseType) {
<span class="line-modified">2920     case GraphicsContext3D::FLOAT: {</span>
<span class="line-modified">2921         GC3Dfloat value[16] = {0};</span>
2922         if (m_isRobustnessEXTSupported)
<span class="line-modified">2923             m_context-&gt;getExtensions().getnUniformfvEXT(objectOrZero(program), location, 16 * sizeof(GC3Dfloat), value);</span>
2924         else
2925             m_context-&gt;getUniformfv(objectOrZero(program), location, value);
2926         if (length == 1)
2927             return value[0];
2928         return Float32Array::tryCreate(value, length);
2929     }
<span class="line-modified">2930     case GraphicsContext3D::INT: {</span>
<span class="line-modified">2931         GC3Dint value[4] = {0};</span>
2932         if (m_isRobustnessEXTSupported)
<span class="line-modified">2933             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GC3Dint), value);</span>
2934         else
2935             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2936         if (length == 1)
2937             return value[0];
2938         return Int32Array::tryCreate(value, length);
2939     }
<span class="line-modified">2940     case GraphicsContext3D::BOOL: {</span>
<span class="line-modified">2941         GC3Dint value[4] = {0};</span>
2942         if (m_isRobustnessEXTSupported)
<span class="line-modified">2943             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GC3Dint), value);</span>
2944         else
2945             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2946         if (length &gt; 1) {
2947             Vector&lt;bool&gt; vector(length);
2948             for (unsigned j = 0; j &lt; length; j++)
2949                 vector[j] = value[j];
2950             return vector;
2951         }
2952         return static_cast&lt;bool&gt;(value[0]);
2953     }
2954     default:
2955         notImplemented();
2956     }
2957 
2958     // If we get here, something went wrong in our unfortunately complex logic above
<span class="line-modified">2959     synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getUniform&quot;, &quot;unknown error&quot;);</span>
2960     return nullptr;
2961 }
2962 
2963 RefPtr&lt;WebGLUniformLocation&gt; WebGLRenderingContextBase::getUniformLocation(WebGLProgram* program, const String&amp; name)
2964 {
2965     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniformLocation&quot;, program))
2966         return nullptr;
2967     if (!validateLocationLength(&quot;getUniformLocation&quot;, name))
2968         return nullptr;
2969     if (!validateString(&quot;getUniformLocation&quot;, name))
2970         return nullptr;
2971     if (isPrefixReserved(name))
2972         return nullptr;
2973     if (!program-&gt;getLinkStatus()) {
<span class="line-modified">2974         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getUniformLocation&quot;, &quot;program not linked&quot;);</span>
2975         return nullptr;
2976     }
<span class="line-modified">2977     GC3Dint uniformLocation = m_context-&gt;getUniformLocation(objectOrZero(program), name);</span>
2978     if (uniformLocation == -1)
2979         return nullptr;
2980 
<span class="line-modified">2981     GC3Dint activeUniforms = 0;</span>
2982 #if USE(ANGLE)
<span class="line-modified">2983     m_context-&gt;getProgramiv(objectOrZero(program), GraphicsContext3D::ACTIVE_UNIFORMS, &amp;activeUniforms);</span>
2984 #else
<span class="line-modified">2985     m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), GraphicsContext3D::ACTIVE_UNIFORMS, &amp;activeUniforms);</span>
2986 #endif
<span class="line-modified">2987     for (GC3Dint i = 0; i &lt; activeUniforms; i++) {</span>
<span class="line-modified">2988         ActiveInfo info;</span>
2989         if (!m_context-&gt;getActiveUniform(objectOrZero(program), i, info))
2990             return nullptr;
2991         // Strip &quot;[0]&quot; from the name if it&#39;s an array.
2992         if (info.name.endsWith(&quot;[0]&quot;))
2993             info.name = info.name.left(info.name.length() - 3);
2994         // If it&#39;s an array, we need to iterate through each element, appending &quot;[index]&quot; to the name.
<span class="line-modified">2995         for (GC3Dint index = 0; index &lt; info.size; ++index) {</span>
2996             String uniformName = makeString(info.name, &#39;[&#39;, index, &#39;]&#39;);
2997 
2998             if (name == uniformName || name == info.name)
2999                 return WebGLUniformLocation::create(program, uniformLocation, info.type);
3000         }
3001     }
3002     return nullptr;
3003 }
3004 
<span class="line-modified">3005 WebGLAny WebGLRenderingContextBase::getVertexAttrib(GC3Duint index, GC3Denum pname)</span>
3006 {
3007     if (isContextLostOrPending())
3008         return nullptr;
3009 
3010     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">3011         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getVertexAttrib&quot;, &quot;index out of range&quot;);</span>
3012         return nullptr;
3013     }
3014 
3015     const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
3016 
<span class="line-modified">3017     if ((isWebGL2() || m_angleInstancedArrays) &amp;&amp; pname == GraphicsContext3D::VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)</span>
3018         return state.divisor;
3019 
3020     switch (pname) {
<span class="line-modified">3021     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:</span>
3022         if ((!isGLES2Compliant() &amp;&amp; !index &amp;&amp; m_boundVertexArrayObject-&gt;getVertexAttribState(0).bufferBinding == m_vertexAttrib0Buffer)
3023             || !state.bufferBinding
3024             || !state.bufferBinding-&gt;object())
3025             return nullptr;
3026         return state.bufferBinding;
<span class="line-modified">3027     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_ENABLED:</span>
3028         return state.enabled;
<span class="line-modified">3029     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_NORMALIZED:</span>
3030         return state.normalized;
<span class="line-modified">3031     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_SIZE:</span>
3032         return state.size;
<span class="line-modified">3033     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_STRIDE:</span>
3034         return state.originalStride;
<span class="line-modified">3035     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_TYPE:</span>
3036         return state.type;
<span class="line-modified">3037     case GraphicsContext3D::CURRENT_VERTEX_ATTRIB:</span>
3038         return Float32Array::tryCreate(m_vertexAttribValue[index].value, 4);
3039     default:
<span class="line-modified">3040         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getVertexAttrib&quot;, &quot;invalid parameter name&quot;);</span>
3041         return nullptr;
3042     }
3043 }
3044 
<span class="line-modified">3045 long long WebGLRenderingContextBase::getVertexAttribOffset(GC3Duint index, GC3Denum pname)</span>
3046 {
3047     if (isContextLostOrPending())
3048         return 0;
3049     return m_context-&gt;getVertexAttribOffset(index, pname);
3050 }
3051 
3052 bool WebGLRenderingContextBase::extensionIsEnabled(const String&amp; name)
3053 {
3054 #define CHECK_EXTENSION(variable, nameLiteral) \
3055     if (equalIgnoringASCIICase(name, nameLiteral)) \
3056         return variable != nullptr;
3057 
3058     CHECK_EXTENSION(m_extFragDepth, &quot;EXT_frag_depth&quot;);
3059     CHECK_EXTENSION(m_extBlendMinMax, &quot;EXT_blend_minmax&quot;);
3060     CHECK_EXTENSION(m_extsRGB, &quot;EXT_sRGB&quot;);
3061     CHECK_EXTENSION(m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;);
3062     CHECK_EXTENSION(m_extTextureFilterAnisotropic, &quot;WEBKIT_EXT_texture_filter_anisotropic&quot;);
3063     CHECK_EXTENSION(m_extShaderTextureLOD, &quot;EXT_shader_texture_lod&quot;);
3064     CHECK_EXTENSION(m_oesTextureFloat, &quot;OES_texture_float&quot;);
3065     CHECK_EXTENSION(m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;);
3066     CHECK_EXTENSION(m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;);
3067     CHECK_EXTENSION(m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;);
3068     CHECK_EXTENSION(m_oesStandardDerivatives, &quot;OES_standard_derivatives&quot;);
3069     CHECK_EXTENSION(m_oesVertexArrayObject, &quot;OES_vertex_array_object&quot;);
3070     CHECK_EXTENSION(m_oesElementIndexUint, &quot;OES_element_index_uint&quot;);
3071     CHECK_EXTENSION(m_webglLoseContext, &quot;WEBGL_lose_context&quot;);
3072     CHECK_EXTENSION(m_webglDebugRendererInfo, &quot;WEBGL_debug_renderer_info&quot;);
3073     CHECK_EXTENSION(m_webglDebugShaders, &quot;WEBGL_debug_shaders&quot;);

3074     CHECK_EXTENSION(m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;);


3075     CHECK_EXTENSION(m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;);
3076     CHECK_EXTENSION(m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;);
3077     CHECK_EXTENSION(m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;);
3078     CHECK_EXTENSION(m_webglDrawBuffers, &quot;WEBGL_draw_buffers&quot;);
3079     CHECK_EXTENSION(m_angleInstancedArrays, &quot;ANGLE_instanced_arrays&quot;);
3080     return false;
3081 }
3082 
<span class="line-modified">3083 GC3Dboolean WebGLRenderingContextBase::isBuffer(WebGLBuffer* buffer)</span>
3084 {
3085     if (!buffer || isContextLostOrPending())
3086         return 0;
3087 
3088     if (!buffer-&gt;hasEverBeenBound())
3089         return 0;
3090 
3091     return m_context-&gt;isBuffer(buffer-&gt;object());
3092 }
3093 
3094 bool WebGLRenderingContextBase::isContextLost() const
3095 {
3096     return m_contextLost;
3097 }
3098 
3099 bool WebGLRenderingContextBase::isContextLostOrPending()
3100 {
3101     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution) {
3102         LOG(WebGL, &quot;Context is being used. Attempt to resolve the policy.&quot;);
3103         auto* canvas = htmlCanvas();
3104         if (canvas) {
3105             Document&amp; document = canvas-&gt;document().topDocument();
3106             Page* page = document.page();
3107             if (page &amp;&amp; !document.url().isLocalFile())
3108                 page-&gt;mainFrame().loader().client().resolveWebGLPolicyForURL(document.url());
3109             // FIXME: We don&#39;t currently do anything with the result from resolution. A more
3110             // complete implementation might try to construct a real context, etc and proceed
3111             // with normal operation.
3112             // https://bugs.webkit.org/show_bug.cgi?id=129122
3113         }
3114         m_hasRequestedPolicyResolution = true;
3115     }
3116 
3117     return m_contextLost || m_isPendingPolicyResolution;
3118 }
3119 
<span class="line-modified">3120 GC3Dboolean WebGLRenderingContextBase::isEnabled(GC3Denum cap)</span>
3121 {
3122     if (isContextLostOrPending() || !validateCapability(&quot;isEnabled&quot;, cap))
3123         return 0;
<span class="line-modified">3124     if (cap == GraphicsContext3D::STENCIL_TEST)</span>
3125         return m_stencilEnabled;
3126     return m_context-&gt;isEnabled(cap);
3127 }
3128 
<span class="line-modified">3129 GC3Dboolean WebGLRenderingContextBase::isFramebuffer(WebGLFramebuffer* framebuffer)</span>
3130 {
3131     if (!framebuffer || isContextLostOrPending())
3132         return 0;
3133 
3134     if (!framebuffer-&gt;hasEverBeenBound())
3135         return 0;
3136 
3137     return m_context-&gt;isFramebuffer(framebuffer-&gt;object());
3138 }
3139 
<span class="line-modified">3140 GC3Dboolean WebGLRenderingContextBase::isProgram(WebGLProgram* program)</span>
3141 {
3142     if (!program || isContextLostOrPending())
3143         return 0;
3144 
3145     return m_context-&gt;isProgram(program-&gt;object());
3146 }
3147 
<span class="line-modified">3148 GC3Dboolean WebGLRenderingContextBase::isRenderbuffer(WebGLRenderbuffer* renderbuffer)</span>
3149 {
3150     if (!renderbuffer || isContextLostOrPending())
3151         return 0;
3152 
3153     if (!renderbuffer-&gt;hasEverBeenBound())
3154         return 0;
3155 
3156     return m_context-&gt;isRenderbuffer(renderbuffer-&gt;object());
3157 }
3158 
<span class="line-modified">3159 GC3Dboolean WebGLRenderingContextBase::isShader(WebGLShader* shader)</span>
3160 {
3161     if (!shader || isContextLostOrPending())
3162         return 0;
3163 
3164     return m_context-&gt;isShader(shader-&gt;object());
3165 }
3166 
<span class="line-modified">3167 GC3Dboolean WebGLRenderingContextBase::isTexture(WebGLTexture* texture)</span>
3168 {
3169     if (!texture || isContextLostOrPending())
3170         return 0;
3171 
3172     if (!texture-&gt;hasEverBeenBound())
3173         return 0;
3174 
3175     return m_context-&gt;isTexture(texture-&gt;object());
3176 }
3177 
<span class="line-modified">3178 void WebGLRenderingContextBase::lineWidth(GC3Dfloat width)</span>
3179 {
3180     if (isContextLostOrPending())
3181         return;
3182     m_context-&gt;lineWidth(width);
3183 }
3184 
3185 void WebGLRenderingContextBase::linkProgram(WebGLProgram* program)
3186 {
3187     if (!linkProgramWithoutInvalidatingAttribLocations(program))
3188         return;
3189 
3190     program-&gt;increaseLinkCount();
3191 }
3192 
3193 bool WebGLRenderingContextBase::linkProgramWithoutInvalidatingAttribLocations(WebGLProgram* program)
3194 {
3195     if (isContextLostOrPending() || !validateWebGLObject(&quot;linkProgram&quot;, program))
3196         return false;
3197 
<span class="line-modified">3198     RefPtr&lt;WebGLShader&gt; vertexShader = program-&gt;getAttachedShader(GraphicsContext3D::VERTEX_SHADER);</span>
<span class="line-modified">3199     RefPtr&lt;WebGLShader&gt; fragmentShader = program-&gt;getAttachedShader(GraphicsContext3D::FRAGMENT_SHADER);</span>
3200     if (!vertexShader || !vertexShader-&gt;isValid() || !fragmentShader || !fragmentShader-&gt;isValid()) {
3201         program-&gt;setLinkStatus(false);
3202         return false;
3203     }
3204 
3205 #if !USE(ANGLE)
3206     if (!m_context-&gt;precisionsMatch(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))
3207         || !m_context-&gt;checkVaryingsPacking(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))) {
3208         program-&gt;setLinkStatus(false);
3209         return false;
3210     }
3211 #endif
3212 
3213     m_context-&gt;linkProgram(objectOrZero(program));
3214     return true;
3215 }
3216 
<span class="line-modified">3217 void WebGLRenderingContextBase::pixelStorei(GC3Denum pname, GC3Dint param)</span>
3218 {
3219     if (isContextLostOrPending())
3220         return;
3221     switch (pname) {
<span class="line-modified">3222     case GraphicsContext3D::UNPACK_FLIP_Y_WEBGL:</span>
3223         m_unpackFlipY = param;
3224         break;
<span class="line-modified">3225     case GraphicsContext3D::UNPACK_PREMULTIPLY_ALPHA_WEBGL:</span>
3226         m_unpackPremultiplyAlpha = param;
3227         break;
<span class="line-modified">3228     case GraphicsContext3D::UNPACK_COLORSPACE_CONVERSION_WEBGL:</span>
<span class="line-modified">3229         if (param == GraphicsContext3D::BROWSER_DEFAULT_WEBGL || param == GraphicsContext3D::NONE)</span>
<span class="line-modified">3230             m_unpackColorspaceConversion = static_cast&lt;GC3Denum&gt;(param);</span>
3231         else {
<span class="line-modified">3232             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for UNPACK_COLORSPACE_CONVERSION_WEBGL&quot;);</span>
3233             return;
3234         }
3235         break;
<span class="line-modified">3236     case GraphicsContext3D::PACK_ALIGNMENT:</span>
<span class="line-modified">3237     case GraphicsContext3D::UNPACK_ALIGNMENT:</span>
3238         if (param == 1 || param == 2 || param == 4 || param == 8) {
<span class="line-modified">3239             if (pname == GraphicsContext3D::PACK_ALIGNMENT)</span>
3240                 m_packAlignment = param;
<span class="line-modified">3241             else // GraphicsContext3D::UNPACK_ALIGNMENT:</span>
3242                 m_unpackAlignment = param;
3243             m_context-&gt;pixelStorei(pname, param);
3244         } else {
<span class="line-modified">3245             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for alignment&quot;);</span>
3246             return;
3247         }
3248         break;
3249     default:
<span class="line-modified">3250         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;pixelStorei&quot;, &quot;invalid parameter name&quot;);</span>
3251         return;
3252     }
3253 }
3254 
<span class="line-modified">3255 void WebGLRenderingContextBase::polygonOffset(GC3Dfloat factor, GC3Dfloat units)</span>
3256 {
3257     if (isContextLostOrPending())
3258         return;
3259     m_context-&gt;polygonOffset(factor, units);
3260 }
3261 
3262 enum class InternalFormatTheme {
3263     None,
3264     NormalizedFixedPoint,
3265     Packed,
3266     SignedNormalizedFixedPoint,
3267     FloatingPoint,
3268     SignedInteger,
3269     UnsignedInteger
3270 };
3271 
<span class="line-modified">3272 static InternalFormatTheme internalFormatTheme(GC3Denum internalFormat)</span>
3273 {
3274     switch (internalFormat) {
<span class="line-modified">3275     case GraphicsContext3D::RGB:</span>
<span class="line-modified">3276     case GraphicsContext3D::RGBA:</span>
<span class="line-modified">3277     case GraphicsContext3D::LUMINANCE_ALPHA:</span>
<span class="line-modified">3278     case GraphicsContext3D::LUMINANCE:</span>
<span class="line-modified">3279     case GraphicsContext3D::ALPHA:</span>
<span class="line-modified">3280     case GraphicsContext3D::R8:</span>
<span class="line-modified">3281     case GraphicsContext3D::RG8:</span>
<span class="line-modified">3282     case GraphicsContext3D::RGB8:</span>
<span class="line-modified">3283     case GraphicsContext3D::SRGB8:</span>
<span class="line-modified">3284     case GraphicsContext3D::RGBA8:</span>
<span class="line-modified">3285     case GraphicsContext3D::SRGB8_ALPHA8:</span>
<span class="line-modified">3286     case GraphicsContext3D::SRGB_ALPHA:</span>
3287         return InternalFormatTheme::NormalizedFixedPoint;
<span class="line-modified">3288     case GraphicsContext3D::RGB565:</span>
<span class="line-modified">3289     case GraphicsContext3D::RGB5_A1:</span>
<span class="line-modified">3290     case GraphicsContext3D::RGBA4:</span>
<span class="line-modified">3291     case GraphicsContext3D::RGB9_E5:</span>
<span class="line-modified">3292     case GraphicsContext3D::RGB10_A2:</span>
<span class="line-modified">3293     case GraphicsContext3D::R11F_G11F_B10F:</span>
<span class="line-modified">3294     case GraphicsContext3D::RGB10_A2UI:</span>
3295         return InternalFormatTheme::Packed;
<span class="line-modified">3296     case GraphicsContext3D::R8_SNORM:</span>
<span class="line-modified">3297     case GraphicsContext3D::RG8_SNORM:</span>
<span class="line-modified">3298     case GraphicsContext3D::RGB8_SNORM:</span>
<span class="line-modified">3299     case GraphicsContext3D::RGBA8_SNORM:</span>
3300         return InternalFormatTheme::SignedNormalizedFixedPoint;
<span class="line-modified">3301     case GraphicsContext3D::R16F:</span>
<span class="line-modified">3302     case GraphicsContext3D::R32F:</span>
<span class="line-modified">3303     case GraphicsContext3D::RG16F:</span>
<span class="line-modified">3304     case GraphicsContext3D::RG32F:</span>
<span class="line-modified">3305     case GraphicsContext3D::RGB16F:</span>
<span class="line-modified">3306     case GraphicsContext3D::RGB32F:</span>
<span class="line-modified">3307     case GraphicsContext3D::RGBA16F:</span>
<span class="line-modified">3308     case GraphicsContext3D::RGBA32F:</span>
3309         return InternalFormatTheme::FloatingPoint;
<span class="line-modified">3310     case GraphicsContext3D::R8I:</span>
<span class="line-modified">3311     case GraphicsContext3D::R16I:</span>
<span class="line-modified">3312     case GraphicsContext3D::R32I:</span>
<span class="line-modified">3313     case GraphicsContext3D::RG8I:</span>
<span class="line-modified">3314     case GraphicsContext3D::RG16I:</span>
<span class="line-modified">3315     case GraphicsContext3D::RG32I:</span>
<span class="line-modified">3316     case GraphicsContext3D::RGB8I:</span>
<span class="line-modified">3317     case GraphicsContext3D::RGB16I:</span>
<span class="line-modified">3318     case GraphicsContext3D::RGB32I:</span>
<span class="line-modified">3319     case GraphicsContext3D::RGBA8I:</span>
<span class="line-modified">3320     case GraphicsContext3D::RGBA16I:</span>
<span class="line-modified">3321     case GraphicsContext3D::RGBA32I:</span>
3322         return InternalFormatTheme::SignedInteger;
<span class="line-modified">3323     case GraphicsContext3D::R8UI:</span>
<span class="line-modified">3324     case GraphicsContext3D::R16UI:</span>
<span class="line-modified">3325     case GraphicsContext3D::R32UI:</span>
<span class="line-modified">3326     case GraphicsContext3D::RG8UI:</span>
<span class="line-modified">3327     case GraphicsContext3D::RG16UI:</span>
<span class="line-modified">3328     case GraphicsContext3D::RG32UI:</span>
<span class="line-modified">3329     case GraphicsContext3D::RGB8UI:</span>
<span class="line-modified">3330     case GraphicsContext3D::RGB16UI:</span>
<span class="line-modified">3331     case GraphicsContext3D::RGB32UI:</span>
<span class="line-modified">3332     case GraphicsContext3D::RGBA8UI:</span>
<span class="line-modified">3333     case GraphicsContext3D::RGBA16UI:</span>
<span class="line-modified">3334     case GraphicsContext3D::RGBA32UI:</span>
3335         return InternalFormatTheme::UnsignedInteger;
3336     default:
3337         return InternalFormatTheme::None;
3338     }
3339 }
3340 
<span class="line-modified">3341 static int numberOfComponentsForFormat(GC3Denum format)</span>
3342 {
3343     switch (format) {
<span class="line-modified">3344     case GraphicsContext3D::RED:</span>
<span class="line-modified">3345     case GraphicsContext3D::RED_INTEGER:</span>
3346         return 1;
<span class="line-modified">3347     case GraphicsContext3D::RG:</span>
<span class="line-modified">3348     case GraphicsContext3D::RG_INTEGER:</span>
3349         return 2;
<span class="line-modified">3350     case GraphicsContext3D::RGB:</span>
<span class="line-modified">3351     case GraphicsContext3D::RGB_INTEGER:</span>
3352         return 3;
<span class="line-modified">3353     case GraphicsContext3D::RGBA:</span>
<span class="line-modified">3354     case GraphicsContext3D::RGBA_INTEGER:</span>
3355         return 4;
3356     default:
3357         return 0;
3358     }
3359 }
3360 
<span class="line-modified">3361 static int numberOfComponentsForInternalFormat(GC3Denum internalFormat)</span>
3362 {
3363     switch (internalFormat) {
<span class="line-modified">3364     case GraphicsContext3D::LUMINANCE:</span>
<span class="line-modified">3365     case GraphicsContext3D::ALPHA:</span>
<span class="line-modified">3366     case GraphicsContext3D::R8:</span>
<span class="line-modified">3367     case GraphicsContext3D::R8_SNORM:</span>
<span class="line-modified">3368     case GraphicsContext3D::R16F:</span>
<span class="line-modified">3369     case GraphicsContext3D::R32F:</span>
<span class="line-modified">3370     case GraphicsContext3D::R8UI:</span>
<span class="line-modified">3371     case GraphicsContext3D::R8I:</span>
<span class="line-modified">3372     case GraphicsContext3D::R16UI:</span>
<span class="line-modified">3373     case GraphicsContext3D::R16I:</span>
<span class="line-modified">3374     case GraphicsContext3D::R32UI:</span>
<span class="line-modified">3375     case GraphicsContext3D::R32I:</span>
<span class="line-modified">3376     case GraphicsContext3D::DEPTH_COMPONENT16:</span>
<span class="line-modified">3377     case GraphicsContext3D::DEPTH_COMPONENT24:</span>
<span class="line-modified">3378     case GraphicsContext3D::DEPTH_COMPONENT32F:</span>
3379         return 1;
<span class="line-modified">3380     case GraphicsContext3D::RG8:</span>
<span class="line-modified">3381     case GraphicsContext3D::LUMINANCE_ALPHA:</span>
<span class="line-modified">3382     case GraphicsContext3D::RG8_SNORM:</span>
<span class="line-modified">3383     case GraphicsContext3D::RG16F:</span>
<span class="line-modified">3384     case GraphicsContext3D::RG32F:</span>
<span class="line-modified">3385     case GraphicsContext3D::RG8UI:</span>
<span class="line-modified">3386     case GraphicsContext3D::RG8I:</span>
<span class="line-modified">3387     case GraphicsContext3D::RG16UI:</span>
<span class="line-modified">3388     case GraphicsContext3D::RG16I:</span>
<span class="line-modified">3389     case GraphicsContext3D::RG32UI:</span>
<span class="line-modified">3390     case GraphicsContext3D::RG32I:</span>
<span class="line-modified">3391     case GraphicsContext3D::DEPTH24_STENCIL8:</span>
<span class="line-modified">3392     case GraphicsContext3D::DEPTH32F_STENCIL8:</span>
3393         return 2;
<span class="line-modified">3394     case GraphicsContext3D::RGB:</span>
<span class="line-modified">3395     case GraphicsContext3D::RGB8:</span>
<span class="line-modified">3396     case GraphicsContext3D::SRGB8:</span>
<span class="line-modified">3397     case GraphicsContext3D::RGB565:</span>
<span class="line-modified">3398     case GraphicsContext3D::RGB8_SNORM:</span>
<span class="line-modified">3399     case GraphicsContext3D::R11F_G11F_B10F:</span>
<span class="line-modified">3400     case GraphicsContext3D::RGB9_E5:</span>
<span class="line-modified">3401     case GraphicsContext3D::RGB16F:</span>
<span class="line-modified">3402     case GraphicsContext3D::RGB32F:</span>
<span class="line-modified">3403     case GraphicsContext3D::RGB8UI:</span>
<span class="line-modified">3404     case GraphicsContext3D::RGB8I:</span>
<span class="line-modified">3405     case GraphicsContext3D::RGB16UI:</span>
<span class="line-modified">3406     case GraphicsContext3D::RGB16I:</span>
<span class="line-modified">3407     case GraphicsContext3D::RGB32UI:</span>
<span class="line-modified">3408     case GraphicsContext3D::RGB32I:</span>
3409         return 3;
<span class="line-modified">3410     case GraphicsContext3D::RGBA:</span>
<span class="line-modified">3411     case GraphicsContext3D::RGBA8:</span>
<span class="line-modified">3412     case GraphicsContext3D::SRGB_ALPHA:</span>
<span class="line-modified">3413     case GraphicsContext3D::SRGB8_ALPHA8:</span>
<span class="line-modified">3414     case GraphicsContext3D::RGBA8_SNORM:</span>
<span class="line-modified">3415     case GraphicsContext3D::RGB5_A1:</span>
<span class="line-modified">3416     case GraphicsContext3D::RGBA4:</span>
<span class="line-modified">3417     case GraphicsContext3D::RGB10_A2:</span>
<span class="line-modified">3418     case GraphicsContext3D::RGBA16F:</span>
<span class="line-modified">3419     case GraphicsContext3D::RGBA32F:</span>
<span class="line-modified">3420     case GraphicsContext3D::RGBA8UI:</span>
<span class="line-modified">3421     case GraphicsContext3D::RGBA8I:</span>
<span class="line-modified">3422     case GraphicsContext3D::RGB10_A2UI:</span>
<span class="line-modified">3423     case GraphicsContext3D::RGBA16UI:</span>
<span class="line-modified">3424     case GraphicsContext3D::RGBA16I:</span>
<span class="line-modified">3425     case GraphicsContext3D::RGBA32UI:</span>
<span class="line-modified">3426     case GraphicsContext3D::RGBA32I:</span>
3427         return 4;
3428     default:
3429         return 0;
3430     }
3431 }
3432 
<span class="line-modified">3433 void WebGLRenderingContextBase::readPixels(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, ArrayBufferView&amp; pixels)</span>
3434 {
3435     if (isContextLostOrPending())
3436         return;
3437     // Due to WebGL&#39;s same-origin restrictions, it is not possible to
3438     // taint the origin using the WebGL API.
3439     ASSERT(canvasBase().originClean());
3440 
<span class="line-modified">3441     GC3Denum internalFormat = 0;</span>
3442     if (m_framebufferBinding) {
3443         const char* reason = &quot;framebuffer incomplete&quot;;
<span class="line-modified">3444         if (!m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {</span>
<span class="line-modified">3445             synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;readPixels&quot;, reason);</span>
3446             return;
3447         }
3448         // FIXME: readBuffer() should affect this
3449         internalFormat = m_framebufferBinding-&gt;getColorBufferFormat();
3450     } else {
3451         if (m_attributes.alpha)
<span class="line-modified">3452             internalFormat = GraphicsContext3D::RGBA8;</span>
3453         else
<span class="line-modified">3454             internalFormat = GraphicsContext3D::RGB8;</span>
3455     }
3456 
3457     if (!internalFormat) {
<span class="line-modified">3458         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);</span>
3459         return;
3460     }
3461 
3462     if (isWebGL1()) {
3463         switch (format) {
<span class="line-modified">3464         case GraphicsContext3D::ALPHA:</span>
<span class="line-modified">3465         case GraphicsContext3D::RGB:</span>
<span class="line-modified">3466         case GraphicsContext3D::RGBA:</span>
3467             break;
3468         default:
<span class="line-modified">3469             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid format&quot;);</span>
3470             return;
3471         }
3472         switch (type) {
<span class="line-modified">3473         case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="line-modified">3474         case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:</span>
<span class="line-modified">3475         case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="line-modified">3476         case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:</span>
3477             break;
<span class="line-modified">3478         case GraphicsContext3D::FLOAT:</span>
3479             if (!m_oesTextureFloat &amp;&amp; !m_oesTextureHalfFloat) {
<span class="line-modified">3480                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);</span>
3481                 return;
3482             }
3483             break;
3484         default:
<span class="line-modified">3485             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);</span>
3486             return;
3487         }
<span class="line-modified">3488         if (format != GraphicsContext3D::RGBA || (type != GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; type != GraphicsContext3D::FLOAT)) {</span>
<span class="line-modified">3489             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;format not RGBA or type not UNSIGNED_BYTE|FLOAT&quot;);</span>
3490             return;
3491         }
3492     }
3493 
3494     InternalFormatTheme internalFormatTheme = WebCore::internalFormatTheme(internalFormat);
3495     int internalFormatComponentCount = numberOfComponentsForInternalFormat(internalFormat);
3496     if (internalFormatTheme == InternalFormatTheme::None || !internalFormatComponentCount) {
<span class="line-modified">3497         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);</span>
3498         return;
3499     }
3500 
3501 #define CHECK_COMPONENT_COUNT \
3502     if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \
<span class="line-modified">3503         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
3504         return; \
3505     }
3506 
3507 #define INTERNAL_FORMAT_CHECK(typeMacro, pixelTypeMacro) \
<span class="line-modified">3508     if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3509         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
3510         return; \
3511     } \
<span class="line-modified">3512     if (format != GraphicsContext3D::RED &amp;&amp; format != GraphicsContext3D::RG &amp;&amp; format != GraphicsContext3D::RGB &amp;&amp; format != GraphicsContext3D::RGBA) { \</span>
<span class="line-modified">3513         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
3514         return; \
3515     } \
3516     CHECK_COMPONENT_COUNT
3517 
3518 #define INTERNAL_FORMAT_INTEGER_CHECK(typeMacro, pixelTypeMacro) \
<span class="line-modified">3519     if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3520         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
3521         return; \
3522     } \
<span class="line-modified">3523     if (format != GraphicsContext3D::RED_INTEGER &amp;&amp; format != GraphicsContext3D::RG_INTEGER &amp;&amp; format != GraphicsContext3D::RGB_INTEGER &amp;&amp; format != GraphicsContext3D::RGBA_INTEGER) { \</span>
<span class="line-modified">3524         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
3525         return; \
3526     } \
3527     CHECK_COMPONENT_COUNT
3528 
<span class="line-modified">3529 #define CASE_PACKED_INTERNAL_FORMAT_CHECK(internalFormatMacro, formatMacro, type0Macro, pixelType0Macro, type1Macro, pixelType1Macro) case GraphicsContext3D::internalFormatMacro: \</span>
<span class="line-modified">3530     if (!(type == GraphicsContext3D::type0Macro &amp;&amp; pixels.getType() == JSC::pixelType0Macro) \</span>
<span class="line-modified">3531         &amp;&amp; !(type == GraphicsContext3D::type1Macro &amp;&amp; pixels.getType() == JSC::pixelType1Macro)) { \</span>
<span class="line-modified">3532         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
3533         return; \
3534     } \
<span class="line-modified">3535     if (format != GraphicsContext3D::formatMacro) { \</span>
<span class="line-modified">3536         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Invalid format&quot;); \</span>
3537         return; \
3538     } \
3539     break;
3540 
3541     switch (internalFormatTheme) {
3542     case InternalFormatTheme::NormalizedFixedPoint:
<span class="line-modified">3543         if (type == GraphicsContext3D::FLOAT) {</span>
3544             INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);
3545         } else {
3546             INTERNAL_FORMAT_CHECK(UNSIGNED_BYTE, TypeUint8);
3547         }
3548         break;
3549     case InternalFormatTheme::SignedNormalizedFixedPoint:
3550         INTERNAL_FORMAT_CHECK(BYTE, TypeInt8);
3551         break;
3552     case InternalFormatTheme::FloatingPoint:
3553         INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);
3554         break;
3555     case InternalFormatTheme::SignedInteger:
3556         INTERNAL_FORMAT_INTEGER_CHECK(INT, TypeInt32);
3557         break;
3558     case InternalFormatTheme::UnsignedInteger:
3559         INTERNAL_FORMAT_INTEGER_CHECK(UNSIGNED_INT, TypeUint32);
3560         break;
3561     case InternalFormatTheme::Packed:
3562         switch (internalFormat) {
3563             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB565        , RGB         , UNSIGNED_SHORT_5_6_5        , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );
3564             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB5_A1       , RGBA        , UNSIGNED_SHORT_5_5_5_1      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );
3565             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGBA4         , RGBA        , UNSIGNED_SHORT_4_4_4_4      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );
3566             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB9_E5       , RGB         , UNSIGNED_INT_5_9_9_9_REV    , TypeUint32, UNSIGNED_INT_5_9_9_9_REV   , TypeUint32 );
3567             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2      , RGBA        , UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );
3568             CASE_PACKED_INTERNAL_FORMAT_CHECK(R11F_G11F_B10F, RGB         , UNSIGNED_INT_10F_11F_11F_REV, TypeUint32, FLOAT                      , TypeFloat32);
3569             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2UI    , RGBA_INTEGER, UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );
3570         }
3571         break;
3572     case InternalFormatTheme::None:
3573         ASSERT_NOT_REACHED();
3574     }
3575 #undef CHECK_COMPONENT_COUNT
3576 #undef INTERNAL_FORMAT_CHECK
3577 #undef INTERNAL_FORMAT_INTEGER_CHECK
3578 #undef CASE_PACKED_INTERNAL_FORMAT_CHECK
3579 
3580     // Calculate array size, taking into consideration of PACK_ALIGNMENT.
3581     unsigned totalBytesRequired = 0;
3582     unsigned padding = 0;
3583     if (!m_isRobustnessEXTSupported) {
<span class="line-modified">3584         GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_packAlignment, &amp;totalBytesRequired, &amp;padding);</span>
<span class="line-modified">3585         if (error != GraphicsContext3D::NO_ERROR) {</span>
3586             synthesizeGLError(error, &quot;readPixels&quot;, &quot;invalid dimensions&quot;);
3587             return;
3588         }
3589         if (pixels.byteLength() &lt; totalBytesRequired) {
<span class="line-modified">3590             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;ArrayBufferView not large enough for dimensions&quot;);</span>
3591             return;
3592         }
3593     }
3594 
3595     clearIfComposited();
3596     void* data = pixels.baseAddress();
3597 
3598     if (m_isRobustnessEXTSupported)
3599         m_context-&gt;getExtensions().readnPixelsEXT(x, y, width, height, format, type, pixels.byteLength(), data);
3600     else
3601         m_context-&gt;readPixels(x, y, width, height, format, type, data);
3602 }
3603 
3604 void WebGLRenderingContextBase::releaseShaderCompiler()
3605 {
3606     if (isContextLostOrPending())
3607         return;
3608     m_context-&gt;releaseShaderCompiler();
3609 }
3610 
<span class="line-modified">3611 void WebGLRenderingContextBase::sampleCoverage(GC3Dfloat value, GC3Dboolean invert)</span>
3612 {
3613     if (isContextLostOrPending())
3614         return;
3615     m_context-&gt;sampleCoverage(value, invert);
3616 }
3617 
<span class="line-modified">3618 void WebGLRenderingContextBase::scissor(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)</span>
3619 {
3620     if (isContextLostOrPending())
3621         return;
3622     if (!validateSize(&quot;scissor&quot;, width, height))
3623         return;
3624     m_context-&gt;scissor(x, y, width, height);
3625 }
3626 
3627 void WebGLRenderingContextBase::shaderSource(WebGLShader* shader, const String&amp; string)
3628 {
3629     if (isContextLostOrPending() || !validateWebGLObject(&quot;shaderSource&quot;, shader))
3630         return;



3631     String stringWithoutComments = StripComments(string).result();
3632     if (!validateString(&quot;shaderSource&quot;, stringWithoutComments))
3633         return;
<span class="line-removed">3634     shader-&gt;setSource(string);</span>
3635     m_context-&gt;shaderSource(objectOrZero(shader), stringWithoutComments);


3636 }
3637 
<span class="line-modified">3638 void WebGLRenderingContextBase::stencilFunc(GC3Denum func, GC3Dint ref, GC3Duint mask)</span>
3639 {
3640     if (isContextLostOrPending())
3641         return;
3642     if (!validateStencilFunc(&quot;stencilFunc&quot;, func))
3643         return;
3644     m_stencilFuncRef = ref;
3645     m_stencilFuncRefBack = ref;
3646     m_stencilFuncMask = mask;
3647     m_stencilFuncMaskBack = mask;
3648     m_context-&gt;stencilFunc(func, ref, mask);
3649 }
3650 
<span class="line-modified">3651 void WebGLRenderingContextBase::stencilFuncSeparate(GC3Denum face, GC3Denum func, GC3Dint ref, GC3Duint mask)</span>
3652 {
3653     if (isContextLostOrPending())
3654         return;
3655     if (!validateStencilFunc(&quot;stencilFuncSeparate&quot;, func))
3656         return;
3657     switch (face) {
<span class="line-modified">3658     case GraphicsContext3D::FRONT_AND_BACK:</span>
3659         m_stencilFuncRef = ref;
3660         m_stencilFuncRefBack = ref;
3661         m_stencilFuncMask = mask;
3662         m_stencilFuncMaskBack = mask;
3663         break;
<span class="line-modified">3664     case GraphicsContext3D::FRONT:</span>
3665         m_stencilFuncRef = ref;
3666         m_stencilFuncMask = mask;
3667         break;
<span class="line-modified">3668     case GraphicsContext3D::BACK:</span>
3669         m_stencilFuncRefBack = ref;
3670         m_stencilFuncMaskBack = mask;
3671         break;
3672     default:
<span class="line-modified">3673         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;stencilFuncSeparate&quot;, &quot;invalid face&quot;);</span>
3674         return;
3675     }
3676     m_context-&gt;stencilFuncSeparate(face, func, ref, mask);
3677 }
3678 
<span class="line-modified">3679 void WebGLRenderingContextBase::stencilMask(GC3Duint mask)</span>
3680 {
3681     if (isContextLostOrPending())
3682         return;
3683     m_stencilMask = mask;
3684     m_stencilMaskBack = mask;
3685     m_context-&gt;stencilMask(mask);
3686 }
3687 
<span class="line-modified">3688 void WebGLRenderingContextBase::stencilMaskSeparate(GC3Denum face, GC3Duint mask)</span>
3689 {
3690     if (isContextLostOrPending())
3691         return;
3692     switch (face) {
<span class="line-modified">3693     case GraphicsContext3D::FRONT_AND_BACK:</span>
3694         m_stencilMask = mask;
3695         m_stencilMaskBack = mask;
3696         break;
<span class="line-modified">3697     case GraphicsContext3D::FRONT:</span>
3698         m_stencilMask = mask;
3699         break;
<span class="line-modified">3700     case GraphicsContext3D::BACK:</span>
3701         m_stencilMaskBack = mask;
3702         break;
3703     default:
<span class="line-modified">3704         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;stencilMaskSeparate&quot;, &quot;invalid face&quot;);</span>
3705         return;
3706     }
3707     m_context-&gt;stencilMaskSeparate(face, mask);
3708 }
3709 
<span class="line-modified">3710 void WebGLRenderingContextBase::stencilOp(GC3Denum fail, GC3Denum zfail, GC3Denum zpass)</span>
3711 {
3712     if (isContextLostOrPending())
3713         return;
3714     m_context-&gt;stencilOp(fail, zfail, zpass);
3715 }
3716 
<span class="line-modified">3717 void WebGLRenderingContextBase::stencilOpSeparate(GC3Denum face, GC3Denum fail, GC3Denum zfail, GC3Denum zpass)</span>
3718 {
3719     if (isContextLostOrPending())
3720         return;
3721     m_context-&gt;stencilOpSeparate(face, fail, zfail, zpass);
3722 }
3723 
<span class="line-modified">3724 void WebGLRenderingContextBase::texImage2DBase(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels)</span>
3725 {
3726     // FIXME: For now we ignore any errors returned.
3727     auto tex = validateTextureBinding(&quot;texImage2D&quot;, target, true);
3728     ASSERT(validateTexFuncParameters(&quot;texImage2D&quot;, TexImage, target, level, internalFormat, width, height, border, format, type));
3729     ASSERT(tex);
3730     ASSERT(validateNPOTTextureLevel(width, height, level, &quot;texImage2D&quot;));
3731     if (!pixels) {
3732         if (!m_context-&gt;texImage2DResourceSafe(target, level, internalFormat, width, height, border, format, type, m_unpackAlignment))
3733             return;
3734     } else {
3735         ASSERT(validateSettableTexInternalFormat(&quot;texImage2D&quot;, internalFormat));
3736         m_context-&gt;moveErrorsToSyntheticErrorList();
3737         m_context-&gt;texImage2D(target, level, internalFormat, width, height,
3738                               border, format, type, pixels);
3739         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
3740             // The texImage2D function failed. Tell the WebGLTexture it doesn&#39;t have the data for this level.
3741             tex-&gt;markInvalid(target, level);
3742             return;
3743         }
3744     }
3745     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, type);
3746 }
3747 
<span class="line-modified">3748 void WebGLRenderingContextBase::texImage2DImpl(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Image* image, GraphicsContext3D::ImageHtmlDomSource domSource, bool flipY, bool premultiplyAlpha)</span>
3749 {
3750     Vector&lt;uint8_t&gt; data;
<span class="line-modified">3751     GraphicsContext3D::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContext3D::NONE);</span>
3752     if (!imageExtractor.extractSucceeded()) {
<span class="line-modified">3753         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
3754         return;
3755     }
<span class="line-modified">3756     GraphicsContext3D::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();</span>
<span class="line-modified">3757     GraphicsContext3D::AlphaOp alphaOp = imageExtractor.imageAlphaOp();</span>
3758     const void* imagePixelData = imageExtractor.imagePixelData();
3759 
3760     bool needConversion = true;
<span class="line-modified">3761     if (type == GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContext3D::DataFormatRGBA8 &amp;&amp; format == GraphicsContext3D::RGBA &amp;&amp; alphaOp == GraphicsContext3D::AlphaDoNothing &amp;&amp; !flipY)</span>
3762         needConversion = false;
3763     else {
3764         if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
<span class="line-modified">3765             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;packImage error&quot;);</span>
3766             return;
3767         }
3768     }
3769 
3770     if (m_unpackAlignment != 1)
<span class="line-modified">3771         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);</span>
3772     texImage2DBase(target, level, internalformat, image-&gt;width(), image-&gt;height(), 0, format, type, needConversion ? data.data() : imagePixelData);
3773     if (m_unpackAlignment != 1)
<span class="line-modified">3774         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
3775 }
3776 
<span class="line-modified">3777 bool WebGLRenderingContextBase::validateTexFunc(const char* functionName, TexFuncValidationFunctionType functionType, TexFuncValidationSourceType sourceType, GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, GC3Dint xoffset, GC3Dint yoffset)</span>
3778 {
3779     if (!validateTexFuncParameters(functionName, functionType, target, level, internalFormat, width, height, border, format, type))
3780         return false;
3781 
3782     auto texture = validateTextureBinding(functionName, target, true);
3783     if (!texture)
3784         return false;
3785 
3786     if (functionType != TexSubImage) {
3787         if (functionType == TexImage &amp;&amp; texture-&gt;immutable()) {
<span class="line-modified">3788             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;texStorage() called on this texture previously&quot;);</span>
3789             return false;
3790         }
3791         if (!validateNPOTTextureLevel(width, height, level, functionName))
3792             return false;
3793         // For SourceArrayBufferView, function validateTexFuncData() would handle whether to validate the SettableTexFormat
3794         // by checking if the ArrayBufferView is null or not.
3795         if (sourceType != SourceArrayBufferView) {
3796             if (!validateSettableTexInternalFormat(functionName, internalFormat))
3797                 return false;
3798         }
3799     } else {
3800         if (!validateSettableTexInternalFormat(functionName, internalFormat))
3801             return false;
3802         if (!validateSize(functionName, xoffset, yoffset))
3803             return false;
3804         // Before checking if it is in the range, check if overflow happens first.
3805         if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
<span class="line-modified">3806             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;bad dimensions&quot;);</span>
3807             return false;
3808         }
3809         if (xoffset + width &gt; texture-&gt;getWidth(target, level) || yoffset + height &gt; texture-&gt;getHeight(target, level)) {
<span class="line-modified">3810             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;dimensions out of range&quot;);</span>
3811             return false;
3812         }
3813         if (texture-&gt;getInternalFormat(target, level) != internalFormat || (isWebGL1() &amp;&amp; texture-&gt;getType(target, level) != type)) {
<span class="line-modified">3814             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;type and format do not match texture&quot;);</span>
3815             return false;
3816         }
3817     }
3818 
3819     return true;
3820 }
3821 
<span class="line-modified">3822 void WebGLRenderingContextBase::texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)</span>
3823 {
3824     if (isContextLostOrPending() || !validateTexFuncData(&quot;texImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullAllowed)
3825         || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceArrayBufferView, target, level, internalFormat, width, height, border, format, type, 0, 0))
3826         return;
3827     void* data = pixels ? pixels-&gt;baseAddress() : 0;
3828     Vector&lt;uint8_t&gt; tempData;
3829     bool changeUnpackAlignment = false;
3830     if (data &amp;&amp; (m_unpackFlipY || m_unpackPremultiplyAlpha)) {
3831         if (!m_context-&gt;extractTextureData(width, height, format, type,
3832                                            m_unpackAlignment,
3833                                            m_unpackFlipY, m_unpackPremultiplyAlpha,
3834                                            data,
3835                                            tempData))
3836             return;
3837         data = tempData.data();
3838         changeUnpackAlignment = true;
3839     }
3840     if (changeUnpackAlignment)
<span class="line-modified">3841         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);</span>
3842     texImage2DBase(target, level, internalFormat, width, height, border, format, type, data);
3843     if (changeUnpackAlignment)
<span class="line-modified">3844         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
3845 }
3846 
<span class="line-modified">3847 void WebGLRenderingContextBase::texSubImage2DImpl(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Image* image, GraphicsContext3D::ImageHtmlDomSource domSource, bool flipY, bool premultiplyAlpha)</span>
3848 {
3849     Vector&lt;uint8_t&gt; data;
<span class="line-modified">3850     GraphicsContext3D::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContext3D::NONE);</span>
3851     if (!imageExtractor.extractSucceeded()) {
<span class="line-modified">3852         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image&quot;);</span>
3853         return;
3854     }
<span class="line-modified">3855     GraphicsContext3D::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();</span>
<span class="line-modified">3856     GraphicsContext3D::AlphaOp alphaOp = imageExtractor.imageAlphaOp();</span>
3857     const void* imagePixelData = imageExtractor.imagePixelData();
3858 
3859     bool needConversion = true;
<span class="line-modified">3860     if (type == GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContext3D::DataFormatRGBA8 &amp;&amp; format == GraphicsContext3D::RGBA &amp;&amp; alphaOp == GraphicsContext3D::AlphaDoNothing &amp;&amp; !flipY)</span>
3861         needConversion = false;
3862     else {
3863         if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
<span class="line-modified">3864             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
3865             return;
3866         }
3867     }
3868 
3869     if (m_unpackAlignment != 1)
<span class="line-modified">3870         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);</span>
3871 
3872     texSubImage2DBase(target, level, xoffset, yoffset, image-&gt;width(), image-&gt;height(), format, format, type, needConversion ? data.data() : imagePixelData);
3873 
3874     if (m_unpackAlignment != 1)
<span class="line-modified">3875         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
3876 }
3877 
<span class="line-modified">3878 void WebGLRenderingContextBase::texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)</span>
3879 {
3880     if (isContextLostOrPending())
3881         return;
3882 
3883     auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3884     if (!texture)
3885         return;
3886 
<span class="line-modified">3887     GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
3888     if (!internalFormat) {
<span class="line-modified">3889         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
3890         return;
3891     }
3892 
3893     if (!validateTexFuncData(&quot;texSubImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullNotAllowed))
3894         return;
3895 
3896     if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceArrayBufferView, target, level, internalFormat, width, height, 0, format, type, xoffset, yoffset))
3897         return;
3898 
3899     void* data = pixels-&gt;baseAddress();
3900     Vector&lt;uint8_t&gt; tempData;
3901     bool changeUnpackAlignment = false;
3902     if (data &amp;&amp; (m_unpackFlipY || m_unpackPremultiplyAlpha)) {
3903         if (!m_context-&gt;extractTextureData(width, height, format, type, m_unpackAlignment, m_unpackFlipY, m_unpackPremultiplyAlpha, data, tempData))
3904             return;
3905         data = tempData.data();
3906         changeUnpackAlignment = true;
3907     }
3908     if (changeUnpackAlignment)
<span class="line-modified">3909         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);</span>
3910 
3911     texSubImage2DBase(target, level, xoffset, yoffset, width, height, internalFormat, format, type, data);
3912 
3913     if (changeUnpackAlignment)
<span class="line-modified">3914         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
3915 }
3916 
<span class="line-modified">3917 ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt;&amp;&amp; source)</span>
3918 {
3919     if (!source) {
<span class="line-modified">3920         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;source is null&quot;);</span>
3921         return { };
3922     }
3923 
3924     if (isContextLostOrPending())
3925         return { };
3926 
3927     auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
3928         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3929         if (!texture)
3930             return { };
3931 
<span class="line-modified">3932         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
3933         if (!internalFormat) {
<span class="line-modified">3934             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
3935             return { };
3936         }
3937 
3938         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageBitmap, target, level, internalFormat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, xoffset, yoffset))
3939             return { };
3940 
3941         ImageBuffer* buffer = bitmap-&gt;buffer();
3942         if (!buffer)
3943             return { };
3944 
<span class="line-modified">3945         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(ImageBuffer::fastCopyImageMode());</span>
3946         if (image)
<span class="line-modified">3947             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
3948         return { };
3949     }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
3950         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3951         if (!texture)
3952             return { };
3953 
<span class="line-modified">3954         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
3955         if (!internalFormat) {
<span class="line-modified">3956             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
3957             return { };
3958         }
3959 
3960         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageData, target, level, internalFormat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, xoffset, yoffset))
3961             return { };
3962 
3963         Vector&lt;uint8_t&gt; data;
3964         bool needConversion = true;
3965         // The data from ImageData is always of format RGBA8.
3966         // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
<span class="line-modified">3967         if (format == GraphicsContext3D::RGBA &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; !m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha)</span>
3968             needConversion = false;
3969         else {
3970             if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
<span class="line-modified">3971                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image data&quot;);</span>
3972                 return { };
3973             }
3974         }
3975         if (m_unpackAlignment != 1)
<span class="line-modified">3976             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);</span>
3977 
3978         texSubImage2DBase(target, level, xoffset, yoffset, pixels-&gt;width(), pixels-&gt;height(), format, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
3979 
3980         if (m_unpackAlignment != 1)
<span class="line-modified">3981             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
3982 
3983         return { };
3984     } , [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
3985         if (isContextLostOrPending())
3986             return { };
3987         auto validationResult = validateHTMLImageElement(&quot;texSubImage2D&quot;, image.get());
3988         if (validationResult.hasException())
3989             return validationResult.releaseException();
3990         if (!validationResult.returnValue())
3991             return { };
3992 
3993         RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
3994         if (!imageForRender)
3995             return { };
3996 
<span class="line-modified">3997         if (imageForRender-&gt;isSVGImage())</span>
3998             imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
3999 
4000         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4001         if (!texture)
4002             return { };
4003 
<span class="line-modified">4004         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
4005         if (!internalFormat) {
<span class="line-modified">4006             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
4007             return { };
4008         }
4009 
4010         if (!imageForRender || !validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLImageElement, target, level, internalFormat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, xoffset, yoffset))
4011             return { };
4012 
<span class="line-modified">4013         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, imageForRender.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4014         return { };
4015     }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
4016         if (isContextLostOrPending())
4017             return { };
4018         auto validationResult = validateHTMLCanvasElement(&quot;texSubImage2D&quot;, canvas.get());
4019         if (validationResult.hasException())
4020             return validationResult.releaseException();
4021         if (!validationResult.returnValue())
4022             return { };
4023 
4024         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4025         if (!texture)
4026             return { };
4027 
<span class="line-modified">4028         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
4029         if (!internalFormat) {
<span class="line-modified">4030             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
4031             return { };
4032         }
4033 
4034         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLCanvasElement, target, level, internalFormat, canvas-&gt;width(), canvas-&gt;height(), 0, format, type, xoffset, yoffset))
4035             return { };
4036 
4037         RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
4038         if (imageData)
4039             texSubImage2D(target, level, xoffset, yoffset, format, type, TexImageSource(imageData.get()));
4040         else
<span class="line-modified">4041             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, canvas-&gt;copiedImage(), GraphicsContext3D::HtmlDomCanvas, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4042         return { };
4043     }
4044 #if ENABLE(VIDEO)
4045     , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
4046         if (isContextLostOrPending())
4047             return { };
4048         auto validationResult = validateHTMLVideoElement(&quot;texSubImage2D&quot;, video.get());
4049         if (validationResult.hasException())
4050             return validationResult.releaseException();
4051         if (!validationResult.returnValue())
4052             return { };
4053 
4054         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4055         if (!texture)
4056             return { };
4057 
<span class="line-modified">4058         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
4059         if (!internalFormat) {
<span class="line-modified">4060             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
4061             return { };
4062         }
4063 
4064         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLVideoElement, target, level, internalFormat, video-&gt;videoWidth(), video-&gt;videoHeight(), 0, format, type, xoffset, yoffset))
4065             return { };
4066 
<span class="line-modified">4067         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), ImageBuffer::fastCopyImageMode());</span>
4068         if (!image)
4069             return { };
<span class="line-modified">4070         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContext3D::HtmlDomVideo, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4071         return { };
4072     }
4073 #endif
4074     );
4075 
4076     return WTF::visit(visitor, source.value());
4077 }
4078 
<span class="line-modified">4079 bool WebGLRenderingContextBase::validateArrayBufferType(const char* functionName, GC3Denum type, Optional&lt;JSC::TypedArrayType&gt; arrayType)</span>
4080 {
4081 #define TYPE_VALIDATION_CASE(arrayTypeMacro) if (arrayType &amp;&amp; arrayType.value() != JSC::arrayTypeMacro) { \
<span class="line-modified">4082             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;ArrayBufferView not &quot; #arrayTypeMacro); \</span>
4083             return false; \
4084         } \
4085         break;
4086 
4087     switch (type) {
<span class="line-modified">4088     case GraphicsContext3D::UNSIGNED_BYTE:</span>
4089         TYPE_VALIDATION_CASE(TypeUint8);
<span class="line-modified">4090     case GraphicsContext3D::BYTE:</span>
4091         TYPE_VALIDATION_CASE(TypeInt8);
<span class="line-modified">4092     case GraphicsContext3D::UNSIGNED_SHORT:</span>
<span class="line-modified">4093     case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:</span>
<span class="line-modified">4094     case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="line-modified">4095     case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:</span>
4096         TYPE_VALIDATION_CASE(TypeUint16);
<span class="line-modified">4097     case GraphicsContext3D::SHORT:</span>
4098         TYPE_VALIDATION_CASE(TypeInt16);
<span class="line-modified">4099     case GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV:</span>
<span class="line-modified">4100     case GraphicsContext3D::UNSIGNED_INT_10F_11F_11F_REV:</span>
<span class="line-modified">4101     case GraphicsContext3D::UNSIGNED_INT_5_9_9_9_REV:</span>
<span class="line-modified">4102     case GraphicsContext3D::UNSIGNED_INT_24_8:</span>
<span class="line-modified">4103     case GraphicsContext3D::UNSIGNED_INT:</span>
4104         TYPE_VALIDATION_CASE(TypeUint32);
<span class="line-modified">4105     case GraphicsContext3D::INT:</span>
4106         TYPE_VALIDATION_CASE(TypeInt32);
<span class="line-modified">4107     case GraphicsContext3D::FLOAT: // OES_texture_float</span>
4108         TYPE_VALIDATION_CASE(TypeFloat32);
<span class="line-modified">4109     case GraphicsContext3D::HALF_FLOAT_OES: // OES_texture_half_float</span>
<span class="line-modified">4110     case GraphicsContext3D::HALF_FLOAT:</span>
<span class="line-modified">4111     case GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV:</span>
<span class="line-modified">4112         // As per the specification, ArrayBufferView should be null when</span>
<span class="line-removed">4113         // OES_texture_half_float is enabled.</span>
<span class="line-removed">4114         if (arrayType) {</span>
<span class="line-removed">4115             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;type HALF_FLOAT_OES but ArrayBufferView is not NULL&quot;);</span>
<span class="line-removed">4116             return false;</span>
<span class="line-removed">4117         }</span>
<span class="line-removed">4118         break;</span>
4119     default:
4120         ASSERT_NOT_REACHED();
4121         return false;
4122     }
4123 #undef TYPE_VALIDATION_CASE
4124     return true;
4125 }
4126 
<span class="line-modified">4127 bool WebGLRenderingContextBase::validateTexFuncData(const char* functionName, GC3Dint level, GC3Dsizei width, GC3Dsizei height, GC3Denum internalFormat, GC3Denum format, GC3Denum type, ArrayBufferView* pixels, NullDisposition disposition)</span>
4128 {
4129     if (!pixels) {
4130         if (disposition == NullAllowed)
4131             return true;
<span class="line-modified">4132         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no pixels&quot;);</span>
4133         return false;
4134     }
4135 
4136     if (!validateTexFuncFormatAndType(functionName, internalFormat, format, type, level))
4137         return false;
4138     if (!validateSettableTexInternalFormat(functionName, internalFormat))
4139         return false;
4140     if (!validateArrayBufferType(functionName, type, pixels ? Optional&lt;JSC::TypedArrayType&gt;(pixels-&gt;getType()) : WTF::nullopt))
4141         return false;
4142 
4143     unsigned totalBytesRequired;
<span class="line-modified">4144     GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;totalBytesRequired, nullptr);</span>
<span class="line-modified">4145     if (error != GraphicsContext3D::NO_ERROR) {</span>
4146         synthesizeGLError(error, functionName, &quot;invalid texture dimensions&quot;);
4147         return false;
4148     }
4149     if (pixels-&gt;byteLength() &lt; totalBytesRequired) {
<span class="line-modified">4150         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;ArrayBufferView not big enough for request&quot;);</span>
4151         return false;
4152     }
4153     return true;
4154 }
4155 
4156 bool WebGLRenderingContextBase::validateTexFuncParameters(const char* functionName,
4157     TexFuncValidationFunctionType functionType,
<span class="line-modified">4158     GC3Denum target, GC3Dint level,</span>
<span class="line-modified">4159     GC3Denum internalformat,</span>
<span class="line-modified">4160     GC3Dsizei width, GC3Dsizei height, GC3Dint border,</span>
<span class="line-modified">4161     GC3Denum format, GC3Denum type)</span>
4162 {
4163     // We absolutely have to validate the format and type combination.
4164     // The texImage2D entry points taking HTMLImage, etc. will produce
4165     // temporary data based on this combination, so it must be legal.
4166     if (!validateTexFuncFormatAndType(functionName, internalformat, format, type, level) || !validateTexFuncLevel(functionName, target, level))
4167         return false;
4168 
4169     if (width &lt; 0 || height &lt; 0) {
<span class="line-modified">4170         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);</span>
4171         return false;
4172     }
4173 
<span class="line-modified">4174     GC3Dint maxTextureSizeForLevel = pow(2.0, m_maxTextureLevel - 1 - level);</span>
4175     switch (target) {
<span class="line-modified">4176     case GraphicsContext3D::TEXTURE_2D:</span>
4177         if (width &gt; maxTextureSizeForLevel || height &gt; maxTextureSizeForLevel) {
<span class="line-modified">4178             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height out of range&quot;);</span>
4179             return false;
4180         }
4181         break;
<span class="line-modified">4182     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="line-modified">4183     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="line-modified">4184     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="line-modified">4185     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="line-modified">4186     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="line-modified">4187     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
4188         if (functionType != TexSubImage &amp;&amp; width != height) {
<span class="line-modified">4189             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width != height for cube map&quot;);</span>
4190             return false;
4191         }
4192         // No need to check height here. For texImage width == height.
4193         // For texSubImage that will be checked when checking yoffset + height is in range.
4194         if (width &gt; maxTextureSizeForLevel) {
<span class="line-modified">4195             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height out of range for cube map&quot;);</span>
4196             return false;
4197         }
4198         break;
4199     default:
<span class="line-modified">4200         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
4201         return false;
4202     }
4203 
4204     if (border) {
<span class="line-modified">4205         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;border != 0&quot;);</span>
4206         return false;
4207     }
4208 
4209     return true;
4210 }
4211 
<span class="line-modified">4212 bool WebGLRenderingContextBase::validateTexFuncFormatAndType(const char* functionName, GC3Denum internalFormat, GC3Denum format, GC3Denum type, GC3Dint level)</span>
4213 {
4214     switch (format) {
<span class="line-modified">4215     case GraphicsContext3D::ALPHA:</span>
<span class="line-modified">4216     case GraphicsContext3D::LUMINANCE:</span>
<span class="line-modified">4217     case GraphicsContext3D::LUMINANCE_ALPHA:</span>
<span class="line-modified">4218     case GraphicsContext3D::RGB:</span>
<span class="line-modified">4219     case GraphicsContext3D::RGBA:</span>
4220         break;
<span class="line-modified">4221     case GraphicsContext3D::DEPTH_STENCIL:</span>
<span class="line-modified">4222     case GraphicsContext3D::DEPTH_COMPONENT:</span>
4223         if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
<span class="line-modified">4224             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;depth texture formats not enabled&quot;);</span>
4225             return false;
4226         }
4227         if (level &gt; 0) {
<span class="line-modified">4228             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;level must be 0 for depth formats&quot;);</span>
4229             return false;
4230         }
4231         break;
<span class="line-modified">4232     case Extensions3D::SRGB_EXT:</span>
<span class="line-modified">4233     case Extensions3D::SRGB_ALPHA_EXT:</span>
4234         if (!m_extsRGB) {
<span class="line-modified">4235             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;sRGB texture formats not enabled&quot;);</span>
4236             return false;
4237         }
4238         break;
4239     default:
4240 #if ENABLE(WEBGL2)
4241         if (!isWebGL1()) {
4242             switch (format) {
<span class="line-modified">4243             case GraphicsContext3D::RED:</span>
<span class="line-modified">4244             case GraphicsContext3D::RED_INTEGER:</span>
<span class="line-modified">4245             case GraphicsContext3D::RG:</span>
<span class="line-modified">4246             case GraphicsContext3D::RG_INTEGER:</span>
<span class="line-modified">4247             case GraphicsContext3D::RGB_INTEGER:</span>
<span class="line-modified">4248             case GraphicsContext3D::RGBA_INTEGER:</span>
4249                 break;
4250             default:
<span class="line-modified">4251                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);</span>
4252                 return false;
4253             }
4254         } else
4255 #endif
4256         {
<span class="line-modified">4257             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);</span>
4258             return false;
4259         }
4260     }
4261 
4262     switch (type) {
<span class="line-modified">4263     case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="line-modified">4264     case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:</span>
<span class="line-modified">4265     case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="line-modified">4266     case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:</span>
4267         break;
<span class="line-modified">4268     case GraphicsContext3D::FLOAT:</span>
4269         if (!m_oesTextureFloat &amp;&amp; isWebGL1()) {
<span class="line-modified">4270             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4271             return false;
4272         }
4273         break;
<span class="line-modified">4274     case GraphicsContext3D::HALF_FLOAT:</span>
<span class="line-modified">4275     case GraphicsContext3D::HALF_FLOAT_OES:</span>
4276         if (!m_oesTextureHalfFloat &amp;&amp; isWebGL1()) {
<span class="line-modified">4277             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4278             return false;
4279         }
4280         break;
<span class="line-modified">4281     case GraphicsContext3D::UNSIGNED_INT:</span>
<span class="line-modified">4282     case GraphicsContext3D::UNSIGNED_INT_24_8:</span>
<span class="line-modified">4283     case GraphicsContext3D::UNSIGNED_SHORT:</span>
4284         if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
<span class="line-modified">4285             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4286             return false;
4287         }
4288         break;
4289     default:
4290 #if ENABLE(WEBGL2)
4291         if (!isWebGL1()) {
4292             switch (type) {
<span class="line-modified">4293             case GraphicsContext3D::BYTE:</span>
<span class="line-modified">4294             case GraphicsContext3D::SHORT:</span>
<span class="line-modified">4295             case GraphicsContext3D::INT:</span>
<span class="line-modified">4296             case GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV:</span>
<span class="line-modified">4297             case GraphicsContext3D::UNSIGNED_INT_10F_11F_11F_REV:</span>
<span class="line-modified">4298             case GraphicsContext3D::UNSIGNED_INT_5_9_9_9_REV:</span>
<span class="line-modified">4299             case GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV:</span>
4300                 break;
4301             default:
<span class="line-modified">4302                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4303                 return false;
4304             }
4305         } else
4306 #endif
4307         {
<span class="line-modified">4308             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4309             return false;
4310         }
4311     }
4312 
4313     // Verify that the combination of internalformat, format, and type is supported.
<span class="line-modified">4314 #define INTERNAL_FORMAT_CASE(internalFormatMacro, formatMacro, type0, type1, type2, type3, type4) case GraphicsContext3D::internalFormatMacro: \</span>
<span class="line-modified">4315     if (format != GraphicsContext3D::formatMacro) { \</span>
<span class="line-modified">4316         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid format for internalformat&quot;); \</span>
4317         return false; \
4318     } \
4319     if (type != type0 &amp;&amp; type != type1 &amp;&amp; type != type2 &amp;&amp; type != type3 &amp;&amp; type != type4) { \
<span class="line-modified">4320         if (type != GraphicsContext3D::HALF_FLOAT_OES || (type0 != GraphicsContext3D::HALF_FLOAT &amp;&amp; type1 != GraphicsContext3D::HALF_FLOAT &amp;&amp; type2 != GraphicsContext3D::HALF_FLOAT &amp;&amp; type3 != GraphicsContext3D::HALF_FLOAT)) { \</span>
<span class="line-modified">4321             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid type for internalformat&quot;); \</span>
4322             return false; \
4323         } \
4324     } \
4325     break;
4326     switch (internalFormat) {
<span class="line-modified">4327     INTERNAL_FORMAT_CASE(RGB               , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_5_6_5  , GraphicsContext3D::HALF_FLOAT                  , GraphicsContext3D::FLOAT     , 0                       );</span>
<span class="line-modified">4328     INTERNAL_FORMAT_CASE(RGBA              , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4, GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1      , GraphicsContext3D::HALF_FLOAT, GraphicsContext3D::FLOAT);</span>
<span class="line-modified">4329     INTERNAL_FORMAT_CASE(LUMINANCE_ALPHA   , LUMINANCE_ALPHA, GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4330     INTERNAL_FORMAT_CASE(LUMINANCE         , LUMINANCE      , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4331     INTERNAL_FORMAT_CASE(ALPHA             , ALPHA          , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4332     INTERNAL_FORMAT_CASE(R8                , RED            , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4333     INTERNAL_FORMAT_CASE(R8_SNORM          , RED            , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4334     INTERNAL_FORMAT_CASE(R16F              , RED            , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4335     INTERNAL_FORMAT_CASE(R32F              , RED            , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4336     INTERNAL_FORMAT_CASE(R8UI              , RED_INTEGER    , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4337     INTERNAL_FORMAT_CASE(R8I               , RED_INTEGER    , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4338     INTERNAL_FORMAT_CASE(R16UI             , RED_INTEGER    , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4339     INTERNAL_FORMAT_CASE(R16I              , RED_INTEGER    , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4340     INTERNAL_FORMAT_CASE(R32UI             , RED_INTEGER    , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4341     INTERNAL_FORMAT_CASE(R32I              , RED_INTEGER    , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4342     INTERNAL_FORMAT_CASE(RG8               , RG             , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4343     INTERNAL_FORMAT_CASE(RG8_SNORM         , RG             , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4344     INTERNAL_FORMAT_CASE(RG16F             , RG             , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4345     INTERNAL_FORMAT_CASE(RG32F             , RG             , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4346     INTERNAL_FORMAT_CASE(RG8UI             , RG_INTEGER     , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4347     INTERNAL_FORMAT_CASE(RG8I              , RG_INTEGER     , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4348     INTERNAL_FORMAT_CASE(RG16UI            , RG_INTEGER     , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4349     INTERNAL_FORMAT_CASE(RG16I             , RG_INTEGER     , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4350     INTERNAL_FORMAT_CASE(RG32UI            , RG_INTEGER     , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4351     INTERNAL_FORMAT_CASE(RG32I             , RG_INTEGER     , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4352     INTERNAL_FORMAT_CASE(RGB8              , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4353     INTERNAL_FORMAT_CASE(SRGB8             , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4354     INTERNAL_FORMAT_CASE(RGB565            , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_5_6_5  , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4355     INTERNAL_FORMAT_CASE(RGB8_SNORM        , RGB            , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4356     INTERNAL_FORMAT_CASE(R11F_G11F_B10F    , RGB            , GraphicsContext3D::UNSIGNED_INT_10F_11F_11F_REV  , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4357     INTERNAL_FORMAT_CASE(RGB9_E5           , RGB            , GraphicsContext3D::UNSIGNED_INT_5_9_9_9_REV      , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4358     INTERNAL_FORMAT_CASE(RGB16F            , RGB            , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4359     INTERNAL_FORMAT_CASE(RGB32F            , RGB            , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4360     INTERNAL_FORMAT_CASE(RGB8UI            , RGB_INTEGER    , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4361     INTERNAL_FORMAT_CASE(RGB8I             , RGB_INTEGER    , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4362     INTERNAL_FORMAT_CASE(RGB16UI           , RGB_INTEGER    , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4363     INTERNAL_FORMAT_CASE(RGB16I            , RGB_INTEGER    , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4364     INTERNAL_FORMAT_CASE(RGB32UI           , RGB_INTEGER    , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4365     INTERNAL_FORMAT_CASE(RGB32I            , RGB_INTEGER    , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4366     INTERNAL_FORMAT_CASE(RGBA8             , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4367     INTERNAL_FORMAT_CASE(SRGB8_ALPHA8      , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4368     INTERNAL_FORMAT_CASE(RGBA8_SNORM       , RGBA           , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4369     INTERNAL_FORMAT_CASE(RGB5_A1           , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1, GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV , 0                            , 0                       );</span>
<span class="line-modified">4370     INTERNAL_FORMAT_CASE(RGBA4             , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4, 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4371     INTERNAL_FORMAT_CASE(RGB10_A2          , RGBA           , GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4372     INTERNAL_FORMAT_CASE(RGBA16F           , RGBA           , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4373     INTERNAL_FORMAT_CASE(RGBA32F           , RGBA           , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4374     INTERNAL_FORMAT_CASE(RGBA8UI           , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4375     INTERNAL_FORMAT_CASE(RGBA8I            , RGBA_INTEGER   , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4376     INTERNAL_FORMAT_CASE(RGB10_A2UI        , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4377     INTERNAL_FORMAT_CASE(RGBA16UI          , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4378     INTERNAL_FORMAT_CASE(RGBA16I           , RGBA_INTEGER   , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4379     INTERNAL_FORMAT_CASE(RGBA32I           , RGBA_INTEGER   , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4380     INTERNAL_FORMAT_CASE(RGBA32UI          , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4381     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT   , DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_SHORT                , GraphicsContext3D::UNSIGNED_INT          , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4382     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT16 , DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_SHORT                , GraphicsContext3D::UNSIGNED_INT          , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4383     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT24 , DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4384     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT32F, DEPTH_COMPONENT, GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4385     INTERNAL_FORMAT_CASE(DEPTH_STENCIL     , DEPTH_STENCIL  , GraphicsContext3D::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4386     INTERNAL_FORMAT_CASE(DEPTH24_STENCIL8  , DEPTH_STENCIL  , GraphicsContext3D::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4387     INTERNAL_FORMAT_CASE(DEPTH32F_STENCIL8 , DEPTH_STENCIL  , GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV, 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4388     case Extensions3D::SRGB_EXT:</span>
4389         if (format != internalFormat) {
<span class="line-modified">4390             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);</span>
4391             return false;
4392         }
<span class="line-modified">4393         if (type != GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; type != GraphicsContext3D::UNSIGNED_SHORT_5_6_5 &amp;&amp; type != GraphicsContext3D::FLOAT &amp;&amp; type != GraphicsContext3D::HALF_FLOAT_OES &amp;&amp; type != GraphicsContext3D::HALF_FLOAT) {</span>
<span class="line-modified">4394             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);</span>
4395             return false;
4396         }
4397         break;
<span class="line-modified">4398     case Extensions3D::SRGB_ALPHA_EXT:</span>
4399         if (format != internalFormat) {
<span class="line-modified">4400             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);</span>
4401             return false;
4402         }
<span class="line-modified">4403         if (type != GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; type != GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4 &amp;&amp; type != GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1 &amp;&amp; type != GraphicsContext3D::FLOAT &amp;&amp; type != GraphicsContext3D::HALF_FLOAT_OES &amp;&amp; type != GraphicsContext3D::HALF_FLOAT) {</span>
<span class="line-modified">4404             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);</span>
4405             return false;
4406         }
4407         break;
4408     default:
<span class="line-modified">4409         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;Unknown internal format&quot;);</span>
4410         return false;
4411     }
4412 #undef INTERNAL_FORMAT_CASE
4413 
4414     return true;
4415 }
4416 
<span class="line-modified">4417 void WebGLRenderingContextBase::texSubImage2DBase(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum internalFormat, GC3Denum format, GC3Denum type, const void* pixels)</span>
4418 {
4419     ASSERT(!isContextLost());
4420     ASSERT(validateTexFuncParameters(&quot;texSubImage2D&quot;, TexSubImage, target, level, internalFormat, width, height, 0, format, type));
4421     ASSERT(validateSize(&quot;texSubImage2D&quot;, xoffset, yoffset));
4422     ASSERT(validateSettableTexInternalFormat(&quot;texSubImage2D&quot;, internalFormat));
4423     auto tex = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4424     if (!tex) {
4425         ASSERT_NOT_REACHED();
4426         return;
4427     }
4428     ASSERT((xoffset + width) &gt;= 0);
4429     ASSERT((yoffset + height) &gt;= 0);
4430     ASSERT(tex-&gt;getWidth(target, level) &gt;= (xoffset + width));
4431     ASSERT(tex-&gt;getHeight(target, level) &gt;= (yoffset + height));
4432     ASSERT_UNUSED(internalFormat, tex-&gt;getInternalFormat(target, level) == internalFormat);
4433     m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
4434 }
4435 
<span class="line-modified">4436 void WebGLRenderingContextBase::copyTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Dint border)</span>
4437 {
4438     if (isContextLostOrPending())
4439         return;
<span class="line-modified">4440     if (!validateTexFuncParameters(&quot;copyTexImage2D&quot;, CopyTexImage, target, level, internalFormat, width, height, border, internalFormat, GraphicsContext3D::UNSIGNED_BYTE))</span>
4441         return;
4442     if (!validateSettableTexInternalFormat(&quot;copyTexImage2D&quot;, internalFormat))
4443         return;
4444     auto tex = validateTextureBinding(&quot;copyTexImage2D&quot;, target, true);
4445     if (!tex)
4446         return;
4447     if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
<span class="line-modified">4448         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;copyTexImage2D&quot;, &quot;framebuffer is incompatible format&quot;);</span>
4449         return;
4450     }
4451     if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
<span class="line-modified">4452         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexImage2D&quot;, &quot;level &gt; 0 not power of 2&quot;);</span>
4453         return;
4454     }
4455     const char* reason = &quot;framebuffer incomplete&quot;;
<span class="line-modified">4456     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {</span>
<span class="line-modified">4457         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexImage2D&quot;, reason);</span>
4458         return;
4459     }
4460     clearIfComposited();
4461 
<span class="line-modified">4462     GC3Dint clippedX, clippedY;</span>
<span class="line-modified">4463     GC3Dsizei clippedWidth, clippedHeight;</span>
4464     if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
4465         m_context-&gt;texImage2DResourceSafe(target, level, internalFormat, width, height, border,
<span class="line-modified">4466             internalFormat, GraphicsContext3D::UNSIGNED_BYTE, m_unpackAlignment);</span>
4467         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0) {
4468             m_context-&gt;copyTexSubImage2D(target, level, clippedX - x, clippedY - y,
4469                 clippedX, clippedY, clippedWidth, clippedHeight);
4470         }
4471     } else
4472         m_context-&gt;copyTexImage2D(target, level, internalFormat, x, y, width, height, border);
4473 
4474     // FIXME: if the framebuffer is not complete, none of the below should be executed.
<span class="line-modified">4475     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, GraphicsContext3D::UNSIGNED_BYTE);</span>
4476 }
4477 
<span class="line-modified">4478 static bool isRGBFormat(GC3Denum internalFormat)</span>
4479 {
<span class="line-modified">4480     return internalFormat == GraphicsContext3D::RGB</span>
<span class="line-modified">4481         || internalFormat == GraphicsContext3D::RGBA</span>
<span class="line-modified">4482         || internalFormat == GraphicsContext3D::RGB8</span>
<span class="line-modified">4483         || internalFormat == GraphicsContext3D::RGBA8;</span>
4484 }
4485 
<span class="line-modified">4486 ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt; source)</span>
4487 {
4488     if (!source) {
<span class="line-modified">4489         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;source is null&quot;);</span>
4490         return { };
4491     }
4492 
4493     auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
4494         if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageBitmap, target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, 0, 0))
4495             return { };
4496 
4497         ImageBuffer* buffer = bitmap-&gt;buffer();
4498         if (!buffer)
4499             return { };
4500 
4501         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4502         // If possible, copy from the bitmap directly to the texture
4503         // via the GPU, without a read-back to system memory.
4504         //
4505         // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
4506         // ImageBuffer::copyToPlatformTexture implementations are fully functional.
4507         if (texture
<span class="line-modified">4508             &amp;&amp; (format == GraphicsContext3D::RGB || format == GraphicsContext3D::RGBA)</span>
<span class="line-modified">4509             &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE) {</span>
4510             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4511             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4512                 if (buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4513                     texture-&gt;setLevelInfo(target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), type);
4514                     return { };
4515                 }
4516             }
4517         }
4518 
4519         // Normal pure SW path.
<span class="line-modified">4520         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(ImageBuffer::fastCopyImageMode());</span>
4521         if (image)
<span class="line-modified">4522             texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4523         return { };
4524     }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
4525         if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageData, target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, 0, 0))
4526             return { };
4527         Vector&lt;uint8_t&gt; data;
4528         bool needConversion = true;
4529         // The data from ImageData is always of format RGBA8.
4530         // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
<span class="line-modified">4531         if (!m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha &amp;&amp; format == GraphicsContext3D::RGBA &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE)</span>
4532             needConversion = false;
4533         else {
4534             if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
<span class="line-modified">4535                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
4536                 return { };
4537             }
4538         }
4539         if (m_unpackAlignment != 1)
<span class="line-modified">4540             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);</span>
4541         texImage2DBase(target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
4542         if (m_unpackAlignment != 1)
<span class="line-modified">4543             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
4544         return { };
4545     }, [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
4546         if (isContextLostOrPending())
4547             return { };
4548         auto validationResult = validateHTMLImageElement(&quot;texImage2D&quot;, image.get());
4549         if (validationResult.hasException())
4550             return validationResult.releaseException();
4551         if (!validationResult.returnValue())
4552             return { };
4553 
4554         RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
4555         if (!imageForRender)
4556             return { };
4557 
<span class="line-modified">4558         if (imageForRender-&gt;isSVGImage())</span>
4559             imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
4560 
4561         if (!imageForRender || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLImageElement, target, level, internalformat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, 0, 0))
4562             return { };
4563 
<span class="line-modified">4564         texImage2DImpl(target, level, internalformat, format, type, imageForRender.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4565         return { };
4566     }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
4567         if (isContextLostOrPending())
4568             return { };
4569         auto validationResult = validateHTMLCanvasElement(&quot;texImage2D&quot;, canvas.get());
4570         if (validationResult.hasException())
4571             return validationResult.releaseException();
4572         if (!validationResult.returnValue())
4573             return { };
4574         if (!validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLCanvasElement, target, level, internalformat, canvas-&gt;width(), canvas-&gt;height(), 0, format, type, 0, 0))
4575             return { };
4576 
4577         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4578         // If possible, copy from the canvas element directly to the texture
4579         // via the GPU, without a read-back to system memory.
4580         //
4581         // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
4582         // ImageBuffer::copyToPlatformTexture implementations are fully functional.
4583         if (texture
<span class="line-modified">4584             &amp;&amp; (format == GraphicsContext3D::RGB || format == GraphicsContext3D::RGBA)</span>
<span class="line-modified">4585             &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE) {</span>
4586             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4587             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4588                 ImageBuffer* buffer = canvas-&gt;buffer();
4589                 if (buffer &amp;&amp; buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4590                     texture-&gt;setLevelInfo(target, level, internalformat, canvas-&gt;width(), canvas-&gt;height(), type);
4591                     return { };
4592                 }
4593             }
4594         }
4595 
4596         RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
4597         if (imageData)
4598             texImage2D(target, level, internalformat, format, type, TexImageSource(imageData.get()));
4599         else
<span class="line-modified">4600             texImage2DImpl(target, level, internalformat, format, type, canvas-&gt;copiedImage(), GraphicsContext3D::HtmlDomCanvas, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4601         return { };
4602     }
4603 #if ENABLE(VIDEO)
4604     , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
4605         if (isContextLostOrPending())
4606             return { };
4607         auto validationResult = validateHTMLVideoElement(&quot;texImage2D&quot;, video.get());
4608         if (validationResult.hasException())
4609             return validationResult.releaseException();
4610         if (!validationResult.returnValue())
4611             return { };
4612         if (!validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLVideoElement, target, level, internalformat, video-&gt;videoWidth(), video-&gt;videoHeight(), 0, format, type, 0, 0))
4613             return { };
4614 
4615         // Go through the fast path doing a GPU-GPU textures copy without a readback to system memory if possible.
4616         // Otherwise, it will fall back to the normal SW path.
4617         // FIXME: The current restrictions require that format shoud be RGB or RGBA,
4618         // type should be UNSIGNED_BYTE and level should be 0. It may be lifted in the future.
4619         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
<span class="line-modified">4620         if (GraphicsContext3D::TEXTURE_2D == target &amp;&amp; texture</span>
<span class="line-modified">4621             &amp;&amp; (format == GraphicsContext3D::RGB || format == GraphicsContext3D::RGBA)</span>
<span class="line-modified">4622             &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE</span>
4623             &amp;&amp; !level) {
4624             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4625             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4626                 if (video-&gt;copyVideoTextureToPlatformTexture(m_context.get(), texture-&gt;object(), target, level, internalformat, format, type, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4627                     texture-&gt;setLevelInfo(target, level, internalformat, video-&gt;videoWidth(), video-&gt;videoHeight(), type);
4628                     return { };
4629                 }
4630             }
4631         }
4632 
4633         // Normal pure SW path.
<span class="line-modified">4634         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), ImageBuffer::fastCopyImageMode());</span>
4635         if (!image)
4636             return { };
<span class="line-modified">4637         texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContext3D::HtmlDomVideo, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4638         return { };
4639     }
4640 #endif
4641     );
4642 
4643     return WTF::visit(visitor, source.value());
4644 }
4645 
4646 RefPtr&lt;Image&gt; WebGLRenderingContextBase::drawImageIntoBuffer(Image&amp; image, int width, int height, int deviceScaleFactor)
4647 {
4648     IntSize size(width, height);
4649     size.scale(deviceScaleFactor);
4650     ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
4651     if (!buf) {
<span class="line-modified">4652         synthesizeGLError(GraphicsContext3D::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);</span>
4653         return nullptr;
4654     }
4655 
4656     FloatRect srcRect(FloatPoint(), image.size());
4657     FloatRect destRect(FloatPoint(), size);
4658     buf-&gt;context().drawImage(image, destRect, srcRect);
<span class="line-modified">4659     return buf-&gt;copyImage(ImageBuffer::fastCopyImageMode());</span>
4660 }
4661 
4662 #if ENABLE(VIDEO)
4663 
4664 RefPtr&lt;Image&gt; WebGLRenderingContextBase::videoFrameToImage(HTMLVideoElement* video, BackingStoreCopy backingStoreCopy)
4665 {
4666     IntSize size(video-&gt;videoWidth(), video-&gt;videoHeight());
4667     ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
4668     if (!buf) {
<span class="line-modified">4669         synthesizeGLError(GraphicsContext3D::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);</span>
4670         return nullptr;
4671     }
4672     FloatRect destRect(0, 0, size.width(), size.height());
4673     // FIXME: Turn this into a GPU-GPU texture copy instead of CPU readback.
4674     video-&gt;paintCurrentFrameInContext(buf-&gt;context(), destRect);
4675     return buf-&gt;copyImage(backingStoreCopy);
4676 }
4677 
4678 #endif
4679 
<span class="line-modified">4680 void WebGLRenderingContextBase::texParameter(GC3Denum target, GC3Denum pname, GC3Dfloat paramf, GC3Dint parami, bool isFloat)</span>
4681 {
4682     if (isContextLostOrPending())
4683         return;
4684     auto tex = validateTextureBinding(&quot;texParameter&quot;, target, false);
4685     if (!tex)
4686         return;
4687     switch (pname) {
<span class="line-modified">4688     case GraphicsContext3D::TEXTURE_MIN_FILTER:</span>
<span class="line-modified">4689     case GraphicsContext3D::TEXTURE_MAG_FILTER:</span>
4690         break;
<span class="line-modified">4691     case GraphicsContext3D::TEXTURE_WRAP_S:</span>
<span class="line-modified">4692     case GraphicsContext3D::TEXTURE_WRAP_T:</span>
<span class="line-modified">4693         if ((isFloat &amp;&amp; paramf != GraphicsContext3D::CLAMP_TO_EDGE &amp;&amp; paramf != GraphicsContext3D::MIRRORED_REPEAT &amp;&amp; paramf != GraphicsContext3D::REPEAT)</span>
<span class="line-modified">4694             || (!isFloat &amp;&amp; parami != GraphicsContext3D::CLAMP_TO_EDGE &amp;&amp; parami != GraphicsContext3D::MIRRORED_REPEAT &amp;&amp; parami != GraphicsContext3D::REPEAT)) {</span>
<span class="line-modified">4695             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter&quot;);</span>
4696             return;
4697         }
4698         break;
<span class="line-modified">4699     case Extensions3D::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
4700         if (!m_extTextureFilterAnisotropic) {
<span class="line-modified">4701             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter, EXT_texture_filter_anisotropic not enabled&quot;);</span>
4702             return;
4703         }
4704         break;
4705     default:
<span class="line-modified">4706         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter name&quot;);</span>
4707         return;
4708     }
4709     if (isFloat) {
4710         tex-&gt;setParameterf(pname, paramf);
4711         m_context-&gt;texParameterf(target, pname, paramf);
4712     } else {
4713         tex-&gt;setParameteri(pname, parami);
4714         m_context-&gt;texParameteri(target, pname, parami);
4715     }
4716 }
4717 
<span class="line-modified">4718 void WebGLRenderingContextBase::texParameterf(GC3Denum target, GC3Denum pname, GC3Dfloat param)</span>
4719 {
4720     texParameter(target, pname, param, 0, true);
4721 }
4722 
<span class="line-modified">4723 void WebGLRenderingContextBase::texParameteri(GC3Denum target, GC3Denum pname, GC3Dint param)</span>
4724 {
4725     texParameter(target, pname, 0, param, false);
4726 }
4727 
<span class="line-modified">4728 void WebGLRenderingContextBase::uniform1f(const WebGLUniformLocation* location, GC3Dfloat x)</span>
4729 {
4730     if (isContextLostOrPending() || !location)
4731         return;
4732 
4733     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4734         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform1f&quot;, &quot;location not for current program&quot;);</span>
4735         return;
4736     }
4737 
4738     m_context-&gt;uniform1f(location-&gt;location(), x);
4739 }
4740 
<span class="line-modified">4741 void WebGLRenderingContextBase::uniform2f(const WebGLUniformLocation* location, GC3Dfloat x, GC3Dfloat y)</span>
4742 {
4743     if (isContextLostOrPending() || !location)
4744         return;
4745 
4746     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4747         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform2f&quot;, &quot;location not for current program&quot;);</span>
4748         return;
4749     }
4750 
4751     m_context-&gt;uniform2f(location-&gt;location(), x, y);
4752 }
4753 
<span class="line-modified">4754 void WebGLRenderingContextBase::uniform3f(const WebGLUniformLocation* location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z)</span>
4755 {
4756     if (isContextLostOrPending() || !location)
4757         return;
4758 
4759     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4760         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform3f&quot;, &quot;location not for current program&quot;);</span>
4761         return;
4762     }
4763 
4764     m_context-&gt;uniform3f(location-&gt;location(), x, y, z);
4765 }
4766 
<span class="line-modified">4767 void WebGLRenderingContextBase::uniform4f(const WebGLUniformLocation* location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w)</span>
4768 {
4769     if (isContextLostOrPending() || !location)
4770         return;
4771 
4772     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4773         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform4f&quot;, &quot;location not for current program&quot;);</span>
4774         return;
4775     }
4776 
4777     m_context-&gt;uniform4f(location-&gt;location(), x, y, z, w);
4778 }
4779 
<span class="line-modified">4780 void WebGLRenderingContextBase::uniform1i(const WebGLUniformLocation* location, GC3Dint x)</span>
4781 {
4782     if (isContextLostOrPending() || !location)
4783         return;
4784 
4785     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4786         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform1i&quot;, &quot;location not for current program&quot;);</span>
4787         return;
4788     }
4789 
<span class="line-modified">4790     if ((location-&gt;type() == GraphicsContext3D::SAMPLER_2D || location-&gt;type() == GraphicsContext3D::SAMPLER_CUBE) &amp;&amp; x &gt;= (int)m_textureUnits.size()) {</span>
<span class="line-modified">4791         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;uniform1i&quot;, &quot;invalid texture unit&quot;);</span>
4792         return;
4793     }
4794 
4795     m_context-&gt;uniform1i(location-&gt;location(), x);
4796 }
4797 
<span class="line-modified">4798 void WebGLRenderingContextBase::uniform2i(const WebGLUniformLocation* location, GC3Dint x, GC3Dint y)</span>
4799 {
4800     if (isContextLostOrPending() || !location)
4801         return;
4802 
4803     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4804         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform2i&quot;, &quot;location not for current program&quot;);</span>
4805         return;
4806     }
4807 
4808     m_context-&gt;uniform2i(location-&gt;location(), x, y);
4809 }
4810 
<span class="line-modified">4811 void WebGLRenderingContextBase::uniform3i(const WebGLUniformLocation* location, GC3Dint x, GC3Dint y, GC3Dint z)</span>
4812 {
4813     if (isContextLostOrPending() || !location)
4814         return;
4815 
4816     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4817         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform3i&quot;, &quot;location not for current program&quot;);</span>
4818         return;
4819     }
4820 
4821     m_context-&gt;uniform3i(location-&gt;location(), x, y, z);
4822 }
4823 
<span class="line-modified">4824 void WebGLRenderingContextBase::uniform4i(const WebGLUniformLocation* location, GC3Dint x, GC3Dint y, GC3Dint z, GC3Dint w)</span>
4825 {
4826     if (isContextLostOrPending() || !location)
4827         return;
4828 
4829     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4830         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform4i&quot;, &quot;location not for current program&quot;);</span>
4831         return;
4832     }
4833 
4834     m_context-&gt;uniform4i(location-&gt;location(), x, y, z, w);
4835 }
4836 
4837 void WebGLRenderingContextBase::uniform1fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4838 {
4839     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform1fv&quot;, location, v, 1))
4840         return;
4841 
4842     m_context-&gt;uniform1fv(location-&gt;location(), v.length(), v.data());
4843 }
4844 
4845 void WebGLRenderingContextBase::uniform2fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4846 {
4847     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform2fv&quot;, location, v, 2))
4848         return;
4849 
4850     m_context-&gt;uniform2fv(location-&gt;location(), v.length() / 2, v.data());
</pre>
<hr />
<pre>
4857 
4858     m_context-&gt;uniform3fv(location-&gt;location(), v.length() / 3, v.data());
4859 }
4860 
4861 void WebGLRenderingContextBase::uniform4fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4862 {
4863     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform4fv&quot;, location, v, 4))
4864         return;
4865 
4866     m_context-&gt;uniform4fv(location-&gt;location(), v.length() / 4, v.data());
4867 }
4868 
4869 void WebGLRenderingContextBase::uniform1iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4870 {
4871     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform1iv&quot;, location, v, 1))
4872         return;
4873 
4874     auto data = v.data();
4875     auto length = v.length();
4876 
<span class="line-modified">4877     if (location-&gt;type() == GraphicsContext3D::SAMPLER_2D || location-&gt;type() == GraphicsContext3D::SAMPLER_CUBE) {</span>
4878         for (auto i = 0; i &lt; length; ++i) {
4879             if (data[i] &gt;= static_cast&lt;int&gt;(m_textureUnits.size())) {
4880                 LOG(WebGL, &quot;Texture unit size=%zu, v[%d]=%d. Location type = %04X.&quot;, m_textureUnits.size(), i, data[i], location-&gt;type());
<span class="line-modified">4881                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;uniform1iv&quot;, &quot;invalid texture unit&quot;);</span>
4882                 return;
4883             }
4884         }
4885     }
4886 
4887     m_context-&gt;uniform1iv(location-&gt;location(), length, data);
4888 }
4889 
4890 void WebGLRenderingContextBase::uniform2iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4891 {
4892     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform2iv&quot;, location, v, 2))
4893         return;
4894 
4895     m_context-&gt;uniform2iv(location-&gt;location(), v.length() / 2, v.data());
4896 }
4897 
4898 void WebGLRenderingContextBase::uniform3iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4899 {
4900     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform3iv&quot;, location, v, 3))
4901         return;
4902 
4903     m_context-&gt;uniform3iv(location-&gt;location(), v.length() / 3, v.data());
4904 }
4905 
4906 void WebGLRenderingContextBase::uniform4iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4907 {
4908     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform4iv&quot;, location, v, 4))
4909         return;
4910 
4911     m_context-&gt;uniform4iv(location-&gt;location(), v.length() / 4, v.data());
4912 }
4913 
<span class="line-modified">4914 void WebGLRenderingContextBase::uniformMatrix2fv(const WebGLUniformLocation* location, GC3Dboolean transpose, Float32List&amp;&amp; v)</span>
4915 {
4916     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix2fv&quot;, location, transpose, v, 4))
4917         return;
4918     m_context-&gt;uniformMatrix2fv(location-&gt;location(), v.length() / 4, transpose, v.data());
4919 }
4920 
<span class="line-modified">4921 void WebGLRenderingContextBase::uniformMatrix3fv(const WebGLUniformLocation* location, GC3Dboolean transpose, Float32List&amp;&amp; v)</span>
4922 {
4923     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix3fv&quot;, location, transpose, v, 9))
4924         return;
4925     m_context-&gt;uniformMatrix3fv(location-&gt;location(), v.length() / 9, transpose, v.data());
4926 }
4927 
<span class="line-modified">4928 void WebGLRenderingContextBase::uniformMatrix4fv(const WebGLUniformLocation* location, GC3Dboolean transpose, Float32List&amp;&amp; v)</span>
4929 {
4930     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix4fv&quot;, location, transpose, v, 16))
4931         return;
4932     m_context-&gt;uniformMatrix4fv(location-&gt;location(), v.length() / 16, transpose, v.data());
4933 }
4934 
4935 void WebGLRenderingContextBase::useProgram(WebGLProgram* program)
4936 {
4937     bool deleted;
4938     if (!checkObjectToBeBound(&quot;useProgram&quot;, program, deleted))
4939         return;
4940     if (deleted)
4941         program = 0;
4942     if (program &amp;&amp; !program-&gt;getLinkStatus()) {
<span class="line-modified">4943         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;useProgram&quot;, &quot;program not valid&quot;);</span>
4944         return;
4945     }
4946     if (m_currentProgram != program) {
4947         if (m_currentProgram)
<span class="line-modified">4948             m_currentProgram-&gt;onDetached(graphicsContext3D());</span>
4949         m_currentProgram = program;
4950         m_context-&gt;useProgram(objectOrZero(program));
4951         if (program)
4952             program-&gt;onAttached();
4953     }
4954 }
4955 
4956 void WebGLRenderingContextBase::validateProgram(WebGLProgram* program)
4957 {
4958     if (isContextLostOrPending() || !validateWebGLObject(&quot;validateProgram&quot;, program))
4959         return;
4960     m_context-&gt;validateProgram(objectOrZero(program));
4961 }
4962 
<span class="line-modified">4963 void WebGLRenderingContextBase::vertexAttrib1f(GC3Duint index, GC3Dfloat v0)</span>
4964 {
4965     vertexAttribfImpl(&quot;vertexAttrib1f&quot;, index, 1, v0, 0.0f, 0.0f, 1.0f);
4966 }
4967 
<span class="line-modified">4968 void WebGLRenderingContextBase::vertexAttrib2f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1)</span>
4969 {
4970     vertexAttribfImpl(&quot;vertexAttrib2f&quot;, index, 2, v0, v1, 0.0f, 1.0f);
4971 }
4972 
<span class="line-modified">4973 void WebGLRenderingContextBase::vertexAttrib3f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2)</span>
4974 {
4975     vertexAttribfImpl(&quot;vertexAttrib3f&quot;, index, 3, v0, v1, v2, 1.0f);
4976 }
4977 
<span class="line-modified">4978 void WebGLRenderingContextBase::vertexAttrib4f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2, GC3Dfloat v3)</span>
4979 {
4980     vertexAttribfImpl(&quot;vertexAttrib4f&quot;, index, 4, v0, v1, v2, v3);
4981 }
4982 
<span class="line-modified">4983 void WebGLRenderingContextBase::vertexAttrib1fv(GC3Duint index, Float32List&amp;&amp; v)</span>
4984 {
4985     vertexAttribfvImpl(&quot;vertexAttrib1fv&quot;, index, WTFMove(v), 1);
4986 }
4987 
<span class="line-modified">4988 void WebGLRenderingContextBase::vertexAttrib2fv(GC3Duint index, Float32List&amp;&amp; v)</span>
4989 {
4990     vertexAttribfvImpl(&quot;vertexAttrib2fv&quot;, index, WTFMove(v), 2);
4991 }
4992 
<span class="line-modified">4993 void WebGLRenderingContextBase::vertexAttrib3fv(GC3Duint index, Float32List&amp;&amp; v)</span>
4994 {
4995     vertexAttribfvImpl(&quot;vertexAttrib3fv&quot;, index, WTFMove(v), 3);
4996 }
4997 
<span class="line-modified">4998 void WebGLRenderingContextBase::vertexAttrib4fv(GC3Duint index, Float32List&amp;&amp; v)</span>
4999 {
5000     vertexAttribfvImpl(&quot;vertexAttrib4fv&quot;, index, WTFMove(v), 4);
5001 }
5002 
<span class="line-modified">5003 void WebGLRenderingContextBase::vertexAttribPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dboolean normalized, GC3Dsizei stride, long long offset)</span>
5004 {
5005     if (isContextLostOrPending())
5006         return;
5007     switch (type) {
<span class="line-modified">5008     case GraphicsContext3D::BYTE:</span>
<span class="line-modified">5009     case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="line-modified">5010     case GraphicsContext3D::SHORT:</span>
<span class="line-modified">5011     case GraphicsContext3D::UNSIGNED_SHORT:</span>
<span class="line-modified">5012     case GraphicsContext3D::FLOAT:</span>
5013         break;
5014     default:
<span class="line-modified">5015         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);</span>
5016         return;
5017     }
5018     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">5019         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;index out of range&quot;);</span>
5020         return;
5021     }
5022     if (size &lt; 1 || size &gt; 4) {
<span class="line-modified">5023         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad size&quot;);</span>
5024         return;
5025     }
5026     if (stride &lt; 0 || stride &gt; 255) {
<span class="line-modified">5027         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad stride&quot;);</span>
5028         return;
5029     }
5030     if (offset &lt; 0 || offset &gt; std::numeric_limits&lt;int32_t&gt;::max()) {
<span class="line-modified">5031         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad offset&quot;);</span>
5032         return;
5033     }
5034     if (!m_boundArrayBuffer &amp;&amp; offset) {
<span class="line-modified">5035         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;no bound ARRAY_BUFFER&quot;);</span>
5036         return;
5037     }
5038     // Determine the number of elements the bound buffer can hold, given the offset, size, type and stride
5039     auto typeSize = sizeInBytes(type);
5040     if (!typeSize) {
<span class="line-modified">5041         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);</span>
5042         return;
5043     }
<span class="line-modified">5044     if ((stride % typeSize) || (static_cast&lt;GC3Dintptr&gt;(offset) % typeSize)) {</span>
<span class="line-modified">5045         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;stride or offset not valid for type&quot;);</span>
5046         return;
5047     }
<span class="line-modified">5048     GC3Dsizei bytesPerElement = size * typeSize;</span>
5049 
<span class="line-modified">5050     m_boundVertexArrayObject-&gt;setVertexAttribState(index, bytesPerElement, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset), m_boundArrayBuffer.get());</span>
<span class="line-modified">5051     m_context-&gt;vertexAttribPointer(index, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset));</span>
5052 }
5053 
<span class="line-modified">5054 void WebGLRenderingContextBase::viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)</span>
5055 {
5056     if (isContextLostOrPending())
5057         return;
5058     if (!validateSize(&quot;viewport&quot;, width, height))
5059         return;
5060     m_context-&gt;viewport(x, y, width, height);
5061 }
5062 
5063 void WebGLRenderingContextBase::forceLostContext(WebGLRenderingContextBase::LostContextMode mode)
5064 {
5065     if (isContextLostOrPending()) {
<span class="line-modified">5066         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;loseContext&quot;, &quot;context already lost&quot;);</span>
5067         return;
5068     }
5069 
5070     m_contextGroup-&gt;loseContextGroup(mode);
5071 }
5072 
5073 void WebGLRenderingContextBase::loseContextImpl(WebGLRenderingContextBase::LostContextMode mode)
5074 {
5075     if (isContextLost())
5076         return;
5077 
5078     m_contextLost = true;
5079     m_contextLostMode = mode;
5080 
5081     if (mode == RealLostContext) {
5082         // Inform the embedder that a lost context was received. In response, the embedder might
5083         // decide to take action such as asking the user for permission to use WebGL again.
5084         auto* canvas = htmlCanvas();
5085         if (canvas) {
5086             if (RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame())
5087                 frame-&gt;loader().client().didLoseWebGLContext(m_context-&gt;getExtensions().getGraphicsResetStatusARB());
5088         }
5089     }
5090 
5091     detachAndRemoveAllObjects();
5092 
5093     // There is no direct way to clear errors from a GL implementation and
5094     // looping until getError() becomes NO_ERROR might cause an infinite loop if
5095     // the driver or context implementation had a bug. So, loop a reasonably
5096     // large number of times to clear any existing errors.
5097     for (int i = 0; i &lt; 100; ++i) {
<span class="line-modified">5098         if (m_context-&gt;getError() == GraphicsContext3D::NO_ERROR)</span>
5099             break;
5100     }
5101     ConsoleDisplayPreference display = (mode == RealLostContext) ? DisplayInConsole: DontDisplayInConsole;
<span class="line-modified">5102     synthesizeGLError(GraphicsContext3D::CONTEXT_LOST_WEBGL, &quot;loseContext&quot;, &quot;context lost&quot;, display);</span>
5103 
5104     // Don&#39;t allow restoration unless the context lost event has both been
5105     // dispatched and its default behavior prevented.
5106     m_restoreAllowed = false;
5107 
5108     // Always defer the dispatch of the context lost event, to implement
5109     // the spec behavior of queueing a task.
5110     m_dispatchContextLostEventTimer.startOneShot(0_s);
5111 }
5112 
5113 void WebGLRenderingContextBase::forceRestoreContext()
5114 {
5115     if (!isContextLostOrPending()) {
<span class="line-modified">5116         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context not lost&quot;);</span>
5117         return;
5118     }
5119 
5120     if (!m_restoreAllowed) {
5121         if (m_contextLostMode == SyntheticLostContext)
<span class="line-modified">5122             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context restoration not allowed&quot;);</span>
5123         return;
5124     }
5125 
5126     if (!m_restoreTimer.isActive())
5127         m_restoreTimer.startOneShot(0_s);
5128 }
5129 
5130 PlatformLayer* WebGLRenderingContextBase::platformLayer() const
5131 {
5132     return (!isContextLost() &amp;&amp; !m_isPendingPolicyResolution) ? m_context-&gt;platformLayer() : 0;
5133 }
5134 
5135 void WebGLRenderingContextBase::removeSharedObject(WebGLSharedObject&amp; object)
5136 {
5137     if (m_isPendingPolicyResolution)
5138         return;
5139 
5140     m_contextGroup-&gt;removeObject(object);
5141 }
5142 
</pre>
<hr />
<pre>
5169 void WebGLRenderingContextBase::detachAndRemoveAllObjects()
5170 {
5171     if (m_isPendingPolicyResolution)
5172         return;
5173 
5174     while (m_contextObjects.size() &gt; 0) {
5175         HashSet&lt;WebGLContextObject*&gt;::iterator it = m_contextObjects.begin();
5176         (*it)-&gt;detachContext();
5177     }
5178 }
5179 
5180 bool WebGLRenderingContextBase::hasPendingActivity() const
5181 {
5182     return false;
5183 }
5184 
5185 void WebGLRenderingContextBase::stop()
5186 {
5187     if (!isContextLost() &amp;&amp; !m_isPendingPolicyResolution) {
5188         forceLostContext(SyntheticLostContext);
<span class="line-modified">5189         destroyGraphicsContext3D();</span>
5190     }
5191 }
5192 
5193 const char* WebGLRenderingContextBase::activeDOMObjectName() const
5194 {
5195     return &quot;WebGLRenderingContext&quot;;
5196 }
5197 
<span class="line-modified">5198 bool WebGLRenderingContextBase::canSuspendForDocumentSuspension() const</span>
5199 {
<span class="line-modified">5200     // FIXME: We should try and do better here.</span>
<span class="line-removed">5201     return false;</span>
5202 }
5203 
<span class="line-modified">5204 bool WebGLRenderingContextBase::getBooleanParameter(GC3Denum pname)</span>
5205 {
<span class="line-modified">5206     GC3Dboolean value = 0;</span>





5207     m_context-&gt;getBooleanv(pname, &amp;value);
5208     return value;
5209 }
5210 
<span class="line-modified">5211 Vector&lt;bool&gt; WebGLRenderingContextBase::getBooleanArrayParameter(GC3Denum pname)</span>
5212 {
<span class="line-modified">5213     if (pname != GraphicsContext3D::COLOR_WRITEMASK) {</span>
5214         notImplemented();
5215         return { };
5216     }
<span class="line-modified">5217     GC3Dboolean value[4] = { 0 };</span>
5218     m_context-&gt;getBooleanv(pname, value);
5219     Vector&lt;bool&gt; vector(4);
5220     for (unsigned i = 0; i &lt; 4; ++i)
5221         vector[i] = value[i];
5222     return vector;
5223 }
5224 
<span class="line-modified">5225 float WebGLRenderingContextBase::getFloatParameter(GC3Denum pname)</span>
5226 {
<span class="line-modified">5227     GC3Dfloat value = 0;</span>
5228     m_context-&gt;getFloatv(pname, &amp;value);
5229     return value;
5230 }
5231 
<span class="line-modified">5232 int WebGLRenderingContextBase::getIntParameter(GC3Denum pname)</span>
5233 {
<span class="line-modified">5234     GC3Dint value = 0;</span>
5235     m_context-&gt;getIntegerv(pname, &amp;value);
5236     return value;
5237 }
5238 
<span class="line-modified">5239 unsigned WebGLRenderingContextBase::getUnsignedIntParameter(GC3Denum pname)</span>
5240 {
<span class="line-modified">5241     GC3Dint value = 0;</span>
5242     m_context-&gt;getIntegerv(pname, &amp;value);
5243     return value;
5244 }
5245 
<span class="line-modified">5246 long long WebGLRenderingContextBase::getInt64Parameter(GC3Denum pname)</span>
5247 {
<span class="line-modified">5248     GC3Dint64 value = 0;</span>
5249     m_context-&gt;getInteger64v(pname, &amp;value);
5250     return value;
5251 }
5252 
<span class="line-modified">5253 RefPtr&lt;Float32Array&gt; WebGLRenderingContextBase::getWebGLFloatArrayParameter(GC3Denum pname)</span>
5254 {
<span class="line-modified">5255     GC3Dfloat value[4] = {0};</span>
5256     m_context-&gt;getFloatv(pname, value);
5257     unsigned length = 0;
5258     switch (pname) {
<span class="line-modified">5259     case GraphicsContext3D::ALIASED_POINT_SIZE_RANGE:</span>
<span class="line-modified">5260     case GraphicsContext3D::ALIASED_LINE_WIDTH_RANGE:</span>
<span class="line-modified">5261     case GraphicsContext3D::DEPTH_RANGE:</span>
5262         length = 2;
5263         break;
<span class="line-modified">5264     case GraphicsContext3D::BLEND_COLOR:</span>
<span class="line-modified">5265     case GraphicsContext3D::COLOR_CLEAR_VALUE:</span>
5266         length = 4;
5267         break;
5268     default:
5269         notImplemented();
5270     }
5271     return Float32Array::tryCreate(value, length);
5272 }
5273 
<span class="line-modified">5274 RefPtr&lt;Int32Array&gt; WebGLRenderingContextBase::getWebGLIntArrayParameter(GC3Denum pname)</span>
5275 {
<span class="line-modified">5276     GC3Dint value[4] = {0};</span>
5277     m_context-&gt;getIntegerv(pname, value);
5278     unsigned length = 0;
5279     switch (pname) {
<span class="line-modified">5280     case GraphicsContext3D::MAX_VIEWPORT_DIMS:</span>
5281         length = 2;
5282         break;
<span class="line-modified">5283     case GraphicsContext3D::SCISSOR_BOX:</span>
<span class="line-modified">5284     case GraphicsContext3D::VIEWPORT:</span>
5285         length = 4;
5286         break;
5287     default:
5288         notImplemented();
5289     }
5290     return Int32Array::tryCreate(value, length);
5291 }
5292 
5293 bool WebGLRenderingContextBase::checkTextureCompleteness(const char* functionName, bool prepareToDraw)
5294 {
5295     bool resetActiveUnit = false;
5296     bool usesAtLeastOneBlackTexture = false;
5297     WebGLTexture::TextureExtensionFlag extensions = textureExtensionFlags();
5298 
5299     Vector&lt;unsigned&gt; noLongerUnrenderable;
5300     for (unsigned badTexture : m_unrenderableTextureUnits) {
5301         ASSERT(badTexture &lt; m_textureUnits.size());
5302         auto&amp; textureUnit = m_textureUnits[badTexture];
5303         bool needsToUseBlack2DTexture = textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(extensions);
5304         bool needsToUseBlack3DTexture = textureUnit.textureCubeMapBinding &amp;&amp; textureUnit.textureCubeMapBinding-&gt;needToUseBlackTexture(extensions);
5305 
5306         if (!needsToUseBlack2DTexture &amp;&amp; !needsToUseBlack3DTexture) {
5307             noLongerUnrenderable.append(badTexture);
5308             continue;
5309         }
5310 
5311         usesAtLeastOneBlackTexture = true;
5312 
5313         if (badTexture != m_activeTextureUnit) {
<span class="line-modified">5314             m_context-&gt;activeTexture(badTexture + GraphicsContext3D::TEXTURE0);</span>
5315             resetActiveUnit = true;
5316         } else if (resetActiveUnit) {
<span class="line-modified">5317             m_context-&gt;activeTexture(badTexture + GraphicsContext3D::TEXTURE0);</span>
5318             resetActiveUnit = false;
5319         }
5320         RefPtr&lt;WebGLTexture&gt; tex2D;
5321         RefPtr&lt;WebGLTexture&gt; texCubeMap;
5322         if (prepareToDraw) {
5323             printToConsole(MessageLevel::Error, makeString(&quot;WebGL: &quot;, functionName, &quot;: texture bound to texture unit &quot;, badTexture,
5324                 &quot; is not renderable. It maybe non-power-of-2 and have incompatible texture filtering or is not &#39;texture complete&#39;,&quot;
5325                 &quot; or it is a float/half-float type with linear filtering and without the relevant float/half-float linear extension enabled.&quot;));
5326             tex2D = m_blackTexture2D.get();
5327             texCubeMap = m_blackTextureCubeMap.get();
5328         } else {
5329             tex2D = textureUnit.texture2DBinding.get();
5330             texCubeMap = textureUnit.textureCubeMapBinding.get();
5331         }
5332         if (needsToUseBlack2DTexture)
<span class="line-modified">5333             m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, objectOrZero(tex2D.get()));</span>
5334         if (needsToUseBlack3DTexture)
<span class="line-modified">5335             m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_CUBE_MAP, objectOrZero(texCubeMap.get()));</span>
5336     }
5337     if (resetActiveUnit)
<span class="line-modified">5338         m_context-&gt;activeTexture(m_activeTextureUnit + GraphicsContext3D::TEXTURE0);</span>
5339 
5340     for (unsigned renderable : noLongerUnrenderable)
5341         m_unrenderableTextureUnits.remove(renderable);
5342 
5343     return usesAtLeastOneBlackTexture;
5344 }
5345 
5346 void WebGLRenderingContextBase::createFallbackBlackTextures1x1()
5347 {
5348     unsigned char black[] = {0, 0, 0, 255};
5349     m_blackTexture2D = createTexture();
<span class="line-modified">5350     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, m_blackTexture2D-&gt;object());</span>
<span class="line-modified">5351     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="line-modified">5352                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5353     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, 0);</span>
5354     m_blackTextureCubeMap = createTexture();
<span class="line-modified">5355     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_CUBE_MAP, m_blackTextureCubeMap-&gt;object());</span>
<span class="line-modified">5356     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="line-modified">5357                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5358     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="line-modified">5359                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5360     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="line-modified">5361                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5362     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="line-modified">5363                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5364     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="line-modified">5365                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5366     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="line-modified">5367                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5368     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_CUBE_MAP, 0);</span>
<span class="line-modified">5369 }</span>
<span class="line-modified">5370 </span>
<span class="line-modified">5371 bool WebGLRenderingContextBase::isTexInternalFormatColorBufferCombinationValid(GC3Denum texInternalFormat,</span>
<span class="line-modified">5372                                                                            GC3Denum colorBufferFormat)</span>
<span class="line-modified">5373 {</span>
<span class="line-modified">5374     unsigned need = GraphicsContext3D::getChannelBitsByFormat(texInternalFormat);</span>
<span class="line-removed">5375     unsigned have = GraphicsContext3D::getChannelBitsByFormat(colorBufferFormat);</span>
5376     return (need &amp; have) == need;
5377 }
5378 
<span class="line-modified">5379 GC3Denum WebGLRenderingContextBase::getBoundFramebufferColorFormat()</span>
5380 {
5381     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5382         return m_framebufferBinding-&gt;getColorBufferFormat();
5383     if (m_attributes.alpha)
<span class="line-modified">5384         return GraphicsContext3D::RGBA;</span>
<span class="line-modified">5385     return GraphicsContext3D::RGB;</span>
5386 }
5387 
5388 int WebGLRenderingContextBase::getBoundFramebufferWidth()
5389 {
5390     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5391         return m_framebufferBinding-&gt;getColorBufferWidth();
5392     return m_context-&gt;getInternalFramebufferSize().width();
5393 }
5394 
5395 int WebGLRenderingContextBase::getBoundFramebufferHeight()
5396 {
5397     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5398         return m_framebufferBinding-&gt;getColorBufferHeight();
5399     return m_context-&gt;getInternalFramebufferSize().height();
5400 }
5401 
<span class="line-modified">5402 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::validateTextureBinding(const char* functionName, GC3Denum target, bool useSixEnumsForCubeMap)</span>
5403 {
5404     RefPtr&lt;WebGLTexture&gt; texture;
5405     switch (target) {
<span class="line-modified">5406     case GraphicsContext3D::TEXTURE_2D:</span>
5407         texture = m_textureUnits[m_activeTextureUnit].texture2DBinding;
5408         break;
<span class="line-modified">5409     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="line-modified">5410     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="line-modified">5411     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="line-modified">5412     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="line-modified">5413     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="line-modified">5414     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
5415         if (!useSixEnumsForCubeMap) {
<span class="line-modified">5416             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
5417             return nullptr;
5418         }
5419         texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
5420         break;
<span class="line-modified">5421     case GraphicsContext3D::TEXTURE_CUBE_MAP:</span>
5422         if (useSixEnumsForCubeMap) {
<span class="line-modified">5423             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
5424             return nullptr;
5425         }
5426         texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
5427         break;
5428     default:
<span class="line-modified">5429         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
5430         return nullptr;
5431     }
5432 
5433     if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
5434         m_unrenderableTextureUnits.add(m_activeTextureUnit);
5435 
5436     if (!texture)
<span class="line-modified">5437         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;no texture&quot;);</span>
5438     return texture;
5439 }
5440 
5441 bool WebGLRenderingContextBase::validateLocationLength(const char* functionName, const String&amp; string)
5442 {
5443     const unsigned maxWebGLLocationLength = 256;
5444     if (string.length() &gt; maxWebGLLocationLength) {
<span class="line-modified">5445         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;location length &gt; 256&quot;);</span>
5446         return false;
5447     }
5448     return true;
5449 }
5450 
<span class="line-modified">5451 bool WebGLRenderingContextBase::validateSize(const char* functionName, GC3Dint x, GC3Dint y)</span>
5452 {
5453     if (x &lt; 0 || y &lt; 0) {
<span class="line-modified">5454         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;size &lt; 0&quot;);</span>
5455         return false;
5456     }
5457     return true;
5458 }
5459 
5460 bool WebGLRenderingContextBase::validateString(const char* functionName, const String&amp; string)
5461 {
5462     for (size_t i = 0; i &lt; string.length(); ++i) {
5463         if (!validateCharacter(string[i])) {
<span class="line-modified">5464             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;string not ASCII&quot;);</span>
5465             return false;
5466         }
5467     }
5468     return true;
5469 }
5470 
<span class="line-modified">5471 bool WebGLRenderingContextBase::validateTexFuncLevel(const char* functionName, GC3Denum target, GC3Dint level)</span>
5472 {
5473     if (level &lt; 0) {
<span class="line-modified">5474         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level &lt; 0&quot;);</span>
5475         return false;
5476     }
5477     switch (target) {
<span class="line-modified">5478     case GraphicsContext3D::TEXTURE_2D:</span>
5479         if (level &gt;= m_maxTextureLevel) {
<span class="line-modified">5480             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level out of range&quot;);</span>
5481             return false;
5482         }
5483         break;
<span class="line-modified">5484     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="line-modified">5485     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="line-modified">5486     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="line-modified">5487     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="line-modified">5488     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="line-modified">5489     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
5490         if (level &gt;= m_maxCubeMapTextureLevel) {
<span class="line-modified">5491             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level out of range&quot;);</span>
5492             return false;
5493         }
5494         break;
5495     }
5496     // This function only checks if level is legal, so we return true and don&#39;t
5497     // generate INVALID_ENUM if target is illegal.
5498     return true;
5499 }
5500 
<span class="line-modified">5501 bool WebGLRenderingContextBase::validateCompressedTexFormat(GC3Denum format)</span>
5502 {
5503     return m_compressedTextureFormats.contains(format);
5504 }
5505 
5506 struct BlockParameters {
5507     const int width;
5508     const int height;
5509     const int size;
5510 };
5511 
<span class="line-modified">5512 static inline unsigned calculateBytesForASTC(GC3Dsizei width, GC3Dsizei height, const BlockParameters&amp; parameters)</span>
5513 {
5514     return ((width + parameters.width - 1) / parameters.width) * ((height + parameters.height - 1) / parameters.height) * parameters.size;
5515 }
5516 
<span class="line-modified">5517 bool WebGLRenderingContextBase::validateCompressedTexFuncData(const char* functionName, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; pixels)</span>
5518 {
5519     if (width &lt; 0 || height &lt; 0) {
<span class="line-modified">5520         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);</span>
5521         return false;
5522     }
5523 
5524     unsigned bytesRequired = 0;
5525 
5526     // Block parameters for ASTC formats
5527     const int kASTCBlockSize = 16;
5528     static const BlockParameters ASTCParameters[] {
5529         BlockParameters { 4, 4, kASTCBlockSize },
5530         BlockParameters { 5, 4, kASTCBlockSize },
5531         BlockParameters { 5, 5, kASTCBlockSize },
5532         BlockParameters { 6, 5, kASTCBlockSize },
5533         BlockParameters { 6, 6, kASTCBlockSize },
5534         BlockParameters { 8, 5, kASTCBlockSize },
5535         BlockParameters { 8, 6, kASTCBlockSize },
5536         BlockParameters { 8, 8, kASTCBlockSize },
5537         BlockParameters { 10, 5, kASTCBlockSize },
5538         BlockParameters { 10, 6, kASTCBlockSize },
5539         BlockParameters { 10, 8, kASTCBlockSize },
5540         BlockParameters { 10, 10, kASTCBlockSize },
5541         BlockParameters { 12, 10, kASTCBlockSize },
5542         BlockParameters { 12, 12, kASTCBlockSize }
5543     };
<span class="line-modified">5544     const GC3Denum ASTCEnumStartRGBA = Extensions3D::COMPRESSED_RGBA_ASTC_4x4_KHR;</span>
<span class="line-modified">5545     const GC3Denum ASTCEnumStartSRGB8 = Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;</span>


5546 
5547     switch (format) {
<span class="line-modified">5548     case Extensions3D::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="line-modified">5549     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="line-modified">5550     case Extensions3D::COMPRESSED_ATC_RGB_AMD:</span>
<span class="line-modified">5551         {</span>
<span class="line-modified">5552             const int kBlockSize = 8;</span>
<span class="line-modified">5553             const int kBlockWidth = 4;</span>
<span class="line-modified">5554             const int kBlockHeight = 4;</span>
<span class="line-modified">5555             int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;</span>
<span class="line-modified">5556             int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;</span>
<span class="line-modified">5557             bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;</span>
<span class="line-removed">5558         }</span>
5559         break;
<span class="line-modified">5560     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="line-modified">5561     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT5_EXT:</span>
<span class="line-modified">5562     case Extensions3D::COMPRESSED_ATC_RGBA_EXPLICIT_ALPHA_AMD:</span>
<span class="line-modified">5563     case Extensions3D::COMPRESSED_ATC_RGBA_INTERPOLATED_ALPHA_AMD:</span>

5564         {
5565             const int kBlockSize = 16;
5566             const int kBlockWidth = 4;
5567             const int kBlockHeight = 4;
5568             int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;
5569             int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;
5570             bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;
5571         }
5572         break;
<span class="line-modified">5573     case Extensions3D::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5574     case Extensions3D::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
5575         {
5576             const int kBlockSize = 8;
5577             const int kBlockWidth = 8;
5578             const int kBlockHeight = 8;
5579             bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 4 + 7) / kBlockSize;
5580         }
5581         break;
<span class="line-modified">5582     case Extensions3D::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="line-modified">5583     case Extensions3D::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:</span>
5584         {
5585             const int kBlockSize = 8;
5586             const int kBlockWidth = 16;
5587             const int kBlockHeight = 8;
5588             bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 2 + 7) / kBlockSize;
5589         }
5590         break;
<span class="line-modified">5591     case Extensions3D::COMPRESSED_RGBA_ASTC_4x4_KHR:</span>
<span class="line-modified">5592     case Extensions3D::COMPRESSED_RGBA_ASTC_5x4_KHR:</span>
<span class="line-modified">5593     case Extensions3D::COMPRESSED_RGBA_ASTC_5x5_KHR:</span>
<span class="line-modified">5594     case Extensions3D::COMPRESSED_RGBA_ASTC_6x5_KHR:</span>
<span class="line-modified">5595     case Extensions3D::COMPRESSED_RGBA_ASTC_6x6_KHR:</span>
<span class="line-modified">5596     case Extensions3D::COMPRESSED_RGBA_ASTC_8x5_KHR:</span>
<span class="line-modified">5597     case Extensions3D::COMPRESSED_RGBA_ASTC_8x6_KHR:</span>
<span class="line-modified">5598     case Extensions3D::COMPRESSED_RGBA_ASTC_8x8_KHR:</span>
<span class="line-modified">5599     case Extensions3D::COMPRESSED_RGBA_ASTC_10x5_KHR:</span>
<span class="line-modified">5600     case Extensions3D::COMPRESSED_RGBA_ASTC_10x6_KHR:</span>
<span class="line-modified">5601     case Extensions3D::COMPRESSED_RGBA_ASTC_10x8_KHR:</span>
<span class="line-modified">5602     case Extensions3D::COMPRESSED_RGBA_ASTC_10x10_KHR:</span>
<span class="line-modified">5603     case Extensions3D::COMPRESSED_RGBA_ASTC_12x10_KHR:</span>
<span class="line-modified">5604     case Extensions3D::COMPRESSED_RGBA_ASTC_12x12_KHR:</span>
5605         bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartRGBA]);
5606         break;
<span class="line-modified">5607     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:</span>
<span class="line-modified">5608     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:</span>
<span class="line-modified">5609     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:</span>
<span class="line-modified">5610     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:</span>
<span class="line-modified">5611     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:</span>
<span class="line-modified">5612     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:</span>
<span class="line-modified">5613     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:</span>
<span class="line-modified">5614     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:</span>
<span class="line-modified">5615     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:</span>
<span class="line-modified">5616     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:</span>
<span class="line-modified">5617     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:</span>
<span class="line-modified">5618     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:</span>
<span class="line-modified">5619     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:</span>
<span class="line-modified">5620     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:</span>
5621         bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartSRGB8]);
5622         break;






























5623     default:
<span class="line-modified">5624         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid format&quot;);</span>
5625         return false;
5626     }
5627 
5628     if (pixels.byteLength() != bytesRequired) {
<span class="line-modified">5629         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;length of ArrayBufferView is not correct for dimensions&quot;);</span>
5630         return false;
5631     }
5632 
5633     return true;
5634 }
5635 
<span class="line-modified">5636 bool WebGLRenderingContextBase::validateCompressedTexDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dsizei width, GC3Dsizei height, GC3Denum format)</span>
5637 {
5638     switch (format) {
<span class="line-modified">5639     case Extensions3D::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="line-modified">5640     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="line-modified">5641     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="line-modified">5642     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT5_EXT: {</span>
<span class="line-modified">5643         const GC3Dsizei kBlockWidth = 4;</span>
<span class="line-modified">5644         const GC3Dsizei kBlockHeight = 4;</span>
<span class="line-modified">5645         const GC3Dint maxTextureSize = target ? m_maxTextureSize : m_maxCubeMapTextureSize;</span>
<span class="line-modified">5646         const GC3Dsizei maxCompressedDimension = maxTextureSize &gt;&gt; level;</span>
5647         bool widthValid = (level &amp;&amp; width == 1) || (level &amp;&amp; width == 2) || (!(width % kBlockWidth) &amp;&amp; width &lt;= maxCompressedDimension);
5648         bool heightValid = (level &amp;&amp; height == 1) || (level &amp;&amp; height == 2) || (!(height % kBlockHeight) &amp;&amp; height &lt;= maxCompressedDimension);
5649         if (!widthValid || !heightValid) {
<span class="line-modified">5650             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);</span>
5651             return false;
5652         }
5653         return true;
5654     }
<span class="line-modified">5655     case Extensions3D::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5656     case Extensions3D::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="line-modified">5657     case Extensions3D::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5658     case Extensions3D::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:</span>
5659         // Height and width must be powers of 2.
5660         if ((width &amp; (width - 1)) || (height &amp; (height - 1))) {
<span class="line-modified">5661             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);</span>
5662             return false;
5663         }
5664         return true;
<span class="line-modified">5665     case Extensions3D::COMPRESSED_RGBA_ASTC_4x4_KHR:</span>
<span class="line-modified">5666     case Extensions3D::COMPRESSED_RGBA_ASTC_5x4_KHR:</span>
<span class="line-modified">5667     case Extensions3D::COMPRESSED_RGBA_ASTC_5x5_KHR:</span>
<span class="line-modified">5668     case Extensions3D::COMPRESSED_RGBA_ASTC_6x5_KHR:</span>
<span class="line-modified">5669     case Extensions3D::COMPRESSED_RGBA_ASTC_6x6_KHR:</span>
<span class="line-modified">5670     case Extensions3D::COMPRESSED_RGBA_ASTC_8x5_KHR:</span>
<span class="line-modified">5671     case Extensions3D::COMPRESSED_RGBA_ASTC_8x6_KHR:</span>
<span class="line-modified">5672     case Extensions3D::COMPRESSED_RGBA_ASTC_8x8_KHR:</span>
<span class="line-modified">5673     case Extensions3D::COMPRESSED_RGBA_ASTC_10x5_KHR:</span>
<span class="line-modified">5674     case Extensions3D::COMPRESSED_RGBA_ASTC_10x6_KHR:</span>
<span class="line-modified">5675     case Extensions3D::COMPRESSED_RGBA_ASTC_10x8_KHR:</span>
<span class="line-modified">5676     case Extensions3D::COMPRESSED_RGBA_ASTC_10x10_KHR:</span>
<span class="line-modified">5677     case Extensions3D::COMPRESSED_RGBA_ASTC_12x10_KHR:</span>
<span class="line-modified">5678     case Extensions3D::COMPRESSED_RGBA_ASTC_12x12_KHR:</span>
<span class="line-modified">5679     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:</span>
<span class="line-modified">5680     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:</span>
<span class="line-modified">5681     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:</span>
<span class="line-modified">5682     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:</span>
<span class="line-modified">5683     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:</span>
<span class="line-modified">5684     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:</span>
<span class="line-modified">5685     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:</span>
<span class="line-modified">5686     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:</span>
<span class="line-modified">5687     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:</span>
<span class="line-modified">5688     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:</span>
<span class="line-modified">5689     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:</span>
<span class="line-modified">5690     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:</span>
<span class="line-modified">5691     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:</span>
<span class="line-modified">5692     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:</span>
<span class="line-modified">5693         // No height and width restrictions on ASTC.</span>











5694         return true;
5695     default:
5696         return false;
5697     }
5698 }
5699 
<span class="line-modified">5700 bool WebGLRenderingContextBase::validateCompressedTexSubDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset,</span>
<span class="line-removed">5701                                                                GC3Dsizei width, GC3Dsizei height, GC3Denum format, WebGLTexture* tex)</span>
5702 {
5703     if (xoffset &lt; 0 || yoffset &lt; 0) {
<span class="line-modified">5704       synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;xoffset or yoffset &lt; 0&quot;);</span>
<span class="line-modified">5705       return false;</span>
5706     }
5707 
5708     switch (format) {
<span class="line-modified">5709     case Extensions3D::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="line-modified">5710     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="line-modified">5711     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="line-modified">5712     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT5_EXT: {</span>
5713         const int kBlockWidth = 4;
5714         const int kBlockHeight = 4;
5715         if ((xoffset % kBlockWidth) || (yoffset % kBlockHeight)) {
<span class="line-modified">5716             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;xoffset or yoffset not multiple of 4&quot;);</span>
5717             return false;
5718         }
5719         if (width - xoffset &gt; tex-&gt;getWidth(target, level)
5720             || height - yoffset &gt; tex-&gt;getHeight(target, level)) {
<span class="line-modified">5721             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;dimensions out of range&quot;);</span>
5722             return false;
5723         }
5724         return validateCompressedTexDimensions(functionName, target, level, width, height, format);
5725     }
<span class="line-modified">5726     case Extensions3D::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5727     case Extensions3D::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="line-modified">5728     case Extensions3D::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5729     case Extensions3D::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: {</span>
5730         if (xoffset || yoffset) {
<span class="line-modified">5731             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;xoffset and yoffset must be zero&quot;);</span>
5732             return false;
5733         }
5734         if (width != tex-&gt;getWidth(target, level)
5735             || height != tex-&gt;getHeight(target, level)) {
<span class="line-modified">5736             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;dimensions must match existing level&quot;);</span>
5737             return false;
5738         }
5739         return validateCompressedTexDimensions(functionName, target, level, width, height, format);
5740     }




























5741     default:
5742         return false;
5743     }
5744 }
5745 
<span class="line-modified">5746 bool WebGLRenderingContextBase::validateDrawMode(const char* functionName, GC3Denum mode)</span>
5747 {
5748     switch (mode) {
<span class="line-modified">5749     case GraphicsContext3D::POINTS:</span>
<span class="line-modified">5750     case GraphicsContext3D::LINE_STRIP:</span>
<span class="line-modified">5751     case GraphicsContext3D::LINE_LOOP:</span>
<span class="line-modified">5752     case GraphicsContext3D::LINES:</span>
<span class="line-modified">5753     case GraphicsContext3D::TRIANGLE_STRIP:</span>
<span class="line-modified">5754     case GraphicsContext3D::TRIANGLE_FAN:</span>
<span class="line-modified">5755     case GraphicsContext3D::TRIANGLES:</span>
5756         return true;
5757     default:
<span class="line-modified">5758         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid draw mode&quot;);</span>
5759         return false;
5760     }
5761 }
5762 
5763 bool WebGLRenderingContextBase::validateStencilSettings(const char* functionName)
5764 {
5765     if (m_stencilMask != m_stencilMaskBack || m_stencilFuncRef != m_stencilFuncRefBack || m_stencilFuncMask != m_stencilFuncMaskBack) {
<span class="line-modified">5766         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;front and back stencils settings do not match&quot;);</span>
5767         return false;
5768     }
5769     return true;
5770 }
5771 
<span class="line-modified">5772 bool WebGLRenderingContextBase::validateStencilFunc(const char* functionName, GC3Denum func)</span>
5773 {
5774     switch (func) {
<span class="line-modified">5775     case GraphicsContext3D::NEVER:</span>
<span class="line-modified">5776     case GraphicsContext3D::LESS:</span>
<span class="line-modified">5777     case GraphicsContext3D::LEQUAL:</span>
<span class="line-modified">5778     case GraphicsContext3D::GREATER:</span>
<span class="line-modified">5779     case GraphicsContext3D::GEQUAL:</span>
<span class="line-modified">5780     case GraphicsContext3D::EQUAL:</span>
<span class="line-modified">5781     case GraphicsContext3D::NOTEQUAL:</span>
<span class="line-modified">5782     case GraphicsContext3D::ALWAYS:</span>
5783         return true;
5784     default:
<span class="line-modified">5785         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid function&quot;);</span>
5786         return false;
5787     }
5788 }
5789 
5790 void WebGLRenderingContextBase::printToConsole(MessageLevel level, const String&amp; message)
5791 {
5792     if (!m_synthesizedErrorsToConsole || !m_numGLErrorsToConsoleAllowed)
5793         return;
5794 
5795     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; consoleMessage;
5796 
5797     // Error messages can occur during function calls, so show stack traces for them.
5798     if (level == MessageLevel::Error) {
5799         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
5800         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message, WTFMove(stackTrace));
5801     } else
5802         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message);
5803 
5804     auto* canvas = htmlCanvas();
5805     if (canvas)
5806         canvas-&gt;document().addConsoleMessage(WTFMove(consoleMessage));
5807 
5808     --m_numGLErrorsToConsoleAllowed;
5809     if (!m_numGLErrorsToConsoleAllowed)
5810         printToConsole(MessageLevel::Warning, &quot;WebGL: too many errors, no more errors will be reported to the console for this context.&quot;);
5811 }
5812 
<span class="line-modified">5813 bool WebGLRenderingContextBase::validateBlendFuncFactors(const char* functionName, GC3Denum src, GC3Denum dst)</span>
5814 {
<span class="line-modified">5815     if (((src == GraphicsContext3D::CONSTANT_COLOR || src == GraphicsContext3D::ONE_MINUS_CONSTANT_COLOR)</span>
<span class="line-modified">5816          &amp;&amp; (dst == GraphicsContext3D::CONSTANT_ALPHA || dst == GraphicsContext3D::ONE_MINUS_CONSTANT_ALPHA))</span>
<span class="line-modified">5817         || ((dst == GraphicsContext3D::CONSTANT_COLOR || dst == GraphicsContext3D::ONE_MINUS_CONSTANT_COLOR)</span>
<span class="line-modified">5818             &amp;&amp; (src == GraphicsContext3D::CONSTANT_ALPHA || src == GraphicsContext3D::ONE_MINUS_CONSTANT_ALPHA))) {</span>
<span class="line-modified">5819         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;incompatible src and dst&quot;);</span>
5820         return false;
5821     }
5822     return true;
5823 }
5824 
<span class="line-modified">5825 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Float32List&amp; v, GC3Dsizei requiredMinSize)</span>
5826 {
5827     return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
5828 }
5829 
<span class="line-modified">5830 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Int32List&amp; v, GC3Dsizei requiredMinSize)</span>
5831 {
5832     return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
5833 }
5834 
<span class="line-modified">5835 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, void* v, GC3Dsizei size, GC3Dsizei requiredMinSize)</span>
5836 {
5837     return validateUniformMatrixParameters(functionName, location, false, v, size, requiredMinSize);
5838 }
5839 
<span class="line-modified">5840 bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GC3Dboolean transpose, const Float32List&amp; v, GC3Dsizei requiredMinSize)</span>
5841 {
5842     return validateUniformMatrixParameters(functionName, location, transpose, v.data(), v.length(), requiredMinSize);
5843 }
5844 
<span class="line-modified">5845 bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GC3Dboolean transpose, const void* v, GC3Dsizei size, GC3Dsizei requiredMinSize)</span>
5846 {
5847     if (!location)
5848         return false;
5849     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">5850         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;location is not from current program&quot;);</span>
5851         return false;
5852     }
5853     if (!v) {
<span class="line-modified">5854         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no array&quot;);</span>
5855         return false;
5856     }
5857     if (transpose) {
<span class="line-modified">5858         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;transpose not FALSE&quot;);</span>
5859         return false;
5860     }
5861     if (size &lt; requiredMinSize || (size % requiredMinSize)) {
<span class="line-modified">5862         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;invalid size&quot;);</span>
5863         return false;
5864     }
5865     return true;
5866 }
5867 
<span class="line-modified">5868 WebGLBuffer* WebGLRenderingContextBase::validateBufferDataParameters(const char* functionName, GC3Denum target, GC3Denum usage)</span>
5869 {
5870     Optional&lt;WebGLBuffer*&gt; buffer;
5871     switch (target) {
<span class="line-modified">5872     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER:</span>
5873         buffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
5874         break;
<span class="line-modified">5875     case GraphicsContext3D::ARRAY_BUFFER:</span>
5876         buffer = m_boundArrayBuffer.get();
5877         break;
5878     default:
5879 #if ENABLE(WEBGL2)
5880         if (isWebGL2()) {
5881             switch (target) {
<span class="line-modified">5882             case GraphicsContext3D::COPY_READ_BUFFER:</span>
5883                 buffer = m_boundCopyReadBuffer.get();
5884                 break;
<span class="line-modified">5885             case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
5886                 buffer = m_boundCopyWriteBuffer.get();
5887                 break;
<span class="line-modified">5888             case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
5889                 buffer = m_boundPixelPackBuffer.get();
5890                 break;
<span class="line-modified">5891             case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
5892                 buffer = m_boundPixelUnpackBuffer.get();
5893                 break;
<span class="line-modified">5894             case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
5895                 buffer = m_boundTransformFeedbackBuffer.get();
5896                 break;
<span class="line-modified">5897             case GraphicsContext3D::UNIFORM_BUFFER:</span>
5898                 buffer = m_boundUniformBuffer.get();
5899                 break;
5900             }
5901             if (buffer)
5902                 break;
5903         }
5904 #endif
<span class="line-modified">5905         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
5906         return nullptr;
5907     }
5908     if (!buffer || !buffer.value()) {
<span class="line-modified">5909         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;no buffer&quot;);</span>
5910         return nullptr;
5911     }
5912     switch (usage) {
<span class="line-modified">5913     case GraphicsContext3D::STREAM_DRAW:</span>
<span class="line-modified">5914     case GraphicsContext3D::STATIC_DRAW:</span>
<span class="line-modified">5915     case GraphicsContext3D::DYNAMIC_DRAW:</span>
5916         return buffer.value();
5917     }
<span class="line-modified">5918     synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid usage&quot;);</span>
5919     return nullptr;
5920 }
5921 
5922 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLImageElement(const char* functionName, HTMLImageElement* image)
5923 {
5924     if (!image || !image-&gt;cachedImage()) {
<span class="line-modified">5925         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no image&quot;);</span>
5926         return false;
5927     }
5928     const URL&amp; url = image-&gt;cachedImage()-&gt;response().url();
5929     if (url.isNull() || url.isEmpty() || !url.isValid()) {
<span class="line-modified">5930         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;invalid image&quot;);</span>
5931         return false;
5932     }
5933     if (wouldTaintOrigin(image))
5934         return Exception { SecurityError };
5935     return true;
5936 }
5937 
5938 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement* canvas)
5939 {
5940     if (!canvas || !canvas-&gt;buffer()) {
<span class="line-modified">5941         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no canvas&quot;);</span>
5942         return false;
5943     }
5944     if (wouldTaintOrigin(canvas))
5945         return Exception { SecurityError };
5946     return true;
5947 }
5948 
5949 #if ENABLE(VIDEO)
5950 
5951 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLVideoElement(const char* functionName, HTMLVideoElement* video)
5952 {
5953     if (!video || !video-&gt;videoWidth() || !video-&gt;videoHeight()) {
<span class="line-modified">5954         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no video&quot;);</span>
5955         return false;
5956     }
5957     if (wouldTaintOrigin(video))
5958         return Exception { SecurityError };
5959     return true;
5960 }
5961 
5962 #endif
5963 
<span class="line-modified">5964 void WebGLRenderingContextBase::vertexAttribfImpl(const char* functionName, GC3Duint index, GC3Dsizei expectedSize, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2, GC3Dfloat v3)</span>
5965 {
5966     if (isContextLostOrPending())
5967         return;
5968     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">5969         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;index out of range&quot;);</span>
5970         return;
5971     }
5972     // In GL, we skip setting vertexAttrib0 values.
5973     if (index || isGLES2Compliant()) {
5974         switch (expectedSize) {
5975         case 1:
5976             m_context-&gt;vertexAttrib1f(index, v0);
5977             break;
5978         case 2:
5979             m_context-&gt;vertexAttrib2f(index, v0, v1);
5980             break;
5981         case 3:
5982             m_context-&gt;vertexAttrib3f(index, v0, v1, v2);
5983             break;
5984         case 4:
5985             m_context-&gt;vertexAttrib4f(index, v0, v1, v2, v3);
5986             break;
5987         }
5988     }
5989     VertexAttribValue&amp; attribValue = m_vertexAttribValue[index];
5990     attribValue.value[0] = v0;
5991     attribValue.value[1] = v1;
5992     attribValue.value[2] = v2;
5993     attribValue.value[3] = v3;
5994 }
5995 
<span class="line-modified">5996 void WebGLRenderingContextBase::vertexAttribfvImpl(const char* functionName, GC3Duint index, Float32List&amp;&amp; list, GC3Dsizei expectedSize)</span>
5997 {
5998     if (isContextLostOrPending())
5999         return;
6000 
6001     auto data = list.data();
6002     if (!data) {
<span class="line-modified">6003         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no array&quot;);</span>
6004         return;
6005     }
6006 
6007     int size = list.length();
6008     if (size &lt; expectedSize) {
<span class="line-modified">6009         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;invalid size&quot;);</span>
6010         return;
6011     }
6012     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">6013         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;index out of range&quot;);</span>
6014         return;
6015     }
6016     // In GL, we skip setting vertexAttrib0 values.
6017     if (index || isGLES2Compliant()) {
6018         switch (expectedSize) {
6019         case 1:
6020             m_context-&gt;vertexAttrib1fv(index, data);
6021             break;
6022         case 2:
6023             m_context-&gt;vertexAttrib2fv(index, data);
6024             break;
6025         case 3:
6026             m_context-&gt;vertexAttrib3fv(index, data);
6027             break;
6028         case 4:
6029             m_context-&gt;vertexAttrib4fv(index, data);
6030             break;
6031         }
6032     }
6033     VertexAttribValue&amp; attribValue = m_vertexAttribValue[index];
6034     attribValue.initValue();
6035     for (int ii = 0; ii &lt; expectedSize; ++ii)
6036         attribValue.value[ii] = data[ii];
6037 }
6038 
6039 void WebGLRenderingContextBase::initVertexAttrib0()
6040 {
6041     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6042 
6043     m_vertexAttrib0Buffer = createBuffer();
<span class="line-modified">6044     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());</span>
<span class="line-modified">6045     m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, 0, GraphicsContext3D::DYNAMIC_DRAW);</span>
<span class="line-modified">6046     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContext3D::FLOAT, false, 0, 0);</span>
6047     state.bufferBinding = m_vertexAttrib0Buffer;
<span class="line-modified">6048     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, 0);</span>
6049     m_context-&gt;enableVertexAttribArray(0);
6050     m_vertexAttrib0BufferSize = 0;
6051     m_vertexAttrib0BufferValue[0] = 0.0f;
6052     m_vertexAttrib0BufferValue[1] = 0.0f;
6053     m_vertexAttrib0BufferValue[2] = 0.0f;
6054     m_vertexAttrib0BufferValue[3] = 1.0f;
6055     m_forceAttrib0BufferRefill = false;
6056     m_vertexAttrib0UsedBefore = false;
6057 }
6058 
<span class="line-modified">6059 bool WebGLRenderingContextBase::validateSimulatedVertexAttrib0(GC3Duint numVertex)</span>
6060 {
6061     if (!m_currentProgram)
6062         return true;
6063 
6064     bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
6065     if (!usingVertexAttrib0)
6066         return true;
6067 
6068     auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6069     if (state.enabled)
6070         return true;
6071 
<span class="line-modified">6072     auto bufferSize = checkedAddAndMultiply&lt;GC3Duint&gt;(numVertex, 1, 4);</span>
6073     if (!bufferSize)
6074         return false;
6075 
<span class="line-modified">6076     Checked&lt;GC3Dsizeiptr, RecordOverflow&gt; bufferDataSize(bufferSize.value());</span>
<span class="line-modified">6077     bufferDataSize *= Checked&lt;GC3Dsizeiptr&gt;(sizeof(GC3Dfloat));</span>
6078     return !bufferDataSize.hasOverflowed() &amp;&amp; bufferDataSize.unsafeGet() &gt; 0;
6079 }
6080 
<span class="line-modified">6081 Optional&lt;bool&gt; WebGLRenderingContextBase::simulateVertexAttrib0(GC3Duint numVertex)</span>
6082 {
6083     if (!m_currentProgram)
6084         return false;
6085     bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
6086     if (usingVertexAttrib0)
6087         m_vertexAttrib0UsedBefore = true;
6088 
6089     auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6090     if (state.enabled &amp;&amp; usingVertexAttrib0)
6091         return false;
6092     if (!usingVertexAttrib0 &amp;&amp; !m_vertexAttrib0UsedBefore)
6093         return false;
6094     m_vertexAttrib0UsedBefore = true;
<span class="line-modified">6095     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());</span>
6096 
6097     // We know bufferSize and bufferDataSize won&#39;t overflow or go negative, thanks to validateSimulatedVertexAttrib0
<span class="line-modified">6098     GC3Duint bufferSize = (numVertex + 1) * 4;</span>
<span class="line-modified">6099     GC3Dsizeiptr bufferDataSize = bufferSize * sizeof(GC3Dfloat);</span>
6100 
6101     if (bufferDataSize &gt; m_vertexAttrib0BufferSize) {
6102         m_context-&gt;moveErrorsToSyntheticErrorList();
<span class="line-modified">6103         m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, bufferDataSize, 0, GraphicsContext3D::DYNAMIC_DRAW);</span>
<span class="line-modified">6104         if (m_context-&gt;getError() != GraphicsContext3D::NO_ERROR) {</span>
6105             // We were unable to create a buffer.
6106             m_vertexAttrib0UsedBefore = false;
6107             m_vertexAttrib0BufferSize = 0;
6108             m_forceAttrib0BufferRefill = true;
6109             return WTF::nullopt;
6110         }
6111         m_vertexAttrib0BufferSize = bufferDataSize;
6112         m_forceAttrib0BufferRefill = true;
6113     }
6114 
6115     auto&amp; attribValue = m_vertexAttribValue[0];
6116 
6117     if (usingVertexAttrib0
6118         &amp;&amp; (m_forceAttrib0BufferRefill
6119             || attribValue.value[0] != m_vertexAttrib0BufferValue[0]
6120             || attribValue.value[1] != m_vertexAttrib0BufferValue[1]
6121             || attribValue.value[2] != m_vertexAttrib0BufferValue[2]
6122             || attribValue.value[3] != m_vertexAttrib0BufferValue[3])) {
6123 
<span class="line-modified">6124         auto bufferData = makeUniqueArray&lt;GC3Dfloat&gt;(bufferSize);</span>
<span class="line-modified">6125         for (GC3Duint ii = 0; ii &lt; numVertex + 1; ++ii) {</span>
6126             bufferData[ii * 4] = attribValue.value[0];
6127             bufferData[ii * 4 + 1] = attribValue.value[1];
6128             bufferData[ii * 4 + 2] = attribValue.value[2];
6129             bufferData[ii * 4 + 3] = attribValue.value[3];
6130         }
6131         m_vertexAttrib0BufferValue[0] = attribValue.value[0];
6132         m_vertexAttrib0BufferValue[1] = attribValue.value[1];
6133         m_vertexAttrib0BufferValue[2] = attribValue.value[2];
6134         m_vertexAttrib0BufferValue[3] = attribValue.value[3];
6135         m_forceAttrib0BufferRefill = false;
<span class="line-modified">6136         m_context-&gt;bufferSubData(GraphicsContext3D::ARRAY_BUFFER, 0, bufferDataSize, bufferData.get());</span>
6137     }
<span class="line-modified">6138     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContext3D::FLOAT, 0, 0, 0);</span>
6139     return true;
6140 }
6141 
6142 void WebGLRenderingContextBase::restoreStatesAfterVertexAttrib0Simulation()
6143 {
6144     const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6145     if (state.bufferBinding != m_vertexAttrib0Buffer) {
<span class="line-modified">6146         m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, objectOrZero(state.bufferBinding.get()));</span>
6147         m_context-&gt;vertexAttribPointer(0, state.size, state.type, state.normalized, state.originalStride, state.offset);
6148     }
<span class="line-modified">6149     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, objectOrZero(m_boundArrayBuffer.get()));</span>
6150 }
6151 
6152 void WebGLRenderingContextBase::dispatchContextLostEvent()
6153 {

6154     auto* canvas = htmlCanvas();
6155     if (!canvas)
6156         return;
6157 
6158     Ref&lt;WebGLContextEvent&gt; event = WebGLContextEvent::create(eventNames().webglcontextlostEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString());
6159     canvas-&gt;dispatchEvent(event);
6160     m_restoreAllowed = event-&gt;defaultPrevented();
6161     if (m_contextLostMode == RealLostContext &amp;&amp; m_restoreAllowed)
6162         m_restoreTimer.startOneShot(0_s);
6163 }
6164 
6165 void WebGLRenderingContextBase::maybeRestoreContext()
6166 {

6167     ASSERT(m_contextLost);
6168     if (!m_contextLost)
6169         return;
6170 
6171     // The rendering context is not restored unless the default behavior of the
6172     // webglcontextlost event was prevented earlier.
6173     //
6174     // Because of the way m_restoreTimer is set up for real vs. synthetic lost
6175     // context events, we don&#39;t have to worry about this test short-circuiting
6176     // the retry loop for real context lost events.
6177     if (!m_restoreAllowed)
6178         return;
6179 
6180     int contextLostReason = m_context-&gt;getExtensions().getGraphicsResetStatusARB();
6181 
6182     switch (contextLostReason) {
<span class="line-modified">6183     case GraphicsContext3D::NO_ERROR:</span>
<span class="line-modified">6184         // The GraphicsContext3D implementation might not fully</span>
6185         // support GL_ARB_robustness semantics yet. Alternatively, the
6186         // WEBGL_lose_context extension might have been used to force
6187         // a lost context.
6188         break;
<span class="line-modified">6189     case Extensions3D::GUILTY_CONTEXT_RESET_ARB:</span>
6190         // The rendering context is not restored if this context was
6191         // guilty of causing the graphics reset.
6192         printToConsole(MessageLevel::Warning, &quot;WARNING: WebGL content on the page caused the graphics card to reset; not restoring the context&quot;);
6193         return;
<span class="line-modified">6194     case Extensions3D::INNOCENT_CONTEXT_RESET_ARB:</span>
6195         // Always allow the context to be restored.
6196         break;
<span class="line-modified">6197     case Extensions3D::UNKNOWN_CONTEXT_RESET_ARB:</span>
6198         // Warn. Ideally, prompt the user telling them that WebGL
6199         // content on the page might have caused the graphics card to
6200         // reset and ask them whether they want to continue running
6201         // the content. Only if they say &quot;yes&quot; should we start
6202         // attempting to restore the context.
6203         printToConsole(MessageLevel::Warning, &quot;WARNING: WebGL content on the page might have caused the graphics card to reset&quot;);
6204         break;
6205     }
6206 
6207     auto* canvas = htmlCanvas();
6208     if (!canvas)
6209         return;
6210 
6211     RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame();
6212     if (!frame)
6213         return;
6214 
6215     if (!frame-&gt;loader().client().allowWebGL(frame-&gt;settings().webGLEnabled()))
6216         return;
6217 
6218     RefPtr&lt;FrameView&gt; view = frame-&gt;view();
6219     if (!view)
6220         return;
6221     RefPtr&lt;ScrollView&gt; root = view-&gt;root();
6222     if (!root)
6223         return;
6224     HostWindow* hostWindow = root-&gt;hostWindow();
6225     if (!hostWindow)
6226         return;
6227 
<span class="line-modified">6228     RefPtr&lt;GraphicsContext3D&gt; context(GraphicsContext3D::create(m_attributes, hostWindow));</span>
6229     if (!context) {
6230         if (m_contextLostMode == RealLostContext)
6231             m_restoreTimer.startOneShot(secondsBetweenRestoreAttempts);
6232         else
6233             // This likely shouldn&#39;t happen but is the best way to report it to the WebGL app.
<span class="line-modified">6234             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;&quot;, &quot;error restoring context&quot;);</span>
6235         return;
6236     }
6237 
6238     m_context = context;
6239     addActivityStateChangeObserverIfNecessary();
6240     m_contextLost = false;
6241     setupFlags();
6242     initializeNewContext();
6243     initializeVertexArrayObjects();
6244     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextrestoredEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
6245 }
6246 
6247 void WebGLRenderingContextBase::simulateContextChanged()
6248 {
6249     if (m_context)
6250         m_context-&gt;simulateContextChanged();
6251 }
6252 
6253 String WebGLRenderingContextBase::ensureNotNull(const String&amp; text) const
6254 {
</pre>
<hr />
<pre>
6260 WebGLRenderingContextBase::LRUImageBufferCache::LRUImageBufferCache(int capacity)
6261     : m_buffers(capacity)
6262 {
6263 }
6264 
6265 ImageBuffer* WebGLRenderingContextBase::LRUImageBufferCache::imageBuffer(const IntSize&amp; size)
6266 {
6267     size_t i;
6268     for (i = 0; i &lt; m_buffers.size(); ++i) {
6269         ImageBuffer* buf = m_buffers[i].get();
6270         if (!buf)
6271             break;
6272         if (buf-&gt;logicalSize() != size)
6273             continue;
6274         bubbleToFront(i);
6275         buf-&gt;context().clearRect(FloatRect({ }, FloatSize(size)));
6276         return buf;
6277     }
6278 
6279     // FIXME (149423): Should this ImageBuffer be unconditionally unaccelerated?
<span class="line-modified">6280     std::unique_ptr&lt;ImageBuffer&gt; temp = ImageBuffer::create(size, Unaccelerated);</span>
6281     if (!temp)
6282         return nullptr;
6283     ASSERT(m_buffers.size() &gt; 0);
6284     i = std::min(m_buffers.size() - 1, i);
6285     m_buffers[i] = WTFMove(temp);
6286 
6287     ImageBuffer* buf = m_buffers[i].get();
6288     bubbleToFront(i);
6289     return buf;
6290 }
6291 
6292 void WebGLRenderingContextBase::LRUImageBufferCache::bubbleToFront(size_t idx)
6293 {
6294     for (size_t i = idx; i &gt; 0; --i)
6295         m_buffers[i].swap(m_buffers[i-1]);
6296 }
6297 
6298 namespace {
6299 
<span class="line-modified">6300     String GetErrorString(GC3Denum error)</span>
6301     {
6302         switch (error) {
<span class="line-modified">6303         case GraphicsContext3D::INVALID_ENUM:</span>
6304             return &quot;INVALID_ENUM&quot;_s;
<span class="line-modified">6305         case GraphicsContext3D::INVALID_VALUE:</span>
6306             return &quot;INVALID_VALUE&quot;_s;
<span class="line-modified">6307         case GraphicsContext3D::INVALID_OPERATION:</span>
6308             return &quot;INVALID_OPERATION&quot;_s;
<span class="line-modified">6309         case GraphicsContext3D::OUT_OF_MEMORY:</span>
6310             return &quot;OUT_OF_MEMORY&quot;_s;
<span class="line-modified">6311         case GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION:</span>
6312             return &quot;INVALID_FRAMEBUFFER_OPERATION&quot;_s;
<span class="line-modified">6313         case GraphicsContext3D::CONTEXT_LOST_WEBGL:</span>
6314             return &quot;CONTEXT_LOST_WEBGL&quot;_s;
6315         default:
6316             return makeString(&quot;WebGL ERROR(&quot;, hex(error, 4, Lowercase), &#39;)&#39;);
6317         }
6318     }
6319 
6320 } // namespace anonymous
6321 
<span class="line-modified">6322 void WebGLRenderingContextBase::synthesizeGLError(GC3Denum error, const char* functionName, const char* description, ConsoleDisplayPreference display)</span>
6323 {
6324     if (m_synthesizedErrorsToConsole &amp;&amp; display == DisplayInConsole) {
6325         String str = &quot;WebGL: &quot; + GetErrorString(error) +  &quot;: &quot; + String(functionName) + &quot;: &quot; + String(description);
6326         printToConsole(MessageLevel::Error, str);
6327     }
6328     m_context-&gt;synthesizeGLError(error);
6329 }
6330 
6331 void WebGLRenderingContextBase::applyStencilTest()
6332 {
6333     bool haveStencilBuffer = false;
6334 
6335     if (m_framebufferBinding)
6336         haveStencilBuffer = m_framebufferBinding-&gt;hasStencilBuffer();
6337     else {
6338         auto attributes = getContextAttributes();
6339         ASSERT(attributes);
6340         haveStencilBuffer = attributes-&gt;stencil;
6341     }
<span class="line-modified">6342     enableOrDisable(GraphicsContext3D::STENCIL_TEST, m_stencilEnabled &amp;&amp; haveStencilBuffer);</span>
6343 }
6344 
<span class="line-modified">6345 void WebGLRenderingContextBase::enableOrDisable(GC3Denum capability, bool enable)</span>
6346 {
6347     if (enable)
6348         m_context-&gt;enable(capability);
6349     else
6350         m_context-&gt;disable(capability);
6351 }
6352 
6353 IntSize WebGLRenderingContextBase::clampedCanvasSize()
6354 {
6355     return IntSize(clamp(canvasBase().width(), 1, m_maxViewportDims[0]),
6356         clamp(canvasBase().height(), 1, m_maxViewportDims[1]));
6357 }
6358 
<span class="line-modified">6359 GC3Dint WebGLRenderingContextBase::getMaxDrawBuffers()</span>
6360 {
6361     if (!supportsDrawBuffers())
6362         return 0;
6363     if (!m_maxDrawBuffers)
<span class="line-modified">6364         m_context-&gt;getIntegerv(Extensions3D::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);</span>
6365     if (!m_maxColorAttachments)
<span class="line-modified">6366         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
6367     // WEBGL_draw_buffers requires MAX_COLOR_ATTACHMENTS &gt;= MAX_DRAW_BUFFERS.
6368     return std::min(m_maxDrawBuffers, m_maxColorAttachments);
6369 }
6370 
<span class="line-modified">6371 GC3Dint WebGLRenderingContextBase::getMaxColorAttachments()</span>
6372 {
6373     if (!supportsDrawBuffers())
6374         return 0;
6375     if (!m_maxColorAttachments)
<span class="line-modified">6376         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
6377     return m_maxColorAttachments;
6378 }
6379 
<span class="line-modified">6380 void WebGLRenderingContextBase::setBackDrawBuffer(GC3Denum buf)</span>
6381 {
6382     m_backDrawBuffer = buf;
6383 }
6384 
6385 void WebGLRenderingContextBase::restoreCurrentFramebuffer()
6386 {
<span class="line-modified">6387     bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebufferBinding.get());</span>
6388 }
6389 
6390 void WebGLRenderingContextBase::restoreCurrentTexture2D()
6391 {
6392     auto texture = m_textureUnits[m_activeTextureUnit].texture2DBinding.get();
<span class="line-modified">6393     bindTexture(GraphicsContext3D::TEXTURE_2D, texture);</span>
6394     if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
6395         m_unrenderableTextureUnits.add(m_activeTextureUnit);
6396 }
6397 
6398 bool WebGLRenderingContextBase::supportsDrawBuffers()
6399 {
6400     if (!m_drawBuffersWebGLRequirementsChecked) {
6401         m_drawBuffersWebGLRequirementsChecked = true;
6402         m_drawBuffersSupported = WebGLDrawBuffers::supported(*this);
6403     }
6404     return m_drawBuffersSupported;
6405 }
6406 
<span class="line-modified">6407 void WebGLRenderingContextBase::drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount)</span>
6408 {
6409     if (!primcount) {
6410         markContextChanged();
6411         return;
6412     }
6413 
6414     if (!validateDrawArrays(&quot;drawArraysInstanced&quot;, mode, first, count, primcount))
6415         return;
6416 
6417     clearIfComposited();
6418 
6419     bool vertexAttrib0Simulated = false;
6420     if (!isGLES2Compliant()) {
6421         auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
6422         if (!simulateVertexAttrib0Status) {
6423             // We were unable to simulate the attribute buffer.
<span class="line-modified">6424             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
6425             return;
6426         }
6427         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
6428     }
6429     if (!isGLES2NPOTStrict())
6430         checkTextureCompleteness(&quot;drawArraysInstanced&quot;, true);
6431 
6432     m_context-&gt;drawArraysInstanced(mode, first, count, primcount);
6433 
6434     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
6435         restoreStatesAfterVertexAttrib0Simulation();
6436     if (!isGLES2NPOTStrict())
6437         checkTextureCompleteness(&quot;drawArraysInstanced&quot;, false);
6438     markContextChangedAndNotifyCanvasObserver();
6439 }
6440 
<span class="line-modified">6441 void WebGLRenderingContextBase::drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, GC3Dsizei primcount)</span>
6442 {
6443     if (!primcount) {
6444         markContextChanged();
6445         return;
6446     }
6447 
6448     unsigned numElements = 0;
6449     if (!validateDrawElements(&quot;drawElementsInstanced&quot;, mode, count, type, offset, numElements, primcount))
6450         return;
6451 
6452     clearIfComposited();
6453 
6454     bool vertexAttrib0Simulated = false;
6455     if (!isGLES2Compliant()) {
6456         if (!numElements)
<span class="line-modified">6457             validateIndexArrayPrecise(count, type, static_cast&lt;GC3Dintptr&gt;(offset), numElements);</span>
6458         auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
6459         if (!simulateVertexAttrib0Status) {
6460             // We were unable to simulate the attribute buffer.
<span class="line-modified">6461             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
6462             return;
6463         }
6464         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
6465     }
6466     if (!isGLES2NPOTStrict())
6467         checkTextureCompleteness(&quot;drawElementsInstanced&quot;, true);
6468 
6469 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
6470     if (isWebGL2())
6471         m_context-&gt;primitiveRestartIndex(getRestartIndex(type));
6472 #endif
6473 
<span class="line-modified">6474     m_context-&gt;drawElementsInstanced(mode, count, type, static_cast&lt;GC3Dintptr&gt;(offset), primcount);</span>
6475 
6476     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
6477         restoreStatesAfterVertexAttrib0Simulation();
6478     if (!isGLES2NPOTStrict())
6479         checkTextureCompleteness(&quot;drawElementsInstanced&quot;, false);
6480     markContextChangedAndNotifyCanvasObserver();
6481 }
6482 
<span class="line-modified">6483 void WebGLRenderingContextBase::vertexAttribDivisor(GC3Duint index, GC3Duint divisor)</span>
6484 {
6485     if (isContextLostOrPending())
6486         return;
6487 
6488     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">6489         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribDivisor&quot;, &quot;index out of range&quot;);</span>
6490         return;
6491     }
6492 
6493     m_boundVertexArrayObject-&gt;setVertexAttribDivisor(index, divisor);
6494     m_context-&gt;vertexAttribDivisor(index, divisor);
6495 }
6496 
6497 bool WebGLRenderingContextBase::enableSupportedExtension(ASCIILiteral extensionNameLiteral)
6498 {
6499     ASSERT(m_context);
6500     auto&amp; extensions = m_context-&gt;getExtensions();
6501     String extensionName { extensionNameLiteral };
6502     if (!extensions.supports(extensionName))
6503         return false;
6504     extensions.ensureEnabled(extensionName);
6505     return true;
6506 }
6507 
6508 void WebGLRenderingContextBase::activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState)
6509 {
</pre>
<hr />
<pre>
6523     m_context-&gt;setFailNextGPUStatusCheck();
6524 }
6525 
6526 void WebGLRenderingContextBase::didComposite()
6527 {
6528     if (UNLIKELY(callTracingActive()))
6529         InspectorInstrumentation::didFinishRecordingCanvasFrame(*this);
6530 }
6531 
6532 void WebGLRenderingContextBase::forceContextLost()
6533 {
6534     forceLostContext(WebGLRenderingContextBase::RealLostContext);
6535 }
6536 
6537 void WebGLRenderingContextBase::recycleContext()
6538 {
6539     printToConsole(MessageLevel::Error, &quot;There are too many active WebGL contexts on this page, the oldest context will be lost.&quot;);
6540     // Using SyntheticLostContext means the developer won&#39;t be able to force the restoration
6541     // of the context by calling preventDefault() in a &quot;webglcontextlost&quot; event handler.
6542     forceLostContext(SyntheticLostContext);
<span class="line-modified">6543     destroyGraphicsContext3D();</span>
6544 }
6545 
6546 void WebGLRenderingContextBase::dispatchContextChangedNotification()
6547 {







6548     auto* canvas = htmlCanvas();
6549     if (!canvas)
6550         return;
6551 
6552     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextchangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
6553 }
6554 
6555 
6556 } // namespace WebCore
6557 
6558 #endif // ENABLE(WEBGL)
</pre>
</td>
<td>
<hr />
<pre>
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WebGLRenderingContextBase.h&quot;
  28 
  29 #if ENABLE(WEBGL)
  30 
  31 #include &quot;ANGLEInstancedArrays.h&quot;
  32 #include &quot;CachedImage.h&quot;
  33 #include &quot;DOMWindow.h&quot;
  34 #include &quot;DiagnosticLoggingClient.h&quot;
  35 #include &quot;DiagnosticLoggingKeys.h&quot;
  36 #include &quot;Document.h&quot;
  37 #include &quot;EXTBlendMinMax.h&quot;
  38 #include &quot;EXTFragDepth.h&quot;
  39 #include &quot;EXTShaderTextureLOD.h&quot;
  40 #include &quot;EXTTextureFilterAnisotropic.h&quot;
  41 #include &quot;EXTsRGB.h&quot;
  42 #include &quot;EventNames.h&quot;
<span class="line-modified">  43 #include &quot;ExtensionsGL.h&quot;</span>
  44 #include &quot;Frame.h&quot;
  45 #include &quot;FrameLoader.h&quot;
  46 #include &quot;FrameLoaderClient.h&quot;
  47 #include &quot;FrameView.h&quot;
  48 #include &quot;GraphicsContext.h&quot;
  49 #include &quot;HTMLCanvasElement.h&quot;
  50 #include &quot;HTMLImageElement.h&quot;
  51 #include &quot;HTMLVideoElement.h&quot;
  52 #include &quot;ImageBuffer.h&quot;
  53 #include &quot;ImageData.h&quot;
  54 #include &quot;InspectorInstrumentation.h&quot;
  55 #include &quot;IntSize.h&quot;
  56 #include &quot;JSExecState.h&quot;
  57 #include &quot;Logging.h&quot;
  58 #include &quot;NotImplemented.h&quot;
  59 #include &quot;OESElementIndexUint.h&quot;
  60 #include &quot;OESStandardDerivatives.h&quot;
  61 #include &quot;OESTextureFloat.h&quot;
  62 #include &quot;OESTextureFloatLinear.h&quot;
  63 #include &quot;OESTextureHalfFloat.h&quot;
  64 #include &quot;OESTextureHalfFloatLinear.h&quot;
  65 #include &quot;OESVertexArrayObject.h&quot;

  66 #include &quot;Page.h&quot;
  67 #include &quot;RenderBox.h&quot;
  68 #include &quot;RuntimeEnabledFeatures.h&quot;
  69 #include &quot;Settings.h&quot;
  70 #include &quot;WebGL2RenderingContext.h&quot;
  71 #include &quot;WebGLActiveInfo.h&quot;
  72 #include &quot;WebGLBuffer.h&quot;
  73 #include &quot;WebGLCompressedTextureASTC.h&quot;
  74 #include &quot;WebGLCompressedTextureATC.h&quot;
<span class="line-added">  75 #include &quot;WebGLCompressedTextureETC.h&quot;</span>
<span class="line-added">  76 #include &quot;WebGLCompressedTextureETC1.h&quot;</span>
  77 #include &quot;WebGLCompressedTexturePVRTC.h&quot;
  78 #include &quot;WebGLCompressedTextureS3TC.h&quot;
  79 #include &quot;WebGLContextAttributes.h&quot;
  80 #include &quot;WebGLContextEvent.h&quot;
  81 #include &quot;WebGLContextGroup.h&quot;
  82 #include &quot;WebGLDebugRendererInfo.h&quot;
  83 #include &quot;WebGLDebugShaders.h&quot;
  84 #include &quot;WebGLDepthTexture.h&quot;
  85 #include &quot;WebGLDrawBuffers.h&quot;
  86 #include &quot;WebGLFramebuffer.h&quot;
  87 #include &quot;WebGLLoseContext.h&quot;
  88 #include &quot;WebGLProgram.h&quot;
  89 #include &quot;WebGLRenderbuffer.h&quot;
  90 #include &quot;WebGLRenderingContext.h&quot;
  91 #include &quot;WebGLShader.h&quot;
  92 #include &quot;WebGLShaderPrecisionFormat.h&quot;
  93 #include &quot;WebGLTexture.h&quot;
  94 #include &quot;WebGLUniformLocation.h&quot;
  95 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
  96 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  97 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  98 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  99 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
 100 #include &lt;JavaScriptCore/Uint32Array.h&gt;
 101 #include &lt;wtf/CheckedArithmetic.h&gt;
 102 #include &lt;wtf/HashMap.h&gt;
 103 #include &lt;wtf/HexNumber.h&gt;
 104 #include &lt;wtf/IsoMallocInlines.h&gt;
 105 #include &lt;wtf/Lock.h&gt;
 106 #include &lt;wtf/StdLibExtras.h&gt;
 107 #include &lt;wtf/UniqueArray.h&gt;
 108 #include &lt;wtf/text/CString.h&gt;
 109 #include &lt;wtf/text/StringBuilder.h&gt;
 110 
<span class="line-added"> 111 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 112 #include &quot;OffscreenCanvas.h&quot;</span>
<span class="line-added"> 113 #endif</span>
<span class="line-added"> 114 </span>
 115 namespace WebCore {
 116 
 117 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGLRenderingContextBase);
 118 
 119 static const Seconds secondsBetweenRestoreAttempts { 1_s };
 120 const int maxGLErrorsAllowedToConsole = 256;
 121 static const Seconds checkContextLossHandlingDelay { 3_s };
 122 
 123 namespace {
 124 
<span class="line-modified"> 125     GCGLint clamp(GCGLint value, GCGLint min, GCGLint max)</span>
 126     {
 127         if (value &lt; min)
 128             value = min;
 129         if (value &gt; max)
 130             value = max;
 131         return value;
 132     }
 133 
 134     // Return true if a character belongs to the ASCII subset as defined in
 135     // GLSL ES 1.0 spec section 3.1.
 136     bool validateCharacter(unsigned char c)
 137     {
 138         // Printing characters are valid except &quot; $ ` @ \ &#39; DEL.
 139         if (c &gt;= 32 &amp;&amp; c &lt;= 126
 140             &amp;&amp; c != &#39;&quot;&#39; &amp;&amp; c != &#39;$&#39; &amp;&amp; c != &#39;`&#39; &amp;&amp; c != &#39;@&#39; &amp;&amp; c != &#39;\\&#39; &amp;&amp; c != &#39;\&#39;&#39;)
 141             return true;
 142         // Horizontal tab, line feed, vertical tab, form feed, carriage return
 143         // are also valid.
 144         if (c &gt;= 9 &amp;&amp; c &lt;= 13)
 145             return true;
</pre>
<hr />
<pre>
 322             break;
 323 
 324         case InMultiLineComment:
 325             if (c == &#39;*&#39; &amp;&amp; peek(temp) &amp;&amp; temp == &#39;/&#39;) {
 326                 emit(&#39;*&#39;);
 327                 emit(&#39;/&#39;);
 328                 m_parseState = MiddleOfLine;
 329                 advance();
 330                 break;
 331             }
 332 
 333             // Swallow all other characters. Unclear whether we may
 334             // want or need to just emit a space per character to try
 335             // to preserve column numbers for debugging purposes.
 336             break;
 337         }
 338     }
 339 } // namespace anonymous
 340 
 341 // Returns false if no clipping is necessary, i.e., x, y, width, height stay the same.
<span class="line-modified"> 342 static bool clip2D(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height,</span>
<span class="line-modified"> 343     GCGLsizei sourceWidth, GCGLsizei sourceHeight,</span>
<span class="line-modified"> 344     GCGLint* clippedX, GCGLint* clippedY, GCGLsizei* clippedWidth, GCGLsizei*clippedHeight)</span>
 345 {
 346     ASSERT(clippedX &amp;&amp; clippedY &amp;&amp; clippedWidth &amp;&amp; clippedHeight);
 347 
<span class="line-modified"> 348     GCGLint left = std::max(x, 0);</span>
<span class="line-modified"> 349     GCGLint top = std::max(y, 0);</span>
<span class="line-modified"> 350     GCGLint right = 0;</span>
<span class="line-modified"> 351     GCGLint bottom = 0;</span>
 352 
<span class="line-modified"> 353     Checked&lt;GCGLint, RecordOverflow&gt; checkedInputRight = Checked&lt;GCGLint&gt;(x) + Checked&lt;GCGLsizei&gt;(width);</span>
<span class="line-modified"> 354     Checked&lt;GCGLint, RecordOverflow&gt; checkedInputBottom = Checked&lt;GCGLint&gt;(y) + Checked&lt;GCGLsizei&gt;(height);</span>
 355     if (!checkedInputRight.hasOverflowed() &amp;&amp; !checkedInputBottom.hasOverflowed()) {
 356         right = std::min(checkedInputRight.unsafeGet(), sourceWidth);
 357         bottom = std::min(checkedInputBottom.unsafeGet(), sourceHeight);
 358     }
 359 
 360     if (left &gt;= right || top &gt;= bottom) {
 361         *clippedX = 0;
 362         *clippedY = 0;
 363         *clippedWidth = 0;
 364         *clippedHeight = 0;
 365         return true;
 366     }
 367 
 368     *clippedX = left;
 369     *clippedY = top;
 370     *clippedWidth = right - left;
 371     *clippedHeight = bottom - top;
 372 
 373     return (*clippedX != x || *clippedY != y || *clippedWidth != width || *clippedHeight != height);
 374 }
 375 


























 376 class InspectorScopedShaderProgramHighlight {
 377 public:
 378     InspectorScopedShaderProgramHighlight(WebGLRenderingContextBase&amp; context, WebGLProgram* program)
 379         : m_context(context)
 380         , m_program(program)
 381     {
 382         showHightlight();
 383     }
 384 
 385     ~InspectorScopedShaderProgramHighlight()
 386     {
 387         hideHighlight();
 388     }
 389 
 390 private:
 391     void showHightlight()
 392     {
<span class="line-modified"> 393         if (!m_program || LIKELY(!InspectorInstrumentation::isWebGLProgramHighlighted(m_context, *m_program)))</span>
 394             return;
 395 
<span class="line-modified"> 396         if (hasBufferBinding(GraphicsContextGL::FRAMEBUFFER_BINDING)) {</span>
<span class="line-modified"> 397             if (!hasBufferBinding(GraphicsContextGL::RENDERBUFFER_BINDING))</span>
 398                 return;
<span class="line-modified"> 399             if (hasFramebufferParameterAttachment(GraphicsContextGL::DEPTH_ATTACHMENT))</span>
 400                 return;
<span class="line-modified"> 401             if (hasFramebufferParameterAttachment(GraphicsContextGL::STENCIL_ATTACHMENT))</span>
 402                 return;
 403 #if ENABLE(WEBGL2)
<span class="line-modified"> 404             if (hasFramebufferParameterAttachment(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT))</span>
 405                 return;
 406 #endif
 407         }
 408 
<span class="line-modified"> 409         saveBlendValue(GraphicsContextGL::BLEND_COLOR, m_savedBlend.color);</span>
<span class="line-modified"> 410         saveBlendValue(GraphicsContextGL::BLEND_EQUATION_RGB, m_savedBlend.equationRGB);</span>
<span class="line-modified"> 411         saveBlendValue(GraphicsContextGL::BLEND_EQUATION_ALPHA, m_savedBlend.equationAlpha);</span>
<span class="line-modified"> 412         saveBlendValue(GraphicsContextGL::BLEND_SRC_RGB, m_savedBlend.srcRGB);</span>
<span class="line-modified"> 413         saveBlendValue(GraphicsContextGL::BLEND_SRC_ALPHA, m_savedBlend.srcAlpha);</span>
<span class="line-modified"> 414         saveBlendValue(GraphicsContextGL::BLEND_DST_RGB, m_savedBlend.dstRGB);</span>
<span class="line-modified"> 415         saveBlendValue(GraphicsContextGL::BLEND_DST_ALPHA, m_savedBlend.dstAlpha);</span>
<span class="line-modified"> 416         saveBlendValue(GraphicsContextGL::BLEND, m_savedBlend.enabled);</span>
<span class="line-modified"> 417 </span>
<span class="line-modified"> 418         static const GCGLfloat red = 111.0 / 255.0;</span>
<span class="line-modified"> 419         static const GCGLfloat green = 168.0 / 255.0;</span>
<span class="line-modified"> 420         static const GCGLfloat blue = 220.0 / 255.0;</span>
<span class="line-modified"> 421         static const GCGLfloat alpha = 2.0 / 3.0;</span>
<span class="line-modified"> 422 </span>
<span class="line-modified"> 423         m_context.enable(GraphicsContextGL::BLEND);</span>
 424         m_context.blendColor(red, green, blue, alpha);
<span class="line-modified"> 425         m_context.blendEquation(GraphicsContextGL::FUNC_ADD);</span>
<span class="line-modified"> 426         m_context.blendFunc(GraphicsContextGL::CONSTANT_COLOR, GraphicsContextGL::ONE_MINUS_SRC_ALPHA);</span>
 427 
 428         m_didApply = true;
 429     }
 430 
 431     void hideHighlight()
 432     {
 433         if (!m_didApply)
 434             return;
 435 
 436         if (!m_savedBlend.enabled)
<span class="line-modified"> 437             m_context.disable(GraphicsContextGL::BLEND);</span>
 438 
 439         const RefPtr&lt;Float32Array&gt;&amp; color = m_savedBlend.color;
 440         m_context.blendColor(color-&gt;item(0), color-&gt;item(1), color-&gt;item(2), color-&gt;item(3));
 441         m_context.blendEquationSeparate(m_savedBlend.equationRGB, m_savedBlend.equationAlpha);
 442         m_context.blendFuncSeparate(m_savedBlend.srcRGB, m_savedBlend.dstRGB, m_savedBlend.srcAlpha, m_savedBlend.dstAlpha);
 443 
 444         m_savedBlend.color = nullptr;
 445 
 446         m_didApply = false;
 447     }
 448 
 449     template &lt;typename T&gt;
<span class="line-modified"> 450     void saveBlendValue(GCGLenum attachment, T&amp; destination)</span>
 451     {
 452         WebGLAny param = m_context.getParameter(attachment);
 453         if (WTF::holds_alternative&lt;T&gt;(param))
 454             destination = WTF::get&lt;T&gt;(param);
 455     }
 456 
<span class="line-modified"> 457     bool hasBufferBinding(GCGLenum pname)</span>
 458     {
 459         WebGLAny binding = m_context.getParameter(pname);
<span class="line-modified"> 460         if (pname == GraphicsContextGL::FRAMEBUFFER_BINDING)</span>
 461             return WTF::holds_alternative&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding);
<span class="line-modified"> 462         if (pname == GraphicsContextGL::RENDERBUFFER_BINDING)</span>
 463             return WTF::holds_alternative&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding);
 464         return false;
 465     }
 466 
<span class="line-modified"> 467     bool hasFramebufferParameterAttachment(GCGLenum attachment)</span>
 468     {
<span class="line-modified"> 469         WebGLAny attachmentParameter = m_context.getFramebufferAttachmentParameter(GraphicsContextGL::FRAMEBUFFER, attachment, GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE);</span>
 470         if (!WTF::holds_alternative&lt;unsigned&gt;(attachmentParameter))
 471             return false;
<span class="line-modified"> 472         if (WTF::get&lt;unsigned&gt;(attachmentParameter) != static_cast&lt;unsigned&gt;(GraphicsContextGL::RENDERBUFFER))</span>
 473             return false;
 474         return true;
 475     }
 476 
 477     struct {
 478         RefPtr&lt;Float32Array&gt; color;
 479         unsigned equationRGB { 0 };
 480         unsigned equationAlpha { 0 };
 481         unsigned srcRGB { 0 };
 482         unsigned srcAlpha { 0 };
 483         unsigned dstRGB { 0 };
 484         unsigned dstAlpha { 0 };
 485         bool enabled { false };
 486     } m_savedBlend;
 487 
 488     WebGLRenderingContextBase&amp; m_context;
 489     WebGLProgram* m_program { nullptr };
 490     bool m_didApply { false };
 491 };
 492 
<span class="line-modified"> 493 static bool isHighPerformanceContext(const RefPtr&lt;GraphicsContextGLOpenGL&gt;&amp; context)</span>
 494 {
 495     return context-&gt;powerPreferenceUsedForCreation() == WebGLPowerPreference::HighPerformance;
 496 }
 497 
 498 std::unique_ptr&lt;WebGLRenderingContextBase&gt; WebGLRenderingContextBase::create(CanvasBase&amp; canvas, WebGLContextAttributes&amp; attributes, const String&amp; type)
 499 {
 500 #if ENABLE(WEBGL2)
 501     if (type == &quot;webgl2&quot; &amp;&amp; !RuntimeEnabledFeatures::sharedFeatures().webGL2Enabled())
 502         return nullptr;
 503 #else
 504     UNUSED_PARAM(type);
 505 #endif
 506 
 507     bool isPendingPolicyResolution = false;
 508     HostWindow* hostWindow = nullptr;
 509 
 510     auto* canvasElement = is&lt;HTMLCanvasElement&gt;(canvas) ? &amp;downcast&lt;HTMLCanvasElement&gt;(canvas) : nullptr;
 511 
 512     if (canvasElement) {
 513         Document&amp; document = canvasElement-&gt;document();
</pre>
<hr />
<pre>
 525 
 526         Document&amp; topDocument = document.topDocument();
 527         Page* page = topDocument.page();
 528         bool forcingPendingPolicy = frame-&gt;settings().isForcePendingWebGLPolicy();
 529 
 530         if (forcingPendingPolicy || (page &amp;&amp; !topDocument.url().isLocalFile())) {
 531             WebGLLoadPolicy policy = forcingPendingPolicy ? WebGLPendingCreation : page-&gt;mainFrame().loader().client().webGLPolicyForURL(topDocument.url());
 532 
 533             if (policy == WebGLBlockCreation) {
 534                 LOG(WebGL, &quot;The policy for this URL (%s) is to block WebGL.&quot;, topDocument.url().host().utf8().data());
 535                 return nullptr;
 536             }
 537 
 538             if (policy == WebGLPendingCreation) {
 539                 LOG(WebGL, &quot;WebGL policy is pending. May need to be resolved later.&quot;);
 540                 isPendingPolicyResolution = true;
 541             }
 542         }
 543 
 544         if (frame-&gt;settings().forceWebGLUsesLowPower()) {
<span class="line-modified"> 545             if (attributes.powerPreference == GraphicsContextGLPowerPreference::HighPerformance)</span>
 546                 LOG(WebGL, &quot;Overriding powerPreference from high-performance to low-power.&quot;);
<span class="line-modified"> 547             attributes.powerPreference = GraphicsContextGLPowerPreference::LowPower;</span>
 548         }
 549 
 550         if (page)
 551             attributes.devicePixelRatio = page-&gt;deviceScaleFactor();
 552 
 553         hostWindow = document.view()-&gt;root()-&gt;hostWindow();
 554     }
 555 
 556     attributes.noExtensions = true;
 557     attributes.shareResources = false;
 558 
 559     attributes.initialPowerPreference = attributes.powerPreference;
 560 
 561 
 562 #if ENABLE(WEBGL2)
 563     if (type == &quot;webgl2&quot;)
 564         attributes.isWebGL2 = true;
 565 #endif
 566 
 567     if (isPendingPolicyResolution) {
 568         LOG(WebGL, &quot;Create a WebGL context that looks real, but will require a policy resolution if used.&quot;);
 569         std::unique_ptr&lt;WebGLRenderingContextBase&gt; renderingContext = nullptr;
 570 #if ENABLE(WEBGL2)
 571         if (type == &quot;webgl2&quot;)
 572             renderingContext = WebGL2RenderingContext::create(canvas, attributes);
 573         else
 574 #endif
 575             renderingContext = WebGLRenderingContext::create(canvas, attributes);
 576         renderingContext-&gt;suspendIfNeeded();
 577         return renderingContext;
 578     }
 579 
<span class="line-modified"> 580     auto context = GraphicsContextGLOpenGL::create(attributes, hostWindow);</span>
 581     if (!context || !context-&gt;makeContextCurrent()) {
 582         if (canvasElement) {
 583             canvasElement-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextcreationerrorEvent,
 584                 Event::CanBubble::No, Event::IsCancelable::Yes, &quot;Could not create a WebGL context.&quot;));
 585         }
 586         return nullptr;
 587     }
 588 
 589     auto&amp; extensions = context-&gt;getExtensions();
 590     if (extensions.supports(&quot;GL_EXT_debug_marker&quot;_s))
 591         extensions.pushGroupMarkerEXT(&quot;WebGLRenderingContext&quot;_s);
 592 
<span class="line-modified"> 593 #if ENABLE(WEBGL2) &amp;&amp; PLATFORM(MAC) &amp;&amp; !USE(ANGLE)</span>
 594     // glTexStorage() was only added to Core in OpenGL 4.2.
 595     // However, according to https://developer.apple.com/opengl/capabilities/ all Apple GPUs support this extension.
 596     if (attributes.isWebGL2 &amp;&amp; !extensions.supports(&quot;GL_ARB_texture_storage&quot;))
 597         return nullptr;
 598 #endif
 599 
 600     std::unique_ptr&lt;WebGLRenderingContextBase&gt; renderingContext;
 601 #if ENABLE(WEBGL2)
 602     if (type == &quot;webgl2&quot;)
 603         renderingContext = WebGL2RenderingContext::create(canvas, context.releaseNonNull(), attributes);
 604     else
 605 #endif
 606         renderingContext = WebGLRenderingContext::create(canvas, context.releaseNonNull(), attributes);
 607     renderingContext-&gt;suspendIfNeeded();
 608 
 609     return renderingContext;
 610 }
 611 
 612 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, WebGLContextAttributes attributes)
 613     : GPUBasedCanvasRenderingContext(canvas)
<span class="line-modified"> 614     , m_dispatchContextLostEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)</span>
<span class="line-modified"> 615     , m_dispatchContextChangedEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextChangedEvent)</span>
<span class="line-added"> 616     , m_restoreTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::maybeRestoreContext)</span>
 617     , m_attributes(attributes)
 618     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 619     , m_isPendingPolicyResolution(true)
 620     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 621 {
<span class="line-added"> 622     m_dispatchContextLostEventTimer.suspendIfNeeded();</span>
<span class="line-added"> 623     m_dispatchContextChangedEventTimer.suspendIfNeeded();</span>
<span class="line-added"> 624     m_restoreTimer.suspendIfNeeded();</span>
<span class="line-added"> 625 </span>
 626     registerWithWebGLStateTracker();
 627     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 628 }
 629 
<span class="line-modified"> 630 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, WebGLContextAttributes attributes)</span>
 631     : GPUBasedCanvasRenderingContext(canvas)
 632     , m_context(WTFMove(context))
<span class="line-modified"> 633     , m_dispatchContextLostEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)</span>
<span class="line-modified"> 634     , m_dispatchContextChangedEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextChangedEvent)</span>
<span class="line-added"> 635     , m_restoreTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::maybeRestoreContext)</span>
 636     , m_generatedImageCache(4)
 637     , m_attributes(attributes)
 638     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 639     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 640 {
<span class="line-added"> 641     m_dispatchContextLostEventTimer.suspendIfNeeded();</span>
<span class="line-added"> 642     m_dispatchContextChangedEventTimer.suspendIfNeeded();</span>
<span class="line-added"> 643     m_restoreTimer.suspendIfNeeded();</span>
<span class="line-added"> 644 </span>
 645     m_contextGroup = WebGLContextGroup::create();
 646     m_contextGroup-&gt;addContext(*this);
 647 
 648     m_context-&gt;addClient(*this);
 649 
<span class="line-modified"> 650     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_VIEWPORT_DIMS, m_maxViewportDims);</span>
 651 
 652     setupFlags();
 653     initializeNewContext();
 654     registerWithWebGLStateTracker();
 655     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 656 
 657     addActivityStateChangeObserverIfNecessary();
 658 }
 659 
 660 WebGLCanvas WebGLRenderingContextBase::canvas()
 661 {
 662     auto&amp; base = canvasBase();
<span class="line-added"> 663 #if ENABLE(OFFSCREEN_CANVAS)</span>
 664     if (is&lt;OffscreenCanvas&gt;(base))
 665         return &amp;downcast&lt;OffscreenCanvas&gt;(base);
<span class="line-added"> 666 #endif</span>
 667     return &amp;downcast&lt;HTMLCanvasElement&gt;(base);
 668 }
 669 
<span class="line-added"> 670 #if ENABLE(OFFSCREEN_CANVAS)</span>
 671 OffscreenCanvas* WebGLRenderingContextBase::offscreenCanvas()
 672 {
 673     auto&amp; base = canvasBase();
 674     if (!is&lt;OffscreenCanvas&gt;(base))
 675         return nullptr;
 676     return &amp;downcast&lt;OffscreenCanvas&gt;(base);
 677 }
<span class="line-added"> 678 #endif</span>
 679 
 680 // We check for context loss handling after a few seconds to give the JS a chance to register the event listeners
 681 // and to discard temporary GL contexts (e.g. feature detection).
 682 void WebGLRenderingContextBase::checkForContextLossHandling()
 683 {
 684     auto canvas = htmlCanvas();
 685     if (!canvas)
 686         return;
 687 
 688     if (!canvas-&gt;renderer())
 689         return;
 690 
 691     auto* page = canvas-&gt;document().page();
 692     if (!page)
 693         return;
 694 
 695     bool handlesContextLoss = canvas-&gt;hasEventListeners(eventNames().webglcontextlostEvent) &amp;&amp; canvas-&gt;hasEventListeners(eventNames().webglcontextrestoredEvent);
 696     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::pageHandlesWebGLContextLossKey(), handlesContextLoss ? DiagnosticLoggingKeys::yesKey() : DiagnosticLoggingKeys::noKey(), ShouldSample::No);
 697 }
 698 
</pre>
<hr />
<pre>
 706     if (!page)
 707         return;
 708 
 709     auto* tracker = page-&gt;webGLStateTracker();
 710     if (!tracker)
 711         return;
 712 
 713     m_trackerToken = tracker-&gt;token(m_attributes.initialPowerPreference);
 714 }
 715 
 716 void WebGLRenderingContextBase::initializeNewContext()
 717 {
 718     ASSERT(!m_contextLost);
 719     m_needsUpdate = true;
 720     m_markedCanvasDirty = false;
 721     m_activeTextureUnit = 0;
 722     m_packAlignment = 4;
 723     m_unpackAlignment = 4;
 724     m_unpackFlipY = false;
 725     m_unpackPremultiplyAlpha = false;
<span class="line-modified"> 726     m_unpackColorspaceConversion = GraphicsContextGL::BROWSER_DEFAULT_WEBGL;</span>
 727     m_boundArrayBuffer = nullptr;
 728     m_currentProgram = nullptr;
 729     m_framebufferBinding = nullptr;
 730     m_readFramebufferBinding = nullptr;
 731     m_renderbufferBinding = nullptr;
 732     m_depthMask = true;
 733     m_stencilEnabled = false;
 734     m_stencilMask = 0xFFFFFFFF;
 735     m_stencilMaskBack = 0xFFFFFFFF;
 736     m_stencilFuncRef = 0;
 737     m_stencilFuncRefBack = 0;
 738     m_stencilFuncMask = 0xFFFFFFFF;
 739     m_stencilFuncMaskBack = 0xFFFFFFFF;
 740     m_layerCleared = false;
 741     m_numGLErrorsToConsoleAllowed = maxGLErrorsAllowedToConsole;
 742 
 743     m_clearColor[0] = m_clearColor[1] = m_clearColor[2] = m_clearColor[3] = 0;
 744     m_scissorEnabled = false;
 745     m_clearDepth = 1;
 746     m_clearStencil = 0;
 747     m_colorMask[0] = m_colorMask[1] = m_colorMask[2] = m_colorMask[3] = true;
 748 
<span class="line-modified"> 749     GCGLint numCombinedTextureImageUnits = 0;</span>
<span class="line-modified"> 750     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_COMBINED_TEXTURE_IMAGE_UNITS, &amp;numCombinedTextureImageUnits);</span>
 751     m_textureUnits.clear();
 752     m_textureUnits.resize(numCombinedTextureImageUnits);
<span class="line-modified"> 753     for (GCGLint i = 0; i &lt; numCombinedTextureImageUnits; ++i)</span>
 754         m_unrenderableTextureUnits.add(i);
 755 
<span class="line-modified"> 756     GCGLint numVertexAttribs = 0;</span>
<span class="line-modified"> 757     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_VERTEX_ATTRIBS, &amp;numVertexAttribs);</span>
 758     m_maxVertexAttribs = numVertexAttribs;
 759 
 760     m_maxTextureSize = 0;
<span class="line-modified"> 761     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_TEXTURE_SIZE, &amp;m_maxTextureSize);</span>
 762     m_maxTextureLevel = WebGLTexture::computeLevelCount(m_maxTextureSize, m_maxTextureSize);
 763     m_maxCubeMapTextureSize = 0;
<span class="line-modified"> 764     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_CUBE_MAP_TEXTURE_SIZE, &amp;m_maxCubeMapTextureSize);</span>
 765     m_maxCubeMapTextureLevel = WebGLTexture::computeLevelCount(m_maxCubeMapTextureSize, m_maxCubeMapTextureSize);
 766     m_maxRenderbufferSize = 0;
<span class="line-modified"> 767     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_RENDERBUFFER_SIZE, &amp;m_maxRenderbufferSize);</span>
 768 
 769     // These two values from EXT_draw_buffers are lazily queried.
 770     m_maxDrawBuffers = 0;
 771     m_maxColorAttachments = 0;
 772 
<span class="line-modified"> 773     m_backDrawBuffer = GraphicsContextGL::BACK;</span>
 774     m_drawBuffersWebGLRequirementsChecked = false;
 775     m_drawBuffersSupported = false;
 776 
 777     m_vertexAttribValue.resize(m_maxVertexAttribs);
 778 
 779     if (!isGLES2NPOTStrict())
 780         createFallbackBlackTextures1x1();
 781 
 782     IntSize canvasSize = clampedCanvasSize();
 783     m_context-&gt;reshape(canvasSize.width(), canvasSize.height());
 784     m_context-&gt;viewport(0, 0, canvasSize.width(), canvasSize.height());
 785     m_context-&gt;scissor(0, 0, canvasSize.width(), canvasSize.height());



 786 }
 787 
 788 void WebGLRenderingContextBase::setupFlags()
 789 {
 790     ASSERT(m_context);
 791 
 792     auto canvas = htmlCanvas();
 793     if (canvas) {
 794         if (Page* page = canvas-&gt;document().page())
 795             m_synthesizedErrorsToConsole = page-&gt;settings().webGLErrorsToConsoleEnabled();
 796     }
 797 
 798     m_isGLES2Compliant = m_context-&gt;isGLES2Compliant();
 799     if (m_isGLES2Compliant) {
 800         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_texture_npot&quot;);
<span class="line-modified"> 801         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_packed_depth_stencil&quot;) || m_context-&gt;getExtensions().isEnabled(&quot;GL_ANGLE_depth_texture&quot;);</span>
 802     } else {
 803         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_ARB_texture_non_power_of_two&quot;);
<span class="line-modified"> 804         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_packed_depth_stencil&quot;) || m_context-&gt;getExtensions().isEnabled(&quot;GL_ANGLE_depth_texture&quot;);</span>
 805     }
 806     m_isRobustnessEXTSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_robustness&quot;);
 807 }
 808 
<span class="line-modified"> 809 void WebGLRenderingContextBase::addCompressedTextureFormat(GCGLenum format)</span>
 810 {
 811     if (!m_compressedTextureFormats.contains(format))
 812         m_compressedTextureFormats.append(format);
 813 }
 814 
 815 void WebGLRenderingContextBase::addActivityStateChangeObserverIfNecessary()
 816 {
 817     // We are only interested in visibility changes for contexts
 818     // that are using the high-performance GPU.
 819     if (!isHighPerformanceContext(m_context))
 820         return;
 821 
 822     auto* canvas = htmlCanvas();
 823     if (!canvas)
 824         return;
 825 
 826     auto* page = canvas-&gt;document().page();
 827     if (!page)
 828         return;
 829 
</pre>
<hr />
<pre>
 850     // they will be freed before the last context is removed from the context group.
 851     m_boundArrayBuffer = nullptr;
 852     m_defaultVertexArrayObject = nullptr;
 853     m_boundVertexArrayObject = nullptr;
 854     m_vertexAttrib0Buffer = nullptr;
 855     m_currentProgram = nullptr;
 856     m_framebufferBinding = nullptr;
 857     m_readFramebufferBinding = nullptr;
 858     m_renderbufferBinding = nullptr;
 859 
 860     for (auto&amp; textureUnit : m_textureUnits) {
 861         textureUnit.texture2DBinding = nullptr;
 862         textureUnit.textureCubeMapBinding = nullptr;
 863     }
 864 
 865     m_blackTexture2D = nullptr;
 866     m_blackTextureCubeMap = nullptr;
 867 
 868     if (!m_isPendingPolicyResolution) {
 869         detachAndRemoveAllObjects();
<span class="line-modified"> 870         destroyGraphicsContextGL();</span>
 871         m_contextGroup-&gt;removeContext(*this);
 872     }
 873 
 874     {
 875         LockHolder lock(WebGLProgram::instancesMutex());
 876         for (auto&amp; entry : WebGLProgram::instances(lock)) {
 877             if (entry.value == this) {
 878                 // Don&#39;t remove any WebGLProgram from the instances list, as they may still exist.
 879                 // Only remove the association with a WebGL context.
 880                 entry.value = nullptr;
 881             }
 882         }
 883     }
 884 }
 885 
<span class="line-modified"> 886 void WebGLRenderingContextBase::destroyGraphicsContextGL()</span>
 887 {
 888     if (m_isPendingPolicyResolution)
 889         return;
 890 
 891     removeActivityStateChangeObserver();
 892 
 893     if (m_context) {
 894         m_context-&gt;removeClient(*this);


 895         m_context = nullptr;
 896     }
 897 }
 898 
 899 void WebGLRenderingContextBase::markContextChanged()
 900 {
 901     if (m_framebufferBinding)
 902         return;
 903 
 904     m_context-&gt;markContextChanged();
 905 
 906     m_layerCleared = false;
 907 
 908     auto* canvas = htmlCanvas();
 909     if (!canvas)
 910         return;
 911 
 912     RenderBox* renderBox = canvas-&gt;renderBox();
 913     if (isAccelerated() &amp;&amp; renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing()) {
 914         m_markedCanvasDirty = true;
</pre>
<hr />
<pre>
 920             canvas-&gt;didDraw(FloatRect(FloatPoint(0, 0), clampedCanvasSize()));
 921         }
 922     }
 923 }
 924 
 925 void WebGLRenderingContextBase::markContextChangedAndNotifyCanvasObserver()
 926 {
 927     markContextChanged();
 928     if (!isAccelerated())
 929         return;
 930 
 931     auto* canvas = htmlCanvas();
 932     if (!canvas)
 933         return;
 934 
 935     RenderBox* renderBox = canvas-&gt;renderBox();
 936     if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing())
 937         canvas-&gt;notifyObserversCanvasChanged(FloatRect(FloatPoint(0, 0), clampedCanvasSize()));
 938 }
 939 
<span class="line-modified"> 940 bool WebGLRenderingContextBase::clearIfComposited(GCGLbitfield mask)</span>
 941 {
 942     if (isContextLostOrPending())
 943         return false;
 944 
 945     if (!m_context-&gt;layerComposited() || m_layerCleared
 946         || m_attributes.preserveDrawingBuffer || (mask &amp;&amp; m_framebufferBinding)
 947         || m_preventBufferClearForInspector)
 948         return false;
 949 
 950     auto contextAttributes = getContextAttributes();
 951     ASSERT(contextAttributes);
 952 
 953     // Determine if it&#39;s possible to combine the clear the user asked for and this clear.
 954     bool combinedClear = mask &amp;&amp; !m_scissorEnabled;
 955 
<span class="line-modified"> 956     m_context-&gt;disable(GraphicsContextGL::SCISSOR_TEST);</span>
<span class="line-modified"> 957     if (combinedClear &amp;&amp; (mask &amp; GraphicsContextGL::COLOR_BUFFER_BIT)) {</span>
 958         m_context-&gt;clearColor(m_colorMask[0] ? m_clearColor[0] : 0,
 959                               m_colorMask[1] ? m_clearColor[1] : 0,
 960                               m_colorMask[2] ? m_clearColor[2] : 0,
 961                               m_colorMask[3] ? m_clearColor[3] : 0);
<span class="line-modified"> 962     } else</span>
 963         m_context-&gt;clearColor(0, 0, 0, 0);
 964     m_context-&gt;colorMask(true, true, true, true);
<span class="line-modified"> 965     GCGLbitfield clearMask = GraphicsContextGL::COLOR_BUFFER_BIT;</span>
 966     if (contextAttributes-&gt;depth) {
<span class="line-modified"> 967         if (!combinedClear || !m_depthMask || !(mask &amp; GraphicsContextGL::DEPTH_BUFFER_BIT))</span>
 968             m_context-&gt;clearDepth(1.0f);
<span class="line-modified"> 969         clearMask |= GraphicsContextGL::DEPTH_BUFFER_BIT;</span>
 970         m_context-&gt;depthMask(true);
 971     }
 972     if (contextAttributes-&gt;stencil) {
<span class="line-modified"> 973         if (combinedClear &amp;&amp; (mask &amp; GraphicsContextGL::STENCIL_BUFFER_BIT))</span>
 974             m_context-&gt;clearStencil(m_clearStencil &amp; m_stencilMask);
 975         else
 976             m_context-&gt;clearStencil(0);
<span class="line-modified"> 977         clearMask |= GraphicsContextGL::STENCIL_BUFFER_BIT;</span>
<span class="line-modified"> 978         m_context-&gt;stencilMaskSeparate(GraphicsContextGL::FRONT, 0xFFFFFFFF);</span>
 979     }
 980     if (m_framebufferBinding)
<span class="line-modified"> 981         m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, 0);</span>
 982     m_context-&gt;clear(clearMask);
 983 
 984     restoreStateAfterClear();
 985     if (m_framebufferBinding)
<span class="line-modified"> 986         m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));</span>
 987     m_layerCleared = true;
 988 
 989     return combinedClear;
 990 }
 991 
 992 void WebGLRenderingContextBase::restoreStateAfterClear()
 993 {
 994     // Restore the state that the context set.
 995     if (m_scissorEnabled)
<span class="line-modified"> 996         m_context-&gt;enable(GraphicsContextGL::SCISSOR_TEST);</span>
 997     m_context-&gt;clearColor(m_clearColor[0], m_clearColor[1],
 998                           m_clearColor[2], m_clearColor[3]);
 999     m_context-&gt;colorMask(m_colorMask[0], m_colorMask[1],
1000                          m_colorMask[2], m_colorMask[3]);
1001     m_context-&gt;clearDepth(m_clearDepth);
1002     m_context-&gt;clearStencil(m_clearStencil);
<span class="line-modified">1003     m_context-&gt;stencilMaskSeparate(GraphicsContextGL::FRONT, m_stencilMask);</span>
1004     m_context-&gt;depthMask(m_depthMask);
1005 }
1006 
1007 void WebGLRenderingContextBase::markLayerComposited()
1008 {
1009     if (isContextLostOrPending())
1010         return;
1011     m_context-&gt;markLayerComposited();
1012 }
1013 
1014 void WebGLRenderingContextBase::paintRenderingResultsToCanvas()
1015 {
1016     if (isContextLostOrPending())
1017         return;
1018 
1019     auto* canvas = htmlCanvas();
1020     if (!canvas)
1021         return;
1022 
1023     if (canvas-&gt;document().printing())
</pre>
<hr />
<pre>
1045 RefPtr&lt;ImageData&gt; WebGLRenderingContextBase::paintRenderingResultsToImageData()
1046 {
1047     if (isContextLostOrPending())
1048         return nullptr;
1049     clearIfComposited();
1050     return m_context-&gt;paintRenderingResultsToImageData();
1051 }
1052 
1053 WebGLTexture::TextureExtensionFlag WebGLRenderingContextBase::textureExtensionFlags() const
1054 {
1055     return static_cast&lt;WebGLTexture::TextureExtensionFlag&gt;((m_oesTextureFloatLinear ? WebGLTexture::TextureExtensionFloatLinearEnabled : 0) | (m_oesTextureHalfFloatLinear ? WebGLTexture::TextureExtensionHalfFloatLinearEnabled : 0));
1056 }
1057 
1058 void WebGLRenderingContextBase::reshape(int width, int height)
1059 {
1060     if (isContextLostOrPending())
1061         return;
1062 
1063     // This is an approximation because at WebGLRenderingContext level we don&#39;t
1064     // know if the underlying FBO uses textures or renderbuffers.
<span class="line-modified">1065     GCGLint maxSize = std::min(m_maxTextureSize, m_maxRenderbufferSize);</span>
<span class="line-modified">1066     GCGLint maxWidth = std::min(maxSize, m_maxViewportDims[0]);</span>
<span class="line-modified">1067     GCGLint maxHeight = std::min(maxSize, m_maxViewportDims[1]);</span>
1068     width = clamp(width, 1, maxWidth);
1069     height = clamp(height, 1, maxHeight);
1070 
1071     if (m_needsUpdate) {
1072         notifyCanvasContentChanged();
1073         m_needsUpdate = false;
1074     }
1075 
1076     // We don&#39;t have to mark the canvas as dirty, since the newly created image buffer will also start off
1077     // clear (and this matches what reshape will do).
1078     m_context-&gt;reshape(width, height);
1079 
1080     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
<span class="line-modified">1081     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, objectOrZero(textureUnit.texture2DBinding.get()));</span>
1082     if (textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(textureExtensionFlags()))
1083         m_unrenderableTextureUnits.add(m_activeTextureUnit);
<span class="line-modified">1084     m_context-&gt;bindRenderbuffer(GraphicsContextGL::RENDERBUFFER, objectOrZero(m_renderbufferBinding.get()));</span>
1085     if (m_framebufferBinding)
<span class="line-modified">1086         m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));</span>
1087 }
1088 
1089 int WebGLRenderingContextBase::drawingBufferWidth() const
1090 {
1091     if (isContextLost())
1092         return 0;
1093 
1094     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution)
1095         return 0;
1096 
1097     return m_context-&gt;getInternalFramebufferSize().width();
1098 }
1099 
1100 int WebGLRenderingContextBase::drawingBufferHeight() const
1101 {
1102     if (isContextLost())
1103         return 0;
1104 
1105     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution)
1106         return 0;
1107 
1108     return m_context-&gt;getInternalFramebufferSize().height();
1109 }
1110 
<span class="line-modified">1111 unsigned WebGLRenderingContextBase::sizeInBytes(GCGLenum type)</span>
1112 {
1113     switch (type) {
<span class="line-modified">1114     case GraphicsContextGL::BYTE:</span>
<span class="line-modified">1115         return sizeof(GCGLbyte);</span>
<span class="line-modified">1116     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">1117         return sizeof(GCGLubyte);</span>
<span class="line-modified">1118     case GraphicsContextGL::SHORT:</span>
<span class="line-modified">1119         return sizeof(GCGLshort);</span>
<span class="line-modified">1120     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="line-modified">1121         return sizeof(GCGLushort);</span>
<span class="line-modified">1122     case GraphicsContextGL::INT:</span>
<span class="line-modified">1123         return sizeof(GCGLint);</span>
<span class="line-modified">1124     case GraphicsContextGL::UNSIGNED_INT:</span>
<span class="line-modified">1125         return sizeof(GCGLuint);</span>
<span class="line-modified">1126     case GraphicsContextGL::FLOAT:</span>
<span class="line-modified">1127         return sizeof(GCGLfloat);</span>
1128     }
1129     ASSERT_NOT_REACHED();
1130     return 0;
1131 }
1132 
<span class="line-modified">1133 void WebGLRenderingContextBase::activeTexture(GCGLenum texture)</span>
1134 {
1135     if (isContextLostOrPending())
1136         return;
<span class="line-modified">1137     if (texture - GraphicsContextGL::TEXTURE0 &gt;= m_textureUnits.size()) {</span>
<span class="line-modified">1138         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;activeTexture&quot;, &quot;texture unit out of range&quot;);</span>
1139         return;
1140     }
<span class="line-modified">1141     m_activeTextureUnit = texture - GraphicsContextGL::TEXTURE0;</span>
1142     m_context-&gt;activeTexture(texture);
1143 }
1144 
1145 void WebGLRenderingContextBase::attachShader(WebGLProgram* program, WebGLShader* shader)
1146 {
1147     if (isContextLostOrPending() || !validateWebGLObject(&quot;attachShader&quot;, program) || !validateWebGLObject(&quot;attachShader&quot;, shader))
1148         return;
1149     if (!program-&gt;attachShader(shader)) {
<span class="line-modified">1150         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;attachShader&quot;, &quot;shader attachment already has shader&quot;);</span>
1151         return;
1152     }
1153     m_context-&gt;attachShader(objectOrZero(program), objectOrZero(shader));
1154     shader-&gt;onAttached();
1155 }
1156 
<span class="line-modified">1157 void WebGLRenderingContextBase::bindAttribLocation(WebGLProgram* program, GCGLuint index, const String&amp; name)</span>
1158 {
1159     if (isContextLostOrPending() || !validateWebGLObject(&quot;bindAttribLocation&quot;, program))
1160         return;
1161     if (!validateLocationLength(&quot;bindAttribLocation&quot;, name))
1162         return;
1163     if (!validateString(&quot;bindAttribLocation&quot;, name))
1164         return;
1165     if (isPrefixReserved(name)) {
<span class="line-modified">1166         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;bindAttribLocation&quot;, &quot;reserved prefix&quot;);</span>
1167         return;
1168     }
1169     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">1170         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bindAttribLocation&quot;, &quot;index out of range&quot;);</span>
1171         return;
1172     }
1173     m_context-&gt;bindAttribLocation(objectOrZero(program), index, name);
1174 }
1175 
1176 bool WebGLRenderingContextBase::checkObjectToBeBound(const char* functionName, WebGLObject* object, bool&amp; deleted)
1177 {
1178     deleted = false;
1179     if (isContextLostOrPending())
1180         return false;
1181     if (object) {
1182         if (!object-&gt;validate(contextGroup(), *this)) {
<span class="line-modified">1183             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;object not from this context&quot;);</span>
1184             return false;
1185         }
1186         deleted = !object-&gt;object();
1187     }
1188     return true;
1189 }
1190 
<span class="line-modified">1191 bool WebGLRenderingContextBase::validateAndCacheBufferBinding(const char* functionName, GCGLenum target, WebGLBuffer* buffer)</span>
1192 {
1193     bool deleted;
<span class="line-modified">1194     if (!checkObjectToBeBound(functionName, buffer, deleted))</span>
<span class="line-modified">1195         return false;</span>
1196     if (deleted)
1197         buffer = nullptr;
<span class="line-modified">1198 </span>
<span class="line-modified">1199     if (buffer) {</span>
<span class="line-modified">1200         // In WebGL, a buffer may only be bound to one of the ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target in its lifetime.</span>
<span class="line-added">1201         if (target == GraphicsContextGL::ARRAY_BUFFER || target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER) {</span>
<span class="line-added">1202             if (buffer-&gt;arrayBufferOrElementArrayBuffer() &amp;&amp; target != buffer-&gt;arrayBufferOrElementArrayBuffer()) {</span>
<span class="line-added">1203                 synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;buffers can only be bound to one of ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER&quot;);</span>
<span class="line-added">1204                 return false;</span>
<span class="line-added">1205             }</span>
<span class="line-added">1206         }</span>
<span class="line-added">1207 </span>
<span class="line-added">1208         buffer-&gt;setTarget(target);</span>
1209     }
<span class="line-modified">1210 </span>
<span class="line-added">1211     if (target == GraphicsContextGL::ARRAY_BUFFER)</span>
1212         m_boundArrayBuffer = buffer;
<span class="line-modified">1213     else if (target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER)</span>
1214         m_boundVertexArrayObject-&gt;setElementArrayBuffer(buffer);
1215     else {
1216         bool success = false;
1217 #if ENABLE(WEBGL2)
1218         if (isWebGL2()) {
1219             success = true;
1220             switch (target) {
<span class="line-modified">1221             case GraphicsContextGL::COPY_READ_BUFFER:</span>
1222                 m_boundCopyReadBuffer = buffer;
1223                 break;
<span class="line-modified">1224             case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
1225                 m_boundCopyWriteBuffer = buffer;
1226                 break;
<span class="line-modified">1227             case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
1228                 m_boundPixelPackBuffer = buffer;
1229                 break;
<span class="line-modified">1230             case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
1231                 m_boundPixelUnpackBuffer = buffer;
1232                 break;
<span class="line-modified">1233             case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
1234                 m_boundTransformFeedbackBuffer = buffer;
1235                 break;
<span class="line-modified">1236             case GraphicsContextGL::UNIFORM_BUFFER:</span>
1237                 m_boundUniformBuffer = buffer;
1238                 break;
1239             default:
1240                 success = false;
1241                 break;
1242             }
1243         }
1244 #endif
1245         if (!success) {
<span class="line-modified">1246             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindBuffer&quot;, &quot;invalid target&quot;);</span>
<span class="line-modified">1247             return false;</span>
1248         }
1249     }
1250 
<span class="line-added">1251     return true;</span>
<span class="line-added">1252 }</span>
<span class="line-added">1253 </span>
<span class="line-added">1254 void WebGLRenderingContextBase::bindBuffer(GCGLenum target, WebGLBuffer* buffer)</span>
<span class="line-added">1255 {</span>
<span class="line-added">1256     if (!validateAndCacheBufferBinding(&quot;bindBuffer&quot;, target, buffer))</span>
<span class="line-added">1257         return;</span>
<span class="line-added">1258 </span>
1259     m_context-&gt;bindBuffer(target, objectOrZero(buffer));


1260 }
1261 
<span class="line-modified">1262 void WebGLRenderingContextBase::bindFramebuffer(GCGLenum target, WebGLFramebuffer* buffer)</span>
1263 {
1264     bool deleted;
1265     if (!checkObjectToBeBound(&quot;bindFramebuffer&quot;, buffer, deleted))
1266         return;
1267     if (deleted)
1268         buffer = 0;
1269 
1270     bool isWebGL2DrawFramebufferTarget = false;
1271 #if ENABLE(WEBGL2)
<span class="line-modified">1272     isWebGL2DrawFramebufferTarget = isWebGL2() &amp;&amp; target == GraphicsContextGL::DRAW_FRAMEBUFFER;</span>
1273 #endif
1274     bool success = false;
1275 
<span class="line-modified">1276     if (target == GraphicsContextGL::FRAMEBUFFER || isWebGL2DrawFramebufferTarget) {</span>
1277         m_framebufferBinding = buffer;
1278         success = true;
1279     }
1280 #if ENABLE(WEBGL2)
<span class="line-modified">1281     if (isWebGL2() &amp;&amp; (target == GraphicsContextGL::FRAMEBUFFER || target == GraphicsContextGL::READ_FRAMEBUFFER)) {</span>
1282         m_readFramebufferBinding = buffer;
1283         success = true;
1284     }
1285 #endif
1286 
1287     if (!success) {
<span class="line-modified">1288         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindFramebuffer&quot;, &quot;invalid target&quot;);</span>
1289         return;
1290     }
1291 
1292     m_context-&gt;bindFramebuffer(target, objectOrZero(buffer));
1293     if (buffer)
1294         buffer-&gt;setHasEverBeenBound();
1295     applyStencilTest();
1296 }
1297 
<span class="line-modified">1298 void WebGLRenderingContextBase::bindRenderbuffer(GCGLenum target, WebGLRenderbuffer* renderBuffer)</span>
1299 {
1300     bool deleted;
1301     if (!checkObjectToBeBound(&quot;bindRenderbuffer&quot;, renderBuffer, deleted))
1302         return;
1303     if (deleted)
1304         renderBuffer = 0;
<span class="line-modified">1305     if (target != GraphicsContextGL::RENDERBUFFER) {</span>
<span class="line-modified">1306         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindRenderbuffer&quot;, &quot;invalid target&quot;);</span>
1307         return;
1308     }
1309     m_renderbufferBinding = renderBuffer;
1310     m_context-&gt;bindRenderbuffer(target, objectOrZero(renderBuffer));
1311     if (renderBuffer)
1312         renderBuffer-&gt;setHasEverBeenBound();
1313 }
1314 
<span class="line-modified">1315 void WebGLRenderingContextBase::bindTexture(GCGLenum target, WebGLTexture* texture)</span>
1316 {
1317     bool deleted;
1318     if (!checkObjectToBeBound(&quot;bindTexture&quot;, texture, deleted))
1319         return;
1320     if (deleted)
1321         texture = nullptr;
1322     if (texture &amp;&amp; texture-&gt;getTarget() &amp;&amp; texture-&gt;getTarget() != target) {
<span class="line-modified">1323         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;bindTexture&quot;, &quot;textures can not be used with multiple targets&quot;);</span>
1324         return;
1325     }
<span class="line-modified">1326     GCGLint maxLevel = 0;</span>
1327     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
<span class="line-modified">1328     if (target == GraphicsContextGL::TEXTURE_2D) {</span>
1329         textureUnit.texture2DBinding = texture;
1330         maxLevel = m_maxTextureLevel;
1331         if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
1332             m_unrenderableTextureUnits.add(m_activeTextureUnit);
1333         else
1334             m_unrenderableTextureUnits.remove(m_activeTextureUnit);
<span class="line-modified">1335     } else if (target == GraphicsContextGL::TEXTURE_CUBE_MAP) {</span>
1336         textureUnit.textureCubeMapBinding = texture;
1337         maxLevel = m_maxCubeMapTextureLevel;
1338         if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
1339             m_unrenderableTextureUnits.add(m_activeTextureUnit);
1340         else
1341             m_unrenderableTextureUnits.remove(m_activeTextureUnit);
1342     } else {
<span class="line-modified">1343         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindTexture&quot;, &quot;invalid target&quot;);</span>
1344         return;
1345     }
1346     m_context-&gt;bindTexture(target, objectOrZero(texture));
1347     if (texture)
1348         texture-&gt;setTarget(target, maxLevel);
1349 
1350     // Note: previously we used to automatically set the TEXTURE_WRAP_R
1351     // repeat mode to CLAMP_TO_EDGE for cube map textures, because OpenGL
1352     // ES 2.0 doesn&#39;t expose this flag (a bug in the specification) and
1353     // otherwise the application has no control over the seams in this
1354     // dimension. However, it appears that supporting this properly on all
1355     // platforms is fairly involved (will require a HashMap from texture ID
1356     // in all ports), and we have not had any complaints, so the logic has
1357     // been removed.
1358 }
1359 
<span class="line-modified">1360 void WebGLRenderingContextBase::blendColor(GCGLfloat red, GCGLfloat green, GCGLfloat blue, GCGLfloat alpha)</span>
1361 {
1362     if (isContextLostOrPending())
1363         return;
1364     m_context-&gt;blendColor(red, green, blue, alpha);
1365 }
1366 
<span class="line-modified">1367 void WebGLRenderingContextBase::blendEquation(GCGLenum mode)</span>
1368 {
1369     if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, mode))
1370         return;
1371     m_context-&gt;blendEquation(mode);
1372 }
1373 
<span class="line-modified">1374 void WebGLRenderingContextBase::blendEquationSeparate(GCGLenum modeRGB, GCGLenum modeAlpha)</span>
1375 {
1376     if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, modeRGB) || !validateBlendEquation(&quot;blendEquation&quot;, modeAlpha))
1377         return;
1378     m_context-&gt;blendEquationSeparate(modeRGB, modeAlpha);
1379 }
1380 
1381 
<span class="line-modified">1382 void WebGLRenderingContextBase::blendFunc(GCGLenum sfactor, GCGLenum dfactor)</span>
1383 {
1384     if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, sfactor, dfactor))
1385         return;
1386     m_context-&gt;blendFunc(sfactor, dfactor);
1387 }
1388 
<span class="line-modified">1389 void WebGLRenderingContextBase::blendFuncSeparate(GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha)</span>
1390 {
1391     // Note: Alpha does not have the same restrictions as RGB.
1392     if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, srcRGB, dstRGB))
1393         return;
1394     m_context-&gt;blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
1395 }
1396 
<span class="line-modified">1397 void WebGLRenderingContextBase::bufferData(GCGLenum target, long long size, GCGLenum usage)</span>
1398 {
1399     if (isContextLostOrPending())
1400         return;
1401     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
1402     if (!buffer)
1403         return;
1404     if (size &lt; 0) {
<span class="line-modified">1405         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;size &lt; 0&quot;);</span>
1406         return;
1407     }
1408     if (!size) {
<span class="line-modified">1409         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;size == 0&quot;);</span>
1410         return;
1411     }
<span class="line-modified">1412     if (!buffer-&gt;associateBufferData(static_cast&lt;GCGLsizeiptr&gt;(size))) {</span>
<span class="line-modified">1413         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);</span>
1414         return;
1415     }
1416 
1417     m_context-&gt;moveErrorsToSyntheticErrorList();
<span class="line-modified">1418     m_context-&gt;bufferData(target, static_cast&lt;GCGLsizeiptr&gt;(size), usage);</span>
1419     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1420         // The bufferData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1421         buffer-&gt;disassociateBufferData();
1422     }
1423 }
1424 
<span class="line-modified">1425 void WebGLRenderingContextBase::bufferData(GCGLenum target, Optional&lt;BufferDataSource&gt;&amp;&amp; data, GCGLenum usage)</span>
1426 {
1427     if (isContextLostOrPending())
1428         return;
1429     if (!data) {
<span class="line-modified">1430         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;null data&quot;);</span>
1431         return;
1432     }
1433     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
1434     if (!buffer)
1435         return;
1436 
1437     WTF::visit([&amp;](auto&amp; data) {
1438         if (!buffer-&gt;associateBufferData(data.get())) {
<span class="line-modified">1439             this-&gt;synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);</span>
1440             return;
1441         }
1442 
1443         m_context-&gt;moveErrorsToSyntheticErrorList();
1444         m_context-&gt;bufferData(target, data-&gt;byteLength(), data-&gt;data(), usage);
1445         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1446             // The bufferData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1447             buffer-&gt;disassociateBufferData();
1448         }
1449     }, data.value());
1450 }
1451 
<span class="line-modified">1452 void WebGLRenderingContextBase::bufferSubData(GCGLenum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp; data)</span>
1453 {
1454     if (isContextLostOrPending())
1455         return;
<span class="line-modified">1456     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferSubData&quot;, target, GraphicsContextGL::STATIC_DRAW);</span>
1457     if (!buffer)
1458         return;
1459     if (offset &lt; 0) {
<span class="line-modified">1460         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset &lt; 0&quot;);</span>
1461         return;
1462     }
1463     if (!data)
1464         return;
1465 
1466     WTF::visit([&amp;](auto&amp; data) {
<span class="line-modified">1467         if (!buffer-&gt;associateBufferSubData(static_cast&lt;GCGLintptr&gt;(offset), data.get())) {</span>
<span class="line-modified">1468             this-&gt;synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset out of range&quot;);</span>
1469             return;
1470         }
1471 
1472         m_context-&gt;moveErrorsToSyntheticErrorList();
<span class="line-modified">1473         m_context-&gt;bufferSubData(target, static_cast&lt;GCGLintptr&gt;(offset), data-&gt;byteLength(), data-&gt;data());</span>
1474         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1475             // The bufferSubData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1476             buffer-&gt;disassociateBufferData();
1477         }
1478     }, data.value());
1479 }
1480 
<span class="line-modified">1481 GCGLenum WebGLRenderingContextBase::checkFramebufferStatus(GCGLenum target)</span>
1482 {
1483     if (isContextLostOrPending())
<span class="line-modified">1484         return GraphicsContextGL::FRAMEBUFFER_UNSUPPORTED;</span>
<span class="line-modified">1485     if (target != GraphicsContextGL::FRAMEBUFFER) {</span>
1486 #if ENABLE(WEBGL2)
<span class="line-modified">1487         if (isWebGL1() || (target != GraphicsContextGL::DRAW_FRAMEBUFFER &amp;&amp; target != GraphicsContextGL::READ_FRAMEBUFFER)) {</span>
1488 #endif
<span class="line-modified">1489             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;checkFramebufferStatus&quot;, &quot;invalid target&quot;);</span>
1490             return 0;
1491 #if ENABLE(WEBGL2)
1492         }
1493 #endif
1494     }
1495 
<span class="line-modified">1496     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
1497 
1498     if (!targetFramebuffer || !targetFramebuffer-&gt;object())
<span class="line-modified">1499         return GraphicsContextGL::FRAMEBUFFER_COMPLETE;</span>
1500     const char* reason = &quot;framebuffer incomplete&quot;;
<span class="line-modified">1501     GCGLenum result = targetFramebuffer-&gt;checkStatus(&amp;reason);</span>
<span class="line-modified">1502     if (result != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
1503         String str = &quot;WebGL: checkFramebufferStatus:&quot; + String(reason);
1504         printToConsole(MessageLevel::Warning, str);
1505         return result;
1506     }
1507     result = m_context-&gt;checkFramebufferStatus(target);
1508     return result;
1509 }
1510 
<span class="line-modified">1511 void WebGLRenderingContextBase::clearColor(GCGLfloat r, GCGLfloat g, GCGLfloat b, GCGLfloat a)</span>
1512 {
1513     if (isContextLostOrPending())
1514         return;
1515     if (std::isnan(r))
1516         r = 0;
1517     if (std::isnan(g))
1518         g = 0;
1519     if (std::isnan(b))
1520         b = 0;
1521     if (std::isnan(a))
1522         a = 1;
1523     m_clearColor[0] = r;
1524     m_clearColor[1] = g;
1525     m_clearColor[2] = b;
1526     m_clearColor[3] = a;
1527     m_context-&gt;clearColor(r, g, b, a);
1528 }
1529 
<span class="line-modified">1530 void WebGLRenderingContextBase::clearDepth(GCGLfloat depth)</span>
1531 {
1532     if (isContextLostOrPending())
1533         return;
1534     m_clearDepth = depth;
1535     m_context-&gt;clearDepth(depth);
1536 }
1537 
<span class="line-modified">1538 void WebGLRenderingContextBase::clearStencil(GCGLint s)</span>
1539 {
1540     if (isContextLostOrPending())
1541         return;
1542     m_clearStencil = s;
1543     m_context-&gt;clearStencil(s);
1544 }
1545 
<span class="line-modified">1546 void WebGLRenderingContextBase::colorMask(GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha)</span>
1547 {
1548     if (isContextLostOrPending())
1549         return;
1550     m_colorMask[0] = red;
1551     m_colorMask[1] = green;
1552     m_colorMask[2] = blue;
1553     m_colorMask[3] = alpha;
1554     m_context-&gt;colorMask(red, green, blue, alpha);
1555 }
1556 
1557 void WebGLRenderingContextBase::compileShader(WebGLShader* shader)
1558 {
1559     if (isContextLostOrPending() || !validateWebGLObject(&quot;compileShader&quot;, shader))
1560         return;
1561     m_context-&gt;compileShader(objectOrZero(shader));
<span class="line-modified">1562     GCGLint value;</span>
<span class="line-modified">1563     m_context-&gt;getShaderiv(objectOrZero(shader), GraphicsContextGL::COMPILE_STATUS, &amp;value);</span>
1564     shader-&gt;setValid(value);
1565 
1566     auto* canvas = htmlCanvas();
1567 
1568     if (canvas &amp;&amp; m_synthesizedErrorsToConsole &amp;&amp; !value) {
1569         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
1570 
1571         for (auto&amp; error : getShaderInfoLog(shader).split(&#39;\n&#39;))
1572             canvas-&gt;document().addConsoleMessage(makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Error, &quot;WebGL: &quot; + error, stackTrace.copyRef()));
1573     }
1574 }
1575 
<span class="line-modified">1576 void WebGLRenderingContextBase::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, ArrayBufferView&amp; data)</span>
1577 {
1578     if (isContextLostOrPending())
1579         return;
1580     if (!validateTexFuncLevel(&quot;compressedTexImage2D&quot;, target, level))
1581         return;
1582 
1583     if (!validateCompressedTexFormat(internalformat)) {
<span class="line-modified">1584         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;compressedTexImage2D&quot;, &quot;invalid internalformat&quot;);</span>
1585         return;
1586     }
1587     if (border) {
<span class="line-modified">1588         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;compressedTexImage2D&quot;, &quot;border not 0&quot;);</span>
1589         return;
1590     }
1591     if (!validateCompressedTexDimensions(&quot;compressedTexImage2D&quot;, target, level, width, height, internalformat))
1592         return;
1593     if (!validateCompressedTexFuncData(&quot;compressedTexImage2D&quot;, width, height, internalformat, data))
1594         return;
1595 
1596     auto tex = validateTextureBinding(&quot;compressedTexImage2D&quot;, target, true);
1597     if (!tex)
1598         return;
1599     if (!validateNPOTTextureLevel(width, height, level, &quot;compressedTexImage2D&quot;))
1600         return;
1601     m_context-&gt;moveErrorsToSyntheticErrorList();
1602     m_context-&gt;compressedTexImage2D(target, level, internalformat, width, height,
1603         border, data.byteLength(), data.baseAddress());
1604     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1605         // The compressedTexImage2D function failed. Tell the WebGLTexture it doesn&#39;t have the data for this level.
1606         tex-&gt;markInvalid(target, level);
1607         return;
1608     }
1609 
<span class="line-modified">1610     tex-&gt;setLevelInfo(target, level, internalformat, width, height, GraphicsContextGL::UNSIGNED_BYTE);</span>
1611     tex-&gt;setCompressed();
1612 }
1613 
<span class="line-modified">1614 void WebGLRenderingContextBase::compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; data)</span>
1615 {
1616     if (isContextLostOrPending())
1617         return;
1618     if (!validateTexFuncLevel(&quot;compressedTexSubImage2D&quot;, target, level))
1619         return;
1620     if (!validateCompressedTexFormat(format)) {
<span class="line-modified">1621         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;compressedTexSubImage2D&quot;, &quot;invalid format&quot;);</span>
1622         return;
1623     }
1624     if (!validateCompressedTexFuncData(&quot;compressedTexSubImage2D&quot;, width, height, format, data))
1625         return;
1626 
1627     auto tex = validateTextureBinding(&quot;compressedTexSubImage2D&quot;, target, true);
1628     if (!tex)
1629         return;
1630 
1631     if (format != tex-&gt;getInternalFormat(target, level)) {
<span class="line-modified">1632         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;compressedTexSubImage2D&quot;, &quot;format does not match texture format&quot;);</span>
1633         return;
1634     }
1635 
1636     if (!validateCompressedTexSubDimensions(&quot;compressedTexSubImage2D&quot;, target, level, xoffset, yoffset, width, height, format, tex.get()))
1637         return;
1638 
<span class="line-modified">1639     graphicsContextGL()-&gt;compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data.byteLength(), data.baseAddress());</span>
1640     tex-&gt;setCompressed();
1641 }
1642 
<span class="line-modified">1643 bool WebGLRenderingContextBase::validateSettableTexInternalFormat(const char* functionName, GCGLenum internalFormat)</span>
1644 {
1645     switch (internalFormat) {
<span class="line-modified">1646     case GraphicsContextGL::DEPTH_COMPONENT:</span>
<span class="line-modified">1647     case GraphicsContextGL::DEPTH_STENCIL:</span>
<span class="line-modified">1648     case GraphicsContextGL::DEPTH_COMPONENT16:</span>
<span class="line-modified">1649     case GraphicsContextGL::DEPTH_COMPONENT24:</span>
<span class="line-modified">1650     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
<span class="line-modified">1651     case GraphicsContextGL::DEPTH24_STENCIL8:</span>
<span class="line-modified">1652     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
<span class="line-modified">1653     case GraphicsContextGL::STENCIL_INDEX8:</span>
<span class="line-modified">1654         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;format can not be set, only rendered to&quot;);</span>
1655         return false;
1656     default:
1657         return true;
1658     }
1659 }
1660 
<span class="line-modified">1661 void WebGLRenderingContextBase::copyTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)</span>
1662 {
1663     if (isContextLostOrPending())
1664         return;
1665     if (!validateTexFuncLevel(&quot;copyTexSubImage2D&quot;, target, level))
1666         return;
1667     auto tex = validateTextureBinding(&quot;copyTexSubImage2D&quot;, target, true);
1668     if (!tex)
1669         return;
1670     if (!validateSize(&quot;copyTexSubImage2D&quot;, xoffset, yoffset) || !validateSize(&quot;copyTexSubImage2D&quot;, width, height))
1671         return;
1672     // Before checking if it is in the range, check if overflow happens first.
1673     if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
<span class="line-modified">1674         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);</span>
1675         return;
1676     }
1677     if (xoffset + width &gt; tex-&gt;getWidth(target, level) || yoffset + height &gt; tex-&gt;getHeight(target, level)) {
<span class="line-modified">1678         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;rectangle out of range&quot;);</span>
1679         return;
1680     }
<span class="line-modified">1681     GCGLenum internalFormat = tex-&gt;getInternalFormat(target, level);</span>
1682     if (!validateSettableTexInternalFormat(&quot;copyTexSubImage2D&quot;, internalFormat))
1683         return;
1684     if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
<span class="line-modified">1685         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;copyTexSubImage2D&quot;, &quot;framebuffer is incompatible format&quot;);</span>
1686         return;
1687     }
1688     const char* reason = &quot;framebuffer incomplete&quot;;
<span class="line-modified">1689     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="line-modified">1690         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexSubImage2D&quot;, reason);</span>
1691         return;
1692     }
1693     clearIfComposited();
1694 
<span class="line-modified">1695     GCGLint clippedX, clippedY;</span>
<span class="line-modified">1696     GCGLsizei clippedWidth, clippedHeight;</span>
1697     if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
<span class="line-modified">1698         GCGLenum format;</span>
<span class="line-modified">1699         GCGLenum type;</span>
<span class="line-modified">1700         if (!GraphicsContextGLOpenGL::possibleFormatAndTypeForInternalFormat(tex-&gt;getInternalFormat(target, level), format, type)) {</span>
<span class="line-modified">1701             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;copyTexSubImage2D&quot;, &quot;Texture has unknown internal format&quot;);</span>
1702             return;
1703         }
1704         UniqueArray&lt;unsigned char&gt; zero;
1705         if (width &amp;&amp; height) {
1706             unsigned size;
<span class="line-modified">1707             GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;size, nullptr);</span>
<span class="line-modified">1708             if (error != GraphicsContextGL::NO_ERROR) {</span>
1709                 synthesizeGLError(error, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);
1710                 return;
1711             }
1712             zero = makeUniqueArray&lt;unsigned char&gt;(size);
1713             if (!zero) {
<span class="line-modified">1714                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;out of memory&quot;);</span>
1715                 return;
1716             }
1717             memset(zero.get(), 0, size);
1718         }
1719         m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, zero.get());
1720         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0)
1721             m_context-&gt;copyTexSubImage2D(target, level, xoffset + clippedX - x, yoffset + clippedY - y, clippedX, clippedY, clippedWidth, clippedHeight);
1722     } else
1723         m_context-&gt;copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
1724 }
1725 
1726 RefPtr&lt;WebGLBuffer&gt; WebGLRenderingContextBase::createBuffer()
1727 {
1728     if (isContextLostOrPending())
1729         return nullptr;
1730     auto buffer = WebGLBuffer::create(*this);
1731     addSharedObject(buffer.get());
1732     return buffer;
1733 }
1734 
</pre>
<hr />
<pre>
1740     addContextObject(buffer.get());
1741     return buffer;
1742 }
1743 
1744 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::createTexture()
1745 {
1746     if (isContextLostOrPending())
1747         return nullptr;
1748     auto texture = WebGLTexture::create(*this);
1749     addSharedObject(texture.get());
1750     return texture;
1751 }
1752 
1753 RefPtr&lt;WebGLProgram&gt; WebGLRenderingContextBase::createProgram()
1754 {
1755     if (isContextLostOrPending())
1756         return nullptr;
1757     auto program = WebGLProgram::create(*this);
1758     addSharedObject(program.get());
1759 
<span class="line-modified">1760     InspectorInstrumentation::didCreateWebGLProgram(*this, program.get());</span>
1761 
1762     return program;
1763 }
1764 
1765 RefPtr&lt;WebGLRenderbuffer&gt; WebGLRenderingContextBase::createRenderbuffer()
1766 {
1767     if (isContextLostOrPending())
1768         return nullptr;
1769     auto buffer = WebGLRenderbuffer::create(*this);
1770     addSharedObject(buffer.get());
1771     return buffer;
1772 }
1773 
<span class="line-modified">1774 RefPtr&lt;WebGLShader&gt; WebGLRenderingContextBase::createShader(GCGLenum type)</span>
1775 {
1776     if (isContextLostOrPending())
1777         return nullptr;
<span class="line-modified">1778     if (type != GraphicsContextGL::VERTEX_SHADER &amp;&amp; type != GraphicsContextGL::FRAGMENT_SHADER) {</span>
<span class="line-modified">1779         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;createShader&quot;, &quot;invalid shader type&quot;);</span>
1780         return nullptr;
1781     }
1782 
1783     auto shader = WebGLShader::create(*this, type);
1784     addSharedObject(shader.get());
1785     return shader;
1786 }
1787 
<span class="line-modified">1788 void WebGLRenderingContextBase::cullFace(GCGLenum mode)</span>
1789 {
1790     if (isContextLostOrPending())
1791         return;
1792     m_context-&gt;cullFace(mode);
1793 }
1794 
1795 bool WebGLRenderingContextBase::deleteObject(WebGLObject* object)
1796 {
1797     if (isContextLostOrPending() || !object)
1798         return false;
1799     if (!object-&gt;validate(contextGroup(), *this)) {
<span class="line-modified">1800         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;delete&quot;, &quot;object does not belong to this context&quot;);</span>
1801         return false;
1802     }
1803     if (object-&gt;isDeleted())
1804         return false;
1805     if (object-&gt;object())
1806         // We need to pass in context here because we want
1807         // things in this context unbound.
<span class="line-modified">1808         object-&gt;deleteObject(graphicsContextGL());</span>
1809     return true;
1810 }
1811 
<span class="line-added">1812 #define REMOVE_BUFFER_FROM_BINDING(binding) \</span>
<span class="line-added">1813     if (binding == buffer) \</span>
<span class="line-added">1814         binding = nullptr;</span>
<span class="line-added">1815 </span>
<span class="line-added">1816 void WebGLRenderingContextBase::uncacheDeletedBuffer(WebGLBuffer* buffer)</span>
<span class="line-added">1817 {</span>
<span class="line-added">1818     REMOVE_BUFFER_FROM_BINDING(m_boundArrayBuffer);</span>
<span class="line-added">1819     REMOVE_BUFFER_FROM_BINDING(m_boundCopyReadBuffer);</span>
<span class="line-added">1820     REMOVE_BUFFER_FROM_BINDING(m_boundCopyWriteBuffer);</span>
<span class="line-added">1821     REMOVE_BUFFER_FROM_BINDING(m_boundPixelPackBuffer);</span>
<span class="line-added">1822     REMOVE_BUFFER_FROM_BINDING(m_boundPixelUnpackBuffer);</span>
<span class="line-added">1823     REMOVE_BUFFER_FROM_BINDING(m_boundTransformFeedbackBuffer);</span>
<span class="line-added">1824     REMOVE_BUFFER_FROM_BINDING(m_boundUniformBuffer);</span>
<span class="line-added">1825 </span>
<span class="line-added">1826     m_boundVertexArrayObject-&gt;unbindBuffer(*buffer);</span>
<span class="line-added">1827 }</span>
<span class="line-added">1828 </span>
1829 void WebGLRenderingContextBase::deleteBuffer(WebGLBuffer* buffer)
1830 {
1831     if (!deleteObject(buffer))
1832         return;


1833 
<span class="line-modified">1834     uncacheDeletedBuffer(buffer);</span>
1835 }
1836 
1837 void WebGLRenderingContextBase::deleteFramebuffer(WebGLFramebuffer* framebuffer)
1838 {
1839     if (!deleteObject(framebuffer))
1840         return;
1841 #if ENABLE(WEBGL2)
1842     if (isWebGL2() &amp;&amp; framebuffer == m_readFramebufferBinding) {
1843         m_readFramebufferBinding = nullptr;
<span class="line-modified">1844         m_context-&gt;bindFramebuffer(GraphicsContextGL::READ_FRAMEBUFFER, 0);</span>
1845     }
1846 #endif
1847     if (framebuffer == m_framebufferBinding) {
1848         m_framebufferBinding = nullptr;
1849 #if ENABLE(WEBGL2)
1850         if (isWebGL2())
<span class="line-modified">1851             m_context-&gt;bindFramebuffer(GraphicsContextGL::DRAW_FRAMEBUFFER, 0);</span>
1852         else
1853 #endif
<span class="line-modified">1854             m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, 0);</span>
1855     }
1856 }
1857 
1858 void WebGLRenderingContextBase::deleteProgram(WebGLProgram* program)
1859 {
1860     if (program)
<span class="line-modified">1861         InspectorInstrumentation::willDestroyWebGLProgram(*program);</span>
1862 
1863     deleteObject(program);
1864     // We don&#39;t reset m_currentProgram to 0 here because the deletion of the
1865     // current program is delayed.
1866 }
1867 
1868 void WebGLRenderingContextBase::deleteRenderbuffer(WebGLRenderbuffer* renderbuffer)
1869 {
1870     if (!deleteObject(renderbuffer))
1871         return;
1872     if (renderbuffer == m_renderbufferBinding)
1873         m_renderbufferBinding = nullptr;
1874     if (m_framebufferBinding)
1875         m_framebufferBinding-&gt;removeAttachmentFromBoundFramebuffer(renderbuffer);
1876 }
1877 
1878 void WebGLRenderingContextBase::deleteShader(WebGLShader* shader)
1879 {
1880     deleteObject(shader);
1881 }
</pre>
<hr />
<pre>
1884 {
1885     if (!deleteObject(texture))
1886         return;
1887 
1888     unsigned current = 0;
1889     for (auto&amp; textureUnit : m_textureUnits) {
1890         if (texture == textureUnit.texture2DBinding) {
1891             textureUnit.texture2DBinding = nullptr;
1892             m_unrenderableTextureUnits.remove(current);
1893         }
1894         if (texture == textureUnit.textureCubeMapBinding) {
1895             textureUnit.textureCubeMapBinding = nullptr;
1896             m_unrenderableTextureUnits.remove(current);
1897         }
1898         ++current;
1899     }
1900     if (m_framebufferBinding)
1901         m_framebufferBinding-&gt;removeAttachmentFromBoundFramebuffer(texture);
1902 }
1903 
<span class="line-modified">1904 void WebGLRenderingContextBase::depthFunc(GCGLenum func)</span>
1905 {
1906     if (isContextLostOrPending())
1907         return;
1908     m_context-&gt;depthFunc(func);
1909 }
1910 
<span class="line-modified">1911 void WebGLRenderingContextBase::depthMask(GCGLboolean flag)</span>
1912 {
1913     if (isContextLostOrPending())
1914         return;
1915     m_depthMask = flag;
1916     m_context-&gt;depthMask(flag);
1917 }
1918 
<span class="line-modified">1919 void WebGLRenderingContextBase::depthRange(GCGLfloat zNear, GCGLfloat zFar)</span>
1920 {
1921     if (isContextLostOrPending())
1922         return;
1923     if (zNear &gt; zFar) {
<span class="line-modified">1924         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;depthRange&quot;, &quot;zNear &gt; zFar&quot;);</span>
1925         return;
1926     }
1927     m_context-&gt;depthRange(zNear, zFar);
1928 }
1929 
1930 void WebGLRenderingContextBase::detachShader(WebGLProgram* program, WebGLShader* shader)
1931 {
1932     if (isContextLostOrPending() || !validateWebGLObject(&quot;detachShader&quot;, program) || !validateWebGLObject(&quot;detachShader&quot;, shader))
1933         return;
1934     if (!program-&gt;detachShader(shader)) {
<span class="line-modified">1935         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;detachShader&quot;, &quot;shader not attached&quot;);</span>
1936         return;
1937     }
1938     m_context-&gt;detachShader(objectOrZero(program), objectOrZero(shader));
<span class="line-modified">1939     shader-&gt;onDetached(graphicsContextGL());</span>
1940 }
1941 
<span class="line-modified">1942 void WebGLRenderingContextBase::disable(GCGLenum cap)</span>
1943 {
1944     if (isContextLostOrPending() || !validateCapability(&quot;disable&quot;, cap))
1945         return;
<span class="line-modified">1946     if (cap == GraphicsContextGL::STENCIL_TEST) {</span>
1947         m_stencilEnabled = false;
1948         applyStencilTest();
1949         return;
1950     }
<span class="line-modified">1951     if (cap == GraphicsContextGL::SCISSOR_TEST)</span>
1952         m_scissorEnabled = false;
1953     m_context-&gt;disable(cap);
1954 }
1955 
<span class="line-modified">1956 void WebGLRenderingContextBase::disableVertexAttribArray(GCGLuint index)</span>
1957 {
1958     if (isContextLostOrPending())
1959         return;
1960     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">1961         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;disableVertexAttribArray&quot;, &quot;index out of range&quot;);</span>
1962         return;
1963     }
1964 
1965     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
1966     state.enabled = false;
1967 
1968     if (index &gt; 0 || isGLES2Compliant())
1969         m_context-&gt;disableVertexAttribArray(index);
1970 }
1971 
<span class="line-modified">1972 bool WebGLRenderingContextBase::validateNPOTTextureLevel(GCGLsizei width, GCGLsizei height, GCGLint level, const char* functionName)</span>
1973 {
1974     if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
<span class="line-modified">1975         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level &gt; 0 not power of 2&quot;);</span>
1976         return false;
1977     }
1978 
1979     return true;
1980 }
1981 
<span class="line-modified">1982 bool WebGLRenderingContextBase::validateElementArraySize(GCGLsizei count, GCGLenum type, GCGLintptr offset)</span>
1983 {
1984     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
1985 
1986     if (!elementArrayBuffer)
1987         return false;
1988 
1989     if (offset &lt; 0)
1990         return false;
1991 
<span class="line-modified">1992     if (type == GraphicsContextGL::UNSIGNED_INT) {</span>
1993         // For an unsigned int array, offset must be divisible by 4 for alignment reasons.
1994         if (offset % 4)
1995             return false;
1996 
1997         // Make uoffset an element offset.
1998         offset /= 4;
1999 
<span class="line-modified">2000         GCGLsizeiptr n = elementArrayBuffer-&gt;byteLength() / 4;</span>
2001         if (offset &gt; n || count &gt; n - offset)
2002             return false;
<span class="line-modified">2003     } else if (type == GraphicsContextGL::UNSIGNED_SHORT) {</span>
2004         // For an unsigned short array, offset must be divisible by 2 for alignment reasons.
2005         if (offset % 2)
2006             return false;
2007 
2008         // Make uoffset an element offset.
2009         offset /= 2;
2010 
<span class="line-modified">2011         GCGLsizeiptr n = elementArrayBuffer-&gt;byteLength() / 2;</span>
2012         if (offset &gt; n || count &gt; n - offset)
2013             return false;
<span class="line-modified">2014     } else if (type == GraphicsContextGL::UNSIGNED_BYTE) {</span>
<span class="line-modified">2015         GCGLsizeiptr n = elementArrayBuffer-&gt;byteLength();</span>
2016         if (offset &gt; n || count &gt; n - offset)
2017             return false;
2018     }
2019     return true;
2020 }
2021 
<span class="line-modified">2022 bool WebGLRenderingContextBase::validateIndexArrayPrecise(GCGLsizei count, GCGLenum type, GCGLintptr offset, unsigned&amp; numElementsRequired)</span>
2023 {
2024     ASSERT(count &gt;= 0 &amp;&amp; offset &gt;= 0);
2025     unsigned maxIndex = 0;
2026 
2027     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
2028 
2029     if (!elementArrayBuffer)
2030         return false;
2031 
2032     if (!count) {
2033         numElementsRequired = 0;
2034         return true;
2035     }
2036 
2037     auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
2038     if (!buffer)
2039         return false;
2040 
2041     switch (type) {
<span class="line-modified">2042     case GraphicsContextGL::UNSIGNED_INT:</span>
<span class="line-modified">2043         maxIndex = getMaxIndex&lt;GCGLuint&gt;(buffer, offset, count);</span>
2044         break;
<span class="line-modified">2045     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="line-modified">2046         maxIndex = getMaxIndex&lt;GCGLushort&gt;(buffer, offset, count);</span>
2047         break;
<span class="line-modified">2048     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">2049         maxIndex = getMaxIndex&lt;GCGLubyte&gt;(buffer, offset, count);</span>
2050         break;
2051     }
2052 
2053     // Then set the maxiumum index in the index array and make sure it is valid.
2054     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex, 1, 1);
2055     if (!checkedNumElementsRequired)
2056         return false;
2057     numElementsRequired = checkedNumElementsRequired.value();
2058     return true;
2059 }
2060 
2061 bool WebGLRenderingContextBase::validateVertexAttributes(unsigned elementCount, unsigned primitiveCount)
2062 {
<span class="line-modified">2063 #if USE(ANGLE)</span>
<span class="line-added">2064     UNUSED_PARAM(elementCount);</span>
<span class="line-added">2065     UNUSED_PARAM(primitiveCount);</span>
<span class="line-added">2066 #else</span>
2067     if (!m_currentProgram)
2068         return false;
2069 
2070     // Look in each enabled vertex attrib and check if they&#39;ve been bound to a buffer.
2071     for (unsigned i = 0; i &lt; m_maxVertexAttribs; ++i) {
2072         if (!m_boundVertexArrayObject-&gt;getVertexAttribState(i).validateBinding())
2073             return false;
2074     }
2075 
2076     if (!elementCount)
2077         return true;
2078 
2079     // Look in each consumed vertex attrib (by the current program).
2080     bool sawNonInstancedAttrib = false;
2081     bool sawEnabledAttrib = false;
2082     int numActiveAttribLocations = m_currentProgram-&gt;numActiveAttribLocations();
2083     for (int i = 0; i &lt; numActiveAttribLocations; ++i) {
2084         int loc = m_currentProgram-&gt;getActiveAttribLocation(i);
2085         if (loc &gt;= 0 &amp;&amp; loc &lt; static_cast&lt;int&gt;(m_maxVertexAttribs)) {
2086             const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(loc);
</pre>
<hr />
<pre>
2107                         return false;
2108                 }
2109             }
2110         }
2111     }
2112 
2113     if (!sawNonInstancedAttrib &amp;&amp; sawEnabledAttrib)
2114         return false;
2115 
2116     bool usingSimulatedArrayBuffer = m_currentProgram-&gt;isUsingVertexAttrib0();
2117 
2118     // Guard against access into non-existent buffers.
2119     if (elementCount &amp;&amp; !sawEnabledAttrib &amp;&amp; !usingSimulatedArrayBuffer)
2120         return false;
2121 
2122     if (elementCount &amp;&amp; sawEnabledAttrib) {
2123         if (!m_boundArrayBuffer &amp;&amp; !m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
2124             if (usingSimulatedArrayBuffer) {
2125                 auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
2126                 if (state.enabled &amp;&amp; state.isBound()) {
<span class="line-modified">2127                     if (state.bufferBinding-&gt;getTarget() == GraphicsContextGL::ARRAY_BUFFER || state.bufferBinding-&gt;getTarget() == GraphicsContextGL::ELEMENT_ARRAY_BUFFER)</span>
2128                         return !!state.bufferBinding-&gt;byteLength();
2129                 }
2130             }
2131             return false;
2132         }
2133     }
2134 #endif
2135 
2136     return true;
2137 }
2138 
2139 bool WebGLRenderingContextBase::validateWebGLObject(const char* functionName, WebGLObject* object)
2140 {
2141     if (!object || !object-&gt;object()) {
<span class="line-modified">2142         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no object or object deleted&quot;);</span>
2143         return false;
2144     }
2145     if (!object-&gt;validate(contextGroup(), *this)) {
<span class="line-modified">2146         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;object does not belong to this context&quot;);</span>
2147         return false;
2148     }
2149     return true;
2150 }
2151 
<span class="line-modified">2152 bool WebGLRenderingContextBase::validateDrawArrays(const char* functionName, GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primitiveCount)</span>
2153 {
2154     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
2155         return false;
2156 
2157     if (!validateStencilSettings(functionName))
2158         return false;
2159 
2160     if (first &lt; 0 || count &lt; 0) {
<span class="line-modified">2161         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;first or count &lt; 0&quot;);</span>
2162         return false;
2163     }
2164 
2165     if (!count) {
2166         markContextChanged();
2167         return false;
2168     }
2169 
2170     if (primitiveCount &lt; 0) {
<span class="line-modified">2171         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);</span>
2172         return false;
2173     }
2174 
2175     // Ensure we have a valid rendering state.
<span class="line-modified">2176     Checked&lt;GCGLint, RecordOverflow&gt; checkedSum = Checked&lt;GCGLint, RecordOverflow&gt;(first) + Checked&lt;GCGLint, RecordOverflow&gt;(count);</span>
<span class="line-modified">2177     Checked&lt;GCGLint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);</span>
2178     if (checkedSum.hasOverflowed() || checkedPrimitiveCount.hasOverflowed() || !validateVertexAttributes(checkedSum.unsafeGet(), checkedPrimitiveCount.unsafeGet())) {
<span class="line-modified">2179         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
2180         return false;
2181     }
2182     if (!validateSimulatedVertexAttrib0(checkedSum.unsafeGet() - 1)) {
<span class="line-modified">2183         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);</span>
2184         return false;
2185     }
2186 
2187     const char* reason = &quot;framebuffer incomplete&quot;;
<span class="line-modified">2188     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="line-modified">2189         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);</span>
2190         return false;
2191     }
2192 
2193     return true;
2194 }
2195 
<span class="line-modified">2196 bool WebGLRenderingContextBase::validateDrawElements(const char* functionName, GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, unsigned&amp; numElements, GCGLsizei primitiveCount)</span>
2197 {
2198     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
2199         return false;
2200 
2201     if (!validateStencilSettings(functionName))
2202         return false;
2203 
2204     switch (type) {
<span class="line-modified">2205     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">2206     case GraphicsContextGL::UNSIGNED_SHORT:</span>
2207         break;
<span class="line-modified">2208     case GraphicsContextGL::UNSIGNED_INT:</span>
2209         if (m_oesElementIndexUint || isWebGL2())
2210             break;
<span class="line-modified">2211         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid type&quot;);</span>
2212         return false;
2213     default:
<span class="line-modified">2214         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid type&quot;);</span>
2215         return false;
2216     }
2217 
2218     if (count &lt; 0 || offset &lt; 0) {
<span class="line-modified">2219         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;count or offset &lt; 0&quot;);</span>
2220         return false;
2221     }
2222 
2223     if (!count) {
2224         markContextChanged();
2225         return false;
2226     }
2227 
2228     if (primitiveCount &lt; 0) {
<span class="line-modified">2229         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);</span>
2230         return false;
2231     }
2232 
2233     if (!m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
<span class="line-modified">2234         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;no ELEMENT_ARRAY_BUFFER bound&quot;);</span>
2235         return false;
2236     }
2237 
2238     // Ensure we have a valid rendering state.
<span class="line-modified">2239     if (!validateElementArraySize(count, type, static_cast&lt;GCGLintptr&gt;(offset))) {</span>
<span class="line-modified">2240         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;request out of bounds for current ELEMENT_ARRAY_BUFFER&quot;);</span>
2241         return false;
2242     }
2243     if (!count)
2244         return false;
2245 
<span class="line-modified">2246     Checked&lt;GCGLint, RecordOverflow&gt; checkedCount(count);</span>
<span class="line-modified">2247     Checked&lt;GCGLint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);</span>
2248     if (checkedCount.hasOverflowed() || checkedPrimitiveCount.hasOverflowed()) {
<span class="line-modified">2249         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
2250         return false;
2251     }
2252 
2253     if (!validateIndexArrayConservative(type, numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {
<span class="line-modified">2254         if (!validateIndexArrayPrecise(checkedCount.unsafeGet(), type, static_cast&lt;GCGLintptr&gt;(offset), numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {</span>
<span class="line-modified">2255             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
2256             return false;
2257         }
2258     }
2259 
2260     if (!validateSimulatedVertexAttrib0(numElements)) {
<span class="line-modified">2261         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);</span>
2262         return false;
2263     }
2264 
2265     const char* reason = &quot;framebuffer incomplete&quot;;
<span class="line-modified">2266     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="line-modified">2267         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);</span>
2268         return false;
2269     }
2270 
2271     return true;
2272 }
2273 
<span class="line-modified">2274 void WebGLRenderingContextBase::drawArrays(GCGLenum mode, GCGLint first, GCGLsizei count)</span>
2275 {
2276     if (!validateDrawArrays(&quot;drawArrays&quot;, mode, first, count, 0))
2277         return;
2278 
<span class="line-modified">2279     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isWebGLProgramDisabled(*this, *m_currentProgram))</span>
2280         return;
2281 
2282     clearIfComposited();
2283 
2284     bool vertexAttrib0Simulated = false;
2285     if (!isGLES2Compliant()) {
2286         auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
2287         if (!simulateVertexAttrib0Status) {
2288             // We were unable to simulate the attribute buffer.
<span class="line-modified">2289             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawArrays&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
2290             return;
2291         }
2292         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
2293     }
2294     bool usesFallbackTexture = false;
2295     if (!isGLES2NPOTStrict())
2296         usesFallbackTexture = checkTextureCompleteness(&quot;drawArrays&quot;, true);
2297 
2298     {
2299         InspectorScopedShaderProgramHighlight scopedHighlight(*this, m_currentProgram.get());
2300 
2301         m_context-&gt;drawArrays(mode, first, count);
2302     }
2303 
2304     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
2305         restoreStatesAfterVertexAttrib0Simulation();
2306     if (usesFallbackTexture)
2307         checkTextureCompleteness(&quot;drawArrays&quot;, false);
2308     markContextChangedAndNotifyCanvasObserver();
2309 }
2310 
2311 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
<span class="line-modified">2312 static GCGLuint getRestartIndex(GCGLenum type)</span>
2313 {
2314     switch (type) {
<span class="line-modified">2315     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">2316         return std::numeric_limits&lt;GCGLubyte&gt;::max();</span>
<span class="line-modified">2317     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="line-modified">2318         return std::numeric_limits&lt;GCGLushort&gt;::max();</span>
<span class="line-modified">2319     case GraphicsContextGL::UNSIGNED_INT:</span>
<span class="line-modified">2320         return std::numeric_limits&lt;GCGLuint&gt;::max();</span>
2321     }
2322 
2323     return 0;
2324 }
2325 #endif
2326 
<span class="line-modified">2327 void WebGLRenderingContextBase::drawElements(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset)</span>
2328 {
2329     unsigned numElements = 0;
2330     if (!validateDrawElements(&quot;drawElements&quot;, mode, count, type, offset, numElements, 0))
2331         return;
2332 
<span class="line-modified">2333     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isWebGLProgramDisabled(*this, *m_currentProgram))</span>
2334         return;
2335 
2336     clearIfComposited();
2337 
2338     bool vertexAttrib0Simulated = false;
2339     if (!isGLES2Compliant()) {
2340         if (!numElements)
<span class="line-modified">2341             validateIndexArrayPrecise(count, type, static_cast&lt;GCGLintptr&gt;(offset), numElements);</span>
2342         auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
2343         if (!simulateVertexAttrib0Status) {
2344             // We were unable to simulate the attribute buffer.
<span class="line-modified">2345             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawElements&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
2346             return;
2347         }
2348         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
2349     }
2350 
2351     bool usesFallbackTexture = false;
2352     if (!isGLES2NPOTStrict())
2353         usesFallbackTexture = checkTextureCompleteness(&quot;drawElements&quot;, true);
2354 
2355 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
2356     if (isWebGL2())
2357         m_context-&gt;primitiveRestartIndex(getRestartIndex(type));
2358 #endif
2359 
2360     {
2361         InspectorScopedShaderProgramHighlight scopedHighlight(*this, m_currentProgram.get());
2362 
<span class="line-modified">2363         m_context-&gt;drawElements(mode, count, type, static_cast&lt;GCGLintptr&gt;(offset));</span>
2364     }
2365 
2366     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
2367         restoreStatesAfterVertexAttrib0Simulation();
2368     if (usesFallbackTexture)
2369         checkTextureCompleteness(&quot;drawElements&quot;, false);
2370     markContextChangedAndNotifyCanvasObserver();
2371 }
2372 
<span class="line-modified">2373 void WebGLRenderingContextBase::enable(GCGLenum cap)</span>
2374 {
2375     if (isContextLostOrPending() || !validateCapability(&quot;enable&quot;, cap))
2376         return;
<span class="line-modified">2377     if (cap == GraphicsContextGL::STENCIL_TEST) {</span>
2378         m_stencilEnabled = true;
2379         applyStencilTest();
2380         return;
2381     }
<span class="line-modified">2382     if (cap == GraphicsContextGL::SCISSOR_TEST)</span>
2383         m_scissorEnabled = true;
2384     m_context-&gt;enable(cap);
2385 }
2386 
<span class="line-modified">2387 void WebGLRenderingContextBase::enableVertexAttribArray(GCGLuint index)</span>
2388 {
2389     if (isContextLostOrPending())
2390         return;
2391     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">2392         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;enableVertexAttribArray&quot;, &quot;index out of range&quot;);</span>
2393         return;
2394     }
2395 
2396     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
2397     state.enabled = true;
2398 
2399     m_context-&gt;enableVertexAttribArray(index);
2400 }
2401 
2402 void WebGLRenderingContextBase::finish()
2403 {
2404     if (isContextLostOrPending())
2405         return;
2406     m_context-&gt;finish();
2407 }
2408 
2409 void WebGLRenderingContextBase::flush()
2410 {
2411     if (isContextLostOrPending())
2412         return;
2413     m_context-&gt;flush();
2414 }
2415 
<span class="line-modified">2416 void WebGLRenderingContextBase::framebufferRenderbuffer(GCGLenum target, GCGLenum attachment, GCGLenum renderbuffertarget, WebGLRenderbuffer* buffer)</span>
2417 {
2418     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferRenderbuffer&quot;, target, attachment))
2419         return;
<span class="line-modified">2420     if (renderbuffertarget != GraphicsContextGL::RENDERBUFFER) {</span>
<span class="line-modified">2421         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;framebufferRenderbuffer&quot;, &quot;invalid target&quot;);</span>
2422         return;
2423     }
2424     if (buffer &amp;&amp; !buffer-&gt;validate(contextGroup(), *this)) {
<span class="line-modified">2425         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no buffer or buffer not from this context&quot;);</span>
<span class="line-added">2426         return;</span>
<span class="line-added">2427     }</span>
<span class="line-added">2428     if (buffer &amp;&amp; !buffer-&gt;hasEverBeenBound()) {</span>
<span class="line-added">2429         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;buffer has never been bound&quot;);</span>
2430         return;
2431     }
2432 
<span class="line-modified">2433     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
2434 
2435     // Don&#39;t allow the default framebuffer to be mutated; all current
2436     // implementations use an FBO internally in place of the default
2437     // FBO.
2438     if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
<span class="line-modified">2439         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no framebuffer bound&quot;);</span>
2440         return;
2441     }
<span class="line-modified">2442     PlatformGLObject bufferObject = objectOrZero(buffer);</span>
<span class="line-modified">2443 #if !USE(ANGLE)</span>
<span class="line-modified">2444     if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">2445         m_context-&gt;framebufferRenderbuffer(target, GraphicsContextGL::DEPTH_ATTACHMENT, renderbuffertarget, bufferObject);</span>
<span class="line-modified">2446         m_context-&gt;framebufferRenderbuffer(target, GraphicsContextGL::STENCIL_ATTACHMENT, renderbuffertarget, bufferObject);</span>
<span class="line-modified">2447     } else</span>
<span class="line-modified">2448 #endif</span>
2449         m_context-&gt;framebufferRenderbuffer(target, attachment, renderbuffertarget, bufferObject);

2450     targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, buffer);
2451     applyStencilTest();
2452 }
2453 
<span class="line-modified">2454 void WebGLRenderingContextBase::framebufferTexture2D(GCGLenum target, GCGLenum attachment, GCGLenum textarget, WebGLTexture* texture, GCGLint level)</span>
2455 {
2456     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferTexture2D&quot;, target, attachment))
2457         return;
2458     if (level &amp;&amp; isWebGL1()) {
<span class="line-modified">2459         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;framebufferTexture2D&quot;, &quot;level not 0&quot;);</span>
2460         return;
2461     }
2462     if (texture &amp;&amp; !texture-&gt;validate(contextGroup(), *this)) {
<span class="line-modified">2463         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no texture or texture not from this context&quot;);</span>
2464         return;
2465     }
2466 
<span class="line-modified">2467     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
2468 
2469     // Don&#39;t allow the default framebuffer to be mutated; all current
2470     // implementations use an FBO internally in place of the default
2471     // FBO.
2472     if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
<span class="line-modified">2473         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no framebuffer bound&quot;);</span>
2474         return;
2475     }
<span class="line-modified">2476     PlatformGLObject textureObject = objectOrZero(texture);</span>
<span class="line-modified">2477 </span>
<span class="line-modified">2478 #if !USE_ANGLE</span>
<span class="line-modified">2479     if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">2480         m_context-&gt;framebufferTexture2D(target, GraphicsContextGL::DEPTH_ATTACHMENT, textarget, textureObject, level);</span>
<span class="line-modified">2481         m_context-&gt;framebufferTexture2D(target, GraphicsContextGL::STENCIL_ATTACHMENT, textarget, textureObject, level);</span>
<span class="line-modified">2482     } else</span>
<span class="line-modified">2483 #endif</span>





2484         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);
<span class="line-modified">2485 </span>
2486     targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, textarget, texture, level);
2487     applyStencilTest();
2488 }
2489 
<span class="line-modified">2490 void WebGLRenderingContextBase::frontFace(GCGLenum mode)</span>
2491 {
2492     if (isContextLostOrPending())
2493         return;
2494     m_context-&gt;frontFace(mode);
2495 }
2496 
<span class="line-modified">2497 void WebGLRenderingContextBase::generateMipmap(GCGLenum target)</span>
2498 {
2499     if (isContextLostOrPending())
2500         return;
2501     auto tex = validateTextureBinding(&quot;generateMipmap&quot;, target, false);
2502     if (!tex)
2503         return;
2504     if (!tex-&gt;canGenerateMipmaps()) {
<span class="line-modified">2505         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;level 0 not power of 2 or not all the same size&quot;);</span>
2506         return;
2507     }
2508     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=123916. Compressed textures should be allowed in WebGL 2:
2509     if (tex-&gt;isCompressed()) {
<span class="line-modified">2510         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;trying to generate mipmaps from compressed texture&quot;);</span>
2511         return;
2512     }
2513     if (!validateSettableTexInternalFormat(&quot;generateMipmap&quot;, tex-&gt;getInternalFormat(target, 0)))
2514         return;
2515 
2516     // generateMipmap won&#39;t work properly if minFilter is not NEAREST_MIPMAP_LINEAR
2517     // on Mac.  Remove the hack once this driver bug is fixed.
2518 #if OS(DARWIN)
2519     bool needToResetMinFilter = false;
<span class="line-modified">2520     if (tex-&gt;getMinFilter() != GraphicsContextGL::NEAREST_MIPMAP_LINEAR) {</span>
<span class="line-modified">2521         m_context-&gt;texParameteri(target, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::NEAREST_MIPMAP_LINEAR);</span>
2522         needToResetMinFilter = true;
2523     }
2524 #endif
2525     m_context-&gt;generateMipmap(target);
2526 #if OS(DARWIN)
2527     if (needToResetMinFilter)
<span class="line-modified">2528         m_context-&gt;texParameteri(target, GraphicsContextGL::TEXTURE_MIN_FILTER, tex-&gt;getMinFilter());</span>
2529 #endif
2530     tex-&gt;generateMipmapLevelInfo();
2531 }
2532 
<span class="line-modified">2533 RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveAttrib(WebGLProgram* program, GCGLuint index)</span>
2534 {
2535     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveAttrib&quot;, program))
2536         return nullptr;
<span class="line-modified">2537     GraphicsContextGL::ActiveInfo info;</span>
2538     if (!m_context-&gt;getActiveAttrib(objectOrZero(program), index, info))
2539         return nullptr;
2540 
2541     LOG(WebGL, &quot;Returning active attribute %d: %s&quot;, index, info.name.utf8().data());
2542 
2543     return WebGLActiveInfo::create(info.name, info.type, info.size);
2544 }
2545 
<span class="line-modified">2546 RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveUniform(WebGLProgram* program, GCGLuint index)</span>
2547 {
2548     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveUniform&quot;, program))
2549         return nullptr;
<span class="line-modified">2550     GraphicsContextGL::ActiveInfo info;</span>
2551     if (!m_context-&gt;getActiveUniform(objectOrZero(program), index, info))
2552         return nullptr;
2553     if (!isGLES2Compliant())
2554         if (info.size &gt; 1 &amp;&amp; !info.name.endsWith(&quot;[0]&quot;))
2555             info.name.append(&quot;[0]&quot;);
2556 
2557     LOG(WebGL, &quot;Returning active uniform %d: %s&quot;, index, info.name.utf8().data());
2558 
2559     return WebGLActiveInfo::create(info.name, info.type, info.size);
2560 }
2561 
2562 Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; WebGLRenderingContextBase::getAttachedShaders(WebGLProgram* program)
2563 {
2564     if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttachedShaders&quot;, program))
2565         return WTF::nullopt;
2566 
<span class="line-modified">2567     const GCGLenum shaderTypes[] = {</span>
<span class="line-modified">2568         GraphicsContextGL::VERTEX_SHADER,</span>
<span class="line-modified">2569         GraphicsContextGL::FRAGMENT_SHADER</span>
2570     };
2571     Vector&lt;RefPtr&lt;WebGLShader&gt;&gt; shaderObjects;
2572     for (auto shaderType : shaderTypes) {
2573         RefPtr&lt;WebGLShader&gt; shader = program-&gt;getAttachedShader(shaderType);
2574         if (shader)
2575             shaderObjects.append(shader);
2576     }
2577     return shaderObjects;
2578 }
2579 
<span class="line-modified">2580 GCGLint WebGLRenderingContextBase::getAttribLocation(WebGLProgram* program, const String&amp; name)</span>
2581 {
2582     if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttribLocation&quot;, program))
2583         return -1;
2584     if (!validateLocationLength(&quot;getAttribLocation&quot;, name))
2585         return -1;
2586     if (!validateString(&quot;getAttribLocation&quot;, name))
2587         return -1;
2588     if (isPrefixReserved(name))
2589         return -1;
2590     if (!program-&gt;getLinkStatus()) {
<span class="line-modified">2591         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getAttribLocation&quot;, &quot;program not linked&quot;);</span>
2592         return -1;
2593     }
2594     return m_context-&gt;getAttribLocation(objectOrZero(program), name);
2595 }
2596 
<span class="line-modified">2597 WebGLAny WebGLRenderingContextBase::getBufferParameter(GCGLenum target, GCGLenum pname)</span>
2598 {
2599     if (isContextLostOrPending())
2600         return nullptr;
2601 
2602     bool valid = false;
<span class="line-modified">2603     if (target == GraphicsContextGL::ARRAY_BUFFER || target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER)</span>
2604         valid = true;
2605 #if ENABLE(WEBGL2)
2606     if (isWebGL2()) {
2607         switch (target) {
<span class="line-modified">2608         case GraphicsContextGL::COPY_READ_BUFFER:</span>
<span class="line-modified">2609         case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
<span class="line-modified">2610         case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">2611         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">2612         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">2613         case GraphicsContextGL::UNIFORM_BUFFER:</span>
2614             valid = true;
2615         }
2616     }
2617 #endif
2618     if (!valid) {
<span class="line-modified">2619         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid target&quot;);</span>
2620         return nullptr;
2621     }
2622 
<span class="line-modified">2623     if (pname != GraphicsContextGL::BUFFER_SIZE &amp;&amp; pname != GraphicsContextGL::BUFFER_USAGE) {</span>
<span class="line-modified">2624         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
2625         return nullptr;
2626     }
2627 
<span class="line-modified">2628     GCGLint value = 0;</span>
2629     m_context-&gt;getBufferParameteriv(target, pname, &amp;value);
<span class="line-modified">2630     if (pname == GraphicsContextGL::BUFFER_SIZE)</span>
2631         return value;
2632     return static_cast&lt;unsigned&gt;(value);
2633 }
2634 
2635 Optional&lt;WebGLContextAttributes&gt; WebGLRenderingContextBase::getContextAttributes()
2636 {
2637     if (isContextLostOrPending())
2638         return WTF::nullopt;
2639 
2640     // Also, we need to enforce requested values of &quot;false&quot; for depth
2641     // and stencil, regardless of the properties of the underlying
<span class="line-modified">2642     // GraphicsContextGLOpenGL.</span>
2643 
<span class="line-modified">2644     auto attributes = m_context-&gt;contextAttributes();</span>
2645     if (!m_attributes.depth)
2646         attributes.depth = false;
2647     if (!m_attributes.stencil)
2648         attributes.stencil = false;
2649     return attributes;
2650 }
2651 
<span class="line-modified">2652 GCGLenum WebGLRenderingContextBase::getError()</span>
2653 {
2654     if (m_isPendingPolicyResolution)
<span class="line-modified">2655         return GraphicsContextGL::NO_ERROR;</span>
2656     return m_context-&gt;getError();
2657 }
2658 
<span class="line-modified">2659 WebGLAny WebGLRenderingContextBase::getProgramParameter(WebGLProgram* program, GCGLenum pname)</span>
2660 {
2661     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramParameter&quot;, program))
2662         return nullptr;
2663 
<span class="line-modified">2664     GCGLint value = 0;</span>
2665     switch (pname) {
<span class="line-modified">2666     case GraphicsContextGL::DELETE_STATUS:</span>
2667         return program-&gt;isDeleted();
<span class="line-modified">2668     case GraphicsContextGL::VALIDATE_STATUS:</span>
2669         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2670         return static_cast&lt;bool&gt;(value);
<span class="line-modified">2671     case GraphicsContextGL::LINK_STATUS:</span>
2672         return program-&gt;getLinkStatus();
<span class="line-modified">2673     case GraphicsContextGL::ATTACHED_SHADERS:</span>
2674         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2675         return value;
<span class="line-modified">2676     case GraphicsContextGL::ACTIVE_ATTRIBUTES:</span>
<span class="line-modified">2677     case GraphicsContextGL::ACTIVE_UNIFORMS:</span>
2678 #if USE(ANGLE)
2679         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2680 #else
2681         m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), pname, &amp;value);
2682 #endif // USE(ANGLE)
2683         return value;
2684     default:
<span class="line-modified">2685 #if ENABLE(WEBGL2)</span>
<span class="line-added">2686         if (isWebGL2()) {</span>
<span class="line-added">2687             switch (pname) {</span>
<span class="line-added">2688             case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER_MODE:</span>
<span class="line-added">2689             case GraphicsContextGL::TRANSFORM_FEEDBACK_VARYINGS:</span>
<span class="line-added">2690             case GraphicsContextGL::ACTIVE_UNIFORM_BLOCKS:</span>
<span class="line-added">2691                 m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);</span>
<span class="line-added">2692                 return value;</span>
<span class="line-added">2693             default:</span>
<span class="line-added">2694                 break;</span>
<span class="line-added">2695             }</span>
<span class="line-added">2696         }</span>
<span class="line-added">2697 #endif // ENABLE(WEBGL2)</span>
<span class="line-added">2698         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getProgramParameter&quot;, &quot;invalid parameter name&quot;);</span>
2699         return nullptr;
2700     }
2701 }
2702 
2703 String WebGLRenderingContextBase::getProgramInfoLog(WebGLProgram* program)
2704 {
2705     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramInfoLog&quot;, program))
2706         return String();
2707     return ensureNotNull(m_context-&gt;getProgramInfoLog(objectOrZero(program)));
2708 }
2709 
<span class="line-modified">2710 WebGLAny WebGLRenderingContextBase::getRenderbufferParameter(GCGLenum target, GCGLenum pname)</span>
2711 {
2712     if (isContextLostOrPending())
2713         return nullptr;
<span class="line-modified">2714     if (target != GraphicsContextGL::RENDERBUFFER) {</span>
<span class="line-modified">2715         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid target&quot;);</span>
2716         return nullptr;
2717     }
2718     if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
<span class="line-modified">2719         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getRenderbufferParameter&quot;, &quot;no renderbuffer bound&quot;);</span>
2720         return nullptr;
2721     }
2722 
<span class="line-modified">2723     if (m_renderbufferBinding-&gt;getInternalFormat() == GraphicsContextGL::DEPTH_STENCIL</span>
2724         &amp;&amp; !m_renderbufferBinding-&gt;isValid()) {
2725         ASSERT(!isDepthStencilSupported());
2726         int value = 0;
2727         switch (pname) {
<span class="line-modified">2728         case GraphicsContextGL::RENDERBUFFER_WIDTH:</span>
2729             value = m_renderbufferBinding-&gt;getWidth();
2730             break;
<span class="line-modified">2731         case GraphicsContextGL::RENDERBUFFER_HEIGHT:</span>
2732             value = m_renderbufferBinding-&gt;getHeight();
2733             break;
<span class="line-modified">2734         case GraphicsContextGL::RENDERBUFFER_RED_SIZE:</span>
<span class="line-modified">2735         case GraphicsContextGL::RENDERBUFFER_GREEN_SIZE:</span>
<span class="line-modified">2736         case GraphicsContextGL::RENDERBUFFER_BLUE_SIZE:</span>
<span class="line-modified">2737         case GraphicsContextGL::RENDERBUFFER_ALPHA_SIZE:</span>
2738             value = 0;
2739             break;
<span class="line-modified">2740         case GraphicsContextGL::RENDERBUFFER_DEPTH_SIZE:</span>
2741             value = 24;
2742             break;
<span class="line-modified">2743         case GraphicsContextGL::RENDERBUFFER_STENCIL_SIZE:</span>
2744             value = 8;
2745             break;
<span class="line-modified">2746         case GraphicsContextGL::RENDERBUFFER_INTERNAL_FORMAT:</span>
2747             return m_renderbufferBinding-&gt;getInternalFormat();
2748         default:
<span class="line-modified">2749             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
2750             return nullptr;
2751         }
2752         return value;
2753     }
2754 
<span class="line-modified">2755     GCGLint value = 0;</span>
2756     switch (pname) {
<span class="line-modified">2757     case GraphicsContextGL::RENDERBUFFER_WIDTH:</span>
<span class="line-modified">2758     case GraphicsContextGL::RENDERBUFFER_HEIGHT:</span>
<span class="line-modified">2759     case GraphicsContextGL::RENDERBUFFER_RED_SIZE:</span>
<span class="line-modified">2760     case GraphicsContextGL::RENDERBUFFER_GREEN_SIZE:</span>
<span class="line-modified">2761     case GraphicsContextGL::RENDERBUFFER_BLUE_SIZE:</span>
<span class="line-modified">2762     case GraphicsContextGL::RENDERBUFFER_ALPHA_SIZE:</span>
<span class="line-modified">2763     case GraphicsContextGL::RENDERBUFFER_DEPTH_SIZE:</span>
<span class="line-modified">2764     case GraphicsContextGL::RENDERBUFFER_STENCIL_SIZE:</span>
2765         m_context-&gt;getRenderbufferParameteriv(target, pname, &amp;value);
2766         return value;
<span class="line-modified">2767     case GraphicsContextGL::RENDERBUFFER_INTERNAL_FORMAT:</span>
2768         return m_renderbufferBinding-&gt;getInternalFormat();
2769     default:
<span class="line-modified">2770         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
2771         return nullptr;
2772     }
2773 }
2774 
<span class="line-modified">2775 WebGLAny WebGLRenderingContextBase::getShaderParameter(WebGLShader* shader, GCGLenum pname)</span>
2776 {
2777     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderParameter&quot;, shader))
2778         return nullptr;
<span class="line-modified">2779     GCGLint value = 0;</span>
2780     switch (pname) {
<span class="line-modified">2781     case GraphicsContextGL::DELETE_STATUS:</span>
2782         return shader-&gt;isDeleted();
<span class="line-modified">2783     case GraphicsContextGL::COMPILE_STATUS:</span>
2784         m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
2785         return static_cast&lt;bool&gt;(value);
<span class="line-modified">2786     case GraphicsContextGL::SHADER_TYPE:</span>
2787         m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
2788         return static_cast&lt;unsigned&gt;(value);
2789     default:
<span class="line-modified">2790         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getShaderParameter&quot;, &quot;invalid parameter name&quot;);</span>
2791         return nullptr;
2792     }
2793 }
2794 
2795 String WebGLRenderingContextBase::getShaderInfoLog(WebGLShader* shader)
2796 {
2797     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderInfoLog&quot;, shader))
2798         return String();
2799     return ensureNotNull(m_context-&gt;getShaderInfoLog(objectOrZero(shader)));
2800 }
2801 
<span class="line-modified">2802 RefPtr&lt;WebGLShaderPrecisionFormat&gt; WebGLRenderingContextBase::getShaderPrecisionFormat(GCGLenum shaderType, GCGLenum precisionType)</span>
2803 {
2804     if (isContextLostOrPending())
2805         return nullptr;
2806     switch (shaderType) {
<span class="line-modified">2807     case GraphicsContextGL::VERTEX_SHADER:</span>
<span class="line-modified">2808     case GraphicsContextGL::FRAGMENT_SHADER:</span>
2809         break;
2810     default:
<span class="line-modified">2811         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid shader type&quot;);</span>
2812         return nullptr;
2813     }
2814     switch (precisionType) {
<span class="line-modified">2815     case GraphicsContextGL::LOW_FLOAT:</span>
<span class="line-modified">2816     case GraphicsContextGL::MEDIUM_FLOAT:</span>
<span class="line-modified">2817     case GraphicsContextGL::HIGH_FLOAT:</span>
<span class="line-modified">2818     case GraphicsContextGL::LOW_INT:</span>
<span class="line-modified">2819     case GraphicsContextGL::MEDIUM_INT:</span>
<span class="line-modified">2820     case GraphicsContextGL::HIGH_INT:</span>
2821         break;
2822     default:
<span class="line-modified">2823         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid precision type&quot;);</span>
2824         return nullptr;
2825     }
2826 
<span class="line-modified">2827     GCGLint range[2] = {0, 0};</span>
<span class="line-modified">2828     GCGLint precision = 0;</span>
2829     m_context-&gt;getShaderPrecisionFormat(shaderType, precisionType, range, &amp;precision);
2830     return WebGLShaderPrecisionFormat::create(range[0], range[1], precision);
2831 }
2832 
2833 String WebGLRenderingContextBase::getShaderSource(WebGLShader* shader)
2834 {
2835     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderSource&quot;, shader))
2836         return String();
2837     return ensureNotNull(shader-&gt;getSource());
2838 }
2839 
<span class="line-modified">2840 WebGLAny WebGLRenderingContextBase::getTexParameter(GCGLenum target, GCGLenum pname)</span>
2841 {
2842     if (isContextLostOrPending())
2843         return nullptr;
2844     auto tex = validateTextureBinding(&quot;getTexParameter&quot;, target, false);
2845     if (!tex)
2846         return nullptr;
<span class="line-modified">2847     GCGLint value = 0;</span>
<span class="line-added">2848     GCGLfloat fValue = 0;</span>
2849     switch (pname) {
<span class="line-modified">2850     case GraphicsContextGL::TEXTURE_MAG_FILTER:</span>
<span class="line-modified">2851     case GraphicsContextGL::TEXTURE_MIN_FILTER:</span>
<span class="line-modified">2852     case GraphicsContextGL::TEXTURE_WRAP_S:</span>
<span class="line-modified">2853     case GraphicsContextGL::TEXTURE_WRAP_T:</span>
2854         m_context-&gt;getTexParameteriv(target, pname, &amp;value);
2855         return static_cast&lt;unsigned&gt;(value);
<span class="line-modified">2856     case ExtensionsGL::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
2857         if (m_extTextureFilterAnisotropic) {
<span class="line-modified">2858             m_context-&gt;getTexParameterfv(target, pname, &amp;fValue);</span>
<span class="line-modified">2859             return static_cast&lt;float&gt;(fValue);</span>
2860         }
<span class="line-modified">2861         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);</span>
2862         return nullptr;
2863     default:
<span class="line-modified">2864         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name&quot;);</span>
2865         return nullptr;
2866     }
2867 }
2868 
2869 WebGLAny WebGLRenderingContextBase::getUniform(WebGLProgram* program, const WebGLUniformLocation* uniformLocation)
2870 {
2871     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniform&quot;, program))
2872         return nullptr;
2873     if (!uniformLocation || uniformLocation-&gt;program() != program) {
<span class="line-modified">2874         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getUniform&quot;, &quot;no uniformlocation or not valid for this program&quot;);</span>
2875         return nullptr;
2876     }
<span class="line-modified">2877     GCGLint location = uniformLocation-&gt;location();</span>
2878 
<span class="line-modified">2879     GCGLenum baseType;</span>
2880     unsigned length;
2881     switch (uniformLocation-&gt;type()) {
<span class="line-modified">2882     case GraphicsContextGL::BOOL:</span>
<span class="line-modified">2883         baseType = GraphicsContextGL::BOOL;</span>
2884         length = 1;
2885         break;
<span class="line-modified">2886     case GraphicsContextGL::BOOL_VEC2:</span>
<span class="line-modified">2887         baseType = GraphicsContextGL::BOOL;</span>
2888         length = 2;
2889         break;
<span class="line-modified">2890     case GraphicsContextGL::BOOL_VEC3:</span>
<span class="line-modified">2891         baseType = GraphicsContextGL::BOOL;</span>
2892         length = 3;
2893         break;
<span class="line-modified">2894     case GraphicsContextGL::BOOL_VEC4:</span>
<span class="line-modified">2895         baseType = GraphicsContextGL::BOOL;</span>
2896         length = 4;
2897         break;
<span class="line-modified">2898     case GraphicsContextGL::INT:</span>
<span class="line-modified">2899         baseType = GraphicsContextGL::INT;</span>
2900         length = 1;
2901         break;
<span class="line-modified">2902     case GraphicsContextGL::INT_VEC2:</span>
<span class="line-modified">2903         baseType = GraphicsContextGL::INT;</span>
2904         length = 2;
2905         break;
<span class="line-modified">2906     case GraphicsContextGL::INT_VEC3:</span>
<span class="line-modified">2907         baseType = GraphicsContextGL::INT;</span>
2908         length = 3;
2909         break;
<span class="line-modified">2910     case GraphicsContextGL::INT_VEC4:</span>
<span class="line-modified">2911         baseType = GraphicsContextGL::INT;</span>
2912         length = 4;
2913         break;
<span class="line-modified">2914     case GraphicsContextGL::FLOAT:</span>
<span class="line-modified">2915         baseType = GraphicsContextGL::FLOAT;</span>
2916         length = 1;
2917         break;
<span class="line-modified">2918     case GraphicsContextGL::FLOAT_VEC2:</span>
<span class="line-modified">2919         baseType = GraphicsContextGL::FLOAT;</span>
2920         length = 2;
2921         break;
<span class="line-modified">2922     case GraphicsContextGL::FLOAT_VEC3:</span>
<span class="line-modified">2923         baseType = GraphicsContextGL::FLOAT;</span>
2924         length = 3;
2925         break;
<span class="line-modified">2926     case GraphicsContextGL::FLOAT_VEC4:</span>
<span class="line-modified">2927         baseType = GraphicsContextGL::FLOAT;</span>
2928         length = 4;
2929         break;
<span class="line-modified">2930     case GraphicsContextGL::FLOAT_MAT2:</span>
<span class="line-modified">2931         baseType = GraphicsContextGL::FLOAT;</span>
2932         length = 4;
2933         break;
<span class="line-modified">2934     case GraphicsContextGL::FLOAT_MAT3:</span>
<span class="line-modified">2935         baseType = GraphicsContextGL::FLOAT;</span>
2936         length = 9;
2937         break;
<span class="line-modified">2938     case GraphicsContextGL::FLOAT_MAT4:</span>
<span class="line-modified">2939         baseType = GraphicsContextGL::FLOAT;</span>
2940         length = 16;
2941         break;
<span class="line-modified">2942     case GraphicsContextGL::SAMPLER_2D:</span>
<span class="line-modified">2943     case GraphicsContextGL::SAMPLER_CUBE:</span>
<span class="line-modified">2944         baseType = GraphicsContextGL::INT;</span>
2945         length = 1;
2946         break;
2947     default:
2948         // Can&#39;t handle this type
<span class="line-modified">2949         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getUniform&quot;, &quot;unhandled type&quot;);</span>
2950         return nullptr;
2951     }
2952     switch (baseType) {
<span class="line-modified">2953     case GraphicsContextGL::FLOAT: {</span>
<span class="line-modified">2954         GCGLfloat value[16] = {0};</span>
2955         if (m_isRobustnessEXTSupported)
<span class="line-modified">2956             m_context-&gt;getExtensions().getnUniformfvEXT(objectOrZero(program), location, 16 * sizeof(GCGLfloat), value);</span>
2957         else
2958             m_context-&gt;getUniformfv(objectOrZero(program), location, value);
2959         if (length == 1)
2960             return value[0];
2961         return Float32Array::tryCreate(value, length);
2962     }
<span class="line-modified">2963     case GraphicsContextGL::INT: {</span>
<span class="line-modified">2964         GCGLint value[4] = {0};</span>
2965         if (m_isRobustnessEXTSupported)
<span class="line-modified">2966             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GCGLint), value);</span>
2967         else
2968             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2969         if (length == 1)
2970             return value[0];
2971         return Int32Array::tryCreate(value, length);
2972     }
<span class="line-modified">2973     case GraphicsContextGL::BOOL: {</span>
<span class="line-modified">2974         GCGLint value[4] = {0};</span>
2975         if (m_isRobustnessEXTSupported)
<span class="line-modified">2976             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GCGLint), value);</span>
2977         else
2978             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2979         if (length &gt; 1) {
2980             Vector&lt;bool&gt; vector(length);
2981             for (unsigned j = 0; j &lt; length; j++)
2982                 vector[j] = value[j];
2983             return vector;
2984         }
2985         return static_cast&lt;bool&gt;(value[0]);
2986     }
2987     default:
2988         notImplemented();
2989     }
2990 
2991     // If we get here, something went wrong in our unfortunately complex logic above
<span class="line-modified">2992     synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getUniform&quot;, &quot;unknown error&quot;);</span>
2993     return nullptr;
2994 }
2995 
2996 RefPtr&lt;WebGLUniformLocation&gt; WebGLRenderingContextBase::getUniformLocation(WebGLProgram* program, const String&amp; name)
2997 {
2998     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniformLocation&quot;, program))
2999         return nullptr;
3000     if (!validateLocationLength(&quot;getUniformLocation&quot;, name))
3001         return nullptr;
3002     if (!validateString(&quot;getUniformLocation&quot;, name))
3003         return nullptr;
3004     if (isPrefixReserved(name))
3005         return nullptr;
3006     if (!program-&gt;getLinkStatus()) {
<span class="line-modified">3007         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getUniformLocation&quot;, &quot;program not linked&quot;);</span>
3008         return nullptr;
3009     }
<span class="line-modified">3010     GCGLint uniformLocation = m_context-&gt;getUniformLocation(objectOrZero(program), name);</span>
3011     if (uniformLocation == -1)
3012         return nullptr;
3013 
<span class="line-modified">3014     GCGLint activeUniforms = 0;</span>
3015 #if USE(ANGLE)
<span class="line-modified">3016     m_context-&gt;getProgramiv(objectOrZero(program), GraphicsContextGL::ACTIVE_UNIFORMS, &amp;activeUniforms);</span>
3017 #else
<span class="line-modified">3018     m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), GraphicsContextGL::ACTIVE_UNIFORMS, &amp;activeUniforms);</span>
3019 #endif
<span class="line-modified">3020     for (GCGLint i = 0; i &lt; activeUniforms; i++) {</span>
<span class="line-modified">3021         GraphicsContextGL::ActiveInfo info;</span>
3022         if (!m_context-&gt;getActiveUniform(objectOrZero(program), i, info))
3023             return nullptr;
3024         // Strip &quot;[0]&quot; from the name if it&#39;s an array.
3025         if (info.name.endsWith(&quot;[0]&quot;))
3026             info.name = info.name.left(info.name.length() - 3);
3027         // If it&#39;s an array, we need to iterate through each element, appending &quot;[index]&quot; to the name.
<span class="line-modified">3028         for (GCGLint index = 0; index &lt; info.size; ++index) {</span>
3029             String uniformName = makeString(info.name, &#39;[&#39;, index, &#39;]&#39;);
3030 
3031             if (name == uniformName || name == info.name)
3032                 return WebGLUniformLocation::create(program, uniformLocation, info.type);
3033         }
3034     }
3035     return nullptr;
3036 }
3037 
<span class="line-modified">3038 WebGLAny WebGLRenderingContextBase::getVertexAttrib(GCGLuint index, GCGLenum pname)</span>
3039 {
3040     if (isContextLostOrPending())
3041         return nullptr;
3042 
3043     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">3044         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getVertexAttrib&quot;, &quot;index out of range&quot;);</span>
3045         return nullptr;
3046     }
3047 
3048     const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
3049 
<span class="line-modified">3050     if ((isWebGL2() || m_angleInstancedArrays) &amp;&amp; pname == GraphicsContextGL::VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)</span>
3051         return state.divisor;
3052 
3053     switch (pname) {
<span class="line-modified">3054     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:</span>
3055         if ((!isGLES2Compliant() &amp;&amp; !index &amp;&amp; m_boundVertexArrayObject-&gt;getVertexAttribState(0).bufferBinding == m_vertexAttrib0Buffer)
3056             || !state.bufferBinding
3057             || !state.bufferBinding-&gt;object())
3058             return nullptr;
3059         return state.bufferBinding;
<span class="line-modified">3060     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_ENABLED:</span>
3061         return state.enabled;
<span class="line-modified">3062     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_NORMALIZED:</span>
3063         return state.normalized;
<span class="line-modified">3064     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_SIZE:</span>
3065         return state.size;
<span class="line-modified">3066     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_STRIDE:</span>
3067         return state.originalStride;
<span class="line-modified">3068     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_TYPE:</span>
3069         return state.type;
<span class="line-modified">3070     case GraphicsContextGL::CURRENT_VERTEX_ATTRIB:</span>
3071         return Float32Array::tryCreate(m_vertexAttribValue[index].value, 4);
3072     default:
<span class="line-modified">3073         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getVertexAttrib&quot;, &quot;invalid parameter name&quot;);</span>
3074         return nullptr;
3075     }
3076 }
3077 
<span class="line-modified">3078 long long WebGLRenderingContextBase::getVertexAttribOffset(GCGLuint index, GCGLenum pname)</span>
3079 {
3080     if (isContextLostOrPending())
3081         return 0;
3082     return m_context-&gt;getVertexAttribOffset(index, pname);
3083 }
3084 
3085 bool WebGLRenderingContextBase::extensionIsEnabled(const String&amp; name)
3086 {
3087 #define CHECK_EXTENSION(variable, nameLiteral) \
3088     if (equalIgnoringASCIICase(name, nameLiteral)) \
3089         return variable != nullptr;
3090 
3091     CHECK_EXTENSION(m_extFragDepth, &quot;EXT_frag_depth&quot;);
3092     CHECK_EXTENSION(m_extBlendMinMax, &quot;EXT_blend_minmax&quot;);
3093     CHECK_EXTENSION(m_extsRGB, &quot;EXT_sRGB&quot;);
3094     CHECK_EXTENSION(m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;);
3095     CHECK_EXTENSION(m_extTextureFilterAnisotropic, &quot;WEBKIT_EXT_texture_filter_anisotropic&quot;);
3096     CHECK_EXTENSION(m_extShaderTextureLOD, &quot;EXT_shader_texture_lod&quot;);
3097     CHECK_EXTENSION(m_oesTextureFloat, &quot;OES_texture_float&quot;);
3098     CHECK_EXTENSION(m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;);
3099     CHECK_EXTENSION(m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;);
3100     CHECK_EXTENSION(m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;);
3101     CHECK_EXTENSION(m_oesStandardDerivatives, &quot;OES_standard_derivatives&quot;);
3102     CHECK_EXTENSION(m_oesVertexArrayObject, &quot;OES_vertex_array_object&quot;);
3103     CHECK_EXTENSION(m_oesElementIndexUint, &quot;OES_element_index_uint&quot;);
3104     CHECK_EXTENSION(m_webglLoseContext, &quot;WEBGL_lose_context&quot;);
3105     CHECK_EXTENSION(m_webglDebugRendererInfo, &quot;WEBGL_debug_renderer_info&quot;);
3106     CHECK_EXTENSION(m_webglDebugShaders, &quot;WEBGL_debug_shaders&quot;);
<span class="line-added">3107     CHECK_EXTENSION(m_webglCompressedTextureASTC, &quot;WEBGL_compressed_texture_astc&quot;);</span>
3108     CHECK_EXTENSION(m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;);
<span class="line-added">3109     CHECK_EXTENSION(m_webglCompressedTextureETC, &quot;WEBGL_compressed_texture_etc&quot;);</span>
<span class="line-added">3110     CHECK_EXTENSION(m_webglCompressedTextureETC1, &quot;WEBGL_compressed_texture_etc1&quot;);</span>
3111     CHECK_EXTENSION(m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;);
3112     CHECK_EXTENSION(m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;);
3113     CHECK_EXTENSION(m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;);
3114     CHECK_EXTENSION(m_webglDrawBuffers, &quot;WEBGL_draw_buffers&quot;);
3115     CHECK_EXTENSION(m_angleInstancedArrays, &quot;ANGLE_instanced_arrays&quot;);
3116     return false;
3117 }
3118 
<span class="line-modified">3119 GCGLboolean WebGLRenderingContextBase::isBuffer(WebGLBuffer* buffer)</span>
3120 {
3121     if (!buffer || isContextLostOrPending())
3122         return 0;
3123 
3124     if (!buffer-&gt;hasEverBeenBound())
3125         return 0;
3126 
3127     return m_context-&gt;isBuffer(buffer-&gt;object());
3128 }
3129 
3130 bool WebGLRenderingContextBase::isContextLost() const
3131 {
3132     return m_contextLost;
3133 }
3134 
3135 bool WebGLRenderingContextBase::isContextLostOrPending()
3136 {
3137     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution) {
3138         LOG(WebGL, &quot;Context is being used. Attempt to resolve the policy.&quot;);
3139         auto* canvas = htmlCanvas();
3140         if (canvas) {
3141             Document&amp; document = canvas-&gt;document().topDocument();
3142             Page* page = document.page();
3143             if (page &amp;&amp; !document.url().isLocalFile())
3144                 page-&gt;mainFrame().loader().client().resolveWebGLPolicyForURL(document.url());
3145             // FIXME: We don&#39;t currently do anything with the result from resolution. A more
3146             // complete implementation might try to construct a real context, etc and proceed
3147             // with normal operation.
3148             // https://bugs.webkit.org/show_bug.cgi?id=129122
3149         }
3150         m_hasRequestedPolicyResolution = true;
3151     }
3152 
3153     return m_contextLost || m_isPendingPolicyResolution;
3154 }
3155 
<span class="line-modified">3156 GCGLboolean WebGLRenderingContextBase::isEnabled(GCGLenum cap)</span>
3157 {
3158     if (isContextLostOrPending() || !validateCapability(&quot;isEnabled&quot;, cap))
3159         return 0;
<span class="line-modified">3160     if (cap == GraphicsContextGL::STENCIL_TEST)</span>
3161         return m_stencilEnabled;
3162     return m_context-&gt;isEnabled(cap);
3163 }
3164 
<span class="line-modified">3165 GCGLboolean WebGLRenderingContextBase::isFramebuffer(WebGLFramebuffer* framebuffer)</span>
3166 {
3167     if (!framebuffer || isContextLostOrPending())
3168         return 0;
3169 
3170     if (!framebuffer-&gt;hasEverBeenBound())
3171         return 0;
3172 
3173     return m_context-&gt;isFramebuffer(framebuffer-&gt;object());
3174 }
3175 
<span class="line-modified">3176 GCGLboolean WebGLRenderingContextBase::isProgram(WebGLProgram* program)</span>
3177 {
3178     if (!program || isContextLostOrPending())
3179         return 0;
3180 
3181     return m_context-&gt;isProgram(program-&gt;object());
3182 }
3183 
<span class="line-modified">3184 GCGLboolean WebGLRenderingContextBase::isRenderbuffer(WebGLRenderbuffer* renderbuffer)</span>
3185 {
3186     if (!renderbuffer || isContextLostOrPending())
3187         return 0;
3188 
3189     if (!renderbuffer-&gt;hasEverBeenBound())
3190         return 0;
3191 
3192     return m_context-&gt;isRenderbuffer(renderbuffer-&gt;object());
3193 }
3194 
<span class="line-modified">3195 GCGLboolean WebGLRenderingContextBase::isShader(WebGLShader* shader)</span>
3196 {
3197     if (!shader || isContextLostOrPending())
3198         return 0;
3199 
3200     return m_context-&gt;isShader(shader-&gt;object());
3201 }
3202 
<span class="line-modified">3203 GCGLboolean WebGLRenderingContextBase::isTexture(WebGLTexture* texture)</span>
3204 {
3205     if (!texture || isContextLostOrPending())
3206         return 0;
3207 
3208     if (!texture-&gt;hasEverBeenBound())
3209         return 0;
3210 
3211     return m_context-&gt;isTexture(texture-&gt;object());
3212 }
3213 
<span class="line-modified">3214 void WebGLRenderingContextBase::lineWidth(GCGLfloat width)</span>
3215 {
3216     if (isContextLostOrPending())
3217         return;
3218     m_context-&gt;lineWidth(width);
3219 }
3220 
3221 void WebGLRenderingContextBase::linkProgram(WebGLProgram* program)
3222 {
3223     if (!linkProgramWithoutInvalidatingAttribLocations(program))
3224         return;
3225 
3226     program-&gt;increaseLinkCount();
3227 }
3228 
3229 bool WebGLRenderingContextBase::linkProgramWithoutInvalidatingAttribLocations(WebGLProgram* program)
3230 {
3231     if (isContextLostOrPending() || !validateWebGLObject(&quot;linkProgram&quot;, program))
3232         return false;
3233 
<span class="line-modified">3234     RefPtr&lt;WebGLShader&gt; vertexShader = program-&gt;getAttachedShader(GraphicsContextGL::VERTEX_SHADER);</span>
<span class="line-modified">3235     RefPtr&lt;WebGLShader&gt; fragmentShader = program-&gt;getAttachedShader(GraphicsContextGL::FRAGMENT_SHADER);</span>
3236     if (!vertexShader || !vertexShader-&gt;isValid() || !fragmentShader || !fragmentShader-&gt;isValid()) {
3237         program-&gt;setLinkStatus(false);
3238         return false;
3239     }
3240 
3241 #if !USE(ANGLE)
3242     if (!m_context-&gt;precisionsMatch(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))
3243         || !m_context-&gt;checkVaryingsPacking(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))) {
3244         program-&gt;setLinkStatus(false);
3245         return false;
3246     }
3247 #endif
3248 
3249     m_context-&gt;linkProgram(objectOrZero(program));
3250     return true;
3251 }
3252 
<span class="line-modified">3253 void WebGLRenderingContextBase::pixelStorei(GCGLenum pname, GCGLint param)</span>
3254 {
3255     if (isContextLostOrPending())
3256         return;
3257     switch (pname) {
<span class="line-modified">3258     case GraphicsContextGL::UNPACK_FLIP_Y_WEBGL:</span>
3259         m_unpackFlipY = param;
3260         break;
<span class="line-modified">3261     case GraphicsContextGL::UNPACK_PREMULTIPLY_ALPHA_WEBGL:</span>
3262         m_unpackPremultiplyAlpha = param;
3263         break;
<span class="line-modified">3264     case GraphicsContextGL::UNPACK_COLORSPACE_CONVERSION_WEBGL:</span>
<span class="line-modified">3265         if (param == GraphicsContextGL::BROWSER_DEFAULT_WEBGL || param == GraphicsContextGL::NONE)</span>
<span class="line-modified">3266             m_unpackColorspaceConversion = static_cast&lt;GCGLenum&gt;(param);</span>
3267         else {
<span class="line-modified">3268             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for UNPACK_COLORSPACE_CONVERSION_WEBGL&quot;);</span>
3269             return;
3270         }
3271         break;
<span class="line-modified">3272     case GraphicsContextGL::PACK_ALIGNMENT:</span>
<span class="line-modified">3273     case GraphicsContextGL::UNPACK_ALIGNMENT:</span>
3274         if (param == 1 || param == 2 || param == 4 || param == 8) {
<span class="line-modified">3275             if (pname == GraphicsContextGL::PACK_ALIGNMENT)</span>
3276                 m_packAlignment = param;
<span class="line-modified">3277             else // GraphicsContextGL::UNPACK_ALIGNMENT:</span>
3278                 m_unpackAlignment = param;
3279             m_context-&gt;pixelStorei(pname, param);
3280         } else {
<span class="line-modified">3281             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for alignment&quot;);</span>
3282             return;
3283         }
3284         break;
3285     default:
<span class="line-modified">3286         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;pixelStorei&quot;, &quot;invalid parameter name&quot;);</span>
3287         return;
3288     }
3289 }
3290 
<span class="line-modified">3291 void WebGLRenderingContextBase::polygonOffset(GCGLfloat factor, GCGLfloat units)</span>
3292 {
3293     if (isContextLostOrPending())
3294         return;
3295     m_context-&gt;polygonOffset(factor, units);
3296 }
3297 
3298 enum class InternalFormatTheme {
3299     None,
3300     NormalizedFixedPoint,
3301     Packed,
3302     SignedNormalizedFixedPoint,
3303     FloatingPoint,
3304     SignedInteger,
3305     UnsignedInteger
3306 };
3307 
<span class="line-modified">3308 static InternalFormatTheme internalFormatTheme(GCGLenum internalFormat)</span>
3309 {
3310     switch (internalFormat) {
<span class="line-modified">3311     case GraphicsContextGL::RGB:</span>
<span class="line-modified">3312     case GraphicsContextGL::RGBA:</span>
<span class="line-modified">3313     case GraphicsContextGL::LUMINANCE_ALPHA:</span>
<span class="line-modified">3314     case GraphicsContextGL::LUMINANCE:</span>
<span class="line-modified">3315     case GraphicsContextGL::ALPHA:</span>
<span class="line-modified">3316     case GraphicsContextGL::R8:</span>
<span class="line-modified">3317     case GraphicsContextGL::RG8:</span>
<span class="line-modified">3318     case GraphicsContextGL::RGB8:</span>
<span class="line-modified">3319     case GraphicsContextGL::SRGB8:</span>
<span class="line-modified">3320     case GraphicsContextGL::RGBA8:</span>
<span class="line-modified">3321     case GraphicsContextGL::SRGB8_ALPHA8:</span>
<span class="line-modified">3322     case GraphicsContextGL::SRGB_ALPHA:</span>
3323         return InternalFormatTheme::NormalizedFixedPoint;
<span class="line-modified">3324     case GraphicsContextGL::RGB565:</span>
<span class="line-modified">3325     case GraphicsContextGL::RGB5_A1:</span>
<span class="line-modified">3326     case GraphicsContextGL::RGBA4:</span>
<span class="line-modified">3327     case GraphicsContextGL::RGB9_E5:</span>
<span class="line-modified">3328     case GraphicsContextGL::RGB10_A2:</span>
<span class="line-modified">3329     case GraphicsContextGL::R11F_G11F_B10F:</span>
<span class="line-modified">3330     case GraphicsContextGL::RGB10_A2UI:</span>
3331         return InternalFormatTheme::Packed;
<span class="line-modified">3332     case GraphicsContextGL::R8_SNORM:</span>
<span class="line-modified">3333     case GraphicsContextGL::RG8_SNORM:</span>
<span class="line-modified">3334     case GraphicsContextGL::RGB8_SNORM:</span>
<span class="line-modified">3335     case GraphicsContextGL::RGBA8_SNORM:</span>
3336         return InternalFormatTheme::SignedNormalizedFixedPoint;
<span class="line-modified">3337     case GraphicsContextGL::R16F:</span>
<span class="line-modified">3338     case GraphicsContextGL::R32F:</span>
<span class="line-modified">3339     case GraphicsContextGL::RG16F:</span>
<span class="line-modified">3340     case GraphicsContextGL::RG32F:</span>
<span class="line-modified">3341     case GraphicsContextGL::RGB16F:</span>
<span class="line-modified">3342     case GraphicsContextGL::RGB32F:</span>
<span class="line-modified">3343     case GraphicsContextGL::RGBA16F:</span>
<span class="line-modified">3344     case GraphicsContextGL::RGBA32F:</span>
3345         return InternalFormatTheme::FloatingPoint;
<span class="line-modified">3346     case GraphicsContextGL::R8I:</span>
<span class="line-modified">3347     case GraphicsContextGL::R16I:</span>
<span class="line-modified">3348     case GraphicsContextGL::R32I:</span>
<span class="line-modified">3349     case GraphicsContextGL::RG8I:</span>
<span class="line-modified">3350     case GraphicsContextGL::RG16I:</span>
<span class="line-modified">3351     case GraphicsContextGL::RG32I:</span>
<span class="line-modified">3352     case GraphicsContextGL::RGB8I:</span>
<span class="line-modified">3353     case GraphicsContextGL::RGB16I:</span>
<span class="line-modified">3354     case GraphicsContextGL::RGB32I:</span>
<span class="line-modified">3355     case GraphicsContextGL::RGBA8I:</span>
<span class="line-modified">3356     case GraphicsContextGL::RGBA16I:</span>
<span class="line-modified">3357     case GraphicsContextGL::RGBA32I:</span>
3358         return InternalFormatTheme::SignedInteger;
<span class="line-modified">3359     case GraphicsContextGL::R8UI:</span>
<span class="line-modified">3360     case GraphicsContextGL::R16UI:</span>
<span class="line-modified">3361     case GraphicsContextGL::R32UI:</span>
<span class="line-modified">3362     case GraphicsContextGL::RG8UI:</span>
<span class="line-modified">3363     case GraphicsContextGL::RG16UI:</span>
<span class="line-modified">3364     case GraphicsContextGL::RG32UI:</span>
<span class="line-modified">3365     case GraphicsContextGL::RGB8UI:</span>
<span class="line-modified">3366     case GraphicsContextGL::RGB16UI:</span>
<span class="line-modified">3367     case GraphicsContextGL::RGB32UI:</span>
<span class="line-modified">3368     case GraphicsContextGL::RGBA8UI:</span>
<span class="line-modified">3369     case GraphicsContextGL::RGBA16UI:</span>
<span class="line-modified">3370     case GraphicsContextGL::RGBA32UI:</span>
3371         return InternalFormatTheme::UnsignedInteger;
3372     default:
3373         return InternalFormatTheme::None;
3374     }
3375 }
3376 
<span class="line-modified">3377 static int numberOfComponentsForFormat(GCGLenum format)</span>
3378 {
3379     switch (format) {
<span class="line-modified">3380     case GraphicsContextGL::RED:</span>
<span class="line-modified">3381     case GraphicsContextGL::RED_INTEGER:</span>
3382         return 1;
<span class="line-modified">3383     case GraphicsContextGL::RG:</span>
<span class="line-modified">3384     case GraphicsContextGL::RG_INTEGER:</span>
3385         return 2;
<span class="line-modified">3386     case GraphicsContextGL::RGB:</span>
<span class="line-modified">3387     case GraphicsContextGL::RGB_INTEGER:</span>
3388         return 3;
<span class="line-modified">3389     case GraphicsContextGL::RGBA:</span>
<span class="line-modified">3390     case GraphicsContextGL::RGBA_INTEGER:</span>
3391         return 4;
3392     default:
3393         return 0;
3394     }
3395 }
3396 
<span class="line-modified">3397 static int numberOfComponentsForInternalFormat(GCGLenum internalFormat)</span>
3398 {
3399     switch (internalFormat) {
<span class="line-modified">3400     case GraphicsContextGL::LUMINANCE:</span>
<span class="line-modified">3401     case GraphicsContextGL::ALPHA:</span>
<span class="line-modified">3402     case GraphicsContextGL::R8:</span>
<span class="line-modified">3403     case GraphicsContextGL::R8_SNORM:</span>
<span class="line-modified">3404     case GraphicsContextGL::R16F:</span>
<span class="line-modified">3405     case GraphicsContextGL::R32F:</span>
<span class="line-modified">3406     case GraphicsContextGL::R8UI:</span>
<span class="line-modified">3407     case GraphicsContextGL::R8I:</span>
<span class="line-modified">3408     case GraphicsContextGL::R16UI:</span>
<span class="line-modified">3409     case GraphicsContextGL::R16I:</span>
<span class="line-modified">3410     case GraphicsContextGL::R32UI:</span>
<span class="line-modified">3411     case GraphicsContextGL::R32I:</span>
<span class="line-modified">3412     case GraphicsContextGL::DEPTH_COMPONENT16:</span>
<span class="line-modified">3413     case GraphicsContextGL::DEPTH_COMPONENT24:</span>
<span class="line-modified">3414     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
3415         return 1;
<span class="line-modified">3416     case GraphicsContextGL::RG8:</span>
<span class="line-modified">3417     case GraphicsContextGL::LUMINANCE_ALPHA:</span>
<span class="line-modified">3418     case GraphicsContextGL::RG8_SNORM:</span>
<span class="line-modified">3419     case GraphicsContextGL::RG16F:</span>
<span class="line-modified">3420     case GraphicsContextGL::RG32F:</span>
<span class="line-modified">3421     case GraphicsContextGL::RG8UI:</span>
<span class="line-modified">3422     case GraphicsContextGL::RG8I:</span>
<span class="line-modified">3423     case GraphicsContextGL::RG16UI:</span>
<span class="line-modified">3424     case GraphicsContextGL::RG16I:</span>
<span class="line-modified">3425     case GraphicsContextGL::RG32UI:</span>
<span class="line-modified">3426     case GraphicsContextGL::RG32I:</span>
<span class="line-modified">3427     case GraphicsContextGL::DEPTH24_STENCIL8:</span>
<span class="line-modified">3428     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
3429         return 2;
<span class="line-modified">3430     case GraphicsContextGL::RGB:</span>
<span class="line-modified">3431     case GraphicsContextGL::RGB8:</span>
<span class="line-modified">3432     case GraphicsContextGL::SRGB8:</span>
<span class="line-modified">3433     case GraphicsContextGL::RGB565:</span>
<span class="line-modified">3434     case GraphicsContextGL::RGB8_SNORM:</span>
<span class="line-modified">3435     case GraphicsContextGL::R11F_G11F_B10F:</span>
<span class="line-modified">3436     case GraphicsContextGL::RGB9_E5:</span>
<span class="line-modified">3437     case GraphicsContextGL::RGB16F:</span>
<span class="line-modified">3438     case GraphicsContextGL::RGB32F:</span>
<span class="line-modified">3439     case GraphicsContextGL::RGB8UI:</span>
<span class="line-modified">3440     case GraphicsContextGL::RGB8I:</span>
<span class="line-modified">3441     case GraphicsContextGL::RGB16UI:</span>
<span class="line-modified">3442     case GraphicsContextGL::RGB16I:</span>
<span class="line-modified">3443     case GraphicsContextGL::RGB32UI:</span>
<span class="line-modified">3444     case GraphicsContextGL::RGB32I:</span>
3445         return 3;
<span class="line-modified">3446     case GraphicsContextGL::RGBA:</span>
<span class="line-modified">3447     case GraphicsContextGL::RGBA8:</span>
<span class="line-modified">3448     case GraphicsContextGL::SRGB_ALPHA:</span>
<span class="line-modified">3449     case GraphicsContextGL::SRGB8_ALPHA8:</span>
<span class="line-modified">3450     case GraphicsContextGL::RGBA8_SNORM:</span>
<span class="line-modified">3451     case GraphicsContextGL::RGB5_A1:</span>
<span class="line-modified">3452     case GraphicsContextGL::RGBA4:</span>
<span class="line-modified">3453     case GraphicsContextGL::RGB10_A2:</span>
<span class="line-modified">3454     case GraphicsContextGL::RGBA16F:</span>
<span class="line-modified">3455     case GraphicsContextGL::RGBA32F:</span>
<span class="line-modified">3456     case GraphicsContextGL::RGBA8UI:</span>
<span class="line-modified">3457     case GraphicsContextGL::RGBA8I:</span>
<span class="line-modified">3458     case GraphicsContextGL::RGB10_A2UI:</span>
<span class="line-modified">3459     case GraphicsContextGL::RGBA16UI:</span>
<span class="line-modified">3460     case GraphicsContextGL::RGBA16I:</span>
<span class="line-modified">3461     case GraphicsContextGL::RGBA32UI:</span>
<span class="line-modified">3462     case GraphicsContextGL::RGBA32I:</span>
3463         return 4;
3464     default:
3465         return 0;
3466     }
3467 }
3468 
<span class="line-modified">3469 void WebGLRenderingContextBase::readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, ArrayBufferView&amp; pixels)</span>
3470 {
3471     if (isContextLostOrPending())
3472         return;
3473     // Due to WebGL&#39;s same-origin restrictions, it is not possible to
3474     // taint the origin using the WebGL API.
3475     ASSERT(canvasBase().originClean());
3476 
<span class="line-modified">3477     GCGLenum internalFormat = 0;</span>
3478     if (m_framebufferBinding) {
3479         const char* reason = &quot;framebuffer incomplete&quot;;
<span class="line-modified">3480         if (!m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="line-modified">3481             synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;readPixels&quot;, reason);</span>
3482             return;
3483         }
3484         // FIXME: readBuffer() should affect this
3485         internalFormat = m_framebufferBinding-&gt;getColorBufferFormat();
3486     } else {
3487         if (m_attributes.alpha)
<span class="line-modified">3488             internalFormat = GraphicsContextGL::RGBA8;</span>
3489         else
<span class="line-modified">3490             internalFormat = GraphicsContextGL::RGB8;</span>
3491     }
3492 
3493     if (!internalFormat) {
<span class="line-modified">3494         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;readPixels&quot;, &quot;Missing attachment&quot;);</span>
3495         return;
3496     }
3497 
3498     if (isWebGL1()) {
3499         switch (format) {
<span class="line-modified">3500         case GraphicsContextGL::ALPHA:</span>
<span class="line-modified">3501         case GraphicsContextGL::RGB:</span>
<span class="line-modified">3502         case GraphicsContextGL::RGBA:</span>
3503             break;
3504         default:
<span class="line-modified">3505             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid format&quot;);</span>
3506             return;
3507         }
3508         switch (type) {
<span class="line-modified">3509         case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">3510         case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:</span>
<span class="line-modified">3511         case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="line-modified">3512         case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:</span>
3513             break;
<span class="line-modified">3514         case GraphicsContextGL::FLOAT:</span>
3515             if (!m_oesTextureFloat &amp;&amp; !m_oesTextureHalfFloat) {
<span class="line-modified">3516                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);</span>
3517                 return;
3518             }
3519             break;
3520         default:
<span class="line-modified">3521             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);</span>
3522             return;
3523         }
<span class="line-modified">3524         if (format != GraphicsContextGL::RGBA || (type != GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; type != GraphicsContextGL::FLOAT)) {</span>
<span class="line-modified">3525             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;readPixels&quot;, &quot;format not RGBA or type not UNSIGNED_BYTE|FLOAT&quot;);</span>
3526             return;
3527         }
3528     }
3529 
3530     InternalFormatTheme internalFormatTheme = WebCore::internalFormatTheme(internalFormat);
3531     int internalFormatComponentCount = numberOfComponentsForInternalFormat(internalFormat);
3532     if (internalFormatTheme == InternalFormatTheme::None || !internalFormatComponentCount) {
<span class="line-modified">3533         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);</span>
3534         return;
3535     }
3536 
3537 #define CHECK_COMPONENT_COUNT \
3538     if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \
<span class="line-modified">3539         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
3540         return; \
3541     }
3542 
3543 #define INTERNAL_FORMAT_CHECK(typeMacro, pixelTypeMacro) \
<span class="line-modified">3544     if (type != GraphicsContextGLOpenGL::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3545         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
3546         return; \
3547     } \
<span class="line-modified">3548     if (format != GraphicsContextGL::RED &amp;&amp; format != GraphicsContextGL::RG &amp;&amp; format != GraphicsContextGL::RGB &amp;&amp; format != GraphicsContextGL::RGBA) { \</span>
<span class="line-modified">3549         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
3550         return; \
3551     } \
3552     CHECK_COMPONENT_COUNT
3553 
3554 #define INTERNAL_FORMAT_INTEGER_CHECK(typeMacro, pixelTypeMacro) \
<span class="line-modified">3555     if (type != GraphicsContextGLOpenGL::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3556         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
3557         return; \
3558     } \
<span class="line-modified">3559     if (format != GraphicsContextGL::RED_INTEGER &amp;&amp; format != GraphicsContextGL::RG_INTEGER &amp;&amp; format != GraphicsContextGL::RGB_INTEGER &amp;&amp; format != GraphicsContextGL::RGBA_INTEGER) { \</span>
<span class="line-modified">3560         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
3561         return; \
3562     } \
3563     CHECK_COMPONENT_COUNT
3564 
<span class="line-modified">3565 #define CASE_PACKED_INTERNAL_FORMAT_CHECK(internalFormatMacro, formatMacro, type0Macro, pixelType0Macro, type1Macro, pixelType1Macro) case GraphicsContextGLOpenGL::internalFormatMacro: \</span>
<span class="line-modified">3566     if (!(type == GraphicsContextGLOpenGL::type0Macro &amp;&amp; pixels.getType() == JSC::pixelType0Macro) \</span>
<span class="line-modified">3567         &amp;&amp; !(type == GraphicsContextGLOpenGL::type1Macro &amp;&amp; pixels.getType() == JSC::pixelType1Macro)) { \</span>
<span class="line-modified">3568         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
3569         return; \
3570     } \
<span class="line-modified">3571     if (format != GraphicsContextGLOpenGL::formatMacro) { \</span>
<span class="line-modified">3572         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Invalid format&quot;); \</span>
3573         return; \
3574     } \
3575     break;
3576 
3577     switch (internalFormatTheme) {
3578     case InternalFormatTheme::NormalizedFixedPoint:
<span class="line-modified">3579         if (type == GraphicsContextGL::FLOAT) {</span>
3580             INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);
3581         } else {
3582             INTERNAL_FORMAT_CHECK(UNSIGNED_BYTE, TypeUint8);
3583         }
3584         break;
3585     case InternalFormatTheme::SignedNormalizedFixedPoint:
3586         INTERNAL_FORMAT_CHECK(BYTE, TypeInt8);
3587         break;
3588     case InternalFormatTheme::FloatingPoint:
3589         INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);
3590         break;
3591     case InternalFormatTheme::SignedInteger:
3592         INTERNAL_FORMAT_INTEGER_CHECK(INT, TypeInt32);
3593         break;
3594     case InternalFormatTheme::UnsignedInteger:
3595         INTERNAL_FORMAT_INTEGER_CHECK(UNSIGNED_INT, TypeUint32);
3596         break;
3597     case InternalFormatTheme::Packed:
3598         switch (internalFormat) {
3599             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB565        , RGB         , UNSIGNED_SHORT_5_6_5        , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );
3600             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB5_A1       , RGBA        , UNSIGNED_SHORT_5_5_5_1      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );
3601             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGBA4         , RGBA        , UNSIGNED_SHORT_4_4_4_4      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );
3602             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB9_E5       , RGB         , UNSIGNED_INT_5_9_9_9_REV    , TypeUint32, UNSIGNED_INT_5_9_9_9_REV   , TypeUint32 );
3603             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2      , RGBA        , UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );
3604             CASE_PACKED_INTERNAL_FORMAT_CHECK(R11F_G11F_B10F, RGB         , UNSIGNED_INT_10F_11F_11F_REV, TypeUint32, FLOAT                      , TypeFloat32);
3605             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2UI    , RGBA_INTEGER, UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );
3606         }
3607         break;
3608     case InternalFormatTheme::None:
3609         ASSERT_NOT_REACHED();
3610     }
3611 #undef CHECK_COMPONENT_COUNT
3612 #undef INTERNAL_FORMAT_CHECK
3613 #undef INTERNAL_FORMAT_INTEGER_CHECK
3614 #undef CASE_PACKED_INTERNAL_FORMAT_CHECK
3615 
3616     // Calculate array size, taking into consideration of PACK_ALIGNMENT.
3617     unsigned totalBytesRequired = 0;
3618     unsigned padding = 0;
3619     if (!m_isRobustnessEXTSupported) {
<span class="line-modified">3620         GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_packAlignment, &amp;totalBytesRequired, &amp;padding);</span>
<span class="line-modified">3621         if (error != GraphicsContextGL::NO_ERROR) {</span>
3622             synthesizeGLError(error, &quot;readPixels&quot;, &quot;invalid dimensions&quot;);
3623             return;
3624         }
3625         if (pixels.byteLength() &lt; totalBytesRequired) {
<span class="line-modified">3626             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;readPixels&quot;, &quot;ArrayBufferView not large enough for dimensions&quot;);</span>
3627             return;
3628         }
3629     }
3630 
3631     clearIfComposited();
3632     void* data = pixels.baseAddress();
3633 
3634     if (m_isRobustnessEXTSupported)
3635         m_context-&gt;getExtensions().readnPixelsEXT(x, y, width, height, format, type, pixels.byteLength(), data);
3636     else
3637         m_context-&gt;readPixels(x, y, width, height, format, type, data);
3638 }
3639 
3640 void WebGLRenderingContextBase::releaseShaderCompiler()
3641 {
3642     if (isContextLostOrPending())
3643         return;
3644     m_context-&gt;releaseShaderCompiler();
3645 }
3646 
<span class="line-modified">3647 void WebGLRenderingContextBase::sampleCoverage(GCGLfloat value, GCGLboolean invert)</span>
3648 {
3649     if (isContextLostOrPending())
3650         return;
3651     m_context-&gt;sampleCoverage(value, invert);
3652 }
3653 
<span class="line-modified">3654 void WebGLRenderingContextBase::scissor(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)</span>
3655 {
3656     if (isContextLostOrPending())
3657         return;
3658     if (!validateSize(&quot;scissor&quot;, width, height))
3659         return;
3660     m_context-&gt;scissor(x, y, width, height);
3661 }
3662 
3663 void WebGLRenderingContextBase::shaderSource(WebGLShader* shader, const String&amp; string)
3664 {
3665     if (isContextLostOrPending() || !validateWebGLObject(&quot;shaderSource&quot;, shader))
3666         return;
<span class="line-added">3667 #if USE(ANGLE)</span>
<span class="line-added">3668     m_context-&gt;shaderSource(objectOrZero(shader), string);</span>
<span class="line-added">3669 #else</span>
3670     String stringWithoutComments = StripComments(string).result();
3671     if (!validateString(&quot;shaderSource&quot;, stringWithoutComments))
3672         return;

3673     m_context-&gt;shaderSource(objectOrZero(shader), stringWithoutComments);
<span class="line-added">3674 #endif</span>
<span class="line-added">3675     shader-&gt;setSource(string);</span>
3676 }
3677 
<span class="line-modified">3678 void WebGLRenderingContextBase::stencilFunc(GCGLenum func, GCGLint ref, GCGLuint mask)</span>
3679 {
3680     if (isContextLostOrPending())
3681         return;
3682     if (!validateStencilFunc(&quot;stencilFunc&quot;, func))
3683         return;
3684     m_stencilFuncRef = ref;
3685     m_stencilFuncRefBack = ref;
3686     m_stencilFuncMask = mask;
3687     m_stencilFuncMaskBack = mask;
3688     m_context-&gt;stencilFunc(func, ref, mask);
3689 }
3690 
<span class="line-modified">3691 void WebGLRenderingContextBase::stencilFuncSeparate(GCGLenum face, GCGLenum func, GCGLint ref, GCGLuint mask)</span>
3692 {
3693     if (isContextLostOrPending())
3694         return;
3695     if (!validateStencilFunc(&quot;stencilFuncSeparate&quot;, func))
3696         return;
3697     switch (face) {
<span class="line-modified">3698     case GraphicsContextGL::FRONT_AND_BACK:</span>
3699         m_stencilFuncRef = ref;
3700         m_stencilFuncRefBack = ref;
3701         m_stencilFuncMask = mask;
3702         m_stencilFuncMaskBack = mask;
3703         break;
<span class="line-modified">3704     case GraphicsContextGL::FRONT:</span>
3705         m_stencilFuncRef = ref;
3706         m_stencilFuncMask = mask;
3707         break;
<span class="line-modified">3708     case GraphicsContextGL::BACK:</span>
3709         m_stencilFuncRefBack = ref;
3710         m_stencilFuncMaskBack = mask;
3711         break;
3712     default:
<span class="line-modified">3713         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;stencilFuncSeparate&quot;, &quot;invalid face&quot;);</span>
3714         return;
3715     }
3716     m_context-&gt;stencilFuncSeparate(face, func, ref, mask);
3717 }
3718 
<span class="line-modified">3719 void WebGLRenderingContextBase::stencilMask(GCGLuint mask)</span>
3720 {
3721     if (isContextLostOrPending())
3722         return;
3723     m_stencilMask = mask;
3724     m_stencilMaskBack = mask;
3725     m_context-&gt;stencilMask(mask);
3726 }
3727 
<span class="line-modified">3728 void WebGLRenderingContextBase::stencilMaskSeparate(GCGLenum face, GCGLuint mask)</span>
3729 {
3730     if (isContextLostOrPending())
3731         return;
3732     switch (face) {
<span class="line-modified">3733     case GraphicsContextGL::FRONT_AND_BACK:</span>
3734         m_stencilMask = mask;
3735         m_stencilMaskBack = mask;
3736         break;
<span class="line-modified">3737     case GraphicsContextGL::FRONT:</span>
3738         m_stencilMask = mask;
3739         break;
<span class="line-modified">3740     case GraphicsContextGL::BACK:</span>
3741         m_stencilMaskBack = mask;
3742         break;
3743     default:
<span class="line-modified">3744         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;stencilMaskSeparate&quot;, &quot;invalid face&quot;);</span>
3745         return;
3746     }
3747     m_context-&gt;stencilMaskSeparate(face, mask);
3748 }
3749 
<span class="line-modified">3750 void WebGLRenderingContextBase::stencilOp(GCGLenum fail, GCGLenum zfail, GCGLenum zpass)</span>
3751 {
3752     if (isContextLostOrPending())
3753         return;
3754     m_context-&gt;stencilOp(fail, zfail, zpass);
3755 }
3756 
<span class="line-modified">3757 void WebGLRenderingContextBase::stencilOpSeparate(GCGLenum face, GCGLenum fail, GCGLenum zfail, GCGLenum zpass)</span>
3758 {
3759     if (isContextLostOrPending())
3760         return;
3761     m_context-&gt;stencilOpSeparate(face, fail, zfail, zpass);
3762 }
3763 
<span class="line-modified">3764 void WebGLRenderingContextBase::texImage2DBase(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels)</span>
3765 {
3766     // FIXME: For now we ignore any errors returned.
3767     auto tex = validateTextureBinding(&quot;texImage2D&quot;, target, true);
3768     ASSERT(validateTexFuncParameters(&quot;texImage2D&quot;, TexImage, target, level, internalFormat, width, height, border, format, type));
3769     ASSERT(tex);
3770     ASSERT(validateNPOTTextureLevel(width, height, level, &quot;texImage2D&quot;));
3771     if (!pixels) {
3772         if (!m_context-&gt;texImage2DResourceSafe(target, level, internalFormat, width, height, border, format, type, m_unpackAlignment))
3773             return;
3774     } else {
3775         ASSERT(validateSettableTexInternalFormat(&quot;texImage2D&quot;, internalFormat));
3776         m_context-&gt;moveErrorsToSyntheticErrorList();
3777         m_context-&gt;texImage2D(target, level, internalFormat, width, height,
3778                               border, format, type, pixels);
3779         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
3780             // The texImage2D function failed. Tell the WebGLTexture it doesn&#39;t have the data for this level.
3781             tex-&gt;markInvalid(target, level);
3782             return;
3783         }
3784     }
3785     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, type);
3786 }
3787 
<span class="line-modified">3788 void WebGLRenderingContextBase::texImage2DImpl(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Image* image, GraphicsContextGL::DOMSource domSource, bool flipY, bool premultiplyAlpha)</span>
3789 {
3790     Vector&lt;uint8_t&gt; data;
<span class="line-modified">3791     GraphicsContextGLOpenGL::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContextGL::NONE);</span>
3792     if (!imageExtractor.extractSucceeded()) {
<span class="line-modified">3793         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
3794         return;
3795     }
<span class="line-modified">3796     GraphicsContextGL::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();</span>
<span class="line-modified">3797     GraphicsContextGL::AlphaOp alphaOp = imageExtractor.imageAlphaOp();</span>
3798     const void* imagePixelData = imageExtractor.imagePixelData();
3799 
3800     bool needConversion = true;
<span class="line-modified">3801     if (type == GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContextGL::DataFormat::RGBA8 &amp;&amp; format == GraphicsContextGL::RGBA &amp;&amp; alphaOp == GraphicsContextGL::AlphaOp::DoNothing &amp;&amp; !flipY)</span>
3802         needConversion = false;
3803     else {
3804         if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
<span class="line-modified">3805             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;packImage error&quot;);</span>
3806             return;
3807         }
3808     }
3809 
3810     if (m_unpackAlignment != 1)
<span class="line-modified">3811         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
3812     texImage2DBase(target, level, internalformat, image-&gt;width(), image-&gt;height(), 0, format, type, needConversion ? data.data() : imagePixelData);
3813     if (m_unpackAlignment != 1)
<span class="line-modified">3814         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
3815 }
3816 
<span class="line-modified">3817 bool WebGLRenderingContextBase::validateTexFunc(const char* functionName, TexFuncValidationFunctionType functionType, TexFuncValidationSourceType sourceType, GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, GCGLint xoffset, GCGLint yoffset)</span>
3818 {
3819     if (!validateTexFuncParameters(functionName, functionType, target, level, internalFormat, width, height, border, format, type))
3820         return false;
3821 
3822     auto texture = validateTextureBinding(functionName, target, true);
3823     if (!texture)
3824         return false;
3825 
3826     if (functionType != TexSubImage) {
3827         if (functionType == TexImage &amp;&amp; texture-&gt;immutable()) {
<span class="line-modified">3828             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;texStorage() called on this texture previously&quot;);</span>
3829             return false;
3830         }
3831         if (!validateNPOTTextureLevel(width, height, level, functionName))
3832             return false;
3833         // For SourceArrayBufferView, function validateTexFuncData() would handle whether to validate the SettableTexFormat
3834         // by checking if the ArrayBufferView is null or not.
3835         if (sourceType != SourceArrayBufferView) {
3836             if (!validateSettableTexInternalFormat(functionName, internalFormat))
3837                 return false;
3838         }
3839     } else {
3840         if (!validateSettableTexInternalFormat(functionName, internalFormat))
3841             return false;
3842         if (!validateSize(functionName, xoffset, yoffset))
3843             return false;
3844         // Before checking if it is in the range, check if overflow happens first.
3845         if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
<span class="line-modified">3846             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;bad dimensions&quot;);</span>
3847             return false;
3848         }
3849         if (xoffset + width &gt; texture-&gt;getWidth(target, level) || yoffset + height &gt; texture-&gt;getHeight(target, level)) {
<span class="line-modified">3850             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;dimensions out of range&quot;);</span>
3851             return false;
3852         }
3853         if (texture-&gt;getInternalFormat(target, level) != internalFormat || (isWebGL1() &amp;&amp; texture-&gt;getType(target, level) != type)) {
<span class="line-modified">3854             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;type and format do not match texture&quot;);</span>
3855             return false;
3856         }
3857     }
3858 
3859     return true;
3860 }
3861 
<span class="line-modified">3862 void WebGLRenderingContextBase::texImage2D(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)</span>
3863 {
3864     if (isContextLostOrPending() || !validateTexFuncData(&quot;texImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullAllowed)
3865         || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceArrayBufferView, target, level, internalFormat, width, height, border, format, type, 0, 0))
3866         return;
3867     void* data = pixels ? pixels-&gt;baseAddress() : 0;
3868     Vector&lt;uint8_t&gt; tempData;
3869     bool changeUnpackAlignment = false;
3870     if (data &amp;&amp; (m_unpackFlipY || m_unpackPremultiplyAlpha)) {
3871         if (!m_context-&gt;extractTextureData(width, height, format, type,
3872                                            m_unpackAlignment,
3873                                            m_unpackFlipY, m_unpackPremultiplyAlpha,
3874                                            data,
3875                                            tempData))
3876             return;
3877         data = tempData.data();
3878         changeUnpackAlignment = true;
3879     }
3880     if (changeUnpackAlignment)
<span class="line-modified">3881         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
3882     texImage2DBase(target, level, internalFormat, width, height, border, format, type, data);
3883     if (changeUnpackAlignment)
<span class="line-modified">3884         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
3885 }
3886 
<span class="line-modified">3887 void WebGLRenderingContextBase::texSubImage2DImpl(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Image* image, GraphicsContextGL::DOMSource domSource, bool flipY, bool premultiplyAlpha)</span>
3888 {
3889     Vector&lt;uint8_t&gt; data;
<span class="line-modified">3890     GraphicsContextGLOpenGL::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContextGL::NONE);</span>
3891     if (!imageExtractor.extractSucceeded()) {
<span class="line-modified">3892         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image&quot;);</span>
3893         return;
3894     }
<span class="line-modified">3895     GraphicsContextGL::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();</span>
<span class="line-modified">3896     GraphicsContextGL::AlphaOp alphaOp = imageExtractor.imageAlphaOp();</span>
3897     const void* imagePixelData = imageExtractor.imagePixelData();
3898 
3899     bool needConversion = true;
<span class="line-modified">3900     if (type == GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContextGL::DataFormat::RGBA8 &amp;&amp; format == GraphicsContextGL::RGBA &amp;&amp; alphaOp == GraphicsContextGL::AlphaOp::DoNothing &amp;&amp; !flipY)</span>
3901         needConversion = false;
3902     else {
3903         if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
<span class="line-modified">3904             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
3905             return;
3906         }
3907     }
3908 
3909     if (m_unpackAlignment != 1)
<span class="line-modified">3910         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
3911 
3912     texSubImage2DBase(target, level, xoffset, yoffset, image-&gt;width(), image-&gt;height(), format, format, type, needConversion ? data.data() : imagePixelData);
3913 
3914     if (m_unpackAlignment != 1)
<span class="line-modified">3915         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
3916 }
3917 
<span class="line-modified">3918 void WebGLRenderingContextBase::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)</span>
3919 {
3920     if (isContextLostOrPending())
3921         return;
3922 
3923     auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3924     if (!texture)
3925         return;
3926 
<span class="line-modified">3927     GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
3928     if (!internalFormat) {
<span class="line-modified">3929         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
3930         return;
3931     }
3932 
3933     if (!validateTexFuncData(&quot;texSubImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullNotAllowed))
3934         return;
3935 
3936     if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceArrayBufferView, target, level, internalFormat, width, height, 0, format, type, xoffset, yoffset))
3937         return;
3938 
3939     void* data = pixels-&gt;baseAddress();
3940     Vector&lt;uint8_t&gt; tempData;
3941     bool changeUnpackAlignment = false;
3942     if (data &amp;&amp; (m_unpackFlipY || m_unpackPremultiplyAlpha)) {
3943         if (!m_context-&gt;extractTextureData(width, height, format, type, m_unpackAlignment, m_unpackFlipY, m_unpackPremultiplyAlpha, data, tempData))
3944             return;
3945         data = tempData.data();
3946         changeUnpackAlignment = true;
3947     }
3948     if (changeUnpackAlignment)
<span class="line-modified">3949         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
3950 
3951     texSubImage2DBase(target, level, xoffset, yoffset, width, height, internalFormat, format, type, data);
3952 
3953     if (changeUnpackAlignment)
<span class="line-modified">3954         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
3955 }
3956 
<span class="line-modified">3957 ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt;&amp;&amp; source)</span>
3958 {
3959     if (!source) {
<span class="line-modified">3960         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;source is null&quot;);</span>
3961         return { };
3962     }
3963 
3964     if (isContextLostOrPending())
3965         return { };
3966 
3967     auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
3968         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3969         if (!texture)
3970             return { };
3971 
<span class="line-modified">3972         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
3973         if (!internalFormat) {
<span class="line-modified">3974             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
3975             return { };
3976         }
3977 
3978         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageBitmap, target, level, internalFormat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, xoffset, yoffset))
3979             return { };
3980 
3981         ImageBuffer* buffer = bitmap-&gt;buffer();
3982         if (!buffer)
3983             return { };
3984 
<span class="line-modified">3985         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(DontCopyBackingStore);</span>
3986         if (image)
<span class="line-modified">3987             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
3988         return { };
3989     }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
3990         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3991         if (!texture)
3992             return { };
3993 
<span class="line-modified">3994         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
3995         if (!internalFormat) {
<span class="line-modified">3996             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
3997             return { };
3998         }
3999 
4000         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageData, target, level, internalFormat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, xoffset, yoffset))
4001             return { };
4002 
4003         Vector&lt;uint8_t&gt; data;
4004         bool needConversion = true;
4005         // The data from ImageData is always of format RGBA8.
4006         // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
<span class="line-modified">4007         if (format == GraphicsContextGL::RGBA &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; !m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha)</span>
4008             needConversion = false;
4009         else {
4010             if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
<span class="line-modified">4011                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image data&quot;);</span>
4012                 return { };
4013             }
4014         }
4015         if (m_unpackAlignment != 1)
<span class="line-modified">4016             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
4017 
4018         texSubImage2DBase(target, level, xoffset, yoffset, pixels-&gt;width(), pixels-&gt;height(), format, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
4019 
4020         if (m_unpackAlignment != 1)
<span class="line-modified">4021             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
4022 
4023         return { };
4024     } , [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
4025         if (isContextLostOrPending())
4026             return { };
4027         auto validationResult = validateHTMLImageElement(&quot;texSubImage2D&quot;, image.get());
4028         if (validationResult.hasException())
4029             return validationResult.releaseException();
4030         if (!validationResult.returnValue())
4031             return { };
4032 
4033         RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
4034         if (!imageForRender)
4035             return { };
4036 
<span class="line-modified">4037         if (imageForRender-&gt;isSVGImage() || imageForRender-&gt;orientation() != ImageOrientation::None)</span>
4038             imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
4039 
4040         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4041         if (!texture)
4042             return { };
4043 
<span class="line-modified">4044         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
4045         if (!internalFormat) {
<span class="line-modified">4046             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
4047             return { };
4048         }
4049 
4050         if (!imageForRender || !validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLImageElement, target, level, internalFormat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, xoffset, yoffset))
4051             return { };
4052 
<span class="line-modified">4053         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, imageForRender.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4054         return { };
4055     }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
4056         if (isContextLostOrPending())
4057             return { };
4058         auto validationResult = validateHTMLCanvasElement(&quot;texSubImage2D&quot;, canvas.get());
4059         if (validationResult.hasException())
4060             return validationResult.releaseException();
4061         if (!validationResult.returnValue())
4062             return { };
4063 
4064         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4065         if (!texture)
4066             return { };
4067 
<span class="line-modified">4068         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
4069         if (!internalFormat) {
<span class="line-modified">4070             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
4071             return { };
4072         }
4073 
4074         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLCanvasElement, target, level, internalFormat, canvas-&gt;width(), canvas-&gt;height(), 0, format, type, xoffset, yoffset))
4075             return { };
4076 
4077         RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
4078         if (imageData)
4079             texSubImage2D(target, level, xoffset, yoffset, format, type, TexImageSource(imageData.get()));
4080         else
<span class="line-modified">4081             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, canvas-&gt;copiedImage(), GraphicsContextGL::DOMSource::Canvas, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4082         return { };
4083     }
4084 #if ENABLE(VIDEO)
4085     , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
4086         if (isContextLostOrPending())
4087             return { };
4088         auto validationResult = validateHTMLVideoElement(&quot;texSubImage2D&quot;, video.get());
4089         if (validationResult.hasException())
4090             return validationResult.releaseException();
4091         if (!validationResult.returnValue())
4092             return { };
4093 
4094         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4095         if (!texture)
4096             return { };
4097 
<span class="line-modified">4098         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
4099         if (!internalFormat) {
<span class="line-modified">4100             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
4101             return { };
4102         }
4103 
4104         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLVideoElement, target, level, internalFormat, video-&gt;videoWidth(), video-&gt;videoHeight(), 0, format, type, xoffset, yoffset))
4105             return { };
4106 
<span class="line-modified">4107         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), DontCopyBackingStore);</span>
4108         if (!image)
4109             return { };
<span class="line-modified">4110         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContextGL::DOMSource::Video, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4111         return { };
4112     }
4113 #endif
4114     );
4115 
4116     return WTF::visit(visitor, source.value());
4117 }
4118 
<span class="line-modified">4119 bool WebGLRenderingContextBase::validateArrayBufferType(const char* functionName, GCGLenum type, Optional&lt;JSC::TypedArrayType&gt; arrayType)</span>
4120 {
4121 #define TYPE_VALIDATION_CASE(arrayTypeMacro) if (arrayType &amp;&amp; arrayType.value() != JSC::arrayTypeMacro) { \
<span class="line-modified">4122             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;ArrayBufferView not &quot; #arrayTypeMacro); \</span>
4123             return false; \
4124         } \
4125         break;
4126 
4127     switch (type) {
<span class="line-modified">4128     case GraphicsContextGL::UNSIGNED_BYTE:</span>
4129         TYPE_VALIDATION_CASE(TypeUint8);
<span class="line-modified">4130     case GraphicsContextGL::BYTE:</span>
4131         TYPE_VALIDATION_CASE(TypeInt8);
<span class="line-modified">4132     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="line-modified">4133     case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:</span>
<span class="line-modified">4134     case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="line-modified">4135     case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:</span>
4136         TYPE_VALIDATION_CASE(TypeUint16);
<span class="line-modified">4137     case GraphicsContextGL::SHORT:</span>
4138         TYPE_VALIDATION_CASE(TypeInt16);
<span class="line-modified">4139     case GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV:</span>
<span class="line-modified">4140     case GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV:</span>
<span class="line-modified">4141     case GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV:</span>
<span class="line-modified">4142     case GraphicsContextGL::UNSIGNED_INT_24_8:</span>
<span class="line-modified">4143     case GraphicsContextGL::UNSIGNED_INT:</span>
4144         TYPE_VALIDATION_CASE(TypeUint32);
<span class="line-modified">4145     case GraphicsContextGL::INT:</span>
4146         TYPE_VALIDATION_CASE(TypeInt32);
<span class="line-modified">4147     case GraphicsContextGL::FLOAT: // OES_texture_float</span>
4148         TYPE_VALIDATION_CASE(TypeFloat32);
<span class="line-modified">4149     case GraphicsContextGL::HALF_FLOAT_OES: // OES_texture_half_float</span>
<span class="line-modified">4150     case GraphicsContextGL::HALF_FLOAT:</span>
<span class="line-modified">4151     case GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV:</span>
<span class="line-modified">4152         TYPE_VALIDATION_CASE(TypeUint16);</span>






4153     default:
4154         ASSERT_NOT_REACHED();
4155         return false;
4156     }
4157 #undef TYPE_VALIDATION_CASE
4158     return true;
4159 }
4160 
<span class="line-modified">4161 bool WebGLRenderingContextBase::validateTexFuncData(const char* functionName, GCGLint level, GCGLsizei width, GCGLsizei height, GCGLenum internalFormat, GCGLenum format, GCGLenum type, ArrayBufferView* pixels, NullDisposition disposition)</span>
4162 {
4163     if (!pixels) {
4164         if (disposition == NullAllowed)
4165             return true;
<span class="line-modified">4166         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no pixels&quot;);</span>
4167         return false;
4168     }
4169 
4170     if (!validateTexFuncFormatAndType(functionName, internalFormat, format, type, level))
4171         return false;
4172     if (!validateSettableTexInternalFormat(functionName, internalFormat))
4173         return false;
4174     if (!validateArrayBufferType(functionName, type, pixels ? Optional&lt;JSC::TypedArrayType&gt;(pixels-&gt;getType()) : WTF::nullopt))
4175         return false;
4176 
4177     unsigned totalBytesRequired;
<span class="line-modified">4178     GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;totalBytesRequired, nullptr);</span>
<span class="line-modified">4179     if (error != GraphicsContextGL::NO_ERROR) {</span>
4180         synthesizeGLError(error, functionName, &quot;invalid texture dimensions&quot;);
4181         return false;
4182     }
4183     if (pixels-&gt;byteLength() &lt; totalBytesRequired) {
<span class="line-modified">4184         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;ArrayBufferView not big enough for request&quot;);</span>
4185         return false;
4186     }
4187     return true;
4188 }
4189 
4190 bool WebGLRenderingContextBase::validateTexFuncParameters(const char* functionName,
4191     TexFuncValidationFunctionType functionType,
<span class="line-modified">4192     GCGLenum target, GCGLint level,</span>
<span class="line-modified">4193     GCGLenum internalformat,</span>
<span class="line-modified">4194     GCGLsizei width, GCGLsizei height, GCGLint border,</span>
<span class="line-modified">4195     GCGLenum format, GCGLenum type)</span>
4196 {
4197     // We absolutely have to validate the format and type combination.
4198     // The texImage2D entry points taking HTMLImage, etc. will produce
4199     // temporary data based on this combination, so it must be legal.
4200     if (!validateTexFuncFormatAndType(functionName, internalformat, format, type, level) || !validateTexFuncLevel(functionName, target, level))
4201         return false;
4202 
4203     if (width &lt; 0 || height &lt; 0) {
<span class="line-modified">4204         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);</span>
4205         return false;
4206     }
4207 
<span class="line-modified">4208     GCGLint maxTextureSizeForLevel = pow(2.0, m_maxTextureLevel - 1 - level);</span>
4209     switch (target) {
<span class="line-modified">4210     case GraphicsContextGL::TEXTURE_2D:</span>
4211         if (width &gt; maxTextureSizeForLevel || height &gt; maxTextureSizeForLevel) {
<span class="line-modified">4212             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height out of range&quot;);</span>
4213             return false;
4214         }
4215         break;
<span class="line-modified">4216     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="line-modified">4217     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="line-modified">4218     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="line-modified">4219     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="line-modified">4220     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="line-modified">4221     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
4222         if (functionType != TexSubImage &amp;&amp; width != height) {
<span class="line-modified">4223             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width != height for cube map&quot;);</span>
4224             return false;
4225         }
4226         // No need to check height here. For texImage width == height.
4227         // For texSubImage that will be checked when checking yoffset + height is in range.
4228         if (width &gt; maxTextureSizeForLevel) {
<span class="line-modified">4229             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height out of range for cube map&quot;);</span>
4230             return false;
4231         }
4232         break;
4233     default:
<span class="line-modified">4234         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
4235         return false;
4236     }
4237 
4238     if (border) {
<span class="line-modified">4239         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;border != 0&quot;);</span>
4240         return false;
4241     }
4242 
4243     return true;
4244 }
4245 
<span class="line-modified">4246 bool WebGLRenderingContextBase::validateTexFuncFormatAndType(const char* functionName, GCGLenum internalFormat, GCGLenum format, GCGLenum type, GCGLint level)</span>
4247 {
4248     switch (format) {
<span class="line-modified">4249     case GraphicsContextGL::ALPHA:</span>
<span class="line-modified">4250     case GraphicsContextGL::LUMINANCE:</span>
<span class="line-modified">4251     case GraphicsContextGL::LUMINANCE_ALPHA:</span>
<span class="line-modified">4252     case GraphicsContextGL::RGB:</span>
<span class="line-modified">4253     case GraphicsContextGL::RGBA:</span>
4254         break;
<span class="line-modified">4255     case GraphicsContextGL::DEPTH_STENCIL:</span>
<span class="line-modified">4256     case GraphicsContextGL::DEPTH_COMPONENT:</span>
4257         if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
<span class="line-modified">4258             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;depth texture formats not enabled&quot;);</span>
4259             return false;
4260         }
4261         if (level &gt; 0) {
<span class="line-modified">4262             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;level must be 0 for depth formats&quot;);</span>
4263             return false;
4264         }
4265         break;
<span class="line-modified">4266     case ExtensionsGL::SRGB_EXT:</span>
<span class="line-modified">4267     case ExtensionsGL::SRGB_ALPHA_EXT:</span>
4268         if (!m_extsRGB) {
<span class="line-modified">4269             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;sRGB texture formats not enabled&quot;);</span>
4270             return false;
4271         }
4272         break;
4273     default:
4274 #if ENABLE(WEBGL2)
4275         if (!isWebGL1()) {
4276             switch (format) {
<span class="line-modified">4277             case GraphicsContextGL::RED:</span>
<span class="line-modified">4278             case GraphicsContextGL::RED_INTEGER:</span>
<span class="line-modified">4279             case GraphicsContextGL::RG:</span>
<span class="line-modified">4280             case GraphicsContextGL::RG_INTEGER:</span>
<span class="line-modified">4281             case GraphicsContextGL::RGB_INTEGER:</span>
<span class="line-modified">4282             case GraphicsContextGL::RGBA_INTEGER:</span>
4283                 break;
4284             default:
<span class="line-modified">4285                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);</span>
4286                 return false;
4287             }
4288         } else
4289 #endif
4290         {
<span class="line-modified">4291             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);</span>
4292             return false;
4293         }
4294     }
4295 
4296     switch (type) {
<span class="line-modified">4297     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">4298     case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:</span>
<span class="line-modified">4299     case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="line-modified">4300     case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:</span>
4301         break;
<span class="line-modified">4302     case GraphicsContextGL::FLOAT:</span>
4303         if (!m_oesTextureFloat &amp;&amp; isWebGL1()) {
<span class="line-modified">4304             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4305             return false;
4306         }
4307         break;
<span class="line-modified">4308     case GraphicsContextGL::HALF_FLOAT:</span>
<span class="line-modified">4309     case GraphicsContextGL::HALF_FLOAT_OES:</span>
4310         if (!m_oesTextureHalfFloat &amp;&amp; isWebGL1()) {
<span class="line-modified">4311             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4312             return false;
4313         }
4314         break;
<span class="line-modified">4315     case GraphicsContextGL::UNSIGNED_INT:</span>
<span class="line-modified">4316     case GraphicsContextGL::UNSIGNED_INT_24_8:</span>
<span class="line-modified">4317     case GraphicsContextGL::UNSIGNED_SHORT:</span>
4318         if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
<span class="line-modified">4319             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4320             return false;
4321         }
4322         break;
4323     default:
4324 #if ENABLE(WEBGL2)
4325         if (!isWebGL1()) {
4326             switch (type) {
<span class="line-modified">4327             case GraphicsContextGL::BYTE:</span>
<span class="line-modified">4328             case GraphicsContextGL::SHORT:</span>
<span class="line-modified">4329             case GraphicsContextGL::INT:</span>
<span class="line-modified">4330             case GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV:</span>
<span class="line-modified">4331             case GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV:</span>
<span class="line-modified">4332             case GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV:</span>
<span class="line-modified">4333             case GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV:</span>
4334                 break;
4335             default:
<span class="line-modified">4336                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4337                 return false;
4338             }
4339         } else
4340 #endif
4341         {
<span class="line-modified">4342             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
4343             return false;
4344         }
4345     }
4346 
4347     // Verify that the combination of internalformat, format, and type is supported.
<span class="line-modified">4348 #define INTERNAL_FORMAT_CASE(internalFormatMacro, formatMacro, type0, type1, type2, type3, type4) case GraphicsContextGLOpenGL::internalFormatMacro: \</span>
<span class="line-modified">4349     if (format != GraphicsContextGLOpenGL::formatMacro) { \</span>
<span class="line-modified">4350         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid format for internalformat&quot;); \</span>
4351         return false; \
4352     } \
4353     if (type != type0 &amp;&amp; type != type1 &amp;&amp; type != type2 &amp;&amp; type != type3 &amp;&amp; type != type4) { \
<span class="line-modified">4354         if (type != GraphicsContextGL::HALF_FLOAT_OES || (type0 != GraphicsContextGL::HALF_FLOAT &amp;&amp; type1 != GraphicsContextGL::HALF_FLOAT &amp;&amp; type2 != GraphicsContextGL::HALF_FLOAT &amp;&amp; type3 != GraphicsContextGL::HALF_FLOAT)) { \</span>
<span class="line-modified">4355             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid type for internalformat&quot;); \</span>
4356             return false; \
4357         } \
4358     } \
4359     break;
4360     switch (internalFormat) {
<span class="line-modified">4361     INTERNAL_FORMAT_CASE(RGB               , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_5_6_5  , GraphicsContextGL::HALF_FLOAT                  , GraphicsContextGL::FLOAT     , 0                       );</span>
<span class="line-modified">4362     INTERNAL_FORMAT_CASE(RGBA              , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4, GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1      , GraphicsContextGL::HALF_FLOAT, GraphicsContextGL::FLOAT);</span>
<span class="line-modified">4363     INTERNAL_FORMAT_CASE(LUMINANCE_ALPHA   , LUMINANCE_ALPHA, GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4364     INTERNAL_FORMAT_CASE(LUMINANCE         , LUMINANCE      , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4365     INTERNAL_FORMAT_CASE(ALPHA             , ALPHA          , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4366     INTERNAL_FORMAT_CASE(R8                , RED            , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4367     INTERNAL_FORMAT_CASE(R8_SNORM          , RED            , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4368     INTERNAL_FORMAT_CASE(R16F              , RED            , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4369     INTERNAL_FORMAT_CASE(R32F              , RED            , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4370     INTERNAL_FORMAT_CASE(R8UI              , RED_INTEGER    , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4371     INTERNAL_FORMAT_CASE(R8I               , RED_INTEGER    , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4372     INTERNAL_FORMAT_CASE(R16UI             , RED_INTEGER    , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4373     INTERNAL_FORMAT_CASE(R16I              , RED_INTEGER    , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4374     INTERNAL_FORMAT_CASE(R32UI             , RED_INTEGER    , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4375     INTERNAL_FORMAT_CASE(R32I              , RED_INTEGER    , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4376     INTERNAL_FORMAT_CASE(RG8               , RG             , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4377     INTERNAL_FORMAT_CASE(RG8_SNORM         , RG             , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4378     INTERNAL_FORMAT_CASE(RG16F             , RG             , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4379     INTERNAL_FORMAT_CASE(RG32F             , RG             , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4380     INTERNAL_FORMAT_CASE(RG8UI             , RG_INTEGER     , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4381     INTERNAL_FORMAT_CASE(RG8I              , RG_INTEGER     , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4382     INTERNAL_FORMAT_CASE(RG16UI            , RG_INTEGER     , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4383     INTERNAL_FORMAT_CASE(RG16I             , RG_INTEGER     , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4384     INTERNAL_FORMAT_CASE(RG32UI            , RG_INTEGER     , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4385     INTERNAL_FORMAT_CASE(RG32I             , RG_INTEGER     , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4386     INTERNAL_FORMAT_CASE(RGB8              , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4387     INTERNAL_FORMAT_CASE(SRGB8             , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4388     INTERNAL_FORMAT_CASE(RGB565            , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_5_6_5  , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4389     INTERNAL_FORMAT_CASE(RGB8_SNORM        , RGB            , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4390     INTERNAL_FORMAT_CASE(R11F_G11F_B10F    , RGB            , GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV  , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4391     INTERNAL_FORMAT_CASE(RGB9_E5           , RGB            , GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV      , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="line-modified">4392     INTERNAL_FORMAT_CASE(RGB16F            , RGB            , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4393     INTERNAL_FORMAT_CASE(RGB32F            , RGB            , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4394     INTERNAL_FORMAT_CASE(RGB8UI            , RGB_INTEGER    , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4395     INTERNAL_FORMAT_CASE(RGB8I             , RGB_INTEGER    , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4396     INTERNAL_FORMAT_CASE(RGB16UI           , RGB_INTEGER    , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4397     INTERNAL_FORMAT_CASE(RGB16I            , RGB_INTEGER    , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4398     INTERNAL_FORMAT_CASE(RGB32UI           , RGB_INTEGER    , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4399     INTERNAL_FORMAT_CASE(RGB32I            , RGB_INTEGER    , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4400     INTERNAL_FORMAT_CASE(RGBA8             , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4401     INTERNAL_FORMAT_CASE(SRGB8_ALPHA8      , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4402     INTERNAL_FORMAT_CASE(RGBA8_SNORM       , RGBA           , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4403     INTERNAL_FORMAT_CASE(RGB5_A1           , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1, GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV , 0                            , 0                       );</span>
<span class="line-modified">4404     INTERNAL_FORMAT_CASE(RGBA4             , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4, 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4405     INTERNAL_FORMAT_CASE(RGB10_A2          , RGBA           , GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4406     INTERNAL_FORMAT_CASE(RGBA16F           , RGBA           , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4407     INTERNAL_FORMAT_CASE(RGBA32F           , RGBA           , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4408     INTERNAL_FORMAT_CASE(RGBA8UI           , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4409     INTERNAL_FORMAT_CASE(RGBA8I            , RGBA_INTEGER   , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4410     INTERNAL_FORMAT_CASE(RGB10_A2UI        , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4411     INTERNAL_FORMAT_CASE(RGBA16UI          , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4412     INTERNAL_FORMAT_CASE(RGBA16I           , RGBA_INTEGER   , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4413     INTERNAL_FORMAT_CASE(RGBA32I           , RGBA_INTEGER   , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4414     INTERNAL_FORMAT_CASE(RGBA32UI          , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4415     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT   , DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_SHORT                , GraphicsContextGL::UNSIGNED_INT          , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4416     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT16 , DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_SHORT                , GraphicsContextGL::UNSIGNED_INT          , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4417     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT24 , DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4418     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT32F, DEPTH_COMPONENT, GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4419     INTERNAL_FORMAT_CASE(DEPTH_STENCIL     , DEPTH_STENCIL  , GraphicsContextGL::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4420     INTERNAL_FORMAT_CASE(DEPTH24_STENCIL8  , DEPTH_STENCIL  , GraphicsContextGL::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4421     INTERNAL_FORMAT_CASE(DEPTH32F_STENCIL8 , DEPTH_STENCIL  , GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV, 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="line-modified">4422     case ExtensionsGL::SRGB_EXT:</span>
4423         if (format != internalFormat) {
<span class="line-modified">4424             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);</span>
4425             return false;
4426         }
<span class="line-modified">4427         if (type != GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; type != GraphicsContextGL::UNSIGNED_SHORT_5_6_5 &amp;&amp; type != GraphicsContextGL::FLOAT &amp;&amp; type != GraphicsContextGL::HALF_FLOAT_OES &amp;&amp; type != GraphicsContextGL::HALF_FLOAT) {</span>
<span class="line-modified">4428             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);</span>
4429             return false;
4430         }
4431         break;
<span class="line-modified">4432     case ExtensionsGL::SRGB_ALPHA_EXT:</span>
4433         if (format != internalFormat) {
<span class="line-modified">4434             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);</span>
4435             return false;
4436         }
<span class="line-modified">4437         if (type != GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; type != GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4 &amp;&amp; type != GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1 &amp;&amp; type != GraphicsContextGL::FLOAT &amp;&amp; type != GraphicsContextGL::HALF_FLOAT_OES &amp;&amp; type != GraphicsContextGL::HALF_FLOAT) {</span>
<span class="line-modified">4438             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);</span>
4439             return false;
4440         }
4441         break;
4442     default:
<span class="line-modified">4443         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;Unknown internal format&quot;);</span>
4444         return false;
4445     }
4446 #undef INTERNAL_FORMAT_CASE
4447 
4448     return true;
4449 }
4450 
<span class="line-modified">4451 void WebGLRenderingContextBase::texSubImage2DBase(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum internalFormat, GCGLenum format, GCGLenum type, const void* pixels)</span>
4452 {
4453     ASSERT(!isContextLost());
4454     ASSERT(validateTexFuncParameters(&quot;texSubImage2D&quot;, TexSubImage, target, level, internalFormat, width, height, 0, format, type));
4455     ASSERT(validateSize(&quot;texSubImage2D&quot;, xoffset, yoffset));
4456     ASSERT(validateSettableTexInternalFormat(&quot;texSubImage2D&quot;, internalFormat));
4457     auto tex = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4458     if (!tex) {
4459         ASSERT_NOT_REACHED();
4460         return;
4461     }
4462     ASSERT((xoffset + width) &gt;= 0);
4463     ASSERT((yoffset + height) &gt;= 0);
4464     ASSERT(tex-&gt;getWidth(target, level) &gt;= (xoffset + width));
4465     ASSERT(tex-&gt;getHeight(target, level) &gt;= (yoffset + height));
4466     ASSERT_UNUSED(internalFormat, tex-&gt;getInternalFormat(target, level) == internalFormat);
4467     m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
4468 }
4469 
<span class="line-modified">4470 void WebGLRenderingContextBase::copyTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLint border)</span>
4471 {
4472     if (isContextLostOrPending())
4473         return;
<span class="line-modified">4474     if (!validateTexFuncParameters(&quot;copyTexImage2D&quot;, CopyTexImage, target, level, internalFormat, width, height, border, internalFormat, GraphicsContextGL::UNSIGNED_BYTE))</span>
4475         return;
4476     if (!validateSettableTexInternalFormat(&quot;copyTexImage2D&quot;, internalFormat))
4477         return;
4478     auto tex = validateTextureBinding(&quot;copyTexImage2D&quot;, target, true);
4479     if (!tex)
4480         return;
4481     if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
<span class="line-modified">4482         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;copyTexImage2D&quot;, &quot;framebuffer is incompatible format&quot;);</span>
4483         return;
4484     }
4485     if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
<span class="line-modified">4486         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexImage2D&quot;, &quot;level &gt; 0 not power of 2&quot;);</span>
4487         return;
4488     }
4489     const char* reason = &quot;framebuffer incomplete&quot;;
<span class="line-modified">4490     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="line-modified">4491         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexImage2D&quot;, reason);</span>
4492         return;
4493     }
4494     clearIfComposited();
4495 
<span class="line-modified">4496     GCGLint clippedX, clippedY;</span>
<span class="line-modified">4497     GCGLsizei clippedWidth, clippedHeight;</span>
4498     if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
4499         m_context-&gt;texImage2DResourceSafe(target, level, internalFormat, width, height, border,
<span class="line-modified">4500             internalFormat, GraphicsContextGL::UNSIGNED_BYTE, m_unpackAlignment);</span>
4501         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0) {
4502             m_context-&gt;copyTexSubImage2D(target, level, clippedX - x, clippedY - y,
4503                 clippedX, clippedY, clippedWidth, clippedHeight);
4504         }
4505     } else
4506         m_context-&gt;copyTexImage2D(target, level, internalFormat, x, y, width, height, border);
4507 
4508     // FIXME: if the framebuffer is not complete, none of the below should be executed.
<span class="line-modified">4509     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);</span>
4510 }
4511 
<span class="line-modified">4512 static bool isRGBFormat(GCGLenum internalFormat)</span>
4513 {
<span class="line-modified">4514     return internalFormat == GraphicsContextGL::RGB</span>
<span class="line-modified">4515         || internalFormat == GraphicsContextGL::RGBA</span>
<span class="line-modified">4516         || internalFormat == GraphicsContextGL::RGB8</span>
<span class="line-modified">4517         || internalFormat == GraphicsContextGL::RGBA8;</span>
4518 }
4519 
<span class="line-modified">4520 ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt; source)</span>
4521 {
4522     if (!source) {
<span class="line-modified">4523         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;source is null&quot;);</span>
4524         return { };
4525     }
4526 
4527     auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
4528         if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageBitmap, target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, 0, 0))
4529             return { };
4530 
4531         ImageBuffer* buffer = bitmap-&gt;buffer();
4532         if (!buffer)
4533             return { };
4534 
4535         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4536         // If possible, copy from the bitmap directly to the texture
4537         // via the GPU, without a read-back to system memory.
4538         //
4539         // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
4540         // ImageBuffer::copyToPlatformTexture implementations are fully functional.
4541         if (texture
<span class="line-modified">4542             &amp;&amp; (format == GraphicsContextGL::RGB || format == GraphicsContextGL::RGBA)</span>
<span class="line-modified">4543             &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE) {</span>
4544             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4545             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4546                 if (buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4547                     texture-&gt;setLevelInfo(target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), type);
4548                     return { };
4549                 }
4550             }
4551         }
4552 
4553         // Normal pure SW path.
<span class="line-modified">4554         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(DontCopyBackingStore);</span>
4555         if (image)
<span class="line-modified">4556             texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4557         return { };
4558     }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
4559         if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageData, target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, 0, 0))
4560             return { };
4561         Vector&lt;uint8_t&gt; data;
4562         bool needConversion = true;
4563         // The data from ImageData is always of format RGBA8.
4564         // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
<span class="line-modified">4565         if (!m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha &amp;&amp; format == GraphicsContextGL::RGBA &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE)</span>
4566             needConversion = false;
4567         else {
4568             if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
<span class="line-modified">4569                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
4570                 return { };
4571             }
4572         }
4573         if (m_unpackAlignment != 1)
<span class="line-modified">4574             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
4575         texImage2DBase(target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
4576         if (m_unpackAlignment != 1)
<span class="line-modified">4577             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
4578         return { };
4579     }, [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
4580         if (isContextLostOrPending())
4581             return { };
4582         auto validationResult = validateHTMLImageElement(&quot;texImage2D&quot;, image.get());
4583         if (validationResult.hasException())
4584             return validationResult.releaseException();
4585         if (!validationResult.returnValue())
4586             return { };
4587 
4588         RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
4589         if (!imageForRender)
4590             return { };
4591 
<span class="line-modified">4592         if (imageForRender-&gt;isSVGImage() || imageForRender-&gt;orientation() != ImageOrientation::None)</span>
4593             imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
4594 
4595         if (!imageForRender || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLImageElement, target, level, internalformat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, 0, 0))
4596             return { };
4597 
<span class="line-modified">4598         texImage2DImpl(target, level, internalformat, format, type, imageForRender.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4599         return { };
4600     }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
4601         if (isContextLostOrPending())
4602             return { };
4603         auto validationResult = validateHTMLCanvasElement(&quot;texImage2D&quot;, canvas.get());
4604         if (validationResult.hasException())
4605             return validationResult.releaseException();
4606         if (!validationResult.returnValue())
4607             return { };
4608         if (!validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLCanvasElement, target, level, internalformat, canvas-&gt;width(), canvas-&gt;height(), 0, format, type, 0, 0))
4609             return { };
4610 
4611         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4612         // If possible, copy from the canvas element directly to the texture
4613         // via the GPU, without a read-back to system memory.
4614         //
4615         // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
4616         // ImageBuffer::copyToPlatformTexture implementations are fully functional.
4617         if (texture
<span class="line-modified">4618             &amp;&amp; (format == GraphicsContextGL::RGB || format == GraphicsContextGL::RGBA)</span>
<span class="line-modified">4619             &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE) {</span>
4620             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4621             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4622                 ImageBuffer* buffer = canvas-&gt;buffer();
4623                 if (buffer &amp;&amp; buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4624                     texture-&gt;setLevelInfo(target, level, internalformat, canvas-&gt;width(), canvas-&gt;height(), type);
4625                     return { };
4626                 }
4627             }
4628         }
4629 
4630         RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
4631         if (imageData)
4632             texImage2D(target, level, internalformat, format, type, TexImageSource(imageData.get()));
4633         else
<span class="line-modified">4634             texImage2DImpl(target, level, internalformat, format, type, canvas-&gt;copiedImage(), GraphicsContextGL::DOMSource::Canvas, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4635         return { };
4636     }
4637 #if ENABLE(VIDEO)
4638     , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
4639         if (isContextLostOrPending())
4640             return { };
4641         auto validationResult = validateHTMLVideoElement(&quot;texImage2D&quot;, video.get());
4642         if (validationResult.hasException())
4643             return validationResult.releaseException();
4644         if (!validationResult.returnValue())
4645             return { };
4646         if (!validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLVideoElement, target, level, internalformat, video-&gt;videoWidth(), video-&gt;videoHeight(), 0, format, type, 0, 0))
4647             return { };
4648 
4649         // Go through the fast path doing a GPU-GPU textures copy without a readback to system memory if possible.
4650         // Otherwise, it will fall back to the normal SW path.
4651         // FIXME: The current restrictions require that format shoud be RGB or RGBA,
4652         // type should be UNSIGNED_BYTE and level should be 0. It may be lifted in the future.
4653         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
<span class="line-modified">4654         if (GraphicsContextGL::TEXTURE_2D == target &amp;&amp; texture</span>
<span class="line-modified">4655             &amp;&amp; (format == GraphicsContextGL::RGB || format == GraphicsContextGL::RGBA)</span>
<span class="line-modified">4656             &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE</span>
4657             &amp;&amp; !level) {
4658             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4659             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4660                 if (video-&gt;copyVideoTextureToPlatformTexture(m_context.get(), texture-&gt;object(), target, level, internalformat, format, type, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4661                     texture-&gt;setLevelInfo(target, level, internalformat, video-&gt;videoWidth(), video-&gt;videoHeight(), type);
4662                     return { };
4663                 }
4664             }
4665         }
4666 
4667         // Normal pure SW path.
<span class="line-modified">4668         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), DontCopyBackingStore);</span>
4669         if (!image)
4670             return { };
<span class="line-modified">4671         texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContextGL::DOMSource::Video, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
4672         return { };
4673     }
4674 #endif
4675     );
4676 
4677     return WTF::visit(visitor, source.value());
4678 }
4679 
4680 RefPtr&lt;Image&gt; WebGLRenderingContextBase::drawImageIntoBuffer(Image&amp; image, int width, int height, int deviceScaleFactor)
4681 {
4682     IntSize size(width, height);
4683     size.scale(deviceScaleFactor);
4684     ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
4685     if (!buf) {
<span class="line-modified">4686         synthesizeGLError(GraphicsContextGL::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);</span>
4687         return nullptr;
4688     }
4689 
4690     FloatRect srcRect(FloatPoint(), image.size());
4691     FloatRect destRect(FloatPoint(), size);
4692     buf-&gt;context().drawImage(image, destRect, srcRect);
<span class="line-modified">4693     return buf-&gt;copyImage(DontCopyBackingStore);</span>
4694 }
4695 
4696 #if ENABLE(VIDEO)
4697 
4698 RefPtr&lt;Image&gt; WebGLRenderingContextBase::videoFrameToImage(HTMLVideoElement* video, BackingStoreCopy backingStoreCopy)
4699 {
4700     IntSize size(video-&gt;videoWidth(), video-&gt;videoHeight());
4701     ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
4702     if (!buf) {
<span class="line-modified">4703         synthesizeGLError(GraphicsContextGL::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);</span>
4704         return nullptr;
4705     }
4706     FloatRect destRect(0, 0, size.width(), size.height());
4707     // FIXME: Turn this into a GPU-GPU texture copy instead of CPU readback.
4708     video-&gt;paintCurrentFrameInContext(buf-&gt;context(), destRect);
4709     return buf-&gt;copyImage(backingStoreCopy);
4710 }
4711 
4712 #endif
4713 
<span class="line-modified">4714 void WebGLRenderingContextBase::texParameter(GCGLenum target, GCGLenum pname, GCGLfloat paramf, GCGLint parami, bool isFloat)</span>
4715 {
4716     if (isContextLostOrPending())
4717         return;
4718     auto tex = validateTextureBinding(&quot;texParameter&quot;, target, false);
4719     if (!tex)
4720         return;
4721     switch (pname) {
<span class="line-modified">4722     case GraphicsContextGL::TEXTURE_MIN_FILTER:</span>
<span class="line-modified">4723     case GraphicsContextGL::TEXTURE_MAG_FILTER:</span>
4724         break;
<span class="line-modified">4725     case GraphicsContextGL::TEXTURE_WRAP_S:</span>
<span class="line-modified">4726     case GraphicsContextGL::TEXTURE_WRAP_T:</span>
<span class="line-modified">4727         if ((isFloat &amp;&amp; paramf != GraphicsContextGL::CLAMP_TO_EDGE &amp;&amp; paramf != GraphicsContextGL::MIRRORED_REPEAT &amp;&amp; paramf != GraphicsContextGL::REPEAT)</span>
<span class="line-modified">4728             || (!isFloat &amp;&amp; parami != GraphicsContextGL::CLAMP_TO_EDGE &amp;&amp; parami != GraphicsContextGL::MIRRORED_REPEAT &amp;&amp; parami != GraphicsContextGL::REPEAT)) {</span>
<span class="line-modified">4729             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter&quot;);</span>
4730             return;
4731         }
4732         break;
<span class="line-modified">4733     case ExtensionsGL::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
4734         if (!m_extTextureFilterAnisotropic) {
<span class="line-modified">4735             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter, EXT_texture_filter_anisotropic not enabled&quot;);</span>
4736             return;
4737         }
4738         break;
4739     default:
<span class="line-modified">4740         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter name&quot;);</span>
4741         return;
4742     }
4743     if (isFloat) {
4744         tex-&gt;setParameterf(pname, paramf);
4745         m_context-&gt;texParameterf(target, pname, paramf);
4746     } else {
4747         tex-&gt;setParameteri(pname, parami);
4748         m_context-&gt;texParameteri(target, pname, parami);
4749     }
4750 }
4751 
<span class="line-modified">4752 void WebGLRenderingContextBase::texParameterf(GCGLenum target, GCGLenum pname, GCGLfloat param)</span>
4753 {
4754     texParameter(target, pname, param, 0, true);
4755 }
4756 
<span class="line-modified">4757 void WebGLRenderingContextBase::texParameteri(GCGLenum target, GCGLenum pname, GCGLint param)</span>
4758 {
4759     texParameter(target, pname, 0, param, false);
4760 }
4761 
<span class="line-modified">4762 void WebGLRenderingContextBase::uniform1f(const WebGLUniformLocation* location, GCGLfloat x)</span>
4763 {
4764     if (isContextLostOrPending() || !location)
4765         return;
4766 
4767     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4768         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform1f&quot;, &quot;location not for current program&quot;);</span>
4769         return;
4770     }
4771 
4772     m_context-&gt;uniform1f(location-&gt;location(), x);
4773 }
4774 
<span class="line-modified">4775 void WebGLRenderingContextBase::uniform2f(const WebGLUniformLocation* location, GCGLfloat x, GCGLfloat y)</span>
4776 {
4777     if (isContextLostOrPending() || !location)
4778         return;
4779 
4780     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4781         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform2f&quot;, &quot;location not for current program&quot;);</span>
4782         return;
4783     }
4784 
4785     m_context-&gt;uniform2f(location-&gt;location(), x, y);
4786 }
4787 
<span class="line-modified">4788 void WebGLRenderingContextBase::uniform3f(const WebGLUniformLocation* location, GCGLfloat x, GCGLfloat y, GCGLfloat z)</span>
4789 {
4790     if (isContextLostOrPending() || !location)
4791         return;
4792 
4793     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4794         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform3f&quot;, &quot;location not for current program&quot;);</span>
4795         return;
4796     }
4797 
4798     m_context-&gt;uniform3f(location-&gt;location(), x, y, z);
4799 }
4800 
<span class="line-modified">4801 void WebGLRenderingContextBase::uniform4f(const WebGLUniformLocation* location, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w)</span>
4802 {
4803     if (isContextLostOrPending() || !location)
4804         return;
4805 
4806     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4807         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform4f&quot;, &quot;location not for current program&quot;);</span>
4808         return;
4809     }
4810 
4811     m_context-&gt;uniform4f(location-&gt;location(), x, y, z, w);
4812 }
4813 
<span class="line-modified">4814 void WebGLRenderingContextBase::uniform1i(const WebGLUniformLocation* location, GCGLint x)</span>
4815 {
4816     if (isContextLostOrPending() || !location)
4817         return;
4818 
4819     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4820         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform1i&quot;, &quot;location not for current program&quot;);</span>
4821         return;
4822     }
4823 
<span class="line-modified">4824     if ((location-&gt;type() == GraphicsContextGL::SAMPLER_2D || location-&gt;type() == GraphicsContextGL::SAMPLER_CUBE) &amp;&amp; x &gt;= (int)m_textureUnits.size()) {</span>
<span class="line-modified">4825         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;uniform1i&quot;, &quot;invalid texture unit&quot;);</span>
4826         return;
4827     }
4828 
4829     m_context-&gt;uniform1i(location-&gt;location(), x);
4830 }
4831 
<span class="line-modified">4832 void WebGLRenderingContextBase::uniform2i(const WebGLUniformLocation* location, GCGLint x, GCGLint y)</span>
4833 {
4834     if (isContextLostOrPending() || !location)
4835         return;
4836 
4837     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4838         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform2i&quot;, &quot;location not for current program&quot;);</span>
4839         return;
4840     }
4841 
4842     m_context-&gt;uniform2i(location-&gt;location(), x, y);
4843 }
4844 
<span class="line-modified">4845 void WebGLRenderingContextBase::uniform3i(const WebGLUniformLocation* location, GCGLint x, GCGLint y, GCGLint z)</span>
4846 {
4847     if (isContextLostOrPending() || !location)
4848         return;
4849 
4850     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4851         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform3i&quot;, &quot;location not for current program&quot;);</span>
4852         return;
4853     }
4854 
4855     m_context-&gt;uniform3i(location-&gt;location(), x, y, z);
4856 }
4857 
<span class="line-modified">4858 void WebGLRenderingContextBase::uniform4i(const WebGLUniformLocation* location, GCGLint x, GCGLint y, GCGLint z, GCGLint w)</span>
4859 {
4860     if (isContextLostOrPending() || !location)
4861         return;
4862 
4863     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">4864         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform4i&quot;, &quot;location not for current program&quot;);</span>
4865         return;
4866     }
4867 
4868     m_context-&gt;uniform4i(location-&gt;location(), x, y, z, w);
4869 }
4870 
4871 void WebGLRenderingContextBase::uniform1fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4872 {
4873     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform1fv&quot;, location, v, 1))
4874         return;
4875 
4876     m_context-&gt;uniform1fv(location-&gt;location(), v.length(), v.data());
4877 }
4878 
4879 void WebGLRenderingContextBase::uniform2fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4880 {
4881     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform2fv&quot;, location, v, 2))
4882         return;
4883 
4884     m_context-&gt;uniform2fv(location-&gt;location(), v.length() / 2, v.data());
</pre>
<hr />
<pre>
4891 
4892     m_context-&gt;uniform3fv(location-&gt;location(), v.length() / 3, v.data());
4893 }
4894 
4895 void WebGLRenderingContextBase::uniform4fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4896 {
4897     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform4fv&quot;, location, v, 4))
4898         return;
4899 
4900     m_context-&gt;uniform4fv(location-&gt;location(), v.length() / 4, v.data());
4901 }
4902 
4903 void WebGLRenderingContextBase::uniform1iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4904 {
4905     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform1iv&quot;, location, v, 1))
4906         return;
4907 
4908     auto data = v.data();
4909     auto length = v.length();
4910 
<span class="line-modified">4911     if (location-&gt;type() == GraphicsContextGL::SAMPLER_2D || location-&gt;type() == GraphicsContextGL::SAMPLER_CUBE) {</span>
4912         for (auto i = 0; i &lt; length; ++i) {
4913             if (data[i] &gt;= static_cast&lt;int&gt;(m_textureUnits.size())) {
4914                 LOG(WebGL, &quot;Texture unit size=%zu, v[%d]=%d. Location type = %04X.&quot;, m_textureUnits.size(), i, data[i], location-&gt;type());
<span class="line-modified">4915                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;uniform1iv&quot;, &quot;invalid texture unit&quot;);</span>
4916                 return;
4917             }
4918         }
4919     }
4920 
4921     m_context-&gt;uniform1iv(location-&gt;location(), length, data);
4922 }
4923 
4924 void WebGLRenderingContextBase::uniform2iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4925 {
4926     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform2iv&quot;, location, v, 2))
4927         return;
4928 
4929     m_context-&gt;uniform2iv(location-&gt;location(), v.length() / 2, v.data());
4930 }
4931 
4932 void WebGLRenderingContextBase::uniform3iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4933 {
4934     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform3iv&quot;, location, v, 3))
4935         return;
4936 
4937     m_context-&gt;uniform3iv(location-&gt;location(), v.length() / 3, v.data());
4938 }
4939 
4940 void WebGLRenderingContextBase::uniform4iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4941 {
4942     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform4iv&quot;, location, v, 4))
4943         return;
4944 
4945     m_context-&gt;uniform4iv(location-&gt;location(), v.length() / 4, v.data());
4946 }
4947 
<span class="line-modified">4948 void WebGLRenderingContextBase::uniformMatrix2fv(const WebGLUniformLocation* location, GCGLboolean transpose, Float32List&amp;&amp; v)</span>
4949 {
4950     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix2fv&quot;, location, transpose, v, 4))
4951         return;
4952     m_context-&gt;uniformMatrix2fv(location-&gt;location(), v.length() / 4, transpose, v.data());
4953 }
4954 
<span class="line-modified">4955 void WebGLRenderingContextBase::uniformMatrix3fv(const WebGLUniformLocation* location, GCGLboolean transpose, Float32List&amp;&amp; v)</span>
4956 {
4957     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix3fv&quot;, location, transpose, v, 9))
4958         return;
4959     m_context-&gt;uniformMatrix3fv(location-&gt;location(), v.length() / 9, transpose, v.data());
4960 }
4961 
<span class="line-modified">4962 void WebGLRenderingContextBase::uniformMatrix4fv(const WebGLUniformLocation* location, GCGLboolean transpose, Float32List&amp;&amp; v)</span>
4963 {
4964     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix4fv&quot;, location, transpose, v, 16))
4965         return;
4966     m_context-&gt;uniformMatrix4fv(location-&gt;location(), v.length() / 16, transpose, v.data());
4967 }
4968 
4969 void WebGLRenderingContextBase::useProgram(WebGLProgram* program)
4970 {
4971     bool deleted;
4972     if (!checkObjectToBeBound(&quot;useProgram&quot;, program, deleted))
4973         return;
4974     if (deleted)
4975         program = 0;
4976     if (program &amp;&amp; !program-&gt;getLinkStatus()) {
<span class="line-modified">4977         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;useProgram&quot;, &quot;program not valid&quot;);</span>
4978         return;
4979     }
4980     if (m_currentProgram != program) {
4981         if (m_currentProgram)
<span class="line-modified">4982             m_currentProgram-&gt;onDetached(graphicsContextGL());</span>
4983         m_currentProgram = program;
4984         m_context-&gt;useProgram(objectOrZero(program));
4985         if (program)
4986             program-&gt;onAttached();
4987     }
4988 }
4989 
4990 void WebGLRenderingContextBase::validateProgram(WebGLProgram* program)
4991 {
4992     if (isContextLostOrPending() || !validateWebGLObject(&quot;validateProgram&quot;, program))
4993         return;
4994     m_context-&gt;validateProgram(objectOrZero(program));
4995 }
4996 
<span class="line-modified">4997 void WebGLRenderingContextBase::vertexAttrib1f(GCGLuint index, GCGLfloat v0)</span>
4998 {
4999     vertexAttribfImpl(&quot;vertexAttrib1f&quot;, index, 1, v0, 0.0f, 0.0f, 1.0f);
5000 }
5001 
<span class="line-modified">5002 void WebGLRenderingContextBase::vertexAttrib2f(GCGLuint index, GCGLfloat v0, GCGLfloat v1)</span>
5003 {
5004     vertexAttribfImpl(&quot;vertexAttrib2f&quot;, index, 2, v0, v1, 0.0f, 1.0f);
5005 }
5006 
<span class="line-modified">5007 void WebGLRenderingContextBase::vertexAttrib3f(GCGLuint index, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2)</span>
5008 {
5009     vertexAttribfImpl(&quot;vertexAttrib3f&quot;, index, 3, v0, v1, v2, 1.0f);
5010 }
5011 
<span class="line-modified">5012 void WebGLRenderingContextBase::vertexAttrib4f(GCGLuint index, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2, GCGLfloat v3)</span>
5013 {
5014     vertexAttribfImpl(&quot;vertexAttrib4f&quot;, index, 4, v0, v1, v2, v3);
5015 }
5016 
<span class="line-modified">5017 void WebGLRenderingContextBase::vertexAttrib1fv(GCGLuint index, Float32List&amp;&amp; v)</span>
5018 {
5019     vertexAttribfvImpl(&quot;vertexAttrib1fv&quot;, index, WTFMove(v), 1);
5020 }
5021 
<span class="line-modified">5022 void WebGLRenderingContextBase::vertexAttrib2fv(GCGLuint index, Float32List&amp;&amp; v)</span>
5023 {
5024     vertexAttribfvImpl(&quot;vertexAttrib2fv&quot;, index, WTFMove(v), 2);
5025 }
5026 
<span class="line-modified">5027 void WebGLRenderingContextBase::vertexAttrib3fv(GCGLuint index, Float32List&amp;&amp; v)</span>
5028 {
5029     vertexAttribfvImpl(&quot;vertexAttrib3fv&quot;, index, WTFMove(v), 3);
5030 }
5031 
<span class="line-modified">5032 void WebGLRenderingContextBase::vertexAttrib4fv(GCGLuint index, Float32List&amp;&amp; v)</span>
5033 {
5034     vertexAttribfvImpl(&quot;vertexAttrib4fv&quot;, index, WTFMove(v), 4);
5035 }
5036 
<span class="line-modified">5037 void WebGLRenderingContextBase::vertexAttribPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLboolean normalized, GCGLsizei stride, long long offset)</span>
5038 {
5039     if (isContextLostOrPending())
5040         return;
5041     switch (type) {
<span class="line-modified">5042     case GraphicsContextGL::BYTE:</span>
<span class="line-modified">5043     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="line-modified">5044     case GraphicsContextGL::SHORT:</span>
<span class="line-modified">5045     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="line-modified">5046     case GraphicsContextGL::FLOAT:</span>
5047         break;
5048     default:
<span class="line-modified">5049         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);</span>
5050         return;
5051     }
5052     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">5053         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;index out of range&quot;);</span>
5054         return;
5055     }
5056     if (size &lt; 1 || size &gt; 4) {
<span class="line-modified">5057         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad size&quot;);</span>
5058         return;
5059     }
5060     if (stride &lt; 0 || stride &gt; 255) {
<span class="line-modified">5061         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad stride&quot;);</span>
5062         return;
5063     }
5064     if (offset &lt; 0 || offset &gt; std::numeric_limits&lt;int32_t&gt;::max()) {
<span class="line-modified">5065         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad offset&quot;);</span>
5066         return;
5067     }
5068     if (!m_boundArrayBuffer &amp;&amp; offset) {
<span class="line-modified">5069         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;no bound ARRAY_BUFFER&quot;);</span>
5070         return;
5071     }
5072     // Determine the number of elements the bound buffer can hold, given the offset, size, type and stride
5073     auto typeSize = sizeInBytes(type);
5074     if (!typeSize) {
<span class="line-modified">5075         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);</span>
5076         return;
5077     }
<span class="line-modified">5078     if ((stride % typeSize) || (static_cast&lt;GCGLintptr&gt;(offset) % typeSize)) {</span>
<span class="line-modified">5079         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;stride or offset not valid for type&quot;);</span>
5080         return;
5081     }
<span class="line-modified">5082     GCGLsizei bytesPerElement = size * typeSize;</span>
5083 
<span class="line-modified">5084     m_boundVertexArrayObject-&gt;setVertexAttribState(index, bytesPerElement, size, type, normalized, stride, static_cast&lt;GCGLintptr&gt;(offset), m_boundArrayBuffer.get());</span>
<span class="line-modified">5085     m_context-&gt;vertexAttribPointer(index, size, type, normalized, stride, static_cast&lt;GCGLintptr&gt;(offset));</span>
5086 }
5087 
<span class="line-modified">5088 void WebGLRenderingContextBase::viewport(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)</span>
5089 {
5090     if (isContextLostOrPending())
5091         return;
5092     if (!validateSize(&quot;viewport&quot;, width, height))
5093         return;
5094     m_context-&gt;viewport(x, y, width, height);
5095 }
5096 
5097 void WebGLRenderingContextBase::forceLostContext(WebGLRenderingContextBase::LostContextMode mode)
5098 {
5099     if (isContextLostOrPending()) {
<span class="line-modified">5100         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;loseContext&quot;, &quot;context already lost&quot;);</span>
5101         return;
5102     }
5103 
5104     m_contextGroup-&gt;loseContextGroup(mode);
5105 }
5106 
5107 void WebGLRenderingContextBase::loseContextImpl(WebGLRenderingContextBase::LostContextMode mode)
5108 {
5109     if (isContextLost())
5110         return;
5111 
5112     m_contextLost = true;
5113     m_contextLostMode = mode;
5114 
5115     if (mode == RealLostContext) {
5116         // Inform the embedder that a lost context was received. In response, the embedder might
5117         // decide to take action such as asking the user for permission to use WebGL again.
5118         auto* canvas = htmlCanvas();
5119         if (canvas) {
5120             if (RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame())
5121                 frame-&gt;loader().client().didLoseWebGLContext(m_context-&gt;getExtensions().getGraphicsResetStatusARB());
5122         }
5123     }
5124 
5125     detachAndRemoveAllObjects();
5126 
5127     // There is no direct way to clear errors from a GL implementation and
5128     // looping until getError() becomes NO_ERROR might cause an infinite loop if
5129     // the driver or context implementation had a bug. So, loop a reasonably
5130     // large number of times to clear any existing errors.
5131     for (int i = 0; i &lt; 100; ++i) {
<span class="line-modified">5132         if (m_context-&gt;getError() == GraphicsContextGL::NO_ERROR)</span>
5133             break;
5134     }
5135     ConsoleDisplayPreference display = (mode == RealLostContext) ? DisplayInConsole: DontDisplayInConsole;
<span class="line-modified">5136     synthesizeGLError(GraphicsContextGL::CONTEXT_LOST_WEBGL, &quot;loseContext&quot;, &quot;context lost&quot;, display);</span>
5137 
5138     // Don&#39;t allow restoration unless the context lost event has both been
5139     // dispatched and its default behavior prevented.
5140     m_restoreAllowed = false;
5141 
5142     // Always defer the dispatch of the context lost event, to implement
5143     // the spec behavior of queueing a task.
5144     m_dispatchContextLostEventTimer.startOneShot(0_s);
5145 }
5146 
5147 void WebGLRenderingContextBase::forceRestoreContext()
5148 {
5149     if (!isContextLostOrPending()) {
<span class="line-modified">5150         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context not lost&quot;);</span>
5151         return;
5152     }
5153 
5154     if (!m_restoreAllowed) {
5155         if (m_contextLostMode == SyntheticLostContext)
<span class="line-modified">5156             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context restoration not allowed&quot;);</span>
5157         return;
5158     }
5159 
5160     if (!m_restoreTimer.isActive())
5161         m_restoreTimer.startOneShot(0_s);
5162 }
5163 
5164 PlatformLayer* WebGLRenderingContextBase::platformLayer() const
5165 {
5166     return (!isContextLost() &amp;&amp; !m_isPendingPolicyResolution) ? m_context-&gt;platformLayer() : 0;
5167 }
5168 
5169 void WebGLRenderingContextBase::removeSharedObject(WebGLSharedObject&amp; object)
5170 {
5171     if (m_isPendingPolicyResolution)
5172         return;
5173 
5174     m_contextGroup-&gt;removeObject(object);
5175 }
5176 
</pre>
<hr />
<pre>
5203 void WebGLRenderingContextBase::detachAndRemoveAllObjects()
5204 {
5205     if (m_isPendingPolicyResolution)
5206         return;
5207 
5208     while (m_contextObjects.size() &gt; 0) {
5209         HashSet&lt;WebGLContextObject*&gt;::iterator it = m_contextObjects.begin();
5210         (*it)-&gt;detachContext();
5211     }
5212 }
5213 
5214 bool WebGLRenderingContextBase::hasPendingActivity() const
5215 {
5216     return false;
5217 }
5218 
5219 void WebGLRenderingContextBase::stop()
5220 {
5221     if (!isContextLost() &amp;&amp; !m_isPendingPolicyResolution) {
5222         forceLostContext(SyntheticLostContext);
<span class="line-modified">5223         destroyGraphicsContextGL();</span>
5224     }
5225 }
5226 
5227 const char* WebGLRenderingContextBase::activeDOMObjectName() const
5228 {
5229     return &quot;WebGLRenderingContext&quot;;
5230 }
5231 
<span class="line-modified">5232 void WebGLRenderingContextBase::suspend(ReasonForSuspension)</span>
5233 {
<span class="line-modified">5234     m_isSuspended = true;</span>

5235 }
5236 
<span class="line-modified">5237 void WebGLRenderingContextBase::resume()</span>
5238 {
<span class="line-modified">5239     m_isSuspended = false;</span>
<span class="line-added">5240 }</span>
<span class="line-added">5241 </span>
<span class="line-added">5242 bool WebGLRenderingContextBase::getBooleanParameter(GCGLenum pname)</span>
<span class="line-added">5243 {</span>
<span class="line-added">5244     GCGLboolean value = 0;</span>
5245     m_context-&gt;getBooleanv(pname, &amp;value);
5246     return value;
5247 }
5248 
<span class="line-modified">5249 Vector&lt;bool&gt; WebGLRenderingContextBase::getBooleanArrayParameter(GCGLenum pname)</span>
5250 {
<span class="line-modified">5251     if (pname != GraphicsContextGL::COLOR_WRITEMASK) {</span>
5252         notImplemented();
5253         return { };
5254     }
<span class="line-modified">5255     GCGLboolean value[4] = { 0 };</span>
5256     m_context-&gt;getBooleanv(pname, value);
5257     Vector&lt;bool&gt; vector(4);
5258     for (unsigned i = 0; i &lt; 4; ++i)
5259         vector[i] = value[i];
5260     return vector;
5261 }
5262 
<span class="line-modified">5263 float WebGLRenderingContextBase::getFloatParameter(GCGLenum pname)</span>
5264 {
<span class="line-modified">5265     GCGLfloat value = 0;</span>
5266     m_context-&gt;getFloatv(pname, &amp;value);
5267     return value;
5268 }
5269 
<span class="line-modified">5270 int WebGLRenderingContextBase::getIntParameter(GCGLenum pname)</span>
5271 {
<span class="line-modified">5272     GCGLint value = 0;</span>
5273     m_context-&gt;getIntegerv(pname, &amp;value);
5274     return value;
5275 }
5276 
<span class="line-modified">5277 unsigned WebGLRenderingContextBase::getUnsignedIntParameter(GCGLenum pname)</span>
5278 {
<span class="line-modified">5279     GCGLint value = 0;</span>
5280     m_context-&gt;getIntegerv(pname, &amp;value);
5281     return value;
5282 }
5283 
<span class="line-modified">5284 long long WebGLRenderingContextBase::getInt64Parameter(GCGLenum pname)</span>
5285 {
<span class="line-modified">5286     GCGLint64 value = 0;</span>
5287     m_context-&gt;getInteger64v(pname, &amp;value);
5288     return value;
5289 }
5290 
<span class="line-modified">5291 RefPtr&lt;Float32Array&gt; WebGLRenderingContextBase::getWebGLFloatArrayParameter(GCGLenum pname)</span>
5292 {
<span class="line-modified">5293     GCGLfloat value[4] = {0};</span>
5294     m_context-&gt;getFloatv(pname, value);
5295     unsigned length = 0;
5296     switch (pname) {
<span class="line-modified">5297     case GraphicsContextGL::ALIASED_POINT_SIZE_RANGE:</span>
<span class="line-modified">5298     case GraphicsContextGL::ALIASED_LINE_WIDTH_RANGE:</span>
<span class="line-modified">5299     case GraphicsContextGL::DEPTH_RANGE:</span>
5300         length = 2;
5301         break;
<span class="line-modified">5302     case GraphicsContextGL::BLEND_COLOR:</span>
<span class="line-modified">5303     case GraphicsContextGL::COLOR_CLEAR_VALUE:</span>
5304         length = 4;
5305         break;
5306     default:
5307         notImplemented();
5308     }
5309     return Float32Array::tryCreate(value, length);
5310 }
5311 
<span class="line-modified">5312 RefPtr&lt;Int32Array&gt; WebGLRenderingContextBase::getWebGLIntArrayParameter(GCGLenum pname)</span>
5313 {
<span class="line-modified">5314     GCGLint value[4] = {0};</span>
5315     m_context-&gt;getIntegerv(pname, value);
5316     unsigned length = 0;
5317     switch (pname) {
<span class="line-modified">5318     case GraphicsContextGL::MAX_VIEWPORT_DIMS:</span>
5319         length = 2;
5320         break;
<span class="line-modified">5321     case GraphicsContextGL::SCISSOR_BOX:</span>
<span class="line-modified">5322     case GraphicsContextGL::VIEWPORT:</span>
5323         length = 4;
5324         break;
5325     default:
5326         notImplemented();
5327     }
5328     return Int32Array::tryCreate(value, length);
5329 }
5330 
5331 bool WebGLRenderingContextBase::checkTextureCompleteness(const char* functionName, bool prepareToDraw)
5332 {
5333     bool resetActiveUnit = false;
5334     bool usesAtLeastOneBlackTexture = false;
5335     WebGLTexture::TextureExtensionFlag extensions = textureExtensionFlags();
5336 
5337     Vector&lt;unsigned&gt; noLongerUnrenderable;
5338     for (unsigned badTexture : m_unrenderableTextureUnits) {
5339         ASSERT(badTexture &lt; m_textureUnits.size());
5340         auto&amp; textureUnit = m_textureUnits[badTexture];
5341         bool needsToUseBlack2DTexture = textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(extensions);
5342         bool needsToUseBlack3DTexture = textureUnit.textureCubeMapBinding &amp;&amp; textureUnit.textureCubeMapBinding-&gt;needToUseBlackTexture(extensions);
5343 
5344         if (!needsToUseBlack2DTexture &amp;&amp; !needsToUseBlack3DTexture) {
5345             noLongerUnrenderable.append(badTexture);
5346             continue;
5347         }
5348 
5349         usesAtLeastOneBlackTexture = true;
5350 
5351         if (badTexture != m_activeTextureUnit) {
<span class="line-modified">5352             m_context-&gt;activeTexture(badTexture + GraphicsContextGL::TEXTURE0);</span>
5353             resetActiveUnit = true;
5354         } else if (resetActiveUnit) {
<span class="line-modified">5355             m_context-&gt;activeTexture(badTexture + GraphicsContextGL::TEXTURE0);</span>
5356             resetActiveUnit = false;
5357         }
5358         RefPtr&lt;WebGLTexture&gt; tex2D;
5359         RefPtr&lt;WebGLTexture&gt; texCubeMap;
5360         if (prepareToDraw) {
5361             printToConsole(MessageLevel::Error, makeString(&quot;WebGL: &quot;, functionName, &quot;: texture bound to texture unit &quot;, badTexture,
5362                 &quot; is not renderable. It maybe non-power-of-2 and have incompatible texture filtering or is not &#39;texture complete&#39;,&quot;
5363                 &quot; or it is a float/half-float type with linear filtering and without the relevant float/half-float linear extension enabled.&quot;));
5364             tex2D = m_blackTexture2D.get();
5365             texCubeMap = m_blackTextureCubeMap.get();
5366         } else {
5367             tex2D = textureUnit.texture2DBinding.get();
5368             texCubeMap = textureUnit.textureCubeMapBinding.get();
5369         }
5370         if (needsToUseBlack2DTexture)
<span class="line-modified">5371             m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, objectOrZero(tex2D.get()));</span>
5372         if (needsToUseBlack3DTexture)
<span class="line-modified">5373             m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_CUBE_MAP, objectOrZero(texCubeMap.get()));</span>
5374     }
5375     if (resetActiveUnit)
<span class="line-modified">5376         m_context-&gt;activeTexture(m_activeTextureUnit + GraphicsContextGL::TEXTURE0);</span>
5377 
5378     for (unsigned renderable : noLongerUnrenderable)
5379         m_unrenderableTextureUnits.remove(renderable);
5380 
5381     return usesAtLeastOneBlackTexture;
5382 }
5383 
5384 void WebGLRenderingContextBase::createFallbackBlackTextures1x1()
5385 {
5386     unsigned char black[] = {0, 0, 0, 255};
5387     m_blackTexture2D = createTexture();
<span class="line-modified">5388     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, m_blackTexture2D-&gt;object());</span>
<span class="line-modified">5389     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5390         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5391     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, 0);</span>
5392     m_blackTextureCubeMap = createTexture();
<span class="line-modified">5393     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_CUBE_MAP, m_blackTextureCubeMap-&gt;object());</span>
<span class="line-modified">5394     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5395         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5396     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5397         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5398     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5399         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5400     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5401         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5402     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5403         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5404     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="line-modified">5405         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="line-modified">5406     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_CUBE_MAP, 0);</span>
<span class="line-modified">5407 }</span>
<span class="line-modified">5408 </span>
<span class="line-modified">5409 bool WebGLRenderingContextBase::isTexInternalFormatColorBufferCombinationValid(GCGLenum texInternalFormat, GCGLenum colorBufferFormat)</span>
<span class="line-modified">5410 {</span>
<span class="line-modified">5411     auto need = GraphicsContextGLOpenGL::getChannelBitsByFormat(texInternalFormat);</span>
<span class="line-modified">5412     auto have = GraphicsContextGLOpenGL::getChannelBitsByFormat(colorBufferFormat);</span>

5413     return (need &amp; have) == need;
5414 }
5415 
<span class="line-modified">5416 GCGLenum WebGLRenderingContextBase::getBoundFramebufferColorFormat()</span>
5417 {
5418     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5419         return m_framebufferBinding-&gt;getColorBufferFormat();
5420     if (m_attributes.alpha)
<span class="line-modified">5421         return GraphicsContextGL::RGBA;</span>
<span class="line-modified">5422     return GraphicsContextGL::RGB;</span>
5423 }
5424 
5425 int WebGLRenderingContextBase::getBoundFramebufferWidth()
5426 {
5427     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5428         return m_framebufferBinding-&gt;getColorBufferWidth();
5429     return m_context-&gt;getInternalFramebufferSize().width();
5430 }
5431 
5432 int WebGLRenderingContextBase::getBoundFramebufferHeight()
5433 {
5434     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5435         return m_framebufferBinding-&gt;getColorBufferHeight();
5436     return m_context-&gt;getInternalFramebufferSize().height();
5437 }
5438 
<span class="line-modified">5439 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::validateTextureBinding(const char* functionName, GCGLenum target, bool useSixEnumsForCubeMap)</span>
5440 {
5441     RefPtr&lt;WebGLTexture&gt; texture;
5442     switch (target) {
<span class="line-modified">5443     case GraphicsContextGL::TEXTURE_2D:</span>
5444         texture = m_textureUnits[m_activeTextureUnit].texture2DBinding;
5445         break;
<span class="line-modified">5446     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="line-modified">5447     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="line-modified">5448     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="line-modified">5449     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="line-modified">5450     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="line-modified">5451     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
5452         if (!useSixEnumsForCubeMap) {
<span class="line-modified">5453             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
5454             return nullptr;
5455         }
5456         texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
5457         break;
<span class="line-modified">5458     case GraphicsContextGL::TEXTURE_CUBE_MAP:</span>
5459         if (useSixEnumsForCubeMap) {
<span class="line-modified">5460             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
5461             return nullptr;
5462         }
5463         texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
5464         break;
5465     default:
<span class="line-modified">5466         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
5467         return nullptr;
5468     }
5469 
5470     if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
5471         m_unrenderableTextureUnits.add(m_activeTextureUnit);
5472 
5473     if (!texture)
<span class="line-modified">5474         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;no texture&quot;);</span>
5475     return texture;
5476 }
5477 
5478 bool WebGLRenderingContextBase::validateLocationLength(const char* functionName, const String&amp; string)
5479 {
5480     const unsigned maxWebGLLocationLength = 256;
5481     if (string.length() &gt; maxWebGLLocationLength) {
<span class="line-modified">5482         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;location length &gt; 256&quot;);</span>
5483         return false;
5484     }
5485     return true;
5486 }
5487 
<span class="line-modified">5488 bool WebGLRenderingContextBase::validateSize(const char* functionName, GCGLint x, GCGLint y)</span>
5489 {
5490     if (x &lt; 0 || y &lt; 0) {
<span class="line-modified">5491         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;size &lt; 0&quot;);</span>
5492         return false;
5493     }
5494     return true;
5495 }
5496 
5497 bool WebGLRenderingContextBase::validateString(const char* functionName, const String&amp; string)
5498 {
5499     for (size_t i = 0; i &lt; string.length(); ++i) {
5500         if (!validateCharacter(string[i])) {
<span class="line-modified">5501             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;string not ASCII&quot;);</span>
5502             return false;
5503         }
5504     }
5505     return true;
5506 }
5507 
<span class="line-modified">5508 bool WebGLRenderingContextBase::validateTexFuncLevel(const char* functionName, GCGLenum target, GCGLint level)</span>
5509 {
5510     if (level &lt; 0) {
<span class="line-modified">5511         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level &lt; 0&quot;);</span>
5512         return false;
5513     }
5514     switch (target) {
<span class="line-modified">5515     case GraphicsContextGL::TEXTURE_2D:</span>
5516         if (level &gt;= m_maxTextureLevel) {
<span class="line-modified">5517             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level out of range&quot;);</span>
5518             return false;
5519         }
5520         break;
<span class="line-modified">5521     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="line-modified">5522     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="line-modified">5523     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="line-modified">5524     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="line-modified">5525     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="line-modified">5526     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
5527         if (level &gt;= m_maxCubeMapTextureLevel) {
<span class="line-modified">5528             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level out of range&quot;);</span>
5529             return false;
5530         }
5531         break;
5532     }
5533     // This function only checks if level is legal, so we return true and don&#39;t
5534     // generate INVALID_ENUM if target is illegal.
5535     return true;
5536 }
5537 
<span class="line-modified">5538 bool WebGLRenderingContextBase::validateCompressedTexFormat(GCGLenum format)</span>
5539 {
5540     return m_compressedTextureFormats.contains(format);
5541 }
5542 
5543 struct BlockParameters {
5544     const int width;
5545     const int height;
5546     const int size;
5547 };
5548 
<span class="line-modified">5549 static inline unsigned calculateBytesForASTC(GCGLsizei width, GCGLsizei height, const BlockParameters&amp; parameters)</span>
5550 {
5551     return ((width + parameters.width - 1) / parameters.width) * ((height + parameters.height - 1) / parameters.height) * parameters.size;
5552 }
5553 
<span class="line-modified">5554 bool WebGLRenderingContextBase::validateCompressedTexFuncData(const char* functionName, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; pixels)</span>
5555 {
5556     if (width &lt; 0 || height &lt; 0) {
<span class="line-modified">5557         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);</span>
5558         return false;
5559     }
5560 
5561     unsigned bytesRequired = 0;
5562 
5563     // Block parameters for ASTC formats
5564     const int kASTCBlockSize = 16;
5565     static const BlockParameters ASTCParameters[] {
5566         BlockParameters { 4, 4, kASTCBlockSize },
5567         BlockParameters { 5, 4, kASTCBlockSize },
5568         BlockParameters { 5, 5, kASTCBlockSize },
5569         BlockParameters { 6, 5, kASTCBlockSize },
5570         BlockParameters { 6, 6, kASTCBlockSize },
5571         BlockParameters { 8, 5, kASTCBlockSize },
5572         BlockParameters { 8, 6, kASTCBlockSize },
5573         BlockParameters { 8, 8, kASTCBlockSize },
5574         BlockParameters { 10, 5, kASTCBlockSize },
5575         BlockParameters { 10, 6, kASTCBlockSize },
5576         BlockParameters { 10, 8, kASTCBlockSize },
5577         BlockParameters { 10, 10, kASTCBlockSize },
5578         BlockParameters { 12, 10, kASTCBlockSize },
5579         BlockParameters { 12, 12, kASTCBlockSize }
5580     };
<span class="line-modified">5581     const GCGLenum ASTCEnumStartRGBA = ExtensionsGL::COMPRESSED_RGBA_ASTC_4x4_KHR;</span>
<span class="line-modified">5582     const GCGLenum ASTCEnumStartSRGB8 = ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;</span>
<span class="line-added">5583 </span>
<span class="line-added">5584     const int kEACAndETC2BlockSize = 4;</span>
5585 
5586     switch (format) {
<span class="line-modified">5587     case ExtensionsGL::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="line-modified">5588     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="line-modified">5589     case ExtensionsGL::COMPRESSED_ATC_RGB_AMD:</span>
<span class="line-modified">5590     case ExtensionsGL::ETC1_RGB8_OES: {</span>
<span class="line-modified">5591         const int kBlockSize = 8;</span>
<span class="line-modified">5592         const int kBlockWidth = 4;</span>
<span class="line-modified">5593         const int kBlockHeight = 4;</span>
<span class="line-modified">5594         int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;</span>
<span class="line-modified">5595         int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;</span>
<span class="line-modified">5596         bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;</span>

5597         break;
<span class="line-modified">5598     }</span>
<span class="line-modified">5599     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="line-modified">5600     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT5_EXT:</span>
<span class="line-modified">5601     case ExtensionsGL::COMPRESSED_ATC_RGBA_EXPLICIT_ALPHA_AMD:</span>
<span class="line-added">5602     case ExtensionsGL::COMPRESSED_ATC_RGBA_INTERPOLATED_ALPHA_AMD:</span>
5603         {
5604             const int kBlockSize = 16;
5605             const int kBlockWidth = 4;
5606             const int kBlockHeight = 4;
5607             int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;
5608             int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;
5609             bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;
5610         }
5611         break;
<span class="line-modified">5612     case ExtensionsGL::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5613     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
5614         {
5615             const int kBlockSize = 8;
5616             const int kBlockWidth = 8;
5617             const int kBlockHeight = 8;
5618             bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 4 + 7) / kBlockSize;
5619         }
5620         break;
<span class="line-modified">5621     case ExtensionsGL::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="line-modified">5622     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:</span>
5623         {
5624             const int kBlockSize = 8;
5625             const int kBlockWidth = 16;
5626             const int kBlockHeight = 8;
5627             bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 2 + 7) / kBlockSize;
5628         }
5629         break;
<span class="line-modified">5630     case ExtensionsGL::COMPRESSED_RGBA_ASTC_4x4_KHR:</span>
<span class="line-modified">5631     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x4_KHR:</span>
<span class="line-modified">5632     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x5_KHR:</span>
<span class="line-modified">5633     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x5_KHR:</span>
<span class="line-modified">5634     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x6_KHR:</span>
<span class="line-modified">5635     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x5_KHR:</span>
<span class="line-modified">5636     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x6_KHR:</span>
<span class="line-modified">5637     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x8_KHR:</span>
<span class="line-modified">5638     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x5_KHR:</span>
<span class="line-modified">5639     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x6_KHR:</span>
<span class="line-modified">5640     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x8_KHR:</span>
<span class="line-modified">5641     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x10_KHR:</span>
<span class="line-modified">5642     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x10_KHR:</span>
<span class="line-modified">5643     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x12_KHR:</span>
5644         bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartRGBA]);
5645         break;
<span class="line-modified">5646     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:</span>
<span class="line-modified">5647     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:</span>
<span class="line-modified">5648     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:</span>
<span class="line-modified">5649     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:</span>
<span class="line-modified">5650     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:</span>
<span class="line-modified">5651     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:</span>
<span class="line-modified">5652     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:</span>
<span class="line-modified">5653     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:</span>
<span class="line-modified">5654     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:</span>
<span class="line-modified">5655     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:</span>
<span class="line-modified">5656     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:</span>
<span class="line-modified">5657     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:</span>
<span class="line-modified">5658     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:</span>
<span class="line-modified">5659     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:</span>
5660         bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartSRGB8]);
5661         break;
<span class="line-added">5662     case ExtensionsGL::COMPRESSED_R11_EAC:</span>
<span class="line-added">5663     case ExtensionsGL::COMPRESSED_SIGNED_R11_EAC:</span>
<span class="line-added">5664     case ExtensionsGL::COMPRESSED_RGB8_ETC2:</span>
<span class="line-added">5665     case ExtensionsGL::COMPRESSED_SRGB8_ETC2:</span>
<span class="line-added">5666     case ExtensionsGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-added">5667     case ExtensionsGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: {</span>
<span class="line-added">5668         Checked&lt;unsigned, RecordOverflow&gt; checkedBytesRequired = (width + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;</span>
<span class="line-added">5669         checkedBytesRequired *= (height + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;</span>
<span class="line-added">5670         checkedBytesRequired *= 8;</span>
<span class="line-added">5671         if (checkedBytesRequired.hasOverflowed()) {</span>
<span class="line-added">5672             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;too large dimensions&quot;);</span>
<span class="line-added">5673             return false;</span>
<span class="line-added">5674         }</span>
<span class="line-added">5675         bytesRequired = checkedBytesRequired.unsafeGet();</span>
<span class="line-added">5676         break;</span>
<span class="line-added">5677     }</span>
<span class="line-added">5678     case ExtensionsGL::COMPRESSED_RG11_EAC:</span>
<span class="line-added">5679     case ExtensionsGL::COMPRESSED_SIGNED_RG11_EAC:</span>
<span class="line-added">5680     case ExtensionsGL::COMPRESSED_RGBA8_ETC2_EAC:</span>
<span class="line-added">5681     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: {</span>
<span class="line-added">5682         Checked&lt;unsigned, RecordOverflow&gt; checkedBytesRequired = (width + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;</span>
<span class="line-added">5683         checkedBytesRequired *= (height + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;</span>
<span class="line-added">5684         checkedBytesRequired *= 16;</span>
<span class="line-added">5685         if (checkedBytesRequired.hasOverflowed()) {</span>
<span class="line-added">5686             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;too large dimensions&quot;);</span>
<span class="line-added">5687             return false;</span>
<span class="line-added">5688         }</span>
<span class="line-added">5689         bytesRequired = checkedBytesRequired.unsafeGet();</span>
<span class="line-added">5690         break;</span>
<span class="line-added">5691     }</span>
5692     default:
<span class="line-modified">5693         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid format&quot;);</span>
5694         return false;
5695     }
5696 
5697     if (pixels.byteLength() != bytesRequired) {
<span class="line-modified">5698         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;length of ArrayBufferView is not correct for dimensions&quot;);</span>
5699         return false;
5700     }
5701 
5702     return true;
5703 }
5704 
<span class="line-modified">5705 bool WebGLRenderingContextBase::validateCompressedTexDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLsizei width, GCGLsizei height, GCGLenum format)</span>
5706 {
5707     switch (format) {
<span class="line-modified">5708     case ExtensionsGL::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="line-modified">5709     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="line-modified">5710     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="line-modified">5711     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT5_EXT: {</span>
<span class="line-modified">5712         const GCGLsizei kBlockWidth = 4;</span>
<span class="line-modified">5713         const GCGLsizei kBlockHeight = 4;</span>
<span class="line-modified">5714         const GCGLint maxTextureSize = target ? m_maxTextureSize : m_maxCubeMapTextureSize;</span>
<span class="line-modified">5715         const GCGLsizei maxCompressedDimension = maxTextureSize &gt;&gt; level;</span>
5716         bool widthValid = (level &amp;&amp; width == 1) || (level &amp;&amp; width == 2) || (!(width % kBlockWidth) &amp;&amp; width &lt;= maxCompressedDimension);
5717         bool heightValid = (level &amp;&amp; height == 1) || (level &amp;&amp; height == 2) || (!(height % kBlockHeight) &amp;&amp; height &lt;= maxCompressedDimension);
5718         if (!widthValid || !heightValid) {
<span class="line-modified">5719             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);</span>
5720             return false;
5721         }
5722         return true;
5723     }
<span class="line-modified">5724     case ExtensionsGL::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5725     case ExtensionsGL::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="line-modified">5726     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5727     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:</span>
5728         // Height and width must be powers of 2.
5729         if ((width &amp; (width - 1)) || (height &amp; (height - 1))) {
<span class="line-modified">5730             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);</span>
5731             return false;
5732         }
5733         return true;
<span class="line-modified">5734     case ExtensionsGL::COMPRESSED_RGBA_ASTC_4x4_KHR:</span>
<span class="line-modified">5735     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x4_KHR:</span>
<span class="line-modified">5736     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x5_KHR:</span>
<span class="line-modified">5737     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x5_KHR:</span>
<span class="line-modified">5738     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x6_KHR:</span>
<span class="line-modified">5739     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x5_KHR:</span>
<span class="line-modified">5740     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x6_KHR:</span>
<span class="line-modified">5741     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x8_KHR:</span>
<span class="line-modified">5742     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x5_KHR:</span>
<span class="line-modified">5743     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x6_KHR:</span>
<span class="line-modified">5744     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x8_KHR:</span>
<span class="line-modified">5745     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x10_KHR:</span>
<span class="line-modified">5746     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x10_KHR:</span>
<span class="line-modified">5747     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x12_KHR:</span>
<span class="line-modified">5748     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:</span>
<span class="line-modified">5749     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:</span>
<span class="line-modified">5750     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:</span>
<span class="line-modified">5751     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:</span>
<span class="line-modified">5752     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:</span>
<span class="line-modified">5753     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:</span>
<span class="line-modified">5754     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:</span>
<span class="line-modified">5755     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:</span>
<span class="line-modified">5756     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:</span>
<span class="line-modified">5757     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:</span>
<span class="line-modified">5758     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:</span>
<span class="line-modified">5759     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:</span>
<span class="line-modified">5760     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:</span>
<span class="line-modified">5761     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:</span>
<span class="line-modified">5762     case ExtensionsGL::ETC1_RGB8_OES:</span>
<span class="line-added">5763     case ExtensionsGL::COMPRESSED_R11_EAC:</span>
<span class="line-added">5764     case ExtensionsGL::COMPRESSED_SIGNED_R11_EAC:</span>
<span class="line-added">5765     case ExtensionsGL::COMPRESSED_RG11_EAC:</span>
<span class="line-added">5766     case ExtensionsGL::COMPRESSED_SIGNED_RG11_EAC:</span>
<span class="line-added">5767     case ExtensionsGL::COMPRESSED_RGB8_ETC2:</span>
<span class="line-added">5768     case ExtensionsGL::COMPRESSED_SRGB8_ETC2:</span>
<span class="line-added">5769     case ExtensionsGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-added">5770     case ExtensionsGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-added">5771     case ExtensionsGL::COMPRESSED_RGBA8_ETC2_EAC:</span>
<span class="line-added">5772     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:</span>
<span class="line-added">5773         // No height and width restrictions on ASTC, ETC1 or ETC2.</span>
5774         return true;
5775     default:
5776         return false;
5777     }
5778 }
5779 
<span class="line-modified">5780 bool WebGLRenderingContextBase::validateCompressedTexSubDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, WebGLTexture* tex)</span>

5781 {
5782     if (xoffset &lt; 0 || yoffset &lt; 0) {
<span class="line-modified">5783         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;xoffset or yoffset &lt; 0&quot;);</span>
<span class="line-modified">5784         return false;</span>
5785     }
5786 
5787     switch (format) {
<span class="line-modified">5788     case ExtensionsGL::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="line-modified">5789     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="line-modified">5790     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="line-modified">5791     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT5_EXT: {</span>
5792         const int kBlockWidth = 4;
5793         const int kBlockHeight = 4;
5794         if ((xoffset % kBlockWidth) || (yoffset % kBlockHeight)) {
<span class="line-modified">5795             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;xoffset or yoffset not multiple of 4&quot;);</span>
5796             return false;
5797         }
5798         if (width - xoffset &gt; tex-&gt;getWidth(target, level)
5799             || height - yoffset &gt; tex-&gt;getHeight(target, level)) {
<span class="line-modified">5800             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;dimensions out of range&quot;);</span>
5801             return false;
5802         }
5803         return validateCompressedTexDimensions(functionName, target, level, width, height, format);
5804     }
<span class="line-modified">5805     case ExtensionsGL::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5806     case ExtensionsGL::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="line-modified">5807     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
<span class="line-modified">5808     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: {</span>
5809         if (xoffset || yoffset) {
<span class="line-modified">5810             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;xoffset and yoffset must be zero&quot;);</span>
5811             return false;
5812         }
5813         if (width != tex-&gt;getWidth(target, level)
5814             || height != tex-&gt;getHeight(target, level)) {
<span class="line-modified">5815             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;dimensions must match existing level&quot;);</span>
5816             return false;
5817         }
5818         return validateCompressedTexDimensions(functionName, target, level, width, height, format);
5819     }
<span class="line-added">5820     case ExtensionsGL::ETC1_RGB8_OES:</span>
<span class="line-added">5821         // Not supported for ETC1_RGB8_OES textures.</span>
<span class="line-added">5822         return false;</span>
<span class="line-added">5823     case ExtensionsGL::COMPRESSED_R11_EAC:</span>
<span class="line-added">5824     case ExtensionsGL::COMPRESSED_SIGNED_R11_EAC:</span>
<span class="line-added">5825     case ExtensionsGL::COMPRESSED_RG11_EAC:</span>
<span class="line-added">5826     case ExtensionsGL::COMPRESSED_SIGNED_RG11_EAC:</span>
<span class="line-added">5827     case ExtensionsGL::COMPRESSED_RGB8_ETC2:</span>
<span class="line-added">5828     case ExtensionsGL::COMPRESSED_SRGB8_ETC2:</span>
<span class="line-added">5829     case ExtensionsGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-added">5830     case ExtensionsGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="line-added">5831     case ExtensionsGL::COMPRESSED_RGBA8_ETC2_EAC:</span>
<span class="line-added">5832     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: {</span>
<span class="line-added">5833         if (target == GraphicsContextGL::TEXTURE_3D) {</span>
<span class="line-added">5834             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;not supported on TEXTURE_3D textures&quot;);</span>
<span class="line-added">5835             return false;</span>
<span class="line-added">5836         }</span>
<span class="line-added">5837         const int kBlockSize = 4;</span>
<span class="line-added">5838         int texWidth = tex-&gt;getWidth(target, level);</span>
<span class="line-added">5839         int texHeight = tex-&gt;getHeight(target, level);</span>
<span class="line-added">5840         if ((xoffset % kBlockSize) || (yoffset % kBlockSize)</span>
<span class="line-added">5841             || ((width % kBlockSize) &amp;&amp; xoffset + width != texWidth)</span>
<span class="line-added">5842             || ((height % kBlockSize) &amp;&amp; yoffset + height != texHeight)) {</span>
<span class="line-added">5843             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;dimensions must match existing texture level dimensions&quot;);</span>
<span class="line-added">5844             return false;</span>
<span class="line-added">5845         }</span>
<span class="line-added">5846         return true;</span>
<span class="line-added">5847     }</span>
5848     default:
5849         return false;
5850     }
5851 }
5852 
<span class="line-modified">5853 bool WebGLRenderingContextBase::validateDrawMode(const char* functionName, GCGLenum mode)</span>
5854 {
5855     switch (mode) {
<span class="line-modified">5856     case GraphicsContextGL::POINTS:</span>
<span class="line-modified">5857     case GraphicsContextGL::LINE_STRIP:</span>
<span class="line-modified">5858     case GraphicsContextGL::LINE_LOOP:</span>
<span class="line-modified">5859     case GraphicsContextGL::LINES:</span>
<span class="line-modified">5860     case GraphicsContextGL::TRIANGLE_STRIP:</span>
<span class="line-modified">5861     case GraphicsContextGL::TRIANGLE_FAN:</span>
<span class="line-modified">5862     case GraphicsContextGL::TRIANGLES:</span>
5863         return true;
5864     default:
<span class="line-modified">5865         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid draw mode&quot;);</span>
5866         return false;
5867     }
5868 }
5869 
5870 bool WebGLRenderingContextBase::validateStencilSettings(const char* functionName)
5871 {
5872     if (m_stencilMask != m_stencilMaskBack || m_stencilFuncRef != m_stencilFuncRefBack || m_stencilFuncMask != m_stencilFuncMaskBack) {
<span class="line-modified">5873         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;front and back stencils settings do not match&quot;);</span>
5874         return false;
5875     }
5876     return true;
5877 }
5878 
<span class="line-modified">5879 bool WebGLRenderingContextBase::validateStencilFunc(const char* functionName, GCGLenum func)</span>
5880 {
5881     switch (func) {
<span class="line-modified">5882     case GraphicsContextGL::NEVER:</span>
<span class="line-modified">5883     case GraphicsContextGL::LESS:</span>
<span class="line-modified">5884     case GraphicsContextGL::LEQUAL:</span>
<span class="line-modified">5885     case GraphicsContextGL::GREATER:</span>
<span class="line-modified">5886     case GraphicsContextGL::GEQUAL:</span>
<span class="line-modified">5887     case GraphicsContextGL::EQUAL:</span>
<span class="line-modified">5888     case GraphicsContextGL::NOTEQUAL:</span>
<span class="line-modified">5889     case GraphicsContextGL::ALWAYS:</span>
5890         return true;
5891     default:
<span class="line-modified">5892         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid function&quot;);</span>
5893         return false;
5894     }
5895 }
5896 
5897 void WebGLRenderingContextBase::printToConsole(MessageLevel level, const String&amp; message)
5898 {
5899     if (!m_synthesizedErrorsToConsole || !m_numGLErrorsToConsoleAllowed)
5900         return;
5901 
5902     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; consoleMessage;
5903 
5904     // Error messages can occur during function calls, so show stack traces for them.
5905     if (level == MessageLevel::Error) {
5906         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
5907         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message, WTFMove(stackTrace));
5908     } else
5909         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message);
5910 
5911     auto* canvas = htmlCanvas();
5912     if (canvas)
5913         canvas-&gt;document().addConsoleMessage(WTFMove(consoleMessage));
5914 
5915     --m_numGLErrorsToConsoleAllowed;
5916     if (!m_numGLErrorsToConsoleAllowed)
5917         printToConsole(MessageLevel::Warning, &quot;WebGL: too many errors, no more errors will be reported to the console for this context.&quot;);
5918 }
5919 
<span class="line-modified">5920 bool WebGLRenderingContextBase::validateBlendFuncFactors(const char* functionName, GCGLenum src, GCGLenum dst)</span>
5921 {
<span class="line-modified">5922     if (((src == GraphicsContextGL::CONSTANT_COLOR || src == GraphicsContextGL::ONE_MINUS_CONSTANT_COLOR)</span>
<span class="line-modified">5923         &amp;&amp; (dst == GraphicsContextGL::CONSTANT_ALPHA || dst == GraphicsContextGL::ONE_MINUS_CONSTANT_ALPHA))</span>
<span class="line-modified">5924         || ((dst == GraphicsContextGL::CONSTANT_COLOR || dst == GraphicsContextGL::ONE_MINUS_CONSTANT_COLOR)</span>
<span class="line-modified">5925             &amp;&amp; (src == GraphicsContextGL::CONSTANT_ALPHA || src == GraphicsContextGL::ONE_MINUS_CONSTANT_ALPHA))) {</span>
<span class="line-modified">5926         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;incompatible src and dst&quot;);</span>
5927         return false;
5928     }
5929     return true;
5930 }
5931 
<span class="line-modified">5932 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Float32List&amp; v, GCGLsizei requiredMinSize)</span>
5933 {
5934     return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
5935 }
5936 
<span class="line-modified">5937 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Int32List&amp; v, GCGLsizei requiredMinSize)</span>
5938 {
5939     return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
5940 }
5941 
<span class="line-modified">5942 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, void* v, GCGLsizei size, GCGLsizei requiredMinSize)</span>
5943 {
5944     return validateUniformMatrixParameters(functionName, location, false, v, size, requiredMinSize);
5945 }
5946 
<span class="line-modified">5947 bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GCGLboolean transpose, const Float32List&amp; v, GCGLsizei requiredMinSize)</span>
5948 {
5949     return validateUniformMatrixParameters(functionName, location, transpose, v.data(), v.length(), requiredMinSize);
5950 }
5951 
<span class="line-modified">5952 bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GCGLboolean transpose, const void* v, GCGLsizei size, GCGLsizei requiredMinSize)</span>
5953 {
5954     if (!location)
5955         return false;
5956     if (location-&gt;program() != m_currentProgram) {
<span class="line-modified">5957         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;location is not from current program&quot;);</span>
5958         return false;
5959     }
5960     if (!v) {
<span class="line-modified">5961         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no array&quot;);</span>
5962         return false;
5963     }
5964     if (transpose) {
<span class="line-modified">5965         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;transpose not FALSE&quot;);</span>
5966         return false;
5967     }
5968     if (size &lt; requiredMinSize || (size % requiredMinSize)) {
<span class="line-modified">5969         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;invalid size&quot;);</span>
5970         return false;
5971     }
5972     return true;
5973 }
5974 
<span class="line-modified">5975 WebGLBuffer* WebGLRenderingContextBase::validateBufferDataParameters(const char* functionName, GCGLenum target, GCGLenum usage)</span>
5976 {
5977     Optional&lt;WebGLBuffer*&gt; buffer;
5978     switch (target) {
<span class="line-modified">5979     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:</span>
5980         buffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
5981         break;
<span class="line-modified">5982     case GraphicsContextGL::ARRAY_BUFFER:</span>
5983         buffer = m_boundArrayBuffer.get();
5984         break;
5985     default:
5986 #if ENABLE(WEBGL2)
5987         if (isWebGL2()) {
5988             switch (target) {
<span class="line-modified">5989             case GraphicsContextGL::COPY_READ_BUFFER:</span>
5990                 buffer = m_boundCopyReadBuffer.get();
5991                 break;
<span class="line-modified">5992             case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
5993                 buffer = m_boundCopyWriteBuffer.get();
5994                 break;
<span class="line-modified">5995             case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
5996                 buffer = m_boundPixelPackBuffer.get();
5997                 break;
<span class="line-modified">5998             case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
5999                 buffer = m_boundPixelUnpackBuffer.get();
6000                 break;
<span class="line-modified">6001             case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
6002                 buffer = m_boundTransformFeedbackBuffer.get();
6003                 break;
<span class="line-modified">6004             case GraphicsContextGL::UNIFORM_BUFFER:</span>
6005                 buffer = m_boundUniformBuffer.get();
6006                 break;
6007             }
6008             if (buffer)
6009                 break;
6010         }
6011 #endif
<span class="line-modified">6012         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
6013         return nullptr;
6014     }
6015     if (!buffer || !buffer.value()) {
<span class="line-modified">6016         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;no buffer&quot;);</span>
6017         return nullptr;
6018     }
6019     switch (usage) {
<span class="line-modified">6020     case GraphicsContextGL::STREAM_DRAW:</span>
<span class="line-modified">6021     case GraphicsContextGL::STATIC_DRAW:</span>
<span class="line-modified">6022     case GraphicsContextGL::DYNAMIC_DRAW:</span>
6023         return buffer.value();
6024     }
<span class="line-modified">6025     synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid usage&quot;);</span>
6026     return nullptr;
6027 }
6028 
6029 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLImageElement(const char* functionName, HTMLImageElement* image)
6030 {
6031     if (!image || !image-&gt;cachedImage()) {
<span class="line-modified">6032         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no image&quot;);</span>
6033         return false;
6034     }
6035     const URL&amp; url = image-&gt;cachedImage()-&gt;response().url();
6036     if (url.isNull() || url.isEmpty() || !url.isValid()) {
<span class="line-modified">6037         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;invalid image&quot;);</span>
6038         return false;
6039     }
6040     if (wouldTaintOrigin(image))
6041         return Exception { SecurityError };
6042     return true;
6043 }
6044 
6045 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement* canvas)
6046 {
6047     if (!canvas || !canvas-&gt;buffer()) {
<span class="line-modified">6048         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no canvas&quot;);</span>
6049         return false;
6050     }
6051     if (wouldTaintOrigin(canvas))
6052         return Exception { SecurityError };
6053     return true;
6054 }
6055 
6056 #if ENABLE(VIDEO)
6057 
6058 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLVideoElement(const char* functionName, HTMLVideoElement* video)
6059 {
6060     if (!video || !video-&gt;videoWidth() || !video-&gt;videoHeight()) {
<span class="line-modified">6061         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no video&quot;);</span>
6062         return false;
6063     }
6064     if (wouldTaintOrigin(video))
6065         return Exception { SecurityError };
6066     return true;
6067 }
6068 
6069 #endif
6070 
<span class="line-modified">6071 void WebGLRenderingContextBase::vertexAttribfImpl(const char* functionName, GCGLuint index, GCGLsizei expectedSize, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2, GCGLfloat v3)</span>
6072 {
6073     if (isContextLostOrPending())
6074         return;
6075     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">6076         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;index out of range&quot;);</span>
6077         return;
6078     }
6079     // In GL, we skip setting vertexAttrib0 values.
6080     if (index || isGLES2Compliant()) {
6081         switch (expectedSize) {
6082         case 1:
6083             m_context-&gt;vertexAttrib1f(index, v0);
6084             break;
6085         case 2:
6086             m_context-&gt;vertexAttrib2f(index, v0, v1);
6087             break;
6088         case 3:
6089             m_context-&gt;vertexAttrib3f(index, v0, v1, v2);
6090             break;
6091         case 4:
6092             m_context-&gt;vertexAttrib4f(index, v0, v1, v2, v3);
6093             break;
6094         }
6095     }
6096     VertexAttribValue&amp; attribValue = m_vertexAttribValue[index];
6097     attribValue.value[0] = v0;
6098     attribValue.value[1] = v1;
6099     attribValue.value[2] = v2;
6100     attribValue.value[3] = v3;
6101 }
6102 
<span class="line-modified">6103 void WebGLRenderingContextBase::vertexAttribfvImpl(const char* functionName, GCGLuint index, Float32List&amp;&amp; list, GCGLsizei expectedSize)</span>
6104 {
6105     if (isContextLostOrPending())
6106         return;
6107 
6108     auto data = list.data();
6109     if (!data) {
<span class="line-modified">6110         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no array&quot;);</span>
6111         return;
6112     }
6113 
6114     int size = list.length();
6115     if (size &lt; expectedSize) {
<span class="line-modified">6116         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;invalid size&quot;);</span>
6117         return;
6118     }
6119     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">6120         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;index out of range&quot;);</span>
6121         return;
6122     }
6123     // In GL, we skip setting vertexAttrib0 values.
6124     if (index || isGLES2Compliant()) {
6125         switch (expectedSize) {
6126         case 1:
6127             m_context-&gt;vertexAttrib1fv(index, data);
6128             break;
6129         case 2:
6130             m_context-&gt;vertexAttrib2fv(index, data);
6131             break;
6132         case 3:
6133             m_context-&gt;vertexAttrib3fv(index, data);
6134             break;
6135         case 4:
6136             m_context-&gt;vertexAttrib4fv(index, data);
6137             break;
6138         }
6139     }
6140     VertexAttribValue&amp; attribValue = m_vertexAttribValue[index];
6141     attribValue.initValue();
6142     for (int ii = 0; ii &lt; expectedSize; ++ii)
6143         attribValue.value[ii] = data[ii];
6144 }
6145 
6146 void WebGLRenderingContextBase::initVertexAttrib0()
6147 {
6148     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6149 
6150     m_vertexAttrib0Buffer = createBuffer();
<span class="line-modified">6151     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());</span>
<span class="line-modified">6152     m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, 0, GraphicsContextGL::DYNAMIC_DRAW);</span>
<span class="line-modified">6153     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContextGL::FLOAT, false, 0, 0);</span>
6154     state.bufferBinding = m_vertexAttrib0Buffer;
<span class="line-modified">6155     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, 0);</span>
6156     m_context-&gt;enableVertexAttribArray(0);
6157     m_vertexAttrib0BufferSize = 0;
6158     m_vertexAttrib0BufferValue[0] = 0.0f;
6159     m_vertexAttrib0BufferValue[1] = 0.0f;
6160     m_vertexAttrib0BufferValue[2] = 0.0f;
6161     m_vertexAttrib0BufferValue[3] = 1.0f;
6162     m_forceAttrib0BufferRefill = false;
6163     m_vertexAttrib0UsedBefore = false;
6164 }
6165 
<span class="line-modified">6166 bool WebGLRenderingContextBase::validateSimulatedVertexAttrib0(GCGLuint numVertex)</span>
6167 {
6168     if (!m_currentProgram)
6169         return true;
6170 
6171     bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
6172     if (!usingVertexAttrib0)
6173         return true;
6174 
6175     auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6176     if (state.enabled)
6177         return true;
6178 
<span class="line-modified">6179     auto bufferSize = checkedAddAndMultiply&lt;GCGLuint&gt;(numVertex, 1, 4);</span>
6180     if (!bufferSize)
6181         return false;
6182 
<span class="line-modified">6183     Checked&lt;GCGLsizeiptr, RecordOverflow&gt; bufferDataSize(bufferSize.value());</span>
<span class="line-modified">6184     bufferDataSize *= Checked&lt;GCGLsizeiptr&gt;(sizeof(GCGLfloat));</span>
6185     return !bufferDataSize.hasOverflowed() &amp;&amp; bufferDataSize.unsafeGet() &gt; 0;
6186 }
6187 
<span class="line-modified">6188 Optional&lt;bool&gt; WebGLRenderingContextBase::simulateVertexAttrib0(GCGLuint numVertex)</span>
6189 {
6190     if (!m_currentProgram)
6191         return false;
6192     bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
6193     if (usingVertexAttrib0)
6194         m_vertexAttrib0UsedBefore = true;
6195 
6196     auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6197     if (state.enabled &amp;&amp; usingVertexAttrib0)
6198         return false;
6199     if (!usingVertexAttrib0 &amp;&amp; !m_vertexAttrib0UsedBefore)
6200         return false;
6201     m_vertexAttrib0UsedBefore = true;
<span class="line-modified">6202     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());</span>
6203 
6204     // We know bufferSize and bufferDataSize won&#39;t overflow or go negative, thanks to validateSimulatedVertexAttrib0
<span class="line-modified">6205     GCGLuint bufferSize = (numVertex + 1) * 4;</span>
<span class="line-modified">6206     GCGLsizeiptr bufferDataSize = bufferSize * sizeof(GCGLfloat);</span>
6207 
6208     if (bufferDataSize &gt; m_vertexAttrib0BufferSize) {
6209         m_context-&gt;moveErrorsToSyntheticErrorList();
<span class="line-modified">6210         m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, bufferDataSize, 0, GraphicsContextGL::DYNAMIC_DRAW);</span>
<span class="line-modified">6211         if (m_context-&gt;getError() != GraphicsContextGL::NO_ERROR) {</span>
6212             // We were unable to create a buffer.
6213             m_vertexAttrib0UsedBefore = false;
6214             m_vertexAttrib0BufferSize = 0;
6215             m_forceAttrib0BufferRefill = true;
6216             return WTF::nullopt;
6217         }
6218         m_vertexAttrib0BufferSize = bufferDataSize;
6219         m_forceAttrib0BufferRefill = true;
6220     }
6221 
6222     auto&amp; attribValue = m_vertexAttribValue[0];
6223 
6224     if (usingVertexAttrib0
6225         &amp;&amp; (m_forceAttrib0BufferRefill
6226             || attribValue.value[0] != m_vertexAttrib0BufferValue[0]
6227             || attribValue.value[1] != m_vertexAttrib0BufferValue[1]
6228             || attribValue.value[2] != m_vertexAttrib0BufferValue[2]
6229             || attribValue.value[3] != m_vertexAttrib0BufferValue[3])) {
6230 
<span class="line-modified">6231         auto bufferData = makeUniqueArray&lt;GCGLfloat&gt;(bufferSize);</span>
<span class="line-modified">6232         for (GCGLuint ii = 0; ii &lt; numVertex + 1; ++ii) {</span>
6233             bufferData[ii * 4] = attribValue.value[0];
6234             bufferData[ii * 4 + 1] = attribValue.value[1];
6235             bufferData[ii * 4 + 2] = attribValue.value[2];
6236             bufferData[ii * 4 + 3] = attribValue.value[3];
6237         }
6238         m_vertexAttrib0BufferValue[0] = attribValue.value[0];
6239         m_vertexAttrib0BufferValue[1] = attribValue.value[1];
6240         m_vertexAttrib0BufferValue[2] = attribValue.value[2];
6241         m_vertexAttrib0BufferValue[3] = attribValue.value[3];
6242         m_forceAttrib0BufferRefill = false;
<span class="line-modified">6243         m_context-&gt;bufferSubData(GraphicsContextGL::ARRAY_BUFFER, 0, bufferDataSize, bufferData.get());</span>
6244     }
<span class="line-modified">6245     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContextGL::FLOAT, 0, 0, 0);</span>
6246     return true;
6247 }
6248 
6249 void WebGLRenderingContextBase::restoreStatesAfterVertexAttrib0Simulation()
6250 {
6251     const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6252     if (state.bufferBinding != m_vertexAttrib0Buffer) {
<span class="line-modified">6253         m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, objectOrZero(state.bufferBinding.get()));</span>
6254         m_context-&gt;vertexAttribPointer(0, state.size, state.type, state.normalized, state.originalStride, state.offset);
6255     }
<span class="line-modified">6256     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, objectOrZero(m_boundArrayBuffer.get()));</span>
6257 }
6258 
6259 void WebGLRenderingContextBase::dispatchContextLostEvent()
6260 {
<span class="line-added">6261     RELEASE_ASSERT(!m_isSuspended);</span>
6262     auto* canvas = htmlCanvas();
6263     if (!canvas)
6264         return;
6265 
6266     Ref&lt;WebGLContextEvent&gt; event = WebGLContextEvent::create(eventNames().webglcontextlostEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString());
6267     canvas-&gt;dispatchEvent(event);
6268     m_restoreAllowed = event-&gt;defaultPrevented();
6269     if (m_contextLostMode == RealLostContext &amp;&amp; m_restoreAllowed)
6270         m_restoreTimer.startOneShot(0_s);
6271 }
6272 
6273 void WebGLRenderingContextBase::maybeRestoreContext()
6274 {
<span class="line-added">6275     RELEASE_ASSERT(!m_isSuspended);</span>
6276     ASSERT(m_contextLost);
6277     if (!m_contextLost)
6278         return;
6279 
6280     // The rendering context is not restored unless the default behavior of the
6281     // webglcontextlost event was prevented earlier.
6282     //
6283     // Because of the way m_restoreTimer is set up for real vs. synthetic lost
6284     // context events, we don&#39;t have to worry about this test short-circuiting
6285     // the retry loop for real context lost events.
6286     if (!m_restoreAllowed)
6287         return;
6288 
6289     int contextLostReason = m_context-&gt;getExtensions().getGraphicsResetStatusARB();
6290 
6291     switch (contextLostReason) {
<span class="line-modified">6292     case GraphicsContextGL::NO_ERROR:</span>
<span class="line-modified">6293         // The GraphicsContextGLOpenGL implementation might not fully</span>
6294         // support GL_ARB_robustness semantics yet. Alternatively, the
6295         // WEBGL_lose_context extension might have been used to force
6296         // a lost context.
6297         break;
<span class="line-modified">6298     case ExtensionsGL::GUILTY_CONTEXT_RESET_ARB:</span>
6299         // The rendering context is not restored if this context was
6300         // guilty of causing the graphics reset.
6301         printToConsole(MessageLevel::Warning, &quot;WARNING: WebGL content on the page caused the graphics card to reset; not restoring the context&quot;);
6302         return;
<span class="line-modified">6303     case ExtensionsGL::INNOCENT_CONTEXT_RESET_ARB:</span>
6304         // Always allow the context to be restored.
6305         break;
<span class="line-modified">6306     case ExtensionsGL::UNKNOWN_CONTEXT_RESET_ARB:</span>
6307         // Warn. Ideally, prompt the user telling them that WebGL
6308         // content on the page might have caused the graphics card to
6309         // reset and ask them whether they want to continue running
6310         // the content. Only if they say &quot;yes&quot; should we start
6311         // attempting to restore the context.
6312         printToConsole(MessageLevel::Warning, &quot;WARNING: WebGL content on the page might have caused the graphics card to reset&quot;);
6313         break;
6314     }
6315 
6316     auto* canvas = htmlCanvas();
6317     if (!canvas)
6318         return;
6319 
6320     RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame();
6321     if (!frame)
6322         return;
6323 
6324     if (!frame-&gt;loader().client().allowWebGL(frame-&gt;settings().webGLEnabled()))
6325         return;
6326 
6327     RefPtr&lt;FrameView&gt; view = frame-&gt;view();
6328     if (!view)
6329         return;
6330     RefPtr&lt;ScrollView&gt; root = view-&gt;root();
6331     if (!root)
6332         return;
6333     HostWindow* hostWindow = root-&gt;hostWindow();
6334     if (!hostWindow)
6335         return;
6336 
<span class="line-modified">6337     RefPtr&lt;GraphicsContextGLOpenGL&gt; context(GraphicsContextGLOpenGL::create(m_attributes, hostWindow));</span>
6338     if (!context) {
6339         if (m_contextLostMode == RealLostContext)
6340             m_restoreTimer.startOneShot(secondsBetweenRestoreAttempts);
6341         else
6342             // This likely shouldn&#39;t happen but is the best way to report it to the WebGL app.
<span class="line-modified">6343             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;&quot;, &quot;error restoring context&quot;);</span>
6344         return;
6345     }
6346 
6347     m_context = context;
6348     addActivityStateChangeObserverIfNecessary();
6349     m_contextLost = false;
6350     setupFlags();
6351     initializeNewContext();
6352     initializeVertexArrayObjects();
6353     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextrestoredEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
6354 }
6355 
6356 void WebGLRenderingContextBase::simulateContextChanged()
6357 {
6358     if (m_context)
6359         m_context-&gt;simulateContextChanged();
6360 }
6361 
6362 String WebGLRenderingContextBase::ensureNotNull(const String&amp; text) const
6363 {
</pre>
<hr />
<pre>
6369 WebGLRenderingContextBase::LRUImageBufferCache::LRUImageBufferCache(int capacity)
6370     : m_buffers(capacity)
6371 {
6372 }
6373 
6374 ImageBuffer* WebGLRenderingContextBase::LRUImageBufferCache::imageBuffer(const IntSize&amp; size)
6375 {
6376     size_t i;
6377     for (i = 0; i &lt; m_buffers.size(); ++i) {
6378         ImageBuffer* buf = m_buffers[i].get();
6379         if (!buf)
6380             break;
6381         if (buf-&gt;logicalSize() != size)
6382             continue;
6383         bubbleToFront(i);
6384         buf-&gt;context().clearRect(FloatRect({ }, FloatSize(size)));
6385         return buf;
6386     }
6387 
6388     // FIXME (149423): Should this ImageBuffer be unconditionally unaccelerated?
<span class="line-modified">6389     std::unique_ptr&lt;ImageBuffer&gt; temp = ImageBuffer::create(size, RenderingMode::Unaccelerated);</span>
6390     if (!temp)
6391         return nullptr;
6392     ASSERT(m_buffers.size() &gt; 0);
6393     i = std::min(m_buffers.size() - 1, i);
6394     m_buffers[i] = WTFMove(temp);
6395 
6396     ImageBuffer* buf = m_buffers[i].get();
6397     bubbleToFront(i);
6398     return buf;
6399 }
6400 
6401 void WebGLRenderingContextBase::LRUImageBufferCache::bubbleToFront(size_t idx)
6402 {
6403     for (size_t i = idx; i &gt; 0; --i)
6404         m_buffers[i].swap(m_buffers[i-1]);
6405 }
6406 
6407 namespace {
6408 
<span class="line-modified">6409     String GetErrorString(GCGLenum error)</span>
6410     {
6411         switch (error) {
<span class="line-modified">6412         case GraphicsContextGL::INVALID_ENUM:</span>
6413             return &quot;INVALID_ENUM&quot;_s;
<span class="line-modified">6414         case GraphicsContextGL::INVALID_VALUE:</span>
6415             return &quot;INVALID_VALUE&quot;_s;
<span class="line-modified">6416         case GraphicsContextGL::INVALID_OPERATION:</span>
6417             return &quot;INVALID_OPERATION&quot;_s;
<span class="line-modified">6418         case GraphicsContextGL::OUT_OF_MEMORY:</span>
6419             return &quot;OUT_OF_MEMORY&quot;_s;
<span class="line-modified">6420         case GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION:</span>
6421             return &quot;INVALID_FRAMEBUFFER_OPERATION&quot;_s;
<span class="line-modified">6422         case GraphicsContextGL::CONTEXT_LOST_WEBGL:</span>
6423             return &quot;CONTEXT_LOST_WEBGL&quot;_s;
6424         default:
6425             return makeString(&quot;WebGL ERROR(&quot;, hex(error, 4, Lowercase), &#39;)&#39;);
6426         }
6427     }
6428 
6429 } // namespace anonymous
6430 
<span class="line-modified">6431 void WebGLRenderingContextBase::synthesizeGLError(GCGLenum error, const char* functionName, const char* description, ConsoleDisplayPreference display)</span>
6432 {
6433     if (m_synthesizedErrorsToConsole &amp;&amp; display == DisplayInConsole) {
6434         String str = &quot;WebGL: &quot; + GetErrorString(error) +  &quot;: &quot; + String(functionName) + &quot;: &quot; + String(description);
6435         printToConsole(MessageLevel::Error, str);
6436     }
6437     m_context-&gt;synthesizeGLError(error);
6438 }
6439 
6440 void WebGLRenderingContextBase::applyStencilTest()
6441 {
6442     bool haveStencilBuffer = false;
6443 
6444     if (m_framebufferBinding)
6445         haveStencilBuffer = m_framebufferBinding-&gt;hasStencilBuffer();
6446     else {
6447         auto attributes = getContextAttributes();
6448         ASSERT(attributes);
6449         haveStencilBuffer = attributes-&gt;stencil;
6450     }
<span class="line-modified">6451     enableOrDisable(GraphicsContextGL::STENCIL_TEST, m_stencilEnabled &amp;&amp; haveStencilBuffer);</span>
6452 }
6453 
<span class="line-modified">6454 void WebGLRenderingContextBase::enableOrDisable(GCGLenum capability, bool enable)</span>
6455 {
6456     if (enable)
6457         m_context-&gt;enable(capability);
6458     else
6459         m_context-&gt;disable(capability);
6460 }
6461 
6462 IntSize WebGLRenderingContextBase::clampedCanvasSize()
6463 {
6464     return IntSize(clamp(canvasBase().width(), 1, m_maxViewportDims[0]),
6465         clamp(canvasBase().height(), 1, m_maxViewportDims[1]));
6466 }
6467 
<span class="line-modified">6468 GCGLint WebGLRenderingContextBase::getMaxDrawBuffers()</span>
6469 {
6470     if (!supportsDrawBuffers())
6471         return 0;
6472     if (!m_maxDrawBuffers)
<span class="line-modified">6473         m_context-&gt;getIntegerv(ExtensionsGL::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);</span>
6474     if (!m_maxColorAttachments)
<span class="line-modified">6475         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
6476     // WEBGL_draw_buffers requires MAX_COLOR_ATTACHMENTS &gt;= MAX_DRAW_BUFFERS.
6477     return std::min(m_maxDrawBuffers, m_maxColorAttachments);
6478 }
6479 
<span class="line-modified">6480 GCGLint WebGLRenderingContextBase::getMaxColorAttachments()</span>
6481 {
6482     if (!supportsDrawBuffers())
6483         return 0;
6484     if (!m_maxColorAttachments)
<span class="line-modified">6485         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
6486     return m_maxColorAttachments;
6487 }
6488 
<span class="line-modified">6489 void WebGLRenderingContextBase::setBackDrawBuffer(GCGLenum buf)</span>
6490 {
6491     m_backDrawBuffer = buf;
6492 }
6493 
6494 void WebGLRenderingContextBase::restoreCurrentFramebuffer()
6495 {
<span class="line-modified">6496     bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_framebufferBinding.get());</span>
6497 }
6498 
6499 void WebGLRenderingContextBase::restoreCurrentTexture2D()
6500 {
6501     auto texture = m_textureUnits[m_activeTextureUnit].texture2DBinding.get();
<span class="line-modified">6502     bindTexture(GraphicsContextGL::TEXTURE_2D, texture);</span>
6503     if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
6504         m_unrenderableTextureUnits.add(m_activeTextureUnit);
6505 }
6506 
6507 bool WebGLRenderingContextBase::supportsDrawBuffers()
6508 {
6509     if (!m_drawBuffersWebGLRequirementsChecked) {
6510         m_drawBuffersWebGLRequirementsChecked = true;
6511         m_drawBuffersSupported = WebGLDrawBuffers::supported(*this);
6512     }
6513     return m_drawBuffersSupported;
6514 }
6515 
<span class="line-modified">6516 void WebGLRenderingContextBase::drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount)</span>
6517 {
6518     if (!primcount) {
6519         markContextChanged();
6520         return;
6521     }
6522 
6523     if (!validateDrawArrays(&quot;drawArraysInstanced&quot;, mode, first, count, primcount))
6524         return;
6525 
6526     clearIfComposited();
6527 
6528     bool vertexAttrib0Simulated = false;
6529     if (!isGLES2Compliant()) {
6530         auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
6531         if (!simulateVertexAttrib0Status) {
6532             // We were unable to simulate the attribute buffer.
<span class="line-modified">6533             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
6534             return;
6535         }
6536         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
6537     }
6538     if (!isGLES2NPOTStrict())
6539         checkTextureCompleteness(&quot;drawArraysInstanced&quot;, true);
6540 
6541     m_context-&gt;drawArraysInstanced(mode, first, count, primcount);
6542 
6543     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
6544         restoreStatesAfterVertexAttrib0Simulation();
6545     if (!isGLES2NPOTStrict())
6546         checkTextureCompleteness(&quot;drawArraysInstanced&quot;, false);
6547     markContextChangedAndNotifyCanvasObserver();
6548 }
6549 
<span class="line-modified">6550 void WebGLRenderingContextBase::drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, GCGLsizei primcount)</span>
6551 {
6552     if (!primcount) {
6553         markContextChanged();
6554         return;
6555     }
6556 
6557     unsigned numElements = 0;
6558     if (!validateDrawElements(&quot;drawElementsInstanced&quot;, mode, count, type, offset, numElements, primcount))
6559         return;
6560 
6561     clearIfComposited();
6562 
6563     bool vertexAttrib0Simulated = false;
6564     if (!isGLES2Compliant()) {
6565         if (!numElements)
<span class="line-modified">6566             validateIndexArrayPrecise(count, type, static_cast&lt;GCGLintptr&gt;(offset), numElements);</span>
6567         auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
6568         if (!simulateVertexAttrib0Status) {
6569             // We were unable to simulate the attribute buffer.
<span class="line-modified">6570             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
6571             return;
6572         }
6573         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
6574     }
6575     if (!isGLES2NPOTStrict())
6576         checkTextureCompleteness(&quot;drawElementsInstanced&quot;, true);
6577 
6578 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
6579     if (isWebGL2())
6580         m_context-&gt;primitiveRestartIndex(getRestartIndex(type));
6581 #endif
6582 
<span class="line-modified">6583     m_context-&gt;drawElementsInstanced(mode, count, type, static_cast&lt;GCGLintptr&gt;(offset), primcount);</span>
6584 
6585     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
6586         restoreStatesAfterVertexAttrib0Simulation();
6587     if (!isGLES2NPOTStrict())
6588         checkTextureCompleteness(&quot;drawElementsInstanced&quot;, false);
6589     markContextChangedAndNotifyCanvasObserver();
6590 }
6591 
<span class="line-modified">6592 void WebGLRenderingContextBase::vertexAttribDivisor(GCGLuint index, GCGLuint divisor)</span>
6593 {
6594     if (isContextLostOrPending())
6595         return;
6596 
6597     if (index &gt;= m_maxVertexAttribs) {
<span class="line-modified">6598         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribDivisor&quot;, &quot;index out of range&quot;);</span>
6599         return;
6600     }
6601 
6602     m_boundVertexArrayObject-&gt;setVertexAttribDivisor(index, divisor);
6603     m_context-&gt;vertexAttribDivisor(index, divisor);
6604 }
6605 
6606 bool WebGLRenderingContextBase::enableSupportedExtension(ASCIILiteral extensionNameLiteral)
6607 {
6608     ASSERT(m_context);
6609     auto&amp; extensions = m_context-&gt;getExtensions();
6610     String extensionName { extensionNameLiteral };
6611     if (!extensions.supports(extensionName))
6612         return false;
6613     extensions.ensureEnabled(extensionName);
6614     return true;
6615 }
6616 
6617 void WebGLRenderingContextBase::activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState)
6618 {
</pre>
<hr />
<pre>
6632     m_context-&gt;setFailNextGPUStatusCheck();
6633 }
6634 
6635 void WebGLRenderingContextBase::didComposite()
6636 {
6637     if (UNLIKELY(callTracingActive()))
6638         InspectorInstrumentation::didFinishRecordingCanvasFrame(*this);
6639 }
6640 
6641 void WebGLRenderingContextBase::forceContextLost()
6642 {
6643     forceLostContext(WebGLRenderingContextBase::RealLostContext);
6644 }
6645 
6646 void WebGLRenderingContextBase::recycleContext()
6647 {
6648     printToConsole(MessageLevel::Error, &quot;There are too many active WebGL contexts on this page, the oldest context will be lost.&quot;);
6649     // Using SyntheticLostContext means the developer won&#39;t be able to force the restoration
6650     // of the context by calling preventDefault() in a &quot;webglcontextlost&quot; event handler.
6651     forceLostContext(SyntheticLostContext);
<span class="line-modified">6652     destroyGraphicsContextGL();</span>
6653 }
6654 
6655 void WebGLRenderingContextBase::dispatchContextChangedNotification()
6656 {
<span class="line-added">6657     if (!m_dispatchContextChangedEventTimer.isActive())</span>
<span class="line-added">6658         m_dispatchContextChangedEventTimer.startOneShot(0_s);</span>
<span class="line-added">6659 }</span>
<span class="line-added">6660 </span>
<span class="line-added">6661 void WebGLRenderingContextBase::dispatchContextChangedEvent()</span>
<span class="line-added">6662 {</span>
<span class="line-added">6663     RELEASE_ASSERT(!m_isSuspended);</span>
6664     auto* canvas = htmlCanvas();
6665     if (!canvas)
6666         return;
6667 
6668     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextchangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
6669 }
6670 
6671 
6672 } // namespace WebCore
6673 
6674 #endif // ENABLE(WEBGL)
</pre>
</td>
</tr>
</table>
<center><a href="WebGLRenderingContext.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContextBase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
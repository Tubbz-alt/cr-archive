<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/Seconds.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/MathExtras.h&gt;
 29 #include &lt;wtf/Optional.h&gt;
 30 
 31 namespace WTF {
 32 
 33 class MonotonicTime;
 34 class PrintStream;
<a name="1" id="anc1"></a><span class="line-added"> 35 class TextStream;</span>
 36 class TimeWithDynamicClockType;
 37 class WallTime;
 38 
 39 class Seconds final {
 40     WTF_MAKE_FAST_ALLOCATED;
 41 public:
 42     constexpr Seconds() { }
 43 
 44     explicit constexpr Seconds(double value)
 45         : m_value(value)
 46     {
 47     }
 48 
 49     constexpr double value() const { return m_value; }
 50 
 51     constexpr double minutes() const { return m_value / 60; }
 52     constexpr double seconds() const { return m_value; }
 53     constexpr double milliseconds() const { return seconds() * 1000; }
 54     constexpr double microseconds() const { return milliseconds() * 1000; }
 55     constexpr double nanoseconds() const { return microseconds() * 1000; }
 56 
 57     // Keep in mind that Seconds is held in double. If the value is not in range of 53bit integer, the result may not be precise.
 58     template&lt;typename T&gt; T minutesAs() const { static_assert(std::is_integral&lt;T&gt;::value, &quot;&quot;); return clampToAccepting64&lt;T&gt;(minutes()); }
 59     template&lt;typename T&gt; T secondsAs() const { static_assert(std::is_integral&lt;T&gt;::value, &quot;&quot;); return clampToAccepting64&lt;T&gt;(seconds()); }
 60     template&lt;typename T&gt; T millisecondsAs() const { static_assert(std::is_integral&lt;T&gt;::value, &quot;&quot;); return clampToAccepting64&lt;T&gt;(milliseconds()); }
 61     template&lt;typename T&gt; T microsecondsAs() const { static_assert(std::is_integral&lt;T&gt;::value, &quot;&quot;); return clampToAccepting64&lt;T&gt;(microseconds()); }
 62     template&lt;typename T&gt; T nanosecondsAs() const { static_assert(std::is_integral&lt;T&gt;::value, &quot;&quot;); return clampToAccepting64&lt;T&gt;(nanoseconds()); }
 63 
 64     static constexpr Seconds fromMinutes(double minutes)
 65     {
 66         return Seconds(minutes * 60);
 67     }
 68 
 69     static constexpr Seconds fromHours(double hours)
 70     {
 71         return Seconds(hours * 3600);
 72     }
 73 
 74     static constexpr Seconds fromMilliseconds(double milliseconds)
 75     {
 76         return Seconds(milliseconds / 1000);
 77     }
 78 
 79     static constexpr Seconds fromMicroseconds(double microseconds)
 80     {
 81         return fromMilliseconds(microseconds / 1000);
 82     }
 83 
 84     static constexpr Seconds fromNanoseconds(double nanoseconds)
 85     {
 86         return fromMicroseconds(nanoseconds / 1000);
 87     }
 88 
 89     static constexpr Seconds infinity()
 90     {
 91         return Seconds(std::numeric_limits&lt;double&gt;::infinity());
 92     }
 93 
 94     static constexpr Seconds nan()
 95     {
 96         return Seconds(std::numeric_limits&lt;double&gt;::quiet_NaN());
 97     }
 98 
 99     explicit constexpr operator bool() const { return !!m_value; }
100 
101     constexpr Seconds operator+(Seconds other) const
102     {
103         return Seconds(value() + other.value());
104     }
105 
106     constexpr Seconds operator-(Seconds other) const
107     {
108         return Seconds(value() - other.value());
109     }
110 
111     constexpr Seconds operator-() const
112     {
113         return Seconds(-value());
114     }
115 
116     // It makes sense to consider scaling a duration, like, &quot;I want to wait 5 times as long as
117     // last time!&quot;.
118     constexpr Seconds operator*(double scalar) const
119     {
120         return Seconds(value() * scalar);
121     }
122 
123     constexpr Seconds operator/(double scalar) const
124     {
125         return Seconds(value() / scalar);
126     }
127 
128     // It&#39;s reasonable to think about ratios between Seconds.
129     constexpr double operator/(Seconds other) const
130     {
131         return value() / other.value();
132     }
133 
134     Seconds operator%(double scalar) const
135     {
136         return Seconds(fmod(value(), scalar));
137     }
138 
139     // This solves for r, where:
140     //
141     //     floor(this / other) + r / other = this / other
142     //
143     // Therefore, if this is Seconds then r is Seconds.
144     Seconds operator%(Seconds other) const
145     {
146         return Seconds(fmod(value(), other.value()));
147     }
148 
149     Seconds&amp; operator+=(Seconds other)
150     {
151         return *this = *this + other;
152     }
153 
154     Seconds&amp; operator-=(Seconds other)
155     {
156         return *this = *this - other;
157     }
158 
159     Seconds&amp; operator*=(double scalar)
160     {
161         return *this = *this * scalar;
162     }
163 
164     Seconds&amp; operator/=(double scalar)
165     {
166         return *this = *this / scalar;
167     }
168 
169     Seconds&amp; operator%=(double scalar)
170     {
171         return *this = *this % scalar;
172     }
173 
174     Seconds&amp; operator%=(Seconds other)
175     {
176         return *this = *this % other;
177     }
178 
179     WTF_EXPORT_PRIVATE WallTime operator+(WallTime) const;
180     WTF_EXPORT_PRIVATE MonotonicTime operator+(MonotonicTime) const;
181     WTF_EXPORT_PRIVATE TimeWithDynamicClockType operator+(const TimeWithDynamicClockType&amp;) const;
182 
183     WTF_EXPORT_PRIVATE WallTime operator-(WallTime) const;
184     WTF_EXPORT_PRIVATE MonotonicTime operator-(MonotonicTime) const;
185     WTF_EXPORT_PRIVATE TimeWithDynamicClockType operator-(const TimeWithDynamicClockType&amp;) const;
186 
187     constexpr bool operator==(Seconds other) const
188     {
189         return m_value == other.m_value;
190     }
191 
192     constexpr bool operator!=(Seconds other) const
193     {
194         return m_value != other.m_value;
195     }
196 
197     constexpr bool operator&lt;(Seconds other) const
198     {
199         return m_value &lt; other.m_value;
200     }
201 
202     constexpr bool operator&gt;(Seconds other) const
203     {
204         return m_value &gt; other.m_value;
205     }
206 
207     constexpr bool operator&lt;=(Seconds other) const
208     {
209         return m_value &lt;= other.m_value;
210     }
211 
212     constexpr bool operator&gt;=(Seconds other) const
213     {
214         return m_value &gt;= other.m_value;
215     }
216 
217     WTF_EXPORT_PRIVATE void dump(PrintStream&amp;) const;
218 
219     Seconds isolatedCopy() const
220     {
221         return *this;
222     }
223 
224     template&lt;class Encoder&gt;
225     void encode(Encoder&amp; encoder) const
226     {
227         encoder &lt;&lt; m_value;
228     }
229 
230     template&lt;class Decoder&gt;
231     static Optional&lt;Seconds&gt; decode(Decoder&amp; decoder)
232     {
233         Optional&lt;double&gt; seconds;
234         decoder &gt;&gt; seconds;
235         if (!seconds)
236             return WTF::nullopt;
237         return Seconds(*seconds);
238     }
239 
240     template&lt;class Decoder&gt;
241     static bool decode(Decoder&amp; decoder, Seconds&amp; seconds)
242     {
243         double value;
244         if (!decoder.decode(value))
245             return false;
246 
247         seconds = Seconds(value);
248         return true;
249     }
250 
251     struct MarkableTraits;
252 
253 private:
254     double m_value { 0 };
255 };
256 
257 WTF_EXPORT_PRIVATE void sleep(Seconds);
258 
259 struct Seconds::MarkableTraits {
260     static bool isEmptyValue(Seconds seconds)
261     {
262         return std::isnan(seconds.value());
263     }
264 
265     static constexpr Seconds emptyValue()
266     {
267         return Seconds::nan();
268     }
269 };
270 
271 inline namespace seconds_literals {
272 
273 constexpr Seconds operator&quot;&quot; _min(long double minutes)
274 {
275     return Seconds::fromMinutes(minutes);
276 }
277 
278 constexpr Seconds operator&quot;&quot; _h(long double hours)
279 {
280     return Seconds::fromHours(hours);
281 }
282 
283 constexpr Seconds operator&quot;&quot; _s(long double seconds)
284 {
285     return Seconds(seconds);
286 }
287 
288 constexpr Seconds operator&quot;&quot; _ms(long double milliseconds)
289 {
290     return Seconds::fromMilliseconds(milliseconds);
291 }
292 
293 constexpr Seconds operator&quot;&quot; _us(long double microseconds)
294 {
295     return Seconds::fromMicroseconds(microseconds);
296 }
297 
298 constexpr Seconds operator&quot;&quot; _ns(long double nanoseconds)
299 {
300     return Seconds::fromNanoseconds(nanoseconds);
301 }
302 
303 constexpr Seconds operator&quot;&quot; _min(unsigned long long minutes)
304 {
305     return Seconds::fromMinutes(minutes);
306 }
307 
308 constexpr Seconds operator&quot;&quot; _h(unsigned long long hours)
309 {
310     return Seconds::fromHours(hours);
311 }
312 
313 constexpr Seconds operator&quot;&quot; _s(unsigned long long seconds)
314 {
315     return Seconds(seconds);
316 }
317 
318 constexpr Seconds operator&quot;&quot; _ms(unsigned long long milliseconds)
319 {
320     return Seconds::fromMilliseconds(milliseconds);
321 }
322 
323 constexpr Seconds operator&quot;&quot; _us(unsigned long long microseconds)
324 {
325     return Seconds::fromMicroseconds(microseconds);
326 }
327 
328 constexpr Seconds operator&quot;&quot; _ns(unsigned long long nanoseconds)
329 {
330     return Seconds::fromNanoseconds(nanoseconds);
331 }
332 
333 } // inline seconds_literals
334 
<a name="2" id="anc2"></a><span class="line-added">335 WTF_EXPORT_PRIVATE TextStream&amp; operator&lt;&lt;(TextStream&amp;, Seconds);</span>
<span class="line-added">336 </span>
337 } // namespace WTF
338 
339 using WTF::sleep;
340 
341 namespace std {
342 
343 inline bool isnan(WTF::Seconds seconds)
344 {
345     return std::isnan(seconds.value());
346 }
347 
348 inline bool isinf(WTF::Seconds seconds)
349 {
350     return std::isinf(seconds.value());
351 }
352 
353 inline bool isfinite(WTF::Seconds seconds)
354 {
355     return std::isfinite(seconds.value());
356 }
357 
358 } // namespace std
359 
360 using namespace WTF::seconds_literals;
361 using WTF::Seconds;
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
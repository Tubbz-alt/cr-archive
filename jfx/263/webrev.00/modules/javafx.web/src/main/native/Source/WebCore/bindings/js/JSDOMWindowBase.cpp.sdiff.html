<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMPromiseDeferred.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMWindowBase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  *
  8  *  This library is free software; you can redistribute it and/or
  9  *  modify it under the terms of the GNU Lesser General Public
 10  *  License as published by the Free Software Foundation; either
 11  *  version 2 of the License, or (at your option) any later version.
 12  *
 13  *  This library is distributed in the hope that it will be useful,
 14  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  *  Lesser General Public License for more details.
 17  *
 18  *  You should have received a copy of the GNU Lesser General Public
 19  *  License along with this library; if not, write to the Free Software
 20  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 21  *  USA
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;JSDOMWindowBase.h&quot;
 26 
<span class="line-removed"> 27 #include &quot;ActiveDOMCallbackMicrotask.h&quot;</span>
 28 #include &quot;Chrome.h&quot;
 29 #include &quot;CommonVM.h&quot;
 30 #include &quot;DOMWindow.h&quot;
 31 #include &quot;Document.h&quot;

 32 #include &quot;FetchResponse.h&quot;
 33 #include &quot;Frame.h&quot;
 34 #include &quot;InspectorController.h&quot;
 35 #include &quot;JSDOMBindingSecurity.h&quot;
 36 #include &quot;JSDOMGlobalObjectTask.h&quot;
 37 #include &quot;JSDOMWindowCustom.h&quot;
 38 #include &quot;JSFetchResponse.h&quot;
 39 #include &quot;JSMicrotaskCallback.h&quot;
 40 #include &quot;JSNode.h&quot;
 41 #include &quot;Logging.h&quot;
 42 #include &quot;Page.h&quot;
 43 #include &quot;RejectedPromiseTracker.h&quot;
 44 #include &quot;RuntimeApplicationChecks.h&quot;
 45 #include &quot;ScriptController.h&quot;
 46 #include &quot;ScriptModuleLoader.h&quot;
 47 #include &quot;SecurityOrigin.h&quot;
 48 #include &quot;Settings.h&quot;
 49 #include &quot;WebCoreJSClientData.h&quot;
 50 #include &lt;JavaScriptCore/CodeBlock.h&gt;
 51 #include &lt;JavaScriptCore/JSInternalPromise.h&gt;
<span class="line-removed"> 52 #include &lt;JavaScriptCore/JSInternalPromiseDeferred.h&gt;</span>
 53 #include &lt;JavaScriptCore/JSWebAssembly.h&gt;
 54 #include &lt;JavaScriptCore/Microtask.h&gt;
<span class="line-modified"> 55 #include &lt;JavaScriptCore/PromiseDeferredTimer.h&gt;</span>
 56 #include &lt;JavaScriptCore/StrongInlines.h&gt;
 57 #include &lt;wtf/Language.h&gt;
 58 #include &lt;wtf/MainThread.h&gt;
 59 
 60 #if PLATFORM(IOS_FAMILY)
 61 #include &quot;ChromeClient.h&quot;
 62 #endif
 63 
 64 
 65 namespace WebCore {
 66 using namespace JSC;
 67 
 68 const ClassInfo JSDOMWindowBase::s_info = { &quot;Window&quot;, &amp;JSDOMGlobalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDOMWindowBase) };
 69 
 70 const GlobalObjectMethodTable JSDOMWindowBase::s_globalObjectMethodTable = {
 71     &amp;supportsRichSourceInfo,
 72     &amp;shouldInterruptScript,
 73     &amp;javaScriptRuntimeFlags,
<span class="line-modified"> 74     &amp;queueTaskToEventLoop,</span>
 75     &amp;shouldInterruptScriptBeforeTimeout,
 76     &amp;moduleLoaderImportModule,
 77     &amp;moduleLoaderResolve,
 78     &amp;moduleLoaderFetch,
 79     &amp;moduleLoaderCreateImportMetaProperties,
 80     &amp;moduleLoaderEvaluate,
 81     &amp;promiseRejectionTracker,
 82     &amp;defaultLanguage,
 83 #if ENABLE(WEBASSEMBLY)
 84     &amp;compileStreaming,
 85     &amp;instantiateStreaming,
 86 #else
 87     nullptr,
 88     nullptr,
 89 #endif
 90 };
 91 
 92 JSDOMWindowBase::JSDOMWindowBase(VM&amp; vm, Structure* structure, RefPtr&lt;DOMWindow&gt;&amp;&amp; window, JSWindowProxy* proxy)
 93     : JSDOMGlobalObject(vm, structure, proxy-&gt;world(), &amp;s_globalObjectMethodTable)
 94     , m_windowCloseWatchpoints((window &amp;&amp; window-&gt;frame()) ? IsWatched : IsInvalidated)
</pre>
<hr />
<pre>
109         GlobalPropertyInfo(builtinNames.windowPublicName(), m_proxy, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),
110     };
111 
112     addStaticGlobals(staticGlobals, WTF_ARRAY_LENGTH(staticGlobals));
113 
114     if (m_wrapped &amp;&amp; m_wrapped-&gt;frame() &amp;&amp; m_wrapped-&gt;frame()-&gt;settings().needsSiteSpecificQuirks())
115         setNeedsSiteSpecificQuirks(true);
116 }
117 
118 void JSDOMWindowBase::destroy(JSCell* cell)
119 {
120     static_cast&lt;JSDOMWindowBase*&gt;(cell)-&gt;JSDOMWindowBase::~JSDOMWindowBase();
121 }
122 
123 void JSDOMWindowBase::updateDocument()
124 {
125     // Since &quot;document&quot; property is defined as { configurable: false, writable: false, enumerable: true },
126     // users cannot change its attributes further.
127     // Reaching here, the attributes of &quot;document&quot; property should be never changed.
128     ASSERT(m_wrapped-&gt;document());
<span class="line-modified">129     ExecState* exec = globalExec();</span>
130     bool shouldThrowReadOnlyError = false;
131     bool ignoreReadOnlyErrors = true;
132     bool putResult = false;
<span class="line-modified">133     symbolTablePutTouchWatchpointSet(this, exec, static_cast&lt;JSVMClientData*&gt;(exec-&gt;vm().clientData)-&gt;builtinNames().documentPublicName(), toJS(exec, this, m_wrapped-&gt;document()), shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);</span>
134 }
135 
136 ScriptExecutionContext* JSDOMWindowBase::scriptExecutionContext() const
137 {
138     return m_wrapped-&gt;document();
139 }
140 
141 void JSDOMWindowBase::printErrorMessage(const String&amp; message) const
142 {
143     printErrorMessageForFrame(wrapped().frame(), message);
144 }
145 
146 bool JSDOMWindowBase::supportsRichSourceInfo(const JSGlobalObject* object)
147 {
148     const JSDOMWindowBase* thisObject = static_cast&lt;const JSDOMWindowBase*&gt;(object);
149     Frame* frame = thisObject-&gt;wrapped().frame();
150     if (!frame)
151         return false;
152 
153     Page* page = frame-&gt;page();
154     if (!page)
155         return false;
156 
157     bool enabled = page-&gt;inspectorController().enabled();
158     ASSERT(enabled || !thisObject-&gt;debugger());
159     return enabled;
160 }
161 
162 static inline bool shouldInterruptScriptToPreventInfiniteRecursionWhenClosingPage(Page* page)
163 {
164     // See &lt;rdar://problem/5479443&gt;. We don&#39;t think that page can ever be NULL
<span class="line-modified">165     // in this case, but if it is, we&#39;ve gotten into a state where we may have</span>
166     // hung the UI, with no way to ask the client whether to cancel execution.
167     // For now, our solution is just to cancel execution no matter what,
168     // ensuring that we never hang. We might want to consider other solutions
169     // if we discover problems with this one.
170     ASSERT(page);
171     return !page;
172 }
173 
174 bool JSDOMWindowBase::shouldInterruptScript(const JSGlobalObject* object)
175 {
176     const JSDOMWindowBase* thisObject = static_cast&lt;const JSDOMWindowBase*&gt;(object);
177     ASSERT(thisObject-&gt;wrapped().frame());
178     Page* page = thisObject-&gt;wrapped().frame()-&gt;page();
179     return shouldInterruptScriptToPreventInfiniteRecursionWhenClosingPage(page);
180 }
181 
182 bool JSDOMWindowBase::shouldInterruptScriptBeforeTimeout(const JSGlobalObject* object)
183 {
184     const JSDOMWindowBase* thisObject = static_cast&lt;const JSDOMWindowBase*&gt;(object);
185     ASSERT(thisObject-&gt;wrapped().frame());
</pre>
<hr />
<pre>
188     if (shouldInterruptScriptToPreventInfiniteRecursionWhenClosingPage(page))
189         return true;
190 
191 #if PLATFORM(IOS_FAMILY)
192     if (page-&gt;chrome().client().isStopping())
193         return true;
194 #endif
195 
196     return JSGlobalObject::shouldInterruptScriptBeforeTimeout(object);
197 }
198 
199 RuntimeFlags JSDOMWindowBase::javaScriptRuntimeFlags(const JSGlobalObject* object)
200 {
201     const JSDOMWindowBase* thisObject = static_cast&lt;const JSDOMWindowBase*&gt;(object);
202     Frame* frame = thisObject-&gt;wrapped().frame();
203     if (!frame)
204         return RuntimeFlags();
205     return frame-&gt;settings().javaScriptRuntimeFlags();
206 }
207 
<span class="line-modified">208 void JSDOMWindowBase::queueTaskToEventLoop(JSGlobalObject&amp; object, Ref&lt;JSC::Microtask&gt;&amp;&amp; task)</span>
209 {
210     JSDOMWindowBase&amp; thisObject = static_cast&lt;JSDOMWindowBase&amp;&gt;(object);
211 
212     auto callback = JSMicrotaskCallback::create(thisObject, WTFMove(task));
<span class="line-modified">213     auto microtask = makeUnique&lt;ActiveDOMCallbackMicrotask&gt;(MicrotaskQueue::mainThreadQueue(), *thisObject.scriptExecutionContext(), [callback = WTFMove(callback)]() mutable {</span>

214         callback-&gt;call();
215     });
<span class="line-removed">216 </span>
<span class="line-removed">217     MicrotaskQueue::mainThreadQueue().append(WTFMove(microtask));</span>
218 }
219 
220 void JSDOMWindowBase::willRemoveFromWindowProxy()
221 {
222     setCurrentEvent(0);
223 }
224 
225 JSWindowProxy* JSDOMWindowBase::proxy() const
226 {
227     return m_proxy;
228 }
229 
<span class="line-modified">230 JSValue toJS(ExecState* state, DOMWindow&amp; domWindow)</span>
231 {
232     auto* frame = domWindow.frame();
233     if (!frame)
234         return jsNull();
<span class="line-modified">235     return toJS(state, frame-&gt;windowProxy());</span>
236 }
237 
238 JSDOMWindow* toJSDOMWindow(Frame&amp; frame, DOMWrapperWorld&amp; world)
239 {
240     return frame.script().globalObject(world);
241 }
242 
243 JSDOMWindow* toJSDOMWindow(JSC::VM&amp; vm, JSValue value)
244 {
245     if (!value.isObject())
246         return nullptr;
247 
248     while (!value.isNull()) {
249         JSObject* object = asObject(value);
250         const ClassInfo* classInfo = object-&gt;classInfo(vm);
251         if (classInfo == JSDOMWindow::info())
252             return jsCast&lt;JSDOMWindow*&gt;(object);
253         if (classInfo == JSWindowProxy::info())
254             return jsDynamicCast&lt;JSDOMWindow*&gt;(vm, jsCast&lt;JSWindowProxy*&gt;(object)-&gt;window());
255         value = object-&gt;getPrototypeDirect(vm);
256     }
257     return nullptr;
258 }
259 
<span class="line-modified">260 DOMWindow&amp; incumbentDOMWindow(ExecState&amp; state)</span>
261 {
<span class="line-modified">262     return asJSDOMWindow(&amp;callerGlobalObject(state))-&gt;wrapped();</span>
263 }
264 
<span class="line-modified">265 DOMWindow&amp; activeDOMWindow(ExecState&amp; state)</span>
266 {
<span class="line-modified">267     return asJSDOMWindow(state.lexicalGlobalObject())-&gt;wrapped();</span>
268 }
269 
<span class="line-modified">270 DOMWindow&amp; firstDOMWindow(ExecState&amp; state)</span>
271 {
<span class="line-modified">272     VM&amp; vm = state.vm();</span>
<span class="line-modified">273     return asJSDOMWindow(vm.vmEntryGlobalObject(&amp;state))-&gt;wrapped();</span>
274 }
275 
<span class="line-modified">276 Document* responsibleDocument(ExecState&amp; state)</span>
277 {
278     CallerFunctor functor;
<span class="line-modified">279     state.iterate(functor);</span>
280     auto* callerFrame = functor.callerFrame();
281     if (!callerFrame)
282         return nullptr;
<span class="line-modified">283     return asJSDOMWindow(callerFrame-&gt;lexicalGlobalObject())-&gt;wrapped().document();</span>
284 }
285 
286 void JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(DOMWindow* window)
287 {
288     JSC::VM&amp; vm = commonVM();
289     JSVMClientData* clientData = static_cast&lt;JSVMClientData*&gt;(vm.clientData);
290     Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt; wrapperWorlds;
291     clientData-&gt;getAllWorlds(wrapperWorlds);
292     for (unsigned i = 0; i &lt; wrapperWorlds.size(); ++i) {
293         auto&amp; wrappers = wrapperWorlds[i]-&gt;wrappers();
294         auto result = wrappers.find(window);
295         if (result == wrappers.end())
296             continue;
297         JSC::JSObject* wrapper = result-&gt;value.get();
298         if (!wrapper)
299             continue;
300         JSDOMWindowBase* jsWindow = JSC::jsCast&lt;JSDOMWindowBase*&gt;(wrapper);
301         jsWindow-&gt;m_windowCloseWatchpoints.fireAll(vm, &quot;Frame cleared&quot;);
302     }
303 }
304 
<span class="line-modified">305 JSC::Identifier JSDOMWindowBase::moduleLoaderResolve(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleName, JSC::JSValue importerModuleKey, JSC::JSValue scriptFetcher)</span>
306 {
307     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
308     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">309         return document-&gt;moduleLoader().resolve(globalObject, exec, moduleLoader, moduleName, importerModuleKey, scriptFetcher);</span>
310     return { };
311 }
312 
<span class="line-modified">313 JSC::JSInternalPromise* JSDOMWindowBase::moduleLoaderFetch(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSValue parameters, JSC::JSValue scriptFetcher)</span>
314 {
<span class="line-modified">315     VM&amp; vm = exec-&gt;vm();</span>
316     auto scope = DECLARE_THROW_SCOPE(vm);
317     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
318     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">319         RELEASE_AND_RETURN(scope, document-&gt;moduleLoader().fetch(globalObject, exec, moduleLoader, moduleKey, parameters, scriptFetcher));</span>
<span class="line-modified">320     JSC::JSInternalPromiseDeferred* deferred = JSC::JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-modified">321     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-modified">322     RELEASE_AND_RETURN(scope, deferred-&gt;reject(exec, jsUndefined()));</span>

323 }
324 
<span class="line-modified">325 JSC::JSValue JSDOMWindowBase::moduleLoaderEvaluate(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSValue moduleRecord, JSC::JSValue scriptFetcher)</span>
326 {
327     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
328     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">329         return document-&gt;moduleLoader().evaluate(globalObject, exec, moduleLoader, moduleKey, moduleRecord, scriptFetcher);</span>
330     return JSC::jsUndefined();
331 }
332 
<span class="line-modified">333 JSC::JSInternalPromise* JSDOMWindowBase::moduleLoaderImportModule(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSModuleLoader* moduleLoader, JSC::JSString* moduleName, JSC::JSValue parameters, const JSC::SourceOrigin&amp; sourceOrigin)</span>
334 {
<span class="line-modified">335     VM&amp; vm = exec-&gt;vm();</span>
336     auto scope = DECLARE_THROW_SCOPE(vm);
337     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
338     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">339         RELEASE_AND_RETURN(scope, document-&gt;moduleLoader().importModule(globalObject, exec, moduleLoader, moduleName, parameters, sourceOrigin));</span>
<span class="line-modified">340     JSC::JSInternalPromiseDeferred* deferred = JSC::JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-modified">341     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-modified">342     RELEASE_AND_RETURN(scope, deferred-&gt;reject(exec, jsUndefined()));</span>

343 }
344 
<span class="line-modified">345 JSC::JSObject* JSDOMWindowBase::moduleLoaderCreateImportMetaProperties(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSModuleRecord* moduleRecord, JSC::JSValue scriptFetcher)</span>
346 {
347     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
348     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">349         return document-&gt;moduleLoader().createImportMetaProperties(globalObject, exec, moduleLoader, moduleKey, moduleRecord, scriptFetcher);</span>
<span class="line-modified">350     return constructEmptyObject(exec, globalObject-&gt;nullPrototypeObjectStructure());</span>
351 }
352 
353 #if ENABLE(WEBASSEMBLY)
<span class="line-modified">354 static Optional&lt;Vector&lt;uint8_t&gt;&gt; tryAllocate(JSC::ExecState* exec, JSC::JSPromiseDeferred* promise, const char* data, size_t byteSize)</span>
355 {
356     Vector&lt;uint8_t&gt; arrayBuffer;
357     if (!arrayBuffer.tryReserveCapacity(byteSize)) {
<span class="line-modified">358         promise-&gt;reject(exec, createOutOfMemoryError(exec));</span>
359         return WTF::nullopt;
360     }
361 
362     arrayBuffer.grow(byteSize);
363     memcpy(arrayBuffer.data(), data, byteSize);
364 
365     return arrayBuffer;
366 }
367 
<span class="line-modified">368 static bool isResponseCorrect(JSC::ExecState* exec, FetchResponse* inputResponse, JSC::JSPromiseDeferred* promise)</span>
369 {
370     bool isResponseCorsSameOrigin = inputResponse-&gt;type() == ResourceResponse::Type::Basic || inputResponse-&gt;type() == ResourceResponse::Type::Cors || inputResponse-&gt;type() == ResourceResponse::Type::Default;
371 
372     if (!isResponseCorsSameOrigin) {
<span class="line-modified">373         promise-&gt;reject(exec, createTypeError(exec, &quot;Response is not CORS-same-origin&quot;_s));</span>
374         return false;
375     }
376 
377     if (!inputResponse-&gt;ok()) {
<span class="line-modified">378         promise-&gt;reject(exec, createTypeError(exec, &quot;Response has not returned OK status&quot;_s));</span>
379         return false;
380     }
381 
382     auto contentType = inputResponse-&gt;headers().fastGet(HTTPHeaderName::ContentType);
383     if (!equalLettersIgnoringASCIICase(contentType, &quot;application/wasm&quot;)) {
<span class="line-modified">384         promise-&gt;reject(exec, createTypeError(exec, &quot;Unexpected response MIME type. Expected &#39;application/wasm&#39;&quot;_s));</span>
385         return false;
386     }
387 
388     return true;
389 }
390 
<span class="line-modified">391 static void handleResponseOnStreamingAction(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, FetchResponse* inputResponse, JSC::JSPromiseDeferred* promise, Function&lt;void(JSC::ExecState* exec, const char* data, size_t byteSize)&gt;&amp;&amp; actionCallback)</span>
392 {
<span class="line-modified">393     if (!isResponseCorrect(exec, inputResponse, promise))</span>
394         return;
395 
396     if (inputResponse-&gt;isBodyReceivedByChunk()) {
397         inputResponse-&gt;consumeBodyReceivedByChunk([promise, callback = WTFMove(actionCallback), globalObject, data = SharedBuffer::create()] (auto&amp;&amp; result) mutable {
<span class="line-removed">398             ExecState* exec = globalObject-&gt;globalExec();</span>
399             if (result.hasException()) {
<span class="line-modified">400                 promise-&gt;reject(exec, createTypeError(exec, result.exception().message()));</span>
401                 return;
402             }
403 
404             if (auto chunk = result.returnValue())
405                 data-&gt;append(reinterpret_cast&lt;const char*&gt;(chunk-&gt;data), chunk-&gt;size);
406             else {
<span class="line-modified">407                 VM&amp; vm = exec-&gt;vm();</span>
408                 JSLockHolder lock(vm);
409 
<span class="line-modified">410                 callback(exec, data-&gt;data(), data-&gt;size());</span>
411             }
412         });
413         return;
414     }
415 
416     auto body = inputResponse-&gt;consumeBody();
417     WTF::switchOn(body, [&amp;] (Ref&lt;FormData&gt;&amp; formData) {
418         if (auto buffer = formData-&gt;asSharedBuffer()) {
<span class="line-modified">419             VM&amp; vm = exec-&gt;vm();</span>
420             JSLockHolder lock(vm);
421 
<span class="line-modified">422             actionCallback(exec, buffer-&gt;data(), buffer-&gt;size());</span>
423             return;
424         }
425         // FIXME: http://webkit.org/b/184886&gt; Implement loading for the Blob type
<span class="line-modified">426         promise-&gt;reject(exec, createTypeError(exec, &quot;Unexpected Response&#39;s Content-type&quot;_s));</span>
427     }, [&amp;] (Ref&lt;SharedBuffer&gt;&amp; buffer) {
<span class="line-modified">428         VM&amp; vm = exec-&gt;vm();</span>
429         JSLockHolder lock(vm);
430 
<span class="line-modified">431         actionCallback(exec, buffer-&gt;data(), buffer-&gt;size());</span>
432     }, [&amp;] (std::nullptr_t&amp;) {
<span class="line-modified">433         promise-&gt;reject(exec, createTypeError(exec, &quot;Unexpected Response&#39;s Content-type&quot;_s));</span>
434     });
435 }
436 
<span class="line-modified">437 void JSDOMWindowBase::compileStreaming(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSPromiseDeferred* promise, JSC::JSValue source)</span>
438 {
439     ASSERT(source);
440 
<span class="line-modified">441     VM&amp; vm = exec-&gt;vm();</span>
442 
<span class="line-modified">443     ASSERT(vm.promiseDeferredTimer-&gt;hasPendingPromise(promise));</span>
<span class="line-modified">444     ASSERT(vm.promiseDeferredTimer-&gt;hasDependancyInPendingPromise(promise, globalObject));</span>
445 
446     if (auto inputResponse = JSFetchResponse::toWrapped(vm, source)) {
<span class="line-modified">447         handleResponseOnStreamingAction(globalObject, exec, inputResponse, promise, [promise] (JSC::ExecState* exec, const char* data, size_t byteSize) mutable {</span>
<span class="line-modified">448             if (auto arrayBuffer = tryAllocate(exec, promise, data, byteSize))</span>
<span class="line-modified">449                 JSC::JSWebAssembly::webAssemblyModuleValidateAsync(exec, promise, WTFMove(*arrayBuffer));</span>
450         });
451     } else
<span class="line-modified">452         promise-&gt;reject(exec, createTypeError(exec, &quot;first argument must be an Response or Promise for Response&quot;_s));</span>
453 }
454 
<span class="line-modified">455 void JSDOMWindowBase::instantiateStreaming(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSPromiseDeferred* promise, JSC::JSValue source, JSC::JSObject* importedObject)</span>
456 {
457     ASSERT(source);
458 
<span class="line-modified">459     VM&amp; vm = exec-&gt;vm();</span>
460 
<span class="line-modified">461     ASSERT(vm.promiseDeferredTimer-&gt;hasPendingPromise(promise));</span>
<span class="line-modified">462     ASSERT(vm.promiseDeferredTimer-&gt;hasDependancyInPendingPromise(promise, globalObject));</span>
<span class="line-modified">463     ASSERT(vm.promiseDeferredTimer-&gt;hasDependancyInPendingPromise(promise, importedObject));</span>
464 
465     if (auto inputResponse = JSFetchResponse::toWrapped(vm, source)) {
<span class="line-modified">466         handleResponseOnStreamingAction(globalObject, exec, inputResponse, promise, [promise, importedObject] (JSC::ExecState* exec, const char* data, size_t byteSize) mutable {</span>
<span class="line-modified">467             if (auto arrayBuffer = tryAllocate(exec, promise, data, byteSize))</span>
<span class="line-modified">468                 JSC::JSWebAssembly::webAssemblyModuleInstantinateAsync(exec, promise, WTFMove(*arrayBuffer), importedObject);</span>
469         });
470     } else
<span class="line-modified">471         promise-&gt;reject(exec, createTypeError(exec, &quot;first argument must be an Response or Promise for Response&quot;_s));</span>
472 }
473 #endif
474 
475 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  7  *
  8  *  This library is free software; you can redistribute it and/or
  9  *  modify it under the terms of the GNU Lesser General Public
 10  *  License as published by the Free Software Foundation; either
 11  *  version 2 of the License, or (at your option) any later version.
 12  *
 13  *  This library is distributed in the hope that it will be useful,
 14  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  *  Lesser General Public License for more details.
 17  *
 18  *  You should have received a copy of the GNU Lesser General Public
 19  *  License along with this library; if not, write to the Free Software
 20  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 21  *  USA
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;JSDOMWindowBase.h&quot;
 26 

 27 #include &quot;Chrome.h&quot;
 28 #include &quot;CommonVM.h&quot;
 29 #include &quot;DOMWindow.h&quot;
 30 #include &quot;Document.h&quot;
<span class="line-added"> 31 #include &quot;EventLoop.h&quot;</span>
 32 #include &quot;FetchResponse.h&quot;
 33 #include &quot;Frame.h&quot;
 34 #include &quot;InspectorController.h&quot;
 35 #include &quot;JSDOMBindingSecurity.h&quot;
 36 #include &quot;JSDOMGlobalObjectTask.h&quot;
 37 #include &quot;JSDOMWindowCustom.h&quot;
 38 #include &quot;JSFetchResponse.h&quot;
 39 #include &quot;JSMicrotaskCallback.h&quot;
 40 #include &quot;JSNode.h&quot;
 41 #include &quot;Logging.h&quot;
 42 #include &quot;Page.h&quot;
 43 #include &quot;RejectedPromiseTracker.h&quot;
 44 #include &quot;RuntimeApplicationChecks.h&quot;
 45 #include &quot;ScriptController.h&quot;
 46 #include &quot;ScriptModuleLoader.h&quot;
 47 #include &quot;SecurityOrigin.h&quot;
 48 #include &quot;Settings.h&quot;
 49 #include &quot;WebCoreJSClientData.h&quot;
 50 #include &lt;JavaScriptCore/CodeBlock.h&gt;
 51 #include &lt;JavaScriptCore/JSInternalPromise.h&gt;

 52 #include &lt;JavaScriptCore/JSWebAssembly.h&gt;
 53 #include &lt;JavaScriptCore/Microtask.h&gt;
<span class="line-modified"> 54 #include &lt;JavaScriptCore/PromiseTimer.h&gt;</span>
 55 #include &lt;JavaScriptCore/StrongInlines.h&gt;
 56 #include &lt;wtf/Language.h&gt;
 57 #include &lt;wtf/MainThread.h&gt;
 58 
 59 #if PLATFORM(IOS_FAMILY)
 60 #include &quot;ChromeClient.h&quot;
 61 #endif
 62 
 63 
 64 namespace WebCore {
 65 using namespace JSC;
 66 
 67 const ClassInfo JSDOMWindowBase::s_info = { &quot;Window&quot;, &amp;JSDOMGlobalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDOMWindowBase) };
 68 
 69 const GlobalObjectMethodTable JSDOMWindowBase::s_globalObjectMethodTable = {
 70     &amp;supportsRichSourceInfo,
 71     &amp;shouldInterruptScript,
 72     &amp;javaScriptRuntimeFlags,
<span class="line-modified"> 73     &amp;queueMicrotaskToEventLoop,</span>
 74     &amp;shouldInterruptScriptBeforeTimeout,
 75     &amp;moduleLoaderImportModule,
 76     &amp;moduleLoaderResolve,
 77     &amp;moduleLoaderFetch,
 78     &amp;moduleLoaderCreateImportMetaProperties,
 79     &amp;moduleLoaderEvaluate,
 80     &amp;promiseRejectionTracker,
 81     &amp;defaultLanguage,
 82 #if ENABLE(WEBASSEMBLY)
 83     &amp;compileStreaming,
 84     &amp;instantiateStreaming,
 85 #else
 86     nullptr,
 87     nullptr,
 88 #endif
 89 };
 90 
 91 JSDOMWindowBase::JSDOMWindowBase(VM&amp; vm, Structure* structure, RefPtr&lt;DOMWindow&gt;&amp;&amp; window, JSWindowProxy* proxy)
 92     : JSDOMGlobalObject(vm, structure, proxy-&gt;world(), &amp;s_globalObjectMethodTable)
 93     , m_windowCloseWatchpoints((window &amp;&amp; window-&gt;frame()) ? IsWatched : IsInvalidated)
</pre>
<hr />
<pre>
108         GlobalPropertyInfo(builtinNames.windowPublicName(), m_proxy, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),
109     };
110 
111     addStaticGlobals(staticGlobals, WTF_ARRAY_LENGTH(staticGlobals));
112 
113     if (m_wrapped &amp;&amp; m_wrapped-&gt;frame() &amp;&amp; m_wrapped-&gt;frame()-&gt;settings().needsSiteSpecificQuirks())
114         setNeedsSiteSpecificQuirks(true);
115 }
116 
117 void JSDOMWindowBase::destroy(JSCell* cell)
118 {
119     static_cast&lt;JSDOMWindowBase*&gt;(cell)-&gt;JSDOMWindowBase::~JSDOMWindowBase();
120 }
121 
122 void JSDOMWindowBase::updateDocument()
123 {
124     // Since &quot;document&quot; property is defined as { configurable: false, writable: false, enumerable: true },
125     // users cannot change its attributes further.
126     // Reaching here, the attributes of &quot;document&quot; property should be never changed.
127     ASSERT(m_wrapped-&gt;document());
<span class="line-modified">128     JSGlobalObject* lexicalGlobalObject = this;</span>
129     bool shouldThrowReadOnlyError = false;
130     bool ignoreReadOnlyErrors = true;
131     bool putResult = false;
<span class="line-modified">132     symbolTablePutTouchWatchpointSet(this, lexicalGlobalObject, static_cast&lt;JSVMClientData*&gt;(lexicalGlobalObject-&gt;vm().clientData)-&gt;builtinNames().documentPublicName(), toJS(lexicalGlobalObject, this, m_wrapped-&gt;document()), shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);</span>
133 }
134 
135 ScriptExecutionContext* JSDOMWindowBase::scriptExecutionContext() const
136 {
137     return m_wrapped-&gt;document();
138 }
139 
140 void JSDOMWindowBase::printErrorMessage(const String&amp; message) const
141 {
142     printErrorMessageForFrame(wrapped().frame(), message);
143 }
144 
145 bool JSDOMWindowBase::supportsRichSourceInfo(const JSGlobalObject* object)
146 {
147     const JSDOMWindowBase* thisObject = static_cast&lt;const JSDOMWindowBase*&gt;(object);
148     Frame* frame = thisObject-&gt;wrapped().frame();
149     if (!frame)
150         return false;
151 
152     Page* page = frame-&gt;page();
153     if (!page)
154         return false;
155 
156     bool enabled = page-&gt;inspectorController().enabled();
157     ASSERT(enabled || !thisObject-&gt;debugger());
158     return enabled;
159 }
160 
161 static inline bool shouldInterruptScriptToPreventInfiniteRecursionWhenClosingPage(Page* page)
162 {
163     // See &lt;rdar://problem/5479443&gt;. We don&#39;t think that page can ever be NULL
<span class="line-modified">164     // in this case, but if it is, we&#39;ve gotten into a lexicalGlobalObject where we may have</span>
165     // hung the UI, with no way to ask the client whether to cancel execution.
166     // For now, our solution is just to cancel execution no matter what,
167     // ensuring that we never hang. We might want to consider other solutions
168     // if we discover problems with this one.
169     ASSERT(page);
170     return !page;
171 }
172 
173 bool JSDOMWindowBase::shouldInterruptScript(const JSGlobalObject* object)
174 {
175     const JSDOMWindowBase* thisObject = static_cast&lt;const JSDOMWindowBase*&gt;(object);
176     ASSERT(thisObject-&gt;wrapped().frame());
177     Page* page = thisObject-&gt;wrapped().frame()-&gt;page();
178     return shouldInterruptScriptToPreventInfiniteRecursionWhenClosingPage(page);
179 }
180 
181 bool JSDOMWindowBase::shouldInterruptScriptBeforeTimeout(const JSGlobalObject* object)
182 {
183     const JSDOMWindowBase* thisObject = static_cast&lt;const JSDOMWindowBase*&gt;(object);
184     ASSERT(thisObject-&gt;wrapped().frame());
</pre>
<hr />
<pre>
187     if (shouldInterruptScriptToPreventInfiniteRecursionWhenClosingPage(page))
188         return true;
189 
190 #if PLATFORM(IOS_FAMILY)
191     if (page-&gt;chrome().client().isStopping())
192         return true;
193 #endif
194 
195     return JSGlobalObject::shouldInterruptScriptBeforeTimeout(object);
196 }
197 
198 RuntimeFlags JSDOMWindowBase::javaScriptRuntimeFlags(const JSGlobalObject* object)
199 {
200     const JSDOMWindowBase* thisObject = static_cast&lt;const JSDOMWindowBase*&gt;(object);
201     Frame* frame = thisObject-&gt;wrapped().frame();
202     if (!frame)
203         return RuntimeFlags();
204     return frame-&gt;settings().javaScriptRuntimeFlags();
205 }
206 
<span class="line-modified">207 void JSDOMWindowBase::queueMicrotaskToEventLoop(JSGlobalObject&amp; object, Ref&lt;JSC::Microtask&gt;&amp;&amp; task)</span>
208 {
209     JSDOMWindowBase&amp; thisObject = static_cast&lt;JSDOMWindowBase&amp;&gt;(object);
210 
211     auto callback = JSMicrotaskCallback::create(thisObject, WTFMove(task));
<span class="line-modified">212     auto&amp; eventLoop = thisObject.scriptExecutionContext()-&gt;eventLoop();</span>
<span class="line-added">213     eventLoop.queueMicrotask([callback = WTFMove(callback)]() mutable {</span>
214         callback-&gt;call();
215     });


216 }
217 
218 void JSDOMWindowBase::willRemoveFromWindowProxy()
219 {
220     setCurrentEvent(0);
221 }
222 
223 JSWindowProxy* JSDOMWindowBase::proxy() const
224 {
225     return m_proxy;
226 }
227 
<span class="line-modified">228 JSValue toJS(JSGlobalObject* lexicalGlobalObject, DOMWindow&amp; domWindow)</span>
229 {
230     auto* frame = domWindow.frame();
231     if (!frame)
232         return jsNull();
<span class="line-modified">233     return toJS(lexicalGlobalObject, frame-&gt;windowProxy());</span>
234 }
235 
236 JSDOMWindow* toJSDOMWindow(Frame&amp; frame, DOMWrapperWorld&amp; world)
237 {
238     return frame.script().globalObject(world);
239 }
240 
241 JSDOMWindow* toJSDOMWindow(JSC::VM&amp; vm, JSValue value)
242 {
243     if (!value.isObject())
244         return nullptr;
245 
246     while (!value.isNull()) {
247         JSObject* object = asObject(value);
248         const ClassInfo* classInfo = object-&gt;classInfo(vm);
249         if (classInfo == JSDOMWindow::info())
250             return jsCast&lt;JSDOMWindow*&gt;(object);
251         if (classInfo == JSWindowProxy::info())
252             return jsDynamicCast&lt;JSDOMWindow*&gt;(vm, jsCast&lt;JSWindowProxy*&gt;(object)-&gt;window());
253         value = object-&gt;getPrototypeDirect(vm);
254     }
255     return nullptr;
256 }
257 
<span class="line-modified">258 DOMWindow&amp; incumbentDOMWindow(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)</span>
259 {
<span class="line-modified">260     return asJSDOMWindow(&amp;callerGlobalObject(lexicalGlobalObject, callFrame))-&gt;wrapped();</span>
261 }
262 
<span class="line-modified">263 DOMWindow&amp; activeDOMWindow(JSGlobalObject&amp; lexicalGlobalObject)</span>
264 {
<span class="line-modified">265     return asJSDOMWindow(&amp;lexicalGlobalObject)-&gt;wrapped();</span>
266 }
267 
<span class="line-modified">268 DOMWindow&amp; firstDOMWindow(JSGlobalObject&amp; lexicalGlobalObject)</span>
269 {
<span class="line-modified">270     VM&amp; vm = lexicalGlobalObject.vm();</span>
<span class="line-modified">271     return asJSDOMWindow(vm.deprecatedVMEntryGlobalObject(&amp;lexicalGlobalObject))-&gt;wrapped();</span>
272 }
273 
<span class="line-modified">274 Document* responsibleDocument(VM&amp; vm, CallFrame&amp; callFrame)</span>
275 {
276     CallerFunctor functor;
<span class="line-modified">277     callFrame.iterate(vm, functor);</span>
278     auto* callerFrame = functor.callerFrame();
279     if (!callerFrame)
280         return nullptr;
<span class="line-modified">281     return asJSDOMWindow(callerFrame-&gt;lexicalGlobalObject(vm))-&gt;wrapped().document();</span>
282 }
283 
284 void JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(DOMWindow* window)
285 {
286     JSC::VM&amp; vm = commonVM();
287     JSVMClientData* clientData = static_cast&lt;JSVMClientData*&gt;(vm.clientData);
288     Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt; wrapperWorlds;
289     clientData-&gt;getAllWorlds(wrapperWorlds);
290     for (unsigned i = 0; i &lt; wrapperWorlds.size(); ++i) {
291         auto&amp; wrappers = wrapperWorlds[i]-&gt;wrappers();
292         auto result = wrappers.find(window);
293         if (result == wrappers.end())
294             continue;
295         JSC::JSObject* wrapper = result-&gt;value.get();
296         if (!wrapper)
297             continue;
298         JSDOMWindowBase* jsWindow = JSC::jsCast&lt;JSDOMWindowBase*&gt;(wrapper);
299         jsWindow-&gt;m_windowCloseWatchpoints.fireAll(vm, &quot;Frame cleared&quot;);
300     }
301 }
302 
<span class="line-modified">303 JSC::Identifier JSDOMWindowBase::moduleLoaderResolve(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleName, JSC::JSValue importerModuleKey, JSC::JSValue scriptFetcher)</span>
304 {
305     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
306     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">307         return document-&gt;moduleLoader().resolve(globalObject, moduleLoader, moduleName, importerModuleKey, scriptFetcher);</span>
308     return { };
309 }
310 
<span class="line-modified">311 JSC::JSInternalPromise* JSDOMWindowBase::moduleLoaderFetch(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSValue parameters, JSC::JSValue scriptFetcher)</span>
312 {
<span class="line-modified">313     VM&amp; vm = globalObject-&gt;vm();</span>
314     auto scope = DECLARE_THROW_SCOPE(vm);
315     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
316     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">317         RELEASE_AND_RETURN(scope, document-&gt;moduleLoader().fetch(globalObject, moduleLoader, moduleKey, parameters, scriptFetcher));</span>
<span class="line-modified">318     JSC::JSInternalPromise* promise = JSC::JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
<span class="line-modified">319     scope.release();</span>
<span class="line-modified">320     promise-&gt;reject(globalObject, jsUndefined());</span>
<span class="line-added">321     return promise;</span>
322 }
323 
<span class="line-modified">324 JSC::JSValue JSDOMWindowBase::moduleLoaderEvaluate(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSValue moduleRecord, JSC::JSValue scriptFetcher)</span>
325 {
326     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
327     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">328         return document-&gt;moduleLoader().evaluate(globalObject, moduleLoader, moduleKey, moduleRecord, scriptFetcher);</span>
329     return JSC::jsUndefined();
330 }
331 
<span class="line-modified">332 JSC::JSInternalPromise* JSDOMWindowBase::moduleLoaderImportModule(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSString* moduleName, JSC::JSValue parameters, const JSC::SourceOrigin&amp; sourceOrigin)</span>
333 {
<span class="line-modified">334     VM&amp; vm = globalObject-&gt;vm();</span>
335     auto scope = DECLARE_THROW_SCOPE(vm);
336     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
337     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">338         RELEASE_AND_RETURN(scope, document-&gt;moduleLoader().importModule(globalObject, moduleLoader, moduleName, parameters, sourceOrigin));</span>
<span class="line-modified">339     JSC::JSInternalPromise* promise = JSC::JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
<span class="line-modified">340     scope.release();</span>
<span class="line-modified">341     promise-&gt;reject(globalObject, jsUndefined());</span>
<span class="line-added">342     return promise;</span>
343 }
344 
<span class="line-modified">345 JSC::JSObject* JSDOMWindowBase::moduleLoaderCreateImportMetaProperties(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSModuleRecord* moduleRecord, JSC::JSValue scriptFetcher)</span>
346 {
347     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
348     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
<span class="line-modified">349         return document-&gt;moduleLoader().createImportMetaProperties(globalObject, moduleLoader, moduleKey, moduleRecord, scriptFetcher);</span>
<span class="line-modified">350     return constructEmptyObject(globalObject-&gt;vm(), globalObject-&gt;nullPrototypeObjectStructure());</span>
351 }
352 
353 #if ENABLE(WEBASSEMBLY)
<span class="line-modified">354 static Optional&lt;Vector&lt;uint8_t&gt;&gt; tryAllocate(JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSPromise* promise, const char* data, size_t byteSize)</span>
355 {
356     Vector&lt;uint8_t&gt; arrayBuffer;
357     if (!arrayBuffer.tryReserveCapacity(byteSize)) {
<span class="line-modified">358         promise-&gt;reject(lexicalGlobalObject, createOutOfMemoryError(lexicalGlobalObject));</span>
359         return WTF::nullopt;
360     }
361 
362     arrayBuffer.grow(byteSize);
363     memcpy(arrayBuffer.data(), data, byteSize);
364 
365     return arrayBuffer;
366 }
367 
<span class="line-modified">368 static bool isResponseCorrect(JSC::JSGlobalObject* lexicalGlobalObject, FetchResponse* inputResponse, JSC::JSPromise* promise)</span>
369 {
370     bool isResponseCorsSameOrigin = inputResponse-&gt;type() == ResourceResponse::Type::Basic || inputResponse-&gt;type() == ResourceResponse::Type::Cors || inputResponse-&gt;type() == ResourceResponse::Type::Default;
371 
372     if (!isResponseCorsSameOrigin) {
<span class="line-modified">373         promise-&gt;reject(lexicalGlobalObject, createTypeError(lexicalGlobalObject, &quot;Response is not CORS-same-origin&quot;_s));</span>
374         return false;
375     }
376 
377     if (!inputResponse-&gt;ok()) {
<span class="line-modified">378         promise-&gt;reject(lexicalGlobalObject, createTypeError(lexicalGlobalObject, &quot;Response has not returned OK status&quot;_s));</span>
379         return false;
380     }
381 
382     auto contentType = inputResponse-&gt;headers().fastGet(HTTPHeaderName::ContentType);
383     if (!equalLettersIgnoringASCIICase(contentType, &quot;application/wasm&quot;)) {
<span class="line-modified">384         promise-&gt;reject(lexicalGlobalObject, createTypeError(lexicalGlobalObject, &quot;Unexpected response MIME type. Expected &#39;application/wasm&#39;&quot;_s));</span>
385         return false;
386     }
387 
388     return true;
389 }
390 
<span class="line-modified">391 static void handleResponseOnStreamingAction(JSC::JSGlobalObject* globalObject, FetchResponse* inputResponse, JSC::JSPromise* promise, Function&lt;void(JSC::JSGlobalObject* lexicalGlobalObject, const char* data, size_t byteSize)&gt;&amp;&amp; actionCallback)</span>
392 {
<span class="line-modified">393     if (!isResponseCorrect(globalObject, inputResponse, promise))</span>
394         return;
395 
396     if (inputResponse-&gt;isBodyReceivedByChunk()) {
397         inputResponse-&gt;consumeBodyReceivedByChunk([promise, callback = WTFMove(actionCallback), globalObject, data = SharedBuffer::create()] (auto&amp;&amp; result) mutable {

398             if (result.hasException()) {
<span class="line-modified">399                 promise-&gt;reject(globalObject, createTypeError(globalObject, result.exception().message()));</span>
400                 return;
401             }
402 
403             if (auto chunk = result.returnValue())
404                 data-&gt;append(reinterpret_cast&lt;const char*&gt;(chunk-&gt;data), chunk-&gt;size);
405             else {
<span class="line-modified">406                 VM&amp; vm = globalObject-&gt;vm();</span>
407                 JSLockHolder lock(vm);
408 
<span class="line-modified">409                 callback(globalObject, data-&gt;data(), data-&gt;size());</span>
410             }
411         });
412         return;
413     }
414 
415     auto body = inputResponse-&gt;consumeBody();
416     WTF::switchOn(body, [&amp;] (Ref&lt;FormData&gt;&amp; formData) {
417         if (auto buffer = formData-&gt;asSharedBuffer()) {
<span class="line-modified">418             VM&amp; vm = globalObject-&gt;vm();</span>
419             JSLockHolder lock(vm);
420 
<span class="line-modified">421             actionCallback(globalObject, buffer-&gt;data(), buffer-&gt;size());</span>
422             return;
423         }
424         // FIXME: http://webkit.org/b/184886&gt; Implement loading for the Blob type
<span class="line-modified">425         promise-&gt;reject(globalObject, createTypeError(globalObject, &quot;Unexpected Response&#39;s Content-type&quot;_s));</span>
426     }, [&amp;] (Ref&lt;SharedBuffer&gt;&amp; buffer) {
<span class="line-modified">427         VM&amp; vm = globalObject-&gt;vm();</span>
428         JSLockHolder lock(vm);
429 
<span class="line-modified">430         actionCallback(globalObject, buffer-&gt;data(), buffer-&gt;size());</span>
431     }, [&amp;] (std::nullptr_t&amp;) {
<span class="line-modified">432         promise-&gt;reject(globalObject, createTypeError(globalObject, &quot;Unexpected Response&#39;s Content-type&quot;_s));</span>
433     });
434 }
435 
<span class="line-modified">436 void JSDOMWindowBase::compileStreaming(JSC::JSGlobalObject* globalObject, JSC::JSPromise* promise, JSC::JSValue source)</span>
437 {
438     ASSERT(source);
439 
<span class="line-modified">440     VM&amp; vm = globalObject-&gt;vm();</span>
441 
<span class="line-modified">442     ASSERT(vm.promiseTimer-&gt;hasPendingPromise(promise));</span>
<span class="line-modified">443     ASSERT(vm.promiseTimer-&gt;hasDependancyInPendingPromise(promise, globalObject));</span>
444 
445     if (auto inputResponse = JSFetchResponse::toWrapped(vm, source)) {
<span class="line-modified">446         handleResponseOnStreamingAction(globalObject, inputResponse, promise, [promise] (JSC::JSGlobalObject* lexicalGlobalObject, const char* data, size_t byteSize) mutable {</span>
<span class="line-modified">447             if (auto arrayBuffer = tryAllocate(lexicalGlobalObject, promise, data, byteSize))</span>
<span class="line-modified">448                 JSC::JSWebAssembly::webAssemblyModuleValidateAsync(lexicalGlobalObject, promise, WTFMove(*arrayBuffer));</span>
449         });
450     } else
<span class="line-modified">451         promise-&gt;reject(globalObject, createTypeError(globalObject, &quot;first argument must be an Response or Promise for Response&quot;_s));</span>
452 }
453 
<span class="line-modified">454 void JSDOMWindowBase::instantiateStreaming(JSC::JSGlobalObject* globalObject, JSC::JSPromise* promise, JSC::JSValue source, JSC::JSObject* importedObject)</span>
455 {
456     ASSERT(source);
457 
<span class="line-modified">458     VM&amp; vm = globalObject-&gt;vm();</span>
459 
<span class="line-modified">460     ASSERT(vm.promiseTimer-&gt;hasPendingPromise(promise));</span>
<span class="line-modified">461     ASSERT(vm.promiseTimer-&gt;hasDependancyInPendingPromise(promise, globalObject));</span>
<span class="line-modified">462     ASSERT(vm.promiseTimer-&gt;hasDependancyInPendingPromise(promise, importedObject));</span>
463 
464     if (auto inputResponse = JSFetchResponse::toWrapped(vm, source)) {
<span class="line-modified">465         handleResponseOnStreamingAction(globalObject, inputResponse, promise, [promise, importedObject] (JSC::JSGlobalObject* lexicalGlobalObject, const char* data, size_t byteSize) mutable {</span>
<span class="line-modified">466             if (auto arrayBuffer = tryAllocate(lexicalGlobalObject, promise, data, byteSize))</span>
<span class="line-modified">467                 JSC::JSWebAssembly::webAssemblyModuleInstantinateAsync(lexicalGlobalObject, promise, WTFMove(*arrayBuffer), importedObject);</span>
468         });
469     } else
<span class="line-modified">470         promise-&gt;reject(globalObject, createTypeError(globalObject, &quot;first argument must be an Response or Promise for Response&quot;_s));</span>
471 }
472 #endif
473 
474 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="JSDOMPromiseDeferred.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMWindowBase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
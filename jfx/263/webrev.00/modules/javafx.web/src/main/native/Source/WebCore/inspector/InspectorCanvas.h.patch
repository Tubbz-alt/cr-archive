diff a/modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorCanvas.h b/modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorCanvas.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorCanvas.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorCanvas.h
@@ -24,42 +24,66 @@
  */
 
 #pragma once
 
 #include "CallTracerTypes.h"
+#include "CanvasRenderingContext.h"
 #include <JavaScriptCore/InspectorProtocolObjects.h>
+#include <JavaScriptCore/JSCInlines.h>
 #include <JavaScriptCore/ScriptCallFrame.h>
 #include <JavaScriptCore/ScriptCallStack.h>
 #include <initializer_list>
+#include <wtf/HashSet.h>
 #include <wtf/Variant.h>
 #include <wtf/Vector.h>
 #include <wtf/text/WTFString.h>
 
+#if ENABLE(WEBGPU)
+#include "WebGPUDevice.h"
+#endif
+
 namespace WebCore {
 
 class CanvasGradient;
 class CanvasPattern;
-class CanvasRenderingContext;
+class Element;
 class HTMLCanvasElement;
 class HTMLImageElement;
 class HTMLVideoElement;
 class ImageBitmap;
 class ImageData;
+#if ENABLE(OFFSCREEN_CANVAS)
+class OffscreenCanvas;
+#endif
 #if ENABLE(CSS_TYPED_OM)
 class TypedOMCSSImageValue;
 #endif
 
 typedef String ErrorString;
 
 class InspectorCanvas final : public RefCounted<InspectorCanvas> {
 public:
     static Ref<InspectorCanvas> create(CanvasRenderingContext&);
+#if ENABLE(WEBGPU)
+    static Ref<InspectorCanvas> create(WebGPUDevice&);
+#endif
+
+    const String& identifier() const { return m_identifier; }
+
+    CanvasRenderingContext* canvasContext() const;
+    HTMLCanvasElement* canvasElement() const;
+
+#if ENABLE(WEBGPU)
+    WebGPUDevice* deviceContext() const;
+    bool isDeviceForCanvasContext(CanvasRenderingContext&) const;
+#endif
+
+    ScriptExecutionContext* scriptExecutionContext() const;
 
-    const String& identifier() { return m_identifier; }
-    CanvasRenderingContext& context() { return m_context; }
+    JSC::JSValue resolveContext(JSC::JSGlobalObject*) const;
 
-    HTMLCanvasElement* canvasElement();
+    HashSet<Element*> clientNodes() const;
 
     void canvasChanged();
 
     void resetRecordingData();
     bool hasRecordingData() const;
@@ -85,10 +109,14 @@
 
     String getCanvasContentAsDataURL(ErrorString&);
 
 private:
     InspectorCanvas(CanvasRenderingContext&);
+#if ENABLE(WEBGPU)
+    InspectorCanvas(WebGPUDevice&);
+#endif
+
     void appendActionSnapshotIfNeeded();
 
     using DuplicateDataVariant = Variant<
         RefPtr<CanvasGradient>,
         RefPtr<CanvasPattern>,
@@ -102,10 +130,13 @@
         RefPtr<Inspector::ScriptCallStack>,
 #if ENABLE(CSS_TYPED_OM)
         RefPtr<TypedOMCSSImageValue>,
 #endif
         Inspector::ScriptCallFrame,
+#if ENABLE(OFFSCREEN_CANVAS)
+        RefPtr<OffscreenCanvas>,
+#endif
         String
     >;
 
     int indexForData(DuplicateDataVariant);
     String stringIndexForKey(const String&);
@@ -114,11 +145,18 @@
     Ref<JSON::ArrayOf<JSON::Value>> buildArrayForCanvasGradient(const CanvasGradient&);
     Ref<JSON::ArrayOf<JSON::Value>> buildArrayForCanvasPattern(const CanvasPattern&);
     Ref<JSON::ArrayOf<JSON::Value>> buildArrayForImageData(const ImageData&);
 
     String m_identifier;
-    CanvasRenderingContext& m_context;
+
+    Variant<
+        std::reference_wrapper<CanvasRenderingContext>,
+#if ENABLE(WEBGPU)
+        std::reference_wrapper<WebGPUDevice>,
+#endif
+        Monostate
+    > m_context;
 
     RefPtr<Inspector::Protocol::Recording::InitialState> m_initialState;
     RefPtr<JSON::ArrayOf<Inspector::Protocol::Recording::Frame>> m_frames;
     RefPtr<JSON::ArrayOf<JSON::Value>> m_currentActions;
     RefPtr<JSON::ArrayOf<JSON::Value>> m_lastRecordedAction;

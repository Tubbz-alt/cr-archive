<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/remote/socket/RemoteInspectorSocket.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Sony Interactive Entertainment Inc.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RemoteInspector.h&quot;
 28 
 29 #if ENABLE(REMOTE_INSPECTOR)
 30 
 31 #include &quot;RemoteAutomationTarget.h&quot;
 32 #include &quot;RemoteConnectionToTarget.h&quot;
 33 #include &quot;RemoteInspectionTarget.h&quot;
 34 #include &lt;wtf/FileSystem.h&gt;
 35 #include &lt;wtf/JSONValues.h&gt;
 36 #include &lt;wtf/MainThread.h&gt;
 37 #include &lt;wtf/NeverDestroyed.h&gt;
 38 #include &lt;wtf/RunLoop.h&gt;
 39 
 40 namespace Inspector {
 41 
 42 RemoteInspector&amp; RemoteInspector::singleton()
 43 {
 44     static NeverDestroyed&lt;RemoteInspector&gt; shared;
 45     return shared;
 46 }
 47 
 48 RemoteInspector::RemoteInspector()
 49 {
 50     Socket::init();
 51     start();
 52 }
 53 
 54 void RemoteInspector::connect(ConnectionID id)
 55 {
 56     ASSERT(!isConnected());
 57 
 58     m_clientConnection = id;
 59     start();
 60 }
 61 
 62 void RemoteInspector::didClose(ConnectionID)
 63 {
 64     ASSERT(isConnected());
 65 
 66     m_clientConnection = WTF::nullopt;
 67 
 68     RunLoop::current().dispatch([=] {
 69         LockHolder lock(m_mutex);
 70         stopInternal(StopSource::API);
 71     });
 72 }
 73 
 74 void RemoteInspector::sendWebInspectorEvent(const String&amp; event)
 75 {
 76     if (!m_clientConnection)
 77         return;
 78 
 79     const CString message = event.utf8();
 80     send(m_clientConnection.value(), reinterpret_cast&lt;const uint8_t*&gt;(message.data()), message.length());
 81 }
 82 
 83 void RemoteInspector::start()
 84 {
 85     LockHolder lock(m_mutex);
 86 
 87     if (m_enabled)
 88         return;
 89 
 90     m_enabled = true;
 91 }
 92 
 93 void RemoteInspector::stopInternal(StopSource)
 94 {
 95     if (!m_enabled)
 96         return;
 97 
 98     m_enabled = false;
 99     m_pushScheduled = false;
100     m_readyToPushListings = false;
101 
102     for (auto targetConnection : m_targetConnectionMap.values())
103         targetConnection-&gt;close();
104     m_targetConnectionMap.clear();
105 
106     updateHasActiveDebugSession();
107 
108     m_automaticInspectionPaused = false;
109 }
110 
111 TargetListing RemoteInspector::listingForInspectionTarget(const RemoteInspectionTarget&amp; target) const
112 {
113     if (!target.remoteDebuggingAllowed())
114         return nullptr;
115 
116     // FIXME: Support remote debugging of a ServiceWorker.
117     if (target.type() == RemoteInspectionTarget::Type::ServiceWorker)
118         return nullptr;
119 
120     TargetListing targetListing = JSON::Object::create();
121 
122     targetListing-&gt;setString(&quot;name&quot;_s, target.name());
123     targetListing-&gt;setString(&quot;url&quot;_s, target.url());
124     targetListing-&gt;setInteger(&quot;targetID&quot;_s, target.targetIdentifier());
125     targetListing-&gt;setBoolean(&quot;hasLocalDebugger&quot;_s, target.hasLocalDebugger());
126     if (target.type() == RemoteInspectionTarget::Type::WebPage)
127         targetListing-&gt;setString(&quot;type&quot;_s, &quot;web-page&quot;_s);
128     else if (target.type() == RemoteInspectionTarget::Type::Page)
129         targetListing-&gt;setString(&quot;type&quot;_s, &quot;page&quot;_s);
130     else if (target.type() == RemoteInspectionTarget::Type::JavaScript)
131         targetListing-&gt;setString(&quot;type&quot;_s, &quot;javascript&quot;_s);
132     else if (target.type() == RemoteInspectionTarget::Type::ServiceWorker)
133         targetListing-&gt;setString(&quot;type&quot;_s, &quot;service-worker&quot;_s);
134 
135     return targetListing;
136 }
137 
138 TargetListing RemoteInspector::listingForAutomationTarget(const RemoteAutomationTarget&amp; target) const
139 {
140     TargetListing targetListing = JSON::Object::create();
141     targetListing-&gt;setString(&quot;type&quot;_s, &quot;automation&quot;_s);
142     targetListing-&gt;setString(&quot;name&quot;_s, target.name());
143     targetListing-&gt;setInteger(&quot;targetID&quot;_s, target.targetIdentifier());
144     targetListing-&gt;setBoolean(&quot;isPaired&quot;_s, target.isPaired());
145     return targetListing;
146 }
147 
148 void RemoteInspector::pushListingsNow()
149 {
150     if (!isConnected() || !m_readyToPushListings)
151         return;
152 
153     m_pushScheduled = false;
154 
155     auto targetListJSON = JSON::Array::create();
156     for (auto listing : m_targetListingMap.values())
157         targetListJSON-&gt;pushObject(listing);
158 
159     auto jsonEvent = JSON::Object::create();
160     jsonEvent-&gt;setString(&quot;event&quot;_s, &quot;SetTargetList&quot;_s);
161     jsonEvent-&gt;setString(&quot;message&quot;_s, targetListJSON-&gt;toJSONString());
162     jsonEvent-&gt;setInteger(&quot;connectionID&quot;_s, m_clientConnection.value());
163     jsonEvent-&gt;setBoolean(&quot;remoteAutomationAllowed&quot;_s, m_clientCapabilities &amp;&amp; m_clientCapabilities-&gt;remoteAutomationAllowed);
164     sendWebInspectorEvent(jsonEvent-&gt;toJSONString());
165 }
166 
167 void RemoteInspector::pushListingsSoon()
168 {
169     if (!isConnected())
170         return;
171 
172     if (m_pushScheduled)
173         return;
174 
175     m_pushScheduled = true;
176 
177     RunLoop::current().dispatch([=] {
178         LockHolder lock(m_mutex);
179         if (m_pushScheduled)
180             pushListingsNow();
181     });
182 }
183 
184 void RemoteInspector::sendAutomaticInspectionCandidateMessage()
185 {
186     ASSERT(m_enabled);
187     ASSERT(m_automaticInspectionEnabled);
188     ASSERT(m_automaticInspectionPaused);
189     ASSERT(m_automaticInspectionCandidateTargetIdentifier);
190     // FIXME: Implement automatic inspection.
191 }
192 
193 void RemoteInspector::requestAutomationSession(const String&amp; sessionID, const Client::SessionCapabilities&amp; capabilities)
194 {
195     if (!m_client)
196         return;
197 
198     if (!m_clientCapabilities || !m_clientCapabilities-&gt;remoteAutomationAllowed) {
199         LOG_ERROR(&quot;Error: Remote automation is not allowed&quot;);
200         return;
201     }
202 
203     if (sessionID.isNull()) {
204         LOG_ERROR(&quot;Client error: SESSION ID cannot be null&quot;);
205         return;
206     }
207 
208     m_client-&gt;requestAutomationSession(sessionID, capabilities);
209     updateClientCapabilities();
210 }
211 
212 void RemoteInspector::sendMessageToRemote(TargetID targetIdentifier, const String&amp; message)
213 {
214     if (!m_clientConnection)
215         return;
216 
217     auto sendMessageEvent = JSON::Object::create();
218     sendMessageEvent-&gt;setInteger(&quot;targetID&quot;_s, targetIdentifier);
219     sendMessageEvent-&gt;setString(&quot;event&quot;_s, &quot;SendMessageToFrontend&quot;_s);
220     sendMessageEvent-&gt;setInteger(&quot;connectionID&quot;_s, m_clientConnection.value());
221     sendMessageEvent-&gt;setString(&quot;message&quot;_s, message);
222     sendWebInspectorEvent(sendMessageEvent-&gt;toJSONString());
223 }
224 
225 void RemoteInspector::setup(TargetID targetIdentifier)
226 {
227     RemoteControllableTarget* target;
228     {
229         LockHolder lock(m_mutex);
230         target = m_targetMap.get(targetIdentifier);
231         if (!target)
232             return;
233     }
234 
235     auto connectionToTarget = adoptRef(*new RemoteConnectionToTarget(*target));
236     ASSERT(is&lt;RemoteInspectionTarget&gt;(target) || is&lt;RemoteAutomationTarget&gt;(target));
237     if (!connectionToTarget-&gt;setup()) {
238         connectionToTarget-&gt;close();
239         return;
240     }
241 
242     LockHolder lock(m_mutex);
243     m_targetConnectionMap.set(targetIdentifier, WTFMove(connectionToTarget));
244 
245     updateHasActiveDebugSession();
246 }
247 
248 void RemoteInspector::sendMessageToTarget(TargetID targetIdentifier, const char* message)
249 {
250     if (auto connectionToTarget = m_targetConnectionMap.get(targetIdentifier))
251         connectionToTarget-&gt;sendMessageToTarget(String::fromUTF8(message));
252 }
253 
254 String RemoteInspector::backendCommands() const
255 {
256     if (m_backendCommandsPath.isEmpty())
257         return { };
258 
259     auto handle = FileSystem::openFile(m_backendCommandsPath, FileSystem::FileOpenMode::Read);
260     if (!FileSystem::isHandleValid(handle))
261         return { };
262 
263     String result;
264     long long size;
265     if (FileSystem::getFileSize(handle, size)) {
266         Vector&lt;LChar&gt; buffer(size);
267         if (FileSystem::readFromFile(handle, reinterpret_cast&lt;char*&gt;(buffer.data()), size) == size)
268             result = String::adopt(WTFMove(buffer));
269     }
270     FileSystem::closeFile(handle);
271     return result;
272 }
273 
274 // RemoteInspectorConnectionClient handlers
275 
276 HashMap&lt;String, RemoteInspectorConnectionClient::CallHandler&gt;&amp; RemoteInspector::dispatchMap()
277 {
278     static NeverDestroyed&lt;HashMap&lt;String, CallHandler&gt;&gt; methods = HashMap&lt;String, CallHandler&gt;({
279         { &quot;SetupInspectorClient&quot;_s, static_cast&lt;CallHandler&gt;(&amp;RemoteInspector::setupInspectorClient) },
280         { &quot;Setup&quot;_s, static_cast&lt;CallHandler&gt;(&amp;RemoteInspector::setupTarget) },
281         { &quot;FrontendDidClose&quot;_s, static_cast&lt;CallHandler&gt;(&amp;RemoteInspector::frontendDidClose) },
282         { &quot;SendMessageToBackend&quot;_s, static_cast&lt;CallHandler&gt;(&amp;RemoteInspector::sendMessageToBackend) },
283         { &quot;StartAutomationSession&quot;_s, static_cast&lt;CallHandler&gt;(&amp;RemoteInspector::startAutomationSession) },
284     });
285 
286     return methods;
287 }
288 
289 void RemoteInspector::setupInspectorClient(const Event&amp;)
290 {
291     ASSERT(isMainThread());
292 
293     auto backendCommandsEvent = JSON::Object::create();
294     backendCommandsEvent-&gt;setString(&quot;event&quot;_s, &quot;BackendCommands&quot;_s);
295     backendCommandsEvent-&gt;setString(&quot;message&quot;_s, backendCommands());
296     sendWebInspectorEvent(backendCommandsEvent-&gt;toJSONString());
297 
298     m_readyToPushListings = true;
299 
300     LockHolder lock(m_mutex);
301     pushListingsNow();
302 }
303 
304 void RemoteInspector::setupTarget(const Event&amp; event)
305 {
306     ASSERT(isMainThread());
307 
308     if (!event.targetID || !event.connectionID)
309         return;
310 
311     setup(event.targetID.value());
312 }
313 
314 void RemoteInspector::frontendDidClose(const Event&amp; event)
315 {
316     ASSERT(isMainThread());
317 
318     if (!event.targetID)
319         return;
320 
321     RefPtr&lt;RemoteConnectionToTarget&gt; connectionToTarget;
322     {
323         LockHolder lock(m_mutex);
324         RemoteControllableTarget* target = m_targetMap.get(event.targetID.value());
325         if (!target)
326             return;
327 
328         connectionToTarget = m_targetConnectionMap.take(event.targetID.value());
329         updateHasActiveDebugSession();
330     }
331 
332     if (connectionToTarget)
333         connectionToTarget-&gt;close();
334 }
335 
336 void RemoteInspector::sendMessageToBackend(const Event&amp; event)
337 {
338     ASSERT(isMainThread());
339 
340     if (!event.connectionID || !event.targetID || !event.message)
341         return;
342 
343     RefPtr&lt;RemoteConnectionToTarget&gt; connectionToTarget;
344     {
345         LockHolder lock(m_mutex);
346         connectionToTarget = m_targetConnectionMap.get(event.targetID.value());
347         if (!connectionToTarget)
348             return;
349     }
350 
351     connectionToTarget-&gt;sendMessageToTarget(event.message.value());
352 }
353 
354 void RemoteInspector::startAutomationSession(const Event&amp; event)
355 {
356     ASSERT(isMainThread());
357 
358     if (!event.message)
359         return;
360 
361     requestAutomationSession(event.message.value(), { });
362 
363     auto sendEvent = JSON::Object::create();
364     sendEvent-&gt;setString(&quot;event&quot;_s, &quot;SetCapabilities&quot;_s);
365 
366     auto capability = clientCapabilities();
367 
368     auto message = JSON::Object::create();
369     message-&gt;setString(&quot;browserName&quot;_s, capability ? capability-&gt;browserName : &quot;&quot;);
370     message-&gt;setString(&quot;browserVersion&quot;_s, capability ? capability-&gt;browserVersion : &quot;&quot;);
371     sendEvent-&gt;setString(&quot;message&quot;_s, message-&gt;toJSONString());
372     sendWebInspectorEvent(sendEvent-&gt;toJSONString());
373 
374     m_readyToPushListings = true;
375 
376     LockHolder lock(m_mutex);
377     pushListingsNow();
378 }
379 
380 } // namespace Inspector
381 
382 #endif // ENABLE(REMOTE_INSPECTOR)
    </pre>
  </body>
</html>
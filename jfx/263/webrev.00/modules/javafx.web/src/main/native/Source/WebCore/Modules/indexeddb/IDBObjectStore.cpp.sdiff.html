<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBObjectStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBKeyRangeData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBObjectStore.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBObjectStore.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 43 #include &quot;IndexedDB.h&quot;
 44 #include &quot;Logging.h&quot;
 45 #include &quot;Page.h&quot;
 46 #include &quot;ScriptExecutionContext.h&quot;
 47 #include &quot;ScriptState.h&quot;
 48 #include &quot;SerializedScriptValue.h&quot;
 49 #include &lt;JavaScriptCore/CatchScope.h&gt;
 50 #include &lt;JavaScriptCore/HeapInlines.h&gt;
 51 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
 52 #include &lt;wtf/Locker.h&gt;
 53 
 54 namespace WebCore {
 55 using namespace JSC;
 56 
 57 IDBObjectStore::IDBObjectStore(ScriptExecutionContext&amp; context, const IDBObjectStoreInfo&amp; info, IDBTransaction&amp; transaction)
 58     : ActiveDOMObject(&amp;context)
 59     , m_info(info)
 60     , m_originalInfo(info)
 61     , m_transaction(transaction)
 62 {
<span class="line-modified"> 63     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
 64 
 65     suspendIfNeeded();
 66 }
 67 
 68 IDBObjectStore::~IDBObjectStore()
 69 {
<span class="line-modified"> 70     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
 71 }
 72 
 73 const char* IDBObjectStore::activeDOMObjectName() const
 74 {
 75     return &quot;IDBObjectStore&quot;;
 76 }
 77 
<span class="line-removed"> 78 bool IDBObjectStore::canSuspendForDocumentSuspension() const</span>
<span class="line-removed"> 79 {</span>
<span class="line-removed"> 80     return false;</span>
<span class="line-removed"> 81 }</span>
<span class="line-removed"> 82 </span>
 83 bool IDBObjectStore::hasPendingActivity() const
 84 {
 85     return m_transaction.hasPendingActivity();
 86 }
 87 
 88 const String&amp; IDBObjectStore::name() const
 89 {
<span class="line-modified"> 90     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
 91     return m_info.name();
 92 }
 93 
 94 ExceptionOr&lt;void&gt; IDBObjectStore::setName(const String&amp; name)
 95 {
<span class="line-modified"> 96     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
 97 
 98     if (m_deleted)
 99         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
100 
101     if (!m_transaction.isVersionChange())
102         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBObjectStore&#39;: The object store&#39;s transaction is not a version change transaction.&quot;_s };
103 
104     if (!m_transaction.isActive())
105         return Exception { TransactionInactiveError, &quot;Failed set property &#39;name&#39; on &#39;IDBObjectStore&#39;: The object store&#39;s transaction is not active.&quot;_s };
106 
107     if (m_info.name() == name)
108         return { };
109 
110     if (m_transaction.database().info().hasObjectStore(name))
111         return Exception { ConstraintError, makeString(&quot;Failed set property &#39;name&#39; on &#39;IDBObjectStore&#39;: The database already has an object store named &#39;&quot;, name, &quot;&#39;.&quot;) };
112 
113     m_transaction.database().renameObjectStore(*this, name);
114     m_info.rename(name);
115 
116     return { };
117 }
118 
119 const Optional&lt;IDBKeyPath&gt;&amp; IDBObjectStore::keyPath() const
120 {
<span class="line-modified">121     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
122     return m_info.keyPath();
123 }
124 
125 Ref&lt;DOMStringList&gt; IDBObjectStore::indexNames() const
126 {
<span class="line-modified">127     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
128 
129     auto indexNames = DOMStringList::create();
130 
131     if (!m_deleted) {
132         for (auto&amp; name : m_info.indexNames())
133             indexNames-&gt;append(name);
134         indexNames-&gt;sort();
135     }
136 
137     return indexNames;
138 }
139 
140 IDBTransaction&amp; IDBObjectStore::transaction()
141 {
<span class="line-modified">142     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
143     return m_transaction;
144 }
145 
146 bool IDBObjectStore::autoIncrement() const
147 {
<span class="line-modified">148     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
149     return m_info.autoIncrement();
150 }
151 
<span class="line-modified">152 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doOpenCursor(ExecState&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
153 {
154     LOG(IndexedDB, &quot;IDBObjectStore::openCursor&quot;);
<span class="line-modified">155     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
156 
157     if (m_deleted)
158         return Exception { InvalidStateError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
159 
160     if (!m_transaction.isActive())
161         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
162 
163     auto keyRange = function();
164     if (keyRange.hasException())
165         return keyRange.releaseException();
166     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
167 
168     auto info = IDBCursorInfo::objectStoreCursor(m_transaction, m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyAndValue);
169     return m_transaction.requestOpenCursor(execState, *this, info);
170 }
171 
<span class="line-modified">172 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
173 {
174     return doOpenCursor(execState, direction, [range = WTFMove(range)]() {
175         return range;
176     });
177 }
178 
<span class="line-modified">179 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)</span>
180 {
181     return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
182         auto onlyResult = IDBKeyRange::only(*state, key);
183         if (onlyResult.hasException())
184             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
185 
186         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
187     });
188 }
189 
<span class="line-modified">190 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doOpenKeyCursor(ExecState&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
191 {
192     LOG(IndexedDB, &quot;IDBObjectStore::openKeyCursor&quot;);
<span class="line-modified">193     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
194 
195     if (m_deleted)
196         return Exception { InvalidStateError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
197 
198     if (!m_transaction.isActive())
199         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
200 
201     auto keyRange = function();
202     if (keyRange.hasException())
203         return keyRange.releaseException();
204 
205     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
206     auto info = IDBCursorInfo::objectStoreCursor(m_transaction, m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyOnly);
207     return m_transaction.requestOpenCursor(execState, *this, info);
208 }
209 
<span class="line-modified">210 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
211 {
212     return doOpenKeyCursor(execState, direction, [range = WTFMove(range)]() {
213         return range;
214     });
215 }
216 
<span class="line-modified">217 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)</span>
218 {
219     return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
220         auto onlyResult = IDBKeyRange::only(*state, key);
221         if (onlyResult.hasException())
222             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
223 
224         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
225     });
226 }
227 
<span class="line-modified">228 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::get(ExecState&amp; execState, JSValue key)</span>
229 {
230     LOG(IndexedDB, &quot;IDBObjectStore::get&quot;);
<span class="line-modified">231     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
232 
233     if (m_deleted)
234         return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
235 
236     if (!m_transaction.isActive())
237         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
238 
239     auto idbKey = scriptValueToIDBKey(execState, key);
240     if (!idbKey-&gt;isValid())
241         return Exception { DataError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
242 
243     return m_transaction.requestGetRecord(execState, *this, { idbKey.ptr(), IDBGetRecordDataType::KeyAndValue });
244 }
245 
<span class="line-modified">246 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::get(ExecState&amp; execState, IDBKeyRange* keyRange)</span>
247 {
248     LOG(IndexedDB, &quot;IDBObjectStore::get&quot;);
<span class="line-modified">249     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
250 
251     if (m_deleted)
252         return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
253 
254     if (!m_transaction.isActive())
255         return Exception { TransactionInactiveError };
256 
257     IDBKeyRangeData keyRangeData(keyRange);
258     if (!keyRangeData.isValid())
259         return Exception { DataError };
260 
261     return m_transaction.requestGetRecord(execState, *this, { keyRangeData, IDBGetRecordDataType::KeyAndValue });
262 }
263 
<span class="line-modified">264 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getKey(ExecState&amp; execState, JSValue key)</span>
265 {
266     LOG(IndexedDB, &quot;IDBObjectStore::getKey&quot;);
<span class="line-modified">267     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
268 
269     if (m_deleted)
270         return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
271 
272     if (!m_transaction.isActive())
273         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
274 
275     auto idbKey = scriptValueToIDBKey(execState, key);
276     if (!idbKey-&gt;isValid())
277         return Exception { DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
278 
279     return m_transaction.requestGetRecord(execState, *this, { idbKey.ptr(), IDBGetRecordDataType::KeyOnly });
280 }
281 
<span class="line-modified">282 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getKey(ExecState&amp; execState, IDBKeyRange* keyRange)</span>
283 {
284     LOG(IndexedDB, &quot;IDBObjectStore::getKey&quot;);
<span class="line-modified">285     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
286 
287     if (m_deleted)
288         return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
289 
290     if (!m_transaction.isActive())
291         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
292 
293     IDBKeyRangeData keyRangeData(keyRange);
294     if (!keyRangeData.isValid())
295         return Exception { DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key range.&quot;_s };
296 
297     return m_transaction.requestGetRecord(execState, *this, { keyRangeData, IDBGetRecordDataType::KeyOnly });
298 }
299 
<span class="line-modified">300 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::add(ExecState&amp; execState, JSValue value, JSValue key)</span>
301 {
302     RefPtr&lt;IDBKey&gt; idbKey;
303     if (!key.isUndefined())
304         idbKey = scriptValueToIDBKey(execState, key);
305     return putOrAdd(execState, value, idbKey, IndexedDB::ObjectStoreOverwriteMode::NoOverwrite, InlineKeyCheck::Perform);
306 }
307 
<span class="line-modified">308 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::put(ExecState&amp; execState, JSValue value, JSValue key)</span>
309 {
310     RefPtr&lt;IDBKey&gt; idbKey;
311     if (!key.isUndefined())
312         idbKey = scriptValueToIDBKey(execState, key);
313     return putOrAdd(execState, value, idbKey, IndexedDB::ObjectStoreOverwriteMode::Overwrite, InlineKeyCheck::Perform);
314 }
315 
<span class="line-modified">316 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::putForCursorUpdate(ExecState&amp; state, JSValue value, RefPtr&lt;IDBKey&gt; key)</span>
317 {
318     return putOrAdd(state, value, WTFMove(key), IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor, InlineKeyCheck::DoNotPerform);
319 }
320 
<span class="line-modified">321 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::putOrAdd(ExecState&amp; state, JSValue value, RefPtr&lt;IDBKey&gt; key, IndexedDB::ObjectStoreOverwriteMode overwriteMode, InlineKeyCheck inlineKeyCheck)</span>
322 {
323     VM&amp; vm = state.vm();
324     auto scope = DECLARE_CATCH_SCOPE(vm);
325 
326     LOG(IndexedDB, &quot;IDBObjectStore::putOrAdd&quot;);
<span class="line-modified">327     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
328 
329     auto context = scriptExecutionContextFromExecState(&amp;state);
330     if (!context)
331         return Exception { UnknownError, &quot;Unable to store record in object store because it does not have a valid script execution context&quot;_s };
332 
333     if (m_deleted)
334         return Exception { InvalidStateError, &quot;Failed to store record in an IDBObjectStore: The object store has been deleted.&quot;_s };
335 
336     if (!m_transaction.isActive())
337         return Exception { TransactionInactiveError, &quot;Failed to store record in an IDBObjectStore: The transaction is inactive or finished.&quot;_s };
338 
339     if (m_transaction.isReadOnly())
340         return Exception { ReadonlyError, &quot;Failed to store record in an IDBObjectStore: The transaction is read-only.&quot;_s };
341 
342     auto serializedValue = SerializedScriptValue::create(state, value);
343     if (UNLIKELY(scope.exception()))
344         return Exception { DataCloneError, &quot;Failed to store record in an IDBObjectStore: An object could not be cloned.&quot;_s };
345 
346     bool privateBrowsingEnabled = false;
347     if (is&lt;Document&gt;(*context)) {
</pre>
<hr />
<pre>
367         if (keyPathKey &amp;&amp; !keyPathKey-&gt;isValid())
368             return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: Evaluating the object store&#39;s key path yielded a value that is not a valid key.&quot;_s };
369 
370         if (!keyPathKey) {
371             if (!usesKeyGenerator)
372                 return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: Evaluating the object store&#39;s key path did not yield a value.&quot;_s };
373             if (!canInjectIDBKeyIntoScriptValue(state, value, m_info.keyPath().value()))
374                 return Exception { DataError };
375         }
376 
377         if (keyPathKey) {
378             ASSERT(!key);
379             key = keyPathKey;
380         }
381     } else if (!usesKeyGenerator &amp;&amp; !key)
382         return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: The object store uses out-of-line keys and has no key generator and the key parameter was not provided.&quot;_s };
383 
384     return m_transaction.requestPutOrAdd(state, *this, WTFMove(key), *serializedValue, overwriteMode);
385 }
386 
<span class="line-modified">387 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(ExecState&amp; execState, IDBKeyRange* keyRange)</span>
388 {
389     return doDelete(execState, [keyRange]() {
390         return makeRefPtr(keyRange);
391     });
392 }
393 
<span class="line-modified">394 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doDelete(ExecState&amp; execState, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
395 {
396     LOG(IndexedDB, &quot;IDBObjectStore::deleteFunction&quot;);
<span class="line-modified">397     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
398 
399     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
400     // the exception for an object store being deleted.
401     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
402     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
403     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
404     if (m_deleted)
405         return Exception { InvalidStateError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
406 
407     if (!m_transaction.isActive())
408         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
409 
410     if (m_transaction.isReadOnly())
411         return Exception { ReadonlyError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The transaction is read-only.&quot;_s };
412 
413     auto keyRange = function();
414     if (keyRange.hasException())
415         return keyRange.releaseException();
416 
417     IDBKeyRangeData keyRangeData = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
418     if (!keyRangeData.isValid())
419         return Exception { DataError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key range.&quot;_s };
420 
421     return m_transaction.requestDeleteRecord(execState, *this, keyRangeData);
422 }
423 
<span class="line-modified">424 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(ExecState&amp; execState, JSValue key)</span>
425 {
426     return doDelete(execState, [state=&amp;execState, key]() {
427         auto idbKey = scriptValueToIDBKey(*state, key);
428         if (!idbKey-&gt;isValid())
429             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
430         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { (IDBKeyRange::create(WTFMove(idbKey))).ptr() };
431     });
432 }
433 
<span class="line-modified">434 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::clear(ExecState&amp; execState)</span>
435 {
436     LOG(IndexedDB, &quot;IDBObjectStore::clear&quot;);
<span class="line-modified">437     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
438 
439     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
440     // the exception for an object store being deleted.
441     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
442     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
443     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
444     if (m_deleted)
445         return Exception { InvalidStateError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
446 
447     if (!m_transaction.isActive())
448         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
449 
450     if (m_transaction.isReadOnly())
451         return Exception { ReadonlyError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The transaction is read-only.&quot;_s };
452 
453     return m_transaction.requestClearObjectStore(execState, *this);
454 }
455 
<span class="line-modified">456 ExceptionOr&lt;Ref&lt;IDBIndex&gt;&gt; IDBObjectStore::createIndex(ExecState&amp;, const String&amp; name, IDBKeyPath&amp;&amp; keyPath, const IndexParameters&amp; parameters)</span>
457 {
458     LOG(IndexedDB, &quot;IDBObjectStore::createIndex %s (keyPath: %s, unique: %i, multiEntry: %i)&quot;, name.utf8().data(), loggingString(keyPath).utf8().data(), parameters.unique, parameters.multiEntry);
<span class="line-modified">459     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
460 
461     if (!m_transaction.isVersionChange())
462         return Exception { InvalidStateError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The database is not running a version change transaction.&quot;_s };
463 
464     if (m_deleted)
465         return Exception { InvalidStateError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
466 
467     if (!m_transaction.isActive())
468         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive.&quot;_s};
469 
470     if (m_info.hasIndex(name))
471         return Exception { ConstraintError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: An index with the specified name already exists.&quot;_s };
472 
473     if (!isIDBKeyPathValid(keyPath))
474         return Exception { SyntaxError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The keyPath argument contains an invalid key path.&quot;_s };
475 
476     if (name.isNull())
477         return Exception { TypeError };
478 
479     if (parameters.multiEntry &amp;&amp; WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(keyPath))
480         return Exception { InvalidAccessError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The keyPath argument was an array and the multiEntry option is true.&quot;_s };
481 
482     // Install the new Index into the ObjectStore&#39;s info.
<span class="line-modified">483     IDBIndexInfo info = m_info.createNewIndex(name, WTFMove(keyPath), parameters.unique, parameters.multiEntry);</span>
484     m_transaction.database().didCreateIndexInfo(info);
485 
486     // Create the actual IDBObjectStore from the transaction, which also schedules the operation server side.
487     auto index = m_transaction.createIndex(*this, info);
488 
489     Ref&lt;IDBIndex&gt; referencedIndex { *index };
490 
491     Locker&lt;Lock&gt; locker(m_referencedIndexLock);
492     m_referencedIndexes.set(name, WTFMove(index));
493 
494     return referencedIndex;
495 }
496 
497 ExceptionOr&lt;Ref&lt;IDBIndex&gt;&gt; IDBObjectStore::index(const String&amp; indexName)
498 {
499     LOG(IndexedDB, &quot;IDBObjectStore::index&quot;);
<span class="line-modified">500     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
501 
502     if (!scriptExecutionContext())
503         return Exception { InvalidStateError }; // FIXME: Is this code tested? Is iteven reachable?
504 
505     if (m_deleted)
506         return Exception { InvalidStateError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
507 
508     if (m_transaction.isFinishedOrFinishing())
509         return Exception { InvalidStateError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The transaction is finished.&quot;_s };
510 
511     Locker&lt;Lock&gt; locker(m_referencedIndexLock);
512     auto iterator = m_referencedIndexes.find(indexName);
513     if (iterator != m_referencedIndexes.end())
514         return Ref&lt;IDBIndex&gt; { *iterator-&gt;value };
515 
516     auto* info = m_info.infoForExistingIndex(indexName);
517     if (!info)
518         return Exception { NotFoundError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The specified index was not found.&quot;_s };
519 
520     auto index = makeUnique&lt;IDBIndex&gt;(*scriptExecutionContext(), *info, *this);
521 
522     Ref&lt;IDBIndex&gt; referencedIndex { *index };
523 
524     m_referencedIndexes.set(indexName, WTFMove(index));
525 
526     return referencedIndex;
527 }
528 
529 ExceptionOr&lt;void&gt; IDBObjectStore::deleteIndex(const String&amp; name)
530 {
531     LOG(IndexedDB, &quot;IDBObjectStore::deleteIndex %s&quot;, name.utf8().data());
<span class="line-modified">532     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
533 
534     if (m_deleted)
535         return Exception { InvalidStateError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
536 
537     if (!m_transaction.isVersionChange())
538         return Exception { InvalidStateError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The database is not running a version change transaction.&quot;_s };
539 
540     if (!m_transaction.isActive())
541         return Exception { TransactionInactiveError,  &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
542 
543     if (!m_info.hasIndex(name))
544         return Exception { NotFoundError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The specified index was not found.&quot;_s };
545 
546     auto* info = m_info.infoForExistingIndex(name);
547     ASSERT(info);
548     m_transaction.database().didDeleteIndexInfo(*info);
549 
550     m_info.deleteIndex(name);
551 
552     {
553         Locker&lt;Lock&gt; locker(m_referencedIndexLock);
554         if (auto index = m_referencedIndexes.take(name)) {
555             index-&gt;markAsDeleted();
556             auto identifier = index-&gt;info().identifier();
557             m_deletedIndexes.add(identifier, WTFMove(index));
558         }
559     }
560 
561     m_transaction.deleteIndex(m_info.identifier(), name);
562 
563     return { };
564 }
565 
<span class="line-modified">566 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(ExecState&amp; execState, JSValue key)</span>
567 {
568     LOG(IndexedDB, &quot;IDBObjectStore::count&quot;);
569 
570     auto idbKey = scriptValueToIDBKey(execState, key);
571 
572     return doCount(execState, IDBKeyRangeData(idbKey-&gt;isValid() ? idbKey.ptr() : nullptr));
573 }
574 
<span class="line-modified">575 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(ExecState&amp; execState, IDBKeyRange* range)</span>
576 {
577     LOG(IndexedDB, &quot;IDBObjectStore::count&quot;);
578 
579     return doCount(execState, range ? IDBKeyRangeData(range) : IDBKeyRangeData::allKeys());
580 }
581 
<span class="line-modified">582 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doCount(ExecState&amp; execState, const IDBKeyRangeData&amp; range)</span>
583 {
<span class="line-modified">584     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
585 
586     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
587     // the exception for an object store being deleted.
588     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
589     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
590     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
591     if (m_deleted)
592         return Exception { InvalidStateError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
593 
594     if (!m_transaction.isActive())
595         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
596 
597     if (!range.isValid())
598         return Exception { DataError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
599 
600     return m_transaction.requestCount(execState, *this, range);
601 }
602 
<span class="line-modified">603 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doGetAll(ExecState&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
604 {
605     LOG(IndexedDB, &quot;IDBObjectStore::getAll&quot;);
<span class="line-modified">606     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
607 
608     if (m_deleted)
609         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
610 
611     if (!m_transaction.isActive())
612         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
613 
614     auto keyRange = function();
615     if (keyRange.hasException())
616         return keyRange.releaseException();
617 
618     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
619     return m_transaction.requestGetAllObjectStoreRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Values, count);
620 }
621 
<span class="line-modified">622 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
623 {
624     return doGetAll(execState, count, [range = WTFMove(range)]() {
625         return range;
626     });
627 }
628 
<span class="line-modified">629 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
630 {
631     return doGetAll(execState, count, [state=&amp;execState, key]() {
632         auto onlyResult = IDBKeyRange::only(*state, key);
633         if (onlyResult.hasException())
634             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
635 
636         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
637     });
638 }
639 
<span class="line-modified">640 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doGetAllKeys(ExecState&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
641 {
642     LOG(IndexedDB, &quot;IDBObjectStore::getAllKeys&quot;);
<span class="line-modified">643     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
644 
645     if (m_deleted)
646         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
647 
648     if (!m_transaction.isActive())
649         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
650 
651     auto keyRange = function();
652     if (keyRange.hasException())
653         return keyRange.releaseException();
654 
655     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
656     return m_transaction.requestGetAllObjectStoreRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Keys, count);
657 }
658 
<span class="line-modified">659 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
660 {
661     return doGetAllKeys(execState, count, [range = WTFMove(range)]() {
662         return range;
663     });
664 }
665 
<span class="line-modified">666 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
667 {
668     return doGetAllKeys(execState, count, [state=&amp;execState, key]() {
669         auto onlyResult = IDBKeyRange::only(*state, key);
670         if (onlyResult.hasException())
671             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
672 
673         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
674     });
675 }
676 
677 void IDBObjectStore::markAsDeleted()
678 {
<span class="line-modified">679     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
680     m_deleted = true;
681 }
682 
683 void IDBObjectStore::rollbackForVersionChangeAbort()
684 {
<span class="line-modified">685     ASSERT(&amp;m_transaction.database().originThread() == &amp;Thread::current());</span>
686 
687     String currentName = m_info.name();
688     m_info = m_originalInfo;
689 
690     auto&amp; databaseInfo = transaction().database().info();
691     auto* objectStoreInfo = databaseInfo.infoForExistingObjectStore(m_info.identifier());
692     if (!objectStoreInfo) {
693         m_info.rename(currentName);
694         m_deleted = true;
695     } else {
696         m_deleted = false;
697 
698         HashSet&lt;uint64_t&gt; indexesToRemove;
699         for (auto indexIdentifier : objectStoreInfo-&gt;indexMap().keys()) {
700             if (!objectStoreInfo-&gt;hasIndex(indexIdentifier))
701                 indexesToRemove.add(indexIdentifier);
702         }
703 
704         for (auto indexIdentifier : indexesToRemove)
705             m_info.deleteIndex(indexIdentifier);
</pre>
</td>
<td>
<hr />
<pre>
 43 #include &quot;IndexedDB.h&quot;
 44 #include &quot;Logging.h&quot;
 45 #include &quot;Page.h&quot;
 46 #include &quot;ScriptExecutionContext.h&quot;
 47 #include &quot;ScriptState.h&quot;
 48 #include &quot;SerializedScriptValue.h&quot;
 49 #include &lt;JavaScriptCore/CatchScope.h&gt;
 50 #include &lt;JavaScriptCore/HeapInlines.h&gt;
 51 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
 52 #include &lt;wtf/Locker.h&gt;
 53 
 54 namespace WebCore {
 55 using namespace JSC;
 56 
 57 IDBObjectStore::IDBObjectStore(ScriptExecutionContext&amp; context, const IDBObjectStoreInfo&amp; info, IDBTransaction&amp; transaction)
 58     : ActiveDOMObject(&amp;context)
 59     , m_info(info)
 60     , m_originalInfo(info)
 61     , m_transaction(transaction)
 62 {
<span class="line-modified"> 63     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
 64 
 65     suspendIfNeeded();
 66 }
 67 
 68 IDBObjectStore::~IDBObjectStore()
 69 {
<span class="line-modified"> 70     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
 71 }
 72 
 73 const char* IDBObjectStore::activeDOMObjectName() const
 74 {
 75     return &quot;IDBObjectStore&quot;;
 76 }
 77 





 78 bool IDBObjectStore::hasPendingActivity() const
 79 {
 80     return m_transaction.hasPendingActivity();
 81 }
 82 
 83 const String&amp; IDBObjectStore::name() const
 84 {
<span class="line-modified"> 85     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
 86     return m_info.name();
 87 }
 88 
 89 ExceptionOr&lt;void&gt; IDBObjectStore::setName(const String&amp; name)
 90 {
<span class="line-modified"> 91     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
 92 
 93     if (m_deleted)
 94         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
 95 
 96     if (!m_transaction.isVersionChange())
 97         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBObjectStore&#39;: The object store&#39;s transaction is not a version change transaction.&quot;_s };
 98 
 99     if (!m_transaction.isActive())
100         return Exception { TransactionInactiveError, &quot;Failed set property &#39;name&#39; on &#39;IDBObjectStore&#39;: The object store&#39;s transaction is not active.&quot;_s };
101 
102     if (m_info.name() == name)
103         return { };
104 
105     if (m_transaction.database().info().hasObjectStore(name))
106         return Exception { ConstraintError, makeString(&quot;Failed set property &#39;name&#39; on &#39;IDBObjectStore&#39;: The database already has an object store named &#39;&quot;, name, &quot;&#39;.&quot;) };
107 
108     m_transaction.database().renameObjectStore(*this, name);
109     m_info.rename(name);
110 
111     return { };
112 }
113 
114 const Optional&lt;IDBKeyPath&gt;&amp; IDBObjectStore::keyPath() const
115 {
<span class="line-modified">116     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
117     return m_info.keyPath();
118 }
119 
120 Ref&lt;DOMStringList&gt; IDBObjectStore::indexNames() const
121 {
<span class="line-modified">122     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
123 
124     auto indexNames = DOMStringList::create();
125 
126     if (!m_deleted) {
127         for (auto&amp; name : m_info.indexNames())
128             indexNames-&gt;append(name);
129         indexNames-&gt;sort();
130     }
131 
132     return indexNames;
133 }
134 
135 IDBTransaction&amp; IDBObjectStore::transaction()
136 {
<span class="line-modified">137     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
138     return m_transaction;
139 }
140 
141 bool IDBObjectStore::autoIncrement() const
142 {
<span class="line-modified">143     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
144     return m_info.autoIncrement();
145 }
146 
<span class="line-modified">147 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doOpenCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
148 {
149     LOG(IndexedDB, &quot;IDBObjectStore::openCursor&quot;);
<span class="line-modified">150     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
151 
152     if (m_deleted)
153         return Exception { InvalidStateError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
154 
155     if (!m_transaction.isActive())
156         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
157 
158     auto keyRange = function();
159     if (keyRange.hasException())
160         return keyRange.releaseException();
161     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
162 
163     auto info = IDBCursorInfo::objectStoreCursor(m_transaction, m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyAndValue);
164     return m_transaction.requestOpenCursor(execState, *this, info);
165 }
166 
<span class="line-modified">167 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
168 {
169     return doOpenCursor(execState, direction, [range = WTFMove(range)]() {
170         return range;
171     });
172 }
173 
<span class="line-modified">174 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)</span>
175 {
176     return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
177         auto onlyResult = IDBKeyRange::only(*state, key);
178         if (onlyResult.hasException())
179             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
180 
181         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
182     });
183 }
184 
<span class="line-modified">185 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doOpenKeyCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
186 {
187     LOG(IndexedDB, &quot;IDBObjectStore::openKeyCursor&quot;);
<span class="line-modified">188     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
189 
190     if (m_deleted)
191         return Exception { InvalidStateError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
192 
193     if (!m_transaction.isActive())
194         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
195 
196     auto keyRange = function();
197     if (keyRange.hasException())
198         return keyRange.releaseException();
199 
200     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
201     auto info = IDBCursorInfo::objectStoreCursor(m_transaction, m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyOnly);
202     return m_transaction.requestOpenCursor(execState, *this, info);
203 }
204 
<span class="line-modified">205 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
206 {
207     return doOpenKeyCursor(execState, direction, [range = WTFMove(range)]() {
208         return range;
209     });
210 }
211 
<span class="line-modified">212 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)</span>
213 {
214     return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
215         auto onlyResult = IDBKeyRange::only(*state, key);
216         if (onlyResult.hasException())
217             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
218 
219         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
220     });
221 }
222 
<span class="line-modified">223 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::get(JSGlobalObject&amp; execState, JSValue key)</span>
224 {
225     LOG(IndexedDB, &quot;IDBObjectStore::get&quot;);
<span class="line-modified">226     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
227 
228     if (m_deleted)
229         return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
230 
231     if (!m_transaction.isActive())
232         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
233 
234     auto idbKey = scriptValueToIDBKey(execState, key);
235     if (!idbKey-&gt;isValid())
236         return Exception { DataError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
237 
238     return m_transaction.requestGetRecord(execState, *this, { idbKey.ptr(), IDBGetRecordDataType::KeyAndValue });
239 }
240 
<span class="line-modified">241 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::get(JSGlobalObject&amp; execState, IDBKeyRange* keyRange)</span>
242 {
243     LOG(IndexedDB, &quot;IDBObjectStore::get&quot;);
<span class="line-modified">244     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
245 
246     if (m_deleted)
247         return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
248 
249     if (!m_transaction.isActive())
250         return Exception { TransactionInactiveError };
251 
252     IDBKeyRangeData keyRangeData(keyRange);
253     if (!keyRangeData.isValid())
254         return Exception { DataError };
255 
256     return m_transaction.requestGetRecord(execState, *this, { keyRangeData, IDBGetRecordDataType::KeyAndValue });
257 }
258 
<span class="line-modified">259 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getKey(JSGlobalObject&amp; execState, JSValue key)</span>
260 {
261     LOG(IndexedDB, &quot;IDBObjectStore::getKey&quot;);
<span class="line-modified">262     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
263 
264     if (m_deleted)
265         return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
266 
267     if (!m_transaction.isActive())
268         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
269 
270     auto idbKey = scriptValueToIDBKey(execState, key);
271     if (!idbKey-&gt;isValid())
272         return Exception { DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
273 
274     return m_transaction.requestGetRecord(execState, *this, { idbKey.ptr(), IDBGetRecordDataType::KeyOnly });
275 }
276 
<span class="line-modified">277 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getKey(JSGlobalObject&amp; execState, IDBKeyRange* keyRange)</span>
278 {
279     LOG(IndexedDB, &quot;IDBObjectStore::getKey&quot;);
<span class="line-modified">280     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
281 
282     if (m_deleted)
283         return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
284 
285     if (!m_transaction.isActive())
286         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
287 
288     IDBKeyRangeData keyRangeData(keyRange);
289     if (!keyRangeData.isValid())
290         return Exception { DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key range.&quot;_s };
291 
292     return m_transaction.requestGetRecord(execState, *this, { keyRangeData, IDBGetRecordDataType::KeyOnly });
293 }
294 
<span class="line-modified">295 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::add(JSGlobalObject&amp; execState, JSValue value, JSValue key)</span>
296 {
297     RefPtr&lt;IDBKey&gt; idbKey;
298     if (!key.isUndefined())
299         idbKey = scriptValueToIDBKey(execState, key);
300     return putOrAdd(execState, value, idbKey, IndexedDB::ObjectStoreOverwriteMode::NoOverwrite, InlineKeyCheck::Perform);
301 }
302 
<span class="line-modified">303 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::put(JSGlobalObject&amp; execState, JSValue value, JSValue key)</span>
304 {
305     RefPtr&lt;IDBKey&gt; idbKey;
306     if (!key.isUndefined())
307         idbKey = scriptValueToIDBKey(execState, key);
308     return putOrAdd(execState, value, idbKey, IndexedDB::ObjectStoreOverwriteMode::Overwrite, InlineKeyCheck::Perform);
309 }
310 
<span class="line-modified">311 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::putForCursorUpdate(JSGlobalObject&amp; state, JSValue value, RefPtr&lt;IDBKey&gt; key)</span>
312 {
313     return putOrAdd(state, value, WTFMove(key), IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor, InlineKeyCheck::DoNotPerform);
314 }
315 
<span class="line-modified">316 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::putOrAdd(JSGlobalObject&amp; state, JSValue value, RefPtr&lt;IDBKey&gt; key, IndexedDB::ObjectStoreOverwriteMode overwriteMode, InlineKeyCheck inlineKeyCheck)</span>
317 {
318     VM&amp; vm = state.vm();
319     auto scope = DECLARE_CATCH_SCOPE(vm);
320 
321     LOG(IndexedDB, &quot;IDBObjectStore::putOrAdd&quot;);
<span class="line-modified">322     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
323 
324     auto context = scriptExecutionContextFromExecState(&amp;state);
325     if (!context)
326         return Exception { UnknownError, &quot;Unable to store record in object store because it does not have a valid script execution context&quot;_s };
327 
328     if (m_deleted)
329         return Exception { InvalidStateError, &quot;Failed to store record in an IDBObjectStore: The object store has been deleted.&quot;_s };
330 
331     if (!m_transaction.isActive())
332         return Exception { TransactionInactiveError, &quot;Failed to store record in an IDBObjectStore: The transaction is inactive or finished.&quot;_s };
333 
334     if (m_transaction.isReadOnly())
335         return Exception { ReadonlyError, &quot;Failed to store record in an IDBObjectStore: The transaction is read-only.&quot;_s };
336 
337     auto serializedValue = SerializedScriptValue::create(state, value);
338     if (UNLIKELY(scope.exception()))
339         return Exception { DataCloneError, &quot;Failed to store record in an IDBObjectStore: An object could not be cloned.&quot;_s };
340 
341     bool privateBrowsingEnabled = false;
342     if (is&lt;Document&gt;(*context)) {
</pre>
<hr />
<pre>
362         if (keyPathKey &amp;&amp; !keyPathKey-&gt;isValid())
363             return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: Evaluating the object store&#39;s key path yielded a value that is not a valid key.&quot;_s };
364 
365         if (!keyPathKey) {
366             if (!usesKeyGenerator)
367                 return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: Evaluating the object store&#39;s key path did not yield a value.&quot;_s };
368             if (!canInjectIDBKeyIntoScriptValue(state, value, m_info.keyPath().value()))
369                 return Exception { DataError };
370         }
371 
372         if (keyPathKey) {
373             ASSERT(!key);
374             key = keyPathKey;
375         }
376     } else if (!usesKeyGenerator &amp;&amp; !key)
377         return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: The object store uses out-of-line keys and has no key generator and the key parameter was not provided.&quot;_s };
378 
379     return m_transaction.requestPutOrAdd(state, *this, WTFMove(key), *serializedValue, overwriteMode);
380 }
381 
<span class="line-modified">382 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(JSGlobalObject&amp; execState, IDBKeyRange* keyRange)</span>
383 {
384     return doDelete(execState, [keyRange]() {
385         return makeRefPtr(keyRange);
386     });
387 }
388 
<span class="line-modified">389 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doDelete(JSGlobalObject&amp; execState, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
390 {
391     LOG(IndexedDB, &quot;IDBObjectStore::deleteFunction&quot;);
<span class="line-modified">392     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
393 
394     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
395     // the exception for an object store being deleted.
396     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
397     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
398     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
399     if (m_deleted)
400         return Exception { InvalidStateError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
401 
402     if (!m_transaction.isActive())
403         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
404 
405     if (m_transaction.isReadOnly())
406         return Exception { ReadonlyError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The transaction is read-only.&quot;_s };
407 
408     auto keyRange = function();
409     if (keyRange.hasException())
410         return keyRange.releaseException();
411 
412     IDBKeyRangeData keyRangeData = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
413     if (!keyRangeData.isValid())
414         return Exception { DataError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key range.&quot;_s };
415 
416     return m_transaction.requestDeleteRecord(execState, *this, keyRangeData);
417 }
418 
<span class="line-modified">419 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(JSGlobalObject&amp; execState, JSValue key)</span>
420 {
421     return doDelete(execState, [state=&amp;execState, key]() {
422         auto idbKey = scriptValueToIDBKey(*state, key);
423         if (!idbKey-&gt;isValid())
424             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
425         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { (IDBKeyRange::create(WTFMove(idbKey))).ptr() };
426     });
427 }
428 
<span class="line-modified">429 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::clear(JSGlobalObject&amp; execState)</span>
430 {
431     LOG(IndexedDB, &quot;IDBObjectStore::clear&quot;);
<span class="line-modified">432     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
433 
434     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
435     // the exception for an object store being deleted.
436     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
437     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
438     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
439     if (m_deleted)
440         return Exception { InvalidStateError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
441 
442     if (!m_transaction.isActive())
443         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
444 
445     if (m_transaction.isReadOnly())
446         return Exception { ReadonlyError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The transaction is read-only.&quot;_s };
447 
448     return m_transaction.requestClearObjectStore(execState, *this);
449 }
450 
<span class="line-modified">451 ExceptionOr&lt;Ref&lt;IDBIndex&gt;&gt; IDBObjectStore::createIndex(JSGlobalObject&amp;, const String&amp; name, IDBKeyPath&amp;&amp; keyPath, const IndexParameters&amp; parameters)</span>
452 {
453     LOG(IndexedDB, &quot;IDBObjectStore::createIndex %s (keyPath: %s, unique: %i, multiEntry: %i)&quot;, name.utf8().data(), loggingString(keyPath).utf8().data(), parameters.unique, parameters.multiEntry);
<span class="line-modified">454     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
455 
456     if (!m_transaction.isVersionChange())
457         return Exception { InvalidStateError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The database is not running a version change transaction.&quot;_s };
458 
459     if (m_deleted)
460         return Exception { InvalidStateError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
461 
462     if (!m_transaction.isActive())
463         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive.&quot;_s};
464 
465     if (m_info.hasIndex(name))
466         return Exception { ConstraintError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: An index with the specified name already exists.&quot;_s };
467 
468     if (!isIDBKeyPathValid(keyPath))
469         return Exception { SyntaxError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The keyPath argument contains an invalid key path.&quot;_s };
470 
471     if (name.isNull())
472         return Exception { TypeError };
473 
474     if (parameters.multiEntry &amp;&amp; WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(keyPath))
475         return Exception { InvalidAccessError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The keyPath argument was an array and the multiEntry option is true.&quot;_s };
476 
477     // Install the new Index into the ObjectStore&#39;s info.
<span class="line-modified">478     IDBIndexInfo info = m_info.createNewIndex(m_transaction.database().info().generateNextIndexID(), name, WTFMove(keyPath), parameters.unique, parameters.multiEntry);</span>
479     m_transaction.database().didCreateIndexInfo(info);
480 
481     // Create the actual IDBObjectStore from the transaction, which also schedules the operation server side.
482     auto index = m_transaction.createIndex(*this, info);
483 
484     Ref&lt;IDBIndex&gt; referencedIndex { *index };
485 
486     Locker&lt;Lock&gt; locker(m_referencedIndexLock);
487     m_referencedIndexes.set(name, WTFMove(index));
488 
489     return referencedIndex;
490 }
491 
492 ExceptionOr&lt;Ref&lt;IDBIndex&gt;&gt; IDBObjectStore::index(const String&amp; indexName)
493 {
494     LOG(IndexedDB, &quot;IDBObjectStore::index&quot;);
<span class="line-modified">495     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
496 
497     if (!scriptExecutionContext())
498         return Exception { InvalidStateError }; // FIXME: Is this code tested? Is iteven reachable?
499 
500     if (m_deleted)
501         return Exception { InvalidStateError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
502 
503     if (m_transaction.isFinishedOrFinishing())
504         return Exception { InvalidStateError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The transaction is finished.&quot;_s };
505 
506     Locker&lt;Lock&gt; locker(m_referencedIndexLock);
507     auto iterator = m_referencedIndexes.find(indexName);
508     if (iterator != m_referencedIndexes.end())
509         return Ref&lt;IDBIndex&gt; { *iterator-&gt;value };
510 
511     auto* info = m_info.infoForExistingIndex(indexName);
512     if (!info)
513         return Exception { NotFoundError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The specified index was not found.&quot;_s };
514 
515     auto index = makeUnique&lt;IDBIndex&gt;(*scriptExecutionContext(), *info, *this);
516 
517     Ref&lt;IDBIndex&gt; referencedIndex { *index };
518 
519     m_referencedIndexes.set(indexName, WTFMove(index));
520 
521     return referencedIndex;
522 }
523 
524 ExceptionOr&lt;void&gt; IDBObjectStore::deleteIndex(const String&amp; name)
525 {
526     LOG(IndexedDB, &quot;IDBObjectStore::deleteIndex %s&quot;, name.utf8().data());
<span class="line-modified">527     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
528 
529     if (m_deleted)
530         return Exception { InvalidStateError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
531 
532     if (!m_transaction.isVersionChange())
533         return Exception { InvalidStateError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The database is not running a version change transaction.&quot;_s };
534 
535     if (!m_transaction.isActive())
536         return Exception { TransactionInactiveError,  &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
537 
538     if (!m_info.hasIndex(name))
539         return Exception { NotFoundError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The specified index was not found.&quot;_s };
540 
541     auto* info = m_info.infoForExistingIndex(name);
542     ASSERT(info);
543     m_transaction.database().didDeleteIndexInfo(*info);
544 
545     m_info.deleteIndex(name);
546 
547     {
548         Locker&lt;Lock&gt; locker(m_referencedIndexLock);
549         if (auto index = m_referencedIndexes.take(name)) {
550             index-&gt;markAsDeleted();
551             auto identifier = index-&gt;info().identifier();
552             m_deletedIndexes.add(identifier, WTFMove(index));
553         }
554     }
555 
556     m_transaction.deleteIndex(m_info.identifier(), name);
557 
558     return { };
559 }
560 
<span class="line-modified">561 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(JSGlobalObject&amp; execState, JSValue key)</span>
562 {
563     LOG(IndexedDB, &quot;IDBObjectStore::count&quot;);
564 
565     auto idbKey = scriptValueToIDBKey(execState, key);
566 
567     return doCount(execState, IDBKeyRangeData(idbKey-&gt;isValid() ? idbKey.ptr() : nullptr));
568 }
569 
<span class="line-modified">570 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(JSGlobalObject&amp; execState, IDBKeyRange* range)</span>
571 {
572     LOG(IndexedDB, &quot;IDBObjectStore::count&quot;);
573 
574     return doCount(execState, range ? IDBKeyRangeData(range) : IDBKeyRangeData::allKeys());
575 }
576 
<span class="line-modified">577 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doCount(JSGlobalObject&amp; execState, const IDBKeyRangeData&amp; range)</span>
578 {
<span class="line-modified">579     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
580 
581     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
582     // the exception for an object store being deleted.
583     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
584     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
585     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
586     if (m_deleted)
587         return Exception { InvalidStateError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
588 
589     if (!m_transaction.isActive())
590         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
591 
592     if (!range.isValid())
593         return Exception { DataError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
594 
595     return m_transaction.requestCount(execState, *this, range);
596 }
597 
<span class="line-modified">598 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doGetAll(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
599 {
600     LOG(IndexedDB, &quot;IDBObjectStore::getAll&quot;);
<span class="line-modified">601     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
602 
603     if (m_deleted)
604         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
605 
606     if (!m_transaction.isActive())
607         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
608 
609     auto keyRange = function();
610     if (keyRange.hasException())
611         return keyRange.releaseException();
612 
613     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
614     return m_transaction.requestGetAllObjectStoreRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Values, count);
615 }
616 
<span class="line-modified">617 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
618 {
619     return doGetAll(execState, count, [range = WTFMove(range)]() {
620         return range;
621     });
622 }
623 
<span class="line-modified">624 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
625 {
626     return doGetAll(execState, count, [state=&amp;execState, key]() {
627         auto onlyResult = IDBKeyRange::only(*state, key);
628         if (onlyResult.hasException())
629             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
630 
631         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
632     });
633 }
634 
<span class="line-modified">635 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doGetAllKeys(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
636 {
637     LOG(IndexedDB, &quot;IDBObjectStore::getAllKeys&quot;);
<span class="line-modified">638     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
639 
640     if (m_deleted)
641         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
642 
643     if (!m_transaction.isActive())
644         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
645 
646     auto keyRange = function();
647     if (keyRange.hasException())
648         return keyRange.releaseException();
649 
650     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
651     return m_transaction.requestGetAllObjectStoreRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Keys, count);
652 }
653 
<span class="line-modified">654 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
655 {
656     return doGetAllKeys(execState, count, [range = WTFMove(range)]() {
657         return range;
658     });
659 }
660 
<span class="line-modified">661 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
662 {
663     return doGetAllKeys(execState, count, [state=&amp;execState, key]() {
664         auto onlyResult = IDBKeyRange::only(*state, key);
665         if (onlyResult.hasException())
666             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
667 
668         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
669     });
670 }
671 
672 void IDBObjectStore::markAsDeleted()
673 {
<span class="line-modified">674     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
675     m_deleted = true;
676 }
677 
678 void IDBObjectStore::rollbackForVersionChangeAbort()
679 {
<span class="line-modified">680     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
681 
682     String currentName = m_info.name();
683     m_info = m_originalInfo;
684 
685     auto&amp; databaseInfo = transaction().database().info();
686     auto* objectStoreInfo = databaseInfo.infoForExistingObjectStore(m_info.identifier());
687     if (!objectStoreInfo) {
688         m_info.rename(currentName);
689         m_deleted = true;
690     } else {
691         m_deleted = false;
692 
693         HashSet&lt;uint64_t&gt; indexesToRemove;
694         for (auto indexIdentifier : objectStoreInfo-&gt;indexMap().keys()) {
695             if (!objectStoreInfo-&gt;hasIndex(indexIdentifier))
696                 indexesToRemove.add(indexIdentifier);
697         }
698 
699         for (auto indexIdentifier : indexesToRemove)
700             m_info.deleteIndex(indexIdentifier);
</pre>
</td>
</tr>
</table>
<center><a href="IDBKeyRangeData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBObjectStore.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
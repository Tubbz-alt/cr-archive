<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/SelectorQuery.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SecurityPolicyViolationEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorQuery.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/SelectorQuery.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,21 ***</span>
  #include &quot;StaticNodeList.h&quot;
  #include &quot;StyledElement.h&quot;
  
  namespace WebCore {
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  static bool isSingleTagNameSelector(const CSSSelector&amp; selector)
  {
      return selector.isLastInTagHistory() &amp;&amp; selector.match() == CSSSelector::Tag;
  }
  
  static bool isSingleClassNameSelector(const CSSSelector&amp; selector)
  {
      return selector.isLastInTagHistory() &amp;&amp; selector.match() == CSSSelector::Class;
  }
<span class="line-modified">! #endif</span>
  
  enum class IdMatchingType : uint8_t {
      None,
      Rightmost,
      Filter
<span class="line-new-header">--- 34,21 ---</span>
  #include &quot;StaticNodeList.h&quot;
  #include &quot;StyledElement.h&quot;
  
  namespace WebCore {
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  static bool isSingleTagNameSelector(const CSSSelector&amp; selector)
  {
      return selector.isLastInTagHistory() &amp;&amp; selector.match() == CSSSelector::Tag;
  }
  
  static bool isSingleClassNameSelector(const CSSSelector&amp; selector)
  {
      return selector.isLastInTagHistory() &amp;&amp; selector.match() == CSSSelector::Class;
  }
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
  enum class IdMatchingType : uint8_t {
      None,
      Rightmost,
      Filter
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,11 ***</span>
      for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
          selectorCount++;
  
      m_selectors.reserveInitialCapacity(selectorCount);
      for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
<span class="line-modified">!         m_selectors.uncheckedAppend(SelectorData(selector));</span>
  
      if (selectorCount == 1) {
          const CSSSelector&amp; selector = *m_selectors.first().selector;
          if (selector.isLastInTagHistory()) {
              switch (selector.match()) {
<span class="line-new-header">--- 81,11 ---</span>
      for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
          selectorCount++;
  
      m_selectors.reserveInitialCapacity(selectorCount);
      for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
<span class="line-modified">!         m_selectors.uncheckedAppend({ selector });</span>
  
      if (selectorCount == 1) {
          const CSSSelector&amp; selector = *m_selectors.first().selector;
          if (selector.isLastInTagHistory()) {
              switch (selector.match()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 403,15 ***</span>
  #if ENABLE(CSS_SELECTOR_JIT)
  template &lt;typename SelectorQueryTrait&gt;
  ALWAYS_INLINE void SelectorDataList::executeCompiledSimpleSelectorChecker(const ContainerNode&amp; searchRootNode, SelectorCompiler::QuerySelectorSimpleSelectorChecker selectorChecker, typename SelectorQueryTrait::OutputType&amp; output, const SelectorData&amp; selectorData) const
  {
      for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(searchRootNode))) {
<span class="line-modified">! #if CSS_SELECTOR_JIT_PROFILING</span>
<span class="line-modified">!         selectorData.compiledSelectorUsed();</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-         UNUSED_PARAM(selectorData);</span>
<span class="line-removed">- #endif</span>
          if (selectorChecker(&amp;element)) {
              SelectorQueryTrait::appendOutputForElement(output, &amp;element);
              if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
                  return;
          }
<span class="line-new-header">--- 403,12 ---</span>
  #if ENABLE(CSS_SELECTOR_JIT)
  template &lt;typename SelectorQueryTrait&gt;
  ALWAYS_INLINE void SelectorDataList::executeCompiledSimpleSelectorChecker(const ContainerNode&amp; searchRootNode, SelectorCompiler::QuerySelectorSimpleSelectorChecker selectorChecker, typename SelectorQueryTrait::OutputType&amp; output, const SelectorData&amp; selectorData) const
  {
      for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(searchRootNode))) {
<span class="line-modified">!         selectorData.compiledSelector.wasUsed();</span>
<span class="line-modified">! </span>
          if (selectorChecker(&amp;element)) {
              SelectorQueryTrait::appendOutputForElement(output, &amp;element);
              if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
                  return;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 423,15 ***</span>
  {
      SelectorChecker::CheckingContext checkingContext(SelectorChecker::Mode::QueryingRules);
      checkingContext.scope = rootNode.isDocumentNode() ? nullptr : &amp;rootNode;
  
      for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(searchRootNode))) {
<span class="line-modified">! #if CSS_SELECTOR_JIT_PROFILING</span>
<span class="line-modified">!         selectorData.compiledSelectorUsed();</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-         UNUSED_PARAM(selectorData);</span>
<span class="line-removed">- #endif</span>
          if (selectorChecker(&amp;element, &amp;checkingContext)) {
              SelectorQueryTrait::appendOutputForElement(output, &amp;element);
              if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
                  return;
          }
<span class="line-new-header">--- 420,12 ---</span>
  {
      SelectorChecker::CheckingContext checkingContext(SelectorChecker::Mode::QueryingRules);
      checkingContext.scope = rootNode.isDocumentNode() ? nullptr : &amp;rootNode;
  
      for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(searchRootNode))) {
<span class="line-modified">!         selectorData.compiledSelector.wasUsed();</span>
<span class="line-modified">! </span>
          if (selectorChecker(&amp;element, &amp;checkingContext)) {
              SelectorQueryTrait::appendOutputForElement(output, &amp;element);
              if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
                  return;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 443,21 ***</span>
  {
      SelectorChecker::CheckingContext checkingContext(SelectorChecker::Mode::QueryingRules);
      checkingContext.scope = rootNode.isDocumentNode() ? nullptr : &amp;rootNode;
      for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(rootNode))) {
          for (auto&amp; selector : m_selectors) {
<span class="line-modified">! #if CSS_SELECTOR_JIT_PROFILING</span>
<span class="line-modified">!             selector.compiledSelectorUsed();</span>
<span class="line-removed">- #endif</span>
              bool matched = false;
<span class="line-modified">!             void* compiledSelectorChecker = selector.compiledSelectorCodeRef.code().executableAddress();</span>
<span class="line-modified">!             if (selector.compilationStatus == SelectorCompilationStatus::SimpleSelectorChecker) {</span>
<span class="line-removed">-                 auto selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(compiledSelectorChecker, selector.compilationStatus);</span>
                  matched = selectorChecker(&amp;element);
              } else {
<span class="line-modified">!                 ASSERT(selector.compilationStatus == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);</span>
<span class="line-modified">!                 auto selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(compiledSelectorChecker, selector.compilationStatus);</span>
                  matched = selectorChecker(&amp;element, &amp;checkingContext);
              }
              if (matched) {
                  SelectorQueryTrait::appendOutputForElement(output, &amp;element);
                  if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
<span class="line-new-header">--- 437,19 ---</span>
  {
      SelectorChecker::CheckingContext checkingContext(SelectorChecker::Mode::QueryingRules);
      checkingContext.scope = rootNode.isDocumentNode() ? nullptr : &amp;rootNode;
      for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(rootNode))) {
          for (auto&amp; selector : m_selectors) {
<span class="line-modified">!             selector.compiledSelector.wasUsed();</span>
<span class="line-modified">! </span>
              bool matched = false;
<span class="line-modified">!             if (selector.compiledSelector.status == SelectorCompilationStatus::SimpleSelectorChecker) {</span>
<span class="line-modified">!                 auto selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(selector.compiledSelector);</span>
                  matched = selectorChecker(&amp;element);
              } else {
<span class="line-modified">!                 ASSERT(selector.compiledSelector.status == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);</span>
<span class="line-modified">!                 auto selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(selector.compiledSelector);</span>
                  matched = selectorChecker(&amp;element, &amp;checkingContext);
              }
              if (matched) {
                  SelectorQueryTrait::appendOutputForElement(output, &amp;element);
                  if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 466,24 ***</span>
              }
          }
      }
  }
  
<span class="line-removed">- static bool isCompiledSelector(SelectorCompilationStatus compilationStatus)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return compilationStatus == SelectorCompilationStatus::SimpleSelectorChecker || compilationStatus == SelectorCompilationStatus::SelectorCheckerWithCheckingContext;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool SelectorDataList::compileSelector(const SelectorData&amp; selectorData)
  {
<span class="line-modified">!     if (selectorData.compilationStatus != SelectorCompilationStatus::NotCompiled)</span>
<span class="line-removed">-         return isCompiledSelector(selectorData.compilationStatus);</span>
  
<span class="line-modified">!     selectorData.compilationStatus = SelectorCompiler::compileSelector(selectorData.selector, SelectorCompiler::SelectorContext::QuerySelector, selectorData.compiledSelectorCodeRef);</span>
<span class="line-modified">!     return isCompiledSelector(selectorData.compilationStatus);</span>
<span class="line-removed">- }</span>
  
  
  #endif // ENABLE(CSS_SELECTOR_JIT)
  
  template &lt;typename SelectorQueryTrait&gt;
  ALWAYS_INLINE void SelectorDataList::execute(ContainerNode&amp; rootNode, typename SelectorQueryTrait::OutputType&amp; output) const
<span class="line-new-header">--- 458,19 ---</span>
              }
          }
      }
  }
  
  bool SelectorDataList::compileSelector(const SelectorData&amp; selectorData)
  {
<span class="line-modified">!     auto&amp; compiledSelector = selectorData.compiledSelector;</span>
  
<span class="line-modified">!     if (compiledSelector.status == SelectorCompilationStatus::NotCompiled)</span>
<span class="line-modified">!         SelectorCompiler::compileSelector(compiledSelector, selectorData.selector, SelectorCompiler::SelectorContext::QuerySelector);</span>
  
<span class="line-added">+     return compiledSelector.status != SelectorCompilationStatus::CannotCompile;</span>
<span class="line-added">+ }</span>
  
  #endif // ENABLE(CSS_SELECTOR_JIT)
  
  template &lt;typename SelectorQueryTrait&gt;
  ALWAYS_INLINE void SelectorDataList::execute(ContainerNode&amp; rootNode, typename SelectorQueryTrait::OutputType&amp; output) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 508,11 ***</span>
      case CompilableSingleWithRootFilter:
      case CompilableSingle:
          {
  #if ENABLE(CSS_SELECTOR_JIT)
          const SelectorData&amp; selectorData = m_selectors.first();
<span class="line-modified">!         ASSERT(selectorData.compilationStatus == SelectorCompilationStatus::NotCompiled);</span>
          ASSERT(m_matchType == CompilableSingle || m_matchType == CompilableSingleWithRootFilter);
          if (compileSelector(selectorData)) {
              if (m_matchType == CompilableSingle) {
                  m_matchType = CompiledSingle;
                  goto CompiledSingleCase;
<span class="line-new-header">--- 495,11 ---</span>
      case CompilableSingleWithRootFilter:
      case CompilableSingle:
          {
  #if ENABLE(CSS_SELECTOR_JIT)
          const SelectorData&amp; selectorData = m_selectors.first();
<span class="line-modified">!         ASSERT(selectorData.compiledSelector.status == SelectorCompilationStatus::NotCompiled);</span>
          ASSERT(m_matchType == CompilableSingle || m_matchType == CompilableSingleWithRootFilter);
          if (compileSelector(selectorData)) {
              if (m_matchType == CompilableSingle) {
                  m_matchType = CompiledSingle;
                  goto CompiledSingleCase;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 539,26 ***</span>
          FALLTHROUGH;
      case CompiledSingle:
          {
          CompiledSingleCase:
          const SelectorData&amp; selectorData = m_selectors.first();
<span class="line-modified">!         void* compiledSelectorChecker = selectorData.compiledSelectorCodeRef.code().executableAddress();</span>
<span class="line-modified">!         if (selectorData.compilationStatus == SelectorCompilationStatus::SimpleSelectorChecker) {</span>
<span class="line-removed">-             SelectorCompiler::QuerySelectorSimpleSelectorChecker selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(compiledSelectorChecker, selectorData.compilationStatus);</span>
              executeCompiledSimpleSelectorChecker&lt;SelectorQueryTrait&gt;(*searchRootNode, selectorChecker, output, selectorData);
          } else {
<span class="line-modified">!             ASSERT(selectorData.compilationStatus == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);</span>
<span class="line-modified">!             SelectorCompiler::QuerySelectorSelectorCheckerWithCheckingContext selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(compiledSelectorChecker, selectorData.compilationStatus);</span>
              executeCompiledSelectorCheckerWithCheckingContext&lt;SelectorQueryTrait&gt;(rootNode, *searchRootNode, selectorChecker, output, selectorData);
          }
          break;
          }
  #else
      case CompiledSingleWithRootFilter:
      case CompiledSingle:
          ASSERT_NOT_REACHED();
<span class="line-modified">! #if ASSERT_DISABLED</span>
          FALLTHROUGH;
  #endif
  #endif // ENABLE(CSS_SELECTOR_JIT)
  
      case SingleSelectorWithRootFilter:
<span class="line-new-header">--- 526,25 ---</span>
          FALLTHROUGH;
      case CompiledSingle:
          {
          CompiledSingleCase:
          const SelectorData&amp; selectorData = m_selectors.first();
<span class="line-modified">!         if (selectorData.compiledSelector.status == SelectorCompilationStatus::SimpleSelectorChecker) {</span>
<span class="line-modified">!             auto selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(selectorData.compiledSelector);</span>
              executeCompiledSimpleSelectorChecker&lt;SelectorQueryTrait&gt;(*searchRootNode, selectorChecker, output, selectorData);
          } else {
<span class="line-modified">!             ASSERT(selectorData.compiledSelector.status == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);</span>
<span class="line-modified">!             auto selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(selectorData.compiledSelector);</span>
              executeCompiledSelectorCheckerWithCheckingContext&lt;SelectorQueryTrait&gt;(rootNode, *searchRootNode, selectorChecker, output, selectorData);
          }
          break;
          }
  #else
      case CompiledSingleWithRootFilter:
      case CompiledSingle:
          ASSERT_NOT_REACHED();
<span class="line-modified">! #if !ASSERT_ENABLED</span>
          FALLTHROUGH;
  #endif
  #endif // ENABLE(CSS_SELECTOR_JIT)
  
      case SingleSelectorWithRootFilter:
</pre>
<center><a href="SecurityPolicyViolationEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorQuery.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
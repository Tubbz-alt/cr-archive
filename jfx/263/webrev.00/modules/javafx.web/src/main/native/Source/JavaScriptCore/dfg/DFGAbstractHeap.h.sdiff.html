<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractHeap.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGAbstractHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractInterpreter.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractHeap.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2016 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DOMJITHeapRange.h&quot;

 31 #include &quot;VirtualRegister.h&quot;
 32 #include &lt;wtf/HashMap.h&gt;
 33 #include &lt;wtf/PrintStream.h&gt;
 34 
 35 namespace JSC { namespace DFG {
 36 
 37 // Implements a four-level type hierarchy:
 38 // - World is the supertype of all of the things.
 39 // - Stack with a TOP payload is a direct subtype of World
 40 // - Stack with a non-TOP payload is a direct subtype of Stack with a TOP payload.
 41 // - Heap is a direct subtype of World.
 42 // - SideState is a direct subtype of World.
 43 // - Any other kind with TOP payload is the direct subtype of Heap.
 44 // - Any other kind with non-TOP payload is the direct subtype of the same kind with a TOP payload.
 45 
 46 #define FOR_EACH_ABSTRACT_HEAP_KIND(macro) \
 47     macro(InvalidAbstractHeap) \
 48     macro(World) \
 49     macro(Stack) \
 50     macro(Heap) \
 51     macro(Butterfly_publicLength) \
 52     macro(Butterfly_vectorLength) \
 53     macro(GetterSetter_getter) \
 54     macro(GetterSetter_setter) \
 55     macro(JSCell_cellState) \
 56     macro(JSCell_indexingType) \
 57     macro(JSCell_structureID) \
 58     macro(JSCell_typeInfoFlags) \
<span class="line-removed"> 59     macro(JSCell_typeInfoType) \</span>
 60     macro(JSObject_butterfly) \
 61     macro(JSPropertyNameEnumerator_cachedPropertyNames) \
 62     macro(RegExpObject_lastIndex) \
 63     macro(NamedProperties) \
 64     macro(IndexedInt32Properties) \
 65     macro(IndexedDoubleProperties) \
 66     macro(IndexedContiguousProperties) \
 67     macro(IndexedArrayStorageProperties) \
<span class="line-removed"> 68     macro(ArrayStorageProperties) \</span>
 69     macro(DirectArgumentsProperties) \
 70     macro(ScopeProperties) \
 71     macro(TypedArrayProperties) \
 72     macro(HeapObjectCount) /* Used to reflect the fact that some allocations reveal object identity */\
 73     macro(RegExpState) \
 74     macro(MathDotRandomState) \

 75     macro(JSMapFields) \
 76     macro(JSSetFields) \
 77     macro(JSWeakMapFields) \
 78     macro(JSWeakSetFields) \

 79     macro(InternalState) \
 80     macro(CatchLocals) \
 81     macro(Absolute) \
 82     /* DOMJIT tells the heap range with the pair of integers. */\
 83     macro(DOMState) \
 84     /* Use this for writes only, to indicate that this may fire watchpoints. Usually this is never directly written but instead we test to see if a node clobbers this; it just so happens that you have to write world to clobber it. */\
 85     macro(Watchpoint_fire) \
 86     /* Use these for reads only, just to indicate that if the world got clobbered, then this operation will not work. */\
 87     macro(MiscFields) \
 88     /* Use this for writes only, just to indicate that hoisting the node is invalid. This works because we don&#39;t hoist anything that has any side effects at all. */\
 89     macro(SideState)
 90 
 91 enum AbstractHeapKind {
 92 #define ABSTRACT_HEAP_DECLARATION(name) name,
 93     FOR_EACH_ABSTRACT_HEAP_KIND(ABSTRACT_HEAP_DECLARATION)
 94 #undef ABSTRACT_HEAP_DECLARATION
 95 };
 96 
 97 class AbstractHeap {
 98 public:
</pre>
<hr />
<pre>
106 
107         Payload(bool isTop, int64_t value)
108             : m_isTop(isTop)
109             , m_value(value)
110         {
111             ASSERT(!(isTop &amp;&amp; value));
112         }
113 
114         Payload(int64_t value)
115             : m_isTop(false)
116             , m_value(value)
117         {
118         }
119 
120         Payload(const void* pointer)
121             : m_isTop(false)
122             , m_value(bitwise_cast&lt;intptr_t&gt;(pointer))
123         {
124         }
125 
<span class="line-modified">126         Payload(VirtualRegister operand)</span>
127             : m_isTop(false)
<span class="line-modified">128             , m_value(operand.offset())</span>





129         {
130         }
131 
132         static Payload top() { return Payload(true, 0); }
133 
134         bool isTop() const { return m_isTop; }
135         int64_t value() const
136         {
137             ASSERT(!isTop());
138             return valueImpl();
139         }
140         int64_t valueImpl() const
141         {
142             return m_value;
143         }
144 
145         int32_t value32() const
146         {
147             return static_cast&lt;int32_t&gt;(value());
148         }
</pre>
<hr />
<pre>
165             if (other.isTop())
166                 return false;
167             return value() &lt; other.value();
168         }
169 
170         bool isDisjoint(const Payload&amp; other) const
171         {
172             if (isTop())
173                 return false;
174             if (other.isTop())
175                 return false;
176             return m_value != other.m_value;
177         }
178 
179         bool overlaps(const Payload&amp; other) const
180         {
181             return !isDisjoint(other);
182         }
183 
184         void dump(PrintStream&amp;) const;

185 
186     private:
187         bool m_isTop;
188         int64_t m_value;
189     };
190 
191     AbstractHeap()
192     {
193         m_value = encode(InvalidAbstractHeap, Payload());
194     }
195 
196     AbstractHeap(AbstractHeapKind kind)
197     {
198         ASSERT(kind != InvalidAbstractHeap);
199         m_value = encode(kind, Payload::top());
200     }
201 
202     AbstractHeap(AbstractHeapKind kind, Payload payload)
203     {
204         ASSERT(kind != InvalidAbstractHeap &amp;&amp; kind != World &amp;&amp; kind != Heap &amp;&amp; kind != SideState);
205         m_value = encode(kind, payload);

206     }
207 
208     AbstractHeap(WTF::HashTableDeletedValueType)
209     {
210         m_value = encode(InvalidAbstractHeap, Payload::top());
211     }
212 
213     bool operator!() const { return kind() == InvalidAbstractHeap &amp;&amp; !payloadImpl().isTop(); }
214 
215     AbstractHeapKind kind() const { return static_cast&lt;AbstractHeapKind&gt;(m_value &amp; ((1 &lt;&lt; topShift) - 1)); }
216     Payload payload() const
217     {
218         ASSERT(kind() != World &amp;&amp; kind() != InvalidAbstractHeap);
219         return payloadImpl();
220     }





221 
222     AbstractHeap supertype() const
223     {
224         ASSERT(kind() != InvalidAbstractHeap);
225         switch (kind()) {
226         case World:
227             return AbstractHeap();
228         case Heap:
229         case SideState:
230             return World;
231         default:
232             if (payload().isTop()) {
233                 if (kind() == Stack)
234                     return World;
235                 return Heap;
236             }
237             return AbstractHeap(kind());
238         }
239     }
240 
</pre>
<hr />
<pre>
286     bool operator!=(const AbstractHeap&amp; other) const
287     {
288         return !(*this == other);
289     }
290 
291     bool operator&lt;(const AbstractHeap&amp; other) const
292     {
293         if (kind() != other.kind())
294             return kind() &lt; other.kind();
295         return payload() &lt; other.payload();
296     }
297 
298     bool isHashTableDeletedValue() const
299     {
300         return kind() == InvalidAbstractHeap &amp;&amp; payloadImpl().isTop();
301     }
302 
303     void dump(PrintStream&amp; out) const;
304 
305 private:
<span class="line-modified">306     static const unsigned valueShift = 15;</span>
<span class="line-modified">307     static const unsigned topShift = 14;</span>

308 
309     Payload payloadImpl() const
310     {
311         return Payload((m_value &gt;&gt; topShift) &amp; 1, m_value &gt;&gt; valueShift);
312     }
313 
314     static int64_t encode(AbstractHeapKind kind, Payload payload)
315     {
316         int64_t kindAsInt = static_cast&lt;int64_t&gt;(kind);
317         ASSERT(kindAsInt &lt; (1 &lt;&lt; topShift));
318         return kindAsInt | (static_cast&lt;uint64_t&gt;(payload.isTop()) &lt;&lt; topShift) | (bitwise_cast&lt;uint64_t&gt;(payload.valueImpl()) &lt;&lt; valueShift);
319     }
320 
321     // The layout of the value is:
322     // Low 14 bits: the Kind
323     // 15th bit: whether or not the payload is TOP.
324     // The upper bits: the payload.value().
325     int64_t m_value;
326 };
327 
328 struct AbstractHeapHash {
329     static unsigned hash(const AbstractHeap&amp; key) { return key.hash(); }
330     static bool equal(const AbstractHeap&amp; a, const AbstractHeap&amp; b) { return a == b; }
<span class="line-modified">331     static const bool safeToCompareToEmptyOrDeleted = true;</span>
332 };
333 
334 } } // namespace JSC::DFG
335 
336 namespace WTF {
337 
338 void printInternal(PrintStream&amp;, JSC::DFG::AbstractHeapKind);
339 
340 template&lt;typename T&gt; struct DefaultHash;
341 template&lt;&gt; struct DefaultHash&lt;JSC::DFG::AbstractHeap&gt; {
342     typedef JSC::DFG::AbstractHeapHash Hash;
343 };
344 
345 template&lt;typename T&gt; struct HashTraits;
346 template&lt;&gt; struct HashTraits&lt;JSC::DFG::AbstractHeap&gt; : SimpleClassHashTraits&lt;JSC::DFG::AbstractHeap&gt; { };
347 
348 } // namespace WTF
349 
350 #endif // ENABLE(DFG_JIT)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DOMJITHeapRange.h&quot;
<span class="line-added"> 31 #include &quot;OperandsInlines.h&quot;</span>
 32 #include &quot;VirtualRegister.h&quot;
 33 #include &lt;wtf/HashMap.h&gt;
 34 #include &lt;wtf/PrintStream.h&gt;
 35 
 36 namespace JSC { namespace DFG {
 37 
 38 // Implements a four-level type hierarchy:
 39 // - World is the supertype of all of the things.
 40 // - Stack with a TOP payload is a direct subtype of World
 41 // - Stack with a non-TOP payload is a direct subtype of Stack with a TOP payload.
 42 // - Heap is a direct subtype of World.
 43 // - SideState is a direct subtype of World.
 44 // - Any other kind with TOP payload is the direct subtype of Heap.
 45 // - Any other kind with non-TOP payload is the direct subtype of the same kind with a TOP payload.
 46 
 47 #define FOR_EACH_ABSTRACT_HEAP_KIND(macro) \
 48     macro(InvalidAbstractHeap) \
 49     macro(World) \
 50     macro(Stack) \
 51     macro(Heap) \
 52     macro(Butterfly_publicLength) \
 53     macro(Butterfly_vectorLength) \
 54     macro(GetterSetter_getter) \
 55     macro(GetterSetter_setter) \
 56     macro(JSCell_cellState) \
 57     macro(JSCell_indexingType) \
 58     macro(JSCell_structureID) \
 59     macro(JSCell_typeInfoFlags) \

 60     macro(JSObject_butterfly) \
 61     macro(JSPropertyNameEnumerator_cachedPropertyNames) \
 62     macro(RegExpObject_lastIndex) \
 63     macro(NamedProperties) \
 64     macro(IndexedInt32Properties) \
 65     macro(IndexedDoubleProperties) \
 66     macro(IndexedContiguousProperties) \
 67     macro(IndexedArrayStorageProperties) \

 68     macro(DirectArgumentsProperties) \
 69     macro(ScopeProperties) \
 70     macro(TypedArrayProperties) \
 71     macro(HeapObjectCount) /* Used to reflect the fact that some allocations reveal object identity */\
 72     macro(RegExpState) \
 73     macro(MathDotRandomState) \
<span class="line-added"> 74     macro(JSDateFields) \</span>
 75     macro(JSMapFields) \
 76     macro(JSSetFields) \
 77     macro(JSWeakMapFields) \
 78     macro(JSWeakSetFields) \
<span class="line-added"> 79     macro(JSInternalFields) \</span>
 80     macro(InternalState) \
 81     macro(CatchLocals) \
 82     macro(Absolute) \
 83     /* DOMJIT tells the heap range with the pair of integers. */\
 84     macro(DOMState) \
 85     /* Use this for writes only, to indicate that this may fire watchpoints. Usually this is never directly written but instead we test to see if a node clobbers this; it just so happens that you have to write world to clobber it. */\
 86     macro(Watchpoint_fire) \
 87     /* Use these for reads only, just to indicate that if the world got clobbered, then this operation will not work. */\
 88     macro(MiscFields) \
 89     /* Use this for writes only, just to indicate that hoisting the node is invalid. This works because we don&#39;t hoist anything that has any side effects at all. */\
 90     macro(SideState)
 91 
 92 enum AbstractHeapKind {
 93 #define ABSTRACT_HEAP_DECLARATION(name) name,
 94     FOR_EACH_ABSTRACT_HEAP_KIND(ABSTRACT_HEAP_DECLARATION)
 95 #undef ABSTRACT_HEAP_DECLARATION
 96 };
 97 
 98 class AbstractHeap {
 99 public:
</pre>
<hr />
<pre>
107 
108         Payload(bool isTop, int64_t value)
109             : m_isTop(isTop)
110             , m_value(value)
111         {
112             ASSERT(!(isTop &amp;&amp; value));
113         }
114 
115         Payload(int64_t value)
116             : m_isTop(false)
117             , m_value(value)
118         {
119         }
120 
121         Payload(const void* pointer)
122             : m_isTop(false)
123             , m_value(bitwise_cast&lt;intptr_t&gt;(pointer))
124         {
125         }
126 
<span class="line-modified">127         Payload(Operand operand)</span>
128             : m_isTop(false)
<span class="line-modified">129             , m_value(operand.asBits())</span>
<span class="line-added">130         {</span>
<span class="line-added">131         }</span>
<span class="line-added">132 </span>
<span class="line-added">133         Payload(VirtualRegister operand)</span>
<span class="line-added">134             : Payload(Operand(operand))</span>
135         {
136         }
137 
138         static Payload top() { return Payload(true, 0); }
139 
140         bool isTop() const { return m_isTop; }
141         int64_t value() const
142         {
143             ASSERT(!isTop());
144             return valueImpl();
145         }
146         int64_t valueImpl() const
147         {
148             return m_value;
149         }
150 
151         int32_t value32() const
152         {
153             return static_cast&lt;int32_t&gt;(value());
154         }
</pre>
<hr />
<pre>
171             if (other.isTop())
172                 return false;
173             return value() &lt; other.value();
174         }
175 
176         bool isDisjoint(const Payload&amp; other) const
177         {
178             if (isTop())
179                 return false;
180             if (other.isTop())
181                 return false;
182             return m_value != other.m_value;
183         }
184 
185         bool overlaps(const Payload&amp; other) const
186         {
187             return !isDisjoint(other);
188         }
189 
190         void dump(PrintStream&amp;) const;
<span class="line-added">191         void dumpAsOperand(PrintStream&amp;) const;</span>
192 
193     private:
194         bool m_isTop;
195         int64_t m_value;
196     };
197 
198     AbstractHeap()
199     {
200         m_value = encode(InvalidAbstractHeap, Payload());
201     }
202 
203     AbstractHeap(AbstractHeapKind kind)
204     {
205         ASSERT(kind != InvalidAbstractHeap);
206         m_value = encode(kind, Payload::top());
207     }
208 
209     AbstractHeap(AbstractHeapKind kind, Payload payload)
210     {
211         ASSERT(kind != InvalidAbstractHeap &amp;&amp; kind != World &amp;&amp; kind != Heap &amp;&amp; kind != SideState);
212         m_value = encode(kind, payload);
<span class="line-added">213         ASSERT(this-&gt;kind() == kind &amp;&amp; this-&gt;payload() == payload);</span>
214     }
215 
216     AbstractHeap(WTF::HashTableDeletedValueType)
217     {
218         m_value = encode(InvalidAbstractHeap, Payload::top());
219     }
220 
221     bool operator!() const { return kind() == InvalidAbstractHeap &amp;&amp; !payloadImpl().isTop(); }
222 
223     AbstractHeapKind kind() const { return static_cast&lt;AbstractHeapKind&gt;(m_value &amp; ((1 &lt;&lt; topShift) - 1)); }
224     Payload payload() const
225     {
226         ASSERT(kind() != World &amp;&amp; kind() != InvalidAbstractHeap);
227         return payloadImpl();
228     }
<span class="line-added">229     Operand operand() const</span>
<span class="line-added">230     {</span>
<span class="line-added">231         ASSERT(kind() == Stack &amp;&amp; !payload().isTop());</span>
<span class="line-added">232         return Operand::fromBits(payload().value());</span>
<span class="line-added">233     }</span>
234 
235     AbstractHeap supertype() const
236     {
237         ASSERT(kind() != InvalidAbstractHeap);
238         switch (kind()) {
239         case World:
240             return AbstractHeap();
241         case Heap:
242         case SideState:
243             return World;
244         default:
245             if (payload().isTop()) {
246                 if (kind() == Stack)
247                     return World;
248                 return Heap;
249             }
250             return AbstractHeap(kind());
251         }
252     }
253 
</pre>
<hr />
<pre>
299     bool operator!=(const AbstractHeap&amp; other) const
300     {
301         return !(*this == other);
302     }
303 
304     bool operator&lt;(const AbstractHeap&amp; other) const
305     {
306         if (kind() != other.kind())
307             return kind() &lt; other.kind();
308         return payload() &lt; other.payload();
309     }
310 
311     bool isHashTableDeletedValue() const
312     {
313         return kind() == InvalidAbstractHeap &amp;&amp; payloadImpl().isTop();
314     }
315 
316     void dump(PrintStream&amp; out) const;
317 
318 private:
<span class="line-modified">319     static constexpr unsigned valueShift = 15;</span>
<span class="line-modified">320     static constexpr unsigned topShift = 14;</span>
<span class="line-added">321     static_assert((64 - valueShift) &gt;= Operand::maxBits, &quot;Operand should fit in Payload&#39;s encoded format&quot;);</span>
322 
323     Payload payloadImpl() const
324     {
325         return Payload((m_value &gt;&gt; topShift) &amp; 1, m_value &gt;&gt; valueShift);
326     }
327 
328     static int64_t encode(AbstractHeapKind kind, Payload payload)
329     {
330         int64_t kindAsInt = static_cast&lt;int64_t&gt;(kind);
331         ASSERT(kindAsInt &lt; (1 &lt;&lt; topShift));
332         return kindAsInt | (static_cast&lt;uint64_t&gt;(payload.isTop()) &lt;&lt; topShift) | (bitwise_cast&lt;uint64_t&gt;(payload.valueImpl()) &lt;&lt; valueShift);
333     }
334 
335     // The layout of the value is:
336     // Low 14 bits: the Kind
337     // 15th bit: whether or not the payload is TOP.
338     // The upper bits: the payload.value().
339     int64_t m_value;
340 };
341 
342 struct AbstractHeapHash {
343     static unsigned hash(const AbstractHeap&amp; key) { return key.hash(); }
344     static bool equal(const AbstractHeap&amp; a, const AbstractHeap&amp; b) { return a == b; }
<span class="line-modified">345     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
346 };
347 
348 } } // namespace JSC::DFG
349 
350 namespace WTF {
351 
352 void printInternal(PrintStream&amp;, JSC::DFG::AbstractHeapKind);
353 
354 template&lt;typename T&gt; struct DefaultHash;
355 template&lt;&gt; struct DefaultHash&lt;JSC::DFG::AbstractHeap&gt; {
356     typedef JSC::DFG::AbstractHeapHash Hash;
357 };
358 
359 template&lt;typename T&gt; struct HashTraits;
360 template&lt;&gt; struct HashTraits&lt;JSC::DFG::AbstractHeap&gt; : SimpleClassHashTraits&lt;JSC::DFG::AbstractHeap&gt; { };
361 
362 } // namespace WTF
363 
364 #endif // ENABLE(DFG_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="DFGAbstractHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractInterpreter.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
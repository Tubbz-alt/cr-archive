diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/CallFrame.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/CallFrame.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/CallFrame.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/CallFrame.cpp
@@ -25,29 +25,31 @@
 
 #include "config.h"
 #include "CallFrame.h"
 
 #include "CodeBlock.h"
+#include "ExecutableAllocator.h"
 #include "InlineCallFrame.h"
 #include "Interpreter.h"
 #include "JSCInlines.h"
 #include "JSWebAssemblyInstance.h"
+#include "LLIntPCRanges.h"
 #include "VMEntryScope.h"
 #include "WasmContextInlines.h"
 #include "WasmInstance.h"
 #include <wtf/StringPrintStream.h>
 
 namespace JSC {
 
-void ExecState::initGlobalExec(ExecState* globalExec, JSCallee* globalCallee)
+void CallFrame::initDeprecatedCallFrameForDebugger(CallFrame* globalExec, JSCallee* globalCallee)
 {
     globalExec->setCodeBlock(nullptr);
     globalExec->setCallerFrame(noCaller());
     globalExec->setReturnPC(0);
     globalExec->setArgumentCountIncludingThis(0);
     globalExec->setCallee(globalCallee);
-    ASSERT(globalExec->isGlobalExec());
+    ASSERT(globalExec->isDeprecatedCallFrameForDebugger());
 }
 
 bool CallFrame::callSiteBitsAreBytecodeOffset() const
 {
     ASSERT(codeBlock());
@@ -86,74 +88,53 @@
     return false;
 }
 
 unsigned CallFrame::callSiteAsRawBits() const
 {
-    return this[CallFrameSlot::argumentCount].tag();
+    return this[static_cast<int>(CallFrameSlot::argumentCountIncludingThis)].tag();
 }
 
 SUPPRESS_ASAN unsigned CallFrame::unsafeCallSiteAsRawBits() const
 {
-    return this[CallFrameSlot::argumentCount].unsafeTag();
+    return this[static_cast<int>(CallFrameSlot::argumentCountIncludingThis)].unsafeTag();
 }
 
 CallSiteIndex CallFrame::callSiteIndex() const
 {
-    return CallSiteIndex(callSiteAsRawBits());
+    return CallSiteIndex::fromBits(callSiteAsRawBits());
 }
 
 SUPPRESS_ASAN CallSiteIndex CallFrame::unsafeCallSiteIndex() const
 {
-    return CallSiteIndex(unsafeCallSiteAsRawBits());
+    return CallSiteIndex::fromBits(unsafeCallSiteAsRawBits());
 }
 
-#if USE(JSVALUE32_64)
-const Instruction* CallFrame::currentVPC() const
-{
-    return bitwise_cast<Instruction*>(callSiteIndex().bits());
-}
-
-void CallFrame::setCurrentVPC(const Instruction* vpc)
-{
-    CallSiteIndex callSite(vpc);
-    this[CallFrameSlot::argumentCount].tag() = callSite.bits();
-}
-
-unsigned CallFrame::callSiteBitsAsBytecodeOffset() const
-{
-    ASSERT(codeBlock());
-    ASSERT(callSiteBitsAreBytecodeOffset());
-    return codeBlock()->bytecodeOffset(currentVPC());
-}
-
-#else // USE(JSVALUE32_64)
 const Instruction* CallFrame::currentVPC() const
 {
     ASSERT(callSiteBitsAreBytecodeOffset());
     return codeBlock()->instructions().at(callSiteBitsAsBytecodeOffset()).ptr();
 }
 
 void CallFrame::setCurrentVPC(const Instruction* vpc)
 {
-    CallSiteIndex callSite(codeBlock()->bytecodeOffset(vpc));
-    this[CallFrameSlot::argumentCount].tag() = static_cast<int32_t>(callSite.bits());
+    CallSiteIndex callSite(codeBlock()->bytecodeIndex(vpc));
+    this[static_cast<int>(CallFrameSlot::argumentCountIncludingThis)].tag() = callSite.bits();
+    ASSERT(currentVPC() == vpc);
 }
 
 unsigned CallFrame::callSiteBitsAsBytecodeOffset() const
 {
     ASSERT(codeBlock());
     ASSERT(callSiteBitsAreBytecodeOffset());
     return callSiteIndex().bits();
 }
 
-#endif
-
-unsigned CallFrame::bytecodeOffset()
+BytecodeIndex CallFrame::bytecodeIndex()
 {
     ASSERT(!callee().isWasm());
     if (!codeBlock())
-        return 0;
+        return BytecodeIndex(0);
 #if ENABLE(DFG_JIT)
     if (callSiteBitsAreCodeOriginIndex()) {
         ASSERT(codeBlock());
         CodeOrigin codeOrigin = this->codeOrigin();
         for (InlineCallFrame* inlineCallFrame = codeOrigin.inlineCallFrame(); inlineCallFrame;) {
@@ -162,54 +143,42 @@
         }
         return codeOrigin.bytecodeIndex();
     }
 #endif
     ASSERT(callSiteBitsAreBytecodeOffset());
-    return callSiteBitsAsBytecodeOffset();
+    return callSiteIndex().bytecodeIndex();
 }
 
 CodeOrigin CallFrame::codeOrigin()
 {
     if (!codeBlock())
-        return CodeOrigin(0);
+        return CodeOrigin(BytecodeIndex(0));
 #if ENABLE(DFG_JIT)
     if (callSiteBitsAreCodeOriginIndex()) {
         CallSiteIndex index = callSiteIndex();
         ASSERT(codeBlock()->canGetCodeOrigin(index));
         return codeBlock()->codeOrigin(index);
     }
 #endif
-    return CodeOrigin(callSiteBitsAsBytecodeOffset());
+    return CodeOrigin(callSiteIndex().bytecodeIndex());
 }
 
 Register* CallFrame::topOfFrameInternal()
 {
     CodeBlock* codeBlock = this->codeBlock();
     ASSERT(codeBlock);
     return registers() + codeBlock->stackPointerOffset();
 }
 
-JSGlobalObject* CallFrame::wasmAwareLexicalGlobalObject(VM& vm)
-{
-#if ENABLE(WEBASSEMBLY)
-    if (!callee().isWasm())
-        return lexicalGlobalObject();
-    return vm.wasmContext.load()->owner<JSWebAssemblyInstance>()->globalObject(vm);
-#else
-    UNUSED_PARAM(vm);
-    return lexicalGlobalObject();
-#endif
-}
-
 bool CallFrame::isAnyWasmCallee()
 {
     CalleeBits callee = this->callee();
     if (callee.isWasm())
         return true;
 
     ASSERT(callee.isCell());
-    if (!!callee.rawPtr() && isWebAssemblyToJSCallee(callee.asCell()))
+    if (!!callee.rawPtr() && isWebAssemblyModule(callee.asCell()))
         return true;
 
     return false;
 }
 
@@ -231,14 +200,13 @@
         return currVMEntryRecord->unsafePrevTopCallFrame();
     }
     return static_cast<CallFrame*>(unsafeCallerFrameOrEntryFrame());
 }
 
-SourceOrigin CallFrame::callerSourceOrigin()
+SourceOrigin CallFrame::callerSourceOrigin(VM& vm)
 {
     RELEASE_ASSERT(callee().isCell());
-    VM* vm = &this->vm();
     SourceOrigin sourceOrigin;
     bool haveSkippedFirstFrame = false;
     StackVisitor::visit(this, vm, [&](StackVisitor& visitor) {
         if (!std::exchange(haveSkippedFirstFrame, true))
             return StackVisitor::Status::Continue;
@@ -290,22 +258,22 @@
         return "module code"_s;
     case GlobalCode:
         return "global code"_s;
     case FunctionCode:
         if (jsCallee())
-            return getCalculatedDisplayName(vm(), jsCallee());
+            return getCalculatedDisplayName(codeBlock->vm(), jsCallee());
         return emptyString();
     }
 
     ASSERT_NOT_REACHED();
     return emptyString();
 }
 
 void CallFrame::dump(PrintStream& out)
 {
     if (CodeBlock* codeBlock = this->codeBlock()) {
-        out.print(codeBlock->inferredName(), "#", codeBlock->hashAsStringIfPossible(), " [", codeBlock->jitType(), " bc#", bytecodeOffset(), "]");
+        out.print(codeBlock->inferredName(), "#", codeBlock->hashAsStringIfPossible(), " [", codeBlock->jitType(), " ", bytecodeIndex(), "]");
 
         out.print("(");
         thisValue().dumpForBacktrace(out);
 
         for (size_t i = 0; i < argumentCount(); ++i) {
@@ -337,11 +305,11 @@
     return buffer;
 }
 
 void CallFrame::convertToStackOverflowFrame(VM& vm, CodeBlock* codeBlockToKeepAliveUntilFrameIsUnwound)
 {
-    ASSERT(!isGlobalExec());
+    ASSERT(!isDeprecatedCallFrameForDebugger());
     ASSERT(codeBlockToKeepAliveUntilFrameIsUnwound->inherits<CodeBlock>(vm));
 
     EntryFrame* entryFrame = vm.topEntryFrame;
     CallFrame* throwOriginFrame = this;
     do {
@@ -354,6 +322,27 @@
     setCodeBlock(codeBlockToKeepAliveUntilFrameIsUnwound);
     setCallee(stackOverflowCallee);
     setArgumentCountIncludingThis(0);
 }
 
+#if ENABLE(WEBASSEMBLY)
+JSGlobalObject* CallFrame::lexicalGlobalObjectFromWasmCallee(VM& vm) const
+{
+    return vm.wasmContext.load()->owner<JSWebAssemblyInstance>()->globalObject();
+}
+#endif
+
+bool isFromJSCode(void* returnAddress)
+{
+    UNUSED_PARAM(returnAddress);
+#if ENABLE(JIT)
+    if (isJITPC(returnAddress))
+        return true;
+#endif
+#if ENABLE(C_LOOP)
+    return true;
+#else
+    return LLInt::isLLIntPC(returnAddress);
+#endif
+}
+
 } // namespace JSC

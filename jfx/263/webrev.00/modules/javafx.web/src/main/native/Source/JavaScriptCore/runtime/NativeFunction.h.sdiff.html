<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/NativeFunction.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NativeExecutable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NullGetterFunction.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/NativeFunction.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;JSCJSValue.h&quot;
 29 #include &quot;JSCPtrTag.h&quot;
 30 
 31 namespace JSC {
 32 
<span class="line-modified"> 33 class ExecState;</span>
 34 
<span class="line-modified"> 35 typedef EncodedJSValue (JSC_HOST_CALL *RawNativeFunction)(ExecState*);</span>
 36 
 37 class NativeFunction {
 38 public:
 39     NativeFunction() = default;
 40     NativeFunction(std::nullptr_t) : m_ptr(nullptr) { }
 41     explicit NativeFunction(uintptr_t bits) : m_ptr(bitwise_cast&lt;RawNativeFunction&gt;(bits)) { }
 42     NativeFunction(RawNativeFunction other) : m_ptr(other) { }
 43 
 44     explicit operator intptr_t() const { return reinterpret_cast&lt;intptr_t&gt;(m_ptr); }
 45     explicit operator bool() const { return !!m_ptr; }
 46     bool operator!() const { return !m_ptr; }
 47     bool operator==(NativeFunction other) const { return m_ptr == other.m_ptr; }
 48     bool operator!=(NativeFunction other) const { return m_ptr == other.m_ptr; }
 49 
<span class="line-modified"> 50     EncodedJSValue operator()(ExecState* exec) { return m_ptr(exec); }</span>
 51 
 52     void* rawPointer() const { return reinterpret_cast&lt;void*&gt;(m_ptr); }
 53 
 54 private:
 55     RawNativeFunction m_ptr;
 56 
 57     friend class TaggedNativeFunction;
 58 };
 59 
 60 struct NativeFunctionHash {
 61     static unsigned hash(NativeFunction key) { return IntHash&lt;uintptr_t&gt;::hash(bitwise_cast&lt;uintptr_t&gt;(key)); }
 62     static bool equal(NativeFunction a, NativeFunction b) { return a == b; }
<span class="line-modified"> 63     static const bool safeToCompareToEmptyOrDeleted = true;</span>
 64 };
 65 
 66 class TaggedNativeFunction {
 67 public:
 68     TaggedNativeFunction() = default;
 69     TaggedNativeFunction(std::nullptr_t) : m_ptr(nullptr) { }
 70     explicit TaggedNativeFunction(intptr_t bits) : m_ptr(bitwise_cast&lt;void*&gt;(bits)) { }
 71 
 72     TaggedNativeFunction(NativeFunction func)
 73         : m_ptr(tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(func.m_ptr))
 74     { }
 75     TaggedNativeFunction(RawNativeFunction func)
 76         : m_ptr(tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(func))
 77     { }
 78 
 79     explicit operator bool() const { return !!m_ptr; }
 80     bool operator!() const { return !m_ptr; }
 81     bool operator==(TaggedNativeFunction other) const { return m_ptr == other.m_ptr; }
 82     bool operator!=(TaggedNativeFunction other) const { return m_ptr != other.m_ptr; }
 83 
<span class="line-modified"> 84     EncodedJSValue operator()(ExecState* exec) { return NativeFunction(*this)(exec); }</span>
 85 
 86     explicit operator NativeFunction()
 87     {
 88         ASSERT(m_ptr);
 89         return untagCFunctionPtr&lt;NativeFunction, JSEntryPtrTag&gt;(m_ptr);
 90     }
 91 
 92     void* rawPointer() const { return m_ptr; }
 93 
 94 private:
 95     void* m_ptr;
 96 };
 97 
 98 struct TaggedNativeFunctionHash {
 99     static unsigned hash(TaggedNativeFunction key) { return IntHash&lt;uintptr_t&gt;::hash(bitwise_cast&lt;uintptr_t&gt;(key)); }
100     static bool equal(TaggedNativeFunction a, TaggedNativeFunction b) { return a == b; }
<span class="line-modified">101     static const bool safeToCompareToEmptyOrDeleted = true;</span>
102 };
103 
104 static_assert(sizeof(NativeFunction) == sizeof(void*), &quot;&quot;);
105 static_assert(sizeof(TaggedNativeFunction) == sizeof(void*), &quot;&quot;);
106 
107 } // namespace JSC
108 
109 namespace WTF {
110 
111 template&lt;typename T&gt; struct DefaultHash;
112 template&lt;&gt; struct DefaultHash&lt;JSC::NativeFunction&gt; {
113     using Hash = JSC::NativeFunctionHash;
114 };
115 
116 template&lt;typename T&gt; struct DefaultHash;
117 template&lt;&gt; struct DefaultHash&lt;JSC::TaggedNativeFunction&gt; {
118     using Hash = JSC::TaggedNativeFunctionHash;
119 };
120 
121 } // namespace WTF
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2018-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;JSCJSValue.h&quot;
 29 #include &quot;JSCPtrTag.h&quot;
 30 
 31 namespace JSC {
 32 
<span class="line-modified"> 33 class CallFrame;</span>
 34 
<span class="line-modified"> 35 typedef EncodedJSValue (JSC_HOST_CALL *RawNativeFunction)(JSGlobalObject*, CallFrame*);</span>
 36 
 37 class NativeFunction {
 38 public:
 39     NativeFunction() = default;
 40     NativeFunction(std::nullptr_t) : m_ptr(nullptr) { }
 41     explicit NativeFunction(uintptr_t bits) : m_ptr(bitwise_cast&lt;RawNativeFunction&gt;(bits)) { }
 42     NativeFunction(RawNativeFunction other) : m_ptr(other) { }
 43 
 44     explicit operator intptr_t() const { return reinterpret_cast&lt;intptr_t&gt;(m_ptr); }
 45     explicit operator bool() const { return !!m_ptr; }
 46     bool operator!() const { return !m_ptr; }
 47     bool operator==(NativeFunction other) const { return m_ptr == other.m_ptr; }
 48     bool operator!=(NativeFunction other) const { return m_ptr == other.m_ptr; }
 49 
<span class="line-modified"> 50     EncodedJSValue operator()(JSGlobalObject* globalObject, CallFrame* callFrame) { return m_ptr(globalObject, callFrame); }</span>
 51 
 52     void* rawPointer() const { return reinterpret_cast&lt;void*&gt;(m_ptr); }
 53 
 54 private:
 55     RawNativeFunction m_ptr;
 56 
 57     friend class TaggedNativeFunction;
 58 };
 59 
 60 struct NativeFunctionHash {
 61     static unsigned hash(NativeFunction key) { return IntHash&lt;uintptr_t&gt;::hash(bitwise_cast&lt;uintptr_t&gt;(key)); }
 62     static bool equal(NativeFunction a, NativeFunction b) { return a == b; }
<span class="line-modified"> 63     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
 64 };
 65 
 66 class TaggedNativeFunction {
 67 public:
 68     TaggedNativeFunction() = default;
 69     TaggedNativeFunction(std::nullptr_t) : m_ptr(nullptr) { }
 70     explicit TaggedNativeFunction(intptr_t bits) : m_ptr(bitwise_cast&lt;void*&gt;(bits)) { }
 71 
 72     TaggedNativeFunction(NativeFunction func)
 73         : m_ptr(tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(func.m_ptr))
 74     { }
 75     TaggedNativeFunction(RawNativeFunction func)
 76         : m_ptr(tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(func))
 77     { }
 78 
 79     explicit operator bool() const { return !!m_ptr; }
 80     bool operator!() const { return !m_ptr; }
 81     bool operator==(TaggedNativeFunction other) const { return m_ptr == other.m_ptr; }
 82     bool operator!=(TaggedNativeFunction other) const { return m_ptr != other.m_ptr; }
 83 
<span class="line-modified"> 84     EncodedJSValue operator()(JSGlobalObject* globalObject, CallFrame* callFrame) { return NativeFunction(*this)(globalObject, callFrame); }</span>
 85 
 86     explicit operator NativeFunction()
 87     {
 88         ASSERT(m_ptr);
 89         return untagCFunctionPtr&lt;NativeFunction, JSEntryPtrTag&gt;(m_ptr);
 90     }
 91 
 92     void* rawPointer() const { return m_ptr; }
 93 
 94 private:
 95     void* m_ptr;
 96 };
 97 
 98 struct TaggedNativeFunctionHash {
 99     static unsigned hash(TaggedNativeFunction key) { return IntHash&lt;uintptr_t&gt;::hash(bitwise_cast&lt;uintptr_t&gt;(key)); }
100     static bool equal(TaggedNativeFunction a, TaggedNativeFunction b) { return a == b; }
<span class="line-modified">101     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
102 };
103 
104 static_assert(sizeof(NativeFunction) == sizeof(void*), &quot;&quot;);
105 static_assert(sizeof(TaggedNativeFunction) == sizeof(void*), &quot;&quot;);
106 
107 } // namespace JSC
108 
109 namespace WTF {
110 
111 template&lt;typename T&gt; struct DefaultHash;
112 template&lt;&gt; struct DefaultHash&lt;JSC::NativeFunction&gt; {
113     using Hash = JSC::NativeFunctionHash;
114 };
115 
116 template&lt;typename T&gt; struct DefaultHash;
117 template&lt;&gt; struct DefaultHash&lt;JSC::TaggedNativeFunction&gt; {
118     using Hash = JSC::TaggedNativeFunctionHash;
119 };
120 
121 } // namespace WTF
</pre>
</td>
</tr>
</table>
<center><a href="NativeExecutable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NullGetterFunction.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/ScriptExecutionContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScriptExecutionContext.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptedAnimationController.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/ScriptExecutionContext.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  *
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;ActiveDOMObject.h&quot;
 31 #include &quot;DOMTimer.h&quot;
 32 #include &quot;SecurityContext.h&quot;
 33 #include &quot;ServiceWorkerTypes.h&quot;
 34 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
 35 #include &lt;JavaScriptCore/HandleTypes.h&gt;
 36 #include &lt;wtf/CrossThreadTask.h&gt;
 37 #include &lt;wtf/Function.h&gt;
 38 #include &lt;wtf/HashSet.h&gt;
 39 #include &lt;wtf/ObjectIdentifier.h&gt;
 40 #include &lt;wtf/text/WTFString.h&gt;
 41 
 42 namespace JSC {

 43 class Exception;
<span class="line-removed"> 44 class ExecState;</span>
 45 class JSPromise;
 46 class VM;
<span class="line-removed"> 47 template&lt;typename&gt; class Strong;</span>
 48 }
 49 
 50 namespace Inspector {
 51 class ConsoleMessage;
 52 class ScriptCallStack;
 53 }
 54 
<span class="line-removed"> 55 namespace PAL {</span>
<span class="line-removed"> 56 class SessionID;</span>
<span class="line-removed"> 57 }</span>
<span class="line-removed"> 58 </span>
 59 namespace WebCore {
 60 

 61 class CachedScript;
 62 class DatabaseContext;
 63 class EventQueue;

 64 class EventTarget;
 65 class MessagePort;
 66 class PublicURLManager;
 67 class RejectedPromiseTracker;
 68 class ResourceRequest;
 69 class SecurityOrigin;
 70 class SocketProvider;


 71 
 72 #if ENABLE(SERVICE_WORKER)
 73 class ServiceWorker;
 74 class ServiceWorkerContainer;
 75 #endif
 76 
 77 namespace IDBClient {
 78 class IDBConnectionProxy;
 79 }
 80 
 81 enum ScriptExecutionContextIdentifierType { };
 82 using ScriptExecutionContextIdentifier = ObjectIdentifier&lt;ScriptExecutionContextIdentifierType&gt;;
 83 
 84 class ScriptExecutionContext : public SecurityContext {
 85 public:
 86     ScriptExecutionContext();
 87     virtual ~ScriptExecutionContext();
 88 
 89     virtual bool isDocument() const { return false; }
 90     virtual bool isWorkerGlobalScope() const { return false; }
 91     virtual bool isWorkletGlobalScope() const { return false; }
 92 
 93     virtual bool isContextThread() const { return true; }
 94     virtual bool isJSExecutionForbidden() const = 0;
 95 


 96     virtual const URL&amp; url() const = 0;
<span class="line-modified"> 97     virtual URL completeURL(const String&amp; url) const = 0;</span>
<span class="line-modified"> 98     virtual PAL::SessionID sessionID() const = 0;</span>
 99 
100     virtual String userAgent(const URL&amp;) const = 0;
101 


102     virtual void disableEval(const String&amp; errorMessage) = 0;
103     virtual void disableWebAssembly(const String&amp; errorMessage) = 0;
104 
105 #if ENABLE(INDEXED_DATABASE)
106     virtual IDBClient::IDBConnectionProxy* idbConnectionProxy() = 0;
107 #endif
108     virtual SocketProvider* socketProvider() = 0;
109 
110     virtual String resourceRequestIdentifier() const { return String(); };
111 
112     bool canIncludeErrorDetails(CachedScript*, const String&amp; sourceURL);
113     void reportException(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception*, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, CachedScript* = nullptr);
<span class="line-modified">114     void reportUnhandledPromiseRejection(JSC::ExecState&amp;, JSC::JSPromise&amp;, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;);</span>
115 
116     virtual void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) = 0;
117 
118     // The following addConsoleMessage functions are deprecated.
119     // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">120     void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, JSC::ExecState* = nullptr, unsigned long requestIdentifier = 0);</span>
121     virtual void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier = 0) = 0;
122 
123     virtual SecurityOrigin&amp; topOrigin() const = 0;
<span class="line-removed">124     virtual String origin() const = 0;</span>
125 
126     virtual bool shouldBypassMainWorldContentSecurityPolicy() const { return false; }
127 
128     PublicURLManager&amp; publicURLManager();
129 
<span class="line-removed">130     // Active objects are not garbage collected even if inaccessible, e.g. because their activity may result in callbacks being invoked.</span>
<span class="line-removed">131     WEBCORE_EXPORT bool canSuspendActiveDOMObjectsForDocumentSuspension(Vector&lt;ActiveDOMObject*&gt;* unsuspendableObjects = nullptr);</span>
<span class="line-removed">132 </span>
<span class="line-removed">133     // Active objects can be asked to suspend even if canSuspendActiveDOMObjectsForDocumentSuspension() returns &#39;false&#39; -</span>
<span class="line-removed">134     // step-by-step JS debugging is one example.</span>
135     virtual void suspendActiveDOMObjects(ReasonForSuspension);
136     virtual void resumeActiveDOMObjects(ReasonForSuspension);
137     virtual void stopActiveDOMObjects();
138 
139     bool activeDOMObjectsAreSuspended() const { return m_activeDOMObjectsAreSuspended; }
140     bool activeDOMObjectsAreStopped() const { return m_activeDOMObjectsAreStopped; }
141 
142     // Called from the constructor and destructors of ActiveDOMObject.
143     void didCreateActiveDOMObject(ActiveDOMObject&amp;);
144     void willDestroyActiveDOMObject(ActiveDOMObject&amp;);
145 
146     // Called after the construction of an ActiveDOMObject to synchronize suspend state.
147     void suspendActiveDOMObjectIfNeeded(ActiveDOMObject&amp;);
148 
149     void didCreateDestructionObserver(ContextDestructionObserver&amp;);
150     void willDestroyDestructionObserver(ContextDestructionObserver&amp;);
151 
152     // MessagePort is conceptually a kind of ActiveDOMObject, but it needs to be tracked separately for message dispatch.
153     void processMessageWithMessagePortsSoon();
154     void dispatchMessagePortEvents();
</pre>
<hr />
<pre>
176             : m_task([task = WTFMove(task)](ScriptExecutionContext&amp;) { task(); })
177             , m_isCleanupTask(false)
178         {
179         }
180 
181         template&lt;typename T, typename = typename std::enable_if&lt;std::is_convertible&lt;T, WTF::Function&lt;void (ScriptExecutionContext&amp;)&gt;&gt;::value&gt;::type&gt;
182         Task(CleanupTaskTag, T task)
183             : m_task(WTFMove(task))
184             , m_isCleanupTask(true)
185         {
186         }
187 
188         void performTask(ScriptExecutionContext&amp; context) { m_task(context); }
189         bool isCleanupTask() const { return m_isCleanupTask; }
190 
191     protected:
192         WTF::Function&lt;void (ScriptExecutionContext&amp;)&gt; m_task;
193         bool m_isCleanupTask;
194     };
195 

196     virtual void postTask(Task&amp;&amp;) = 0; // Executes the task on context&#39;s thread asynchronously.
197 
198     template&lt;typename... Arguments&gt;
199     void postCrossThreadTask(Arguments&amp;&amp;... arguments)
200     {
201         postTask([crossThreadTask = createCrossThreadTask(arguments...)](ScriptExecutionContext&amp;) mutable {
202             crossThreadTask.performTask();
203         });
204     }
205 
206     // Gets the next id in a circular sequence from 1 to 2^31-1.
207     int circularSequentialID();
208 
<span class="line-modified">209     bool addTimeout(int timeoutId, DOMTimer&amp; timer) { return m_timeouts.add(timeoutId, &amp;timer).isNewEntry; }</span>
210     void removeTimeout(int timeoutId) { m_timeouts.remove(timeoutId); }
211     DOMTimer* findTimeout(int timeoutId) { return m_timeouts.get(timeoutId); }
212 
213     WEBCORE_EXPORT JSC::VM&amp; vm();
214 
215     void adjustMinimumDOMTimerInterval(Seconds oldMinimumTimerInterval);
216     virtual Seconds minimumDOMTimerInterval() const;
217 
218     void didChangeTimerAlignmentInterval();
219     virtual Seconds domTimerAlignmentInterval(bool hasReachedMaxNestingLevel) const;
220 
<span class="line-removed">221     virtual EventQueue&amp; eventQueue() const = 0;</span>
222     virtual EventTarget* errorEventTarget() = 0;
223 
224     DatabaseContext* databaseContext() { return m_databaseContext.get(); }
225     void setDatabaseContext(DatabaseContext*);
226 
227 #if ENABLE(WEB_CRYPTO)



228     virtual bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey) = 0;
229     virtual bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key) = 0;
230 #endif
231 
232     int timerNestingLevel() const { return m_timerNestingLevel; }
233     void setTimerNestingLevel(int timerNestingLevel) { m_timerNestingLevel = timerNestingLevel; }
234 
235     RejectedPromiseTracker&amp; ensureRejectedPromiseTracker()
236     {
237         if (m_rejectedPromiseTracker)
238             return *m_rejectedPromiseTracker.get();
239         return ensureRejectedPromiseTrackerSlow();
240     }
241 
<span class="line-modified">242     WEBCORE_EXPORT JSC::ExecState* execState();</span>
243 
244     WEBCORE_EXPORT String domainForCachePartition() const;
245     void setDomainForCachePartition(String&amp;&amp; domain) { m_domainForCachePartition = WTFMove(domain); }
246 
247     bool allowsMediaDevices() const;
248     bool hasServiceWorkerScheme() const;
249 #if ENABLE(SERVICE_WORKER)
250     ServiceWorker* activeServiceWorker() const;
251     void setActiveServiceWorker(RefPtr&lt;ServiceWorker&gt;&amp;&amp;);
252 
253     void registerServiceWorker(ServiceWorker&amp;);
254     void unregisterServiceWorker(ServiceWorker&amp;);
255     ServiceWorker* serviceWorker(ServiceWorkerIdentifier identifier) { return m_serviceWorkers.get(identifier); }
256 
257     ServiceWorkerContainer* serviceWorkerContainer();
<span class="line-modified">258 </span>
<span class="line-removed">259     WEBCORE_EXPORT static bool postTaskTo(const DocumentOrWorkerIdentifier&amp;, WTF::Function&lt;void(ScriptExecutionContext&amp;)&gt;&amp;&amp;);</span>
260 #endif
261     WEBCORE_EXPORT static bool postTaskTo(ScriptExecutionContextIdentifier, Task&amp;&amp;);
262 
263     ScriptExecutionContextIdentifier contextIdentifier() const;
264 
265 protected:
266     class AddConsoleMessageTask : public Task {
267     public:
268         AddConsoleMessageTask(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; consoleMessage)
269             : Task([&amp;consoleMessage](ScriptExecutionContext&amp; context) {
270                 context.addConsoleMessage(WTFMove(consoleMessage));
271             })
272         {
273         }
274 
275         AddConsoleMessageTask(MessageSource source, MessageLevel level, const String&amp; message)
276             : Task([source, level, message = message.isolatedCopy()](ScriptExecutionContext&amp; context) {
277                 context.addConsoleMessage(source, level, message);
278             })
279         {
280         }
281     };
282 
283     ReasonForSuspension reasonForSuspendingActiveDOMObjects() const { return m_reasonForSuspendingActiveDOMObjects; }
284 
285     bool hasPendingActivity() const;
286     void removeFromContextsMap();
287     void removeRejectedPromiseTracker();
288 
289 private:
290     // The following addMessage function is deprecated.
291     // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">292     virtual void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::ExecState* = nullptr, unsigned long requestIdentifier = 0) = 0;</span>
293     virtual void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) = 0;
294     bool dispatchErrorEvent(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception*, CachedScript*);
295 
296     virtual void refScriptExecutionContext() = 0;
297     virtual void derefScriptExecutionContext() = 0;
298 
299     enum class ShouldContinue { No, Yes };
300     void forEachActiveDOMObject(const Function&lt;ShouldContinue(ActiveDOMObject&amp;)&gt;&amp;) const;
301 
302     RejectedPromiseTracker&amp; ensureRejectedPromiseTrackerSlow();
303 
304     void checkConsistency() const;
305 
306     HashSet&lt;MessagePort*&gt; m_messagePorts;
307     HashSet&lt;ContextDestructionObserver*&gt; m_destructionObservers;
308     HashSet&lt;ActiveDOMObject*&gt; m_activeDOMObjects;
309 
<span class="line-modified">310     HashMap&lt;int, RefPtr&lt;DOMTimer&gt;&gt; m_timeouts;</span>
311 
312     struct PendingException;
313     std::unique_ptr&lt;Vector&lt;std::unique_ptr&lt;PendingException&gt;&gt;&gt; m_pendingExceptions;
314     std::unique_ptr&lt;RejectedPromiseTracker&gt; m_rejectedPromiseTracker;
315 
316     ReasonForSuspension m_reasonForSuspendingActiveDOMObjects { static_cast&lt;ReasonForSuspension&gt;(-1) };
317 
318     std::unique_ptr&lt;PublicURLManager&gt; m_publicURLManager;
319 
320     RefPtr&lt;DatabaseContext&gt; m_databaseContext;
321 
322     int m_circularSequentialID { 0 };
323     int m_timerNestingLevel { 0 };
324 
325     bool m_activeDOMObjectsAreSuspended { false };
326     bool m_activeDOMObjectsAreStopped { false };
327     bool m_inDispatchErrorEvent { false };
328     mutable bool m_activeDOMObjectAdditionForbidden { false };
329     bool m_willprocessMessageWithMessagePortsSoon { false };
330 
<span class="line-modified">331 #if !ASSERT_DISABLED</span>
332     bool m_inScriptExecutionContextDestructor { false };
333 #endif
334 
335 #if ENABLE(SERVICE_WORKER)
336     RefPtr&lt;ServiceWorker&gt; m_activeServiceWorker;
337     HashMap&lt;ServiceWorkerIdentifier, ServiceWorker*&gt; m_serviceWorkers;
338 #endif
339 
340     String m_domainForCachePartition;
341     mutable ScriptExecutionContextIdentifier m_contextIdentifier;
342 };
343 
344 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  *
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;ActiveDOMObject.h&quot;
 31 #include &quot;DOMTimer.h&quot;
 32 #include &quot;SecurityContext.h&quot;
 33 #include &quot;ServiceWorkerTypes.h&quot;
 34 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
 35 #include &lt;JavaScriptCore/HandleTypes.h&gt;
 36 #include &lt;wtf/CrossThreadTask.h&gt;
 37 #include &lt;wtf/Function.h&gt;
 38 #include &lt;wtf/HashSet.h&gt;
 39 #include &lt;wtf/ObjectIdentifier.h&gt;
 40 #include &lt;wtf/text/WTFString.h&gt;
 41 
 42 namespace JSC {
<span class="line-added"> 43 class CallFrame;</span>
 44 class Exception;

 45 class JSPromise;
 46 class VM;

 47 }
 48 
 49 namespace Inspector {
 50 class ConsoleMessage;
 51 class ScriptCallStack;
 52 }
 53 




 54 namespace WebCore {
 55 
<span class="line-added"> 56 class EventLoop;</span>
 57 class CachedScript;
 58 class DatabaseContext;
 59 class EventQueue;
<span class="line-added"> 60 class EventLoopTaskGroup;</span>
 61 class EventTarget;
 62 class MessagePort;
 63 class PublicURLManager;
 64 class RejectedPromiseTracker;
 65 class ResourceRequest;
 66 class SecurityOrigin;
 67 class SocketProvider;
<span class="line-added"> 68 enum class ReferrerPolicy : uint8_t;</span>
<span class="line-added"> 69 enum class TaskSource : uint8_t;</span>
 70 
 71 #if ENABLE(SERVICE_WORKER)
 72 class ServiceWorker;
 73 class ServiceWorkerContainer;
 74 #endif
 75 
 76 namespace IDBClient {
 77 class IDBConnectionProxy;
 78 }
 79 
 80 enum ScriptExecutionContextIdentifierType { };
 81 using ScriptExecutionContextIdentifier = ObjectIdentifier&lt;ScriptExecutionContextIdentifierType&gt;;
 82 
 83 class ScriptExecutionContext : public SecurityContext {
 84 public:
 85     ScriptExecutionContext();
 86     virtual ~ScriptExecutionContext();
 87 
 88     virtual bool isDocument() const { return false; }
 89     virtual bool isWorkerGlobalScope() const { return false; }
 90     virtual bool isWorkletGlobalScope() const { return false; }
 91 
 92     virtual bool isContextThread() const { return true; }
 93     virtual bool isJSExecutionForbidden() const = 0;
 94 
<span class="line-added"> 95     virtual EventLoopTaskGroup&amp; eventLoop() = 0;</span>
<span class="line-added"> 96 </span>
 97     virtual const URL&amp; url() const = 0;
<span class="line-modified"> 98     enum class ForceUTF8 { No, Yes };</span>
<span class="line-modified"> 99     virtual URL completeURL(const String&amp; url, ForceUTF8 = ForceUTF8::No) const = 0;</span>
100 
101     virtual String userAgent(const URL&amp;) const = 0;
102 
<span class="line-added">103     virtual ReferrerPolicy referrerPolicy() const = 0;</span>
<span class="line-added">104 </span>
105     virtual void disableEval(const String&amp; errorMessage) = 0;
106     virtual void disableWebAssembly(const String&amp; errorMessage) = 0;
107 
108 #if ENABLE(INDEXED_DATABASE)
109     virtual IDBClient::IDBConnectionProxy* idbConnectionProxy() = 0;
110 #endif
111     virtual SocketProvider* socketProvider() = 0;
112 
113     virtual String resourceRequestIdentifier() const { return String(); };
114 
115     bool canIncludeErrorDetails(CachedScript*, const String&amp; sourceURL);
116     void reportException(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception*, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, CachedScript* = nullptr);
<span class="line-modified">117     void reportUnhandledPromiseRejection(JSC::JSGlobalObject&amp;, JSC::JSPromise&amp;, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;);</span>
118 
119     virtual void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) = 0;
120 
121     // The following addConsoleMessage functions are deprecated.
122     // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">123     void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, JSC::JSGlobalObject* = nullptr, unsigned long requestIdentifier = 0);</span>
124     virtual void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier = 0) = 0;
125 
126     virtual SecurityOrigin&amp; topOrigin() const = 0;

127 
128     virtual bool shouldBypassMainWorldContentSecurityPolicy() const { return false; }
129 
130     PublicURLManager&amp; publicURLManager();
131 





132     virtual void suspendActiveDOMObjects(ReasonForSuspension);
133     virtual void resumeActiveDOMObjects(ReasonForSuspension);
134     virtual void stopActiveDOMObjects();
135 
136     bool activeDOMObjectsAreSuspended() const { return m_activeDOMObjectsAreSuspended; }
137     bool activeDOMObjectsAreStopped() const { return m_activeDOMObjectsAreStopped; }
138 
139     // Called from the constructor and destructors of ActiveDOMObject.
140     void didCreateActiveDOMObject(ActiveDOMObject&amp;);
141     void willDestroyActiveDOMObject(ActiveDOMObject&amp;);
142 
143     // Called after the construction of an ActiveDOMObject to synchronize suspend state.
144     void suspendActiveDOMObjectIfNeeded(ActiveDOMObject&amp;);
145 
146     void didCreateDestructionObserver(ContextDestructionObserver&amp;);
147     void willDestroyDestructionObserver(ContextDestructionObserver&amp;);
148 
149     // MessagePort is conceptually a kind of ActiveDOMObject, but it needs to be tracked separately for message dispatch.
150     void processMessageWithMessagePortsSoon();
151     void dispatchMessagePortEvents();
</pre>
<hr />
<pre>
173             : m_task([task = WTFMove(task)](ScriptExecutionContext&amp;) { task(); })
174             , m_isCleanupTask(false)
175         {
176         }
177 
178         template&lt;typename T, typename = typename std::enable_if&lt;std::is_convertible&lt;T, WTF::Function&lt;void (ScriptExecutionContext&amp;)&gt;&gt;::value&gt;::type&gt;
179         Task(CleanupTaskTag, T task)
180             : m_task(WTFMove(task))
181             , m_isCleanupTask(true)
182         {
183         }
184 
185         void performTask(ScriptExecutionContext&amp; context) { m_task(context); }
186         bool isCleanupTask() const { return m_isCleanupTask; }
187 
188     protected:
189         WTF::Function&lt;void (ScriptExecutionContext&amp;)&gt; m_task;
190         bool m_isCleanupTask;
191     };
192 
<span class="line-added">193     void enqueueTaskForDispatcher(Function&lt;void()&gt;&amp;&amp; function) { postTask(WTFMove(function)); }</span>
194     virtual void postTask(Task&amp;&amp;) = 0; // Executes the task on context&#39;s thread asynchronously.
195 
196     template&lt;typename... Arguments&gt;
197     void postCrossThreadTask(Arguments&amp;&amp;... arguments)
198     {
199         postTask([crossThreadTask = createCrossThreadTask(arguments...)](ScriptExecutionContext&amp;) mutable {
200             crossThreadTask.performTask();
201         });
202     }
203 
204     // Gets the next id in a circular sequence from 1 to 2^31-1.
205     int circularSequentialID();
206 
<span class="line-modified">207     bool addTimeout(int timeoutId, DOMTimer&amp; timer) { return m_timeouts.add(timeoutId, timer).isNewEntry; }</span>
208     void removeTimeout(int timeoutId) { m_timeouts.remove(timeoutId); }
209     DOMTimer* findTimeout(int timeoutId) { return m_timeouts.get(timeoutId); }
210 
211     WEBCORE_EXPORT JSC::VM&amp; vm();
212 
213     void adjustMinimumDOMTimerInterval(Seconds oldMinimumTimerInterval);
214     virtual Seconds minimumDOMTimerInterval() const;
215 
216     void didChangeTimerAlignmentInterval();
217     virtual Seconds domTimerAlignmentInterval(bool hasReachedMaxNestingLevel) const;
218 

219     virtual EventTarget* errorEventTarget() = 0;
220 
221     DatabaseContext* databaseContext() { return m_databaseContext.get(); }
222     void setDatabaseContext(DatabaseContext*);
223 
224 #if ENABLE(WEB_CRYPTO)
<span class="line-added">225     // These two methods are used when CryptoKeys are serialized into IndexedDB. As a side effect, it is also</span>
<span class="line-added">226     // used for things that utilize the same structure clone algorithm, for example, message passing between</span>
<span class="line-added">227     // worker and document.</span>
228     virtual bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey) = 0;
229     virtual bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key) = 0;
230 #endif
231 
232     int timerNestingLevel() const { return m_timerNestingLevel; }
233     void setTimerNestingLevel(int timerNestingLevel) { m_timerNestingLevel = timerNestingLevel; }
234 
235     RejectedPromiseTracker&amp; ensureRejectedPromiseTracker()
236     {
237         if (m_rejectedPromiseTracker)
238             return *m_rejectedPromiseTracker.get();
239         return ensureRejectedPromiseTrackerSlow();
240     }
241 
<span class="line-modified">242     WEBCORE_EXPORT JSC::JSGlobalObject* execState();</span>
243 
244     WEBCORE_EXPORT String domainForCachePartition() const;
245     void setDomainForCachePartition(String&amp;&amp; domain) { m_domainForCachePartition = WTFMove(domain); }
246 
247     bool allowsMediaDevices() const;
248     bool hasServiceWorkerScheme() const;
249 #if ENABLE(SERVICE_WORKER)
250     ServiceWorker* activeServiceWorker() const;
251     void setActiveServiceWorker(RefPtr&lt;ServiceWorker&gt;&amp;&amp;);
252 
253     void registerServiceWorker(ServiceWorker&amp;);
254     void unregisterServiceWorker(ServiceWorker&amp;);
255     ServiceWorker* serviceWorker(ServiceWorkerIdentifier identifier) { return m_serviceWorkers.get(identifier); }
256 
257     ServiceWorkerContainer* serviceWorkerContainer();
<span class="line-modified">258     ServiceWorkerContainer* ensureServiceWorkerContainer();</span>

259 #endif
260     WEBCORE_EXPORT static bool postTaskTo(ScriptExecutionContextIdentifier, Task&amp;&amp;);
261 
262     ScriptExecutionContextIdentifier contextIdentifier() const;
263 
264 protected:
265     class AddConsoleMessageTask : public Task {
266     public:
267         AddConsoleMessageTask(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; consoleMessage)
268             : Task([&amp;consoleMessage](ScriptExecutionContext&amp; context) {
269                 context.addConsoleMessage(WTFMove(consoleMessage));
270             })
271         {
272         }
273 
274         AddConsoleMessageTask(MessageSource source, MessageLevel level, const String&amp; message)
275             : Task([source, level, message = message.isolatedCopy()](ScriptExecutionContext&amp; context) {
276                 context.addConsoleMessage(source, level, message);
277             })
278         {
279         }
280     };
281 
282     ReasonForSuspension reasonForSuspendingActiveDOMObjects() const { return m_reasonForSuspendingActiveDOMObjects; }
283 
284     bool hasPendingActivity() const;
285     void removeFromContextsMap();
286     void removeRejectedPromiseTracker();
287 
288 private:
289     // The following addMessage function is deprecated.
290     // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">291     virtual void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::JSGlobalObject* = nullptr, unsigned long requestIdentifier = 0) = 0;</span>
292     virtual void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) = 0;
293     bool dispatchErrorEvent(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception*, CachedScript*);
294 
295     virtual void refScriptExecutionContext() = 0;
296     virtual void derefScriptExecutionContext() = 0;
297 
298     enum class ShouldContinue { No, Yes };
299     void forEachActiveDOMObject(const Function&lt;ShouldContinue(ActiveDOMObject&amp;)&gt;&amp;) const;
300 
301     RejectedPromiseTracker&amp; ensureRejectedPromiseTrackerSlow();
302 
303     void checkConsistency() const;
304 
305     HashSet&lt;MessagePort*&gt; m_messagePorts;
306     HashSet&lt;ContextDestructionObserver*&gt; m_destructionObservers;
307     HashSet&lt;ActiveDOMObject*&gt; m_activeDOMObjects;
308 
<span class="line-modified">309     HashMap&lt;int, Ref&lt;DOMTimer&gt;&gt; m_timeouts;</span>
310 
311     struct PendingException;
312     std::unique_ptr&lt;Vector&lt;std::unique_ptr&lt;PendingException&gt;&gt;&gt; m_pendingExceptions;
313     std::unique_ptr&lt;RejectedPromiseTracker&gt; m_rejectedPromiseTracker;
314 
315     ReasonForSuspension m_reasonForSuspendingActiveDOMObjects { static_cast&lt;ReasonForSuspension&gt;(-1) };
316 
317     std::unique_ptr&lt;PublicURLManager&gt; m_publicURLManager;
318 
319     RefPtr&lt;DatabaseContext&gt; m_databaseContext;
320 
321     int m_circularSequentialID { 0 };
322     int m_timerNestingLevel { 0 };
323 
324     bool m_activeDOMObjectsAreSuspended { false };
325     bool m_activeDOMObjectsAreStopped { false };
326     bool m_inDispatchErrorEvent { false };
327     mutable bool m_activeDOMObjectAdditionForbidden { false };
328     bool m_willprocessMessageWithMessagePortsSoon { false };
329 
<span class="line-modified">330 #if ASSERT_ENABLED</span>
331     bool m_inScriptExecutionContextDestructor { false };
332 #endif
333 
334 #if ENABLE(SERVICE_WORKER)
335     RefPtr&lt;ServiceWorker&gt; m_activeServiceWorker;
336     HashMap&lt;ServiceWorkerIdentifier, ServiceWorker*&gt; m_serviceWorkers;
337 #endif
338 
339     String m_domainForCachePartition;
340     mutable ScriptExecutionContextIdentifier m_contextIdentifier;
341 };
342 
343 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="ScriptExecutionContext.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptedAnimationController.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
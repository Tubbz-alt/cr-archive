<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/cssjit/SelectorCompiler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FunctionCall.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorCompiler.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/cssjit/SelectorCompiler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 379     const CSSSelector* m_originalSelector;
 380 #endif
 381 };
 382 
 383 const Assembler::RegisterID SelectorCodeGenerator::returnRegister = JSC::GPRInfo::returnValueGPR;
 384 const Assembler::RegisterID SelectorCodeGenerator::elementAddressRegister = JSC::GPRInfo::argumentGPR0;
 385 const Assembler::RegisterID SelectorCodeGenerator::checkingContextRegister = JSC::GPRInfo::argumentGPR1;
 386 const Assembler::RegisterID SelectorCodeGenerator::callFrameRegister = JSC::GPRInfo::callFrameRegister;
 387 
 388 enum class FragmentsLevel {
 389     Root = 0,
 390     InFunctionalPseudoType = 1
 391 };
 392 
 393 enum class PseudoElementMatchingBehavior { CanMatch, NeverMatch };
 394 
 395 static FunctionType constructFragments(const CSSSelector* rootSelector, SelectorContext, SelectorFragmentList&amp; selectorFragments, FragmentsLevel, FragmentPositionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp;, PseudoElementMatchingBehavior);
 396 
 397 static void computeBacktrackingInformation(SelectorFragmentList&amp; selectorFragments, unsigned level = 0);
 398 
<span class="line-modified"> 399 SelectorCompilationStatus compileSelector(const CSSSelector* lastSelector, SelectorContext selectorContext, JSC::MacroAssemblerCodeRef&lt;CSSSelectorPtrTag&gt;&amp; codeRef)</span>
 400 {
<span class="line-modified"> 401     if (!JSC::VM::canUseJIT())</span>
<span class="line-modified"> 402         return SelectorCompilationStatus::CannotCompile;</span>
<span class="line-modified"> 403     SelectorCodeGenerator codeGenerator(lastSelector, selectorContext);</span>
<span class="line-modified"> 404     return codeGenerator.compile(codeRef);</span>











 405 }
 406 
 407 static inline FragmentRelation fragmentRelationForSelectorRelation(CSSSelector::RelationType relation)
 408 {
 409     switch (relation) {
 410     case CSSSelector::DescendantSpace:
 411         return FragmentRelation::Descendant;
 412     case CSSSelector::Child:
 413         return FragmentRelation::Child;
 414     case CSSSelector::DirectAdjacent:
 415         return FragmentRelation::DirectAdjacent;
 416     case CSSSelector::IndirectAdjacent:
 417         return FragmentRelation::IndirectAdjacent;
 418     case CSSSelector::Subselector:
 419     case CSSSelector::ShadowDescendant:
 420         ASSERT_NOT_REACHED();
 421     }
 422     ASSERT_NOT_REACHED();
 423     return FragmentRelation::Descendant;
 424 }
</pre>
<hr />
<pre>
 541         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilledStrongPassword));
 542         return FunctionType::SimpleSelectorChecker;
 543     case CSSSelector::PseudoClassAutofillStrongPasswordViewable:
 544         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilledStrongPasswordViewable));
 545         return FunctionType::SimpleSelectorChecker;
 546     case CSSSelector::PseudoClassChecked:
 547         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isChecked));
 548         return FunctionType::SimpleSelectorChecker;
 549     case CSSSelector::PseudoClassDefault:
 550         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesDefaultPseudoClass));
 551         return FunctionType::SimpleSelectorChecker;
 552     case CSSSelector::PseudoClassDisabled:
 553         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesDisabledPseudoClass));
 554         return FunctionType::SimpleSelectorChecker;
 555     case CSSSelector::PseudoClassEnabled:
 556         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesEnabledPseudoClass));
 557         return FunctionType::SimpleSelectorChecker;
 558     case CSSSelector::PseudoClassDefined:
 559         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isDefinedElement));
 560         return FunctionType::SimpleSelectorChecker;



 561     case CSSSelector::PseudoClassFocus:
 562         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(SelectorChecker::matchesFocusPseudoClass));
 563         return FunctionType::SimpleSelectorChecker;
 564     case CSSSelector::PseudoClassFullPageMedia:
 565         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isMediaDocument));
 566         return FunctionType::SimpleSelectorChecker;
 567     case CSSSelector::PseudoClassInRange:
 568         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isInRange));
 569         return FunctionType::SimpleSelectorChecker;
 570     case CSSSelector::PseudoClassIndeterminate:
 571         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesIndeterminatePseudoClass));
 572         return FunctionType::SimpleSelectorChecker;
 573     case CSSSelector::PseudoClassInvalid:
 574         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isInvalid));
 575         return FunctionType::SimpleSelectorChecker;
 576     case CSSSelector::PseudoClassOptional:
 577         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isOptionalFormControl));
 578         return FunctionType::SimpleSelectorChecker;
 579     case CSSSelector::PseudoClassOutOfRange:
 580         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isOutOfRange));
</pre>
<hr />
<pre>
 596         return FunctionType::SimpleSelectorChecker;
 597 
 598 #if ENABLE(FULLSCREEN_API)
 599     case CSSSelector::PseudoClassFullScreen:
 600         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenPseudoClass));
 601         return FunctionType::SimpleSelectorChecker;
 602     case CSSSelector::PseudoClassFullScreenDocument:
 603         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenDocumentPseudoClass));
 604         return FunctionType::SimpleSelectorChecker;
 605     case CSSSelector::PseudoClassFullScreenAncestor:
 606         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenAncestorPseudoClass));
 607         return FunctionType::SimpleSelectorChecker;
 608     case CSSSelector::PseudoClassAnimatingFullScreenTransition:
 609         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenAnimatingFullScreenTransitionPseudoClass));
 610         return FunctionType::SimpleSelectorChecker;
 611 
 612     case CSSSelector::PseudoClassFullScreenControlsHidden:
 613         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenControlsHiddenPseudoClass));
 614         return FunctionType::SimpleSelectorChecker;
 615 #endif







 616 #if ENABLE(VIDEO_TRACK)
 617     case CSSSelector::PseudoClassFuture:
 618         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFutureCuePseudoClass));
 619         return FunctionType::SimpleSelectorChecker;
 620     case CSSSelector::PseudoClassPast:
 621         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesPastCuePseudoClass));
 622         return FunctionType::SimpleSelectorChecker;
 623 #endif
 624 
 625 #if ENABLE(ATTACHMENT_ELEMENT)
 626     case CSSSelector::PseudoClassHasAttachment:
 627         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(hasAttachment));
 628         return FunctionType::SimpleSelectorChecker;
 629 #endif
 630 
 631     // These pseudo-classes only have meaning with scrollbars.
 632     case CSSSelector::PseudoClassHorizontal:
 633     case CSSSelector::PseudoClassVertical:
 634     case CSSSelector::PseudoClassDecrement:
 635     case CSSSelector::PseudoClassIncrement:
</pre>
<hr />
<pre>
 767                 if (fragmentList.size() != 1)
 768                     return FunctionType::CannotCompile;
 769 
 770                 const SelectorFragment&amp; subFragment = fragmentList.first();
 771                 anyFragments.append(subFragment);
 772                 functionType = mostRestrictiveFunctionType(functionType, subFunctionType);
 773             }
 774 
 775             // Since all fragments in :any() cannot match anything, this :any() filter cannot match anything.
 776             if (anyFragments.isEmpty())
 777                 return FunctionType::CannotMatchAnything;
 778 
 779             ASSERT(!anyFragments.isEmpty());
 780             fragment.anyFilters.append(anyFragments);
 781 
 782             return functionType;
 783         }
 784 
 785     case CSSSelector::PseudoClassLang:
 786         {
<span class="line-modified"> 787             const Vector&lt;AtomString&gt;* selectorLangArgumentList = selector.langArgumentList();</span>
 788             ASSERT(selectorLangArgumentList &amp;&amp; !selectorLangArgumentList-&gt;isEmpty());
 789             fragment.languageArgumentsList.append(selectorLangArgumentList);
 790             return FunctionType::SimpleSelectorChecker;
 791         }
 792 
 793     case CSSSelector::PseudoClassMatches:
 794         {
 795             SelectorList matchesList;
 796             const CSSSelectorList* selectorList = selector.selectorList();
 797             FunctionType functionType = FunctionType::SimpleSelectorChecker;
 798             unsigned firstFragmentListSpecificity = 0;
 799             bool firstFragmentListSpecificitySet = false;
 800             SelectorFragmentList* selectorFragments = nullptr;
 801             for (const CSSSelector* subselector = selectorList-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 802                 if (!selectorFragments) {
 803                     matchesList.append(SelectorFragmentList());
 804                     selectorFragments = &amp;matchesList.last();
 805                 }
 806 
 807                 VisitedMode ignoreVisitedMode = VisitedMode::None;
</pre>
<hr />
<pre>
2433     StackAllocator::StackReference temporaryRemainderStackReference;
2434     Assembler::RegisterID temporaryRemainderCopy = JSC::InvalidGPRReg;
2435     if (inputDividend != remainder) {
2436         bool registerIsInUse = m_registerAllocator.allocatedRegisters().contains(remainder);
2437         if (registerIsInUse) {
2438             if (m_registerAllocator.availableRegisterCount() &gt; 1) {
2439                 temporaryRemainderCopy = m_registerAllocator.allocateRegister();
2440                 m_assembler.move(remainder, temporaryRemainderCopy);
2441                 remainderAllocation = RegisterAllocationType::CopiedToTemporary;
2442             } else {
2443                 temporaryRemainderStackReference = m_stackAllocator.push(remainder);
2444                 remainderAllocation = RegisterAllocationType::PushedToStack;
2445             }
2446         } else {
2447             m_registerAllocator.allocateRegister(remainder);
2448             remainderAllocation = RegisterAllocationType::AllocatedLocally;
2449         }
2450     }
2451 
2452     // If the input register is used by idiv, save its value to restore it after the operation.
<span class="line-modified">2453     Assembler::RegisterID inputDividendCopy;</span>
2454     StackAllocator::StackReference pushedInputDividendStackReference;
2455     RegisterAllocationType savedInputDividendAllocationType = RegisterAllocationType::External;
2456     if (inputDividend == dividend || inputDividend == remainder) {
2457         if (m_registerAllocator.availableRegisterCount() &gt; 1) {
2458             inputDividendCopy = m_registerAllocator.allocateRegister();
2459             m_assembler.move(inputDividend, inputDividendCopy);
2460             savedInputDividendAllocationType = RegisterAllocationType::CopiedToTemporary;
2461         } else {
2462             pushedInputDividendStackReference = m_stackAllocator.push(inputDividend);
2463             savedInputDividendAllocationType = RegisterAllocationType::PushedToStack;
2464         }
2465     }
2466 
2467     m_assembler.m_assembler.cdq();
2468 
2469     // 2) Perform the division with idiv.
2470     {
2471         LocalRegister divisorRegister(m_registerAllocator);
2472         m_assembler.move(Assembler::TrustedImm64(divisor), divisorRegister);
2473         m_assembler.m_assembler.idivl_r(divisorRegister);
</pre>
</td>
<td>
<hr />
<pre>
 379     const CSSSelector* m_originalSelector;
 380 #endif
 381 };
 382 
 383 const Assembler::RegisterID SelectorCodeGenerator::returnRegister = JSC::GPRInfo::returnValueGPR;
 384 const Assembler::RegisterID SelectorCodeGenerator::elementAddressRegister = JSC::GPRInfo::argumentGPR0;
 385 const Assembler::RegisterID SelectorCodeGenerator::checkingContextRegister = JSC::GPRInfo::argumentGPR1;
 386 const Assembler::RegisterID SelectorCodeGenerator::callFrameRegister = JSC::GPRInfo::callFrameRegister;
 387 
 388 enum class FragmentsLevel {
 389     Root = 0,
 390     InFunctionalPseudoType = 1
 391 };
 392 
 393 enum class PseudoElementMatchingBehavior { CanMatch, NeverMatch };
 394 
 395 static FunctionType constructFragments(const CSSSelector* rootSelector, SelectorContext, SelectorFragmentList&amp; selectorFragments, FragmentsLevel, FragmentPositionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp;, PseudoElementMatchingBehavior);
 396 
 397 static void computeBacktrackingInformation(SelectorFragmentList&amp; selectorFragments, unsigned level = 0);
 398 
<span class="line-modified"> 399 void compileSelector(CompiledSelector&amp; compiledSelector, const CSSSelector* selector, SelectorContext selectorContext)</span>
 400 {
<span class="line-modified"> 401     ASSERT(compiledSelector.status == SelectorCompilationStatus::NotCompiled);</span>
<span class="line-modified"> 402 </span>
<span class="line-modified"> 403     if (!JSC::VM::canUseJIT()) {</span>
<span class="line-modified"> 404         compiledSelector.status = SelectorCompilationStatus::CannotCompile;</span>
<span class="line-added"> 405         return;</span>
<span class="line-added"> 406     }</span>
<span class="line-added"> 407 </span>
<span class="line-added"> 408     SelectorCodeGenerator codeGenerator(selector, selectorContext);</span>
<span class="line-added"> 409     compiledSelector.status = codeGenerator.compile(compiledSelector.codeRef);</span>
<span class="line-added"> 410 </span>
<span class="line-added"> 411 #if defined(CSS_SELECTOR_JIT_PROFILING) &amp;&amp; CSS_SELECTOR_JIT_PROFILING</span>
<span class="line-added"> 412     compiledSelector.selector = selector;</span>
<span class="line-added"> 413 #endif</span>
<span class="line-added"> 414 </span>
<span class="line-added"> 415     ASSERT(compiledSelector.status != SelectorCompilationStatus::NotCompiled);</span>
 416 }
 417 
 418 static inline FragmentRelation fragmentRelationForSelectorRelation(CSSSelector::RelationType relation)
 419 {
 420     switch (relation) {
 421     case CSSSelector::DescendantSpace:
 422         return FragmentRelation::Descendant;
 423     case CSSSelector::Child:
 424         return FragmentRelation::Child;
 425     case CSSSelector::DirectAdjacent:
 426         return FragmentRelation::DirectAdjacent;
 427     case CSSSelector::IndirectAdjacent:
 428         return FragmentRelation::IndirectAdjacent;
 429     case CSSSelector::Subselector:
 430     case CSSSelector::ShadowDescendant:
 431         ASSERT_NOT_REACHED();
 432     }
 433     ASSERT_NOT_REACHED();
 434     return FragmentRelation::Descendant;
 435 }
</pre>
<hr />
<pre>
 552         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilledStrongPassword));
 553         return FunctionType::SimpleSelectorChecker;
 554     case CSSSelector::PseudoClassAutofillStrongPasswordViewable:
 555         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilledStrongPasswordViewable));
 556         return FunctionType::SimpleSelectorChecker;
 557     case CSSSelector::PseudoClassChecked:
 558         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isChecked));
 559         return FunctionType::SimpleSelectorChecker;
 560     case CSSSelector::PseudoClassDefault:
 561         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesDefaultPseudoClass));
 562         return FunctionType::SimpleSelectorChecker;
 563     case CSSSelector::PseudoClassDisabled:
 564         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesDisabledPseudoClass));
 565         return FunctionType::SimpleSelectorChecker;
 566     case CSSSelector::PseudoClassEnabled:
 567         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesEnabledPseudoClass));
 568         return FunctionType::SimpleSelectorChecker;
 569     case CSSSelector::PseudoClassDefined:
 570         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isDefinedElement));
 571         return FunctionType::SimpleSelectorChecker;
<span class="line-added"> 572     case CSSSelector::PseudoClassDirectFocus:</span>
<span class="line-added"> 573         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(SelectorChecker::matchesDirectFocusPseudoClass));</span>
<span class="line-added"> 574         return FunctionType::SimpleSelectorChecker;</span>
 575     case CSSSelector::PseudoClassFocus:
 576         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(SelectorChecker::matchesFocusPseudoClass));
 577         return FunctionType::SimpleSelectorChecker;
 578     case CSSSelector::PseudoClassFullPageMedia:
 579         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isMediaDocument));
 580         return FunctionType::SimpleSelectorChecker;
 581     case CSSSelector::PseudoClassInRange:
 582         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isInRange));
 583         return FunctionType::SimpleSelectorChecker;
 584     case CSSSelector::PseudoClassIndeterminate:
 585         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesIndeterminatePseudoClass));
 586         return FunctionType::SimpleSelectorChecker;
 587     case CSSSelector::PseudoClassInvalid:
 588         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isInvalid));
 589         return FunctionType::SimpleSelectorChecker;
 590     case CSSSelector::PseudoClassOptional:
 591         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isOptionalFormControl));
 592         return FunctionType::SimpleSelectorChecker;
 593     case CSSSelector::PseudoClassOutOfRange:
 594         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isOutOfRange));
</pre>
<hr />
<pre>
 610         return FunctionType::SimpleSelectorChecker;
 611 
 612 #if ENABLE(FULLSCREEN_API)
 613     case CSSSelector::PseudoClassFullScreen:
 614         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenPseudoClass));
 615         return FunctionType::SimpleSelectorChecker;
 616     case CSSSelector::PseudoClassFullScreenDocument:
 617         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenDocumentPseudoClass));
 618         return FunctionType::SimpleSelectorChecker;
 619     case CSSSelector::PseudoClassFullScreenAncestor:
 620         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenAncestorPseudoClass));
 621         return FunctionType::SimpleSelectorChecker;
 622     case CSSSelector::PseudoClassAnimatingFullScreenTransition:
 623         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenAnimatingFullScreenTransitionPseudoClass));
 624         return FunctionType::SimpleSelectorChecker;
 625 
 626     case CSSSelector::PseudoClassFullScreenControlsHidden:
 627         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenControlsHiddenPseudoClass));
 628         return FunctionType::SimpleSelectorChecker;
 629 #endif
<span class="line-added"> 630 </span>
<span class="line-added"> 631 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added"> 632     case CSSSelector::PseudoClassPictureInPicture:</span>
<span class="line-added"> 633         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesPictureInPicturePseudoClass));</span>
<span class="line-added"> 634         return FunctionType::SimpleSelectorChecker;</span>
<span class="line-added"> 635 #endif</span>
<span class="line-added"> 636 </span>
 637 #if ENABLE(VIDEO_TRACK)
 638     case CSSSelector::PseudoClassFuture:
 639         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFutureCuePseudoClass));
 640         return FunctionType::SimpleSelectorChecker;
 641     case CSSSelector::PseudoClassPast:
 642         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesPastCuePseudoClass));
 643         return FunctionType::SimpleSelectorChecker;
 644 #endif
 645 
 646 #if ENABLE(ATTACHMENT_ELEMENT)
 647     case CSSSelector::PseudoClassHasAttachment:
 648         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(hasAttachment));
 649         return FunctionType::SimpleSelectorChecker;
 650 #endif
 651 
 652     // These pseudo-classes only have meaning with scrollbars.
 653     case CSSSelector::PseudoClassHorizontal:
 654     case CSSSelector::PseudoClassVertical:
 655     case CSSSelector::PseudoClassDecrement:
 656     case CSSSelector::PseudoClassIncrement:
</pre>
<hr />
<pre>
 788                 if (fragmentList.size() != 1)
 789                     return FunctionType::CannotCompile;
 790 
 791                 const SelectorFragment&amp; subFragment = fragmentList.first();
 792                 anyFragments.append(subFragment);
 793                 functionType = mostRestrictiveFunctionType(functionType, subFunctionType);
 794             }
 795 
 796             // Since all fragments in :any() cannot match anything, this :any() filter cannot match anything.
 797             if (anyFragments.isEmpty())
 798                 return FunctionType::CannotMatchAnything;
 799 
 800             ASSERT(!anyFragments.isEmpty());
 801             fragment.anyFilters.append(anyFragments);
 802 
 803             return functionType;
 804         }
 805 
 806     case CSSSelector::PseudoClassLang:
 807         {
<span class="line-modified"> 808             const Vector&lt;AtomString&gt;* selectorLangArgumentList = selector.argumentList();</span>
 809             ASSERT(selectorLangArgumentList &amp;&amp; !selectorLangArgumentList-&gt;isEmpty());
 810             fragment.languageArgumentsList.append(selectorLangArgumentList);
 811             return FunctionType::SimpleSelectorChecker;
 812         }
 813 
 814     case CSSSelector::PseudoClassMatches:
 815         {
 816             SelectorList matchesList;
 817             const CSSSelectorList* selectorList = selector.selectorList();
 818             FunctionType functionType = FunctionType::SimpleSelectorChecker;
 819             unsigned firstFragmentListSpecificity = 0;
 820             bool firstFragmentListSpecificitySet = false;
 821             SelectorFragmentList* selectorFragments = nullptr;
 822             for (const CSSSelector* subselector = selectorList-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 823                 if (!selectorFragments) {
 824                     matchesList.append(SelectorFragmentList());
 825                     selectorFragments = &amp;matchesList.last();
 826                 }
 827 
 828                 VisitedMode ignoreVisitedMode = VisitedMode::None;
</pre>
<hr />
<pre>
2454     StackAllocator::StackReference temporaryRemainderStackReference;
2455     Assembler::RegisterID temporaryRemainderCopy = JSC::InvalidGPRReg;
2456     if (inputDividend != remainder) {
2457         bool registerIsInUse = m_registerAllocator.allocatedRegisters().contains(remainder);
2458         if (registerIsInUse) {
2459             if (m_registerAllocator.availableRegisterCount() &gt; 1) {
2460                 temporaryRemainderCopy = m_registerAllocator.allocateRegister();
2461                 m_assembler.move(remainder, temporaryRemainderCopy);
2462                 remainderAllocation = RegisterAllocationType::CopiedToTemporary;
2463             } else {
2464                 temporaryRemainderStackReference = m_stackAllocator.push(remainder);
2465                 remainderAllocation = RegisterAllocationType::PushedToStack;
2466             }
2467         } else {
2468             m_registerAllocator.allocateRegister(remainder);
2469             remainderAllocation = RegisterAllocationType::AllocatedLocally;
2470         }
2471     }
2472 
2473     // If the input register is used by idiv, save its value to restore it after the operation.
<span class="line-modified">2474     Assembler::RegisterID inputDividendCopy = JSC::InvalidGPRReg;</span>
2475     StackAllocator::StackReference pushedInputDividendStackReference;
2476     RegisterAllocationType savedInputDividendAllocationType = RegisterAllocationType::External;
2477     if (inputDividend == dividend || inputDividend == remainder) {
2478         if (m_registerAllocator.availableRegisterCount() &gt; 1) {
2479             inputDividendCopy = m_registerAllocator.allocateRegister();
2480             m_assembler.move(inputDividend, inputDividendCopy);
2481             savedInputDividendAllocationType = RegisterAllocationType::CopiedToTemporary;
2482         } else {
2483             pushedInputDividendStackReference = m_stackAllocator.push(inputDividend);
2484             savedInputDividendAllocationType = RegisterAllocationType::PushedToStack;
2485         }
2486     }
2487 
2488     m_assembler.m_assembler.cdq();
2489 
2490     // 2) Perform the division with idiv.
2491     {
2492         LocalRegister divisorRegister(m_registerAllocator);
2493         m_assembler.move(Assembler::TrustedImm64(divisor), divisorRegister);
2494         m_assembler.m_assembler.idivl_r(divisorRegister);
</pre>
</td>
</tr>
</table>
<center><a href="FunctionCall.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorCompiler.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
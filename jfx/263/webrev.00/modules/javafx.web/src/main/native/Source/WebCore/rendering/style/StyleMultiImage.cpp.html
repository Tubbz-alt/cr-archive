<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/style/StyleMultiImage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2003, 2005-2008, 2016 Apple Inc. All rights reserved.
  3  * Copyright (C) 2020 Noam Rosenthal (noam@webkit.org)
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;StyleMultiImage.h&quot;
 24 
 25 #include &quot;CSSImageGeneratorValue.h&quot;
 26 #include &quot;CSSImageSetValue.h&quot;
 27 #include &quot;CSSImageValue.h&quot;
 28 #include &quot;CachedImage.h&quot;
 29 #include &quot;CachedResourceLoader.h&quot;
 30 #include &quot;RenderElement.h&quot;
 31 #include &quot;RenderView.h&quot;
 32 #include &quot;StyleCachedImage.h&quot;
 33 #include &quot;StyleGeneratedImage.h&quot;
 34 
 35 namespace WebCore {
 36 
 37 StyleMultiImage::StyleMultiImage() = default;
 38 
 39 StyleMultiImage::~StyleMultiImage() = default;
 40 
 41 bool StyleMultiImage::equals(const StyleMultiImage&amp; other) const
 42 {
 43     return (!m_isPending &amp;&amp; !other.m_isPending &amp;&amp; m_selectedImage.get() == other.m_selectedImage.get());
 44 }
 45 
 46 void StyleMultiImage::load(CachedResourceLoader&amp; loader, const ResourceLoaderOptions&amp; options)
 47 {
 48     ASSERT(m_isPending);
 49     ASSERT(loader.document());
 50 
 51     m_isPending = false;
 52     auto imageWithScale = selectBestFitImage(*loader.document());
 53     ASSERT(is&lt;CSSImageValue&gt;(imageWithScale.value) || is&lt;CSSImageGeneratorValue&gt;(imageWithScale.value));
 54 
 55     if (is&lt;CSSImageGeneratorValue&gt;(imageWithScale.value)) {
 56         m_selectedImage = StyleGeneratedImage::create(downcast&lt;CSSImageGeneratorValue&gt;(*imageWithScale.value.get()));
 57         m_selectedImage-&gt;load(loader, options);
 58     }
 59 
 60     if (is&lt;CSSImageValue&gt;(imageWithScale.value)) {
 61         m_selectedImage = StyleCachedImage::create(downcast&lt;CSSImageValue&gt;(*imageWithScale.value.get()), imageWithScale.scaleFactor);
 62         if (m_selectedImage-&gt;isPending())
 63             m_selectedImage-&gt;load(loader, options);
 64     }
 65 }
 66 
 67 CachedImage* StyleMultiImage::cachedImage() const
 68 {
 69     if (!m_selectedImage)
 70         return nullptr;
 71     return m_selectedImage-&gt;cachedImage();
 72 }
 73 
 74 WrappedImagePtr StyleMultiImage::data() const
 75 {
 76     if (!m_selectedImage)
 77         return nullptr;
 78     return m_selectedImage-&gt;data();
 79 }
 80 
 81 bool StyleMultiImage::canRender(const RenderElement* renderer, float multiplier) const
 82 {
 83     return m_selectedImage &amp;&amp; m_selectedImage-&gt;canRender(renderer, multiplier);
 84 }
 85 
 86 bool StyleMultiImage::isPending() const
 87 {
 88     return m_isPending;
 89 }
 90 
 91 bool StyleMultiImage::isLoaded() const
 92 {
 93     return m_selectedImage &amp;&amp; m_selectedImage-&gt;isLoaded();
 94 }
 95 
 96 bool StyleMultiImage::errorOccurred() const
 97 {
 98     return m_selectedImage &amp;&amp; m_selectedImage-&gt;errorOccurred();
 99 }
100 
101 FloatSize StyleMultiImage::imageSize(const RenderElement* renderer, float multiplier) const
102 {
103     if (!m_selectedImage)
104         return { };
105     return m_selectedImage-&gt;imageSize(renderer, multiplier);
106 }
107 
108 bool StyleMultiImage::imageHasRelativeWidth() const
109 {
110     return m_selectedImage &amp;&amp; m_selectedImage-&gt;imageHasRelativeWidth();
111 }
112 
113 bool StyleMultiImage::imageHasRelativeHeight() const
114 {
115     return m_selectedImage &amp;&amp; m_selectedImage-&gt;imageHasRelativeHeight();
116 }
117 
118 void StyleMultiImage::computeIntrinsicDimensions(const RenderElement* element, Length&amp; intrinsicWidth, Length&amp; intrinsicHeight, FloatSize&amp; intrinsicRatio)
119 {
120     if (!m_selectedImage)
121         return;
122     m_selectedImage-&gt;computeIntrinsicDimensions(element, intrinsicWidth, intrinsicHeight, intrinsicRatio);
123 }
124 
125 bool StyleMultiImage::usesImageContainerSize() const
126 {
127     return m_selectedImage &amp;&amp; m_selectedImage-&gt;usesImageContainerSize();
128 }
129 
130 void StyleMultiImage::setContainerContextForRenderer(const RenderElement&amp; renderer, const FloatSize&amp; containerSize, float containerZoom)
131 {
132     if (!m_selectedImage)
133         return;
134     m_selectedImage-&gt;setContainerContextForRenderer(renderer, containerSize, containerZoom);
135 }
136 
137 void StyleMultiImage::addClient(RenderElement* renderer)
138 {
139     if (!m_selectedImage)
140         return;
141     m_selectedImage-&gt;addClient(renderer);
142 }
143 
144 void StyleMultiImage::removeClient(RenderElement* renderer)
145 {
146     if (!m_selectedImage)
147         return;
148     m_selectedImage-&gt;removeClient(renderer);
149 }
150 
151 RefPtr&lt;Image&gt; StyleMultiImage::image(RenderElement* renderer, const FloatSize&amp; size) const
152 {
153     if (!m_selectedImage)
154         return nullptr;
155     return m_selectedImage-&gt;image(renderer, size);
156 }
157 
158 float StyleMultiImage::imageScaleFactor() const
159 {
160     if (!m_selectedImage)
161         return 1;
162     return m_selectedImage-&gt;imageScaleFactor();
163 }
164 
165 bool StyleMultiImage::knownToBeOpaque(const RenderElement* renderer) const
166 {
167     return m_selectedImage &amp;&amp; m_selectedImage-&gt;knownToBeOpaque(renderer);
168 }
169 
170 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockFormattingContextGeometry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BlockFormattingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BlockFormattingContextQuirks.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockFormattingContextGeometry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;BlockFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 


 31 #include &quot;FormattingContext.h&quot;
 32 #include &quot;InlineFormattingState.h&quot;
 33 #include &quot;LayoutChildIterator.h&quot;

 34 #include &quot;Logging.h&quot;
 35 #include &lt;wtf/text/TextStream.h&gt;
 36 
 37 namespace WebCore {
 38 namespace Layout {
 39 
<span class="line-modified"> 40 HeightAndMargin BlockFormattingContext::Geometry::inFlowNonReplacedHeightAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
 41 {
 42     ASSERT(layoutBox.isInFlow() &amp;&amp; !layoutBox.replaced());
 43     ASSERT(layoutBox.isOverflowVisible());
 44 
<span class="line-modified"> 45     auto compute = [&amp;]() -&gt; HeightAndMargin {</span>
 46 
 47         // 10.6.3 Block-level non-replaced elements in normal flow when &#39;overflow&#39; computes to &#39;visible&#39;
 48         //
 49         // If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
 50         // If &#39;height&#39; is &#39;auto&#39;, the height depends on whether the element has any block-level children and whether it has padding or borders:
 51         // The element&#39;s height is the distance from its top content edge to the first applicable of the following:
 52         // 1. the bottom edge of the last line box, if the box establishes a inline formatting context with one or more lines
 53         // 2. the bottom edge of the bottom (possibly collapsed) margin of its last in-flow child, if the child&#39;s bottom margin
 54         //    does not collapse with the element&#39;s bottom margin
 55         // 3. the bottom border edge of the last in-flow child whose top margin doesn&#39;t collapse with the element&#39;s bottom margin
 56         // 4. zero, otherwise
 57         // Only children in the normal flow are taken into account (i.e., floating boxes and absolutely positioned boxes are ignored,
 58         // and relatively positioned boxes are considered without their offset). Note that the child box may be an anonymous block box.
 59 
<span class="line-modified"> 60         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified"> 61         auto containingBlockWidth = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth();</span>
<span class="line-removed"> 62         auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });</span>
 63         auto nonCollapsedMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified"> 64         auto borderAndPaddingTop = displayBox.borderTop() + displayBox.paddingTop().valueOr(0);</span>
<span class="line-modified"> 65         auto height = usedValues.height ? usedValues.height.value() : computedHeightValue(layoutState, layoutBox, HeightType::Normal);</span>
 66 
<span class="line-modified"> 67         if (height) {</span>
<span class="line-modified"> 68             auto borderAndPaddingBottom = displayBox.borderBottom() + displayBox.paddingBottom().valueOr(0);</span>
<span class="line-removed"> 69             auto contentHeight = layoutBox.style().boxSizing() == BoxSizing::ContentBox ? *height : *height - (borderAndPaddingTop + borderAndPaddingBottom);</span>
<span class="line-removed"> 70             return { contentHeight, nonCollapsedMargin };</span>
<span class="line-removed"> 71         }</span>
 72 
 73         if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowChild())
 74             return { 0, nonCollapsedMargin };
 75 
 76         // 1. the bottom edge of the last line box, if the box establishes a inline formatting context with one or more lines
<span class="line-modified"> 77         if (layoutBox.establishesInlineFormattingContext()) {</span>
<span class="line-modified"> 78             auto&amp; lineBoxes = downcast&lt;InlineFormattingState&gt;(layoutState.establishedFormattingState(layoutBox)).lineBoxes();</span>

 79             // Even empty containers generate one line.
 80             ASSERT(!lineBoxes.isEmpty());
<span class="line-modified"> 81             return { lineBoxes.last().logicalBottom() - borderAndPaddingTop, nonCollapsedMargin };</span>
 82         }
 83 
 84         // 2. the bottom edge of the bottom (possibly collapsed) margin of its last in-flow child, if the child&#39;s bottom margin...
<span class="line-modified"> 85         auto* lastInFlowChild = downcast&lt;Container&gt;(layoutBox).lastInFlowChild();</span>
 86         ASSERT(lastInFlowChild);
<span class="line-modified"> 87         if (!MarginCollapse::marginAfterCollapsesWithParentMarginAfter(layoutState, *lastInFlowChild)) {</span>
<span class="line-modified"> 88             auto&amp; lastInFlowDisplayBox = layoutState.displayBoxForLayoutBox(*lastInFlowChild);</span>
<span class="line-modified"> 89             auto bottomEdgeOfBottomMargin = lastInFlowDisplayBox.bottom() + (lastInFlowDisplayBox.hasCollapsedThroughMargin() ? LayoutUnit() : lastInFlowDisplayBox.marginAfter());</span>
 90             return { bottomEdgeOfBottomMargin - borderAndPaddingTop, nonCollapsedMargin };
 91         }
 92 
 93         // 3. the bottom border edge of the last in-flow child whose top margin doesn&#39;t collapse with the element&#39;s bottom margin
 94         auto* inFlowChild = lastInFlowChild;
<span class="line-modified"> 95         while (inFlowChild &amp;&amp; MarginCollapse::marginBeforeCollapsesWithParentMarginAfter(layoutState, *inFlowChild))</span>
 96             inFlowChild = inFlowChild-&gt;previousInFlowSibling();
 97         if (inFlowChild) {
<span class="line-modified"> 98             auto&amp; inFlowDisplayBox = layoutState.displayBoxForLayoutBox(*inFlowChild);</span>
<span class="line-modified"> 99             return { inFlowDisplayBox.top() + inFlowDisplayBox.borderBox().height() - borderAndPaddingTop, nonCollapsedMargin };</span>
100         }
101 
102         // 4. zero, otherwise
103         return { 0, nonCollapsedMargin };
104     };
105 
<span class="line-modified">106     auto heightAndMargin = compute();</span>
<span class="line-modified">107     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; inflow non-replaced -&gt; height(&quot; &lt;&lt; heightAndMargin.height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; heightAndMargin.nonCollapsedMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; heightAndMargin.nonCollapsedMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">108     return heightAndMargin;</span>


109 }
110 
<span class="line-modified">111 WidthAndMargin BlockFormattingContext::Geometry::inFlowNonReplacedWidthAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
112 {
113     ASSERT(layoutBox.isInFlow());
114 
115     auto compute = [&amp;]() {
116 
117         // 10.3.3 Block-level, non-replaced elements in normal flow
118         //
119         // The following constraints must hold among the used values of the other properties:
120         // &#39;margin-left&#39; + &#39;border-left-width&#39; + &#39;padding-left&#39; + &#39;width&#39; + &#39;padding-right&#39; + &#39;border-right-width&#39; + &#39;margin-right&#39; = width of containing block
121         //
122         // 1. If &#39;width&#39; is not &#39;auto&#39; and &#39;border-left-width&#39; + &#39;padding-left&#39; + &#39;width&#39; + &#39;padding-right&#39; + &#39;border-right-width&#39;
123         //    (plus any of &#39;margin-left&#39; or &#39;margin-right&#39; that are not &#39;auto&#39;) is larger than the width of the containing block, then
124         //    any &#39;auto&#39; values for &#39;margin-left&#39; or &#39;margin-right&#39; are, for the following rules, treated as zero.
125         //
126         // 2. If all of the above have a computed value other than &#39;auto&#39;, the values are said to be &quot;over-constrained&quot; and one of the used values will
127         //    have to be different from its computed value. If the &#39;direction&#39; property of the containing block has the value &#39;ltr&#39;, the specified value
128         //    of &#39;margin-right&#39; is ignored and the value is calculated so as to make the equality true. If the value of &#39;direction&#39; is &#39;rtl&#39;,
129         //    this happens to &#39;margin-left&#39; instead.
130         //
131         // 3. If there is exactly one value specified as &#39;auto&#39;, its used value follows from the equality.
132         //
133         // 4. If &#39;width&#39; is set to &#39;auto&#39;, any other &#39;auto&#39; values become &#39;0&#39; and &#39;width&#39; follows from the resulting equality.
134         //
135         // 5. If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, their used values are equal. This horizontally centers the element with respect to the
136         //    edges of the containing block.
137 
<span class="line-modified">138         auto&amp; style = layoutBox.style();</span>
<span class="line-modified">139         auto* containingBlock = layoutBox.containingBlock();</span>
<span class="line-removed">140         auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
<span class="line-removed">141         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
142 
<span class="line-modified">143         auto width = computedValueIfNotAuto(usedValues.width ? Length { usedValues.width.value(), Fixed } : style.logicalWidth(), containingBlockWidth);</span>
<span class="line-modified">144         auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
145         UsedHorizontalMargin usedHorizontalMargin;
<span class="line-modified">146         auto borderLeft = displayBox.borderLeft();</span>
<span class="line-modified">147         auto borderRight = displayBox.borderRight();</span>
<span class="line-modified">148         auto paddingLeft = displayBox.paddingLeft().valueOr(0);</span>
<span class="line-modified">149         auto paddingRight = displayBox.paddingRight().valueOr(0);</span>
<span class="line-removed">150         auto contentWidth = [&amp;] {</span>
<span class="line-removed">151             ASSERT(width);</span>
<span class="line-removed">152             return style.boxSizing() == BoxSizing::ContentBox ? *width : *width - (borderLeft + paddingLeft + paddingRight + borderRight);</span>
<span class="line-removed">153         };</span>
154 
155         // #1
156         if (width) {
<span class="line-modified">157             auto horizontalSpaceForMargin = containingBlockWidth - (computedHorizontalMargin.start.valueOr(0) + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + computedHorizontalMargin.end.valueOr(0));</span>
158             if (horizontalSpaceForMargin &lt; 0)
159                 usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
160         }
161 
162         // #2
163         if (width &amp;&amp; computedHorizontalMargin.start &amp;&amp; computedHorizontalMargin.end) {
<span class="line-modified">164             if (containingBlock-&gt;style().isLeftToRightDirection()) {</span>
165                 usedHorizontalMargin.start = *computedHorizontalMargin.start;
<span class="line-modified">166                 usedHorizontalMargin.end = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight);</span>
167             } else {
168                 usedHorizontalMargin.end = *computedHorizontalMargin.end;
<span class="line-modified">169                 usedHorizontalMargin.start = containingBlockWidth - (borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);</span>
170             }
171         }
172 
173         // #3
174         if (!computedHorizontalMargin.start &amp;&amp; width &amp;&amp; computedHorizontalMargin.end) {
175             usedHorizontalMargin.end = *computedHorizontalMargin.end;
<span class="line-modified">176             usedHorizontalMargin.start = containingBlockWidth - (borderLeft + paddingLeft  + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);</span>
177         } else if (computedHorizontalMargin.start &amp;&amp; !width &amp;&amp; computedHorizontalMargin.end) {
178             usedHorizontalMargin = { *computedHorizontalMargin.start, *computedHorizontalMargin.end };
179             width = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end);
180         } else if (computedHorizontalMargin.start &amp;&amp; width &amp;&amp; !computedHorizontalMargin.end) {
181             usedHorizontalMargin.start = *computedHorizontalMargin.start;
<span class="line-modified">182             usedHorizontalMargin.end = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight);</span>
183         }
184 
185         // #4
186         if (!width) {
187             usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
188             width = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end);
189         }
190 
191         // #5
192         if (!computedHorizontalMargin.start &amp;&amp; !computedHorizontalMargin.end) {
<span class="line-modified">193             auto horizontalSpaceForMargin = containingBlockWidth - (borderLeft + paddingLeft  + contentWidth() + paddingRight + borderRight);</span>
194             usedHorizontalMargin = { horizontalSpaceForMargin / 2, horizontalSpaceForMargin / 2 };
195         }
196 
197         ASSERT(width);
198 
<span class="line-modified">199         return WidthAndMargin { contentWidth(), usedHorizontalMargin, computedHorizontalMargin };</span>
200     };
201 
<span class="line-modified">202     auto widthAndMargin = compute();</span>
<span class="line-modified">203     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow non-replaced -&gt; width(&quot; &lt;&lt; widthAndMargin.width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; widthAndMargin.usedMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; widthAndMargin.usedMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">204     return widthAndMargin;</span>
205 }
206 
<span class="line-modified">207 WidthAndMargin BlockFormattingContext::Geometry::inFlowReplacedWidthAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
208 {
209     ASSERT(layoutBox.isInFlow() &amp;&amp; layoutBox.replaced());
210 
211     // 10.3.4 Block-level, replaced elements in normal flow
212     //
213     // 1. The used value of &#39;width&#39; is determined as for inline replaced elements.
214     // 2. Then the rules for non-replaced block-level elements are applied to determine the margins.
215 
216     // #1
<span class="line-modified">217     usedValues.width = inlineReplacedWidthAndMargin(layoutState, layoutBox, usedValues).width;</span>
218     // #2
<span class="line-modified">219     auto nonReplacedWidthAndMargin = inFlowNonReplacedWidthAndMargin(layoutState, layoutBox, usedValues);</span>
220 
<span class="line-modified">221     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow replaced -&gt; width(&quot; &lt;&lt; *usedValues.width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; nonReplacedWidthAndMargin.usedMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; nonReplacedWidthAndMargin.usedMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">222     return { *usedValues.width, nonReplacedWidthAndMargin.usedMargin, nonReplacedWidthAndMargin.computedMargin };</span>
223 }
224 
<span class="line-modified">225 LayoutUnit BlockFormattingContext::Geometry::staticVerticalPosition(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
226 {
227     // https://www.w3.org/TR/CSS22/visuren.html#block-formatting
228     // In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block.
229     // The vertical distance between two sibling boxes is determined by the &#39;margin&#39; properties.
230     // Vertical margins between adjacent block-level boxes in a block formatting context collapse.
231     if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
<span class="line-modified">232         auto&amp; previousInFlowDisplayBox = layoutState.displayBoxForLayoutBox(*previousInFlowSibling);</span>
<span class="line-modified">233         return previousInFlowDisplayBox.bottom() + previousInFlowDisplayBox.marginAfter();</span>
234     }
<span class="line-modified">235     return layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxTop();</span>
236 }
237 
<span class="line-modified">238 LayoutUnit BlockFormattingContext::Geometry::staticHorizontalPosition(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
239 {
240     // https://www.w3.org/TR/CSS22/visuren.html#block-formatting
241     // In a block formatting context, each box&#39;s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch).
<span class="line-modified">242     return layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxLeft() + layoutState.displayBoxForLayoutBox(layoutBox).marginStart();</span>
243 }
244 
<span class="line-modified">245 Point BlockFormattingContext::Geometry::staticPosition(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
246 {
<span class="line-modified">247     return { staticHorizontalPosition(layoutState, layoutBox), staticVerticalPosition(layoutState, layoutBox) };</span>
248 }
249 
<span class="line-modified">250 HeightAndMargin BlockFormattingContext::Geometry::inFlowHeightAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
251 {
252     ASSERT(layoutBox.isInFlow());
253 
254     // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39;
255     // replaced elements in normal flow and floating replaced elements
256     if (layoutBox.replaced())
<span class="line-modified">257         return inlineReplacedHeightAndMargin(layoutState, layoutBox, usedValues);</span>
<span class="line-modified">258 </span>
<span class="line-modified">259     HeightAndMargin heightAndMargin;</span>
<span class="line-modified">260     // TODO: Figure out the case for the document element. Let&#39;s just complicated-case it for now.</span>
<span class="line-modified">261     if (layoutBox.isOverflowVisible() &amp;&amp; !layoutBox.isDocumentBox())</span>
<span class="line-modified">262         heightAndMargin = inFlowNonReplacedHeightAndMargin(layoutState, layoutBox, usedValues);</span>
<span class="line-modified">263     else {</span>



264         // 10.6.6 Complicated cases
265         // Block-level, non-replaced elements in normal flow when &#39;overflow&#39; does not compute to &#39;visible&#39; (except if the &#39;overflow&#39; property&#39;s value has been propagated to the viewport).
<span class="line-modified">266         auto usedHorizontalValues = UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() };</span>
<span class="line-removed">267         heightAndMargin = complicatedCases(layoutState, layoutBox, usedValues, usedHorizontalValues);</span>
268     }
269 
<span class="line-modified">270     if (!Quirks::needsStretching(layoutState, layoutBox))</span>
<span class="line-modified">271         return heightAndMargin;</span>

272 
<span class="line-modified">273     heightAndMargin = Quirks::stretchedInFlowHeight(layoutState, layoutBox, heightAndMargin);</span>
274 
<span class="line-modified">275     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; inflow non-replaced -&gt; streched to viewport -&gt; height(&quot; &lt;&lt; heightAndMargin.height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; heightAndMargin.nonCollapsedMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; heightAndMargin.nonCollapsedMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">276     return heightAndMargin;</span>
277 }
278 
<span class="line-modified">279 WidthAndMargin BlockFormattingContext::Geometry::inFlowWidthAndMargin(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
280 {
281     ASSERT(layoutBox.isInFlow());
282 
283     if (!layoutBox.replaced()) {
<span class="line-modified">284         if (layoutBox.establishesTableFormattingContext()) {</span>
<span class="line-modified">285             // This is a special table &quot;fit-content size&quot; behavior handling. Not in the spec though.</span>
<span class="line-modified">286             // Table returns its final width as min/max. Use this final width value to computed horizontal margins etc.</span>
<span class="line-modified">287             usedValues.width = Geometry::shrinkToFitWidth(layoutState, layoutBox, usedValues);</span>
<span class="line-modified">288         }</span>
<span class="line-modified">289         return inFlowNonReplacedWidthAndMargin(layoutState, layoutBox, usedValues);</span>
290     }
<span class="line-modified">291     return inFlowReplacedWidthAndMargin(layoutState, layoutBox, usedValues);</span>
292 }
293 
<span class="line-modified">294 FormattingContext::IntrinsicWidthConstraints BlockFormattingContext::Geometry::intrinsicWidthConstraints(LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
295 {
296     auto fixedMarginBorderAndPadding = [&amp;](auto&amp; layoutBox) {
297         auto&amp; style = layoutBox.style();
298         return fixedValue(style.marginStart()).valueOr(0)
299             + LayoutUnit { style.borderLeftWidth() }
300             + fixedValue(style.paddingLeft()).valueOr(0)
301             + fixedValue(style.paddingRight()).valueOr(0)
302             + LayoutUnit { style.borderRightWidth() }
303             + fixedValue(style.marginEnd()).valueOr(0);
304     };
305 
306     auto computedIntrinsicWidthConstraints = [&amp;]() -&gt; IntrinsicWidthConstraints {
307         auto&amp; style = layoutBox.style();
308         if (auto width = fixedValue(style.logicalWidth()))
309             return { *width, *width };
310 
311         // Minimum/maximum width can&#39;t be depending on the containing block&#39;s width.
312         if (!style.logicalWidth().isAuto())
313             return { };
314 
315         if (auto* replaced = layoutBox.replaced()) {
316             if (replaced-&gt;hasIntrinsicWidth()) {
317                 auto replacedWidth = replaced-&gt;intrinsicWidth();
318                 return { replacedWidth, replacedWidth };
319             }
320             return { };
321         }
322 
<span class="line-removed">323         if (layoutBox.establishesFormattingContext())</span>
<span class="line-removed">324             return layoutState.createFormattingContext(layoutBox)-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-removed">325 </span>
326         if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
327             return { };
328 



329         auto intrinsicWidthConstraints = IntrinsicWidthConstraints { };
<span class="line-modified">330         auto&amp; formattingState = layoutState.formattingStateForBox(layoutBox);</span>
331         for (auto&amp; child : childrenOfType&lt;Box&gt;(downcast&lt;Container&gt;(layoutBox))) {
332             if (child.isOutOfFlowPositioned())
333                 continue;
334             auto childIntrinsicWidthConstraints = formattingState.intrinsicWidthConstraintsForBox(child);
335             ASSERT(childIntrinsicWidthConstraints);
336 
337             // FIXME Check for box-sizing: border-box;
338             auto marginBorderAndPadding = fixedMarginBorderAndPadding(child);
339             intrinsicWidthConstraints.minimum = std::max(intrinsicWidthConstraints.minimum, childIntrinsicWidthConstraints-&gt;minimum + marginBorderAndPadding);
340             intrinsicWidthConstraints.maximum = std::max(intrinsicWidthConstraints.maximum, childIntrinsicWidthConstraints-&gt;maximum + marginBorderAndPadding);
341         }
342         return intrinsicWidthConstraints;
343     };
344     // FIXME Check for box-sizing: border-box;
345     auto intrinsicWidthConstraints = constrainByMinMaxWidth(layoutBox, computedIntrinsicWidthConstraints());
346     intrinsicWidthConstraints.expand(fixedMarginBorderAndPadding(layoutBox));
347     return intrinsicWidthConstraints;
348 }
349 
350 }
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;BlockFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
<span class="line-added"> 31 #include &quot;BlockFormattingState.h&quot;</span>
<span class="line-added"> 32 #include &quot;DisplayBox.h&quot;</span>
 33 #include &quot;FormattingContext.h&quot;
 34 #include &quot;InlineFormattingState.h&quot;
 35 #include &quot;LayoutChildIterator.h&quot;
<span class="line-added"> 36 #include &quot;LayoutContext.h&quot;</span>
 37 #include &quot;Logging.h&quot;
 38 #include &lt;wtf/text/TextStream.h&gt;
 39 
 40 namespace WebCore {
 41 namespace Layout {
 42 
<span class="line-modified"> 43 ContentHeightAndMargin BlockFormattingContext::Geometry::inFlowNonReplacedHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues)</span>
 44 {
 45     ASSERT(layoutBox.isInFlow() &amp;&amp; !layoutBox.replaced());
 46     ASSERT(layoutBox.isOverflowVisible());
 47 
<span class="line-modified"> 48     auto compute = [&amp;](const auto&amp; overrideVerticalValues) -&gt; ContentHeightAndMargin {</span>
 49 
 50         // 10.6.3 Block-level non-replaced elements in normal flow when &#39;overflow&#39; computes to &#39;visible&#39;
 51         //
 52         // If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
 53         // If &#39;height&#39; is &#39;auto&#39;, the height depends on whether the element has any block-level children and whether it has padding or borders:
 54         // The element&#39;s height is the distance from its top content edge to the first applicable of the following:
 55         // 1. the bottom edge of the last line box, if the box establishes a inline formatting context with one or more lines
 56         // 2. the bottom edge of the bottom (possibly collapsed) margin of its last in-flow child, if the child&#39;s bottom margin
 57         //    does not collapse with the element&#39;s bottom margin
 58         // 3. the bottom border edge of the last in-flow child whose top margin doesn&#39;t collapse with the element&#39;s bottom margin
 59         // 4. zero, otherwise
 60         // Only children in the normal flow are taken into account (i.e., floating boxes and absolutely positioned boxes are ignored,
 61         // and relatively positioned boxes are considered without their offset). Note that the child box may be an anonymous block box.
 62 
<span class="line-modified"> 63         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);</span>
<span class="line-modified"> 64         auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>

 65         auto nonCollapsedMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified"> 66         auto borderAndPaddingTop = boxGeometry.borderTop() + boxGeometry.paddingTop().valueOr(0);</span>
<span class="line-modified"> 67         auto height = overrideVerticalValues.height ? overrideVerticalValues.height.value() : computedContentHeight(layoutBox);</span>
 68 
<span class="line-modified"> 69         if (height)</span>
<span class="line-modified"> 70             return { *height, nonCollapsedMargin };</span>



 71 
 72         if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowChild())
 73             return { 0, nonCollapsedMargin };
 74 
 75         // 1. the bottom edge of the last line box, if the box establishes a inline formatting context with one or more lines
<span class="line-modified"> 76         auto&amp; layoutContainer = downcast&lt;Container&gt;(layoutBox);</span>
<span class="line-modified"> 77         if (layoutContainer.establishesInlineFormattingContext()) {</span>
<span class="line-added"> 78             auto&amp; lineBoxes = layoutState().establishedInlineFormattingState(layoutContainer).displayInlineContent()-&gt;lineBoxes;</span>
 79             // Even empty containers generate one line.
 80             ASSERT(!lineBoxes.isEmpty());
<span class="line-modified"> 81             return { toLayoutUnit(lineBoxes.last().bottom()) - borderAndPaddingTop, nonCollapsedMargin };</span>
 82         }
 83 
 84         // 2. the bottom edge of the bottom (possibly collapsed) margin of its last in-flow child, if the child&#39;s bottom margin...
<span class="line-modified"> 85         auto* lastInFlowChild = layoutContainer.lastInFlowChild();</span>
 86         ASSERT(lastInFlowChild);
<span class="line-modified"> 87         if (!formattingContext().marginCollapse().marginAfterCollapsesWithParentMarginAfter(*lastInFlowChild)) {</span>
<span class="line-modified"> 88             auto&amp; lastInFlowBoxGeometry = formattingContext().geometryForBox(*lastInFlowChild);</span>
<span class="line-modified"> 89             auto bottomEdgeOfBottomMargin = lastInFlowBoxGeometry.bottom() + (lastInFlowBoxGeometry.hasCollapsedThroughMargin() ? LayoutUnit() : lastInFlowBoxGeometry.marginAfter());</span>
 90             return { bottomEdgeOfBottomMargin - borderAndPaddingTop, nonCollapsedMargin };
 91         }
 92 
 93         // 3. the bottom border edge of the last in-flow child whose top margin doesn&#39;t collapse with the element&#39;s bottom margin
 94         auto* inFlowChild = lastInFlowChild;
<span class="line-modified"> 95         while (inFlowChild &amp;&amp; formattingContext().marginCollapse().marginBeforeCollapsesWithParentMarginAfter(*inFlowChild))</span>
 96             inFlowChild = inFlowChild-&gt;previousInFlowSibling();
 97         if (inFlowChild) {
<span class="line-modified"> 98             auto&amp; inFlowDisplayBoxGeometry = formattingContext().geometryForBox(*inFlowChild);</span>
<span class="line-modified"> 99             return { inFlowDisplayBoxGeometry.top() + inFlowDisplayBoxGeometry.borderBox().height() - borderAndPaddingTop, nonCollapsedMargin };</span>
100         }
101 
102         // 4. zero, otherwise
103         return { 0, nonCollapsedMargin };
104     };
105 
<span class="line-modified">106     // 10.6.7 &#39;Auto&#39; heights for block formatting context roots</span>
<span class="line-modified">107     auto isAutoHeight = !overrideVerticalValues.height &amp;&amp; !computedContentHeight(layoutBox);</span>
<span class="line-modified">108     if (isAutoHeight &amp;&amp; layoutBox.establishesBlockFormattingContext())</span>
<span class="line-added">109         return compute( OverrideVerticalValues { contentHeightForFormattingContextRoot(layoutBox) });</span>
<span class="line-added">110     return compute(overrideVerticalValues);</span>
111 }
112 
<span class="line-modified">113 ContentWidthAndMargin BlockFormattingContext::Geometry::inFlowNonReplacedWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues) const</span>
114 {
115     ASSERT(layoutBox.isInFlow());
116 
117     auto compute = [&amp;]() {
118 
119         // 10.3.3 Block-level, non-replaced elements in normal flow
120         //
121         // The following constraints must hold among the used values of the other properties:
122         // &#39;margin-left&#39; + &#39;border-left-width&#39; + &#39;padding-left&#39; + &#39;width&#39; + &#39;padding-right&#39; + &#39;border-right-width&#39; + &#39;margin-right&#39; = width of containing block
123         //
124         // 1. If &#39;width&#39; is not &#39;auto&#39; and &#39;border-left-width&#39; + &#39;padding-left&#39; + &#39;width&#39; + &#39;padding-right&#39; + &#39;border-right-width&#39;
125         //    (plus any of &#39;margin-left&#39; or &#39;margin-right&#39; that are not &#39;auto&#39;) is larger than the width of the containing block, then
126         //    any &#39;auto&#39; values for &#39;margin-left&#39; or &#39;margin-right&#39; are, for the following rules, treated as zero.
127         //
128         // 2. If all of the above have a computed value other than &#39;auto&#39;, the values are said to be &quot;over-constrained&quot; and one of the used values will
129         //    have to be different from its computed value. If the &#39;direction&#39; property of the containing block has the value &#39;ltr&#39;, the specified value
130         //    of &#39;margin-right&#39; is ignored and the value is calculated so as to make the equality true. If the value of &#39;direction&#39; is &#39;rtl&#39;,
131         //    this happens to &#39;margin-left&#39; instead.
132         //
133         // 3. If there is exactly one value specified as &#39;auto&#39;, its used value follows from the equality.
134         //
135         // 4. If &#39;width&#39; is set to &#39;auto&#39;, any other &#39;auto&#39; values become &#39;0&#39; and &#39;width&#39; follows from the resulting equality.
136         //
137         // 5. If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, their used values are equal. This horizontally centers the element with respect to the
138         //    edges of the containing block.
139 
<span class="line-modified">140         auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
<span class="line-modified">141         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);</span>


142 
<span class="line-modified">143         auto width = overrideHorizontalValues.width ? overrideHorizontalValues.width : computedContentWidth(layoutBox, containingBlockWidth);</span>
<span class="line-modified">144         auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
145         UsedHorizontalMargin usedHorizontalMargin;
<span class="line-modified">146         auto borderLeft = boxGeometry.borderLeft();</span>
<span class="line-modified">147         auto borderRight = boxGeometry.borderRight();</span>
<span class="line-modified">148         auto paddingLeft = boxGeometry.paddingLeft().valueOr(0);</span>
<span class="line-modified">149         auto paddingRight = boxGeometry.paddingRight().valueOr(0);</span>




150 
151         // #1
152         if (width) {
<span class="line-modified">153             auto horizontalSpaceForMargin = containingBlockWidth - (computedHorizontalMargin.start.valueOr(0) + borderLeft + paddingLeft + *width + paddingRight + borderRight + computedHorizontalMargin.end.valueOr(0));</span>
154             if (horizontalSpaceForMargin &lt; 0)
155                 usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
156         }
157 
158         // #2
159         if (width &amp;&amp; computedHorizontalMargin.start &amp;&amp; computedHorizontalMargin.end) {
<span class="line-modified">160             if (layoutBox.containingBlock()-&gt;style().isLeftToRightDirection()) {</span>
161                 usedHorizontalMargin.start = *computedHorizontalMargin.start;
<span class="line-modified">162                 usedHorizontalMargin.end = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight);</span>
163             } else {
164                 usedHorizontalMargin.end = *computedHorizontalMargin.end;
<span class="line-modified">165                 usedHorizontalMargin.start = containingBlockWidth - (borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);</span>
166             }
167         }
168 
169         // #3
170         if (!computedHorizontalMargin.start &amp;&amp; width &amp;&amp; computedHorizontalMargin.end) {
171             usedHorizontalMargin.end = *computedHorizontalMargin.end;
<span class="line-modified">172             usedHorizontalMargin.start = containingBlockWidth - (borderLeft + paddingLeft  + *width + paddingRight + borderRight + usedHorizontalMargin.end);</span>
173         } else if (computedHorizontalMargin.start &amp;&amp; !width &amp;&amp; computedHorizontalMargin.end) {
174             usedHorizontalMargin = { *computedHorizontalMargin.start, *computedHorizontalMargin.end };
175             width = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end);
176         } else if (computedHorizontalMargin.start &amp;&amp; width &amp;&amp; !computedHorizontalMargin.end) {
177             usedHorizontalMargin.start = *computedHorizontalMargin.start;
<span class="line-modified">178             usedHorizontalMargin.end = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight);</span>
179         }
180 
181         // #4
182         if (!width) {
183             usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
184             width = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end);
185         }
186 
187         // #5
188         if (!computedHorizontalMargin.start &amp;&amp; !computedHorizontalMargin.end) {
<span class="line-modified">189             auto horizontalSpaceForMargin = containingBlockWidth - (borderLeft + paddingLeft  + *width + paddingRight + borderRight);</span>
190             usedHorizontalMargin = { horizontalSpaceForMargin / 2, horizontalSpaceForMargin / 2 };
191         }
192 
193         ASSERT(width);
194 
<span class="line-modified">195         return ContentWidthAndMargin { *width, usedHorizontalMargin, computedHorizontalMargin };</span>
196     };
197 
<span class="line-modified">198     auto contentWidthAndMargin = compute();</span>
<span class="line-modified">199     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow non-replaced -&gt; width(&quot; &lt;&lt; contentWidthAndMargin.contentWidth &lt;&lt; &quot;px) margin(&quot; &lt;&lt; contentWidthAndMargin.usedMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; contentWidthAndMargin.usedMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">200     return contentWidthAndMargin;</span>
201 }
202 
<span class="line-modified">203 ContentWidthAndMargin BlockFormattingContext::Geometry::inFlowReplacedWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues) const</span>
204 {
205     ASSERT(layoutBox.isInFlow() &amp;&amp; layoutBox.replaced());
206 
207     // 10.3.4 Block-level, replaced elements in normal flow
208     //
209     // 1. The used value of &#39;width&#39; is determined as for inline replaced elements.
210     // 2. Then the rules for non-replaced block-level elements are applied to determine the margins.
211 
212     // #1
<span class="line-modified">213     auto usedWidth = inlineReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues).contentWidth;</span>
214     // #2
<span class="line-modified">215     auto nonReplacedWidthAndMargin = inFlowNonReplacedWidthAndMargin(layoutBox, horizontalConstraints, OverrideHorizontalValues { usedWidth, overrideHorizontalValues.margin });</span>
216 
<span class="line-modified">217     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow replaced -&gt; width(&quot; &lt;&lt; usedWidth  &lt;&lt; &quot;px) margin(&quot; &lt;&lt; nonReplacedWidthAndMargin.usedMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; nonReplacedWidthAndMargin.usedMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">218     return { usedWidth, nonReplacedWidthAndMargin.usedMargin, nonReplacedWidthAndMargin.computedMargin };</span>
219 }
220 
<span class="line-modified">221 LayoutUnit BlockFormattingContext::Geometry::staticVerticalPosition(const Box&amp; layoutBox, const VerticalConstraints&amp; verticalConstraints) const</span>
222 {
223     // https://www.w3.org/TR/CSS22/visuren.html#block-formatting
224     // In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block.
225     // The vertical distance between two sibling boxes is determined by the &#39;margin&#39; properties.
226     // Vertical margins between adjacent block-level boxes in a block formatting context collapse.
227     if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
<span class="line-modified">228         auto&amp; previousInFlowBoxGeometry = formattingContext().geometryForBox(*previousInFlowSibling);</span>
<span class="line-modified">229         return previousInFlowBoxGeometry.bottom() + previousInFlowBoxGeometry.marginAfter();</span>
230     }
<span class="line-modified">231     return verticalConstraints.logicalTop;</span>
232 }
233 
<span class="line-modified">234 LayoutUnit BlockFormattingContext::Geometry::staticHorizontalPosition(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
235 {
236     // https://www.w3.org/TR/CSS22/visuren.html#block-formatting
237     // In a block formatting context, each box&#39;s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch).
<span class="line-modified">238     return horizontalConstraints.logicalLeft + formattingContext().geometryForBox(layoutBox).marginStart();</span>
239 }
240 
<span class="line-modified">241 Point BlockFormattingContext::Geometry::staticPosition(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints) const</span>
242 {
<span class="line-modified">243     return { staticHorizontalPosition(layoutBox, horizontalConstraints), staticVerticalPosition(layoutBox, verticalConstraints) };</span>
244 }
245 
<span class="line-modified">246 ContentHeightAndMargin BlockFormattingContext::Geometry::inFlowHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues)</span>
247 {
248     ASSERT(layoutBox.isInFlow());
249 
250     // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39;
251     // replaced elements in normal flow and floating replaced elements
252     if (layoutBox.replaced())
<span class="line-modified">253         return inlineReplacedHeightAndMargin(layoutBox, horizontalConstraints, { }, overrideVerticalValues);</span>
<span class="line-modified">254 </span>
<span class="line-modified">255     ContentHeightAndMargin contentHeightAndMargin;</span>
<span class="line-modified">256     // FIXME: Let&#39;s special case the table height computation for now -&gt; figure out whether tables fall into the &quot;inFlowNonReplacedHeightAndMargin&quot; category.</span>
<span class="line-modified">257     if (layoutBox.establishesTableFormattingContext())</span>
<span class="line-modified">258         contentHeightAndMargin = complicatedCases(layoutBox, horizontalConstraints, overrideVerticalValues);</span>
<span class="line-modified">259     else if (layoutBox.isOverflowVisible() &amp;&amp; !layoutBox.isDocumentBox()) {</span>
<span class="line-added">260         // TODO: Figure out the case for the document element. Let&#39;s just complicated-case it for now.</span>
<span class="line-added">261         contentHeightAndMargin = inFlowNonReplacedHeightAndMargin(layoutBox, horizontalConstraints, overrideVerticalValues);</span>
<span class="line-added">262     } else {</span>
263         // 10.6.6 Complicated cases
264         // Block-level, non-replaced elements in normal flow when &#39;overflow&#39; does not compute to &#39;visible&#39; (except if the &#39;overflow&#39; property&#39;s value has been propagated to the viewport).
<span class="line-modified">265         contentHeightAndMargin = complicatedCases(layoutBox, horizontalConstraints, overrideVerticalValues);</span>

266     }
267 
<span class="line-modified">268     auto quirks = formattingContext().quirks();</span>
<span class="line-modified">269     if (!quirks.needsStretching(layoutBox))</span>
<span class="line-added">270         return contentHeightAndMargin;</span>
271 
<span class="line-modified">272     contentHeightAndMargin = quirks.stretchedInFlowHeight(layoutBox, contentHeightAndMargin);</span>
273 
<span class="line-modified">274     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; inflow non-replaced -&gt; streched to viewport -&gt; height(&quot; &lt;&lt; contentHeightAndMargin.contentHeight &lt;&lt; &quot;px) margin(&quot; &lt;&lt; contentHeightAndMargin.nonCollapsedMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; contentHeightAndMargin.nonCollapsedMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">275     return contentHeightAndMargin;</span>
276 }
277 
<span class="line-modified">278 ContentWidthAndMargin BlockFormattingContext::Geometry::inFlowWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
279 {
280     ASSERT(layoutBox.isInFlow());
281 
282     if (!layoutBox.replaced()) {
<span class="line-modified">283         if (!layoutBox.establishesTableFormattingContext())</span>
<span class="line-modified">284             return inFlowNonReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
<span class="line-modified">285         // This is a special table &quot;fit-content size&quot; behavior handling. Not in the spec though.</span>
<span class="line-modified">286         // Table returns its final width as min/max. Use this final width value to computed horizontal margins etc.</span>
<span class="line-modified">287         auto usedWidth = overrideHorizontalValues.width ? overrideHorizontalValues.width : shrinkToFitWidth(layoutBox, horizontalConstraints.logicalWidth);</span>
<span class="line-modified">288         return inFlowNonReplacedWidthAndMargin(layoutBox, horizontalConstraints, OverrideHorizontalValues { usedWidth, overrideHorizontalValues.margin });</span>
289     }
<span class="line-modified">290     return inFlowReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
291 }
292 
<span class="line-modified">293 FormattingContext::IntrinsicWidthConstraints BlockFormattingContext::Geometry::intrinsicWidthConstraints(const Box&amp; layoutBox)</span>
294 {
295     auto fixedMarginBorderAndPadding = [&amp;](auto&amp; layoutBox) {
296         auto&amp; style = layoutBox.style();
297         return fixedValue(style.marginStart()).valueOr(0)
298             + LayoutUnit { style.borderLeftWidth() }
299             + fixedValue(style.paddingLeft()).valueOr(0)
300             + fixedValue(style.paddingRight()).valueOr(0)
301             + LayoutUnit { style.borderRightWidth() }
302             + fixedValue(style.marginEnd()).valueOr(0);
303     };
304 
305     auto computedIntrinsicWidthConstraints = [&amp;]() -&gt; IntrinsicWidthConstraints {
306         auto&amp; style = layoutBox.style();
307         if (auto width = fixedValue(style.logicalWidth()))
308             return { *width, *width };
309 
310         // Minimum/maximum width can&#39;t be depending on the containing block&#39;s width.
311         if (!style.logicalWidth().isAuto())
312             return { };
313 
314         if (auto* replaced = layoutBox.replaced()) {
315             if (replaced-&gt;hasIntrinsicWidth()) {
316                 auto replacedWidth = replaced-&gt;intrinsicWidth();
317                 return { replacedWidth, replacedWidth };
318             }
319             return { };
320         }
321 



322         if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
323             return { };
324 
<span class="line-added">325         if (layoutBox.establishesFormattingContext())</span>
<span class="line-added">326             return LayoutContext::createFormattingContext(downcast&lt;Container&gt;(layoutBox), layoutState())-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-added">327 </span>
328         auto intrinsicWidthConstraints = IntrinsicWidthConstraints { };
<span class="line-modified">329         auto&amp; formattingState = layoutState().formattingStateForBox(layoutBox);</span>
330         for (auto&amp; child : childrenOfType&lt;Box&gt;(downcast&lt;Container&gt;(layoutBox))) {
331             if (child.isOutOfFlowPositioned())
332                 continue;
333             auto childIntrinsicWidthConstraints = formattingState.intrinsicWidthConstraintsForBox(child);
334             ASSERT(childIntrinsicWidthConstraints);
335 
336             // FIXME Check for box-sizing: border-box;
337             auto marginBorderAndPadding = fixedMarginBorderAndPadding(child);
338             intrinsicWidthConstraints.minimum = std::max(intrinsicWidthConstraints.minimum, childIntrinsicWidthConstraints-&gt;minimum + marginBorderAndPadding);
339             intrinsicWidthConstraints.maximum = std::max(intrinsicWidthConstraints.maximum, childIntrinsicWidthConstraints-&gt;maximum + marginBorderAndPadding);
340         }
341         return intrinsicWidthConstraints;
342     };
343     // FIXME Check for box-sizing: border-box;
344     auto intrinsicWidthConstraints = constrainByMinMaxWidth(layoutBox, computedIntrinsicWidthConstraints());
345     intrinsicWidthConstraints.expand(fixedMarginBorderAndPadding(layoutBox));
346     return intrinsicWidthConstraints;
347 }
348 
349 }
</pre>
</td>
</tr>
</table>
<center><a href="BlockFormattingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BlockFormattingContextQuirks.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
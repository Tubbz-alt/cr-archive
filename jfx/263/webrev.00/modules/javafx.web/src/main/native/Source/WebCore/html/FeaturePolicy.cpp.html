<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/FeaturePolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FeaturePolicy.h&quot;
 28 
 29 #include &quot;DOMWindow.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;HTMLIFrameElement.h&quot;
 32 #include &quot;HTMLNames.h&quot;
 33 #include &quot;HTMLParserIdioms.h&quot;
 34 #include &quot;SecurityOrigin.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 using namespace HTMLNames;
 39 
 40 static const char* policyTypeName(FeaturePolicy::Type type)
 41 {
 42     switch (type) {
 43     case FeaturePolicy::Type::Camera:
 44         return &quot;Camera&quot;;
 45     case FeaturePolicy::Type::Microphone:
 46         return &quot;Microphone&quot;;
 47     case FeaturePolicy::Type::DisplayCapture:
 48         return &quot;DisplayCapture&quot;;
 49     case FeaturePolicy::Type::SyncXHR:
 50         return &quot;SyncXHR&quot;;
 51     case FeaturePolicy::Type::Fullscreen:
 52         return &quot;Fullscreen&quot;;
 53     }
 54     ASSERT_NOT_REACHED();
 55     return &quot;&quot;;
 56 }
 57 
 58 bool isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type type, const Document&amp; document, LogFeaturePolicyFailure logFailure)
 59 {
 60     auto&amp; topDocument = document.topDocument();
 61     auto* ancestorDocument = &amp;document;
 62     while (ancestorDocument != &amp;topDocument) {
 63         if (!ancestorDocument) {
 64             if (logFailure == LogFeaturePolicyFailure::Yes &amp;&amp; document.domWindow())
 65                 document.domWindow()-&gt;printErrorMessage(makeString(&quot;Feature policy &#39;&quot;, policyTypeName(type), &quot;&#39; check failed.&quot;));
 66             return false;
 67         }
 68 
 69         auto* ownerElement = ancestorDocument-&gt;ownerElement();
 70         if (is&lt;HTMLIFrameElement&gt;(ownerElement)) {
 71             const auto&amp; featurePolicy = downcast&lt;HTMLIFrameElement&gt;(ownerElement)-&gt;featurePolicy();
 72             if (!featurePolicy.allows(type, ancestorDocument-&gt;securityOrigin().data())) {
 73                 if (logFailure == LogFeaturePolicyFailure::Yes &amp;&amp; document.domWindow()) {
 74                     auto&amp; allowValue = downcast&lt;HTMLIFrameElement&gt;(ownerElement)-&gt;attributeWithoutSynchronization(HTMLNames::allowAttr);
 75                     document.domWindow()-&gt;printErrorMessage(makeString(&quot;Feature policy &#39;&quot;, policyTypeName(type), &quot;&#39; check failed for iframe with origin &#39;&quot;, document.securityOrigin().toString(), &quot;&#39; and allow attribute &#39;&quot;, allowValue, &quot;&#39;.&quot;));
 76                 }
 77                 return false;
 78             }
 79         }
 80 
 81         ancestorDocument = ancestorDocument-&gt;parentDocument();
 82     }
 83 
 84     return true;
 85 }
 86 
 87 static bool isAllowedByFeaturePolicy(const FeaturePolicy::AllowRule&amp; rule, const SecurityOriginData&amp; origin)
 88 {
 89     switch (rule.type) {
 90     case FeaturePolicy::AllowRule::Type::None:
 91         return false;
 92     case FeaturePolicy::AllowRule::Type::All:
 93         return true;
 94     case FeaturePolicy::AllowRule::Type::List:
 95         return rule.allowedList.contains(origin);
 96     }
 97     ASSERT_NOT_REACHED();
 98     return false;
 99 }
100 
101 static inline void processOriginItem(Document&amp; document, FeaturePolicy::AllowRule&amp; rule, StringView item)
102 {
103     if (rule.type == FeaturePolicy::AllowRule::Type::None)
104         return;
105 
106     item = item.stripLeadingAndTrailingMatchedCharacters(isHTMLSpace&lt;UChar&gt;);
107     // FIXME: Support &#39;src&#39;.
108     if (item == &quot;&#39;src&#39;&quot;)
109         return;
110 
111     if (item == &quot;*&quot;) {
112         rule.type = FeaturePolicy::AllowRule::Type::All;
113         return;
114     }
115 
116     if (item == &quot;&#39;self&#39;&quot;) {
117         rule.allowedList.add(document.securityOrigin().data());
118         return;
119     }
120     if (item == &quot;&#39;none&#39;&quot;) {
121         rule.type = FeaturePolicy::AllowRule::Type::None;
122         return;
123     }
124     URL url { { }, item.toString() };
125     if (url.isValid())
126         rule.allowedList.add(SecurityOriginData::fromURL(url));
127 }
128 
129 static inline void updateList(Document&amp; document, FeaturePolicy::AllowRule&amp; rule, StringView value)
130 {
131     // We keep the empty string value equivalent to &#39;*&#39; for existing websites.
132     if (value.isEmpty()) {
133         rule.type = FeaturePolicy::AllowRule::Type::All;
134         return;
135     }
136 
137     while (!value.isEmpty()) {
138         auto position = value.find(isHTMLSpace&lt;UChar&gt;);
139         if (position == notFound) {
140             processOriginItem(document, rule, value);
141             return;
142         }
143 
144         processOriginItem(document, rule, value.substring(0, position));
145         value = value.substring(position + 1).stripLeadingAndTrailingMatchedCharacters(isHTMLSpace&lt;UChar&gt;);
146     }
147 }
148 
149 FeaturePolicy FeaturePolicy::parse(Document&amp; document, const HTMLIFrameElement&amp; iframe, StringView allowAttributeValue)
150 {
151     FeaturePolicy policy;
152     bool isCameraInitialized = false;
153     bool isMicrophoneInitialized = false;
154     bool isDisplayCaptureInitialized = false;
155     bool isSyncXHRInitialized = false;
156     bool isFullscreenInitialized = false;
157     for (auto allowItem : allowAttributeValue.split(&#39;;&#39;)) {
158         auto item = allowItem.stripLeadingAndTrailingMatchedCharacters(isHTMLSpace&lt;UChar&gt;);
159         if (item.startsWith(&quot;camera&quot;)) {
160             isCameraInitialized = true;
161             updateList(document, policy.m_cameraRule, item.substring(7));
162             continue;
163         }
164         if (item.startsWith(&quot;microphone&quot;)) {
165             isMicrophoneInitialized = true;
166             updateList(document, policy.m_microphoneRule, item.substring(11));
167             continue;
168         }
169         if (item.startsWith(&quot;display-capture&quot;)) {
170             isDisplayCaptureInitialized = true;
171             updateList(document, policy.m_displayCaptureRule, item.substring(16));
172             continue;
173         }
174         if (item.startsWith(&quot;sync-xhr&quot;)) {
175             isSyncXHRInitialized = true;
176             updateList(document, policy.m_syncXHRRule, item.substring(8));
177             continue;
178         }
179         if (item.startsWith(&quot;fullscreen&quot;)) {
180             isFullscreenInitialized = true;
181             updateList(document, policy.m_fullscreenRule, item.substring(11));
182             continue;
183         }
184     }
185 
186     // By default, camera, microphone, display-capture, and fullscreen policy is &#39;self&#39;
187     if (!isCameraInitialized)
188         policy.m_cameraRule.allowedList.add(document.securityOrigin().data());
189     if (!isMicrophoneInitialized)
190         policy.m_microphoneRule.allowedList.add(document.securityOrigin().data());
191     if (!isDisplayCaptureInitialized)
192         policy.m_displayCaptureRule.allowedList.add(document.securityOrigin().data());
193 
194     // https://w3c.github.io/webappsec-feature-policy/#process-feature-policy-attributes
195     // 9.5 Process Feature Policy Attributes
196     // 3.1 If elementâ€™s allowfullscreen attribute is specified, and container policy does
197     //     not contain an allowlist for fullscreen,
198     if (!isFullscreenInitialized) {
199         if (iframe.hasAttribute(allowfullscreenAttr) || iframe.hasAttribute(webkitallowfullscreenAttr)) {
200             // 3.1.1 Construct a new declaration for fullscreen, whose allowlist is the special value *.
201             policy.m_fullscreenRule.type = FeaturePolicy::AllowRule::Type::All;
202         } else {
203             // https://fullscreen.spec.whatwg.org/#feature-policy-integration
204             // The default allowlist is &#39;self&#39;.
205             policy.m_fullscreenRule.allowedList.add(document.securityOrigin().data());
206         }
207     }
208 
209     if (!isSyncXHRInitialized)
210         policy.m_syncXHRRule.type = AllowRule::Type::All;
211 
212     return policy;
213 }
214 
215 bool FeaturePolicy::allows(Type type, const SecurityOriginData&amp; origin) const
216 {
217     switch (type) {
218     case Type::Camera:
219         return isAllowedByFeaturePolicy(m_cameraRule, origin);
220     case Type::Microphone:
221         return isAllowedByFeaturePolicy(m_microphoneRule, origin);
222     case Type::DisplayCapture:
223         return isAllowedByFeaturePolicy(m_displayCaptureRule, origin);
224     case Type::SyncXHR:
225         return isAllowedByFeaturePolicy(m_syncXHRRule, origin);
226     case Type::Fullscreen:
227         return isAllowedByFeaturePolicy(m_fullscreenRule, origin);
228     }
229     ASSERT_NOT_REACHED();
230     return false;
231 }
232 
233 }
    </pre>
  </body>
</html>
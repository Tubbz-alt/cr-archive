<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/SampleMap.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SampleMap.h&quot;
 28 
 29 #include &quot;MediaSample.h&quot;
 30 
 31 namespace WebCore {
 32 
 33 template &lt;typename M&gt;
 34 class SampleIsLessThanMediaTimeComparator {
 35 public:
 36     typedef typename M::value_type value_type;
 37     bool operator()(const value_type&amp; value, const MediaTime&amp; time)
 38     {
 39         MediaTime presentationEndTime = value.second-&gt;presentationTime() + value.second-&gt;duration();
 40         return presentationEndTime &lt;= time;
 41     }
 42     bool operator()(const MediaTime&amp; time, const value_type&amp; value)
 43     {
 44         MediaTime presentationStartTime = value.second-&gt;presentationTime();
 45         return time &lt; presentationStartTime;
 46     }
 47 };
 48 
 49 template &lt;typename M&gt;
 50 class SampleIsGreaterThanMediaTimeComparator {
 51 public:
 52     typedef typename M::value_type value_type;
 53     bool operator()(const value_type&amp; value, const MediaTime&amp; time)
 54     {
 55         MediaTime presentationStartTime = value.second-&gt;presentationTime();
 56         return presentationStartTime &gt; time;
 57     }
 58     bool operator()(const MediaTime&amp; time, const value_type&amp; value)
 59     {
 60         MediaTime presentationEndTime = value.second-&gt;presentationTime() + value.second-&gt;duration();
 61         return time &gt;= presentationEndTime;
 62     }
 63 };
 64 
 65 class SampleIsRandomAccess {
 66 public:
 67     bool operator()(DecodeOrderSampleMap::MapType::value_type&amp; value)
 68     {
 69         return value.second-&gt;flags() == MediaSample::IsSync;
 70     }
 71 };
 72 
 73 // SamplePresentationTimeIsInsideRangeComparator matches (range.first, range.second]
 74 struct SamplePresentationTimeIsInsideRangeComparator {
 75     bool operator()(std::pair&lt;MediaTime, MediaTime&gt; range, const std::pair&lt;MediaTime, RefPtr&lt;MediaSample&gt;&gt;&amp; value)
 76     {
 77         return range.second &lt; value.first;
 78     }
 79     bool operator()(const std::pair&lt;MediaTime, RefPtr&lt;MediaSample&gt;&gt;&amp; value, std::pair&lt;MediaTime, MediaTime&gt; range)
 80     {
 81         return value.first &lt;= range.first;
 82     }
 83 };
 84 
 85 // SamplePresentationTimeIsWithinRangeComparator matches [range.first, range.second)
 86 struct SamplePresentationTimeIsWithinRangeComparator {
 87     bool operator()(std::pair&lt;MediaTime, MediaTime&gt; range, const std::pair&lt;MediaTime, RefPtr&lt;MediaSample&gt;&gt;&amp; value)
 88     {
 89         return range.second &lt;= value.first;
 90     }
 91     bool operator()(const std::pair&lt;MediaTime, RefPtr&lt;MediaSample&gt;&gt;&amp; value, std::pair&lt;MediaTime, MediaTime&gt; range)
 92     {
 93         return value.first &lt; range.first;
 94     }
 95 };
 96 
 97 bool SampleMap::empty() const
 98 {
 99     return presentationOrder().m_samples.empty();
100 }
101 
102 void SampleMap::clear()
103 {
104     presentationOrder().m_samples.clear();
105     decodeOrder().m_samples.clear();
106     m_totalSize = 0;
107 }
108 
109 void SampleMap::addSample(MediaSample&amp; sample)
110 {
111     MediaTime presentationTime = sample.presentationTime();
112 
113     presentationOrder().m_samples.insert(PresentationOrderSampleMap::MapType::value_type(presentationTime, &amp;sample));
114 
115     auto decodeKey = DecodeOrderSampleMap::KeyType(sample.decodeTime(), presentationTime);
116     decodeOrder().m_samples.insert(DecodeOrderSampleMap::MapType::value_type(decodeKey, &amp;sample));
117 
118     m_totalSize += sample.sizeInBytes();
119 }
120 
121 void SampleMap::removeSample(MediaSample* sample)
122 {
123     ASSERT(sample);
124     MediaTime presentationTime = sample-&gt;presentationTime();
125 
126     m_totalSize -= sample-&gt;sizeInBytes();
127 
128     auto decodeKey = DecodeOrderSampleMap::KeyType(sample-&gt;decodeTime(), presentationTime);
129     presentationOrder().m_samples.erase(presentationTime);
130     decodeOrder().m_samples.erase(decodeKey);
131 }
132 
133 PresentationOrderSampleMap::iterator PresentationOrderSampleMap::findSampleWithPresentationTime(const MediaTime&amp; time)
134 {
135     auto range = m_samples.equal_range(time);
136     if (range.first == range.second)
137         return end();
138     return range.first;
139 }
140 
141 PresentationOrderSampleMap::iterator PresentationOrderSampleMap::findSampleContainingPresentationTime(const MediaTime&amp; time)
142 {
143     // upper_bound will return the first sample whose presentation start time is greater than the search time.
144     // If this is the first sample, that means no sample in the map contains the requested time.
145     auto iter = m_samples.upper_bound(time);
146     if (iter == begin())
147         return end();
148 
149     // Look at the previous sample; does it contain the requested time?
150     --iter;
151     MediaSample&amp; sample = *iter-&gt;second;
152     if (sample.presentationTime() + sample.duration() &gt; time)
153         return iter;
154     return end();
155 }
156 
157 PresentationOrderSampleMap::iterator PresentationOrderSampleMap::findSampleContainingOrAfterPresentationTime(const MediaTime&amp; time)
158 {
159     if (m_samples.empty())
160         return end();
161 
162     // upper_bound will return the first sample whose presentation start time is greater than the search time.
163     // If this is the first sample, that means no sample in the map contains the requested time.
164     auto iter = m_samples.upper_bound(time);
165     if (iter == begin())
166         return iter;
167 
168     // Look at the previous sample; does it contain the requested time?
169     --iter;
170     MediaSample&amp; sample = *iter-&gt;second;
171     if (sample.presentationTime() + sample.duration() &gt; time)
172         return iter;
173     return ++iter;
174 }
175 
176 PresentationOrderSampleMap::iterator PresentationOrderSampleMap::findSampleStartingOnOrAfterPresentationTime(const MediaTime&amp; time)
177 {
178     return m_samples.lower_bound(time);
179 }
180 
181 PresentationOrderSampleMap::iterator PresentationOrderSampleMap::findSampleStartingAfterPresentationTime(const MediaTime&amp; time)
182 {
183     return m_samples.upper_bound(time);
184 }
185 
186 DecodeOrderSampleMap::iterator DecodeOrderSampleMap::findSampleWithDecodeKey(const KeyType&amp; key)
187 {
188     return m_samples.find(key);
189 }
190 
191 PresentationOrderSampleMap::reverse_iterator PresentationOrderSampleMap::reverseFindSampleContainingPresentationTime(const MediaTime&amp; time)
192 {
193     auto range = std::equal_range(rbegin(), rend(), time, SampleIsGreaterThanMediaTimeComparator&lt;MapType&gt;());
194     if (range.first == range.second)
195         return rend();
196     return range.first;
197 }
198 
199 PresentationOrderSampleMap::reverse_iterator PresentationOrderSampleMap::reverseFindSampleBeforePresentationTime(const MediaTime&amp; time)
200 {
201     if (m_samples.empty())
202         return rend();
203 
204     // upper_bound will return the first sample whose presentation start time is greater than the search time.
205     auto found = m_samples.upper_bound(time);
206 
207     // If no sample was found with a time greater than the search time, return the last sample.
208     if (found == end())
209         return rbegin();
210 
211     // If the first sample has a time grater than the search time, no samples will have a presentation time before the search time.
212     if (found == begin())
213         return rend();
214 
215     // Otherwise, return the sample immediately previous to the one found.
216     return --reverse_iterator(--found);
217 }
218 
219 DecodeOrderSampleMap::reverse_iterator DecodeOrderSampleMap::reverseFindSampleWithDecodeKey(const KeyType&amp; key)
220 {
221     DecodeOrderSampleMap::iterator found = findSampleWithDecodeKey(key);
222     if (found == end())
223         return rend();
224     return --reverse_iterator(found);
225 }
226 
227 DecodeOrderSampleMap::reverse_iterator DecodeOrderSampleMap::findSyncSamplePriorToPresentationTime(const MediaTime&amp; time, const MediaTime&amp; threshold)
228 {
229     PresentationOrderSampleMap::reverse_iterator reverseCurrentSamplePTS = m_presentationOrder.reverseFindSampleBeforePresentationTime(time);
230     if (reverseCurrentSamplePTS == m_presentationOrder.rend())
231         return rend();
232 
233     const RefPtr&lt;MediaSample&gt;&amp; sample = reverseCurrentSamplePTS-&gt;second;
234     reverse_iterator reverseCurrentSampleDTS = reverseFindSampleWithDecodeKey(KeyType(sample-&gt;decodeTime(), sample-&gt;presentationTime()));
235 
236     reverse_iterator foundSample = findSyncSamplePriorToDecodeIterator(reverseCurrentSampleDTS);
237     if (foundSample == rend())
238         return rend();
239     if (foundSample-&gt;second-&gt;presentationTime() &lt; time - threshold)
240         return rend();
241     return foundSample;
242 }
243 
244 DecodeOrderSampleMap::reverse_iterator DecodeOrderSampleMap::findSyncSamplePriorToDecodeIterator(reverse_iterator iterator)
245 {
246     return std::find_if(iterator, rend(), SampleIsRandomAccess());
247 }
248 
249 DecodeOrderSampleMap::iterator DecodeOrderSampleMap::findSyncSampleAfterPresentationTime(const MediaTime&amp; time, const MediaTime&amp; threshold)
250 {
251     PresentationOrderSampleMap::iterator currentSamplePTS = m_presentationOrder.findSampleStartingOnOrAfterPresentationTime(time);
252     if (currentSamplePTS == m_presentationOrder.end())
253         return end();
254 
255     const RefPtr&lt;MediaSample&gt;&amp; sample = currentSamplePTS-&gt;second;
256     iterator currentSampleDTS = findSampleWithDecodeKey(KeyType(sample-&gt;decodeTime(), sample-&gt;presentationTime()));
257 
258     MediaTime upperBound = time + threshold;
259     iterator foundSample = std::find_if(currentSampleDTS, end(), SampleIsRandomAccess());
260     if (foundSample == end())
261         return end();
262     if (foundSample-&gt;second-&gt;presentationTime() &gt; upperBound)
263         return end();
264     return foundSample;
265 }
266 
267 DecodeOrderSampleMap::iterator DecodeOrderSampleMap::findSyncSampleAfterDecodeIterator(iterator currentSampleDTS)
268 {
269     if (currentSampleDTS == end())
270         return end();
271     return std::find_if(++currentSampleDTS, end(), SampleIsRandomAccess());
272 }
273 
274 PresentationOrderSampleMap::iterator_range PresentationOrderSampleMap::findSamplesBetweenPresentationTimes(const MediaTime&amp; beginTime, const MediaTime&amp; endTime)
275 {
276     // startTime is inclusive, so use lower_bound to include samples wich start exactly at startTime.
277     // endTime is not inclusive, so use lower_bound to exclude samples which start exactly at endTime.
278     auto lower_bound = m_samples.lower_bound(beginTime);
279     auto upper_bound = m_samples.lower_bound(endTime);
280     if (lower_bound == upper_bound)
281         return { end(), end() };
282     return { lower_bound, upper_bound };
283 }
284 
285 PresentationOrderSampleMap::iterator_range PresentationOrderSampleMap::findSamplesBetweenPresentationTimesFromEnd(const MediaTime&amp; beginTime, const MediaTime&amp; endTime)
286 {
287     reverse_iterator rangeEnd = std::find_if(rbegin(), rend(), [&amp;endTime](auto&amp; value) {
288         return value.first &lt; endTime;
289     });
290 
291     reverse_iterator rangeStart = std::find_if(rangeEnd, rend(), [&amp;beginTime](auto&amp; value) {
292         return value.first &lt; beginTime;
293     });
294 
295     if (rangeStart == rangeEnd)
296         return { end(), end() };
297 
298     // ( rangeStart, rangeEnd ] == [ rangeStart.base(), rangeEnd.base() )
299     return { rangeStart.base(), rangeEnd.base() };
300 }
301 
302 DecodeOrderSampleMap::reverse_iterator_range DecodeOrderSampleMap::findDependentSamples(MediaSample* sample)
303 {
304     ASSERT(sample);
305     reverse_iterator currentDecodeIter = reverseFindSampleWithDecodeKey(KeyType(sample-&gt;decodeTime(), sample-&gt;presentationTime()));
306     reverse_iterator nextSyncSample = findSyncSamplePriorToDecodeIterator(currentDecodeIter);
307     return reverse_iterator_range(currentDecodeIter, nextSyncSample);
308 }
309 
310 DecodeOrderSampleMap::iterator_range DecodeOrderSampleMap::findSamplesBetweenDecodeKeys(const KeyType&amp; beginKey, const KeyType&amp; endKey)
311 {
312     if (beginKey &gt; endKey)
313         return { end(), end() };
314 
315     // beginKey is inclusive, so use lower_bound to include samples wich start exactly at beginKey.
316     // endKey is not inclusive, so use lower_bound to exclude samples which start exactly at endKey.
317     auto lower_bound = m_samples.lower_bound(beginKey);
318     auto upper_bound = m_samples.lower_bound(endKey);
319     if (lower_bound == upper_bound)
320         return { end(), end() };
321     return { lower_bound, upper_bound };
322 }
323 
324 }
    </pre>
  </body>
</html>
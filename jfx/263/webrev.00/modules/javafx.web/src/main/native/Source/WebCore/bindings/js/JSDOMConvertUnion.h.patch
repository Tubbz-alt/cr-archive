diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertUnion.h b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertUnion.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertUnion.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertUnion.h
@@ -60,38 +60,38 @@
 template<typename ReturnType, typename T, bool enabled>
 struct ConditionalConverter;
 
 template<typename ReturnType, typename T>
 struct ConditionalConverter<ReturnType, T, true> {
-    static Optional<ReturnType> convert(JSC::ExecState& state, JSC::JSValue value)
+    static Optional<ReturnType> convert(JSC::JSGlobalObject& lexicalGlobalObject, JSC::JSValue value)
     {
-        return ReturnType(Converter<T>::convert(state, value));
+        return ReturnType(Converter<T>::convert(lexicalGlobalObject, value));
     }
 };
 
 template<typename ReturnType, typename T>
 struct ConditionalConverter<ReturnType, T, false> {
-    static Optional<ReturnType> convert(JSC::ExecState&, JSC::JSValue)
+    static Optional<ReturnType> convert(JSC::JSGlobalObject&, JSC::JSValue)
     {
         return WTF::nullopt;
     }
 };
 
 template<typename ReturnType, typename T, bool enabled>
 struct ConditionalSequenceConverter;
 
 template<typename ReturnType, typename T>
 struct ConditionalSequenceConverter<ReturnType, T, true> {
-    static Optional<ReturnType> convert(JSC::ExecState& state, JSC::JSObject* object, JSC::JSValue method)
+    static Optional<ReturnType> convert(JSC::JSGlobalObject& lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method)
     {
-        return ReturnType(Converter<T>::convert(state, object, method));
+        return ReturnType(Converter<T>::convert(lexicalGlobalObject, object, method));
     }
 };
 
 template<typename ReturnType, typename T>
 struct ConditionalSequenceConverter<ReturnType, T, false> {
-    static Optional<ReturnType> convert(JSC::ExecState&, JSC::JSObject*, JSC::JSValue)
+    static Optional<ReturnType> convert(JSC::JSGlobalObject&, JSC::JSObject*, JSC::JSValue)
     {
         return WTF::nullopt;
     }
 };
 
@@ -161,30 +161,30 @@
     static constexpr bool hasAnyObjectType = (numberOfSequenceTypes + numberOfFrozenArrayTypes + numberOfDictionaryTypes + numberOfRecordTypes + numberOfObjectTypes) > 0;
 
     using InterfaceTypeList = brigand::filter<TypeList, IsIDLInterface<brigand::_1>>;
     using TypedArrayTypeList = brigand::filter<TypeList, IsIDLTypedArray<brigand::_1>>;
 
-    static ReturnType convert(JSC::ExecState& state, JSC::JSValue value)
+    static ReturnType convert(JSC::JSGlobalObject& lexicalGlobalObject, JSC::JSValue value)
     {
-        JSC::VM& vm = state.vm();
+        JSC::VM& vm = JSC::getVM(&lexicalGlobalObject);
         auto scope = DECLARE_THROW_SCOPE(vm);
 
         // 1. If the union type includes a nullable type and V is null or undefined, then return the IDL value null.
         constexpr bool hasNullType = brigand::any<TypeList, std::is_same<IDLNull, brigand::_1>>::value;
         if (hasNullType) {
             if (value.isUndefinedOrNull())
-                return ConditionalConverter<ReturnType, IDLNull, hasNullType>::convert(state, value).value();
+                return ConditionalConverter<ReturnType, IDLNull, hasNullType>::convert(lexicalGlobalObject, value).value();
         }
 
         // 2. Let types be the flattened member types of the union type.
         // NOTE: Union is expected to be pre-flattented.
 
         // 3. If V is null or undefined then:
         if (hasDictionaryType) {
             if (value.isUndefinedOrNull()) {
                 //     1. If types includes a dictionary type, then return the result of converting V to that dictionary type.
-                return ConditionalConverter<ReturnType, DictionaryType, hasDictionaryType>::convert(state, value).value();
+                return ConditionalConverter<ReturnType, DictionaryType, hasDictionaryType>::convert(lexicalGlobalObject, value).value();
             }
         }
 
         // 4. If V is a platform object, then:
         //     1. If types includes an interface type that V implements, then return the IDL value that is a reference to the object V.
@@ -198,11 +198,11 @@
 
                 using Type = typename WTF::RemoveCVAndReference<decltype(type)>::type::type;
                 using ImplementationType = typename Type::ImplementationType;
                 using RawType = typename Type::RawType;
 
-                auto castedValue = JSToWrappedOverloader<RawType>::toWrapped(state, value);
+                auto castedValue = JSToWrappedOverloader<RawType>::toWrapped(lexicalGlobalObject, value);
                 if (!castedValue)
                     return;
 
                 returnValue = ReturnType(ImplementationType(castedValue));
             });
@@ -229,21 +229,21 @@
         if (hasArrayBufferType || hasObjectType) {
             auto arrayBuffer = JSC::JSArrayBuffer::toWrapped(vm, value);
             if (arrayBuffer) {
                 if (hasArrayBufferType)
                     return ConditionalReturner<ReturnType, hasArrayBufferType>::get(WTFMove(arrayBuffer)).value();
-                return ConditionalConverter<ReturnType, ObjectType, hasObjectType>::convert(state, value).value();
+                return ConditionalConverter<ReturnType, ObjectType, hasObjectType>::convert(lexicalGlobalObject, value).value();
             }
         }
 
         constexpr bool hasArrayBufferViewType = brigand::any<TypeList, std::is_same<IDLArrayBufferView, brigand::_1>>::value;
         if (hasArrayBufferViewType || hasObjectType) {
             auto arrayBufferView = JSC::JSArrayBufferView::toWrapped(vm, value);
             if (arrayBufferView) {
                 if (hasArrayBufferViewType)
                     return ConditionalReturner<ReturnType, hasArrayBufferViewType>::get(WTFMove(arrayBufferView)).value();
-                return ConditionalConverter<ReturnType, ObjectType, hasObjectType>::convert(state, value).value();
+                return ConditionalConverter<ReturnType, ObjectType, hasObjectType>::convert(lexicalGlobalObject, value).value();
             }
         }
 
         // 8. If Type(V) is Object and V has a [[DataView]] internal slot, then:
         //     1. If types includes DataView, then return the result of converting V to DataView.
@@ -252,11 +252,11 @@
         if (hasDataViewType || hasObjectType) {
             auto dataView = JSC::JSDataView::toWrapped(vm, value);
             if (dataView) {
                 if (hasDataViewType)
                     return ConditionalReturner<ReturnType, hasDataViewType>::get(WTFMove(dataView)).value();
-                return ConditionalConverter<ReturnType, ObjectType, hasObjectType>::convert(state, value).value();
+                return ConditionalConverter<ReturnType, ObjectType, hasObjectType>::convert(lexicalGlobalObject, value).value();
             }
         }
 
         // 9. If Type(V) is Object and V has a [[TypedArrayName]] internal slot, then:
         //     1. If types includes a typed array type whose name is the value of Vâ€™s [[TypedArrayName]] internal slot, then return the result of converting V to that type.
@@ -302,79 +302,79 @@
                     //         2. ReturnIfAbrupt(method).
                     //         3. If method is not undefined, return the result of creating a
                     //            sequence of that type from V and method.
                     constexpr bool hasSequenceType = numberOfSequenceTypes != 0;
                     if (hasSequenceType) {
-                        auto method = JSC::iteratorMethod(state, object);
+                        auto method = JSC::iteratorMethod(&lexicalGlobalObject, object);
                         RETURN_IF_EXCEPTION(scope, ReturnType());
                         if (!method.isUndefined())
-                            return ConditionalSequenceConverter<ReturnType, SequenceType, hasSequenceType>::convert(state, object, method).value();
+                            return ConditionalSequenceConverter<ReturnType, SequenceType, hasSequenceType>::convert(lexicalGlobalObject, object, method).value();
                     }
 
                     //     2. If types includes a frozen array type, then:
                     //         1. Let method be the result of GetMethod(V, @@iterator).
                     //         2. ReturnIfAbrupt(method).
                     //         3. If method is not undefined, return the result of creating a
                     //            frozen array of that type from V and method.
                     constexpr bool hasFrozenArrayType = numberOfFrozenArrayTypes != 0;
                     if (hasFrozenArrayType) {
-                        auto method = JSC::iteratorMethod(state, object);
+                        auto method = JSC::iteratorMethod(&lexicalGlobalObject, object);
                         RETURN_IF_EXCEPTION(scope, ReturnType());
                         if (!method.isUndefined())
-                            return ConditionalSequenceConverter<ReturnType, FrozenArrayType, hasFrozenArrayType>::convert(state, object, method).value();
+                            return ConditionalSequenceConverter<ReturnType, FrozenArrayType, hasFrozenArrayType>::convert(lexicalGlobalObject, object, method).value();
                     }
 
                     //     3. If types includes a dictionary type, then return the result of
                     //        converting V to that dictionary type.
                     if (hasDictionaryType)
-                        return ConditionalConverter<ReturnType, DictionaryType, hasDictionaryType>::convert(state, value).value();
+                        return ConditionalConverter<ReturnType, DictionaryType, hasDictionaryType>::convert(lexicalGlobalObject, value).value();
 
                     //     4. If types includes a record type, then return the result of converting V to that record type.
                     if (hasRecordType)
-                        return ConditionalConverter<ReturnType, RecordType, hasRecordType>::convert(state, value).value();
+                        return ConditionalConverter<ReturnType, RecordType, hasRecordType>::convert(lexicalGlobalObject, value).value();
 
                     //     5. If types includes a callback interface type, then return the result of converting V to that interface type.
                     //         (FIXME: Add support for callback interface type and step 12.5)
 
                     //     6. If types includes object, then return the IDL value that is a reference to the object V.
                     if (hasObjectType)
-                        return ConditionalConverter<ReturnType, ObjectType, hasObjectType>::convert(state, value).value();
+                        return ConditionalConverter<ReturnType, ObjectType, hasObjectType>::convert(lexicalGlobalObject, value).value();
                 }
             }
         }
 
         // 12. If V is a Boolean value, then:
         //     1. If types includes a boolean, then return the result of converting V to boolean.
         constexpr bool hasBooleanType = brigand::any<TypeList, std::is_same<IDLBoolean, brigand::_1>>::value;
         if (hasBooleanType) {
             if (value.isBoolean())
-                return ConditionalConverter<ReturnType, IDLBoolean, hasBooleanType>::convert(state, value).value();
+                return ConditionalConverter<ReturnType, IDLBoolean, hasBooleanType>::convert(lexicalGlobalObject, value).value();
         }
 
         // 13. If V is a Number value, then:
         //     1. If types includes a numeric type, then return the result of converting V to that numeric type.
         constexpr bool hasNumericType = brigand::size<NumericTypeList>::value != 0;
         if (hasNumericType) {
             if (value.isNumber())
-                return ConditionalConverter<ReturnType, NumericType, hasNumericType>::convert(state, value).value();
+                return ConditionalConverter<ReturnType, NumericType, hasNumericType>::convert(lexicalGlobalObject, value).value();
         }
 
         // 14. If types includes a string type, then return the result of converting V to that type.
         constexpr bool hasStringType = brigand::size<StringTypeList>::value != 0;
         if (hasStringType)
-            return ConditionalConverter<ReturnType, StringType, hasStringType>::convert(state, value).value();
+            return ConditionalConverter<ReturnType, StringType, hasStringType>::convert(lexicalGlobalObject, value).value();
 
         // 15. If types includes a numeric type, then return the result of converting V to that numeric type.
         if (hasNumericType)
-            return ConditionalConverter<ReturnType, NumericType, hasNumericType>::convert(state, value).value();
+            return ConditionalConverter<ReturnType, NumericType, hasNumericType>::convert(lexicalGlobalObject, value).value();
 
         // 16. If types includes a boolean, then return the result of converting V to boolean.
         if (hasBooleanType)
-            return ConditionalConverter<ReturnType, IDLBoolean, hasBooleanType>::convert(state, value).value();
+            return ConditionalConverter<ReturnType, IDLBoolean, hasBooleanType>::convert(lexicalGlobalObject, value).value();
 
         // 17. Throw a TypeError.
-        throwTypeError(&state, scope);
+        throwTypeError(&lexicalGlobalObject, scope);
         return ReturnType();
     }
 };
 
 template<typename... T> struct JSConverter<IDLUnion<T...>> {
@@ -385,20 +385,20 @@
     static constexpr bool needsState = true;
     static constexpr bool needsGlobalObject = true;
 
     using Sequence = brigand::make_sequence<brigand::ptrdiff_t<0>, WTF::variant_size<ImplementationType>::value>;
 
-    static JSC::JSValue convert(JSC::ExecState& state, JSDOMGlobalObject& globalObject, const ImplementationType& variant)
+    static JSC::JSValue convert(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const ImplementationType& variant)
     {
         auto index = variant.index();
 
         Optional<JSC::JSValue> returnValue;
         brigand::for_each<Sequence>([&](auto&& type) {
             using I = typename WTF::RemoveCVAndReference<decltype(type)>::type::type;
             if (I::value == index) {
                 ASSERT(!returnValue);
-                returnValue = toJS<brigand::at<TypeList, I>>(state, globalObject, WTF::get<I::value>(variant));
+                returnValue = toJS<brigand::at<TypeList, I>>(lexicalGlobalObject, globalObject, WTF::get<I::value>(variant));
             }
         });
 
         ASSERT(returnValue);
         return returnValue.value();

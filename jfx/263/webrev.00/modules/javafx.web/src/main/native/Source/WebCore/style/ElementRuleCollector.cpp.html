<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/ElementRuleCollector.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
  4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
  5  * Copyright (C) 2005-2018 Apple Inc. All rights reserved.
  6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
  7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
  8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
 10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
 11  * Copyright (C) 2012 Google Inc. All rights reserved.
 12  *
 13  * This library is free software; you can redistribute it and/or
 14  * modify it under the terms of the GNU Library General Public
 15  * License as published by the Free Software Foundation; either
 16  * version 2 of the License, or (at your option) any later version.
 17  *
 18  * This library is distributed in the hope that it will be useful,
 19  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 20  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 21  * Library General Public License for more details.
 22  *
 23  * You should have received a copy of the GNU Library General Public License
 24  * along with this library; see the file COPYING.LIB.  If not, write to
 25  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 26  * Boston, MA 02110-1301, USA.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;ElementRuleCollector.h&quot;
 31 
 32 #include &quot;CSSRuleList.h&quot;
 33 #include &quot;CSSSelector.h&quot;
 34 #include &quot;CSSValueKeywords.h&quot;
 35 #include &quot;HTMLElement.h&quot;
 36 #include &quot;HTMLSlotElement.h&quot;
 37 #include &quot;SVGElement.h&quot;
 38 #include &quot;SelectorCompiler.h&quot;
 39 #include &quot;SelectorFilter.h&quot;
 40 #include &quot;ShadowRoot.h&quot;
 41 #include &quot;StyleProperties.h&quot;
 42 #include &quot;StyleResolver.h&quot;
 43 #include &quot;StyleScope.h&quot;
 44 #include &quot;StyleScopeRuleSets.h&quot;
 45 #include &quot;StyledElement.h&quot;
 46 #include &quot;UserAgentStyle.h&quot;
 47 #include &lt;wtf/SetForScope.h&gt;
 48 
 49 namespace WebCore {
 50 namespace Style {
 51 
 52 static const StyleProperties&amp; leftToRightDeclaration()
 53 {
 54     static auto&amp; declaration = [] () -&gt; const StyleProperties&amp; {
 55         auto properties = MutableStyleProperties::create();
 56         properties-&gt;setProperty(CSSPropertyDirection, CSSValueLtr);
 57         return properties.leakRef();
 58     }();
 59     return declaration;
 60 }
 61 
 62 static const StyleProperties&amp; rightToLeftDeclaration()
 63 {
 64     static auto&amp; declaration = [] () -&gt; const StyleProperties&amp; {
 65         auto properties = MutableStyleProperties::create();
 66         properties-&gt;setProperty(CSSPropertyDirection, CSSValueRtl);
 67         return properties.leakRef();
 68     }();
 69     return declaration;
 70 }
 71 
 72 class MatchRequest {
 73 public:
 74     MatchRequest(const RuleSet* ruleSet, ScopeOrdinal styleScopeOrdinal = ScopeOrdinal::Element)
 75         : ruleSet(ruleSet)
 76         , styleScopeOrdinal(styleScopeOrdinal)
 77     {
 78     }
 79     const RuleSet* ruleSet;
 80     ScopeOrdinal styleScopeOrdinal;
 81 };
 82 
 83 ElementRuleCollector::ElementRuleCollector(const Element&amp; element, const ScopeRuleSets&amp; ruleSets, const SelectorFilter* selectorFilter)
 84     : m_element(element)
 85     , m_authorStyle(ruleSets.authorStyle())
 86     , m_userStyle(ruleSets.userStyle())
 87     , m_userAgentMediaQueryStyle(ruleSets.userAgentMediaQueryStyle())
 88     , m_selectorFilter(selectorFilter)
 89 {
 90     ASSERT(!m_selectorFilter || m_selectorFilter-&gt;parentStackIsConsistent(element.parentNode()));
 91 }
 92 
 93 ElementRuleCollector::ElementRuleCollector(const Element&amp; element, const RuleSet&amp; authorStyle, const SelectorFilter* selectorFilter)
 94     : m_element(element)
 95     , m_authorStyle(authorStyle)
 96     , m_selectorFilter(selectorFilter)
 97 {
 98     ASSERT(!m_selectorFilter || m_selectorFilter-&gt;parentStackIsConsistent(element.parentNode()));
 99 }
100 
101 const MatchResult&amp; ElementRuleCollector::matchResult() const
102 {
103     ASSERT(m_mode == SelectorChecker::Mode::ResolvingStyle);
104     return m_result;
105 }
106 
107 const Vector&lt;RefPtr&lt;const StyleRule&gt;&gt;&amp; ElementRuleCollector::matchedRuleList() const
108 {
109     ASSERT(m_mode == SelectorChecker::Mode::CollectingRules);
110     return m_matchedRuleList;
111 }
112 
113 inline void ElementRuleCollector::addMatchedRule(const RuleData&amp; ruleData, unsigned specificity, ScopeOrdinal styleScopeOrdinal)
114 {
115     m_matchedRules.append({ &amp;ruleData, specificity, styleScopeOrdinal });
116 }
117 
118 void ElementRuleCollector::clearMatchedRules()
119 {
120     m_matchedRules.clear();
121     m_keepAliveSlottedPseudoElementRules.clear();
122     m_matchedRuleTransferIndex = 0;
123 }
124 
125 inline void ElementRuleCollector::addElementStyleProperties(const StyleProperties* propertySet, bool isCacheable)
126 {
127     if (!propertySet || propertySet-&gt;isEmpty())
128         return;
129 
130     if (!isCacheable)
131         m_result.isCacheable = false;
132 
133     addMatchedProperties({ propertySet }, DeclarationOrigin::Author);
134 }
135 
136 void ElementRuleCollector::collectMatchingRules(const MatchRequest&amp; matchRequest)
137 {
138     ASSERT(matchRequest.ruleSet);
139     ASSERT_WITH_MESSAGE(!(m_mode == SelectorChecker::Mode::CollectingRulesIgnoringVirtualPseudoElements &amp;&amp; m_pseudoElementRequest.pseudoId != PseudoId::None), &quot;When in StyleInvalidation or SharingRules, SelectorChecker does not try to match the pseudo ID. While ElementRuleCollector supports matching a particular pseudoId in this case, this would indicate a error at the call site since matching a particular element should be unnecessary.&quot;);
140 
141     auto* shadowRoot = element().containingShadowRoot();
142     if (shadowRoot &amp;&amp; shadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
143         collectMatchingShadowPseudoElementRules(matchRequest);
144 
145     // We need to collect the rules for id, class, tag, and everything else into a buffer and
146     // then sort the buffer.
147     auto&amp; id = element().idForStyleResolution();
148     if (!id.isNull())
149         collectMatchingRulesForList(matchRequest.ruleSet-&gt;idRules(id), matchRequest);
150     if (element().hasClass()) {
151         for (size_t i = 0; i &lt; element().classNames().size(); ++i)
152             collectMatchingRulesForList(matchRequest.ruleSet-&gt;classRules(element().classNames()[i]), matchRequest);
153     }
154 
155     if (element().isLink())
156         collectMatchingRulesForList(matchRequest.ruleSet-&gt;linkPseudoClassRules(), matchRequest);
157     if (SelectorChecker::matchesFocusPseudoClass(element()))
158         collectMatchingRulesForList(matchRequest.ruleSet-&gt;focusPseudoClassRules(), matchRequest);
159     collectMatchingRulesForList(matchRequest.ruleSet-&gt;tagRules(element().localName(), element().isHTMLElement() &amp;&amp; element().document().isHTMLDocument()), matchRequest);
160     collectMatchingRulesForList(matchRequest.ruleSet-&gt;universalRules(), matchRequest);
161 }
162 
163 
164 Vector&lt;MatchedProperties&gt;&amp; ElementRuleCollector::declarationsForOrigin(MatchResult&amp; matchResult, DeclarationOrigin declarationOrigin)
165 {
166     switch (declarationOrigin) {
167     case DeclarationOrigin::UserAgent: return matchResult.userAgentDeclarations;
168     case DeclarationOrigin::User: return matchResult.userDeclarations;
169     case DeclarationOrigin::Author: return matchResult.authorDeclarations;
170     }
171     ASSERT_NOT_REACHED();
172     return matchResult.authorDeclarations;
173 }
174 
175 void ElementRuleCollector::sortAndTransferMatchedRules(DeclarationOrigin declarationOrigin)
176 {
177     if (m_matchedRules.isEmpty())
178         return;
179 
180     sortMatchedRules();
181 
182     transferMatchedRules(declarationOrigin);
183 }
184 
185 void ElementRuleCollector::transferMatchedRules(DeclarationOrigin declarationOrigin, Optional&lt;ScopeOrdinal&gt; fromScope)
186 {
187     if (m_mode != SelectorChecker::Mode::CollectingRules)
188         declarationsForOrigin(m_result, declarationOrigin).reserveCapacity(m_matchedRules.size());
189 
190     for (; m_matchedRuleTransferIndex &lt; m_matchedRules.size(); ++m_matchedRuleTransferIndex) {
191         auto&amp; matchedRule = m_matchedRules[m_matchedRuleTransferIndex];
192         if (fromScope &amp;&amp; matchedRule.styleScopeOrdinal &lt; *fromScope)
193             break;
194 
195         if (m_mode == SelectorChecker::Mode::CollectingRules) {
196             m_matchedRuleList.append(&amp;matchedRule.ruleData-&gt;styleRule());
197             continue;
198         }
199 
200         addMatchedProperties({
201             &amp;matchedRule.ruleData-&gt;styleRule().properties(),
202             static_cast&lt;uint16_t&gt;(matchedRule.ruleData-&gt;linkMatchType()),
203             static_cast&lt;uint16_t&gt;(matchedRule.ruleData-&gt;propertyWhitelistType()),
204             matchedRule.styleScopeOrdinal
205         }, declarationOrigin);
206     }
207 }
208 
209 void ElementRuleCollector::matchAuthorRules()
210 {
211     clearMatchedRules();
212 
213     collectMatchingAuthorRules();
214 
215     sortAndTransferMatchedRules(DeclarationOrigin::Author);
216 }
217 
218 bool ElementRuleCollector::matchesAnyAuthorRules()
219 {
220     clearMatchedRules();
221 
222     // FIXME: This should bail out on first match.
223     collectMatchingAuthorRules();
224 
225     return !m_matchedRules.isEmpty();
226 }
227 
228 void ElementRuleCollector::collectMatchingAuthorRules()
229 {
230     {
231         MatchRequest matchRequest(m_authorStyle.ptr());
232         collectMatchingRules(matchRequest);
233     }
234 
235     auto* parent = element().parentElement();
236     if (parent &amp;&amp; parent-&gt;shadowRoot())
237         matchSlottedPseudoElementRules();
238 
239     if (element().shadowRoot())
240         matchHostPseudoClassRules();
241 
242     if (element().isInShadowTree()) {
243         matchAuthorShadowPseudoElementRules();
244         matchPartPseudoElementRules();
245     }
246 }
247 
248 void ElementRuleCollector::matchAuthorShadowPseudoElementRules()
249 {
250     ASSERT(element().isInShadowTree());
251     auto&amp; shadowRoot = *element().containingShadowRoot();
252     if (shadowRoot.mode() != ShadowRootMode::UserAgent)
253         return;
254     // Look up shadow pseudo elements also from the host scope author style as they are web-exposed.
255     auto&amp; hostAuthorRules = Scope::forNode(*shadowRoot.host()).resolver().ruleSets().authorStyle();
256     MatchRequest hostAuthorRequest { &amp;hostAuthorRules, ScopeOrdinal::ContainingHost };
257     collectMatchingShadowPseudoElementRules(hostAuthorRequest);
258 }
259 
260 void ElementRuleCollector::matchHostPseudoClassRules()
261 {
262     ASSERT(element().shadowRoot());
263 
264     auto&amp; shadowAuthorStyle = element().shadowRoot()-&gt;styleScope().resolver().ruleSets().authorStyle();
265     auto&amp; shadowHostRules = shadowAuthorStyle.hostPseudoClassRules();
266     if (shadowHostRules.isEmpty())
267         return;
268 
269     SetForScope&lt;bool&gt; change(m_isMatchingHostPseudoClass, true);
270 
271     MatchRequest hostMatchRequest { nullptr, ScopeOrdinal::Shadow };
272     collectMatchingRulesForList(&amp;shadowHostRules, hostMatchRequest);
273 }
274 
275 void ElementRuleCollector::matchSlottedPseudoElementRules()
276 {
277     auto* slot = element().assignedSlot();
278     auto styleScopeOrdinal = ScopeOrdinal::FirstSlot;
279 
280     for (; slot; slot = slot-&gt;assignedSlot(), ++styleScopeOrdinal) {
281         auto&amp; styleScope = Scope::forNode(*slot);
282         if (!styleScope.resolver().ruleSets().isAuthorStyleDefined())
283             continue;
284         // Find out if there are any ::slotted rules in the shadow tree matching the current slot.
285         // FIXME: This is really part of the slot style and could be cached when resolving it.
286         ElementRuleCollector collector(*slot, styleScope.resolver().ruleSets().authorStyle(), nullptr);
287         auto slottedPseudoElementRules = collector.collectSlottedPseudoElementRulesForSlot();
288         if (!slottedPseudoElementRules)
289             continue;
290         // Match in the current scope.
291         SetForScope&lt;bool&gt; change(m_isMatchingSlottedPseudoElements, true);
292 
293         MatchRequest scopeMatchRequest(nullptr, styleScopeOrdinal);
294         collectMatchingRulesForList(slottedPseudoElementRules.get(), scopeMatchRequest);
295 
296         m_keepAliveSlottedPseudoElementRules.append(WTFMove(slottedPseudoElementRules));
297     }
298 }
299 
300 void ElementRuleCollector::matchPartPseudoElementRules()
301 {
302     ASSERT(element().isInShadowTree());
303 
304     bool isUAShadowPseudoElement = element().containingShadowRoot()-&gt;mode() == ShadowRootMode::UserAgent &amp;&amp; !element().shadowPseudoId().isNull();
305 
306     auto&amp; partMatchingElement = isUAShadowPseudoElement ? *element().shadowHost() : element();
307     if (partMatchingElement.partNames().isEmpty() || !partMatchingElement.isInShadowTree())
308         return;
309 
310     matchPartPseudoElementRulesForScope(*partMatchingElement.containingShadowRoot());
311 }
312 
313 void ElementRuleCollector::matchPartPseudoElementRulesForScope(const ShadowRoot&amp; scopeShadowRoot)
314 {
315     auto&amp; shadowHost = *scopeShadowRoot.host();
316     {
317         SetForScope&lt;RefPtr&lt;const Element&gt;&gt; partMatchingScope(m_shadowHostInPartRuleScope, &amp;shadowHost);
318 
319         auto&amp; hostAuthorRules = Scope::forNode(shadowHost).resolver().ruleSets().authorStyle();
320         MatchRequest hostAuthorRequest { &amp;hostAuthorRules, ScopeOrdinal::ContainingHost };
321         collectMatchingRulesForList(&amp;hostAuthorRules.partPseudoElementRules(), hostAuthorRequest);
322     }
323 
324     // Element may be exposed to styling from enclosing scopes via exportparts attributes.
325     if (scopeShadowRoot.partMappings().isEmpty())
326         return;
327 
328     if (auto* parentScopeShadowRoot = shadowHost.containingShadowRoot())
329         matchPartPseudoElementRulesForScope(*parentScopeShadowRoot);
330 }
331 
332 void ElementRuleCollector::collectMatchingShadowPseudoElementRules(const MatchRequest&amp; matchRequest)
333 {
334     ASSERT(matchRequest.ruleSet);
335     ASSERT(element().containingShadowRoot()-&gt;mode() == ShadowRootMode::UserAgent);
336 
337     auto&amp; rules = *matchRequest.ruleSet;
338 #if ENABLE(VIDEO_TRACK)
339     // FXIME: WebVTT should not be done by styling UA shadow trees like this.
340     if (element().isWebVTTElement())
341         collectMatchingRulesForList(rules.cuePseudoRules(), matchRequest);
342 #endif
343     auto&amp; pseudoId = element().shadowPseudoId();
344     if (!pseudoId.isEmpty())
345         collectMatchingRulesForList(rules.shadowPseudoElementRules(pseudoId), matchRequest);
346 }
347 
348 std::unique_ptr&lt;RuleSet::RuleDataVector&gt; ElementRuleCollector::collectSlottedPseudoElementRulesForSlot()
349 {
350     ASSERT(is&lt;HTMLSlotElement&gt;(element()));
351 
352     clearMatchedRules();
353 
354     m_mode = SelectorChecker::Mode::CollectingRules;
355 
356     // Match global author rules.
357     MatchRequest matchRequest(m_authorStyle.ptr());
358     collectMatchingRulesForList(&amp;m_authorStyle-&gt;slottedPseudoElementRules(), matchRequest);
359 
360     if (m_matchedRules.isEmpty())
361         return { };
362 
363     auto ruleDataVector = makeUnique&lt;RuleSet::RuleDataVector&gt;();
364     ruleDataVector-&gt;reserveInitialCapacity(m_matchedRules.size());
365     for (auto&amp; matchedRule : m_matchedRules)
366         ruleDataVector-&gt;uncheckedAppend(*matchedRule.ruleData);
367 
368     return ruleDataVector;
369 }
370 
371 void ElementRuleCollector::matchUserRules()
372 {
373     if (!m_userStyle)
374         return;
375 
376     clearMatchedRules();
377 
378     MatchRequest matchRequest(m_userStyle.get());
379     collectMatchingRules(matchRequest);
380 
381     sortAndTransferMatchedRules(DeclarationOrigin::User);
382 }
383 
384 void ElementRuleCollector::matchUARules()
385 {
386     // First we match rules from the user agent sheet.
387     if (UserAgentStyle::simpleDefaultStyleSheet)
388         m_result.isCacheable = false;
389     auto* userAgentStyleSheet = m_isPrintStyle
390         ? UserAgentStyle::defaultPrintStyle : UserAgentStyle::defaultStyle;
391     matchUARules(*userAgentStyleSheet);
392 
393     // In quirks mode, we match rules from the quirks user agent sheet.
394     if (element().document().inQuirksMode())
395         matchUARules(*UserAgentStyle::defaultQuirksStyle);
396 
397     if (m_userAgentMediaQueryStyle)
398         matchUARules(*m_userAgentMediaQueryStyle);
399 }
400 
401 void ElementRuleCollector::matchUARules(const RuleSet&amp; rules)
402 {
403     clearMatchedRules();
404 
405     collectMatchingRules(MatchRequest(&amp;rules));
406 
407     sortAndTransferMatchedRules(DeclarationOrigin::UserAgent);
408 }
409 
410 static const CSSSelector* findSlottedPseudoElementSelector(const CSSSelector* selector)
411 {
412     for (; selector; selector = selector-&gt;tagHistory()) {
413         if (selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; selector-&gt;pseudoElementType() == CSSSelector::PseudoElementSlotted) {
414             if (auto* list = selector-&gt;selectorList())
415                 return list-&gt;first();
416             break;
417         }
418     };
419     return nullptr;
420 }
421 
422 inline bool ElementRuleCollector::ruleMatches(const RuleData&amp; ruleData, unsigned&amp; specificity)
423 {
424     // We know a sufficiently simple single part selector matches simply because we found it from the rule hash when filtering the RuleSet.
425     // This is limited to HTML only so we don&#39;t need to check the namespace (because of tag name match).
426     auto matchBasedOnRuleHash = ruleData.matchBasedOnRuleHash();
427     if (matchBasedOnRuleHash != MatchBasedOnRuleHash::None &amp;&amp; element().isHTMLElement()) {
428         ASSERT_WITH_MESSAGE(m_pseudoElementRequest.pseudoId == PseudoId::None, &quot;If we match based on the rule hash while collecting for a particular pseudo element ID, we would add incorrect rules for that pseudo element ID. We should never end in ruleMatches() with a pseudo element if the ruleData cannot match any pseudo element.&quot;);
429 
430         switch (matchBasedOnRuleHash) {
431         case MatchBasedOnRuleHash::None:
432             ASSERT_NOT_REACHED();
433             break;
434         case MatchBasedOnRuleHash::Universal:
435             specificity = 0;
436             break;
437         case MatchBasedOnRuleHash::ClassA:
438             specificity = static_cast&lt;unsigned&gt;(SelectorSpecificityIncrement::ClassA);
439             break;
440         case MatchBasedOnRuleHash::ClassB:
441             specificity = static_cast&lt;unsigned&gt;(SelectorSpecificityIncrement::ClassB);
442             break;
443         case MatchBasedOnRuleHash::ClassC:
444             specificity = static_cast&lt;unsigned&gt;(SelectorSpecificityIncrement::ClassC);
445             break;
446         }
447         return true;
448     }
449 
450 #if ENABLE(CSS_SELECTOR_JIT)
451     auto&amp; compiledSelector = ruleData.compiledSelector();
452 
453     if (compiledSelector.status == SelectorCompilationStatus::NotCompiled)
454         SelectorCompiler::compileSelector(compiledSelector, ruleData.selector(), SelectorCompiler::SelectorContext::RuleCollector);
455 
456     if (compiledSelector.status == SelectorCompilationStatus::SimpleSelectorChecker) {
457         compiledSelector.wasUsed();
458 
459         auto selectorChecker = SelectorCompiler::ruleCollectorSimpleSelectorCheckerFunction(compiledSelector);
460 #if !ASSERT_MSG_DISABLED
461         unsigned ignoreSpecificity;
462         ASSERT_WITH_MESSAGE(!selectorChecker(&amp;element(), &amp;ignoreSpecificity) || m_pseudoElementRequest.pseudoId == PseudoId::None, &quot;When matching pseudo elements, we should never compile a selector checker without context unless it cannot match anything.&quot;);
463 #endif
464         bool selectorMatches = selectorChecker(&amp;element(), &amp;specificity);
465 
466         if (selectorMatches &amp;&amp; ruleData.containsUncommonAttributeSelector())
467             m_didMatchUncommonAttributeSelector = true;
468 
469         return selectorMatches;
470     }
471 #endif // ENABLE(CSS_SELECTOR_JIT)
472 
473     SelectorChecker::CheckingContext context(m_mode);
474     context.pseudoId = m_pseudoElementRequest.pseudoId;
475     context.scrollbarState = m_pseudoElementRequest.scrollbarState;
476     context.nameForHightlightPseudoElement = m_pseudoElementRequest.highlightName;
477     context.isMatchingHostPseudoClass = m_isMatchingHostPseudoClass;
478     context.shadowHostInPartRuleScope = m_shadowHostInPartRuleScope.get();
479 
480     bool selectorMatches;
481 #if ENABLE(CSS_SELECTOR_JIT)
482     if (compiledSelector.status == SelectorCompilationStatus::SelectorCheckerWithCheckingContext) {
483         compiledSelector.wasUsed();
484 
485         auto selectorChecker = SelectorCompiler::ruleCollectorSelectorCheckerFunctionWithCheckingContext(compiledSelector);
486         selectorMatches = selectorChecker(&amp;element(), &amp;context, &amp;specificity);
487     } else
488 #endif // ENABLE(CSS_SELECTOR_JIT)
489     {
490         auto* selector = ruleData.selector();
491         if (m_isMatchingSlottedPseudoElements) {
492             selector = findSlottedPseudoElementSelector(ruleData.selector());
493             if (!selector)
494                 return false;
495         }
496         // Slow path.
497         SelectorChecker selectorChecker(element().document());
498         selectorMatches = selectorChecker.match(*selector, element(), context, specificity);
499     }
500 
501     if (ruleData.containsUncommonAttributeSelector()) {
502         if (selectorMatches || context.pseudoIDSet)
503             m_didMatchUncommonAttributeSelector = true;
504     }
505     m_matchedPseudoElementIds.merge(context.pseudoIDSet);
506     m_styleRelations.appendVector(context.styleRelations);
507 
508     return selectorMatches;
509 }
510 
511 void ElementRuleCollector::collectMatchingRulesForList(const RuleSet::RuleDataVector* rules, const MatchRequest&amp; matchRequest)
512 {
513     if (!rules)
514         return;
515 
516     for (unsigned i = 0, size = rules-&gt;size(); i &lt; size; ++i) {
517         const auto&amp; ruleData = rules-&gt;data()[i];
518 
519         if (UNLIKELY(!ruleData.isEnabled()))
520             continue;
521 
522         if (!ruleData.canMatchPseudoElement() &amp;&amp; m_pseudoElementRequest.pseudoId != PseudoId::None)
523             continue;
524 
525         if (m_selectorFilter &amp;&amp; m_selectorFilter-&gt;fastRejectSelector(ruleData.descendantSelectorIdentifierHashes()))
526             continue;
527 
528         auto&amp; rule = ruleData.styleRule();
529 
530         // If the rule has no properties to apply, then ignore it in the non-debug mode.
531         // Note that if we get null back here, it means we have a rule with deferred properties,
532         // and that means we always have to consider it.
533         const StyleProperties* properties = rule.propertiesWithoutDeferredParsing();
534         if (properties &amp;&amp; properties-&gt;isEmpty() &amp;&amp; !m_shouldIncludeEmptyRules)
535             continue;
536 
537         unsigned specificity;
538         if (ruleMatches(ruleData, specificity))
539             addMatchedRule(ruleData, specificity, matchRequest.styleScopeOrdinal);
540     }
541 }
542 
543 static inline bool compareRules(MatchedRule r1, MatchedRule r2)
544 {
545     // For normal properties the earlier scope wins. This may be reversed by !important which is handled when resolving cascade.
546     if (r1.styleScopeOrdinal != r2.styleScopeOrdinal)
547         return r1.styleScopeOrdinal &gt; r2.styleScopeOrdinal;
548 
549     if (r1.specificity != r2.specificity)
550         return r1.specificity &lt; r2.specificity;
551 
552     return r1.ruleData-&gt;position() &lt; r2.ruleData-&gt;position();
553 }
554 
555 void ElementRuleCollector::sortMatchedRules()
556 {
557     std::sort(m_matchedRules.begin(), m_matchedRules.end(), compareRules);
558 }
559 
560 void ElementRuleCollector::matchAllRules(bool matchAuthorAndUserStyles, bool includeSMILProperties)
561 {
562     matchUARules();
563 
564     // Now we check user sheet rules.
565     if (matchAuthorAndUserStyles)
566         matchUserRules();
567 
568     // Now check author rules, beginning first with presentational attributes mapped from HTML.
569     if (is&lt;StyledElement&gt;(element())) {
570         auto&amp; styledElement = downcast&lt;StyledElement&gt;(element());
571         addElementStyleProperties(styledElement.presentationAttributeStyle());
572 
573         // Now we check additional mapped declarations.
574         // Tables and table cells share an additional mapped rule that must be applied
575         // after all attributes, since their mapped style depends on the values of multiple attributes.
576         addElementStyleProperties(styledElement.additionalPresentationAttributeStyle());
577 
578         if (is&lt;HTMLElement&gt;(styledElement)) {
579             bool isAuto;
580             auto textDirection = downcast&lt;HTMLElement&gt;(styledElement).directionalityIfhasDirAutoAttribute(isAuto);
581             auto&amp; properties = textDirection == TextDirection::LTR ? leftToRightDeclaration() : rightToLeftDeclaration();
582             if (isAuto)
583                 addMatchedProperties({ &amp;properties }, DeclarationOrigin::Author);
584         }
585     }
586 
587     if (matchAuthorAndUserStyles) {
588         clearMatchedRules();
589 
590         collectMatchingAuthorRules();
591         sortMatchedRules();
592 
593         transferMatchedRules(DeclarationOrigin::Author, ScopeOrdinal::Element);
594 
595         // Inline style behaves as if it has higher specificity than any rule.
596         addElementInlineStyleProperties(includeSMILProperties);
597 
598         // Rules from the host scope override inline style.
599         transferMatchedRules(DeclarationOrigin::Author, ScopeOrdinal::ContainingHost);
600     }
601 }
602 
603 void ElementRuleCollector::addElementInlineStyleProperties(bool includeSMILProperties)
604 {
605     if (!is&lt;StyledElement&gt;(element()))
606         return;
607 
608     if (auto* inlineStyle = downcast&lt;StyledElement&gt;(element()).inlineStyle()) {
609         // FIXME: Media control shadow trees seem to have problems with caching.
610         bool isInlineStyleCacheable = !inlineStyle-&gt;isMutable() &amp;&amp; !element().isInShadowTree();
611         addElementStyleProperties(inlineStyle, isInlineStyleCacheable);
612     }
613 
614     if (includeSMILProperties &amp;&amp; is&lt;SVGElement&gt;(element()))
615         addElementStyleProperties(downcast&lt;SVGElement&gt;(element()).animatedSMILStyleProperties(), false /* isCacheable */);
616 }
617 
618 bool ElementRuleCollector::hasAnyMatchingRules(const RuleSet* ruleSet)
619 {
620     clearMatchedRules();
621 
622     m_mode = SelectorChecker::Mode::CollectingRulesIgnoringVirtualPseudoElements;
623     collectMatchingRules(MatchRequest(ruleSet));
624 
625     return !m_matchedRules.isEmpty();
626 }
627 
628 void ElementRuleCollector::addMatchedProperties(MatchedProperties&amp;&amp; matchedProperties, DeclarationOrigin declarationOrigin)
629 {
630     // FIXME: This should be moved to the matched properties cache code.
631     auto computeIsCacheable = [&amp;] {
632         if (!m_result.isCacheable)
633             return false;
634 
635         if (matchedProperties.styleScopeOrdinal != ScopeOrdinal::Element)
636             return false;
637 
638         auto&amp; properties = *matchedProperties.properties;
639         for (unsigned i = 0, count = properties.propertyCount(); i &lt; count; ++i) {
640             // Currently the property cache only copy the non-inherited values and resolve
641             // the inherited ones.
642             // Here we define some exception were we have to resolve some properties that are not inherited
643             // by default. If those exceptions become too common on the web, it should be possible
644             // to build a list of exception to resolve instead of completely disabling the cache.
645             StyleProperties::PropertyReference current = properties.propertyAt(i);
646             if (current.isInherited())
647                 continue;
648 
649             // If the property value is explicitly inherited, we need to apply further non-inherited properties
650             // as they might override the value inherited here. For this reason we don&#39;t allow declarations with
651             // explicitly inherited properties to be cached.
652             const CSSValue&amp; value = *current.value();
653             if (value.isInheritedValue())
654                 return false;
655 
656             // The value currentColor has implicitely the same side effect. It depends on the value of color,
657             // which is an inherited value, making the non-inherited property implicitly inherited.
658             if (is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueCurrentcolor)
659                 return false;
660 
661             if (value.hasVariableReferences())
662                 return false;
663         }
664 
665         return true;
666     };
667 
668     m_result.isCacheable = computeIsCacheable();
669 
670     declarationsForOrigin(m_result, declarationOrigin).append(WTFMove(matchedProperties));
671 }
672 
673 }
674 } // namespace WebCore
    </pre>
  </body>
</html>
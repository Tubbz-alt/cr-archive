<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/ComplexLineLayout.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ComplexLineLayout.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventRegion.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/ComplexLineLayout.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 53 typedef Vector&lt;WordMeasurement, 64&gt; WordMeasurements;
 54 
 55 class ComplexLineLayout {
 56     WTF_MAKE_FAST_ALLOCATED;
 57 public:
 58     ComplexLineLayout(RenderBlockFlow&amp;);
 59     ~ComplexLineLayout();
 60 
 61     RenderLineBoxList&amp; lineBoxes() { return m_lineBoxes; }
 62     const RenderLineBoxList&amp; lineBoxes() const { return m_lineBoxes; }
 63 
 64     RootInlineBox* firstRootBox() const { return downcast&lt;RootInlineBox&gt;(m_lineBoxes.firstLineBox()); }
 65     RootInlineBox* lastRootBox() const { return downcast&lt;RootInlineBox&gt;(m_lineBoxes.lastLineBox()); }
 66 
 67     void layoutLineBoxes(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
 68 
 69     RootInlineBox* constructLine(BidiRunList&lt;BidiRun&gt;&amp;, const LineInfo&amp;);
 70     bool positionNewFloatOnLine(const FloatingObject&amp; newFloat, FloatingObject* lastFloatFromPreviousLine, LineInfo&amp;, LineWidth&amp;);
 71     void addOverflowFromInlineChildren();
 72 



 73     static void appendRunsForObject(BidiRunList&lt;BidiRun&gt;*, int start, int end, RenderObject&amp;, InlineBidiResolver&amp;);
 74     static void updateLogicalWidthForAlignment(RenderBlockFlow&amp;, const TextAlignMode&amp;, const RootInlineBox*, BidiRun* trailingSpaceRun, float&amp; logicalLeft, float&amp; totalLogicalWidth, float&amp; availableLogicalWidth, int expansionOpportunityCount);
 75 
 76 private:
 77     std::unique_ptr&lt;RootInlineBox&gt; createRootInlineBox();
 78     RootInlineBox* createAndAppendRootInlineBox();
 79     InlineBox* createInlineBoxForRenderer(RenderObject*, bool isOnlyRun = false);
 80     InlineFlowBox* createLineBoxes(RenderObject*, const LineInfo&amp;, InlineBox*);
 81     TextAlignMode textAlignmentForLine(bool endsWithSoftBreak) const;
 82     void setMarginsForRubyRun(BidiRun*, RenderRubyRun&amp;, RenderObject* previousObject, const LineInfo&amp;);
 83     void updateRubyForJustifiedText(RenderRubyRun&amp;, BidiRun&amp;, const Vector&lt;unsigned, 16&gt;&amp; expansionOpportunities, unsigned&amp; expansionOpportunityCount, float&amp; totalLogicalWidth, float availableLogicalWidth, size_t&amp;);
 84     void computeExpansionForJustifiedText(BidiRun* firstRun, BidiRun* trailingSpaceRun, const Vector&lt;unsigned, 16&gt;&amp; expansionOpportunities, unsigned expansionOpportunityCount, float totalLogicalWidth, float availableLogicalWidth);
 85     void computeInlineDirectionPositionsForLine(RootInlineBox*, const LineInfo&amp;, BidiRun* firstRun, BidiRun* trailingSpaceRun, bool reachedEnd, GlyphOverflowAndFallbackFontsMap&amp;, VerticalPositionCache&amp;, WordMeasurements&amp;);
 86     BidiRun* computeInlineDirectionPositionsForSegment(RootInlineBox*, const LineInfo&amp;, TextAlignMode, float&amp; logicalLeft, float&amp; availableLogicalWidth, BidiRun* firstRun, BidiRun* trailingSpaceRun, GlyphOverflowAndFallbackFontsMap&amp;, VerticalPositionCache&amp;, WordMeasurements&amp;);
 87     void removeInlineBox(BidiRun&amp;, const RootInlineBox&amp;) const;
 88     void computeBlockDirectionPositionsForLine(RootInlineBox*, BidiRun* firstRun, GlyphOverflowAndFallbackFontsMap&amp; textBoxDataMap, VerticalPositionCache&amp;);
 89     inline BidiRun* handleTrailingSpaces(BidiRunList&lt;BidiRun&gt;&amp; bidiRuns, BidiContext* currentContext);
 90     void appendFloatingObjectToLastLine(FloatingObject&amp;);
 91     RootInlineBox* createLineBoxesFromBidiRuns(unsigned bidiLevel, BidiRunList&lt;BidiRun&gt;&amp; bidiRuns, const InlineIterator&amp; end, LineInfo&amp;, VerticalPositionCache&amp;, BidiRun* trailingSpaceRun, WordMeasurements&amp;);
 92     void layoutRunsAndFloats(LineLayoutState&amp;, bool hasInlineChild);
</pre>
</td>
<td>
<hr />
<pre>
 53 typedef Vector&lt;WordMeasurement, 64&gt; WordMeasurements;
 54 
 55 class ComplexLineLayout {
 56     WTF_MAKE_FAST_ALLOCATED;
 57 public:
 58     ComplexLineLayout(RenderBlockFlow&amp;);
 59     ~ComplexLineLayout();
 60 
 61     RenderLineBoxList&amp; lineBoxes() { return m_lineBoxes; }
 62     const RenderLineBoxList&amp; lineBoxes() const { return m_lineBoxes; }
 63 
 64     RootInlineBox* firstRootBox() const { return downcast&lt;RootInlineBox&gt;(m_lineBoxes.firstLineBox()); }
 65     RootInlineBox* lastRootBox() const { return downcast&lt;RootInlineBox&gt;(m_lineBoxes.lastLineBox()); }
 66 
 67     void layoutLineBoxes(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
 68 
 69     RootInlineBox* constructLine(BidiRunList&lt;BidiRun&gt;&amp;, const LineInfo&amp;);
 70     bool positionNewFloatOnLine(const FloatingObject&amp; newFloat, FloatingObject* lastFloatFromPreviousLine, LineInfo&amp;, LineWidth&amp;);
 71     void addOverflowFromInlineChildren();
 72 
<span class="line-added"> 73     size_t lineCount() const;</span>
<span class="line-added"> 74     size_t lineCountUntil(const RootInlineBox*) const;</span>
<span class="line-added"> 75 </span>
 76     static void appendRunsForObject(BidiRunList&lt;BidiRun&gt;*, int start, int end, RenderObject&amp;, InlineBidiResolver&amp;);
 77     static void updateLogicalWidthForAlignment(RenderBlockFlow&amp;, const TextAlignMode&amp;, const RootInlineBox*, BidiRun* trailingSpaceRun, float&amp; logicalLeft, float&amp; totalLogicalWidth, float&amp; availableLogicalWidth, int expansionOpportunityCount);
 78 
 79 private:
 80     std::unique_ptr&lt;RootInlineBox&gt; createRootInlineBox();
 81     RootInlineBox* createAndAppendRootInlineBox();
 82     InlineBox* createInlineBoxForRenderer(RenderObject*, bool isOnlyRun = false);
 83     InlineFlowBox* createLineBoxes(RenderObject*, const LineInfo&amp;, InlineBox*);
 84     TextAlignMode textAlignmentForLine(bool endsWithSoftBreak) const;
 85     void setMarginsForRubyRun(BidiRun*, RenderRubyRun&amp;, RenderObject* previousObject, const LineInfo&amp;);
 86     void updateRubyForJustifiedText(RenderRubyRun&amp;, BidiRun&amp;, const Vector&lt;unsigned, 16&gt;&amp; expansionOpportunities, unsigned&amp; expansionOpportunityCount, float&amp; totalLogicalWidth, float availableLogicalWidth, size_t&amp;);
 87     void computeExpansionForJustifiedText(BidiRun* firstRun, BidiRun* trailingSpaceRun, const Vector&lt;unsigned, 16&gt;&amp; expansionOpportunities, unsigned expansionOpportunityCount, float totalLogicalWidth, float availableLogicalWidth);
 88     void computeInlineDirectionPositionsForLine(RootInlineBox*, const LineInfo&amp;, BidiRun* firstRun, BidiRun* trailingSpaceRun, bool reachedEnd, GlyphOverflowAndFallbackFontsMap&amp;, VerticalPositionCache&amp;, WordMeasurements&amp;);
 89     BidiRun* computeInlineDirectionPositionsForSegment(RootInlineBox*, const LineInfo&amp;, TextAlignMode, float&amp; logicalLeft, float&amp; availableLogicalWidth, BidiRun* firstRun, BidiRun* trailingSpaceRun, GlyphOverflowAndFallbackFontsMap&amp;, VerticalPositionCache&amp;, WordMeasurements&amp;);
 90     void removeInlineBox(BidiRun&amp;, const RootInlineBox&amp;) const;
 91     void computeBlockDirectionPositionsForLine(RootInlineBox*, BidiRun* firstRun, GlyphOverflowAndFallbackFontsMap&amp; textBoxDataMap, VerticalPositionCache&amp;);
 92     inline BidiRun* handleTrailingSpaces(BidiRunList&lt;BidiRun&gt;&amp; bidiRuns, BidiContext* currentContext);
 93     void appendFloatingObjectToLastLine(FloatingObject&amp;);
 94     RootInlineBox* createLineBoxesFromBidiRuns(unsigned bidiLevel, BidiRunList&lt;BidiRun&gt;&amp; bidiRuns, const InlineIterator&amp; end, LineInfo&amp;, VerticalPositionCache&amp;, BidiRun* trailingSpaceRun, WordMeasurements&amp;);
 95     void layoutRunsAndFloats(LineLayoutState&amp;, bool hasInlineChild);
</pre>
</td>
</tr>
</table>
<center><a href="ComplexLineLayout.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventRegion.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
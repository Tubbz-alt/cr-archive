<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPlan.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGPlan.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGArgumentsEliminationPhase.h&quot;
 32 #include &quot;DFGBackwardsPropagationPhase.h&quot;
 33 #include &quot;DFGByteCodeParser.h&quot;
 34 #include &quot;DFGCFAPhase.h&quot;
 35 #include &quot;DFGCFGSimplificationPhase.h&quot;
 36 #include &quot;DFGCPSRethreadingPhase.h&quot;
 37 #include &quot;DFGCSEPhase.h&quot;
 38 #include &quot;DFGCleanUpPhase.h&quot;
 39 #include &quot;DFGConstantFoldingPhase.h&quot;
 40 #include &quot;DFGConstantHoistingPhase.h&quot;
 41 #include &quot;DFGCriticalEdgeBreakingPhase.h&quot;
 42 #include &quot;DFGDCEPhase.h&quot;
 43 #include &quot;DFGFailedFinalizer.h&quot;
 44 #include &quot;DFGFixupPhase.h&quot;
 45 #include &quot;DFGGraphSafepoint.h&quot;
 46 #include &quot;DFGIntegerCheckCombiningPhase.h&quot;
 47 #include &quot;DFGIntegerRangeOptimizationPhase.h&quot;
 48 #include &quot;DFGInvalidationPointInjectionPhase.h&quot;
 49 #include &quot;DFGJITCompiler.h&quot;
 50 #include &quot;DFGLICMPhase.h&quot;
 51 #include &quot;DFGLiveCatchVariablePreservationPhase.h&quot;
 52 #include &quot;DFGLivenessAnalysisPhase.h&quot;
 53 #include &quot;DFGLoopPreHeaderCreationPhase.h&quot;
 54 #include &quot;DFGMovHintRemovalPhase.h&quot;
 55 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
 56 #include &quot;DFGOSREntrypointCreationPhase.h&quot;
 57 #include &quot;DFGObjectAllocationSinkingPhase.h&quot;
 58 #include &quot;DFGPhantomInsertionPhase.h&quot;
 59 #include &quot;DFGPredictionInjectionPhase.h&quot;
 60 #include &quot;DFGPredictionPropagationPhase.h&quot;
 61 #include &quot;DFGPutStackSinkingPhase.h&quot;
 62 #include &quot;DFGSSAConversionPhase.h&quot;
 63 #include &quot;DFGSSALoweringPhase.h&quot;
 64 #include &quot;DFGStackLayoutPhase.h&quot;
 65 #include &quot;DFGStaticExecutionCountEstimationPhase.h&quot;
 66 #include &quot;DFGStoreBarrierClusteringPhase.h&quot;
 67 #include &quot;DFGStoreBarrierInsertionPhase.h&quot;
 68 #include &quot;DFGStrengthReductionPhase.h&quot;
 69 #include &quot;DFGTierUpCheckInjectionPhase.h&quot;
 70 #include &quot;DFGTypeCheckHoistingPhase.h&quot;
 71 #include &quot;DFGUnificationPhase.h&quot;
 72 #include &quot;DFGValidate.h&quot;
 73 #include &quot;DFGValueRepReductionPhase.h&quot;
 74 #include &quot;DFGVarargsForwardingPhase.h&quot;
 75 #include &quot;DFGVirtualRegisterAllocationPhase.h&quot;
 76 #include &quot;DFGWatchpointCollectionPhase.h&quot;
 77 #include &quot;JSCInlines.h&quot;
 78 #include &quot;OperandsInlines.h&quot;
 79 #include &quot;ProfilerDatabase.h&quot;
 80 #include &quot;TrackedReferences.h&quot;
 81 #include &quot;VMInlines.h&quot;
 82 
 83 #if ENABLE(FTL_JIT)
 84 #include &quot;FTLCapabilities.h&quot;
 85 #include &quot;FTLCompile.h&quot;
 86 #include &quot;FTLFail.h&quot;
 87 #include &quot;FTLLink.h&quot;
 88 #include &quot;FTLLowerDFGToB3.h&quot;
 89 #include &quot;FTLState.h&quot;
 90 #endif
 91 
 92 namespace JSC {
 93 
 94 extern Seconds totalDFGCompileTime;
 95 extern Seconds totalFTLCompileTime;
 96 extern Seconds totalFTLDFGCompileTime;
 97 extern Seconds totalFTLB3CompileTime;
 98 
 99 }
100 
101 namespace JSC { namespace DFG {
102 
103 namespace {
104 
105 void dumpAndVerifyGraph(Graph&amp; graph, const char* text, bool forceDump = false)
106 {
107     GraphDumpMode modeForFinalValidate = DumpGraph;
108     if (verboseCompilationEnabled(graph.m_plan.mode()) || forceDump) {
109         dataLog(text, &quot;\n&quot;);
110         graph.dump();
111         modeForFinalValidate = DontDumpGraph;
112     }
113     if (validationEnabled())
114         validate(graph, modeForFinalValidate);
115 }
116 
117 Profiler::CompilationKind profilerCompilationKindForMode(CompilationMode mode)
118 {
119     switch (mode) {
120     case InvalidCompilationMode:
121         RELEASE_ASSERT_NOT_REACHED();
122         return Profiler::DFG;
123     case DFGMode:
124         return Profiler::DFG;
125     case FTLMode:
126         return Profiler::FTL;
127     case FTLForOSREntryMode:
128         return Profiler::FTLForOSREntry;
129     }
130     RELEASE_ASSERT_NOT_REACHED();
131     return Profiler::DFG;
132 }
133 
134 } // anonymous namespace
135 
136 Plan::Plan(CodeBlock* passedCodeBlock, CodeBlock* profiledDFGCodeBlock,
137     CompilationMode mode, BytecodeIndex osrEntryBytecodeIndex,
138     const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues)
139     : m_mode(mode)
140     , m_vm(&amp;passedCodeBlock-&gt;vm())
141     , m_codeBlock(passedCodeBlock)
142     , m_profiledDFGCodeBlock(profiledDFGCodeBlock)
143     , m_mustHandleValues(mustHandleValues)
144     , m_osrEntryBytecodeIndex(osrEntryBytecodeIndex)
145     , m_compilation(UNLIKELY(m_vm-&gt;m_perBytecodeProfiler) ? adoptRef(new Profiler::Compilation(m_vm-&gt;m_perBytecodeProfiler-&gt;ensureBytecodesFor(m_codeBlock), profilerCompilationKindForMode(mode))) : nullptr)
146     , m_inlineCallFrames(adoptRef(new InlineCallFrameSet()))
147     , m_identifiers(m_codeBlock)
148     , m_weakReferences(m_codeBlock)
149     , m_stage(Preparing)
150 {
151     RELEASE_ASSERT(m_codeBlock-&gt;alternative()-&gt;jitCode());
152     m_inlineCallFrames-&gt;disableThreadingChecks();
153 }
154 
155 Plan::~Plan()
156 {
157 }
158 
159 bool Plan::computeCompileTimes() const
160 {
161     return reportCompileTimes()
162         || Options::reportTotalCompileTimes()
163         || (m_vm &amp;&amp; m_vm-&gt;m_perBytecodeProfiler);
164 }
165 
166 bool Plan::reportCompileTimes() const
167 {
168     return Options::reportCompileTimes()
169         || Options::reportDFGCompileTimes()
170         || (Options::reportFTLCompileTimes() &amp;&amp; isFTL());
171 }
172 
173 void Plan::compileInThread(ThreadData* threadData)
174 {
175     m_threadData = threadData;
176 
177     MonotonicTime before { };
178     CString codeBlockName;
179     if (UNLIKELY(computeCompileTimes()))
180         before = MonotonicTime::now();
181     if (UNLIKELY(reportCompileTimes()))
182         codeBlockName = toCString(*m_codeBlock);
183 
184     CompilationScope compilationScope;
185 
186     if (logCompilationChanges(m_mode) || Options::logPhaseTimes())
187         dataLog(&quot;DFG(Plan) compiling &quot;, *m_codeBlock, &quot; with &quot;, m_mode, &quot;, instructions size = &quot;, m_codeBlock-&gt;instructionsSize(), &quot;\n&quot;);
188 
189     CompilationPath path = compileInThreadImpl();
190 
191     RELEASE_ASSERT(path == CancelPath || m_finalizer);
192     RELEASE_ASSERT((path == CancelPath) == (m_stage == Cancelled));
193 
194     MonotonicTime after { };
195     if (UNLIKELY(computeCompileTimes())) {
196         after = MonotonicTime::now();
197 
198         if (Options::reportTotalCompileTimes()) {
199             if (isFTL()) {
200                 totalFTLCompileTime += after - before;
201                 totalFTLDFGCompileTime += m_timeBeforeFTL - before;
202                 totalFTLB3CompileTime += after - m_timeBeforeFTL;
203             } else
204                 totalDFGCompileTime += after - before;
205         }
206     }
207     const char* pathName = nullptr;
208     switch (path) {
209     case FailPath:
210         pathName = &quot;N/A (fail)&quot;;
211         break;
212     case DFGPath:
213         pathName = &quot;DFG&quot;;
214         break;
215     case FTLPath:
216         pathName = &quot;FTL&quot;;
217         break;
218     case CancelPath:
219         pathName = &quot;Cancelled&quot;;
220         break;
221     default:
222         RELEASE_ASSERT_NOT_REACHED();
223         break;
224     }
225     if (m_codeBlock) { // m_codeBlock will be null if the compilation was cancelled.
226         if (path == FTLPath)
227             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;ftlCompile&quot;, (&quot;took &quot;, (after - before).milliseconds(), &quot; ms (DFG: &quot;, (m_timeBeforeFTL - before).milliseconds(), &quot;, B3: &quot;, (after - m_timeBeforeFTL).milliseconds(), &quot;) with &quot;, pathName));
228         else
229             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgCompile&quot;, (&quot;took &quot;, (after - before).milliseconds(), &quot; ms with &quot;, pathName));
230     }
231     if (UNLIKELY(reportCompileTimes())) {
232         dataLog(&quot;Optimized &quot;, codeBlockName, &quot; using &quot;, m_mode, &quot; with &quot;, pathName, &quot; into &quot;, m_finalizer ? m_finalizer-&gt;codeSize() : 0, &quot; bytes in &quot;, (after - before).milliseconds(), &quot; ms&quot;);
233         if (path == FTLPath)
234             dataLog(&quot; (DFG: &quot;, (m_timeBeforeFTL - before).milliseconds(), &quot;, B3: &quot;, (after - m_timeBeforeFTL).milliseconds(), &quot;)&quot;);
235         dataLog(&quot;.\n&quot;);
236     }
237 }
238 
239 Plan::CompilationPath Plan::compileInThreadImpl()
240 {
241     {
242         CompilerTimingScope timingScope(&quot;DFG&quot;, &quot;clean must handle values&quot;);
243         cleanMustHandleValuesIfNecessary();
244     }
245 
246     if (verboseCompilationEnabled(m_mode) &amp;&amp; m_osrEntryBytecodeIndex) {
247         dataLog(&quot;\n&quot;);
248         dataLog(&quot;Compiler must handle OSR entry from &quot;, m_osrEntryBytecodeIndex, &quot; with values: &quot;, m_mustHandleValues, &quot;\n&quot;);
249         dataLog(&quot;\n&quot;);
250     }
251 
252     Graph dfg(*m_vm, *this);
253 
254     {
255         CompilerTimingScope timingScope(&quot;DFG&quot;, &quot;bytecode parser&quot;);
256         parse(dfg);
257     }
258 
259     m_codeBlock-&gt;setCalleeSaveRegisters(RegisterSet::dfgCalleeSaveRegisters());
260 
261     bool changed = false;
262 
263 #define RUN_PHASE(phase)                                         \
264     do {                                                         \
265         if (Options::safepointBeforeEachPhase()) {               \
266             Safepoint::Result safepointResult;                   \
267             {                                                    \
268                 GraphSafepoint safepoint(dfg, safepointResult);  \
269             }                                                    \
270             if (safepointResult.didGetCancelled())               \
271                 return CancelPath;                               \
272         }                                                        \
273         dfg.nextPhase();                                         \
274         changed |= phase(dfg);                                   \
275     } while (false);                                             \
276 
277 
278     // By this point the DFG bytecode parser will have potentially mutated various tables
279     // in the CodeBlock. This is a good time to perform an early shrink, which is more
280     // powerful than a late one. It&#39;s safe to do so because we haven&#39;t generated any code
281     // that references any of the tables directly, yet.
282     {
283         ConcurrentJSLocker locker(m_codeBlock-&gt;m_lock);
284         m_codeBlock-&gt;shrinkToFit(locker, CodeBlock::ShrinkMode::EarlyShrink);
285     }
286 
287     if (validationEnabled())
288         validate(dfg);
289 
290     if (Options::dumpGraphAfterParsing()) {
291         dataLog(&quot;Graph after parsing:\n&quot;);
292         dfg.dump();
293     }
294 
295     RUN_PHASE(performLiveCatchVariablePreservationPhase);
296 
297     RUN_PHASE(performCPSRethreading);
298     RUN_PHASE(performUnification);
299     RUN_PHASE(performPredictionInjection);
300 
301     RUN_PHASE(performStaticExecutionCountEstimation);
302 
303     if (m_mode == FTLForOSREntryMode) {
304         bool result = performOSREntrypointCreation(dfg);
305         if (!result) {
306             m_finalizer = makeUnique&lt;FailedFinalizer&gt;(*this);
307             return FailPath;
308         }
309         RUN_PHASE(performCPSRethreading);
310     }
311 
312     if (validationEnabled())
313         validate(dfg);
314 
315     RUN_PHASE(performBackwardsPropagation);
316     RUN_PHASE(performPredictionPropagation);
317     RUN_PHASE(performFixup);
318     RUN_PHASE(performInvalidationPointInjection);
319     RUN_PHASE(performTypeCheckHoisting);
320 
321     dfg.m_fixpointState = FixpointNotConverged;
322 
323     // For now we&#39;re back to avoiding a fixpoint. Note that we&#39;ve ping-ponged on this decision
324     // many times. For maximum throughput, it&#39;s best to fixpoint. But the throughput benefit is
325     // small and not likely to show up in FTL anyway. On the other hand, not fixpointing means
326     // that the compiler compiles more quickly. We want the third tier to compile quickly, which
327     // not fixpointing accomplishes; and the fourth tier shouldn&#39;t need a fixpoint.
328     if (validationEnabled())
329         validate(dfg);
330 
331     RUN_PHASE(performStrengthReduction);
332     RUN_PHASE(performCPSRethreading);
333     RUN_PHASE(performCFA);
334     RUN_PHASE(performConstantFolding);
335     changed = false;
336     RUN_PHASE(performCFGSimplification);
337     RUN_PHASE(performLocalCSE);
338 
339     if (validationEnabled())
340         validate(dfg);
341 
342     RUN_PHASE(performCPSRethreading);
343     if (!isFTL()) {
344         // Only run this if we&#39;re not FTLing, because currently for a LoadVarargs that is forwardable and
345         // in a non-varargs inlined call frame, this will generate ForwardVarargs while the FTL
346         // ArgumentsEliminationPhase will create a sequence of GetStack+PutStacks. The GetStack+PutStack
347         // sequence then gets sunk, eliminating anything that looks like an escape for subsequent phases,
348         // while the ForwardVarargs doesn&#39;t get simplified until later (or not at all) and looks like an
349         // escape for all of the arguments. This then disables object allocation sinking.
350         //
351         // So, for now, we just disable this phase for the FTL.
352         //
353         // If we wanted to enable it, we&#39;d have to do any of the following:
354         // - Enable ForwardVarargs-&gt;GetStack+PutStack strength reduction, and have that run before
355         //   PutStack sinking and object allocation sinking.
356         // - Make VarargsForwarding emit a GetLocal+SetLocal sequence, that we can later turn into
357         //   GetStack+PutStack.
358         //
359         // But, it&#39;s not super valuable to enable those optimizations, since the FTL
360         // ArgumentsEliminationPhase does everything that this phase does, and it doesn&#39;t introduce this
361         // pathology.
362 
363         RUN_PHASE(performVarargsForwarding); // Do this after CFG simplification and CPS rethreading.
364     }
365     if (changed) {
366         RUN_PHASE(performCFA);
367         RUN_PHASE(performConstantFolding);
368     }
369 
370     // If we&#39;re doing validation, then run some analyses, to give them an opportunity
371     // to self-validate. Now is as good a time as any to do this.
372     if (validationEnabled()) {
373         dfg.ensureCPSDominators();
374         dfg.ensureCPSNaturalLoops();
375     }
376 
377     switch (m_mode) {
378     case DFGMode: {
379         dfg.m_fixpointState = FixpointConverged;
380 
381         RUN_PHASE(performTierUpCheckInjection);
382 
383         RUN_PHASE(performFastStoreBarrierInsertion);
384         RUN_PHASE(performStoreBarrierClustering);
385         RUN_PHASE(performCleanUp);
386         RUN_PHASE(performCPSRethreading);
387         RUN_PHASE(performDCE);
388         RUN_PHASE(performPhantomInsertion);
389         RUN_PHASE(performStackLayout);
390         RUN_PHASE(performVirtualRegisterAllocation);
391         RUN_PHASE(performWatchpointCollection);
392         dumpAndVerifyGraph(dfg, &quot;Graph after optimization:&quot;);
393 
394         {
395             CompilerTimingScope timingScope(&quot;DFG&quot;, &quot;machine code generation&quot;);
396 
397             JITCompiler dataFlowJIT(dfg);
398             if (m_codeBlock-&gt;codeType() == FunctionCode)
399                 dataFlowJIT.compileFunction();
400             else
401                 dataFlowJIT.compile();
402         }
403 
404         return DFGPath;
405     }
406 
407     case FTLMode:
408     case FTLForOSREntryMode: {
409 #if ENABLE(FTL_JIT)
410         if (FTL::canCompile(dfg) == FTL::CannotCompile) {
411             m_finalizer = makeUnique&lt;FailedFinalizer&gt;(*this);
412             return FailPath;
413         }
414 
415         RUN_PHASE(performCleanUp); // Reduce the graph size a bit.
416         RUN_PHASE(performCriticalEdgeBreaking);
417         if (Options::createPreHeaders())
418             RUN_PHASE(performLoopPreHeaderCreation);
419         RUN_PHASE(performCPSRethreading);
420         RUN_PHASE(performSSAConversion);
421         RUN_PHASE(performSSALowering);
422 
423         // Ideally, these would be run to fixpoint with the object allocation sinking phase.
424         RUN_PHASE(performArgumentsElimination);
425         if (Options::usePutStackSinking())
426             RUN_PHASE(performPutStackSinking);
427 
428         RUN_PHASE(performConstantHoisting);
429         RUN_PHASE(performGlobalCSE);
430         RUN_PHASE(performLivenessAnalysis);
431         RUN_PHASE(performCFA);
432         RUN_PHASE(performConstantFolding);
433         RUN_PHASE(performCleanUp); // Reduce the graph size a lot.
434         changed = false;
435         RUN_PHASE(performStrengthReduction);
436         if (Options::useObjectAllocationSinking()) {
437             RUN_PHASE(performCriticalEdgeBreaking);
438             RUN_PHASE(performObjectAllocationSinking);
439         }
440         if (Options::useValueRepElimination())
441             RUN_PHASE(performValueRepReduction);
442         if (changed) {
443             // State-at-tail and state-at-head will be invalid if we did strength reduction since
444             // it might increase live ranges.
445             RUN_PHASE(performLivenessAnalysis);
446             RUN_PHASE(performCFA);
447             RUN_PHASE(performConstantFolding);
448         }
449 
450         // Currently, this relies on pre-headers still being valid. That precludes running CFG
451         // simplification before it, unless we re-created the pre-headers. There wouldn&#39;t be anything
452         // wrong with running LICM earlier, if we wanted to put other CFG transforms above this point.
453         // Alternatively, we could run loop pre-header creation after SSA conversion - but if we did that
454         // then we&#39;d need to do some simple SSA fix-up.
455         RUN_PHASE(performLivenessAnalysis);
456         RUN_PHASE(performCFA);
457         RUN_PHASE(performLICM);
458 
459         // FIXME: Currently: IntegerRangeOptimization *must* be run after LICM.
460         //
461         // IntegerRangeOptimization makes changes on nodes based on preceding blocks
462         // and nodes. LICM moves nodes which can invalidates assumptions used
463         // by IntegerRangeOptimization.
464         //
465         // Ideally, the dependencies should be explicit. See https://bugs.webkit.org/show_bug.cgi?id=157534.
466         RUN_PHASE(performLivenessAnalysis);
467         RUN_PHASE(performIntegerRangeOptimization);
468 
469         RUN_PHASE(performCleanUp);
470         RUN_PHASE(performIntegerCheckCombining);
471         RUN_PHASE(performGlobalCSE);
472 
473         // At this point we&#39;re not allowed to do any further code motion because our reasoning
474         // about code motion assumes that it&#39;s OK to insert GC points in random places.
475         dfg.m_fixpointState = FixpointConverged;
476 
477         RUN_PHASE(performLivenessAnalysis);
478         RUN_PHASE(performCFA);
479         RUN_PHASE(performGlobalStoreBarrierInsertion);
480         RUN_PHASE(performStoreBarrierClustering);
481         if (Options::useMovHintRemoval())
482             RUN_PHASE(performMovHintRemoval);
483         RUN_PHASE(performCleanUp);
484         RUN_PHASE(performDCE); // We rely on this to kill dead code that won&#39;t be recognized as dead by B3.
485         RUN_PHASE(performStackLayout);
486         RUN_PHASE(performLivenessAnalysis);
487         RUN_PHASE(performOSRAvailabilityAnalysis);
488         RUN_PHASE(performWatchpointCollection);
489 
490         if (FTL::canCompile(dfg) == FTL::CannotCompile) {
491             m_finalizer = makeUnique&lt;FailedFinalizer&gt;(*this);
492             return FailPath;
493         }
494 
495         dfg.nextPhase();
496         dumpAndVerifyGraph(dfg, &quot;Graph just before FTL lowering:&quot;, shouldDumpDisassembly(m_mode));
497 
498         // Flash a safepoint in case the GC wants some action.
499         Safepoint::Result safepointResult;
500         {
501             GraphSafepoint safepoint(dfg, safepointResult);
502         }
503         if (safepointResult.didGetCancelled())
504             return CancelPath;
505 
506         dfg.nextPhase();
507         FTL::State state(dfg);
508         FTL::lowerDFGToB3(state);
509 
510         if (UNLIKELY(computeCompileTimes()))
511             m_timeBeforeFTL = MonotonicTime::now();
512 
513         if (UNLIKELY(Options::b3AlwaysFailsBeforeCompile())) {
514             FTL::fail(state);
515             return FTLPath;
516         }
517 
518         FTL::compile(state, safepointResult);
519         if (safepointResult.didGetCancelled())
520             return CancelPath;
521 
522         if (UNLIKELY(Options::b3AlwaysFailsBeforeLink())) {
523             FTL::fail(state);
524             return FTLPath;
525         }
526 
527         if (state.allocationFailed) {
528             FTL::fail(state);
529             return FTLPath;
530         }
531 
532         FTL::link(state);
533 
534         if (state.allocationFailed) {
535             FTL::fail(state);
536             return FTLPath;
537         }
538 
539         return FTLPath;
540 #else
541         RELEASE_ASSERT_NOT_REACHED();
542         return FailPath;
543 #endif // ENABLE(FTL_JIT)
544     }
545 
546     default:
547         RELEASE_ASSERT_NOT_REACHED();
548         return FailPath;
549     }
550 
551 #undef RUN_PHASE
552 }
553 
554 bool Plan::isStillValid()
555 {
556     CodeBlock* replacement = m_codeBlock-&gt;replacement();
557     if (!replacement)
558         return false;
559     // FIXME: This is almost certainly not necessary. There&#39;s no way for the baseline
560     // code to be replaced during a compilation, except if we delete the plan, in which
561     // case we wouldn&#39;t be here.
562     // https://bugs.webkit.org/show_bug.cgi?id=132707
563     if (m_codeBlock-&gt;alternative() != replacement-&gt;baselineVersion())
564         return false;
565     if (!m_watchpoints.areStillValid())
566         return false;
567     return true;
568 }
569 
570 void Plan::reallyAdd(CommonData* commonData)
571 {
572     m_watchpoints.reallyAdd(m_codeBlock, *commonData);
573     m_identifiers.reallyAdd(*m_vm, commonData);
574     m_weakReferences.reallyAdd(*m_vm, commonData);
575     m_transitions.reallyAdd(*m_vm, commonData);
576     m_globalProperties.reallyAdd(m_codeBlock, m_identifiers, *commonData);
577     commonData-&gt;recordedStatuses = WTFMove(m_recordedStatuses);
578 }
579 
580 void Plan::notifyCompiling()
581 {
582     m_stage = Compiling;
583 }
584 
585 void Plan::notifyReady()
586 {
587     m_callback-&gt;compilationDidBecomeReadyAsynchronously(m_codeBlock, m_profiledDFGCodeBlock);
588     m_stage = Ready;
589 }
590 
591 bool Plan::isStillValidOnMainThread()
592 {
593     return m_globalProperties.isStillValidOnMainThread(*m_vm, m_identifiers);
594 }
595 
596 CompilationResult Plan::finalizeWithoutNotifyingCallback()
597 {
598     // We perform multiple stores before emitting a write-barrier. To ensure that no GC happens between store and write-barrier, we should ensure that
599     // GC is deferred when this function is called.
600     ASSERT(m_vm-&gt;heap.isDeferred());
601 
602     CompilationResult result = [&amp;] {
603         if (!isStillValidOnMainThread() || !isStillValid()) {
604             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;invalidated&quot;));
605             return CompilationInvalidated;
606         }
607 
608         bool result;
609         if (m_codeBlock-&gt;codeType() == FunctionCode)
610             result = m_finalizer-&gt;finalizeFunction();
611         else
612             result = m_finalizer-&gt;finalize();
613 
614         if (!result) {
615             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;failed&quot;));
616             return CompilationFailed;
617         }
618 
619         reallyAdd(m_codeBlock-&gt;jitCode()-&gt;dfgCommon());
620         {
621             ConcurrentJSLocker locker(m_codeBlock-&gt;m_lock);
622             m_codeBlock-&gt;jitCode()-&gt;shrinkToFit(locker);
623             m_codeBlock-&gt;shrinkToFit(locker, CodeBlock::ShrinkMode::LateShrink);
624         }
625 
626         if (validationEnabled()) {
627             TrackedReferences trackedReferences;
628 
629             for (WriteBarrier&lt;JSCell&gt;&amp; reference : m_codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;weakReferences)
630                 trackedReferences.add(reference.get());
631             for (StructureID structureID : m_codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;weakStructureReferences)
632                 trackedReferences.add(m_vm-&gt;getStructure(structureID));
633             for (WriteBarrier&lt;Unknown&gt;&amp; constant : m_codeBlock-&gt;constants())
634                 trackedReferences.add(constant.get());
635 
636             for (auto* inlineCallFrame : *m_inlineCallFrames) {
637                 ASSERT(inlineCallFrame-&gt;baselineCodeBlock.get());
638                 trackedReferences.add(inlineCallFrame-&gt;baselineCodeBlock.get());
639             }
640 
641             // Check that any other references that we have anywhere in the JITCode are also
642             // tracked either strongly or weakly.
643             m_codeBlock-&gt;jitCode()-&gt;validateReferences(trackedReferences);
644         }
645 
646         CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;succeeded&quot;));
647         return CompilationSuccessful;
648     }();
649 
650     // We will establish new references from the code block to things. So, we need a barrier.
651     m_vm-&gt;heap.writeBarrier(m_codeBlock);
652     return result;
653 }
654 
655 void Plan::finalizeAndNotifyCallback()
656 {
657     m_callback-&gt;compilationDidComplete(m_codeBlock, m_profiledDFGCodeBlock, finalizeWithoutNotifyingCallback());
658 }
659 
660 CompilationKey Plan::key()
661 {
662     return CompilationKey(m_codeBlock-&gt;alternative(), m_mode);
663 }
664 
665 void Plan::checkLivenessAndVisitChildren(SlotVisitor&amp; visitor)
666 {
667     if (!isKnownToBeLiveDuringGC())
668         return;
669 
670     cleanMustHandleValuesIfNecessary();
671     for (unsigned i = m_mustHandleValues.size(); i--;) {
672         Optional&lt;JSValue&gt; value = m_mustHandleValues[i];
673         if (value)
674             visitor.appendUnbarriered(value.value());
675     }
676 
677     m_recordedStatuses.visitAggregate(visitor);
678     m_recordedStatuses.markIfCheap(visitor);
679 
680     visitor.appendUnbarriered(m_codeBlock);
681     visitor.appendUnbarriered(m_codeBlock-&gt;alternative());
682     visitor.appendUnbarriered(m_profiledDFGCodeBlock);
683 
684     if (m_inlineCallFrames) {
685         for (auto* inlineCallFrame : *m_inlineCallFrames) {
686             ASSERT(inlineCallFrame-&gt;baselineCodeBlock.get());
687             visitor.appendUnbarriered(inlineCallFrame-&gt;baselineCodeBlock.get());
688         }
689     }
690 
691     m_weakReferences.visitChildren(visitor);
692     m_transitions.visitChildren(visitor);
693 }
694 
695 void Plan::finalizeInGC()
696 {
697     ASSERT(m_vm);
698     m_recordedStatuses.finalizeWithoutDeleting(*m_vm);
699 }
700 
701 bool Plan::isKnownToBeLiveDuringGC()
702 {
703     if (m_stage == Cancelled)
704         return false;
705     if (!m_vm-&gt;heap.isMarked(m_codeBlock-&gt;ownerExecutable()))
706         return false;
707     if (!m_vm-&gt;heap.isMarked(m_codeBlock-&gt;alternative()))
708         return false;
709     if (!!m_profiledDFGCodeBlock &amp;&amp; !m_vm-&gt;heap.isMarked(m_profiledDFGCodeBlock))
710         return false;
711     return true;
712 }
713 
714 void Plan::cancel()
715 {
716     RELEASE_ASSERT(m_stage != Cancelled);
717     ASSERT(m_vm);
718     m_vm = nullptr;
719 
720     m_codeBlock = nullptr;
721     m_profiledDFGCodeBlock = nullptr;
722     m_mustHandleValues.clear();
723     m_compilation = nullptr;
724     m_finalizer = nullptr;
725     m_inlineCallFrames = nullptr;
726     m_watchpoints = DesiredWatchpoints();
727     m_identifiers = DesiredIdentifiers();
728     m_globalProperties = DesiredGlobalProperties();
729     m_weakReferences = DesiredWeakReferences();
730     m_transitions = DesiredTransitions();
731     m_callback = nullptr;
732     m_stage = Cancelled;
733 }
734 
735 void Plan::cleanMustHandleValuesIfNecessary()
736 {
737     LockHolder locker(m_mustHandleValueCleaningLock);
738 
739     if (!m_mustHandleValuesMayIncludeGarbage)
740         return;
741 
742     m_mustHandleValuesMayIncludeGarbage = false;
743 
744     if (!m_codeBlock)
745         return;
746 
747     if (!m_mustHandleValues.numberOfLocals())
748         return;
749 
750     CodeBlock* alternative = m_codeBlock-&gt;alternative();
751     FastBitVector liveness = alternative-&gt;livenessAnalysis().getLivenessInfoAtBytecodeIndex(alternative, m_osrEntryBytecodeIndex);
752 
753     for (unsigned local = m_mustHandleValues.numberOfLocals(); local--;) {
754         if (!liveness[local])
755             m_mustHandleValues.local(local) = WTF::nullopt;
756     }
757 }
758 
759 } } // namespace JSC::DFG
760 
761 #endif // ENABLE(DFG_JIT)
762 
    </pre>
  </body>
</html>
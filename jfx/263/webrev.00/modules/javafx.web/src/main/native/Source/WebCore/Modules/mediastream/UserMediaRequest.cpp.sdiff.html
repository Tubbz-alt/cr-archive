<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/UserMediaRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="UserMediaController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="UserMediaRequest.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/UserMediaRequest.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 22  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 23  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 24  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 25  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 26  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 27  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 28  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 29  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 30  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 31  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 
 34 #include &quot;config.h&quot;
 35 #include &quot;UserMediaRequest.h&quot;
 36 
 37 #if ENABLE(MEDIA_STREAM)
 38 
 39 #include &quot;Document.h&quot;
 40 #include &quot;Frame.h&quot;

 41 #include &quot;JSMediaStream.h&quot;
 42 #include &quot;JSOverconstrainedError.h&quot;
 43 #include &quot;Logging.h&quot;
 44 #include &quot;MediaConstraints.h&quot;
 45 #include &quot;PlatformMediaSessionManager.h&quot;
 46 #include &quot;RealtimeMediaSourceCenter.h&quot;
<span class="line-removed"> 47 #include &quot;SchemeRegistry.h&quot;</span>
 48 #include &quot;Settings.h&quot;
 49 #include &quot;UserMediaController.h&quot;

 50 #include &lt;wtf/Scope.h&gt;
 51 
 52 namespace WebCore {
 53 
 54 Ref&lt;UserMediaRequest&gt; UserMediaRequest::create(Document&amp; document, MediaStreamRequest&amp;&amp; request, DOMPromiseDeferred&lt;IDLInterface&lt;MediaStream&gt;&gt;&amp;&amp; promise)
 55 {
 56     auto result = adoptRef(*new UserMediaRequest(document, WTFMove(request), WTFMove(promise)));
 57     result-&gt;suspendIfNeeded();
 58     return result;
 59 }
 60 
 61 UserMediaRequest::UserMediaRequest(Document&amp; document, MediaStreamRequest&amp;&amp; request, DOMPromiseDeferred&lt;IDLInterface&lt;MediaStream&gt;&gt;&amp;&amp; promise)
 62     : ActiveDOMObject(document)
<span class="line-modified"> 63     , m_promise(WTFMove(promise))</span>

 64     , m_request(WTFMove(request))
 65 {
 66 }
 67 
<span class="line-modified"> 68 UserMediaRequest::~UserMediaRequest() = default;</span>




 69 
 70 SecurityOrigin* UserMediaRequest::userMediaDocumentOrigin() const
 71 {
 72     if (!m_scriptExecutionContext)
 73         return nullptr;
 74     return m_scriptExecutionContext-&gt;securityOrigin();
 75 }
 76 
 77 SecurityOrigin* UserMediaRequest::topLevelDocumentOrigin() const
 78 {
 79     if (!m_scriptExecutionContext)
 80         return nullptr;
 81     return &amp;m_scriptExecutionContext-&gt;topOrigin();
 82 }
 83 
 84 static bool hasInvalidGetDisplayMediaConstraint(const MediaConstraints&amp; constraints)
 85 {
 86     // https://w3c.github.io/mediacapture-screen-share/#navigator-additions
 87     // 1. Let constraints be the method&#39;s first argument.
 88     // 2. For each member present in constraints whose value, value, is a dictionary, run the following steps:
</pre>
<hr />
<pre>
175         deny(MediaAccessDenialReason::NoConstraints);
176         return;
177     }
178 
179     // 4. If the current settings object&#39;s responsible document is NOT allowed to use the feature indicated by
180     //    attribute name allowusermedia, return a promise rejected with a DOMException object whose name
181     //    attribute has the value SecurityError.
182     auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
183     auto* controller = UserMediaController::from(document.page());
184     if (!controller) {
185         deny(MediaAccessDenialReason::UserMediaDisabled);
186         return;
187     }
188 
189     // 6.3 Optionally, e.g., based on a previously-established user preference, for security reasons,
190     //     or due to platform limitations, jump to the step labeled Permission Failure below.
191     // ...
192     // 6.10 Permission Failure: Reject p with a new DOMException object whose name attribute has
193     //      the value NotAllowedError.
194 
<span class="line-modified">195     OptionSet&lt;UserMediaController::CaptureType&gt; types;</span>
<span class="line-modified">196     UserMediaController::BlockedCaller caller;</span>
<span class="line-modified">197     if (m_request.type == MediaStreamRequest::Type::DisplayMedia) {</span>
<span class="line-modified">198         types.add(UserMediaController::CaptureType::Display);</span>
<span class="line-modified">199         caller = UserMediaController::BlockedCaller::GetDisplayMedia;</span>
<span class="line-modified">200     } else {</span>
<span class="line-modified">201         if (m_request.audioConstraints.isValid)</span>
<span class="line-modified">202             types.add(UserMediaController::CaptureType::Microphone);</span>
<span class="line-modified">203         if (m_request.videoConstraints.isValid)</span>
<span class="line-modified">204             types.add(UserMediaController::CaptureType::Camera);</span>
<span class="line-modified">205         caller = UserMediaController::BlockedCaller::GetUserMedia;</span>
<span class="line-modified">206     }</span>
<span class="line-modified">207     auto access = controller-&gt;canCallGetUserMedia(document, types);</span>
<span class="line-modified">208     if (access != UserMediaController::GetUserMediaAccess::CanCall) {</span>
<span class="line-modified">209         deny(MediaAccessDenialReason::PermissionDenied);</span>
<span class="line-modified">210         controller-&gt;logGetUserMediaDenial(document, access, caller);</span>
<span class="line-modified">211         return;</span>



212     }
213 
214     PlatformMediaSessionManager::sharedManager().prepareToSendUserMediaPermissionRequest();
215     controller-&gt;requestUserMediaAccess(*this);
216 }
217 










218 void UserMediaRequest::allow(CaptureDevice&amp;&amp; audioDevice, CaptureDevice&amp;&amp; videoDevice, String&amp;&amp; deviceIdentifierHashSalt, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
219 {
220     RELEASE_LOG(MediaStream, &quot;UserMediaRequest::allow %s %s&quot;, audioDevice ? audioDevice.persistentId().utf8().data() : &quot;&quot;, videoDevice ? videoDevice.persistentId().utf8().data() : &quot;&quot;);





































221 
<span class="line-removed">222     auto callback = [this, protector = makePendingActivity(*this), completionHandler = WTFMove(completionHandler)](RefPtr&lt;MediaStreamPrivate&gt;&amp;&amp; privateStream) mutable {</span>
<span class="line-removed">223         auto scopeExit = makeScopeExit([&amp;] {</span>
<span class="line-removed">224             completionHandler();</span>
<span class="line-removed">225         });</span>
226         if (!m_scriptExecutionContext)
227             return;
228 
<span class="line-removed">229         if (!privateStream) {</span>
<span class="line-removed">230             RELEASE_LOG(MediaStream, &quot;UserMediaRequest::allow failed to create media stream!&quot;);</span>
<span class="line-removed">231             deny(MediaAccessDenialReason::HardwareError);</span>
<span class="line-removed">232             return;</span>
<span class="line-removed">233         }</span>
<span class="line-removed">234         privateStream-&gt;monitorOrientation(downcast&lt;Document&gt;(m_scriptExecutionContext)-&gt;orientationNotifier());</span>
<span class="line-removed">235 </span>
<span class="line-removed">236         auto stream = MediaStream::create(*downcast&lt;Document&gt;(m_scriptExecutionContext), privateStream.releaseNonNull());</span>
<span class="line-removed">237         if (stream-&gt;getTracks().isEmpty()) {</span>
<span class="line-removed">238             deny(MediaAccessDenialReason::HardwareError);</span>
<span class="line-removed">239             return;</span>
<span class="line-removed">240         }</span>
<span class="line-removed">241 </span>
<span class="line-removed">242         scopeExit.release();</span>
<span class="line-removed">243         m_pendingActivationMediaStream = makeUnique&lt;PendingActivationMediaStream&gt;(WTFMove(protector), *this, WTFMove(stream), WTFMove(completionHandler));</span>
<span class="line-removed">244     };</span>
<span class="line-removed">245 </span>
<span class="line-removed">246     auto&amp; document = downcast&lt;Document&gt;(*scriptExecutionContext());</span>
<span class="line-removed">247     document.setDeviceIDHashSalt(deviceIdentifierHashSalt);</span>
<span class="line-removed">248 </span>
<span class="line-removed">249     RealtimeMediaSourceCenter::singleton().createMediaStream(document.logger(), WTFMove(callback), WTFMove(deviceIdentifierHashSalt), WTFMove(audioDevice), WTFMove(videoDevice), m_request);</span>
<span class="line-removed">250 </span>
<span class="line-removed">251     if (!m_scriptExecutionContext)</span>
<span class="line-removed">252         return;</span>
<span class="line-removed">253 </span>
254 #if ENABLE(WEB_RTC)
<span class="line-modified">255     if (auto* page = document.page())</span>
<span class="line-modified">256         page-&gt;rtcController().disableICECandidateFilteringForDocument(document);</span>
257 #endif

258 }
259 
260 void UserMediaRequest::deny(MediaAccessDenialReason reason, const String&amp; message)
261 {
262     if (!m_scriptExecutionContext)
263         return;
264 
265     ExceptionCode code;
266     switch (reason) {
267     case MediaAccessDenialReason::IllegalConstraint:
268         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - invalid constraints&quot;);
269         code = TypeError;
270         break;
271     case MediaAccessDenialReason::NoConstraints:
272         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - no constraints&quot;);
273         code = TypeError;
274         break;
275     case MediaAccessDenialReason::UserMediaDisabled:
276         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - user media disabled&quot;);
277         code = SecurityError;
278         break;
279     case MediaAccessDenialReason::NoCaptureDevices:
280         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - no capture devices&quot;);
281         code = NotFoundError;
282         break;
283     case MediaAccessDenialReason::InvalidConstraint:
284         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - invalid constraint - %s&quot;, message.utf8().data());
<span class="line-modified">285         m_promise.rejectType&lt;IDLInterface&lt;OverconstrainedError&gt;&gt;(OverconstrainedError::create(message, &quot;Invalid constraint&quot;_s).get());</span>
286         return;
287     case MediaAccessDenialReason::HardwareError:
288         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - hardware error&quot;);
289         code = NotReadableError;
290         break;
291     case MediaAccessDenialReason::OtherFailure:
292         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - other failure&quot;);
293         code = AbortError;
294         break;
295     case MediaAccessDenialReason::PermissionDenied:
296         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - permission denied&quot;);
297         code = NotAllowedError;
298         break;
299     case MediaAccessDenialReason::InvalidAccess:
300         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - invalid access&quot;);
301         code = InvalidAccessError;
302         break;
303     }
304 
305     if (!message.isEmpty())
<span class="line-modified">306         m_promise.reject(code, message);</span>
307     else
<span class="line-modified">308         m_promise.reject(code);</span>
309 }
310 
311 void UserMediaRequest::stop()
312 {
<span class="line-removed">313     // Protecting &#39;this&#39; since nulling m_pendingActivationMediaStream might destroy it.</span>
<span class="line-removed">314     Ref&lt;UserMediaRequest&gt; protectedThis(*this);</span>
<span class="line-removed">315 </span>
<span class="line-removed">316     m_pendingActivationMediaStream = nullptr;</span>
<span class="line-removed">317 </span>
318     auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
319     if (auto* controller = UserMediaController::from(document.page()))
320         controller-&gt;cancelUserMediaAccessRequest(*this);
321 }
322 
323 const char* UserMediaRequest::activeDOMObjectName() const
324 {
325     return &quot;UserMediaRequest&quot;;
326 }
327 
<span class="line-removed">328 bool UserMediaRequest::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">329 {</span>
<span class="line-removed">330     return !hasPendingActivity();</span>
<span class="line-removed">331 }</span>
<span class="line-removed">332 </span>
333 Document* UserMediaRequest::document() const
334 {
335     return downcast&lt;Document&gt;(m_scriptExecutionContext);
336 }
337 
<span class="line-removed">338 UserMediaRequest::PendingActivationMediaStream::PendingActivationMediaStream(Ref&lt;PendingActivity&lt;UserMediaRequest&gt;&gt;&amp;&amp; protectingUserMediaRequest, UserMediaRequest&amp; userMediaRequest, Ref&lt;MediaStream&gt;&amp;&amp; stream, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)</span>
<span class="line-removed">339     : m_protectingUserMediaRequest(WTFMove(protectingUserMediaRequest))</span>
<span class="line-removed">340     , m_userMediaRequest(userMediaRequest)</span>
<span class="line-removed">341     , m_mediaStream(WTFMove(stream))</span>
<span class="line-removed">342     , m_completionHandler(WTFMove(completionHandler))</span>
<span class="line-removed">343 {</span>
<span class="line-removed">344     m_mediaStream-&gt;privateStream().addObserver(*this);</span>
<span class="line-removed">345     m_mediaStream-&gt;startProducingData();</span>
<span class="line-removed">346 }</span>
<span class="line-removed">347 </span>
<span class="line-removed">348 UserMediaRequest::PendingActivationMediaStream::~PendingActivationMediaStream()</span>
<span class="line-removed">349 {</span>
<span class="line-removed">350     m_mediaStream-&gt;privateStream().removeObserver(*this);</span>
<span class="line-removed">351     m_completionHandler();</span>
<span class="line-removed">352     if (auto* document = m_mediaStream-&gt;document())</span>
<span class="line-removed">353         document-&gt;updateIsPlayingMedia();</span>
<span class="line-removed">354 }</span>
<span class="line-removed">355 </span>
<span class="line-removed">356 void UserMediaRequest::PendingActivationMediaStream::characteristicsChanged()</span>
<span class="line-removed">357 {</span>
<span class="line-removed">358     if (!m_userMediaRequest.m_pendingActivationMediaStream)</span>
<span class="line-removed">359         return;</span>
<span class="line-removed">360 </span>
<span class="line-removed">361     for (auto&amp; track : m_mediaStream-&gt;privateStream().tracks()) {</span>
<span class="line-removed">362         if (track-&gt;source().captureDidFail()) {</span>
<span class="line-removed">363             m_userMediaRequest.mediaStreamDidFail(track-&gt;source().type());</span>
<span class="line-removed">364             return;</span>
<span class="line-removed">365         }</span>
<span class="line-removed">366     }</span>
<span class="line-removed">367 </span>
<span class="line-removed">368     if (m_mediaStream-&gt;privateStream().hasVideo() || m_mediaStream-&gt;privateStream().hasAudio()) {</span>
<span class="line-removed">369         m_userMediaRequest.mediaStreamIsReady(WTFMove(m_mediaStream));</span>
<span class="line-removed">370         return;</span>
<span class="line-removed">371     }</span>
<span class="line-removed">372 }</span>
<span class="line-removed">373 </span>
<span class="line-removed">374 void UserMediaRequest::mediaStreamIsReady(Ref&lt;MediaStream&gt;&amp;&amp; stream)</span>
<span class="line-removed">375 {</span>
<span class="line-removed">376     RELEASE_LOG(MediaStream, &quot;UserMediaRequest::mediaStreamIsReady&quot;);</span>
<span class="line-removed">377     stream-&gt;document()-&gt;setHasCaptureMediaStreamTrack();</span>
<span class="line-removed">378     m_promise.resolve(WTFMove(stream));</span>
<span class="line-removed">379     m_pendingActivationMediaStream = nullptr;</span>
<span class="line-removed">380 }</span>
<span class="line-removed">381 </span>
382 void UserMediaRequest::mediaStreamDidFail(RealtimeMediaSource::Type type)
383 {
384     RELEASE_LOG(MediaStream, &quot;UserMediaRequest::mediaStreamDidFail&quot;);
385     const char* typeDescription = &quot;&quot;;
386     switch (type) {
387     case RealtimeMediaSource::Type::Audio:
388         typeDescription = &quot;audio&quot;;
389         break;
390     case RealtimeMediaSource::Type::Video:
391         typeDescription = &quot;video&quot;;
392         break;
393     case RealtimeMediaSource::Type::None:
394         typeDescription = &quot;unknown&quot;;
395         break;
396     }
<span class="line-modified">397     m_promise.reject(NotReadableError, makeString(&quot;Failed starting capture of a &quot;_s, typeDescription, &quot; track&quot;_s));</span>
<span class="line-removed">398     m_pendingActivationMediaStream = nullptr;</span>
399 }
400 
401 } // namespace WebCore
402 
403 #endif // ENABLE(MEDIA_STREAM)
</pre>
</td>
<td>
<hr />
<pre>
 21  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 22  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 23  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 24  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 25  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 26  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 27  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 28  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 29  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 30  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 31  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 
 34 #include &quot;config.h&quot;
 35 #include &quot;UserMediaRequest.h&quot;
 36 
 37 #if ENABLE(MEDIA_STREAM)
 38 
 39 #include &quot;Document.h&quot;
 40 #include &quot;Frame.h&quot;
<span class="line-added"> 41 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 42 #include &quot;JSMediaStream.h&quot;
 43 #include &quot;JSOverconstrainedError.h&quot;
 44 #include &quot;Logging.h&quot;
 45 #include &quot;MediaConstraints.h&quot;
 46 #include &quot;PlatformMediaSessionManager.h&quot;
 47 #include &quot;RealtimeMediaSourceCenter.h&quot;

 48 #include &quot;Settings.h&quot;
 49 #include &quot;UserMediaController.h&quot;
<span class="line-added"> 50 #include &quot;WindowEventLoop.h&quot;</span>
 51 #include &lt;wtf/Scope.h&gt;
 52 
 53 namespace WebCore {
 54 
 55 Ref&lt;UserMediaRequest&gt; UserMediaRequest::create(Document&amp; document, MediaStreamRequest&amp;&amp; request, DOMPromiseDeferred&lt;IDLInterface&lt;MediaStream&gt;&gt;&amp;&amp; promise)
 56 {
 57     auto result = adoptRef(*new UserMediaRequest(document, WTFMove(request), WTFMove(promise)));
 58     result-&gt;suspendIfNeeded();
 59     return result;
 60 }
 61 
 62 UserMediaRequest::UserMediaRequest(Document&amp; document, MediaStreamRequest&amp;&amp; request, DOMPromiseDeferred&lt;IDLInterface&lt;MediaStream&gt;&gt;&amp;&amp; promise)
 63     : ActiveDOMObject(document)
<span class="line-modified"> 64     , m_identifier(UserMediaRequestIdentifier::generate())</span>
<span class="line-added"> 65     , m_promise(makeUniqueRef&lt;DOMPromiseDeferred&lt;IDLInterface&lt;MediaStream&gt;&gt;&gt;(WTFMove(promise)))</span>
 66     , m_request(WTFMove(request))
 67 {
 68 }
 69 
<span class="line-modified"> 70 UserMediaRequest::~UserMediaRequest()</span>
<span class="line-added"> 71 {</span>
<span class="line-added"> 72     if (m_allowCompletionHandler)</span>
<span class="line-added"> 73         m_allowCompletionHandler();</span>
<span class="line-added"> 74 }</span>
 75 
 76 SecurityOrigin* UserMediaRequest::userMediaDocumentOrigin() const
 77 {
 78     if (!m_scriptExecutionContext)
 79         return nullptr;
 80     return m_scriptExecutionContext-&gt;securityOrigin();
 81 }
 82 
 83 SecurityOrigin* UserMediaRequest::topLevelDocumentOrigin() const
 84 {
 85     if (!m_scriptExecutionContext)
 86         return nullptr;
 87     return &amp;m_scriptExecutionContext-&gt;topOrigin();
 88 }
 89 
 90 static bool hasInvalidGetDisplayMediaConstraint(const MediaConstraints&amp; constraints)
 91 {
 92     // https://w3c.github.io/mediacapture-screen-share/#navigator-additions
 93     // 1. Let constraints be the method&#39;s first argument.
 94     // 2. For each member present in constraints whose value, value, is a dictionary, run the following steps:
</pre>
<hr />
<pre>
181         deny(MediaAccessDenialReason::NoConstraints);
182         return;
183     }
184 
185     // 4. If the current settings object&#39;s responsible document is NOT allowed to use the feature indicated by
186     //    attribute name allowusermedia, return a promise rejected with a DOMException object whose name
187     //    attribute has the value SecurityError.
188     auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
189     auto* controller = UserMediaController::from(document.page());
190     if (!controller) {
191         deny(MediaAccessDenialReason::UserMediaDisabled);
192         return;
193     }
194 
195     // 6.3 Optionally, e.g., based on a previously-established user preference, for security reasons,
196     //     or due to platform limitations, jump to the step labeled Permission Failure below.
197     // ...
198     // 6.10 Permission Failure: Reject p with a new DOMException object whose name attribute has
199     //      the value NotAllowedError.
200 
<span class="line-modified">201     switch (m_request.type) {</span>
<span class="line-modified">202     case MediaStreamRequest::Type::DisplayMedia:</span>
<span class="line-modified">203         if (!isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::DisplayCapture, document)) {</span>
<span class="line-modified">204             deny(MediaAccessDenialReason::PermissionDenied);</span>
<span class="line-modified">205             controller-&gt;logGetDisplayMediaDenial(document);</span>
<span class="line-modified">206             return;</span>
<span class="line-modified">207         }</span>
<span class="line-modified">208         break;</span>
<span class="line-modified">209     case MediaStreamRequest::Type::UserMedia:</span>
<span class="line-modified">210         if (m_request.audioConstraints.isValid &amp;&amp; !isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Microphone, document)) {</span>
<span class="line-modified">211             deny(MediaAccessDenialReason::PermissionDenied);</span>
<span class="line-modified">212             controller-&gt;logGetUserMediaDenial(document);</span>
<span class="line-modified">213             return;</span>
<span class="line-modified">214         }</span>
<span class="line-modified">215         if (m_request.videoConstraints.isValid &amp;&amp; !isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Camera, document)) {</span>
<span class="line-modified">216             deny(MediaAccessDenialReason::PermissionDenied);</span>
<span class="line-modified">217             controller-&gt;logGetUserMediaDenial(document);</span>
<span class="line-added">218             return;</span>
<span class="line-added">219         }</span>
<span class="line-added">220         break;</span>
221     }
222 
223     PlatformMediaSessionManager::sharedManager().prepareToSendUserMediaPermissionRequest();
224     controller-&gt;requestUserMediaAccess(*this);
225 }
226 
<span class="line-added">227 static inline bool isMediaStreamCorrectlyStarted(const MediaStream&amp; stream)</span>
<span class="line-added">228 {</span>
<span class="line-added">229     if (stream.getTracks().isEmpty())</span>
<span class="line-added">230         return false;</span>
<span class="line-added">231 </span>
<span class="line-added">232     return WTF::allOf(stream.getTracks(), [](auto&amp; track) {</span>
<span class="line-added">233         return !track-&gt;source().captureDidFail();</span>
<span class="line-added">234     });</span>
<span class="line-added">235 }</span>
<span class="line-added">236 </span>
237 void UserMediaRequest::allow(CaptureDevice&amp;&amp; audioDevice, CaptureDevice&amp;&amp; videoDevice, String&amp;&amp; deviceIdentifierHashSalt, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
238 {
239     RELEASE_LOG(MediaStream, &quot;UserMediaRequest::allow %s %s&quot;, audioDevice ? audioDevice.persistentId().utf8().data() : &quot;&quot;, videoDevice ? videoDevice.persistentId().utf8().data() : &quot;&quot;);
<span class="line-added">240     m_allowCompletionHandler = WTFMove(completionHandler);</span>
<span class="line-added">241     queueTaskKeepingObjectAlive(*this, TaskSource::UserInteraction, [this, audioDevice = WTFMove(audioDevice), videoDevice = WTFMove(videoDevice), deviceIdentifierHashSalt = WTFMove(deviceIdentifierHashSalt)]() mutable {</span>
<span class="line-added">242         auto callback = [this, protector = makePendingActivity(*this)](auto privateStreamOrError) mutable {</span>
<span class="line-added">243             auto scopeExit = makeScopeExit([completionHandler = WTFMove(m_allowCompletionHandler)]() mutable {</span>
<span class="line-added">244                 completionHandler();</span>
<span class="line-added">245             });</span>
<span class="line-added">246             if (isContextStopped())</span>
<span class="line-added">247                 return;</span>
<span class="line-added">248 </span>
<span class="line-added">249             if (!privateStreamOrError.has_value()) {</span>
<span class="line-added">250                 RELEASE_LOG(MediaStream, &quot;UserMediaRequest::allow failed to create media stream!&quot;);</span>
<span class="line-added">251                 scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, privateStreamOrError.error());</span>
<span class="line-added">252                 deny(MediaAccessDenialReason::HardwareError);</span>
<span class="line-added">253                 return;</span>
<span class="line-added">254             }</span>
<span class="line-added">255             auto privateStream = WTFMove(privateStreamOrError).value();</span>
<span class="line-added">256 </span>
<span class="line-added">257             auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);</span>
<span class="line-added">258             privateStream-&gt;monitorOrientation(document.orientationNotifier());</span>
<span class="line-added">259 </span>
<span class="line-added">260             auto stream = MediaStream::create(document, WTFMove(privateStream));</span>
<span class="line-added">261             stream-&gt;startProducingData();</span>
<span class="line-added">262 </span>
<span class="line-added">263             if (!isMediaStreamCorrectlyStarted(stream)) {</span>
<span class="line-added">264                 deny(MediaAccessDenialReason::HardwareError);</span>
<span class="line-added">265                 return;</span>
<span class="line-added">266             }</span>
<span class="line-added">267 </span>
<span class="line-added">268             ASSERT(document.isCapturing());</span>
<span class="line-added">269             stream-&gt;document()-&gt;setHasCaptureMediaStreamTrack();</span>
<span class="line-added">270             m_promise-&gt;resolve(WTFMove(stream));</span>
<span class="line-added">271         };</span>
<span class="line-added">272 </span>
<span class="line-added">273         auto&amp; document = downcast&lt;Document&gt;(*scriptExecutionContext());</span>
<span class="line-added">274         document.setDeviceIDHashSalt(deviceIdentifierHashSalt);</span>
<span class="line-added">275 </span>
<span class="line-added">276         RealtimeMediaSourceCenter::singleton().createMediaStream(document.logger(), WTFMove(callback), WTFMove(deviceIdentifierHashSalt), WTFMove(audioDevice), WTFMove(videoDevice), m_request);</span>
277 




278         if (!m_scriptExecutionContext)
279             return;
280 

























281 #if ENABLE(WEB_RTC)
<span class="line-modified">282         if (auto* page = document.page())</span>
<span class="line-modified">283             page-&gt;rtcController().disableICECandidateFilteringForDocument(document);</span>
284 #endif
<span class="line-added">285     });</span>
286 }
287 
288 void UserMediaRequest::deny(MediaAccessDenialReason reason, const String&amp; message)
289 {
290     if (!m_scriptExecutionContext)
291         return;
292 
293     ExceptionCode code;
294     switch (reason) {
295     case MediaAccessDenialReason::IllegalConstraint:
296         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - invalid constraints&quot;);
297         code = TypeError;
298         break;
299     case MediaAccessDenialReason::NoConstraints:
300         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - no constraints&quot;);
301         code = TypeError;
302         break;
303     case MediaAccessDenialReason::UserMediaDisabled:
304         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - user media disabled&quot;);
305         code = SecurityError;
306         break;
307     case MediaAccessDenialReason::NoCaptureDevices:
308         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - no capture devices&quot;);
309         code = NotFoundError;
310         break;
311     case MediaAccessDenialReason::InvalidConstraint:
312         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - invalid constraint - %s&quot;, message.utf8().data());
<span class="line-modified">313         m_promise-&gt;rejectType&lt;IDLInterface&lt;OverconstrainedError&gt;&gt;(OverconstrainedError::create(message, &quot;Invalid constraint&quot;_s).get());</span>
314         return;
315     case MediaAccessDenialReason::HardwareError:
316         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - hardware error&quot;);
317         code = NotReadableError;
318         break;
319     case MediaAccessDenialReason::OtherFailure:
320         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - other failure&quot;);
321         code = AbortError;
322         break;
323     case MediaAccessDenialReason::PermissionDenied:
324         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - permission denied&quot;);
325         code = NotAllowedError;
326         break;
327     case MediaAccessDenialReason::InvalidAccess:
328         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - invalid access&quot;);
329         code = InvalidAccessError;
330         break;
331     }
332 
333     if (!message.isEmpty())
<span class="line-modified">334         m_promise-&gt;reject(code, message);</span>
335     else
<span class="line-modified">336         m_promise-&gt;reject(code);</span>
337 }
338 
339 void UserMediaRequest::stop()
340 {





341     auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
342     if (auto* controller = UserMediaController::from(document.page()))
343         controller-&gt;cancelUserMediaAccessRequest(*this);
344 }
345 
346 const char* UserMediaRequest::activeDOMObjectName() const
347 {
348     return &quot;UserMediaRequest&quot;;
349 }
350 





351 Document* UserMediaRequest::document() const
352 {
353     return downcast&lt;Document&gt;(m_scriptExecutionContext);
354 }
355 












































356 void UserMediaRequest::mediaStreamDidFail(RealtimeMediaSource::Type type)
357 {
358     RELEASE_LOG(MediaStream, &quot;UserMediaRequest::mediaStreamDidFail&quot;);
359     const char* typeDescription = &quot;&quot;;
360     switch (type) {
361     case RealtimeMediaSource::Type::Audio:
362         typeDescription = &quot;audio&quot;;
363         break;
364     case RealtimeMediaSource::Type::Video:
365         typeDescription = &quot;video&quot;;
366         break;
367     case RealtimeMediaSource::Type::None:
368         typeDescription = &quot;unknown&quot;;
369         break;
370     }
<span class="line-modified">371     m_promise-&gt;reject(NotReadableError, makeString(&quot;Failed starting capture of a &quot;_s, typeDescription, &quot; track&quot;_s));</span>

372 }
373 
374 } // namespace WebCore
375 
376 #endif // ENABLE(MEDIA_STREAM)
</pre>
</td>
</tr>
</table>
<center><a href="UserMediaController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="UserMediaRequest.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
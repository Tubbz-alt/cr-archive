diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/geolocation/Geolocation.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/geolocation/Geolocation.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/geolocation/Geolocation.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/geolocation/Geolocation.cpp
@@ -144,10 +144,11 @@
 }
 
 Geolocation::~Geolocation()
 {
     ASSERT(m_allowGeolocation != InProgress);
+    revokeAuthorizationTokenIfNecessary();
 }
 
 SecurityOrigin* Geolocation::securityOrigin() const
 {
     return scriptExecutionContext()->securityOrigin();
@@ -156,18 +157,13 @@
 Page* Geolocation::page() const
 {
     return document() ? document()->page() : nullptr;
 }
 
-bool Geolocation::canSuspendForDocumentSuspension() const
-{
-    return true;
-}
-
 void Geolocation::suspend(ReasonForSuspension reason)
 {
-    if (reason == ReasonForSuspension::PageCache) {
+    if (reason == ReasonForSuspension::BackForwardCache) {
         stop();
         m_resetOnResume = true;
     }
 
     // Suspend GeoNotifier timeout timers.
@@ -209,19 +205,19 @@
             watcher->startTimerIfNeeded();
     }
 
     if ((isAllowed() || isDenied()) && !m_pendingForPermissionNotifiers.isEmpty()) {
         // The pending permission was granted while the object was suspended.
-        setIsAllowed(isAllowed());
+        setIsAllowed(isAllowed(), authorizationToken());
         ASSERT(!m_hasChangedPosition);
         ASSERT(!m_errorWaitingForResume);
         return;
     }
 
     if (isDenied() && hasListeners()) {
         // The permission was revoked while the object was suspended.
-        setIsAllowed(false);
+        setIsAllowed(false, { });
         return;
     }
 
     if (m_hasChangedPosition) {
         positionChanged();
@@ -251,11 +247,11 @@
         return;
     }
 
     // 1) Reset our own state.
     stopUpdating();
-    m_allowGeolocation = Unknown;
+    resetIsAllowed();
     m_hasChangedPosition = false;
     m_errorWaitingForResume = nullptr;
 
     // 2) Request new permission for the active notifiers.
     stopTimers();
@@ -274,11 +270,11 @@
 {
     Page* page = this->page();
     if (page && m_allowGeolocation == InProgress)
         GeolocationController::from(page)->cancelPermissionRequest(*this);
     // The frame may be moving to a new page and we want to get the permissions from the new page's client.
-    m_allowGeolocation = Unknown;
+    resetIsAllowed();
     cancelAllRequests();
     stopUpdating();
     m_hasChangedPosition = false;
     m_errorWaitingForResume = nullptr;
     m_pendingForPermissionNotifiers.clear();
@@ -483,18 +479,19 @@
 
     if (!hasListeners())
         stopUpdating();
 }
 
-void Geolocation::setIsAllowed(bool allowed)
+void Geolocation::setIsAllowed(bool allowed, const String& authorizationToken)
 {
     // Protect the Geolocation object from garbage collection during a callback.
     Ref<Geolocation> protectedThis(*this);
 
     // This may be due to either a new position from the service, or a cached
     // position.
     m_allowGeolocation = allowed ? Yes : No;
+    m_authorizationToken = authorizationToken;
 
     if (m_isSuspended)
         return;
 
     // Permission request was made during the startRequest process
@@ -640,10 +637,28 @@
 
     // Ask the embedder: it maintains the geolocation challenge policy itself.
     GeolocationController::from(page)->requestPermission(*this);
 }
 
+void Geolocation::revokeAuthorizationTokenIfNecessary()
+{
+    if (m_authorizationToken.isNull())
+        return;
+
+    Page* page = this->page();
+    if (!page)
+        return;
+
+    GeolocationController::from(page)->revokeAuthorizationToken(std::exchange(m_authorizationToken, String()));
+}
+
+void Geolocation::resetIsAllowed()
+{
+    m_allowGeolocation = Unknown;
+    revokeAuthorizationTokenIfNecessary();
+}
+
 void Geolocation::makeSuccessCallbacks(GeolocationPosition& position)
 {
     ASSERT(lastPosition());
     ASSERT(isAllowed());
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;OffscreenCanvas.h&quot;
 28 
 29 #if ENABLE(OFFSCREEN_CANVAS)
 30 
 31 #include &quot;CSSValuePool.h&quot;
 32 #include &quot;CanvasRenderingContext.h&quot;
 33 #include &quot;ImageBitmap.h&quot;
 34 #include &quot;JSBlob.h&quot;
 35 #include &quot;JSDOMPromiseDeferred.h&quot;
 36 #include &quot;MIMETypeRegistry.h&quot;
 37 #include &quot;OffscreenCanvasRenderingContext2D.h&quot;
 38 #include &quot;WebGLRenderingContext.h&quot;
 39 #include &quot;WorkerGlobalScope.h&quot;
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 WTF_MAKE_ISO_ALLOCATED_IMPL(OffscreenCanvas);
 45 
 46 DetachedOffscreenCanvas::DetachedOffscreenCanvas(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer, const IntSize&amp; size, bool originClean)
 47     : m_buffer(WTFMove(buffer))
 48     , m_size(size)
 49     , m_originClean(originClean)
 50 {
 51 }
 52 
 53 std::unique_ptr&lt;ImageBuffer&gt; DetachedOffscreenCanvas::takeImageBuffer()
 54 {
 55     return WTFMove(m_buffer);
 56 }
 57 
 58 Ref&lt;OffscreenCanvas&gt; OffscreenCanvas::create(ScriptExecutionContext&amp; context, unsigned width, unsigned height)
 59 {
 60     return adoptRef(*new OffscreenCanvas(context, width, height));
 61 }
 62 
 63 Ref&lt;OffscreenCanvas&gt; OffscreenCanvas::create(ScriptExecutionContext&amp; context, std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&amp;&amp; detachedCanvas)
 64 {
 65     Ref&lt;OffscreenCanvas&gt; clone = adoptRef(*new OffscreenCanvas(context, detachedCanvas-&gt;size().width(), detachedCanvas-&gt;size().height()));
 66     clone-&gt;setImageBuffer(detachedCanvas-&gt;takeImageBuffer());
 67     if (!detachedCanvas-&gt;originClean())
 68         clone-&gt;setOriginTainted();
 69 
 70     return clone;
 71 }
 72 
 73 OffscreenCanvas::OffscreenCanvas(ScriptExecutionContext&amp; context, unsigned width, unsigned height)
 74     : CanvasBase(IntSize(width, height))
 75     , ContextDestructionObserver(&amp;context)
 76 {
 77 }
 78 
 79 OffscreenCanvas::~OffscreenCanvas()
 80 {
 81     notifyObserversCanvasDestroyed();
 82 
 83     m_context = nullptr; // Ensure this goes away before the ImageBuffer.
 84     setImageBuffer(nullptr);
 85 }
 86 
 87 unsigned OffscreenCanvas::width() const
 88 {
 89     if (m_detached)
 90         return 0;
 91     return CanvasBase::width();
 92 }
 93 
 94 unsigned OffscreenCanvas::height() const
 95 {
 96     if (m_detached)
 97         return 0;
 98     return CanvasBase::height();
 99 }
100 
101 void OffscreenCanvas::setWidth(unsigned newWidth)
102 {
103     if (m_detached)
104         return;
105     setSize(IntSize(newWidth, height()));
106 }
107 
108 void OffscreenCanvas::setHeight(unsigned newHeight)
109 {
110     if (m_detached)
111         return;
112     setSize(IntSize(width(), newHeight));
113 }
114 
115 void OffscreenCanvas::setSize(const IntSize&amp; newSize)
116 {
117     CanvasBase::setSize(newSize);
118     reset();
119 }
120 
121 ExceptionOr&lt;OffscreenRenderingContext&gt; OffscreenCanvas::getContext(JSC::JSGlobalObject&amp; state, RenderingContextType contextType, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
122 {
123     if (m_detached)
124         return Exception { InvalidStateError };
125 
126     if (contextType == RenderingContextType::_2d) {
127         if (m_context) {
128             if (!is&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context))
129                 return Exception { InvalidStateError };
130             return { RefPtr&lt;OffscreenCanvasRenderingContext2D&gt; { &amp;downcast&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context) } };
131         }
132 
133         m_context = makeUnique&lt;OffscreenCanvasRenderingContext2D&gt;(*this);
134         if (!m_context)
135             return { RefPtr&lt;OffscreenCanvasRenderingContext2D&gt; { nullptr } };
136 
137         return { RefPtr&lt;OffscreenCanvasRenderingContext2D&gt; { &amp;downcast&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context) } };
138     }
139 #if ENABLE(WEBGL)
140     if (contextType == RenderingContextType::Webgl) {
141         if (m_context) {
142             if (!is&lt;WebGLRenderingContext&gt;(*m_context))
143                 return Exception { InvalidStateError };
144             return { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };
145         }
146 
147         auto scope = DECLARE_THROW_SCOPE(state.vm());
148         auto attributes = convert&lt;IDLDictionary&lt;WebGLContextAttributes&gt;&gt;(state, !arguments.isEmpty() ? arguments[0].get() : JSC::jsUndefined());
149         RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
150 
151         m_context = WebGLRenderingContextBase::create(*this, attributes, &quot;webgl&quot;);
152         if (!m_context)
153             return { RefPtr&lt;WebGLRenderingContext&gt; { nullptr } };
154 
155         return { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };
156     }
157 #endif
158 
159     return Exception { NotSupportedError };
160 }
161 
162 ExceptionOr&lt;RefPtr&lt;ImageBitmap&gt;&gt; OffscreenCanvas::transferToImageBitmap()
163 {
164     if (m_detached || !m_context)
165         return Exception { InvalidStateError };
166 
167     if (is&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context)) {
168         if (!width() || !height())
169             return { RefPtr&lt;ImageBitmap&gt; { nullptr } };
170 
171         if (!m_hasCreatedImageBuffer)
172             return { ImageBitmap::create({ ImageBuffer::create(size(), RenderingMode::Unaccelerated), true }) };
173 
174         auto buffer = takeImageBuffer();
175         if (!buffer)
176             return { RefPtr&lt;ImageBitmap&gt; { nullptr } };
177 
178         return { ImageBitmap::create({ WTFMove(buffer), originClean() }) };
179     }
180 
181 #if ENABLE(WEBGL)
182     if (is&lt;WebGLRenderingContext&gt;(*m_context)) {
183         auto webGLContext = &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context);
184 
185         // FIXME: We&#39;re supposed to create an ImageBitmap using the backing
186         // store from this canvas (or its context), but for now we&#39;ll just
187         // create a new bitmap and paint into it.
188 
189         auto imageBitmap = ImageBitmap::create(size());
190         if (!imageBitmap-&gt;buffer())
191             return { RefPtr&lt;ImageBitmap&gt; { nullptr } };
192 
193         auto* gc3d = webGLContext-&gt;graphicsContextGL();
194         gc3d-&gt;paintRenderingResultsToCanvas(imageBitmap-&gt;buffer());
195 
196         // FIXME: The transfer algorithm requires that the canvas effectively
197         // creates a new backing store. Since we&#39;re not doing that yet, we
198         // need to erase what&#39;s there.
199 
200         GCGLfloat clearColor[4];
201         gc3d-&gt;getFloatv(GraphicsContextGL::COLOR_CLEAR_VALUE, clearColor);
202         gc3d-&gt;clearColor(0, 0, 0, 0);
203         gc3d-&gt;clear(GraphicsContextGL::COLOR_BUFFER_BIT | GraphicsContextGL::DEPTH_BUFFER_BIT | GraphicsContextGL::STENCIL_BUFFER_BIT);
204         gc3d-&gt;clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
205 
206         return { WTFMove(imageBitmap) };
207     }
208 #endif
209 
210     return Exception { NotSupportedError };
211 }
212 
213 static String toEncodingMimeType(const String&amp; mimeType)
214 {
215     if (!MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(mimeType))
216         return &quot;image/png&quot;_s;
217     return mimeType.convertToASCIILowercase();
218 }
219 
220 static Optional&lt;double&gt; qualityFromDouble(double qualityNumber)
221 {
222     if (!(qualityNumber &gt;= 0 &amp;&amp; qualityNumber &lt;= 1))
223         return WTF::nullopt;
224 
225     return qualityNumber;
226 }
227 
228 void OffscreenCanvas::convertToBlob(ImageEncodeOptions&amp;&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
229 {
230     if (!originClean()) {
231         promise-&gt;reject(SecurityError);
232         return;
233     }
234     if (size().isEmpty()) {
235         promise-&gt;reject(IndexSizeError);
236         return;
237     }
238     if (m_detached || !buffer()) {
239         promise-&gt;reject(InvalidStateError);
240         return;
241     }
242 
243     makeRenderingResultsAvailable();
244 
245     auto encodingMIMEType = toEncodingMimeType(options.type);
246     auto quality = qualityFromDouble(options.quality);
247 
248     Vector&lt;uint8_t&gt; blobData = buffer()-&gt;toData(encodingMIMEType, quality);
249     if (blobData.isEmpty()) {
250         promise-&gt;reject(EncodingError);
251         return;
252     }
253 
254     Ref&lt;Blob&gt; blob = Blob::create(WTFMove(blobData), encodingMIMEType);
255     promise-&gt;resolveWithNewlyCreated&lt;IDLInterface&lt;Blob&gt;&gt;(WTFMove(blob));
256 }
257 
258 void OffscreenCanvas::didDraw(const FloatRect&amp; rect)
259 {
260     notifyObserversCanvasChanged(rect);
261 }
262 
263 SecurityOrigin* OffscreenCanvas::securityOrigin() const
264 {
265     auto&amp; context = *canvasBaseScriptExecutionContext();
266     if (is&lt;WorkerGlobalScope&gt;(context))
267         return &amp;downcast&lt;WorkerGlobalScope&gt;(context).topOrigin();
268 
269     return &amp;downcast&lt;Document&gt;(context).securityOrigin();
270 }
271 
272 bool OffscreenCanvas::canDetach() const
273 {
274     return !m_detached &amp;&amp; !m_context;
275 }
276 
277 std::unique_ptr&lt;DetachedOffscreenCanvas&gt; OffscreenCanvas::detach()
278 {
279     if (!canDetach())
280         return nullptr;
281 
282     m_detached = true;
283 
284     return makeUnique&lt;DetachedOffscreenCanvas&gt;(takeImageBuffer(), size(), originClean());
285 }
286 
287 CSSValuePool&amp; OffscreenCanvas::cssValuePool()
288 {
289     auto* context = canvasBaseScriptExecutionContext();
290     if (context-&gt;isWorkerGlobalScope())
291         return downcast&lt;WorkerGlobalScope&gt;(*context).cssValuePool();
292 
293     ASSERT(context-&gt;isDocument());
294     return CSSValuePool::singleton();
295 }
296 
297 void OffscreenCanvas::createImageBuffer() const
298 {
299     m_hasCreatedImageBuffer = true;
300 
301     if (!width() || !height())
302         return;
303 
304     setImageBuffer(ImageBuffer::create(size(), RenderingMode::Unaccelerated));
305 }
306 
307 std::unique_ptr&lt;ImageBuffer&gt; OffscreenCanvas::takeImageBuffer() const
308 {
309     if (!m_detached)
310         m_hasCreatedImageBuffer = true;
311 
312     // This function is primarily for use with transferToImageBitmap, which
313     // requires that the canvas bitmap refer to a new, blank bitmap of the same
314     // size after the existing bitmap is taken. In the case of a zero-size
315     // bitmap, our buffer is null, so returning early here is valid.
316     if (size().isEmpty())
317         return nullptr;
318 
319     return setImageBuffer(m_detached ? nullptr : ImageBuffer::create(size(), RenderingMode::Unaccelerated));
320 }
321 
322 void OffscreenCanvas::reset()
323 {
324     resetGraphicsContextState();
325     if (is&lt;OffscreenCanvasRenderingContext2D&gt;(m_context.get()))
326         downcast&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context).reset();
327 
328     m_hasCreatedImageBuffer = false;
329     setImageBuffer(nullptr);
330 
331     notifyObserversCanvasResized();
332 }
333 
334 }
335 
336 #endif
    </pre>
  </body>
</html>
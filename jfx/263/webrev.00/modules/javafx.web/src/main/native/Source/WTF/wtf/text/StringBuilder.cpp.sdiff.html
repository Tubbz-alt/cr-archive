<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringBuffer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringBuilder.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &lt;wtf/text/StringBuilder.h&gt;
 29 
 30 #include &lt;wtf/dtoa.h&gt;
 31 #include &lt;wtf/MathExtras.h&gt;
 32 
 33 namespace WTF {
 34 
 35 static constexpr unsigned maxCapacity = String::MaxLength;
 36 
 37 static unsigned expandedCapacity(unsigned capacity, unsigned requiredLength)
 38 {
<span class="line-modified"> 39     static const unsigned minimumCapacity = 16;</span>
 40     return std::max(requiredLength, std::max(minimumCapacity, std::min(capacity * 2, maxCapacity)));
 41 }
 42 
 43 void StringBuilder::reifyString() const
 44 {
 45     ASSERT(!hasOverflowed());
 46 
 47     // Check if the string already exists.
 48     if (!m_string.isNull()) {
 49         ASSERT(m_string.length() == m_length.unsafeGet&lt;unsigned&gt;());
 50         return;
 51     }
 52 
<span class="line-modified"> 53 #if !ASSERT_DISABLED</span>
 54     m_isReified = true;
 55 #endif
 56 
 57     // Check for empty.
 58     if (!m_length) {
 59         m_string = StringImpl::empty();
 60         return;
 61     }
 62 
 63     // Must be valid in the buffer, take a substring (unless string fills the buffer).
 64     ASSERT(m_buffer &amp;&amp; m_length.unsafeGet&lt;unsigned&gt;() &lt;= m_buffer-&gt;length());
 65     if (m_length.unsafeGet&lt;unsigned&gt;() == m_buffer-&gt;length())
 66         m_string = m_buffer.get();
 67     else
 68         m_string = StringImpl::createSubstringSharingImpl(*m_buffer, 0, m_length.unsafeGet());
 69 }
 70 
 71 void StringBuilder::resize(unsigned newSize)
 72 {
 73     if (hasOverflowed())
</pre>
<hr />
<pre>
405 void StringBuilder::appendNumber(long number)
406 {
407     numberToStringSigned&lt;StringBuilder&gt;(number, this);
408 }
409 
410 void StringBuilder::appendNumber(unsigned long number)
411 {
412     numberToStringUnsigned&lt;StringBuilder&gt;(number, this);
413 }
414 
415 void StringBuilder::appendNumber(long long number)
416 {
417     numberToStringSigned&lt;StringBuilder&gt;(number, this);
418 }
419 
420 void StringBuilder::appendNumber(unsigned long long number)
421 {
422     numberToStringUnsigned&lt;StringBuilder&gt;(number, this);
423 }
424 
<span class="line-removed">425 void StringBuilder::appendFixedPrecisionNumber(float number, unsigned precision, TrailingZerosTruncatingPolicy policy)</span>
<span class="line-removed">426 {</span>
<span class="line-removed">427     NumberToStringBuffer buffer;</span>
<span class="line-removed">428     append(numberToFixedPrecisionString(number, precision, buffer, policy == TruncateTrailingZeros));</span>
<span class="line-removed">429 }</span>
<span class="line-removed">430 </span>
<span class="line-removed">431 void StringBuilder::appendFixedPrecisionNumber(double number, unsigned precision, TrailingZerosTruncatingPolicy policy)</span>
<span class="line-removed">432 {</span>
<span class="line-removed">433     NumberToStringBuffer buffer;</span>
<span class="line-removed">434     append(numberToFixedPrecisionString(number, precision, buffer, policy == TruncateTrailingZeros));</span>
<span class="line-removed">435 }</span>
<span class="line-removed">436 </span>
437 void StringBuilder::appendNumber(float number)
438 {
439     NumberToStringBuffer buffer;
440     append(numberToString(number, buffer));
441 }
442 
443 void StringBuilder::appendNumber(double number)
444 {
445     NumberToStringBuffer buffer;
446     append(numberToString(number, buffer));
447 }
448 
<span class="line-removed">449 void StringBuilder::appendFixedWidthNumber(float number, unsigned decimalPlaces)</span>
<span class="line-removed">450 {</span>
<span class="line-removed">451     NumberToStringBuffer buffer;</span>
<span class="line-removed">452     append(numberToFixedWidthString(number, decimalPlaces, buffer));</span>
<span class="line-removed">453 }</span>
<span class="line-removed">454 </span>
<span class="line-removed">455 void StringBuilder::appendFixedWidthNumber(double number, unsigned decimalPlaces)</span>
<span class="line-removed">456 {</span>
<span class="line-removed">457     NumberToStringBuffer buffer;</span>
<span class="line-removed">458     append(numberToFixedWidthString(number, decimalPlaces, buffer));</span>
<span class="line-removed">459 }</span>
<span class="line-removed">460 </span>
461 bool StringBuilder::canShrink() const
462 {
463     if (hasOverflowed())
464         return false;
465     // Only shrink the buffer if it&#39;s less than 80% full.
466     // FIXME: We should tune this heuristic based some actual test case measurements.
467     unsigned length = m_length.unsafeGet();
468     return m_buffer &amp;&amp; m_buffer-&gt;length() &gt; (length + (length &gt;&gt; 2));
469 }
470 
471 void StringBuilder::shrinkToFit()
472 {
473     if (canShrink()) {
474         if (m_is8Bit)
475             reallocateBuffer&lt;LChar&gt;(m_length.unsafeGet());
476         else
477             reallocateBuffer&lt;UChar&gt;(m_length.unsafeGet());
478         ASSERT(!hasOverflowed());
479         m_string = WTFMove(m_buffer);
480     }
</pre>
</td>
<td>
<hr />
<pre>
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &lt;wtf/text/StringBuilder.h&gt;
 29 
 30 #include &lt;wtf/dtoa.h&gt;
 31 #include &lt;wtf/MathExtras.h&gt;
 32 
 33 namespace WTF {
 34 
 35 static constexpr unsigned maxCapacity = String::MaxLength;
 36 
 37 static unsigned expandedCapacity(unsigned capacity, unsigned requiredLength)
 38 {
<span class="line-modified"> 39     static constexpr unsigned minimumCapacity = 16;</span>
 40     return std::max(requiredLength, std::max(minimumCapacity, std::min(capacity * 2, maxCapacity)));
 41 }
 42 
 43 void StringBuilder::reifyString() const
 44 {
 45     ASSERT(!hasOverflowed());
 46 
 47     // Check if the string already exists.
 48     if (!m_string.isNull()) {
 49         ASSERT(m_string.length() == m_length.unsafeGet&lt;unsigned&gt;());
 50         return;
 51     }
 52 
<span class="line-modified"> 53 #if ASSERT_ENABLED</span>
 54     m_isReified = true;
 55 #endif
 56 
 57     // Check for empty.
 58     if (!m_length) {
 59         m_string = StringImpl::empty();
 60         return;
 61     }
 62 
 63     // Must be valid in the buffer, take a substring (unless string fills the buffer).
 64     ASSERT(m_buffer &amp;&amp; m_length.unsafeGet&lt;unsigned&gt;() &lt;= m_buffer-&gt;length());
 65     if (m_length.unsafeGet&lt;unsigned&gt;() == m_buffer-&gt;length())
 66         m_string = m_buffer.get();
 67     else
 68         m_string = StringImpl::createSubstringSharingImpl(*m_buffer, 0, m_length.unsafeGet());
 69 }
 70 
 71 void StringBuilder::resize(unsigned newSize)
 72 {
 73     if (hasOverflowed())
</pre>
<hr />
<pre>
405 void StringBuilder::appendNumber(long number)
406 {
407     numberToStringSigned&lt;StringBuilder&gt;(number, this);
408 }
409 
410 void StringBuilder::appendNumber(unsigned long number)
411 {
412     numberToStringUnsigned&lt;StringBuilder&gt;(number, this);
413 }
414 
415 void StringBuilder::appendNumber(long long number)
416 {
417     numberToStringSigned&lt;StringBuilder&gt;(number, this);
418 }
419 
420 void StringBuilder::appendNumber(unsigned long long number)
421 {
422     numberToStringUnsigned&lt;StringBuilder&gt;(number, this);
423 }
424 












425 void StringBuilder::appendNumber(float number)
426 {
427     NumberToStringBuffer buffer;
428     append(numberToString(number, buffer));
429 }
430 
431 void StringBuilder::appendNumber(double number)
432 {
433     NumberToStringBuffer buffer;
434     append(numberToString(number, buffer));
435 }
436 












437 bool StringBuilder::canShrink() const
438 {
439     if (hasOverflowed())
440         return false;
441     // Only shrink the buffer if it&#39;s less than 80% full.
442     // FIXME: We should tune this heuristic based some actual test case measurements.
443     unsigned length = m_length.unsafeGet();
444     return m_buffer &amp;&amp; m_buffer-&gt;length() &gt; (length + (length &gt;&gt; 2));
445 }
446 
447 void StringBuilder::shrinkToFit()
448 {
449     if (canShrink()) {
450         if (m_is8Bit)
451             reallocateBuffer&lt;LChar&gt;(m_length.unsafeGet());
452         else
453             reallocateBuffer&lt;UChar&gt;(m_length.unsafeGet());
454         ASSERT(!hasOverflowed());
455         m_string = WTFMove(m_buffer);
456     }
</pre>
</td>
</tr>
</table>
<center><a href="StringBuffer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringBuilder.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
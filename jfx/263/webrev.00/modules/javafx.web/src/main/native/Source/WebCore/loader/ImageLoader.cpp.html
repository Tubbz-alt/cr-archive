<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/ImageLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;ImageLoader.h&quot;
 24 
 25 #include &quot;BitmapImage.h&quot;
 26 #include &quot;CachedImage.h&quot;
 27 #include &quot;CachedResourceLoader.h&quot;
 28 #include &quot;CachedResourceRequest.h&quot;
 29 #include &quot;CrossOriginAccessControl.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;Element.h&quot;
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;EventSender.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;FrameLoader.h&quot;
 37 #include &quot;HTMLNames.h&quot;
 38 #include &quot;HTMLObjectElement.h&quot;
 39 #include &quot;HTMLParserIdioms.h&quot;
 40 #include &quot;InspectorInstrumentation.h&quot;
 41 #include &quot;JSDOMPromiseDeferred.h&quot;
 42 #include &quot;Page.h&quot;
 43 #include &quot;RenderImage.h&quot;
 44 #include &quot;RenderSVGImage.h&quot;
 45 #include &lt;wtf/NeverDestroyed.h&gt;
 46 
 47 #if ENABLE(VIDEO)
 48 #include &quot;RenderVideo.h&quot;
 49 #endif
 50 
 51 #if ASSERT_ENABLED
 52 // ImageLoader objects are allocated as members of other objects, so generic pointer check would always fail.
 53 namespace WTF {
 54 
 55 template&lt;&gt; struct ValueCheck&lt;WebCore::ImageLoader*&gt; {
 56     typedef WebCore::ImageLoader* TraitType;
 57     static void checkConsistency(const WebCore::ImageLoader* p)
 58     {
 59         if (!p)
 60             return;
 61         ValueCheck&lt;WebCore::Element*&gt;::checkConsistency(&amp;p-&gt;element());
 62     }
 63 };
 64 
 65 } // namespace WTF
 66 #endif // ASSERT_ENABLED
 67 
 68 namespace WebCore {
 69 
 70 static ImageEventSender&amp; beforeLoadEventSender()
 71 {
 72     static NeverDestroyed&lt;ImageEventSender&gt; sender(eventNames().beforeloadEvent);
 73     return sender;
 74 }
 75 
 76 static ImageEventSender&amp; loadEventSender()
 77 {
 78     static NeverDestroyed&lt;ImageEventSender&gt; sender(eventNames().loadEvent);
 79     return sender;
 80 }
 81 
 82 static ImageEventSender&amp; errorEventSender()
 83 {
 84     static NeverDestroyed&lt;ImageEventSender&gt; sender(eventNames().errorEvent);
 85     return sender;
 86 }
 87 
 88 static inline bool pageIsBeingDismissed(Document&amp; document)
 89 {
 90     Frame* frame = document.frame();
 91     return frame &amp;&amp; frame-&gt;loader().pageDismissalEventBeingDispatched() != FrameLoader::PageDismissalType::None;
 92 }
 93 
 94 ImageLoader::ImageLoader(Element&amp; element)
 95     : m_element(element)
 96     , m_image(nullptr)
 97     , m_derefElementTimer(*this, &amp;ImageLoader::timerFired)
 98     , m_hasPendingBeforeLoadEvent(false)
 99     , m_hasPendingLoadEvent(false)
100     , m_hasPendingErrorEvent(false)
101     , m_imageComplete(true)
102     , m_loadManually(false)
103     , m_elementIsProtected(false)
104 {
105 }
106 
107 ImageLoader::~ImageLoader()
108 {
109     if (m_image)
110         m_image-&gt;removeClient(*this);
111 
112     ASSERT(m_hasPendingBeforeLoadEvent || !beforeLoadEventSender().hasPendingEvents(*this));
113     if (m_hasPendingBeforeLoadEvent)
114         beforeLoadEventSender().cancelEvent(*this);
115 
116     ASSERT(m_hasPendingLoadEvent || !loadEventSender().hasPendingEvents(*this));
117     if (m_hasPendingLoadEvent)
118         loadEventSender().cancelEvent(*this);
119 
120     ASSERT(m_hasPendingErrorEvent || !errorEventSender().hasPendingEvents(*this));
121     if (m_hasPendingErrorEvent)
122         errorEventSender().cancelEvent(*this);
123 }
124 
125 void ImageLoader::clearImage()
126 {
127     clearImageWithoutConsideringPendingLoadEvent();
128 
129     // Only consider updating the protection ref-count of the Element immediately before returning
130     // from this function as doing so might result in the destruction of this ImageLoader.
131     updatedHasPendingEvent();
132 }
133 
134 void ImageLoader::clearImageWithoutConsideringPendingLoadEvent()
135 {
136     ASSERT(m_failedLoadURL.isEmpty());
137     CachedImage* oldImage = m_image.get();
138     if (oldImage) {
139         m_image = nullptr;
140         if (m_hasPendingBeforeLoadEvent) {
141             beforeLoadEventSender().cancelEvent(*this);
142             m_hasPendingBeforeLoadEvent = false;
143         }
144         if (m_hasPendingLoadEvent) {
145             loadEventSender().cancelEvent(*this);
146             m_hasPendingLoadEvent = false;
147         }
148         if (m_hasPendingErrorEvent) {
149             errorEventSender().cancelEvent(*this);
150             m_hasPendingErrorEvent = false;
151         }
152         m_imageComplete = true;
153         if (oldImage)
154             oldImage-&gt;removeClient(*this);
155     }
156 
157     if (RenderImageResource* imageResource = renderImageResource())
158         imageResource-&gt;resetAnimation();
159 }
160 
161 void ImageLoader::updateFromElement()
162 {
163     // If we&#39;re not making renderers for the page, then don&#39;t load images. We don&#39;t want to slow
164     // down the raw HTML parsing case by loading images we don&#39;t intend to display.
165     Document&amp; document = element().document();
166     if (!document.hasLivingRenderTree())
167         return;
168 
169     AtomString attr = element().imageSourceURL();
170 
171     // Avoid loading a URL we already failed to load.
172     if (!m_failedLoadURL.isEmpty() &amp;&amp; attr == m_failedLoadURL)
173         return;
174 
175     // Do not load any image if the &#39;src&#39; attribute is missing or if it is
176     // an empty string.
177     CachedResourceHandle&lt;CachedImage&gt; newImage = nullptr;
178     if (!attr.isNull() &amp;&amp; !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
179         ResourceLoaderOptions options = CachedResourceLoader::defaultCachedResourceOptions();
180         options.contentSecurityPolicyImposition = element().isInUserAgentShadowTree() ? ContentSecurityPolicyImposition::SkipPolicyCheck : ContentSecurityPolicyImposition::DoPolicyCheck;
181         options.sameOriginDataURLFlag = SameOriginDataURLFlag::Set;
182 
183         auto crossOriginAttribute = element().attributeWithoutSynchronization(HTMLNames::crossoriginAttr);
184 
185         ResourceRequest resourceRequest(document.completeURL(sourceURI(attr)));
186         resourceRequest.setInspectorInitiatorNodeIdentifier(InspectorInstrumentation::identifierForNode(m_element));
187 
188         auto request = createPotentialAccessControlRequest(WTFMove(resourceRequest), WTFMove(options), document, crossOriginAttribute);
189         request.setInitiator(element());
190 
191         if (m_loadManually) {
192             bool autoLoadOtherImages = document.cachedResourceLoader().autoLoadImages();
193             document.cachedResourceLoader().setAutoLoadImages(false);
194             auto* page = m_element.document().page();
195             newImage = new CachedImage(WTFMove(request), page-&gt;sessionID(), &amp;page-&gt;cookieJar());
196             newImage-&gt;setStatus(CachedResource::Pending);
197             newImage-&gt;setLoading(true);
198             document.cachedResourceLoader().m_documentResources.set(newImage-&gt;url(), newImage.get());
199             document.cachedResourceLoader().setAutoLoadImages(autoLoadOtherImages);
200         } else
201             newImage = document.cachedResourceLoader().requestImage(WTFMove(request)).value_or(nullptr);
202 
203         // If we do not have an image here, it means that a cross-site
204         // violation occurred, or that the image was blocked via Content
205         // Security Policy, or the page is being dismissed. Trigger an
206         // error event if the page is not being dismissed.
207         if (!newImage &amp;&amp; !pageIsBeingDismissed(document)) {
208             m_failedLoadURL = attr;
209             m_hasPendingErrorEvent = true;
210             errorEventSender().dispatchEventSoon(*this);
211         } else
212             clearFailedLoadURL();
213     } else if (!attr.isNull()) {
214         // Fire an error event if the url is empty.
215         m_failedLoadURL = attr;
216         m_hasPendingErrorEvent = true;
217         errorEventSender().dispatchEventSoon(*this);
218     }
219 
220     CachedImage* oldImage = m_image.get();
221     if (newImage != oldImage) {
222         if (m_hasPendingBeforeLoadEvent) {
223             beforeLoadEventSender().cancelEvent(*this);
224             m_hasPendingBeforeLoadEvent = false;
225         }
226         if (m_hasPendingLoadEvent) {
227             loadEventSender().cancelEvent(*this);
228             m_hasPendingLoadEvent = false;
229         }
230 
231         // Cancel error events that belong to the previous load, which is now cancelled by changing the src attribute.
232         // If newImage is null and m_hasPendingErrorEvent is true, we know the error event has been just posted by
233         // this load and we should not cancel the event.
234         // FIXME: If both previous load and this one got blocked with an error, we can receive one error event instead of two.
235         if (m_hasPendingErrorEvent &amp;&amp; newImage) {
236             errorEventSender().cancelEvent(*this);
237             m_hasPendingErrorEvent = false;
238         }
239 
240         m_image = newImage;
241         m_hasPendingBeforeLoadEvent = !document.isImageDocument() &amp;&amp; newImage;
242         m_hasPendingLoadEvent = newImage;
243         m_imageComplete = !newImage;
244 
245         if (newImage) {
246             if (!document.isImageDocument()) {
247                 if (!document.hasListenerType(Document::BEFORELOAD_LISTENER))
248                     dispatchPendingBeforeLoadEvent();
249                 else
250                     beforeLoadEventSender().dispatchEventSoon(*this);
251             } else
252                 updateRenderer();
253 
254             // If newImage is cached, addClient() will result in the load event
255             // being queued to fire. Ensure this happens after beforeload is
256             // dispatched.
257             newImage-&gt;addClient(*this);
258         }
259         if (oldImage) {
260             oldImage-&gt;removeClient(*this);
261             updateRenderer();
262         }
263     }
264 
265     if (RenderImageResource* imageResource = renderImageResource())
266         imageResource-&gt;resetAnimation();
267 
268     // Only consider updating the protection ref-count of the Element immediately before returning
269     // from this function as doing so might result in the destruction of this ImageLoader.
270     updatedHasPendingEvent();
271 }
272 
273 void ImageLoader::updateFromElementIgnoringPreviousError()
274 {
275     clearFailedLoadURL();
276     updateFromElement();
277 }
278 
279 static inline void resolvePromises(Vector&lt;RefPtr&lt;DeferredPromise&gt;&gt;&amp; promises)
280 {
281     ASSERT(!promises.isEmpty());
282     auto promisesToBeResolved = std::exchange(promises, { });
283     for (auto&amp; promise : promisesToBeResolved)
284         promise-&gt;resolve();
285 }
286 
287 static inline void rejectPromises(Vector&lt;RefPtr&lt;DeferredPromise&gt;&gt;&amp; promises, const char* message)
288 {
289     ASSERT(!promises.isEmpty());
290     auto promisesToBeRejected = std::exchange(promises, { });
291     for (auto&amp; promise : promisesToBeRejected)
292         promise-&gt;reject(Exception { EncodingError, message });
293 }
294 
295 inline void ImageLoader::resolveDecodePromises()
296 {
297     resolvePromises(m_decodingPromises);
298 }
299 
300 inline void ImageLoader::rejectDecodePromises(const char* message)
301 {
302     rejectPromises(m_decodingPromises, message);
303 }
304 
305 void ImageLoader::notifyFinished(CachedResource&amp; resource)
306 {
307     ASSERT(m_failedLoadURL.isEmpty());
308     ASSERT_UNUSED(resource, &amp;resource == m_image.get());
309 
310     m_imageComplete = true;
311     if (!hasPendingBeforeLoadEvent())
312         updateRenderer();
313 
314     if (!m_hasPendingLoadEvent)
315         return;
316 
317     if (m_image-&gt;resourceError().isAccessControl()) {
318         URL imageURL = m_image-&gt;url();
319 
320         clearImageWithoutConsideringPendingLoadEvent();
321 
322         m_hasPendingErrorEvent = true;
323         errorEventSender().dispatchEventSoon(*this);
324 
325         auto message = makeString(&quot;Cannot load image &quot;, imageURL.string(), &quot; due to access control checks.&quot;);
326         element().document().addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
327 
328         if (hasPendingDecodePromises())
329             rejectDecodePromises(&quot;Access control error.&quot;);
330 
331         ASSERT(!m_hasPendingLoadEvent);
332 
333         // Only consider updating the protection ref-count of the Element immediately before returning
334         // from this function as doing so might result in the destruction of this ImageLoader.
335         updatedHasPendingEvent();
336         return;
337     }
338 
339     if (m_image-&gt;wasCanceled()) {
340         if (hasPendingDecodePromises())
341             rejectDecodePromises(&quot;Loading was canceled.&quot;);
342         m_hasPendingLoadEvent = false;
343         // Only consider updating the protection ref-count of the Element immediately before returning
344         // from this function as doing so might result in the destruction of this ImageLoader.
345         updatedHasPendingEvent();
346         return;
347     }
348 
349     if (hasPendingDecodePromises())
350         decode();
351     loadEventSender().dispatchEventSoon(*this);
352 }
353 
354 RenderImageResource* ImageLoader::renderImageResource()
355 {
356     auto* renderer = element().renderer();
357     if (!renderer)
358         return nullptr;
359 
360     // We don&#39;t return style generated image because it doesn&#39;t belong to the ImageLoader.
361     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=42840&gt;
362     if (is&lt;RenderImage&gt;(*renderer) &amp;&amp; !downcast&lt;RenderImage&gt;(*renderer).isGeneratedContent())
363         return &amp;downcast&lt;RenderImage&gt;(*renderer).imageResource();
364 
365     if (is&lt;RenderSVGImage&gt;(*renderer))
366         return &amp;downcast&lt;RenderSVGImage&gt;(*renderer).imageResource();
367 
368 #if ENABLE(VIDEO)
369     if (is&lt;RenderVideo&gt;(*renderer))
370         return &amp;downcast&lt;RenderVideo&gt;(*renderer).imageResource();
371 #endif
372 
373     return nullptr;
374 }
375 
376 void ImageLoader::updateRenderer()
377 {
378     RenderImageResource* imageResource = renderImageResource();
379 
380     if (!imageResource)
381         return;
382 
383     // Only update the renderer if it doesn&#39;t have an image or if what we have
384     // is a complete image. This prevents flickering in the case where a dynamic
385     // change is happening between two images.
386     CachedImage* cachedImage = imageResource-&gt;cachedImage();
387     if (m_image != cachedImage &amp;&amp; (m_imageComplete || !cachedImage))
388         imageResource-&gt;setCachedImage(m_image.get());
389 }
390 
391 void ImageLoader::updatedHasPendingEvent()
392 {
393     // If an Element that does image loading is removed from the DOM the load/error event for the image is still observable.
394     // As long as the ImageLoader is actively loading, the Element itself needs to be ref&#39;ed to keep it from being
395     // destroyed by DOM manipulation or garbage collection.
396     // If such an Element wishes for the load to stop when removed from the DOM it needs to stop the ImageLoader explicitly.
397     bool wasProtected = m_elementIsProtected;
398     m_elementIsProtected = m_hasPendingLoadEvent || m_hasPendingErrorEvent;
399     if (wasProtected == m_elementIsProtected)
400         return;
401 
402     if (m_elementIsProtected) {
403         if (m_derefElementTimer.isActive())
404             m_derefElementTimer.stop();
405         else
406             m_protectedElement = &amp;element();
407     } else {
408         ASSERT(!m_derefElementTimer.isActive());
409         m_derefElementTimer.startOneShot(0_s);
410     }
411 }
412 
413 void ImageLoader::decode(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
414 {
415     m_decodingPromises.append(WTFMove(promise));
416 
417     if (!element().document().domWindow()) {
418         rejectDecodePromises(&quot;Inactive document.&quot;);
419         return;
420     }
421 
422     AtomString attr = element().imageSourceURL();
423     if (stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
424         rejectDecodePromises(&quot;Missing source URL.&quot;);
425         return;
426     }
427 
428     if (m_imageComplete)
429         decode();
430 }
431 
432 void ImageLoader::decode()
433 {
434     ASSERT(hasPendingDecodePromises());
435 
436     if (!element().document().domWindow()) {
437         rejectDecodePromises(&quot;Inactive document.&quot;);
438         return;
439     }
440 
441     if (!m_image || !m_image-&gt;image() || m_image-&gt;errorOccurred()) {
442         rejectDecodePromises(&quot;Loading error.&quot;);
443         return;
444     }
445 
446     Image* image = m_image-&gt;image();
447     if (!is&lt;BitmapImage&gt;(image)) {
448         resolveDecodePromises();
449         return;
450     }
451 
452     auto&amp; bitmapImage = downcast&lt;BitmapImage&gt;(*image);
453     bitmapImage.decode([promises = WTFMove(m_decodingPromises)]() mutable {
454         resolvePromises(promises);
455     });
456 }
457 
458 void ImageLoader::timerFired()
459 {
460     m_protectedElement = nullptr;
461 }
462 
463 void ImageLoader::dispatchPendingEvent(ImageEventSender* eventSender)
464 {
465     ASSERT(eventSender == &amp;beforeLoadEventSender() || eventSender == &amp;loadEventSender() || eventSender == &amp;errorEventSender());
466     const AtomString&amp; eventType = eventSender-&gt;eventType();
467     if (eventType == eventNames().beforeloadEvent)
468         dispatchPendingBeforeLoadEvent();
469     if (eventType == eventNames().loadEvent)
470         dispatchPendingLoadEvent();
471     if (eventType == eventNames().errorEvent)
472         dispatchPendingErrorEvent();
473 }
474 
475 void ImageLoader::dispatchPendingBeforeLoadEvent()
476 {
477     if (!m_hasPendingBeforeLoadEvent)
478         return;
479     if (!m_image)
480         return;
481     if (!element().document().hasLivingRenderTree())
482         return;
483     m_hasPendingBeforeLoadEvent = false;
484     Ref&lt;Document&gt; originalDocument = element().document();
485     if (element().dispatchBeforeLoadEvent(m_image-&gt;url())) {
486         bool didEventListenerDisconnectThisElement = !element().isConnected() || &amp;element().document() != originalDocument.ptr();
487         if (didEventListenerDisconnectThisElement)
488             return;
489 
490         updateRenderer();
491         return;
492     }
493     if (m_image) {
494         m_image-&gt;removeClient(*this);
495         m_image = nullptr;
496     }
497 
498     loadEventSender().cancelEvent(*this);
499     m_hasPendingLoadEvent = false;
500 
501     if (is&lt;HTMLObjectElement&gt;(element()))
502         downcast&lt;HTMLObjectElement&gt;(element()).renderFallbackContent();
503 
504     // Only consider updating the protection ref-count of the Element immediately before returning
505     // from this function as doing so might result in the destruction of this ImageLoader.
506     updatedHasPendingEvent();
507 }
508 
509 void ImageLoader::dispatchPendingLoadEvent()
510 {
511     if (!m_hasPendingLoadEvent)
512         return;
513     if (!m_image)
514         return;
515     m_hasPendingLoadEvent = false;
516     if (element().document().hasLivingRenderTree())
517         dispatchLoadEvent();
518 
519     // Only consider updating the protection ref-count of the Element immediately before returning
520     // from this function as doing so might result in the destruction of this ImageLoader.
521     updatedHasPendingEvent();
522 }
523 
524 void ImageLoader::dispatchPendingErrorEvent()
525 {
526     if (!m_hasPendingErrorEvent)
527         return;
528     m_hasPendingErrorEvent = false;
529     if (element().document().hasLivingRenderTree())
530         element().dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
531 
532     // Only consider updating the protection ref-count of the Element immediately before returning
533     // from this function as doing so might result in the destruction of this ImageLoader.
534     updatedHasPendingEvent();
535 }
536 
537 void ImageLoader::dispatchPendingBeforeLoadEvents()
538 {
539     beforeLoadEventSender().dispatchPendingEvents();
540 }
541 
542 void ImageLoader::dispatchPendingLoadEvents()
543 {
544     loadEventSender().dispatchPendingEvents();
545 }
546 
547 void ImageLoader::dispatchPendingErrorEvents()
548 {
549     errorEventSender().dispatchPendingEvents();
550 }
551 
552 void ImageLoader::elementDidMoveToNewDocument()
553 {
554     clearFailedLoadURL();
555     clearImage();
556 }
557 
558 inline void ImageLoader::clearFailedLoadURL()
559 {
560     m_failedLoadURL = nullAtom();
561 }
562 
563 }
    </pre>
  </body>
</html>
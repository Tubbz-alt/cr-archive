diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOSRExitCompiler.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOSRExitCompiler.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOSRExitCompiler.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOSRExitCompiler.cpp
@@ -26,23 +26,25 @@
 #include "config.h"
 #include "FTLOSRExitCompiler.h"
 
 #if ENABLE(FTL_JIT)
 
+#include "BytecodeStructs.h"
+#include "CheckpointOSRExitSideState.h"
 #include "DFGOSRExitCompilerCommon.h"
-#include "DFGOSRExitPreparation.h"
 #include "FTLExitArgumentForOperand.h"
 #include "FTLJITCode.h"
 #include "FTLLocation.h"
 #include "FTLOSRExit.h"
 #include "FTLOperations.h"
 #include "FTLState.h"
 #include "FTLSaveRestore.h"
+#include "JSCInlines.h"
 #include "LinkBuffer.h"
 #include "MaxFrameExtentForSlowPathCall.h"
 #include "OperandsInlines.h"
-#include "JSCInlines.h"
+#include "ProbeContext.h"
 
 namespace JSC { namespace FTL {
 
 using namespace DFG;
 
@@ -50,11 +52,11 @@
     DataFormat format, AssemblyHelpers& jit, GPRReg value, GPRReg scratch1, GPRReg scratch2)
 {
     switch (format) {
     case DataFormatInt32: {
         jit.zeroExtend32ToPtr(value, value);
-        jit.or64(GPRInfo::tagTypeNumberRegister, value);
+        jit.or64(GPRInfo::numberTagRegister, value);
         break;
     }
 
     case DataFormatInt52: {
         jit.rshift64(AssemblyHelpers::TrustedImm32(JSValue::int52ShiftAmount), value);
@@ -71,11 +73,11 @@
         break;
     }
 
     case DataFormatBoolean: {
         jit.zeroExtend32ToPtr(value, value);
-        jit.or32(MacroAssembler::TrustedImm32(ValueFalse), value);
+        jit.or32(MacroAssembler::TrustedImm32(JSValue::ValueFalse), value);
         break;
     }
 
     case DataFormatJS: {
         // Done already!
@@ -135,23 +137,22 @@
 
     reboxAccordingToFormat(
         value.dataFormat(), jit, GPRInfo::regT0, GPRInfo::regT1, GPRInfo::regT2);
 }
 
-static void compileStub(
-    unsigned exitID, JITCode* jitCode, OSRExit& exit, VM* vm, CodeBlock* codeBlock)
+static void compileStub(VM& vm, unsigned exitID, JITCode* jitCode, OSRExit& exit, CodeBlock* codeBlock)
 {
     // This code requires framePointerRegister is the same as callFrameRegister
     static_assert(MacroAssembler::framePointerRegister == GPRInfo::callFrameRegister, "MacroAssembler::framePointerRegister and GPRInfo::callFrameRegister must be the same");
 
     CCallHelpers jit(codeBlock);
 
     // The first thing we need to do is restablish our frame in the case of an exception.
     if (exit.isGenericUnwindHandler()) {
-        RELEASE_ASSERT(vm->callFrameForCatch); // The first time we hit this exit, like at all other times, this field should be non-null.
-        jit.restoreCalleeSavesFromEntryFrameCalleeSavesBuffer(vm->topEntryFrame);
-        jit.loadPtr(vm->addressOfCallFrameForCatch(), MacroAssembler::framePointerRegister);
+        RELEASE_ASSERT(vm.callFrameForCatch); // The first time we hit this exit, like at all other times, this field should be non-null.
+        jit.restoreCalleeSavesFromEntryFrameCalleeSavesBuffer(vm.topEntryFrame);
+        jit.loadPtr(vm.addressOfCallFrameForCatch(), MacroAssembler::framePointerRegister);
         jit.addPtr(CCallHelpers::TrustedImm32(codeBlock->stackPointerOffset() * sizeof(Register)),
             MacroAssembler::framePointerRegister, CCallHelpers::stackPointerRegister);
 
         // Do a pushToSave because that's what the exit compiler below expects the stack
         // to look like because that's the last thing the ExitThunkGenerator does. The code
@@ -173,11 +174,11 @@
         maxMaterializationNumArguments = std::max(
             maxMaterializationNumArguments,
             materialization->properties().size());
     }
 
-    ScratchBuffer* scratchBuffer = vm->scratchBufferForSize(
+    ScratchBuffer* scratchBuffer = vm.scratchBufferForSize(
         sizeof(EncodedJSValue) * (
             exit.m_descriptor->m_values.size() + numMaterializations + maxMaterializationNumArguments) +
         requiredScratchMemorySizeInBytes() +
         codeBlock->calleeSaveRegisters()->size() * sizeof(uint64_t));
     EncodedJSValue* scratch = scratchBuffer ? static_cast<EncodedJSValue*>(scratchBuffer->dataBuffer()) : 0;
@@ -213,19 +214,19 @@
 
         // Even though we set Heap::m_expectDoesGC in compileFTLOSRExit(), we also need
         // to set it here because compileFTLOSRExit() is only called on the first time
         // we exit from this site, but all subsequent exits will take this compiled
         // ramp without calling compileFTLOSRExit() first.
-        jit.store8(CCallHelpers::TrustedImm32(true), vm->heap.addressOfExpectDoesGC());
+        jit.store8(CCallHelpers::TrustedImm32(true), vm.heap.addressOfExpectDoesGC());
     }
 
     // Bring the stack back into a sane form and assert that it's sane.
     jit.popToRestore(GPRInfo::regT0);
     jit.checkStackPointerAlignment();
 
-    if (UNLIKELY(vm->m_perBytecodeProfiler && jitCode->dfgCommon()->compilation)) {
-        Profiler::Database& database = *vm->m_perBytecodeProfiler;
+    if (UNLIKELY(vm.m_perBytecodeProfiler && jitCode->dfgCommon()->compilation)) {
+        Profiler::Database& database = *vm.m_perBytecodeProfiler;
         Profiler::Compilation* compilation = jitCode->dfgCommon()->compilation.get();
 
         Profiler::OSRExit* profilerExit = compilation->addOSRExit(
             exitID, Profiler::OriginStack(database, codeBlock, exit.m_codeOrigin),
             exit.m_kind, exit.m_kind == UncountableInvalidation);
@@ -235,22 +236,30 @@
     // The remaining code assumes that SP/FP are in the same state that they were in the FTL's
     // call frame.
 
     // Get the call frame and tag thingies.
     // Restore the exiting function's callFrame value into a regT4
-    jit.move(MacroAssembler::TrustedImm64(TagTypeNumber), GPRInfo::tagTypeNumberRegister);
-    jit.move(MacroAssembler::TrustedImm64(TagMask), GPRInfo::tagMaskRegister);
+    jit.move(MacroAssembler::TrustedImm64(JSValue::NumberTag), GPRInfo::numberTagRegister);
+    jit.move(MacroAssembler::TrustedImm64(JSValue::NotCellMask), GPRInfo::notCellMaskRegister);
 
     // Do some value profiling.
     if (exit.m_descriptor->m_profileDataFormat != DataFormatNone) {
         Location::forValueRep(exit.m_valueReps[0]).restoreInto(jit, registerScratch, GPRInfo::regT0);
         reboxAccordingToFormat(
             exit.m_descriptor->m_profileDataFormat, jit, GPRInfo::regT0, GPRInfo::regT1, GPRInfo::regT2);
 
         if (exit.m_kind == BadCache || exit.m_kind == BadIndexingType) {
             CodeOrigin codeOrigin = exit.m_codeOriginForExitProfile;
-            if (ArrayProfile* arrayProfile = jit.baselineCodeBlockFor(codeOrigin)->getArrayProfile(codeOrigin.bytecodeIndex())) {
+            CodeBlock* codeBlock = jit.baselineCodeBlockFor(codeOrigin);
+            if (ArrayProfile* arrayProfile = codeBlock->getArrayProfile(codeOrigin.bytecodeIndex())) {
+                const Instruction* instruction = codeBlock->instructions().at(codeOrigin.bytecodeIndex()).ptr();
+                CCallHelpers::Jump skipProfile;
+                if (instruction->is<OpGetById>()) {
+                    auto& metadata = instruction->as<OpGetById>().metadata(codeBlock);
+                    skipProfile = jit.branch8(CCallHelpers::NotEqual, CCallHelpers::AbsoluteAddress(&metadata.m_modeMetadata.mode), CCallHelpers::TrustedImm32(static_cast<uint8_t>(GetByIdMode::ArrayLength)));
+                }
+
                 jit.load32(MacroAssembler::Address(GPRInfo::regT0, JSCell::structureIDOffset()), GPRInfo::regT1);
                 jit.store32(GPRInfo::regT1, arrayProfile->addressOfLastSeenStructureID());
 
                 jit.load8(MacroAssembler::Address(GPRInfo::regT0, JSCell::typeInfoTypeOffset()), GPRInfo::regT2);
                 jit.sub32(MacroAssembler::TrustedImm32(FirstTypedArrayType), GPRInfo::regT2);
@@ -264,10 +273,13 @@
                 jit.and32(MacroAssembler::TrustedImm32(IndexingModeMask), GPRInfo::regT1);
                 jit.move(MacroAssembler::TrustedImm32(1), GPRInfo::regT2);
                 jit.lshift32(GPRInfo::regT1, GPRInfo::regT2);
                 storeArrayModes.link(&jit);
                 jit.or32(GPRInfo::regT2, MacroAssembler::AbsoluteAddress(arrayProfile->addressOfArrayModes()));
+
+                if (skipProfile.isSet())
+                    skipProfile.link(&jit);
             }
         }
 
         if (exit.m_descriptor->m_valueProfile)
             exit.m_descriptor->m_valueProfile.emitReportValue(jit, JSValueRegs(GPRInfo::regT0));
@@ -319,12 +331,14 @@
                 jit.storePtr(GPRInfo::regT0, materializationArguments + propertyIndex);
             }
 
             static_assert(FunctionTraits<decltype(operationMaterializeObjectInOSR)>::arity < GPRInfo::numberOfArgumentRegisters, "This call assumes that we don't pass arguments on the stack.");
             jit.setupArguments<decltype(operationMaterializeObjectInOSR)>(
+                CCallHelpers::TrustedImmPtr(codeBlock->globalObjectFor(materialization->origin())),
                 CCallHelpers::TrustedImmPtr(materialization),
                 CCallHelpers::TrustedImmPtr(materializationArguments));
+            jit.prepareCallOperation(vm);
             jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr<OperationPtrTag>(operationMaterializeObjectInOSR)), GPRInfo::nonArgGPR0);
             jit.call(GPRInfo::nonArgGPR0, OperationPtrTag);
             jit.storePtr(GPRInfo::returnValueGPR, materializationToPointer.get(materialization));
 
             // Let everyone know that we're done.
@@ -346,13 +360,15 @@
             jit.storePtr(GPRInfo::regT0, materializationArguments + propertyIndex);
         }
 
         static_assert(FunctionTraits<decltype(operationPopulateObjectInOSR)>::arity < GPRInfo::numberOfArgumentRegisters, "This call assumes that we don't pass arguments on the stack.");
         jit.setupArguments<decltype(operationPopulateObjectInOSR)>(
+            CCallHelpers::TrustedImmPtr(codeBlock->globalObjectFor(materialization->origin())),
             CCallHelpers::TrustedImmPtr(materialization),
             CCallHelpers::TrustedImmPtr(materializationToPointer.get(materialization)),
             CCallHelpers::TrustedImmPtr(materializationArguments));
+        jit.prepareCallOperation(vm);
         jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr<OperationPtrTag>(operationPopulateObjectInOSR)), GPRInfo::nonArgGPR0);
         jit.call(GPRInfo::nonArgGPR0, OperationPtrTag);
     }
 
     // Save all state from wherever the exit data tells us it was, into the appropriate place in
@@ -395,11 +411,11 @@
     RegisterSet allFTLCalleeSaves = RegisterSet::ftlCalleeSaveRegisters();
     const RegisterAtOffsetList* baselineCalleeSaves = baselineCodeBlock->calleeSaveRegisters();
     RegisterAtOffsetList* vmCalleeSaves = RegisterSet::vmCalleeSaveRegisterOffsets();
     RegisterSet vmCalleeSavesToSkip = RegisterSet::stackRegisters();
     if (exit.isExceptionHandler()) {
-        jit.loadPtr(&vm->topEntryFrame, GPRInfo::regT1);
+        jit.loadPtr(&vm.topEntryFrame, GPRInfo::regT1);
         jit.addPtr(CCallHelpers::TrustedImm32(EntryFrame::calleeSaveRegistersBufferOffset()), GPRInfo::regT1);
     }
 
     for (Reg reg = Reg::first(); reg <= Reg::last(); reg = reg.next()) {
         if (!allFTLCalleeSaves.get(reg)) {
@@ -449,34 +465,70 @@
                 jit.storeDouble(fpRegToLoad, MacroAssembler::Address(GPRInfo::regT1, vmCalleeSave->offset()));
         }
     }
 
     if (exit.isExceptionHandler()) {
-        RegisterAtOffset* vmCalleeSave = vmCalleeSaves->find(GPRInfo::tagTypeNumberRegister);
-        jit.store64(GPRInfo::tagTypeNumberRegister, MacroAssembler::Address(GPRInfo::regT1, vmCalleeSave->offset()));
+        RegisterAtOffset* vmCalleeSave = vmCalleeSaves->find(GPRInfo::numberTagRegister);
+        jit.store64(GPRInfo::numberTagRegister, MacroAssembler::Address(GPRInfo::regT1, vmCalleeSave->offset()));
 
-        vmCalleeSave = vmCalleeSaves->find(GPRInfo::tagMaskRegister);
-        jit.store64(GPRInfo::tagMaskRegister, MacroAssembler::Address(GPRInfo::regT1, vmCalleeSave->offset()));
+        vmCalleeSave = vmCalleeSaves->find(GPRInfo::notCellMaskRegister);
+        jit.store64(GPRInfo::notCellMaskRegister, MacroAssembler::Address(GPRInfo::regT1, vmCalleeSave->offset()));
     }
 
     size_t baselineVirtualRegistersForCalleeSaves = baselineCodeBlock->calleeSaveSpaceAsVirtualRegisters();
 
+    if (exit.m_codeOrigin.inlineStackContainsActiveCheckpoint()) {
+        JSValue* tmpScratch = reinterpret_cast<JSValue*>(scratch + exit.m_descriptor->m_values.tmpIndex(0));
+        VM* vmPtr = &vm;
+        jit.probe([=] (Probe::Context& context) {
+            auto addSideState = [&] (CallFrame* frame, BytecodeIndex index, size_t tmpOffset) {
+                std::unique_ptr<CheckpointOSRExitSideState> sideState = WTF::makeUnique<CheckpointOSRExitSideState>();
+
+                sideState->bytecodeIndex = index;
+                for (size_t i = 0; i < maxNumCheckpointTmps; ++i)
+                    sideState->tmps[i] = tmpScratch[i + tmpOffset];
+
+                vmPtr->addCheckpointOSRSideState(frame, WTFMove(sideState));
+            };
+
+            const CodeOrigin* codeOrigin;
+            CallFrame* callFrame = context.gpr<CallFrame*>(GPRInfo::callFrameRegister);
+            for (codeOrigin = &exit.m_codeOrigin; codeOrigin && codeOrigin->inlineCallFrame(); codeOrigin = codeOrigin->inlineCallFrame()->getCallerSkippingTailCalls()) {
+                BytecodeIndex callBytecodeIndex = codeOrigin->bytecodeIndex();
+                if (!callBytecodeIndex.checkpoint())
+                    continue;
+
+                auto* inlineCallFrame = codeOrigin->inlineCallFrame();
+                addSideState(reinterpret_cast<CallFrame*>(reinterpret_cast<char*>(callFrame) + inlineCallFrame->returnPCOffset() - sizeof(CPURegister)), callBytecodeIndex, inlineCallFrame->tmpOffset);
+            }
+
+            if (!codeOrigin)
+                return;
+
+            if (BytecodeIndex bytecodeIndex = codeOrigin->bytecodeIndex(); bytecodeIndex.checkpoint())
+                addSideState(callFrame, bytecodeIndex, 0);
+        });
+    }
+
     // Now get state out of the scratch buffer and place it back into the stack. The values are
     // already reboxed so we just move them.
     for (unsigned index = exit.m_descriptor->m_values.size(); index--;) {
-        VirtualRegister reg = exit.m_descriptor->m_values.virtualRegisterForIndex(index);
+        Operand operand = exit.m_descriptor->m_values.operandForIndex(index);
 
-        if (reg.isLocal() && reg.toLocal() < static_cast<int>(baselineVirtualRegistersForCalleeSaves))
+        if (operand.isTmp())
+            continue;
+
+        if (operand.isLocal() && operand.toLocal() < static_cast<int>(baselineVirtualRegistersForCalleeSaves))
             continue;
 
         jit.load64(scratch + index, GPRInfo::regT0);
-        jit.store64(GPRInfo::regT0, AssemblyHelpers::addressFor(reg));
+        jit.store64(GPRInfo::regT0, AssemblyHelpers::addressFor(operand.virtualRegister()));
     }
 
-    handleExitCounts(jit, exit);
+    handleExitCounts(vm, jit, exit);
     reifyInlinedCallFrames(jit, exit);
-    adjustAndJumpToTarget(*vm, jit, exit);
+    adjustAndJumpToTarget(vm, jit, exit);
 
     LinkBuffer patchBuffer(jit, codeBlock);
     exit.m_code = FINALIZE_CODE_IF(
         shouldDumpDisassembly() || Options::verboseOSR() || Options::verboseFTLOSRExit(),
         patchBuffer, OSRExitPtrTag,
@@ -485,27 +537,27 @@
             exitKindToString(exit.m_kind), toCString(*codeBlock).data(),
             toCString(ignoringContext<DumpContext>(exit.m_descriptor->m_values)).data()
         );
 }
 
-extern "C" void* compileFTLOSRExit(ExecState* exec, unsigned exitID)
+extern "C" JIT_OPERATION void* operationCompileFTLOSRExit(CallFrame* callFrame, unsigned exitID)
 {
     if (shouldDumpDisassembly() || Options::verboseOSR() || Options::verboseFTLOSRExit())
         dataLog("Compiling OSR exit with exitID = ", exitID, "\n");
 
-    VM& vm = exec->vm();
+    VM& vm = callFrame->deprecatedVM();
 
     if (validateDFGDoesGC) {
         // We're about to exit optimized code. So, there's no longer any optimized
         // code running that expects no GC.
         vm.heap.setExpectDoesGC(true);
     }
 
     if (vm.callFrameForCatch)
-        RELEASE_ASSERT(vm.callFrameForCatch == exec);
+        RELEASE_ASSERT(vm.callFrameForCatch == callFrame);
 
-    CodeBlock* codeBlock = exec->codeBlock();
+    CodeBlock* codeBlock = callFrame->codeBlock();
 
     ASSERT(codeBlock);
     ASSERT(codeBlock->jitType() == JITType::FTLJIT);
 
     // It's sort of preferable that we don't GC while in here. Anyways, doing so wouldn't
@@ -518,11 +570,11 @@
     if (shouldDumpDisassembly() || Options::verboseOSR() || Options::verboseFTLOSRExit()) {
         dataLog("    Owning block: ", pointerDump(codeBlock), "\n");
         dataLog("    Origin: ", exit.m_codeOrigin, "\n");
         if (exit.m_codeOriginForExitProfile != exit.m_codeOrigin)
             dataLog("    Origin for exit profile: ", exit.m_codeOriginForExitProfile, "\n");
-        dataLog("    Current call site index: ", exec->callSiteIndex().bits(), "\n");
+        dataLog("    Current call site index: ", callFrame->callSiteIndex().bits(), "\n");
         dataLog("    Exit is exception handler: ", exit.isExceptionHandler(), "\n");
         dataLog("    Is unwind handler: ", exit.isGenericUnwindHandler(), "\n");
         dataLog("    Exit values: ", exit.m_descriptor->m_values, "\n");
         dataLog("    Value reps: ", listDump(exit.m_valueReps), "\n");
         if (!exit.m_descriptor->m_materializations.isEmpty()) {
@@ -530,13 +582,11 @@
             for (ExitTimeObjectMaterialization* materialization : exit.m_descriptor->m_materializations)
                 dataLog("        ", pointerDump(materialization), "\n");
         }
     }
 
-    prepareCodeOriginForOSRExit(exec, exit.m_codeOrigin);
-
-    compileStub(exitID, jitCode, exit, &vm, codeBlock);
+    compileStub(vm, exitID, jitCode, exit, codeBlock);
 
     MacroAssembler::repatchJump(
         exit.codeLocationForRepatch(codeBlock), CodeLocationLabel<OSRExitPtrTag>(exit.m_code.code()));
 
     return exit.m_code.code().executableAddress();

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/cache/WorkerCacheStorageConnection.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DOMWindowCaches.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WorkerCacheStorageConnection.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/cache/WorkerCacheStorageConnection.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
117 {
118     auto connection = adoptRef(*new WorkerCacheStorageConnection(scope));
119     callOnMainThreadAndWait([workerThread = makeRef(scope.thread()), connection = connection.ptr()]() mutable {
120         connection-&gt;m_mainThreadConnection = workerThread-&gt;workerLoaderProxy().createCacheStorageConnection();
121     });
122     ASSERT(connection-&gt;m_mainThreadConnection);
123     return connection;
124 }
125 
126 WorkerCacheStorageConnection::WorkerCacheStorageConnection(WorkerGlobalScope&amp; scope)
127     : m_scope(scope)
128 {
129 }
130 
131 WorkerCacheStorageConnection::~WorkerCacheStorageConnection()
132 {
133     if (m_mainThreadConnection)
134         callOnMainThread([mainThreadConnection = WTFMove(m_mainThreadConnection)]() mutable { });
135 }
136 
<span class="line-removed">137 PAL::SessionID WorkerCacheStorageConnection::sessionID() const</span>
<span class="line-removed">138 {</span>
<span class="line-removed">139     return m_scope.sessionID();</span>
<span class="line-removed">140 }</span>
<span class="line-removed">141 </span>
142 void WorkerCacheStorageConnection::open(const ClientOrigin&amp; origin, const String&amp; cacheName, CacheIdentifierCallback&amp;&amp; callback)
143 {
144     uint64_t requestIdentifier = ++m_lastRequestIdentifier;
145     m_openAndRemoveCachePendingRequests.add(requestIdentifier, WTFMove(callback));
146 
147     callOnMainThread([workerThread = makeRef(m_scope.thread()), mainThreadConnection = m_mainThreadConnection, requestIdentifier, origin = origin.isolatedCopy(), cacheName = cacheName.isolatedCopy()] () mutable {
148         mainThreadConnection-&gt;open(origin, cacheName, [workerThread = WTFMove(workerThread), requestIdentifier] (const CacheIdentifierOrError&amp; result) mutable {
149             workerThread-&gt;runLoop().postTaskForMode([requestIdentifier, result] (auto&amp; scope) mutable {
150                 downcast&lt;WorkerGlobalScope&gt;(scope).cacheStorageConnection().openOrRemoveCompleted(requestIdentifier, result);
151             }, WorkerRunLoop::defaultMode());
152         });
153     });
154 }
155 
156 void WorkerCacheStorageConnection::openOrRemoveCompleted(uint64_t requestIdentifier, const CacheIdentifierOrError&amp; result)
157 {
158     if (auto callback = m_openAndRemoveCachePendingRequests.take(requestIdentifier))
159         callback(result);
160 }
161 
</pre>
</td>
<td>
<hr />
<pre>
117 {
118     auto connection = adoptRef(*new WorkerCacheStorageConnection(scope));
119     callOnMainThreadAndWait([workerThread = makeRef(scope.thread()), connection = connection.ptr()]() mutable {
120         connection-&gt;m_mainThreadConnection = workerThread-&gt;workerLoaderProxy().createCacheStorageConnection();
121     });
122     ASSERT(connection-&gt;m_mainThreadConnection);
123     return connection;
124 }
125 
126 WorkerCacheStorageConnection::WorkerCacheStorageConnection(WorkerGlobalScope&amp; scope)
127     : m_scope(scope)
128 {
129 }
130 
131 WorkerCacheStorageConnection::~WorkerCacheStorageConnection()
132 {
133     if (m_mainThreadConnection)
134         callOnMainThread([mainThreadConnection = WTFMove(m_mainThreadConnection)]() mutable { });
135 }
136 





137 void WorkerCacheStorageConnection::open(const ClientOrigin&amp; origin, const String&amp; cacheName, CacheIdentifierCallback&amp;&amp; callback)
138 {
139     uint64_t requestIdentifier = ++m_lastRequestIdentifier;
140     m_openAndRemoveCachePendingRequests.add(requestIdentifier, WTFMove(callback));
141 
142     callOnMainThread([workerThread = makeRef(m_scope.thread()), mainThreadConnection = m_mainThreadConnection, requestIdentifier, origin = origin.isolatedCopy(), cacheName = cacheName.isolatedCopy()] () mutable {
143         mainThreadConnection-&gt;open(origin, cacheName, [workerThread = WTFMove(workerThread), requestIdentifier] (const CacheIdentifierOrError&amp; result) mutable {
144             workerThread-&gt;runLoop().postTaskForMode([requestIdentifier, result] (auto&amp; scope) mutable {
145                 downcast&lt;WorkerGlobalScope&gt;(scope).cacheStorageConnection().openOrRemoveCompleted(requestIdentifier, result);
146             }, WorkerRunLoop::defaultMode());
147         });
148     });
149 }
150 
151 void WorkerCacheStorageConnection::openOrRemoveCompleted(uint64_t requestIdentifier, const CacheIdentifierOrError&amp; result)
152 {
153     if (auto callback = m_openAndRemoveCachePendingRequests.take(requestIdentifier))
154         callback(result);
155 }
156 
</pre>
</td>
</tr>
</table>
<center><a href="DOMWindowCaches.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WorkerCacheStorageConnection.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/bindings/js/IDBBindingUtilities.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
  3  * Copyright (C) 2012 Michael Pruett &lt;michael@68k.org&gt;
  4  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  *
 10  * 1.  Redistributions of source code must retain the above copyright
 11  *     notice, this list of conditions and the following disclaimer.
 12  * 2.  Redistributions in binary form must reproduce the above copyright
 13  *     notice, this list of conditions and the following disclaimer in the
 14  *     documentation and/or other materials provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 18  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 19  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 20  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 21  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 22  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 23  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 25  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 
 30 #if ENABLE(INDEXED_DATABASE)
 31 
 32 #include &quot;IDBBindingUtilities.h&quot;
 33 
 34 #include &quot;ExceptionCode.h&quot;
 35 #include &quot;IDBIndexInfo.h&quot;
 36 #include &quot;IDBKey.h&quot;
 37 #include &quot;IDBKeyData.h&quot;
 38 #include &quot;IDBKeyPath.h&quot;
 39 #include &quot;IDBValue.h&quot;
 40 #include &quot;IndexKey.h&quot;
 41 #include &quot;JSBlob.h&quot;
 42 #include &quot;JSDOMBinding.h&quot;
 43 #include &quot;JSDOMConvertDate.h&quot;
 44 #include &quot;JSDOMConvertNullable.h&quot;
 45 #include &quot;JSDOMExceptionHandling.h&quot;
 46 #include &quot;JSFile.h&quot;
 47 #include &quot;Logging.h&quot;
 48 #include &quot;MessagePort.h&quot;
 49 #include &quot;ScriptExecutionContext.h&quot;
 50 #include &quot;SerializedScriptValue.h&quot;
 51 #include &quot;SharedBuffer.h&quot;
 52 #include &quot;ThreadSafeDataBuffer.h&quot;
 53 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 54 #include &lt;JavaScriptCore/DateInstance.h&gt;
 55 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
 56 
 57 namespace WebCore {
 58 using namespace JSC;
 59 
<a name="1" id="anc1"></a><span class="line-modified"> 60 static bool get(JSGlobalObject&amp; lexicalGlobalObject, JSValue object, const String&amp; keyPathElement, JSValue&amp; result)</span>
 61 {
 62     if (object.isString() &amp;&amp; keyPathElement == &quot;length&quot;) {
 63         result = jsNumber(asString(object)-&gt;length());
 64         return true;
 65     }
 66     if (!object.isObject())
 67         return false;
 68 
<a name="2" id="anc2"></a><span class="line-modified"> 69     VM&amp; vm = lexicalGlobalObject.vm();</span>
 70     auto* obj = asObject(object);
 71     Identifier identifier = Identifier::fromString(vm, keyPathElement);
 72     if (obj-&gt;inherits&lt;JSArray&gt;(vm) &amp;&amp; keyPathElement == &quot;length&quot;) {
<a name="3" id="anc3"></a><span class="line-modified"> 73         result = obj-&gt;get(&amp;lexicalGlobalObject, identifier);</span>
 74         return true;
 75     }
 76     if (obj-&gt;inherits&lt;JSBlob&gt;(vm) &amp;&amp; (keyPathElement == &quot;size&quot; || keyPathElement == &quot;type&quot;)) {
 77         if (keyPathElement == &quot;size&quot;) {
 78             result = jsNumber(jsCast&lt;JSBlob*&gt;(obj)-&gt;wrapped().size());
 79             return true;
 80         }
 81         if (keyPathElement == &quot;type&quot;) {
 82             result = jsString(vm, jsCast&lt;JSBlob*&gt;(obj)-&gt;wrapped().type());
 83             return true;
 84         }
 85     }
 86     if (obj-&gt;inherits&lt;JSFile&gt;(vm)) {
 87         if (keyPathElement == &quot;name&quot;) {
 88             result = jsString(vm, jsCast&lt;JSFile*&gt;(obj)-&gt;wrapped().name());
 89             return true;
 90         }
 91         if (keyPathElement == &quot;lastModified&quot;) {
 92             result = jsNumber(jsCast&lt;JSFile*&gt;(obj)-&gt;wrapped().lastModified());
 93             return true;
 94         }
 95         if (keyPathElement == &quot;lastModifiedDate&quot;) {
<a name="4" id="anc4"></a><span class="line-modified"> 96             result = jsDate(lexicalGlobalObject, jsCast&lt;JSFile*&gt;(obj)-&gt;wrapped().lastModified());</span>
 97             return true;
 98         }
 99     }
100 
101     PropertyDescriptor descriptor;
<a name="5" id="anc5"></a><span class="line-modified">102     if (!obj-&gt;getOwnPropertyDescriptor(&amp;lexicalGlobalObject, identifier, descriptor))</span>
103         return false;
104     if (!descriptor.enumerable())
105         return false;
106 
<a name="6" id="anc6"></a><span class="line-modified">107     result = obj-&gt;get(&amp;lexicalGlobalObject, identifier);</span>
108     return true;
109 }
110 
111 static bool canSet(JSValue object, const String&amp; keyPathElement)
112 {
113     UNUSED_PARAM(keyPathElement);
114     return object.isObject();
115 }
116 
<a name="7" id="anc7"></a><span class="line-modified">117 static bool set(JSGlobalObject&amp; lexicalGlobalObject, JSValue&amp; object, const String&amp; keyPathElement, JSValue jsValue)</span>
118 {
119     if (!canSet(object, keyPathElement))
120         return false;
<a name="8" id="anc8"></a><span class="line-modified">121     VM&amp; vm = lexicalGlobalObject.vm();</span>
122     Identifier identifier = Identifier::fromString(vm, keyPathElement);
123     asObject(object)-&gt;putDirect(vm, identifier, jsValue);
124     return true;
125 }
126 
<a name="9" id="anc9"></a><span class="line-modified">127 JSValue toJS(JSGlobalObject&amp; lexicalGlobalObject, JSGlobalObject&amp; globalObject, IDBKey* key)</span>
128 {
129     if (!key) {
130         // This must be undefined, not null.
131         // Spec: http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#idl-def-IDBKeyRange
132         return jsUndefined();
133     }
134 
<a name="10" id="anc10"></a><span class="line-modified">135     VM&amp; vm = lexicalGlobalObject.vm();</span>
136     Locker&lt;JSLock&gt; locker(vm.apiLock());
137     auto scope = DECLARE_THROW_SCOPE(vm);
138 
139     switch (key-&gt;type()) {
140     case IndexedDB::KeyType::Array: {
141         auto&amp; inArray = key-&gt;array();
142         unsigned size = inArray.size();
<a name="11" id="anc11"></a><span class="line-modified">143         auto outArray = constructEmptyArray(&amp;globalObject, static_cast&lt;JSC::ArrayAllocationProfile*&gt;(nullptr), size);</span>
144         RETURN_IF_EXCEPTION(scope, JSValue());
145         for (size_t i = 0; i &lt; size; ++i) {
<a name="12" id="anc12"></a><span class="line-modified">146             outArray-&gt;putDirectIndex(&amp;lexicalGlobalObject, i, toJS(lexicalGlobalObject, globalObject, inArray.at(i).get()));</span>
147             RETURN_IF_EXCEPTION(scope, JSValue());
148         }
149         return outArray;
150     }
151     case IndexedDB::KeyType::Binary: {
152         auto* data = key-&gt;binary().data();
153         if (!data) {
154             ASSERT_NOT_REACHED();
155             return jsNull();
156         }
157 
158         auto arrayBuffer = ArrayBuffer::create(data-&gt;data(), data-&gt;size());
159         Structure* structure = globalObject.arrayBufferStructure(arrayBuffer-&gt;sharingMode());
160         if (!structure)
161             return jsNull();
162 
<a name="13" id="anc13"></a><span class="line-modified">163         return JSArrayBuffer::create(lexicalGlobalObject.vm(), structure, WTFMove(arrayBuffer));</span>
164     }
165     case IndexedDB::KeyType::String:
<a name="14" id="anc14"></a><span class="line-modified">166         return jsStringWithCache(&amp;lexicalGlobalObject, key-&gt;string());</span>
167     case IndexedDB::KeyType::Date:
168         // FIXME: This should probably be toJS&lt;IDLDate&gt;(...) as per:
169         // http://w3c.github.io/IndexedDB/#request-convert-a-key-to-a-value
<a name="15" id="anc15"></a><span class="line-modified">170         return toJS&lt;IDLNullable&lt;IDLDate&gt;&gt;(lexicalGlobalObject, key-&gt;date());</span>
171     case IndexedDB::KeyType::Number:
172         return jsNumber(key-&gt;number());
173     case IndexedDB::KeyType::Min:
174     case IndexedDB::KeyType::Max:
175     case IndexedDB::KeyType::Invalid:
176         ASSERT_NOT_REACHED();
177         return jsUndefined();
178     }
179 
180     ASSERT_NOT_REACHED();
181     return jsUndefined();
182 }
183 
184 static const size_t maximumDepth = 2000;
185 
<a name="16" id="anc16"></a><span class="line-modified">186 static RefPtr&lt;IDBKey&gt; createIDBKeyFromValue(JSGlobalObject&amp; lexicalGlobalObject, JSValue value, Vector&lt;JSArray*&gt;&amp; stack)</span>
187 {
<a name="17" id="anc17"></a><span class="line-modified">188     VM&amp; vm = lexicalGlobalObject.vm();</span>
<span class="line-modified">189     if (value.isNumber() &amp;&amp; !std::isnan(value.toNumber(&amp;lexicalGlobalObject)))</span>
<span class="line-modified">190         return IDBKey::createNumber(value.toNumber(&amp;lexicalGlobalObject));</span>
191 
192     if (value.isString())
<a name="18" id="anc18"></a><span class="line-modified">193         return IDBKey::createString(asString(value)-&gt;value(&amp;lexicalGlobalObject));</span>
194 
195     if (value.inherits&lt;DateInstance&gt;(vm)) {
<a name="19" id="anc19"></a><span class="line-modified">196         auto dateValue = valueToDate(lexicalGlobalObject, value);</span>
197         if (!std::isnan(dateValue))
198             return IDBKey::createDate(dateValue);
199     }
200 
201     if (value.isObject()) {
202         JSObject* object = asObject(value);
203         if (auto* array = jsDynamicCast&lt;JSArray*&gt;(vm, object)) {
204             size_t length = array-&gt;length();
205 
206             if (stack.contains(array))
207                 return nullptr;
208 
209             if (stack.size() &gt;= maximumDepth)
210                 return nullptr;
211 
212             stack.append(array);
213 
214             Vector&lt;RefPtr&lt;IDBKey&gt;&gt; subkeys;
215             for (size_t i = 0; i &lt; length; i++) {
<a name="20" id="anc20"></a><span class="line-modified">216                 JSValue item = array-&gt;getIndex(&amp;lexicalGlobalObject, i);</span>
<span class="line-modified">217                 RefPtr&lt;IDBKey&gt; subkey = createIDBKeyFromValue(lexicalGlobalObject, item, stack);</span>
218                 if (!subkey)
219                     subkeys.append(IDBKey::createInvalid());
220                 else
221                     subkeys.append(subkey);
222             }
223 
224             stack.removeLast();
225             return IDBKey::createArray(subkeys);
226         }
227 
228         if (auto* arrayBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, value))
229             return IDBKey::createBinary(*arrayBuffer);
230 
231         if (auto* arrayBufferView = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, value))
232             return IDBKey::createBinary(*arrayBufferView);
233     }
234     return nullptr;
235 }
236 
<a name="21" id="anc21"></a><span class="line-modified">237 static Ref&lt;IDBKey&gt; createIDBKeyFromValue(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)</span>
238 {
239     Vector&lt;JSArray*&gt; stack;
<a name="22" id="anc22"></a><span class="line-modified">240     RefPtr&lt;IDBKey&gt; key = createIDBKeyFromValue(lexicalGlobalObject, value, stack);</span>
241     if (key)
242         return *key;
243     return IDBKey::createInvalid();
244 }
245 
<a name="23" id="anc23"></a><span class="line-modified">246 static JSValue getNthValueOnKeyPath(JSGlobalObject&amp; lexicalGlobalObject, JSValue rootValue, const Vector&lt;String&gt;&amp; keyPathElements, size_t index)</span>
247 {
248     JSValue currentValue(rootValue);
249     ASSERT(index &lt;= keyPathElements.size());
250     for (size_t i = 0; i &lt; index; i++) {
251         JSValue parentValue(currentValue);
<a name="24" id="anc24"></a><span class="line-modified">252         if (!get(lexicalGlobalObject, parentValue, keyPathElements[i], currentValue))</span>
253             return jsUndefined();
254     }
255     return currentValue;
256 }
257 
<a name="25" id="anc25"></a><span class="line-modified">258 static RefPtr&lt;IDBKey&gt; internalCreateIDBKeyFromScriptValueAndKeyPath(JSGlobalObject&amp; lexicalGlobalObject, const JSValue&amp; value, const String&amp; keyPath)</span>
259 {
260     Vector&lt;String&gt; keyPathElements;
261     IDBKeyPathParseError error;
262     IDBParseKeyPath(keyPath, keyPathElements, error);
263     ASSERT(error == IDBKeyPathParseError::None);
264 
265     JSValue jsValue = value;
<a name="26" id="anc26"></a><span class="line-modified">266     jsValue = getNthValueOnKeyPath(lexicalGlobalObject, jsValue, keyPathElements, keyPathElements.size());</span>
267     if (jsValue.isUndefined())
268         return nullptr;
<a name="27" id="anc27"></a><span class="line-modified">269     return createIDBKeyFromValue(lexicalGlobalObject, jsValue);</span>
270 }
271 
<a name="28" id="anc28"></a><span class="line-modified">272 static JSValue ensureNthValueOnKeyPath(JSGlobalObject&amp; lexicalGlobalObject, JSValue rootValue, const Vector&lt;String&gt;&amp; keyPathElements, size_t index)</span>
273 {
274     JSValue currentValue(rootValue);
275 
276     ASSERT(index &lt;= keyPathElements.size());
277     for (size_t i = 0; i &lt; index; i++) {
278         JSValue parentValue(currentValue);
279         const String&amp; keyPathElement = keyPathElements[i];
<a name="29" id="anc29"></a><span class="line-modified">280         if (!get(lexicalGlobalObject, parentValue, keyPathElement, currentValue)) {</span>
<span class="line-modified">281             JSObject* object = constructEmptyObject(&amp;lexicalGlobalObject);</span>
<span class="line-modified">282             if (!set(lexicalGlobalObject, parentValue, keyPathElement, JSValue(object)))</span>
283                 return jsUndefined();
284             currentValue = JSValue(object);
285         }
286     }
287 
288     return currentValue;
289 }
290 
<a name="30" id="anc30"></a><span class="line-modified">291 static bool canInjectNthValueOnKeyPath(JSGlobalObject&amp; lexicalGlobalObject, JSValue rootValue, const Vector&lt;String&gt;&amp; keyPathElements, size_t index)</span>
292 {
293     if (!rootValue.isObject())
294         return false;
295 
296     JSValue currentValue(rootValue);
297 
298     ASSERT(index &lt;= keyPathElements.size());
299     for (size_t i = 0; i &lt;= index; ++i) {
300         JSValue parentValue(currentValue);
301         const String&amp; keyPathElement = keyPathElements[i];
<a name="31" id="anc31"></a><span class="line-modified">302         if (!get(lexicalGlobalObject, parentValue, keyPathElement, currentValue))</span>
303             return canSet(parentValue, keyPathElement);
304     }
305     return true;
306 }
307 
<a name="32" id="anc32"></a><span class="line-modified">308 bool injectIDBKeyIntoScriptValue(JSGlobalObject&amp; lexicalGlobalObject, const IDBKeyData&amp; keyData, JSValue value, const IDBKeyPath&amp; keyPath)</span>
309 {
310     LOG(IndexedDB, &quot;injectIDBKeyIntoScriptValue&quot;);
311 
312     ASSERT(WTF::holds_alternative&lt;String&gt;(keyPath));
313 
314     Vector&lt;String&gt; keyPathElements;
315     IDBKeyPathParseError error;
316     IDBParseKeyPath(WTF::get&lt;String&gt;(keyPath), keyPathElements, error);
317     ASSERT(error == IDBKeyPathParseError::None);
318 
319     if (keyPathElements.isEmpty())
320         return false;
321 
<a name="33" id="anc33"></a><span class="line-modified">322     JSValue parent = ensureNthValueOnKeyPath(lexicalGlobalObject, value, keyPathElements, keyPathElements.size() - 1);</span>
323     if (parent.isUndefined())
324         return false;
325 
326     auto key = keyData.maybeCreateIDBKey();
327     if (!key)
328         return false;
329 
330     // Do not set if object already has the correct property value.
331     JSValue existingKey;
<a name="34" id="anc34"></a><span class="line-modified">332     if (get(lexicalGlobalObject, parent, keyPathElements.last(), existingKey) &amp;&amp; !key-&gt;compare(createIDBKeyFromValue(lexicalGlobalObject, existingKey)))</span>
333         return true;
<a name="35" id="anc35"></a><span class="line-modified">334     if (!set(lexicalGlobalObject, parent, keyPathElements.last(), toJS(lexicalGlobalObject, lexicalGlobalObject, key.get())))</span>
335         return false;
336 
337     return true;
338 }
339 
340 
<a name="36" id="anc36"></a><span class="line-modified">341 RefPtr&lt;IDBKey&gt; maybeCreateIDBKeyFromScriptValueAndKeyPath(JSGlobalObject&amp; lexicalGlobalObject, const JSValue&amp; value, const IDBKeyPath&amp; keyPath)</span>
342 {
343     if (WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(keyPath)) {
344         auto&amp; array = WTF::get&lt;Vector&lt;String&gt;&gt;(keyPath);
345         Vector&lt;RefPtr&lt;IDBKey&gt;&gt; result;
346         result.reserveInitialCapacity(array.size());
347         for (auto&amp; string : array) {
<a name="37" id="anc37"></a><span class="line-modified">348             RefPtr&lt;IDBKey&gt; key = internalCreateIDBKeyFromScriptValueAndKeyPath(lexicalGlobalObject, value, string);</span>
349             if (!key)
350                 return nullptr;
351             result.uncheckedAppend(WTFMove(key));
352         }
353         return IDBKey::createArray(WTFMove(result));
354     }
355 
<a name="38" id="anc38"></a><span class="line-modified">356     return internalCreateIDBKeyFromScriptValueAndKeyPath(lexicalGlobalObject, value, WTF::get&lt;String&gt;(keyPath));</span>
357 }
358 
<a name="39" id="anc39"></a><span class="line-modified">359 bool canInjectIDBKeyIntoScriptValue(JSGlobalObject&amp; lexicalGlobalObject, const JSValue&amp; scriptValue, const IDBKeyPath&amp; keyPath)</span>
360 {
361     LOG(StorageAPI, &quot;canInjectIDBKeyIntoScriptValue&quot;);
362 
363     ASSERT(WTF::holds_alternative&lt;String&gt;(keyPath));
364     Vector&lt;String&gt; keyPathElements;
365     IDBKeyPathParseError error;
366     IDBParseKeyPath(WTF::get&lt;String&gt;(keyPath), keyPathElements, error);
367     ASSERT(error == IDBKeyPathParseError::None);
368 
369     if (!keyPathElements.size())
370         return false;
371 
<a name="40" id="anc40"></a><span class="line-modified">372     return canInjectNthValueOnKeyPath(lexicalGlobalObject, scriptValue, keyPathElements, keyPathElements.size() - 1);</span>
373 }
374 
<a name="41" id="anc41"></a><span class="line-modified">375 static JSValue deserializeIDBValueToJSValue(JSGlobalObject&amp; lexicalGlobalObject, JSC::JSGlobalObject&amp; globalObject, const IDBValue&amp; value)</span>
376 {
377     // FIXME: I think it&#39;s peculiar to use undefined to mean &quot;null data&quot; and null to mean &quot;empty data&quot;.
378     // But I am not changing this at the moment because at least some callers are specifically checking isUndefined.
379 
380     if (!value.data().data())
381         return jsUndefined();
382 
383     auto&amp; data = *value.data().data();
384     if (data.isEmpty())
385         return jsNull();
386 
387     auto serializedValue = SerializedScriptValue::createFromWireBytes(Vector&lt;uint8_t&gt;(data));
388 
<a name="42" id="anc42"></a><span class="line-modified">389     lexicalGlobalObject.vm().apiLock().lock();</span>
390     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; messagePorts;
<a name="43" id="anc43"></a><span class="line-modified">391     JSValue result = serializedValue-&gt;deserialize(lexicalGlobalObject, &amp;globalObject, messagePorts, value.blobURLs(), value.blobFilePaths(), SerializationErrorMode::NonThrowing);</span>
<span class="line-modified">392     lexicalGlobalObject.vm().apiLock().unlock();</span>
393 
394     return result;
395 }
396 
<a name="44" id="anc44"></a><span class="line-modified">397 JSValue deserializeIDBValueToJSValue(JSGlobalObject&amp; lexicalGlobalObject, const IDBValue&amp; value)</span>
398 {
<a name="45" id="anc45"></a><span class="line-modified">399     return deserializeIDBValueToJSValue(lexicalGlobalObject, lexicalGlobalObject, value);</span>
400 }
401 
<a name="46" id="anc46"></a><span class="line-modified">402 JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, const IDBValue&amp; value)</span>
403 {
<a name="47" id="anc47"></a><span class="line-modified">404     ASSERT(lexicalGlobalObject);</span>
<span class="line-modified">405     return deserializeIDBValueToJSValue(*lexicalGlobalObject, *globalObject, value);</span>
406 }
407 
<a name="48" id="anc48"></a><span class="line-modified">408 Ref&lt;IDBKey&gt; scriptValueToIDBKey(JSGlobalObject&amp; lexicalGlobalObject, const JSValue&amp; scriptValue)</span>
409 {
<a name="49" id="anc49"></a><span class="line-modified">410     return createIDBKeyFromValue(lexicalGlobalObject, scriptValue);</span>
411 }
412 
<a name="50" id="anc50"></a><span class="line-modified">413 JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, const IDBKeyData&amp; keyData)</span>
414 {
<a name="51" id="anc51"></a><span class="line-modified">415     ASSERT(lexicalGlobalObject);</span>
416     ASSERT(globalObject);
417 
<a name="52" id="anc52"></a><span class="line-modified">418     return toJS(*lexicalGlobalObject, *globalObject, keyData.maybeCreateIDBKey().get());</span>
419 }
420 
<a name="53" id="anc53"></a><span class="line-modified">421 static Vector&lt;IDBKeyData&gt; createKeyPathArray(JSGlobalObject&amp; lexicalGlobalObject, JSValue value, const IDBIndexInfo&amp; info, Optional&lt;IDBKeyPath&gt; objectStoreKeyPath, const IDBKeyData&amp; objectStoreKey)</span>
422 {
423     auto visitor = WTF::makeVisitor([&amp;](const String&amp; string) -&gt; Vector&lt;IDBKeyData&gt; {
424         // Value doesn&#39;t contain auto-generated key, so we need to manually add key if it is possibly auto-generated.
425         if (objectStoreKeyPath &amp;&amp; WTF::holds_alternative&lt;String&gt;(objectStoreKeyPath.value()) &amp;&amp; IDBKeyPath(string) == objectStoreKeyPath.value())
426             return { objectStoreKey };
427 
<a name="54" id="anc54"></a><span class="line-modified">428         auto idbKey = internalCreateIDBKeyFromScriptValueAndKeyPath(lexicalGlobalObject, value, string);</span>
429         if (!idbKey)
430             return { };
431 
432         Vector&lt;IDBKeyData&gt; keys;
433         if (info.multiEntry() &amp;&amp; idbKey-&gt;type() == IndexedDB::Array) {
434             for (auto&amp; key : idbKey-&gt;array())
435                 keys.append(key.get());
436         } else
437             keys.append(idbKey.get());
438         return keys;
439     }, [&amp;](const Vector&lt;String&gt;&amp; vector) -&gt; Vector&lt;IDBKeyData&gt; {
440         Vector&lt;IDBKeyData&gt; keys;
441         for (auto&amp; entry : vector) {
442             if (objectStoreKeyPath &amp;&amp; WTF::holds_alternative&lt;String&gt;(objectStoreKeyPath.value()) &amp;&amp; IDBKeyPath(entry) == objectStoreKeyPath.value())
443                 keys.append(objectStoreKey);
444             else {
<a name="55" id="anc55"></a><span class="line-modified">445                 auto key = internalCreateIDBKeyFromScriptValueAndKeyPath(lexicalGlobalObject, value, entry);</span>
446                 if (!key || !key-&gt;isValid())
447                     return { };
448                 keys.append(key.get());
449             }
450         }
451         return keys;
452     });
453 
454     return WTF::visit(visitor, info.keyPath());
455 }
456 
<a name="56" id="anc56"></a><span class="line-modified">457 void generateIndexKeyForValue(JSGlobalObject&amp; lexicalGlobalObject, const IDBIndexInfo&amp; info, JSValue value, IndexKey&amp; outKey, const Optional&lt;IDBKeyPath&gt;&amp; objectStoreKeyPath, const IDBKeyData&amp; objectStoreKey)</span>
458 {
<a name="57" id="anc57"></a><span class="line-modified">459     auto keyDatas = createKeyPathArray(lexicalGlobalObject, value, info, objectStoreKeyPath, objectStoreKey);</span>
460     if (keyDatas.isEmpty())
461         return;
462 
463     outKey = IndexKey(WTFMove(keyDatas));
464 }
465 
<a name="58" id="anc58"></a><span class="line-modified">466 Optional&lt;JSC::JSValue&gt; deserializeIDBValueWithKeyInjection(JSGlobalObject&amp; lexicalGlobalObject, const IDBValue&amp; value, const IDBKeyData&amp; key, const Optional&lt;IDBKeyPath&gt;&amp; keyPath)</span>
467 {
<a name="59" id="anc59"></a><span class="line-modified">468     auto jsValue = deserializeIDBValueToJSValue(lexicalGlobalObject, value);</span>
469     if (jsValue.isUndefined() || !keyPath || !WTF::holds_alternative&lt;String&gt;(keyPath.value()) || !isIDBKeyPathValid(keyPath.value()))
470         return jsValue;
471 
<a name="60" id="anc60"></a><span class="line-modified">472     JSLockHolder locker(lexicalGlobalObject.vm());</span>
<span class="line-modified">473     if (!injectIDBKeyIntoScriptValue(lexicalGlobalObject, key, jsValue, keyPath.value())) {</span>
<span class="line-modified">474         auto throwScope = DECLARE_THROW_SCOPE(lexicalGlobalObject.vm());</span>
<span class="line-modified">475         propagateException(lexicalGlobalObject, throwScope, Exception(UnknownError, &quot;Cannot inject key into script value&quot;_s));</span>
476         return WTF::nullopt;
477     }
478 
479     return jsValue;
480 }
481 
482 } // namespace WebCore
483 
484 #endif // ENABLE(INDEXED_DATABASE)
<a name="61" id="anc61"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="61" type="hidden" />
</body>
</html>
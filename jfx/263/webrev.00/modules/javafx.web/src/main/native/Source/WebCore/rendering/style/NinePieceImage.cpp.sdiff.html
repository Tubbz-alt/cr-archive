<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/style/NinePieceImage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GridArea.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="NinePieceImage.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/style/NinePieceImage.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;NinePieceImage.h&quot;
 26 
 27 #include &quot;GraphicsContext.h&quot;
 28 #include &quot;ImageQualityController.h&quot;
 29 #include &quot;LengthFunctions.h&quot;
 30 #include &quot;RenderStyle.h&quot;
 31 #include &lt;wtf/NeverDestroyed.h&gt;
 32 #include &lt;wtf/PointerComparison.h&gt;
 33 #include &lt;wtf/text/TextStream.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 inline DataRef&lt;NinePieceImage::Data&gt;&amp; NinePieceImage::defaultData()
 38 {
 39     static NeverDestroyed&lt;DataRef&lt;Data&gt;&gt; data { Data::create() };
 40     return data.get();
 41 }
 42 
<span class="line-modified"> 43 NinePieceImage::NinePieceImage()</span>
<span class="line-removed"> 44     : m_data(defaultData())</span>
 45 {






 46 }
 47 
<span class="line-modified"> 48 NinePieceImage::NinePieceImage(RefPtr&lt;StyleImage&gt;&amp;&amp; image, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, ENinePieceImageRule horizontalRule, ENinePieceImageRule verticalRule)</span>





 49     : m_data(Data::create(WTFMove(image), imageSlices, fill, borderSlices, outset, horizontalRule, verticalRule))
 50 {
 51 }
 52 
 53 LayoutUnit NinePieceImage::computeSlice(Length length, LayoutUnit width, LayoutUnit slice, LayoutUnit extent)
 54 {
 55     if (length.isRelative())
 56         return LayoutUnit(length.value() * width);
 57     if (length.isAuto())
 58         return slice;
 59     return valueForLength(length, extent);
 60 }
 61 
 62 LayoutBoxExtent NinePieceImage::computeSlices(const LayoutSize&amp; size, const LengthBox&amp; lengths, int scaleFactor)
 63 {
 64     return {
 65         std::min(size.height(), valueForLength(lengths.top(), size.height())) * scaleFactor,
 66         std::min(size.width(), valueForLength(lengths.right(), size.width()))  * scaleFactor,
 67         std::min(size.height(), valueForLength(lengths.bottom(), size.height())) * scaleFactor,
 68         std::min(size.width(), valueForLength(lengths.left(), size.width()))  * scaleFactor
</pre>
<hr />
<pre>
133 
134     rects[MiddlePiece] = snapRectToDevicePixels(LayoutUnit(inner.x()), LayoutUnit(inner.y()), LayoutUnit(inner.width()), LayoutUnit(inner.height()), deviceScaleFactor);
135     return rects;
136 }
137 
138 FloatSize NinePieceImage::computeSideTileScale(ImagePiece piece, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects)
139 {
140     ASSERT(!isCornerPiece(piece) &amp;&amp; !isMiddlePiece(piece));
141     if (isEmptyPieceRect(piece, destinationRects, sourceRects))
142         return FloatSize(1, 1);
143 
144     float scale;
145     if (isHorizontalPiece(piece))
146         scale = destinationRects[piece].height() / sourceRects[piece].height();
147     else
148         scale = destinationRects[piece].width() / sourceRects[piece].width();
149 
150     return FloatSize(scale, scale);
151 }
152 
<span class="line-modified">153 FloatSize NinePieceImage::computeMiddleTileScale(const Vector&lt;FloatSize&gt;&amp; scales, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects, ENinePieceImageRule hRule, ENinePieceImageRule vRule)</span>
154 {
155     FloatSize scale(1, 1);
156     if (isEmptyPieceRect(MiddlePiece, destinationRects, sourceRects))
157         return scale;
158 
159     // Unlike the side pieces, the middle piece can have &quot;stretch&quot; specified in one axis but not the other.
160     // In fact the side pieces don&#39;t even use the scale factor unless they have a rule other than &quot;stretch&quot;.
<span class="line-modified">161     if (hRule == StretchImageRule)</span>
162         scale.setWidth(destinationRects[MiddlePiece].width() / sourceRects[MiddlePiece].width());
163     else if (!isEmptyPieceRect(TopPiece, destinationRects, sourceRects))
164         scale.setWidth(scales[TopPiece].width());
165     else if (!isEmptyPieceRect(BottomPiece, destinationRects, sourceRects))
166         scale.setWidth(scales[BottomPiece].width());
167 
<span class="line-modified">168     if (vRule == StretchImageRule)</span>
169         scale.setHeight(destinationRects[MiddlePiece].height() / sourceRects[MiddlePiece].height());
170     else if (!isEmptyPieceRect(LeftPiece, destinationRects, sourceRects))
171         scale.setHeight(scales[LeftPiece].height());
172     else if (!isEmptyPieceRect(RightPiece, destinationRects, sourceRects))
173         scale.setHeight(scales[RightPiece].height());
174 
175     return scale;
176 }
177 
<span class="line-modified">178 Vector&lt;FloatSize&gt; NinePieceImage::computeTileScales(const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects, ENinePieceImageRule hRule, ENinePieceImageRule vRule)</span>
179 {
180     Vector&lt;FloatSize&gt; scales(MaxPiece, FloatSize(1, 1));
181 
182     scales[TopPiece]    = computeSideTileScale(TopPiece,    destinationRects, sourceRects);
183     scales[RightPiece]  = computeSideTileScale(RightPiece,  destinationRects, sourceRects);
184     scales[BottomPiece] = computeSideTileScale(BottomPiece, destinationRects, sourceRects);
185     scales[LeftPiece]   = computeSideTileScale(LeftPiece,   destinationRects, sourceRects);
186 
187     scales[MiddlePiece] = computeMiddleTileScale(scales, destinationRects, sourceRects, hRule, vRule);
188     return scales;
189 }
190 
191 void NinePieceImage::paint(GraphicsContext&amp; graphicsContext, RenderElement* renderer, const RenderStyle&amp; style, const LayoutRect&amp; destination, const LayoutSize&amp; source, float deviceScaleFactor, CompositeOperator op) const
192 {
193     StyleImage* styleImage = image();
194     ASSERT(styleImage);
195     ASSERT(styleImage-&gt;isLoaded());
196 
197     LayoutBoxExtent sourceSlices = computeSlices(source, imageSlices(), styleImage-&gt;imageScaleFactor());
198     LayoutBoxExtent destinationSlices = computeSlices(destination.size(), borderSlices(), style.borderWidth(), sourceSlices);
199 
200     scaleSlicesIfNeeded(destination.size(), destinationSlices, deviceScaleFactor);
201 
202     Vector&lt;FloatRect&gt; destinationRects = computeNineRects(destination, destinationSlices, deviceScaleFactor);
203     Vector&lt;FloatRect&gt; sourceRects = computeNineRects(FloatRect(FloatPoint(), source), sourceSlices, deviceScaleFactor);
204     Vector&lt;FloatSize&gt; tileScales = computeTileScales(destinationRects, sourceRects, horizontalRule(), verticalRule());
205 
206     RefPtr&lt;Image&gt; image = styleImage-&gt;image(renderer, source);
207     if (!image)
208         return;
209 
210     InterpolationQualityMaintainer interpolationMaintainer(graphicsContext, ImageQualityController::interpolationQualityFromStyle(style));
211     for (ImagePiece piece = MinPiece; piece &lt; MaxPiece; ++piece) {
212         if ((piece == MiddlePiece &amp;&amp; !fill()) || isEmptyPieceRect(piece, destinationRects, sourceRects))
213             continue;
214 
215         if (isCornerPiece(piece)) {
<span class="line-modified">216             graphicsContext.drawImage(*image, destinationRects[piece], sourceRects[piece], op);</span>
217             continue;
218         }
219 
220         Image::TileRule hRule = isHorizontalPiece(piece) ? static_cast&lt;Image::TileRule&gt;(horizontalRule()) : Image::StretchTile;
221         Image::TileRule vRule = isVerticalPiece(piece) ? static_cast&lt;Image::TileRule&gt;(verticalRule()) : Image::StretchTile;
<span class="line-modified">222         graphicsContext.drawTiledImage(*image, destinationRects[piece], sourceRects[piece], tileScales[piece], hRule, vRule, op);</span>
223     }
224 }
225 
<span class="line-modified">226 inline NinePieceImage::Data::Data()</span>
<span class="line-removed">227     : fill(false)</span>
<span class="line-removed">228     , horizontalRule(StretchImageRule)</span>
<span class="line-removed">229     , verticalRule(StretchImageRule)</span>
<span class="line-removed">230 {</span>
<span class="line-removed">231 }</span>
232 
<span class="line-modified">233 inline NinePieceImage::Data::Data(RefPtr&lt;StyleImage&gt;&amp;&amp; image, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, ENinePieceImageRule horizontalRule, ENinePieceImageRule verticalRule)</span>
234     : fill(fill)
235     , horizontalRule(horizontalRule)
236     , verticalRule(verticalRule)
237     , image(WTFMove(image))
238     , imageSlices(imageSlices)
239     , borderSlices(borderSlices)
240     , outset(outset)
241 {
242 }
243 
244 inline NinePieceImage::Data::Data(const Data&amp; other)
245     : RefCounted&lt;Data&gt;()
246     , fill(other.fill)
247     , horizontalRule(other.horizontalRule)
248     , verticalRule(other.verticalRule)
249     , image(other.image)
250     , imageSlices(other.imageSlices)
251     , borderSlices(other.borderSlices)
252     , outset(other.outset)
253 {
254 }
255 
256 inline Ref&lt;NinePieceImage::Data&gt; NinePieceImage::Data::create()
257 {
258     return adoptRef(*new Data);
259 }
260 
<span class="line-modified">261 inline Ref&lt;NinePieceImage::Data&gt; NinePieceImage::Data::create(RefPtr&lt;StyleImage&gt;&amp;&amp; image, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, ENinePieceImageRule horizontalRule, ENinePieceImageRule verticalRule)</span>
262 {
263     return adoptRef(*new Data(WTFMove(image), imageSlices, fill, borderSlices, outset, horizontalRule, verticalRule));
264 }
265 
266 Ref&lt;NinePieceImage::Data&gt; NinePieceImage::Data::copy() const
267 {
268     return adoptRef(*new Data(*this));
269 }
270 
271 bool NinePieceImage::Data::operator==(const Data&amp; other) const
272 {
273     return arePointingToEqualData(image, other.image)
274         &amp;&amp; imageSlices == other.imageSlices
275         &amp;&amp; fill == other.fill
276         &amp;&amp; borderSlices == other.borderSlices
277         &amp;&amp; outset == other.outset
278         &amp;&amp; horizontalRule == other.horizontalRule
279         &amp;&amp; verticalRule == other.verticalRule;
280 }
281 
</pre>
</td>
<td>
<hr />
<pre>
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;NinePieceImage.h&quot;
 26 
 27 #include &quot;GraphicsContext.h&quot;
 28 #include &quot;ImageQualityController.h&quot;
 29 #include &quot;LengthFunctions.h&quot;
 30 #include &quot;RenderStyle.h&quot;
 31 #include &lt;wtf/NeverDestroyed.h&gt;
 32 #include &lt;wtf/PointerComparison.h&gt;
 33 #include &lt;wtf/text/TextStream.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 inline DataRef&lt;NinePieceImage::Data&gt;&amp; NinePieceImage::defaultData()
 38 {
 39     static NeverDestroyed&lt;DataRef&lt;Data&gt;&gt; data { Data::create() };
 40     return data.get();
 41 }
 42 
<span class="line-modified"> 43 inline DataRef&lt;NinePieceImage::Data&gt;&amp; NinePieceImage::defaultMaskData()</span>

 44 {
<span class="line-added"> 45     static NeverDestroyed&lt;DataRef&lt;Data&gt;&gt; maskData { Data::create() };</span>
<span class="line-added"> 46     auto&amp; data = maskData.get().access();</span>
<span class="line-added"> 47     data.imageSlices = LengthBox(0);</span>
<span class="line-added"> 48     data.fill = true;</span>
<span class="line-added"> 49     data.borderSlices = LengthBox();</span>
<span class="line-added"> 50     return maskData.get();</span>
 51 }
 52 
<span class="line-modified"> 53 NinePieceImage::NinePieceImage(Type imageType)</span>
<span class="line-added"> 54     : m_data(imageType == Type::Normal ? defaultData() : defaultMaskData())</span>
<span class="line-added"> 55 {</span>
<span class="line-added"> 56 }</span>
<span class="line-added"> 57 </span>
<span class="line-added"> 58 NinePieceImage::NinePieceImage(RefPtr&lt;StyleImage&gt;&amp;&amp; image, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, NinePieceImageRule horizontalRule, NinePieceImageRule verticalRule)</span>
 59     : m_data(Data::create(WTFMove(image), imageSlices, fill, borderSlices, outset, horizontalRule, verticalRule))
 60 {
 61 }
 62 
 63 LayoutUnit NinePieceImage::computeSlice(Length length, LayoutUnit width, LayoutUnit slice, LayoutUnit extent)
 64 {
 65     if (length.isRelative())
 66         return LayoutUnit(length.value() * width);
 67     if (length.isAuto())
 68         return slice;
 69     return valueForLength(length, extent);
 70 }
 71 
 72 LayoutBoxExtent NinePieceImage::computeSlices(const LayoutSize&amp; size, const LengthBox&amp; lengths, int scaleFactor)
 73 {
 74     return {
 75         std::min(size.height(), valueForLength(lengths.top(), size.height())) * scaleFactor,
 76         std::min(size.width(), valueForLength(lengths.right(), size.width()))  * scaleFactor,
 77         std::min(size.height(), valueForLength(lengths.bottom(), size.height())) * scaleFactor,
 78         std::min(size.width(), valueForLength(lengths.left(), size.width()))  * scaleFactor
</pre>
<hr />
<pre>
143 
144     rects[MiddlePiece] = snapRectToDevicePixels(LayoutUnit(inner.x()), LayoutUnit(inner.y()), LayoutUnit(inner.width()), LayoutUnit(inner.height()), deviceScaleFactor);
145     return rects;
146 }
147 
148 FloatSize NinePieceImage::computeSideTileScale(ImagePiece piece, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects)
149 {
150     ASSERT(!isCornerPiece(piece) &amp;&amp; !isMiddlePiece(piece));
151     if (isEmptyPieceRect(piece, destinationRects, sourceRects))
152         return FloatSize(1, 1);
153 
154     float scale;
155     if (isHorizontalPiece(piece))
156         scale = destinationRects[piece].height() / sourceRects[piece].height();
157     else
158         scale = destinationRects[piece].width() / sourceRects[piece].width();
159 
160     return FloatSize(scale, scale);
161 }
162 
<span class="line-modified">163 FloatSize NinePieceImage::computeMiddleTileScale(const Vector&lt;FloatSize&gt;&amp; scales, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects, NinePieceImageRule hRule, NinePieceImageRule vRule)</span>
164 {
165     FloatSize scale(1, 1);
166     if (isEmptyPieceRect(MiddlePiece, destinationRects, sourceRects))
167         return scale;
168 
169     // Unlike the side pieces, the middle piece can have &quot;stretch&quot; specified in one axis but not the other.
170     // In fact the side pieces don&#39;t even use the scale factor unless they have a rule other than &quot;stretch&quot;.
<span class="line-modified">171     if (hRule == NinePieceImageRule::Stretch)</span>
172         scale.setWidth(destinationRects[MiddlePiece].width() / sourceRects[MiddlePiece].width());
173     else if (!isEmptyPieceRect(TopPiece, destinationRects, sourceRects))
174         scale.setWidth(scales[TopPiece].width());
175     else if (!isEmptyPieceRect(BottomPiece, destinationRects, sourceRects))
176         scale.setWidth(scales[BottomPiece].width());
177 
<span class="line-modified">178     if (vRule == NinePieceImageRule::Stretch)</span>
179         scale.setHeight(destinationRects[MiddlePiece].height() / sourceRects[MiddlePiece].height());
180     else if (!isEmptyPieceRect(LeftPiece, destinationRects, sourceRects))
181         scale.setHeight(scales[LeftPiece].height());
182     else if (!isEmptyPieceRect(RightPiece, destinationRects, sourceRects))
183         scale.setHeight(scales[RightPiece].height());
184 
185     return scale;
186 }
187 
<span class="line-modified">188 Vector&lt;FloatSize&gt; NinePieceImage::computeTileScales(const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects, NinePieceImageRule hRule, NinePieceImageRule vRule)</span>
189 {
190     Vector&lt;FloatSize&gt; scales(MaxPiece, FloatSize(1, 1));
191 
192     scales[TopPiece]    = computeSideTileScale(TopPiece,    destinationRects, sourceRects);
193     scales[RightPiece]  = computeSideTileScale(RightPiece,  destinationRects, sourceRects);
194     scales[BottomPiece] = computeSideTileScale(BottomPiece, destinationRects, sourceRects);
195     scales[LeftPiece]   = computeSideTileScale(LeftPiece,   destinationRects, sourceRects);
196 
197     scales[MiddlePiece] = computeMiddleTileScale(scales, destinationRects, sourceRects, hRule, vRule);
198     return scales;
199 }
200 
201 void NinePieceImage::paint(GraphicsContext&amp; graphicsContext, RenderElement* renderer, const RenderStyle&amp; style, const LayoutRect&amp; destination, const LayoutSize&amp; source, float deviceScaleFactor, CompositeOperator op) const
202 {
203     StyleImage* styleImage = image();
204     ASSERT(styleImage);
205     ASSERT(styleImage-&gt;isLoaded());
206 
207     LayoutBoxExtent sourceSlices = computeSlices(source, imageSlices(), styleImage-&gt;imageScaleFactor());
208     LayoutBoxExtent destinationSlices = computeSlices(destination.size(), borderSlices(), style.borderWidth(), sourceSlices);
209 
210     scaleSlicesIfNeeded(destination.size(), destinationSlices, deviceScaleFactor);
211 
212     Vector&lt;FloatRect&gt; destinationRects = computeNineRects(destination, destinationSlices, deviceScaleFactor);
213     Vector&lt;FloatRect&gt; sourceRects = computeNineRects(FloatRect(FloatPoint(), source), sourceSlices, deviceScaleFactor);
214     Vector&lt;FloatSize&gt; tileScales = computeTileScales(destinationRects, sourceRects, horizontalRule(), verticalRule());
215 
216     RefPtr&lt;Image&gt; image = styleImage-&gt;image(renderer, source);
217     if (!image)
218         return;
219 
220     InterpolationQualityMaintainer interpolationMaintainer(graphicsContext, ImageQualityController::interpolationQualityFromStyle(style));
221     for (ImagePiece piece = MinPiece; piece &lt; MaxPiece; ++piece) {
222         if ((piece == MiddlePiece &amp;&amp; !fill()) || isEmptyPieceRect(piece, destinationRects, sourceRects))
223             continue;
224 
225         if (isCornerPiece(piece)) {
<span class="line-modified">226             graphicsContext.drawImage(*image, destinationRects[piece], sourceRects[piece], { op, ImageOrientation::FromImage });</span>
227             continue;
228         }
229 
230         Image::TileRule hRule = isHorizontalPiece(piece) ? static_cast&lt;Image::TileRule&gt;(horizontalRule()) : Image::StretchTile;
231         Image::TileRule vRule = isVerticalPiece(piece) ? static_cast&lt;Image::TileRule&gt;(verticalRule()) : Image::StretchTile;
<span class="line-modified">232         graphicsContext.drawTiledImage(*image, destinationRects[piece], sourceRects[piece], tileScales[piece], hRule, vRule, { op, ImageOrientation::FromImage });</span>
233     }
234 }
235 
<span class="line-modified">236 inline NinePieceImage::Data::Data() = default;</span>





237 
<span class="line-modified">238 inline NinePieceImage::Data::Data(RefPtr&lt;StyleImage&gt;&amp;&amp; image, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, NinePieceImageRule horizontalRule, NinePieceImageRule verticalRule)</span>
239     : fill(fill)
240     , horizontalRule(horizontalRule)
241     , verticalRule(verticalRule)
242     , image(WTFMove(image))
243     , imageSlices(imageSlices)
244     , borderSlices(borderSlices)
245     , outset(outset)
246 {
247 }
248 
249 inline NinePieceImage::Data::Data(const Data&amp; other)
250     : RefCounted&lt;Data&gt;()
251     , fill(other.fill)
252     , horizontalRule(other.horizontalRule)
253     , verticalRule(other.verticalRule)
254     , image(other.image)
255     , imageSlices(other.imageSlices)
256     , borderSlices(other.borderSlices)
257     , outset(other.outset)
258 {
259 }
260 
261 inline Ref&lt;NinePieceImage::Data&gt; NinePieceImage::Data::create()
262 {
263     return adoptRef(*new Data);
264 }
265 
<span class="line-modified">266 inline Ref&lt;NinePieceImage::Data&gt; NinePieceImage::Data::create(RefPtr&lt;StyleImage&gt;&amp;&amp; image, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, NinePieceImageRule horizontalRule, NinePieceImageRule verticalRule)</span>
267 {
268     return adoptRef(*new Data(WTFMove(image), imageSlices, fill, borderSlices, outset, horizontalRule, verticalRule));
269 }
270 
271 Ref&lt;NinePieceImage::Data&gt; NinePieceImage::Data::copy() const
272 {
273     return adoptRef(*new Data(*this));
274 }
275 
276 bool NinePieceImage::Data::operator==(const Data&amp; other) const
277 {
278     return arePointingToEqualData(image, other.image)
279         &amp;&amp; imageSlices == other.imageSlices
280         &amp;&amp; fill == other.fill
281         &amp;&amp; borderSlices == other.borderSlices
282         &amp;&amp; outset == other.outset
283         &amp;&amp; horizontalRule == other.horizontalRule
284         &amp;&amp; verticalRule == other.verticalRule;
285 }
286 
</pre>
</td>
</tr>
</table>
<center><a href="GridArea.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="NinePieceImage.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertRecord.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMConvertPromise.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertScheduledAction.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertRecord.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;IDLTypes.h&quot;
 29 #include &quot;JSDOMConvertStrings.h&quot;

 30 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 namespace Detail {
 35 
 36 template&lt;typename IDLStringType&gt;
 37 struct IdentifierConverter;
 38 
 39 template&lt;&gt; struct IdentifierConverter&lt;IDLDOMString&gt; {
<span class="line-modified"> 40     static String convert(JSC::ExecState&amp;, const JSC::Identifier&amp; identifier)</span>
 41     {
 42         return identifier.string();
 43     }
 44 };
 45 
 46 template&lt;&gt; struct IdentifierConverter&lt;IDLByteString&gt; {
<span class="line-modified"> 47     static String convert(JSC::ExecState&amp; state, const JSC::Identifier&amp; identifier)</span>
 48     {
<span class="line-modified"> 49         return identifierToByteString(state, identifier);</span>
 50     }
 51 };
 52 
 53 template&lt;&gt; struct IdentifierConverter&lt;IDLUSVString&gt; {
<span class="line-modified"> 54     static String convert(JSC::ExecState&amp; state, const JSC::Identifier&amp; identifier)</span>
 55     {
<span class="line-modified"> 56         return identifierToUSVString(state, identifier);</span>
 57     }
 58 };
 59 
 60 }
 61 
 62 template&lt;typename K, typename V&gt; struct Converter&lt;IDLRecord&lt;K, V&gt;&gt; : DefaultConverter&lt;IDLRecord&lt;K, V&gt;&gt; {
 63     using ReturnType = typename IDLRecord&lt;K, V&gt;::ImplementationType;
 64     using KeyType = typename K::ImplementationType;
 65     using ValueType = typename V::ImplementationType;
 66 
<span class="line-modified"> 67     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
 68     {
<span class="line-modified"> 69         auto&amp; vm = state.vm();</span>












 70         auto scope = DECLARE_THROW_SCOPE(vm);
 71 
 72         // 1. Let result be a new empty instance of record&lt;K, V&gt;.
 73         // 2. If Type(O) is Undefined or Null, return result.
 74         if (value.isUndefinedOrNull())
 75             return { };
 76 
 77         // 3. If Type(O) is not Object, throw a TypeError.
 78         if (!value.isObject()) {
<span class="line-modified"> 79             throwTypeError(&amp;state, scope);</span>
 80             return { };
 81         }
 82 
 83         JSC::JSObject* object = JSC::asObject(value);
 84 
 85         ReturnType result;
 86 
 87         // 4. Let keys be ? O.[[OwnPropertyKeys]]().
 88         JSC::PropertyNameArray keys(vm, JSC::PropertyNameMode::Strings, JSC::PrivateSymbolMode::Exclude);
<span class="line-modified"> 89         object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, &amp;state, keys, JSC::EnumerationMode(JSC::DontEnumPropertiesMode::Include));</span>
 90 
 91         RETURN_IF_EXCEPTION(scope, { });
 92 
 93         // 5. Repeat, for each element key of keys in List order:
 94         for (auto&amp; key : keys) {
 95             // 1. Let desc be ? O.[[GetOwnProperty]](key).
 96             JSC::PropertyDescriptor descriptor;
<span class="line-modified"> 97             bool didGetDescriptor = object-&gt;getOwnPropertyDescriptor(&amp;state, key, descriptor);</span>
 98             RETURN_IF_EXCEPTION(scope, { });
 99 
100             // 2. If desc is not undefined and desc.[[Enumerable]] is true:
101 
102             // It&#39;s necessary to filter enumerable here rather than using the default EnumerationMode,
103             // to prevent an observable extra [[GetOwnProperty]] operation in the case of ProxyObject records.
104             if (didGetDescriptor &amp;&amp; descriptor.enumerable()) {
105                 // 1. Let typedKey be key converted to an IDL value of type K.
<span class="line-modified">106                 auto typedKey = Detail::IdentifierConverter&lt;K&gt;::convert(state, key);</span>
107                 RETURN_IF_EXCEPTION(scope, { });
108 
109                 // 2. Let value be ? Get(O, key).
<span class="line-modified">110                 auto subValue = object-&gt;get(&amp;state, key);</span>
111                 RETURN_IF_EXCEPTION(scope, { });
112 
113                 // 3. Let typedValue be value converted to an IDL value of type V.
<span class="line-modified">114                 auto typedValue = Converter&lt;V&gt;::convert(state, subValue);</span>
115                 RETURN_IF_EXCEPTION(scope, { });
116 
117                 // 4. If typedKey is already a key in result, set its value to typedValue.
118                 // Note: This can happen when O is a proxy object.
119                 // FIXME: Handle this case.
120 
121                 // 5. Otherwise, append to result a mapping (typedKey, typedValue).
122                 result.append({ typedKey, typedValue });
123             }
124         }
125 
126         // 6. Return result.
127         return result;
128     }
129 };
130 
131 template&lt;typename K, typename V&gt; struct JSConverter&lt;IDLRecord&lt;K, V&gt;&gt; {
132     static constexpr bool needsState = true;
133     static constexpr bool needsGlobalObject = true;
134 
135     template&lt;typename MapType&gt;
<span class="line-modified">136     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const MapType&amp; map)</span>
137     {
<span class="line-modified">138         auto&amp; vm = state.vm();</span>
139 
140         // 1. Let result be ! ObjectCreate(%ObjectPrototype%).
<span class="line-modified">141         auto result = constructEmptyObject(&amp;state, globalObject.objectPrototype());</span>
142 
143         // 2. Repeat, for each mapping (key, value) in D:
144         for (const auto&amp; keyValuePair : map) {
145             // 1. Let esKey be key converted to an ECMAScript value.
146             // Note, this step is not required, as we need the key to be
147             // an Identifier, not a JSValue.
148 
149             // 2. Let esValue be value converted to an ECMAScript value.
<span class="line-modified">150             auto esValue = toJS&lt;V&gt;(state, globalObject, keyValuePair.value);</span>
151 
152             // 3. Let created be ! CreateDataProperty(result, esKey, esValue).
153             bool created = result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, keyValuePair.key), esValue);
154 
155             // 4. Assert: created is true.
156             ASSERT_UNUSED(created, created);
157         }
158 
159         // 3. Return result.
160         return result;
161     }
162 };
163 
164 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;IDLTypes.h&quot;
 29 #include &quot;JSDOMConvertStrings.h&quot;
<span class="line-added"> 30 #include &quot;JSDOMGlobalObject.h&quot;</span>
 31 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
 32 
 33 namespace WebCore {
 34 
 35 namespace Detail {
 36 
 37 template&lt;typename IDLStringType&gt;
 38 struct IdentifierConverter;
 39 
 40 template&lt;&gt; struct IdentifierConverter&lt;IDLDOMString&gt; {
<span class="line-modified"> 41     static String convert(JSC::JSGlobalObject&amp;, const JSC::Identifier&amp; identifier)</span>
 42     {
 43         return identifier.string();
 44     }
 45 };
 46 
 47 template&lt;&gt; struct IdentifierConverter&lt;IDLByteString&gt; {
<span class="line-modified"> 48     static String convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, const JSC::Identifier&amp; identifier)</span>
 49     {
<span class="line-modified"> 50         return identifierToByteString(lexicalGlobalObject, identifier);</span>
 51     }
 52 };
 53 
 54 template&lt;&gt; struct IdentifierConverter&lt;IDLUSVString&gt; {
<span class="line-modified"> 55     static String convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, const JSC::Identifier&amp; identifier)</span>
 56     {
<span class="line-modified"> 57         return identifierToUSVString(lexicalGlobalObject, identifier);</span>
 58     }
 59 };
 60 
 61 }
 62 
 63 template&lt;typename K, typename V&gt; struct Converter&lt;IDLRecord&lt;K, V&gt;&gt; : DefaultConverter&lt;IDLRecord&lt;K, V&gt;&gt; {
 64     using ReturnType = typename IDLRecord&lt;K, V&gt;::ImplementationType;
 65     using KeyType = typename K::ImplementationType;
 66     using ValueType = typename V::ImplementationType;
 67 
<span class="line-modified"> 68     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, JSDOMGlobalObject&amp; globalObject)</span>
 69     {
<span class="line-modified"> 70         return convertRecord&lt;JSDOMGlobalObject&amp;&gt;(lexicalGlobalObject, value, globalObject);</span>
<span class="line-added"> 71     }</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
<span class="line-added"> 74     {</span>
<span class="line-added"> 75         return convertRecord(lexicalGlobalObject, value);</span>
<span class="line-added"> 76     }</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78 private:</span>
<span class="line-added"> 79     template&lt;class...Args&gt;</span>
<span class="line-added"> 80     static ReturnType convertRecord(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, Args ... args)</span>
<span class="line-added"> 81     {</span>
<span class="line-added"> 82         auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
 83         auto scope = DECLARE_THROW_SCOPE(vm);
 84 
 85         // 1. Let result be a new empty instance of record&lt;K, V&gt;.
 86         // 2. If Type(O) is Undefined or Null, return result.
 87         if (value.isUndefinedOrNull())
 88             return { };
 89 
 90         // 3. If Type(O) is not Object, throw a TypeError.
 91         if (!value.isObject()) {
<span class="line-modified"> 92             throwTypeError(&amp;lexicalGlobalObject, scope);</span>
 93             return { };
 94         }
 95 
 96         JSC::JSObject* object = JSC::asObject(value);
 97 
 98         ReturnType result;
 99 
100         // 4. Let keys be ? O.[[OwnPropertyKeys]]().
101         JSC::PropertyNameArray keys(vm, JSC::PropertyNameMode::Strings, JSC::PrivateSymbolMode::Exclude);
<span class="line-modified">102         object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, &amp;lexicalGlobalObject, keys, JSC::EnumerationMode(JSC::DontEnumPropertiesMode::Include));</span>
103 
104         RETURN_IF_EXCEPTION(scope, { });
105 
106         // 5. Repeat, for each element key of keys in List order:
107         for (auto&amp; key : keys) {
108             // 1. Let desc be ? O.[[GetOwnProperty]](key).
109             JSC::PropertyDescriptor descriptor;
<span class="line-modified">110             bool didGetDescriptor = object-&gt;getOwnPropertyDescriptor(&amp;lexicalGlobalObject, key, descriptor);</span>
111             RETURN_IF_EXCEPTION(scope, { });
112 
113             // 2. If desc is not undefined and desc.[[Enumerable]] is true:
114 
115             // It&#39;s necessary to filter enumerable here rather than using the default EnumerationMode,
116             // to prevent an observable extra [[GetOwnProperty]] operation in the case of ProxyObject records.
117             if (didGetDescriptor &amp;&amp; descriptor.enumerable()) {
118                 // 1. Let typedKey be key converted to an IDL value of type K.
<span class="line-modified">119                 auto typedKey = Detail::IdentifierConverter&lt;K&gt;::convert(lexicalGlobalObject, key);</span>
120                 RETURN_IF_EXCEPTION(scope, { });
121 
122                 // 2. Let value be ? Get(O, key).
<span class="line-modified">123                 auto subValue = object-&gt;get(&amp;lexicalGlobalObject, key);</span>
124                 RETURN_IF_EXCEPTION(scope, { });
125 
126                 // 3. Let typedValue be value converted to an IDL value of type V.
<span class="line-modified">127                 auto typedValue = Converter&lt;V&gt;::convert(lexicalGlobalObject, subValue, args...);</span>
128                 RETURN_IF_EXCEPTION(scope, { });
129 
130                 // 4. If typedKey is already a key in result, set its value to typedValue.
131                 // Note: This can happen when O is a proxy object.
132                 // FIXME: Handle this case.
133 
134                 // 5. Otherwise, append to result a mapping (typedKey, typedValue).
135                 result.append({ typedKey, typedValue });
136             }
137         }
138 
139         // 6. Return result.
140         return result;
141     }
142 };
143 
144 template&lt;typename K, typename V&gt; struct JSConverter&lt;IDLRecord&lt;K, V&gt;&gt; {
145     static constexpr bool needsState = true;
146     static constexpr bool needsGlobalObject = true;
147 
148     template&lt;typename MapType&gt;
<span class="line-modified">149     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const MapType&amp; map)</span>
150     {
<span class="line-modified">151         auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
152 
153         // 1. Let result be ! ObjectCreate(%ObjectPrototype%).
<span class="line-modified">154         auto result = constructEmptyObject(&amp;lexicalGlobalObject, globalObject.objectPrototype());</span>
155 
156         // 2. Repeat, for each mapping (key, value) in D:
157         for (const auto&amp; keyValuePair : map) {
158             // 1. Let esKey be key converted to an ECMAScript value.
159             // Note, this step is not required, as we need the key to be
160             // an Identifier, not a JSValue.
161 
162             // 2. Let esValue be value converted to an ECMAScript value.
<span class="line-modified">163             auto esValue = toJS&lt;V&gt;(lexicalGlobalObject, globalObject, keyValuePair.value);</span>
164 
165             // 3. Let created be ! CreateDataProperty(result, esKey, esValue).
166             bool created = result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, keyValuePair.key), esValue);
167 
168             // 4. Assert: created is true.
169             ASSERT_UNUSED(created, created);
170         }
171 
172         // 3. Return result.
173         return result;
174     }
175 };
176 
177 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="JSDOMConvertPromise.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertScheduledAction.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
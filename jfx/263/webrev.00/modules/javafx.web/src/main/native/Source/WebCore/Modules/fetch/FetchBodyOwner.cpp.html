<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchBodyOwner.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Canon Inc.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted, provided that the following conditions
  6  * are required to be met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Canon Inc. nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY CANON INC. AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL CANON INC. AND ITS CONTRIBUTORS BE LIABLE FOR
 21  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 22  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 23  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 24  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 25  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;FetchBodyOwner.h&quot;
 31 
 32 #include &quot;Document.h&quot;
 33 #include &quot;FetchLoader.h&quot;
 34 #include &quot;HTTPParsers.h&quot;
 35 #include &quot;JSBlob.h&quot;
 36 #include &quot;ResourceError.h&quot;
 37 #include &quot;ResourceResponse.h&quot;
 38 #include &quot;WindowEventLoop.h&quot;
 39 
 40 namespace WebCore {
 41 
 42 FetchBodyOwner::FetchBodyOwner(ScriptExecutionContext&amp; context, Optional&lt;FetchBody&gt;&amp;&amp; body, Ref&lt;FetchHeaders&gt;&amp;&amp; headers)
 43     : ActiveDOMObject(&amp;context)
 44     , m_body(WTFMove(body))
 45     , m_headers(WTFMove(headers))
 46 {
 47     suspendIfNeeded();
 48 }
 49 
 50 FetchBodyOwner::~FetchBodyOwner()
 51 {
 52     if (m_readableStreamSource)
 53         m_readableStreamSource-&gt;detach();
 54 }
 55 
 56 void FetchBodyOwner::stop()
 57 {
 58     if (m_body)
 59         m_body-&gt;cleanConsumer();
 60 
 61     if (m_blobLoader) {
 62         bool isUniqueReference = hasOneRef();
 63         if (m_blobLoader-&gt;loader)
 64             m_blobLoader-&gt;loader-&gt;stop();
 65         // After that point, &#39;this&#39; may be destroyed, since unsetPendingActivity should have been called.
 66         ASSERT_UNUSED(isUniqueReference, isUniqueReference || !m_blobLoader);
 67     }
 68 }
 69 
 70 bool FetchBodyOwner::isDisturbed() const
 71 {
 72     if (isBodyNull())
 73         return false;
 74 
 75     if (m_isDisturbed)
 76         return true;
 77 
 78 #if ENABLE(STREAMS_API)
 79     if (body().readableStream())
 80         return body().readableStream()-&gt;isDisturbed();
 81 #endif
 82 
 83     return false;
 84 }
 85 
 86 bool FetchBodyOwner::isDisturbedOrLocked() const
 87 {
 88     if (isBodyNull())
 89         return false;
 90 
 91     if (m_isDisturbed)
 92         return true;
 93 
 94 #if ENABLE(STREAMS_API)
 95     if (body().readableStream())
 96         return body().readableStream()-&gt;isDisturbed() || body().readableStream()-&gt;isLocked();
 97 #endif
 98 
 99     return false;
100 }
101 
102 void FetchBodyOwner::arrayBuffer(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
103 {
104     if (auto exception = loadingException()) {
105         promise-&gt;reject(*exception);
106         return;
107     }
108 
109     if (isBodyNullOrOpaque()) {
110         fulfillPromiseWithArrayBuffer(WTFMove(promise), nullptr, 0);
111         return;
112     }
113     if (isDisturbedOrLocked()) {
114         promise-&gt;reject(Exception { TypeError, &quot;Body is disturbed or locked&quot;_s });
115         return;
116     }
117     m_isDisturbed = true;
118     m_body-&gt;arrayBuffer(*this, WTFMove(promise));
119 }
120 
121 void FetchBodyOwner::blob(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
122 {
123     if (auto exception = loadingException()) {
124         promise-&gt;reject(*exception);
125         return;
126     }
127 
128     if (isBodyNullOrOpaque()) {
129         promise-&gt;resolveCallbackValueWithNewlyCreated&lt;IDLInterface&lt;Blob&gt;&gt;([this](auto&amp;) {
130             return Blob::create(Vector&lt;uint8_t&gt; { }, Blob::normalizedContentType(extractMIMETypeFromMediaType(m_contentType)));
131         });
132         return;
133     }
134     if (isDisturbedOrLocked()) {
135         promise-&gt;reject(Exception { TypeError, &quot;Body is disturbed or locked&quot;_s });
136         return;
137     }
138     m_isDisturbed = true;
139     m_body-&gt;blob(*this, WTFMove(promise), m_contentType);
140 }
141 
142 void FetchBodyOwner::cloneBody(FetchBodyOwner&amp; owner)
143 {
144     m_loadingError = owner.m_loadingError;
145 
146     m_contentType = owner.m_contentType;
147     if (owner.isBodyNull())
148         return;
149     m_body = owner.m_body-&gt;clone();
150 }
151 
152 ExceptionOr&lt;void&gt; FetchBodyOwner::extractBody(FetchBody::Init&amp;&amp; value)
153 {
154     auto result = FetchBody::extract(WTFMove(value), m_contentType);
155     if (result.hasException())
156         return result.releaseException();
157     m_body = result.releaseReturnValue();
158     return { };
159 }
160 
161 void FetchBodyOwner::updateContentType()
162 {
163     String contentType = m_headers-&gt;fastGet(HTTPHeaderName::ContentType);
164     if (!contentType.isNull()) {
165         m_contentType = WTFMove(contentType);
166         return;
167     }
168     if (!m_contentType.isNull())
169         m_headers-&gt;fastSet(HTTPHeaderName::ContentType, m_contentType);
170 }
171 
172 void FetchBodyOwner::consumeOnceLoadingFinished(FetchBodyConsumer::Type type, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
173 {
174     if (isDisturbedOrLocked()) {
175         promise-&gt;reject(Exception { TypeError, &quot;Body is disturbed or locked&quot;_s });
176         return;
177     }
178     m_isDisturbed = true;
179     m_body-&gt;consumeOnceLoadingFinished(type, WTFMove(promise), m_contentType);
180 }
181 
182 void FetchBodyOwner::formData(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
183 {
184     if (auto exception = loadingException()) {
185         promise-&gt;reject(*exception);
186         return;
187     }
188 
189     if (isBodyNullOrOpaque()) {
190         promise-&gt;reject();
191         return;
192     }
193     if (isDisturbedOrLocked()) {
194         promise-&gt;reject(Exception { TypeError, &quot;Body is disturbed or locked&quot;_s });
195         return;
196     }
197     m_isDisturbed = true;
198     m_body-&gt;formData(*this, WTFMove(promise));
199 }
200 
201 void FetchBodyOwner::json(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
202 {
203     if (auto exception = loadingException()) {
204         promise-&gt;reject(*exception);
205         return;
206     }
207 
208     if (isBodyNullOrOpaque()) {
209         promise-&gt;reject(SyntaxError);
210         return;
211     }
212     if (isDisturbedOrLocked()) {
213         promise-&gt;reject(Exception { TypeError, &quot;Body is disturbed or locked&quot;_s });
214         return;
215     }
216     m_isDisturbed = true;
217     m_body-&gt;json(*this, WTFMove(promise));
218 }
219 
220 void FetchBodyOwner::text(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
221 {
222     if (auto exception = loadingException()) {
223         promise-&gt;reject(*exception);
224         return;
225     }
226 
227     if (isBodyNullOrOpaque()) {
228         promise-&gt;resolve&lt;IDLDOMString&gt;({ });
229         return;
230     }
231     if (isDisturbedOrLocked()) {
232         promise-&gt;reject(Exception { TypeError, &quot;Body is disturbed or locked&quot;_s });
233         return;
234     }
235     m_isDisturbed = true;
236     m_body-&gt;text(*this, WTFMove(promise));
237 }
238 
239 void FetchBodyOwner::loadBlob(const Blob&amp; blob, FetchBodyConsumer* consumer)
240 {
241     // Can only be called once for a body instance.
242     ASSERT(!m_blobLoader);
243     ASSERT(!isBodyNull());
244 
245     if (!scriptExecutionContext()) {
246         m_body-&gt;loadingFailed(Exception { TypeError, &quot;Blob loading failed&quot;_s});
247         return;
248     }
249 
250     m_blobLoader.emplace(*this);
251     m_blobLoader-&gt;loader = makeUnique&lt;FetchLoader&gt;(*m_blobLoader, consumer);
252 
253     m_blobLoader-&gt;loader-&gt;start(*scriptExecutionContext(), blob);
254     if (!m_blobLoader-&gt;loader-&gt;isStarted()) {
255         m_body-&gt;loadingFailed(Exception { TypeError, &quot;Blob loading failed&quot;_s});
256         m_blobLoader = WTF::nullopt;
257         return;
258     }
259     setPendingActivity(*this);
260 }
261 
262 void FetchBodyOwner::finishBlobLoading()
263 {
264     ASSERT(m_blobLoader);
265 
266     m_blobLoader = WTF::nullopt;
267     unsetPendingActivity(*this);
268 }
269 
270 void FetchBodyOwner::blobLoadingSucceeded()
271 {
272     ASSERT(!isBodyNull());
273 #if ENABLE(STREAMS_API)
274     if (m_readableStreamSource) {
275         m_readableStreamSource-&gt;close();
276         m_readableStreamSource = nullptr;
277     }
278 #endif
279     m_body-&gt;loadingSucceeded();
280     finishBlobLoading();
281 }
282 
283 void FetchBodyOwner::blobLoadingFailed()
284 {
285     ASSERT(!isBodyNull());
286 #if ENABLE(STREAMS_API)
287     if (m_readableStreamSource) {
288         if (!m_readableStreamSource-&gt;isCancelling())
289             m_readableStreamSource-&gt;error(Exception { TypeError, &quot;Blob loading failed&quot;_s});
290         m_readableStreamSource = nullptr;
291     } else
292 #endif
293         m_body-&gt;loadingFailed(Exception { TypeError, &quot;Blob loading failed&quot;_s});
294     finishBlobLoading();
295 }
296 
297 void FetchBodyOwner::blobChunk(const char* data, size_t size)
298 {
299     ASSERT(data);
300 #if ENABLE(STREAMS_API)
301     ASSERT(m_readableStreamSource);
302     if (!m_readableStreamSource-&gt;enqueue(ArrayBuffer::tryCreate(data, size)))
303         stop();
304 #else
305     UNUSED_PARAM(data);
306     UNUSED_PARAM(size);
307 #endif
308 }
309 
310 FetchBodyOwner::BlobLoader::BlobLoader(FetchBodyOwner&amp; owner)
311     : owner(owner)
312 {
313 }
314 
315 void FetchBodyOwner::BlobLoader::didReceiveResponse(const ResourceResponse&amp; response)
316 {
317     if (response.httpStatusCode() != 200)
318         didFail({ });
319 }
320 
321 void FetchBodyOwner::BlobLoader::didFail(const ResourceError&amp;)
322 {
323     // didFail might be called within FetchLoader::start call.
324     if (loader-&gt;isStarted())
325         owner.blobLoadingFailed();
326 }
327 
328 RefPtr&lt;ReadableStream&gt; FetchBodyOwner::readableStream(JSC::JSGlobalObject&amp; state)
329 {
330     if (isBodyNullOrOpaque())
331         return nullptr;
332 
333     if (!m_body-&gt;hasReadableStream())
334         createReadableStream(state);
335 
336     return m_body-&gt;readableStream();
337 }
338 
339 void FetchBodyOwner::createReadableStream(JSC::JSGlobalObject&amp; state)
340 {
341     ASSERT(!m_readableStreamSource);
342     if (isDisturbed()) {
343         m_body-&gt;setReadableStream(ReadableStream::create(state, nullptr));
344         m_body-&gt;readableStream()-&gt;lock();
345     } else {
346         m_readableStreamSource = adoptRef(*new FetchBodySource(*this));
347         m_body-&gt;setReadableStream(ReadableStream::create(state, m_readableStreamSource));
348     }
349 }
350 
351 void FetchBodyOwner::consumeBodyAsStream()
352 {
353     ASSERT(m_readableStreamSource);
354 
355     if (auto exception = loadingException()) {
356         m_readableStreamSource-&gt;error(*exception);
357         return;
358     }
359 
360     body().consumeAsStream(*this, *m_readableStreamSource);
361     if (!m_readableStreamSource-&gt;isPulling())
362         m_readableStreamSource = nullptr;
363 }
364 
365 ResourceError FetchBodyOwner::loadingError() const
366 {
367     return WTF::switchOn(m_loadingError, [](const ResourceError&amp; error) {
368         return ResourceError { error };
369     }, [](const Exception&amp; exception) {
370         return ResourceError { errorDomainWebKitInternal, 0, { }, exception.message() };
371     }, [](auto&amp;&amp;) {
372         return ResourceError { };
373     });
374 }
375 
376 Optional&lt;Exception&gt; FetchBodyOwner::loadingException() const
377 {
378     return WTF::switchOn(m_loadingError, [](const ResourceError&amp; error) {
379         return Exception { TypeError, error.localizedDescription().isEmpty() ? &quot;Loading failed&quot;_s : error.localizedDescription() };
380     }, [](const Exception&amp; exception) {
381         return Exception { exception };
382     }, [](auto&amp;&amp;) -&gt; Optional&lt;Exception&gt; {
383         return WTF::nullopt;
384     });
385 }
386 
387 bool FetchBodyOwner::hasLoadingError() const
388 {
389     return WTF::switchOn(m_loadingError, [](const ResourceError&amp;) {
390         return true;
391     }, [](const Exception&amp;) {
392         return true;
393     }, [](auto&amp;&amp;) {
394         return false;
395     });
396 }
397 
398 void FetchBodyOwner::setLoadingError(Exception&amp;&amp; exception)
399 {
400     if (hasLoadingError())
401         return;
402 
403     m_loadingError = WTFMove(exception);
404 }
405 
406 void FetchBodyOwner::setLoadingError(ResourceError&amp;&amp; error)
407 {
408     if (hasLoadingError())
409         return;
410 
411     m_loadingError = WTFMove(error);
412 }
413 
414 } // namespace WebCore
    </pre>
  </body>
</html>
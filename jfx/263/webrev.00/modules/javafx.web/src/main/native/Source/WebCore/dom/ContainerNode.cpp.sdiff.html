<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/ContainerNode.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompositionEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ContainerNodeAlgorithms.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/ContainerNode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;GenericCachedHTMLCollection.h&quot;
 37 #include &quot;HTMLFormControlsCollection.h&quot;
 38 #include &quot;HTMLOptionsCollection.h&quot;
 39 #include &quot;HTMLSlotElement.h&quot;
 40 #include &quot;HTMLTableRowsCollection.h&quot;
 41 #include &quot;InlineTextBox.h&quot;
 42 #include &quot;InspectorInstrumentation.h&quot;
 43 #include &quot;JSNode.h&quot;
 44 #include &quot;LabelsNodeList.h&quot;
 45 #include &quot;MutationEvent.h&quot;
 46 #include &quot;NameNodeList.h&quot;
 47 #include &quot;NodeRareData.h&quot;
 48 #include &quot;NodeRenderStyle.h&quot;
 49 #include &quot;RadioNodeList.h&quot;
 50 #include &quot;RenderBox.h&quot;
 51 #include &quot;RenderTheme.h&quot;
 52 #include &quot;RenderTreeUpdater.h&quot;
 53 #include &quot;RenderWidget.h&quot;
 54 #include &quot;RootInlineBox.h&quot;
<span class="line-removed"> 55 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
 56 #include &quot;SVGDocumentExtensions.h&quot;
 57 #include &quot;SVGElement.h&quot;
 58 #include &quot;SVGNames.h&quot;
 59 #include &quot;SVGUseElement.h&quot;
 60 #include &quot;ScriptDisallowedScope.h&quot;
 61 #include &quot;SelectorQuery.h&quot;
 62 #include &quot;SlotAssignment.h&quot;
 63 #include &quot;TemplateContentDocumentFragment.h&quot;
 64 #include &lt;algorithm&gt;
 65 #include &lt;wtf/IsoMallocInlines.h&gt;
 66 #include &lt;wtf/Variant.h&gt;
 67 
 68 namespace WebCore {
 69 
 70 WTF_MAKE_ISO_ALLOCATED_IMPL(ContainerNode);
 71 
 72 static void dispatchChildInsertionEvents(Node&amp;);
 73 static void dispatchChildRemovalEvents(Ref&lt;Node&gt;&amp;);
 74 
 75 ChildNodesLazySnapshot* ChildNodesLazySnapshot::latestSnapshot;
 76 
 77 unsigned ScriptDisallowedScope::s_count = 0;
<span class="line-modified"> 78 #if !ASSERT_DISABLED</span>
 79 ScriptDisallowedScope::EventAllowedScope* ScriptDisallowedScope::EventAllowedScope::s_currentScope = nullptr;
 80 #endif
 81 
 82 ALWAYS_INLINE NodeVector ContainerNode::removeAllChildrenWithScriptAssertion(ChildChangeSource source, DeferChildrenChanged deferChildrenChanged)
 83 {
 84     auto children = collectChildNodes(*this);
 85 
 86     if (source == ContainerNode::ChildChangeSource::API) {
 87         ChildListMutationScope mutation(*this);
 88         for (auto&amp; child : children) {
 89             mutation.willRemoveChild(child.get());
 90             child-&gt;notifyMutationObserversNodeWillDetach();
 91             dispatchChildRemovalEvents(child);
 92         }
 93     } else {
 94         ASSERT(source == ContainerNode::ChildChangeSource::Parser);
 95         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
 96         if (UNLIKELY(document().hasMutationObserversOfType(MutationObserver::ChildList))) {
 97             ChildListMutationScope mutation(*this);
 98             for (auto&amp; child : children)
</pre>
<hr />
<pre>
294 
295 static bool containsIncludingHostElements(const Node&amp; possibleAncestor, const Node&amp; node)
296 {
297     const Node* currentNode = &amp;node;
298     do {
299         if (currentNode == &amp;possibleAncestor)
300             return true;
301         const ContainerNode* parent = currentNode-&gt;parentNode();
302         if (!parent) {
303             if (is&lt;ShadowRoot&gt;(currentNode))
304                 parent = downcast&lt;ShadowRoot&gt;(currentNode)-&gt;host();
305             else if (is&lt;DocumentFragment&gt;(*currentNode) &amp;&amp; downcast&lt;DocumentFragment&gt;(*currentNode).isTemplateContent())
306                 parent = static_cast&lt;const TemplateContentDocumentFragment*&gt;(currentNode)-&gt;host();
307         }
308         currentNode = parent;
309     } while (currentNode);
310 
311     return false;
312 }
313 
<span class="line-modified">314 static inline ExceptionOr&lt;void&gt; checkAcceptChild(ContainerNode&amp; newParent, Node&amp; newChild, const Node* refChild, Document::AcceptChildOperation operation)</span>

315 {
316     if (containsIncludingHostElements(newChild, newParent))
317         return Exception { HierarchyRequestError };
318 
319     // Use common case fast path if possible.
320     if ((newChild.isElementNode() || newChild.isTextNode()) &amp;&amp; newParent.isElementNode()) {
321         ASSERT(!newParent.isDocumentTypeNode());
322         ASSERT(isChildTypeAllowed(newParent, newChild));
<span class="line-modified">323         if (operation == Document::AcceptChildOperation::InsertOrAdd &amp;&amp; refChild &amp;&amp; refChild-&gt;parentNode() != &amp;newParent)</span>
324             return Exception { NotFoundError };
325         return { };
326     }
327 
328     // This should never happen, but also protect release builds from tree corruption.
329     ASSERT(!newChild.isPseudoElement());
330     if (newChild.isPseudoElement())
331         return Exception { HierarchyRequestError };
332 
<span class="line-modified">333     if (operation == Document::AcceptChildOperation::InsertOrAdd &amp;&amp; refChild &amp;&amp; refChild-&gt;parentNode() != &amp;newParent)</span>
334         return Exception { NotFoundError };
335 
336     if (is&lt;Document&gt;(newParent)) {
337         if (!downcast&lt;Document&gt;(newParent).canAcceptChild(newChild, refChild, operation))
338             return Exception { HierarchyRequestError };
339     } else if (!isChildTypeAllowed(newParent, newChild))
340         return Exception { HierarchyRequestError };
341 
342     return { };
343 }
344 
345 static inline ExceptionOr&lt;void&gt; checkAcceptChildGuaranteedNodeTypes(ContainerNode&amp; newParent, Node&amp; newChild)
346 {
347     ASSERT(!newParent.isDocumentTypeNode());
348     ASSERT(isChildTypeAllowed(newParent, newChild));
349     if (containsIncludingHostElements(newChild, newParent))
350         return Exception { HierarchyRequestError };
351     return { };
352 }
353 
354 // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
355 ExceptionOr&lt;void&gt; ContainerNode::ensurePreInsertionValidity(Node&amp; newChild, Node* refChild)
356 {
<span class="line-modified">357     return checkAcceptChild(*this, newChild, refChild, Document::AcceptChildOperation::InsertOrAdd);</span>
358 }
359 
360 // https://dom.spec.whatwg.org/#concept-node-replace
<span class="line-modified">361 static inline ExceptionOr&lt;void&gt; checkPreReplacementValidity(ContainerNode&amp; newParent, Node&amp; newChild, Node&amp; oldChild)</span>
362 {
<span class="line-modified">363     return checkAcceptChild(newParent, newChild, &amp;oldChild, Document::AcceptChildOperation::Replace);</span>
364 }
365 
366 ExceptionOr&lt;void&gt; ContainerNode::insertBefore(Node&amp; newChild, Node* refChild)
367 {
368     // Check that this node is not &quot;floating&quot;.
369     // If it is, it can be deleted as a side effect of sending mutation events.
370     ASSERT(refCount() || parentOrShadowHostNode());
371 
372     // Make sure adding the new child is OK.
373     auto validityCheckResult = ensurePreInsertionValidity(newChild, refChild);
374     if (validityCheckResult.hasException())
375         return validityCheckResult.releaseException();
376 
377     if (refChild == &amp;newChild)
378         refChild = newChild.nextSibling();
379 
380     // insertBefore(node, null) is equivalent to appendChild(node)
381     if (!refChild)
382         return appendChildWithoutPreInsertionValidityCheck(newChild);
383 
</pre>
<hr />
<pre>
472 
473     executeNodeInsertionWithScriptAssertion(*this, newChild, ChildChangeSource::Parser, ReplacedAllChildren::No, [&amp;] {
474         if (&amp;document() != &amp;newChild.document())
475             document().adoptNode(newChild);
476 
477         insertBeforeCommon(nextChild, newChild);
478 
479         newChild.updateAncestorConnectedSubframeCountForInsertion();
480     });
481 }
482 
483 ExceptionOr&lt;void&gt; ContainerNode::replaceChild(Node&amp; newChild, Node&amp; oldChild)
484 {
485     // Check that this node is not &quot;floating&quot;.
486     // If it is, it can be deleted as a side effect of sending mutation events.
487     ASSERT(refCount() || parentOrShadowHostNode());
488 
489     Ref&lt;ContainerNode&gt; protectedThis(*this);
490 
491     // Make sure replacing the old child with the new is ok
<span class="line-modified">492     auto validityResult = checkPreReplacementValidity(*this, newChild, oldChild);</span>
493     if (validityResult.hasException())
494         return validityResult.releaseException();
495 
<span class="line-removed">496     // NotFoundError: Raised if oldChild is not a child of this node.</span>
<span class="line-removed">497     if (oldChild.parentNode() != this)</span>
<span class="line-removed">498         return Exception { NotFoundError };</span>
<span class="line-removed">499 </span>
500     RefPtr&lt;Node&gt; refChild = oldChild.nextSibling();
501     if (refChild.get() == &amp;newChild)
502         refChild = refChild-&gt;nextSibling();
503 
504     NodeVector targets;
505     {
506         ChildListMutationScope mutation(*this);
507         auto collectResult = collectChildrenAndRemoveFromOldParent(newChild, targets);
508         if (collectResult.hasException())
509             return collectResult.releaseException();
510     }
511 
512     // Do this one more time because collectChildrenAndRemoveFromOldParent() fires a MutationEvent.
513     for (auto&amp; child : targets) {
<span class="line-modified">514         validityResult = checkPreReplacementValidity(*this, child, oldChild);</span>
515         if (validityResult.hasException())
516             return validityResult.releaseException();
517     }
518 
519     // Remove the node we&#39;re replacing.
520     Ref&lt;Node&gt; protectOldChild(oldChild);
521 
522     ChildListMutationScope mutation(*this);
523 
524     // If oldChild == newChild then oldChild no longer has a parent at this point.
525     if (oldChild.parentNode()) {
526         auto removeResult = removeChild(oldChild);
527         if (removeResult.hasException())
528             return removeResult.releaseException();
529 
530         // Does this one more time because removeChild() fires a MutationEvent.
531         for (auto&amp; child : targets) {
<span class="line-modified">532             validityResult = checkPreReplacementValidity(*this, child, oldChild);</span>
533             if (validityResult.hasException())
534                 return validityResult.releaseException();
535         }
536     }
537 
538     InspectorInstrumentation::willInsertDOMNode(document(), *this);
539 
540     // Add the new child(ren).
541     for (auto&amp; child : targets) {
542         // Due to arbitrary code running in response to a DOM mutation event it&#39;s
543         // possible that &quot;refChild&quot; is no longer a child of &quot;this&quot;.
544         // It&#39;s also possible that &quot;child&quot; has been inserted elsewhere.
545         // In either of those cases, we&#39;ll just stop.
546         if (refChild &amp;&amp; refChild-&gt;parentNode() != this)
547             break;
548         if (child-&gt;parentNode())
549             break;
550 
551         executeNodeInsertionWithScriptAssertion(*this, child.get(), ChildChangeSource::API, ReplacedAllChildren::No, [&amp;] {
552             child-&gt;setTreeScopeRecursively(treeScope());
</pre>
<hr />
<pre>
878 Ref&lt;HTMLCollection&gt; ContainerNode::getElementsByTagName(const AtomString&amp; qualifiedName)
879 {
880     ASSERT(!qualifiedName.isNull());
881 
882     if (qualifiedName == starAtom())
883         return ensureRareData().ensureNodeLists().addCachedCollection&lt;AllDescendantsCollection&gt;(*this, AllDescendants);
884 
885     if (document().isHTMLDocument())
886         return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLTagCollection&gt;(*this, ByHTMLTag, qualifiedName);
887     return ensureRareData().ensureNodeLists().addCachedCollection&lt;TagCollection&gt;(*this, ByTag, qualifiedName);
888 }
889 
890 Ref&lt;HTMLCollection&gt; ContainerNode::getElementsByTagNameNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName)
891 {
892     ASSERT(!localName.isNull());
893     return ensureRareData().ensureNodeLists().addCachedTagCollectionNS(*this, namespaceURI.isEmpty() ? nullAtom() : namespaceURI, localName);
894 }
895 
896 Ref&lt;NodeList&gt; ContainerNode::getElementsByName(const String&amp; elementName)
897 {
<span class="line-modified">898     return ensureRareData().ensureNodeLists().addCacheWithAtomicName&lt;NameNodeList&gt;(*this, elementName);</span>
899 }
900 
901 Ref&lt;HTMLCollection&gt; ContainerNode::getElementsByClassName(const AtomString&amp; classNames)
902 {
903     return ensureRareData().ensureNodeLists().addCachedCollection&lt;ClassCollection&gt;(*this, ByClass, classNames);
904 }
905 
906 Ref&lt;RadioNodeList&gt; ContainerNode::radioNodeList(const AtomString&amp; name)
907 {
908     ASSERT(hasTagName(HTMLNames::formTag) || hasTagName(HTMLNames::fieldsetTag));
<span class="line-modified">909     return ensureRareData().ensureNodeLists().addCacheWithAtomicName&lt;RadioNodeList&gt;(*this, name);</span>
910 }
911 
912 Ref&lt;HTMLCollection&gt; ContainerNode::children()
913 {
914     return ensureRareData().ensureNodeLists().addCachedCollection&lt;GenericCachedHTMLCollection&lt;CollectionTypeTraits&lt;NodeChildren&gt;::traversalType&gt;&gt;(*this, NodeChildren);
915 }
916 
917 Element* ContainerNode::firstElementChild() const
918 {
919     return ElementTraversal::firstChild(*this);
920 }
921 
922 Element* ContainerNode::lastElementChild() const
923 {
924     return ElementTraversal::lastChild(*this);
925 }
926 
927 unsigned ContainerNode::childElementCount() const
928 {
929     auto children = childrenOfType&lt;Element&gt;(*this);
</pre>
</td>
<td>
<hr />
<pre>
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;GenericCachedHTMLCollection.h&quot;
 37 #include &quot;HTMLFormControlsCollection.h&quot;
 38 #include &quot;HTMLOptionsCollection.h&quot;
 39 #include &quot;HTMLSlotElement.h&quot;
 40 #include &quot;HTMLTableRowsCollection.h&quot;
 41 #include &quot;InlineTextBox.h&quot;
 42 #include &quot;InspectorInstrumentation.h&quot;
 43 #include &quot;JSNode.h&quot;
 44 #include &quot;LabelsNodeList.h&quot;
 45 #include &quot;MutationEvent.h&quot;
 46 #include &quot;NameNodeList.h&quot;
 47 #include &quot;NodeRareData.h&quot;
 48 #include &quot;NodeRenderStyle.h&quot;
 49 #include &quot;RadioNodeList.h&quot;
 50 #include &quot;RenderBox.h&quot;
 51 #include &quot;RenderTheme.h&quot;
 52 #include &quot;RenderTreeUpdater.h&quot;
 53 #include &quot;RenderWidget.h&quot;
 54 #include &quot;RootInlineBox.h&quot;

 55 #include &quot;SVGDocumentExtensions.h&quot;
 56 #include &quot;SVGElement.h&quot;
 57 #include &quot;SVGNames.h&quot;
 58 #include &quot;SVGUseElement.h&quot;
 59 #include &quot;ScriptDisallowedScope.h&quot;
 60 #include &quot;SelectorQuery.h&quot;
 61 #include &quot;SlotAssignment.h&quot;
 62 #include &quot;TemplateContentDocumentFragment.h&quot;
 63 #include &lt;algorithm&gt;
 64 #include &lt;wtf/IsoMallocInlines.h&gt;
 65 #include &lt;wtf/Variant.h&gt;
 66 
 67 namespace WebCore {
 68 
 69 WTF_MAKE_ISO_ALLOCATED_IMPL(ContainerNode);
 70 
 71 static void dispatchChildInsertionEvents(Node&amp;);
 72 static void dispatchChildRemovalEvents(Ref&lt;Node&gt;&amp;);
 73 
 74 ChildNodesLazySnapshot* ChildNodesLazySnapshot::latestSnapshot;
 75 
 76 unsigned ScriptDisallowedScope::s_count = 0;
<span class="line-modified"> 77 #if ASSERT_ENABLED</span>
 78 ScriptDisallowedScope::EventAllowedScope* ScriptDisallowedScope::EventAllowedScope::s_currentScope = nullptr;
 79 #endif
 80 
 81 ALWAYS_INLINE NodeVector ContainerNode::removeAllChildrenWithScriptAssertion(ChildChangeSource source, DeferChildrenChanged deferChildrenChanged)
 82 {
 83     auto children = collectChildNodes(*this);
 84 
 85     if (source == ContainerNode::ChildChangeSource::API) {
 86         ChildListMutationScope mutation(*this);
 87         for (auto&amp; child : children) {
 88             mutation.willRemoveChild(child.get());
 89             child-&gt;notifyMutationObserversNodeWillDetach();
 90             dispatchChildRemovalEvents(child);
 91         }
 92     } else {
 93         ASSERT(source == ContainerNode::ChildChangeSource::Parser);
 94         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
 95         if (UNLIKELY(document().hasMutationObserversOfType(MutationObserver::ChildList))) {
 96             ChildListMutationScope mutation(*this);
 97             for (auto&amp; child : children)
</pre>
<hr />
<pre>
293 
294 static bool containsIncludingHostElements(const Node&amp; possibleAncestor, const Node&amp; node)
295 {
296     const Node* currentNode = &amp;node;
297     do {
298         if (currentNode == &amp;possibleAncestor)
299             return true;
300         const ContainerNode* parent = currentNode-&gt;parentNode();
301         if (!parent) {
302             if (is&lt;ShadowRoot&gt;(currentNode))
303                 parent = downcast&lt;ShadowRoot&gt;(currentNode)-&gt;host();
304             else if (is&lt;DocumentFragment&gt;(*currentNode) &amp;&amp; downcast&lt;DocumentFragment&gt;(*currentNode).isTemplateContent())
305                 parent = static_cast&lt;const TemplateContentDocumentFragment*&gt;(currentNode)-&gt;host();
306         }
307         currentNode = parent;
308     } while (currentNode);
309 
310     return false;
311 }
312 
<span class="line-modified">313 enum class ShouldValidateChildParent { No, Yes };</span>
<span class="line-added">314 static inline ExceptionOr&lt;void&gt; checkAcceptChild(ContainerNode&amp; newParent, Node&amp; newChild, const Node* refChild, Document::AcceptChildOperation operation, ShouldValidateChildParent shouldValidateChildParent)</span>
315 {
316     if (containsIncludingHostElements(newChild, newParent))
317         return Exception { HierarchyRequestError };
318 
319     // Use common case fast path if possible.
320     if ((newChild.isElementNode() || newChild.isTextNode()) &amp;&amp; newParent.isElementNode()) {
321         ASSERT(!newParent.isDocumentTypeNode());
322         ASSERT(isChildTypeAllowed(newParent, newChild));
<span class="line-modified">323         if (shouldValidateChildParent == ShouldValidateChildParent::Yes &amp;&amp; refChild &amp;&amp; refChild-&gt;parentNode() != &amp;newParent)</span>
324             return Exception { NotFoundError };
325         return { };
326     }
327 
328     // This should never happen, but also protect release builds from tree corruption.
329     ASSERT(!newChild.isPseudoElement());
330     if (newChild.isPseudoElement())
331         return Exception { HierarchyRequestError };
332 
<span class="line-modified">333     if (shouldValidateChildParent == ShouldValidateChildParent::Yes &amp;&amp; refChild &amp;&amp; refChild-&gt;parentNode() != &amp;newParent)</span>
334         return Exception { NotFoundError };
335 
336     if (is&lt;Document&gt;(newParent)) {
337         if (!downcast&lt;Document&gt;(newParent).canAcceptChild(newChild, refChild, operation))
338             return Exception { HierarchyRequestError };
339     } else if (!isChildTypeAllowed(newParent, newChild))
340         return Exception { HierarchyRequestError };
341 
342     return { };
343 }
344 
345 static inline ExceptionOr&lt;void&gt; checkAcceptChildGuaranteedNodeTypes(ContainerNode&amp; newParent, Node&amp; newChild)
346 {
347     ASSERT(!newParent.isDocumentTypeNode());
348     ASSERT(isChildTypeAllowed(newParent, newChild));
349     if (containsIncludingHostElements(newChild, newParent))
350         return Exception { HierarchyRequestError };
351     return { };
352 }
353 
354 // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
355 ExceptionOr&lt;void&gt; ContainerNode::ensurePreInsertionValidity(Node&amp; newChild, Node* refChild)
356 {
<span class="line-modified">357     return checkAcceptChild(*this, newChild, refChild, Document::AcceptChildOperation::InsertOrAdd, ShouldValidateChildParent::Yes);</span>
358 }
359 
360 // https://dom.spec.whatwg.org/#concept-node-replace
<span class="line-modified">361 static inline ExceptionOr&lt;void&gt; checkPreReplacementValidity(ContainerNode&amp; newParent, Node&amp; newChild, Node&amp; oldChild, ShouldValidateChildParent shouldValidateChildParent)</span>
362 {
<span class="line-modified">363     return checkAcceptChild(newParent, newChild, &amp;oldChild, Document::AcceptChildOperation::Replace, shouldValidateChildParent);</span>
364 }
365 
366 ExceptionOr&lt;void&gt; ContainerNode::insertBefore(Node&amp; newChild, Node* refChild)
367 {
368     // Check that this node is not &quot;floating&quot;.
369     // If it is, it can be deleted as a side effect of sending mutation events.
370     ASSERT(refCount() || parentOrShadowHostNode());
371 
372     // Make sure adding the new child is OK.
373     auto validityCheckResult = ensurePreInsertionValidity(newChild, refChild);
374     if (validityCheckResult.hasException())
375         return validityCheckResult.releaseException();
376 
377     if (refChild == &amp;newChild)
378         refChild = newChild.nextSibling();
379 
380     // insertBefore(node, null) is equivalent to appendChild(node)
381     if (!refChild)
382         return appendChildWithoutPreInsertionValidityCheck(newChild);
383 
</pre>
<hr />
<pre>
472 
473     executeNodeInsertionWithScriptAssertion(*this, newChild, ChildChangeSource::Parser, ReplacedAllChildren::No, [&amp;] {
474         if (&amp;document() != &amp;newChild.document())
475             document().adoptNode(newChild);
476 
477         insertBeforeCommon(nextChild, newChild);
478 
479         newChild.updateAncestorConnectedSubframeCountForInsertion();
480     });
481 }
482 
483 ExceptionOr&lt;void&gt; ContainerNode::replaceChild(Node&amp; newChild, Node&amp; oldChild)
484 {
485     // Check that this node is not &quot;floating&quot;.
486     // If it is, it can be deleted as a side effect of sending mutation events.
487     ASSERT(refCount() || parentOrShadowHostNode());
488 
489     Ref&lt;ContainerNode&gt; protectedThis(*this);
490 
491     // Make sure replacing the old child with the new is ok
<span class="line-modified">492     auto validityResult = checkPreReplacementValidity(*this, newChild, oldChild, ShouldValidateChildParent::Yes);</span>
493     if (validityResult.hasException())
494         return validityResult.releaseException();
495 




496     RefPtr&lt;Node&gt; refChild = oldChild.nextSibling();
497     if (refChild.get() == &amp;newChild)
498         refChild = refChild-&gt;nextSibling();
499 
500     NodeVector targets;
501     {
502         ChildListMutationScope mutation(*this);
503         auto collectResult = collectChildrenAndRemoveFromOldParent(newChild, targets);
504         if (collectResult.hasException())
505             return collectResult.releaseException();
506     }
507 
508     // Do this one more time because collectChildrenAndRemoveFromOldParent() fires a MutationEvent.
509     for (auto&amp; child : targets) {
<span class="line-modified">510         validityResult = checkPreReplacementValidity(*this, child, oldChild, ShouldValidateChildParent::No);</span>
511         if (validityResult.hasException())
512             return validityResult.releaseException();
513     }
514 
515     // Remove the node we&#39;re replacing.
516     Ref&lt;Node&gt; protectOldChild(oldChild);
517 
518     ChildListMutationScope mutation(*this);
519 
520     // If oldChild == newChild then oldChild no longer has a parent at this point.
521     if (oldChild.parentNode()) {
522         auto removeResult = removeChild(oldChild);
523         if (removeResult.hasException())
524             return removeResult.releaseException();
525 
526         // Does this one more time because removeChild() fires a MutationEvent.
527         for (auto&amp; child : targets) {
<span class="line-modified">528             validityResult = checkPreReplacementValidity(*this, child, oldChild, ShouldValidateChildParent::No);</span>
529             if (validityResult.hasException())
530                 return validityResult.releaseException();
531         }
532     }
533 
534     InspectorInstrumentation::willInsertDOMNode(document(), *this);
535 
536     // Add the new child(ren).
537     for (auto&amp; child : targets) {
538         // Due to arbitrary code running in response to a DOM mutation event it&#39;s
539         // possible that &quot;refChild&quot; is no longer a child of &quot;this&quot;.
540         // It&#39;s also possible that &quot;child&quot; has been inserted elsewhere.
541         // In either of those cases, we&#39;ll just stop.
542         if (refChild &amp;&amp; refChild-&gt;parentNode() != this)
543             break;
544         if (child-&gt;parentNode())
545             break;
546 
547         executeNodeInsertionWithScriptAssertion(*this, child.get(), ChildChangeSource::API, ReplacedAllChildren::No, [&amp;] {
548             child-&gt;setTreeScopeRecursively(treeScope());
</pre>
<hr />
<pre>
874 Ref&lt;HTMLCollection&gt; ContainerNode::getElementsByTagName(const AtomString&amp; qualifiedName)
875 {
876     ASSERT(!qualifiedName.isNull());
877 
878     if (qualifiedName == starAtom())
879         return ensureRareData().ensureNodeLists().addCachedCollection&lt;AllDescendantsCollection&gt;(*this, AllDescendants);
880 
881     if (document().isHTMLDocument())
882         return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLTagCollection&gt;(*this, ByHTMLTag, qualifiedName);
883     return ensureRareData().ensureNodeLists().addCachedCollection&lt;TagCollection&gt;(*this, ByTag, qualifiedName);
884 }
885 
886 Ref&lt;HTMLCollection&gt; ContainerNode::getElementsByTagNameNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName)
887 {
888     ASSERT(!localName.isNull());
889     return ensureRareData().ensureNodeLists().addCachedTagCollectionNS(*this, namespaceURI.isEmpty() ? nullAtom() : namespaceURI, localName);
890 }
891 
892 Ref&lt;NodeList&gt; ContainerNode::getElementsByName(const String&amp; elementName)
893 {
<span class="line-modified">894     return ensureRareData().ensureNodeLists().addCacheWithAtomName&lt;NameNodeList&gt;(*this, elementName);</span>
895 }
896 
897 Ref&lt;HTMLCollection&gt; ContainerNode::getElementsByClassName(const AtomString&amp; classNames)
898 {
899     return ensureRareData().ensureNodeLists().addCachedCollection&lt;ClassCollection&gt;(*this, ByClass, classNames);
900 }
901 
902 Ref&lt;RadioNodeList&gt; ContainerNode::radioNodeList(const AtomString&amp; name)
903 {
904     ASSERT(hasTagName(HTMLNames::formTag) || hasTagName(HTMLNames::fieldsetTag));
<span class="line-modified">905     return ensureRareData().ensureNodeLists().addCacheWithAtomName&lt;RadioNodeList&gt;(*this, name);</span>
906 }
907 
908 Ref&lt;HTMLCollection&gt; ContainerNode::children()
909 {
910     return ensureRareData().ensureNodeLists().addCachedCollection&lt;GenericCachedHTMLCollection&lt;CollectionTypeTraits&lt;NodeChildren&gt;::traversalType&gt;&gt;(*this, NodeChildren);
911 }
912 
913 Element* ContainerNode::firstElementChild() const
914 {
915     return ElementTraversal::firstChild(*this);
916 }
917 
918 Element* ContainerNode::lastElementChild() const
919 {
920     return ElementTraversal::lastChild(*this);
921 }
922 
923 unsigned ContainerNode::childElementCount() const
924 {
925     auto children = childrenOfType&lt;Element&gt;(*this);
</pre>
</td>
</tr>
</table>
<center><a href="CompositionEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ContainerNodeAlgorithms.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
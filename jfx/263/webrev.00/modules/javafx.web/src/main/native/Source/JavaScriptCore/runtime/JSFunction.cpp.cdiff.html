<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSFunction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDestructibleObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSFunction.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSFunction.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 50,15 ***</span>
  #include &quot;StackVisitor.h&quot;
  #include &quot;WebAssemblyFunction.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL callHostFunctionAsConstructor(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     return throwVMError(exec, scope, createNotAConstructorError(exec, exec-&gt;jsCallee()));</span>
  }
  
  const ClassInfo JSFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFunction) };
  const ClassInfo JSStrictFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSStrictFunction) };
  const ClassInfo JSSloppyFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSloppyFunction) };
<span class="line-new-header">--- 50,15 ---</span>
  #include &quot;StackVisitor.h&quot;
  #include &quot;WebAssemblyFunction.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL callHostFunctionAsConstructor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     return throwVMError(globalObject, scope, createNotAConstructorError(globalObject, callFrame-&gt;jsCallee()));</span>
  }
  
  const ClassInfo JSFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFunction) };
  const ClassInfo JSStrictFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSStrictFunction) };
  const ClassInfo JSSloppyFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSloppyFunction) };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,124 ***</span>
  
  JSFunction* JSFunction::create(VM&amp; vm, JSGlobalObject* globalObject, int length, const String&amp; name, NativeFunction nativeFunction, Intrinsic intrinsic, NativeFunction nativeConstructor, const DOMJIT::Signature* signature)
  {
      NativeExecutable* executable = vm.getHostFunction(nativeFunction, intrinsic, nativeConstructor, signature, name);
      Structure* structure = globalObject-&gt;hostFunctionStructure();
<span class="line-modified">!     JSFunction* function = new (NotNull, allocateCell&lt;JSFunction&gt;(vm.heap)) JSFunction(vm, globalObject, structure);</span>
      // Can&#39;t do this during initialization because getHostFunction might do a GC allocation.
      function-&gt;finishCreation(vm, executable, length, name);
      return function;
  }
  
  JSFunction* JSFunction::createFunctionThatMasqueradesAsUndefined(VM&amp; vm, JSGlobalObject* globalObject, int length, const String&amp; name, NativeFunction nativeFunction, Intrinsic intrinsic, NativeFunction nativeConstructor, const DOMJIT::Signature* signature)
  {
      NativeExecutable* executable = vm.getHostFunction(nativeFunction, intrinsic, nativeConstructor, signature, name);
      Structure* structure = Structure::create(vm, globalObject, globalObject-&gt;objectPrototype(), TypeInfo(JSFunctionType, JSFunction::StructureFlags | MasqueradesAsUndefined), JSFunction::info());
      globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(globalObject-&gt;vm(), &quot;Allocated masquerading object&quot;);
<span class="line-modified">!     JSFunction* function = new (NotNull, allocateCell&lt;JSFunction&gt;(vm.heap)) JSFunction(vm, globalObject, structure);</span>
      function-&gt;finishCreation(vm, executable, length, name);
      return function;
  }
  
<span class="line-modified">! JSFunction::JSFunction(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)</span>
      : Base(vm, globalObject, structure)
<span class="line-modified">!     , m_executable()</span>
  {
      assertTypeInfoFlagInvariants();
  }
  
  
  void JSFunction::finishCreation(VM&amp; vm)
  {
      Base::finishCreation(vm);
      ASSERT(jsDynamicCast&lt;JSFunction*&gt;(vm, this));
      ASSERT(type() == JSFunctionType);
<span class="line-modified">!     if (isAnonymousBuiltinFunction()) {</span>
<span class="line-modified">!         // This is anonymous builtin function.</span>
<span class="line-removed">-         rareData(vm)-&gt;setHasReifiedName();</span>
<span class="line-removed">-     }</span>
  }
  
<span class="line-modified">! void JSFunction::finishCreation(VM&amp; vm, NativeExecutable* executable, int length, const String&amp; name)</span>
  {
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
      ASSERT(type() == JSFunctionType);
<span class="line-modified">!     m_executable.set(vm, this, executable);</span>
<span class="line-modified">!     // Some NativeExecutable functions, like JSBoundFunction, decide to lazily allocate their name string.</span>
      if (!name.isNull())
          putDirect(vm, vm.propertyNames-&gt;name, jsString(vm, name), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
      putDirect(vm, vm.propertyNames-&gt;length, jsNumber(length), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
  }
  
  FunctionRareData* JSFunction::allocateRareData(VM&amp; vm)
  {
<span class="line-modified">!     ASSERT(!m_rareData);</span>
<span class="line-modified">!     FunctionRareData* rareData = FunctionRareData::create(vm);</span>
  
      // A DFG compilation thread may be trying to read the rare data
      // We want to ensure that it sees it properly allocated
      WTF::storeStoreFence();
  
<span class="line-modified">!     m_rareData.set(vm, this, rareData);</span>
<span class="line-modified">!     return m_rareData.get();</span>
  }
  
<span class="line-modified">! JSObject* JSFunction::prototypeForConstruction(VM&amp; vm, ExecState* exec)</span>
  {
      // This code assumes getting the prototype is not effectful. That&#39;s only
      // true when we can use the allocation profile.
      ASSERT(canUseAllocationProfile());
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     JSValue prototype = get(exec, vm.propertyNames-&gt;prototype);</span>
      scope.releaseAssertNoException();
      if (LIKELY(prototype.isObject()))
          return asObject(prototype);
  
<span class="line-modified">!     JSGlobalObject* globalObject = this-&gt;globalObject(vm);</span>
      if (!isHostOrBuiltinFunction()) {
          // https://tc39.github.io/ecma262/#sec-generator-function-definitions-runtime-semantics-evaluatebody
          if (isGeneratorWrapperParseMode(jsExecutable()-&gt;parseMode()))
<span class="line-modified">!             return globalObject-&gt;generatorPrototype();</span>
  
          // https://tc39.github.io/ecma262/#sec-asyncgenerator-definitions-evaluatebody
          if (isAsyncGeneratorWrapperParseMode(jsExecutable()-&gt;parseMode()))
<span class="line-modified">!             return globalObject-&gt;asyncGeneratorPrototype();</span>
      }
<span class="line-modified">!     return globalObject-&gt;objectPrototype();</span>
  }
  
<span class="line-modified">! FunctionRareData* JSFunction::allocateAndInitializeRareData(ExecState* exec, size_t inlineCapacity)</span>
  {
<span class="line-modified">!     ASSERT(!m_rareData);</span>
      ASSERT(canUseAllocationProfile());
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSObject* prototype = prototypeForConstruction(vm, exec);</span>
<span class="line-modified">!     FunctionRareData* rareData = FunctionRareData::create(vm);</span>
<span class="line-modified">!     rareData-&gt;initializeObjectAllocationProfile(vm, globalObject(vm), prototype, inlineCapacity, this);</span>
  
      // A DFG compilation thread may be trying to read the rare data
      // We want to ensure that it sees it properly allocated
      WTF::storeStoreFence();
  
<span class="line-modified">!     m_rareData.set(vm, this, rareData);</span>
<span class="line-modified">!     return m_rareData.get();</span>
  }
  
<span class="line-modified">! FunctionRareData* JSFunction::initializeRareData(ExecState* exec, size_t inlineCapacity)</span>
  {
<span class="line-modified">!     ASSERT(!!m_rareData);</span>
      ASSERT(canUseAllocationProfile());
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSObject* prototype = prototypeForConstruction(vm, exec);</span>
<span class="line-modified">!     m_rareData-&gt;initializeObjectAllocationProfile(vm, globalObject(vm), prototype, inlineCapacity, this);</span>
<span class="line-modified">!     return m_rareData.get();</span>
  }
  
  String JSFunction::name(VM&amp; vm)
  {
      if (isHostFunction()) {
          NativeExecutable* executable = jsCast&lt;NativeExecutable*&gt;(this-&gt;executable());
          return executable-&gt;name();
      }
      const Identifier identifier = jsExecutable()-&gt;name();
      if (identifier == vm.propertyNames-&gt;builtinNames().starDefaultPrivateName())
<span class="line-new-header">--- 94,140 ---</span>
  
  JSFunction* JSFunction::create(VM&amp; vm, JSGlobalObject* globalObject, int length, const String&amp; name, NativeFunction nativeFunction, Intrinsic intrinsic, NativeFunction nativeConstructor, const DOMJIT::Signature* signature)
  {
      NativeExecutable* executable = vm.getHostFunction(nativeFunction, intrinsic, nativeConstructor, signature, name);
      Structure* structure = globalObject-&gt;hostFunctionStructure();
<span class="line-modified">!     JSFunction* function = new (NotNull, allocateCell&lt;JSFunction&gt;(vm.heap)) JSFunction(vm, executable, globalObject, structure);</span>
      // Can&#39;t do this during initialization because getHostFunction might do a GC allocation.
      function-&gt;finishCreation(vm, executable, length, name);
      return function;
  }
  
  JSFunction* JSFunction::createFunctionThatMasqueradesAsUndefined(VM&amp; vm, JSGlobalObject* globalObject, int length, const String&amp; name, NativeFunction nativeFunction, Intrinsic intrinsic, NativeFunction nativeConstructor, const DOMJIT::Signature* signature)
  {
      NativeExecutable* executable = vm.getHostFunction(nativeFunction, intrinsic, nativeConstructor, signature, name);
      Structure* structure = Structure::create(vm, globalObject, globalObject-&gt;objectPrototype(), TypeInfo(JSFunctionType, JSFunction::StructureFlags | MasqueradesAsUndefined), JSFunction::info());
      globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(globalObject-&gt;vm(), &quot;Allocated masquerading object&quot;);
<span class="line-modified">!     JSFunction* function = new (NotNull, allocateCell&lt;JSFunction&gt;(vm.heap)) JSFunction(vm, executable, globalObject, structure);</span>
      function-&gt;finishCreation(vm, executable, length, name);
      return function;
  }
  
<span class="line-modified">! JSFunction::JSFunction(VM&amp; vm, NativeExecutable* executable, JSGlobalObject* globalObject, Structure* structure)</span>
      : Base(vm, globalObject, structure)
<span class="line-modified">!     , m_executableOrRareData(bitwise_cast&lt;uintptr_t&gt;(executable))</span>
  {
      assertTypeInfoFlagInvariants();
<span class="line-added">+     ASSERT(structure-&gt;globalObject() == globalObject);</span>
  }
  
  
  void JSFunction::finishCreation(VM&amp; vm)
  {
      Base::finishCreation(vm);
      ASSERT(jsDynamicCast&lt;JSFunction*&gt;(vm, this));
      ASSERT(type() == JSFunctionType);
<span class="line-modified">!     ASSERT(methodTable(vm)-&gt;getConstructData == &amp;JSFunction::getConstructData);</span>
<span class="line-modified">!     ASSERT(methodTable(vm)-&gt;getCallData == &amp;JSFunction::getCallData);</span>
  }
  
<span class="line-modified">! void JSFunction::finishCreation(VM&amp; vm, NativeExecutable*, int length, const String&amp; name)</span>
  {
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
      ASSERT(type() == JSFunctionType);
<span class="line-modified">!     ASSERT(methodTable(vm)-&gt;getConstructData == &amp;JSFunction::getConstructData);</span>
<span class="line-modified">!     ASSERT(methodTable(vm)-&gt;getCallData == &amp;JSFunction::getCallData);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Some NativeExecutable functions, like JSBoundFunction, decide to lazily allocate their name string / length.</span>
<span class="line-added">+     if (this-&gt;inherits&lt;JSBoundFunction&gt;(vm))</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      if (!name.isNull())
          putDirect(vm, vm.propertyNames-&gt;name, jsString(vm, name), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
      putDirect(vm, vm.propertyNames-&gt;length, jsNumber(length), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
  }
  
  FunctionRareData* JSFunction::allocateRareData(VM&amp; vm)
  {
<span class="line-modified">!     uintptr_t executableOrRareData = m_executableOrRareData;</span>
<span class="line-modified">!     ASSERT(!(executableOrRareData &amp; rareDataTag));</span>
<span class="line-added">+     FunctionRareData* rareData = FunctionRareData::create(vm, bitwise_cast&lt;ExecutableBase*&gt;(executableOrRareData));</span>
<span class="line-added">+     executableOrRareData = bitwise_cast&lt;uintptr_t&gt;(rareData) | rareDataTag;</span>
  
      // A DFG compilation thread may be trying to read the rare data
      // We want to ensure that it sees it properly allocated
      WTF::storeStoreFence();
  
<span class="line-modified">!     m_executableOrRareData = executableOrRareData;</span>
<span class="line-modified">!     vm.heap.writeBarrier(this, rareData);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return rareData;</span>
  }
  
<span class="line-modified">! JSObject* JSFunction::prototypeForConstruction(VM&amp; vm, JSGlobalObject* globalObject)</span>
  {
      // This code assumes getting the prototype is not effectful. That&#39;s only
      // true when we can use the allocation profile.
      ASSERT(canUseAllocationProfile());
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     JSValue prototype = get(globalObject, vm.propertyNames-&gt;prototype);</span>
      scope.releaseAssertNoException();
      if (LIKELY(prototype.isObject()))
          return asObject(prototype);
  
<span class="line-modified">!     JSGlobalObject* thisGlobalObject = this-&gt;globalObject();</span>
      if (!isHostOrBuiltinFunction()) {
          // https://tc39.github.io/ecma262/#sec-generator-function-definitions-runtime-semantics-evaluatebody
          if (isGeneratorWrapperParseMode(jsExecutable()-&gt;parseMode()))
<span class="line-modified">!             return thisGlobalObject-&gt;generatorPrototype();</span>
  
          // https://tc39.github.io/ecma262/#sec-asyncgenerator-definitions-evaluatebody
          if (isAsyncGeneratorWrapperParseMode(jsExecutable()-&gt;parseMode()))
<span class="line-modified">!             return thisGlobalObject-&gt;asyncGeneratorPrototype();</span>
      }
<span class="line-modified">!     return thisGlobalObject-&gt;objectPrototype();</span>
  }
  
<span class="line-modified">! FunctionRareData* JSFunction::allocateAndInitializeRareData(JSGlobalObject* globalObject, size_t inlineCapacity)</span>
  {
<span class="line-modified">!     uintptr_t executableOrRareData = m_executableOrRareData;</span>
<span class="line-added">+     ASSERT(!(executableOrRareData &amp; rareDataTag));</span>
      ASSERT(canUseAllocationProfile());
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSObject* prototype = prototypeForConstruction(vm, globalObject);</span>
<span class="line-modified">!     FunctionRareData* rareData = FunctionRareData::create(vm, bitwise_cast&lt;ExecutableBase*&gt;(executableOrRareData));</span>
<span class="line-modified">!     rareData-&gt;initializeObjectAllocationProfile(vm, this-&gt;globalObject(), prototype, inlineCapacity, this);</span>
<span class="line-added">+     executableOrRareData = bitwise_cast&lt;uintptr_t&gt;(rareData) | rareDataTag;</span>
  
      // A DFG compilation thread may be trying to read the rare data
      // We want to ensure that it sees it properly allocated
      WTF::storeStoreFence();
  
<span class="line-modified">!     m_executableOrRareData = executableOrRareData;</span>
<span class="line-modified">!     vm.heap.writeBarrier(this, rareData);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return rareData;</span>
  }
  
<span class="line-modified">! FunctionRareData* JSFunction::initializeRareData(JSGlobalObject* globalObject, size_t inlineCapacity)</span>
  {
<span class="line-modified">!     uintptr_t executableOrRareData = m_executableOrRareData;</span>
<span class="line-added">+     ASSERT(executableOrRareData &amp; rareDataTag);</span>
      ASSERT(canUseAllocationProfile());
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSObject* prototype = prototypeForConstruction(vm, globalObject);</span>
<span class="line-modified">!     FunctionRareData* rareData = bitwise_cast&lt;FunctionRareData*&gt;(executableOrRareData &amp; ~rareDataTag);</span>
<span class="line-modified">!     rareData-&gt;initializeObjectAllocationProfile(vm, this-&gt;globalObject(), prototype, inlineCapacity, this);</span>
<span class="line-added">+     return rareData;</span>
  }
  
  String JSFunction::name(VM&amp; vm)
  {
      if (isHostFunction()) {
<span class="line-added">+         if (this-&gt;inherits&lt;JSBoundFunction&gt;(vm))</span>
<span class="line-added">+             return jsCast&lt;JSBoundFunction*&gt;(this)-&gt;nameString();</span>
          NativeExecutable* executable = jsCast&lt;NativeExecutable*&gt;(this-&gt;executable());
          return executable-&gt;name();
      }
      const Identifier identifier = jsExecutable()-&gt;name();
      if (identifier == vm.propertyNames-&gt;builtinNames().starDefaultPrivateName())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 254,12 ***</span>
  {
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(cell);
      ASSERT_GC_OBJECT_INHERITS(thisObject, info());
      Base::visitChildren(thisObject, visitor);
  
<span class="line-modified">!     visitor.append(thisObject-&gt;m_executable);</span>
<span class="line-removed">-     visitor.append(thisObject-&gt;m_rareData);</span>
  }
  
  CallType JSFunction::getCallData(JSCell* cell, CallData&amp; callData)
  {
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(cell);
<span class="line-new-header">--- 270,11 ---</span>
  {
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(cell);
      ASSERT_GC_OBJECT_INHERITS(thisObject, info());
      Base::visitChildren(thisObject, visitor);
  
<span class="line-modified">!     visitor.appendUnbarriered(bitwise_cast&lt;JSCell*&gt;(bitwise_cast&lt;uintptr_t&gt;(thisObject-&gt;m_executableOrRareData) &amp; ~rareDataTag));</span>
  }
  
  CallType JSFunction::getCallData(JSCell* cell, CallData&amp; callData)
  {
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(cell);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,12 ***</span>
      return CallType::JS;
  }
  
  class RetrieveArgumentsFunctor {
  public:
<span class="line-modified">!     RetrieveArgumentsFunctor(JSFunction* functionObj)</span>
<span class="line-modified">!         : m_targetCallee(functionObj)</span>
          , m_result(jsNull())
      {
      }
  
      JSValue result() const { return m_result; }
<span class="line-new-header">--- 287,13 ---</span>
      return CallType::JS;
  }
  
  class RetrieveArgumentsFunctor {
  public:
<span class="line-modified">!     RetrieveArgumentsFunctor(VM&amp; vm, JSFunction* functionObj)</span>
<span class="line-modified">!         : m_vm(vm)</span>
<span class="line-added">+         , m_targetCallee(functionObj)</span>
          , m_result(jsNull())
      {
      }
  
      JSValue result() const { return m_result; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 289,32 ***</span>
  
          JSCell* callee = visitor-&gt;callee().asCell();
          if (callee != m_targetCallee)
              return StackVisitor::Continue;
  
<span class="line-modified">!         m_result = JSValue(visitor-&gt;createArguments());</span>
          return StackVisitor::Done;
      }
  
  private:
      JSObject* m_targetCallee;
      mutable JSValue m_result;
  };
  
<span class="line-modified">! static JSValue retrieveArguments(ExecState* exec, JSFunction* functionObj)</span>
  {
<span class="line-modified">!     RetrieveArgumentsFunctor functor(functionObj);</span>
<span class="line-modified">!     exec-&gt;iterate(functor);</span>
      return functor.result();
  }
  
<span class="line-modified">! EncodedJSValue JSFunction::argumentsGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
  {
      JSFunction* thisObj = jsCast&lt;JSFunction*&gt;(JSValue::decode(thisValue));
      ASSERT(!thisObj-&gt;isHostFunction());
  
<span class="line-modified">!     return JSValue::encode(retrieveArguments(exec, thisObj));</span>
  }
  
  class RetrieveCallerFunctionFunctor {
  public:
      RetrieveCallerFunctionFunctor(JSFunction* functionObj)
<span class="line-new-header">--- 305,35 ---</span>
  
          JSCell* callee = visitor-&gt;callee().asCell();
          if (callee != m_targetCallee)
              return StackVisitor::Continue;
  
<span class="line-modified">!         m_result = JSValue(visitor-&gt;createArguments(m_vm));</span>
          return StackVisitor::Done;
      }
  
  private:
<span class="line-added">+     VM&amp; m_vm;</span>
      JSObject* m_targetCallee;
      mutable JSValue m_result;
  };
  
<span class="line-modified">! static JSValue retrieveArguments(VM&amp; vm, CallFrame* callFrame, JSFunction* functionObj)</span>
  {
<span class="line-modified">!     RetrieveArgumentsFunctor functor(vm, functionObj);</span>
<span class="line-modified">!     if (callFrame)</span>
<span class="line-added">+         callFrame-&gt;iterate(vm, functor);</span>
      return functor.result();
  }
  
<span class="line-modified">! EncodedJSValue JSFunction::argumentsGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
  {
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSFunction* thisObj = jsCast&lt;JSFunction*&gt;(JSValue::decode(thisValue));
      ASSERT(!thisObj-&gt;isHostFunction());
  
<span class="line-modified">!     return JSValue::encode(retrieveArguments(vm, vm.topCallFrame, thisObj));</span>
  }
  
  class RetrieveCallerFunctionFunctor {
  public:
      RetrieveCallerFunctionFunctor(JSFunction* functionObj)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 356,25 ***</span>
      mutable bool m_hasFoundFrame;
      mutable bool m_hasSkippedToCallerFrame;
      mutable JSValue m_result;
  };
  
<span class="line-modified">! static JSValue retrieveCallerFunction(ExecState* exec, JSFunction* functionObj)</span>
  {
      RetrieveCallerFunctionFunctor functor(functionObj);
<span class="line-modified">!     exec-&gt;iterate(functor);</span>
      return functor.result();
  }
  
<span class="line-modified">! EncodedJSValue JSFunction::callerGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSFunction* thisObj = jsCast&lt;JSFunction*&gt;(JSValue::decode(thisValue));
      ASSERT(!thisObj-&gt;isHostFunction());
<span class="line-modified">!     JSValue caller = retrieveCallerFunction(exec, thisObj);</span>
  
      // See ES5.1 15.3.5.4 - Function.caller may not be used to retrieve a strict caller.
      if (!caller.isObject() || !asObject(caller)-&gt;inherits&lt;JSFunction&gt;(vm)) {
          // It isn&#39;t a JSFunction, but if it is a JSCallee from a program or eval call or an internal constructor, return null.
          if (jsDynamicCast&lt;JSCallee*&gt;(vm, caller) || jsDynamicCast&lt;InternalFunction*&gt;(vm, caller))
<span class="line-new-header">--- 375,26 ---</span>
      mutable bool m_hasFoundFrame;
      mutable bool m_hasSkippedToCallerFrame;
      mutable JSValue m_result;
  };
  
<span class="line-modified">! static JSValue retrieveCallerFunction(VM&amp; vm, CallFrame* callFrame, JSFunction* functionObj)</span>
  {
      RetrieveCallerFunctionFunctor functor(functionObj);
<span class="line-modified">!     if (callFrame)</span>
<span class="line-added">+         callFrame-&gt;iterate(vm, functor);</span>
      return functor.result();
  }
  
<span class="line-modified">! EncodedJSValue JSFunction::callerGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSFunction* thisObj = jsCast&lt;JSFunction*&gt;(JSValue::decode(thisValue));
      ASSERT(!thisObj-&gt;isHostFunction());
<span class="line-modified">!     JSValue caller = retrieveCallerFunction(vm, vm.topCallFrame, thisObj);</span>
  
      // See ES5.1 15.3.5.4 - Function.caller may not be used to retrieve a strict caller.
      if (!caller.isObject() || !asObject(caller)-&gt;inherits&lt;JSFunction&gt;(vm)) {
          // It isn&#39;t a JSFunction, but if it is a JSCallee from a program or eval call or an internal constructor, return null.
          if (jsDynamicCast&lt;JSCallee*&gt;(vm, caller) || jsDynamicCast&lt;InternalFunction*&gt;(vm, caller))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 388,14 ***</span>
          return JSValue::encode(jsNull());
      SourceParseMode parseMode = function-&gt;jsExecutable()-&gt;parseMode();
      switch (parseMode) {
      case SourceParseMode::GeneratorBodyMode:
      case SourceParseMode::AsyncGeneratorBodyMode:
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Function.caller used to retrieve generator body&quot;_s));</span>
      case SourceParseMode::AsyncFunctionBodyMode:
      case SourceParseMode::AsyncArrowFunctionBodyMode:
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Function.caller used to retrieve async function body&quot;_s));</span>
      case SourceParseMode::NormalFunctionMode:
      case SourceParseMode::GeneratorWrapperFunctionMode:
      case SourceParseMode::GetterMode:
      case SourceParseMode::SetterMode:
      case SourceParseMode::MethodMode:
<span class="line-new-header">--- 408,14 ---</span>
          return JSValue::encode(jsNull());
      SourceParseMode parseMode = function-&gt;jsExecutable()-&gt;parseMode();
      switch (parseMode) {
      case SourceParseMode::GeneratorBodyMode:
      case SourceParseMode::AsyncGeneratorBodyMode:
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Function.caller used to retrieve generator body&quot;_s));</span>
      case SourceParseMode::AsyncFunctionBodyMode:
      case SourceParseMode::AsyncArrowFunctionBodyMode:
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Function.caller used to retrieve async function body&quot;_s));</span>
      case SourceParseMode::NormalFunctionMode:
      case SourceParseMode::GeneratorWrapperFunctionMode:
      case SourceParseMode::GetterMode:
      case SourceParseMode::SetterMode:
      case SourceParseMode::MethodMode:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 407,24 ***</span>
      case SourceParseMode::ModuleAnalyzeMode:
      case SourceParseMode::ModuleEvaluateMode:
      case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
      case SourceParseMode::AsyncGeneratorWrapperMethodMode:
      case SourceParseMode::GeneratorWrapperMethodMode:
          if (!function-&gt;jsExecutable()-&gt;isStrictMode())
              return JSValue::encode(caller);
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Function.caller used to retrieve strict caller&quot;_s));</span>
      }
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! bool JSFunction::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(object);
      if (thisObject-&gt;isHostOrBuiltinFunction()) {
<span class="line-modified">!         thisObject-&gt;reifyLazyPropertyForHostOrBuiltinIfNeeded(vm, exec, propertyName);</span>
<span class="line-modified">!         return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
      }
  
      if (propertyName == vm.propertyNames-&gt;prototype &amp;&amp; thisObject-&gt;jsExecutable()-&gt;hasPrototypeProperty() &amp;&amp; !thisObject-&gt;jsExecutable()-&gt;isClassConstructorFunction()) {
          // NOTE: class constructors define the prototype property in bytecode using
          // defineOwnProperty, which ends up calling into this code (see our defineOwnProperty
<span class="line-new-header">--- 427,28 ---</span>
      case SourceParseMode::ModuleAnalyzeMode:
      case SourceParseMode::ModuleEvaluateMode:
      case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
      case SourceParseMode::AsyncGeneratorWrapperMethodMode:
      case SourceParseMode::GeneratorWrapperMethodMode:
<span class="line-added">+     case SourceParseMode::InstanceFieldInitializerMode:</span>
          if (!function-&gt;jsExecutable()-&gt;isStrictMode())
              return JSValue::encode(caller);
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Function.caller used to retrieve strict caller&quot;_s));</span>
      }
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! bool JSFunction::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(object);
      if (thisObject-&gt;isHostOrBuiltinFunction()) {
<span class="line-modified">!         thisObject-&gt;reifyLazyPropertyForHostOrBuiltinIfNeeded(vm, globalObject, propertyName);</span>
<span class="line-modified">!         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+         RELEASE_AND_RETURN(scope, Base::getOwnPropertySlot(thisObject, globalObject, propertyName, slot));</span>
      }
  
      if (propertyName == vm.propertyNames-&gt;prototype &amp;&amp; thisObject-&gt;jsExecutable()-&gt;hasPrototypeProperty() &amp;&amp; !thisObject-&gt;jsExecutable()-&gt;isClassConstructorFunction()) {
          // NOTE: class constructors define the prototype property in bytecode using
          // defineOwnProperty, which ends up calling into this code (see our defineOwnProperty
</pre>
<hr />
<pre>
<span class="line-old-header">*** 439,15 ***</span>
              JSObject* prototype = nullptr;
              if (isGeneratorWrapperParseMode(thisObject-&gt;jsExecutable()-&gt;parseMode())) {
                  // Unlike function instances, the object that is the value of the a GeneratorFunction&#39;s prototype
                  // property does not have a constructor property whose value is the GeneratorFunction instance.
                  // https://tc39.github.io/ecma262/#sec-generatorfunction-instances-prototype
<span class="line-modified">!                 prototype = constructEmptyObject(exec, thisObject-&gt;globalObject(vm)-&gt;generatorPrototype());</span>
              } else if (isAsyncGeneratorWrapperParseMode(thisObject-&gt;jsExecutable()-&gt;parseMode()))
<span class="line-modified">!                 prototype = constructEmptyObject(exec, thisObject-&gt;globalObject(vm)-&gt;asyncGeneratorPrototype());</span>
              else {
<span class="line-modified">!                 prototype = constructEmptyObject(exec);</span>
                  prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
              }
  
              thisObject-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, prototype, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum);
              offset = thisObject-&gt;getDirectOffset(vm, vm.propertyNames-&gt;prototype, attributes);
<span class="line-new-header">--- 463,15 ---</span>
              JSObject* prototype = nullptr;
              if (isGeneratorWrapperParseMode(thisObject-&gt;jsExecutable()-&gt;parseMode())) {
                  // Unlike function instances, the object that is the value of the a GeneratorFunction&#39;s prototype
                  // property does not have a constructor property whose value is the GeneratorFunction instance.
                  // https://tc39.github.io/ecma262/#sec-generatorfunction-instances-prototype
<span class="line-modified">!                 prototype = constructEmptyObject(globalObject, thisObject-&gt;globalObject()-&gt;generatorPrototype());</span>
              } else if (isAsyncGeneratorWrapperParseMode(thisObject-&gt;jsExecutable()-&gt;parseMode()))
<span class="line-modified">!                 prototype = constructEmptyObject(globalObject, thisObject-&gt;globalObject()-&gt;asyncGeneratorPrototype());</span>
              else {
<span class="line-modified">!                 prototype = constructEmptyObject(globalObject);</span>
                  prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
              }
  
              thisObject-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, prototype, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum);
              offset = thisObject-&gt;getDirectOffset(vm, vm.propertyNames-&gt;prototype, attributes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 456,167 ***</span>
          slot.setValue(thisObject, attributes, thisObject-&gt;getDirect(offset), offset);
      }
  
      if (propertyName == vm.propertyNames-&gt;arguments) {
          if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<span class="line-modified">!             return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
  
          slot.setCacheableCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete, argumentsGetter);
          return true;
  
      } else if (propertyName == vm.propertyNames-&gt;caller) {
          if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<span class="line-modified">!             return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
  
          slot.setCacheableCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete, callerGetter);
          return true;
      }
  
<span class="line-modified">!     thisObject-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>
  
<span class="line-modified">!     return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
  }
  
<span class="line-modified">! void JSFunction::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(object);
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      if (mode.includeDontEnumProperties()) {
          if (!thisObject-&gt;isHostOrBuiltinFunction()) {
              // Make sure prototype has been reified.
              PropertySlot slot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!             thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, exec, vm.propertyNames-&gt;prototype, slot);</span>
  
              if (thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties()) {
                  propertyNames.add(vm.propertyNames-&gt;arguments);
                  propertyNames.add(vm.propertyNames-&gt;caller);
              }
              if (!thisObject-&gt;hasReifiedLength())
                  propertyNames.add(vm.propertyNames-&gt;length);
              if (!thisObject-&gt;hasReifiedName())
                  propertyNames.add(vm.propertyNames-&gt;name);
          } else {
<span class="line-modified">!             if (thisObject-&gt;isBuiltinFunction() &amp;&amp; !thisObject-&gt;hasReifiedLength())</span>
<span class="line-modified">!                 propertyNames.add(vm.propertyNames-&gt;length);</span>
<span class="line-modified">!             if ((thisObject-&gt;isBuiltinFunction() || thisObject-&gt;inherits&lt;JSBoundFunction&gt;(vm)) &amp;&amp; !thisObject-&gt;hasReifiedName())</span>
<span class="line-modified">!                 propertyNames.add(vm.propertyNames-&gt;name);</span>
          }
      }
<span class="line-modified">!     Base::getOwnNonIndexPropertyNames(thisObject, exec, propertyNames, mode);</span>
  }
  
<span class="line-modified">! bool JSFunction::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(cell);
  
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
  
  
      if (thisObject-&gt;isHostOrBuiltinFunction()) {
<span class="line-modified">!         PropertyStatus propertyType = thisObject-&gt;reifyLazyPropertyForHostOrBuiltinIfNeeded(vm, exec, propertyName);</span>
          if (isLazy(propertyType))
              slot.disableCaching();
<span class="line-modified">!         RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));</span>
      }
  
      if (propertyName == vm.propertyNames-&gt;prototype) {
          slot.disableCaching();
          // Make sure prototype has been reified, such that it can only be overwritten
          // following the rules set out in ECMA-262 8.12.9.
          PropertySlot getSlot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!         thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, exec, propertyName, getSlot);</span>
<span class="line-modified">!         if (thisObject-&gt;m_rareData)</span>
<span class="line-modified">!             thisObject-&gt;m_rareData-&gt;clear(&quot;Store to prototype property of a function&quot;);</span>
<span class="line-modified">!         RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));</span>
      }
  
      if (propertyName == vm.propertyNames-&gt;arguments || propertyName == vm.propertyNames-&gt;caller) {
          if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));</span>
  
          slot.disableCaching();
<span class="line-modified">!         return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
      }
<span class="line-modified">!     PropertyStatus propertyType = thisObject-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>
      if (isLazy(propertyType))
          slot.disableCaching();
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));</span>
  }
  
<span class="line-modified">! bool JSFunction::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(cell);
<span class="line-modified">!     if (thisObject-&gt;isHostOrBuiltinFunction())</span>
<span class="line-modified">!         thisObject-&gt;reifyLazyPropertyForHostOrBuiltinIfNeeded(vm, exec, propertyName);</span>
<span class="line-modified">!     else if (vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable) {</span>
          // For non-host functions, don&#39;t let these properties by deleted - except by DefineOwnProperty.
          FunctionExecutable* executable = thisObject-&gt;jsExecutable();
  
          if ((propertyName == vm.propertyNames-&gt;caller || propertyName == vm.propertyNames-&gt;arguments) &amp;&amp; executable-&gt;hasCallerAndArgumentsProperties())
              return false;
  
          if (propertyName == vm.propertyNames-&gt;prototype &amp;&amp; !executable-&gt;isArrowFunction())
              return false;
  
<span class="line-modified">!         thisObject-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>
      }
  
<span class="line-modified">!     return Base::deleteProperty(thisObject, exec, propertyName);</span>
  }
  
<span class="line-modified">! bool JSFunction::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(object);
      if (thisObject-&gt;isHostOrBuiltinFunction()) {
<span class="line-modified">!         thisObject-&gt;reifyLazyPropertyForHostOrBuiltinIfNeeded(vm, exec, propertyName);</span>
<span class="line-modified">!         RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, propertyName, descriptor, throwException));</span>
      }
  
      if (propertyName == vm.propertyNames-&gt;prototype) {
          // Make sure prototype has been reified, such that it can only be overwritten
          // following the rules set out in ECMA-262 8.12.9.
          PropertySlot slot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!         thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
<span class="line-modified">!         if (thisObject-&gt;m_rareData)</span>
<span class="line-modified">!             thisObject-&gt;m_rareData-&gt;clear(&quot;Store to prototype property of a function&quot;);</span>
<span class="line-modified">!         RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, propertyName, descriptor, throwException));</span>
      }
  
      bool valueCheck;
      if (propertyName == vm.propertyNames-&gt;arguments) {
          if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, propertyName, descriptor, throwException));</span>
  
<span class="line-modified">!         valueCheck = !descriptor.value() || sameValue(exec, descriptor.value(), retrieveArguments(exec, thisObject));</span>
      } else if (propertyName == vm.propertyNames-&gt;caller) {
          if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, propertyName, descriptor, throwException));</span>
  
<span class="line-modified">!         valueCheck = !descriptor.value() || sameValue(exec, descriptor.value(), retrieveCallerFunction(exec, thisObject));</span>
      } else {
<span class="line-modified">!         thisObject-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>
<span class="line-modified">!         RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, propertyName, descriptor, throwException));</span>
      }
  
      if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<span class="line-modified">!         return typeError(exec, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
      if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable())
<span class="line-modified">!         return typeError(exec, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
      if (descriptor.isAccessorDescriptor())
<span class="line-modified">!         return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
      if (descriptor.writablePresent() &amp;&amp; descriptor.writable())
<span class="line-modified">!         return typeError(exec, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
      if (!valueCheck)
<span class="line-modified">!         return typeError(exec, scope, throwException, ReadonlyPropertyChangeError);</span>
      return true;
  }
  
  // ECMA 13.2.2 [[Construct]]
  ConstructType JSFunction::getConstructData(JSCell* cell, ConstructData&amp; constructData)
<span class="line-new-header">--- 480,215 ---</span>
          slot.setValue(thisObject, attributes, thisObject-&gt;getDirect(offset), offset);
      }
  
      if (propertyName == vm.propertyNames-&gt;arguments) {
          if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, Base::getOwnPropertySlot(thisObject, globalObject, propertyName, slot));</span>
  
          slot.setCacheableCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete, argumentsGetter);
          return true;
  
      } else if (propertyName == vm.propertyNames-&gt;caller) {
          if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, Base::getOwnPropertySlot(thisObject, globalObject, propertyName, slot));</span>
  
          slot.setCacheableCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete, callerGetter);
          return true;
      }
  
<span class="line-modified">!     thisObject-&gt;reifyLazyPropertyIfNeeded(vm, globalObject, propertyName);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, false);</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::getOwnPropertySlot(thisObject, globalObject, propertyName, slot));</span>
  }
  
<span class="line-modified">! void JSFunction::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(object);
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
      if (mode.includeDontEnumProperties()) {
          if (!thisObject-&gt;isHostOrBuiltinFunction()) {
              // Make sure prototype has been reified.
              PropertySlot slot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!             thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, globalObject, vm.propertyNames-&gt;prototype, slot);</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, void());</span>
  
              if (thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties()) {
                  propertyNames.add(vm.propertyNames-&gt;arguments);
                  propertyNames.add(vm.propertyNames-&gt;caller);
              }
              if (!thisObject-&gt;hasReifiedLength())
                  propertyNames.add(vm.propertyNames-&gt;length);
              if (!thisObject-&gt;hasReifiedName())
                  propertyNames.add(vm.propertyNames-&gt;name);
          } else {
<span class="line-modified">!             if (thisObject-&gt;isBuiltinFunction() || thisObject-&gt;inherits&lt;JSBoundFunction&gt;(vm)) {</span>
<span class="line-modified">!                 if (!thisObject-&gt;hasReifiedLength())</span>
<span class="line-modified">!                     propertyNames.add(vm.propertyNames-&gt;length);</span>
<span class="line-modified">!                 if (!thisObject-&gt;hasReifiedName())</span>
<span class="line-added">+                     propertyNames.add(vm.propertyNames-&gt;name);</span>
<span class="line-added">+             }</span>
          }
      }
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::getOwnNonIndexPropertyNames(thisObject, globalObject, propertyNames, mode));</span>
  }
  
<span class="line-modified">! bool JSFunction::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(cell);
  
<span class="line-added">+     if (propertyName == vm.propertyNames-&gt;length || propertyName == vm.propertyNames-&gt;name) {</span>
<span class="line-added">+         FunctionRareData* rareData = thisObject-&gt;ensureRareData(vm);</span>
<span class="line-added">+         if (propertyName == vm.propertyNames-&gt;length)</span>
<span class="line-added">+             rareData-&gt;setHasModifiedLength();</span>
<span class="line-added">+         else</span>
<span class="line-added">+             rareData-&gt;setHasModifiedName();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
  
  
      if (thisObject-&gt;isHostOrBuiltinFunction()) {
<span class="line-modified">!         PropertyStatus propertyType = thisObject-&gt;reifyLazyPropertyForHostOrBuiltinIfNeeded(vm, globalObject, propertyName);</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, false);</span>
          if (isLazy(propertyType))
              slot.disableCaching();
<span class="line-modified">!         RELEASE_AND_RETURN(scope, Base::put(thisObject, globalObject, propertyName, value, slot));</span>
      }
  
      if (propertyName == vm.propertyNames-&gt;prototype) {
          slot.disableCaching();
          // Make sure prototype has been reified, such that it can only be overwritten
          // following the rules set out in ECMA-262 8.12.9.
          PropertySlot getSlot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!         thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, globalObject, propertyName, getSlot);</span>
<span class="line-modified">!         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-modified">!         if (FunctionRareData* rareData = thisObject-&gt;rareData())</span>
<span class="line-modified">!             rareData-&gt;clear(&quot;Store to prototype property of a function&quot;);</span>
<span class="line-added">+         RELEASE_AND_RETURN(scope, Base::put(thisObject, globalObject, propertyName, value, slot));</span>
      }
  
      if (propertyName == vm.propertyNames-&gt;arguments || propertyName == vm.propertyNames-&gt;caller) {
          if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, Base::put(thisObject, globalObject, propertyName, value, slot));</span>
  
          slot.disableCaching();
<span class="line-modified">!         return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
      }
<span class="line-modified">!     PropertyStatus propertyType = thisObject-&gt;reifyLazyPropertyIfNeeded(vm, globalObject, propertyName);</span>
      if (isLazy(propertyType))
          slot.disableCaching();
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::put(thisObject, globalObject, propertyName, value, slot));</span>
  }
  
<span class="line-modified">! bool JSFunction::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(cell);
<span class="line-modified">! </span>
<span class="line-modified">!     if (propertyName == vm.propertyNames-&gt;length || propertyName == vm.propertyNames-&gt;name) {</span>
<span class="line-modified">!         FunctionRareData* rareData = thisObject-&gt;ensureRareData(vm);</span>
<span class="line-added">+         if (propertyName == vm.propertyNames-&gt;length)</span>
<span class="line-added">+             rareData-&gt;setHasModifiedLength();</span>
<span class="line-added">+         else</span>
<span class="line-added">+             rareData-&gt;setHasModifiedName();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (thisObject-&gt;isHostOrBuiltinFunction()) {</span>
<span class="line-added">+         thisObject-&gt;reifyLazyPropertyForHostOrBuiltinIfNeeded(vm, globalObject, propertyName);</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+     } else if (vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable) {</span>
          // For non-host functions, don&#39;t let these properties by deleted - except by DefineOwnProperty.
          FunctionExecutable* executable = thisObject-&gt;jsExecutable();
  
          if ((propertyName == vm.propertyNames-&gt;caller || propertyName == vm.propertyNames-&gt;arguments) &amp;&amp; executable-&gt;hasCallerAndArgumentsProperties())
              return false;
  
          if (propertyName == vm.propertyNames-&gt;prototype &amp;&amp; !executable-&gt;isArrowFunction())
              return false;
  
<span class="line-modified">!         thisObject-&gt;reifyLazyPropertyIfNeeded(vm, globalObject, propertyName);</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, false);</span>
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::deleteProperty(thisObject, globalObject, propertyName));</span>
  }
  
<span class="line-modified">! bool JSFunction::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(object);
<span class="line-added">+ </span>
<span class="line-added">+     if (propertyName == vm.propertyNames-&gt;length || propertyName == vm.propertyNames-&gt;name) {</span>
<span class="line-added">+         FunctionRareData* rareData = thisObject-&gt;ensureRareData(vm);</span>
<span class="line-added">+         if (propertyName == vm.propertyNames-&gt;length)</span>
<span class="line-added">+             rareData-&gt;setHasModifiedLength();</span>
<span class="line-added">+         else</span>
<span class="line-added">+             rareData-&gt;setHasModifiedName();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (thisObject-&gt;isHostOrBuiltinFunction()) {
<span class="line-modified">!         thisObject-&gt;reifyLazyPropertyForHostOrBuiltinIfNeeded(vm, globalObject, propertyName);</span>
<span class="line-modified">!         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+         RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, globalObject, propertyName, descriptor, throwException));</span>
      }
  
      if (propertyName == vm.propertyNames-&gt;prototype) {
          // Make sure prototype has been reified, such that it can only be overwritten
          // following the rules set out in ECMA-262 8.12.9.
          PropertySlot slot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!         thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
<span class="line-modified">!         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-modified">!         if (FunctionRareData* rareData = thisObject-&gt;rareData())</span>
<span class="line-modified">!             rareData-&gt;clear(&quot;Store to prototype property of a function&quot;);</span>
<span class="line-added">+         RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, globalObject, propertyName, descriptor, throwException));</span>
      }
  
      bool valueCheck;
      if (propertyName == vm.propertyNames-&gt;arguments) {
          if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, globalObject, propertyName, descriptor, throwException));</span>
  
<span class="line-modified">!         valueCheck = !descriptor.value();</span>
<span class="line-added">+         if (!valueCheck) {</span>
<span class="line-added">+             valueCheck = sameValue(globalObject, descriptor.value(), retrieveArguments(vm, vm.topCallFrame, thisObject));</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+         }</span>
      } else if (propertyName == vm.propertyNames-&gt;caller) {
          if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, globalObject, propertyName, descriptor, throwException));</span>
  
<span class="line-modified">!         valueCheck = !descriptor.value();</span>
<span class="line-added">+         if (!valueCheck) {</span>
<span class="line-added">+             valueCheck = sameValue(globalObject, descriptor.value(), retrieveCallerFunction(vm, vm.topCallFrame, thisObject));</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+         }</span>
      } else {
<span class="line-modified">!         thisObject-&gt;reifyLazyPropertyIfNeeded(vm, globalObject, propertyName);</span>
<span class="line-modified">!         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+         RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, globalObject, propertyName, descriptor, throwException));</span>
      }
  
      if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<span class="line-modified">!         return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
      if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable())
<span class="line-modified">!         return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
      if (descriptor.isAccessorDescriptor())
<span class="line-modified">!         return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
      if (descriptor.writablePresent() &amp;&amp; descriptor.writable())
<span class="line-modified">!         return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
      if (!valueCheck)
<span class="line-modified">!         return typeError(globalObject, scope, throwException, ReadonlyPropertyChangeError);</span>
      return true;
  }
  
  // ECMA 13.2.2 [[Construct]]
  ConstructType JSFunction::getConstructData(JSCell* cell, ConstructData&amp; constructData)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 671,13 ***</span>
  
  
      return emptyString();
  }
  
<span class="line-modified">! void JSFunction::setFunctionName(ExecState* exec, JSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // The &quot;name&quot; property may have been already been defined as part of a property list in an
      // object literal (and therefore reified).
      if (hasReifiedName())
<span class="line-new-header">--- 743,13 ---</span>
  
  
      return emptyString();
  }
  
<span class="line-modified">! void JSFunction::setFunctionName(JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // The &quot;name&quot; property may have been already been defined as part of a property list in an
      // object literal (and therefore reified).
      if (hasReifiedName())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 692,55 ***</span>
          if (uid.isNullSymbol())
              name = emptyString();
          else
              name = makeString(&#39;[&#39;, String(&amp;uid), &#39;]&#39;);
      } else {
<span class="line-modified">!         JSString* jsStr = value.toString(exec);</span>
          RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!         name = jsStr-&gt;value(exec);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
<span class="line-modified">!     reifyName(vm, exec, name);</span>
  }
  
  void JSFunction::reifyLength(VM&amp; vm)
  {
<span class="line-modified">!     FunctionRareData* rareData = this-&gt;rareData(vm);</span>
  
      ASSERT(!hasReifiedLength());
<span class="line-modified">!     ASSERT(!isHostFunction());</span>
<span class="line-modified">!     JSValue initialValue = jsNumber(jsExecutable()-&gt;parameterCount());</span>
      unsigned initialAttributes = PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
      const Identifier&amp; identifier = vm.propertyNames-&gt;length;
      rareData-&gt;setHasReifiedLength();
      putDirect(vm, identifier, initialValue, initialAttributes);
  }
  
<span class="line-modified">! void JSFunction::reifyName(VM&amp; vm, ExecState* exec)</span>
  {
      const Identifier&amp; ecmaName = jsExecutable()-&gt;ecmaName();
      String name;
      // https://tc39.github.io/ecma262/#sec-exports-runtime-semantics-evaluation
      // When the ident is &quot;*default*&quot;, we need to set &quot;default&quot; for the ecma name.
      // This &quot;*default*&quot; name is never shown to users.
      if (ecmaName == vm.propertyNames-&gt;builtinNames().starDefaultPrivateName())
          name = vm.propertyNames-&gt;defaultKeyword.string();
      else
          name = ecmaName.string();
<span class="line-modified">!     reifyName(vm, exec, name);</span>
  }
  
<span class="line-modified">! void JSFunction::reifyName(VM&amp; vm, ExecState* exec, String name)</span>
  {
<span class="line-modified">!     FunctionRareData* rareData = this-&gt;rareData(vm);</span>
  
      ASSERT(!hasReifiedName());
      ASSERT(!isHostFunction());
      unsigned initialAttributes = PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
      const Identifier&amp; propID = vm.propertyNames-&gt;name;
  
<span class="line-modified">!     if (exec-&gt;lexicalGlobalObject()-&gt;needsSiteSpecificQuirks()) {</span>
          auto illegalCharMatcher = [] (UChar ch) -&gt; bool {
              return ch == &#39; &#39; || ch == &#39;|&#39;;
          };
          if (name.find(illegalCharMatcher) != notFound)
              name = String();
<span class="line-new-header">--- 764,61 ---</span>
          if (uid.isNullSymbol())
              name = emptyString();
          else
              name = makeString(&#39;[&#39;, String(&amp;uid), &#39;]&#39;);
      } else {
<span class="line-modified">!         JSString* jsStr = value.toString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!         name = jsStr-&gt;value(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
<span class="line-modified">!     reifyName(vm, globalObject, name);</span>
  }
  
  void JSFunction::reifyLength(VM&amp; vm)
  {
<span class="line-modified">!     FunctionRareData* rareData = this-&gt;ensureRareData(vm);</span>
  
      ASSERT(!hasReifiedLength());
<span class="line-modified">!     unsigned length = 0;</span>
<span class="line-modified">!     if (this-&gt;inherits&lt;JSBoundFunction&gt;(vm))</span>
<span class="line-added">+         length = jsCast&lt;JSBoundFunction*&gt;(this)-&gt;length(vm);</span>
<span class="line-added">+     else {</span>
<span class="line-added">+         ASSERT(!isHostFunction());</span>
<span class="line-added">+         length = jsExecutable()-&gt;parameterCount();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     JSValue initialValue = jsNumber(length);</span>
      unsigned initialAttributes = PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
      const Identifier&amp; identifier = vm.propertyNames-&gt;length;
      rareData-&gt;setHasReifiedLength();
      putDirect(vm, identifier, initialValue, initialAttributes);
  }
  
<span class="line-modified">! void JSFunction::reifyName(VM&amp; vm, JSGlobalObject* globalObject)</span>
  {
      const Identifier&amp; ecmaName = jsExecutable()-&gt;ecmaName();
      String name;
      // https://tc39.github.io/ecma262/#sec-exports-runtime-semantics-evaluation
      // When the ident is &quot;*default*&quot;, we need to set &quot;default&quot; for the ecma name.
      // This &quot;*default*&quot; name is never shown to users.
      if (ecmaName == vm.propertyNames-&gt;builtinNames().starDefaultPrivateName())
          name = vm.propertyNames-&gt;defaultKeyword.string();
      else
          name = ecmaName.string();
<span class="line-modified">!     reifyName(vm, globalObject, name);</span>
  }
  
<span class="line-modified">! void JSFunction::reifyName(VM&amp; vm, JSGlobalObject* globalObject, String name)</span>
  {
<span class="line-modified">!     FunctionRareData* rareData = this-&gt;ensureRareData(vm);</span>
  
      ASSERT(!hasReifiedName());
      ASSERT(!isHostFunction());
      unsigned initialAttributes = PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
      const Identifier&amp; propID = vm.propertyNames-&gt;name;
  
<span class="line-modified">!     if (globalObject-&gt;needsSiteSpecificQuirks()) {</span>
          auto illegalCharMatcher = [] (UChar ch) -&gt; bool {
              return ch == &#39; &#39; || ch == &#39;|&#39;;
          };
          if (name.find(illegalCharMatcher) != notFound)
              name = String();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 753,35 ***</span>
  
      rareData-&gt;setHasReifiedName();
      putDirect(vm, propID, jsString(vm, name), initialAttributes);
  }
  
<span class="line-modified">! JSFunction::PropertyStatus JSFunction::reifyLazyPropertyIfNeeded(VM&amp; vm, ExecState* exec, PropertyName propertyName)</span>
  {
<span class="line-modified">!     if (isHostOrBuiltinFunction())</span>
          return PropertyStatus::Eager;
<span class="line-modified">!     PropertyStatus lazyLength = reifyLazyLengthIfNeeded(vm, exec, propertyName);</span>
      if (isLazy(lazyLength))
          return lazyLength;
<span class="line-modified">!     PropertyStatus lazyName = reifyLazyNameIfNeeded(vm, exec, propertyName);</span>
      if (isLazy(lazyName))
          return lazyName;
      return PropertyStatus::Eager;
  }
  
<span class="line-modified">! JSFunction::PropertyStatus JSFunction::reifyLazyPropertyForHostOrBuiltinIfNeeded(VM&amp; vm, ExecState* exec, PropertyName propertyName)</span>
  {
      ASSERT(isHostOrBuiltinFunction());
<span class="line-modified">!     if (isBuiltinFunction()) {</span>
<span class="line-modified">!         PropertyStatus lazyLength = reifyLazyLengthIfNeeded(vm, exec, propertyName);</span>
          if (isLazy(lazyLength))
              return lazyLength;
      }
<span class="line-modified">!     return reifyLazyBoundNameIfNeeded(vm, exec, propertyName);</span>
  }
  
<span class="line-modified">! JSFunction::PropertyStatus JSFunction::reifyLazyLengthIfNeeded(VM&amp; vm, ExecState*, PropertyName propertyName)</span>
  {
      if (propertyName == vm.propertyNames-&gt;length) {
          if (!hasReifiedLength()) {
              reifyLength(vm);
              return PropertyStatus::Reified;
<span class="line-new-header">--- 831,35 ---</span>
  
      rareData-&gt;setHasReifiedName();
      putDirect(vm, propID, jsString(vm, name), initialAttributes);
  }
  
<span class="line-modified">! JSFunction::PropertyStatus JSFunction::reifyLazyPropertyIfNeeded(VM&amp; vm, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
<span class="line-modified">!     if (isHostOrBuiltinFunction() &amp;&amp; !this-&gt;inherits&lt;JSBoundFunction&gt;(vm))</span>
          return PropertyStatus::Eager;
<span class="line-modified">!     PropertyStatus lazyLength = reifyLazyLengthIfNeeded(vm, globalObject, propertyName);</span>
      if (isLazy(lazyLength))
          return lazyLength;
<span class="line-modified">!     PropertyStatus lazyName = reifyLazyNameIfNeeded(vm, globalObject, propertyName);</span>
      if (isLazy(lazyName))
          return lazyName;
      return PropertyStatus::Eager;
  }
  
<span class="line-modified">! JSFunction::PropertyStatus JSFunction::reifyLazyPropertyForHostOrBuiltinIfNeeded(VM&amp; vm, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
      ASSERT(isHostOrBuiltinFunction());
<span class="line-modified">!     if (isBuiltinFunction() || this-&gt;inherits&lt;JSBoundFunction&gt;(vm)) {</span>
<span class="line-modified">!         PropertyStatus lazyLength = reifyLazyLengthIfNeeded(vm, globalObject, propertyName);</span>
          if (isLazy(lazyLength))
              return lazyLength;
      }
<span class="line-modified">!     return reifyLazyBoundNameIfNeeded(vm, globalObject, propertyName);</span>
  }
  
<span class="line-modified">! JSFunction::PropertyStatus JSFunction::reifyLazyLengthIfNeeded(VM&amp; vm, JSGlobalObject*, PropertyName propertyName)</span>
  {
      if (propertyName == vm.propertyNames-&gt;length) {
          if (!hasReifiedLength()) {
              reifyLength(vm);
              return PropertyStatus::Reified;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 789,51 ***</span>
          return PropertyStatus::Lazy;
      }
      return PropertyStatus::Eager;
  }
  
<span class="line-modified">! JSFunction::PropertyStatus JSFunction::reifyLazyNameIfNeeded(VM&amp; vm, ExecState* exec, PropertyName propertyName)</span>
  {
      if (propertyName == vm.propertyNames-&gt;name) {
          if (!hasReifiedName()) {
<span class="line-modified">!             reifyName(vm, exec);</span>
              return PropertyStatus::Reified;
          }
          return PropertyStatus::Lazy;
      }
      return PropertyStatus::Eager;
  }
  
<span class="line-modified">! JSFunction::PropertyStatus JSFunction::reifyLazyBoundNameIfNeeded(VM&amp; vm, ExecState* exec, PropertyName propertyName)</span>
  {
      const Identifier&amp; nameIdent = vm.propertyNames-&gt;name;
      if (propertyName != nameIdent)
          return PropertyStatus::Eager;
  
      if (hasReifiedName())
          return PropertyStatus::Lazy;
  
      if (isBuiltinFunction())
<span class="line-modified">!         reifyName(vm, exec);</span>
      else if (this-&gt;inherits&lt;JSBoundFunction&gt;(vm)) {
<span class="line-modified">!         FunctionRareData* rareData = this-&gt;rareData(vm);</span>
<span class="line-modified">!         String name = makeString(&quot;bound &quot;, static_cast&lt;NativeExecutable*&gt;(m_executable.get())-&gt;name());</span>
          unsigned initialAttributes = PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
          rareData-&gt;setHasReifiedName();
<span class="line-modified">!         putDirect(vm, nameIdent, jsString(vm, name), initialAttributes);</span>
      }
      return PropertyStatus::Reified;
  }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  void JSFunction::assertTypeInfoFlagInvariants()
  {
      // If you change this, you&#39;ll need to update speculationFromClassInfo.
      const ClassInfo* info = classInfo(vm());
      if (!(inlineTypeFlags() &amp; ImplementsDefaultHasInstance))
          RELEASE_ASSERT(info == JSBoundFunction::info());
      else
          RELEASE_ASSERT(info != JSBoundFunction::info());
  }
<span class="line-modified">! #endif</span>
  
  } // namespace JSC
<span class="line-new-header">--- 867,59 ---</span>
          return PropertyStatus::Lazy;
      }
      return PropertyStatus::Eager;
  }
  
<span class="line-modified">! JSFunction::PropertyStatus JSFunction::reifyLazyNameIfNeeded(VM&amp; vm, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
      if (propertyName == vm.propertyNames-&gt;name) {
          if (!hasReifiedName()) {
<span class="line-modified">!             reifyName(vm, globalObject);</span>
              return PropertyStatus::Reified;
          }
          return PropertyStatus::Lazy;
      }
      return PropertyStatus::Eager;
  }
  
<span class="line-modified">! JSFunction::PropertyStatus JSFunction::reifyLazyBoundNameIfNeeded(VM&amp; vm, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
      const Identifier&amp; nameIdent = vm.propertyNames-&gt;name;
      if (propertyName != nameIdent)
          return PropertyStatus::Eager;
  
      if (hasReifiedName())
          return PropertyStatus::Lazy;
  
      if (isBuiltinFunction())
<span class="line-modified">!         reifyName(vm, globalObject);</span>
      else if (this-&gt;inherits&lt;JSBoundFunction&gt;(vm)) {
<span class="line-modified">!         FunctionRareData* rareData = this-&gt;ensureRareData(vm);</span>
<span class="line-modified">!         JSString* nameMayBeNull = jsCast&lt;JSBoundFunction*&gt;(this)-&gt;nameMayBeNull();</span>
<span class="line-added">+         JSString* string = nullptr;</span>
<span class="line-added">+         if (nameMayBeNull) {</span>
<span class="line-added">+             string = jsString(globalObject, vm.smallStrings.boundPrefixString(), nameMayBeNull);</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, PropertyStatus::Lazy);</span>
<span class="line-added">+         } else</span>
<span class="line-added">+             string = jsEmptyString(vm);</span>
          unsigned initialAttributes = PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
          rareData-&gt;setHasReifiedName();
<span class="line-modified">!         putDirect(vm, nameIdent, string, initialAttributes);</span>
      }
      return PropertyStatus::Reified;
  }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  void JSFunction::assertTypeInfoFlagInvariants()
  {
      // If you change this, you&#39;ll need to update speculationFromClassInfo.
      const ClassInfo* info = classInfo(vm());
      if (!(inlineTypeFlags() &amp; ImplementsDefaultHasInstance))
          RELEASE_ASSERT(info == JSBoundFunction::info());
      else
          RELEASE_ASSERT(info != JSBoundFunction::info());
  }
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
  } // namespace JSC
</pre>
<center><a href="JSDestructibleObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSFunction.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
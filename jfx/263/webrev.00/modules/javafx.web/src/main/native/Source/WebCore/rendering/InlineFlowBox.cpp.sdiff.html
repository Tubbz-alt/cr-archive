<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineFlowBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineFlowBox.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineFlowBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  79     LayoutUnit totalWidth = marginBorderPaddingLogicalLeft() + marginBorderPaddingLogicalRight();
  80     for (InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine()) {
  81         if (is&lt;InlineFlowBox&gt;(*child))
  82             totalWidth += downcast&lt;InlineFlowBox&gt;(*child).getFlowSpacingLogicalWidth();
  83     }
  84     return totalWidth;
  85 }
  86 
  87 static void setHasTextDescendantsOnAncestors(InlineFlowBox* box)
  88 {
  89     while (box &amp;&amp; !box-&gt;hasTextDescendants()) {
  90         box-&gt;setHasTextDescendants();
  91         box = box-&gt;parent();
  92     }
  93 }
  94 
  95 void InlineFlowBox::addToLine(InlineBox* child)
  96 {
  97     ASSERT(!child-&gt;parent());
  98     ASSERT(!child-&gt;nextOnLine());
<span class="line-modified">  99     ASSERT(!child-&gt;prevOnLine());</span>
 100     checkConsistency();
 101 
 102     child-&gt;setParent(this);
 103     if (!m_firstChild) {
 104         m_firstChild = child;
 105         m_lastChild = child;
 106     } else {
 107         m_lastChild-&gt;setNextOnLine(child);
<span class="line-modified"> 108         child-&gt;setPrevOnLine(m_lastChild);</span>
 109         m_lastChild = child;
 110     }
 111     child-&gt;setIsFirstLine(isFirstLine());
 112     child-&gt;setIsHorizontal(isHorizontal());
 113     if (child-&gt;behavesLikeText()) {
 114         if (child-&gt;renderer().parent() == &amp;renderer())
 115             m_hasTextChildren = true;
 116         setHasTextDescendantsOnAncestors(this);
 117     } else if (is&lt;InlineFlowBox&gt;(*child)) {
 118         if (downcast&lt;InlineFlowBox&gt;(*child).hasTextDescendants())
 119             setHasTextDescendantsOnAncestors(this);
 120     }
 121     if (descendantsHaveSameLineHeightAndBaseline() &amp;&amp; !child-&gt;renderer().isOutOfFlowPositioned()) {
 122         const RenderStyle&amp; parentStyle = lineStyle();
 123         const RenderStyle&amp; childStyle = child-&gt;lineStyle();
 124         bool shouldClearDescendantsHaveSameLineHeightAndBaseline = false;
 125         if (child-&gt;renderer().isReplaced())
 126             shouldClearDescendantsHaveSameLineHeightAndBaseline = true;
 127         else if (child-&gt;behavesLikeText()) {
 128             if (child-&gt;renderer().isLineBreak() || child-&gt;renderer().parent() != &amp;renderer()) {
</pre>
<hr />
<pre>
 178 
 179         if (knownToHaveNoOverflow() &amp;&amp; is&lt;InlineFlowBox&gt;(*child) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(*child).knownToHaveNoOverflow())
 180             clearKnownToHaveNoOverflow();
 181     }
 182 
 183     checkConsistency();
 184 }
 185 
 186 void InlineFlowBox::removeChild(InlineBox* child)
 187 {
 188     checkConsistency();
 189 
 190     if (!isDirty())
 191         dirtyLineBoxes();
 192 
 193     root().childRemoved(child);
 194 
 195     if (child == m_firstChild)
 196         m_firstChild = child-&gt;nextOnLine();
 197     if (child == m_lastChild)
<span class="line-modified"> 198         m_lastChild = child-&gt;prevOnLine();</span>
 199     if (child-&gt;nextOnLine())
<span class="line-modified"> 200         child-&gt;nextOnLine()-&gt;setPrevOnLine(child-&gt;prevOnLine());</span>
<span class="line-modified"> 201     if (child-&gt;prevOnLine())</span>
<span class="line-modified"> 202         child-&gt;prevOnLine()-&gt;setNextOnLine(child-&gt;nextOnLine());</span>
 203 
 204     child-&gt;setParent(nullptr);
 205 
 206     checkConsistency();
 207 }
 208 
 209 void InlineFlowBox::deleteLine()
 210 {
 211     InlineBox* child = firstChild();
 212     InlineBox* next = nullptr;
 213     while (child) {
 214         ASSERT(this == child-&gt;parent());
 215         next = child-&gt;nextOnLine();
 216 #ifndef NDEBUG
 217         child-&gt;setParent(nullptr);
 218 #endif
 219         child-&gt;deleteLine();
 220         child = next;
 221     }
 222 #ifndef NDEBUG
</pre>
<hr />
<pre>
 375     float minLogicalLeft = startLogicalLeft;
 376     float maxLogicalRight = logicalLeft;
 377 
 378     placeBoxRangeInInlineDirection(firstChild(), nullptr, logicalLeft, minLogicalLeft, maxLogicalRight, needsWordSpacing);
 379 
 380     logicalLeft += borderLogicalRight() + paddingLogicalRight();
 381     endPlacingBoxRangesInInlineDirection(startLogicalLeft, logicalLeft, minLogicalLeft, maxLogicalRight);
 382     return logicalLeft;
 383 }
 384 
 385 float InlineFlowBox::placeBoxRangeInInlineDirection(InlineBox* firstChild, InlineBox* lastChild, float&amp; logicalLeft, float&amp; minLogicalLeft, float&amp; maxLogicalRight, bool&amp; needsWordSpacing)
 386 {
 387     float totalExpansion = 0;
 388     for (InlineBox* child = firstChild; child &amp;&amp; child != lastChild; child = child-&gt;nextOnLine()) {
 389         if (is&lt;RenderText&gt;(child-&gt;renderer())) {
 390             auto&amp; textBox = downcast&lt;InlineTextBox&gt;(*child);
 391             RenderText&amp; renderText = textBox.renderer();
 392             if (renderText.text().length()) {
 393                 if (needsWordSpacing &amp;&amp; isSpaceOrNewline(renderText.characterAt(textBox.start())))
 394                     logicalLeft += textBox.lineStyle().fontCascade().wordSpacing();
<span class="line-modified"> 395                 needsWordSpacing = !isSpaceOrNewline(renderText.characterAt(textBox.end()));</span>
 396             }
 397             textBox.setLogicalLeft(logicalLeft);
 398             if (knownToHaveNoOverflow())
 399                 minLogicalLeft = std::min(logicalLeft, minLogicalLeft);
 400             logicalLeft += textBox.logicalWidth();
 401             totalExpansion += textBox.expansion();
 402             if (knownToHaveNoOverflow())
 403                 maxLogicalRight = std::max(logicalLeft, maxLogicalRight);
 404         } else {
 405             if (child-&gt;renderer().isOutOfFlowPositioned()) {
 406                 if (child-&gt;renderer().parent()-&gt;style().isLeftToRightDirection())
 407                     child-&gt;setLogicalLeft(logicalLeft);
 408                 else
 409                     // Our offset that we cache needs to be from the edge of the right border box and
 410                     // not the left border box.  We have to subtract |x| from the width of the block
 411                     // (which can be obtained from the root line box).
 412                     child-&gt;setLogicalLeft(root().blockFlow().logicalWidth() - logicalLeft);
 413                 continue; // The positioned object has no effect on the width.
 414             }
 415             if (is&lt;RenderInline&gt;(child-&gt;renderer())) {
</pre>
<hr />
<pre>
1051     setLayoutOverflow(layoutOverflow, lineTop, lineBottom);
1052 
1053     LayoutRect visualOverflow(isHorizontal() ? logicalVisualOverflow : logicalVisualOverflow.transposedRect());
1054     setVisualOverflow(visualOverflow, lineTop, lineBottom);
1055 }
1056 
1057 bool InlineFlowBox::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, LayoutUnit lineTop, LayoutUnit lineBottom, HitTestAction hitTestAction)
1058 {
1059     if (hitTestAction != HitTestForeground)
1060         return false;
1061 
1062     LayoutRect overflowRect(visualOverflowRect(lineTop, lineBottom));
1063     flipForWritingMode(overflowRect);
1064     overflowRect.moveBy(accumulatedOffset);
1065     if (!locationInContainer.intersects(overflowRect))
1066         return false;
1067 
1068     // Check children first.
1069     // We need to account for culled inline parents of the hit-tested nodes, so that they may also get included in area-based hit-tests.
1070     RenderElement* culledParent = nullptr;
<span class="line-modified">1071     for (InlineBox* child = lastChild(); child; child = child-&gt;prevOnLine()) {</span>
1072         if (is&lt;RenderText&gt;(child-&gt;renderer()) || !child-&gt;boxModelObject()-&gt;hasSelfPaintingLayer()) {
1073             RenderElement* newParent = nullptr;
1074             // Culled parents are only relevant for area-based hit-tests, so ignore it in point-based ones.
1075             if (locationInContainer.isRectBasedTest()) {
1076                 newParent = child-&gt;renderer().parent();
1077                 if (newParent == &amp;renderer())
1078                     newParent = nullptr;
1079             }
1080             // Check the culled parent after all its children have been checked, to do this we wait until
1081             // we are about to test an element with a different parent.
1082             if (newParent != culledParent) {
1083                 if (!newParent || !newParent-&gt;isDescendantOf(culledParent)) {
1084                     while (culledParent &amp;&amp; culledParent != &amp;renderer() &amp;&amp; culledParent != newParent) {
1085                         if (is&lt;RenderInline&gt;(*culledParent) &amp;&amp; downcast&lt;RenderInline&gt;(*culledParent).hitTestCulledInline(request, result, locationInContainer, accumulatedOffset))
1086                             return true;
1087                         culledParent = culledParent-&gt;parent();
1088                     }
1089                 }
1090                 culledParent = newParent;
1091             }
</pre>
<hr />
<pre>
1350     // You can use p::first-line to specify a background. If so, the root line boxes for
1351     // a line may actually have to paint a background.
1352     if (parent() &amp;&amp; !renderer().hasVisibleBoxDecorations())
1353         return;
1354     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
1355     if (!parent() &amp;&amp; (!isFirstLine() || &amp;lineStyle == &amp;renderer().style()))
1356         return;
1357 
1358     LayoutRect frameRect(this-&gt;frameRect());
1359     constrainToLineTopAndBottomIfNeeded(frameRect);
1360 
1361     // Move x/y to our coordinates.
1362     LayoutRect localRect(frameRect);
1363     flipForWritingMode(localRect);
1364 
1365     LayoutPoint adjustedPaintoffset = paintOffset + localRect.location();
1366     GraphicsContext&amp; context = paintInfo.context();
1367     LayoutRect paintRect = LayoutRect(adjustedPaintoffset, frameRect.size());
1368     // Shadow comes first and is behind the background and border.
1369     if (!renderer().boxShadowShouldBeAppliedToBackground(adjustedPaintoffset, BackgroundBleedNone, this))
<span class="line-modified">1370         paintBoxShadow(paintInfo, lineStyle, Normal, paintRect);</span>
1371 
1372     auto color = lineStyle.visitedDependentColor(CSSPropertyBackgroundColor);
1373     auto compositeOp = renderer().document().compositeOperatorForBackgroundColor(color, renderer());
1374 
1375     color = lineStyle.colorByApplyingColorFilter(color);
1376 
1377     paintFillLayers(paintInfo, color, lineStyle.backgroundLayers(), paintRect, compositeOp);
<span class="line-modified">1378     paintBoxShadow(paintInfo, lineStyle, Inset, paintRect);</span>
1379 
1380     // :first-line cannot be used to put borders on a line. Always paint borders with our
1381     // non-first-line style.
1382     if (!parent() || !renderer().style().hasVisibleBorderDecoration())
1383         return;
1384     const NinePieceImage&amp; borderImage = renderer().style().borderImage();
1385     StyleImage* borderImageSource = borderImage.image();
1386     bool hasBorderImage = borderImageSource &amp;&amp; borderImageSource-&gt;canRender(&amp;renderer(), lineStyle.effectiveZoom());
1387     if (hasBorderImage &amp;&amp; !borderImageSource-&gt;isLoaded())
1388         return; // Don&#39;t paint anything while we wait for the image to load.
1389 
1390     // The simple case is where we either have no border image or we are the only box for this object. In those
1391     // cases only a single call to draw is required.
1392     if (!hasBorderImage || (!prevLineBox() &amp;&amp; !nextLineBox()))
1393         renderer().paintBorder(paintInfo, paintRect, lineStyle, BackgroundBleedNone, includeLogicalLeftEdge(), includeLogicalRightEdge());
1394     else {
1395         // We have a border image that spans multiple lines.
1396         // We need to adjust tx and ty by the width of all previous lines.
1397         // Think of border image painting on inlines as though you had one long line, a single continuous
1398         // strip. Even though that strip has been broken up across multiple lines, you still paint it
</pre>
<hr />
<pre>
1421 void InlineFlowBox::paintMask(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1422 {
1423     if (!paintInfo.shouldPaintWithinRoot(renderer()) || renderer().style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::Mask)
1424         return;
1425 
1426     LayoutRect frameRect(this-&gt;frameRect());
1427     constrainToLineTopAndBottomIfNeeded(frameRect);
1428 
1429     // Move x/y to our coordinates.
1430     LayoutRect localRect(frameRect);
1431     flipForWritingMode(localRect);
1432     LayoutPoint adjustedPaintOffset = paintOffset + localRect.location();
1433 
1434     const NinePieceImage&amp; maskNinePieceImage = renderer().style().maskBoxImage();
1435     StyleImage* maskBoxImage = renderer().style().maskBoxImage().image();
1436 
1437     // Figure out if we need to push a transparency layer to render our mask.
1438     bool pushTransparencyLayer = false;
1439     bool compositedMask = renderer().hasLayer() &amp;&amp; renderer().layer()-&gt;hasCompositedMask();
1440     bool flattenCompositingLayers = renderer().view().frameView().paintBehavior().contains(PaintBehavior::FlattenCompositingLayers);
<span class="line-modified">1441     CompositeOperator compositeOp = CompositeSourceOver;</span>
1442     if (!compositedMask || flattenCompositingLayers) {
1443         if ((maskBoxImage &amp;&amp; renderer().style().maskLayers().hasImage()) || renderer().style().maskLayers().next())
1444             pushTransparencyLayer = true;
1445 
<span class="line-modified">1446         compositeOp = CompositeDestinationIn;</span>
1447         if (pushTransparencyLayer) {
<span class="line-modified">1448             paintInfo.context().setCompositeOperation(CompositeDestinationIn);</span>
1449             paintInfo.context().beginTransparencyLayer(1.0f);
<span class="line-modified">1450             compositeOp = CompositeSourceOver;</span>
1451         }
1452     }
1453 
1454     LayoutRect paintRect = LayoutRect(adjustedPaintOffset, frameRect.size());
1455     paintFillLayers(paintInfo, Color(), renderer().style().maskLayers(), paintRect, compositeOp);
1456 
1457     bool hasBoxImage = maskBoxImage &amp;&amp; maskBoxImage-&gt;canRender(&amp;renderer(), renderer().style().effectiveZoom());
1458     if (!hasBoxImage || !maskBoxImage-&gt;isLoaded()) {
1459         if (pushTransparencyLayer)
1460             paintInfo.context().endTransparencyLayer();
1461         return; // Don&#39;t paint anything while we wait for the image to load.
1462     }
1463 
1464     // The simple case is where we are the only box for this object.  In those
1465     // cases only a single call to draw is required.
1466     if (!prevLineBox() &amp;&amp; !nextLineBox()) {
1467         renderer().paintNinePieceImage(paintInfo.context(), LayoutRect(adjustedPaintOffset, frameRect.size()), renderer().style(), maskNinePieceImage, compositeOp);
1468     } else {
1469         // We have a mask image that spans multiple lines.
1470         // We need to adjust _tx and _ty by the width of all previous lines.
</pre>
<hr />
<pre>
1472         for (InlineFlowBox* curr = prevLineBox(); curr; curr = curr-&gt;prevLineBox())
1473             logicalOffsetOnLine += curr-&gt;logicalWidth();
1474         LayoutUnit totalLogicalWidth = logicalOffsetOnLine;
1475         for (InlineFlowBox* curr = this; curr; curr = curr-&gt;nextLineBox())
1476             totalLogicalWidth += curr-&gt;logicalWidth();
1477         LayoutUnit stripX = adjustedPaintOffset.x() - (isHorizontal() ? logicalOffsetOnLine : 0_lu);
1478         LayoutUnit stripY = adjustedPaintOffset.y() - (isHorizontal() ? 0_lu : logicalOffsetOnLine);
1479         LayoutUnit stripWidth = isHorizontal() ? totalLogicalWidth : frameRect.width();
1480         LayoutUnit stripHeight = isHorizontal() ? frameRect.height() : totalLogicalWidth;
1481 
1482         LayoutRect clipRect = clipRectForNinePieceImageStrip(this, maskNinePieceImage, paintRect);
1483         GraphicsContextStateSaver stateSaver(paintInfo.context());
1484         paintInfo.context().clip(clipRect);
1485         renderer().paintNinePieceImage(paintInfo.context(), LayoutRect(stripX, stripY, stripWidth, stripHeight), renderer().style(), maskNinePieceImage, compositeOp);
1486     }
1487 
1488     if (pushTransparencyLayer)
1489         paintInfo.context().endTransparencyLayer();
1490 }
1491 
<span class="line-modified">1492 InlineBox* InlineFlowBox::firstLeafChild() const</span>
1493 {
1494     InlineBox* leaf = nullptr;
1495     for (InlineBox* child = firstChild(); child &amp;&amp; !leaf; child = child-&gt;nextOnLine())
<span class="line-modified">1496         leaf = child-&gt;isLeaf() ? child : downcast&lt;InlineFlowBox&gt;(*child).firstLeafChild();</span>
1497     return leaf;
1498 }
1499 
<span class="line-modified">1500 InlineBox* InlineFlowBox::lastLeafChild() const</span>
1501 {
1502     InlineBox* leaf = nullptr;
<span class="line-modified">1503     for (InlineBox* child = lastChild(); child &amp;&amp; !leaf; child = child-&gt;prevOnLine())</span>
<span class="line-modified">1504         leaf = child-&gt;isLeaf() ? child : downcast&lt;InlineFlowBox&gt;(*child).lastLeafChild();</span>
1505     return leaf;
1506 }
1507 
1508 RenderObject::SelectionState InlineFlowBox::selectionState()
1509 {
1510     return RenderObject::SelectionNone;
1511 }
1512 
1513 bool InlineFlowBox::canAccommodateEllipsis(bool ltr, int blockEdge, int ellipsisWidth) const
1514 {
1515     for (InlineBox *box = firstChild(); box; box = box-&gt;nextOnLine()) {
1516         if (!box-&gt;canAccommodateEllipsis(ltr, blockEdge, ellipsisWidth))
1517             return false;
1518     }
1519     return true;
1520 }
1521 
1522 float InlineFlowBox::placeEllipsisBox(bool ltr, float blockLeftEdge, float blockRightEdge, float ellipsisWidth, float &amp;truncatedWidth, bool&amp; foundBox)
1523 {
1524     float result = -1;
</pre>
<hr />
<pre>
1526     // box containing the ellipsis.  All boxes after that one in the flow are hidden.
1527     // If our flow is ltr then iterate over the boxes from left to right, otherwise iterate
1528     // from right to left. Varying the order allows us to correctly hide the boxes following the ellipsis.
1529     InlineBox* box = ltr ? firstChild() : lastChild();
1530 
1531     // NOTE: these will cross after foundBox = true.
1532     int visibleLeftEdge = blockLeftEdge;
1533     int visibleRightEdge = blockRightEdge;
1534 
1535     while (box) {
1536         int currResult = box-&gt;placeEllipsisBox(ltr, visibleLeftEdge, visibleRightEdge, ellipsisWidth, truncatedWidth, foundBox);
1537         if (currResult != -1 &amp;&amp; result == -1)
1538             result = currResult;
1539 
1540         if (ltr) {
1541             visibleLeftEdge += box-&gt;logicalWidth();
1542             box = box-&gt;nextOnLine();
1543         }
1544         else {
1545             visibleRightEdge -= box-&gt;logicalWidth();
<span class="line-modified">1546             box = box-&gt;prevOnLine();</span>
1547         }
1548     }
1549     return result;
1550 }
1551 
1552 void InlineFlowBox::clearTruncation()
1553 {
1554     for (InlineBox *box = firstChild(); box; box = box-&gt;nextOnLine())
1555         box-&gt;clearTruncation();
1556 }
1557 
1558 LayoutUnit InlineFlowBox::computeOverAnnotationAdjustment(LayoutUnit allowedPosition) const
1559 {
1560     LayoutUnit result;
1561     for (InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine()) {
1562         if (child-&gt;renderer().isOutOfFlowPositioned())
1563             continue; // Positioned placeholders don&#39;t affect calculations.
1564 
1565         if (is&lt;InlineFlowBox&gt;(*child))
1566             result = std::max(result, downcast&lt;InlineFlowBox&gt;(*child).computeOverAnnotationAdjustment(allowedPosition));
</pre>
<hr />
<pre>
1636 
1637         if (is&lt;InlineTextBox&gt;(*child)) {
1638             const RenderStyle&amp; childLineStyle = child-&gt;lineStyle();
1639             Optional&lt;bool&gt; markExistsAndIsAbove = downcast&lt;InlineTextBox&gt;(*child).emphasisMarkExistsAndIsAbove(childLineStyle);
1640             if (markExistsAndIsAbove &amp;&amp; !*markExistsAndIsAbove) {
1641                 if (!childLineStyle.isFlippedLinesWritingMode()) {
1642                     LayoutUnit bottomOfEmphasisMark { child-&gt;logicalBottom() + childLineStyle.fontCascade().emphasisMarkHeight(childLineStyle.textEmphasisMarkString()) };
1643                     result = std::max(result, bottomOfEmphasisMark - allowedPosition);
1644                 } else {
1645                     LayoutUnit topOfEmphasisMark { child-&gt;logicalTop() - childLineStyle.fontCascade().emphasisMarkHeight(childLineStyle.textEmphasisMarkString()) };
1646                     result = std::max(result, allowedPosition - topOfEmphasisMark);
1647                 }
1648             }
1649         }
1650     }
1651     return result;
1652 }
1653 
1654 void InlineFlowBox::collectLeafBoxesInLogicalOrder(Vector&lt;InlineBox*&gt;&amp; leafBoxesInLogicalOrder, CustomInlineBoxRangeReverse customReverseImplementation, void* userData) const
1655 {
<span class="line-modified">1656     InlineBox* leaf = firstLeafChild();</span>
1657 
1658     // FIXME: The reordering code is a copy of parts from BidiResolver::createBidiRunsForLine, operating directly on InlineBoxes, instead of BidiRuns.
1659     // Investigate on how this code could possibly be shared.
1660     unsigned char minLevel = 128;
1661     unsigned char maxLevel = 0;
1662 
1663     // First find highest and lowest levels, and initialize leafBoxesInLogicalOrder with the leaf boxes in visual order.
<span class="line-modified">1664     for (; leaf; leaf = leaf-&gt;nextLeafChild()) {</span>
1665         minLevel = std::min(minLevel, leaf-&gt;bidiLevel());
1666         maxLevel = std::max(maxLevel, leaf-&gt;bidiLevel());
1667         leafBoxesInLogicalOrder.append(leaf);
1668     }
1669 
1670     if (renderer().style().rtlOrdering() == Order::Visual)
1671         return;
1672 
1673     // Reverse of reordering of the line (L2 according to Bidi spec):
1674     // L2. From the highest level found in the text to the lowest odd level on each line,
1675     // reverse any contiguous sequence of characters that are at that level or higher.
1676 
1677     // Reversing the reordering of the line is only done up to the lowest odd level.
1678     if (!(minLevel % 2))
1679         ++minLevel;
1680 
1681     Vector&lt;InlineBox*&gt;::iterator end = leafBoxesInLogicalOrder.end();
1682     while (minLevel &lt;= maxLevel) {
1683         Vector&lt;InlineBox*&gt;::iterator it = leafBoxesInLogicalOrder.begin();
1684         while (it != end) {
</pre>
<hr />
<pre>
1727 
1728 void InlineFlowBox::outputLineTreeAndMark(WTF::TextStream&amp; stream, const InlineBox* markedBox, int depth) const
1729 {
1730     InlineBox::outputLineTreeAndMark(stream, markedBox, depth);
1731     for (const InlineBox* box = firstChild(); box; box = box-&gt;nextOnLine())
1732         box-&gt;outputLineTreeAndMark(stream, markedBox, depth + 1);
1733 }
1734 
1735 #endif
1736 
1737 #ifndef NDEBUG
1738 
1739 void InlineFlowBox::checkConsistency() const
1740 {
1741     assertNotDeleted();
1742     ASSERT_WITH_SECURITY_IMPLICATION(!m_hasBadChildList);
1743 #ifdef CHECK_CONSISTENCY
1744     const InlineBox* previousChild = nullptr;
1745     for (const InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine()) {
1746         ASSERT(child-&gt;parent() == this);
<span class="line-modified">1747         ASSERT(child-&gt;prevOnLine() == previousChild);</span>
1748         previousChild = child;
1749     }
1750     ASSERT(previousChild == m_lastChild);
1751 #endif
1752 }
1753 
1754 #endif
1755 
1756 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  79     LayoutUnit totalWidth = marginBorderPaddingLogicalLeft() + marginBorderPaddingLogicalRight();
  80     for (InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine()) {
  81         if (is&lt;InlineFlowBox&gt;(*child))
  82             totalWidth += downcast&lt;InlineFlowBox&gt;(*child).getFlowSpacingLogicalWidth();
  83     }
  84     return totalWidth;
  85 }
  86 
  87 static void setHasTextDescendantsOnAncestors(InlineFlowBox* box)
  88 {
  89     while (box &amp;&amp; !box-&gt;hasTextDescendants()) {
  90         box-&gt;setHasTextDescendants();
  91         box = box-&gt;parent();
  92     }
  93 }
  94 
  95 void InlineFlowBox::addToLine(InlineBox* child)
  96 {
  97     ASSERT(!child-&gt;parent());
  98     ASSERT(!child-&gt;nextOnLine());
<span class="line-modified">  99     ASSERT(!child-&gt;previousOnLine());</span>
 100     checkConsistency();
 101 
 102     child-&gt;setParent(this);
 103     if (!m_firstChild) {
 104         m_firstChild = child;
 105         m_lastChild = child;
 106     } else {
 107         m_lastChild-&gt;setNextOnLine(child);
<span class="line-modified"> 108         child-&gt;setPreviousOnLine(m_lastChild);</span>
 109         m_lastChild = child;
 110     }
 111     child-&gt;setIsFirstLine(isFirstLine());
 112     child-&gt;setIsHorizontal(isHorizontal());
 113     if (child-&gt;behavesLikeText()) {
 114         if (child-&gt;renderer().parent() == &amp;renderer())
 115             m_hasTextChildren = true;
 116         setHasTextDescendantsOnAncestors(this);
 117     } else if (is&lt;InlineFlowBox&gt;(*child)) {
 118         if (downcast&lt;InlineFlowBox&gt;(*child).hasTextDescendants())
 119             setHasTextDescendantsOnAncestors(this);
 120     }
 121     if (descendantsHaveSameLineHeightAndBaseline() &amp;&amp; !child-&gt;renderer().isOutOfFlowPositioned()) {
 122         const RenderStyle&amp; parentStyle = lineStyle();
 123         const RenderStyle&amp; childStyle = child-&gt;lineStyle();
 124         bool shouldClearDescendantsHaveSameLineHeightAndBaseline = false;
 125         if (child-&gt;renderer().isReplaced())
 126             shouldClearDescendantsHaveSameLineHeightAndBaseline = true;
 127         else if (child-&gt;behavesLikeText()) {
 128             if (child-&gt;renderer().isLineBreak() || child-&gt;renderer().parent() != &amp;renderer()) {
</pre>
<hr />
<pre>
 178 
 179         if (knownToHaveNoOverflow() &amp;&amp; is&lt;InlineFlowBox&gt;(*child) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(*child).knownToHaveNoOverflow())
 180             clearKnownToHaveNoOverflow();
 181     }
 182 
 183     checkConsistency();
 184 }
 185 
 186 void InlineFlowBox::removeChild(InlineBox* child)
 187 {
 188     checkConsistency();
 189 
 190     if (!isDirty())
 191         dirtyLineBoxes();
 192 
 193     root().childRemoved(child);
 194 
 195     if (child == m_firstChild)
 196         m_firstChild = child-&gt;nextOnLine();
 197     if (child == m_lastChild)
<span class="line-modified"> 198         m_lastChild = child-&gt;previousOnLine();</span>
 199     if (child-&gt;nextOnLine())
<span class="line-modified"> 200         child-&gt;nextOnLine()-&gt;setPreviousOnLine(child-&gt;previousOnLine());</span>
<span class="line-modified"> 201     if (child-&gt;previousOnLine())</span>
<span class="line-modified"> 202         child-&gt;previousOnLine()-&gt;setNextOnLine(child-&gt;nextOnLine());</span>
 203 
 204     child-&gt;setParent(nullptr);
 205 
 206     checkConsistency();
 207 }
 208 
 209 void InlineFlowBox::deleteLine()
 210 {
 211     InlineBox* child = firstChild();
 212     InlineBox* next = nullptr;
 213     while (child) {
 214         ASSERT(this == child-&gt;parent());
 215         next = child-&gt;nextOnLine();
 216 #ifndef NDEBUG
 217         child-&gt;setParent(nullptr);
 218 #endif
 219         child-&gt;deleteLine();
 220         child = next;
 221     }
 222 #ifndef NDEBUG
</pre>
<hr />
<pre>
 375     float minLogicalLeft = startLogicalLeft;
 376     float maxLogicalRight = logicalLeft;
 377 
 378     placeBoxRangeInInlineDirection(firstChild(), nullptr, logicalLeft, minLogicalLeft, maxLogicalRight, needsWordSpacing);
 379 
 380     logicalLeft += borderLogicalRight() + paddingLogicalRight();
 381     endPlacingBoxRangesInInlineDirection(startLogicalLeft, logicalLeft, minLogicalLeft, maxLogicalRight);
 382     return logicalLeft;
 383 }
 384 
 385 float InlineFlowBox::placeBoxRangeInInlineDirection(InlineBox* firstChild, InlineBox* lastChild, float&amp; logicalLeft, float&amp; minLogicalLeft, float&amp; maxLogicalRight, bool&amp; needsWordSpacing)
 386 {
 387     float totalExpansion = 0;
 388     for (InlineBox* child = firstChild; child &amp;&amp; child != lastChild; child = child-&gt;nextOnLine()) {
 389         if (is&lt;RenderText&gt;(child-&gt;renderer())) {
 390             auto&amp; textBox = downcast&lt;InlineTextBox&gt;(*child);
 391             RenderText&amp; renderText = textBox.renderer();
 392             if (renderText.text().length()) {
 393                 if (needsWordSpacing &amp;&amp; isSpaceOrNewline(renderText.characterAt(textBox.start())))
 394                     logicalLeft += textBox.lineStyle().fontCascade().wordSpacing();
<span class="line-modified"> 395                 needsWordSpacing = !isSpaceOrNewline(renderText.characterAt(textBox.end() - 1));</span>
 396             }
 397             textBox.setLogicalLeft(logicalLeft);
 398             if (knownToHaveNoOverflow())
 399                 minLogicalLeft = std::min(logicalLeft, minLogicalLeft);
 400             logicalLeft += textBox.logicalWidth();
 401             totalExpansion += textBox.expansion();
 402             if (knownToHaveNoOverflow())
 403                 maxLogicalRight = std::max(logicalLeft, maxLogicalRight);
 404         } else {
 405             if (child-&gt;renderer().isOutOfFlowPositioned()) {
 406                 if (child-&gt;renderer().parent()-&gt;style().isLeftToRightDirection())
 407                     child-&gt;setLogicalLeft(logicalLeft);
 408                 else
 409                     // Our offset that we cache needs to be from the edge of the right border box and
 410                     // not the left border box.  We have to subtract |x| from the width of the block
 411                     // (which can be obtained from the root line box).
 412                     child-&gt;setLogicalLeft(root().blockFlow().logicalWidth() - logicalLeft);
 413                 continue; // The positioned object has no effect on the width.
 414             }
 415             if (is&lt;RenderInline&gt;(child-&gt;renderer())) {
</pre>
<hr />
<pre>
1051     setLayoutOverflow(layoutOverflow, lineTop, lineBottom);
1052 
1053     LayoutRect visualOverflow(isHorizontal() ? logicalVisualOverflow : logicalVisualOverflow.transposedRect());
1054     setVisualOverflow(visualOverflow, lineTop, lineBottom);
1055 }
1056 
1057 bool InlineFlowBox::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, LayoutUnit lineTop, LayoutUnit lineBottom, HitTestAction hitTestAction)
1058 {
1059     if (hitTestAction != HitTestForeground)
1060         return false;
1061 
1062     LayoutRect overflowRect(visualOverflowRect(lineTop, lineBottom));
1063     flipForWritingMode(overflowRect);
1064     overflowRect.moveBy(accumulatedOffset);
1065     if (!locationInContainer.intersects(overflowRect))
1066         return false;
1067 
1068     // Check children first.
1069     // We need to account for culled inline parents of the hit-tested nodes, so that they may also get included in area-based hit-tests.
1070     RenderElement* culledParent = nullptr;
<span class="line-modified">1071     for (InlineBox* child = lastChild(); child; child = child-&gt;previousOnLine()) {</span>
1072         if (is&lt;RenderText&gt;(child-&gt;renderer()) || !child-&gt;boxModelObject()-&gt;hasSelfPaintingLayer()) {
1073             RenderElement* newParent = nullptr;
1074             // Culled parents are only relevant for area-based hit-tests, so ignore it in point-based ones.
1075             if (locationInContainer.isRectBasedTest()) {
1076                 newParent = child-&gt;renderer().parent();
1077                 if (newParent == &amp;renderer())
1078                     newParent = nullptr;
1079             }
1080             // Check the culled parent after all its children have been checked, to do this we wait until
1081             // we are about to test an element with a different parent.
1082             if (newParent != culledParent) {
1083                 if (!newParent || !newParent-&gt;isDescendantOf(culledParent)) {
1084                     while (culledParent &amp;&amp; culledParent != &amp;renderer() &amp;&amp; culledParent != newParent) {
1085                         if (is&lt;RenderInline&gt;(*culledParent) &amp;&amp; downcast&lt;RenderInline&gt;(*culledParent).hitTestCulledInline(request, result, locationInContainer, accumulatedOffset))
1086                             return true;
1087                         culledParent = culledParent-&gt;parent();
1088                     }
1089                 }
1090                 culledParent = newParent;
1091             }
</pre>
<hr />
<pre>
1350     // You can use p::first-line to specify a background. If so, the root line boxes for
1351     // a line may actually have to paint a background.
1352     if (parent() &amp;&amp; !renderer().hasVisibleBoxDecorations())
1353         return;
1354     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
1355     if (!parent() &amp;&amp; (!isFirstLine() || &amp;lineStyle == &amp;renderer().style()))
1356         return;
1357 
1358     LayoutRect frameRect(this-&gt;frameRect());
1359     constrainToLineTopAndBottomIfNeeded(frameRect);
1360 
1361     // Move x/y to our coordinates.
1362     LayoutRect localRect(frameRect);
1363     flipForWritingMode(localRect);
1364 
1365     LayoutPoint adjustedPaintoffset = paintOffset + localRect.location();
1366     GraphicsContext&amp; context = paintInfo.context();
1367     LayoutRect paintRect = LayoutRect(adjustedPaintoffset, frameRect.size());
1368     // Shadow comes first and is behind the background and border.
1369     if (!renderer().boxShadowShouldBeAppliedToBackground(adjustedPaintoffset, BackgroundBleedNone, this))
<span class="line-modified">1370         paintBoxShadow(paintInfo, lineStyle, ShadowStyle::Normal, paintRect);</span>
1371 
1372     auto color = lineStyle.visitedDependentColor(CSSPropertyBackgroundColor);
1373     auto compositeOp = renderer().document().compositeOperatorForBackgroundColor(color, renderer());
1374 
1375     color = lineStyle.colorByApplyingColorFilter(color);
1376 
1377     paintFillLayers(paintInfo, color, lineStyle.backgroundLayers(), paintRect, compositeOp);
<span class="line-modified">1378     paintBoxShadow(paintInfo, lineStyle, ShadowStyle::Inset, paintRect);</span>
1379 
1380     // :first-line cannot be used to put borders on a line. Always paint borders with our
1381     // non-first-line style.
1382     if (!parent() || !renderer().style().hasVisibleBorderDecoration())
1383         return;
1384     const NinePieceImage&amp; borderImage = renderer().style().borderImage();
1385     StyleImage* borderImageSource = borderImage.image();
1386     bool hasBorderImage = borderImageSource &amp;&amp; borderImageSource-&gt;canRender(&amp;renderer(), lineStyle.effectiveZoom());
1387     if (hasBorderImage &amp;&amp; !borderImageSource-&gt;isLoaded())
1388         return; // Don&#39;t paint anything while we wait for the image to load.
1389 
1390     // The simple case is where we either have no border image or we are the only box for this object. In those
1391     // cases only a single call to draw is required.
1392     if (!hasBorderImage || (!prevLineBox() &amp;&amp; !nextLineBox()))
1393         renderer().paintBorder(paintInfo, paintRect, lineStyle, BackgroundBleedNone, includeLogicalLeftEdge(), includeLogicalRightEdge());
1394     else {
1395         // We have a border image that spans multiple lines.
1396         // We need to adjust tx and ty by the width of all previous lines.
1397         // Think of border image painting on inlines as though you had one long line, a single continuous
1398         // strip. Even though that strip has been broken up across multiple lines, you still paint it
</pre>
<hr />
<pre>
1421 void InlineFlowBox::paintMask(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1422 {
1423     if (!paintInfo.shouldPaintWithinRoot(renderer()) || renderer().style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::Mask)
1424         return;
1425 
1426     LayoutRect frameRect(this-&gt;frameRect());
1427     constrainToLineTopAndBottomIfNeeded(frameRect);
1428 
1429     // Move x/y to our coordinates.
1430     LayoutRect localRect(frameRect);
1431     flipForWritingMode(localRect);
1432     LayoutPoint adjustedPaintOffset = paintOffset + localRect.location();
1433 
1434     const NinePieceImage&amp; maskNinePieceImage = renderer().style().maskBoxImage();
1435     StyleImage* maskBoxImage = renderer().style().maskBoxImage().image();
1436 
1437     // Figure out if we need to push a transparency layer to render our mask.
1438     bool pushTransparencyLayer = false;
1439     bool compositedMask = renderer().hasLayer() &amp;&amp; renderer().layer()-&gt;hasCompositedMask();
1440     bool flattenCompositingLayers = renderer().view().frameView().paintBehavior().contains(PaintBehavior::FlattenCompositingLayers);
<span class="line-modified">1441     CompositeOperator compositeOp = CompositeOperator::SourceOver;</span>
1442     if (!compositedMask || flattenCompositingLayers) {
1443         if ((maskBoxImage &amp;&amp; renderer().style().maskLayers().hasImage()) || renderer().style().maskLayers().next())
1444             pushTransparencyLayer = true;
1445 
<span class="line-modified">1446         compositeOp = CompositeOperator::DestinationIn;</span>
1447         if (pushTransparencyLayer) {
<span class="line-modified">1448             paintInfo.context().setCompositeOperation(CompositeOperator::DestinationIn);</span>
1449             paintInfo.context().beginTransparencyLayer(1.0f);
<span class="line-modified">1450             compositeOp = CompositeOperator::SourceOver;</span>
1451         }
1452     }
1453 
1454     LayoutRect paintRect = LayoutRect(adjustedPaintOffset, frameRect.size());
1455     paintFillLayers(paintInfo, Color(), renderer().style().maskLayers(), paintRect, compositeOp);
1456 
1457     bool hasBoxImage = maskBoxImage &amp;&amp; maskBoxImage-&gt;canRender(&amp;renderer(), renderer().style().effectiveZoom());
1458     if (!hasBoxImage || !maskBoxImage-&gt;isLoaded()) {
1459         if (pushTransparencyLayer)
1460             paintInfo.context().endTransparencyLayer();
1461         return; // Don&#39;t paint anything while we wait for the image to load.
1462     }
1463 
1464     // The simple case is where we are the only box for this object.  In those
1465     // cases only a single call to draw is required.
1466     if (!prevLineBox() &amp;&amp; !nextLineBox()) {
1467         renderer().paintNinePieceImage(paintInfo.context(), LayoutRect(adjustedPaintOffset, frameRect.size()), renderer().style(), maskNinePieceImage, compositeOp);
1468     } else {
1469         // We have a mask image that spans multiple lines.
1470         // We need to adjust _tx and _ty by the width of all previous lines.
</pre>
<hr />
<pre>
1472         for (InlineFlowBox* curr = prevLineBox(); curr; curr = curr-&gt;prevLineBox())
1473             logicalOffsetOnLine += curr-&gt;logicalWidth();
1474         LayoutUnit totalLogicalWidth = logicalOffsetOnLine;
1475         for (InlineFlowBox* curr = this; curr; curr = curr-&gt;nextLineBox())
1476             totalLogicalWidth += curr-&gt;logicalWidth();
1477         LayoutUnit stripX = adjustedPaintOffset.x() - (isHorizontal() ? logicalOffsetOnLine : 0_lu);
1478         LayoutUnit stripY = adjustedPaintOffset.y() - (isHorizontal() ? 0_lu : logicalOffsetOnLine);
1479         LayoutUnit stripWidth = isHorizontal() ? totalLogicalWidth : frameRect.width();
1480         LayoutUnit stripHeight = isHorizontal() ? frameRect.height() : totalLogicalWidth;
1481 
1482         LayoutRect clipRect = clipRectForNinePieceImageStrip(this, maskNinePieceImage, paintRect);
1483         GraphicsContextStateSaver stateSaver(paintInfo.context());
1484         paintInfo.context().clip(clipRect);
1485         renderer().paintNinePieceImage(paintInfo.context(), LayoutRect(stripX, stripY, stripWidth, stripHeight), renderer().style(), maskNinePieceImage, compositeOp);
1486     }
1487 
1488     if (pushTransparencyLayer)
1489         paintInfo.context().endTransparencyLayer();
1490 }
1491 
<span class="line-modified">1492 InlineBox* InlineFlowBox::firstLeafDescendant() const</span>
1493 {
1494     InlineBox* leaf = nullptr;
1495     for (InlineBox* child = firstChild(); child &amp;&amp; !leaf; child = child-&gt;nextOnLine())
<span class="line-modified">1496         leaf = child-&gt;isLeaf() ? child : downcast&lt;InlineFlowBox&gt;(*child).firstLeafDescendant();</span>
1497     return leaf;
1498 }
1499 
<span class="line-modified">1500 InlineBox* InlineFlowBox::lastLeafDescendant() const</span>
1501 {
1502     InlineBox* leaf = nullptr;
<span class="line-modified">1503     for (InlineBox* child = lastChild(); child &amp;&amp; !leaf; child = child-&gt;previousOnLine())</span>
<span class="line-modified">1504         leaf = child-&gt;isLeaf() ? child : downcast&lt;InlineFlowBox&gt;(*child).lastLeafDescendant();</span>
1505     return leaf;
1506 }
1507 
1508 RenderObject::SelectionState InlineFlowBox::selectionState()
1509 {
1510     return RenderObject::SelectionNone;
1511 }
1512 
1513 bool InlineFlowBox::canAccommodateEllipsis(bool ltr, int blockEdge, int ellipsisWidth) const
1514 {
1515     for (InlineBox *box = firstChild(); box; box = box-&gt;nextOnLine()) {
1516         if (!box-&gt;canAccommodateEllipsis(ltr, blockEdge, ellipsisWidth))
1517             return false;
1518     }
1519     return true;
1520 }
1521 
1522 float InlineFlowBox::placeEllipsisBox(bool ltr, float blockLeftEdge, float blockRightEdge, float ellipsisWidth, float &amp;truncatedWidth, bool&amp; foundBox)
1523 {
1524     float result = -1;
</pre>
<hr />
<pre>
1526     // box containing the ellipsis.  All boxes after that one in the flow are hidden.
1527     // If our flow is ltr then iterate over the boxes from left to right, otherwise iterate
1528     // from right to left. Varying the order allows us to correctly hide the boxes following the ellipsis.
1529     InlineBox* box = ltr ? firstChild() : lastChild();
1530 
1531     // NOTE: these will cross after foundBox = true.
1532     int visibleLeftEdge = blockLeftEdge;
1533     int visibleRightEdge = blockRightEdge;
1534 
1535     while (box) {
1536         int currResult = box-&gt;placeEllipsisBox(ltr, visibleLeftEdge, visibleRightEdge, ellipsisWidth, truncatedWidth, foundBox);
1537         if (currResult != -1 &amp;&amp; result == -1)
1538             result = currResult;
1539 
1540         if (ltr) {
1541             visibleLeftEdge += box-&gt;logicalWidth();
1542             box = box-&gt;nextOnLine();
1543         }
1544         else {
1545             visibleRightEdge -= box-&gt;logicalWidth();
<span class="line-modified">1546             box = box-&gt;previousOnLine();</span>
1547         }
1548     }
1549     return result;
1550 }
1551 
1552 void InlineFlowBox::clearTruncation()
1553 {
1554     for (InlineBox *box = firstChild(); box; box = box-&gt;nextOnLine())
1555         box-&gt;clearTruncation();
1556 }
1557 
1558 LayoutUnit InlineFlowBox::computeOverAnnotationAdjustment(LayoutUnit allowedPosition) const
1559 {
1560     LayoutUnit result;
1561     for (InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine()) {
1562         if (child-&gt;renderer().isOutOfFlowPositioned())
1563             continue; // Positioned placeholders don&#39;t affect calculations.
1564 
1565         if (is&lt;InlineFlowBox&gt;(*child))
1566             result = std::max(result, downcast&lt;InlineFlowBox&gt;(*child).computeOverAnnotationAdjustment(allowedPosition));
</pre>
<hr />
<pre>
1636 
1637         if (is&lt;InlineTextBox&gt;(*child)) {
1638             const RenderStyle&amp; childLineStyle = child-&gt;lineStyle();
1639             Optional&lt;bool&gt; markExistsAndIsAbove = downcast&lt;InlineTextBox&gt;(*child).emphasisMarkExistsAndIsAbove(childLineStyle);
1640             if (markExistsAndIsAbove &amp;&amp; !*markExistsAndIsAbove) {
1641                 if (!childLineStyle.isFlippedLinesWritingMode()) {
1642                     LayoutUnit bottomOfEmphasisMark { child-&gt;logicalBottom() + childLineStyle.fontCascade().emphasisMarkHeight(childLineStyle.textEmphasisMarkString()) };
1643                     result = std::max(result, bottomOfEmphasisMark - allowedPosition);
1644                 } else {
1645                     LayoutUnit topOfEmphasisMark { child-&gt;logicalTop() - childLineStyle.fontCascade().emphasisMarkHeight(childLineStyle.textEmphasisMarkString()) };
1646                     result = std::max(result, allowedPosition - topOfEmphasisMark);
1647                 }
1648             }
1649         }
1650     }
1651     return result;
1652 }
1653 
1654 void InlineFlowBox::collectLeafBoxesInLogicalOrder(Vector&lt;InlineBox*&gt;&amp; leafBoxesInLogicalOrder, CustomInlineBoxRangeReverse customReverseImplementation, void* userData) const
1655 {
<span class="line-modified">1656     InlineBox* leaf = firstLeafDescendant();</span>
1657 
1658     // FIXME: The reordering code is a copy of parts from BidiResolver::createBidiRunsForLine, operating directly on InlineBoxes, instead of BidiRuns.
1659     // Investigate on how this code could possibly be shared.
1660     unsigned char minLevel = 128;
1661     unsigned char maxLevel = 0;
1662 
1663     // First find highest and lowest levels, and initialize leafBoxesInLogicalOrder with the leaf boxes in visual order.
<span class="line-modified">1664     for (; leaf; leaf = leaf-&gt;nextLeafOnLine()) {</span>
1665         minLevel = std::min(minLevel, leaf-&gt;bidiLevel());
1666         maxLevel = std::max(maxLevel, leaf-&gt;bidiLevel());
1667         leafBoxesInLogicalOrder.append(leaf);
1668     }
1669 
1670     if (renderer().style().rtlOrdering() == Order::Visual)
1671         return;
1672 
1673     // Reverse of reordering of the line (L2 according to Bidi spec):
1674     // L2. From the highest level found in the text to the lowest odd level on each line,
1675     // reverse any contiguous sequence of characters that are at that level or higher.
1676 
1677     // Reversing the reordering of the line is only done up to the lowest odd level.
1678     if (!(minLevel % 2))
1679         ++minLevel;
1680 
1681     Vector&lt;InlineBox*&gt;::iterator end = leafBoxesInLogicalOrder.end();
1682     while (minLevel &lt;= maxLevel) {
1683         Vector&lt;InlineBox*&gt;::iterator it = leafBoxesInLogicalOrder.begin();
1684         while (it != end) {
</pre>
<hr />
<pre>
1727 
1728 void InlineFlowBox::outputLineTreeAndMark(WTF::TextStream&amp; stream, const InlineBox* markedBox, int depth) const
1729 {
1730     InlineBox::outputLineTreeAndMark(stream, markedBox, depth);
1731     for (const InlineBox* box = firstChild(); box; box = box-&gt;nextOnLine())
1732         box-&gt;outputLineTreeAndMark(stream, markedBox, depth + 1);
1733 }
1734 
1735 #endif
1736 
1737 #ifndef NDEBUG
1738 
1739 void InlineFlowBox::checkConsistency() const
1740 {
1741     assertNotDeleted();
1742     ASSERT_WITH_SECURITY_IMPLICATION(!m_hasBadChildList);
1743 #ifdef CHECK_CONSISTENCY
1744     const InlineBox* previousChild = nullptr;
1745     for (const InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine()) {
1746         ASSERT(child-&gt;parent() == this);
<span class="line-modified">1747         ASSERT(child-&gt;previousOnLine() == previousChild);</span>
1748         previousChild = child;
1749     }
1750     ASSERT(previousChild == m_lastChild);
1751 #endif
1752 }
1753 
1754 #endif
1755 
1756 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InlineBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineFlowBox.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
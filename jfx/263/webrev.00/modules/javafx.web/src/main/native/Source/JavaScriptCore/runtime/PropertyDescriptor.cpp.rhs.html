<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/PropertyDescriptor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 
 27 #include &quot;config.h&quot;
 28 
 29 #include &quot;PropertyDescriptor.h&quot;
 30 
 31 #include &quot;GetterSetter.h&quot;
 32 #include &quot;JSObject.h&quot;
 33 #include &quot;JSCInlines.h&quot;
 34 
 35 namespace JSC {
 36 unsigned PropertyDescriptor::defaultAttributes = PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
 37 
 38 bool PropertyDescriptor::writable() const
 39 {
 40     ASSERT(!isAccessorDescriptor());
 41     return !(m_attributes &amp; PropertyAttribute::ReadOnly);
 42 }
 43 
 44 bool PropertyDescriptor::enumerable() const
 45 {
 46     return !(m_attributes &amp; PropertyAttribute::DontEnum);
 47 }
 48 
 49 bool PropertyDescriptor::configurable() const
 50 {
 51     return !(m_attributes &amp; PropertyAttribute::DontDelete);
 52 }
 53 
 54 bool PropertyDescriptor::isDataDescriptor() const
 55 {
 56     return m_value || (m_seenAttributes &amp; WritablePresent);
 57 }
 58 
 59 bool PropertyDescriptor::isGenericDescriptor() const
 60 {
 61     return !isAccessorDescriptor() &amp;&amp; !isDataDescriptor();
 62 }
 63 
 64 bool PropertyDescriptor::isAccessorDescriptor() const
 65 {
 66     return m_getter || m_setter;
 67 }
 68 
 69 void PropertyDescriptor::setUndefined()
 70 {
 71     m_value = jsUndefined();
 72     m_attributes = PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::DontEnum;
 73 }
 74 
<a name="2" id="anc2"></a><span class="line-modified"> 75 GetterSetter* PropertyDescriptor::slowGetterSetter(JSGlobalObject* globalObject)</span>
 76 {
<a name="3" id="anc3"></a><span class="line-modified"> 77     VM&amp; vm = globalObject-&gt;vm();</span>

 78     JSValue getter = m_getter &amp;&amp; !m_getter.isUndefined() ? jsCast&lt;JSObject*&gt;(m_getter) : jsUndefined();
 79     JSValue setter = m_setter &amp;&amp; !m_setter.isUndefined() ? jsCast&lt;JSObject*&gt;(m_setter) : jsUndefined();
 80     return GetterSetter::create(vm, globalObject, getter, setter);
 81 }
 82 
 83 JSValue PropertyDescriptor::getter() const
 84 {
 85     ASSERT(isAccessorDescriptor());
 86     return m_getter;
 87 }
 88 
 89 JSValue PropertyDescriptor::setter() const
 90 {
 91     ASSERT(isAccessorDescriptor());
 92     return m_setter;
 93 }
 94 
 95 JSObject* PropertyDescriptor::getterObject() const
 96 {
 97     ASSERT(isAccessorDescriptor() &amp;&amp; getterPresent());
 98     return m_getter.isObject() ? asObject(m_getter) : 0;
 99 }
100 
101 JSObject* PropertyDescriptor::setterObject() const
102 {
103     ASSERT(isAccessorDescriptor() &amp;&amp; setterPresent());
104     return m_setter.isObject() ? asObject(m_setter) : 0;
105 }
106 
107 void PropertyDescriptor::setDescriptor(JSValue value, unsigned attributes)
108 {
109     ASSERT(value);
110 
111     // We need to mask off the PropertyAttribute::CustomValue bit because
112     // PropertyDescriptor::attributesEqual() does an equivalent test on
113     // m_attributes, and a property that has a CustomValue should be indistinguishable
114     // from a property that has a normal value as far as JS code is concerned.
115     // PropertyAttribute does not need knowledge of the underlying implementation
116     // actually being a CustomValue. So, we&#39;ll just mask it off up front here.
117     m_attributes = attributes &amp; ~PropertyAttribute::CustomValue;
118     if (value.isGetterSetter()) {
119         m_attributes &amp;= ~PropertyAttribute::ReadOnly; // FIXME: we should be able to ASSERT this!
120 
121         GetterSetter* accessor = jsCast&lt;GetterSetter*&gt;(value);
122         m_getter = !accessor-&gt;isGetterNull() ? accessor-&gt;getter() : jsUndefined();
123         m_setter = !accessor-&gt;isSetterNull() ? accessor-&gt;setter() : jsUndefined();
124         m_seenAttributes = EnumerablePresent | ConfigurablePresent;
125     } else {
126         m_value = value;
127         m_seenAttributes = EnumerablePresent | ConfigurablePresent | WritablePresent;
128     }
129 }
130 
131 void PropertyDescriptor::setCustomDescriptor(unsigned attributes)
132 {
133     ASSERT(!(attributes &amp; PropertyAttribute::CustomValue));
134     m_attributes = attributes | PropertyAttribute::Accessor | PropertyAttribute::CustomAccessor;
135     m_attributes &amp;= ~PropertyAttribute::ReadOnly;
136     m_seenAttributes = EnumerablePresent | ConfigurablePresent;
137     setGetter(jsUndefined());
138     setSetter(jsUndefined());
139     m_value = JSValue();
140 }
141 
142 void PropertyDescriptor::setAccessorDescriptor(GetterSetter* accessor, unsigned attributes)
143 {
144     ASSERT(attributes &amp; PropertyAttribute::Accessor);
145     ASSERT(!(attributes &amp; PropertyAttribute::CustomValue));
146     attributes &amp;= ~PropertyAttribute::ReadOnly; // FIXME: we should be able to ASSERT this!
147 
148     m_attributes = attributes;
149     m_getter = !accessor-&gt;isGetterNull() ? accessor-&gt;getter() : jsUndefined();
150     m_setter = !accessor-&gt;isSetterNull() ? accessor-&gt;setter() : jsUndefined();
151     m_seenAttributes = EnumerablePresent | ConfigurablePresent;
152 }
153 
154 void PropertyDescriptor::setWritable(bool writable)
155 {
156     if (writable)
157         m_attributes &amp;= ~PropertyAttribute::ReadOnly;
158     else
159         m_attributes |= PropertyAttribute::ReadOnly;
160     m_seenAttributes |= WritablePresent;
161 }
162 
163 void PropertyDescriptor::setEnumerable(bool enumerable)
164 {
165     if (enumerable)
166         m_attributes &amp;= ~PropertyAttribute::DontEnum;
167     else
168         m_attributes |= PropertyAttribute::DontEnum;
169     m_seenAttributes |= EnumerablePresent;
170 }
171 
172 void PropertyDescriptor::setConfigurable(bool configurable)
173 {
174     if (configurable)
175         m_attributes &amp;= ~PropertyAttribute::DontDelete;
176     else
177         m_attributes |= PropertyAttribute::DontDelete;
178     m_seenAttributes |= ConfigurablePresent;
179 }
180 
181 void PropertyDescriptor::setSetter(JSValue setter)
182 {
183     m_setter = setter;
184     m_attributes |= PropertyAttribute::Accessor;
185     m_attributes &amp;= ~PropertyAttribute::ReadOnly;
186 }
187 
188 void PropertyDescriptor::setGetter(JSValue getter)
189 {
190     m_getter = getter;
191     m_attributes |= PropertyAttribute::Accessor;
192     m_attributes &amp;= ~PropertyAttribute::ReadOnly;
193 }
194 
<a name="4" id="anc4"></a><span class="line-modified">195 bool PropertyDescriptor::equalTo(JSGlobalObject* globalObject, const PropertyDescriptor&amp; other) const</span>
196 {
<a name="5" id="anc5"></a><span class="line-added">197     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">198     auto scope = DECLARE_THROW_SCOPE(vm);</span>
199     if (other.m_value.isEmpty() != m_value.isEmpty()
200         || other.m_getter.isEmpty() != m_getter.isEmpty()
201         || other.m_setter.isEmpty() != m_setter.isEmpty())
202         return false;
<a name="6" id="anc6"></a><span class="line-modified">203     if (m_value) {</span>
<span class="line-modified">204         bool isSame = sameValue(globalObject, other.m_value, m_value);</span>
<span class="line-modified">205         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">206         if (!isSame)</span>
<span class="line-added">207             return false;</span>
<span class="line-added">208     }</span>
<span class="line-added">209     return (!m_getter || JSValue::strictEqual(globalObject, other.m_getter, m_getter))</span>
<span class="line-added">210         &amp;&amp; (!m_setter || JSValue::strictEqual(globalObject, other.m_setter, m_setter))</span>
211         &amp;&amp; attributesEqual(other);
212 }
213 
214 bool PropertyDescriptor::attributesEqual(const PropertyDescriptor&amp; other) const
215 {
216     unsigned mismatch = other.m_attributes ^ m_attributes;
217     unsigned sharedSeen = other.m_seenAttributes &amp; m_seenAttributes;
218     if (sharedSeen &amp; WritablePresent &amp;&amp; mismatch &amp; PropertyAttribute::ReadOnly)
219         return false;
220     if (sharedSeen &amp; ConfigurablePresent &amp;&amp; mismatch &amp; PropertyAttribute::DontDelete)
221         return false;
222     if (sharedSeen &amp; EnumerablePresent &amp;&amp; mismatch &amp; PropertyAttribute::DontEnum)
223         return false;
224     return true;
225 }
226 
227 unsigned PropertyDescriptor::attributesOverridingCurrent(const PropertyDescriptor&amp; current) const
228 {
229     unsigned currentAttributes = current.m_attributes;
230     if (isDataDescriptor() &amp;&amp; current.isAccessorDescriptor())
231         currentAttributes |= PropertyAttribute::ReadOnly;
232     unsigned overrideMask = 0;
233     if (writablePresent())
234         overrideMask |= PropertyAttribute::ReadOnly;
235     if (enumerablePresent())
236         overrideMask |= PropertyAttribute::DontEnum;
237     if (configurablePresent())
238         overrideMask |= PropertyAttribute::DontDelete;
239     if (isAccessorDescriptor())
240         overrideMask |= PropertyAttribute::Accessor;
241     return (m_attributes &amp; overrideMask) | (currentAttributes &amp; ~overrideMask &amp; ~PropertyAttribute::CustomAccessor);
242 }
243 
244 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
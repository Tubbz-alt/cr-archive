diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/libwebrtc/LibWebRTCProvider.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/libwebrtc/LibWebRTCProvider.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/libwebrtc/LibWebRTCProvider.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/libwebrtc/LibWebRTCProvider.h
@@ -24,24 +24,23 @@
  */
 
 #pragma once
 
 #include "LibWebRTCMacros.h"
-#include <pal/SessionID.h>
 #include <wtf/CompletionHandler.h>
 #include <wtf/Expected.h>
 #include <wtf/UniqueRef.h>
 #include <wtf/text/WTFString.h>
 
 #if USE(LIBWEBRTC)
 
 ALLOW_UNUSED_PARAMETERS_BEGIN
 
-#include <webrtc/api/peerconnectioninterface.h>
+#include <webrtc/api/peer_connection_interface.h>
 #include <webrtc/api/video_codecs/video_encoder_factory.h>
 #include <webrtc/api/video_codecs/video_decoder_factory.h>
-#include <webrtc/rtc_base/scoped_ref_ptr.h>
+#include <webrtc/api/scoped_refptr.h>
 
 ALLOW_UNUSED_PARAMETERS_END
 
 namespace rtc {
 class NetworkManager;
@@ -82,11 +81,11 @@
     virtual void unregisterMDNSNames(uint64_t documentIdentifier)
     {
         UNUSED_PARAM(documentIdentifier);
     }
 
-    virtual void registerMDNSName(PAL::SessionID, uint64_t documentIdentifier, const String& ipAddress, CompletionHandler<void(MDNSNameOrError&&)>&& callback)
+    virtual void registerMDNSName(uint64_t documentIdentifier, const String& ipAddress, CompletionHandler<void(MDNSNameOrError&&)>&& callback)
     {
         UNUSED_PARAM(documentIdentifier);
         UNUSED_PARAM(ipAddress);
         callback(makeUnexpected(MDNSRegisterError::NotImplemented));
     }
@@ -97,10 +96,11 @@
     webrtc::PeerConnectionFactoryInterface* factory();
 
     // FIXME: Make these methods not static.
     static void callOnWebRTCNetworkThread(Function<void()>&&);
     static void callOnWebRTCSignalingThread(Function<void()>&&);
+    static bool hasWebRTCThreads();
 
     // Used for mock testing
     void setPeerConnectionFactory(rtc::scoped_refptr<webrtc::PeerConnectionFactoryInterface>&&);
 
     void disableEnumeratingAllNetworkInterfaces();
@@ -116,12 +116,20 @@
 
     void clearFactory() { m_factory = nullptr; }
 
     void setEnableLogging(bool);
     void setEnableWebRTCEncryption(bool);
+    void setUseDTLS10(bool);
+    void setUseGPUProcess(bool);
 
-    virtual std::unique_ptr<rtc::PacketSocketFactory> createSocketFactory(PAL::SessionID, String&& /* userAgent */) { return nullptr; }
+    class SuspendableSocketFactory : public rtc::PacketSocketFactory {
+    public:
+        virtual ~SuspendableSocketFactory() = default;
+        virtual void suspend() { };
+        virtual void resume() { };
+    };
+    virtual std::unique_ptr<SuspendableSocketFactory> createSocketFactory(String&& /* userAgent */) { return nullptr; }
 
 protected:
     LibWebRTCProvider() = default;
 
     rtc::scoped_refptr<webrtc::PeerConnectionInterface> createPeerConnection(webrtc::PeerConnectionObserver&, rtc::NetworkManager&, rtc::PacketSocketFactory&, webrtc::PeerConnectionInterface::RTCConfiguration&&, std::unique_ptr<webrtc::AsyncResolverFactory>&&);
@@ -136,10 +144,12 @@
 
     rtc::scoped_refptr<webrtc::PeerConnectionFactoryInterface> m_factory;
     bool m_disableNonLocalhostConnections { false };
     bool m_supportsVP8 { false };
     bool m_enableLogging { true };
+    bool m_useDTLS10 { false };
+    bool m_useGPUProcess { false };
 #endif
 };
 
 } // namespace WebCore
 

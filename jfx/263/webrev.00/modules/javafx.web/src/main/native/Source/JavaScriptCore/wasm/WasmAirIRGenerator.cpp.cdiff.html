<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmAirIRGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../tools/VMInspector.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmAirIRGenerator.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmAirIRGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  
  #if ENABLE(WEBASSEMBLY)
  
  #include &quot;AirCode.h&quot;
  #include &quot;AirGenerate.h&quot;
<span class="line-added">+ #include &quot;AirHelpers.h&quot;</span>
  #include &quot;AirOpcodeUtils.h&quot;
  #include &quot;AirValidate.h&quot;
  #include &quot;AllowMacroScratchRegisterUsageIf.h&quot;
  #include &quot;B3CCallValue.h&quot;
  #include &quot;B3CheckSpecial.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,20 ***</span>
<span class="line-new-header">--- 66,23 ---</span>
  namespace JSC { namespace Wasm {
  
  using namespace B3::Air;
  
  struct ConstrainedTmp {
<span class="line-added">+     ConstrainedTmp() = default;</span>
      ConstrainedTmp(Tmp tmp)
          : ConstrainedTmp(tmp, tmp.isReg() ? B3::ValueRep::reg(tmp.reg()) : B3::ValueRep::SomeRegister)
      { }
  
      ConstrainedTmp(Tmp tmp, B3::ValueRep rep)
          : tmp(tmp)
          , rep(rep)
      {
      }
  
<span class="line-added">+     explicit operator bool() const { return !!tmp; }</span>
<span class="line-added">+ </span>
      Tmp tmp;
      B3::ValueRep rep;
  };
  
  class TypedTmp {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,40 ***</span>
      operator Tmp() const { return tmp(); }
      operator Arg() const { return Arg(tmp()); }
      Tmp tmp() const { return m_tmp; }
      Type type() const { return m_type; }
  
  private:
  
      Tmp m_tmp;
      Type m_type;
  };
  
  class AirIRGenerator {
  public:
      struct ControlData {
<span class="line-modified">!         ControlData(B3::Origin origin, Type returnType, TypedTmp resultTmp, BlockType type, BasicBlock* continuation, BasicBlock* special = nullptr)</span>
<span class="line-modified">!             : blockType(type)</span>
              , continuation(continuation)
              , special(special)
<span class="line-modified">!             , returnType(returnType)</span>
          {
<span class="line-modified">!             UNUSED_PARAM(origin); // FIXME: Use origin.</span>
<span class="line-removed">-             if (resultTmp) {</span>
<span class="line-removed">-                 ASSERT(returnType != Type::Void);</span>
<span class="line-removed">-                 result.append(resultTmp);</span>
<span class="line-removed">-             } else</span>
<span class="line-removed">-                 ASSERT(returnType == Type::Void);</span>
          }
  
          ControlData()
          {
          }
  
          void dump(PrintStream&amp; out) const
          {
<span class="line-modified">!             switch (type()) {</span>
              case BlockType::If:
                  out.print(&quot;If:       &quot;);
                  break;
              case BlockType::Block:
                  out.print(&quot;Block:    &quot;);
<span class="line-new-header">--- 116,47 ---</span>
      operator Tmp() const { return tmp(); }
      operator Arg() const { return Arg(tmp()); }
      Tmp tmp() const { return m_tmp; }
      Type type() const { return m_type; }
  
<span class="line-added">+     void dump(PrintStream&amp; out) const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         out.print(&quot;(&quot;, m_tmp, &quot;, &quot;, m_type, &quot;)&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
  private:
  
      Tmp m_tmp;
      Type m_type;
  };
  
  class AirIRGenerator {
  public:
<span class="line-added">+     using ExpressionType = TypedTmp;</span>
<span class="line-added">+     using ResultList = Vector&lt;ExpressionType, 8&gt;;</span>
<span class="line-added">+ </span>
      struct ControlData {
<span class="line-modified">!         ControlData(B3::Origin origin, BlockSignature result, ResultList resultTmps, BlockType type, BasicBlock* continuation, BasicBlock* special = nullptr)</span>
<span class="line-modified">!             : controlBlockType(type)</span>
              , continuation(continuation)
              , special(special)
<span class="line-modified">!             , results(resultTmps)</span>
<span class="line-added">+             , returnType(result)</span>
          {
<span class="line-modified">!             UNUSED_PARAM(origin);</span>
          }
  
          ControlData()
          {
          }
  
<span class="line-added">+         static bool isIf(const ControlData&amp; control) { return control.blockType() == BlockType::If; }</span>
<span class="line-added">+         static bool isTopLevel(const ControlData&amp; control) { return control.blockType() == BlockType::TopLevel; }</span>
<span class="line-added">+ </span>
          void dump(PrintStream&amp; out) const
          {
<span class="line-modified">!             switch (blockType()) {</span>
              case BlockType::If:
                  out.print(&quot;If:       &quot;);
                  break;
              case BlockType::Block:
                  out.print(&quot;Block:    &quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,65 ***</span>
              out.print(&quot;Continuation: &quot;, *continuation, &quot;, Special: &quot;);
              if (special)
                  out.print(*special);
              else
                  out.print(&quot;None&quot;);
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         BlockType type() const { return blockType; }</span>
  
<span class="line-modified">!         Type signature() const { return returnType; }</span>
  
<span class="line-modified">!         bool hasNonVoidSignature() const { return result.size(); }</span>
  
          BasicBlock* targetBlockForBranch()
          {
<span class="line-modified">!             if (type() == BlockType::Loop)</span>
                  return special;
              return continuation;
          }
  
          void convertIfToBlock()
          {
<span class="line-modified">!             ASSERT(type() == BlockType::If);</span>
<span class="line-modified">!             blockType = BlockType::Block;</span>
              special = nullptr;
          }
  
<span class="line-modified">!         using ResultList = Vector&lt;TypedTmp, 1&gt;;</span>
  
<span class="line-modified">!         ResultList resultForBranch() const</span>
          {
<span class="line-modified">!             if (type() == BlockType::Loop)</span>
<span class="line-modified">!                 return ResultList();</span>
<span class="line-modified">!             return result;</span>
          }
  
      private:
          friend class AirIRGenerator;
<span class="line-modified">!         BlockType blockType;</span>
          BasicBlock* continuation;
          BasicBlock* special;
<span class="line-modified">!         ResultList result;</span>
<span class="line-modified">!         Type returnType;</span>
      };
  
<span class="line-removed">-     using ExpressionType = TypedTmp;</span>
      using ControlType = ControlData;
<span class="line-removed">-     using ExpressionList = Vector&lt;ExpressionType, 1&gt;;</span>
<span class="line-removed">-     using Stack = ExpressionList;</span>
<span class="line-removed">-     using ResultList = ControlData::ResultList;</span>
<span class="line-removed">-     using ControlEntry = FunctionParser&lt;AirIRGenerator&gt;::ControlEntry;</span>
  
<span class="line-modified">!     static ExpressionType emptyExpression() { return { }; };</span>
<span class="line-modified">!     Stack createStack() { return Stack(); }</span>
  
      using ErrorType = String;
      using UnexpectedResult = Unexpected&lt;ErrorType&gt;;
      using Result = Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, ErrorType&gt;;
      using PartialResult = Expected&lt;void, ErrorType&gt;;
  
      template &lt;typename ...Args&gt;
      NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN fail(Args... args) const
      {
          using namespace FailureHelper; // See ADL comment in WasmParser.h.
          return UnexpectedResult(makeString(&quot;WebAssembly.Module failed compiling: &quot;_s, makeString(args)...));
<span class="line-new-header">--- 171,75 ---</span>
              out.print(&quot;Continuation: &quot;, *continuation, &quot;, Special: &quot;);
              if (special)
                  out.print(*special);
              else
                  out.print(&quot;None&quot;);
  
<span class="line-modified">!             CommaPrinter comma(&quot;, &quot;, &quot; Result Tmps: [&quot;);</span>
<span class="line-added">+             for (const auto&amp; tmp : results)</span>
<span class="line-added">+                 out.print(comma, tmp);</span>
<span class="line-added">+             if (comma.didPrint())</span>
<span class="line-added">+                 out.print(&quot;]&quot;);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         BlockType blockType() const { return controlBlockType; }</span>
<span class="line-added">+         BlockSignature signature() const { return returnType; }</span>
  
          BasicBlock* targetBlockForBranch()
          {
<span class="line-modified">!             if (blockType() == BlockType::Loop)</span>
                  return special;
              return continuation;
          }
  
          void convertIfToBlock()
          {
<span class="line-modified">!             ASSERT(blockType() == BlockType::If);</span>
<span class="line-modified">!             controlBlockType = BlockType::Block;</span>
              special = nullptr;
          }
  
<span class="line-modified">!         SignatureArgCount branchTargetArity() const</span>
<span class="line-added">+         {</span>
<span class="line-added">+             if (blockType() == BlockType::Loop)</span>
<span class="line-added">+                 return returnType-&gt;argumentCount();</span>
<span class="line-added">+             return returnType-&gt;returnCount();</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         Type branchTargetType(unsigned i) const</span>
          {
<span class="line-modified">!             ASSERT(i &lt; branchTargetArity());</span>
<span class="line-modified">!             if (blockType() == BlockType::Loop)</span>
<span class="line-modified">!                 return returnType-&gt;argument(i);</span>
<span class="line-added">+             return returnType-&gt;returnType(i);</span>
          }
  
      private:
          friend class AirIRGenerator;
<span class="line-modified">!         BlockType controlBlockType;</span>
          BasicBlock* continuation;
          BasicBlock* special;
<span class="line-modified">!         ResultList results;</span>
<span class="line-modified">!         BlockSignature returnType;</span>
      };
  
      using ControlType = ControlData;
  
<span class="line-modified">!     using ControlEntry = FunctionParser&lt;AirIRGenerator&gt;::ControlEntry;</span>
<span class="line-modified">!     using ControlStack = FunctionParser&lt;AirIRGenerator&gt;::ControlStack;</span>
<span class="line-added">+     using Stack = FunctionParser&lt;AirIRGenerator&gt;::Stack;</span>
<span class="line-added">+     using TypedExpression = FunctionParser&lt;AirIRGenerator&gt;::TypedExpression;</span>
  
      using ErrorType = String;
      using UnexpectedResult = Unexpected&lt;ErrorType&gt;;
      using Result = Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, ErrorType&gt;;
      using PartialResult = Expected&lt;void, ErrorType&gt;;
  
<span class="line-added">+     static_assert(std::is_same_v&lt;ResultList, FunctionParser&lt;AirIRGenerator&gt;::ResultList&gt;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     static ExpressionType emptyExpression() { return { }; };</span>
<span class="line-added">+ </span>
      template &lt;typename ...Args&gt;
      NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN fail(Args... args) const
      {
          using namespace FailureHelper; // See ADL comment in WasmParser.h.
          return UnexpectedResult(makeString(&quot;WebAssembly.Module failed compiling: &quot;_s, makeString(args)...));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,27 ***</span>
  #define WASM_COMPILE_FAIL_IF(condition, ...) do { \
          if (UNLIKELY(condition))                  \
              return fail(__VA_ARGS__);             \
      } while (0)
  
<span class="line-modified">!     AirIRGenerator(const ModuleInformation&amp;, B3::Procedure&amp;, InternalFunction*, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp;, MemoryMode, unsigned functionIndex, TierUpCount*, ThrowWasmException, const Signature&amp;);</span>
  
      PartialResult WARN_UNUSED_RETURN addArguments(const Signature&amp;);
      PartialResult WARN_UNUSED_RETURN addLocal(Type, uint32_t);
      ExpressionType addConstant(Type, uint64_t);
      ExpressionType addConstant(BasicBlock*, Type, uint64_t);
  
      // References
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result);</span>
      PartialResult WARN_UNUSED_RETURN addRefFunc(uint32_t index, ExpressionType&amp; result);
  
      // Tables
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableGet(unsigned, ExpressionType&amp; index, ExpressionType&amp; result);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableSet(unsigned, ExpressionType&amp; index, ExpressionType&amp; value);</span>
      PartialResult WARN_UNUSED_RETURN addTableSize(unsigned, ExpressionType&amp; result);
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableGrow(unsigned, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableFill(unsigned, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count);</span>
  
      // Locals
      PartialResult WARN_UNUSED_RETURN getLocal(uint32_t index, ExpressionType&amp; result);
      PartialResult WARN_UNUSED_RETURN setLocal(uint32_t index, ExpressionType value);
  
<span class="line-new-header">--- 248,28 ---</span>
  #define WASM_COMPILE_FAIL_IF(condition, ...) do { \
          if (UNLIKELY(condition))                  \
              return fail(__VA_ARGS__);             \
      } while (0)
  
<span class="line-modified">!     AirIRGenerator(const ModuleInformation&amp;, B3::Procedure&amp;, InternalFunction*, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp;, MemoryMode, unsigned functionIndex, TierUpCount*, const Signature&amp;);</span>
  
      PartialResult WARN_UNUSED_RETURN addArguments(const Signature&amp;);
      PartialResult WARN_UNUSED_RETURN addLocal(Type, uint32_t);
      ExpressionType addConstant(Type, uint64_t);
      ExpressionType addConstant(BasicBlock*, Type, uint64_t);
<span class="line-added">+     ExpressionType addBottom(BasicBlock*, Type);</span>
  
      // References
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addRefIsNull(ExpressionType value, ExpressionType&amp; result);</span>
      PartialResult WARN_UNUSED_RETURN addRefFunc(uint32_t index, ExpressionType&amp; result);
  
      // Tables
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableGet(unsigned, ExpressionType index, ExpressionType&amp; result);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableSet(unsigned, ExpressionType index, ExpressionType value);</span>
      PartialResult WARN_UNUSED_RETURN addTableSize(unsigned, ExpressionType&amp; result);
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableGrow(unsigned, ExpressionType fill, ExpressionType delta, ExpressionType&amp; result);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableFill(unsigned, ExpressionType offset, ExpressionType fill, ExpressionType count);</span>
  
      // Locals
      PartialResult WARN_UNUSED_RETURN getLocal(uint32_t index, ExpressionType&amp; result);
      PartialResult WARN_UNUSED_RETURN setLocal(uint32_t index, ExpressionType value);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 267,66 ***</span>
      template&lt;OpType&gt;
      PartialResult WARN_UNUSED_RETURN addOp(ExpressionType left, ExpressionType right, ExpressionType&amp; result);
      PartialResult WARN_UNUSED_RETURN addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result);
  
      // Control flow
<span class="line-modified">!     ControlData WARN_UNUSED_RETURN addTopLevel(Type signature);</span>
<span class="line-modified">!     ControlData WARN_UNUSED_RETURN addBlock(Type signature);</span>
<span class="line-modified">!     ControlData WARN_UNUSED_RETURN addLoop(Type signature, const Stack&amp;, uint32_t loopIndex);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addIf(ExpressionType condition, Type signature, ControlData&amp; result);</span>
      PartialResult WARN_UNUSED_RETURN addElse(ControlData&amp;, const Stack&amp;);
      PartialResult WARN_UNUSED_RETURN addElseToUnreachable(ControlData&amp;);
  
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addReturn(const ControlData&amp;, const ExpressionList&amp; returnValues);</span>
      PartialResult WARN_UNUSED_RETURN addBranch(ControlData&amp;, ExpressionType condition, const Stack&amp; returnValues);
      PartialResult WARN_UNUSED_RETURN addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTargets, const Stack&amp; expressionStack);
      PartialResult WARN_UNUSED_RETURN endBlock(ControlEntry&amp;, Stack&amp; expressionStack);
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addEndToUnreachable(ControlEntry&amp;);</span>
  
      // Calls
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addCall(uint32_t calleeIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addCallIndirect(unsigned tableIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);</span>
      PartialResult WARN_UNUSED_RETURN addUnreachable();
  
      PartialResult addShift(Type, B3::Air::Opcode, ExpressionType value, ExpressionType shift, ExpressionType&amp; result);
      PartialResult addIntegerSub(B3::Air::Opcode, ExpressionType lhs, ExpressionType rhs, ExpressionType&amp; result);
      PartialResult addFloatingPointAbs(B3::Air::Opcode, ExpressionType value, ExpressionType&amp; result);
      PartialResult addFloatingPointBinOp(Type, B3::Air::Opcode, ExpressionType lhs, ExpressionType rhs, ExpressionType&amp; result);
  
<span class="line-modified">!     void dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const Stack* expressionStack);</span>
      void setParser(FunctionParser&lt;AirIRGenerator&gt;* parser) { m_parser = parser; };
<span class="line-modified">! </span>
<span class="line-modified">!     static Vector&lt;Tmp&gt; toTmpVector(const Vector&lt;TypedTmp&gt;&amp; vector)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         Vector&lt;Tmp&gt; result;</span>
<span class="line-removed">-         for (const auto&amp; item : vector)</span>
<span class="line-removed">-             result.append(item.tmp());</span>
<span class="line-removed">-         return result;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ALWAYS_INLINE void didKill(const ExpressionType&amp; typedTmp)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         Tmp tmp = typedTmp.tmp();</span>
<span class="line-removed">-         if (!tmp)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         if (tmp.isGP())</span>
<span class="line-removed">-             m_freeGPs.append(tmp);</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             m_freeFPs.append(tmp);</span>
<span class="line-removed">-     }</span>
  
      const Bag&lt;B3::PatchpointValue*&gt;&amp; patchpoints() const
      {
          return m_patchpoints;
      }
  
  private:
      ALWAYS_INLINE void validateInst(Inst&amp; inst)
      {
<span class="line-modified">!         if (!ASSERT_DISABLED) {</span>
              if (!inst.isValidForm()) {
<span class="line-modified">!                 dataLogLn(inst);</span>
                  CRASH();
              }
          }
      }
  
<span class="line-new-header">--- 289,56 ---</span>
      template&lt;OpType&gt;
      PartialResult WARN_UNUSED_RETURN addOp(ExpressionType left, ExpressionType right, ExpressionType&amp; result);
      PartialResult WARN_UNUSED_RETURN addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result);
  
      // Control flow
<span class="line-modified">!     ControlData WARN_UNUSED_RETURN addTopLevel(BlockSignature);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addBlock(BlockSignature, Stack&amp; enclosingStack, ControlType&amp; newBlock, Stack&amp; newStack);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addLoop(BlockSignature, Stack&amp; enclosingStack, ControlType&amp; block, Stack&amp; newStack, uint32_t loopIndex);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addIf(ExpressionType condition, BlockSignature, Stack&amp; enclosingStack, ControlType&amp; result, Stack&amp; newStack);</span>
      PartialResult WARN_UNUSED_RETURN addElse(ControlData&amp;, const Stack&amp;);
      PartialResult WARN_UNUSED_RETURN addElseToUnreachable(ControlData&amp;);
  
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addReturn(const ControlData&amp;, const Stack&amp; returnValues);</span>
      PartialResult WARN_UNUSED_RETURN addBranch(ControlData&amp;, ExpressionType condition, const Stack&amp; returnValues);
      PartialResult WARN_UNUSED_RETURN addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTargets, const Stack&amp; expressionStack);
      PartialResult WARN_UNUSED_RETURN endBlock(ControlEntry&amp;, Stack&amp; expressionStack);
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addEndToUnreachable(ControlEntry&amp;, const Stack&amp; expressionStack = { });</span>
<span class="line-added">+ </span>
<span class="line-added">+     PartialResult WARN_UNUSED_RETURN endTopLevel(BlockSignature, const Stack&amp;) { return { }; }</span>
  
      // Calls
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addCall(uint32_t calleeIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ResultList&amp; results);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addCallIndirect(unsigned tableIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ResultList&amp; results);</span>
      PartialResult WARN_UNUSED_RETURN addUnreachable();
<span class="line-added">+     B3::PatchpointValue* WARN_UNUSED_RETURN emitCallPatchpoint(BasicBlock*, const Signature&amp;, const ResultList&amp; results, const Vector&lt;TypedTmp&gt;&amp; args, Vector&lt;ConstrainedTmp&gt;&amp;&amp; extraArgs = { });</span>
  
      PartialResult addShift(Type, B3::Air::Opcode, ExpressionType value, ExpressionType shift, ExpressionType&amp; result);
      PartialResult addIntegerSub(B3::Air::Opcode, ExpressionType lhs, ExpressionType rhs, ExpressionType&amp; result);
      PartialResult addFloatingPointAbs(B3::Air::Opcode, ExpressionType value, ExpressionType&amp; result);
      PartialResult addFloatingPointBinOp(Type, B3::Air::Opcode, ExpressionType lhs, ExpressionType rhs, ExpressionType&amp; result);
  
<span class="line-modified">!     void dump(const ControlStack&amp;, const Stack* expressionStack);</span>
      void setParser(FunctionParser&lt;AirIRGenerator&gt;* parser) { m_parser = parser; };
<span class="line-modified">!     void didFinishParsingLocals() { }</span>
<span class="line-modified">!     void didPopValueFromStack() { }</span>
  
      const Bag&lt;B3::PatchpointValue*&gt;&amp; patchpoints() const
      {
          return m_patchpoints;
      }
  
  private:
<span class="line-added">+     B3::Type toB3ResultType(BlockSignature returnType);</span>
      ALWAYS_INLINE void validateInst(Inst&amp; inst)
      {
<span class="line-modified">!         if (ASSERT_ENABLED) {</span>
              if (!inst.isValidForm()) {
<span class="line-modified">!                 dataLogLn(&quot;Inst validation failed:&quot;);</span>
<span class="line-added">+                 dataLogLn(inst, &quot;\n&quot;);</span>
<span class="line-added">+                 if (inst.origin)</span>
<span class="line-added">+                     dataLogLn(deepDump(inst.origin), &quot;\n&quot;);</span>
                  CRASH();
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 398,10 ***</span>
<span class="line-new-header">--- 410,18 ---</span>
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
      }
  
<span class="line-added">+     ResultList tmpsForSignature(BlockSignature signature)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ResultList result(signature-&gt;returnCount());</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; signature-&gt;returnCount(); ++i)</span>
<span class="line-added">+             result[i] = tmpForType(signature-&gt;returnType(i));</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      B3::PatchpointValue* addPatchpoint(B3::Type type)
      {
          auto* result = m_proc.add&lt;B3::PatchpointValue&gt;(type, B3::Origin());
          if (UNLIKELY(shouldDumpIRAtEachPhase(B3::AirMode)))
              m_patchpoints.add(result);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 415,43 ***</span>
      }
  
      template &lt;typename ...Args&gt;
      void emitPatchpoint(BasicBlock* basicBlock, B3::PatchpointValue* patch, Tmp result, Args... theArgs)
      {
<span class="line-modified">!         emitPatchpoint(basicBlock, patch, result, Vector&lt;ConstrainedTmp, sizeof...(Args)&gt;::from(theArgs...));</span>
      }
  
      void emitPatchpoint(BasicBlock* basicBlock, B3::PatchpointValue* patch, Tmp result)
      {
<span class="line-modified">!         emitPatchpoint(basicBlock, patch, result, Vector&lt;ConstrainedTmp&gt;());</span>
      }
  
<span class="line-modified">!     template &lt;size_t inlineSize&gt;</span>
<span class="line-modified">!     void emitPatchpoint(BasicBlock* basicBlock, B3::PatchpointValue* patch, Tmp result, Vector&lt;ConstrainedTmp, inlineSize&gt;&amp;&amp; args)</span>
      {
          if (!m_patchpointSpecial)
              m_patchpointSpecial = static_cast&lt;B3::PatchpointSpecial*&gt;(m_code.addSpecial(makeUnique&lt;B3::PatchpointSpecial&gt;()));
  
          Inst inst(Patch, patch, Arg::special(m_patchpointSpecial));
<span class="line-modified">!         Inst resultMov;</span>
<span class="line-modified">!         if (result) {</span>
<span class="line-modified">!             ASSERT(patch-&gt;type() != B3::Void);</span>
<span class="line-modified">!             switch (patch-&gt;resultConstraints[0].kind()) {</span>
<span class="line-modified">!             case B3::ValueRep::Register:</span>
<span class="line-modified">!                 inst.args.append(Tmp(patch-&gt;resultConstraints[0].reg()));</span>
<span class="line-modified">!                 resultMov = Inst(result.isGP() ? Move : MoveDouble, nullptr, Tmp(patch-&gt;resultConstraints[0].reg()), result);</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             case B3::ValueRep::SomeRegister:</span>
<span class="line-modified">!                 inst.args.append(result);</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             default:</span>
<span class="line-modified">!                 RELEASE_ASSERT_NOT_REACHED();</span>
              }
<span class="line-modified">!         } else</span>
<span class="line-modified">!             ASSERT(patch-&gt;type() == B3::Void);</span>
  
<span class="line-modified">!         for (ConstrainedTmp&amp; tmp : args) {</span>
              // FIXME: This is less than ideal to create dummy values just to satisfy Air&#39;s
              // validation. We should abstrcat Patch enough so ValueRep&#39;s don&#39;t need to be
              // backed by Values.
              // https://bugs.webkit.org/show_bug.cgi?id=194040
              B3::Value* dummyValue = m_proc.addConstant(B3::Origin(), tmp.tmp.isGP() ? B3::Int64 : B3::Double, 0);
<span class="line-new-header">--- 435,64 ---</span>
      }
  
      template &lt;typename ...Args&gt;
      void emitPatchpoint(BasicBlock* basicBlock, B3::PatchpointValue* patch, Tmp result, Args... theArgs)
      {
<span class="line-modified">!         emitPatchpoint(basicBlock, patch, Vector&lt;Tmp, 8&gt; { result }, Vector&lt;ConstrainedTmp, sizeof...(Args)&gt;::from(theArgs...));</span>
      }
  
      void emitPatchpoint(BasicBlock* basicBlock, B3::PatchpointValue* patch, Tmp result)
      {
<span class="line-modified">!         emitPatchpoint(basicBlock, patch, Vector&lt;Tmp, 8&gt; { result }, Vector&lt;ConstrainedTmp&gt;());</span>
      }
  
<span class="line-modified">!     template &lt;typename ResultTmpType, size_t inlineSize&gt;</span>
<span class="line-modified">!     void emitPatchpoint(BasicBlock* basicBlock, B3::PatchpointValue* patch, const Vector&lt;ResultTmpType, 8&gt;&amp;  results, Vector&lt;ConstrainedTmp, inlineSize&gt;&amp;&amp; args)</span>
      {
          if (!m_patchpointSpecial)
              m_patchpointSpecial = static_cast&lt;B3::PatchpointSpecial*&gt;(m_code.addSpecial(makeUnique&lt;B3::PatchpointSpecial&gt;()));
  
<span class="line-added">+         auto toTmp = [&amp;] (ResultTmpType tmp) {</span>
<span class="line-added">+             if constexpr (std::is_same_v&lt;ResultTmpType, Tmp&gt;)</span>
<span class="line-added">+                 return tmp;</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 return tmp.tmp();</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
          Inst inst(Patch, patch, Arg::special(m_patchpointSpecial));
<span class="line-modified">!         Vector&lt;Inst, 1&gt; resultMovs;</span>
<span class="line-modified">!         switch (patch-&gt;type().kind()) {</span>
<span class="line-modified">!         case B3::Void:</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         default: {</span>
<span class="line-modified">!             ASSERT(results.size());</span>
<span class="line-modified">!             for (unsigned i = 0; i &lt; results.size(); ++i) {</span>
<span class="line-modified">!                 switch (patch-&gt;resultConstraints[i].kind()) {</span>
<span class="line-modified">!                 case B3::ValueRep::StackArgument: {</span>
<span class="line-modified">!                     Arg arg = Arg::callArg(patch-&gt;resultConstraints[i].offsetFromSP());</span>
<span class="line-modified">!                     inst.args.append(arg);</span>
<span class="line-modified">!                     resultMovs.append(Inst(B3::Air::moveForType(m_proc.typeAtOffset(patch-&gt;type(), i)), nullptr, arg, toTmp(results[i])));</span>
<span class="line-modified">!                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case B3::ValueRep::Register: {</span>
<span class="line-added">+                     inst.args.append(Tmp(patch-&gt;resultConstraints[i].reg()));</span>
<span class="line-added">+                     resultMovs.append(Inst(B3::Air::relaxedMoveForType(m_proc.typeAtOffset(patch-&gt;type(), i)), nullptr, Tmp(patch-&gt;resultConstraints[i].reg()), toTmp(results[i])));</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case B3::ValueRep::SomeRegister: {</span>
<span class="line-added">+                     inst.args.append(toTmp(results[i]));</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+                 }</span>
              }
<span class="line-modified">!         }</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         for (unsigned i = 0; i &lt; args.size(); ++i) {</span>
<span class="line-added">+             ConstrainedTmp&amp; tmp = args[i];</span>
              // FIXME: This is less than ideal to create dummy values just to satisfy Air&#39;s
              // validation. We should abstrcat Patch enough so ValueRep&#39;s don&#39;t need to be
              // backed by Values.
              // https://bugs.webkit.org/show_bug.cgi?id=194040
              B3::Value* dummyValue = m_proc.addConstant(B3::Origin(), tmp.tmp.isGP() ? B3::Int64 : B3::Double, 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 465,32 ***</span>
                  patch-&gt;earlyClobbered().clear(tmp.rep.reg());
                  append(basicBlock, tmp.tmp.isGP() ? Move : MoveDouble, tmp.tmp, tmp.rep.reg());
                  inst.args.append(Tmp(tmp.rep.reg()));
                  break;
              case B3::ValueRep::StackArgument: {
<span class="line-modified">!                 auto arg = Arg::callArg(tmp.rep.offsetFromSP());</span>
                  append(basicBlock, tmp.tmp.isGP() ? Move : MoveDouble, tmp.tmp, arg);
                  inst.args.append(arg);
                  break;
              }
              default:
                  RELEASE_ASSERT_NOT_REACHED();
              }
          }
  
<span class="line-modified">!         if (patch-&gt;resultConstraints[0].isReg())</span>
<span class="line-modified">!             patch-&gt;lateClobbered().clear(patch-&gt;resultConstraints[0].reg());</span>
          for (unsigned i = patch-&gt;numGPScratchRegisters; i--;)
              inst.args.append(g64().tmp());
          for (unsigned i = patch-&gt;numFPScratchRegisters; i--;)
              inst.args.append(f64().tmp());
  
          validateInst(inst);
          basicBlock-&gt;append(WTFMove(inst));
<span class="line-modified">!         if (resultMov) {</span>
<span class="line-modified">!             validateInst(resultMov);</span>
<span class="line-modified">!             basicBlock-&gt;append(WTFMove(resultMov));</span>
          }
      }
  
      template &lt;typename Branch, typename Generator&gt;
      void emitCheck(const Branch&amp; makeBranch, const Generator&amp; generator)
<span class="line-new-header">--- 506,36 ---</span>
                  patch-&gt;earlyClobbered().clear(tmp.rep.reg());
                  append(basicBlock, tmp.tmp.isGP() ? Move : MoveDouble, tmp.tmp, tmp.rep.reg());
                  inst.args.append(Tmp(tmp.rep.reg()));
                  break;
              case B3::ValueRep::StackArgument: {
<span class="line-modified">!                 ASSERT(!patch-&gt;effects.terminal);</span>
<span class="line-added">+                 Arg arg = Arg::callArg(tmp.rep.offsetFromSP());</span>
                  append(basicBlock, tmp.tmp.isGP() ? Move : MoveDouble, tmp.tmp, arg);
<span class="line-added">+                 ASSERT(arg.canRepresent(patch-&gt;child(i)-&gt;type()));</span>
                  inst.args.append(arg);
                  break;
              }
              default:
                  RELEASE_ASSERT_NOT_REACHED();
              }
          }
  
<span class="line-modified">!         for (auto valueRep : patch-&gt;resultConstraints) {</span>
<span class="line-modified">!             if (valueRep.isReg())</span>
<span class="line-added">+                 patch-&gt;lateClobbered().clear(valueRep.reg());</span>
<span class="line-added">+         }</span>
          for (unsigned i = patch-&gt;numGPScratchRegisters; i--;)
              inst.args.append(g64().tmp());
          for (unsigned i = patch-&gt;numFPScratchRegisters; i--;)
              inst.args.append(f64().tmp());
  
          validateInst(inst);
          basicBlock-&gt;append(WTFMove(inst));
<span class="line-modified">!         for (Inst result : resultMovs) {</span>
<span class="line-modified">!             validateInst(result);</span>
<span class="line-modified">!             basicBlock-&gt;append(WTFMove(result));</span>
          }
      }
  
      template &lt;typename Branch, typename Generator&gt;
      void emitCheck(const Branch&amp; makeBranch, const Generator&amp; generator)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 589,19 ***</span>
          }
      }
  
      void emitThrowException(CCallHelpers&amp;, ExceptionType);
  
<span class="line-modified">!     void emitEntryTierUpCheck(int32_t incrementCount, B3::Origin);</span>
<span class="line-modified">!     void emitLoopTierUpCheck(int32_t incrementCount, const Stack&amp;, uint32_t, uint32_t, B3::Origin);</span>
  
      void emitWriteBarrierForJSWrapper();
      ExpressionType emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOp);
      ExpressionType emitLoadOp(LoadOpType, ExpressionType pointer, uint32_t offset);
      void emitStoreOp(StoreOpType, ExpressionType pointer, ExpressionType value, uint32_t offset);
  
<span class="line-modified">!     void unify(const ExpressionType&amp; dst, const ExpressionType&amp; source);</span>
      void unifyValuesWithBlock(const Stack&amp; resultStack, const ResultList&amp; stack);
  
      template &lt;typename IntType&gt;
      void emitChecksForModOrDiv(bool isSignedDiv, ExpressionType left, ExpressionType right);
  
<span class="line-new-header">--- 634,19 ---</span>
          }
      }
  
      void emitThrowException(CCallHelpers&amp;, ExceptionType);
  
<span class="line-modified">!     void emitEntryTierUpCheck();</span>
<span class="line-modified">!     void emitLoopTierUpCheck(uint32_t loopIndex, const Stack&amp; enclosingStack);</span>
  
      void emitWriteBarrierForJSWrapper();
      ExpressionType emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOp);
      ExpressionType emitLoadOp(LoadOpType, ExpressionType pointer, uint32_t offset);
      void emitStoreOp(StoreOpType, ExpressionType pointer, ExpressionType value, uint32_t offset);
  
<span class="line-modified">!     void unify(const ExpressionType dst, const ExpressionType source);</span>
      void unifyValuesWithBlock(const Stack&amp; resultStack, const ResultList&amp; stack);
  
      template &lt;typename IntType&gt;
      void emitChecksForModOrDiv(bool isSignedDiv, ExpressionType left, ExpressionType right);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 646,10 ***</span>
<span class="line-new-header">--- 691,11 ---</span>
      bool m_makesCalls { false };
  
      Vector&lt;Tmp, 8&gt; m_freeGPs;
      Vector&lt;Tmp, 8&gt; m_freeFPs;
  
<span class="line-added">+     HashMap&lt;BlockSignature, B3::Type&gt; m_tupleMap;</span>
      // This is only filled if we are dumping IR.
      Bag&lt;B3::PatchpointValue*&gt; m_patchpoints;
  
      TypedTmp m_instanceValue; // Always use the accessor below to ensure the instance value is materialized when used.
      bool m_usesInstanceValue { false };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 706,11 ***</span>
          jit.move(param[0].gpr(), wasmContextInstanceGPR);
      });
      emitPatchpoint(block, patchpoint, Tmp(), instance);
  }
  
<span class="line-modified">! AirIRGenerator::AirIRGenerator(const ModuleInformation&amp; info, B3::Procedure&amp; procedure, InternalFunction* compilation, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, MemoryMode mode, unsigned functionIndex, TierUpCount* tierUp, ThrowWasmException throwWasmException, const Signature&amp; signature)</span>
      : m_info(info)
      , m_mode(mode)
      , m_functionIndex(functionIndex)
      , m_tierUp(tierUp)
      , m_proc(procedure)
<span class="line-new-header">--- 752,11 ---</span>
          jit.move(param[0].gpr(), wasmContextInstanceGPR);
      });
      emitPatchpoint(block, patchpoint, Tmp(), instance);
  }
  
<span class="line-modified">! AirIRGenerator::AirIRGenerator(const ModuleInformation&amp; info, B3::Procedure&amp; procedure, InternalFunction* compilation, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, MemoryMode mode, unsigned functionIndex, TierUpCount* tierUp, const Signature&amp; signature)</span>
      : m_info(info)
      , m_mode(mode)
      , m_functionIndex(functionIndex)
      , m_tierUp(tierUp)
      , m_proc(procedure)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 734,13 ***</span>
      if (mode != MemoryMode::Signaling) {
          m_memorySizeGPR = pinnedRegs.sizeRegister;
          m_code.pinRegister(m_memorySizeGPR);
      }
  
<span class="line-removed">-     if (throwWasmException)</span>
<span class="line-removed">-         Thunks::singleton().setThrowWasmException(throwWasmException);</span>
<span class="line-removed">- </span>
      if (info.memory) {
          switch (m_mode) {
          case MemoryMode::BoundsChecking:
              break;
          case MemoryMode::Signaling:
<span class="line-new-header">--- 780,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 754,18 ***</span>
          }
      }
  
      m_code.setNumEntrypoints(1);
  
<span class="line-modified">!     GPRReg contextInstance = Context::useFastTLS() ? wasmCallingConventionAir().prologueScratch(1) : m_wasmContextInstanceGPR;</span>
  
      Ref&lt;B3::Air::PrologueGenerator&gt; prologueGenerator = createSharedTask&lt;B3::Air::PrologueGeneratorFunction&gt;([=] (CCallHelpers&amp; jit, B3::Air::Code&amp; code) {
          AllowMacroScratchRegisterUsage allowScratch(jit);
          code.emitDefaultPrologue(jit);
  
          {
<span class="line-modified">!             GPRReg calleeGPR = wasmCallingConventionAir().prologueScratch(0);</span>
              auto moveLocation = jit.moveWithPatch(MacroAssembler::TrustedImmPtr(nullptr), calleeGPR);
              jit.addLinkTask([compilation, moveLocation] (LinkBuffer&amp; linkBuffer) {
                  compilation-&gt;calleeMoveLocation = linkBuffer.locationOf&lt;WasmEntryPtrTag&gt;(moveLocation);
              });
              jit.emitPutToCallFrameHeader(calleeGPR, CallFrameSlot::callee);
<span class="line-new-header">--- 797,18 ---</span>
          }
      }
  
      m_code.setNumEntrypoints(1);
  
<span class="line-modified">!     GPRReg contextInstance = Context::useFastTLS() ? wasmCallingConvention().prologueScratchGPRs[1] : m_wasmContextInstanceGPR;</span>
  
      Ref&lt;B3::Air::PrologueGenerator&gt; prologueGenerator = createSharedTask&lt;B3::Air::PrologueGeneratorFunction&gt;([=] (CCallHelpers&amp; jit, B3::Air::Code&amp; code) {
          AllowMacroScratchRegisterUsage allowScratch(jit);
          code.emitDefaultPrologue(jit);
  
          {
<span class="line-modified">!             GPRReg calleeGPR = wasmCallingConvention().prologueScratchGPRs[0];</span>
              auto moveLocation = jit.moveWithPatch(MacroAssembler::TrustedImmPtr(nullptr), calleeGPR);
              jit.addLinkTask([compilation, moveLocation] (LinkBuffer&amp; linkBuffer) {
                  compilation-&gt;calleeMoveLocation = linkBuffer.locationOf&lt;WasmEntryPtrTag&gt;(moveLocation);
              });
              jit.emitPutToCallFrameHeader(calleeGPR, CallFrameSlot::callee);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 784,20 ***</span>
                  // 2. Try to speed things up by skipping stack checks.
                  minimumParentCheckSize,
                  // This allows us to elide stack checks in the Wasm -&gt; Embedder call IC stub. Since these will
                  // spill all arguments to the stack, we ensure that a stack check here covers the
                  // stack that such a stub would use.
<span class="line-modified">!                 (Checked&lt;uint32_t&gt;(m_maxNumJSCallArguments) * sizeof(Register) + jscCallingConvention().headerSizeInBytes()).unsafeGet()</span>
              ));
              const int32_t checkSize = m_makesCalls ? (wasmFrameSize + extraFrameSize).unsafeGet() : wasmFrameSize.unsafeGet();
              bool needUnderflowCheck = static_cast&lt;unsigned&gt;(checkSize) &gt; Options::reservedZoneSize();
              bool needsOverflowCheck = m_makesCalls || wasmFrameSize &gt;= minimumParentCheckSize || needUnderflowCheck;
  
              // This allows leaf functions to not do stack checks if their frame size is within
              // certain limits since their caller would have already done the check.
              if (needsOverflowCheck) {
<span class="line-modified">!                 GPRReg scratch = wasmCallingConventionAir().prologueScratch(0);</span>
  
                  if (Context::useFastTLS())
                      jit.loadWasmContextInstance(contextInstance);
  
                  jit.addPtr(CCallHelpers::TrustedImm32(-checkSize), GPRInfo::callFrameRegister, scratch);
<span class="line-new-header">--- 827,20 ---</span>
                  // 2. Try to speed things up by skipping stack checks.
                  minimumParentCheckSize,
                  // This allows us to elide stack checks in the Wasm -&gt; Embedder call IC stub. Since these will
                  // spill all arguments to the stack, we ensure that a stack check here covers the
                  // stack that such a stub would use.
<span class="line-modified">!                 (Checked&lt;uint32_t&gt;(m_maxNumJSCallArguments) * sizeof(Register) + jsCallingConvention().headerSizeInBytes).unsafeGet()</span>
              ));
              const int32_t checkSize = m_makesCalls ? (wasmFrameSize + extraFrameSize).unsafeGet() : wasmFrameSize.unsafeGet();
              bool needUnderflowCheck = static_cast&lt;unsigned&gt;(checkSize) &gt; Options::reservedZoneSize();
              bool needsOverflowCheck = m_makesCalls || wasmFrameSize &gt;= minimumParentCheckSize || needUnderflowCheck;
  
              // This allows leaf functions to not do stack checks if their frame size is within
              // certain limits since their caller would have already done the check.
              if (needsOverflowCheck) {
<span class="line-modified">!                 GPRReg scratch = wasmCallingConvention().prologueScratchGPRs[0];</span>
  
                  if (Context::useFastTLS())
                      jit.loadWasmContextInstance(contextInstance);
  
                  jit.addPtr(CCallHelpers::TrustedImm32(-checkSize), GPRInfo::callFrameRegister, scratch);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 829,11 ***</span>
      for (unsigned i = 0; i &lt; signature.argumentCount(); ++i) {
          Type type = signature.argument(i);
          m_locals[i] = tmpForType(type);
      }
  
<span class="line-modified">!     wasmCallingConventionAir().loadArguments(signature, [&amp;] (const Arg&amp; arg, unsigned i) {</span>
          switch (signature.argument(i)) {
          case Type::I32:
              append(Move32, arg, m_locals[i]);
              break;
          case Type::I64:
<span class="line-new-header">--- 872,15 ---</span>
      for (unsigned i = 0; i &lt; signature.argumentCount(); ++i) {
          Type type = signature.argument(i);
          m_locals[i] = tmpForType(type);
      }
  
<span class="line-modified">!     CallInformation wasmCallInfo = wasmCallingConvention().callInformationFor(signature, CallRole::Callee);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (unsigned i = 0; i &lt; wasmCallInfo.params.size(); ++i) {</span>
<span class="line-added">+         B3::ValueRep location = wasmCallInfo.params[i];</span>
<span class="line-added">+         Arg arg = location.isReg() ? Arg(Tmp(location.reg())) : Arg::addr(Tmp(GPRInfo::callFrameRegister), location.offsetFromFP());</span>
          switch (signature.argument(i)) {
          case Type::I32:
              append(Move32, arg, m_locals[i]);
              break;
          case Type::I64:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 848,13 ***</span>
              append(MoveDouble, arg, m_locals[i]);
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
<span class="line-modified">!     });</span>
  
<span class="line-modified">!     emitEntryTierUpCheck(TierUpCount::functionEntryIncrement(), B3::Origin());</span>
  }
  
  void AirIRGenerator::restoreWebAssemblyGlobalState(RestoreCachedStackLimit restoreCachedStackLimit, const MemoryInformation&amp; memory, TypedTmp instance, BasicBlock* block)
  {
      restoreWasmContextInstance(block, instance);
<span class="line-new-header">--- 895,30 ---</span>
              append(MoveDouble, arg, m_locals[i]);
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     emitEntryTierUpCheck();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ B3::Type AirIRGenerator::toB3ResultType(BlockSignature returnType)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (returnType-&gt;returnsVoid())</span>
<span class="line-added">+         return B3::Void;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (returnType-&gt;returnCount() == 1)</span>
<span class="line-added">+         return toB3Type(returnType-&gt;returnType(0));</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto result = m_tupleMap.ensure(returnType, [&amp;] {</span>
<span class="line-added">+         Vector&lt;B3::Type&gt; result;</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; returnType-&gt;returnCount(); ++i)</span>
<span class="line-added">+             result.append(toB3Type(returnType-&gt;returnType(i)));</span>
<span class="line-added">+         return m_proc.addTuple(WTFMove(result));</span>
<span class="line-added">+     });</span>
<span class="line-added">+     return result.iterator-&gt;value;</span>
  }
  
  void AirIRGenerator::restoreWebAssemblyGlobalState(RestoreCachedStackLimit restoreCachedStackLimit, const MemoryInformation&amp; memory, TypedTmp instance, BasicBlock* block)
  {
      restoreWasmContextInstance(block, instance);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 975,17 ***</span>
      }
  
      return result;
  }
  
  auto AirIRGenerator::addArguments(const Signature&amp; signature) -&gt; PartialResult
  {
      RELEASE_ASSERT(m_locals.size() == signature.argumentCount()); // We handle arguments in the prologue
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      ASSERT(value.tmp());
      result = tmpForType(Type::I32);
      auto tmp = g64();
  
<span class="line-new-header">--- 1039,23 ---</span>
      }
  
      return result;
  }
  
<span class="line-added">+ auto AirIRGenerator::addBottom(BasicBlock* block, Type type) -&gt; ExpressionType</span>
<span class="line-added">+ {</span>
<span class="line-added">+     append(block, B3::Air::Oops);</span>
<span class="line-added">+     return addConstant(type, 0);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  auto AirIRGenerator::addArguments(const Signature&amp; signature) -&gt; PartialResult
  {
      RELEASE_ASSERT(m_locals.size() == signature.argumentCount()); // We handle arguments in the prologue
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addRefIsNull(ExpressionType value, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      ASSERT(value.tmp());
      result = tmpForType(Type::I32);
      auto tmp = g64();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 997,41 ***</span>
  
  auto AirIRGenerator::addRefFunc(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
      result = tmpForType(Type::Funcref);
<span class="line-modified">!     emitCCall(&amp;doWasmRefFunc, result, instanceValue(), addConstant(Type::I32, index));</span>
  
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addTableGet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
      ASSERT(index.tmp());
      ASSERT(index.type() == Type::I32);
      result = tmpForType(m_info.tables[tableIndex].wasmType());
  
<span class="line-modified">!     emitCCall(&amp;getWasmTableElement, result, instanceValue(), addConstant(Type::I32, tableIndex), index);</span>
      emitCheck([&amp;] {
          return Inst(BranchTest32, nullptr, Arg::resCond(MacroAssembler::Zero), result, result);
      }, [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
          this-&gt;emitThrowException(jit, ExceptionType::OutOfBoundsTableAccess);
      });
  
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addTableSet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; value) -&gt; PartialResult</span>
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
      ASSERT(index.tmp());
      ASSERT(index.type() == Type::I32);
      ASSERT(value.tmp());
  
      auto shouldThrow = g32();
<span class="line-modified">!     emitCCall(&amp;setWasmTableElement, shouldThrow, instanceValue(), addConstant(Type::I32, tableIndex), index, value);</span>
  
      emitCheck([&amp;] {
          return Inst(BranchTest32, nullptr, Arg::resCond(MacroAssembler::Zero), shouldThrow, shouldThrow);
      }, [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
          this-&gt;emitThrowException(jit, ExceptionType::OutOfBoundsTableAccess);
<span class="line-new-header">--- 1067,41 ---</span>
  
  auto AirIRGenerator::addRefFunc(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
      result = tmpForType(Type::Funcref);
<span class="line-modified">!     emitCCall(&amp;operationWasmRefFunc, result, instanceValue(), addConstant(Type::I32, index));</span>
  
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addTableGet(unsigned tableIndex, ExpressionType index, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
      ASSERT(index.tmp());
      ASSERT(index.type() == Type::I32);
      result = tmpForType(m_info.tables[tableIndex].wasmType());
  
<span class="line-modified">!     emitCCall(&amp;operationGetWasmTableElement, result, instanceValue(), addConstant(Type::I32, tableIndex), index);</span>
      emitCheck([&amp;] {
          return Inst(BranchTest32, nullptr, Arg::resCond(MacroAssembler::Zero), result, result);
      }, [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
          this-&gt;emitThrowException(jit, ExceptionType::OutOfBoundsTableAccess);
      });
  
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addTableSet(unsigned tableIndex, ExpressionType index, ExpressionType value) -&gt; PartialResult</span>
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
      ASSERT(index.tmp());
      ASSERT(index.type() == Type::I32);
      ASSERT(value.tmp());
  
      auto shouldThrow = g32();
<span class="line-modified">!     emitCCall(&amp;operationSetWasmTableElement, shouldThrow, instanceValue(), addConstant(Type::I32, tableIndex), index, value);</span>
  
      emitCheck([&amp;] {
          return Inst(BranchTest32, nullptr, Arg::resCond(MacroAssembler::Zero), shouldThrow, shouldThrow);
      }, [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
          this-&gt;emitThrowException(jit, ExceptionType::OutOfBoundsTableAccess);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1043,43 ***</span>
  auto AirIRGenerator::addTableSize(unsigned tableIndex, ExpressionType&amp; result) -&gt; PartialResult
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
      result = tmpForType(Type::I32);
  
<span class="line-modified">!     int32_t (*doSize)(Instance*, unsigned) = [] (Instance* instance, unsigned tableIndex) -&gt; int32_t {</span>
<span class="line-removed">-         return instance-&gt;table(tableIndex)-&gt;length();</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitCCall(doSize, result, instanceValue(), addConstant(Type::I32, tableIndex));</span>
  
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addTableGrow(unsigned tableIndex, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      ASSERT(fill.tmp());
      ASSERT(isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()));
      ASSERT(delta.tmp());
      ASSERT(delta.type() == Type::I32);
      result = tmpForType(Type::I32);
  
<span class="line-modified">!     emitCCall(&amp;doWasmTableGrow, result, instanceValue(), addConstant(Type::I32, tableIndex), fill, delta);</span>
  
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addTableFill(unsigned tableIndex, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count) -&gt; PartialResult</span>
  {
      ASSERT(fill.tmp());
      ASSERT(isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()));
      ASSERT(offset.tmp());
      ASSERT(offset.type() == Type::I32);
      ASSERT(count.tmp());
      ASSERT(count.type() == Type::I32);
  
      auto result = tmpForType(Type::I32);
<span class="line-modified">!     emitCCall(&amp;doWasmTableFill, result, instanceValue(), addConstant(Type::I32, tableIndex), offset, fill, count);</span>
  
      emitCheck([&amp;] {
          return Inst(BranchTest32, nullptr, Arg::resCond(MacroAssembler::Zero), result, result);
      }, [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
          this-&gt;emitThrowException(jit, ExceptionType::OutOfBoundsTableAccess);
<span class="line-new-header">--- 1113,39 ---</span>
  auto AirIRGenerator::addTableSize(unsigned tableIndex, ExpressionType&amp; result) -&gt; PartialResult
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
      result = tmpForType(Type::I32);
  
<span class="line-modified">!     emitCCall(&amp;operationGetWasmTableSize, result, instanceValue(), addConstant(Type::I32, tableIndex));</span>
  
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addTableGrow(unsigned tableIndex, ExpressionType fill, ExpressionType delta, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      ASSERT(fill.tmp());
      ASSERT(isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()));
      ASSERT(delta.tmp());
      ASSERT(delta.type() == Type::I32);
      result = tmpForType(Type::I32);
  
<span class="line-modified">!     emitCCall(&amp;operationWasmTableGrow, result, instanceValue(), addConstant(Type::I32, tableIndex), fill, delta);</span>
  
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addTableFill(unsigned tableIndex, ExpressionType offset, ExpressionType fill, ExpressionType count) -&gt; PartialResult</span>
  {
      ASSERT(fill.tmp());
      ASSERT(isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()));
      ASSERT(offset.tmp());
      ASSERT(offset.type() == Type::I32);
      ASSERT(count.tmp());
      ASSERT(count.type() == Type::I32);
  
      auto result = tmpForType(Type::I32);
<span class="line-modified">!     emitCCall(&amp;operationWasmTableFill, result, instanceValue(), addConstant(Type::I32, tableIndex), offset, fill, count);</span>
  
      emitCheck([&amp;] {
          return Inst(BranchTest32, nullptr, Arg::resCond(MacroAssembler::Zero), result, result);
      }, [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
          this-&gt;emitThrowException(jit, ExceptionType::OutOfBoundsTableAccess);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1107,33 ***</span>
      return { };
  }
  
  auto AirIRGenerator::addGrowMemory(ExpressionType delta, ExpressionType&amp; result) -&gt; PartialResult
  {
<span class="line-removed">-     int32_t (*growMemory)(void*, Instance*, int32_t) = [] (void* callFrame, Instance* instance, int32_t delta) -&gt; int32_t {</span>
<span class="line-removed">-         instance-&gt;storeTopCallFrame(callFrame);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (delta &lt; 0)</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto grown = instance-&gt;memory()-&gt;grow(PageCount(delta));</span>
<span class="line-removed">-         if (!grown) {</span>
<span class="line-removed">-             switch (grown.error()) {</span>
<span class="line-removed">-             case Memory::GrowFailReason::InvalidDelta:</span>
<span class="line-removed">-             case Memory::GrowFailReason::InvalidGrowSize:</span>
<span class="line-removed">-             case Memory::GrowFailReason::WouldExceedMaximum:</span>
<span class="line-removed">-             case Memory::GrowFailReason::OutOfMemory:</span>
<span class="line-removed">-                 return -1;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return grown.value().pageCount();</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
      result = g32();
<span class="line-modified">!     emitCCall(growMemory, result, TypedTmp { Tmp(GPRInfo::callFrameRegister), Type::I64 }, instanceValue(), delta);</span>
      restoreWebAssemblyGlobalState(RestoreCachedStackLimit::No, m_info.memory, instanceValue(), m_currentBlock);
  
      return { };
  }
  
<span class="line-new-header">--- 1173,12 ---</span>
      return { };
  }
  
  auto AirIRGenerator::addGrowMemory(ExpressionType delta, ExpressionType&amp; result) -&gt; PartialResult
  {
      result = g32();
<span class="line-modified">!     emitCCall(&amp;operationGrowMemory, result, TypedTmp { Tmp(GPRInfo::callFrameRegister), Type::I64 }, instanceValue(), delta);</span>
      restoreWebAssemblyGlobalState(RestoreCachedStackLimit::No, m_info.memory, instanceValue(), m_currentBlock);
  
      return { };
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1162,27 ***</span>
      return { };
  }
  
  auto AirIRGenerator::getGlobal(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
  {
<span class="line-modified">!     Type type = m_info.globals[index].type;</span>
  
      result = tmpForType(type);
  
      auto temp = g64();
  
      RELEASE_ASSERT(Arg::isValidAddrForm(Instance::offsetOfGlobals(), B3::Width64));
      append(Move, Arg::addr(instanceValue(), Instance::offsetOfGlobals()), temp);
  
      int32_t offset = safeCast&lt;int32_t&gt;(index * sizeof(Register));
<span class="line-modified">!     if (Arg::isValidAddrForm(offset, B3::widthForType(toB3Type(type))))</span>
<span class="line-modified">!         append(moveOpForValueType(type), Arg::addr(temp, offset), result);</span>
<span class="line-modified">!     else {</span>
<span class="line-modified">!         auto temp2 = g64();</span>
<span class="line-modified">!         append(Move, Arg::bigImm(offset), temp2);</span>
<span class="line-modified">!         append(Add64, temp2, temp, temp);</span>
          append(moveOpForValueType(type), Arg::addr(temp), result);
      }
      return { };
  }
  
  auto AirIRGenerator::setGlobal(uint32_t index, ExpressionType value) -&gt; PartialResult
<span class="line-new-header">--- 1207,44 ---</span>
      return { };
  }
  
  auto AirIRGenerator::getGlobal(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
  {
<span class="line-modified">!     const Wasm::GlobalInformation&amp; global = m_info.globals[index];</span>
<span class="line-added">+     Type type = global.type;</span>
  
      result = tmpForType(type);
  
      auto temp = g64();
  
      RELEASE_ASSERT(Arg::isValidAddrForm(Instance::offsetOfGlobals(), B3::Width64));
      append(Move, Arg::addr(instanceValue(), Instance::offsetOfGlobals()), temp);
  
      int32_t offset = safeCast&lt;int32_t&gt;(index * sizeof(Register));
<span class="line-modified">!     switch (global.bindingMode) {</span>
<span class="line-modified">!     case Wasm::GlobalInformation::BindingMode::EmbeddedInInstance:</span>
<span class="line-modified">!         if (Arg::isValidAddrForm(offset, B3::widthForType(toB3Type(type))))</span>
<span class="line-modified">!             append(moveOpForValueType(type), Arg::addr(temp, offset), result);</span>
<span class="line-modified">!         else {</span>
<span class="line-modified">!             auto temp2 = g64();</span>
<span class="line-added">+             append(Move, Arg::bigImm(offset), temp2);</span>
<span class="line-added">+             append(Add64, temp2, temp, temp);</span>
<span class="line-added">+             append(moveOpForValueType(type), Arg::addr(temp), result);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case Wasm::GlobalInformation::BindingMode::Portable:</span>
<span class="line-added">+         ASSERT(global.mutability == Wasm::GlobalInformation::Mutability::Mutable);</span>
<span class="line-added">+         if (Arg::isValidAddrForm(offset, B3::Width64))</span>
<span class="line-added">+             append(Move, Arg::addr(temp, offset), temp);</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             auto temp2 = g64();</span>
<span class="line-added">+             append(Move, Arg::bigImm(offset), temp2);</span>
<span class="line-added">+             append(Add64, temp2, temp, temp);</span>
<span class="line-added">+             append(Move, Arg::addr(temp), temp);</span>
<span class="line-added">+         }</span>
          append(moveOpForValueType(type), Arg::addr(temp), result);
<span class="line-added">+         break;</span>
      }
      return { };
  }
  
  auto AirIRGenerator::setGlobal(uint32_t index, ExpressionType value) -&gt; PartialResult
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1190,24 ***</span>
      auto temp = g64();
  
      RELEASE_ASSERT(Arg::isValidAddrForm(Instance::offsetOfGlobals(), B3::Width64));
      append(Move, Arg::addr(instanceValue(), Instance::offsetOfGlobals()), temp);
  
<span class="line-modified">!     Type type = m_info.globals[index].type;</span>
  
      int32_t offset = safeCast&lt;int32_t&gt;(index * sizeof(Register));
<span class="line-modified">!     if (Arg::isValidAddrForm(offset, B3::widthForType(toB3Type(type))))</span>
<span class="line-modified">!         append(moveOpForValueType(type), value, Arg::addr(temp, offset));</span>
<span class="line-modified">!     else {</span>
<span class="line-modified">!         auto temp2 = g64();</span>
<span class="line-modified">!         append(Move, Arg::bigImm(offset), temp2);</span>
<span class="line-modified">!         append(Add64, temp2, temp, temp);</span>
          append(moveOpForValueType(type), value, Arg::addr(temp));
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     if (isSubtype(type, Anyref))</span>
<span class="line-modified">!         emitWriteBarrierForJSWrapper();</span>
  
      return { };
  }
  
  inline void AirIRGenerator::emitWriteBarrierForJSWrapper()
<span class="line-new-header">--- 1252,84 ---</span>
      auto temp = g64();
  
      RELEASE_ASSERT(Arg::isValidAddrForm(Instance::offsetOfGlobals(), B3::Width64));
      append(Move, Arg::addr(instanceValue(), Instance::offsetOfGlobals()), temp);
  
<span class="line-modified">!     const Wasm::GlobalInformation&amp; global = m_info.globals[index];</span>
<span class="line-added">+     Type type = global.type;</span>
  
      int32_t offset = safeCast&lt;int32_t&gt;(index * sizeof(Register));
<span class="line-modified">!     switch (global.bindingMode) {</span>
<span class="line-modified">!     case Wasm::GlobalInformation::BindingMode::EmbeddedInInstance:</span>
<span class="line-modified">!         if (Arg::isValidAddrForm(offset, B3::widthForType(toB3Type(type))))</span>
<span class="line-modified">!             append(moveOpForValueType(type), value, Arg::addr(temp, offset));</span>
<span class="line-modified">!         else {</span>
<span class="line-modified">!             auto temp2 = g64();</span>
<span class="line-added">+             append(Move, Arg::bigImm(offset), temp2);</span>
<span class="line-added">+             append(Add64, temp2, temp, temp);</span>
<span class="line-added">+             append(moveOpForValueType(type), value, Arg::addr(temp));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (isSubtype(type, Anyref))</span>
<span class="line-added">+             emitWriteBarrierForJSWrapper();</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case Wasm::GlobalInformation::BindingMode::Portable:</span>
<span class="line-added">+         ASSERT(global.mutability == Wasm::GlobalInformation::Mutability::Mutable);</span>
<span class="line-added">+         if (Arg::isValidAddrForm(offset, B3::Width64))</span>
<span class="line-added">+             append(Move, Arg::addr(temp, offset), temp);</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             auto temp2 = g64();</span>
<span class="line-added">+             append(Move, Arg::bigImm(offset), temp2);</span>
<span class="line-added">+             append(Add64, temp2, temp, temp);</span>
<span class="line-added">+             append(Move, Arg::addr(temp), temp);</span>
<span class="line-added">+         }</span>
          append(moveOpForValueType(type), value, Arg::addr(temp));
<span class="line-modified">!         // We emit a write-barrier onto JSWebAssemblyGlobal, not JSWebAssemblyInstance.</span>
<span class="line-added">+         if (isSubtype(type, Anyref)) {</span>
<span class="line-added">+             auto cell = g64();</span>
<span class="line-added">+             auto vm = g64();</span>
<span class="line-added">+             auto cellState = g32();</span>
<span class="line-added">+             auto threshold = g32();</span>
<span class="line-added">+ </span>
<span class="line-added">+             BasicBlock* fenceCheckPath = m_code.addBlock();</span>
<span class="line-added">+             BasicBlock* fencePath = m_code.addBlock();</span>
<span class="line-added">+             BasicBlock* doSlowPath = m_code.addBlock();</span>
<span class="line-added">+             BasicBlock* continuation = m_code.addBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+             append(Move, Arg::addr(instanceValue(), Instance::offsetOfOwner()), cell);</span>
<span class="line-added">+             append(Move, Arg::addr(cell, JSWebAssemblyInstance::offsetOfVM()), vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+             append(Move, Arg::addr(temp, Wasm::Global::offsetOfOwner() - Wasm::Global::offsetOfValue()), cell);</span>
<span class="line-added">+             append(Load8, Arg::addr(cell, JSCell::cellStateOffset()), cellState);</span>
<span class="line-added">+             append(Move32, Arg::addr(vm, VM::offsetOfHeapBarrierThreshold()), threshold);</span>
<span class="line-added">+ </span>
<span class="line-added">+             append(Branch32, Arg::relCond(MacroAssembler::Above), cellState, threshold);</span>
<span class="line-added">+             m_currentBlock-&gt;setSuccessors(continuation, fenceCheckPath);</span>
<span class="line-added">+             m_currentBlock = fenceCheckPath;</span>
<span class="line-added">+ </span>
<span class="line-added">+             append(Load8, Arg::addr(vm, VM::offsetOfHeapMutatorShouldBeFenced()), threshold);</span>
<span class="line-added">+             append(BranchTest32, Arg::resCond(MacroAssembler::Zero), threshold, threshold);</span>
<span class="line-added">+             m_currentBlock-&gt;setSuccessors(doSlowPath, fencePath);</span>
<span class="line-added">+             m_currentBlock = fencePath;</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto* doFence = addPatchpoint(B3::Void);</span>
<span class="line-added">+             doFence-&gt;setGenerator([] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="line-added">+                 jit.memoryFence();</span>
<span class="line-added">+             });</span>
<span class="line-added">+             emitPatchpoint(doFence, Tmp());</span>
<span class="line-added">+ </span>
<span class="line-added">+             append(Load8, Arg::addr(cell, JSCell::cellStateOffset()), cellState);</span>
<span class="line-added">+             append(Branch32, Arg::relCond(MacroAssembler::Above), cellState, Arg::imm(blackThreshold));</span>
<span class="line-added">+             m_currentBlock-&gt;setSuccessors(continuation, doSlowPath);</span>
<span class="line-added">+             m_currentBlock = doSlowPath;</span>
  
<span class="line-modified">!             emitCCall(&amp;operationWasmWriteBarrierSlowPath, TypedTmp(), cell, vm);</span>
<span class="line-modified">!             append(Jump);</span>
<span class="line-added">+             m_currentBlock-&gt;setSuccessors(continuation);</span>
<span class="line-added">+             m_currentBlock = continuation;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
  
      return { };
  }
  
  inline void AirIRGenerator::emitWriteBarrierForJSWrapper()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1245,16 ***</span>
      append(Load8, Arg::addr(cell, JSCell::cellStateOffset()), cellState);
      append(Branch32, Arg::relCond(MacroAssembler::Above), cellState, Arg::imm(blackThreshold));
      m_currentBlock-&gt;setSuccessors(continuation, doSlowPath);
      m_currentBlock = doSlowPath;
  
<span class="line-modified">!     void (*writeBarrier)(JSWebAssemblyInstance*, VM*) = [] (JSWebAssemblyInstance* cell, VM* vm) -&gt; void {</span>
<span class="line-removed">-         ASSERT(cell);</span>
<span class="line-removed">-         ASSERT(vm);</span>
<span class="line-removed">-         vm-&gt;heap.writeBarrierSlowPath(cell);</span>
<span class="line-removed">-     };</span>
<span class="line-removed">-     emitCCall(writeBarrier, TypedTmp(), cell, vm);</span>
      append(Jump);
      m_currentBlock-&gt;setSuccessors(continuation);
      m_currentBlock = continuation;
  }
  
<span class="line-new-header">--- 1367,11 ---</span>
      append(Load8, Arg::addr(cell, JSCell::cellStateOffset()), cellState);
      append(Branch32, Arg::relCond(MacroAssembler::Above), cellState, Arg::imm(blackThreshold));
      m_currentBlock-&gt;setSuccessors(continuation, doSlowPath);
      m_currentBlock = doSlowPath;
  
<span class="line-modified">!     emitCCall(&amp;operationWasmWriteBarrierSlowPath, TypedTmp(), cell, vm);</span>
      append(Jump);
      m_currentBlock-&gt;setSuccessors(continuation);
      m_currentBlock = continuation;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1601,14 ***</span>
      m_currentBlock = continuation;
  
      return { };
  }
  
<span class="line-modified">! void AirIRGenerator::emitEntryTierUpCheck(int32_t incrementCount, B3::Origin origin)</span>
  {
<span class="line-removed">-     UNUSED_PARAM(origin);</span>
<span class="line-removed">- </span>
      if (!m_tierUp)
          return;
  
      auto countdownPtr = g64();
  
<span class="line-new-header">--- 1718,12 ---</span>
      m_currentBlock = continuation;
  
      return { };
  }
  
<span class="line-modified">! void AirIRGenerator::emitEntryTierUpCheck()</span>
  {
      if (!m_tierUp)
          return;
  
      auto countdownPtr = g64();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1622,11 ***</span>
      patch-&gt;clobber(RegisterSet::macroScratchRegisters());
  
      patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
          AllowMacroScratchRegisterUsage allowScratch(jit);
  
<span class="line-modified">!         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(incrementCount), CCallHelpers::Address(params[0].gpr()));</span>
          CCallHelpers::Label tierUpResume = jit.label();
  
          params.addLatePath([=] (CCallHelpers&amp; jit) {
              tierUp.link(&amp;jit);
  
<span class="line-new-header">--- 1737,11 ---</span>
      patch-&gt;clobber(RegisterSet::macroScratchRegisters());
  
      patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
          AllowMacroScratchRegisterUsage allowScratch(jit);
  
<span class="line-modified">!         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(TierUpCount::functionEntryIncrement()), CCallHelpers::Address(params[0].gpr()));</span>
          CCallHelpers::Label tierUpResume = jit.label();
  
          params.addLatePath([=] (CCallHelpers&amp; jit) {
              tierUp.link(&amp;jit);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1648,13 ***</span>
      });
  
      emitPatchpoint(patch, Tmp(), countdownPtr);
  }
  
<span class="line-modified">! void AirIRGenerator::emitLoopTierUpCheck(int32_t incrementCount, const Stack&amp; expressionStack, uint32_t loopIndex, uint32_t outerLoopIndex, B3::Origin origin)</span>
  {
<span class="line-modified">!     UNUSED_PARAM(origin);</span>
  
      if (!m_tierUp)
          return;
  
      ASSERT(m_tierUp-&gt;osrEntryTriggers().size() == loopIndex);
<span class="line-new-header">--- 1763,14 ---</span>
      });
  
      emitPatchpoint(patch, Tmp(), countdownPtr);
  }
  
<span class="line-modified">! void AirIRGenerator::emitLoopTierUpCheck(uint32_t loopIndex, const Stack&amp; enclosingStack)</span>
  {
<span class="line-modified">!     uint32_t outerLoopIndex = this-&gt;outerLoopIndex();</span>
<span class="line-added">+     m_outerLoops.append(loopIndex);</span>
  
      if (!m_tierUp)
          return;
  
      ASSERT(m_tierUp-&gt;osrEntryTriggers().size() == loopIndex);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1678,143 ***</span>
      patch-&gt;clobberLate(clobberLate);
  
      Vector&lt;ConstrainedTmp&gt; patchArgs;
      patchArgs.append(countdownPtr);
  
<span class="line-modified">!     Vector&lt;B3::Type&gt; types;</span>
<span class="line-removed">-     for (auto&amp; local : m_locals) {</span>
          patchArgs.append(ConstrainedTmp(local, B3::ValueRep::ColdAny));
<span class="line-modified">!         types.append(toB3Type(local.type()));</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     for (auto&amp; expression : expressionStack) {</span>
<span class="line-modified">!         patchArgs.append(ConstrainedTmp(expression, B3::ValueRep::ColdAny));</span>
<span class="line-removed">-         types.append(toB3Type(expression.type()));</span>
      }
  
      TierUpCount::TriggerReason* forceEntryTrigger = &amp;(m_tierUp-&gt;osrEntryTriggers().last());
      static_assert(!static_cast&lt;uint8_t&gt;(TierUpCount::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);
      static_assert(sizeof(TierUpCount::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);
      patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
          AllowMacroScratchRegisterUsage allowScratch(jit);
          CCallHelpers::Jump forceOSREntry = jit.branchTest8(CCallHelpers::NonZero, CCallHelpers::AbsoluteAddress(forceEntryTrigger));
<span class="line-modified">!         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(incrementCount), CCallHelpers::Address(params[0].gpr()));</span>
          MacroAssembler::Label tierUpResume = jit.label();
  
          OSREntryData&amp; osrEntryData = m_tierUp-&gt;addOSREntryData(m_functionIndex, loopIndex);
<span class="line-modified">!         for (unsigned index = 0; index &lt; types.size(); ++index)</span>
<span class="line-modified">!             osrEntryData.values().constructAndAppend(params[index + 1], types[index]);</span>
          OSREntryData* osrEntryDataPtr = &amp;osrEntryData;
  
          params.addLatePath([=] (CCallHelpers&amp; jit) {
              AllowMacroScratchRegisterUsage allowScratch(jit);
              forceOSREntry.link(&amp;jit);
              tierUp.link(&amp;jit);
  
<span class="line-modified">!             jit.probe(triggerOSREntryNow, osrEntryDataPtr);</span>
              jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::argumentGPR0).linkTo(tierUpResume, &amp;jit);
              jit.farJump(GPRInfo::argumentGPR1, WasmEntryPtrTag);
          });
      });
  
<span class="line-modified">!     emitPatchpoint(patch, Tmp(), WTFMove(patchArgs));</span>
  }
  
<span class="line-modified">! AirIRGenerator::ControlData AirIRGenerator::addLoop(Type signature, const Stack&amp; expressionStack, uint32_t loopIndex)</span>
  {
      BasicBlock* body = m_code.addBlock();
      BasicBlock* continuation = m_code.addBlock();
  
      append(Jump);
      m_currentBlock-&gt;setSuccessors(body);
  
<span class="line-removed">-     uint32_t outerLoopIndex = this-&gt;outerLoopIndex();</span>
<span class="line-removed">-     m_outerLoops.append(loopIndex);</span>
      m_currentBlock = body;
<span class="line-modified">!     emitLoopTierUpCheck(TierUpCount::loopIncrement(), expressionStack, loopIndex, outerLoopIndex, origin());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return ControlData(origin(), signature, tmpForType(signature), BlockType::Loop, continuation, body);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! AirIRGenerator::ControlData AirIRGenerator::addTopLevel(Type signature)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return ControlData(B3::Origin(), signature, tmpForType(signature), BlockType::TopLevel, m_code.addBlock());</span>
  }
  
<span class="line-modified">! AirIRGenerator::ControlData AirIRGenerator::addBlock(Type signature)</span>
  {
<span class="line-modified">!     return ControlData(origin(), signature, tmpForType(signature), BlockType::Block, m_code.addBlock());</span>
  }
  
<span class="line-modified">! auto AirIRGenerator::addIf(ExpressionType condition, Type signature, ControlType&amp; result) -&gt; PartialResult</span>
  {
      BasicBlock* taken = m_code.addBlock();
      BasicBlock* notTaken = m_code.addBlock();
      BasicBlock* continuation = m_code.addBlock();
  
      // Wasm bools are i32.
      append(BranchTest32, Arg::resCond(MacroAssembler::NonZero), condition, condition);
      m_currentBlock-&gt;setSuccessors(taken, notTaken);
  
      m_currentBlock = taken;
<span class="line-modified">!     result = ControlData(origin(), signature, tmpForType(signature), BlockType::If, continuation, notTaken);</span>
      return { };
  }
  
  auto AirIRGenerator::addElse(ControlData&amp; data, const Stack&amp; currentStack) -&gt; PartialResult
  {
<span class="line-modified">!     unifyValuesWithBlock(currentStack, data.result);</span>
      append(Jump);
      m_currentBlock-&gt;setSuccessors(data.continuation);
      return addElseToUnreachable(data);
  }
  
  auto AirIRGenerator::addElseToUnreachable(ControlData&amp; data) -&gt; PartialResult
  {
<span class="line-modified">!     ASSERT(data.type() == BlockType::If);</span>
      m_currentBlock = data.special;
      data.convertIfToBlock();
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addReturn(const ControlData&amp; data, const ExpressionList&amp; returnValues) -&gt; PartialResult</span>
  {
<span class="line-modified">!     ASSERT(returnValues.size() &lt;= 1);</span>
<span class="line-modified">!     if (returnValues.size()) {</span>
<span class="line-removed">-         Tmp returnValueGPR = Tmp(GPRInfo::returnValueGPR);</span>
<span class="line-removed">-         Tmp returnValueFPR = Tmp(FPRInfo::returnValueFPR);</span>
<span class="line-removed">-         switch (data.signature()) {</span>
<span class="line-removed">-         case Type::I32:</span>
<span class="line-removed">-             append(Move32, returnValues[0], returnValueGPR);</span>
<span class="line-removed">-             append(Ret32, returnValueGPR);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case Type::I64:</span>
<span class="line-removed">-         case Type::Anyref:</span>
<span class="line-removed">-         case Type::Funcref:</span>
<span class="line-removed">-             append(Move, returnValues[0], returnValueGPR);</span>
<span class="line-removed">-             append(Ret64, returnValueGPR);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case Type::F32:</span>
<span class="line-removed">-             append(MoveFloat, returnValues[0], returnValueFPR);</span>
<span class="line-removed">-             append(RetFloat, returnValueFPR);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case Type::F64:</span>
<span class="line-removed">-             append(MoveDouble, returnValues[0], returnValueFPR);</span>
<span class="line-removed">-             append(RetFloat, returnValueFPR);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         default:</span>
<span class="line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } else</span>
          append(RetVoid);
      return { };
  }
  
  // NOTE: All branches in Wasm are on 32-bit ints
  
  auto AirIRGenerator::addBranch(ControlData&amp; data, ExpressionType condition, const Stack&amp; returnValues) -&gt; PartialResult
  {
<span class="line-modified">!     unifyValuesWithBlock(returnValues, data.resultForBranch());</span>
  
      BasicBlock* target = data.targetBlockForBranch();
      if (condition) {
          BasicBlock* continuation = m_code.addBlock();
          append(BranchTest32, Arg::resCond(MacroAssembler::NonZero), condition, condition);
<span class="line-new-header">--- 1794,161 ---</span>
      patch-&gt;clobberLate(clobberLate);
  
      Vector&lt;ConstrainedTmp&gt; patchArgs;
      patchArgs.append(countdownPtr);
  
<span class="line-modified">!     for (auto&amp; local : m_locals)</span>
          patchArgs.append(ConstrainedTmp(local, B3::ValueRep::ColdAny));
<span class="line-modified">!     for (unsigned controlIndex = 0; controlIndex &lt; m_parser-&gt;controlStack().size(); ++controlIndex) {</span>
<span class="line-modified">!         Stack&amp; expressionStack = m_parser-&gt;controlStack()[controlIndex].enclosedExpressionStack;</span>
<span class="line-modified">!         for (TypedExpression value : expressionStack)</span>
<span class="line-modified">!             patchArgs.append(ConstrainedTmp(value.value(), B3::ValueRep::ColdAny));</span>
      }
<span class="line-added">+     for (TypedExpression value : enclosingStack)</span>
<span class="line-added">+         patchArgs.append(ConstrainedTmp(value.value(), B3::ValueRep::ColdAny));</span>
  
      TierUpCount::TriggerReason* forceEntryTrigger = &amp;(m_tierUp-&gt;osrEntryTriggers().last());
      static_assert(!static_cast&lt;uint8_t&gt;(TierUpCount::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);
      static_assert(sizeof(TierUpCount::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);
      patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
          AllowMacroScratchRegisterUsage allowScratch(jit);
          CCallHelpers::Jump forceOSREntry = jit.branchTest8(CCallHelpers::NonZero, CCallHelpers::AbsoluteAddress(forceEntryTrigger));
<span class="line-modified">!         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(TierUpCount::loopIncrement()), CCallHelpers::Address(params[0].gpr()));</span>
          MacroAssembler::Label tierUpResume = jit.label();
  
          OSREntryData&amp; osrEntryData = m_tierUp-&gt;addOSREntryData(m_functionIndex, loopIndex);
<span class="line-modified">!         // First argument is the countdown location.</span>
<span class="line-modified">!         for (unsigned index = 1; index &lt; params.value()-&gt;numChildren(); ++index)</span>
<span class="line-added">+             osrEntryData.values().constructAndAppend(params[index], params.value()-&gt;child(index)-&gt;type());</span>
          OSREntryData* osrEntryDataPtr = &amp;osrEntryData;
  
          params.addLatePath([=] (CCallHelpers&amp; jit) {
              AllowMacroScratchRegisterUsage allowScratch(jit);
              forceOSREntry.link(&amp;jit);
              tierUp.link(&amp;jit);
  
<span class="line-modified">!             jit.probe(operationWasmTriggerOSREntryNow, osrEntryDataPtr);</span>
              jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::argumentGPR0).linkTo(tierUpResume, &amp;jit);
              jit.farJump(GPRInfo::argumentGPR1, WasmEntryPtrTag);
          });
      });
  
<span class="line-modified">!     emitPatchpoint(m_currentBlock, patch, ResultList { }, WTFMove(patchArgs));</span>
  }
  
<span class="line-modified">! AirIRGenerator::ControlData AirIRGenerator::addTopLevel(BlockSignature signature)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return ControlData(B3::Origin(), signature, tmpsForSignature(signature), BlockType::TopLevel, m_code.addBlock());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ auto AirIRGenerator::addLoop(BlockSignature signature, Stack&amp; enclosingStack, ControlType&amp; block, Stack&amp; newStack, uint32_t loopIndex) -&gt; PartialResult</span>
  {
      BasicBlock* body = m_code.addBlock();
      BasicBlock* continuation = m_code.addBlock();
  
<span class="line-added">+     splitStack(signature, enclosingStack, newStack);</span>
<span class="line-added">+     ResultList results;</span>
<span class="line-added">+     results.reserveInitialCapacity(newStack.size());</span>
<span class="line-added">+     for (auto item : newStack)</span>
<span class="line-added">+         results.uncheckedAppend(item);</span>
<span class="line-added">+     block = ControlData(origin(), signature, WTFMove(results), BlockType::Loop, continuation, body);</span>
<span class="line-added">+ </span>
      append(Jump);
      m_currentBlock-&gt;setSuccessors(body);
  
      m_currentBlock = body;
<span class="line-modified">!     emitLoopTierUpCheck(loopIndex, enclosingStack);</span>
  
<span class="line-modified">!     return { };</span>
  }
  
<span class="line-modified">! auto AirIRGenerator::addBlock(BlockSignature signature, Stack&amp; enclosingStack, ControlType&amp; newBlock, Stack&amp; newStack) -&gt; PartialResult</span>
  {
<span class="line-modified">!     splitStack(signature, enclosingStack, newStack);</span>
<span class="line-added">+     newBlock = ControlData(origin(), signature, tmpsForSignature(signature), BlockType::Block, m_code.addBlock());</span>
<span class="line-added">+     return { };</span>
  }
  
<span class="line-modified">! auto AirIRGenerator::addIf(ExpressionType condition, BlockSignature signature, Stack&amp; enclosingStack, ControlType&amp; result, Stack&amp; newStack) -&gt; PartialResult</span>
  {
      BasicBlock* taken = m_code.addBlock();
      BasicBlock* notTaken = m_code.addBlock();
      BasicBlock* continuation = m_code.addBlock();
  
      // Wasm bools are i32.
      append(BranchTest32, Arg::resCond(MacroAssembler::NonZero), condition, condition);
      m_currentBlock-&gt;setSuccessors(taken, notTaken);
  
      m_currentBlock = taken;
<span class="line-modified">!     splitStack(signature, enclosingStack, newStack);</span>
<span class="line-added">+     result = ControlData(origin(), signature, tmpsForSignature(signature), BlockType::If, continuation, notTaken);</span>
      return { };
  }
  
  auto AirIRGenerator::addElse(ControlData&amp; data, const Stack&amp; currentStack) -&gt; PartialResult
  {
<span class="line-modified">!     unifyValuesWithBlock(currentStack, data.results);</span>
      append(Jump);
      m_currentBlock-&gt;setSuccessors(data.continuation);
      return addElseToUnreachable(data);
  }
  
  auto AirIRGenerator::addElseToUnreachable(ControlData&amp; data) -&gt; PartialResult
  {
<span class="line-modified">!     ASSERT(data.blockType() == BlockType::If);</span>
      m_currentBlock = data.special;
      data.convertIfToBlock();
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addReturn(const ControlData&amp; data, const Stack&amp; returnValues) -&gt; PartialResult</span>
  {
<span class="line-modified">!     CallInformation wasmCallInfo = wasmCallingConvention().callInformationFor(*data.signature(), CallRole::Callee);</span>
<span class="line-modified">!     if (!wasmCallInfo.results.size()) {</span>
          append(RetVoid);
<span class="line-added">+         return { };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     B3::PatchpointValue* patch = addPatchpoint(B3::Void);</span>
<span class="line-added">+     patch-&gt;setGenerator([] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {</span>
<span class="line-added">+         auto calleeSaves = params.code().calleeSaveRegisterAtOffsetList();</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (RegisterAtOffset calleeSave : calleeSaves)</span>
<span class="line-added">+             jit.load64ToReg(CCallHelpers::Address(GPRInfo::callFrameRegister, calleeSave.offset()), calleeSave.reg());</span>
<span class="line-added">+ </span>
<span class="line-added">+         jit.emitFunctionEpilogue();</span>
<span class="line-added">+         jit.ret();</span>
<span class="line-added">+     });</span>
<span class="line-added">+     patch-&gt;effects.terminal = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(returnValues.size() &gt;= wasmCallInfo.results.size());</span>
<span class="line-added">+     unsigned offset = returnValues.size() - wasmCallInfo.results.size();</span>
<span class="line-added">+     Vector&lt;ConstrainedTmp, 8&gt; returnConstraints;</span>
<span class="line-added">+     for (unsigned i = 0; i &lt; wasmCallInfo.results.size(); ++i) {</span>
<span class="line-added">+         B3::ValueRep rep = wasmCallInfo.results[i];</span>
<span class="line-added">+         TypedTmp tmp = returnValues[offset + i];</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (rep.isStack()) {</span>
<span class="line-added">+             append(moveForType(toB3Type(tmp.type())), tmp, Arg::addr(Tmp(GPRInfo::callFrameRegister), rep.offsetFromFP()));</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         ASSERT(rep.isReg());</span>
<span class="line-added">+         if (data.signature()-&gt;returnType(i) == I32)</span>
<span class="line-added">+             append(Move32, tmp, tmp);</span>
<span class="line-added">+         returnConstraints.append(ConstrainedTmp(tmp, wasmCallInfo.results[i]));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitPatchpoint(m_currentBlock, patch, ResultList { }, WTFMove(returnConstraints));</span>
      return { };
  }
  
  // NOTE: All branches in Wasm are on 32-bit ints
  
  auto AirIRGenerator::addBranch(ControlData&amp; data, ExpressionType condition, const Stack&amp; returnValues) -&gt; PartialResult
  {
<span class="line-modified">!     unifyValuesWithBlock(returnValues, data.results);</span>
  
      BasicBlock* target = data.targetBlockForBranch();
      if (condition) {
          BasicBlock* continuation = m_code.addBlock();
          append(BranchTest32, Arg::resCond(MacroAssembler::NonZero), condition, condition);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1831,14 ***</span>
  auto AirIRGenerator::addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const Stack&amp; expressionStack) -&gt; PartialResult
  {
      auto&amp; successors = m_currentBlock-&gt;successors();
      ASSERT(successors.isEmpty());
      for (const auto&amp; target : targets) {
<span class="line-modified">!         unifyValuesWithBlock(expressionStack, target-&gt;resultForBranch());</span>
          successors.append(target-&gt;targetBlockForBranch());
      }
<span class="line-modified">!     unifyValuesWithBlock(expressionStack, defaultTarget.resultForBranch());</span>
      successors.append(defaultTarget.targetBlockForBranch());
  
      ASSERT(condition.type() == Type::I32);
  
      // FIXME: We should consider dynamically switching between a jump table
<span class="line-new-header">--- 1965,14 ---</span>
  auto AirIRGenerator::addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const Stack&amp; expressionStack) -&gt; PartialResult
  {
      auto&amp; successors = m_currentBlock-&gt;successors();
      ASSERT(successors.isEmpty());
      for (const auto&amp; target : targets) {
<span class="line-modified">!         unifyValuesWithBlock(expressionStack, target-&gt;results);</span>
          successors.append(target-&gt;targetBlockForBranch());
      }
<span class="line-modified">!     unifyValuesWithBlock(expressionStack, defaultTarget.results);</span>
      successors.append(defaultTarget.targetBlockForBranch());
  
      ASSERT(condition.type() == Type::I32);
  
      // FIXME: We should consider dynamically switching between a jump table
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1893,50 ***</span>
  
  auto AirIRGenerator::endBlock(ControlEntry&amp; entry, Stack&amp; expressionStack) -&gt; PartialResult
  {
      ControlData&amp; data = entry.controlData;
  
<span class="line-modified">!     unifyValuesWithBlock(expressionStack, data.result);</span>
      append(Jump);
      m_currentBlock-&gt;setSuccessors(data.continuation);
  
<span class="line-modified">!     return addEndToUnreachable(entry);</span>
  }
  
  
<span class="line-modified">! auto AirIRGenerator::addEndToUnreachable(ControlEntry&amp; entry) -&gt; PartialResult</span>
  {
      ControlData&amp; data = entry.controlData;
      m_currentBlock = data.continuation;
  
<span class="line-modified">!     if (data.type() == BlockType::If) {</span>
          append(data.special, Jump);
          data.special-&gt;setSuccessors(m_currentBlock);
      }
  
<span class="line-modified">!     if (data.type() == BlockType::Loop)</span>
          m_outerLoops.removeLast();
<span class="line-modified">! </span>
<span class="line-modified">!     for (const auto&amp; result : data.result)</span>
<span class="line-modified">!         entry.enclosedExpressionStack.append(result);</span>
  
      // TopLevel does not have any code after this so we need to make sure we emit a return here.
<span class="line-modified">!     if (data.type() == BlockType::TopLevel)</span>
          return addReturn(data, entry.enclosedExpressionStack);
  
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addCall(uint32_t functionIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      ASSERT(signature.argumentCount() == args.size());
  
      m_makesCalls = true;
  
<span class="line-modified">!     Type returnType = signature.returnType();</span>
<span class="line-modified">!     if (returnType != Type::Void)</span>
<span class="line-removed">-         result = tmpForType(returnType);</span>
  
      Vector&lt;UnlinkedWasmToWasmCall&gt;* unlinkedWasmToWasmCalls = &amp;m_unlinkedWasmToWasmCalls;
  
      if (m_info.isImportedFunctionFromFunctionIndexSpace(functionIndex)) {
          m_maxNumJSCallArguments = std::max(m_maxNumJSCallArguments, static_cast&lt;uint32_t&gt;(args.size()));
<span class="line-new-header">--- 2027,84 ---</span>
  
  auto AirIRGenerator::endBlock(ControlEntry&amp; entry, Stack&amp; expressionStack) -&gt; PartialResult
  {
      ControlData&amp; data = entry.controlData;
  
<span class="line-modified">!     if (data.blockType() != BlockType::Loop)</span>
<span class="line-added">+         unifyValuesWithBlock(expressionStack, data.results);</span>
      append(Jump);
      m_currentBlock-&gt;setSuccessors(data.continuation);
  
<span class="line-modified">!     return addEndToUnreachable(entry, expressionStack);</span>
  }
  
  
<span class="line-modified">! auto AirIRGenerator::addEndToUnreachable(ControlEntry&amp; entry, const Stack&amp; expressionStack) -&gt; PartialResult</span>
  {
      ControlData&amp; data = entry.controlData;
      m_currentBlock = data.continuation;
  
<span class="line-modified">!     if (data.blockType() == BlockType::If) {</span>
          append(data.special, Jump);
          data.special-&gt;setSuccessors(m_currentBlock);
      }
  
<span class="line-modified">!     if (data.blockType() == BlockType::Loop) {</span>
          m_outerLoops.removeLast();
<span class="line-modified">!         for (unsigned i = 0; i &lt; data.signature()-&gt;returnCount(); ++i) {</span>
<span class="line-modified">!             if (i &lt; expressionStack.size())</span>
<span class="line-modified">!                 entry.enclosedExpressionStack.append(expressionStack[i]);</span>
<span class="line-added">+             else {</span>
<span class="line-added">+                 Type type = data.signature()-&gt;returnType(i);</span>
<span class="line-added">+                 entry.enclosedExpressionStack.constructAndAppend(type, addBottom(m_currentBlock, type));</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; data.signature()-&gt;returnCount(); ++i)</span>
<span class="line-added">+             entry.enclosedExpressionStack.constructAndAppend(data.signature()-&gt;returnType(i), data.results[i]);</span>
<span class="line-added">+     }</span>
  
      // TopLevel does not have any code after this so we need to make sure we emit a return here.
<span class="line-modified">!     if (data.blockType() == BlockType::TopLevel)</span>
          return addReturn(data, entry.enclosedExpressionStack);
  
      return { };
  }
  
<span class="line-modified">! B3::PatchpointValue* AirIRGenerator::emitCallPatchpoint(BasicBlock* block, const Signature&amp; signature, const ResultList&amp; results, const Vector&lt;TypedTmp&gt;&amp; args, Vector&lt;ConstrainedTmp&gt;&amp;&amp; patchArgs)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* patchpoint = addPatchpoint(toB3ResultType(&amp;signature));</span>
<span class="line-added">+     patchpoint-&gt;effects.writesPinned = true;</span>
<span class="line-added">+     patchpoint-&gt;effects.readsPinned = true;</span>
<span class="line-added">+     patchpoint-&gt;clobberEarly(RegisterSet::macroScratchRegisters());</span>
<span class="line-added">+     patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());</span>
<span class="line-added">+ </span>
<span class="line-added">+     CallInformation locations = wasmCallingConvention().callInformationFor(signature);</span>
<span class="line-added">+     m_code.requestCallArgAreaSizeInBytes(WTF::roundUpToMultipleOf(stackAlignmentBytes(), locations.headerAndArgumentStackSizeInBytes));</span>
<span class="line-added">+ </span>
<span class="line-added">+     size_t offset = patchArgs.size();</span>
<span class="line-added">+     Checked&lt;size_t&gt; newSize = checkedSum&lt;size_t&gt;(patchArgs.size(), args.size());</span>
<span class="line-added">+     RELEASE_ASSERT(!newSize.hasOverflowed());</span>
<span class="line-added">+ </span>
<span class="line-added">+     patchArgs.grow(newSize.unsafeGet());</span>
<span class="line-added">+     for (unsigned i = 0; i &lt; args.size(); ++i)</span>
<span class="line-added">+         patchArgs[i + offset] = ConstrainedTmp(args[i], locations.params[i]);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (patchpoint-&gt;type() != B3::Void)</span>
<span class="line-added">+         patchpoint-&gt;resultConstraints = WTFMove(locations.results);</span>
<span class="line-added">+     emitPatchpoint(block, patchpoint, results, WTFMove(patchArgs));</span>
<span class="line-added">+     return patchpoint;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ auto AirIRGenerator::addCall(uint32_t functionIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ResultList&amp; results) -&gt; PartialResult</span>
  {
      ASSERT(signature.argumentCount() == args.size());
  
      m_makesCalls = true;
  
<span class="line-modified">!     for (unsigned i = 0; i &lt; signature.returnCount(); ++i)</span>
<span class="line-modified">!         results.append(tmpForType(signature.returnType(i)));</span>
  
      Vector&lt;UnlinkedWasmToWasmCall&gt;* unlinkedWasmToWasmCalls = &amp;m_unlinkedWasmToWasmCalls;
  
      if (m_info.isImportedFunctionFromFunctionIndexSpace(functionIndex)) {
          m_maxNumJSCallArguments = std::max(m_maxNumJSCallArguments, static_cast&lt;uint32_t&gt;(args.size()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1958,95 ***</span>
  
          append(BranchTest64, Arg::resCond(MacroAssembler::NonZero), targetInstance, targetInstance);
          m_currentBlock-&gt;setSuccessors(isWasmBlock, isEmbedderBlock);
  
          {
<span class="line-modified">!             auto* patchpoint = addPatchpoint(toB3Type(returnType));</span>
<span class="line-removed">-             patchpoint-&gt;effects.writesPinned = true;</span>
<span class="line-removed">-             patchpoint-&gt;effects.readsPinned = true;</span>
              // We need to clobber all potential pinned registers since we might be leaving the instance.
              // We pessimistically assume we could be calling to something that is bounds checking.
              // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
              patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
  
<span class="line-removed">-             Vector&lt;ConstrainedTmp&gt; patchArgs;</span>
<span class="line-removed">-             wasmCallingConventionAir().setupCall(m_code, returnType, patchpoint, toTmpVector(args), [&amp;] (Tmp tmp, B3::ValueRep rep) {</span>
<span class="line-removed">-                 patchArgs.append({ tmp, rep });</span>
<span class="line-removed">-             });</span>
<span class="line-removed">- </span>
              patchpoint-&gt;setGenerator([unlinkedWasmToWasmCalls, functionIndex] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
                  CCallHelpers::Call call = jit.threadSafePatchableNearCall();
                  jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndex] (LinkBuffer&amp; linkBuffer) {
                      unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndex });
                  });
              });
  
<span class="line-removed">-             emitPatchpoint(isWasmBlock, patchpoint, result, WTFMove(patchArgs));</span>
              append(isWasmBlock, Jump);
              isWasmBlock-&gt;setSuccessors(continuation);
          }
  
          {
              auto jumpDestination = g64();
              append(isEmbedderBlock, Move, Arg::bigImm(Instance::offsetOfWasmToEmbedderStub(functionIndex)), jumpDestination);
              append(isEmbedderBlock, Add64, instanceValue(), jumpDestination);
              append(isEmbedderBlock, Move, Arg::addr(jumpDestination), jumpDestination);
  
<span class="line-modified">!             auto* patchpoint = addPatchpoint(toB3Type(returnType));</span>
<span class="line-modified">!             patchpoint-&gt;effects.writesPinned = true;</span>
<span class="line-modified">!             patchpoint-&gt;effects.readsPinned = true;</span>
              // We need to clobber all potential pinned registers since we might be leaving the instance.
              // We pessimistically assume we could be calling to something that is bounds checking.
              // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
              patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
<span class="line-modified">! </span>
<span class="line-removed">-             Vector&lt;ConstrainedTmp&gt; patchArgs;</span>
<span class="line-removed">-             patchArgs.append(jumpDestination);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             wasmCallingConventionAir().setupCall(m_code, returnType, patchpoint, toTmpVector(args), [&amp;] (Tmp tmp, B3::ValueRep rep) {</span>
<span class="line-removed">-                 patchArgs.append({ tmp, rep });</span>
<span class="line-removed">-             });</span>
<span class="line-removed">- </span>
<span class="line-removed">-             patchpoint-&gt;setGenerator([returnType] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {</span>
                  AllowMacroScratchRegisterUsage allowScratch(jit);
<span class="line-modified">!                 jit.call(params[returnType == Void ? 0 : 1].gpr(), WasmEntryPtrTag);</span>
              });
  
<span class="line-removed">-             emitPatchpoint(isEmbedderBlock, patchpoint, result, WTFMove(patchArgs));</span>
              append(isEmbedderBlock, Jump);
              isEmbedderBlock-&gt;setSuccessors(continuation);
          }
  
          m_currentBlock = continuation;
          // The call could have been to another WebAssembly instance, and / or could have modified our Memory.
          restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, currentInstance, continuation);
      } else {
<span class="line-modified">!         auto* patchpoint = addPatchpoint(toB3Type(returnType));</span>
<span class="line-modified">!         patchpoint-&gt;effects.writesPinned = true;</span>
<span class="line-modified">!         patchpoint-&gt;effects.readsPinned = true;</span>
<span class="line-modified">! </span>
<span class="line-removed">-         Vector&lt;ConstrainedTmp&gt; patchArgs;</span>
<span class="line-removed">-         wasmCallingConventionAir().setupCall(m_code, returnType, patchpoint, toTmpVector(args), [&amp;] (Tmp tmp, B3::ValueRep rep) {</span>
<span class="line-removed">-             patchArgs.append({ tmp, rep });</span>
<span class="line-removed">-         });</span>
<span class="line-removed">- </span>
          patchpoint-&gt;setGenerator([unlinkedWasmToWasmCalls, functionIndex] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
              AllowMacroScratchRegisterUsage allowScratch(jit);
              CCallHelpers::Call call = jit.threadSafePatchableNearCall();
              jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndex] (LinkBuffer&amp; linkBuffer) {
                  unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndex });
              });
          });
<span class="line-removed">- </span>
<span class="line-removed">-         emitPatchpoint(m_currentBlock, patchpoint, result, WTFMove(patchArgs));</span>
      }
  
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addCallIndirect(unsigned tableIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      ExpressionType calleeIndex = args.takeLast();
      ASSERT(signature.argumentCount() == args.size());
      ASSERT(m_info.tableCount() &gt; tableIndex);
      ASSERT(m_info.tables[tableIndex].type() == TableElementType::Funcref);
<span class="line-new-header">--- 2126,71 ---</span>
  
          append(BranchTest64, Arg::resCond(MacroAssembler::NonZero), targetInstance, targetInstance);
          m_currentBlock-&gt;setSuccessors(isWasmBlock, isEmbedderBlock);
  
          {
<span class="line-modified">!             auto* patchpoint = emitCallPatchpoint(isWasmBlock, signature, results, args);</span>
              // We need to clobber all potential pinned registers since we might be leaving the instance.
              // We pessimistically assume we could be calling to something that is bounds checking.
              // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
              patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
  
              patchpoint-&gt;setGenerator([unlinkedWasmToWasmCalls, functionIndex] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
                  CCallHelpers::Call call = jit.threadSafePatchableNearCall();
                  jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndex] (LinkBuffer&amp; linkBuffer) {
                      unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndex });
                  });
              });
  
              append(isWasmBlock, Jump);
              isWasmBlock-&gt;setSuccessors(continuation);
          }
  
          {
              auto jumpDestination = g64();
              append(isEmbedderBlock, Move, Arg::bigImm(Instance::offsetOfWasmToEmbedderStub(functionIndex)), jumpDestination);
              append(isEmbedderBlock, Add64, instanceValue(), jumpDestination);
              append(isEmbedderBlock, Move, Arg::addr(jumpDestination), jumpDestination);
  
<span class="line-modified">!             Vector&lt;ConstrainedTmp&gt; jumpArgs;</span>
<span class="line-modified">!             jumpArgs.append({ jumpDestination, B3::ValueRep::SomeRegister });</span>
<span class="line-modified">!             auto* patchpoint = emitCallPatchpoint(isEmbedderBlock, signature, results, args, WTFMove(jumpArgs));</span>
              // We need to clobber all potential pinned registers since we might be leaving the instance.
              // We pessimistically assume we could be calling to something that is bounds checking.
              // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
              patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
<span class="line-modified">!             patchpoint-&gt;setGenerator([] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {</span>
                  AllowMacroScratchRegisterUsage allowScratch(jit);
<span class="line-modified">!                 jit.call(params[params.proc().resultCount(params.value()-&gt;type())].gpr(), WasmEntryPtrTag);</span>
              });
  
              append(isEmbedderBlock, Jump);
              isEmbedderBlock-&gt;setSuccessors(continuation);
          }
  
          m_currentBlock = continuation;
          // The call could have been to another WebAssembly instance, and / or could have modified our Memory.
          restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, currentInstance, continuation);
      } else {
<span class="line-modified">!         auto* patchpoint = emitCallPatchpoint(m_currentBlock, signature, results, args);</span>
<span class="line-modified">!         // We need to clobber the size register since the LLInt always bounds checks</span>
<span class="line-modified">!         if (m_mode == MemoryMode::Signaling)</span>
<span class="line-modified">!             patchpoint-&gt;clobberLate(RegisterSet { PinnedRegisterInfo::get().sizeRegister });</span>
          patchpoint-&gt;setGenerator([unlinkedWasmToWasmCalls, functionIndex] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
              AllowMacroScratchRegisterUsage allowScratch(jit);
              CCallHelpers::Call call = jit.threadSafePatchableNearCall();
              jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndex] (LinkBuffer&amp; linkBuffer) {
                  unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndex });
              });
          });
      }
  
      return { };
  }
  
<span class="line-modified">! auto AirIRGenerator::addCallIndirect(unsigned tableIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ResultList&amp; results) -&gt; PartialResult</span>
  {
      ExpressionType calleeIndex = args.takeLast();
      ASSERT(signature.argumentCount() == args.size());
      ASSERT(m_info.tableCount() &gt; tableIndex);
      ASSERT(m_info.tables[tableIndex].type() == TableElementType::Funcref);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2171,43 ***</span>
          m_currentBlock = continuation;
      }
  
      append(Move, Arg::addr(calleeCode), calleeCode);
  
<span class="line-modified">!     Type returnType = signature.returnType();</span>
<span class="line-modified">!     if (returnType != Type::Void)</span>
<span class="line-modified">!         result = tmpForType(returnType);</span>
  
<span class="line-removed">-     auto* patch = addPatchpoint(toB3Type(returnType));</span>
<span class="line-removed">-     patch-&gt;effects.writesPinned = true;</span>
<span class="line-removed">-     patch-&gt;effects.readsPinned = true;</span>
      // We need to clobber all potential pinned registers since we might be leaving the instance.
      // We pessimistically assume we&#39;re always calling something that is bounds checking so
      // because the wasm-&gt;wasm thunk unconditionally overrides the size registers.
      // FIXME: We should not have to do this, but the wasm-&gt;wasm stub assumes it can
      // use all the pinned registers as scratch: https://bugs.webkit.org/show_bug.cgi?id=172181
<span class="line-removed">-     patch-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));</span>
  
<span class="line-modified">!     Vector&lt;ConstrainedTmp&gt; emitArgs;</span>
<span class="line-modified">!     emitArgs.append(calleeCode);</span>
<span class="line-modified">!     wasmCallingConventionAir().setupCall(m_code, returnType, patch, toTmpVector(args), [&amp;] (Tmp tmp, B3::ValueRep rep) {</span>
<span class="line-removed">-         emitArgs.append({ tmp, rep });</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {</span>
          AllowMacroScratchRegisterUsage allowScratch(jit);
<span class="line-modified">!         jit.call(params[returnType == Void ? 0 : 1].gpr(), WasmEntryPtrTag);</span>
      });
  
<span class="line-removed">-     emitPatchpoint(m_currentBlock, patch, result, WTFMove(emitArgs));</span>
<span class="line-removed">- </span>
      // The call could have been to another WebAssembly instance, and / or could have modified our Memory.
      restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, currentInstance, m_currentBlock);
  
      return { };
  }
  
<span class="line-modified">! void AirIRGenerator::unify(const ExpressionType&amp; dst, const ExpressionType&amp; source)</span>
  {
      ASSERT(isSubtype(source.type(), dst.type()));
      append(moveOpForValueType(dst.type()), source, dst);
  }
  
<span class="line-new-header">--- 2315,38 ---</span>
          m_currentBlock = continuation;
      }
  
      append(Move, Arg::addr(calleeCode), calleeCode);
  
<span class="line-modified">!     Vector&lt;ConstrainedTmp&gt; extraArgs;</span>
<span class="line-modified">!     extraArgs.append(calleeCode);</span>
<span class="line-modified">! </span>
<span class="line-added">+     for (unsigned i = 0; i &lt; signature.returnCount(); ++i)</span>
<span class="line-added">+         results.append(tmpForType(signature.returnType(i)));</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* patchpoint = emitCallPatchpoint(m_currentBlock, signature, results, args, WTFMove(extraArgs));</span>
  
      // We need to clobber all potential pinned registers since we might be leaving the instance.
      // We pessimistically assume we&#39;re always calling something that is bounds checking so
      // because the wasm-&gt;wasm thunk unconditionally overrides the size registers.
      // FIXME: We should not have to do this, but the wasm-&gt;wasm stub assumes it can
      // use all the pinned registers as scratch: https://bugs.webkit.org/show_bug.cgi?id=172181
  
<span class="line-modified">!     patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {</span>
          AllowMacroScratchRegisterUsage allowScratch(jit);
<span class="line-modified">!         jit.call(params[params.proc().resultCount(params.value()-&gt;type())].gpr(), WasmEntryPtrTag);</span>
      });
  
      // The call could have been to another WebAssembly instance, and / or could have modified our Memory.
      restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, currentInstance, m_currentBlock);
  
      return { };
  }
  
<span class="line-modified">! void AirIRGenerator::unify(const ExpressionType dst, const ExpressionType source)</span>
  {
      ASSERT(isSubtype(source.type(), dst.type()));
      append(moveOpForValueType(dst.type()), source, dst);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2217,21 ***</span>
  
      for (size_t i = 0; i &lt; result.size(); ++i)
          unify(result[result.size() - 1 - i], resultStack[resultStack.size() - 1 - i]);
  }
  
<span class="line-modified">! void AirIRGenerator::dump(const Vector&lt;ControlEntry&gt;&amp;, const Stack*)</span>
  {
  }
  
  auto AirIRGenerator::origin() -&gt; B3::Origin
  {
      // FIXME: We should implement a way to give Inst&#39;s an origin.
      return B3::Origin();
  }
  
<span class="line-modified">! Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompileAir(CompilationContext&amp; compilationContext, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, const ModuleInformation&amp; info, MemoryMode mode, uint32_t functionIndex, TierUpCount* tierUp, ThrowWasmException throwWasmException)</span>
  {
      auto result = makeUnique&lt;InternalFunction&gt;();
  
      compilationContext.embedderEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();
      compilationContext.wasmEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();
<span class="line-new-header">--- 2356,40 ---</span>
  
      for (size_t i = 0; i &lt; result.size(); ++i)
          unify(result[result.size() - 1 - i], resultStack[resultStack.size() - 1 - i]);
  }
  
<span class="line-modified">! static void dumpExpressionStack(const CommaPrinter&amp; comma, const AirIRGenerator::Stack&amp; expressionStack)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     dataLog(comma, &quot;ExpressionStack:&quot;);</span>
<span class="line-added">+     for (const auto&amp; expression : expressionStack)</span>
<span class="line-added">+         dataLog(comma, expression.value());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void AirIRGenerator::dump(const ControlStack&amp; controlStack, const Stack* stack)</span>
  {
<span class="line-added">+     dataLogLn(&quot;Processing Graph:&quot;);</span>
<span class="line-added">+     dataLog(m_code);</span>
<span class="line-added">+     dataLogLn(&quot;With current block:&quot;, *m_currentBlock);</span>
<span class="line-added">+     dataLogLn(&quot;Control stack:&quot;);</span>
<span class="line-added">+     for (size_t i = controlStack.size(); i--;) {</span>
<span class="line-added">+         dataLog(&quot;  &quot;, controlStack[i].controlData, &quot;: &quot;);</span>
<span class="line-added">+         CommaPrinter comma(&quot;, &quot;, &quot;&quot;);</span>
<span class="line-added">+         dumpExpressionStack(comma, *stack);</span>
<span class="line-added">+         stack = &amp;controlStack[i].enclosedExpressionStack;</span>
<span class="line-added">+         dataLogLn();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     dataLogLn(&quot;\n&quot;);</span>
  }
  
  auto AirIRGenerator::origin() -&gt; B3::Origin
  {
      // FIXME: We should implement a way to give Inst&#39;s an origin.
      return B3::Origin();
  }
  
<span class="line-modified">! Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompileAir(CompilationContext&amp; compilationContext, const FunctionData&amp; function, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, const ModuleInformation&amp; info, MemoryMode mode, uint32_t functionIndex, TierUpCount* tierUp)</span>
  {
      auto result = makeUnique&lt;InternalFunction&gt;();
  
      compilationContext.embedderEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();
      compilationContext.wasmEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2250,12 ***</span>
      // optLevel=1.
      procedure.setNeedsUsedRegisters(false);
  
      procedure.setOptLevel(Options::webAssemblyBBQAirOptimizationLevel());
  
<span class="line-modified">!     AirIRGenerator irGenerator(info, procedure, result.get(), unlinkedWasmToWasmCalls, mode, functionIndex, tierUp, throwWasmException, signature);</span>
<span class="line-modified">!     FunctionParser&lt;AirIRGenerator&gt; parser(irGenerator, functionStart, functionLength, signature, info);</span>
      WASM_FAIL_IF_HELPER_FAILS(parser.parse());
  
  
      for (BasicBlock* block : code) {
          for (size_t i = 0; i &lt; block-&gt;numSuccessors(); ++i)
<span class="line-new-header">--- 2408,12 ---</span>
      // optLevel=1.
      procedure.setNeedsUsedRegisters(false);
  
      procedure.setOptLevel(Options::webAssemblyBBQAirOptimizationLevel());
  
<span class="line-modified">!     AirIRGenerator irGenerator(info, procedure, result.get(), unlinkedWasmToWasmCalls, mode, functionIndex, tierUp, signature);</span>
<span class="line-modified">!     FunctionParser&lt;AirIRGenerator&gt; parser(irGenerator, function.data.data(), function.data.size(), signature, info);</span>
      WASM_FAIL_IF_HELPER_FAILS(parser.parse());
  
  
      for (BasicBlock* block : code) {
          for (size_t i = 0; i &lt; block-&gt;numSuccessors(); ++i)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2342,11 ***</span>
          }
  
          return;
      }
  
<span class="line-modified">! #if CPU(X86) || CPU(X86_64)</span>
      Tmp eax(X86Registers::eax);
      Tmp edx(X86Registers::edx);
  
      if (isSigned) {
          B3::Air::Opcode convertToDoubleWord;
<span class="line-new-header">--- 2500,11 ---</span>
          }
  
          return;
      }
  
<span class="line-modified">! #if CPU(X86_64)</span>
      Tmp eax(X86Registers::eax);
      Tmp edx(X86Registers::edx);
  
      if (isSigned) {
          B3::Air::Opcode convertToDoubleWord;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2534,12 ***</span>
          emitPatchpoint(patchpoint, result, arg);
          return { };
      }
  #endif
  
<span class="line-modified">!     uint32_t (*popcount)(int32_t) = [] (int32_t value) -&gt; uint32_t { return __builtin_popcount(value); };</span>
<span class="line-removed">-     emitCCall(popcount, result, arg);</span>
      return { };
  }
  
  template&lt;&gt;
  auto AirIRGenerator::addOp&lt;OpType::I64Popcnt&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
<span class="line-new-header">--- 2692,11 ---</span>
          emitPatchpoint(patchpoint, result, arg);
          return { };
      }
  #endif
  
<span class="line-modified">!     emitCCall(&amp;operationPopcount32, result, arg);</span>
      return { };
  }
  
  template&lt;&gt;
  auto AirIRGenerator::addOp&lt;OpType::I64Popcnt&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2556,12 ***</span>
          emitPatchpoint(patchpoint, result, arg);
          return { };
      }
  #endif
  
<span class="line-modified">!     uint64_t (*popcount)(int64_t) = [] (int64_t value) -&gt; uint64_t { return __builtin_popcountll(value); };</span>
<span class="line-removed">-     emitCCall(popcount, result, arg);</span>
      return { };
  }
  
  template&lt;&gt;
  auto AirIRGenerator::addOp&lt;F64ConvertUI64&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
<span class="line-new-header">--- 2713,11 ---</span>
          emitPatchpoint(patchpoint, result, arg);
          return { };
      }
  #endif
  
<span class="line-modified">!     emitCCall(&amp;operationPopcount64, result, arg);</span>
      return { };
  }
  
  template&lt;&gt;
  auto AirIRGenerator::addOp&lt;F64ConvertUI64&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2841,11 ***</span>
          }
          jit.truncateDoubleToUint64(params[1].fpr(), params[0].gpr(), scratch, constant);
      });
  
      result = g64();
<span class="line-modified">!     emitPatchpoint(m_currentBlock, patchpoint, result, WTFMove(args));</span>
      return { };
  }
  
  template&lt;&gt;
  auto AirIRGenerator::addOp&lt;OpType::I64TruncSF32&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
<span class="line-new-header">--- 2997,11 ---</span>
          }
          jit.truncateDoubleToUint64(params[1].fpr(), params[0].gpr(), scratch, constant);
      });
  
      result = g64();
<span class="line-modified">!     emitPatchpoint(m_currentBlock, patchpoint, Vector&lt;TypedTmp, 8&gt; { result }, WTFMove(args));</span>
      return { };
  }
  
  template&lt;&gt;
  auto AirIRGenerator::addOp&lt;OpType::I64TruncSF32&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2898,11 ***</span>
          signBitConstant = addConstant(Type::F32, bitwise_cast&lt;uint32_t&gt;(static_cast&lt;float&gt;(std::numeric_limits&lt;uint64_t&gt;::max() - std::numeric_limits&lt;int64_t&gt;::max())));
  
      auto* patchpoint = addPatchpoint(B3::Int64);
      patchpoint-&gt;effects = B3::Effects::none();
      patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">!     Vector&lt;ConstrainedTmp&gt; args;</span>
      args.append(arg);
      if (isX86()) {
          args.append(signBitConstant);
          patchpoint-&gt;numFPScratchRegisters = 1;
      }
<span class="line-new-header">--- 3054,11 ---</span>
          signBitConstant = addConstant(Type::F32, bitwise_cast&lt;uint32_t&gt;(static_cast&lt;float&gt;(std::numeric_limits&lt;uint64_t&gt;::max() - std::numeric_limits&lt;int64_t&gt;::max())));
  
      auto* patchpoint = addPatchpoint(B3::Int64);
      patchpoint-&gt;effects = B3::Effects::none();
      patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-modified">!     Vector&lt;ConstrainedTmp, 2&gt; args;</span>
      args.append(arg);
      if (isX86()) {
          args.append(signBitConstant);
          patchpoint-&gt;numFPScratchRegisters = 1;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2916,11 ***</span>
          }
          jit.truncateFloatToUint64(params[1].fpr(), params[0].gpr(), scratch, constant);
      });
  
      result = g64();
<span class="line-modified">!     emitPatchpoint(m_currentBlock, patchpoint, result, WTFMove(args));</span>
  
      return { };
  }
  
  auto AirIRGenerator::addShift(Type type, B3::Air::Opcode op, ExpressionType value, ExpressionType shift, ExpressionType&amp; result) -&gt; PartialResult
<span class="line-new-header">--- 3072,11 ---</span>
          }
          jit.truncateFloatToUint64(params[1].fpr(), params[0].gpr(), scratch, constant);
      });
  
      result = g64();
<span class="line-modified">!     emitPatchpoint(m_currentBlock, patchpoint, Vector&lt;TypedTmp, 8&gt; { result }, WTFMove(args));</span>
  
      return { };
  }
  
  auto AirIRGenerator::addShift(Type type, B3::Air::Opcode op, ExpressionType value, ExpressionType shift, ExpressionType&amp; result) -&gt; PartialResult
</pre>
<center><a href="../tools/VMInspector.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmAirIRGenerator.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AbstractModuleRecord.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AbstractModuleRecord.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AbstractModuleRecord.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AbstractModuleRecord.cpp
@@ -37,34 +37,28 @@
 #include "WebAssemblyModuleRecord.h"
 #include <wtf/Optional.h>
 
 namespace JSC {
 namespace AbstractModuleRecordInternal {
-static const bool verbose = false;
+static constexpr bool verbose = false;
 } // namespace AbstractModuleRecordInternal
 
 const ClassInfo AbstractModuleRecord::s_info = { "AbstractModuleRecord", &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(AbstractModuleRecord) };
 
 AbstractModuleRecord::AbstractModuleRecord(VM& vm, Structure* structure, const Identifier& moduleKey)
     : Base(vm, structure)
     , m_moduleKey(moduleKey)
 {
 }
 
-void AbstractModuleRecord::destroy(JSCell* cell)
-{
-    AbstractModuleRecord* thisObject = static_cast<AbstractModuleRecord*>(cell);
-    thisObject->AbstractModuleRecord::~AbstractModuleRecord();
-}
-
-void AbstractModuleRecord::finishCreation(ExecState* exec, VM& vm)
+void AbstractModuleRecord::finishCreation(JSGlobalObject* globalObject, VM& vm)
 {
     Base::finishCreation(vm);
     ASSERT(inherits(vm, info()));
 
     auto scope = DECLARE_THROW_SCOPE(vm);
-    JSMap* map = JSMap::create(exec, vm, globalObject(vm)->mapStructure());
+    JSMap* map = JSMap::create(globalObject, vm, globalObject->mapStructure());
     scope.releaseAssertNoException();
     m_dependenciesMap.set(vm, this, map);
     putDirect(vm, Identifier::fromString(vm, "dependenciesMap"_s), m_dependenciesMap.get());
 }
 
@@ -139,43 +133,43 @@
 auto AbstractModuleRecord::Resolution::ambiguous() -> Resolution
 {
     return Resolution { Type::Ambiguous, nullptr, Identifier() };
 }
 
-AbstractModuleRecord* AbstractModuleRecord::hostResolveImportedModule(ExecState* exec, const Identifier& moduleName)
+AbstractModuleRecord* AbstractModuleRecord::hostResolveImportedModule(JSGlobalObject* globalObject, const Identifier& moduleName)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     JSValue moduleNameValue = identifierToJSValue(vm, moduleName);
-    JSValue entry = m_dependenciesMap->JSMap::get(exec, moduleNameValue);
+    JSValue entry = m_dependenciesMap->JSMap::get(globalObject, moduleNameValue);
     RETURN_IF_EXCEPTION(scope, nullptr);
-    RELEASE_AND_RETURN(scope, jsCast<AbstractModuleRecord*>(entry.get(exec, Identifier::fromString(vm, "module"))));
+    RELEASE_AND_RETURN(scope, jsCast<AbstractModuleRecord*>(entry.get(globalObject, Identifier::fromString(vm, "module"))));
 }
 
-auto AbstractModuleRecord::resolveImport(ExecState* exec, const Identifier& localName) -> Resolution
+auto AbstractModuleRecord::resolveImport(JSGlobalObject* globalObject, const Identifier& localName) -> Resolution
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     Optional<ImportEntry> optionalImportEntry = tryGetImportEntry(localName.impl());
     if (!optionalImportEntry)
         return Resolution::notFound();
 
     const ImportEntry& importEntry = *optionalImportEntry;
     if (importEntry.type == AbstractModuleRecord::ImportEntryType::Namespace)
         return Resolution::notFound();
 
-    AbstractModuleRecord* importedModule = hostResolveImportedModule(exec, importEntry.moduleRequest);
+    AbstractModuleRecord* importedModule = hostResolveImportedModule(globalObject, importEntry.moduleRequest);
     RETURN_IF_EXCEPTION(scope, Resolution::error());
-    return importedModule->resolveExport(exec, importEntry.importName);
+    return importedModule->resolveExport(globalObject, importEntry.importName);
 }
 
 struct AbstractModuleRecord::ResolveQuery {
     struct Hash {
         static unsigned hash(const ResolveQuery&);
         static bool equal(const ResolveQuery&, const ResolveQuery&);
-        static const bool safeToCompareToEmptyOrDeleted = true;
+        static constexpr bool safeToCompareToEmptyOrDeleted = true;
     };
     using HashTraits = WTF::CustomHashTraits<ResolveQuery>;
 
     ResolveQuery(AbstractModuleRecord* moduleRecord, UniquedStringImpl* exportName)
         : moduleRecord(moduleRecord)
@@ -246,13 +240,13 @@
 void AbstractModuleRecord::cacheResolution(UniquedStringImpl* exportName, const Resolution& resolution)
 {
     m_resolutionCache.add(exportName, resolution);
 }
 
-auto AbstractModuleRecord::resolveExportImpl(ExecState* exec, const ResolveQuery& root) -> Resolution
+auto AbstractModuleRecord::resolveExportImpl(JSGlobalObject* globalObject, const ResolveQuery& root) -> Resolution
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (AbstractModuleRecordInternal::verbose)
         dataLog("Resolving ", root, "\n");
 
@@ -525,11 +519,11 @@
     auto resolveNonLocal = [&](const ResolveQuery& query) -> bool {
         // https://tc39.github.io/ecma262/#sec-resolveexport
         // section 15.2.1.16.3, step 6
         // If the "default" name is not resolved in the current module, we need to throw an error and stop resolution immediately,
         // Rationale to this error: A default export cannot be provided by an export *.
-        VM& vm = exec->vm();
+        VM& vm = globalObject->vm();
         auto scope = DECLARE_THROW_SCOPE(vm);
         if (query.exportName == vm.propertyNames->defaultKeyword.impl())
             return false;
 
         // Enqueue the task to gather the results of the stars.
@@ -539,11 +533,11 @@
         frames.append(Resolution::notFound());
 
         // Enqueue the tasks in reverse order.
         for (auto iterator = query.moduleRecord->starExportEntries().rbegin(), end = query.moduleRecord->starExportEntries().rend(); iterator != end; ++iterator) {
             const RefPtr<UniquedStringImpl>& starModuleName = *iterator;
-            AbstractModuleRecord* importedModuleRecord = query.moduleRecord->hostResolveImportedModule(exec, Identifier::fromUid(vm, starModuleName.get()));
+            AbstractModuleRecord* importedModuleRecord = query.moduleRecord->hostResolveImportedModule(globalObject, Identifier::fromUid(vm, starModuleName.get()));
             RETURN_IF_EXCEPTION(scope, false);
             pendingTasks.append(Task { ResolveQuery(importedModuleRecord, query.exportName.get()), Type::Query });
         }
         return true;
     };
@@ -626,11 +620,11 @@
                     return Resolution::ambiguous();
                 continue;
             }
 
             case ExportEntry::Type::Indirect: {
-                AbstractModuleRecord* importedModuleRecord = moduleRecord->hostResolveImportedModule(exec, exportEntry.moduleName);
+                AbstractModuleRecord* importedModuleRecord = moduleRecord->hostResolveImportedModule(globalObject, exportEntry.moduleName);
                 RETURN_IF_EXCEPTION(scope, Resolution::error());
 
                 // When the imported module does not produce any resolved binding, we need to look into the stars in the *current*
                 // module. To do this, we append the `IndirectFallback` task to the task queue.
                 pendingTasks.append(Task { query, Type::IndirectFallback });
@@ -687,21 +681,21 @@
     if (frames[0].type == Resolution::Type::Resolved)
         cacheResolutionForQuery(root, frames[0]);
     return frames[0];
 }
 
-auto AbstractModuleRecord::resolveExport(ExecState* exec, const Identifier& exportName) -> Resolution
+auto AbstractModuleRecord::resolveExport(JSGlobalObject* globalObject, const Identifier& exportName) -> Resolution
 {
     // Look up the cached resolution first before entering the resolving loop, since the loop setup takes some cost.
     if (Optional<Resolution> cachedResolution = tryGetCachedResolution(exportName.impl()))
         return *cachedResolution;
-    return resolveExportImpl(exec, ResolveQuery(this, exportName.impl()));
+    return resolveExportImpl(globalObject, ResolveQuery(this, exportName.impl()));
 }
 
-static void getExportedNames(ExecState* exec, AbstractModuleRecord* root, IdentifierSet& exportedNames)
+static void getExportedNames(JSGlobalObject* globalObject, AbstractModuleRecord* root, IdentifierSet& exportedNames)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     HashSet<AbstractModuleRecord*> exportStarSet;
     Vector<AbstractModuleRecord*, 8> pendingModules;
 
@@ -718,43 +712,42 @@
             if (moduleRecord == root || vm.propertyNames->defaultKeyword != exportEntry.exportName)
                 exportedNames.add(exportEntry.exportName.impl());
         }
 
         for (const auto& starModuleName : moduleRecord->starExportEntries()) {
-            AbstractModuleRecord* requestedModuleRecord = moduleRecord->hostResolveImportedModule(exec, Identifier::fromUid(vm, starModuleName.get()));
+            AbstractModuleRecord* requestedModuleRecord = moduleRecord->hostResolveImportedModule(globalObject, Identifier::fromUid(vm, starModuleName.get()));
             RETURN_IF_EXCEPTION(scope, void());
             pendingModules.append(requestedModuleRecord);
         }
     }
 }
 
-JSModuleNamespaceObject* AbstractModuleRecord::getModuleNamespace(ExecState* exec)
+JSModuleNamespaceObject* AbstractModuleRecord::getModuleNamespace(JSGlobalObject* globalObject)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // http://www.ecma-international.org/ecma-262/6.0/#sec-getmodulenamespace
     if (m_moduleNamespaceObject)
         return m_moduleNamespaceObject.get();
 
-    JSGlobalObject* globalObject = exec->lexicalGlobalObject();
     IdentifierSet exportedNames;
-    getExportedNames(exec, this, exportedNames);
+    getExportedNames(globalObject, this, exportedNames);
     RETURN_IF_EXCEPTION(scope, nullptr);
 
     Vector<std::pair<Identifier, Resolution>> resolutions;
     for (auto& name : exportedNames) {
         Identifier ident = Identifier::fromUid(vm, name.get());
-        const Resolution resolution = resolveExport(exec, ident);
+        const Resolution resolution = resolveExport(globalObject, ident);
         RETURN_IF_EXCEPTION(scope, nullptr);
         switch (resolution.type) {
         case Resolution::Type::NotFound:
-            throwSyntaxError(exec, scope, makeString("Exported binding name '", String(name.get()), "' is not found."));
+            throwSyntaxError(globalObject, scope, makeString("Exported binding name '", String(name.get()), "' is not found."));
             return nullptr;
 
         case Resolution::Type::Error:
-            throwSyntaxError(exec, scope, makeString("Exported binding name 'default' cannot be resolved by star export entries."));
+            throwSyntaxError(globalObject, scope, makeString("Exported binding name 'default' cannot be resolved by star export entries."));
             return nullptr;
 
         case Resolution::Type::Ambiguous:
             break;
 
@@ -762,36 +755,36 @@
             resolutions.append({ WTFMove(ident), resolution });
             break;
         }
     }
 
-    auto* moduleNamespaceObject = JSModuleNamespaceObject::create(exec, globalObject, globalObject->moduleNamespaceObjectStructure(), this, WTFMove(resolutions));
+    auto* moduleNamespaceObject = JSModuleNamespaceObject::create(globalObject, globalObject->moduleNamespaceObjectStructure(), this, WTFMove(resolutions));
     RETURN_IF_EXCEPTION(scope, nullptr);
     m_moduleNamespaceObject.set(vm, this, moduleNamespaceObject);
     return moduleNamespaceObject;
 }
 
-void AbstractModuleRecord::link(ExecState* exec, JSValue scriptFetcher)
+void AbstractModuleRecord::link(JSGlobalObject* globalObject, JSValue scriptFetcher)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     if (auto* jsModuleRecord = jsDynamicCast<JSModuleRecord*>(vm, this))
-        return jsModuleRecord->link(exec, scriptFetcher);
+        return jsModuleRecord->link(globalObject, scriptFetcher);
 #if ENABLE(WEBASSEMBLY)
     if (auto* wasmModuleRecord = jsDynamicCast<WebAssemblyModuleRecord*>(vm, this))
-        return wasmModuleRecord->link(exec, scriptFetcher, nullptr, Wasm::CreationMode::FromModuleLoader);
+        return wasmModuleRecord->link(globalObject, scriptFetcher, nullptr, Wasm::CreationMode::FromModuleLoader);
 #endif
     RELEASE_ASSERT_NOT_REACHED();
 }
 
-JS_EXPORT_PRIVATE JSValue AbstractModuleRecord::evaluate(ExecState* exec)
+JS_EXPORT_PRIVATE JSValue AbstractModuleRecord::evaluate(JSGlobalObject* globalObject)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     if (auto* jsModuleRecord = jsDynamicCast<JSModuleRecord*>(vm, this))
-        return jsModuleRecord->evaluate(exec);
+        return jsModuleRecord->evaluate(globalObject);
 #if ENABLE(WEBASSEMBLY)
     if (auto* wasmModuleRecord = jsDynamicCast<WebAssemblyModuleRecord*>(vm, this))
-        return wasmModuleRecord->evaluate(exec);
+        return wasmModuleRecord->evaluate(globalObject);
 #endif
     RELEASE_ASSERT_NOT_REACHED();
     return jsUndefined();
 }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimationElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004, 2005 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005, 2006, 2007 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
  5  * Copyright (C) 2008, 2017 Apple Inc. All rights reserved.
  6  * Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
  7  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  8  * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
  9  *
 10  * This library is free software; you can redistribute it and/or
 11  * modify it under the terms of the GNU Library General Public
 12  * License as published by the Free Software Foundation; either
 13  * version 2 of the License, or (at your option) any later version.
 14  *
 15  * This library is distributed in the hope that it will be useful,
 16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 18  * Library General Public License for more details.
 19  *
 20  * You should have received a copy of the GNU Library General Public License
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SVGAnimationElement.h&quot;
 28 
 29 #include &quot;CSSComputedStyleDeclaration.h&quot;
 30 #include &quot;CSSPropertyNames.h&quot;
 31 #include &quot;CSSPropertyParser.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;FloatConversion.h&quot;
 34 #include &quot;RenderObject.h&quot;
 35 #include &quot;SVGAnimateColorElement.h&quot;
 36 #include &quot;SVGAnimateElement.h&quot;
 37 #include &quot;SVGElement.h&quot;
 38 #include &quot;SVGNames.h&quot;
 39 #include &quot;SVGParserUtilities.h&quot;
 40 #include &quot;SVGStringList.h&quot;
 41 #include &lt;wtf/IsoMallocInlines.h&gt;
 42 #include &lt;wtf/MathExtras.h&gt;
 43 #include &lt;wtf/NeverDestroyed.h&gt;
 44 #include &lt;wtf/text/StringView.h&gt;
 45 
 46 namespace WebCore {
 47 
 48 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGAnimationElement);
 49 
 50 SVGAnimationElement::SVGAnimationElement(const QualifiedName&amp; tagName, Document&amp; document)
 51     : SVGSMILElement(tagName, document)
 52     , SVGTests(this)
 53 {
 54 }
 55 
 56 static void parseKeyTimes(const String&amp; parse, Vector&lt;float&gt;&amp; result, bool verifyOrder)
 57 {
 58     result.clear();
 59     bool isFirst = true;
 60     for (StringView timeString : StringView(parse).split(&#39;;&#39;)) {
 61         bool ok;
 62         float time = timeString.toFloat(ok);
 63         if (!ok || time &lt; 0 || time &gt; 1)
 64             goto fail;
 65         if (verifyOrder) {
 66             if (isFirst) {
 67                 if (time)
 68                     goto fail;
 69                 isFirst = false;
 70             } else if (time &lt; result.last())
 71                 goto fail;
 72         }
 73         result.append(time);
 74     }
 75     return;
 76 fail:
 77     result.clear();
 78 }
 79 
 80 static void parseKeySplines(const String&amp; parse, Vector&lt;UnitBezier&gt;&amp; result)
 81 {
 82     result.clear();
 83     if (parse.isEmpty())
 84         return;
 85 
 86     auto upconvertedCharacters = StringView(parse).upconvertedCharacters();
 87     const UChar* cur = upconvertedCharacters;
 88     const UChar* end = cur + parse.length();
 89 
 90     skipOptionalSVGSpaces(cur, end);
 91 
 92     bool delimParsed = false;
 93     while (cur &lt; end) {
 94         delimParsed = false;
 95         float posA = 0;
 96         if (!parseNumber(cur, end, posA)) {
 97             result.clear();
 98             return;
 99         }
100 
101         float posB = 0;
102         if (!parseNumber(cur, end, posB)) {
103             result.clear();
104             return;
105         }
106 
107         float posC = 0;
108         if (!parseNumber(cur, end, posC)) {
109             result.clear();
110             return;
111         }
112 
113         float posD = 0;
114         if (!parseNumber(cur, end, posD, false)) {
115             result.clear();
116             return;
117         }
118 
119         skipOptionalSVGSpaces(cur, end);
120 
121         if (cur &lt; end &amp;&amp; *cur == &#39;;&#39;) {
122             delimParsed = true;
123             cur++;
124         }
125         skipOptionalSVGSpaces(cur, end);
126 
127         result.append(UnitBezier(posA, posB, posC, posD));
128     }
129     if (!(cur == end &amp;&amp; !delimParsed))
130         result.clear();
131 }
132 
133 bool SVGAnimationElement::isSupportedAttribute(const QualifiedName&amp; attrName)
134 {
135     static const auto supportedAttributes = makeNeverDestroyed([] {
136         HashSet&lt;QualifiedName&gt; set;
137         SVGTests::addSupportedAttributes(set);
138         set.add({
139             SVGNames::valuesAttr.get(),
140             SVGNames::keyTimesAttr.get(),
141             SVGNames::keyPointsAttr.get(),
142             SVGNames::keySplinesAttr.get(),
143             SVGNames::attributeTypeAttr.get(),
144             SVGNames::calcModeAttr.get(),
145             SVGNames::fromAttr.get(),
146             SVGNames::toAttr.get(),
147             SVGNames::byAttr.get(),
148         });
149         return set;
150     }());
151     return supportedAttributes.get().contains&lt;SVGAttributeHashTranslator&gt;(attrName);
152 }
153 
154 void SVGAnimationElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
155 {
156     if (name == SVGNames::valuesAttr) {
157         // Per the SMIL specification, leading and trailing white space,
158         // and white space before and after semicolon separators, is allowed and will be ignored.
159         // http://www.w3.org/TR/SVG11/animate.html#ValuesAttribute
160         m_values = value.string().split(&#39;;&#39;);
161         for (auto&amp; value : m_values)
162             value = value.stripWhiteSpace();
163 
164         updateAnimationMode();
165         return;
166     }
167 
168     if (name == SVGNames::keyTimesAttr) {
169         parseKeyTimes(value, m_keyTimes, true);
170         return;
171     }
172 
173     if (name == SVGNames::keyPointsAttr) {
174         if (hasTagName(SVGNames::animateMotionTag)) {
175             // This is specified to be an animateMotion attribute only but it is simpler to put it here
176             // where the other timing calculatations are.
177             parseKeyTimes(value, m_keyPoints, false);
178         }
179         return;
180     }
181 
182     if (name == SVGNames::keySplinesAttr) {
183         parseKeySplines(value, m_keySplines);
184         return;
185     }
186 
187     if (name == SVGNames::attributeTypeAttr) {
188         setAttributeType(value);
189         return;
190     }
191 
192     if (name == SVGNames::calcModeAttr) {
193         setCalcMode(value);
194         return;
195     }
196 
197     if (name == SVGNames::fromAttr || name == SVGNames::toAttr || name == SVGNames::byAttr) {
198         updateAnimationMode();
199         return;
200     }
201 
202     SVGSMILElement::parseAttribute(name, value);
203     SVGTests::parseAttribute(name, value);
204 }
205 
206 void SVGAnimationElement::svgAttributeChanged(const QualifiedName&amp; attrName)
207 {
208     if (!isSupportedAttribute(attrName)) {
209         SVGSMILElement::svgAttributeChanged(attrName);
210         return;
211     }
212 
213     animationAttributeChanged();
214 }
215 
216 void SVGAnimationElement::animationAttributeChanged()
217 {
218     // Assumptions may not hold after an attribute change.
219     m_animationValid = false;
220     setInactive();
221 }
222 
223 float SVGAnimationElement::getStartTime() const
224 {
225     return narrowPrecisionToFloat(intervalBegin().value());
226 }
227 
228 float SVGAnimationElement::getCurrentTime() const
229 {
230     return narrowPrecisionToFloat(elapsed().value());
231 }
232 
233 float SVGAnimationElement::getSimpleDuration() const
234 {
235     return narrowPrecisionToFloat(simpleDuration().value());
236 }
237 
238 void SVGAnimationElement::beginElement()
239 {
240     beginElementAt(0);
241 }
242 
243 void SVGAnimationElement::beginElementAt(float offset)
244 {
245     if (std::isnan(offset))
246         return;
247     SMILTime elapsed = this-&gt;elapsed();
248     addBeginTime(elapsed, elapsed + offset, SMILTimeWithOrigin::ScriptOrigin);
249 }
250 
251 void SVGAnimationElement::endElement()
252 {
253     endElementAt(0);
254 }
255 
256 void SVGAnimationElement::endElementAt(float offset)
257 {
258     if (std::isnan(offset))
259         return;
260     SMILTime elapsed = this-&gt;elapsed();
261     addEndTime(elapsed, elapsed + offset, SMILTimeWithOrigin::ScriptOrigin);
262 }
263 
264 void SVGAnimationElement::updateAnimationMode()
265 {
266     // http://www.w3.org/TR/2001/REC-smil-animation-20010904/#AnimFuncValues
267     if (hasAttribute(SVGNames::valuesAttr))
268         setAnimationMode(AnimationMode::Values);
269     else if (!toValue().isEmpty())
270         setAnimationMode(fromValue().isEmpty() ? AnimationMode::To : AnimationMode::FromTo);
271     else if (!byValue().isEmpty())
272         setAnimationMode(fromValue().isEmpty() ? AnimationMode::By : AnimationMode::FromBy);
273     else
274         setAnimationMode(AnimationMode::None);
275 }
276 
277 void SVGAnimationElement::setCalcMode(const AtomString&amp; calcMode)
278 {
279     static NeverDestroyed&lt;const AtomString&gt; discrete(&quot;discrete&quot;, AtomString::ConstructFromLiteral);
280     static NeverDestroyed&lt;const AtomString&gt; linear(&quot;linear&quot;, AtomString::ConstructFromLiteral);
281     static NeverDestroyed&lt;const AtomString&gt; paced(&quot;paced&quot;, AtomString::ConstructFromLiteral);
282     static NeverDestroyed&lt;const AtomString&gt; spline(&quot;spline&quot;, AtomString::ConstructFromLiteral);
283     if (calcMode == discrete)
284         setCalcMode(CalcMode::Discrete);
285     else if (calcMode == linear)
286         setCalcMode(CalcMode::Linear);
287     else if (calcMode == paced)
288         setCalcMode(CalcMode::Paced);
289     else if (calcMode == spline)
290         setCalcMode(CalcMode::Spline);
291     else
292         setCalcMode(hasTagName(SVGNames::animateMotionTag) ? CalcMode::Paced : CalcMode::Linear);
293 }
294 
295 void SVGAnimationElement::setAttributeType(const AtomString&amp; attributeType)
296 {
297     static NeverDestroyed&lt;const AtomString&gt; css(&quot;CSS&quot;, AtomString::ConstructFromLiteral);
298     static NeverDestroyed&lt;const AtomString&gt; xml(&quot;XML&quot;, AtomString::ConstructFromLiteral);
299     if (attributeType == css)
300         m_attributeType = AttributeType::CSS;
301     else if (attributeType == xml)
302         m_attributeType = AttributeType::XML;
303     else
304         m_attributeType = AttributeType::Auto;
305 }
306 
307 String SVGAnimationElement::toValue() const
308 {
309     return attributeWithoutSynchronization(SVGNames::toAttr);
310 }
311 
312 String SVGAnimationElement::byValue() const
313 {
314     return attributeWithoutSynchronization(SVGNames::byAttr);
315 }
316 
317 String SVGAnimationElement::fromValue() const
318 {
319     return attributeWithoutSynchronization(SVGNames::fromAttr);
320 }
321 
322 bool SVGAnimationElement::isAdditive() const
323 {
324     static NeverDestroyed&lt;const AtomString&gt; sum(&quot;sum&quot;, AtomString::ConstructFromLiteral);
325     const AtomString&amp; value = attributeWithoutSynchronization(SVGNames::additiveAttr);
326     return value == sum || animationMode() == AnimationMode::By;
327 }
328 
329 bool SVGAnimationElement::isAccumulated() const
330 {
331     static NeverDestroyed&lt;const AtomString&gt; sum(&quot;sum&quot;, AtomString::ConstructFromLiteral);
332     const AtomString&amp; value = attributeWithoutSynchronization(SVGNames::accumulateAttr);
333     return value == sum &amp;&amp; animationMode() != AnimationMode::To;
334 }
335 
336 bool SVGAnimationElement::isTargetAttributeCSSProperty(SVGElement* targetElement, const QualifiedName&amp; attributeName)
337 {
338     return targetElement-&gt;isAnimatedStyleAttribute(attributeName);
339 }
340 
341 void SVGAnimationElement::calculateKeyTimesForCalcModePaced()
342 {
343     ASSERT(calcMode() == CalcMode::Paced);
344     ASSERT(animationMode() == AnimationMode::Values);
345 
346     unsigned valuesCount = m_values.size();
347     ASSERT(valuesCount &gt;= 1);
348     if (valuesCount == 1)
349         return;
350 
351     // FIXME, webkit.org/b/109010: m_keyTimes should not be modified in this function.
352     m_keyTimes.clear();
353 
354     Vector&lt;float&gt; keyTimesForPaced;
355     float totalDistance = 0;
356     keyTimesForPaced.append(0);
357     for (unsigned n = 0; n &lt; valuesCount - 1; ++n) {
358         // Distance in any units
359         auto distance = calculateDistance(m_values[n], m_values[n + 1]);
360         if (!distance)
361             return;
362         totalDistance += *distance;
363         keyTimesForPaced.append(*distance);
364     }
365     if (!totalDistance)
366         return;
367 
368     // Normalize.
369     for (unsigned n = 1; n &lt; keyTimesForPaced.size() - 1; ++n)
370         keyTimesForPaced[n] = keyTimesForPaced[n - 1] + keyTimesForPaced[n] / totalDistance;
371     keyTimesForPaced[keyTimesForPaced.size() - 1] = 1;
372 
373     // Use key times calculated based on pacing instead of the user provided ones.
374     m_keyTimes = keyTimesForPaced;
375 }
376 
377 static inline double solveEpsilon(double duration) { return 1 / (200 * duration); }
378 
379 unsigned SVGAnimationElement::calculateKeyTimesIndex(float percent) const
380 {
381     unsigned index;
382     unsigned keyTimesCount = m_keyTimes.size();
383     // Compare index + 1 to keyTimesCount because the last keyTimes entry is
384     // required to be 1, and percent can never exceed 1; i.e., the second last
385     // keyTimes entry defines the beginning of the final interval
386     for (index = 1; index + 1 &lt; keyTimesCount; ++index) {
387         if (m_keyTimes[index] &gt; percent)
388             break;
389     }
390     return --index;
391 }
392 
393 float SVGAnimationElement::calculatePercentForSpline(float percent, unsigned splineIndex) const
394 {
395     ASSERT(calcMode() == CalcMode::Spline);
396     ASSERT_WITH_SECURITY_IMPLICATION(splineIndex &lt; m_keySplines.size());
397     UnitBezier bezier = m_keySplines[splineIndex];
398     SMILTime duration = simpleDuration();
399     if (!duration.isFinite())
400         duration = 100.0;
401     return narrowPrecisionToFloat(bezier.solve(percent, solveEpsilon(duration.value())));
402 }
403 
404 float SVGAnimationElement::calculatePercentFromKeyPoints(float percent) const
405 {
406     ASSERT(!m_keyPoints.isEmpty());
407     ASSERT(calcMode() != CalcMode::Paced);
408     ASSERT(m_keyTimes.size() &gt; 1);
409     ASSERT(m_keyPoints.size() == m_keyTimes.size());
410 
411     if (percent == 1)
412         return m_keyPoints[m_keyPoints.size() - 1];
413 
414     unsigned index = calculateKeyTimesIndex(percent);
415     float fromPercent = m_keyTimes[index];
416     float toPercent = m_keyTimes[index + 1];
417     float fromKeyPoint = m_keyPoints[index];
418     float toKeyPoint = m_keyPoints[index + 1];
419 
420     if (calcMode() == CalcMode::Discrete)
421         return fromKeyPoint;
422 
423     float keyPointPercent = (percent - fromPercent) / (toPercent - fromPercent);
424 
425     if (calcMode() == CalcMode::Spline) {
426         ASSERT(m_keySplines.size() == m_keyPoints.size() - 1);
427         keyPointPercent = calculatePercentForSpline(keyPointPercent, index);
428     }
429     return (toKeyPoint - fromKeyPoint) * keyPointPercent + fromKeyPoint;
430 }
431 
432 float SVGAnimationElement::calculatePercentForFromTo(float percent) const
433 {
434     if (calcMode() == CalcMode::Discrete &amp;&amp; m_keyTimes.size() == 2)
435         return percent &gt; m_keyTimes[1] ? 1 : 0;
436 
437     return percent;
438 }
439 
440 void SVGAnimationElement::currentValuesFromKeyPoints(float percent, float&amp; effectivePercent, String&amp; from, String&amp; to) const
441 {
442     ASSERT(!m_keyPoints.isEmpty());
443     ASSERT(m_keyPoints.size() == m_keyTimes.size());
444     ASSERT(calcMode() != CalcMode::Paced);
445     effectivePercent = calculatePercentFromKeyPoints(percent);
446     unsigned index = effectivePercent == 1 ? m_values.size() - 2 : static_cast&lt;unsigned&gt;(effectivePercent * (m_values.size() - 1));
447     from = m_values[index];
448     to = m_values[index + 1];
449 }
450 
451 void SVGAnimationElement::currentValuesForValuesAnimation(float percent, float&amp; effectivePercent, String&amp; from, String&amp; to)
452 {
453     unsigned valuesCount = m_values.size();
454     ASSERT(m_animationValid);
455     ASSERT(valuesCount &gt;= 1);
456 
457     if (percent == 1 || valuesCount == 1) {
458         from = m_values[valuesCount - 1];
459         to = m_values[valuesCount - 1];
460         effectivePercent = 1;
461         return;
462     }
463 
464     CalcMode calcMode = this-&gt;calcMode();
465     if (is&lt;SVGAnimateElement&gt;(*this) || is&lt;SVGAnimateColorElement&gt;(*this)) {
466         ASSERT(targetElement());
467         if (downcast&lt;SVGAnimateElementBase&gt;(*this).isDiscreteAnimator())
468             calcMode = CalcMode::Discrete;
469     }
470     if (!m_keyPoints.isEmpty() &amp;&amp; calcMode != CalcMode::Paced)
471         return currentValuesFromKeyPoints(percent, effectivePercent, from, to);
472 
473     unsigned keyTimesCount = m_keyTimes.size();
474     ASSERT(!keyTimesCount || valuesCount == keyTimesCount);
475     ASSERT(!keyTimesCount || (keyTimesCount &gt; 1 &amp;&amp; !m_keyTimes[0]));
476 
477     unsigned index = calculateKeyTimesIndex(percent);
478     if (calcMode == CalcMode::Discrete) {
479         if (!keyTimesCount)
480             index = static_cast&lt;unsigned&gt;(percent * valuesCount);
481         from = m_values[index];
482         to = m_values[index];
483         effectivePercent = 0;
484         return;
485     }
486 
487     float fromPercent;
488     float toPercent;
489     if (keyTimesCount) {
490         fromPercent = m_keyTimes[index];
491         toPercent = m_keyTimes[index + 1];
492     } else {
493         index = static_cast&lt;unsigned&gt;(floorf(percent * (valuesCount - 1)));
494         fromPercent =  static_cast&lt;float&gt;(index) / (valuesCount - 1);
495         toPercent =  static_cast&lt;float&gt;(index + 1) / (valuesCount - 1);
496     }
497 
498     if (index == valuesCount - 1)
499         --index;
500     from = m_values[index];
501     to = m_values[index + 1];
502     ASSERT_WITH_SECURITY_IMPLICATION(toPercent &gt; fromPercent);
503     effectivePercent = (percent - fromPercent) / (toPercent - fromPercent);
504 
505     if (calcMode == CalcMode::Spline) {
506         ASSERT(m_keySplines.size() == m_values.size() - 1);
507         effectivePercent = calculatePercentForSpline(effectivePercent, index);
508     }
509 }
510 
511 void SVGAnimationElement::startedActiveInterval()
512 {
513     m_animationValid = false;
514 
515     if (!hasValidAttributeType())
516         return;
517 
518     // These validations are appropriate for all animation modes.
519     if (hasAttributeWithoutSynchronization(SVGNames::keyPointsAttr) &amp;&amp; m_keyPoints.size() != m_keyTimes.size())
520         return;
521 
522     AnimationMode animationMode = this-&gt;animationMode();
523     CalcMode calcMode = this-&gt;calcMode();
524     if (calcMode == CalcMode::Spline) {
525         unsigned splinesCount = m_keySplines.size();
526         if (!splinesCount
527             || (hasAttributeWithoutSynchronization(SVGNames::keyPointsAttr) &amp;&amp; m_keyPoints.size() - 1 != splinesCount)
528             || (animationMode == AnimationMode::Values &amp;&amp; m_values.size() - 1 != splinesCount)
529             || (hasAttributeWithoutSynchronization(SVGNames::keyTimesAttr) &amp;&amp; m_keyTimes.size() - 1 != splinesCount))
530             return;
531     }
532 
533     String from = fromValue();
534     String to = toValue();
535     String by = byValue();
536     if (animationMode == AnimationMode::None)
537         return;
538     if ((animationMode == AnimationMode::FromTo || animationMode == AnimationMode::FromBy || animationMode == AnimationMode::To || animationMode == AnimationMode::By)
539         &amp;&amp; (hasAttributeWithoutSynchronization(SVGNames::keyPointsAttr) &amp;&amp; hasAttributeWithoutSynchronization(SVGNames::keyTimesAttr) &amp;&amp; (m_keyTimes.size() &lt; 2 || m_keyTimes.size() != m_keyPoints.size())))
540         return;
541     if (animationMode == AnimationMode::FromTo)
542         m_animationValid = calculateFromAndToValues(from, to);
543     else if (animationMode == AnimationMode::To) {
544         // For to-animations the from value is the current accumulated value from lower priority animations.
545         // The value is not static and is determined during the animation.
546         m_animationValid = calculateFromAndToValues(emptyString(), to);
547     } else if (animationMode == AnimationMode::FromBy)
548         m_animationValid = calculateFromAndByValues(from, by);
549     else if (animationMode == AnimationMode::By)
550         m_animationValid = calculateFromAndByValues(emptyString(), by);
551     else if (animationMode == AnimationMode::Values) {
552         m_animationValid = m_values.size() &gt;= 1
553             &amp;&amp; (calcMode == CalcMode::Paced || !hasAttributeWithoutSynchronization(SVGNames::keyTimesAttr) || hasAttributeWithoutSynchronization(SVGNames::keyPointsAttr) || (m_values.size() == m_keyTimes.size()))
554             &amp;&amp; (calcMode == CalcMode::Discrete || !m_keyTimes.size() || m_keyTimes.last() == 1)
555             &amp;&amp; (calcMode != CalcMode::Spline || ((m_keySplines.size() &amp;&amp; (m_keySplines.size() == m_values.size() - 1)) || m_keySplines.size() == m_keyPoints.size() - 1))
556             &amp;&amp; (!hasAttributeWithoutSynchronization(SVGNames::keyPointsAttr) || (m_keyTimes.size() &gt; 1 &amp;&amp; m_keyTimes.size() == m_keyPoints.size()));
557         if (m_animationValid)
558             m_animationValid = calculateToAtEndOfDurationValue(m_values.last());
559         if (calcMode == CalcMode::Paced &amp;&amp; m_animationValid)
560             calculateKeyTimesForCalcModePaced();
561     } else if (animationMode == AnimationMode::Path)
562         m_animationValid = calcMode == CalcMode::Paced || !hasAttributeWithoutSynchronization(SVGNames::keyPointsAttr) || (m_keyTimes.size() &gt; 1 &amp;&amp; m_keyTimes.size() == m_keyPoints.size());
563 }
564 
565 void SVGAnimationElement::updateAnimation(float percent, unsigned repeatCount)
566 {
567     if (!m_animationValid)
568         return;
569 
570     float effectivePercent;
571     CalcMode calcMode = this-&gt;calcMode();
572     AnimationMode animationMode = this-&gt;animationMode();
573     if (animationMode == AnimationMode::Values) {
574         String from;
575         String to;
576         currentValuesForValuesAnimation(percent, effectivePercent, from, to);
577         if (from != m_lastValuesAnimationFrom || to != m_lastValuesAnimationTo) {
578             m_animationValid = calculateFromAndToValues(from, to);
579             if (!m_animationValid)
580                 return;
581             m_lastValuesAnimationFrom = from;
582             m_lastValuesAnimationTo = to;
583         }
584     } else if (!m_keyPoints.isEmpty() &amp;&amp; calcMode != CalcMode::Paced)
585         effectivePercent = calculatePercentFromKeyPoints(percent);
586     else if (m_keyPoints.isEmpty() &amp;&amp; calcMode == CalcMode::Spline &amp;&amp; m_keyTimes.size() &gt; 1)
587         effectivePercent = calculatePercentForSpline(percent, calculateKeyTimesIndex(percent));
588     else if (animationMode == AnimationMode::FromTo || animationMode == AnimationMode::To)
589         effectivePercent = calculatePercentForFromTo(percent);
590     else
591         effectivePercent = percent;
592 
593     calculateAnimatedValue(effectivePercent, repeatCount);
594 }
595 
596 void SVGAnimationElement::computeCSSPropertyValue(SVGElement* element, CSSPropertyID id, String&amp; valueString)
597 {
598     ASSERT(element);
599 
600     // Don&#39;t include any properties resulting from CSS Transitions/Animations or SMIL animations, as we want to retrieve the &quot;base value&quot;.
601     element-&gt;setUseOverrideComputedStyle(true);
602     RefPtr&lt;CSSValue&gt; value = ComputedStyleExtractor(element).propertyValue(id);
603     valueString = value ? value-&gt;cssText() : String();
604     element-&gt;setUseOverrideComputedStyle(false);
605 }
606 
607 static bool inheritsFromProperty(SVGElement* targetElement, const QualifiedName&amp; attributeName, const String&amp; value)
608 {
609     static NeverDestroyed&lt;const AtomString&gt; inherit(&quot;inherit&quot;, AtomString::ConstructFromLiteral);
610 
611     if (value.isEmpty() || value != inherit)
612         return false;
613     return targetElement-&gt;isAnimatedStyleAttribute(attributeName);
614 }
615 
616 void SVGAnimationElement::determinePropertyValueTypes(const String&amp; from, const String&amp; to)
617 {
618     auto targetElement = makeRefPtr(this-&gt;targetElement());
619     ASSERT(targetElement);
620 
621     const QualifiedName&amp; attributeName = this-&gt;attributeName();
622     if (inheritsFromProperty(targetElement.get(), attributeName, from))
623         m_fromPropertyValueType = InheritValue;
624     if (inheritsFromProperty(targetElement.get(), attributeName, to))
625         m_toPropertyValueType = InheritValue;
626 }
627 void SVGAnimationElement::resetAnimation()
628 {
629     m_lastValuesAnimationFrom = String();
630     m_lastValuesAnimationTo = String();
631 }
632 
633 }
    </pre>
  </body>
</html>
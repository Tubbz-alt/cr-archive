diff a/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGLengthContext.cpp b/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGLengthContext.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGLengthContext.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGLengthContext.cpp
@@ -1,9 +1,9 @@
 /*
  * Copyright (C) 2004, 2005, 2006 Nikolas Zimmermann <zimmermann@kde.org>
  * Copyright (C) 2004, 2005, 2006, 2007 Rob Buis <buis@kde.org>
- * Copyright (C) 2007 Apple Inc. All rights reserved.
+ * Copyright (C) 2007-2019 Apple Inc. All rights reserved.
  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
  * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -30,10 +30,11 @@
 #include "LengthFunctions.h"
 #include "RenderSVGRoot.h"
 #include "RenderSVGViewportContainer.h"
 #include "RenderView.h"
 #include "SVGSVGElement.h"
+#include <wtf/MathExtras.h>
 
 namespace WebCore {
 
 SVGLengthContext::SVGLengthContext(const SVGElement* context)
     : m_context(context)
@@ -83,137 +84,137 @@
 
     // FIXME: valueAsPercentage() won't be correct for eg. cm units. They need to be resolved in user space and then be considered in objectBoundingBox space.
     return x.valueAsPercentage();
 }
 
-float SVGLengthContext::valueForLength(const Length& length, SVGLengthMode mode)
+float SVGLengthContext::valueForLength(const Length& length, SVGLengthMode lengthMode)
 {
     if (length.isPercent()) {
-        auto result = convertValueFromPercentageToUserUnits(length.value() / 100, mode);
+        auto result = convertValueFromPercentageToUserUnits(length.value() / 100, lengthMode);
         if (result.hasException())
             return 0;
         return result.releaseReturnValue();
     }
     if (length.isAuto() || !length.isSpecified())
         return 0;
 
     FloatSize viewportSize;
     determineViewport(viewportSize);
 
-    switch (mode) {
-    case LengthModeWidth:
+    switch (lengthMode) {
+    case SVGLengthMode::Width:
         return floatValueForLength(length, viewportSize.width());
-    case LengthModeHeight:
+    case SVGLengthMode::Height:
         return floatValueForLength(length, viewportSize.height());
-    case LengthModeOther:
-        return floatValueForLength(length, std::sqrt(viewportSize.diagonalLengthSquared() / 2));
+    case SVGLengthMode::Other:
+        return floatValueForLength(length, viewportSize.diagonalLength() / sqrtOfTwoFloat);
     };
     return 0;
 }
 
-ExceptionOr<float> SVGLengthContext::convertValueToUserUnits(float value, SVGLengthMode mode, SVGLengthType fromUnit) const
+ExceptionOr<float> SVGLengthContext::convertValueToUserUnits(float value, SVGLengthType lengthType, SVGLengthMode lengthMode) const
 {
     // If the SVGLengthContext carries a custom viewport, force resolving against it.
     if (!m_overriddenViewport.isEmpty()) {
         // 100% = 100.0 instead of 1.0 for historical reasons, this could eventually be changed
-        if (fromUnit == LengthTypePercentage)
+        if (lengthType == SVGLengthType::Percentage)
             value /= 100;
-        return convertValueFromPercentageToUserUnits(value, mode);
+        return convertValueFromPercentageToUserUnits(value, lengthMode);
     }
 
-    switch (fromUnit) {
-    case LengthTypeUnknown:
+    switch (lengthType) {
+    case SVGLengthType::Unknown:
         return Exception { NotSupportedError };
-    case LengthTypeNumber:
+    case SVGLengthType::Number:
         return value;
-    case LengthTypePX:
+    case SVGLengthType::Pixels:
         return value;
-    case LengthTypePercentage:
-        return convertValueFromPercentageToUserUnits(value / 100, mode);
-    case LengthTypeEMS:
+    case SVGLengthType::Percentage:
+        return convertValueFromPercentageToUserUnits(value / 100, lengthMode);
+    case SVGLengthType::Ems:
         return convertValueFromEMSToUserUnits(value);
-    case LengthTypeEXS:
+    case SVGLengthType::Exs:
         return convertValueFromEXSToUserUnits(value);
-    case LengthTypeCM:
+    case SVGLengthType::Centimeters:
         return value * cssPixelsPerInch / 2.54f;
-    case LengthTypeMM:
+    case SVGLengthType::Millimeters:
         return value * cssPixelsPerInch / 25.4f;
-    case LengthTypeIN:
+    case SVGLengthType::Inches:
         return value * cssPixelsPerInch;
-    case LengthTypePT:
+    case SVGLengthType::Points:
         return value * cssPixelsPerInch / 72;
-    case LengthTypePC:
+    case SVGLengthType::Picas:
         return value * cssPixelsPerInch / 6;
     }
 
     ASSERT_NOT_REACHED();
     return 0;
 }
 
-ExceptionOr<float> SVGLengthContext::convertValueFromUserUnits(float value, SVGLengthMode mode, SVGLengthType toUnit) const
+ExceptionOr<float> SVGLengthContext::convertValueFromUserUnits(float value, SVGLengthType lengthType, SVGLengthMode lengthMode) const
 {
-    switch (toUnit) {
-    case LengthTypeUnknown:
+    switch (lengthType) {
+    case SVGLengthType::Unknown:
         return Exception { NotSupportedError };
-    case LengthTypeNumber:
+    case SVGLengthType::Number:
         return value;
-    case LengthTypePercentage:
-        return convertValueFromUserUnitsToPercentage(value * 100, mode);
-    case LengthTypeEMS:
+    case SVGLengthType::Percentage:
+        return convertValueFromUserUnitsToPercentage(value * 100, lengthMode);
+    case SVGLengthType::Ems:
         return convertValueFromUserUnitsToEMS(value);
-    case LengthTypeEXS:
+    case SVGLengthType::Exs:
         return convertValueFromUserUnitsToEXS(value);
-    case LengthTypePX:
+    case SVGLengthType::Pixels:
         return value;
-    case LengthTypeCM:
+    case SVGLengthType::Centimeters:
         return value * 2.54f / cssPixelsPerInch;
-    case LengthTypeMM:
+    case SVGLengthType::Millimeters:
         return value * 25.4f / cssPixelsPerInch;
-    case LengthTypeIN:
+    case SVGLengthType::Inches:
         return value / cssPixelsPerInch;
-    case LengthTypePT:
+    case SVGLengthType::Points:
         return value * 72 / cssPixelsPerInch;
-    case LengthTypePC:
+    case SVGLengthType::Picas:
         return value * 6 / cssPixelsPerInch;
     }
 
     ASSERT_NOT_REACHED();
     return 0;
 }
 
-ExceptionOr<float> SVGLengthContext::convertValueFromUserUnitsToPercentage(float value, SVGLengthMode mode) const
+ExceptionOr<float> SVGLengthContext::convertValueFromUserUnitsToPercentage(float value, SVGLengthMode lengthMode) const
 {
     FloatSize viewportSize;
     if (!determineViewport(viewportSize))
         return Exception { NotSupportedError };
 
-    switch (mode) {
-    case LengthModeWidth:
+    switch (lengthMode) {
+    case SVGLengthMode::Width:
         return value / viewportSize.width() * 100;
-    case LengthModeHeight:
+    case SVGLengthMode::Height:
         return value / viewportSize.height() * 100;
-    case LengthModeOther:
-        return value / (std::sqrt(viewportSize.diagonalLengthSquared() / 2)) * 100;
+    case SVGLengthMode::Other:
+        return value / (viewportSize.diagonalLength() / sqrtOfTwoFloat) * 100;
     };
 
     ASSERT_NOT_REACHED();
     return 0;
 }
 
-ExceptionOr<float> SVGLengthContext::convertValueFromPercentageToUserUnits(float value, SVGLengthMode mode) const
+ExceptionOr<float> SVGLengthContext::convertValueFromPercentageToUserUnits(float value, SVGLengthMode lengthMode) const
 {
     FloatSize viewportSize;
     if (!determineViewport(viewportSize))
         return Exception { NotSupportedError };
 
-    switch (mode) {
-    case LengthModeWidth:
+    switch (lengthMode) {
+    case SVGLengthMode::Width:
         return value * viewportSize.width();
-    case LengthModeHeight:
+    case SVGLengthMode::Height:
         return value * viewportSize.height();
-    case LengthModeOther:
-        return value * std::sqrt(viewportSize.diagonalLengthSquared() / 2);
+    case SVGLengthMode::Other:
+        return value * viewportSize.diagonalLength() / sqrtOfTwoFloat;
     };
 
     ASSERT_NOT_REACHED();
     return 0;
 }

diff a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerRegistration.cpp b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerRegistration.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerRegistration.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerRegistration.cpp
@@ -26,11 +26,13 @@
 #include "config.h"
 #include "SWServerRegistration.h"
 
 #if ENABLE(SERVICE_WORKER)
 
+#include "Logging.h"
 #include "SWServer.h"
+#include "SWServerToContextConnection.h"
 #include "SWServerWorker.h"
 #include "ServiceWorkerTypes.h"
 #include "ServiceWorkerUpdateViaCache.h"
 
 namespace WebCore {
@@ -46,10 +48,11 @@
     , m_updateViaCache(updateViaCache)
     , m_scopeURL(scopeURL)
     , m_scriptURL(scriptURL)
     , m_server(server)
     , m_creationTime(MonotonicTime::now())
+    , m_softUpdateTimer { *this, &SWServerRegistration::softUpdate }
 {
     m_scopeURL.removeFragmentIdentifier();
 }
 
 SWServerRegistration::~SWServerRegistration()
@@ -257,11 +260,11 @@
         updateWorkerState(*waitingWorker, ServiceWorkerState::Redundant);
     if (activeWorker)
         updateWorkerState(*activeWorker, ServiceWorkerState::Redundant);
 
     // Remove scope to registration map[scopeString].
-    m_server.removeRegistration(key());
+    m_server.removeRegistration(identifier());
 }
 
 // https://w3c.github.io/ServiceWorker/#try-activate-algorithm
 void SWServerRegistration::tryActivate()
 {
@@ -331,15 +334,20 @@
 // https://w3c.github.io/ServiceWorker/#on-client-unload-algorithm
 void SWServerRegistration::handleClientUnload()
 {
     if (hasClientsUsingRegistration())
         return;
-    if (isUninstalling() && tryClear())
+    if (isUnregistered() && tryClear())
         return;
     tryActivate();
 }
 
+bool SWServerRegistration::isUnregistered() const
+{
+    return m_server.getRegistration(key()) != this;
+}
+
 void SWServerRegistration::controlClient(ServiceWorkerClientIdentifier identifier)
 {
     ASSERT(activeWorker());
 
     addClientUsingRegistration(identifier);
@@ -347,21 +355,32 @@
     HashSet<DocumentIdentifier> identifiers;
     identifiers.add(identifier.contextIdentifier);
     m_server.connection(identifier.serverConnectionIdentifier)->notifyClientsOfControllerChange(identifiers, activeWorker()->data());
 }
 
-void SWServerRegistration::setIsUninstalling(bool value)
+bool SWServerRegistration::shouldSoftUpdate(const FetchOptions& options) const
 {
-    if (m_uninstalling == value)
-        return;
+    if (options.mode == FetchOptions::Mode::Navigate)
+        return true;
 
-    m_uninstalling = value;
+    return WebCore::isNonSubresourceRequest(options.destination) && isStale();
+}
 
-    if (!m_uninstalling && activeWorker()) {
-        // Registration with active worker has been resurrected, we need to check if any ready promises were waiting for this.
-        m_server.resolveRegistrationReadyRequests(*this);
-    }
+void SWServerRegistration::softUpdate()
+{
+    m_server.softUpdate(*this);
+}
+
+void SWServerRegistration::scheduleSoftUpdate()
+{
+    // To avoid scheduling many updates during a single page load, we do soft updates on a 1 second delay and keep delaying
+    // as long as soft update requests keep coming. This seems to match Chrome's behavior.
+    if (m_softUpdateTimer.isActive())
+        return;
+
+    RELEASE_LOG(ServiceWorker, "SWServerRegistration::softUpdateIfNeeded");
+    m_softUpdateTimer.startOneShot(softUpdateDelay);
 }
 
 } // namespace WebCore
 
 #endif // ENABLE(SERVICE_WORKER)

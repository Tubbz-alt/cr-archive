<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/SharedBuffer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) Research In Motion Limited 2009-2010. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 30 #include &lt;wtf/FileSystem.h&gt;
 31 #include &lt;wtf/Forward.h&gt;
 32 #include &lt;wtf/RefCounted.h&gt;
 33 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 34 #include &lt;wtf/Variant.h&gt;
 35 #include &lt;wtf/Vector.h&gt;
 36 #include &lt;wtf/text/WTFString.h&gt;
 37 
 38 #if USE(CF)
 39 #include &lt;wtf/RetainPtr.h&gt;
 40 #endif
 41 
 42 #if USE(SOUP)
 43 #include &quot;GUniquePtrSoup.h&quot;
 44 #endif
 45 
 46 #if USE(GLIB)
 47 #include &lt;wtf/glib/GRefPtr.h&gt;
 48 typedef struct _GBytes GBytes;
 49 #endif
 50 
 51 #if USE(GSTREAMER)
 52 #include &quot;GStreamerCommon.h&quot;
 53 #endif
 54 
 55 #if USE(FOUNDATION)
 56 OBJC_CLASS NSArray;
 57 OBJC_CLASS NSData;
 58 #endif
 59 
<a name="2" id="anc2"></a><span class="line-added"> 60 namespace WTF {</span>
<span class="line-added"> 61 namespace Persistence {</span>
<span class="line-added"> 62 class Decoder;</span>
<span class="line-added"> 63 }</span>
<span class="line-added"> 64 }</span>
<span class="line-added"> 65 </span>
 66 namespace WebCore {
 67 
 68 class SharedBufferDataView;
 69 
 70 class WEBCORE_EXPORT SharedBuffer : public RefCounted&lt;SharedBuffer&gt; {
 71 public:
 72     static Ref&lt;SharedBuffer&gt; create() { return adoptRef(*new SharedBuffer); }
 73     static Ref&lt;SharedBuffer&gt; create(const char* data, size_t size) { return adoptRef(*new SharedBuffer(data, size)); }
 74     static Ref&lt;SharedBuffer&gt; create(const unsigned char* data, size_t size) { return adoptRef(*new SharedBuffer(data, size)); }
 75     static RefPtr&lt;SharedBuffer&gt; createWithContentsOfFile(const String&amp; filePath);
 76 
 77     static Ref&lt;SharedBuffer&gt; create(Vector&lt;char&gt;&amp;&amp;);
 78     static Ref&lt;SharedBuffer&gt; create(Vector&lt;uint8_t&gt;&amp;&amp;);
 79 
 80 #if USE(FOUNDATION)
 81     RetainPtr&lt;NSData&gt; createNSData() const;
 82     RetainPtr&lt;NSArray&gt; createNSDataArray() const;
 83     static Ref&lt;SharedBuffer&gt; create(NSData *);
 84     void append(NSData *);
 85 #endif
 86 #if USE(CF)
 87     RetainPtr&lt;CFDataRef&gt; createCFData() const;
 88     static Ref&lt;SharedBuffer&gt; create(CFDataRef);
 89     void append(CFDataRef);
 90 #endif
 91 
 92 #if USE(SOUP)
 93     GUniquePtr&lt;SoupBuffer&gt; createSoupBuffer(unsigned offset = 0, unsigned size = 0);
 94     static Ref&lt;SharedBuffer&gt; wrapSoupBuffer(SoupBuffer*);
 95 #endif
 96 
 97 #if USE(GLIB)
 98     static Ref&lt;SharedBuffer&gt; create(GBytes*);
 99 #endif
100 
101 #if USE(GSTREAMER)
102     static Ref&lt;SharedBuffer&gt; create(GstMappedBuffer&amp;);
103 #endif
104     // Calling data() causes all the data segments to be copied into one segment if they are not already.
105     // Iterate the segments using begin() and end() instead.
106     // FIXME: Audit the call sites of this function and replace them with iteration if possible.
107     const char* data() const;
108 
109     // Creates an ArrayBuffer and copies this SharedBuffer&#39;s contents to that
110     // ArrayBuffer without merging segmented buffers into a flat buffer.
111     RefPtr&lt;ArrayBuffer&gt; tryCreateArrayBuffer() const;
112 
113     size_t size() const { return m_size; }
114 
115     bool isEmpty() const { return !size(); }
116 
117     void append(const SharedBuffer&amp;);
118     void append(const char*, size_t);
119     void append(Vector&lt;char&gt;&amp;&amp;);
120 
121     void clear();
122 
123     Ref&lt;SharedBuffer&gt; copy() const;
124 
125     // Data wrapped by a DataSegment should be immutable because it can be referenced by other objects.
126     // To modify or combine the data, allocate a new DataSegment.
127     class DataSegment : public ThreadSafeRefCounted&lt;DataSegment&gt; {
128     public:
129         WEBCORE_EXPORT const char* data() const;
130         WEBCORE_EXPORT size_t size() const;
131 
<a name="3" id="anc3"></a><span class="line-modified">132         static Ref&lt;DataSegment&gt; create(Vector&lt;char&gt;&amp;&amp; data)</span>
<span class="line-added">133         {</span>
<span class="line-added">134             data.shrinkToFit();</span>
<span class="line-added">135             return adoptRef(*new DataSegment(WTFMove(data)));</span>
<span class="line-added">136         }</span>
<span class="line-added">137 </span>
138 #if USE(CF)
139         static Ref&lt;DataSegment&gt; create(RetainPtr&lt;CFDataRef&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
140 #endif
141 #if USE(SOUP)
142         static Ref&lt;DataSegment&gt; create(GUniquePtr&lt;SoupBuffer&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
143 #endif
144 #if USE(GLIB)
145         static Ref&lt;DataSegment&gt; create(GRefPtr&lt;GBytes&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
146 #endif
147 #if USE(GSTREAMER)
148         static Ref&lt;DataSegment&gt; create(RefPtr&lt;GstMappedBuffer&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
149 #endif
150         static Ref&lt;DataSegment&gt; create(FileSystem::MappedFileData&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
151 
<a name="4" id="anc4"></a><span class="line-added">152 #if USE(FOUNDATION)</span>
<span class="line-added">153         RetainPtr&lt;NSData&gt; createNSData() const;</span>
<span class="line-added">154 #endif</span>
<span class="line-added">155 </span>
156     private:
157         DataSegment(Vector&lt;char&gt;&amp;&amp; data)
158             : m_immutableData(WTFMove(data)) { }
159 #if USE(CF)
160         DataSegment(RetainPtr&lt;CFDataRef&gt;&amp;&amp; data)
161             : m_immutableData(WTFMove(data)) { }
162 #endif
163 #if USE(SOUP)
164         DataSegment(GUniquePtr&lt;SoupBuffer&gt;&amp;&amp; data)
165             : m_immutableData(WTFMove(data)) { }
166 #endif
167 #if USE(GLIB)
168         DataSegment(GRefPtr&lt;GBytes&gt;&amp;&amp; data)
169             : m_immutableData(WTFMove(data)) { }
170 #endif
171 #if USE(GSTREAMER)
172         DataSegment(RefPtr&lt;GstMappedBuffer&gt;&amp;&amp; data)
173             : m_immutableData(WTFMove(data)) { }
174 #endif
175         DataSegment(FileSystem::MappedFileData&amp;&amp; data)
176             : m_immutableData(WTFMove(data)) { }
177 
178         Variant&lt;Vector&lt;char&gt;,
179 #if USE(CF)
180             RetainPtr&lt;CFDataRef&gt;,
181 #endif
182 #if USE(SOUP)
183             GUniquePtr&lt;SoupBuffer&gt;,
184 #endif
185 #if USE(GLIB)
186             GRefPtr&lt;GBytes&gt;,
187 #endif
188 #if USE(GSTREAMER)
189             RefPtr&lt;GstMappedBuffer&gt;,
190 #endif
191             FileSystem::MappedFileData&gt; m_immutableData;
192         friend class SharedBuffer;
193     };
194 
195     struct DataSegmentVectorEntry {
196         size_t beginPosition;
197         Ref&lt;DataSegment&gt; segment;
198     };
199     using DataSegmentVector = Vector&lt;DataSegmentVectorEntry, 1&gt;;
200     DataSegmentVector::const_iterator begin() const { return m_segments.begin(); }
201     DataSegmentVector::const_iterator end() const { return m_segments.end(); }
202 
203     // begin and end take O(1) time, this takes O(log(N)) time.
204     SharedBufferDataView getSomeData(size_t position) const;
205 
<a name="5" id="anc5"></a><span class="line-added">206     String toHexString() const;</span>
<span class="line-added">207 </span>
208     void hintMemoryNotNeededSoon() const;
209 
<a name="6" id="anc6"></a><span class="line-added">210     WTF::Persistence::Decoder decoder() const;</span>
<span class="line-added">211 </span>
212     bool operator==(const SharedBuffer&amp;) const;
213     bool operator!=(const SharedBuffer&amp; other) const { return !operator==(other); }
214 
215 private:
216     explicit SharedBuffer() = default;
217     explicit SharedBuffer(const char*, size_t);
218     explicit SharedBuffer(const unsigned char*, size_t);
219     explicit SharedBuffer(Vector&lt;char&gt;&amp;&amp;);
220     explicit SharedBuffer(FileSystem::MappedFileData&amp;&amp;);
221 #if USE(CF)
222     explicit SharedBuffer(CFDataRef);
223 #endif
224 #if USE(SOUP)
225     explicit SharedBuffer(SoupBuffer*);
226 #endif
227 #if USE(GLIB)
228     explicit SharedBuffer(GBytes*);
229 #endif
230 #if USE(GSTREAMER)
231     explicit SharedBuffer(GstMappedBuffer&amp;);
232 #endif
233 
234     void combineIntoOneSegment() const;
235 
236     static RefPtr&lt;SharedBuffer&gt; createFromReadingFile(const String&amp; filePath);
237 
238     size_t m_size { 0 };
239     mutable DataSegmentVector m_segments;
240 
<a name="7" id="anc7"></a><span class="line-modified">241 #if ASSERT_ENABLED</span>
242     mutable bool m_hasBeenCombinedIntoOneSegment { false };
243     bool internallyConsistent() const;
244 #endif
245 };
246 
247 inline bool operator==(const Ref&lt;SharedBuffer&gt;&amp; left, const SharedBuffer&amp; right)
248 {
249     return left.get() == right;
250 }
251 
252 inline bool operator!=(const Ref&lt;SharedBuffer&gt;&amp; left, const SharedBuffer&amp; right)
253 {
254     return left.get() != right;
255 }
256 
257 class WEBCORE_EXPORT SharedBufferDataView {
258 public:
259     SharedBufferDataView(Ref&lt;SharedBuffer::DataSegment&gt;&amp;&amp;, size_t);
260     size_t size() const;
261     const char* data() const;
<a name="8" id="anc8"></a><span class="line-added">262 #if USE(FOUNDATION)</span>
<span class="line-added">263     RetainPtr&lt;NSData&gt; createNSData() const;</span>
<span class="line-added">264 #endif</span>
265 private:
266     size_t m_positionWithinSegment;
267     Ref&lt;SharedBuffer::DataSegment&gt; m_segment;
268 };
269 
270 RefPtr&lt;SharedBuffer&gt; utf8Buffer(const String&amp;);
271 
272 } // namespace WebCore
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
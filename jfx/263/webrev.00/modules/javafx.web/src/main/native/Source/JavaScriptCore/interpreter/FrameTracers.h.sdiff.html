<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/FrameTracers.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CalleeBits.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Interpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/FrameTracers.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 64     {
 65         vm.topCallFrame = oldCallFrame;
 66     }
 67 private:
 68     VM&amp; vm;
 69     CallFrame* oldCallFrame;
 70 };
 71 
 72 ALWAYS_INLINE static void assertStackPointerIsAligned()
 73 {
 74 #ifndef NDEBUG
 75 #if CPU(X86) &amp;&amp; !OS(WINDOWS)
 76     uintptr_t stackPointer;
 77 
 78     asm(&quot;movl %%esp,%0&quot; : &quot;=r&quot;(stackPointer));
 79     ASSERT(!(stackPointer % stackAlignmentBytes()));
 80 #endif
 81 #endif
 82 }
 83 











 84 class NativeCallFrameTracer {
 85 public:
 86     ALWAYS_INLINE NativeCallFrameTracer(VM&amp; vm, CallFrame* callFrame)
 87     {
<span class="line-removed"> 88         ASSERT(&amp;vm);</span>
 89         ASSERT(callFrame);
 90         ASSERT(reinterpret_cast&lt;void*&gt;(callFrame) &lt; reinterpret_cast&lt;void*&gt;(vm.topEntryFrame));
 91         assertStackPointerIsAligned();
 92         vm.topCallFrame = callFrame;
 93     }
 94 };
 95 
































 96 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 64     {
 65         vm.topCallFrame = oldCallFrame;
 66     }
 67 private:
 68     VM&amp; vm;
 69     CallFrame* oldCallFrame;
 70 };
 71 
 72 ALWAYS_INLINE static void assertStackPointerIsAligned()
 73 {
 74 #ifndef NDEBUG
 75 #if CPU(X86) &amp;&amp; !OS(WINDOWS)
 76     uintptr_t stackPointer;
 77 
 78     asm(&quot;movl %%esp,%0&quot; : &quot;=r&quot;(stackPointer));
 79     ASSERT(!(stackPointer % stackAlignmentBytes()));
 80 #endif
 81 #endif
 82 }
 83 
<span class="line-added"> 84 class SlowPathFrameTracer {</span>
<span class="line-added"> 85 public:</span>
<span class="line-added"> 86     ALWAYS_INLINE SlowPathFrameTracer(VM&amp; vm, CallFrame* callFrame)</span>
<span class="line-added"> 87     {</span>
<span class="line-added"> 88         ASSERT(callFrame);</span>
<span class="line-added"> 89         ASSERT(reinterpret_cast&lt;void*&gt;(callFrame) &lt; reinterpret_cast&lt;void*&gt;(vm.topEntryFrame));</span>
<span class="line-added"> 90         assertStackPointerIsAligned();</span>
<span class="line-added"> 91         vm.topCallFrame = callFrame;</span>
<span class="line-added"> 92     }</span>
<span class="line-added"> 93 };</span>
<span class="line-added"> 94 </span>
 95 class NativeCallFrameTracer {
 96 public:
 97     ALWAYS_INLINE NativeCallFrameTracer(VM&amp; vm, CallFrame* callFrame)
 98     {

 99         ASSERT(callFrame);
100         ASSERT(reinterpret_cast&lt;void*&gt;(callFrame) &lt; reinterpret_cast&lt;void*&gt;(vm.topEntryFrame));
101         assertStackPointerIsAligned();
102         vm.topCallFrame = callFrame;
103     }
104 };
105 
<span class="line-added">106 class JITOperationPrologueCallFrameTracer {</span>
<span class="line-added">107 public:</span>
<span class="line-added">108     ALWAYS_INLINE JITOperationPrologueCallFrameTracer(VM&amp; vm, CallFrame* callFrame)</span>
<span class="line-added">109 #if ASSERT_ENABLED</span>
<span class="line-added">110         : m_vm(vm)</span>
<span class="line-added">111 #endif</span>
<span class="line-added">112     {</span>
<span class="line-added">113         UNUSED_PARAM(vm);</span>
<span class="line-added">114         UNUSED_PARAM(callFrame);</span>
<span class="line-added">115         ASSERT(callFrame);</span>
<span class="line-added">116         ASSERT(reinterpret_cast&lt;void*&gt;(callFrame) &lt; reinterpret_cast&lt;void*&gt;(vm.topEntryFrame));</span>
<span class="line-added">117         assertStackPointerIsAligned();</span>
<span class="line-added">118 #if USE(BUILTIN_FRAME_ADDRESS)</span>
<span class="line-added">119         // If ASSERT_ENABLED and USE(BUILTIN_FRAME_ADDRESS), prepareCallOperation() will put the frame pointer into vm.topCallFrame.</span>
<span class="line-added">120         // We can ensure here that a call to prepareCallOperation() (or its equivalent) is not missing by comparing vm.topCallFrame to</span>
<span class="line-added">121         // the result of __builtin_frame_address which is passed in as callFrame.</span>
<span class="line-added">122         ASSERT(vm.topCallFrame == callFrame);</span>
<span class="line-added">123         vm.topCallFrame = callFrame;</span>
<span class="line-added">124 #endif</span>
<span class="line-added">125     }</span>
<span class="line-added">126 </span>
<span class="line-added">127 #if ASSERT_ENABLED</span>
<span class="line-added">128     ~JITOperationPrologueCallFrameTracer()</span>
<span class="line-added">129     {</span>
<span class="line-added">130         // Fill vm.topCallFrame with invalid value when leaving from JIT operation functions.</span>
<span class="line-added">131         m_vm.topCallFrame = bitwise_cast&lt;CallFrame*&gt;(static_cast&lt;uintptr_t&gt;(0x0badbeef0badbeefULL));</span>
<span class="line-added">132     }</span>
<span class="line-added">133 </span>
<span class="line-added">134     VM&amp; m_vm;</span>
<span class="line-added">135 #endif</span>
<span class="line-added">136 };</span>
<span class="line-added">137 </span>
138 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="CalleeBits.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Interpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
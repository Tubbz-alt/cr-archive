diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSDataView.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSDataView.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSDataView.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSDataView.cpp
@@ -42,23 +42,23 @@
     , m_buffer(buffer)
 {
 }
 
 JSDataView* JSDataView::create(
-    ExecState* exec, Structure* structure, RefPtr<ArrayBuffer>&& buffer,
+    JSGlobalObject* globalObject, Structure* structure, RefPtr<ArrayBuffer>&& buffer,
     unsigned byteOffset, unsigned byteLength)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     ASSERT(buffer);
     if (!ArrayBufferView::verifySubRangeLength(*buffer, byteOffset, byteLength, sizeof(uint8_t))) {
-        throwVMError(exec, scope, createRangeError(exec, "Length out of range of buffer"_s));
+        throwVMError(globalObject, scope, createRangeError(globalObject, "Length out of range of buffer"_s));
         return nullptr;
     }
     if (!ArrayBufferView::verifyByteOffsetAlignment(byteOffset, sizeof(uint8_t))) {
-        throwException(exec, scope, createRangeError(exec, "Byte offset is not aligned"_s));
+        throwException(globalObject, scope, createRangeError(globalObject, "Byte offset is not aligned"_s));
         return nullptr;
     }
     ConstructionContext context(
         structure, buffer.copyRef(), byteOffset, byteLength, ConstructionContext::DataView);
     ASSERT(context);
@@ -66,29 +66,29 @@
         new (NotNull, allocateCell<JSDataView>(vm.heap)) JSDataView(vm, context, buffer.get());
     result->finishCreation(vm);
     return result;
 }
 
-JSDataView* JSDataView::createUninitialized(ExecState*, Structure*, unsigned)
+JSDataView* JSDataView::createUninitialized(JSGlobalObject*, Structure*, unsigned)
 {
     UNREACHABLE_FOR_PLATFORM();
     return 0;
 }
 
-JSDataView* JSDataView::create(ExecState*, Structure*, unsigned)
+JSDataView* JSDataView::create(JSGlobalObject*, Structure*, unsigned)
 {
     UNREACHABLE_FOR_PLATFORM();
     return 0;
 }
 
-bool JSDataView::set(ExecState*, unsigned, JSObject*, unsigned, unsigned)
+bool JSDataView::set(JSGlobalObject*, unsigned, JSObject*, unsigned, unsigned)
 {
     UNREACHABLE_FOR_PLATFORM();
     return false;
 }
 
-bool JSDataView::setIndex(ExecState*, unsigned, JSValue)
+bool JSDataView::setIndex(JSGlobalObject*, unsigned, JSValue)
 {
     UNREACHABLE_FOR_PLATFORM();
     return false;
 }
 
@@ -101,82 +101,82 @@
 {
     return DataView::create(unsharedBuffer(), byteOffset(), length());
 }
 
 bool JSDataView::getOwnPropertySlot(
-    JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot& slot)
+    JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot& slot)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSDataView* thisObject = jsCast<JSDataView*>(object);
     if (propertyName == vm.propertyNames->byteLength) {
         slot.setValue(thisObject, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly, jsNumber(thisObject->m_length));
         return true;
     }
     if (propertyName == vm.propertyNames->byteOffset) {
         slot.setValue(thisObject, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly, jsNumber(thisObject->byteOffset()));
         return true;
     }
 
-    return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);
+    return Base::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);
 }
 
 bool JSDataView::put(
-    JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value,
+    JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value,
     PutPropertySlot& slot)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     JSDataView* thisObject = jsCast<JSDataView*>(cell);
 
     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
-        RELEASE_AND_RETURN(scope, ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));
+        RELEASE_AND_RETURN(scope, ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));
 
     if (propertyName == vm.propertyNames->byteLength
         || propertyName == vm.propertyNames->byteOffset)
-        return typeError(exec, scope, slot.isStrictMode(), "Attempting to write to read-only typed array property."_s);
+        return typeError(globalObject, scope, slot.isStrictMode(), "Attempting to write to read-only typed array property."_s);
 
-    RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));
+    RELEASE_AND_RETURN(scope, Base::put(thisObject, globalObject, propertyName, value, slot));
 }
 
 bool JSDataView::defineOwnProperty(
-    JSObject* object, ExecState* exec, PropertyName propertyName,
+    JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName,
     const PropertyDescriptor& descriptor, bool shouldThrow)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     JSDataView* thisObject = jsCast<JSDataView*>(object);
     if (propertyName == vm.propertyNames->byteLength
         || propertyName == vm.propertyNames->byteOffset)
-        return typeError(exec, scope, shouldThrow, "Attempting to define read-only typed array property."_s);
+        return typeError(globalObject, scope, shouldThrow, "Attempting to define read-only typed array property."_s);
 
-    RELEASE_AND_RETURN(scope, Base::defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow));
+    RELEASE_AND_RETURN(scope, Base::defineOwnProperty(thisObject, globalObject, propertyName, descriptor, shouldThrow));
 }
 
 bool JSDataView::deleteProperty(
-    JSCell* cell, ExecState* exec, PropertyName propertyName)
+    JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSDataView* thisObject = jsCast<JSDataView*>(cell);
     if (propertyName == vm.propertyNames->byteLength
         || propertyName == vm.propertyNames->byteOffset)
         return false;
 
-    return Base::deleteProperty(thisObject, exec, propertyName);
+    return Base::deleteProperty(thisObject, globalObject, propertyName);
 }
 
 void JSDataView::getOwnNonIndexPropertyNames(
-    JSObject* object, ExecState* exec, PropertyNameArray& array, EnumerationMode mode)
+    JSObject* object, JSGlobalObject* globalObject, PropertyNameArray& array, EnumerationMode mode)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSDataView* thisObject = jsCast<JSDataView*>(object);
 
     if (mode.includeDontEnumProperties()) {
         array.add(vm.propertyNames->byteOffset);
         array.add(vm.propertyNames->byteLength);
     }
 
-    Base::getOwnNonIndexPropertyNames(thisObject, exec, array, mode);
+    Base::getOwnNonIndexPropertyNames(thisObject, globalObject, array, mode);
 }
 
 Structure* JSDataView::createStructure(
     VM& vm, JSGlobalObject* globalObject, JSValue prototype)
 {

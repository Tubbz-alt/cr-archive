<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/dom/Node.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NameNodeList.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Node.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Node.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -75,10 +75,11 @@</span>
  #include &quot;TextEvent.h&quot;
  #include &quot;TouchEvent.h&quot;
  #include &quot;WheelEvent.h&quot;
  #include &quot;XMLNSNames.h&quot;
  #include &quot;XMLNames.h&quot;
<span class="udiff-line-added">+ #include &lt;JavaScriptCore/HeapInlines.h&gt;</span>
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/RefCountedLeakCounter.h&gt;
  #include &lt;wtf/SHA1.h&gt;
  #include &lt;wtf/Variant.h&gt;
  #include &lt;wtf/text/CString.h&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -361,11 +362,11 @@</span>
      if (hasEventTargetData())
          clearEventTargetData();
  
      document().decrementReferencingNodeCount();
  
<span class="udiff-line-modified-removed">- #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY) &amp;&amp; (!ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS))</span>
<span class="udiff-line-modified-added">+ #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY) &amp;&amp; (ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS))</span>
      for (auto* document : Document::allDocuments()) {
          ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventListenersContain(*this));
          ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventHandlersContain(*this));
          ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventTargetsContain(*this));
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -667,12 +668,17 @@</span>
                  continue;
              }
  
              // Both non-empty text nodes. Merge them.
              unsigned offset = text-&gt;length();
<span class="udiff-line-modified-removed">-             text-&gt;appendData(nextText-&gt;data());</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+             // Update start/end for any affected Ranges before appendData since modifying contents might trigger mutation events that modify ordering.</span>
              document().textNodesMerged(nextText, offset);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // FIXME: DOM spec requires contents to be replaced all at once (see https://dom.spec.whatwg.org/#dom-node-normalize).</span>
<span class="udiff-line-added">+             // Appending once per sibling may trigger mutation events too many times.</span>
<span class="udiff-line-added">+             text-&gt;appendData(nextText-&gt;data());</span>
              nextText-&gt;remove();
          }
  
          node = NodeTraversal::nextPostOrder(*node);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1127,11 +1133,11 @@</span>
  {
      ContainerNode&amp; root = treeScope().rootNode();
      return is&lt;ShadowRoot&gt;(root) ? downcast&lt;ShadowRoot&gt;(&amp;root) : nullptr;
  }
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
  // https://dom.spec.whatwg.org/#concept-closed-shadow-hidden
  static bool isClosedShadowHiddenUsingSpecDefinition(const Node&amp; A, const Node&amp; B)
  {
      return A.isInShadowTree()
          &amp;&amp; !A.rootNode().containsIncludingShadowDOM(&amp;B)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1607,10 +1613,18 @@</span>
      unsigned short direction = memcmp(firstHash.data(), secondHash.data(), SHA1::hashSize) &gt; 0 ? Node::DOCUMENT_POSITION_PRECEDING : Node::DOCUMENT_POSITION_FOLLOWING;
  
      return Node::DOCUMENT_POSITION_DISCONNECTED | Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | direction;
  }
  
<span class="udiff-line-added">+ bool areNodesConnectedInSameTreeScope(const Node* a, const Node* b)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!a || !b)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+     // Note that we avoid comparing Attr nodes here, since they return false from isConnected() all the time (which seems like a bug).</span>
<span class="udiff-line-added">+     return a-&gt;isConnected() == b-&gt;isConnected() &amp;&amp; &amp;a-&gt;treeScope() == &amp;b-&gt;treeScope();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  unsigned short Node::compareDocumentPosition(Node&amp; otherNode)
  {
      if (&amp;otherNode == this)
          return DOCUMENT_POSITION_EQUIVALENT;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1651,13 +1665,12 @@</span>
          ASSERT_NOT_REACHED();
          return DOCUMENT_POSITION_DISCONNECTED;
      }
  
      // If one node is in the document and the other is not, we must be disconnected.
<span class="udiff-line-modified-removed">-     // If the nodes have different owning documents, they must be disconnected.  Note that we avoid</span>
<span class="udiff-line-modified-removed">-     // comparing Attr nodes here, since they return false from isConnected() all the time (which seems like a bug).</span>
<span class="udiff-line-removed">-     if (start1-&gt;isConnected() != start2-&gt;isConnected() || &amp;start1-&gt;treeScope() != &amp;start2-&gt;treeScope())</span>
<span class="udiff-line-modified-added">+     // If the nodes have different owning documents, they must be disconnected.</span>
<span class="udiff-line-modified-added">+     if (!areNodesConnectedInSameTreeScope(start1, start2))</span>
          return compareDetachedElementsPosition(*this, otherNode);
  
      // We need to find a common ancestor container, and then compare the indices of the two immediate children.
      Node* current;
      for (current = start1; current; current = current-&gt;parentNode())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1904,24 +1917,24 @@</span>
  
  // --------
  
  void NodeListsNodeData::invalidateCaches()
  {
<span class="udiff-line-modified-removed">-     for (auto&amp; atomicName : m_atomicNameCaches)</span>
<span class="udiff-line-modified-removed">-         atomicName.value-&gt;invalidateCache();</span>
<span class="udiff-line-modified-added">+     for (auto&amp; atomName : m_atomNameCaches)</span>
<span class="udiff-line-modified-added">+         atomName.value-&gt;invalidateCache();</span>
  
      for (auto&amp; collection : m_cachedCollections)
          collection.value-&gt;invalidateCache();
  
      for (auto&amp; tagCollection : m_tagCollectionNSCache)
          tagCollection.value-&gt;invalidateCache();
  }
  
  void NodeListsNodeData::invalidateCachesForAttribute(const QualifiedName&amp; attrName)
  {
<span class="udiff-line-modified-removed">-     for (auto&amp; atomicName : m_atomicNameCaches)</span>
<span class="udiff-line-modified-removed">-         atomicName.value-&gt;invalidateCacheForAttribute(attrName);</span>
<span class="udiff-line-modified-added">+     for (auto&amp; atomName : m_atomNameCaches)</span>
<span class="udiff-line-modified-added">+         atomName.value-&gt;invalidateCacheForAttribute(attrName);</span>
  
      for (auto&amp; collection : m_cachedCollections)
          collection.value-&gt;invalidateCacheForAttribute(attrName);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2086,11 +2099,11 @@</span>
              newDocument.addTouchEventHandler(*this);
          }
  #endif
      }
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)</span>
  #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
      ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventListenersContain(*this));
      ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventHandlersContain(*this));
  #endif
  #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2112,12 +2125,14 @@</span>
          targetNode-&gt;document().didAddWheelEventHandler(*targetNode);
      else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
          targetNode-&gt;document().didAddTouchEventHandler(*targetNode);
  
  #if PLATFORM(IOS_FAMILY)
<span class="udiff-line-modified-removed">-     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)</span>
<span class="udiff-line-modified-removed">-         targetNode-&gt;document().domWindow()-&gt;incrementScrollEventListenersCount();</span>
<span class="udiff-line-modified-added">+     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent) {</span>
<span class="udiff-line-modified-added">+         if (auto* window = targetNode-&gt;document().domWindow())</span>
<span class="udiff-line-added">+             window-&gt;incrementScrollEventListenersCount();</span>
<span class="udiff-line-added">+     }</span>
  
  #if ENABLE(TOUCH_EVENTS)
      if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
          targetNode-&gt;document().addTouchEventListener(*targetNode);
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2147,12 +2162,14 @@</span>
          targetNode-&gt;document().didRemoveWheelEventHandler(*targetNode);
      else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
          targetNode-&gt;document().didRemoveTouchEventHandler(*targetNode);
  
  #if PLATFORM(IOS_FAMILY)
<span class="udiff-line-modified-removed">-     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)</span>
<span class="udiff-line-modified-removed">-         targetNode-&gt;document().domWindow()-&gt;decrementScrollEventListenersCount();</span>
<span class="udiff-line-modified-added">+     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent) {</span>
<span class="udiff-line-modified-added">+         if (auto* window = targetNode-&gt;document().domWindow())</span>
<span class="udiff-line-added">+             window-&gt;decrementScrollEventListenersCount();</span>
<span class="udiff-line-added">+     }</span>
  
  #if ENABLE(TOUCH_EVENTS)
      if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
          targetNode-&gt;document().removeTouchEventListener(*targetNode);
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2426,10 +2443,16 @@</span>
      } else if (eventType == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event)) {
          if (downcast&lt;MouseEvent&gt;(event).button() == MiddleButton) {
              if (enclosingLinkEventParentOrSelf())
                  return;
  
<span class="udiff-line-added">+             // Avoid that canBeScrolledAndHasScrollableArea changes render tree</span>
<span class="udiff-line-added">+             // structure.</span>
<span class="udiff-line-added">+             // FIXME: We should avoid synchronous layout if possible. We can</span>
<span class="udiff-line-added">+             // remove this synchronous layout if we avoid synchronous layout in</span>
<span class="udiff-line-added">+             // RenderTextControlSingleLine::scrollHeight</span>
<span class="udiff-line-added">+             document().updateLayoutIgnorePendingStylesheets();</span>
              RenderObject* renderer = this-&gt;renderer();
              while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
                  renderer = renderer-&gt;parent();
  
              if (renderer) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2521,11 +2544,11 @@</span>
      // may outlive the SVGElement. The only difference after the detach is no commit will
      // be carried out unless these properties are attached to another owner.
      if (is&lt;SVGElement&gt;(*this))
          downcast&lt;SVGElement&gt;(*this).detachAllProperties();
  
<span class="udiff-line-modified-removed">- #ifndef NDEBUG</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      m_deletionHasBegun = true;
  #endif
      delete this;
  }
  
</pre>
<center><a href="NameNodeList.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Node.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
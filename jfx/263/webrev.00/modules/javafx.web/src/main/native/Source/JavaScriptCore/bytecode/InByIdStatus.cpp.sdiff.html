<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InByIdStatus.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ICStatusUtils.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InByIdStatus.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InByIdStatus.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;InByIdStatus.h&quot;
 29 
 30 #include &quot;CodeBlock.h&quot;
 31 #include &quot;ComplexGetStatus.h&quot;
 32 #include &quot;ICStatusUtils.h&quot;
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;PolymorphicAccess.h&quot;
 35 #include &quot;StructureStubInfo.h&quot;
 36 #include &lt;wtf/ListDump.h&gt;
 37 
 38 namespace JSC {
 39 
 40 bool InByIdStatus::appendVariant(const InByIdVariant&amp; variant)
 41 {
 42     return appendICStatusVariant(m_variants, variant);
 43 }
 44 
 45 #if ENABLE(JIT)
<span class="line-modified"> 46 InByIdStatus InByIdStatus::computeFor(CodeBlock* profiledBlock, ICStatusMap&amp; map, unsigned bytecodeIndex, UniquedStringImpl* uid, ExitFlag didExit)</span>
 47 {
 48     ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);
 49 
 50     InByIdStatus result;
 51 
 52 #if ENABLE(DFG_JIT)
<span class="line-modified"> 53     result = computeForStubInfoWithoutExitSiteFeedback(locker, map.get(CodeOrigin(bytecodeIndex)).stubInfo, uid);</span>
 54 
 55     if (!result.takesSlowPath() &amp;&amp; didExit)
 56         return InByIdStatus(TakesSlowPath);
 57 #else
 58     UNUSED_PARAM(map);
 59     UNUSED_PARAM(bytecodeIndex);
 60     UNUSED_PARAM(uid);
 61     UNUSED_PARAM(didExit);
 62 #endif
 63 
 64     return result;
 65 }
 66 
<span class="line-modified"> 67 InByIdStatus InByIdStatus::computeFor(CodeBlock* profiledBlock, ICStatusMap&amp; map, unsigned bytecodeIndex, UniquedStringImpl* uid)</span>
 68 {
 69     return computeFor(profiledBlock, map, bytecodeIndex, uid, hasBadCacheExitSite(profiledBlock, bytecodeIndex));
 70 }
 71 
 72 InByIdStatus InByIdStatus::computeFor(
 73     CodeBlock* profiledBlock, ICStatusMap&amp; baselineMap,
 74     ICStatusContextStack&amp; contextStack, CodeOrigin codeOrigin, UniquedStringImpl* uid)
 75 {
<span class="line-modified"> 76     unsigned bytecodeIndex = codeOrigin.bytecodeIndex();</span>
 77     ExitFlag didExit = hasBadCacheExitSite(profiledBlock, bytecodeIndex);
 78 
 79     for (ICStatusContext* context : contextStack) {
 80         ICStatus status = context-&gt;get(codeOrigin);
 81 
 82         auto bless = [&amp;] (const InByIdStatus&amp; result) -&gt; InByIdStatus {
 83             if (!context-&gt;isInlined(codeOrigin)) {
 84                 InByIdStatus baselineResult = computeFor(
 85                     profiledBlock, baselineMap, bytecodeIndex, uid, didExit);
 86                 baselineResult.merge(result);
 87                 return baselineResult;
 88             }
 89             if (didExit.isSet(ExitFromInlined))
 90                 return InByIdStatus(TakesSlowPath);
 91             return result;
 92         };
 93 
 94 #if ENABLE(DFG_JIT)
 95         if (status.stubInfo) {
 96             InByIdStatus result;
 97             {
 98                 ConcurrentJSLocker locker(context-&gt;optimizedCodeBlock-&gt;m_lock);
<span class="line-modified"> 99                 result = computeForStubInfoWithoutExitSiteFeedback(locker, status.stubInfo, uid);</span>
100             }
101             if (result.isSet())
102                 return bless(result);
103         }
104 #endif
105 
106         if (status.inStatus)
107             return bless(*status.inStatus);
108     }
109 
110     return computeFor(profiledBlock, baselineMap, bytecodeIndex, uid, didExit);
111 }
112 #endif // ENABLE(JIT)
113 
114 #if ENABLE(DFG_JIT)
115 InByIdStatus InByIdStatus::computeForStubInfo(const ConcurrentJSLocker&amp; locker, CodeBlock* profiledBlock, StructureStubInfo* stubInfo, CodeOrigin codeOrigin, UniquedStringImpl* uid)
116 {
<span class="line-modified">117     InByIdStatus result = InByIdStatus::computeForStubInfoWithoutExitSiteFeedback(locker, stubInfo, uid);</span>
118 
119     if (!result.takesSlowPath() &amp;&amp; hasBadCacheExitSite(profiledBlock, codeOrigin.bytecodeIndex()))
120         return InByIdStatus(TakesSlowPath);
121     return result;
122 }
123 
<span class="line-modified">124 InByIdStatus InByIdStatus::computeForStubInfoWithoutExitSiteFeedback(const ConcurrentJSLocker&amp;, StructureStubInfo* stubInfo, UniquedStringImpl* uid)</span>
125 {
<span class="line-modified">126     StubInfoSummary summary = StructureStubInfo::summary(stubInfo);</span>
127     if (!isInlineable(summary))
128         return InByIdStatus(summary);
129 
130     // Finally figure out if we can derive an access strategy.
131     InByIdStatus result;
132     result.m_state = Simple;
<span class="line-modified">133     switch (stubInfo-&gt;cacheType) {</span>
134     case CacheType::Unset:
135         return InByIdStatus(NoInformation);
136 
137     case CacheType::InByIdSelf: {
138         Structure* structure = stubInfo-&gt;u.byIdSelf.baseObjectStructure.get();
139         if (structure-&gt;takesSlowPathInDFGForImpureProperty())
140             return InByIdStatus(TakesSlowPath);
141         unsigned attributes;
142         InByIdVariant variant;
143         variant.m_offset = structure-&gt;getConcurrently(uid, attributes);
144         if (!isValidOffset(variant.m_offset))
145             return InByIdStatus(TakesSlowPath);
146         if (attributes &amp; PropertyAttribute::CustomAccessorOrValue)
147             return InByIdStatus(TakesSlowPath);
148 
149         variant.m_structureSet.add(structure);
150         bool didAppend = result.appendVariant(variant);
151         ASSERT_UNUSED(didAppend, didAppend);
152         return result;
153     }
</pre>
</td>
<td>
<hr />
<pre>
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;InByIdStatus.h&quot;
 29 
 30 #include &quot;CodeBlock.h&quot;
 31 #include &quot;ComplexGetStatus.h&quot;
 32 #include &quot;ICStatusUtils.h&quot;
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;PolymorphicAccess.h&quot;
 35 #include &quot;StructureStubInfo.h&quot;
 36 #include &lt;wtf/ListDump.h&gt;
 37 
 38 namespace JSC {
 39 
 40 bool InByIdStatus::appendVariant(const InByIdVariant&amp; variant)
 41 {
 42     return appendICStatusVariant(m_variants, variant);
 43 }
 44 
 45 #if ENABLE(JIT)
<span class="line-modified"> 46 InByIdStatus InByIdStatus::computeFor(CodeBlock* profiledBlock, ICStatusMap&amp; map, BytecodeIndex bytecodeIndex, UniquedStringImpl* uid, ExitFlag didExit)</span>
 47 {
 48     ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);
 49 
 50     InByIdStatus result;
 51 
 52 #if ENABLE(DFG_JIT)
<span class="line-modified"> 53     result = computeForStubInfoWithoutExitSiteFeedback(locker, profiledBlock-&gt;vm(), map.get(CodeOrigin(bytecodeIndex)).stubInfo, uid);</span>
 54 
 55     if (!result.takesSlowPath() &amp;&amp; didExit)
 56         return InByIdStatus(TakesSlowPath);
 57 #else
 58     UNUSED_PARAM(map);
 59     UNUSED_PARAM(bytecodeIndex);
 60     UNUSED_PARAM(uid);
 61     UNUSED_PARAM(didExit);
 62 #endif
 63 
 64     return result;
 65 }
 66 
<span class="line-modified"> 67 InByIdStatus InByIdStatus::computeFor(CodeBlock* profiledBlock, ICStatusMap&amp; map, BytecodeIndex bytecodeIndex, UniquedStringImpl* uid)</span>
 68 {
 69     return computeFor(profiledBlock, map, bytecodeIndex, uid, hasBadCacheExitSite(profiledBlock, bytecodeIndex));
 70 }
 71 
 72 InByIdStatus InByIdStatus::computeFor(
 73     CodeBlock* profiledBlock, ICStatusMap&amp; baselineMap,
 74     ICStatusContextStack&amp; contextStack, CodeOrigin codeOrigin, UniquedStringImpl* uid)
 75 {
<span class="line-modified"> 76     BytecodeIndex bytecodeIndex = codeOrigin.bytecodeIndex();</span>
 77     ExitFlag didExit = hasBadCacheExitSite(profiledBlock, bytecodeIndex);
 78 
 79     for (ICStatusContext* context : contextStack) {
 80         ICStatus status = context-&gt;get(codeOrigin);
 81 
 82         auto bless = [&amp;] (const InByIdStatus&amp; result) -&gt; InByIdStatus {
 83             if (!context-&gt;isInlined(codeOrigin)) {
 84                 InByIdStatus baselineResult = computeFor(
 85                     profiledBlock, baselineMap, bytecodeIndex, uid, didExit);
 86                 baselineResult.merge(result);
 87                 return baselineResult;
 88             }
 89             if (didExit.isSet(ExitFromInlined))
 90                 return InByIdStatus(TakesSlowPath);
 91             return result;
 92         };
 93 
 94 #if ENABLE(DFG_JIT)
 95         if (status.stubInfo) {
 96             InByIdStatus result;
 97             {
 98                 ConcurrentJSLocker locker(context-&gt;optimizedCodeBlock-&gt;m_lock);
<span class="line-modified"> 99                 result = computeForStubInfoWithoutExitSiteFeedback(locker, profiledBlock-&gt;vm(), status.stubInfo, uid);</span>
100             }
101             if (result.isSet())
102                 return bless(result);
103         }
104 #endif
105 
106         if (status.inStatus)
107             return bless(*status.inStatus);
108     }
109 
110     return computeFor(profiledBlock, baselineMap, bytecodeIndex, uid, didExit);
111 }
112 #endif // ENABLE(JIT)
113 
114 #if ENABLE(DFG_JIT)
115 InByIdStatus InByIdStatus::computeForStubInfo(const ConcurrentJSLocker&amp; locker, CodeBlock* profiledBlock, StructureStubInfo* stubInfo, CodeOrigin codeOrigin, UniquedStringImpl* uid)
116 {
<span class="line-modified">117     InByIdStatus result = InByIdStatus::computeForStubInfoWithoutExitSiteFeedback(locker, profiledBlock-&gt;vm(), stubInfo, uid);</span>
118 
119     if (!result.takesSlowPath() &amp;&amp; hasBadCacheExitSite(profiledBlock, codeOrigin.bytecodeIndex()))
120         return InByIdStatus(TakesSlowPath);
121     return result;
122 }
123 
<span class="line-modified">124 InByIdStatus InByIdStatus::computeForStubInfoWithoutExitSiteFeedback(const ConcurrentJSLocker&amp;, VM&amp; vm, StructureStubInfo* stubInfo, UniquedStringImpl* uid)</span>
125 {
<span class="line-modified">126     StubInfoSummary summary = StructureStubInfo::summary(vm, stubInfo);</span>
127     if (!isInlineable(summary))
128         return InByIdStatus(summary);
129 
130     // Finally figure out if we can derive an access strategy.
131     InByIdStatus result;
132     result.m_state = Simple;
<span class="line-modified">133     switch (stubInfo-&gt;cacheType()) {</span>
134     case CacheType::Unset:
135         return InByIdStatus(NoInformation);
136 
137     case CacheType::InByIdSelf: {
138         Structure* structure = stubInfo-&gt;u.byIdSelf.baseObjectStructure.get();
139         if (structure-&gt;takesSlowPathInDFGForImpureProperty())
140             return InByIdStatus(TakesSlowPath);
141         unsigned attributes;
142         InByIdVariant variant;
143         variant.m_offset = structure-&gt;getConcurrently(uid, attributes);
144         if (!isValidOffset(variant.m_offset))
145             return InByIdStatus(TakesSlowPath);
146         if (attributes &amp; PropertyAttribute::CustomAccessorOrValue)
147             return InByIdStatus(TakesSlowPath);
148 
149         variant.m_structureSet.add(structure);
150         bool didAppend = result.appendVariant(variant);
151         ASSERT_UNUSED(didAppend, didAppend);
152         return result;
153     }
</pre>
</td>
</tr>
</table>
<center><a href="ICStatusUtils.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InByIdStatus.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
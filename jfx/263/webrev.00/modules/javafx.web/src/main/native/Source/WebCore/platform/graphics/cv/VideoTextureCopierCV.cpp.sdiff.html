<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/cv/VideoTextureCopierCV.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextureCacheCV.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VideoTextureCopierCV.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/cv/VideoTextureCopierCV.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;VideoTextureCopierCV.h&quot;
  28 
  29 #if HAVE(CORE_VIDEO)
  30 
  31 #include &quot;FourCC.h&quot;
  32 #include &quot;Logging.h&quot;
  33 #include &quot;TextureCacheCV.h&quot;
  34 #include &lt;pal/spi/cocoa/IOSurfaceSPI.h&gt;
  35 #include &lt;wtf/NeverDestroyed.h&gt;
  36 #include &lt;wtf/StdMap.h&gt;
  37 #include &lt;wtf/text/StringBuilder.h&gt;
  38 
  39 #if USE(OPENGL_ES)
  40 #include &lt;OpenGLES/ES3/glext.h&gt;
  41 #endif
  42 













  43 #include &quot;CoreVideoSoftLink.h&quot;
  44 
  45 namespace WebCore {
  46 
  47 #if HAVE(IOSURFACE)
  48 enum class PixelRange {
  49     Unknown,
  50     Video,
  51     Full,
  52 };
  53 
<span class="line-modified">  54 enum class TransferFunction {</span>
  55     Unknown,
  56     kITU_R_709_2,
  57     kITU_R_601_4,
  58     kSMPTE_240M_1995,
  59     kDCI_P3,
  60     kP3_D65,
  61     kITU_R_2020,
  62 };
  63 
  64 static PixelRange pixelRangeFromPixelFormat(OSType pixelFormat)
  65 {
  66     switch (pixelFormat) {
  67     case kCVPixelFormatType_4444AYpCbCr8:
  68     case kCVPixelFormatType_4444AYpCbCr16:
  69     case kCVPixelFormatType_422YpCbCr_4A_8BiPlanar:
  70     case kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange:
  71     case kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange:
  72     case kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange:
  73     case kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange:
  74         return PixelRange::Video;
  75     case kCVPixelFormatType_420YpCbCr8PlanarFullRange:
  76     case kCVPixelFormatType_420YpCbCr8BiPlanarFullRange:
  77     case kCVPixelFormatType_422YpCbCr8FullRange:
  78     case kCVPixelFormatType_ARGB2101010LEPacked:
  79     case kCVPixelFormatType_420YpCbCr10BiPlanarFullRange:
  80     case kCVPixelFormatType_422YpCbCr10BiPlanarFullRange:
  81     case kCVPixelFormatType_444YpCbCr10BiPlanarFullRange:
  82         return PixelRange::Full;
  83     default:
  84         return PixelRange::Unknown;
  85     }
  86 }
  87 
<span class="line-modified">  88 static TransferFunction transferFunctionFromString(CFStringRef string)</span>
  89 {
  90     if (!string || CFGetTypeID(string) != CFStringGetTypeID())
<span class="line-modified">  91         return TransferFunction::Unknown;</span>
  92     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_709_2))
<span class="line-modified">  93         return TransferFunction::kITU_R_709_2;</span>
  94     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_601_4))
<span class="line-modified">  95         return TransferFunction::kITU_R_601_4;</span>
  96     if (CFEqual(string, kCVImageBufferYCbCrMatrix_SMPTE_240M_1995))
<span class="line-modified">  97         return TransferFunction::kSMPTE_240M_1995;</span>
  98     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_DCI_P3() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_DCI_P3))
<span class="line-modified">  99         return TransferFunction::kDCI_P3;</span>
 100     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_P3_D65() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_P3_D65))
<span class="line-modified"> 101         return TransferFunction::kP3_D65;</span>
 102     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_ITU_R_2020() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_2020))
<span class="line-modified"> 103         return TransferFunction::kITU_R_2020;</span>
<span class="line-modified"> 104     return TransferFunction::Unknown;</span>
 105 }
 106 
 107 struct GLfloatColor {
 108     union {
 109         struct {
 110             GLfloat r;
 111             GLfloat g;
 112             GLfloat b;
 113         } rgb;
 114         struct {
 115             GLfloat y;
 116             GLfloat cb;
 117             GLfloat cr;
 118         } ycbcr;
 119     };
 120 
 121     constexpr GLfloatColor(GLfloat r, GLfloat g, GLfloat b)
 122         : rgb { r, g, b }
 123     {
 124     }
</pre>
<hr />
<pre>
 219         auto&amp; x = row[0];
 220         auto&amp; y = row[1];
 221         auto&amp; z = row[2];
 222         auto&amp; w = row[3];
 223 
 224         w -= (y + z) * 128 / 255;
 225         if (range == PixelRange::Video)
 226             w -= x * 16 / 255;
 227     }
 228 }
 229 
 230 constexpr GLfloatColor YCbCrMatrix::operator*(const GLfloatColor&amp; color) const
 231 {
 232     return GLfloatColor(
 233         rows[0][0] * color.rgb.r + rows[0][1] * color.rgb.g + rows[0][2] * color.rgb.b + rows[0][3],
 234         rows[1][0] * color.rgb.r + rows[1][1] * color.rgb.g + rows[1][2] * color.rgb.b + rows[1][3],
 235         rows[2][0] * color.rgb.r + rows[2][1] * color.rgb.g + rows[2][2] * color.rgb.b + rows[2][3]
 236     );
 237 }
 238 
<span class="line-modified"> 239 static const Vector&lt;GLfloat&gt; YCbCrToRGBMatrixForRangeAndTransferFunction(PixelRange range, TransferFunction transferFunction)</span>
 240 {
<span class="line-modified"> 241     using MapKey = std::pair&lt;PixelRange, TransferFunction&gt;;</span>
 242     using MatrixMap = StdMap&lt;MapKey, Vector&lt;GLfloat&gt;&gt;;
 243 
 244     static NeverDestroyed&lt;MatrixMap&gt; matrices;
 245     static dispatch_once_t onceToken;
 246 
 247     // Matrices are derived from the components in the ITU R.601 rev 4 specification
 248     // https://www.itu.int/rec/R-REC-BT.601
 249     constexpr static YCbCrMatrix r601VideoMatrix { PixelRange::Video, 0.114f, 0.299f };
 250     constexpr static YCbCrMatrix r601FullMatrix { PixelRange::Full, 0.114f, 0.299f };
 251 
 252     static_assert((r601VideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.610 video matrix does not produce black color&quot;);
 253     static_assert((r601VideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.610 video matrix does not produce white color&quot;);
 254     static_assert((r601VideoMatrix * GLfloatColor(81,  90,  240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.610 video matrix does not produce red color&quot;);
 255     static_assert((r601VideoMatrix * GLfloatColor(145, 54,  34,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.610 video matrix does not produce green color&quot;);
 256     static_assert((r601VideoMatrix * GLfloatColor(41,  240, 110, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.610 video matrix does not produce blue color&quot;);
 257     static_assert((r601VideoMatrix * GLfloatColor(210, 16,  146, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.610 video matrix does not produce yellow color&quot;);
 258     static_assert((r601VideoMatrix * GLfloatColor(106, 202, 222, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.610 video matrix does not produce magenta color&quot;);
 259     static_assert((r601VideoMatrix * GLfloatColor(170, 166, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.610 video matrix does not produce cyan color&quot;);
 260 
 261     static_assert((r601FullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.610 full matrix does not produce black color&quot;);
</pre>
<hr />
<pre>
 320 
 321     static_assert((smpte240MVideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce black color&quot;);
 322     static_assert((smpte240MVideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce white color&quot;);
 323     static_assert((smpte240MVideoMatrix * GLfloatColor(62,  102, 240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce red color&quot;);
 324     static_assert((smpte240MVideoMatrix * GLfloatColor(170, 42,  28,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce green color&quot;);
 325     static_assert((smpte240MVideoMatrix * GLfloatColor(35,  240, 116, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce blue color&quot;);
 326     static_assert((smpte240MVideoMatrix * GLfloatColor(216, 16,  140, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce yellow color&quot;);
 327     static_assert((smpte240MVideoMatrix * GLfloatColor(81,  214, 228, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce magenta color&quot;);
 328     static_assert((smpte240MVideoMatrix * GLfloatColor(189, 154, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce cyan color&quot;);
 329 
 330     static_assert((smpte240MFullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce black color&quot;);
 331     static_assert((smpte240MFullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce white color&quot;);
 332     static_assert((smpte240MFullMatrix * GLfloatColor(54,  98,  256, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce red color&quot;);
 333     static_assert((smpte240MFullMatrix * GLfloatColor(179, 30,  15,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce green color&quot;);
 334     static_assert((smpte240MFullMatrix * GLfloatColor(22,  256, 114, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce blue color&quot;);
 335     static_assert((smpte240MFullMatrix * GLfloatColor(233, 1,   142, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce yellow color&quot;);
 336     static_assert((smpte240MFullMatrix * GLfloatColor(76,  226, 241, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce magenta color&quot;);
 337     static_assert((smpte240MFullMatrix * GLfloatColor(201, 158, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce cyan color&quot;);
 338 
 339     dispatch_once(&amp;onceToken, ^{
<span class="line-modified"> 340         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kITU_R_601_4), r601VideoMatrix);</span>
<span class="line-modified"> 341         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kITU_R_601_4), r601FullMatrix);</span>
<span class="line-modified"> 342         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kITU_R_709_2), r709VideoMatrix);</span>
<span class="line-modified"> 343         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kITU_R_709_2), r709FullMatrix);</span>
<span class="line-modified"> 344         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kITU_R_2020), bt2020VideoMatrix);</span>
<span class="line-modified"> 345         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kITU_R_2020), bt2020FullMatrix);</span>
<span class="line-modified"> 346         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kSMPTE_240M_1995), smpte240MVideoMatrix);</span>
<span class="line-modified"> 347         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kSMPTE_240M_1995), smpte240MFullMatrix);</span>
 348     });
 349 
 350     // We should never be asked to handle a Pixel Format whose range value is unknown.
 351     ASSERT(range != PixelRange::Unknown);
 352     if (range == PixelRange::Unknown)
 353         range = PixelRange::Full;
 354 
 355     auto iterator = matrices.get().find({range, transferFunction});
 356 
 357     // Assume unknown transfer functions are r.601:
 358     if (iterator == matrices.get().end())
<span class="line-modified"> 359         iterator = matrices.get().find({range, TransferFunction::kITU_R_601_4});</span>
 360 
 361     ASSERT(iterator != matrices.get().end());
 362     return iterator-&gt;second;
 363 }
 364 #endif // HAVE(IOSURFACE)
 365 
<span class="line-modified"> 366 VideoTextureCopierCV::VideoTextureCopierCV(GraphicsContext3D&amp; context)</span>
 367     : m_sharedContext(context)
<span class="line-modified"> 368     , m_context(GraphicsContext3D::createShared(context))</span>
 369     , m_framebuffer(context.createFramebuffer())
 370 {
 371 }
 372 
 373 VideoTextureCopierCV::~VideoTextureCopierCV()
 374 {
 375     if (m_vertexBuffer)
 376         m_context-&gt;deleteProgram(m_vertexBuffer);
 377     if (m_program)
 378         m_context-&gt;deleteProgram(m_program);
 379     if (m_yuvVertexBuffer)
 380         m_context-&gt;deleteProgram(m_yuvVertexBuffer);
 381     if (m_yuvProgram)
 382         m_context-&gt;deleteProgram(m_yuvProgram);
 383     m_context-&gt;deleteFramebuffer(m_framebuffer);
 384 }
 385 
 386 #if !LOG_DISABLED
 387 using StringMap = StdMap&lt;uint32_t, const char*&gt;;
 388 #define STRINGIFY_PAIR(e) e, #e
 389 static StringMap&amp; enumToStringMap()
 390 {
 391     static NeverDestroyed&lt;StringMap&gt; map;
 392     if (map.get().empty()) {
 393         StringMap stringMap;
<span class="line-modified"> 394         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB));</span>
<span class="line-modified"> 395         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA));</span>
<span class="line-modified"> 396         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE_ALPHA));</span>
<span class="line-modified"> 397         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE));</span>
<span class="line-modified"> 398         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::ALPHA));</span>
<span class="line-modified"> 399         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R8));</span>
<span class="line-modified"> 400         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R16F));</span>
<span class="line-modified"> 401         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R32F));</span>
<span class="line-modified"> 402         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R8UI));</span>
<span class="line-modified"> 403         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R8I));</span>
<span class="line-modified"> 404         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R16UI));</span>
<span class="line-modified"> 405         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R16I));</span>
<span class="line-modified"> 406         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R32UI));</span>
<span class="line-modified"> 407         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R32I));</span>
<span class="line-modified"> 408         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG8));</span>
<span class="line-modified"> 409         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG16F));</span>
<span class="line-modified"> 410         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG32F));</span>
<span class="line-modified"> 411         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG8UI));</span>
<span class="line-modified"> 412         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG8I));</span>
<span class="line-modified"> 413         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG16UI));</span>
<span class="line-modified"> 414         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG16I));</span>
<span class="line-modified"> 415         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG32UI));</span>
<span class="line-modified"> 416         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG32I));</span>
<span class="line-modified"> 417         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB8));</span>
<span class="line-modified"> 418         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::SRGB8));</span>
<span class="line-modified"> 419         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA8));</span>
<span class="line-modified"> 420         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::SRGB8_ALPHA8));</span>
<span class="line-modified"> 421         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA4));</span>
<span class="line-modified"> 422         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB10_A2));</span>
<span class="line-modified"> 423         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_COMPONENT16));</span>
<span class="line-modified"> 424         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_COMPONENT24));</span>
<span class="line-modified"> 425         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_COMPONENT32F));</span>
<span class="line-modified"> 426         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH24_STENCIL8));</span>
<span class="line-modified"> 427         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH32F_STENCIL8));</span>
<span class="line-modified"> 428         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB));</span>
<span class="line-modified"> 429         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA));</span>
<span class="line-modified"> 430         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE_ALPHA));</span>
<span class="line-modified"> 431         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE));</span>
<span class="line-modified"> 432         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::ALPHA));</span>
<span class="line-modified"> 433         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RED));</span>
<span class="line-modified"> 434         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG_INTEGER));</span>
<span class="line-modified"> 435         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_STENCIL));</span>
<span class="line-modified"> 436         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_BYTE));</span>
<span class="line-modified"> 437         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT_5_6_5));</span>
<span class="line-modified"> 438         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4));</span>
<span class="line-modified"> 439         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1));</span>
<span class="line-modified"> 440         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::BYTE));</span>
<span class="line-modified"> 441         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::HALF_FLOAT));</span>
<span class="line-modified"> 442         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::FLOAT));</span>
<span class="line-modified"> 443         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT));</span>
<span class="line-modified"> 444         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::SHORT));</span>
<span class="line-modified"> 445         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_INT));</span>
<span class="line-modified"> 446         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::INT));</span>
<span class="line-modified"> 447         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV));</span>
<span class="line-modified"> 448         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_INT_24_8));</span>
<span class="line-modified"> 449         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV));</span>
 450 
 451 #if USE(OPENGL_ES)
 452         map.get().emplace(STRINGIFY_PAIR(GL_RED_INTEGER));
 453         map.get().emplace(STRINGIFY_PAIR(GL_RGB_INTEGER));
 454         map.get().emplace(STRINGIFY_PAIR(GL_RG8_SNORM));
 455         map.get().emplace(STRINGIFY_PAIR(GL_RGB565));
 456         map.get().emplace(STRINGIFY_PAIR(GL_RGB8_SNORM));
 457         map.get().emplace(STRINGIFY_PAIR(GL_R11F_G11F_B10F));
 458         map.get().emplace(STRINGIFY_PAIR(GL_RGB9_E5));
 459         map.get().emplace(STRINGIFY_PAIR(GL_RGB16F));
 460         map.get().emplace(STRINGIFY_PAIR(GL_RGB32F));
 461         map.get().emplace(STRINGIFY_PAIR(GL_RGB8UI));
 462         map.get().emplace(STRINGIFY_PAIR(GL_RGB8I));
 463         map.get().emplace(STRINGIFY_PAIR(GL_RGB16UI));
 464         map.get().emplace(STRINGIFY_PAIR(GL_RGB16I));
 465         map.get().emplace(STRINGIFY_PAIR(GL_RGB32UI));
 466         map.get().emplace(STRINGIFY_PAIR(GL_RGB32I));
 467         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8_SNORM));
 468         map.get().emplace(STRINGIFY_PAIR(GL_RGBA16F));
 469         map.get().emplace(STRINGIFY_PAIR(GL_RGBA32F));
</pre>
<hr />
<pre>
 484     }
 485     return map.get();
 486 }
 487 
 488 #endif
 489 
 490 bool VideoTextureCopierCV::initializeContextObjects()
 491 {
 492     StringBuilder vertexShaderSource;
 493     vertexShaderSource.appendLiteral(&quot;attribute vec4 a_position;\n&quot;);
 494     vertexShaderSource.appendLiteral(&quot;uniform int u_flipY;\n&quot;);
 495     vertexShaderSource.appendLiteral(&quot;varying vec2 v_texturePosition;\n&quot;);
 496     vertexShaderSource.appendLiteral(&quot;void main() {\n&quot;);
 497     vertexShaderSource.appendLiteral(&quot;    v_texturePosition = vec2((a_position.x + 1.0) / 2.0, (a_position.y + 1.0) / 2.0);\n&quot;);
 498     vertexShaderSource.appendLiteral(&quot;    if (u_flipY == 1) {\n&quot;);
 499     vertexShaderSource.appendLiteral(&quot;        v_texturePosition.y = 1.0 - v_texturePosition.y;\n&quot;);
 500     vertexShaderSource.appendLiteral(&quot;    }\n&quot;);
 501     vertexShaderSource.appendLiteral(&quot;    gl_Position = a_position;\n&quot;);
 502     vertexShaderSource.appendLiteral(&quot;}\n&quot;);
 503 
<span class="line-modified"> 504     Platform3DObject vertexShader = m_context-&gt;createShader(GraphicsContext3D::VERTEX_SHADER);</span>
 505     m_context-&gt;shaderSource(vertexShader, vertexShaderSource.toString());
 506     m_context-&gt;compileShaderDirect(vertexShader);
 507 
<span class="line-modified"> 508     GC3Dint value = 0;</span>
<span class="line-modified"> 509     m_context-&gt;getShaderiv(vertexShader, GraphicsContext3D::COMPILE_STATUS, &amp;value);</span>
 510     if (!value) {
 511         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Vertex shader failed to compile.&quot;, this);
 512         m_context-&gt;deleteShader(vertexShader);
 513         return false;
 514     }
 515 
 516     StringBuilder fragmentShaderSource;
 517 
<span class="line-modified"> 518 #if USE(OPENGL_ES)</span>
 519     fragmentShaderSource.appendLiteral(&quot;precision mediump float;\n&quot;);


 520     fragmentShaderSource.appendLiteral(&quot;uniform sampler2D u_texture;\n&quot;);
<span class="line-modified"> 521 #elif USE(OPENGL)</span>
 522     fragmentShaderSource.appendLiteral(&quot;uniform sampler2DRect u_texture;\n&quot;);
<span class="line-removed"> 523 #elif USE(ANGLE)</span>
<span class="line-removed"> 524     // FIXME: determine how to access rectangular textures via ANGLE.</span>
<span class="line-removed"> 525     ASSERT_NOT_REACHED();</span>
 526 #else
 527 #error Unsupported configuration
 528 #endif
 529     fragmentShaderSource.appendLiteral(&quot;varying vec2 v_texturePosition;\n&quot;);
 530     fragmentShaderSource.appendLiteral(&quot;uniform int u_premultiply;\n&quot;);
 531     fragmentShaderSource.appendLiteral(&quot;uniform vec2 u_textureDimensions;\n&quot;);
 532     fragmentShaderSource.appendLiteral(&quot;uniform int u_swapColorChannels;\n&quot;);
 533     fragmentShaderSource.appendLiteral(&quot;void main() {\n&quot;);
 534     fragmentShaderSource.appendLiteral(&quot;    vec2 texPos = vec2(v_texturePosition.x * u_textureDimensions.x, v_texturePosition.y * u_textureDimensions.y);\n&quot;);
<span class="line-modified"> 535 #if USE(OPENGL_ES)</span>
 536     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2D(u_texture, texPos);\n&quot;);
<span class="line-modified"> 537 #elif USE(OPENGL)</span>
 538     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2DRect(u_texture, texPos);\n&quot;);
<span class="line-removed"> 539 #elif USE(ANGLE)</span>
<span class="line-removed"> 540     // FIXME: determine how to access rectangular textures via ANGLE.</span>
<span class="line-removed"> 541     ASSERT_NOT_REACHED();</span>
 542 #else
 543 #error Unsupported configuration
 544 #endif
 545     fragmentShaderSource.appendLiteral(&quot;    if (u_swapColorChannels == 1) {\n&quot;);
 546     fragmentShaderSource.appendLiteral(&quot;        color.rgba = color.bgra;\n&quot;);
 547     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
 548     fragmentShaderSource.appendLiteral(&quot;    if (u_premultiply == 1) {\n&quot;);
 549     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = vec4(color.r * color.a, color.g * color.a, color.b * color.a, color.a);\n&quot;);
 550     fragmentShaderSource.appendLiteral(&quot;    } else {\n&quot;);
 551     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = color;\n&quot;);
 552     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
 553     fragmentShaderSource.appendLiteral(&quot;}\n&quot;);
 554 
<span class="line-modified"> 555     Platform3DObject fragmentShader = m_context-&gt;createShader(GraphicsContext3D::FRAGMENT_SHADER);</span>
 556     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource.toString());
 557     m_context-&gt;compileShaderDirect(fragmentShader);
 558 
<span class="line-modified"> 559     m_context-&gt;getShaderiv(fragmentShader, GraphicsContext3D::COMPILE_STATUS, &amp;value);</span>
 560     if (!value) {
 561         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Fragment shader failed to compile.&quot;, this);
 562         m_context-&gt;deleteShader(vertexShader);
 563         m_context-&gt;deleteShader(fragmentShader);
 564         return false;
 565     }
 566 
 567     m_program = m_context-&gt;createProgram();
 568     m_context-&gt;attachShader(m_program, vertexShader);
 569     m_context-&gt;attachShader(m_program, fragmentShader);
 570     m_context-&gt;linkProgram(m_program);
 571 
<span class="line-modified"> 572     m_context-&gt;getProgramiv(m_program, GraphicsContext3D::LINK_STATUS, &amp;value);</span>
 573     if (!value) {
 574         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Program failed to link.&quot;, this);
 575         m_context-&gt;deleteShader(vertexShader);
 576         m_context-&gt;deleteShader(fragmentShader);
 577         m_context-&gt;deleteProgram(m_program);
 578         m_program = 0;
 579         return false;
 580     }
 581 
 582     m_textureUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_texture&quot;_s);
 583     m_textureDimensionsUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_textureDimensions&quot;_s);
 584     m_flipYUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_flipY&quot;_s);
 585     m_swapColorChannelsUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_swapColorChannels&quot;_s);
 586     m_premultiplyUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_premultiply&quot;_s);
 587     m_positionAttributeLocation = m_context-&gt;getAttribLocationDirect(m_program, &quot;a_position&quot;_s);
 588 
 589     m_context-&gt;detachShader(m_program, vertexShader);
 590     m_context-&gt;detachShader(m_program, fragmentShader);
 591     m_context-&gt;deleteShader(vertexShader);
 592     m_context-&gt;deleteShader(fragmentShader);
 593 
 594     LOG(WebGL, &quot;Uniform and Attribute locations: u_texture = %d, u_textureDimensions = %d, u_flipY = %d, u_premultiply = %d, a_position = %d&quot;, m_textureUniformLocation, m_textureDimensionsUniformLocation, m_flipYUniformLocation, m_premultiplyUniformLocation, m_positionAttributeLocation);
 595     m_context-&gt;enableVertexAttribArray(m_positionAttributeLocation);
 596 
 597     m_vertexBuffer = m_context-&gt;createBuffer();
 598     float vertices[12] = { -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1 };
 599 
<span class="line-modified"> 600     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexBuffer);</span>
<span class="line-modified"> 601     m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, sizeof(float) * 12, vertices, GraphicsContext3D::STATIC_DRAW);</span>
 602 
 603     return true;
 604 }
 605 
 606 bool VideoTextureCopierCV::initializeUVContextObjects()
 607 {
 608     String vertexShaderSource {
 609         &quot;attribute vec2 a_position;\n&quot;
 610         &quot;uniform vec2 u_yTextureSize;\n&quot;
 611         &quot;uniform vec2 u_uvTextureSize;\n&quot;
 612         &quot;uniform int u_flipY;\n&quot;
 613         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
 614         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
 615         &quot;void main() {\n&quot;
 616         &quot;   gl_Position = vec4(a_position, 0, 1.0);\n&quot;
 617         &quot;   vec2 normalizedPosition = a_position * .5 + .5;\n&quot;
 618         &quot;   if (u_flipY == 1) {\n&quot;
 619         &quot;       normalizedPosition.y = 1.0 - normalizedPosition.y;\n&quot;
 620         &quot;   }\n&quot;
<span class="line-modified"> 621 #if USE(OPENGL_ES)</span>
 622         &quot;   v_yTextureCoordinate = normalizedPosition;\n&quot;
 623         &quot;   v_uvTextureCoordinate = normalizedPosition;\n&quot;
<span class="line-modified"> 624 #elif USE(OPENGL)</span>
 625         &quot;   v_yTextureCoordinate = normalizedPosition * u_yTextureSize;\n&quot;
 626         &quot;   v_uvTextureCoordinate = normalizedPosition * u_uvTextureSize;\n&quot;
<span class="line-removed"> 627 #elif USE(ANGLE)</span>
<span class="line-removed"> 628         // FIXME: determine how to access rectangular textures via ANGLE.</span>
 629 #else
 630 #error Unsupported configuration
 631 #endif
 632         &quot;}\n&quot;_s
 633     };
 634 
<span class="line-modified"> 635     Platform3DObject vertexShader = m_context-&gt;createShader(GraphicsContext3D::VERTEX_SHADER);</span>
 636     m_context-&gt;shaderSource(vertexShader, vertexShaderSource);
 637     m_context-&gt;compileShaderDirect(vertexShader);
 638 
<span class="line-modified"> 639     GC3Dint status = 0;</span>
<span class="line-modified"> 640     m_context-&gt;getShaderiv(vertexShader, GraphicsContext3D::COMPILE_STATUS, &amp;status);</span>
 641     if (!status) {
 642         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Vertex shader failed to compile.&quot;, this);
 643         m_context-&gt;deleteShader(vertexShader);
 644         return false;
 645     }
 646 
 647     String fragmentShaderSource {
<span class="line-modified"> 648 #if USE(OPENGL_ES)</span>
 649         &quot;precision mediump float;\n&quot;


 650         &quot;#define SAMPLERTYPE sampler2D\n&quot;
 651         &quot;#define TEXTUREFUNC texture2D\n&quot;
<span class="line-modified"> 652 #elif USE(OPENGL)</span>
 653         &quot;#define SAMPLERTYPE sampler2DRect\n&quot;
 654         &quot;#define TEXTUREFUNC texture2DRect\n&quot;
<span class="line-removed"> 655 #elif USE(ANGLE)</span>
<span class="line-removed"> 656         // FIXME: determine how to access rectangular textures via ANGLE.</span>
 657 #else
 658 #error Unsupported configuration
 659 #endif
 660         &quot;uniform SAMPLERTYPE u_yTexture;\n&quot;
 661         &quot;uniform SAMPLERTYPE u_uvTexture;\n&quot;
 662         &quot;uniform mat4 u_colorMatrix;\n&quot;
 663         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
 664         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
 665         &quot;void main() {\n&quot;
 666         &quot;    vec4 yuv;\n&quot;
 667         &quot;    yuv.r = TEXTUREFUNC(u_yTexture, v_yTextureCoordinate).r;\n&quot;
 668         &quot;    yuv.gb = TEXTUREFUNC(u_uvTexture, v_uvTextureCoordinate).rg;\n&quot;
 669         &quot;    yuv.a = 1.0;\n&quot;
 670         &quot;    gl_FragColor = yuv * u_colorMatrix;\n&quot;
 671         &quot;}\n&quot;_s
 672     };
 673 
<span class="line-modified"> 674     Platform3DObject fragmentShader = m_context-&gt;createShader(GraphicsContext3D::FRAGMENT_SHADER);</span>
 675     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource);
 676     m_context-&gt;compileShaderDirect(fragmentShader);
 677 
<span class="line-modified"> 678     m_context-&gt;getShaderiv(fragmentShader, GraphicsContext3D::COMPILE_STATUS, &amp;status);</span>
 679     if (!status) {
 680         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Fragment shader failed to compile.&quot;, this);
 681         m_context-&gt;deleteShader(vertexShader);
 682         m_context-&gt;deleteShader(fragmentShader);
 683         return false;
 684     }
 685 
 686     m_yuvProgram = m_context-&gt;createProgram();
 687     m_context-&gt;attachShader(m_yuvProgram, vertexShader);
 688     m_context-&gt;attachShader(m_yuvProgram, fragmentShader);
 689     m_context-&gt;linkProgram(m_yuvProgram);
 690 
<span class="line-modified"> 691     m_context-&gt;getProgramiv(m_yuvProgram, GraphicsContext3D::LINK_STATUS, &amp;status);</span>
 692     if (!status) {
 693         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Program failed to link.&quot;, this);
 694         m_context-&gt;deleteShader(vertexShader);
 695         m_context-&gt;deleteShader(fragmentShader);
 696         m_context-&gt;deleteProgram(m_yuvProgram);
 697         m_yuvProgram = 0;
 698         return false;
 699     }
 700 
 701     m_yTextureUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_yTexture&quot;_s);
 702     m_uvTextureUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_uvTexture&quot;_s);
 703     m_colorMatrixUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_colorMatrix&quot;_s);
 704     m_yuvFlipYUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_flipY&quot;_s);
 705     m_yTextureSizeUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_yTextureSize&quot;_s);
 706     m_uvTextureSizeUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_uvTextureSize&quot;_s);
 707     m_yuvPositionAttributeLocation = m_context-&gt;getAttribLocationDirect(m_yuvProgram, &quot;a_position&quot;_s);
 708 
 709     m_context-&gt;detachShader(m_yuvProgram, vertexShader);
 710     m_context-&gt;detachShader(m_yuvProgram, fragmentShader);
 711     m_context-&gt;deleteShader(vertexShader);
 712     m_context-&gt;deleteShader(fragmentShader);
 713 
 714     m_yuvVertexBuffer = m_context-&gt;createBuffer();
 715     float vertices[12] = { -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1 };
 716 
<span class="line-modified"> 717     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_yuvVertexBuffer);</span>
<span class="line-modified"> 718     m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, sizeof(vertices), vertices, GraphicsContext3D::STATIC_DRAW);</span>
 719     m_context-&gt;enableVertexAttribArray(m_yuvPositionAttributeLocation);
<span class="line-modified"> 720     m_context-&gt;vertexAttribPointer(m_yuvPositionAttributeLocation, 2, GraphicsContext3D::FLOAT, false, 0, 0);</span>
 721 
 722     return true;
 723 }
 724 
<span class="line-modified"> 725 bool VideoTextureCopierCV::copyImageToPlatformTexture(CVPixelBufferRef image, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY)</span>

















































 726 {






 727     if (!m_textureCache) {
 728         m_textureCache = TextureCacheCV::create(m_context);
 729         if (!m_textureCache)
 730             return false;
 731     }
 732 
 733     if (auto texture = m_textureCache-&gt;textureFromImage(image, outputTarget, level, internalFormat, format, type)) {
 734         bool swapColorChannels = false;
 735 #if USE(OPENGL_ES)
 736         // FIXME: Remove this workaround once rdar://problem/35834388 is fixed.
 737         swapColorChannels = CVPixelBufferGetPixelFormatType(image) == kCVPixelFormatType_32BGRA;
 738 #endif
 739         return copyVideoTextureToPlatformTexture(texture.get(), width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
 740     }

 741 
 742 #if HAVE(IOSURFACE)
 743     // FIXME: This currently only supports &#39;420v&#39; and &#39;420f&#39; pixel formats. Investigate supporting more pixel formats.
 744     OSType pixelFormat = CVPixelBufferGetPixelFormatType(image);
 745     if (pixelFormat != kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange &amp;&amp; pixelFormat != kCVPixelFormatType_420YpCbCr8BiPlanarFullRange) {
 746         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Asked to copy an unsupported pixel format (&#39;%s&#39;).&quot;, this, FourCC(pixelFormat).toString().utf8().data());
 747         return false;
 748     }
 749 
 750     IOSurfaceRef surface = CVPixelBufferGetIOSurface(image);
 751     if (!surface)
 752         return false;
 753 
 754     auto newSurfaceSeed = IOSurfaceGetSeed(surface);
 755     if (flipY == m_lastFlipY
 756         &amp;&amp; surface == m_lastSurface
 757         &amp;&amp; newSurfaceSeed == m_lastSurfaceSeed
 758         &amp;&amp; lastTextureSeed(outputTexture) == m_context-&gt;textureSeed(outputTexture)) {
 759         // If the texture hasn&#39;t been modified since the last time we copied to it, and the
 760         // image hasn&#39;t been modified since the last time it was copied, this is a no-op.
 761         return true;
 762     }
 763 
 764     if (!m_yuvProgram) {
 765         if (!initializeUVContextObjects()) {
 766             LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
 767             return false;
 768         }
 769     }
 770 
<span class="line-modified"> 771     m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebuffer);</span>
 772 
 773     // Allocate memory for the output texture.
<span class="line-modified"> 774     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, outputTexture);</span>
<span class="line-modified"> 775     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="line-modified"> 776     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="line-modified"> 777     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 778     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 779     m_context-&gt;texImage2DDirect(GraphicsContext3D::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);</span>
<span class="line-modified"> 780 </span>
<span class="line-modified"> 781     m_context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0, GraphicsContext3D::TEXTURE_2D, outputTexture, level);</span>
<span class="line-modified"> 782     GC3Denum status = m_context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER);</span>
<span class="line-modified"> 783     if (status != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
 784         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
 785         return false;
 786     }
 787 
 788     m_context-&gt;useProgram(m_yuvProgram);
 789     m_context-&gt;viewport(0, 0, width, height);
 790 
 791     // Bind and set up the textures for the video source.
 792     auto yPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 0);
 793     auto yPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 0);
 794     auto uvPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 1);
 795     auto uvPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 1);
 796 
 797 #if USE(OPENGL_ES)
<span class="line-modified"> 798     GC3Denum videoTextureTarget = GraphicsContext3D::TEXTURE_2D;</span>
 799 #elif USE(OPENGL)
<span class="line-modified"> 800     GC3Denum videoTextureTarget = GL_TEXTURE_RECTANGLE_ARB;</span>
 801 #elif USE(ANGLE)
<span class="line-modified"> 802     // FIXME: determine how to access rectangular textures via ANGLE.</span>
<span class="line-removed"> 803     GC3Denum videoTextureTarget = GraphicsContext3D::TEXTURE_2D;</span>
 804 #else
 805 #error Unsupported configuration
 806 #endif
 807     auto uvTexture = m_context-&gt;createTexture();
<span class="line-modified"> 808     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE1);</span>
 809     m_context-&gt;bindTexture(videoTextureTarget, uvTexture);
<span class="line-modified"> 810     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="line-modified"> 811     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="line-modified"> 812     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 813     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 814     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContext3D::RG, uvPlaneWidth, uvPlaneHeight, GraphicsContext3D::RG, GraphicsContext3D::UNSIGNED_BYTE, surface, 1)) {</span>


 815         m_context-&gt;deleteTexture(uvTexture);
 816         return false;
 817     }






 818 
 819     auto yTexture = m_context-&gt;createTexture();
<span class="line-modified"> 820     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE0);</span>
 821     m_context-&gt;bindTexture(videoTextureTarget, yTexture);
<span class="line-modified"> 822     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="line-modified"> 823     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="line-modified"> 824     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 825     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 826     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContext3D::LUMINANCE, yPlaneWidth, yPlaneHeight, GraphicsContext3D::LUMINANCE, GraphicsContext3D::UNSIGNED_BYTE, surface, 0)) {</span>








 827         m_context-&gt;deleteTexture(yTexture);
 828         m_context-&gt;deleteTexture(uvTexture);
 829         return false;
 830     }

 831 
 832     // Configure the drawing parameters.
 833     m_context-&gt;uniform1i(m_yTextureUniformLocation, 0);
 834     m_context-&gt;uniform1i(m_uvTextureUniformLocation, 1);
 835     m_context-&gt;uniform1i(m_yuvFlipYUniformLocation, flipY);
 836     m_context-&gt;uniform2f(m_yTextureSizeUniformLocation, yPlaneWidth, yPlaneHeight);
 837     m_context-&gt;uniform2f(m_uvTextureSizeUniformLocation, uvPlaneWidth, uvPlaneHeight);
 838 
 839     auto range = pixelRangeFromPixelFormat(pixelFormat);
 840     auto transferFunction = transferFunctionFromString((CFStringRef)CVBufferGetAttachment(image, kCVImageBufferYCbCrMatrixKey, nil));
 841     auto&amp; colorMatrix = YCbCrToRGBMatrixForRangeAndTransferFunction(range, transferFunction);
 842     m_context-&gt;uniformMatrix4fv(m_colorMatrixUniformLocation, 1, GL_FALSE, colorMatrix.data());
 843 
 844     // Do the actual drawing.
<span class="line-modified"> 845     m_context-&gt;drawArrays(GraphicsContext3D::TRIANGLES, 0, 6);</span>
 846 
<span class="line-modified"> 847 #if USE(OPENGL_ES)</span>
 848     // flush() must be called here in order to re-synchronize the output texture&#39;s contents across the
 849     // two EAGL contexts.
 850     m_context-&gt;flush();
 851 #endif
 852 
 853     // Clean-up.
 854     m_context-&gt;deleteTexture(yTexture);
 855     m_context-&gt;deleteTexture(uvTexture);




 856 
 857     m_lastSurface = surface;
 858     m_lastSurfaceSeed = newSurfaceSeed;
 859     m_lastTextureSeed.set(outputTexture, m_context-&gt;textureSeed(outputTexture));
 860     m_lastFlipY = flipY;
 861 
 862     return true;
 863 #else
 864     return false;
 865 #endif // HAVE(IOSURFACE)
 866 }
 867 
<span class="line-modified"> 868 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(TextureType inputVideoTexture, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)</span>
 869 {
 870     if (!inputVideoTexture)
 871         return false;
 872 
 873     GLfloat lowerLeft[2] = { 0, 0 };
 874     GLfloat lowerRight[2] = { 0, 0 };
 875     GLfloat upperRight[2] = { 0, 0 };
 876     GLfloat upperLeft[2] = { 0, 0 };



 877 #if USE(OPENGL_ES)
<span class="line-modified"> 878     Platform3DObject videoTextureName = CVOpenGLESTextureGetName(inputVideoTexture);</span>
<span class="line-modified"> 879     GC3Denum videoTextureTarget = CVOpenGLESTextureGetTarget(inputVideoTexture);</span>
 880     CVOpenGLESTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
 881 #elif USE(OPENGL)
<span class="line-modified"> 882     Platform3DObject videoTextureName = CVOpenGLTextureGetName(inputVideoTexture);</span>
<span class="line-modified"> 883     GC3Denum videoTextureTarget = CVOpenGLTextureGetTarget(inputVideoTexture);</span>
 884     CVOpenGLTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
 885 #elif USE(ANGLE)
<span class="line-modified"> 886     Platform3DObject videoTextureName = CVOpenGLTextureGetName(inputVideoTexture);</span>
<span class="line-modified"> 887     GC3Denum videoTextureTarget = CVOpenGLTextureGetTarget(inputVideoTexture);</span>
<span class="line-modified"> 888     CVOpenGLTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);</span>
















 889     // FIXME: determine how to access rectangular textures via ANGLE.
<span class="line-modified"> 890     ASSERT_NOT_REACHED();</span>

 891 #endif
 892 
 893     if (lowerLeft[1] &lt; upperRight[1])
 894         flipY = !flipY;
 895 
 896     return copyVideoTextureToPlatformTexture(videoTextureName, videoTextureTarget, width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
 897 }
 898 
<span class="line-modified"> 899 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(Platform3DObject videoTextureName, GC3Denum videoTextureTarget, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)</span>
 900 {
 901     LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - internalFormat: %s, format: %s, type: %s flipY: %s, premultiplyAlpha: %s&quot;, this, enumToStringMap()[internalFormat], enumToStringMap()[format], enumToStringMap()[type], flipY ? &quot;true&quot; : &quot;false&quot;, premultiplyAlpha ? &quot;true&quot; : &quot;false&quot;);
 902 
 903     if (!m_program) {
 904         if (!initializeContextObjects()) {
 905             LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
 906             return false;
 907         }
 908     }
 909 
<span class="line-modified"> 910     m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebuffer);</span>
 911 
 912     // Allocate memory for the output texture.
<span class="line-modified"> 913     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, outputTexture);</span>
<span class="line-modified"> 914     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="line-modified"> 915     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="line-modified"> 916     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 917     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 918     m_context-&gt;texImage2DDirect(GraphicsContext3D::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);</span>
<span class="line-modified"> 919 </span>
<span class="line-modified"> 920     m_context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0, GraphicsContext3D::TEXTURE_2D, outputTexture, level);</span>
<span class="line-modified"> 921     GC3Denum status = m_context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER);</span>
<span class="line-modified"> 922     if (status != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
 923         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
 924         return false;
 925     }
 926 
 927     m_context-&gt;useProgram(m_program);
 928     m_context-&gt;viewport(0, 0, width, height);
 929 
 930     // Bind and set up the texture for the video source.
<span class="line-modified"> 931     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE0);</span>
 932     m_context-&gt;bindTexture(videoTextureTarget, videoTextureName);
<span class="line-modified"> 933     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="line-modified"> 934     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="line-modified"> 935     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 936     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);</span>
 937 
 938     // Configure the drawing parameters.
 939     m_context-&gt;uniform1i(m_textureUniformLocation, 0);
 940 #if USE(OPENGL_ES)
 941     m_context-&gt;uniform2f(m_textureDimensionsUniformLocation, 1, 1);
 942 #else
 943     m_context-&gt;uniform2f(m_textureDimensionsUniformLocation, width, height);
 944 #endif
 945 
 946     m_context-&gt;uniform1i(m_flipYUniformLocation, flipY);
 947     m_context-&gt;uniform1i(m_swapColorChannelsUniformLocation, swapColorChannels);
 948     m_context-&gt;uniform1i(m_premultiplyUniformLocation, premultiplyAlpha);
 949 
 950     // Do the actual drawing.
 951     m_context-&gt;enableVertexAttribArray(m_positionAttributeLocation);
<span class="line-modified"> 952     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexBuffer);</span>
<span class="line-modified"> 953     m_context-&gt;vertexAttribPointer(m_positionAttributeLocation, 2, GraphicsContext3D::FLOAT, false, 0, 0);</span>
<span class="line-modified"> 954     m_context-&gt;drawArrays(GraphicsContext3D::TRIANGLES, 0, 6);</span>
 955 
 956 #if USE(OPENGL_ES)
 957     // flush() must be called here in order to re-synchronize the output texture&#39;s contents across the
 958     // two EAGL contexts.
 959     m_context-&gt;flush();
 960 #endif
 961 
 962     // Clean-up.
 963     m_context-&gt;bindTexture(videoTextureTarget, 0);
 964     m_context-&gt;bindTexture(outputTarget, outputTexture);
 965 
 966     return true;
 967 }
 968 
 969 }
 970 
 971 #endif // HAVE(CORE_VIDEO)
</pre>
</td>
<td>
<hr />
<pre>
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;VideoTextureCopierCV.h&quot;
  28 
  29 #if HAVE(CORE_VIDEO)
  30 
  31 #include &quot;FourCC.h&quot;
  32 #include &quot;Logging.h&quot;
  33 #include &quot;TextureCacheCV.h&quot;
  34 #include &lt;pal/spi/cocoa/IOSurfaceSPI.h&gt;
  35 #include &lt;wtf/NeverDestroyed.h&gt;
  36 #include &lt;wtf/StdMap.h&gt;
  37 #include &lt;wtf/text/StringBuilder.h&gt;
  38 
  39 #if USE(OPENGL_ES)
  40 #include &lt;OpenGLES/ES3/glext.h&gt;
  41 #endif
  42 
<span class="line-added">  43 #if USE(ANGLE)</span>
<span class="line-added">  44 #define EGL_EGL_PROTOTYPES 0</span>
<span class="line-added">  45 #include &lt;ANGLE/egl.h&gt;</span>
<span class="line-added">  46 #include &lt;ANGLE/eglext.h&gt;</span>
<span class="line-added">  47 #include &lt;ANGLE/eglext_angle.h&gt;</span>
<span class="line-added">  48 #include &lt;ANGLE/entry_points_egl.h&gt;</span>
<span class="line-added">  49 #include &lt;ANGLE/entry_points_gles_2_0_autogen.h&gt;</span>
<span class="line-added">  50 // Skip the inclusion of ANGLE&#39;s explicit context entry points for now.</span>
<span class="line-added">  51 #define GL_ANGLE_explicit_context</span>
<span class="line-added">  52 #include &lt;ANGLE/gl2ext.h&gt;</span>
<span class="line-added">  53 #include &lt;ANGLE/gl2ext_angle.h&gt;</span>
<span class="line-added">  54 #endif</span>
<span class="line-added">  55 </span>
  56 #include &quot;CoreVideoSoftLink.h&quot;
  57 
  58 namespace WebCore {
  59 
  60 #if HAVE(IOSURFACE)
  61 enum class PixelRange {
  62     Unknown,
  63     Video,
  64     Full,
  65 };
  66 
<span class="line-modified">  67 enum class TransferFunctionCV {</span>
  68     Unknown,
  69     kITU_R_709_2,
  70     kITU_R_601_4,
  71     kSMPTE_240M_1995,
  72     kDCI_P3,
  73     kP3_D65,
  74     kITU_R_2020,
  75 };
  76 
  77 static PixelRange pixelRangeFromPixelFormat(OSType pixelFormat)
  78 {
  79     switch (pixelFormat) {
  80     case kCVPixelFormatType_4444AYpCbCr8:
  81     case kCVPixelFormatType_4444AYpCbCr16:
  82     case kCVPixelFormatType_422YpCbCr_4A_8BiPlanar:
  83     case kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange:
  84     case kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange:
  85     case kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange:
  86     case kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange:
  87         return PixelRange::Video;
  88     case kCVPixelFormatType_420YpCbCr8PlanarFullRange:
  89     case kCVPixelFormatType_420YpCbCr8BiPlanarFullRange:
  90     case kCVPixelFormatType_422YpCbCr8FullRange:
  91     case kCVPixelFormatType_ARGB2101010LEPacked:
  92     case kCVPixelFormatType_420YpCbCr10BiPlanarFullRange:
  93     case kCVPixelFormatType_422YpCbCr10BiPlanarFullRange:
  94     case kCVPixelFormatType_444YpCbCr10BiPlanarFullRange:
  95         return PixelRange::Full;
  96     default:
  97         return PixelRange::Unknown;
  98     }
  99 }
 100 
<span class="line-modified"> 101 static TransferFunctionCV transferFunctionFromString(CFStringRef string)</span>
 102 {
 103     if (!string || CFGetTypeID(string) != CFStringGetTypeID())
<span class="line-modified"> 104         return TransferFunctionCV::Unknown;</span>
 105     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_709_2))
<span class="line-modified"> 106         return TransferFunctionCV::kITU_R_709_2;</span>
 107     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_601_4))
<span class="line-modified"> 108         return TransferFunctionCV::kITU_R_601_4;</span>
 109     if (CFEqual(string, kCVImageBufferYCbCrMatrix_SMPTE_240M_1995))
<span class="line-modified"> 110         return TransferFunctionCV::kSMPTE_240M_1995;</span>
 111     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_DCI_P3() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_DCI_P3))
<span class="line-modified"> 112         return TransferFunctionCV::kDCI_P3;</span>
 113     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_P3_D65() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_P3_D65))
<span class="line-modified"> 114         return TransferFunctionCV::kP3_D65;</span>
 115     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_ITU_R_2020() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_2020))
<span class="line-modified"> 116         return TransferFunctionCV::kITU_R_2020;</span>
<span class="line-modified"> 117     return TransferFunctionCV::Unknown;</span>
 118 }
 119 
 120 struct GLfloatColor {
 121     union {
 122         struct {
 123             GLfloat r;
 124             GLfloat g;
 125             GLfloat b;
 126         } rgb;
 127         struct {
 128             GLfloat y;
 129             GLfloat cb;
 130             GLfloat cr;
 131         } ycbcr;
 132     };
 133 
 134     constexpr GLfloatColor(GLfloat r, GLfloat g, GLfloat b)
 135         : rgb { r, g, b }
 136     {
 137     }
</pre>
<hr />
<pre>
 232         auto&amp; x = row[0];
 233         auto&amp; y = row[1];
 234         auto&amp; z = row[2];
 235         auto&amp; w = row[3];
 236 
 237         w -= (y + z) * 128 / 255;
 238         if (range == PixelRange::Video)
 239             w -= x * 16 / 255;
 240     }
 241 }
 242 
 243 constexpr GLfloatColor YCbCrMatrix::operator*(const GLfloatColor&amp; color) const
 244 {
 245     return GLfloatColor(
 246         rows[0][0] * color.rgb.r + rows[0][1] * color.rgb.g + rows[0][2] * color.rgb.b + rows[0][3],
 247         rows[1][0] * color.rgb.r + rows[1][1] * color.rgb.g + rows[1][2] * color.rgb.b + rows[1][3],
 248         rows[2][0] * color.rgb.r + rows[2][1] * color.rgb.g + rows[2][2] * color.rgb.b + rows[2][3]
 249     );
 250 }
 251 
<span class="line-modified"> 252 static const Vector&lt;GLfloat&gt; YCbCrToRGBMatrixForRangeAndTransferFunction(PixelRange range, TransferFunctionCV transferFunction)</span>
 253 {
<span class="line-modified"> 254     using MapKey = std::pair&lt;PixelRange, TransferFunctionCV&gt;;</span>
 255     using MatrixMap = StdMap&lt;MapKey, Vector&lt;GLfloat&gt;&gt;;
 256 
 257     static NeverDestroyed&lt;MatrixMap&gt; matrices;
 258     static dispatch_once_t onceToken;
 259 
 260     // Matrices are derived from the components in the ITU R.601 rev 4 specification
 261     // https://www.itu.int/rec/R-REC-BT.601
 262     constexpr static YCbCrMatrix r601VideoMatrix { PixelRange::Video, 0.114f, 0.299f };
 263     constexpr static YCbCrMatrix r601FullMatrix { PixelRange::Full, 0.114f, 0.299f };
 264 
 265     static_assert((r601VideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.610 video matrix does not produce black color&quot;);
 266     static_assert((r601VideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.610 video matrix does not produce white color&quot;);
 267     static_assert((r601VideoMatrix * GLfloatColor(81,  90,  240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.610 video matrix does not produce red color&quot;);
 268     static_assert((r601VideoMatrix * GLfloatColor(145, 54,  34,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.610 video matrix does not produce green color&quot;);
 269     static_assert((r601VideoMatrix * GLfloatColor(41,  240, 110, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.610 video matrix does not produce blue color&quot;);
 270     static_assert((r601VideoMatrix * GLfloatColor(210, 16,  146, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.610 video matrix does not produce yellow color&quot;);
 271     static_assert((r601VideoMatrix * GLfloatColor(106, 202, 222, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.610 video matrix does not produce magenta color&quot;);
 272     static_assert((r601VideoMatrix * GLfloatColor(170, 166, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.610 video matrix does not produce cyan color&quot;);
 273 
 274     static_assert((r601FullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.610 full matrix does not produce black color&quot;);
</pre>
<hr />
<pre>
 333 
 334     static_assert((smpte240MVideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce black color&quot;);
 335     static_assert((smpte240MVideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce white color&quot;);
 336     static_assert((smpte240MVideoMatrix * GLfloatColor(62,  102, 240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce red color&quot;);
 337     static_assert((smpte240MVideoMatrix * GLfloatColor(170, 42,  28,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce green color&quot;);
 338     static_assert((smpte240MVideoMatrix * GLfloatColor(35,  240, 116, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce blue color&quot;);
 339     static_assert((smpte240MVideoMatrix * GLfloatColor(216, 16,  140, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce yellow color&quot;);
 340     static_assert((smpte240MVideoMatrix * GLfloatColor(81,  214, 228, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce magenta color&quot;);
 341     static_assert((smpte240MVideoMatrix * GLfloatColor(189, 154, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce cyan color&quot;);
 342 
 343     static_assert((smpte240MFullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce black color&quot;);
 344     static_assert((smpte240MFullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce white color&quot;);
 345     static_assert((smpte240MFullMatrix * GLfloatColor(54,  98,  256, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce red color&quot;);
 346     static_assert((smpte240MFullMatrix * GLfloatColor(179, 30,  15,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce green color&quot;);
 347     static_assert((smpte240MFullMatrix * GLfloatColor(22,  256, 114, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce blue color&quot;);
 348     static_assert((smpte240MFullMatrix * GLfloatColor(233, 1,   142, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce yellow color&quot;);
 349     static_assert((smpte240MFullMatrix * GLfloatColor(76,  226, 241, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce magenta color&quot;);
 350     static_assert((smpte240MFullMatrix * GLfloatColor(201, 158, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce cyan color&quot;);
 351 
 352     dispatch_once(&amp;onceToken, ^{
<span class="line-modified"> 353         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunctionCV::kITU_R_601_4), r601VideoMatrix);</span>
<span class="line-modified"> 354         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunctionCV::kITU_R_601_4), r601FullMatrix);</span>
<span class="line-modified"> 355         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunctionCV::kITU_R_709_2), r709VideoMatrix);</span>
<span class="line-modified"> 356         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunctionCV::kITU_R_709_2), r709FullMatrix);</span>
<span class="line-modified"> 357         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunctionCV::kITU_R_2020), bt2020VideoMatrix);</span>
<span class="line-modified"> 358         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunctionCV::kITU_R_2020), bt2020FullMatrix);</span>
<span class="line-modified"> 359         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunctionCV::kSMPTE_240M_1995), smpte240MVideoMatrix);</span>
<span class="line-modified"> 360         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunctionCV::kSMPTE_240M_1995), smpte240MFullMatrix);</span>
 361     });
 362 
 363     // We should never be asked to handle a Pixel Format whose range value is unknown.
 364     ASSERT(range != PixelRange::Unknown);
 365     if (range == PixelRange::Unknown)
 366         range = PixelRange::Full;
 367 
 368     auto iterator = matrices.get().find({range, transferFunction});
 369 
 370     // Assume unknown transfer functions are r.601:
 371     if (iterator == matrices.get().end())
<span class="line-modified"> 372         iterator = matrices.get().find({range, TransferFunctionCV::kITU_R_601_4});</span>
 373 
 374     ASSERT(iterator != matrices.get().end());
 375     return iterator-&gt;second;
 376 }
 377 #endif // HAVE(IOSURFACE)
 378 
<span class="line-modified"> 379 VideoTextureCopierCV::VideoTextureCopierCV(GraphicsContextGLOpenGL&amp; context)</span>
 380     : m_sharedContext(context)
<span class="line-modified"> 381     , m_context(GraphicsContextGLOpenGL::createShared(context))</span>
 382     , m_framebuffer(context.createFramebuffer())
 383 {
 384 }
 385 
 386 VideoTextureCopierCV::~VideoTextureCopierCV()
 387 {
 388     if (m_vertexBuffer)
 389         m_context-&gt;deleteProgram(m_vertexBuffer);
 390     if (m_program)
 391         m_context-&gt;deleteProgram(m_program);
 392     if (m_yuvVertexBuffer)
 393         m_context-&gt;deleteProgram(m_yuvVertexBuffer);
 394     if (m_yuvProgram)
 395         m_context-&gt;deleteProgram(m_yuvProgram);
 396     m_context-&gt;deleteFramebuffer(m_framebuffer);
 397 }
 398 
 399 #if !LOG_DISABLED
 400 using StringMap = StdMap&lt;uint32_t, const char*&gt;;
 401 #define STRINGIFY_PAIR(e) e, #e
 402 static StringMap&amp; enumToStringMap()
 403 {
 404     static NeverDestroyed&lt;StringMap&gt; map;
 405     if (map.get().empty()) {
 406         StringMap stringMap;
<span class="line-modified"> 407         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGB));</span>
<span class="line-modified"> 408         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGBA));</span>
<span class="line-modified"> 409         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::LUMINANCE_ALPHA));</span>
<span class="line-modified"> 410         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::LUMINANCE));</span>
<span class="line-modified"> 411         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::ALPHA));</span>
<span class="line-modified"> 412         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R8));</span>
<span class="line-modified"> 413         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R16F));</span>
<span class="line-modified"> 414         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R32F));</span>
<span class="line-modified"> 415         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R8UI));</span>
<span class="line-modified"> 416         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R8I));</span>
<span class="line-modified"> 417         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R16UI));</span>
<span class="line-modified"> 418         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R16I));</span>
<span class="line-modified"> 419         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R32UI));</span>
<span class="line-modified"> 420         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R32I));</span>
<span class="line-modified"> 421         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG8));</span>
<span class="line-modified"> 422         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG16F));</span>
<span class="line-modified"> 423         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG32F));</span>
<span class="line-modified"> 424         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG8UI));</span>
<span class="line-modified"> 425         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG8I));</span>
<span class="line-modified"> 426         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG16UI));</span>
<span class="line-modified"> 427         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG16I));</span>
<span class="line-modified"> 428         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG32UI));</span>
<span class="line-modified"> 429         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG32I));</span>
<span class="line-modified"> 430         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGB8));</span>
<span class="line-modified"> 431         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::SRGB8));</span>
<span class="line-modified"> 432         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGBA8));</span>
<span class="line-modified"> 433         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::SRGB8_ALPHA8));</span>
<span class="line-modified"> 434         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGBA4));</span>
<span class="line-modified"> 435         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGB10_A2));</span>
<span class="line-modified"> 436         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH_COMPONENT16));</span>
<span class="line-modified"> 437         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH_COMPONENT24));</span>
<span class="line-modified"> 438         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH_COMPONENT32F));</span>
<span class="line-modified"> 439         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH24_STENCIL8));</span>
<span class="line-modified"> 440         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH32F_STENCIL8));</span>
<span class="line-modified"> 441         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGB));</span>
<span class="line-modified"> 442         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGBA));</span>
<span class="line-modified"> 443         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::LUMINANCE_ALPHA));</span>
<span class="line-modified"> 444         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::LUMINANCE));</span>
<span class="line-modified"> 445         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::ALPHA));</span>
<span class="line-modified"> 446         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RED));</span>
<span class="line-modified"> 447         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG_INTEGER));</span>
<span class="line-modified"> 448         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH_STENCIL));</span>
<span class="line-modified"> 449         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_BYTE));</span>
<span class="line-modified"> 450         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_SHORT_5_6_5));</span>
<span class="line-modified"> 451         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4));</span>
<span class="line-modified"> 452         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1));</span>
<span class="line-modified"> 453         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::BYTE));</span>
<span class="line-modified"> 454         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::HALF_FLOAT));</span>
<span class="line-modified"> 455         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::FLOAT));</span>
<span class="line-modified"> 456         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_SHORT));</span>
<span class="line-modified"> 457         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::SHORT));</span>
<span class="line-modified"> 458         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_INT));</span>
<span class="line-modified"> 459         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::INT));</span>
<span class="line-modified"> 460         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV));</span>
<span class="line-modified"> 461         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_INT_24_8));</span>
<span class="line-modified"> 462         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV));</span>
 463 
 464 #if USE(OPENGL_ES)
 465         map.get().emplace(STRINGIFY_PAIR(GL_RED_INTEGER));
 466         map.get().emplace(STRINGIFY_PAIR(GL_RGB_INTEGER));
 467         map.get().emplace(STRINGIFY_PAIR(GL_RG8_SNORM));
 468         map.get().emplace(STRINGIFY_PAIR(GL_RGB565));
 469         map.get().emplace(STRINGIFY_PAIR(GL_RGB8_SNORM));
 470         map.get().emplace(STRINGIFY_PAIR(GL_R11F_G11F_B10F));
 471         map.get().emplace(STRINGIFY_PAIR(GL_RGB9_E5));
 472         map.get().emplace(STRINGIFY_PAIR(GL_RGB16F));
 473         map.get().emplace(STRINGIFY_PAIR(GL_RGB32F));
 474         map.get().emplace(STRINGIFY_PAIR(GL_RGB8UI));
 475         map.get().emplace(STRINGIFY_PAIR(GL_RGB8I));
 476         map.get().emplace(STRINGIFY_PAIR(GL_RGB16UI));
 477         map.get().emplace(STRINGIFY_PAIR(GL_RGB16I));
 478         map.get().emplace(STRINGIFY_PAIR(GL_RGB32UI));
 479         map.get().emplace(STRINGIFY_PAIR(GL_RGB32I));
 480         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8_SNORM));
 481         map.get().emplace(STRINGIFY_PAIR(GL_RGBA16F));
 482         map.get().emplace(STRINGIFY_PAIR(GL_RGBA32F));
</pre>
<hr />
<pre>
 497     }
 498     return map.get();
 499 }
 500 
 501 #endif
 502 
 503 bool VideoTextureCopierCV::initializeContextObjects()
 504 {
 505     StringBuilder vertexShaderSource;
 506     vertexShaderSource.appendLiteral(&quot;attribute vec4 a_position;\n&quot;);
 507     vertexShaderSource.appendLiteral(&quot;uniform int u_flipY;\n&quot;);
 508     vertexShaderSource.appendLiteral(&quot;varying vec2 v_texturePosition;\n&quot;);
 509     vertexShaderSource.appendLiteral(&quot;void main() {\n&quot;);
 510     vertexShaderSource.appendLiteral(&quot;    v_texturePosition = vec2((a_position.x + 1.0) / 2.0, (a_position.y + 1.0) / 2.0);\n&quot;);
 511     vertexShaderSource.appendLiteral(&quot;    if (u_flipY == 1) {\n&quot;);
 512     vertexShaderSource.appendLiteral(&quot;        v_texturePosition.y = 1.0 - v_texturePosition.y;\n&quot;);
 513     vertexShaderSource.appendLiteral(&quot;    }\n&quot;);
 514     vertexShaderSource.appendLiteral(&quot;    gl_Position = a_position;\n&quot;);
 515     vertexShaderSource.appendLiteral(&quot;}\n&quot;);
 516 
<span class="line-modified"> 517     PlatformGLObject vertexShader = m_context-&gt;createShader(GraphicsContextGL::VERTEX_SHADER);</span>
 518     m_context-&gt;shaderSource(vertexShader, vertexShaderSource.toString());
 519     m_context-&gt;compileShaderDirect(vertexShader);
 520 
<span class="line-modified"> 521     GCGLint value = 0;</span>
<span class="line-modified"> 522     m_context-&gt;getShaderiv(vertexShader, GraphicsContextGL::COMPILE_STATUS, &amp;value);</span>
 523     if (!value) {
 524         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Vertex shader failed to compile.&quot;, this);
 525         m_context-&gt;deleteShader(vertexShader);
 526         return false;
 527     }
 528 
 529     StringBuilder fragmentShaderSource;
 530 
<span class="line-modified"> 531 #if USE(OPENGL_ES) || USE(ANGLE)</span>
 532     fragmentShaderSource.appendLiteral(&quot;precision mediump float;\n&quot;);
<span class="line-added"> 533 #endif</span>
<span class="line-added"> 534 #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
 535     fragmentShaderSource.appendLiteral(&quot;uniform sampler2D u_texture;\n&quot;);
<span class="line-modified"> 536 #elif USE(OPENGL) || (USE(ANGLE) &amp;&amp; !PLATFORM(IOS_FAMILY))</span>
 537     fragmentShaderSource.appendLiteral(&quot;uniform sampler2DRect u_texture;\n&quot;);



 538 #else
 539 #error Unsupported configuration
 540 #endif
 541     fragmentShaderSource.appendLiteral(&quot;varying vec2 v_texturePosition;\n&quot;);
 542     fragmentShaderSource.appendLiteral(&quot;uniform int u_premultiply;\n&quot;);
 543     fragmentShaderSource.appendLiteral(&quot;uniform vec2 u_textureDimensions;\n&quot;);
 544     fragmentShaderSource.appendLiteral(&quot;uniform int u_swapColorChannels;\n&quot;);
 545     fragmentShaderSource.appendLiteral(&quot;void main() {\n&quot;);
 546     fragmentShaderSource.appendLiteral(&quot;    vec2 texPos = vec2(v_texturePosition.x * u_textureDimensions.x, v_texturePosition.y * u_textureDimensions.y);\n&quot;);
<span class="line-modified"> 547 #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
 548     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2D(u_texture, texPos);\n&quot;);
<span class="line-modified"> 549 #elif USE(OPENGL) || (USE(ANGLE) &amp;&amp; !PLATFORM(IOS_FAMILY))</span>
 550     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2DRect(u_texture, texPos);\n&quot;);



 551 #else
 552 #error Unsupported configuration
 553 #endif
 554     fragmentShaderSource.appendLiteral(&quot;    if (u_swapColorChannels == 1) {\n&quot;);
 555     fragmentShaderSource.appendLiteral(&quot;        color.rgba = color.bgra;\n&quot;);
 556     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
 557     fragmentShaderSource.appendLiteral(&quot;    if (u_premultiply == 1) {\n&quot;);
 558     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = vec4(color.r * color.a, color.g * color.a, color.b * color.a, color.a);\n&quot;);
 559     fragmentShaderSource.appendLiteral(&quot;    } else {\n&quot;);
 560     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = color;\n&quot;);
 561     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
 562     fragmentShaderSource.appendLiteral(&quot;}\n&quot;);
 563 
<span class="line-modified"> 564     PlatformGLObject fragmentShader = m_context-&gt;createShader(GraphicsContextGL::FRAGMENT_SHADER);</span>
 565     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource.toString());
 566     m_context-&gt;compileShaderDirect(fragmentShader);
 567 
<span class="line-modified"> 568     m_context-&gt;getShaderiv(fragmentShader, GraphicsContextGL::COMPILE_STATUS, &amp;value);</span>
 569     if (!value) {
 570         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Fragment shader failed to compile.&quot;, this);
 571         m_context-&gt;deleteShader(vertexShader);
 572         m_context-&gt;deleteShader(fragmentShader);
 573         return false;
 574     }
 575 
 576     m_program = m_context-&gt;createProgram();
 577     m_context-&gt;attachShader(m_program, vertexShader);
 578     m_context-&gt;attachShader(m_program, fragmentShader);
 579     m_context-&gt;linkProgram(m_program);
 580 
<span class="line-modified"> 581     m_context-&gt;getProgramiv(m_program, GraphicsContextGL::LINK_STATUS, &amp;value);</span>
 582     if (!value) {
 583         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Program failed to link.&quot;, this);
 584         m_context-&gt;deleteShader(vertexShader);
 585         m_context-&gt;deleteShader(fragmentShader);
 586         m_context-&gt;deleteProgram(m_program);
 587         m_program = 0;
 588         return false;
 589     }
 590 
 591     m_textureUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_texture&quot;_s);
 592     m_textureDimensionsUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_textureDimensions&quot;_s);
 593     m_flipYUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_flipY&quot;_s);
 594     m_swapColorChannelsUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_swapColorChannels&quot;_s);
 595     m_premultiplyUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_premultiply&quot;_s);
 596     m_positionAttributeLocation = m_context-&gt;getAttribLocationDirect(m_program, &quot;a_position&quot;_s);
 597 
 598     m_context-&gt;detachShader(m_program, vertexShader);
 599     m_context-&gt;detachShader(m_program, fragmentShader);
 600     m_context-&gt;deleteShader(vertexShader);
 601     m_context-&gt;deleteShader(fragmentShader);
 602 
 603     LOG(WebGL, &quot;Uniform and Attribute locations: u_texture = %d, u_textureDimensions = %d, u_flipY = %d, u_premultiply = %d, a_position = %d&quot;, m_textureUniformLocation, m_textureDimensionsUniformLocation, m_flipYUniformLocation, m_premultiplyUniformLocation, m_positionAttributeLocation);
 604     m_context-&gt;enableVertexAttribArray(m_positionAttributeLocation);
 605 
 606     m_vertexBuffer = m_context-&gt;createBuffer();
 607     float vertices[12] = { -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1 };
 608 
<span class="line-modified"> 609     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexBuffer);</span>
<span class="line-modified"> 610     m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, sizeof(float) * 12, vertices, GraphicsContextGL::STATIC_DRAW);</span>
 611 
 612     return true;
 613 }
 614 
 615 bool VideoTextureCopierCV::initializeUVContextObjects()
 616 {
 617     String vertexShaderSource {
 618         &quot;attribute vec2 a_position;\n&quot;
 619         &quot;uniform vec2 u_yTextureSize;\n&quot;
 620         &quot;uniform vec2 u_uvTextureSize;\n&quot;
 621         &quot;uniform int u_flipY;\n&quot;
 622         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
 623         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
 624         &quot;void main() {\n&quot;
 625         &quot;   gl_Position = vec4(a_position, 0, 1.0);\n&quot;
 626         &quot;   vec2 normalizedPosition = a_position * .5 + .5;\n&quot;
 627         &quot;   if (u_flipY == 1) {\n&quot;
 628         &quot;       normalizedPosition.y = 1.0 - normalizedPosition.y;\n&quot;
 629         &quot;   }\n&quot;
<span class="line-modified"> 630 #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
 631         &quot;   v_yTextureCoordinate = normalizedPosition;\n&quot;
 632         &quot;   v_uvTextureCoordinate = normalizedPosition;\n&quot;
<span class="line-modified"> 633 #elif USE(OPENGL) || (USE(ANGLE) &amp;&amp; !PLATFORM(IOS_FAMILY))</span>
 634         &quot;   v_yTextureCoordinate = normalizedPosition * u_yTextureSize;\n&quot;
 635         &quot;   v_uvTextureCoordinate = normalizedPosition * u_uvTextureSize;\n&quot;


 636 #else
 637 #error Unsupported configuration
 638 #endif
 639         &quot;}\n&quot;_s
 640     };
 641 
<span class="line-modified"> 642     PlatformGLObject vertexShader = m_context-&gt;createShader(GraphicsContextGL::VERTEX_SHADER);</span>
 643     m_context-&gt;shaderSource(vertexShader, vertexShaderSource);
 644     m_context-&gt;compileShaderDirect(vertexShader);
 645 
<span class="line-modified"> 646     GCGLint status = 0;</span>
<span class="line-modified"> 647     m_context-&gt;getShaderiv(vertexShader, GraphicsContextGL::COMPILE_STATUS, &amp;status);</span>
 648     if (!status) {
 649         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Vertex shader failed to compile.&quot;, this);
 650         m_context-&gt;deleteShader(vertexShader);
 651         return false;
 652     }
 653 
 654     String fragmentShaderSource {
<span class="line-modified"> 655 #if USE(OPENGL_ES) || USE(ANGLE)</span>
 656         &quot;precision mediump float;\n&quot;
<span class="line-added"> 657 #endif</span>
<span class="line-added"> 658 #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
 659         &quot;#define SAMPLERTYPE sampler2D\n&quot;
 660         &quot;#define TEXTUREFUNC texture2D\n&quot;
<span class="line-modified"> 661 #elif USE(OPENGL) || (USE(ANGLE) &amp;&amp; !PLATFORM(IOS_FAMILY))</span>
 662         &quot;#define SAMPLERTYPE sampler2DRect\n&quot;
 663         &quot;#define TEXTUREFUNC texture2DRect\n&quot;


 664 #else
 665 #error Unsupported configuration
 666 #endif
 667         &quot;uniform SAMPLERTYPE u_yTexture;\n&quot;
 668         &quot;uniform SAMPLERTYPE u_uvTexture;\n&quot;
 669         &quot;uniform mat4 u_colorMatrix;\n&quot;
 670         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
 671         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
 672         &quot;void main() {\n&quot;
 673         &quot;    vec4 yuv;\n&quot;
 674         &quot;    yuv.r = TEXTUREFUNC(u_yTexture, v_yTextureCoordinate).r;\n&quot;
 675         &quot;    yuv.gb = TEXTUREFUNC(u_uvTexture, v_uvTextureCoordinate).rg;\n&quot;
 676         &quot;    yuv.a = 1.0;\n&quot;
 677         &quot;    gl_FragColor = yuv * u_colorMatrix;\n&quot;
 678         &quot;}\n&quot;_s
 679     };
 680 
<span class="line-modified"> 681     PlatformGLObject fragmentShader = m_context-&gt;createShader(GraphicsContextGL::FRAGMENT_SHADER);</span>
 682     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource);
 683     m_context-&gt;compileShaderDirect(fragmentShader);
 684 
<span class="line-modified"> 685     m_context-&gt;getShaderiv(fragmentShader, GraphicsContextGL::COMPILE_STATUS, &amp;status);</span>
 686     if (!status) {
 687         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Fragment shader failed to compile.&quot;, this);
 688         m_context-&gt;deleteShader(vertexShader);
 689         m_context-&gt;deleteShader(fragmentShader);
 690         return false;
 691     }
 692 
 693     m_yuvProgram = m_context-&gt;createProgram();
 694     m_context-&gt;attachShader(m_yuvProgram, vertexShader);
 695     m_context-&gt;attachShader(m_yuvProgram, fragmentShader);
 696     m_context-&gt;linkProgram(m_yuvProgram);
 697 
<span class="line-modified"> 698     m_context-&gt;getProgramiv(m_yuvProgram, GraphicsContextGL::LINK_STATUS, &amp;status);</span>
 699     if (!status) {
 700         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Program failed to link.&quot;, this);
 701         m_context-&gt;deleteShader(vertexShader);
 702         m_context-&gt;deleteShader(fragmentShader);
 703         m_context-&gt;deleteProgram(m_yuvProgram);
 704         m_yuvProgram = 0;
 705         return false;
 706     }
 707 
 708     m_yTextureUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_yTexture&quot;_s);
 709     m_uvTextureUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_uvTexture&quot;_s);
 710     m_colorMatrixUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_colorMatrix&quot;_s);
 711     m_yuvFlipYUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_flipY&quot;_s);
 712     m_yTextureSizeUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_yTextureSize&quot;_s);
 713     m_uvTextureSizeUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_uvTextureSize&quot;_s);
 714     m_yuvPositionAttributeLocation = m_context-&gt;getAttribLocationDirect(m_yuvProgram, &quot;a_position&quot;_s);
 715 
 716     m_context-&gt;detachShader(m_yuvProgram, vertexShader);
 717     m_context-&gt;detachShader(m_yuvProgram, fragmentShader);
 718     m_context-&gt;deleteShader(vertexShader);
 719     m_context-&gt;deleteShader(fragmentShader);
 720 
 721     m_yuvVertexBuffer = m_context-&gt;createBuffer();
 722     float vertices[12] = { -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1 };
 723 
<span class="line-modified"> 724     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_yuvVertexBuffer);</span>
<span class="line-modified"> 725     m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, sizeof(vertices), vertices, GraphicsContextGL::STATIC_DRAW);</span>
 726     m_context-&gt;enableVertexAttribArray(m_yuvPositionAttributeLocation);
<span class="line-modified"> 727     m_context-&gt;vertexAttribPointer(m_yuvPositionAttributeLocation, 2, GraphicsContextGL::FLOAT, false, 0, 0);</span>
 728 
 729     return true;
 730 }
 731 
<span class="line-modified"> 732 #if USE(ANGLE)</span>
<span class="line-added"> 733 void* VideoTextureCopierCV::attachIOSurfaceToTexture(GCGLenum target, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLenum type, IOSurfaceRef surface, GCGLuint plane)</span>
<span class="line-added"> 734 {</span>
<span class="line-added"> 735     auto display = m_context-&gt;platformDisplay();</span>
<span class="line-added"> 736     EGLint eglTextureTarget = 0;</span>
<span class="line-added"> 737 </span>
<span class="line-added"> 738     if (target == GraphicsContextGL::TEXTURE_RECTANGLE_ARB)</span>
<span class="line-added"> 739         eglTextureTarget = EGL_TEXTURE_RECTANGLE_ANGLE;</span>
<span class="line-added"> 740     else if (target == GraphicsContextGL::TEXTURE_2D)</span>
<span class="line-added"> 741         eglTextureTarget = EGL_TEXTURE_2D;</span>
<span class="line-added"> 742     else {</span>
<span class="line-added"> 743         LOG(WebGL, &quot;Unknown texture target %d.&quot;, static_cast&lt;int&gt;(target));</span>
<span class="line-added"> 744         return nullptr;</span>
<span class="line-added"> 745     }</span>
<span class="line-added"> 746     if (eglTextureTarget != GraphicsContextGL::EGLIOSurfaceTextureTarget) {</span>
<span class="line-added"> 747         LOG(WebGL, &quot;Mismatch in EGL texture target %d.&quot;, static_cast&lt;int&gt;(target));</span>
<span class="line-added"> 748         return nullptr;</span>
<span class="line-added"> 749     }</span>
<span class="line-added"> 750 </span>
<span class="line-added"> 751     const EGLint surfaceAttributes[] = {</span>
<span class="line-added"> 752         EGL_WIDTH, width,</span>
<span class="line-added"> 753         EGL_HEIGHT, height,</span>
<span class="line-added"> 754         EGL_IOSURFACE_PLANE_ANGLE, static_cast&lt;EGLint&gt;(plane),</span>
<span class="line-added"> 755         EGL_TEXTURE_TARGET, static_cast&lt;EGLint&gt;(eglTextureTarget),</span>
<span class="line-added"> 756         EGL_TEXTURE_INTERNAL_FORMAT_ANGLE, static_cast&lt;EGLint&gt;(internalFormat),</span>
<span class="line-added"> 757         EGL_TEXTURE_FORMAT, EGL_TEXTURE_RGBA,</span>
<span class="line-added"> 758         EGL_TEXTURE_TYPE_ANGLE, static_cast&lt;EGLint&gt;(type),</span>
<span class="line-added"> 759         // Only has an effect on the iOS Simulator.</span>
<span class="line-added"> 760         EGL_IOSURFACE_USAGE_HINT_ANGLE, EGL_IOSURFACE_READ_HINT_ANGLE,</span>
<span class="line-added"> 761         EGL_NONE, EGL_NONE</span>
<span class="line-added"> 762     };</span>
<span class="line-added"> 763     EGLSurface pbuffer = EGL_CreatePbufferFromClientBuffer(display, EGL_IOSURFACE_ANGLE, surface, m_context-&gt;platformConfig(), surfaceAttributes);</span>
<span class="line-added"> 764     if (!pbuffer)</span>
<span class="line-added"> 765         return nullptr;</span>
<span class="line-added"> 766     if (!EGL_BindTexImage(display, pbuffer, EGL_BACK_BUFFER)) {</span>
<span class="line-added"> 767         EGL_DestroySurface(display, pbuffer);</span>
<span class="line-added"> 768         return nullptr;</span>
<span class="line-added"> 769     }</span>
<span class="line-added"> 770     return pbuffer;</span>
<span class="line-added"> 771 }</span>
<span class="line-added"> 772 </span>
<span class="line-added"> 773 void VideoTextureCopierCV::detachIOSurfaceFromTexture(void* handle)</span>
<span class="line-added"> 774 {</span>
<span class="line-added"> 775     auto display = m_context-&gt;platformDisplay();</span>
<span class="line-added"> 776     EGL_ReleaseTexImage(display, handle, EGL_BACK_BUFFER);</span>
<span class="line-added"> 777     EGL_DestroySurface(display, handle);</span>
<span class="line-added"> 778 }</span>
<span class="line-added"> 779 #endif</span>
<span class="line-added"> 780 </span>
<span class="line-added"> 781 bool VideoTextureCopierCV::copyImageToPlatformTexture(CVPixelBufferRef image, size_t width, size_t height, PlatformGLObject outputTexture, GCGLenum outputTarget, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY)</span>
 782 {
<span class="line-added"> 783     // CVOpenGLTextureCache seems to be disabled since the deprecation of</span>
<span class="line-added"> 784     // OpenGL. To avoid porting unused code to the ANGLE code paths, remove it.</span>
<span class="line-added"> 785 #if USE(ANGLE)</span>
<span class="line-added"> 786     UNUSED_PARAM(outputTarget);</span>
<span class="line-added"> 787     UNUSED_PARAM(premultiplyAlpha);</span>
<span class="line-added"> 788 #else</span>
 789     if (!m_textureCache) {
 790         m_textureCache = TextureCacheCV::create(m_context);
 791         if (!m_textureCache)
 792             return false;
 793     }
 794 
 795     if (auto texture = m_textureCache-&gt;textureFromImage(image, outputTarget, level, internalFormat, format, type)) {
 796         bool swapColorChannels = false;
 797 #if USE(OPENGL_ES)
 798         // FIXME: Remove this workaround once rdar://problem/35834388 is fixed.
 799         swapColorChannels = CVPixelBufferGetPixelFormatType(image) == kCVPixelFormatType_32BGRA;
 800 #endif
 801         return copyVideoTextureToPlatformTexture(texture.get(), width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
 802     }
<span class="line-added"> 803 #endif // USE(ANGLE)</span>
 804 
 805 #if HAVE(IOSURFACE)
 806     // FIXME: This currently only supports &#39;420v&#39; and &#39;420f&#39; pixel formats. Investigate supporting more pixel formats.
 807     OSType pixelFormat = CVPixelBufferGetPixelFormatType(image);
 808     if (pixelFormat != kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange &amp;&amp; pixelFormat != kCVPixelFormatType_420YpCbCr8BiPlanarFullRange) {
 809         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Asked to copy an unsupported pixel format (&#39;%s&#39;).&quot;, this, FourCC(pixelFormat).toString().utf8().data());
 810         return false;
 811     }
 812 
 813     IOSurfaceRef surface = CVPixelBufferGetIOSurface(image);
 814     if (!surface)
 815         return false;
 816 
 817     auto newSurfaceSeed = IOSurfaceGetSeed(surface);
 818     if (flipY == m_lastFlipY
 819         &amp;&amp; surface == m_lastSurface
 820         &amp;&amp; newSurfaceSeed == m_lastSurfaceSeed
 821         &amp;&amp; lastTextureSeed(outputTexture) == m_context-&gt;textureSeed(outputTexture)) {
 822         // If the texture hasn&#39;t been modified since the last time we copied to it, and the
 823         // image hasn&#39;t been modified since the last time it was copied, this is a no-op.
 824         return true;
 825     }
 826 
 827     if (!m_yuvProgram) {
 828         if (!initializeUVContextObjects()) {
 829             LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
 830             return false;
 831         }
 832     }
 833 
<span class="line-modified"> 834     m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_framebuffer);</span>
 835 
 836     // Allocate memory for the output texture.
<span class="line-modified"> 837     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, outputTexture);</span>
<span class="line-modified"> 838     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified"> 839     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified"> 840     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 841     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 842     m_context-&gt;texImage2DDirect(GraphicsContextGL::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);</span>
<span class="line-modified"> 843 </span>
<span class="line-modified"> 844     m_context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::COLOR_ATTACHMENT0, GraphicsContextGL::TEXTURE_2D, outputTexture, level);</span>
<span class="line-modified"> 845     GCGLenum status = m_context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER);</span>
<span class="line-modified"> 846     if (status != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
 847         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
 848         return false;
 849     }
 850 
 851     m_context-&gt;useProgram(m_yuvProgram);
 852     m_context-&gt;viewport(0, 0, width, height);
 853 
 854     // Bind and set up the textures for the video source.
 855     auto yPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 0);
 856     auto yPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 0);
 857     auto uvPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 1);
 858     auto uvPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 1);
 859 
 860 #if USE(OPENGL_ES)
<span class="line-modified"> 861     GCGLenum videoTextureTarget = GraphicsContextGL::TEXTURE_2D;</span>
 862 #elif USE(OPENGL)
<span class="line-modified"> 863     GCGLenum videoTextureTarget = GraphicsContextGL::TEXTURE_RECTANGLE_ARB;</span>
 864 #elif USE(ANGLE)
<span class="line-modified"> 865     GCGLenum videoTextureTarget = GraphicsContextGL::IOSurfaceTextureTarget;</span>

 866 #else
 867 #error Unsupported configuration
 868 #endif
 869     auto uvTexture = m_context-&gt;createTexture();
<span class="line-modified"> 870     m_context-&gt;activeTexture(GraphicsContextGL::TEXTURE1);</span>
 871     m_context-&gt;bindTexture(videoTextureTarget, uvTexture);
<span class="line-modified"> 872     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified"> 873     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified"> 874     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 875     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 876 #if USE(ANGLE)</span>
<span class="line-added"> 877     auto uvHandle = attachIOSurfaceToTexture(videoTextureTarget, GraphicsContextGL::RG, uvPlaneWidth, uvPlaneHeight, GraphicsContextGL::UNSIGNED_BYTE, surface, 1);</span>
<span class="line-added"> 878     if (!uvHandle) {</span>
 879         m_context-&gt;deleteTexture(uvTexture);
 880         return false;
 881     }
<span class="line-added"> 882 #else</span>
<span class="line-added"> 883     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContextGL::RG, uvPlaneWidth, uvPlaneHeight, GraphicsContextGL::RG, GraphicsContextGL::UNSIGNED_BYTE, surface, 1)) {</span>
<span class="line-added"> 884         m_context-&gt;deleteTexture(uvTexture);</span>
<span class="line-added"> 885         return false;</span>
<span class="line-added"> 886     }</span>
<span class="line-added"> 887 #endif // USE(ANGLE)</span>
 888 
 889     auto yTexture = m_context-&gt;createTexture();
<span class="line-modified"> 890     m_context-&gt;activeTexture(GraphicsContextGL::TEXTURE0);</span>
 891     m_context-&gt;bindTexture(videoTextureTarget, yTexture);
<span class="line-modified"> 892     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified"> 893     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified"> 894     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 895     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 896 #if USE(ANGLE)</span>
<span class="line-added"> 897     auto yHandle = attachIOSurfaceToTexture(videoTextureTarget, GraphicsContextGL::RED, yPlaneWidth, yPlaneHeight, GraphicsContextGL::UNSIGNED_BYTE, surface, 0);</span>
<span class="line-added"> 898     if (!yHandle) {</span>
<span class="line-added"> 899         m_context-&gt;deleteTexture(yTexture);</span>
<span class="line-added"> 900         m_context-&gt;deleteTexture(uvTexture);</span>
<span class="line-added"> 901         return false;</span>
<span class="line-added"> 902     }</span>
<span class="line-added"> 903 #else</span>
<span class="line-added"> 904     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContextGL::LUMINANCE, yPlaneWidth, yPlaneHeight, GraphicsContextGL::LUMINANCE, GraphicsContextGL::UNSIGNED_BYTE, surface, 0)) {</span>
 905         m_context-&gt;deleteTexture(yTexture);
 906         m_context-&gt;deleteTexture(uvTexture);
 907         return false;
 908     }
<span class="line-added"> 909 #endif // USE(ANGLE)</span>
 910 
 911     // Configure the drawing parameters.
 912     m_context-&gt;uniform1i(m_yTextureUniformLocation, 0);
 913     m_context-&gt;uniform1i(m_uvTextureUniformLocation, 1);
 914     m_context-&gt;uniform1i(m_yuvFlipYUniformLocation, flipY);
 915     m_context-&gt;uniform2f(m_yTextureSizeUniformLocation, yPlaneWidth, yPlaneHeight);
 916     m_context-&gt;uniform2f(m_uvTextureSizeUniformLocation, uvPlaneWidth, uvPlaneHeight);
 917 
 918     auto range = pixelRangeFromPixelFormat(pixelFormat);
 919     auto transferFunction = transferFunctionFromString((CFStringRef)CVBufferGetAttachment(image, kCVImageBufferYCbCrMatrixKey, nil));
 920     auto&amp; colorMatrix = YCbCrToRGBMatrixForRangeAndTransferFunction(range, transferFunction);
 921     m_context-&gt;uniformMatrix4fv(m_colorMatrixUniformLocation, 1, GL_FALSE, colorMatrix.data());
 922 
 923     // Do the actual drawing.
<span class="line-modified"> 924     m_context-&gt;drawArrays(GraphicsContextGL::TRIANGLES, 0, 6);</span>
 925 
<span class="line-modified"> 926 #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
 927     // flush() must be called here in order to re-synchronize the output texture&#39;s contents across the
 928     // two EAGL contexts.
 929     m_context-&gt;flush();
 930 #endif
 931 
 932     // Clean-up.
 933     m_context-&gt;deleteTexture(yTexture);
 934     m_context-&gt;deleteTexture(uvTexture);
<span class="line-added"> 935 #if USE(ANGLE)</span>
<span class="line-added"> 936     detachIOSurfaceFromTexture(yHandle);</span>
<span class="line-added"> 937     detachIOSurfaceFromTexture(uvHandle);</span>
<span class="line-added"> 938 #endif</span>
 939 
 940     m_lastSurface = surface;
 941     m_lastSurfaceSeed = newSurfaceSeed;
 942     m_lastTextureSeed.set(outputTexture, m_context-&gt;textureSeed(outputTexture));
 943     m_lastFlipY = flipY;
 944 
 945     return true;
 946 #else
 947     return false;
 948 #endif // HAVE(IOSURFACE)
 949 }
 950 
<span class="line-modified"> 951 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(TextureType inputVideoTexture, size_t width, size_t height, PlatformGLObject outputTexture, GCGLenum outputTarget, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)</span>
 952 {
 953     if (!inputVideoTexture)
 954         return false;
 955 
 956     GLfloat lowerLeft[2] = { 0, 0 };
 957     GLfloat lowerRight[2] = { 0, 0 };
 958     GLfloat upperRight[2] = { 0, 0 };
 959     GLfloat upperLeft[2] = { 0, 0 };
<span class="line-added"> 960     PlatformGLObject videoTextureName;</span>
<span class="line-added"> 961     GCGLenum videoTextureTarget;</span>
<span class="line-added"> 962 </span>
 963 #if USE(OPENGL_ES)
<span class="line-modified"> 964     videoTextureName = CVOpenGLESTextureGetName(inputVideoTexture);</span>
<span class="line-modified"> 965     videoTextureTarget = CVOpenGLESTextureGetTarget(inputVideoTexture);</span>
 966     CVOpenGLESTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
 967 #elif USE(OPENGL)
<span class="line-modified"> 968     videoTextureName = CVOpenGLTextureGetName(inputVideoTexture);</span>
<span class="line-modified"> 969     videoTextureTarget = CVOpenGLTextureGetTarget(inputVideoTexture);</span>
 970     CVOpenGLTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
 971 #elif USE(ANGLE)
<span class="line-modified"> 972     // CVOpenGLTextureCacheCreateTextureFromImage seems to always return</span>
<span class="line-modified"> 973     // kCVReturnPixelBufferNotOpenGLCompatible on desktop macOS now, so this</span>
<span class="line-modified"> 974     // entire code path seems to be unused. Assume the IOSurface path will be</span>
<span class="line-added"> 975     // taken when using ANGLE.</span>
<span class="line-added"> 976     UNUSED_PARAM(lowerLeft);</span>
<span class="line-added"> 977     UNUSED_PARAM(lowerRight);</span>
<span class="line-added"> 978     UNUSED_PARAM(upperLeft);</span>
<span class="line-added"> 979     UNUSED_PARAM(upperRight);</span>
<span class="line-added"> 980     UNUSED_PARAM(width);</span>
<span class="line-added"> 981     UNUSED_PARAM(height);</span>
<span class="line-added"> 982     UNUSED_PARAM(outputTexture);</span>
<span class="line-added"> 983     UNUSED_PARAM(outputTarget);</span>
<span class="line-added"> 984     UNUSED_PARAM(level);</span>
<span class="line-added"> 985     UNUSED_PARAM(internalFormat);</span>
<span class="line-added"> 986     UNUSED_PARAM(format);</span>
<span class="line-added"> 987     UNUSED_PARAM(type);</span>
<span class="line-added"> 988     UNUSED_PARAM(premultiplyAlpha);</span>
<span class="line-added"> 989     UNUSED_PARAM(flipY);</span>
<span class="line-added"> 990     UNUSED_PARAM(swapColorChannels);</span>
 991     // FIXME: determine how to access rectangular textures via ANGLE.
<span class="line-modified"> 992     UNIMPLEMENTED();</span>
<span class="line-added"> 993     return false;</span>
 994 #endif
 995 
 996     if (lowerLeft[1] &lt; upperRight[1])
 997         flipY = !flipY;
 998 
 999     return copyVideoTextureToPlatformTexture(videoTextureName, videoTextureTarget, width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
1000 }
1001 
<span class="line-modified">1002 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(PlatformGLObject videoTextureName, GCGLenum videoTextureTarget, size_t width, size_t height, PlatformGLObject outputTexture, GCGLenum outputTarget, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)</span>
1003 {
1004     LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - internalFormat: %s, format: %s, type: %s flipY: %s, premultiplyAlpha: %s&quot;, this, enumToStringMap()[internalFormat], enumToStringMap()[format], enumToStringMap()[type], flipY ? &quot;true&quot; : &quot;false&quot;, premultiplyAlpha ? &quot;true&quot; : &quot;false&quot;);
1005 
1006     if (!m_program) {
1007         if (!initializeContextObjects()) {
1008             LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
1009             return false;
1010         }
1011     }
1012 
<span class="line-modified">1013     m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_framebuffer);</span>
1014 
1015     // Allocate memory for the output texture.
<span class="line-modified">1016     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, outputTexture);</span>
<span class="line-modified">1017     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified">1018     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified">1019     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified">1020     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified">1021     m_context-&gt;texImage2DDirect(GraphicsContextGL::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);</span>
<span class="line-modified">1022 </span>
<span class="line-modified">1023     m_context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::COLOR_ATTACHMENT0, GraphicsContextGL::TEXTURE_2D, outputTexture, level);</span>
<span class="line-modified">1024     GCGLenum status = m_context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER);</span>
<span class="line-modified">1025     if (status != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
1026         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
1027         return false;
1028     }
1029 
1030     m_context-&gt;useProgram(m_program);
1031     m_context-&gt;viewport(0, 0, width, height);
1032 
1033     // Bind and set up the texture for the video source.
<span class="line-modified">1034     m_context-&gt;activeTexture(GraphicsContextGL::TEXTURE0);</span>
1035     m_context-&gt;bindTexture(videoTextureTarget, videoTextureName);
<span class="line-modified">1036     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified">1037     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified">1038     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified">1039     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
1040 
1041     // Configure the drawing parameters.
1042     m_context-&gt;uniform1i(m_textureUniformLocation, 0);
1043 #if USE(OPENGL_ES)
1044     m_context-&gt;uniform2f(m_textureDimensionsUniformLocation, 1, 1);
1045 #else
1046     m_context-&gt;uniform2f(m_textureDimensionsUniformLocation, width, height);
1047 #endif
1048 
1049     m_context-&gt;uniform1i(m_flipYUniformLocation, flipY);
1050     m_context-&gt;uniform1i(m_swapColorChannelsUniformLocation, swapColorChannels);
1051     m_context-&gt;uniform1i(m_premultiplyUniformLocation, premultiplyAlpha);
1052 
1053     // Do the actual drawing.
1054     m_context-&gt;enableVertexAttribArray(m_positionAttributeLocation);
<span class="line-modified">1055     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexBuffer);</span>
<span class="line-modified">1056     m_context-&gt;vertexAttribPointer(m_positionAttributeLocation, 2, GraphicsContextGL::FLOAT, false, 0, 0);</span>
<span class="line-modified">1057     m_context-&gt;drawArrays(GraphicsContextGL::TRIANGLES, 0, 6);</span>
1058 
1059 #if USE(OPENGL_ES)
1060     // flush() must be called here in order to re-synchronize the output texture&#39;s contents across the
1061     // two EAGL contexts.
1062     m_context-&gt;flush();
1063 #endif
1064 
1065     // Clean-up.
1066     m_context-&gt;bindTexture(videoTextureTarget, 0);
1067     m_context-&gt;bindTexture(outputTarget, outputTexture);
1068 
1069     return true;
1070 }
1071 
1072 }
1073 
1074 #endif // HAVE(CORE_VIDEO)
</pre>
</td>
</tr>
</table>
<center><a href="TextureCacheCV.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VideoTextureCopierCV.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
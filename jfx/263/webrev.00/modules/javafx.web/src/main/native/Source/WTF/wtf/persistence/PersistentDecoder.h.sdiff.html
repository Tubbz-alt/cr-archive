<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/persistence/PersistentDecoder.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PersistentDecoder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PersistentEncoder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/persistence/PersistentDecoder.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 33 namespace Persistence {
 34 
 35 class Decoder {
 36     WTF_MAKE_FAST_ALLOCATED;
 37 public:
 38     WTF_EXPORT_PRIVATE Decoder(const uint8_t* buffer, size_t bufferSize);
 39     WTF_EXPORT_PRIVATE ~Decoder();
 40 
 41     size_t length() const { return m_bufferEnd - m_buffer; }
 42     size_t currentOffset() const { return m_bufferPosition - m_buffer; }
 43 
 44     WTF_EXPORT_PRIVATE bool verifyChecksum();
 45 
 46     WTF_EXPORT_PRIVATE bool decodeFixedLengthData(uint8_t*, size_t);
 47 
 48     WTF_EXPORT_PRIVATE bool decode(bool&amp;);
 49     WTF_EXPORT_PRIVATE bool decode(uint8_t&amp;);
 50     WTF_EXPORT_PRIVATE bool decode(uint16_t&amp;);
 51     WTF_EXPORT_PRIVATE bool decode(uint32_t&amp;);
 52     WTF_EXPORT_PRIVATE bool decode(uint64_t&amp;);

 53     WTF_EXPORT_PRIVATE bool decode(int32_t&amp;);
 54     WTF_EXPORT_PRIVATE bool decode(int64_t&amp;);
 55     WTF_EXPORT_PRIVATE bool decode(float&amp;);
 56     WTF_EXPORT_PRIVATE bool decode(double&amp;);
 57 
 58     template&lt;typename E&gt; auto decode(E&amp; e) -&gt; std::enable_if_t&lt;std::is_enum&lt;E&gt;::value, bool&gt;
 59     {
 60         uint64_t value;
 61         if (!decode(value))
 62             return false;
 63         if (!isValidEnum&lt;E&gt;(value))
 64             return false;
 65 
 66         e = static_cast&lt;E&gt;(value);
 67         return true;
 68     }
 69 
 70     template&lt;typename T&gt; bool decodeEnum(T&amp; result)
 71     {
 72         static_assert(sizeof(T) &lt;= 8, &quot;Enum type T must not be larger than 64 bits!&quot;);
</pre>
<hr />
<pre>
 78         result = static_cast&lt;T&gt;(value);
 79         return true;
 80     }
 81 
 82     template&lt;typename T&gt; auto decode(T&amp; t) -&gt; std::enable_if_t&lt;!std::is_enum&lt;T&gt;::value, bool&gt;
 83     {
 84         return Coder&lt;T&gt;::decode(*this, t);
 85     }
 86 
 87     template&lt;typename T&gt;
 88     bool bufferIsLargeEnoughToContain(size_t numElements) const
 89     {
 90         static_assert(std::is_arithmetic&lt;T&gt;::value, &quot;Type T must have a fixed, known encoded size!&quot;);
 91 
 92         if (numElements &gt; std::numeric_limits&lt;size_t&gt;::max() / sizeof(T))
 93             return false;
 94 
 95         return bufferIsLargeEnoughToContain(numElements * sizeof(T));
 96     }
 97 
<span class="line-modified"> 98     static const bool isIPCDecoder = false;</span>
 99 
100 private:
101     WTF_EXPORT_PRIVATE bool bufferIsLargeEnoughToContain(size_t) const;
102     template&lt;typename Type&gt; bool decodeNumber(Type&amp;);
103 
104     const uint8_t* m_buffer;
105     const uint8_t* m_bufferPosition;
106     const uint8_t* m_bufferEnd;
107 
108     SHA1 m_sha1;
109 };
110 
111 }
112 }
113 
</pre>
</td>
<td>
<hr />
<pre>
 33 namespace Persistence {
 34 
 35 class Decoder {
 36     WTF_MAKE_FAST_ALLOCATED;
 37 public:
 38     WTF_EXPORT_PRIVATE Decoder(const uint8_t* buffer, size_t bufferSize);
 39     WTF_EXPORT_PRIVATE ~Decoder();
 40 
 41     size_t length() const { return m_bufferEnd - m_buffer; }
 42     size_t currentOffset() const { return m_bufferPosition - m_buffer; }
 43 
 44     WTF_EXPORT_PRIVATE bool verifyChecksum();
 45 
 46     WTF_EXPORT_PRIVATE bool decodeFixedLengthData(uint8_t*, size_t);
 47 
 48     WTF_EXPORT_PRIVATE bool decode(bool&amp;);
 49     WTF_EXPORT_PRIVATE bool decode(uint8_t&amp;);
 50     WTF_EXPORT_PRIVATE bool decode(uint16_t&amp;);
 51     WTF_EXPORT_PRIVATE bool decode(uint32_t&amp;);
 52     WTF_EXPORT_PRIVATE bool decode(uint64_t&amp;);
<span class="line-added"> 53     WTF_EXPORT_PRIVATE bool decode(int16_t&amp;);</span>
 54     WTF_EXPORT_PRIVATE bool decode(int32_t&amp;);
 55     WTF_EXPORT_PRIVATE bool decode(int64_t&amp;);
 56     WTF_EXPORT_PRIVATE bool decode(float&amp;);
 57     WTF_EXPORT_PRIVATE bool decode(double&amp;);
 58 
 59     template&lt;typename E&gt; auto decode(E&amp; e) -&gt; std::enable_if_t&lt;std::is_enum&lt;E&gt;::value, bool&gt;
 60     {
 61         uint64_t value;
 62         if (!decode(value))
 63             return false;
 64         if (!isValidEnum&lt;E&gt;(value))
 65             return false;
 66 
 67         e = static_cast&lt;E&gt;(value);
 68         return true;
 69     }
 70 
 71     template&lt;typename T&gt; bool decodeEnum(T&amp; result)
 72     {
 73         static_assert(sizeof(T) &lt;= 8, &quot;Enum type T must not be larger than 64 bits!&quot;);
</pre>
<hr />
<pre>
 79         result = static_cast&lt;T&gt;(value);
 80         return true;
 81     }
 82 
 83     template&lt;typename T&gt; auto decode(T&amp; t) -&gt; std::enable_if_t&lt;!std::is_enum&lt;T&gt;::value, bool&gt;
 84     {
 85         return Coder&lt;T&gt;::decode(*this, t);
 86     }
 87 
 88     template&lt;typename T&gt;
 89     bool bufferIsLargeEnoughToContain(size_t numElements) const
 90     {
 91         static_assert(std::is_arithmetic&lt;T&gt;::value, &quot;Type T must have a fixed, known encoded size!&quot;);
 92 
 93         if (numElements &gt; std::numeric_limits&lt;size_t&gt;::max() / sizeof(T))
 94             return false;
 95 
 96         return bufferIsLargeEnoughToContain(numElements * sizeof(T));
 97     }
 98 
<span class="line-modified"> 99     static constexpr bool isIPCDecoder = false;</span>
100 
101 private:
102     WTF_EXPORT_PRIVATE bool bufferIsLargeEnoughToContain(size_t) const;
103     template&lt;typename Type&gt; bool decodeNumber(Type&amp;);
104 
105     const uint8_t* m_buffer;
106     const uint8_t* m_bufferPosition;
107     const uint8_t* m_bufferEnd;
108 
109     SHA1 m_sha1;
110 };
111 
112 }
113 }
114 
</pre>
</td>
</tr>
</table>
<center><a href="PersistentDecoder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PersistentEncoder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
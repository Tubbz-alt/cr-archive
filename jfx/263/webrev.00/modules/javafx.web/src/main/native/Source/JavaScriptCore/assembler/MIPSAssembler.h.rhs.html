<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MIPSAssembler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2009 University of Szeged
   4  * All rights reserved.
   5  * Copyright (C) 2010 MIPS Technologies, Inc. All rights reserved.
   6  *
   7  * Redistribution and use in source and binary forms, with or without
   8  * modification, are permitted provided that the following conditions
   9  * are met:
  10  * 1. Redistributions of source code must retain the above copyright
  11  *    notice, this list of conditions and the following disclaimer.
  12  * 2. Redistributions in binary form must reproduce the above copyright
  13  *    notice, this list of conditions and the following disclaimer in the
  14  *    documentation and/or other materials provided with the distribution.
  15  *
  16  * THIS SOFTWARE IS PROVIDED BY MIPS TECHNOLOGIES, INC. ``AS IS&#39;&#39; AND ANY
  17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  19  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MIPS TECHNOLOGIES, INC. OR
  20  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  21  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  24  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #pragma once
  30 
  31 #if ENABLE(ASSEMBLER) &amp;&amp; CPU(MIPS)
  32 
  33 #include &quot;AssemblerBuffer.h&quot;
  34 #include &quot;JITCompilationEffort.h&quot;
  35 #include &quot;MIPSRegisters.h&quot;
  36 #include &lt;limits.h&gt;
  37 #include &lt;wtf/Assertions.h&gt;
  38 #include &lt;wtf/SegmentedVector.h&gt;
  39 
  40 namespace JSC {
  41 
  42 typedef uint32_t MIPSWord;
  43 
  44 namespace RegisterNames {
  45 typedef enum : int8_t {
  46 #define REGISTER_ID(id, name, r, cs) id,
  47     FOR_EACH_GP_REGISTER(REGISTER_ID)
  48 #undef REGISTER_ID
  49 #define REGISTER_ALIAS(id, alias) id = alias,
  50     FOR_EACH_REGISTER_ALIAS(REGISTER_ALIAS)
  51 #undef REGISTER_ALIAS
  52     InvalidGPRReg = -1,
  53 } RegisterID;
  54 
  55 typedef enum : int8_t {
  56 #define REGISTER_ID(id, name, idx) id = idx,
  57     FOR_EACH_SP_REGISTER(REGISTER_ID)
  58 #undef REGISTER_ID
  59 } SPRegisterID;
  60 
  61 typedef enum : int8_t {
  62 #define REGISTER_ID(id, name, r, cs) id,
  63     FOR_EACH_FP_REGISTER(REGISTER_ID)
  64 #undef REGISTER_ID
  65     InvalidFPRReg = -1,
  66 } FPRegisterID;
  67 
  68 } // namespace MIPSRegisters
  69 
  70 class MIPSAssembler {
  71 public:
  72     typedef MIPSRegisters::RegisterID RegisterID;
  73     typedef MIPSRegisters::SPRegisterID SPRegisterID;
  74     typedef MIPSRegisters::FPRegisterID FPRegisterID;
  75     typedef SegmentedVector&lt;AssemblerLabel, 64&gt; Jumps;
  76 
  77     static constexpr RegisterID firstRegister() { return MIPSRegisters::r0; }
  78     static constexpr RegisterID lastRegister() { return MIPSRegisters::r31; }
  79     static constexpr unsigned numberOfRegisters() { return lastRegister() - firstRegister() + 1; }
  80 
  81     static constexpr SPRegisterID firstSPRegister() { return MIPSRegisters::fir; }
  82     static constexpr SPRegisterID lastSPRegister() { return MIPSRegisters::pc; }
  83     static constexpr unsigned numberOfSPRegisters() { return lastSPRegister() - firstSPRegister() + 1; }
  84 
  85     static constexpr FPRegisterID firstFPRegister() { return MIPSRegisters::f0; }
  86     static constexpr FPRegisterID lastFPRegister() { return MIPSRegisters::f31; }
  87     static constexpr unsigned numberOfFPRegisters() { return lastFPRegister() - firstFPRegister() + 1; }
  88 
  89     static const char* gprName(RegisterID id)
  90     {
  91         ASSERT(id &gt;= firstRegister() &amp;&amp; id &lt;= lastRegister());
  92         static const char* const nameForRegister[numberOfRegisters()] = {
  93 #define REGISTER_NAME(id, name, r, c) name,
  94         FOR_EACH_GP_REGISTER(REGISTER_NAME)
  95 #undef REGISTER_NAME
  96         };
  97         return nameForRegister[id];
  98     }
  99 
 100     static const char* sprName(SPRegisterID id)
 101     {
 102         ASSERT(id &gt;= firstSPRegister() &amp;&amp; id &lt;= lastSPRegister());
 103         static const char* const nameForRegister[numberOfSPRegisters()] = {
 104 #define REGISTER_NAME(id, name, idx) name,
 105         FOR_EACH_SP_REGISTER(REGISTER_NAME)
 106 #undef REGISTER_NAME
 107         };
 108         return nameForRegister[id];
 109     }
 110 
 111     static const char* fprName(FPRegisterID id)
 112     {
 113         ASSERT(id &gt;= firstFPRegister() &amp;&amp; id &lt;= lastFPRegister());
 114         static const char* const nameForRegister[numberOfFPRegisters()] = {
 115 #define REGISTER_NAME(id, name, r, cs) name,
 116         FOR_EACH_FP_REGISTER(REGISTER_NAME)
 117 #undef REGISTER_NAME
 118         };
 119         return nameForRegister[id];
 120     }
 121 
 122     MIPSAssembler()
 123         : m_indexOfLastWatchpoint(INT_MIN)
 124         , m_indexOfTailOfLastWatchpoint(INT_MIN)
 125     {
 126     }
 127 
 128     AssemblerBuffer&amp; buffer() { return m_buffer; }
 129 
 130     // MIPS instruction opcode field position
 131     enum {
 132         OP_SH_RD = 11,
 133         OP_SH_RT = 16,
 134         OP_SH_RS = 21,
 135         OP_SH_SHAMT = 6,
 136         OP_SH_CODE = 16,
 137         OP_SH_FD = 6,
 138         OP_SH_FS = 11,
 139         OP_SH_FT = 16,
 140         OP_SH_MSB = 11,
 141         OP_SH_LSB = 6
 142     };
 143 
 144     // FCSR Bits
 145     enum {
 146         FP_CAUSE_INVALID_OPERATION = 1 &lt;&lt; 16
 147     };
 148 
 149     void emitInst(MIPSWord op)
 150     {
 151         void* oldBase = m_buffer.data();
 152 
 153         m_buffer.putInt(op);
 154 
 155         void* newBase = m_buffer.data();
 156         if (oldBase != newBase)
 157             relocateJumps(oldBase, newBase);
 158     }
 159 
 160     void nop()
 161     {
 162         emitInst(0x00000000);
 163     }
 164 
<a name="1" id="anc1"></a><span class="line-modified"> 165     using CopyFunction = void*(&amp;)(void*, const void*, size_t);</span>
<span class="line-modified"> 166 </span>
<span class="line-added"> 167     template &lt;CopyFunction copy&gt;</span>
<span class="line-added"> 168     static void fillNops(void* base, size_t size)</span>
 169     {
 170         UNUSED_PARAM(copy);
 171         RELEASE_ASSERT(!(size % sizeof(int32_t)));
 172 
 173         int32_t* ptr = static_cast&lt;int32_t*&gt;(base);
 174         const size_t num32s = size / sizeof(int32_t);
 175         const int32_t insn = 0x00000000;
 176         for (size_t i = 0; i &lt; num32s; i++)
 177             *ptr++ = insn;
 178     }
 179 
 180     void sync()
 181     {
 182         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=169984
 183         // We might get a performance improvements by using SYNC_MB in some or
 184         // all cases.
 185         emitInst(0x0000000f);
 186     }
 187 
 188     /* Need to insert one load data delay nop for mips1.  */
 189     void loadDelayNop()
 190     {
 191 #if WTF_MIPS_ISA(1)
 192         nop();
 193 #endif
 194     }
 195 
 196     /* Need to insert one coprocessor access delay nop for mips1.  */
 197     void copDelayNop()
 198     {
 199 #if WTF_MIPS_ISA(1)
 200         nop();
 201 #endif
 202     }
 203 
 204     void move(RegisterID rd, RegisterID rs)
 205     {
 206         /* addu */
 207         emitInst(0x00000021 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS));
 208     }
 209 
 210     /* Set an immediate value to a register.  This may generate 1 or 2
 211        instructions.  */
 212     void li(RegisterID dest, int imm)
 213     {
 214         if (imm &gt;= -32768 &amp;&amp; imm &lt;= 32767)
 215             addiu(dest, MIPSRegisters::zero, imm);
 216         else if (imm &gt;= 0 &amp;&amp; imm &lt; 65536)
 217             ori(dest, MIPSRegisters::zero, imm);
 218         else {
 219             lui(dest, imm &gt;&gt; 16);
 220             if (imm &amp; 0xffff)
 221                 ori(dest, dest, imm);
 222         }
 223     }
 224 
 225     void ext(RegisterID rt, RegisterID rs, int pos, int size)
 226     {
 227         int msb = size - 1;
 228         emitInst(0x7c000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (pos &lt;&lt; OP_SH_LSB) | (msb &lt;&lt; OP_SH_MSB));
 229     }
 230 
 231     void mfhc1(RegisterID rt, FPRegisterID fs)
 232     {
 233         emitInst(0x4460000 | (rt &lt;&lt; OP_SH_RT) | (fs &lt;&lt; OP_SH_FS));
 234     }
 235 
 236     void lui(RegisterID rt, int imm)
 237     {
 238         emitInst(0x3c000000 | (rt &lt;&lt; OP_SH_RT) | (imm &amp; 0xffff));
 239     }
 240 
 241     void clz(RegisterID rd, RegisterID rs)
 242     {
 243         emitInst(0x70000020 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rd &lt;&lt; OP_SH_RT));
 244     }
 245 
 246     void addiu(RegisterID rt, RegisterID rs, int imm)
 247     {
 248         emitInst(0x24000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 249     }
 250 
 251     void addu(RegisterID rd, RegisterID rs, RegisterID rt)
 252     {
 253         emitInst(0x00000021 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 254     }
 255 
 256     void subu(RegisterID rd, RegisterID rs, RegisterID rt)
 257     {
 258         emitInst(0x00000023 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 259     }
 260 
 261     void mult(RegisterID rs, RegisterID rt)
 262     {
 263         emitInst(0x00000018 | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 264     }
 265 
 266     void div(RegisterID rs, RegisterID rt)
 267     {
 268         emitInst(0x0000001a | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 269     }
 270 
 271     void mfhi(RegisterID rd)
 272     {
 273         emitInst(0x00000010 | (rd &lt;&lt; OP_SH_RD));
 274     }
 275 
 276     void mflo(RegisterID rd)
 277     {
 278         emitInst(0x00000012 | (rd &lt;&lt; OP_SH_RD));
 279     }
 280 
 281     void mul(RegisterID rd, RegisterID rs, RegisterID rt)
 282     {
 283 #if WTF_MIPS_ISA_AT_LEAST(32)
 284         emitInst(0x70000002 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 285 #else
 286         mult(rs, rt);
 287         mflo(rd);
 288 #endif
 289     }
 290 
 291     void andInsn(RegisterID rd, RegisterID rs, RegisterID rt)
 292     {
 293         emitInst(0x00000024 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 294     }
 295 
 296     void andi(RegisterID rt, RegisterID rs, int imm)
 297     {
 298         emitInst(0x30000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 299     }
 300 
 301     void nor(RegisterID rd, RegisterID rs, RegisterID rt)
 302     {
 303         emitInst(0x00000027 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 304     }
 305 
 306     void orInsn(RegisterID rd, RegisterID rs, RegisterID rt)
 307     {
 308         emitInst(0x00000025 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 309     }
 310 
 311     void ori(RegisterID rt, RegisterID rs, int imm)
 312     {
 313         emitInst(0x34000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 314     }
 315 
 316     void xorInsn(RegisterID rd, RegisterID rs, RegisterID rt)
 317     {
 318         emitInst(0x00000026 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 319     }
 320 
 321     void xori(RegisterID rt, RegisterID rs, int imm)
 322     {
 323         emitInst(0x38000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 324     }
 325 
 326     void slt(RegisterID rd, RegisterID rs, RegisterID rt)
 327     {
 328         emitInst(0x0000002a | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 329     }
 330 
 331     void sltu(RegisterID rd, RegisterID rs, RegisterID rt)
 332     {
 333         emitInst(0x0000002b | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 334     }
 335 
 336     void slti(RegisterID rt, RegisterID rs, int imm)
 337     {
 338         emitInst(0x28000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 339     }
 340 
 341     void sltiu(RegisterID rt, RegisterID rs, int imm)
 342     {
 343         emitInst(0x2c000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 344     }
 345 
 346     void sll(RegisterID rd, RegisterID rt, int shamt)
 347     {
 348         emitInst(0x00000000 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | ((shamt &amp; 0x1f) &lt;&lt; OP_SH_SHAMT));
 349     }
 350 
 351     void sllv(RegisterID rd, RegisterID rt, RegisterID rs)
 352     {
 353         emitInst(0x00000004 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS));
 354     }
 355 
 356     void sra(RegisterID rd, RegisterID rt, int shamt)
 357     {
 358         emitInst(0x00000003 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | ((shamt &amp; 0x1f) &lt;&lt; OP_SH_SHAMT));
 359     }
 360 
 361     void srav(RegisterID rd, RegisterID rt, RegisterID rs)
 362     {
 363         emitInst(0x00000007 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS));
 364     }
 365 
 366     void srl(RegisterID rd, RegisterID rt, int shamt)
 367     {
 368         emitInst(0x00000002 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | ((shamt &amp; 0x1f) &lt;&lt; OP_SH_SHAMT));
 369     }
 370 
 371     void srlv(RegisterID rd, RegisterID rt, RegisterID rs)
 372     {
 373         emitInst(0x00000006 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS));
 374     }
 375 
 376     void lb(RegisterID rt, RegisterID rs, int offset)
 377     {
 378         emitInst(0x80000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 379         loadDelayNop();
 380     }
 381 
 382     void lbu(RegisterID rt, RegisterID rs, int offset)
 383     {
 384         emitInst(0x90000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 385         loadDelayNop();
 386     }
 387 
 388     void lw(RegisterID rt, RegisterID rs, int offset)
 389     {
 390         emitInst(0x8c000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 391         loadDelayNop();
 392     }
 393 
 394     void lwl(RegisterID rt, RegisterID rs, int offset)
 395     {
 396         emitInst(0x88000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 397         loadDelayNop();
 398     }
 399 
 400     void lwr(RegisterID rt, RegisterID rs, int offset)
 401     {
 402         emitInst(0x98000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 403         loadDelayNop();
 404     }
 405 
 406     void lh(RegisterID rt, RegisterID rs, int offset)
 407     {
 408         emitInst(0x84000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 409         loadDelayNop();
 410     }
 411 
 412     void lhu(RegisterID rt, RegisterID rs, int offset)
 413     {
 414         emitInst(0x94000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 415         loadDelayNop();
 416     }
 417 
 418     void sb(RegisterID rt, RegisterID rs, int offset)
 419     {
 420         emitInst(0xa0000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 421     }
 422 
 423     void sh(RegisterID rt, RegisterID rs, int offset)
 424     {
 425         emitInst(0xa4000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 426     }
 427 
 428     void sw(RegisterID rt, RegisterID rs, int offset)
 429     {
 430         emitInst(0xac000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 431     }
 432 
 433     void jr(RegisterID rs)
 434     {
 435         emitInst(0x00000008 | (rs &lt;&lt; OP_SH_RS));
 436     }
 437 
 438     void jalr(RegisterID rs)
 439     {
 440         emitInst(0x0000f809 | (rs &lt;&lt; OP_SH_RS));
 441     }
 442 
 443     void jal()
 444     {
 445         emitInst(0x0c000000);
 446     }
 447 
 448     void bkpt()
 449     {
 450         int value = 512; /* BRK_BUG */
 451         emitInst(0x0000000d | ((value &amp; 0x3ff) &lt;&lt; OP_SH_CODE));
 452     }
 453 
 454     static bool isBkpt(void* address)
 455     {
 456         int value = 512; /* BRK_BUG */
 457         MIPSWord expected = (0x0000000d | ((value &amp; 0x3ff) &lt;&lt; OP_SH_CODE));
 458         MIPSWord candidateInstruction = *reinterpret_cast&lt;MIPSWord*&gt;(address);
 459         return candidateInstruction == expected;
 460     }
 461 
 462     void bgez(RegisterID rs, int imm)
 463     {
 464         emitInst(0x04010000 | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 465     }
 466 
 467     void bltz(RegisterID rs, int imm)
 468     {
 469         emitInst(0x04000000 | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 470     }
 471 
 472     void beq(RegisterID rs, RegisterID rt, int imm)
 473     {
 474         emitInst(0x10000000 | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT) | (imm &amp; 0xffff));
 475     }
 476 
 477     void bne(RegisterID rs, RegisterID rt, int imm)
 478     {
 479         emitInst(0x14000000 | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT) | (imm &amp; 0xffff));
 480     }
 481 
 482     void bc1t()
 483     {
 484         emitInst(0x45010000);
 485     }
 486 
 487     void bc1f()
 488     {
 489         emitInst(0x45000000);
 490     }
 491 
 492     void appendJump()
 493     {
 494         m_jumps.append(m_buffer.label());
 495     }
 496 
 497     void addd(FPRegisterID fd, FPRegisterID fs, FPRegisterID ft)
 498     {
 499         emitInst(0x46200000 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 500     }
 501 
 502     void subd(FPRegisterID fd, FPRegisterID fs, FPRegisterID ft)
 503     {
 504         emitInst(0x46200001 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 505     }
 506 
 507     void muld(FPRegisterID fd, FPRegisterID fs, FPRegisterID ft)
 508     {
 509         emitInst(0x46200002 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 510     }
 511 
 512     void divd(FPRegisterID fd, FPRegisterID fs, FPRegisterID ft)
 513     {
 514         emitInst(0x46200003 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 515     }
 516 
 517     void lwc1(FPRegisterID ft, RegisterID rs, int offset)
 518     {
 519         emitInst(0xc4000000 | (ft &lt;&lt; OP_SH_FT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 520         copDelayNop();
 521     }
 522 
 523     void ldc1(FPRegisterID ft, RegisterID rs, int offset)
 524     {
 525         emitInst(0xd4000000 | (ft &lt;&lt; OP_SH_FT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 526     }
 527 
 528     void swc1(FPRegisterID ft, RegisterID rs, int offset)
 529     {
 530         emitInst(0xe4000000 | (ft &lt;&lt; OP_SH_FT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 531     }
 532 
 533     void sdc1(FPRegisterID ft, RegisterID rs, int offset)
 534     {
 535         emitInst(0xf4000000 | (ft &lt;&lt; OP_SH_FT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 536     }
 537 
 538     void mtc1(RegisterID rt, FPRegisterID fs)
 539     {
 540         emitInst(0x44800000 | (fs &lt;&lt; OP_SH_FS) | (rt &lt;&lt; OP_SH_RT));
 541         copDelayNop();
 542     }
 543 
 544     void mthc1(RegisterID rt, FPRegisterID fs)
 545     {
 546         emitInst(0x44e00000 | (fs &lt;&lt; OP_SH_FS) | (rt &lt;&lt; OP_SH_RT));
 547         copDelayNop();
 548     }
 549 
 550     void mfc1(RegisterID rt, FPRegisterID fs)
 551     {
 552         emitInst(0x44000000 | (fs &lt;&lt; OP_SH_FS) | (rt &lt;&lt; OP_SH_RT));
 553         copDelayNop();
 554     }
 555 
 556     void sqrtd(FPRegisterID fd, FPRegisterID fs)
 557     {
 558         emitInst(0x46200004 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 559     }
 560 
 561     void absd(FPRegisterID fd, FPRegisterID fs)
 562     {
 563         emitInst(0x46200005 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 564     }
 565 
 566     void movd(FPRegisterID fd, FPRegisterID fs)
 567     {
 568         emitInst(0x46200006 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 569     }
 570 
 571     void negd(FPRegisterID fd, FPRegisterID fs)
 572     {
 573         emitInst(0x46200007 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 574     }
 575 
 576     void truncwd(FPRegisterID fd, FPRegisterID fs)
 577     {
 578         emitInst(0x4620000d | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 579     }
 580 
 581     void cvtdw(FPRegisterID fd, FPRegisterID fs)
 582     {
 583         emitInst(0x46800021 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 584     }
 585 
 586     void cvtds(FPRegisterID fd, FPRegisterID fs)
 587     {
 588         emitInst(0x46000021 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 589     }
 590 
 591     void cvtwd(FPRegisterID fd, FPRegisterID fs)
 592     {
 593         emitInst(0x46200024 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 594     }
 595 
 596     void cvtsd(FPRegisterID fd, FPRegisterID fs)
 597     {
 598         emitInst(0x46200020 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 599     }
 600 
 601     void ceqd(FPRegisterID fs, FPRegisterID ft)
 602     {
 603         emitInst(0x46200032 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 604         copDelayNop();
 605     }
 606 
 607     void cngtd(FPRegisterID fs, FPRegisterID ft)
 608     {
 609         emitInst(0x4620003f | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 610         copDelayNop();
 611     }
 612 
 613     void cnged(FPRegisterID fs, FPRegisterID ft)
 614     {
 615         emitInst(0x4620003d | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 616         copDelayNop();
 617     }
 618 
 619     void cltd(FPRegisterID fs, FPRegisterID ft)
 620     {
 621         emitInst(0x4620003c | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 622         copDelayNop();
 623     }
 624 
 625     void cled(FPRegisterID fs, FPRegisterID ft)
 626     {
 627         emitInst(0x4620003e | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 628         copDelayNop();
 629     }
 630 
 631     void cueqd(FPRegisterID fs, FPRegisterID ft)
 632     {
 633         emitInst(0x46200033 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 634         copDelayNop();
 635     }
 636 
 637     void coled(FPRegisterID fs, FPRegisterID ft)
 638     {
 639         emitInst(0x46200036 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 640         copDelayNop();
 641     }
 642 
 643     void coltd(FPRegisterID fs, FPRegisterID ft)
 644     {
 645         emitInst(0x46200034 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 646         copDelayNop();
 647     }
 648 
 649     void culed(FPRegisterID fs, FPRegisterID ft)
 650     {
 651         emitInst(0x46200037 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 652         copDelayNop();
 653     }
 654 
 655     void cultd(FPRegisterID fs, FPRegisterID ft)
 656     {
 657         emitInst(0x46200035 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 658         copDelayNop();
 659     }
 660 
 661     void cfc1(RegisterID rt, SPRegisterID fs)
 662     {
 663         emitInst(0x44400000 | (rt &lt;&lt; OP_SH_RT) | (fs &lt;&lt; OP_SH_FS));
 664         copDelayNop();
 665     }
 666 
 667     // General helpers
 668 
 669     AssemblerLabel labelIgnoringWatchpoints()
 670     {
 671         return m_buffer.label();
 672     }
 673 
 674     AssemblerLabel labelForWatchpoint()
 675     {
 676         AssemblerLabel result = m_buffer.label();
 677         if (static_cast&lt;int&gt;(result.m_offset) != m_indexOfLastWatchpoint)
 678             result = label();
 679         m_indexOfLastWatchpoint = result.m_offset;
 680         m_indexOfTailOfLastWatchpoint = result.m_offset + maxJumpReplacementSize();
 681         return result;
 682     }
 683 
 684     AssemblerLabel label()
 685     {
 686         AssemblerLabel result = m_buffer.label();
 687         while (UNLIKELY(static_cast&lt;int&gt;(result.m_offset) &lt; m_indexOfTailOfLastWatchpoint)) {
 688             nop();
 689             result = m_buffer.label();
 690         }
 691         return result;
 692     }
 693 
 694     AssemblerLabel align(int alignment)
 695     {
 696         while (!m_buffer.isAligned(alignment))
 697             bkpt();
 698 
 699         return label();
 700     }
 701 
 702     static void* getRelocatedAddress(void* code, AssemblerLabel label)
 703     {
 704         return reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;char*&gt;(code) + label.m_offset);
 705     }
 706 
 707     static int getDifferenceBetweenLabels(AssemblerLabel a, AssemblerLabel b)
 708     {
 709         return b.m_offset - a.m_offset;
 710     }
 711 
 712     // Assembler admin methods:
 713 
 714     size_t codeSize() const
 715     {
 716         return m_buffer.codeSize();
 717     }
 718 
 719     unsigned debugOffset() { return m_buffer.debugOffset(); }
 720 
 721     // Assembly helpers for moving data between fp and registers.
 722     void vmov(RegisterID rd1, RegisterID rd2, FPRegisterID rn)
 723     {
 724 #if WTF_MIPS_ISA_REV(2) &amp;&amp; WTF_MIPS_FP64
 725         mfc1(rd1, rn);
 726         mfhc1(rd2, rn);
 727 #else
 728         mfc1(rd1, rn);
 729         mfc1(rd2, FPRegisterID(rn + 1));
 730 #endif
 731     }
 732 
 733     void vmov(FPRegisterID rd, RegisterID rn1, RegisterID rn2)
 734     {
 735 #if WTF_MIPS_ISA_REV(2) &amp;&amp; WTF_MIPS_FP64
 736         mtc1(rn1, rd);
 737         mthc1(rn2, rd);
 738 #else
 739         mtc1(rn1, rd);
 740         mtc1(rn2, FPRegisterID(rd + 1));
 741 #endif
 742     }
 743 
 744     static unsigned getCallReturnOffset(AssemblerLabel call)
 745     {
 746         // The return address is after a call and a delay slot instruction
 747         return call.m_offset;
 748     }
 749 
 750     // Linking &amp; patching:
 751     //
 752     // &#39;link&#39; and &#39;patch&#39; methods are for use on unprotected code - such as the code
 753     // within the AssemblerBuffer, and code being patched by the patch buffer. Once
 754     // code has been finalized it is (platform support permitting) within a non-
 755     // writable region of memory; to modify the code in an execute-only execuable
 756     // pool the &#39;repatch&#39; and &#39;relink&#39; methods should be used.
 757 
 758     static size_t linkDirectJump(void* code, void* to)
 759     {
 760         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(code));
 761         size_t ops = 0;
 762         int32_t slotAddr = reinterpret_cast&lt;int&gt;(insn) + 4;
 763         int32_t toAddr = reinterpret_cast&lt;int&gt;(to);
 764 
 765         if ((slotAddr &amp; 0xf0000000) != (toAddr &amp; 0xf0000000)) {
 766             // lui
 767             *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((toAddr &gt;&gt; 16) &amp; 0xffff);
 768             ++insn;
 769             // ori
 770             *insn = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (toAddr &amp; 0xffff);
 771             ++insn;
 772             // jr
 773             *insn = 0x00000008 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS);
 774             ++insn;
 775             ops = 4 * sizeof(MIPSWord);
 776         } else {
 777             // j
 778             *insn = 0x08000000 | ((toAddr &amp; 0x0fffffff) &gt;&gt; 2);
 779             ++insn;
 780             ops = 2 * sizeof(MIPSWord);
 781         }
 782         // nop
 783         *insn = 0x00000000;
 784         return ops;
 785     }
 786 
 787     void linkJump(AssemblerLabel from, AssemblerLabel to)
 788     {
 789         ASSERT(to.isSet());
 790         ASSERT(from.isSet());
 791         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(m_buffer.data()) + from.m_offset);
 792         MIPSWord* toPos = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(m_buffer.data()) + to.m_offset);
 793 
 794         ASSERT(!(*(insn - 1)) &amp;&amp; !(*(insn - 2)) &amp;&amp; !(*(insn - 3)) &amp;&amp; !(*(insn - 5)));
 795         insn = insn - 6;
 796         linkWithOffset(insn, toPos);
 797     }
 798 
 799     static void linkJump(void* code, AssemblerLabel from, void* to)
 800     {
 801         ASSERT(from.isSet());
 802         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(code) + from.m_offset);
 803 
 804         ASSERT(!(*(insn - 1)) &amp;&amp; !(*(insn - 2)) &amp;&amp; !(*(insn - 3)) &amp;&amp; !(*(insn - 5)));
 805         insn = insn - 6;
 806         linkWithOffset(insn, to);
 807     }
 808 
 809     static void linkCall(void* code, AssemblerLabel from, void* to)
 810     {
 811         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(code) + from.m_offset);
 812         linkCallInternal(insn, to);
 813     }
 814 
 815     static void linkPointer(void* code, AssemblerLabel from, void* to)
 816     {
 817         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(code) + from.m_offset);
 818         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 819         *insn = (*insn &amp; 0xffff0000) | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 16) &amp; 0xffff);
 820         insn++;
 821         ASSERT((*insn &amp; 0xfc000000) == 0x34000000); // ori
 822         *insn = (*insn &amp; 0xffff0000) | (reinterpret_cast&lt;intptr_t&gt;(to) &amp; 0xffff);
 823     }
 824 
 825     static void relinkJump(void* from, void* to)
 826     {
 827         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
 828 
 829         ASSERT(!(*(insn - 1)) &amp;&amp; !(*(insn - 5)));
 830         insn = insn - 6;
 831         int flushSize = linkWithOffset(insn, to);
 832 
 833         cacheFlush(insn, flushSize);
 834     }
 835 
 836     static void relinkJumpToNop(void* from)
 837     {
 838         relinkJump(from, from);
 839     }
 840 
 841     static void relinkCall(void* from, void* to)
 842     {
 843         void* start;
 844         int size = linkCallInternal(from, to);
 845         if (size == sizeof(MIPSWord))
 846             start = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;intptr_t&gt;(from) - 2 * sizeof(MIPSWord));
 847         else
 848             start = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;intptr_t&gt;(from) - 4 * sizeof(MIPSWord));
 849 
 850         cacheFlush(start, size);
 851     }
 852 
 853     static void repatchInt32(void* from, int32_t to)
 854     {
 855         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
 856         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 857         *insn = (*insn &amp; 0xffff0000) | ((to &gt;&gt; 16) &amp; 0xffff);
 858         insn++;
 859         ASSERT((*insn &amp; 0xfc000000) == 0x34000000); // ori
 860         *insn = (*insn &amp; 0xffff0000) | (to &amp; 0xffff);
 861         cacheFlush(from, 2 * sizeof(MIPSWord));
 862     }
 863 
 864     static int32_t readInt32(void* from)
 865     {
 866         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
 867         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 868         int32_t result = (*insn &amp; 0x0000ffff) &lt;&lt; 16;
 869         insn++;
 870         ASSERT((*insn &amp; 0xfc000000) == 0x34000000); // ori
 871         result |= *insn &amp; 0x0000ffff;
 872         return result;
 873     }
 874 
 875     static void repatchCompact(void* where, int32_t value)
 876     {
 877         repatchInt32(where, value);
 878     }
 879 
 880     static void repatchPointer(void* from, void* to)
 881     {
 882         repatchInt32(from, reinterpret_cast&lt;int32_t&gt;(to));
 883     }
 884 
 885     static void* readPointer(void* from)
 886     {
 887         return reinterpret_cast&lt;void*&gt;(readInt32(from));
 888     }
 889 
 890     static void* readCallTarget(void* from)
 891     {
 892         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
 893         insn -= 4;
 894         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 895         int32_t result = (*insn &amp; 0x0000ffff) &lt;&lt; 16;
 896         insn++;
 897         ASSERT((*insn &amp; 0xfc000000) == 0x34000000); // ori
 898         result |= *insn &amp; 0x0000ffff;
 899         return reinterpret_cast&lt;void*&gt;(result);
 900     }
 901 
 902     static void cacheFlush(void* code, size_t size)
 903     {
 904         intptr_t end = reinterpret_cast&lt;intptr_t&gt;(code) + size;
 905         __builtin___clear_cache(reinterpret_cast&lt;char*&gt;(code), reinterpret_cast&lt;char*&gt;(end));
 906     }
 907 
 908     static ptrdiff_t maxJumpReplacementSize()
 909     {
 910         return sizeof(MIPSWord) * 4;
 911     }
 912 
 913     static constexpr ptrdiff_t patchableJumpSize()
 914     {
 915         return sizeof(MIPSWord) * 8;
 916     }
 917 
 918     static void revertJumpToMove(void* instructionStart, RegisterID rt, int imm)
 919     {
 920         MIPSWord* insn = static_cast&lt;MIPSWord*&gt;(instructionStart);
 921         size_t codeSize = 2 * sizeof(MIPSWord);
 922 
 923         // lui
 924         *insn = 0x3c000000 | (rt &lt;&lt; OP_SH_RT) | ((imm &gt;&gt; 16) &amp; 0xffff);
 925         ++insn;
 926         // ori
 927         *insn = 0x34000000 | (rt &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT) | (imm &amp; 0xffff);
 928         ++insn;
 929         // if jr $t9
 930         if (*insn == 0x03200008) {
 931             *insn = 0x00000000;
 932             codeSize += sizeof(MIPSWord);
 933         }
 934         cacheFlush(instructionStart, codeSize);
 935     }
 936 
 937     static void replaceWithJump(void* instructionStart, void* to)
 938     {
 939         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(instructionStart) &amp; 3));
 940         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(to) &amp; 3));
 941         size_t ops = linkDirectJump(instructionStart, to);
 942         cacheFlush(instructionStart, ops);
 943     }
 944 
 945     static void replaceWithLoad(void* instructionStart)
 946     {
 947         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(instructionStart);
 948         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 949         insn++;
 950         ASSERT((*insn &amp; 0xfc0007ff) == 0x00000021); // addu
 951         insn++;
 952         *insn = 0x8c000000 | ((*insn) &amp; 0x3ffffff); // lw
 953         cacheFlush(insn, 4);
 954     }
 955 
 956     static void replaceWithAddressComputation(void* instructionStart)
 957     {
 958         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(instructionStart);
 959         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 960         insn++;
 961         ASSERT((*insn &amp; 0xfc0007ff) == 0x00000021); // addu
 962         insn++;
 963         *insn = 0x24000000 | ((*insn) &amp; 0x3ffffff); // addiu
 964         cacheFlush(insn, 4);
 965     }
 966 
 967     /* Update each jump in the buffer of newBase.  */
 968     void relocateJumps(void* oldBase, void* newBase)
 969     {
 970         // Check each jump
 971         for (Jumps::Iterator iter = m_jumps.begin(); iter != m_jumps.end(); ++iter) {
 972             int pos = iter-&gt;m_offset;
 973             MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(newBase) + pos);
 974             insn = insn + 2;
 975             // Need to make sure we have 5 valid instructions after pos
 976             if ((unsigned)pos &gt;= m_buffer.codeSize() - 5 * sizeof(MIPSWord))
 977                 continue;
 978 
 979             if ((*insn &amp; 0xfc000000) == 0x08000000) { // j
 980                 int offset = *insn &amp; 0x03ffffff;
 981                 int oldInsnAddress = (int)insn - (int)newBase + (int)oldBase;
 982                 int topFourBits = (oldInsnAddress + 4) &gt;&gt; 28;
 983                 int oldTargetAddress = (topFourBits &lt;&lt; 28) | (offset &lt;&lt; 2);
 984                 int newTargetAddress = oldTargetAddress - (int)oldBase + (int)newBase;
 985                 int newInsnAddress = (int)insn;
 986                 if (((newInsnAddress + 4) &gt;&gt; 28) == (newTargetAddress &gt;&gt; 28))
 987                     *insn = 0x08000000 | ((newTargetAddress &gt;&gt; 2) &amp; 0x3ffffff);
 988                 else {
 989                     /* lui */
 990                     *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((newTargetAddress &gt;&gt; 16) &amp; 0xffff);
 991                     /* ori */
 992                     *(insn + 1) = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (newTargetAddress &amp; 0xffff);
 993                     /* jr */
 994                     *(insn + 2) = 0x00000008 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS);
 995                 }
 996             } else if ((*insn &amp; 0xffe00000) == 0x3c000000) { // lui
 997                 int high = (*insn &amp; 0xffff) &lt;&lt; 16;
 998                 int low = *(insn + 1) &amp; 0xffff;
 999                 int oldTargetAddress = high | low;
1000                 int newTargetAddress = oldTargetAddress - (int)oldBase + (int)newBase;
1001                 /* lui */
1002                 *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((newTargetAddress &gt;&gt; 16) &amp; 0xffff);
1003                 /* ori */
1004                 *(insn + 1) = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (newTargetAddress &amp; 0xffff);
1005             }
1006         }
1007     }
1008 
1009 private:
1010     static int linkWithOffset(MIPSWord* insn, void* to)
1011     {
1012         ASSERT((*insn &amp; 0xfc000000) == 0x10000000 // beq
1013             || (*insn &amp; 0xfc000000) == 0x14000000 // bne
1014             || (*insn &amp; 0xffff0000) == 0x45010000 // bc1t
1015             || (*insn &amp; 0xffff0000) == 0x45000000); // bc1f
1016         intptr_t diff = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(insn) - 4) &gt;&gt; 2;
1017 
1018         if (diff &lt; -32768 || diff &gt; 32767 || *(insn + 2) != 0x10000003) {
1019             /*
1020                 Convert the sequence:
1021                   beq $2, $3, target
1022                   nop
1023                   b 1f
1024                   nop
1025                   nop
1026                   nop
1027                 1:
1028 
1029                 to the new sequence if possible:
1030                   bne $2, $3, 1f
1031                   nop
1032                   j    target
1033                   nop
1034                   nop
1035                   nop
1036                 1:
1037 
1038                 OR to the new sequence:
1039                   bne $2, $3, 1f
1040                   nop
1041                   lui $25, target &gt;&gt; 16
1042                   ori $25, $25, target &amp; 0xffff
1043                   jr $25
1044                   nop
1045                 1:
1046 
1047                 Note: beq/bne/bc1t/bc1f are converted to bne/beq/bc1f/bc1t.
1048             */
1049 
1050             if (*(insn + 2) == 0x10000003) {
1051                 if ((*insn &amp; 0xfc000000) == 0x10000000) // beq
1052                     *insn = (*insn &amp; 0x03ff0000) | 0x14000005; // bne
1053                 else if ((*insn &amp; 0xfc000000) == 0x14000000) // bne
1054                     *insn = (*insn &amp; 0x03ff0000) | 0x10000005; // beq
1055                 else if ((*insn &amp; 0xffff0000) == 0x45010000) // bc1t
1056                     *insn = 0x45000005; // bc1f
1057                 else if ((*insn &amp; 0xffff0000) == 0x45000000) // bc1f
1058                     *insn = 0x45010005; // bc1t
1059                 else
1060                     ASSERT(0);
1061             }
1062 
1063             insn = insn + 2;
1064             if ((reinterpret_cast&lt;intptr_t&gt;(insn) + 4) &gt;&gt; 28
1065                 == reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 28) {
1066                 *insn = 0x08000000 | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 2) &amp; 0x3ffffff);
1067                 *(insn + 1) = 0;
1068                 return 4 * sizeof(MIPSWord);
1069             }
1070 
1071             intptr_t newTargetAddress = reinterpret_cast&lt;intptr_t&gt;(to);
1072             /* lui */
1073             *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((newTargetAddress &gt;&gt; 16) &amp; 0xffff);
1074             /* ori */
1075             *(insn + 1) = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (newTargetAddress &amp; 0xffff);
1076             /* jr */
1077             *(insn + 2) = 0x00000008 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS);
1078             return 5 * sizeof(MIPSWord);
1079         }
1080 
1081         *insn = (*insn &amp; 0xffff0000) | (diff &amp; 0xffff);
1082         return sizeof(MIPSWord);
1083     }
1084 
1085     static int linkCallInternal(void* from, void* to)
1086     {
1087         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
1088         insn = insn - 4;
1089 
1090         if ((*(insn + 2) &amp; 0xfc000000) == 0x0c000000) { // jal
1091             if ((reinterpret_cast&lt;intptr_t&gt;(from) - 4) &gt;&gt; 28
1092                 == reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 28) {
1093                 *(insn + 2) = 0x0c000000 | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 2) &amp; 0x3ffffff);
1094                 return sizeof(MIPSWord);
1095             }
1096 
1097             /* lui $25, (to &gt;&gt; 16) &amp; 0xffff */
1098             *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 16) &amp; 0xffff);
1099             /* ori $25, $25, to &amp; 0xffff */
1100             *(insn + 1) = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (reinterpret_cast&lt;intptr_t&gt;(to) &amp; 0xffff);
1101             /* jalr $25 */
1102             *(insn + 2) = 0x0000f809 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS);
1103             return 3 * sizeof(MIPSWord);
1104         }
1105 
1106         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
1107         ASSERT((*(insn + 1) &amp; 0xfc000000) == 0x34000000); // ori
1108 
1109         /* lui */
1110         *insn = (*insn &amp; 0xffff0000) | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 16) &amp; 0xffff);
1111         /* ori */
1112         *(insn + 1) = (*(insn + 1) &amp; 0xffff0000) | (reinterpret_cast&lt;intptr_t&gt;(to) &amp; 0xffff);
1113         return 2 * sizeof(MIPSWord);
1114     }
1115 
1116     AssemblerBuffer m_buffer;
1117     Jumps m_jumps;
1118     int m_indexOfLastWatchpoint;
1119     int m_indexOfTailOfLastWatchpoint;
1120 };
1121 
1122 } // namespace JSC
1123 
1124 #endif // ENABLE(ASSEMBLER) &amp;&amp; CPU(MIPS)
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
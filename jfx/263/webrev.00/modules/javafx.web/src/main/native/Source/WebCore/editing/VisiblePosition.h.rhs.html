<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/VisiblePosition.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004, 2008 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;EditingBoundary.h&quot;
 29 #include &quot;Position.h&quot;
 30 
 31 namespace WTF {
 32 class TextStream;
 33 }
 34 
 35 namespace WebCore {
 36 
 37 // VisiblePosition default affinity is downstream because
 38 // the callers do not really care (they just want the
 39 // deep position without regard to line position), and this
 40 // is cheaper than UPSTREAM
 41 #define VP_DEFAULT_AFFINITY DOWNSTREAM
 42 
 43 // Callers who do not know where on the line the position is,
 44 // but would like UPSTREAM if at a line break or DOWNSTREAM
 45 // otherwise, need a clear way to specify that.  The
 46 // constructors auto-correct UPSTREAM to DOWNSTREAM if the
 47 // position is not at a line break.
 48 #define VP_UPSTREAM_IF_POSSIBLE UPSTREAM
 49 
 50 class InlineBox;
 51 class Node;
 52 
 53 class VisiblePosition {
 54 public:
 55     // NOTE: UPSTREAM affinity will be used only if pos is at end of a wrapped line,
 56     // otherwise it will be converted to DOWNSTREAM
 57     VisiblePosition() : m_affinity(VP_DEFAULT_AFFINITY) { }
 58     WEBCORE_EXPORT VisiblePosition(const Position&amp;, EAffinity = VP_DEFAULT_AFFINITY);
 59 
 60     void clear() { m_deepPosition.clear(); }
 61 
 62     bool isNull() const { return m_deepPosition.isNull(); }
 63     bool isNotNull() const { return m_deepPosition.isNotNull(); }
 64     bool isOrphan() const { return m_deepPosition.isOrphan(); }
 65 
 66     Position deepEquivalent() const { return m_deepPosition; }
 67     EAffinity affinity() const { ASSERT(m_affinity == UPSTREAM || m_affinity == DOWNSTREAM); return m_affinity; }
 68     void setAffinity(EAffinity affinity) { m_affinity = affinity; }
 69 
 70     // FIXME: Change the following functions&#39; parameter from a boolean to StayInEditableContent.
 71 
 72     // next() and previous() will increment/decrement by a character cluster.
 73     WEBCORE_EXPORT VisiblePosition next(EditingBoundaryCrossingRule = CanCrossEditingBoundary, bool* reachedBoundary = nullptr) const;
 74     WEBCORE_EXPORT VisiblePosition previous(EditingBoundaryCrossingRule = CanCrossEditingBoundary, bool* reachedBoundary = nullptr) const;
 75     VisiblePosition honorEditingBoundaryAtOrBefore(const VisiblePosition&amp;, bool* reachedBoundary = nullptr) const;
 76     VisiblePosition honorEditingBoundaryAtOrAfter(const VisiblePosition&amp;, bool* reachedBoundary = nullptr) const;
 77 
 78     WEBCORE_EXPORT VisiblePosition left(bool stayInEditableContent = false, bool* reachedBoundary = nullptr) const;
 79     WEBCORE_EXPORT VisiblePosition right(bool stayInEditableContent = false, bool* reachedBoundary = nullptr) const;
 80 
 81     WEBCORE_EXPORT UChar32 characterAfter() const;
 82     UChar32 characterBefore() const { return previous().characterAfter(); }
 83 
 84     // FIXME: This does not handle [table, 0] correctly.
 85     Element* rootEditableElement() const { return m_deepPosition.isNotNull() ? m_deepPosition.deprecatedNode()-&gt;rootEditableElement() : 0; }
 86 
 87     void getInlineBoxAndOffset(InlineBox*&amp; inlineBox, int&amp; caretOffset) const
 88     {
 89         m_deepPosition.getInlineBoxAndOffset(m_affinity, inlineBox, caretOffset);
 90     }
 91 
 92     void getInlineBoxAndOffset(TextDirection primaryDirection, InlineBox*&amp; inlineBox, int&amp; caretOffset) const
 93     {
 94         m_deepPosition.getInlineBoxAndOffset(m_affinity, primaryDirection, inlineBox, caretOffset);
 95     }
 96 
 97     // Rect is local to the returned renderer
 98     WEBCORE_EXPORT LayoutRect localCaretRect(RenderObject*&amp;) const;
 99     // Bounds of (possibly transformed) caret in absolute coords
100     WEBCORE_EXPORT IntRect absoluteCaretBounds(bool* insideFixed = nullptr) const;
101     // Abs x/y position of the caret ignoring transforms.
102     // FIXME: navigation with transforms should be smarter.
103     WEBCORE_EXPORT int lineDirectionPointForBlockDirectionNavigation() const;
104 
<a name="1" id="anc1"></a><span class="line-added">105     WEBCORE_EXPORT FloatRect absoluteSelectionBoundsForLine() const;</span>
<span class="line-added">106 </span>
107     // This is a tentative enhancement of operator== to account for affinity.
108     // FIXME: Combine this function with operator==
109     bool equals(const VisiblePosition&amp;) const;
110 
111 #if ENABLE(TREE_DEBUGGING)
112     void debugPosition(const char* msg = &quot;&quot;) const;
113     void formatForDebugger(char* buffer, unsigned length) const;
114     void showTreeForThis() const;
115 #endif
116 
117 private:
118     void init(const Position&amp;, EAffinity);
119     Position canonicalPosition(const Position&amp;);
120 
121     Position leftVisuallyDistinctCandidate() const;
122     Position rightVisuallyDistinctCandidate() const;
123 
124     Position m_deepPosition;
125     EAffinity m_affinity;
126 };
127 
128 // FIXME: This shouldn&#39;t ignore affinity.
129 inline bool operator==(const VisiblePosition&amp; a, const VisiblePosition&amp; b)
130 {
131     return a.deepEquivalent() == b.deepEquivalent();
132 }
133 
134 inline bool operator!=(const VisiblePosition&amp; a, const VisiblePosition&amp; b)
135 {
136     return !(a == b);
137 }
138 
139 inline bool operator&lt;(const VisiblePosition&amp; a, const VisiblePosition&amp; b)
140 {
141     return a.deepEquivalent() &lt; b.deepEquivalent();
142 }
143 
144 inline bool operator&gt;(const VisiblePosition&amp; a, const VisiblePosition&amp; b)
145 {
146     return a.deepEquivalent() &gt; b.deepEquivalent();
147 }
148 
149 inline bool operator&lt;=(const VisiblePosition&amp; a, const VisiblePosition&amp; b)
150 {
151     return a.deepEquivalent() &lt;= b.deepEquivalent();
152 }
153 
154 inline bool operator&gt;=(const VisiblePosition&amp; a, const VisiblePosition&amp; b)
155 {
156     return a.deepEquivalent() &gt;= b.deepEquivalent();
157 }
158 
159 WEBCORE_EXPORT RefPtr&lt;Range&gt; makeRange(const VisiblePosition&amp;, const VisiblePosition&amp;);
160 bool setStart(Range*, const VisiblePosition&amp;);
161 bool setEnd(Range*, const VisiblePosition&amp;);
162 VisiblePosition startVisiblePosition(const Range*, EAffinity);
163 VisiblePosition endVisiblePosition(const Range*, EAffinity);
164 
165 WEBCORE_EXPORT Element* enclosingBlockFlowElement(const VisiblePosition&amp;);
166 
167 bool isFirstVisiblePositionInNode(const VisiblePosition&amp;, const Node*);
168 bool isLastVisiblePositionInNode(const VisiblePosition&amp;, const Node*);
169 
<a name="2" id="anc2"></a><span class="line-added">170 bool areVisiblePositionsInSameTreeScope(const VisiblePosition&amp;, const VisiblePosition&amp;);</span>
<span class="line-added">171 </span>
172 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, EAffinity);
173 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const VisiblePosition&amp;);
174 
175 } // namespace WebCore
176 
177 #if ENABLE(TREE_DEBUGGING)
178 // Outside the WebCore namespace for ease of invocation from the debugger.
179 void showTree(const WebCore::VisiblePosition*);
180 void showTree(const WebCore::VisiblePosition&amp;);
181 #endif
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerX86Common.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(ASSEMBLER) &amp;&amp; (CPU(X86) || CPU(X86_64))
 29 #include &quot;MacroAssembler.h&quot;
 30 
 31 #include &quot;ProbeContext.h&quot;
 32 #include &lt;wtf/InlineASM.h&gt;
 33 
 34 #if COMPILER(MSVC)
 35 #include &lt;intrin.h&gt;
 36 #endif
 37 
 38 namespace JSC {
 39 
 40 #if ENABLE(MASM_PROBE)
 41 
 42 extern &quot;C&quot; void ctiMasmProbeTrampoline();
 43 
 44 // The following are offsets for Probe::State fields accessed by the ctiMasmProbeTrampoline stub.
 45 
 46 #if CPU(X86)
 47 #define PTR_SIZE 4
 48 #else // CPU(X86_64)
 49 #define PTR_SIZE 8
 50 #endif
 51 
 52 #define PROBE_PROBE_FUNCTION_OFFSET (0 * PTR_SIZE)
 53 #define PROBE_ARG_OFFSET (1 * PTR_SIZE)
 54 #define PROBE_INIT_STACK_FUNCTION_OFFSET (2 * PTR_SIZE)
 55 #define PROBE_INIT_STACK_ARG_OFFSET (3 * PTR_SIZE)
 56 
 57 #define PROBE_FIRST_GPR_OFFSET (4 * PTR_SIZE)
 58 #define PROBE_CPU_EAX_OFFSET (PROBE_FIRST_GPR_OFFSET + (0 * PTR_SIZE))
 59 #define PROBE_CPU_ECX_OFFSET (PROBE_FIRST_GPR_OFFSET + (1 * PTR_SIZE))
 60 #define PROBE_CPU_EDX_OFFSET (PROBE_FIRST_GPR_OFFSET + (2 * PTR_SIZE))
 61 #define PROBE_CPU_EBX_OFFSET (PROBE_FIRST_GPR_OFFSET + (3 * PTR_SIZE))
 62 #define PROBE_CPU_ESP_OFFSET (PROBE_FIRST_GPR_OFFSET + (4 * PTR_SIZE))
 63 #define PROBE_CPU_EBP_OFFSET (PROBE_FIRST_GPR_OFFSET + (5 * PTR_SIZE))
 64 #define PROBE_CPU_ESI_OFFSET (PROBE_FIRST_GPR_OFFSET + (6 * PTR_SIZE))
 65 #define PROBE_CPU_EDI_OFFSET (PROBE_FIRST_GPR_OFFSET + (7 * PTR_SIZE))
 66 
 67 #if CPU(X86)
 68 #define PROBE_FIRST_SPR_OFFSET (PROBE_FIRST_GPR_OFFSET + (8 * PTR_SIZE))
 69 #else // CPU(X86_64)
 70 #define PROBE_CPU_R8_OFFSET (PROBE_FIRST_GPR_OFFSET + (8 * PTR_SIZE))
 71 #define PROBE_CPU_R9_OFFSET (PROBE_FIRST_GPR_OFFSET + (9 * PTR_SIZE))
 72 #define PROBE_CPU_R10_OFFSET (PROBE_FIRST_GPR_OFFSET + (10 * PTR_SIZE))
 73 #define PROBE_CPU_R11_OFFSET (PROBE_FIRST_GPR_OFFSET + (11 * PTR_SIZE))
 74 #define PROBE_CPU_R12_OFFSET (PROBE_FIRST_GPR_OFFSET + (12 * PTR_SIZE))
 75 #define PROBE_CPU_R13_OFFSET (PROBE_FIRST_GPR_OFFSET + (13 * PTR_SIZE))
 76 #define PROBE_CPU_R14_OFFSET (PROBE_FIRST_GPR_OFFSET + (14 * PTR_SIZE))
 77 #define PROBE_CPU_R15_OFFSET (PROBE_FIRST_GPR_OFFSET + (15 * PTR_SIZE))
 78 #define PROBE_FIRST_SPR_OFFSET (PROBE_FIRST_GPR_OFFSET + (16 * PTR_SIZE))
 79 #endif // CPU(X86_64)
 80 
 81 #define PROBE_CPU_EIP_OFFSET (PROBE_FIRST_SPR_OFFSET + (0 * PTR_SIZE))
 82 #define PROBE_CPU_EFLAGS_OFFSET (PROBE_FIRST_SPR_OFFSET + (1 * PTR_SIZE))
 83 #define PROBE_FIRST_XMM_OFFSET (PROBE_FIRST_SPR_OFFSET + (2 * PTR_SIZE))
 84 
 85 #define XMM_SIZE 8
 86 #define PROBE_CPU_XMM0_OFFSET (PROBE_FIRST_XMM_OFFSET + (0 * XMM_SIZE))
 87 #define PROBE_CPU_XMM1_OFFSET (PROBE_FIRST_XMM_OFFSET + (1 * XMM_SIZE))
 88 #define PROBE_CPU_XMM2_OFFSET (PROBE_FIRST_XMM_OFFSET + (2 * XMM_SIZE))
 89 #define PROBE_CPU_XMM3_OFFSET (PROBE_FIRST_XMM_OFFSET + (3 * XMM_SIZE))
 90 #define PROBE_CPU_XMM4_OFFSET (PROBE_FIRST_XMM_OFFSET + (4 * XMM_SIZE))
 91 #define PROBE_CPU_XMM5_OFFSET (PROBE_FIRST_XMM_OFFSET + (5 * XMM_SIZE))
 92 #define PROBE_CPU_XMM6_OFFSET (PROBE_FIRST_XMM_OFFSET + (6 * XMM_SIZE))
 93 #define PROBE_CPU_XMM7_OFFSET (PROBE_FIRST_XMM_OFFSET + (7 * XMM_SIZE))
 94 
 95 #if CPU(X86)
 96 #define PROBE_SIZE (PROBE_CPU_XMM7_OFFSET + XMM_SIZE)
 97 #else // CPU(X86_64)
 98 #define PROBE_CPU_XMM8_OFFSET (PROBE_FIRST_XMM_OFFSET + (8 * XMM_SIZE))
 99 #define PROBE_CPU_XMM9_OFFSET (PROBE_FIRST_XMM_OFFSET + (9 * XMM_SIZE))
100 #define PROBE_CPU_XMM10_OFFSET (PROBE_FIRST_XMM_OFFSET + (10 * XMM_SIZE))
101 #define PROBE_CPU_XMM11_OFFSET (PROBE_FIRST_XMM_OFFSET + (11 * XMM_SIZE))
102 #define PROBE_CPU_XMM12_OFFSET (PROBE_FIRST_XMM_OFFSET + (12 * XMM_SIZE))
103 #define PROBE_CPU_XMM13_OFFSET (PROBE_FIRST_XMM_OFFSET + (13 * XMM_SIZE))
104 #define PROBE_CPU_XMM14_OFFSET (PROBE_FIRST_XMM_OFFSET + (14 * XMM_SIZE))
105 #define PROBE_CPU_XMM15_OFFSET (PROBE_FIRST_XMM_OFFSET + (15 * XMM_SIZE))
106 #define PROBE_SIZE (PROBE_CPU_XMM15_OFFSET + XMM_SIZE)
107 #endif // CPU(X86_64)
108 
109 #define PROBE_EXECUTOR_OFFSET PROBE_SIZE // Stash the executeProbe function pointer at the end of the ProbeContext.
110 
111 // The outgoing record to be popped off the stack at the end consists of:
112 // eflags, eax, ecx, ebp, eip.
113 #define OUT_SIZE        (5 * PTR_SIZE)
114 
115 // These ASSERTs remind you that if you change the layout of Probe::State,
116 // you need to change ctiMasmProbeTrampoline offsets above to match.
117 #define PROBE_OFFSETOF(x) offsetof(struct Probe::State, x)
118 #define PROBE_OFFSETOF_REG(x, reg) offsetof(struct Probe::State, x) + reg * sizeof((reinterpret_cast&lt;Probe::State*&gt;(0))-&gt;x[reg])
119 static_assert(PROBE_OFFSETOF(probeFunction) == PROBE_PROBE_FUNCTION_OFFSET, &quot;Probe::State::probeFunction&#39;s offset matches ctiMasmProbeTrampoline&quot;);
120 static_assert(PROBE_OFFSETOF(arg) == PROBE_ARG_OFFSET, &quot;Probe::State::arg&#39;s offset matches ctiMasmProbeTrampoline&quot;);
121 static_assert(PROBE_OFFSETOF(initializeStackFunction) == PROBE_INIT_STACK_FUNCTION_OFFSET, &quot;Probe::State::initializeStackFunction&#39;s offset matches ctiMasmProbeTrampoline&quot;);
122 static_assert(PROBE_OFFSETOF(initializeStackArg) == PROBE_INIT_STACK_ARG_OFFSET, &quot;Probe::State::initializeStackArg&#39;s offset matches ctiMasmProbeTrampoline&quot;);
123 
124 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::eax) == PROBE_CPU_EAX_OFFSET, &quot;Probe::State::cpu.gprs[eax]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
125 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::ecx) == PROBE_CPU_ECX_OFFSET, &quot;Probe::State::cpu.gprs[ecx]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
126 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::edx) == PROBE_CPU_EDX_OFFSET, &quot;Probe::State::cpu.gprs[edx]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
127 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::ebx) == PROBE_CPU_EBX_OFFSET, &quot;Probe::State::cpu.gprs[ebx]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
128 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::esp) == PROBE_CPU_ESP_OFFSET, &quot;Probe::State::cpu.gprs[esp]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
129 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::ebp) == PROBE_CPU_EBP_OFFSET, &quot;Probe::State::cpu.gprs[ebp]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
130 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::esi) == PROBE_CPU_ESI_OFFSET, &quot;Probe::State::cpu.gprs[esi]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
131 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::edi) == PROBE_CPU_EDI_OFFSET, &quot;Probe::State::cpu.gprs[edi]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
132 static_assert(PROBE_OFFSETOF_REG(cpu.sprs, X86Registers::eip) == PROBE_CPU_EIP_OFFSET, &quot;Probe::State::cpu.gprs[eip]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
133 static_assert(PROBE_OFFSETOF_REG(cpu.sprs, X86Registers::eflags) == PROBE_CPU_EFLAGS_OFFSET, &quot;Probe::State::cpu.sprs[eflags]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
134 
135 #if CPU(X86_64)
136 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::r8) == PROBE_CPU_R8_OFFSET, &quot;Probe::State::cpu.gprs[r8]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
137 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::r9) == PROBE_CPU_R9_OFFSET, &quot;Probe::State::cpu.gprs[r9]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
138 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::r10) == PROBE_CPU_R10_OFFSET, &quot;Probe::State::cpu.gprs[r10]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
139 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::r11) == PROBE_CPU_R11_OFFSET, &quot;Probe::State::cpu.gprs[r11]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
140 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::r12) == PROBE_CPU_R12_OFFSET, &quot;Probe::State::cpu.gprs[r12]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
141 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::r13) == PROBE_CPU_R13_OFFSET, &quot;Probe::State::cpu.gprs[r13]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
142 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::r14) == PROBE_CPU_R14_OFFSET, &quot;Probe::State::cpu.gprs[r14]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
143 static_assert(PROBE_OFFSETOF_REG(cpu.gprs, X86Registers::r15) == PROBE_CPU_R15_OFFSET, &quot;Probe::State::cpu.gprs[r15]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
144 #endif // CPU(X86_64)
145 
146 static_assert(!(PROBE_CPU_XMM0_OFFSET &amp; 0x7), &quot;Probe::State::cpu.fprs[xmm0]&#39;s offset should be 8 byte aligned&quot;);
147 
148 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm0) == PROBE_CPU_XMM0_OFFSET, &quot;Probe::State::cpu.fprs[xmm0]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
149 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm1) == PROBE_CPU_XMM1_OFFSET, &quot;Probe::State::cpu.fprs[xmm1]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
150 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm2) == PROBE_CPU_XMM2_OFFSET, &quot;Probe::State::cpu.fprs[xmm2]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
151 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm3) == PROBE_CPU_XMM3_OFFSET, &quot;Probe::State::cpu.fprs[xmm3]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
152 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm4) == PROBE_CPU_XMM4_OFFSET, &quot;Probe::State::cpu.fprs[xmm4]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
153 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm5) == PROBE_CPU_XMM5_OFFSET, &quot;Probe::State::cpu.fprs[xmm5]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
154 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm6) == PROBE_CPU_XMM6_OFFSET, &quot;Probe::State::cpu.fprs[xmm6]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
155 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm7) == PROBE_CPU_XMM7_OFFSET, &quot;Probe::State::cpu.fprs[xmm7]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
156 
157 #if CPU(X86_64)
158 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm8) == PROBE_CPU_XMM8_OFFSET, &quot;Probe::State::cpu.fprs[xmm8]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
159 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm9) == PROBE_CPU_XMM9_OFFSET, &quot;Probe::State::cpu.fprs[xmm9]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
160 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm10) == PROBE_CPU_XMM10_OFFSET, &quot;Probe::State::cpu.fprs[xmm10]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
161 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm11) == PROBE_CPU_XMM11_OFFSET, &quot;Probe::State::cpu.fprs[xmm11]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
162 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm12) == PROBE_CPU_XMM12_OFFSET, &quot;Probe::State::cpu.fprs[xmm12]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
163 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm13) == PROBE_CPU_XMM13_OFFSET, &quot;Probe::State::cpu.fprs[xmm13]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
164 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm14) == PROBE_CPU_XMM14_OFFSET, &quot;Probe::State::cpu.fprs[xmm14]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
165 static_assert(PROBE_OFFSETOF_REG(cpu.fprs, X86Registers::xmm15) == PROBE_CPU_XMM15_OFFSET, &quot;Probe::State::cpu.fprs[xmm15]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
166 #endif // CPU(X86_64)
167 
168 static_assert(sizeof(Probe::State) == PROBE_SIZE, &quot;Probe::State::size&#39;s matches ctiMasmProbeTrampoline&quot;);
169 static_assert((PROBE_EXECUTOR_OFFSET + PTR_SIZE) &lt;= (PROBE_SIZE + OUT_SIZE), &quot;Must have room after ProbeContext to stash the probe handler&quot;);
170 
171 #undef PROBE_OFFSETOF
172 
173 #if CPU(X86)
174 #if COMPILER(GCC_COMPATIBLE)
175 asm (
176     &quot;.globl &quot; SYMBOL_STRING(ctiMasmProbeTrampoline) &quot;\n&quot;
177     HIDE_SYMBOL(ctiMasmProbeTrampoline) &quot;\n&quot;
178     SYMBOL_STRING(ctiMasmProbeTrampoline) &quot;:&quot; &quot;\n&quot;
179 
180     &quot;pushfl&quot; &quot;\n&quot;
181 
182     // MacroAssemblerX86Common::probe() has already generated code to store some values.
183     // Together with the eflags pushed above, the top of stack now looks like
184     // this:
185     //     esp[0 * ptrSize]: eflags
186     //     esp[1 * ptrSize]: return address / saved eip
187     //     esp[2 * ptrSize]: saved ebx
188     //     esp[3 * ptrSize]: saved edx
189     //     esp[4 * ptrSize]: saved ecx
190     //     esp[5 * ptrSize]: saved eax
191     //
192     // Incoming registers contain:
193     //     ecx: Probe::executeProbe
194     //     edx: probe function
195     //     ebx: probe arg
196     //     eax: scratch (was ctiMasmProbeTrampoline)
197 
198     &quot;movl %esp, %eax&quot; &quot;\n&quot;
199     &quot;subl $&quot; STRINGIZE_VALUE_OF(PROBE_SIZE + OUT_SIZE) &quot;, %esp&quot; &quot;\n&quot;
200 
201     // The X86_64 ABI specifies that the worse case stack alignment requirement is 32 bytes.
202     &quot;andl $~0x1f, %esp&quot; &quot;\n&quot;
203 
204     &quot;movl %ebp, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EBP_OFFSET) &quot;(%esp)&quot; &quot;\n&quot;
205     &quot;movl %esp, %ebp&quot; &quot;\n&quot; // Save the Probe::State*.
206 
207     &quot;movl %ecx, &quot; STRINGIZE_VALUE_OF(PROBE_EXECUTOR_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
208     &quot;movl %edx, &quot; STRINGIZE_VALUE_OF(PROBE_PROBE_FUNCTION_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
209     &quot;movl %ebx, &quot; STRINGIZE_VALUE_OF(PROBE_ARG_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
210     &quot;movl %esi, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ESI_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
211     &quot;movl %edi, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EDI_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
212 
213     &quot;movl 0 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%eax), %ecx&quot; &quot;\n&quot;
214     &quot;movl %ecx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EFLAGS_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
215     &quot;movl 1 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%eax), %ecx&quot; &quot;\n&quot;
216     &quot;movl %ecx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EIP_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
217     &quot;movl 2 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%eax), %ecx&quot; &quot;\n&quot;
218     &quot;movl %ecx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EBX_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
219     &quot;movl 3 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%eax), %ecx&quot; &quot;\n&quot;
220     &quot;movl %ecx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EDX_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
221     &quot;movl 4 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%eax), %ecx&quot; &quot;\n&quot;
222     &quot;movl %ecx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ECX_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
223     &quot;movl 5 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%eax), %ecx&quot; &quot;\n&quot;
224     &quot;movl %ecx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EAX_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
225 
226     &quot;movl %eax, %ecx&quot; &quot;\n&quot;
227     &quot;addl $&quot; STRINGIZE_VALUE_OF(6 * PTR_SIZE) &quot;, %ecx&quot; &quot;\n&quot;
228     &quot;movl %ecx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ESP_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
229 
230     &quot;movq %xmm0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM0_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
231     &quot;movq %xmm1, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM1_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
232     &quot;movq %xmm2, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM2_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
233     &quot;movq %xmm3, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM3_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
234     &quot;movq %xmm4, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM4_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
235     &quot;movq %xmm5, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM5_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
236     &quot;movq %xmm6, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM6_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
237     &quot;movq %xmm7, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM7_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
238 
239     // Reserve stack space for the arg while maintaining the required stack
240     // pointer 32 byte alignment:
241     &quot;subl $0x20, %esp&quot; &quot;\n&quot;
242     &quot;movl %ebp, 0(%esp)&quot; &quot;\n&quot; // the Probe::State* arg.
243 
244     &quot;call *&quot; STRINGIZE_VALUE_OF(PROBE_EXECUTOR_OFFSET) &quot;(%ebp)&quot; &quot;\n&quot;
245 
246     // Make sure the Probe::State is entirely below the result stack pointer so
247     // that register values are still preserved when we call the initializeStack
248     // function.
249     &quot;movl $&quot; STRINGIZE_VALUE_OF(PROBE_SIZE + OUT_SIZE) &quot;, %ecx&quot; &quot;\n&quot;
250     &quot;movl %ebp, %eax&quot; &quot;\n&quot;
251     &quot;movl &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ESP_OFFSET) &quot;(%ebp), %edx&quot; &quot;\n&quot;
252     &quot;addl %ecx, %eax&quot; &quot;\n&quot;
253     &quot;cmpl %eax, %edx&quot; &quot;\n&quot;
254     &quot;jge &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineProbeStateIsSafe) &quot;\n&quot;
255 
256     // Allocate a safe place on the stack below the result stack pointer to stash the Probe::State.
257     &quot;subl %ecx, %edx&quot; &quot;\n&quot;
258     &quot;andl $~0x1f, %edx&quot; &quot;\n&quot; // Keep the stack pointer 32 bytes aligned.
259     &quot;xorl %eax, %eax&quot; &quot;\n&quot;
260     &quot;movl %edx, %esp&quot; &quot;\n&quot;
261 
262     &quot;movl $&quot; STRINGIZE_VALUE_OF(PROBE_SIZE) &quot;, %ecx&quot; &quot;\n&quot;
263 
264     // Copy the Probe::State to the safe place.
265     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineCopyLoop) &quot;:&quot; &quot;\n&quot;
266     &quot;movl (%ebp, %eax), %edx&quot; &quot;\n&quot;
267     &quot;movl %edx, (%esp, %eax)&quot; &quot;\n&quot;
268     &quot;addl $&quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;, %eax&quot; &quot;\n&quot;
269     &quot;cmpl %eax, %ecx&quot; &quot;\n&quot;
270     &quot;jg &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineCopyLoop) &quot;\n&quot;
271 
272     &quot;movl %esp, %ebp&quot; &quot;\n&quot;
273 
274     // Call initializeStackFunction if present.
275     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineProbeStateIsSafe) &quot;:&quot; &quot;\n&quot;
276     &quot;xorl %ecx, %ecx&quot; &quot;\n&quot;
277     &quot;addl &quot; STRINGIZE_VALUE_OF(PROBE_INIT_STACK_FUNCTION_OFFSET) &quot;(%ebp), %ecx&quot; &quot;\n&quot;
278     &quot;je &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineRestoreRegisters) &quot;\n&quot;
279 
280     // Reserve stack space for the arg while maintaining the required stack
281     // pointer 32 byte alignment:
282     &quot;subl $0x20, %esp&quot; &quot;\n&quot;
283     &quot;movl %ebp, 0(%esp)&quot; &quot;\n&quot; // the Probe::State* arg.
284     &quot;call *%ecx&quot; &quot;\n&quot;
285 
286     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineRestoreRegisters) &quot;:&quot; &quot;\n&quot;
287 
288     // To enable probes to modify register state, we copy all registers
289     // out of the Probe::State before returning.
290 
291     &quot;movl &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EDX_OFFSET) &quot;(%ebp), %edx&quot; &quot;\n&quot;
292     &quot;movl &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EBX_OFFSET) &quot;(%ebp), %ebx&quot; &quot;\n&quot;
293     &quot;movl &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ESI_OFFSET) &quot;(%ebp), %esi&quot; &quot;\n&quot;
294     &quot;movl &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EDI_OFFSET) &quot;(%ebp), %edi&quot; &quot;\n&quot;
295 
296     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM0_OFFSET) &quot;(%ebp), %xmm0&quot; &quot;\n&quot;
297     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM1_OFFSET) &quot;(%ebp), %xmm1&quot; &quot;\n&quot;
298     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM2_OFFSET) &quot;(%ebp), %xmm2&quot; &quot;\n&quot;
299     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM3_OFFSET) &quot;(%ebp), %xmm3&quot; &quot;\n&quot;
300     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM4_OFFSET) &quot;(%ebp), %xmm4&quot; &quot;\n&quot;
301     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM5_OFFSET) &quot;(%ebp), %xmm5&quot; &quot;\n&quot;
302     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM6_OFFSET) &quot;(%ebp), %xmm6&quot; &quot;\n&quot;
303     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM7_OFFSET) &quot;(%ebp), %xmm7&quot; &quot;\n&quot;
304 
305     // There are 6 more registers left to restore:
306     //     eax, ecx, ebp, esp, eip, and eflags.
307 
308     // The restoration process at ctiMasmProbeTrampolineEnd below works by popping
309     // 5 words off the stack into eflags, eax, ecx, ebp, and eip. These 5 words need
310     // to be pushed on top of the final esp value so that just by popping the 5 words,
311     // we&#39;ll get the esp that the probe wants to set. Let&#39;s call this area (for storing
312     // these 5 words) the restore area.
313     &quot;movl &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ESP_OFFSET) &quot;(%ebp), %ecx&quot; &quot;\n&quot;
314     &quot;subl $5 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;, %ecx&quot; &quot;\n&quot;
315 
316     // ecx now points to the restore area.
317 
318     // Copy remaining restore values from the Probe::State to the restore area.
319     // Note: We already ensured above that the Probe::State is in a safe location before
320     // calling the initializeStackFunction. The initializeStackFunction is not allowed to
321     // change the stack pointer again.
322     &quot;movl &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EFLAGS_OFFSET) &quot;(%ebp), %eax&quot; &quot;\n&quot;
323     &quot;movl %eax, 0 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%ecx)&quot; &quot;\n&quot;
324     &quot;movl &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EAX_OFFSET) &quot;(%ebp), %eax&quot; &quot;\n&quot;
325     &quot;movl %eax, 1 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%ecx)&quot; &quot;\n&quot;
326     &quot;movl &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ECX_OFFSET) &quot;(%ebp), %eax&quot; &quot;\n&quot;
327     &quot;movl %eax, 2 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%ecx)&quot; &quot;\n&quot;
328     &quot;movl &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EBP_OFFSET) &quot;(%ebp), %eax&quot; &quot;\n&quot;
329     &quot;movl %eax, 3 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%ecx)&quot; &quot;\n&quot;
330     &quot;movl &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EIP_OFFSET) &quot;(%ebp), %eax&quot; &quot;\n&quot;
331     &quot;movl %eax, 4 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%ecx)&quot; &quot;\n&quot;
332     &quot;movl %ecx, %esp&quot; &quot;\n&quot;
333 
334     // Do the remaining restoration by popping off the restore area.
335     &quot;popfl&quot; &quot;\n&quot;
336     &quot;popl %eax&quot; &quot;\n&quot;
337     &quot;popl %ecx&quot; &quot;\n&quot;
338     &quot;popl %ebp&quot; &quot;\n&quot;
339     &quot;ret&quot; &quot;\n&quot;
340 );
341 #endif
342 
343 #if COMPILER(MSVC)
344 extern &quot;C&quot; __declspec(naked) void ctiMasmProbeTrampoline()
345 {
346     __asm {
347         pushfd;
348 
349         // MacroAssemblerX86Common::probe() has already generated code to store some values.
350         // Together with the eflags pushed above, the top of stack now looks like
351         // this:
352         //     esp[0 * ptrSize]: eflags
353         //     esp[1 * ptrSize]: return address / saved eip
354         //     esp[2 * ptrSize]: saved ebx
355         //     esp[3 * ptrSize]: saved edx
356         //     esp[4 * ptrSize]: saved ecx
357         //     esp[5 * ptrSize]: saved eax
358         //
359         // Incoming registers contain:
360         //     ecx: Probe::executeProbe
361         //     edx: probe function
362         //     ebx: probe arg
363         //     eax: scratch (was ctiMasmProbeTrampoline)
364 
365         mov eax, esp
366         sub esp, PROBE_SIZE + OUT_SIZE
367 
368         // The X86_64 ABI specifies that the worse case stack alignment requirement is 32 bytes.
369         and esp, ~0x1f
370 
371         mov [PROBE_CPU_EBP_OFFSET + esp], ebp
372         mov ebp, esp // Save the ProbeContext*.
373 
374         mov [PROBE_EXECUTOR_OFFSET + ebp], ecx
375         mov [PROBE_PROBE_FUNCTION_OFFSET + ebp], edx
376         mov [PROBE_ARG_OFFSET + ebp], ebx
377         mov [PROBE_CPU_ESI_OFFSET + ebp], esi
378         mov [PROBE_CPU_EDI_OFFSET + ebp], edi
379 
380         mov ecx, [0 * PTR_SIZE + eax]
381         mov [PROBE_CPU_EFLAGS_OFFSET + ebp], ecx
382         mov ecx, [1 * PTR_SIZE + eax]
383         mov [PROBE_CPU_EIP_OFFSET + ebp], ecx
384         mov ecx, [2 * PTR_SIZE + eax]
385         mov [PROBE_CPU_EBX_OFFSET + ebp], ecx
386         mov ecx, [3 * PTR_SIZE + eax]
387         mov [PROBE_CPU_EDX_OFFSET + ebp], ecx
388         mov ecx, [4 * PTR_SIZE + eax]
389         mov [PROBE_CPU_ECX_OFFSET + ebp], ecx
390         mov ecx, [5 * PTR_SIZE + eax]
391         mov [PROBE_CPU_EAX_OFFSET + ebp], ecx
392 
393         mov ecx, eax
394         add ecx, 6 * PTR_SIZE
395         mov [PROBE_CPU_ESP_OFFSET + ebp], ecx
396 
397         movq qword ptr[PROBE_CPU_XMM0_OFFSET + ebp], xmm0
398         movq qword ptr[PROBE_CPU_XMM1_OFFSET + ebp], xmm1
399         movq qword ptr[PROBE_CPU_XMM2_OFFSET + ebp], xmm2
400         movq qword ptr[PROBE_CPU_XMM3_OFFSET + ebp], xmm3
401         movq qword ptr[PROBE_CPU_XMM4_OFFSET + ebp], xmm4
402         movq qword ptr[PROBE_CPU_XMM5_OFFSET + ebp], xmm5
403         movq qword ptr[PROBE_CPU_XMM6_OFFSET + ebp], xmm6
404         movq qword ptr[PROBE_CPU_XMM7_OFFSET + ebp], xmm7
405 
406         // Reserve stack space for the arg while maintaining the required stack
407         // pointer 32 byte alignment:
408         sub esp, 0x20
409         mov [0 + esp], ebp // the ProbeContext* arg.
410 
411         call [PROBE_EXECUTOR_OFFSET + ebp]
412 
413         // Make sure the ProbeContext is entirely below the result stack pointer so
414         // that register values are still preserved when we call the initializeStack
415         // function.
416         mov ecx, PROBE_SIZE + OUT_SIZE
417         mov eax, ebp
418         mov edx, [PROBE_CPU_ESP_OFFSET + ebp]
419         add eax, ecx
420         cmp edx, eax
421         jge ctiMasmProbeTrampolineProbeContextIsSafe
422 
423         // Allocate a safe place on the stack below the result stack pointer to stash the ProbeContext.
424         sub edx, ecx
425         and edx, ~0x1f // Keep the stack pointer 32 bytes aligned.
426         xor eax, eax
427         mov esp, edx
428 
429         mov ecx, PROBE_SIZE
430 
431         // Copy the ProbeContext to the safe place.
432         ctiMasmProbeTrampolineCopyLoop :
433         mov edx, [ebp + eax]
434         mov [esp + eax], edx
435         add eax, PTR_SIZE
436         cmp ecx, eax
437         jg ctiMasmProbeTrampolineCopyLoop
438 
439         mov ebp, esp
440 
441         // Call initializeStackFunction if present.
442         ctiMasmProbeTrampolineProbeContextIsSafe :
443         xor ecx, ecx
444         add ecx, [PROBE_INIT_STACK_FUNCTION_OFFSET + ebp]
445         je ctiMasmProbeTrampolineRestoreRegisters
446 
447         // Reserve stack space for the arg while maintaining the required stack
448         // pointer 32 byte alignment:
449         sub esp, 0x20
450         mov [0 + esp], ebp // the ProbeContext* arg.
451         call ecx
452 
453         ctiMasmProbeTrampolineRestoreRegisters :
454 
455         // To enable probes to modify register state, we copy all registers
456         // out of the ProbeContext before returning.
457 
458         mov edx, [PROBE_CPU_EDX_OFFSET + ebp]
459         mov ebx, [PROBE_CPU_EBX_OFFSET + ebp]
460         mov esi, [PROBE_CPU_ESI_OFFSET + ebp]
461         mov edi, [PROBE_CPU_EDI_OFFSET + ebp]
462 
463         movq xmm0, qword ptr[PROBE_CPU_XMM0_OFFSET + ebp]
464         movq xmm1, qword ptr[PROBE_CPU_XMM1_OFFSET + ebp]
465         movq xmm2, qword ptr[PROBE_CPU_XMM2_OFFSET + ebp]
466         movq xmm3, qword ptr[PROBE_CPU_XMM3_OFFSET + ebp]
467         movq xmm4, qword ptr[PROBE_CPU_XMM4_OFFSET + ebp]
468         movq xmm5, qword ptr[PROBE_CPU_XMM5_OFFSET + ebp]
469         movq xmm6, qword ptr[PROBE_CPU_XMM6_OFFSET + ebp]
470         movq xmm7, qword ptr[PROBE_CPU_XMM7_OFFSET + ebp]
471 
472         // There are 6 more registers left to restore:
473         //     eax, ecx, ebp, esp, eip, and eflags.
474 
475         // The restoration process at ctiMasmProbeTrampolineEnd below works by popping
476         // 5 words off the stack into eflags, eax, ecx, ebp, and eip. These 5 words need
477         // to be pushed on top of the final esp value so that just by popping the 5 words,
478         // we&#39;ll get the esp that the probe wants to set. Let&#39;s call this area (for storing
479         // these 5 words) the restore area.
480         mov ecx, [PROBE_CPU_ESP_OFFSET + ebp]
481         sub ecx, 5 * PTR_SIZE
482 
483         // ecx now points to the restore area.
484 
485         // Copy remaining restore values from the ProbeContext to the restore area.
486         // Note: We already ensured above that the ProbeContext is in a safe location before
487         // calling the initializeStackFunction. The initializeStackFunction is not allowed to
488         // change the stack pointer again.
489         mov eax, [PROBE_CPU_EFLAGS_OFFSET + ebp]
490         mov [0 * PTR_SIZE + ecx], eax
491         mov eax, [PROBE_CPU_EAX_OFFSET + ebp]
492         mov [1 * PTR_SIZE + ecx], eax
493         mov eax, [PROBE_CPU_ECX_OFFSET + ebp]
494         mov [2 * PTR_SIZE + ecx], eax
495         mov eax, [PROBE_CPU_EBP_OFFSET + ebp]
496         mov [3 * PTR_SIZE + ecx], eax
497         mov eax, [PROBE_CPU_EIP_OFFSET + ebp]
498         mov [4 * PTR_SIZE + ecx], eax
499         mov esp, ecx
500 
501         // Do the remaining restoration by popping off the restore area.
502         popfd
503         pop eax
504         pop ecx
505         pop ebp
506         ret
507     }
508 }
509 #endif // COMPILER(MSVC)
510 
511 #endif // CPU(X86)
512 
513 #if CPU(X86_64)
514 #if COMPILER(GCC_COMPATIBLE)
515 asm (
516     &quot;.globl &quot; SYMBOL_STRING(ctiMasmProbeTrampoline) &quot;\n&quot;
517     HIDE_SYMBOL(ctiMasmProbeTrampoline) &quot;\n&quot;
518     SYMBOL_STRING(ctiMasmProbeTrampoline) &quot;:&quot; &quot;\n&quot;
519 
<a name="2" id="anc2"></a>


520     &quot;pushfq&quot; &quot;\n&quot;
521 
522     // MacroAssemblerX86Common::probe() has already generated code to store some values.
<a name="3" id="anc3"></a><span class="line-modified">523     // Together with the rflags pushed above, the top of stack now looks like this:</span>
<span class="line-modified">524     //     rsp[0 * ptrSize]: rflags</span>
<span class="line-modified">525     //     rsp[1 * ptrSize]: return address / saved rip</span>
<span class="line-modified">526     //     rsp[2 * ptrSize]: saved rbx</span>
<span class="line-modified">527     //     rsp[3 * ptrSize]: saved rdx</span>
<span class="line-modified">528     //     rsp[4 * ptrSize]: saved rcx</span>
<span class="line-modified">529     //     rsp[5 * ptrSize]: saved rax</span>

530     //
531     // Incoming registers contain:
532     //     rcx: Probe::executeProbe
533     //     rdx: probe function
534     //     rbx: probe arg
535     //     rax: scratch (was ctiMasmProbeTrampoline)
536 
<a name="4" id="anc4"></a><span class="line-removed">537     &quot;movq %rsp, %rax&quot; &quot;\n&quot;</span>
538     &quot;subq $&quot; STRINGIZE_VALUE_OF(PROBE_SIZE + OUT_SIZE) &quot;, %rsp&quot; &quot;\n&quot;
539 
540     // The X86_64 ABI specifies that the worse case stack alignment requirement is 32 bytes.
541     &quot;andq $~0x1f, %rsp&quot; &quot;\n&quot;
542     // Since sp points to the Probe::State, we&#39;ve ensured that it&#39;s protected from interrupts before we initialize it.
543 
<a name="5" id="anc5"></a><span class="line-modified">544     &quot;movq %rbp, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EBP_OFFSET) &quot;(%rsp)&quot; &quot;\n&quot;</span>
<span class="line-modified">545     &quot;movq %rsp, %rbp&quot; &quot;\n&quot; // Save the Probe::State*.</span>
<span class="line-modified">546 </span>
<span class="line-modified">547     &quot;movq %rcx, &quot; STRINGIZE_VALUE_OF(PROBE_EXECUTOR_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">548     &quot;movq %rdx, &quot; STRINGIZE_VALUE_OF(PROBE_PROBE_FUNCTION_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">549     &quot;movq %rbx, &quot; STRINGIZE_VALUE_OF(PROBE_ARG_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">550     &quot;movq %rsi, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ESI_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">551     &quot;movq %rdi, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EDI_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">552 </span>
<span class="line-modified">553     &quot;movq 0 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%rax), %rcx&quot; &quot;\n&quot;</span>
<span class="line-modified">554     &quot;movq %rcx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EFLAGS_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">555     &quot;movq 1 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%rax), %rcx&quot; &quot;\n&quot;</span>
<span class="line-modified">556     &quot;movq %rcx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EIP_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">557     &quot;movq 2 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%rax), %rcx&quot; &quot;\n&quot;</span>
<span class="line-modified">558     &quot;movq %rcx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EBX_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">559     &quot;movq 3 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%rax), %rcx&quot; &quot;\n&quot;</span>
<span class="line-modified">560     &quot;movq %rcx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EDX_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">561     &quot;movq 4 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%rax), %rcx&quot; &quot;\n&quot;</span>
<span class="line-modified">562     &quot;movq %rcx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ECX_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">563     &quot;movq 5 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%rax), %rcx&quot; &quot;\n&quot;</span>
<span class="line-modified">564     &quot;movq %rcx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EAX_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">565 </span>
<span class="line-removed">566     &quot;movq %rax, %rcx&quot; &quot;\n&quot;</span>
567     &quot;addq $&quot; STRINGIZE_VALUE_OF(6 * PTR_SIZE) &quot;, %rcx&quot; &quot;\n&quot;
<a name="6" id="anc6"></a><span class="line-modified">568     &quot;movq %rcx, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ESP_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">569 </span>
<span class="line-modified">570     &quot;movq %r8, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R8_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">571     &quot;movq %r9, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R9_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">572     &quot;movq %r10, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R10_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">573     &quot;movq %r11, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R11_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">574     &quot;movq %r12, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R12_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">575     &quot;movq %r13, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R13_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">576     &quot;movq %r14, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R14_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">577     &quot;movq %r15, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R15_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">578 </span>
<span class="line-modified">579     &quot;movq %xmm0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM0_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">580     &quot;movq %xmm1, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM1_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">581     &quot;movq %xmm2, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM2_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">582     &quot;movq %xmm3, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM3_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">583     &quot;movq %xmm4, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM4_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">584     &quot;movq %xmm5, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM5_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">585     &quot;movq %xmm6, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM6_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">586     &quot;movq %xmm7, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM7_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">587     &quot;movq %xmm8, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM8_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">588     &quot;movq %xmm9, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM9_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">589     &quot;movq %xmm10, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM10_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">590     &quot;movq %xmm11, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM11_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">591     &quot;movq %xmm12, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM12_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">592     &quot;movq %xmm13, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM13_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">593     &quot;movq %xmm14, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM14_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">594     &quot;movq %xmm15, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM15_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
<span class="line-modified">595 </span>
<span class="line-modified">596     &quot;movq %rbp, %rdi&quot; &quot;\n&quot; // the Probe::State* arg.</span>
<span class="line-modified">597     &quot;call *&quot; STRINGIZE_VALUE_OF(PROBE_EXECUTOR_OFFSET) &quot;(%rbp)&quot; &quot;\n&quot;</span>
598 
599     // Make sure the Probe::State is entirely below the result stack pointer so
600     // that register values are still preserved when we call the initializeStack
601     // function.
<a name="7" id="anc7"></a>
602     &quot;movq $&quot; STRINGIZE_VALUE_OF(PROBE_SIZE + OUT_SIZE) &quot;, %rcx&quot; &quot;\n&quot;
<a name="8" id="anc8"></a><span class="line-modified">603     &quot;movq %rbp, %rax&quot; &quot;\n&quot;</span>
604     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ESP_OFFSET) &quot;(%rbp), %rdx&quot; &quot;\n&quot;
605     &quot;addq %rcx, %rax&quot; &quot;\n&quot;
606     &quot;cmpq %rax, %rdx&quot; &quot;\n&quot;
607     &quot;jge &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineProbeStateIsSafe) &quot;\n&quot;
608 
609     // Allocate a safe place on the stack below the result stack pointer to stash the Probe::State.
610     &quot;subq %rcx, %rdx&quot; &quot;\n&quot;
611     &quot;andq $~0x1f, %rdx&quot; &quot;\n&quot; // Keep the stack pointer 32 bytes aligned.
612     &quot;xorq %rax, %rax&quot; &quot;\n&quot;
613     &quot;movq %rdx, %rsp&quot; &quot;\n&quot;
614 
615     &quot;movq $&quot; STRINGIZE_VALUE_OF(PROBE_SIZE) &quot;, %rcx&quot; &quot;\n&quot;
616 
617     // Copy the Probe::State to the safe place.
618     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineCopyLoop) &quot;:&quot; &quot;\n&quot;
619     &quot;movq (%rbp, %rax), %rdx&quot; &quot;\n&quot;
620     &quot;movq %rdx, (%rsp, %rax)&quot; &quot;\n&quot;
621     &quot;addq $&quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;, %rax&quot; &quot;\n&quot;
622     &quot;cmpq %rax, %rcx&quot; &quot;\n&quot;
623     &quot;jg &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineCopyLoop) &quot;\n&quot;
624 
625     &quot;movq %rsp, %rbp&quot; &quot;\n&quot;
626 
627     // Call initializeStackFunction if present.
628     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineProbeStateIsSafe) &quot;:&quot; &quot;\n&quot;
629     &quot;xorq %rcx, %rcx&quot; &quot;\n&quot;
630     &quot;addq &quot; STRINGIZE_VALUE_OF(PROBE_INIT_STACK_FUNCTION_OFFSET) &quot;(%rbp), %rcx&quot; &quot;\n&quot;
631     &quot;je &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineRestoreRegisters) &quot;\n&quot;
632 
633     &quot;movq %rbp, %rdi&quot; &quot;\n&quot; // the Probe::State* arg.
634     &quot;call *%rcx&quot; &quot;\n&quot;
635 
636     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineRestoreRegisters) &quot;:&quot; &quot;\n&quot;
637 
638     // To enable probes to modify register state, we copy all registers
639     // out of the Probe::State before returning.
640 
641     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EDX_OFFSET) &quot;(%rbp), %rdx&quot; &quot;\n&quot;
642     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EBX_OFFSET) &quot;(%rbp), %rbx&quot; &quot;\n&quot;
643     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ESI_OFFSET) &quot;(%rbp), %rsi&quot; &quot;\n&quot;
644     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EDI_OFFSET) &quot;(%rbp), %rdi&quot; &quot;\n&quot;
645 
646     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R8_OFFSET) &quot;(%rbp), %r8&quot; &quot;\n&quot;
647     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R9_OFFSET) &quot;(%rbp), %r9&quot; &quot;\n&quot;
648     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R10_OFFSET) &quot;(%rbp), %r10&quot; &quot;\n&quot;
649     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R11_OFFSET) &quot;(%rbp), %r11&quot; &quot;\n&quot;
650     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R12_OFFSET) &quot;(%rbp), %r12&quot; &quot;\n&quot;
651     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R13_OFFSET) &quot;(%rbp), %r13&quot; &quot;\n&quot;
652     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R14_OFFSET) &quot;(%rbp), %r14&quot; &quot;\n&quot;
653     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_R15_OFFSET) &quot;(%rbp), %r15&quot; &quot;\n&quot;
654 
655     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM0_OFFSET) &quot;(%rbp), %xmm0&quot; &quot;\n&quot;
656     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM1_OFFSET) &quot;(%rbp), %xmm1&quot; &quot;\n&quot;
657     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM2_OFFSET) &quot;(%rbp), %xmm2&quot; &quot;\n&quot;
658     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM3_OFFSET) &quot;(%rbp), %xmm3&quot; &quot;\n&quot;
659     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM4_OFFSET) &quot;(%rbp), %xmm4&quot; &quot;\n&quot;
660     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM5_OFFSET) &quot;(%rbp), %xmm5&quot; &quot;\n&quot;
661     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM6_OFFSET) &quot;(%rbp), %xmm6&quot; &quot;\n&quot;
662     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM7_OFFSET) &quot;(%rbp), %xmm7&quot; &quot;\n&quot;
663     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM8_OFFSET) &quot;(%rbp), %xmm8&quot; &quot;\n&quot;
664     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM9_OFFSET) &quot;(%rbp), %xmm9&quot; &quot;\n&quot;
665     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM10_OFFSET) &quot;(%rbp), %xmm10&quot; &quot;\n&quot;
666     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM11_OFFSET) &quot;(%rbp), %xmm11&quot; &quot;\n&quot;
667     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM12_OFFSET) &quot;(%rbp), %xmm12&quot; &quot;\n&quot;
668     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM13_OFFSET) &quot;(%rbp), %xmm13&quot; &quot;\n&quot;
669     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM14_OFFSET) &quot;(%rbp), %xmm14&quot; &quot;\n&quot;
670     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_XMM15_OFFSET) &quot;(%rbp), %xmm15&quot; &quot;\n&quot;
671 
672     // There are 6 more registers left to restore:
673     //     rax, rcx, rbp, rsp, rip, and rflags.
674 
675     // The restoration process at ctiMasmProbeTrampolineEnd below works by popping
676     // 5 words off the stack into rflags, rax, rcx, rbp, and rip. These 5 words need
677     // to be pushed on top of the final esp value so that just by popping the 5 words,
678     // we&#39;ll get the esp that the probe wants to set. Let&#39;s call this area (for storing
679     // these 5 words) the restore area.
680     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ESP_OFFSET) &quot;(%rbp), %rcx&quot; &quot;\n&quot;
681     &quot;subq $5 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;, %rcx&quot; &quot;\n&quot;
682 
683     // rcx now points to the restore area.
684 
685     // Copy remaining restore values from the Probe::State to the restore area.
686     // Note: We already ensured above that the Probe::State is in a safe location before
687     // calling the initializeStackFunction. The initializeStackFunction is not allowed to
688     // change the stack pointer again.
689     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EFLAGS_OFFSET) &quot;(%rbp), %rax&quot; &quot;\n&quot;
690     &quot;movq %rax, 0 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%rcx)&quot; &quot;\n&quot;
691     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EAX_OFFSET) &quot;(%rbp), %rax&quot; &quot;\n&quot;
692     &quot;movq %rax, 1 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%rcx)&quot; &quot;\n&quot;
693     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_ECX_OFFSET) &quot;(%rbp), %rax&quot; &quot;\n&quot;
694     &quot;movq %rax, 2 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%rcx)&quot; &quot;\n&quot;
695     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EBP_OFFSET) &quot;(%rbp), %rax&quot; &quot;\n&quot;
696     &quot;movq %rax, 3 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%rcx)&quot; &quot;\n&quot;
697     &quot;movq &quot; STRINGIZE_VALUE_OF(PROBE_CPU_EIP_OFFSET) &quot;(%rbp), %rax&quot; &quot;\n&quot;
698     &quot;movq %rax, 4 * &quot; STRINGIZE_VALUE_OF(PTR_SIZE) &quot;(%rcx)&quot; &quot;\n&quot;
699     &quot;movq %rcx, %rsp&quot; &quot;\n&quot;
700 
701     // Do the remaining restoration by popping off the restore area.
702     &quot;popfq&quot; &quot;\n&quot;
703     &quot;popq %rax&quot; &quot;\n&quot;
704     &quot;popq %rcx&quot; &quot;\n&quot;
705     &quot;popq %rbp&quot; &quot;\n&quot;
706     &quot;ret&quot; &quot;\n&quot;
707 );
708 #endif // COMPILER(GCC_COMPATIBLE)
709 #endif // CPU(X86_64)
710 
711 // What code is emitted for the probe?
712 // ==================================
713 // We want to keep the size of the emitted probe invocation code as compact as
714 // possible to minimize the perturbation to the JIT generated code. However,
715 // we also need to preserve the CPU registers and set up the Probe::State to be
716 // passed to the user probe function.
717 //
718 // Hence, we do only the minimum here to preserve a scratch register (i.e. rax
719 // in this case) and the stack pointer (i.e. rsp), and pass the probe arguments.
720 // We&#39;ll let the ctiMasmProbeTrampoline handle the rest of the probe invocation
721 // work i.e. saving the CPUState (and setting up the Probe::State), calling the
722 // user probe function, and restoring the CPUState before returning to JIT
723 // generated code.
724 //
725 // What registers need to be saved?
726 // ===============================
727 // The registers are saved for 2 reasons:
728 // 1. To preserve their state in the JITted code. This means that all registers
729 //    that are not callee saved needs to be saved. We also need to save the
730 //    condition code registers because the probe can be inserted between a test
731 //    and a branch.
732 // 2. To allow the probe to inspect the values of the registers for debugging
733 //    purposes. This means all registers need to be saved.
734 //
735 // In summary, save everything. But for reasons stated above, we should do the
736 // minimum here and let ctiMasmProbeTrampoline do the heavy lifting to save the
737 // full set.
738 //
739 // What values are in the saved registers?
740 // ======================================
741 // Conceptually, the saved registers should contain values as if the probe
742 // is not present in the JIT generated code. Hence, they should contain values
743 // that are expected at the start of the instruction immediately following the
744 // probe.
745 //
746 // Specifically, the saved stack pointer register will point to the stack
747 // position before we push the Probe::State frame. The saved rip will point to
748 // the address of the instruction immediately following the probe.
749 
750 void MacroAssembler::probe(Probe::Function function, void* arg)
751 {
752     push(RegisterID::eax);
753     move(TrustedImmPtr(reinterpret_cast&lt;void*&gt;(ctiMasmProbeTrampoline)), RegisterID::eax);
754     push(RegisterID::ecx);
755     move(TrustedImmPtr(reinterpret_cast&lt;void*&gt;(Probe::executeProbe)), RegisterID::ecx);
756     push(RegisterID::edx);
757     move(TrustedImmPtr(reinterpret_cast&lt;void*&gt;(function)), RegisterID::edx);
758     push(RegisterID::ebx);
759     move(TrustedImmPtr(arg), RegisterID::ebx);
760     call(RegisterID::eax, CFunctionPtrTag);
761 }
762 #endif // ENABLE(MASM_PROBE)
763 
764 MacroAssemblerX86Common::CPUID MacroAssemblerX86Common::getCPUID(unsigned level)
765 {
766     return getCPUIDEx(level, 0);
767 }
768 
769 MacroAssemblerX86Common::CPUID MacroAssemblerX86Common::getCPUIDEx(unsigned level, unsigned count)
770 {
771     CPUID result { };
772 #if COMPILER(MSVC)
773     __cpuidex(bitwise_cast&lt;int*&gt;(result.data()), level, count);
774 #else
775     __asm__ (
776         &quot;cpuid\n&quot;
777         : &quot;=a&quot;(result[0]), &quot;=b&quot;(result[1]), &quot;=c&quot;(result[2]), &quot;=d&quot;(result[3])
778         : &quot;0&quot;(level), &quot;2&quot;(count)
779     );
780 #endif
781     return result;
782 }
783 
784 void MacroAssemblerX86Common::collectCPUFeatures()
785 {
786     static std::once_flag onceKey;
787     std::call_once(onceKey, [] {
788         {
789             CPUID cpuid = getCPUID(0x1);
790             s_sse4_1CheckState = (cpuid[2] &amp; (1 &lt;&lt; 19)) ? CPUIDCheckState::Set : CPUIDCheckState::Clear;
791             s_sse4_2CheckState = (cpuid[2] &amp; (1 &lt;&lt; 20)) ? CPUIDCheckState::Set : CPUIDCheckState::Clear;
792             s_popcntCheckState = (cpuid[2] &amp; (1 &lt;&lt; 23)) ? CPUIDCheckState::Set : CPUIDCheckState::Clear;
793             s_avxCheckState = (cpuid[2] &amp; (1 &lt;&lt; 28)) ? CPUIDCheckState::Set : CPUIDCheckState::Clear;
794         }
795         {
796             CPUID cpuid = getCPUID(0x7);
797             s_bmi1CheckState = (cpuid[2] &amp; (1 &lt;&lt; 3)) ? CPUIDCheckState::Set : CPUIDCheckState::Clear;
798         }
799         {
800             CPUID cpuid = getCPUID(0x80000001);
801             s_lzcntCheckState = (cpuid[2] &amp; (1 &lt;&lt; 5)) ? CPUIDCheckState::Set : CPUIDCheckState::Clear;
802         }
803     });
804 }
805 
806 MacroAssemblerX86Common::CPUIDCheckState MacroAssemblerX86Common::s_sse4_1CheckState = CPUIDCheckState::NotChecked;
807 MacroAssemblerX86Common::CPUIDCheckState MacroAssemblerX86Common::s_sse4_2CheckState = CPUIDCheckState::NotChecked;
808 MacroAssemblerX86Common::CPUIDCheckState MacroAssemblerX86Common::s_avxCheckState = CPUIDCheckState::NotChecked;
809 MacroAssemblerX86Common::CPUIDCheckState MacroAssemblerX86Common::s_lzcntCheckState = CPUIDCheckState::NotChecked;
810 MacroAssemblerX86Common::CPUIDCheckState MacroAssemblerX86Common::s_bmi1CheckState = CPUIDCheckState::NotChecked;
811 MacroAssemblerX86Common::CPUIDCheckState MacroAssemblerX86Common::s_popcntCheckState = CPUIDCheckState::NotChecked;
812 
813 } // namespace JSC
814 
815 #endif // ENABLE(ASSEMBLER) &amp;&amp; (CPU(X86) || CPU(X86_64))
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
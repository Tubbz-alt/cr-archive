diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.cpp
@@ -1,8 +1,8 @@
 /*
  * Copyright (C) 2017 Caio Lima <ticaiolima@gmail.com>
- * Copyright (C) 2017-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -59,15 +59,21 @@
 
 namespace JSC {
 
 const ClassInfo JSBigInt::s_info = { "BigInt", nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSBigInt) };
 
-JSBigInt::JSBigInt(VM& vm, Structure* structure, unsigned length)
+JSBigInt::JSBigInt(VM& vm, Structure* structure, Digit* data, unsigned length)
     : Base(vm, structure)
     , m_length(length)
+    , m_data(data, length)
 { }
 
+void JSBigInt::destroy(JSCell* thisCell)
+{
+    static_cast<JSBigInt*>(thisCell)->~JSBigInt();
+}
+
 void JSBigInt::initialize(InitializationType initType)
 {
     if (initType == InitializationType::WithZero)
         memset(dataStorage(), 0, length() * sizeof(Digit));
 }
@@ -81,23 +87,17 @@
 {
     JSBigInt* zeroBigInt = createWithLengthUnchecked(vm, 0);
     return zeroBigInt;
 }
 
-inline size_t JSBigInt::allocationSize(unsigned length)
+JSBigInt* JSBigInt::tryCreateWithLength(JSGlobalObject* globalObject, unsigned length)
 {
-    size_t sizeWithPadding = WTF::roundUpToMultipleOf<sizeof(size_t)>(sizeof(JSBigInt));
-    return sizeWithPadding + length * sizeof(Digit);
-}
-
-JSBigInt* JSBigInt::tryCreateWithLength(ExecState* exec, unsigned length)
-{
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (UNLIKELY(length > maxLength)) {
-        throwOutOfMemoryError(exec, scope);
+        throwOutOfMemoryError(globalObject, scope);
         return nullptr;
     }
 
     scope.release();
 
@@ -105,11 +105,12 @@
 }
 
 JSBigInt* JSBigInt::createWithLengthUnchecked(VM& vm, unsigned length)
 {
     ASSERT(length <= maxLength);
-    JSBigInt* bigInt = new (NotNull, allocateCell<JSBigInt>(vm.heap, allocationSize(length))) JSBigInt(vm, vm.bigIntStructure.get(), length);
+    void* data = Gigacage::malloc(Gigacage::Primitive, length * sizeof(Digit));
+    JSBigInt* bigInt = new (NotNull, allocateCell<JSBigInt>(vm.heap)) JSBigInt(vm, vm.bigIntStructure.get(), reinterpret_cast<Digit*>(data), length);
     bigInt->finishCreation(vm);
     return bigInt;
 }
 
 JSBigInt* JSBigInt::createFrom(VM& vm, int32_t value)
@@ -180,11 +181,11 @@
     JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
     bigInt->setDigit(0, static_cast<Digit>(value));
     return bigInt;
 }
 
-JSValue JSBigInt::toPrimitive(ExecState*, PreferredPrimitiveType) const
+JSValue JSBigInt::toPrimitive(JSGlobalObject*, PreferredPrimitiveType) const
 {
     return const_cast<JSBigInt*>(this);
 }
 
 Optional<uint8_t> JSBigInt::singleDigitValueForString()
@@ -198,38 +199,38 @@
             return static_cast<uint8_t>(rDigit);
     }
     return { };
 }
 
-JSBigInt* JSBigInt::parseInt(ExecState* exec, StringView s, ErrorParseMode parserMode)
+JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, StringView s, ErrorParseMode parserMode)
 {
     if (s.is8Bit())
-        return parseInt(exec, s.characters8(), s.length(), parserMode);
-    return parseInt(exec, s.characters16(), s.length(), parserMode);
+        return parseInt(globalObject, s.characters8(), s.length(), parserMode);
+    return parseInt(globalObject, s.characters16(), s.length(), parserMode);
 }
 
-JSBigInt* JSBigInt::parseInt(ExecState* exec, VM& vm, StringView s, uint8_t radix, ErrorParseMode parserMode, ParseIntSign sign)
+JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, VM& vm, StringView s, uint8_t radix, ErrorParseMode parserMode, ParseIntSign sign)
 {
     if (s.is8Bit())
-        return parseInt(exec, vm, s.characters8(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);
-    return parseInt(exec, vm, s.characters16(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);
+        return parseInt(globalObject, vm, s.characters8(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);
+    return parseInt(globalObject, vm, s.characters16(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);
 }
 
-JSBigInt* JSBigInt::stringToBigInt(ExecState* exec, StringView s)
+JSBigInt* JSBigInt::stringToBigInt(JSGlobalObject* globalObject, StringView s)
 {
-    return parseInt(exec, s, ErrorParseMode::IgnoreExceptions);
+    return parseInt(globalObject, s, ErrorParseMode::IgnoreExceptions);
 }
 
-String JSBigInt::toString(ExecState* exec, unsigned radix)
+String JSBigInt::toString(JSGlobalObject* globalObject, unsigned radix)
 {
     if (this->isZero())
-        return exec->vm().smallStrings.singleCharacterStringRep('0');
+        return globalObject->vm().smallStrings.singleCharacterStringRep('0');
 
     if (hasOneBitSet(radix))
-        return toStringBasePowerOfTwo(exec->vm(), exec, this, radix);
+        return toStringBasePowerOfTwo(globalObject->vm(), globalObject, this, radix);
 
-    return toStringGeneric(exec->vm(), exec, this, radix);
+    return toStringGeneric(globalObject->vm(), globalObject, this, radix);
 }
 
 String JSBigInt::tryGetString(VM& vm, JSBigInt* bigInt, unsigned radix)
 {
     if (bigInt->isZero())
@@ -245,17 +246,17 @@
 void JSBigInt::inplaceMultiplyAdd(Digit factor, Digit summand)
 {
     internalMultiplyAdd(this, factor, summand, length(), this);
 }
 
-JSBigInt* JSBigInt::exponentiate(ExecState* exec, JSBigInt* base, JSBigInt* exponent)
+JSBigInt* JSBigInt::exponentiate(JSGlobalObject* globalObject, JSBigInt* base, JSBigInt* exponent)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (exponent->sign()) {
-        throwRangeError(exec, scope, "Negative exponent is not allowed"_s);
+        throwRangeError(globalObject, scope, "Negative exponent is not allowed"_s);
         return nullptr;
     }
 
     // 2. If base is 0n and exponent is 0n, return 1n.
     if (exponent->isZero())
@@ -277,28 +278,28 @@
 
     // For all bases >= 2, very large exponents would lead to unrepresentable
     // results.
     static_assert(maxLengthBits < std::numeric_limits<Digit>::max(), "maxLengthBits needs to be less than digit::max()");
     if (exponent->length() > 1) {
-        throwRangeError(exec, scope, "BigInt generated from this operation is too big"_s);
+        throwRangeError(globalObject, scope, "BigInt generated from this operation is too big"_s);
         return nullptr;
     }
 
     Digit expValue = exponent->digit(0);
     if (expValue == 1)
         return base;
     if (expValue >= maxLengthBits) {
-        throwRangeError(exec, scope, "BigInt generated from this operation is too big"_s);
+        throwRangeError(globalObject, scope, "BigInt generated from this operation is too big"_s);
         return nullptr;
     }
 
     static_assert(maxLengthBits <= maxInt, "maxLengthBits needs to be <= maxInt");
     int n = static_cast<int>(expValue);
     if (base->length() == 1 && base->digit(0) == 2) {
         // Fast path for 2^n.
         int neededDigits = 1 + (n / digitBits);
-        JSBigInt* result = JSBigInt::tryCreateWithLength(exec, neededDigits);
+        JSBigInt* result = JSBigInt::tryCreateWithLength(globalObject, neededDigits);
         RETURN_IF_EXCEPTION(scope, nullptr);
 
         result->initialize(InitializationType::WithZero);
         // All bits are zero. Now set the n-th bit.
         Digit msd = static_cast<Digit>(1) << (n % digitBits);
@@ -317,57 +318,57 @@
     if (n & 1)
         result = base;
 
     n >>= 1;
     for (; n; n >>= 1) {
-        JSBigInt* maybeResult = JSBigInt::multiply(exec, runningSquare, runningSquare);
+        JSBigInt* maybeResult = JSBigInt::multiply(globalObject, runningSquare, runningSquare);
         RETURN_IF_EXCEPTION(scope, nullptr);
         runningSquare = maybeResult;
         if (n & 1) {
             if (!result)
                 result = runningSquare;
             else {
-                maybeResult = JSBigInt::multiply(exec, result, runningSquare);
+                maybeResult = JSBigInt::multiply(globalObject, result, runningSquare);
                 RETURN_IF_EXCEPTION(scope, nullptr);
                 result = maybeResult;
             }
         }
     }
 
     return result;
 }
 
-JSBigInt* JSBigInt::multiply(ExecState* exec, JSBigInt* x, JSBigInt* y)
+JSBigInt* JSBigInt::multiply(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (x->isZero())
         return x;
     if (y->isZero())
         return y;
 
     unsigned resultLength = x->length() + y->length();
-    JSBigInt* result = JSBigInt::tryCreateWithLength(exec, resultLength);
+    JSBigInt* result = JSBigInt::tryCreateWithLength(globalObject, resultLength);
     RETURN_IF_EXCEPTION(scope, nullptr);
     result->initialize(InitializationType::WithZero);
 
     for (unsigned i = 0; i < x->length(); i++)
         multiplyAccumulate(y, x->digit(i), result, i);
 
     result->setSign(x->sign() != y->sign());
     return result->rightTrim(vm);
 }
 
-JSBigInt* JSBigInt::divide(ExecState* exec, JSBigInt* x, JSBigInt* y)
+JSBigInt* JSBigInt::divide(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)
 {
     // 1. If y is 0n, throw a RangeError exception.
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (y->isZero()) {
-        throwRangeError(exec, scope, "0 is an invalid divisor value."_s);
+        throwRangeError(globalObject, scope, "0 is an invalid divisor value."_s);
         return nullptr;
     }
 
     // 2. Let quotient be the mathematical value of x divided by y.
     // 3. Return a BigInt representing quotient rounded towards 0 to the next
@@ -383,11 +384,11 @@
             return resultSign == x->sign() ? x : unaryMinus(vm, x);
 
         Digit remainder;
         absoluteDivWithDigitDivisor(vm, x, divisor, &quotient, remainder);
     } else {
-        absoluteDivWithBigIntDivisor(exec, x, y, &quotient, nullptr);
+        absoluteDivWithBigIntDivisor(globalObject, x, y, &quotient, nullptr);
         RETURN_IF_EXCEPTION(scope, nullptr);
     }
 
     quotient->setSign(resultSign);
     return quotient->rightTrim(vm);
@@ -411,18 +412,18 @@
     JSBigInt* result = copy(vm, x);
     result->setSign(!x->sign());
     return result;
 }
 
-JSBigInt* JSBigInt::remainder(ExecState* exec, JSBigInt* x, JSBigInt* y)
+JSBigInt* JSBigInt::remainder(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)
 {
     // 1. If y is 0n, throw a RangeError exception.
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (y->isZero()) {
-        throwRangeError(exec, scope, "0 is an invalid divisor value."_s);
+        throwRangeError(globalObject, scope, "0 is an invalid divisor value."_s);
         return nullptr;
     }
 
     // 2. Return the JSBigInt representing x modulo y.
     // See https://github.com/tc39/proposal-bigint/issues/84 though.
@@ -441,58 +442,72 @@
             return createZero(vm);
 
         remainder = createWithLengthUnchecked(vm, 1);
         remainder->setDigit(0, remainderDigit);
     } else {
-        absoluteDivWithBigIntDivisor(exec, x, y, nullptr, &remainder);
+        absoluteDivWithBigIntDivisor(globalObject, x, y, nullptr, &remainder);
         RETURN_IF_EXCEPTION(scope, nullptr);
     }
 
     remainder->setSign(x->sign());
     return remainder->rightTrim(vm);
 }
 
-JSBigInt* JSBigInt::add(ExecState* exec, JSBigInt* x, JSBigInt* y)
+JSBigInt* JSBigInt::inc(JSGlobalObject* globalObject, JSBigInt* x)
+{
+    // FIXME: we can probably do something a fair bit more efficient here
+    VM& vm = globalObject->vm();
+    return add(globalObject, x, vm.bigIntConstantOne.get());
+}
+
+JSBigInt* JSBigInt::dec(JSGlobalObject* globalObject, JSBigInt* x)
 {
-    VM& vm = exec->vm();
+    // FIXME: we can probably do something a fair bit more efficient here
+    VM& vm = globalObject->vm();
+    return sub(globalObject, x, vm.bigIntConstantOne.get());
+}
+
+JSBigInt* JSBigInt::add(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)
+{
+    VM& vm = globalObject->vm();
     bool xSign = x->sign();
 
     // x + y == x + y
     // -x + -y == -(x + y)
     if (xSign == y->sign())
-        return absoluteAdd(exec, x, y, xSign);
+        return absoluteAdd(globalObject, x, y, xSign);
 
     // x + -y == x - y == -(y - x)
     // -x + y == y - x == -(x - y)
     ComparisonResult comparisonResult = absoluteCompare(x, y);
     if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
         return absoluteSub(vm, x, y, xSign);
 
     return absoluteSub(vm, y, x, !xSign);
 }
 
-JSBigInt* JSBigInt::sub(ExecState* exec, JSBigInt* x, JSBigInt* y)
+JSBigInt* JSBigInt::sub(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     bool xSign = x->sign();
     if (xSign != y->sign()) {
         // x - (-y) == x + y
         // (-x) - y == -(x + y)
-        return absoluteAdd(exec, x, y, xSign);
+        return absoluteAdd(globalObject, x, y, xSign);
     }
     // x - y == -(y - x)
     // (-x) - (-y) == y - x == -(x - y)
     ComparisonResult comparisonResult = absoluteCompare(x, y);
     if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
         return absoluteSub(vm, x, y, xSign);
 
     return absoluteSub(vm, y, x, !xSign);
 }
 
-JSBigInt* JSBigInt::bitwiseAnd(ExecState* exec, JSBigInt* x, JSBigInt* y)
+JSBigInt* JSBigInt::bitwiseAnd(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!x->sign() && !y->sign()) {
         scope.release();
         return absoluteAnd(vm, x, y);
@@ -500,34 +515,34 @@
 
     if (x->sign() && y->sign()) {
         int resultLength = std::max(x->length(), y->length()) + 1;
         // (-x) & (-y) == ~(x-1) & ~(y-1) == ~((x-1) | (y-1))
         // == -(((x-1) | (y-1)) + 1)
-        JSBigInt* result = absoluteSubOne(exec, x, resultLength);
+        JSBigInt* result = absoluteSubOne(globalObject, x, resultLength);
         RETURN_IF_EXCEPTION(scope, nullptr);
 
-        JSBigInt* y1 = absoluteSubOne(exec, y, y->length());
+        JSBigInt* y1 = absoluteSubOne(globalObject, y, y->length());
         RETURN_IF_EXCEPTION(scope, nullptr);
         result = absoluteOr(vm, result, y1);
         scope.release();
-        return absoluteAddOne(exec, result, SignOption::Signed);
+        return absoluteAddOne(globalObject, result, SignOption::Signed);
     }
 
     ASSERT(x->sign() != y->sign());
     // Assume that x is the positive BigInt.
     if (x->sign())
         std::swap(x, y);
 
     // x & (-y) == x & ~(y-1) == x & ~(y-1)
-    JSBigInt* y1 = absoluteSubOne(exec, y, y->length());
+    JSBigInt* y1 = absoluteSubOne(globalObject, y, y->length());
     RETURN_IF_EXCEPTION(scope, nullptr);
     return absoluteAndNot(vm, x, y1);
 }
 
-JSBigInt* JSBigInt::bitwiseOr(ExecState* exec, JSBigInt* x, JSBigInt* y)
+JSBigInt* JSBigInt::bitwiseOr(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     unsigned resultLength = std::max(x->length(), y->length());
 
     if (!x->sign() && !y->sign()) {
@@ -536,39 +551,39 @@
     }
 
     if (x->sign() && y->sign()) {
         // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) & (y-1))
         // == -(((x-1) & (y-1)) + 1)
-        JSBigInt* result = absoluteSubOne(exec, x, resultLength);
+        JSBigInt* result = absoluteSubOne(globalObject, x, resultLength);
         RETURN_IF_EXCEPTION(scope, nullptr);
-        JSBigInt* y1 = absoluteSubOne(exec, y, y->length());
+        JSBigInt* y1 = absoluteSubOne(globalObject, y, y->length());
         RETURN_IF_EXCEPTION(scope, nullptr);
         result = absoluteAnd(vm, result, y1);
         RETURN_IF_EXCEPTION(scope, nullptr);
 
         scope.release();
-        return absoluteAddOne(exec, result, SignOption::Signed);
+        return absoluteAddOne(globalObject, result, SignOption::Signed);
     }
 
     ASSERT(x->sign() != y->sign());
 
     // Assume that x is the positive BigInt.
     if (x->sign())
         std::swap(x, y);
 
     // x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) &~ x) + 1)
-    JSBigInt* result = absoluteSubOne(exec, y, resultLength);
+    JSBigInt* result = absoluteSubOne(globalObject, y, resultLength);
     RETURN_IF_EXCEPTION(scope, nullptr);
     result = absoluteAndNot(vm, result, x);
 
     scope.release();
-    return absoluteAddOne(exec, result, SignOption::Signed);
+    return absoluteAddOne(globalObject, result, SignOption::Signed);
 }
 
-JSBigInt* JSBigInt::bitwiseXor(ExecState* exec, JSBigInt* x, JSBigInt* y)
+JSBigInt* JSBigInt::bitwiseXor(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!x->sign() && !y->sign()) {
         scope.release();
         return absoluteXor(vm, x, y);
@@ -576,13 +591,13 @@
 
     if (x->sign() && y->sign()) {
         int resultLength = std::max(x->length(), y->length());
 
         // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)
-        JSBigInt* result = absoluteSubOne(exec, x, resultLength);
+        JSBigInt* result = absoluteSubOne(globalObject, x, resultLength);
         RETURN_IF_EXCEPTION(scope, nullptr);
-        JSBigInt* y1 = absoluteSubOne(exec, y, y->length());
+        JSBigInt* y1 = absoluteSubOne(globalObject, y, y->length());
         RETURN_IF_EXCEPTION(scope, nullptr);
 
         scope.release();
         return absoluteXor(vm, result, y1);
     }
@@ -592,48 +607,48 @@
     // Assume that x is the positive BigInt.
     if (x->sign())
         std::swap(x, y);
 
     // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)
-    JSBigInt* result = absoluteSubOne(exec, y, resultLength);
+    JSBigInt* result = absoluteSubOne(globalObject, y, resultLength);
     RETURN_IF_EXCEPTION(scope, nullptr);
 
     result = absoluteXor(vm, result, x);
     scope.release();
-    return absoluteAddOne(exec, result, SignOption::Signed);
+    return absoluteAddOne(globalObject, result, SignOption::Signed);
 }
 
-JSBigInt* JSBigInt::leftShift(ExecState* exec, JSBigInt* x, JSBigInt* y)
+JSBigInt* JSBigInt::leftShift(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)
 {
     if (y->isZero() || x->isZero())
         return x;
 
     if (y->sign())
-        return rightShiftByAbsolute(exec, x, y);
+        return rightShiftByAbsolute(globalObject, x, y);
 
-    return leftShiftByAbsolute(exec, x, y);
+    return leftShiftByAbsolute(globalObject, x, y);
 }
 
-JSBigInt* JSBigInt::signedRightShift(ExecState* exec, JSBigInt* x, JSBigInt* y)
+JSBigInt* JSBigInt::signedRightShift(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)
 {
     if (y->isZero() || x->isZero())
         return x;
 
     if (y->sign())
-        return leftShiftByAbsolute(exec, x, y);
+        return leftShiftByAbsolute(globalObject, x, y);
 
-    return rightShiftByAbsolute(exec, x, y);
+    return rightShiftByAbsolute(globalObject, x, y);
 }
 
-JSBigInt* JSBigInt::bitwiseNot(ExecState* exec, JSBigInt* x)
+JSBigInt* JSBigInt::bitwiseNot(JSGlobalObject* globalObject, JSBigInt* x)
 {
     if (x->sign()) {
         // ~(-x) == ~(~(x-1)) == x-1
-        return absoluteSubOne(exec, x, x->length());
+        return absoluteSubOne(globalObject, x, x->length());
     }
     // ~x == -x-1 == -(x+1)
-    return absoluteAddOne(exec, x, SignOption::Signed);
+    return absoluteAddOne(globalObject, x, SignOption::Signed);
 }
 
 #if USE(JSVALUE32_64)
 #define HAVE_TWO_DIGIT 1
 typedef uint64_t TwoDigit;
@@ -925,26 +940,26 @@
         return ComparisonResult::Equal;
 
     return x->digit(i) > y->digit(i) ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
 }
 
-JSBigInt* JSBigInt::absoluteAdd(ExecState* exec, JSBigInt* x, JSBigInt* y, bool resultSign)
+JSBigInt* JSBigInt::absoluteAdd(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y, bool resultSign)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
 
     if (x->length() < y->length())
-        return absoluteAdd(exec, y, x, resultSign);
+        return absoluteAdd(globalObject, y, x, resultSign);
 
     if (x->isZero()) {
         ASSERT(y->isZero());
         return x;
     }
 
     if (y->isZero())
         return resultSign == x->sign() ? x : unaryMinus(vm, x);
 
-    JSBigInt* result = JSBigInt::tryCreateWithLength(exec, x->length() + 1);
+    JSBigInt* result = JSBigInt::tryCreateWithLength(globalObject, x->length() + 1);
     if (!result)
         return nullptr;
     Digit carry = 0;
     unsigned i = 0;
     for (; i < y->length(); i++) {
@@ -1047,15 +1062,15 @@
 // {remainder}. Mathematically, the contract is:
 // quotient = (dividend - remainder) / divisor, with 0 <= remainder < divisor.
 // Both {quotient} and {remainder} are optional, for callers that are only
 // interested in one of them.
 // See Knuth, Volume 2, section 4.3.1, Algorithm D.
-void JSBigInt::absoluteDivWithBigIntDivisor(ExecState* exec, JSBigInt* dividend, JSBigInt* divisor, JSBigInt** quotient, JSBigInt** remainder)
+void JSBigInt::absoluteDivWithBigIntDivisor(JSGlobalObject* globalObject, JSBigInt* dividend, JSBigInt* divisor, JSBigInt** quotient, JSBigInt** remainder)
 {
     ASSERT(divisor->length() >= 2);
     ASSERT(dividend->length() >= divisor->length());
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // The unusual variable names inside this function are consistent with
     // Knuth's book, as well as with Go's implementation of this algorithm.
     // Maintaining this consistency is probably more useful than trying to
@@ -1064,15 +1079,15 @@
     unsigned m = dividend->length() - n;
 
     // The quotient to be computed.
     JSBigInt* q = nullptr;
     if (quotient != nullptr)
-        q = createWithLengthUnchecked(exec->vm(), m + 1);
+        q = createWithLengthUnchecked(globalObject->vm(), m + 1);
 
     // In each iteration, {qhatv} holds {divisor} * {current quotient digit}.
     // "v" is the book's name for {divisor}, "qhat" the current quotient digit.
-    JSBigInt* qhatv = tryCreateWithLength(exec, n + 1);
+    JSBigInt* qhatv = tryCreateWithLength(globalObject, n + 1);
     RETURN_IF_EXCEPTION(scope, void());
 
     // D1.
     // Left-shift inputs so that the divisor's MSB is set. This is necessary
     // to prevent the digit-wise divisions (see digit_div call below) from
@@ -1080,17 +1095,17 @@
     // result).
     Digit lastDigit = divisor->digit(n - 1);
     unsigned shift = clz(lastDigit);
 
     if (shift > 0) {
-        divisor = absoluteLeftShiftAlwaysCopy(exec, divisor, shift, LeftShiftMode::SameSizeResult);
+        divisor = absoluteLeftShiftAlwaysCopy(globalObject, divisor, shift, LeftShiftMode::SameSizeResult);
         RETURN_IF_EXCEPTION(scope, void());
     }
 
     // Holds the (continuously updated) remaining part of the dividend, which
     // eventually becomes the remainder.
-    JSBigInt* u = absoluteLeftShiftAlwaysCopy(exec, dividend, shift, LeftShiftMode::AlwaysAddOneDigit);
+    JSBigInt* u = absoluteLeftShiftAlwaysCopy(globalObject, dividend, shift, LeftShiftMode::AlwaysAddOneDigit);
     RETURN_IF_EXCEPTION(scope, void());
 
     // D2.
     // Iterate over the dividend's digit (like the "grad school" algorithm).
     // {vn1} is the divisor's most significant digit.
@@ -1215,18 +1230,18 @@
     }
     setDigit(last, carry);
 }
 
 // Always copies the input, even when {shift} == 0.
-JSBigInt* JSBigInt::absoluteLeftShiftAlwaysCopy(ExecState* exec, JSBigInt* x, unsigned shift, LeftShiftMode mode)
+JSBigInt* JSBigInt::absoluteLeftShiftAlwaysCopy(JSGlobalObject* globalObject, JSBigInt* x, unsigned shift, LeftShiftMode mode)
 {
     ASSERT(shift < digitBits);
     ASSERT(!x->isZero());
 
     unsigned n = x->length();
     unsigned resultLength = mode == LeftShiftMode::AlwaysAddOneDigit ? n + 1 : n;
-    JSBigInt* result = tryCreateWithLength(exec, resultLength);
+    JSBigInt* result = tryCreateWithLength(globalObject, resultLength);
     if (!result)
         return nullptr;
 
     if (!shift) {
         for (unsigned i = 0; i < n; i++)
@@ -1329,11 +1344,11 @@
         return a ^ b;
     };
     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::Symmetric, digitOperation);
 }
 
-JSBigInt* JSBigInt::absoluteAddOne(ExecState* exec, JSBigInt* x, SignOption signOption)
+JSBigInt* JSBigInt::absoluteAddOne(JSGlobalObject* globalObject, JSBigInt* x, SignOption signOption)
 {
     unsigned inputLength = x->length();
     // The addition will overflow into a new digit if all existing digits are
     // at maximum.
     bool willOverflow = true;
@@ -1343,11 +1358,11 @@
             break;
         }
     }
 
     unsigned resultLength = inputLength + willOverflow;
-    JSBigInt* result = tryCreateWithLength(exec, resultLength);
+    JSBigInt* result = tryCreateWithLength(globalObject, resultLength);
     if (!result)
         return nullptr;
 
     Digit carry = 1;
     for (unsigned i = 0; i < inputLength; i++) {
@@ -1359,21 +1374,21 @@
         result->setDigit(inputLength, carry);
     else
         ASSERT(!carry);
 
     result->setSign(signOption == SignOption::Signed);
-    return result->rightTrim(exec->vm());
+    return result->rightTrim(globalObject->vm());
 }
 
-JSBigInt* JSBigInt::absoluteSubOne(ExecState* exec, JSBigInt* x, unsigned resultLength)
+JSBigInt* JSBigInt::absoluteSubOne(JSGlobalObject* globalObject, JSBigInt* x, unsigned resultLength)
 {
     ASSERT(!x->isZero());
     ASSERT(resultLength >= x->length());
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSBigInt* result = tryCreateWithLength(exec, resultLength);
+    JSBigInt* result = tryCreateWithLength(globalObject, resultLength);
     RETURN_IF_EXCEPTION(scope, nullptr);
 
     unsigned length = x->length();
     Digit borrow = 1;
     for (unsigned i = 0; i < length; i++) {
@@ -1386,33 +1401,33 @@
         result->setDigit(i, borrow);
 
     return result->rightTrim(vm);
 }
 
-JSBigInt* JSBigInt::leftShiftByAbsolute(ExecState* exec, JSBigInt* x, JSBigInt* y)
+JSBigInt* JSBigInt::leftShiftByAbsolute(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     auto optionalShift = toShiftAmount(y);
     if (!optionalShift) {
-        throwRangeError(exec, scope, "BigInt generated from this operation is too big"_s);
+        throwRangeError(globalObject, scope, "BigInt generated from this operation is too big"_s);
         return nullptr;
     }
 
     Digit shift = *optionalShift;
     unsigned digitShift = static_cast<unsigned>(shift / digitBits);
     unsigned bitsShift = static_cast<unsigned>(shift % digitBits);
     unsigned length = x->length();
     bool grow = bitsShift && (x->digit(length - 1) >> (digitBits - bitsShift));
     int resultLength = length + digitShift + grow;
     if (static_cast<unsigned>(resultLength) > maxLength) {
-        throwRangeError(exec, scope, "BigInt generated from this operation is too big"_s);
+        throwRangeError(globalObject, scope, "BigInt generated from this operation is too big"_s);
         return nullptr;
     }
 
-    JSBigInt* result = tryCreateWithLength(exec, resultLength);
+    JSBigInt* result = tryCreateWithLength(globalObject, resultLength);
     RETURN_IF_EXCEPTION(scope, nullptr);
     if (!bitsShift) {
         unsigned i = 0;
         for (; i < digitShift; i++)
             result->setDigit(i, 0ul);
@@ -1438,13 +1453,13 @@
 
     result->setSign(x->sign());
     return result->rightTrim(vm);
 }
 
-JSBigInt* JSBigInt::rightShiftByAbsolute(ExecState* exec, JSBigInt* x, JSBigInt* y)
+JSBigInt* JSBigInt::rightShiftByAbsolute(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     unsigned length = x->length();
     bool sign = x->sign();
     auto optionalShift = toShiftAmount(y);
     if (!optionalShift)
         return rightShiftByMaximum(vm, sign);
@@ -1504,11 +1519,11 @@
         result->setSign(true);
         if (mustRoundDown) {
             // Since the result is negative, rounding down means adding one to
             // its absolute value. This cannot overflow.
             result = result->rightTrim(vm);
-            return absoluteAddOne(exec, result, SignOption::Signed);
+            return absoluteAddOne(globalObject, result, SignOption::Signed);
         }
     }
 
     return result->rightTrim(vm);
 }
@@ -1562,11 +1577,11 @@
     maximumCharactersRequired += sign;
 
     return maximumCharactersRequired;
 }
 
-String JSBigInt::toStringBasePowerOfTwo(VM& vm, ExecState* exec, JSBigInt* x, unsigned radix)
+String JSBigInt::toStringBasePowerOfTwo(VM& vm, JSGlobalObject* globalObject, JSBigInt* x, unsigned radix)
 {
     ASSERT(hasOneBitSet(radix));
     ASSERT(radix >= 2 && radix <= 32);
     ASSERT(!x->isZero());
 
@@ -1582,13 +1597,13 @@
 
     const size_t bitLength = length * digitBits - msdLeadingZeros;
     const size_t charsRequired = (bitLength + bitsPerChar - 1) / bitsPerChar + sign;
 
     if (charsRequired > JSString::MaxLength) {
-        if (exec) {
+        if (globalObject) {
             auto scope = DECLARE_THROW_SCOPE(vm);
-            throwOutOfMemoryError(exec, scope);
+            throwOutOfMemoryError(globalObject, scope);
         }
         return String();
     }
 
     Vector<LChar> resultString(charsRequired);
@@ -1624,11 +1639,11 @@
 
     ASSERT(pos == -1);
     return StringImpl::adopt(WTFMove(resultString));
 }
 
-String JSBigInt::toStringGeneric(VM& vm, ExecState* exec, JSBigInt* x, unsigned radix)
+String JSBigInt::toStringGeneric(VM& vm, JSGlobalObject* globalObject, JSBigInt* x, unsigned radix)
 {
     // FIXME: [JSC] Revisit usage of Vector into JSBigInt::toString
     // https://bugs.webkit.org/show_bug.cgi?id=18067
     Vector<LChar> resultString;
 
@@ -1640,13 +1655,13 @@
 
     uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
     uint64_t maximumCharactersRequired = calculateMaximumCharactersRequired(length, radix, x->digit(length - 1), sign);
 
     if (maximumCharactersRequired > JSString::MaxLength) {
-        if (exec) {
+        if (globalObject) {
             auto scope = DECLARE_THROW_SCOPE(vm);
-            throwOutOfMemoryError(exec, scope);
+            throwOutOfMemoryError(globalObject, scope);
         }
         return String();
     }
 
     Digit lastDigit;
@@ -1735,11 +1750,11 @@
     trimmedBigInt->setSign(this->sign());
 
     return trimmedBigInt;
 }
 
-JSBigInt* JSBigInt::allocateFor(ExecState* exec, VM& vm, unsigned radix, unsigned charcount)
+JSBigInt* JSBigInt::allocateFor(JSGlobalObject* globalObject, VM& vm, unsigned radix, unsigned charcount)
 {
     ASSERT(2 <= radix && radix <= 36);
 
     size_t bitsPerChar = maxBitsPerCharTable[radix];
     size_t chars = charcount;
@@ -1757,56 +1772,56 @@
                 return result;
             }
         }
     }
 
-    if (exec) {
+    if (globalObject) {
         auto scope = DECLARE_THROW_SCOPE(vm);
-        throwOutOfMemoryError(exec, scope);
+        throwOutOfMemoryError(globalObject, scope);
     }
     return nullptr;
 }
 
 size_t JSBigInt::estimatedSize(JSCell* cell, VM& vm)
 {
     return Base::estimatedSize(cell, vm) + jsCast<JSBigInt*>(cell)->m_length * sizeof(Digit);
 }
 
-double JSBigInt::toNumber(ExecState* exec) const
+double JSBigInt::toNumber(JSGlobalObject* globalObject) const
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    throwTypeError(exec, scope, "Conversion from 'BigInt' to 'number' is not allowed."_s);
+    throwTypeError(globalObject, scope, "Conversion from 'BigInt' to 'number' is not allowed."_s);
     return 0.0;
 }
 
-bool JSBigInt::getPrimitiveNumber(ExecState* exec, double& number, JSValue& result) const
+bool JSBigInt::getPrimitiveNumber(JSGlobalObject* globalObject, double& number, JSValue& result) const
 {
     result = this;
-    number = toNumber(exec);
+    number = toNumber(globalObject);
     return true;
 }
 
 template <typename CharType>
-JSBigInt* JSBigInt::parseInt(ExecState* exec, CharType*  data, unsigned length, ErrorParseMode errorParseMode)
+JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, CharType*  data, unsigned length, ErrorParseMode errorParseMode)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
 
     unsigned p = 0;
     while (p < length && isStrWhiteSpace(data[p]))
         ++p;
 
     // Check Radix from frist characters
     if (static_cast<unsigned>(p) + 1 < static_cast<unsigned>(length) && data[p] == '0') {
         if (isASCIIAlphaCaselessEqual(data[p + 1], 'b'))
-            return parseInt(exec, vm, data, length, p + 2, 2, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);
+            return parseInt(globalObject, vm, data, length, p + 2, 2, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);
 
         if (isASCIIAlphaCaselessEqual(data[p + 1], 'x'))
-            return parseInt(exec, vm, data, length, p + 2, 16, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);
+            return parseInt(globalObject, vm, data, length, p + 2, 16, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);
 
         if (isASCIIAlphaCaselessEqual(data[p + 1], 'o'))
-            return parseInt(exec, vm, data, length, p + 2, 8, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);
+            return parseInt(globalObject, vm, data, length, p + 2, 8, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);
     }
 
     ParseIntSign sign = ParseIntSign::Unsigned;
     if (p < length) {
         if (data[p] == '+')
@@ -1815,30 +1830,30 @@
             sign = ParseIntSign::Signed;
             ++p;
         }
     }
 
-    JSBigInt* result = parseInt(exec, vm, data, length, p, 10, errorParseMode, sign);
+    JSBigInt* result = parseInt(globalObject, vm, data, length, p, 10, errorParseMode, sign);
 
     if (result && !result->isZero())
         result->setSign(sign == ParseIntSign::Signed);
 
     return result;
 }
 
 template <typename CharType>
-JSBigInt* JSBigInt::parseInt(ExecState* exec, VM& vm, CharType* data, unsigned length, unsigned startIndex, unsigned radix, ErrorParseMode errorParseMode, ParseIntSign sign, ParseIntMode parseMode)
+JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, VM& vm, CharType* data, unsigned length, unsigned startIndex, unsigned radix, ErrorParseMode errorParseMode, ParseIntSign sign, ParseIntMode parseMode)
 {
     ASSERT(length >= 0);
     unsigned p = startIndex;
 
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (parseMode != ParseIntMode::AllowEmptyString && startIndex == length) {
-        ASSERT(exec);
+        ASSERT(globalObject);
         if (errorParseMode == ErrorParseMode::ThrowExceptions)
-            throwVMError(exec, scope, createSyntaxError(exec, "Failed to parse String to BigInt"));
+            throwVMError(globalObject, scope, createSyntaxError(globalObject, "Failed to parse String to BigInt"));
         return nullptr;
     }
 
     // Skipping leading zeros
     while (p < length && data[p] == '0')
@@ -1856,12 +1871,15 @@
 
     unsigned limit0 = '0' + (radix < 10 ? radix : 10);
     unsigned limita = 'a' + (radix - 10);
     unsigned limitA = 'A' + (radix - 10);
 
-    JSBigInt* result = allocateFor(exec, vm, radix, length - p);
+    JSBigInt* result = allocateFor(globalObject, vm, radix, length - p);
     RETURN_IF_EXCEPTION(scope, nullptr);
+    // result can still be null if we don't have access to global object, as allocateFor cannot throw an exception in that case.
+    if (!result)
+        return nullptr;
 
     result->initialize(InitializationType::WithZero);
 
     for (unsigned i = p; i < length; i++, p++) {
         uint32_t digit;
@@ -1879,13 +1897,13 @@
 
     result->setSign(sign == ParseIntSign::Signed ? true : false);
     if (p == length)
         return result->rightTrim(vm);
 
-    ASSERT(exec);
+    ASSERT(globalObject);
     if (errorParseMode == ErrorParseMode::ThrowExceptions)
-        throwVMError(exec, scope, createSyntaxError(exec, "Failed to parse String to BigInt"));
+        throwVMError(globalObject, scope, createSyntaxError(globalObject, "Failed to parse String to BigInt"));
 
     return nullptr;
 }
 
 inline JSBigInt::Digit JSBigInt::digit(unsigned n)
@@ -1898,13 +1916,13 @@
 {
     ASSERT(n < length());
     dataStorage()[n] = value;
 }
 
-JSObject* JSBigInt::toObject(ExecState* exec, JSGlobalObject* globalObject) const
+JSObject* JSBigInt::toObject(JSGlobalObject* globalObject) const
 {
-    return BigIntObject::create(exec->vm(), globalObject, const_cast<JSBigInt*>(this));
+    return BigIntObject::create(globalObject->vm(), globalObject, const_cast<JSBigInt*>(this));
 }
 
 bool JSBigInt::equalsToNumber(JSValue numValue)
 {
     ASSERT(numValue.isNumber());

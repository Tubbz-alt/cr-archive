<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/java/com/sun/webkit/WebPage.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.webkit;
  27 
  28 import javafx.application.ConditionalFeature;
  29 import javafx.application.Platform;
  30 import com.sun.glass.utils.NativeLibLoader;
  31 import com.sun.javafx.logging.PlatformLogger;
  32 import com.sun.javafx.logging.PlatformLogger.Level;
  33 import com.sun.webkit.event.WCFocusEvent;
  34 import com.sun.webkit.event.WCInputMethodEvent;
  35 import com.sun.webkit.event.WCKeyEvent;
  36 import com.sun.webkit.event.WCMouseEvent;
  37 import com.sun.webkit.event.WCMouseWheelEvent;
  38 import com.sun.webkit.graphics.*;
  39 import com.sun.webkit.network.CookieManager;
  40 import static com.sun.webkit.network.URLs.newURL;
  41 import java.net.CookieHandler;
  42 import java.net.MalformedURLException;
  43 import java.net.URL;
  44 import java.nio.ByteBuffer;
  45 import java.nio.ByteOrder;
  46 import java.security.AccessControlContext;
  47 import java.security.AccessController;
  48 import java.security.PrivilegedAction;
  49 import java.util.ArrayList;
  50 import java.util.HashMap;
  51 import java.util.HashSet;
  52 import java.util.Iterator;
  53 import java.util.LinkedList;
  54 import java.util.List;
  55 import java.util.Map;
  56 import java.util.Queue;
  57 import java.util.Set;
  58 import java.util.concurrent.CountDownLatch;
  59 import java.util.concurrent.ExecutionException;
  60 import java.util.concurrent.FutureTask;
  61 import java.util.concurrent.atomic.AtomicReference;
  62 import java.util.concurrent.locks.ReentrantLock;
  63 import netscape.javascript.JSException;
  64 import org.w3c.dom.Document;
  65 import org.w3c.dom.Element;
  66 
  67 /**
  68  * This class provides two-side interaction between native webkit core and
  69  * number of clients representing different subsystems of the WebPane component
  70  * such as
  71  * &lt;ul&gt;
  72  * &lt;li&gt;webpage rendering({@link WebPageClient})
  73  * &lt;li&gt;creating/disposing web frames ({@link WebFrameClient})
  74  * &lt;li&gt;creating new windows, alert dialogues ... ({@link UIClient})
  75  * &lt;li&gt;handling menus {@link MenuClient}
  76  * &lt;li&gt;supporting policy checking {@link PolicyClient}
  77  * &lt;/ul&gt;
  78  */
  79 
  80 public final class WebPage {
  81     private final static PlatformLogger log = PlatformLogger.getLogger(WebPage.class.getName());
  82     private final static PlatformLogger paintLog = PlatformLogger.getLogger(WebPage.class.getName() + &quot;.paint&quot;);
  83 
  84     private static final int MAX_FRAME_QUEUE_SIZE = 10;
  85 
  86     // Native WebPage* pointer
  87     private long pPage = 0;
  88 
  89     // A flag to distinguish whether the web page hasn&#39;t been created
  90     // yet or had been already disposed - in both cases pPage is 0
  91     private boolean isDisposed = false;
  92 
  93     private int width, height;
  94 
  95     private int fontSmoothingType;
  96 
  97     private final WCFrameView hostWindow;
  98 
  99     // List of created frames
 100     private final Set&lt;Long&gt; frames = new HashSet&lt;Long&gt;();
 101 
 102     // The access control context associated with this object
 103     private final AccessControlContext accessControlContext;
 104 
 105     // Maps load request identifiers to URLs
 106     private final Map&lt;Integer, String&gt; requestURLs =
 107             new HashMap&lt;Integer, String&gt;();
 108 
 109     // There may be several RESOURCE_STARTED events for a resource,
 110     // so this map is used to convert them to RESOURCE_REDIRECTED
 111     private final Set&lt;Integer&gt; requestStarted = new HashSet&lt;Integer&gt;();
 112 
 113     // PAGE_LOCK is used to synchronize the following operations b/w Event &amp; Main threads:
 114     // - rendering of the page (Main thread)
 115     // - native calls &amp; other manipulations on the page (Event &amp; Main threads)
 116     // - timer invocations (Event thread)
 117     private static final ReentrantLock PAGE_LOCK = new ReentrantLock();
 118 
 119     // The queue of render frames awaiting rendering.
 120     // Access to this object is synchronized on its monitor.
 121     // Accessed on: Event thread and Main thread.
 122     private final Queue&lt;RenderFrame&gt; frameQueue = new LinkedList&lt;RenderFrame&gt;();
 123 
 124     // The current frame being generated.
 125     // Accessed on: Event thread only.
 126     private RenderFrame currentFrame = new RenderFrame();
 127 
 128     // An ID of the current updateContent cycle associated with an updateContent call.
 129     private int updateContentCycleID;
 130 
 131     static {
 132         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 133             NativeLibLoader.loadLibrary(&quot;jfxwebkit&quot;);
 134             log.finer(&quot;jfxwebkit loaded&quot;);
 135 
 136             if (CookieHandler.getDefault() == null) {
 137                 boolean setDefault = Boolean.valueOf(System.getProperty(
 138                         &quot;com.sun.webkit.setDefaultCookieHandler&quot;,
 139                         &quot;true&quot;));
 140                 if (setDefault) {
 141                     CookieHandler.setDefault(new CookieManager());
 142                 }
 143             }
 144 
 145             final boolean useJIT = Boolean.valueOf(System.getProperty(
 146                     &quot;com.sun.webkit.useJIT&quot;, &quot;true&quot;));
 147             final boolean useDFGJIT = Boolean.valueOf(System.getProperty(
 148                     &quot;com.sun.webkit.useDFGJIT&quot;, &quot;true&quot;));
 149 
 150             // TODO: Enable CSS3D by default once it is stabilized.
 151             boolean useCSS3D = Boolean.valueOf(System.getProperty(
 152                     &quot;com.sun.webkit.useCSS3D&quot;, &quot;false&quot;));
 153             useCSS3D = useCSS3D &amp;&amp; Platform.isSupported(ConditionalFeature.SCENE3D);
 154 
 155             // Initialize WTF, WebCore and JavaScriptCore.
 156             twkInitWebCore(useJIT, useDFGJIT, useCSS3D);
 157             return null;
 158         });
 159 
 160     }
 161 
 162     private static boolean firstWebPageCreated = false;
 163 
 164     private static void collectJSCGarbages() {
 165         Invoker.getInvoker().checkEventThread();
 166         // Add dummy object to get notification as soon as it is collected
 167         // by the JVM GC.
 168         Disposer.addRecord(new Object(), WebPage::collectJSCGarbages);
 169         // Invoke JavaScriptCore GC.
 170         twkDoJSCGarbageCollection();
 171     }
 172 
 173     public WebPage(WebPageClient pageClient,
 174                    UIClient uiClient,
 175                    PolicyClient policyClient,
 176                    InspectorClient inspectorClient,
 177                    ThemeClient themeClient,
 178                    boolean editable)
 179     {
 180         Invoker.getInvoker().checkEventThread();
 181 
 182         this.pageClient = pageClient;
 183         this.uiClient = uiClient;
 184         this.policyClient = policyClient;
 185         this.inspectorClient = inspectorClient;
 186         if (themeClient != null) {
 187             this.renderTheme = themeClient.createRenderTheme();
 188             this.scrollbarTheme = themeClient.createScrollBarTheme();
 189         } else {
 190             this.renderTheme = null;
 191             this.scrollbarTheme = null;
 192         }
 193 
 194         accessControlContext = AccessController.getContext();
 195 
 196         hostWindow = new WCFrameView(this);
 197         pPage = twkCreatePage(editable);
 198 
 199         twkInit(pPage, false, WCGraphicsManager.getGraphicsManager().getDevicePixelScale());
 200 
 201         if (pageClient != null &amp;&amp; pageClient.isBackBufferSupported()) {
 202             backbuffer = pageClient.createBackBuffer();
 203             backbuffer.ref();
 204         }
 205 
 206         if (!firstWebPageCreated) {
 207             // Add dummy object to get notification as soon as it is collected
 208             // by the JVM GC.
 209             Disposer.addRecord(new Object(), WebPage::collectJSCGarbages);
 210             firstWebPageCreated = true;
 211         }
 212     }
 213 
 214     long getPage() {
 215         return pPage;
 216     }
 217 
 218     // Called from the native code
 219     private WCWidget getHostWindow() {
 220         return hostWindow;
 221     }
 222 
 223     /**
 224      * Returns the access control context associated with this object.
 225      * May be called on any thread.
 226      * @return the access control context associated with this object
 227      */
 228     public AccessControlContext getAccessControlContext() {
 229         return accessControlContext;
 230     }
 231 
 232     static boolean lockPage() {
 233         return Invoker.getInvoker().lock(PAGE_LOCK);
 234     }
 235 
 236     static boolean unlockPage() {
 237         return Invoker.getInvoker().unlock(PAGE_LOCK);
 238     }
 239 
 240     // *************************************************************************
 241     // Backbuffer support
 242     // *************************************************************************
 243 
 244     private WCPageBackBuffer backbuffer;
 245     private List&lt;WCRectangle&gt; dirtyRects = new LinkedList&lt;WCRectangle&gt;();
 246 
 247     private void addDirtyRect(WCRectangle toPaint) {
 248         if (toPaint.getWidth() &lt;= 0 || toPaint.getHeight() &lt;= 0) {
 249             return;
 250         }
 251         for (Iterator&lt;WCRectangle&gt; it = dirtyRects.iterator(); it.hasNext();) {
 252             WCRectangle rect = it.next();
 253             // if already covered
 254             if (rect.contains(toPaint)) {
 255                 return;
 256             }
 257             // if covers an existing one
 258             if (toPaint.contains(rect)) {
 259                 it.remove();
 260                 continue;
 261             }
 262             WCRectangle u = rect.createUnion(toPaint);
 263             // if squre of union is less than summary of squares
 264             if (u.getIntWidth() * u.getIntHeight() &lt;
 265                 rect.getIntWidth() * rect.getIntHeight() +
 266                 toPaint.getIntWidth() * toPaint.getIntHeight())
 267             {
 268                 it.remove();
 269                 toPaint = u; // replace both the rects with their union
 270                 continue;
 271             }
 272         }
 273         dirtyRects.add(toPaint);
 274     }
 275 
 276     public boolean isDirty() {
 277         lockPage();
 278         try {
 279             return !dirtyRects.isEmpty();
 280         } finally {
 281             unlockPage();
 282         }
 283     }
 284 
 285     private void updateDirty(WCRectangle clip) {
 286         if (paintLog.isLoggable(Level.FINEST)) {
 287             paintLog.finest(&quot;Entering, dirtyRects: {0}, currentFrame: {1}&quot;,
 288                     new Object[] {dirtyRects, currentFrame});
 289         }
 290 
 291         if (isDisposed || width &lt;= 0 || height &lt;= 0) {
 292             // If there&#39;re any dirty rects left, they are invalid.
 293             // Clear the list so that the platform doesn&#39;t consider
 294             // the page dirty.
 295             dirtyRects.clear();
 296             return;
 297         }
 298         if (clip == null) {
 299             clip = new WCRectangle(0, 0, width, height);
 300         }
 301         List&lt;WCRectangle&gt; oldDirtyRects = dirtyRects;
 302         dirtyRects = new LinkedList&lt;WCRectangle&gt;();
 303         twkPrePaint(getPage());
 304         while (!oldDirtyRects.isEmpty()) {
 305             WCRectangle r = oldDirtyRects.remove(0).intersection(clip);
 306             if (r.getWidth() &lt;= 0 || r.getHeight() &lt;= 0) {
 307                 continue;
 308             }
 309             paintLog.finest(&quot;Updating: {0}&quot;, r);
 310             WCRenderQueue rq = WCGraphicsManager.getGraphicsManager()
 311                     .createRenderQueue(r, true);
 312             twkUpdateContent(getPage(), rq, r.getIntX() - 1, r.getIntY() - 1,
 313                              r.getIntWidth() + 2, r.getIntHeight() + 2);
 314             currentFrame.addRenderQueue(rq);
 315         }
 316         {
 317             WCRenderQueue rq = WCGraphicsManager.getGraphicsManager()
 318                     .createRenderQueue(clip, false);
 319             twkPostPaint(getPage(), rq,
 320                          clip.getIntX(), clip.getIntY(),
 321                          clip.getIntWidth(), clip.getIntHeight());
 322             currentFrame.addRenderQueue(rq);
 323         }
 324 
 325         if (paintLog.isLoggable(Level.FINEST)) {
 326             paintLog.finest(&quot;Dirty rects processed, dirtyRects: {0}, currentFrame: {1}&quot;,
 327                     new Object[] {dirtyRects, currentFrame});
 328         }
 329 
 330         if (currentFrame.getRQList().size() &gt; 0) {
 331             synchronized (frameQueue) {
 332                 paintLog.finest(&quot;About to update frame queue, frameQueue: {0}&quot;, frameQueue);
 333 
 334                 Iterator&lt;RenderFrame&gt; it = frameQueue.iterator();
 335                 while (it.hasNext()) {
 336                     RenderFrame frame = it.next();
 337                     for (WCRenderQueue rq : currentFrame.getRQList()) {
 338                         WCRectangle rqRect = rq.getClip();
 339                         if (rq.isOpaque()
 340                                 &amp;&amp; rqRect.contains(frame.getEnclosingRect()))
 341                         {
 342                             paintLog.finest(&quot;Dropping: {0}&quot;, frame);
 343                             frame.drop();
 344                             it.remove();
 345                             break;
 346                         }
 347                     }
 348                 }
 349 
 350                 frameQueue.add(currentFrame);
 351                 currentFrame = new RenderFrame();
 352 
 353                 if (frameQueue.size() &gt; MAX_FRAME_QUEUE_SIZE) {
 354                     paintLog.finest(&quot;Frame queue exceeded maximum &quot;
 355                             + &quot;size, clearing and requesting full repaint&quot;);
 356                     dropRenderFrames();
 357                     repaintAll();
 358                 }
 359 
 360                 paintLog.finest(&quot;Frame queue updated, frameQueue: {0}&quot;, frameQueue);
 361             }
 362         }
 363 
 364         if (paintLog.isLoggable(Level.FINEST)) {
 365             paintLog.finest(&quot;Exiting, dirtyRects: {0}, currentFrame: {1}&quot;,
 366                     new Object[] {dirtyRects, currentFrame});
 367         }
 368     }
 369 
 370     private void scroll(int x, int y, int w, int h, int dx, int dy) {
 371         if (paintLog.isLoggable(Level.FINEST)) {
 372             paintLog.finest(&quot;rect=[&quot; + x + &quot;, &quot; + y + &quot; &quot; + w + &quot;x&quot; + h +
 373                             &quot;] delta=[&quot; + dx + &quot;, &quot; + dy + &quot;]&quot;);
 374         }
 375         dx += currentFrame.scrollDx;
 376         dy += currentFrame.scrollDy;
 377 
 378         if (Math.abs(dx) &lt; w &amp;&amp; Math.abs(dy) &lt; h) {
 379             int cx = (dx &gt;= 0) ? x : x - dx;
 380             int cy = (dy &gt;= 0) ? y : y - dy;
 381             int cw = (dx == 0) ? w : w - Math.abs(dx);
 382             int ch = (dy == 0) ? h : h - Math.abs(dy);
 383 
 384             WCRenderQueue rq = WCGraphicsManager.getGraphicsManager()
 385                     .createRenderQueue(
 386                             new WCRectangle(0, 0, width, height), false);
 387             ByteBuffer buffer = ByteBuffer.allocate(32)
 388                     .order(ByteOrder.nativeOrder())
 389                     .putInt(GraphicsDecoder.COPYREGION)
 390                     .putInt(backbuffer.getID())
 391                     .putInt(cx).putInt(cy).putInt(cw).putInt(ch)
 392                     .putInt(dx).putInt(dy);
 393             buffer.flip();
 394             rq.addBuffer(buffer);
 395             // Ignore previous COPYREGION
 396             currentFrame.drop();
 397             currentFrame.addRenderQueue(rq);
 398             currentFrame.scrollDx = dx;
 399             currentFrame.scrollDy = dy;
 400             // Now we have to translate &quot;old&quot; dirty rects that fit to the frame&#39;s
 401             // content as the content is already scrolled at the moment by webkit.
 402             if (!dirtyRects.isEmpty()) {
 403                 WCRectangle scrollRect = new WCRectangle(x, y, w, h);
 404                 for (WCRectangle r: dirtyRects) {
 405                     if (scrollRect.contains(r)) {
 406                         if (paintLog.isLoggable(Level.FINEST)) {
 407                             paintLog.finest(&quot;translating old dirty rect by the delta: &quot; + r);
 408                         }
 409                         r.translate(dx, dy);
 410                     }
 411                 }
 412             }
 413         }
 414 
 415         // Add the dirty (not copied) rects
 416         addDirtyRect(new WCRectangle(x, dy &gt;= 0 ? y : y + h + dy,
 417                                      w, Math.abs(dy)));
 418         addDirtyRect(new WCRectangle(dx &gt;= 0 ? x : x + w + dx, y,
 419                                      Math.abs(dx), h - Math.abs(dy)));
 420     }
 421 
 422     // Instances of this class may not be accessed and modified concurrently
 423     // by multiple threads
 424     private static final class RenderFrame {
 425         private final List&lt;WCRenderQueue&gt; rqList =
 426                 new LinkedList&lt;WCRenderQueue&gt;();
 427         private int scrollDx, scrollDy;
 428         private final WCRectangle enclosingRect = new WCRectangle();
 429 
 430         // Called on: Event thread only
 431         private void addRenderQueue(WCRenderQueue rq) {
 432             if (rq.isEmpty()) {
 433                 return;
 434             }
 435             rqList.add(rq);
 436             WCRectangle rqRect = rq.getClip();
 437             if (enclosingRect.isEmpty()) {
 438                 enclosingRect.setFrame(rqRect.getX(), rqRect.getY(),
 439                                        rqRect.getWidth(), rqRect.getHeight());
 440             } else if (rqRect.isEmpty()) {
 441                 // do nothing
 442             } else {
 443                 WCRectangle.union(enclosingRect, rqRect, enclosingRect);
 444             }
 445         }
 446 
 447         // Called on: Event thread and Main thread
 448         private List&lt;WCRenderQueue&gt; getRQList() {
 449             return rqList;
 450         }
 451 
 452         // Called on: Event thread only
 453         private WCRectangle getEnclosingRect() {
 454             return enclosingRect;
 455         }
 456 
 457         // Called on: Event thread only
 458         private void drop() {
 459             for (WCRenderQueue rq : rqList) {
 460                 rq.dispose();
 461             }
 462             rqList.clear();
 463             enclosingRect.setFrame(0, 0, 0, 0);
 464             scrollDx = 0;
 465             scrollDy = 0;
 466         }
 467 
 468         @Override
 469         public String toString() {
 470             return &quot;RenderFrame{&quot;
 471                     + &quot;rqList=&quot; + rqList + &quot;, &quot;
 472                     + &quot;enclosingRect=&quot; + enclosingRect
 473                     + &quot;}&quot;;
 474         }
 475     }
 476 
 477     // *************************************************************************
 478     // Callback API
 479     // *************************************************************************
 480 
 481     private final WebPageClient pageClient;
 482     private final UIClient uiClient;
 483     private final PolicyClient policyClient;
 484     private InputMethodClient imClient;
 485     private final List&lt;LoadListenerClient&gt; loadListenerClients =
 486         new LinkedList&lt;LoadListenerClient&gt;();
 487     private final InspectorClient inspectorClient;
 488     private final RenderTheme renderTheme;
 489     private final ScrollBarTheme scrollbarTheme;
 490 
 491     public WebPageClient getPageClient() {
 492         return pageClient;
 493     }
 494 
 495     public void setInputMethodClient(InputMethodClient imClient) {
 496         this.imClient = imClient;
 497     }
 498 
 499     public void setInputMethodState(boolean state) {
 500         if (imClient != null) {
 501             // A web page containing multiple clients is a single client from Java
 502             // Input Method Framework&#39;s viewpoint. We need to control activation and
 503             // deactivation for each text field/area here. Also, we need to control
 504             // enabling and disabling input methods here so that input method events
 505             // won&#39;t get delivered to wrong places (e.g., background).
 506             imClient.activateInputMethods(state);
 507         }
 508     }
 509 
 510     public void addLoadListenerClient(LoadListenerClient l) {
 511         if (!loadListenerClients.contains(l)) {
 512             loadListenerClients.add(l);
 513         }
 514     }
 515 
 516     private RenderTheme getRenderTheme() {
 517         return renderTheme;
 518     }
 519 
 520     private static RenderTheme fwkGetDefaultRenderTheme() {
 521         return ThemeClient.getDefaultRenderTheme();
 522     }
 523 
 524     private ScrollBarTheme getScrollBarTheme() {
 525         return scrollbarTheme;
 526     }
 527 
 528     // *************************************************************************
 529     // UI stuff API
 530     // *************************************************************************
 531 
 532     public void setBounds(int x, int y, int w, int h) {
 533         lockPage();
 534         try {
 535             log.fine(&quot;setBounds: &quot; + x + &quot; &quot; + y + &quot; &quot; + w + &quot; &quot; + h);
 536             if (isDisposed) {
 537                 log.fine(&quot;setBounds() request for a disposed web page.&quot;);
 538                 return;
 539             }
 540             width = w;
 541             height = h;
 542             twkSetBounds(getPage(), 0, 0, w, h);
 543             // In response to the above call, WebKit will issue many
 544             // repaint requests, one of which will be meant to invalidate
 545             // the entire visible area. However, if the current scroll
 546             // offset is non-zero, that repaint request will contain
 547             // incorrect coordinates.
 548             // As of time of writing this, this problem exists in both
 549             // MiniBrowser and WinLauncher.
 550             // MiniBrowser is based on WebKit2, and WebKit2 workarounds
 551             // this problem by calling m_drawingArea-&gt;setNeedsDisplay()
 552             // for the entire visible area from within the WebKit2&#39;s
 553             // WebPage::setSize().
 554             // WinLauncher workarounds this problem by setting the main
 555             // window class style to CS_HREDRAW | CS_VREDRAW and calling
 556             // MoveWindow() with bRepaint = TRUE when resizing the web
 557             // view.
 558             // We workaround this problem by invalidating the entire
 559             // visible area here.
 560             repaintAll();
 561 
 562         } finally {
 563             unlockPage();
 564         }
 565     }
 566 
 567     public void setOpaque(long frameID, boolean isOpaque) {
 568         lockPage();
 569         try {
 570             log.fine(&quot;setOpaque: &quot; + isOpaque);
 571             if (isDisposed) {
 572                 log.fine(&quot;setOpaque() request for a disposed web page.&quot;);
 573                 return;
 574             }
 575             if (!frames.contains(frameID)) {
 576                 return;
 577             }
 578             twkSetTransparent(frameID, !isOpaque);
 579 
 580         } finally {
 581             unlockPage();
 582         }
 583     }
 584 
 585     public void setBackgroundColor(long frameID, int backgroundColor) {
 586         lockPage();
 587         try {
 588             log.fine(&quot;setBackgroundColor: &quot; + backgroundColor);
 589             if (isDisposed) {
 590                 log.fine(&quot;setBackgroundColor() request for a disposed web page.&quot;);
 591                 return;
 592             }
 593             if (!frames.contains(frameID)) {
 594                 return;
 595             }
 596             twkSetBackgroundColor(frameID, backgroundColor);
 597 
 598         } finally {
 599             unlockPage();
 600         }
 601     }
 602 
 603     public void setBackgroundColor(int backgroundColor) {
 604         lockPage();
 605         try {
 606             log.fine(&quot;setBackgroundColor: &quot; + backgroundColor +
 607                    &quot; for all frames&quot;);
 608             if (isDisposed) {
 609                 log.fine(&quot;setBackgroundColor() request for a disposed web page.&quot;);
 610                 return;
 611             }
 612 
 613             for (long frameID: frames) {
 614                 twkSetBackgroundColor(frameID, backgroundColor);
 615             }
 616 
 617         } finally {
 618             unlockPage();
 619         }
 620     }
 621 
 622     /*
 623      * Executed on the Event Thread.
 624      */
 625     public void updateContent(WCRectangle toPaint) {
 626         lockPage();
 627         try {
 628             ++updateContentCycleID;
 629 
 630             paintLog.finest(&quot;toPaint: {0}&quot;, toPaint);
 631             if (isDisposed) {
 632                 paintLog.fine(&quot;updateContent() request for a disposed web page.&quot;);
 633                 return;
 634             }
 635             updateDirty(toPaint);
 636 
 637         } finally {
 638             unlockPage();
 639         }
 640     }
 641 
 642     public int getUpdateContentCycleID() {
 643         return updateContentCycleID;
 644     }
 645 
 646     public boolean isRepaintPending() {
 647         lockPage();
 648         try {
 649             synchronized (frameQueue) {
 650                 return !frameQueue.isEmpty();
 651             }
 652         } finally {
 653             unlockPage();
 654         }
 655     }
 656 
 657     /*
 658      * Executed on printing thread.
 659      */
 660     public void print(WCGraphicsContext gc,
 661             final int x, final int y, final int w, final int h)
 662     {
 663         lockPage();
 664         try {
 665             final WCRenderQueue rq = WCGraphicsManager.getGraphicsManager().
 666                     createRenderQueue(new WCRectangle(x, y, w, h), true);
 667             FutureTask&lt;Void&gt; f = new FutureTask&lt;Void&gt;(() -&gt; {
 668                 twkUpdateContent(getPage(), rq, x, y, w, h);
 669             }, null);
 670             Invoker.getInvoker().invokeOnEventThread(f);
 671 
 672             try {
 673                 // block until job is complete
 674                 f.get();
 675             } catch (ExecutionException ex) {
 676                 throw new AssertionError(ex);
 677             } catch (InterruptedException ex) {
 678                 // ignore; recovery is impossible
 679             }
 680 
 681             rq.decode(gc);
 682         } finally {
 683             unlockPage();
 684         }
 685     }
 686 
 687     /*
 688      * Executed on the Render Thread.
 689      */
 690     public void paint(WCGraphicsContext gc, int x, int y, int w, int h) {
 691         lockPage();
 692         try {
 693             if (pageClient != null &amp;&amp; pageClient.isBackBufferSupported()) {
 694                 if (!backbuffer.validate(width, height)) {
 695                     // We need to repaint the whole page on the next turn
 696                     Invoker.getInvoker().invokeOnEventThread(() -&gt; {
 697                         repaintAll();
 698                     });
 699                     return;
 700                 }
 701                 WCGraphicsContext bgc = backbuffer.createGraphics();
 702                 try {
 703                     paint2GC(bgc);
 704                     bgc.flush();
 705                 } finally {
 706                     backbuffer.disposeGraphics(bgc);
 707                 }
 708                 backbuffer.flush(gc, x, y, w, h);
 709             } else {
 710                 paint2GC(gc);
 711             }
 712         } finally {
 713             unlockPage();
 714         }
 715     }
 716 
 717     private void paint2GC(WCGraphicsContext gc) {
 718         paintLog.finest(&quot;Entering&quot;);
 719         gc.setFontSmoothingType(this.fontSmoothingType);
 720 
 721         List&lt;RenderFrame&gt; framesToRender;
 722         synchronized (frameQueue) {
 723             framesToRender = new ArrayList(frameQueue);
 724             frameQueue.clear();
 725         }
 726 
 727         paintLog.finest(&quot;Frames to render: {0}&quot;, framesToRender);
 728 
 729         for (RenderFrame frame : framesToRender) {
 730             paintLog.finest(&quot;Rendering: {0}&quot;, frame);
 731             for (WCRenderQueue rq : frame.getRQList()) {
 732                 gc.saveState();
 733                 if (rq.getClip() != null) {
 734                     gc.setClip(rq.getClip());
 735                 }
 736                 rq.decode(gc);
 737                 gc.restoreState();
 738             }
 739         }
 740         paintLog.finest(&quot;Exiting&quot;);
 741     }
 742 
 743     /*
 744      * Executed on the Event Thread.
 745      */
 746     public void dropRenderFrames() {
 747         lockPage();
 748         try {
 749             currentFrame.drop();
 750             synchronized (frameQueue) {
 751                 for (RenderFrame frame = frameQueue.poll(); frame != null; frame = frameQueue.poll()) {
 752                     frame.drop();
 753                 }
 754             }
 755         } finally {
 756             unlockPage();
 757         }
 758     }
 759 
 760     public void dispatchFocusEvent(WCFocusEvent fe) {
 761         lockPage();
 762         try {
 763             log.finest(&quot;dispatchFocusEvent: &quot; + fe);
 764             if (isDisposed) {
 765                 log.fine(&quot;Focus event for a disposed web page.&quot;);
 766                 return;
 767             }
 768             twkProcessFocusEvent(getPage(), fe.getID(), fe.getDirection());
 769 
 770         } finally {
 771             unlockPage();
 772         }
 773     }
 774 
 775     public boolean dispatchKeyEvent(WCKeyEvent ke) {
 776         lockPage();
 777         try {
 778             log.finest(&quot;dispatchKeyEvent: &quot; + ke);
 779             if (isDisposed) {
 780                 log.fine(&quot;Key event for a disposed web page.&quot;);
 781                 return false;
 782             }
 783             if (WCKeyEvent.filterEvent(ke)) {
 784                 log.finest(&quot;filtered&quot;);
 785                 return false;
 786             }
 787             return twkProcessKeyEvent(getPage(), ke.getType(), ke.getText(),
 788                                       ke.getKeyIdentifier(),
 789                                       ke.getWindowsVirtualKeyCode(),
 790                                       ke.isShiftDown(), ke.isCtrlDown(),
 791                                       ke.isAltDown(), ke.isMetaDown(), ke.getWhen() / 1000.0);
 792         } finally {
 793             unlockPage();
 794         }
 795     }
 796 
 797     public boolean dispatchMouseEvent(WCMouseEvent me) {
 798         lockPage();
 799         try {
 800             log.finest(&quot;dispatchMouseEvent: &quot; + me.getX() + &quot;,&quot; + me.getY());
 801             if (isDisposed) {
 802                 log.fine(&quot;Mouse event for a disposed web page.&quot;);
 803                 return false;
 804             }
 805 
 806             return !isDragConfirmed() //When Webkit informes FX about drag start, it waits
 807                                       //for system DnD loop and not intereasted in
 808                                       //intermediate mouse events that can change text selection.
 809                 &amp;&amp; twkProcessMouseEvent(getPage(), me.getID(),
 810                                         me.getButton(), me.getClickCount(),
 811                                         me.getX(), me.getY(), me.getScreenX(), me.getScreenY(),
 812                                         me.isShiftDown(), me.isControlDown(), me.isAltDown(), me.isMetaDown(), me.isPopupTrigger(),
 813                                         me.getWhen() / 1000.0);
 814         } finally {
 815             unlockPage();
 816         }
 817     }
 818 
 819     public boolean dispatchMouseWheelEvent(WCMouseWheelEvent me) {
 820         lockPage();
 821         try {
 822             log.finest(&quot;dispatchMouseWheelEvent: &quot; + me);
 823             if (isDisposed) {
 824                 log.fine(&quot;MouseWheel event for a disposed web page.&quot;);
 825                 return false;
 826             }
 827             return twkProcessMouseWheelEvent(getPage(),
 828                                              me.getX(), me.getY(), me.getScreenX(), me.getScreenY(),
 829                                              me.getDeltaX(), me.getDeltaY(),
 830                                              me.isShiftDown(), me.isControlDown(), me.isAltDown(), me.isMetaDown(),
 831                                              me.getWhen() / 1000.0);
 832         } finally {
 833             unlockPage();
 834         }
 835     }
 836 
 837     public boolean dispatchInputMethodEvent(WCInputMethodEvent ie) {
 838         lockPage();
 839         try {
 840             log.finest(&quot;dispatchInputMethodEvent: &quot; + ie);
 841             if (isDisposed) {
 842                 log.fine(&quot;InputMethod event for a disposed web page.&quot;);
 843                 return false;
 844             }
 845             switch (ie.getID()) {
 846                 case WCInputMethodEvent.INPUT_METHOD_TEXT_CHANGED:
 847                     return twkProcessInputTextChange(getPage(),
 848                                                      ie.getComposed(), ie.getCommitted(),
 849                                                      ie.getAttributes(), ie.getCaretPosition());
 850 
 851                 case WCInputMethodEvent.CARET_POSITION_CHANGED:
 852                     return twkProcessCaretPositionChange(getPage(),
 853                                                          ie.getCaretPosition());
 854             }
 855             return false;
 856 
 857         } finally {
 858             unlockPage();
 859         }
 860     }
 861 
 862     public final static int DND_DST_ENTER = 0;
 863     public final static int DND_DST_OVER = 1;
 864     public final static int DND_DST_CHANGE = 2;
 865     public final static int DND_DST_EXIT = 3;
 866     public final static int DND_DST_DROP = 4;
 867 
 868     public final static int DND_SRC_ENTER = 100;
 869     public final static int DND_SRC_OVER = 101;
 870     public final static int DND_SRC_CHANGE = 102;
 871     public final static int DND_SRC_EXIT = 103;
 872     public final static int DND_SRC_DROP = 104;
 873 
 874     public int dispatchDragOperation(
 875             int commandId,
 876             String[] mimeTypes, String[] values,
 877             int x, int y,
 878             int screenX, int screenY,
 879             int dndActionId)
 880     {
 881         lockPage();
 882         try {
 883             log.finest(&quot;dispatchDragOperation: &quot; + x + &quot;,&quot; + y
 884                     + &quot; dndCommand:&quot; + commandId
 885                     + &quot; dndAction&quot; + dndActionId);
 886             if (isDisposed) {
 887                 log.fine(&quot;DnD event for a disposed web page.&quot;);
 888                 return 0;
 889             }
 890             return twkProcessDrag(getPage(),
 891                     commandId,
 892                     mimeTypes, values,
 893                     x, y,
 894                     screenX, screenY,
 895                     dndActionId);
 896         } finally {
 897             unlockPage();
 898         }
 899     }
 900 
 901     public void confirmStartDrag() {
 902         if (uiClient != null)
 903             uiClient.confirmStartDrag();
 904     }
 905 
 906     public boolean isDragConfirmed(){
 907         return (uiClient != null)
 908             ? uiClient.isDragConfirmed()
 909             : false;
 910     }
 911 
 912     // *************************************************************************
 913     // Input methods
 914     // *************************************************************************
 915 
 916     public int[] getClientTextLocation(int index) {
 917         lockPage();
 918         try {
 919             if (isDisposed) {
 920                 log.fine(&quot;getClientTextLocation() request for a disposed web page.&quot;);
 921                 return new int[] { 0, 0, 0, 0 };
 922             }
 923             Invoker.getInvoker().checkEventThread();
 924             return twkGetTextLocation(getPage(), index);
 925 
 926         } finally {
 927             unlockPage();
 928         }
 929     }
 930 
 931     public int getClientLocationOffset(int x, int y) {
 932         lockPage();
 933         try {
 934             if (isDisposed) {
 935                 log.fine(&quot;getClientLocationOffset() request for a disposed web page.&quot;);
 936                 return 0;
 937             }
 938             Invoker.getInvoker().checkEventThread();
 939             return twkGetInsertPositionOffset(getPage());
 940 
 941         } finally {
 942             unlockPage();
 943         }
 944     }
 945 
 946     public int getClientInsertPositionOffset() {
 947         lockPage();
 948         try {
 949             if (isDisposed) {
 950                 log.fine(&quot;getClientInsertPositionOffset() request for a disposed web page.&quot;);
 951                 return 0;
 952             }
 953             return twkGetInsertPositionOffset(getPage());
 954 
 955         } finally {
 956             unlockPage();
 957         }
 958     }
 959 
 960     public int getClientCommittedTextLength() {
 961         lockPage();
 962         try {
 963             if (isDisposed) {
 964                 log.fine(&quot;getClientCommittedTextOffset() request for a disposed web page.&quot;);
 965                 return 0;
 966             }
 967             return twkGetCommittedTextLength(getPage());
 968 
 969         } finally {
 970             unlockPage();
 971         }
 972     }
 973 
 974     public String getClientCommittedText() {
 975         lockPage();
 976         try {
 977             if (isDisposed) {
 978                 log.fine(&quot;getClientCommittedText() request for a disposed web page.&quot;);
 979                 return &quot;&quot;;
 980             }
 981             return twkGetCommittedText(getPage());
 982 
 983         } finally {
 984             unlockPage();
 985         }
 986     }
 987 
 988     public String getClientSelectedText() {
 989         lockPage();
 990         try {
 991             if (isDisposed) {
 992                 log.fine(&quot;getClientSelectedText() request for a disposed web page.&quot;);
 993                 return &quot;&quot;;
 994             }
 995             final String selectedText = twkGetSelectedText(getPage());
 996             return selectedText != null ? selectedText : &quot;&quot;;
 997 
 998         } finally {
 999             unlockPage();
1000         }
1001     }
1002 
1003     // *************************************************************************
1004     // Browser API
1005     // *************************************************************************
1006 
1007     public void dispose() {
1008         lockPage();
1009         try {
1010             log.finer(&quot;dispose&quot;);
1011 
1012             stop();
1013             dropRenderFrames();
1014             isDisposed = true;
1015 
1016             twkDestroyPage(pPage);
1017             pPage = 0;
1018 
1019             for (long frameID : frames) {
1020                 log.fine(&quot;Undestroyed frame view: &quot; + frameID);
1021             }
1022             frames.clear();
1023 
1024             if (backbuffer != null) {
1025                 backbuffer.deref();
1026                 backbuffer = null;
1027             }
1028         } finally {
1029             unlockPage();
1030         }
1031     }
1032 
1033     public String getName(long frameID) {
1034         lockPage();
1035         try {
1036             log.fine(&quot;Get Name: frame = &quot; + frameID);
1037             if (isDisposed) {
1038                 log.fine(&quot;getName() request for a disposed web page.&quot;);
1039                 return null;
1040             }
1041             if (!frames.contains(frameID)) {
1042                 return null;
1043             }
1044             return twkGetName(frameID);
1045 
1046         } finally {
1047             unlockPage();
1048         }
1049     }
1050 
1051     public String getURL(long frameID) {
1052         lockPage();
1053         try {
1054             log.fine(&quot;Get URL: frame = &quot; + frameID);
1055             if (isDisposed) {
1056                 log.fine(&quot;getURL() request for a disposed web page.&quot;);
1057                 return null;
1058             }
1059             if (!frames.contains(frameID)) {
1060                 return null;
1061             }
1062             return twkGetURL(frameID);
1063 
1064         } finally {
1065             unlockPage();
1066         }
1067     }
1068 
1069     public String getEncoding() {
1070         lockPage();
1071         try {
1072             log.fine(&quot;Get encoding&quot;);
1073             if (isDisposed) {
1074                 log.fine(&quot;getEncoding() request for a disposed web page.&quot;);
1075                 return null;
1076             }
1077             return twkGetEncoding(getPage());
1078 
1079         } finally {
1080             unlockPage();
1081         }
1082     }
1083 
1084     public void setEncoding(String encoding) {
1085         lockPage();
1086         try {
1087             log.fine(&quot;Set encoding: encoding = &quot; + encoding);
1088             if (isDisposed) {
1089                 log.fine(&quot;setEncoding() request for a disposed web page.&quot;);
1090                 return;
1091             }
1092             if (encoding != null &amp;&amp; !encoding.isEmpty()) {
1093                 twkSetEncoding(getPage(), encoding);
1094             }
1095 
1096         } finally {
1097             unlockPage();
1098         }
1099     }
1100 
1101     // DRT support
1102     public String getInnerText(long frameID) {
1103         lockPage();
1104         try {
1105             log.fine(&quot;Get inner text: frame = &quot; + frameID);
1106             if (isDisposed) {
1107                 log.fine(&quot;getInnerText() request for a disposed web page.&quot;);
1108                 return null;
1109             }
1110             if (!frames.contains(frameID)) {
1111                 return null;
1112             }
1113             return twkGetInnerText(frameID);
1114 
1115         } finally {
1116             unlockPage();
1117         }
1118     }
1119 
1120     // DRT support
1121     public String getRenderTree(long frameID) {
1122         lockPage();
1123         try {
1124             log.fine(&quot;Get render tree: frame = &quot; + frameID);
1125             if (isDisposed) {
1126                 log.fine(&quot;getRenderTree() request for a disposed web page.&quot;);
1127                 return null;
1128             }
1129             if (!frames.contains(frameID)) {
1130                 return null;
1131             }
1132             return twkGetRenderTree(frameID);
1133 
1134         } finally {
1135             unlockPage();
1136         }
1137     }
1138 
1139     // DRT support
1140     public int getUnloadEventListenersCount(long frameID) {
1141         lockPage();
1142         try {
1143             log.fine(&quot;frame: &quot; + frameID);
1144             if (isDisposed) {
1145                 log.fine(&quot;request for a disposed web page.&quot;);
1146                 return 0;
1147             }
1148             if (!frames.contains(frameID)) {
1149                 return 0;
1150             }
1151             return twkGetUnloadEventListenersCount(frameID);
1152 
1153         } finally {
1154             unlockPage();
1155         }
1156     }
1157 
1158     public String getContentType(long frameID) {
1159         lockPage();
1160         try {
1161             log.fine(&quot;Get content type: frame = &quot; + frameID);
1162             if (isDisposed) {
1163                 log.fine(&quot;getContentType() request for a disposed web page.&quot;);
1164                 return null;
1165             }
1166             if (!frames.contains(frameID)) {
1167                 return null;
1168             }
1169             return twkGetContentType(frameID);
1170 
1171         } finally {
1172             unlockPage();
1173         }
1174     }
1175 
1176     public String getTitle(long frameID) {
1177         lockPage();
1178         try {
1179             log.fine(&quot;Get title: frame = &quot; + frameID);
1180             if (isDisposed) {
1181                 log.fine(&quot;getTitle() request for a disposed web page.&quot;);
1182                 return null;
1183             }
1184             if (!frames.contains(frameID)) {
1185                 return null;
1186             }
1187             return twkGetTitle(frameID);
1188 
1189         } finally {
1190             unlockPage();
1191         }
1192     }
1193 
1194     public WCImage getIcon(long frameID) {
1195         lockPage();
1196         try {
1197             log.fine(&quot;Get icon: frame = &quot; + frameID);
1198             if (isDisposed) {
1199                 log.fine(&quot;getIcon() request for a disposed web page.&quot;);
1200                 return null;
1201             }
1202             if (!frames.contains(frameID)) {
1203                 return null;
1204             }
1205             String iconURL = twkGetIconURL(frameID);
1206             // do we need any cache for icons here?
1207             if (iconURL != null &amp;&amp; !iconURL.isEmpty()) {
1208                 return WCGraphicsManager.getGraphicsManager().getIconImage(iconURL);
1209             }
1210             return null;
1211 
1212         } finally {
1213             unlockPage();
1214         }
1215     }
1216 
1217     public void open(final long frameID, final String url) {
1218         lockPage();
1219         try {
1220             log.fine(&quot;Open URL: &quot; + url);
1221             if (isDisposed) {
1222                 log.fine(&quot;open() request for a disposed web page.&quot;);
1223                 return;
1224             }
1225             if (!frames.contains(frameID)) {
1226                 return;
1227             }
1228             if (twkIsLoading(frameID)) {
1229                 Invoker.getInvoker().postOnEventThread(() -&gt; {
1230                     // Postpone new load request while webkit is
1231                     // about to commit the DocumentLoader from
1232                     // provisional state to committed state
1233                     twkOpen(frameID, url);
1234                 });
1235             } else {
1236                 twkOpen(frameID, url);
1237             }
1238         } finally {
1239             unlockPage();
1240         }
1241     }
1242 
1243     public void load(final long frameID, final String text, final String contentType) {
1244         lockPage();
1245         try {
1246             log.fine(&quot;Load text: &quot; + text);
1247             if (text == null) {
1248                 return;
1249             }
1250             if (isDisposed) {
1251                 log.fine(&quot;load() request for a disposed web page.&quot;);
1252                 return;
1253             }
1254             if (!frames.contains(frameID)) {
1255                 return;
1256             }
1257             // TODO: handle contentType
1258             if (twkIsLoading(frameID)) {
1259                 // Postpone loading new content while webkit is
1260                 // about to commit the DocumentLoader from
1261                 // provisional state to committed state
1262                 Invoker.getInvoker().postOnEventThread(() -&gt; {
1263                     twkLoad(frameID, text, contentType);
1264                 });
1265             } else {
1266                 twkLoad(frameID, text, contentType);
1267             }
1268         } finally {
1269             unlockPage();
1270         }
1271     }
1272 
1273     public void stop(final long frameID) {
1274         lockPage();
1275         try {
1276             log.fine(&quot;Stop loading: frame = &quot; + frameID);
1277 
1278             String url;
1279             String contentType;
1280             if (isDisposed) {
1281                 log.fine(&quot;cancel() request for a disposed web page.&quot;);
1282                 return;
1283             }
1284             if (!frames.contains(frameID)) {
1285                 return;
1286             }
1287             url = twkGetURL(frameID);
1288             contentType = twkGetContentType(frameID);
1289             twkStop(frameID);
1290             // WebKit doesn&#39;t send any notifications about loading stopped,
1291             // so sending it here
1292             fireLoadEvent(frameID, LoadListenerClient.LOAD_STOPPED, url, contentType, 1.0, 0);
1293 
1294         } finally {
1295             unlockPage();
1296         }
1297     }
1298 
1299     // stops all loading synchronously
1300     public void stop() {
1301         lockPage();
1302         try {
1303             log.fine(&quot;Stop loading sync&quot;);
1304             if (isDisposed) {
1305                 log.fine(&quot;stopAll() request for a disposed web page.&quot;);
1306                 return;
1307             }
1308             twkStopAll(getPage());
1309 
1310         } finally {
1311             unlockPage();
1312         }
1313     }
1314 
1315     public void refresh(final long frameID) {
1316         lockPage();
1317         try {
1318             log.fine(&quot;Refresh: frame = &quot; + frameID);
1319             if (isDisposed) {
1320                 log.fine(&quot;refresh() request for a disposed web page.&quot;);
1321                 return;
1322             }
1323             if (!frames.contains(frameID)) {
1324                 return;
1325             }
1326             twkRefresh(frameID);
1327 
1328         } finally {
1329             unlockPage();
1330         }
1331     }
1332 
1333     public BackForwardList createBackForwardList() {
1334         return new BackForwardList(this);
1335     }
1336 
1337     public boolean goBack() {
1338         lockPage();
1339         try {
1340             log.fine(&quot;Go back&quot;);
1341             if (isDisposed) {
1342                 log.fine(&quot;goBack() request for a disposed web page.&quot;);
1343                 return false;
1344             }
1345             return twkGoBackForward(getPage(), -1);
1346 
1347         } finally {
1348             unlockPage();
1349         }
1350     }
1351 
1352     public boolean goForward() {
1353         lockPage();
1354         try {
1355             log.fine(&quot;Go forward&quot;);
1356             if (isDisposed) {
1357                 log.fine(&quot;goForward() request for a disposed web page.&quot;);
1358                 return false;
1359             }
1360             return twkGoBackForward(getPage(), 1);
1361 
1362         } finally {
1363             unlockPage();
1364         }
1365     }
1366 
1367     public boolean copy() {
1368         lockPage();
1369         try {
1370             log.fine(&quot;Copy&quot;);
1371             if (isDisposed) {
1372                 log.fine(&quot;copy() request for a disposed web page.&quot;);
1373                 return false;
1374             }
1375             long frameID = getMainFrame();
1376             if (!frames.contains(frameID)) {
1377                 return false;
1378             }
1379             return twkCopy(frameID);
1380 
1381         } finally {
1382             unlockPage();
1383         }
1384     }
1385 
1386     // Find in page
1387     public boolean find(String stringToFind, boolean forward, boolean wrap, boolean matchCase) {
1388         lockPage();
1389         try {
1390             log.fine(&quot;Find in page: stringToFind = &quot; + stringToFind + &quot;, &quot; +
1391                     (forward ? &quot;forward&quot; : &quot;backward&quot;) + (wrap ? &quot;, wrap&quot; : &quot;&quot;) + (matchCase ? &quot;, matchCase&quot; : &quot;&quot;));
1392             if (isDisposed) {
1393                 log.fine(&quot;find() request for a disposed web page.&quot;);
1394                 return false;
1395             }
1396             return twkFindInPage(getPage(), stringToFind, forward, wrap, matchCase);
1397 
1398         } finally {
1399             unlockPage();
1400         }
1401     }
1402 
1403     // Find in frame
1404     public boolean find(long frameID,
1405         String stringToFind, boolean forward, boolean wrap, boolean matchCase)
1406     {
1407         lockPage();
1408         try {
1409             log.fine(&quot;Find in frame: stringToFind = &quot; + stringToFind + &quot;, &quot; +
1410                     (forward ? &quot;forward&quot; : &quot;backward&quot;) + (wrap ? &quot;, wrap&quot; : &quot;&quot;) + (matchCase ? &quot;, matchCase&quot; : &quot;&quot;));
1411             if (isDisposed) {
1412                 log.fine(&quot;find() request for a disposed web page.&quot;);
1413                 return false;
1414             }
1415             if (!frames.contains(frameID)) {
1416                 return false;
1417             }
1418             return twkFindInFrame(frameID, stringToFind, forward, wrap, matchCase);
1419 
1420         } finally {
1421             unlockPage();
1422         }
1423     }
1424 
1425     public void overridePreference(String key, String value) {
1426         lockPage();
1427         try {
1428             twkOverridePreference(getPage(), key, value);
1429         } finally {
1430             unlockPage();
1431         }
1432     }
1433 
1434     public void resetToConsistentStateBeforeTesting() {
1435         lockPage();
1436         try {
1437             twkResetToConsistentStateBeforeTesting(getPage());
1438         } finally {
1439             unlockPage();
1440         }
1441     }
1442 
1443     public float getZoomFactor(boolean textOnly) {
1444         lockPage();
1445         try {
1446             log.fine(&quot;Get zoom factor, textOnly=&quot; + textOnly);
1447             if (isDisposed) {
1448                 log.fine(&quot;getZoomFactor() request for a disposed web page.&quot;);
1449                 return 1.0f;
1450             }
1451             long frameID = getMainFrame();
1452             if (!frames.contains(frameID)) {
1453                 return 1.0f;
1454             }
1455             return twkGetZoomFactor(frameID, textOnly);
1456         } finally {
1457             unlockPage();
1458         }
1459     }
1460 
1461     public void setZoomFactor(float zoomFactor, boolean textOnly) {
1462         lockPage();
1463         try {
1464             log.fine(String.format(&quot;Set zoom factor %.2f, textOnly=%b&quot;, zoomFactor, textOnly));
1465             if (isDisposed) {
1466                 log.fine(&quot;setZoomFactor() request for a disposed web page.&quot;);
1467                 return;
1468             }
1469             long frameID = getMainFrame();
1470             if ((frameID == 0) || !frames.contains(frameID)) {
1471                 return;
1472             }
1473             twkSetZoomFactor(frameID, zoomFactor, textOnly);
1474         } finally {
1475             unlockPage();
1476         }
1477     }
1478 
1479     public void setFontSmoothingType(int fontSmoothingType) {
1480         this.fontSmoothingType = fontSmoothingType;
1481         repaintAll();
1482     }
1483 
1484     // DRT support
1485     public void reset(long frameID) {
1486         lockPage();
1487         try {
1488             log.fine(&quot;Reset: frame = &quot; + frameID);
1489             if (isDisposed) {
1490                 log.fine(&quot;reset() request for a disposed web page.&quot;);
1491                 return;
1492             }
1493             if ((frameID == 0) || !frames.contains(frameID)) {
1494                 return;
1495             }
1496             twkReset(frameID);
1497 
1498         } finally {
1499             unlockPage();
1500         }
1501     }
1502 
1503     public Object executeScript(long frameID, String script) throws JSException {
1504         lockPage();
1505         try {
1506             log.fine(&quot;execute script: \&quot;&quot; + script + &quot;\&quot; in frame = &quot; + frameID);
1507             if (isDisposed) {
1508                 log.fine(&quot;executeScript() request for a disposed web page.&quot;);
1509                 return null;
1510             }
1511             if ((frameID == 0) || !frames.contains(frameID)) {
1512                 return null;
1513             }
1514             return twkExecuteScript(frameID, script);
1515 
1516         } finally {
1517             unlockPage();
1518         }
1519     }
1520 
1521     public long getMainFrame() {
1522         lockPage();
1523         try {
1524             log.finer(&quot;getMainFrame: page = &quot; + pPage);
1525             if (isDisposed) {
1526                 log.fine(&quot;getMainFrame() request for a disposed web page.&quot;);
1527                 return 0L;
1528             }
1529             long mainFrameID = twkGetMainFrame(getPage());
1530             log.finer(&quot;Main frame = &quot; + mainFrameID);
1531             frames.add(mainFrameID);
1532             return mainFrameID;
1533         } finally {
1534             unlockPage();
1535         }
1536     }
1537 
1538     public long getParentFrame(long childID) {
1539         lockPage();
1540         try {
1541             log.fine(&quot;getParentFrame: child = &quot; + childID);
1542             if (isDisposed) {
1543                 log.fine(&quot;getParentFrame() request for a disposed web page.&quot;);
1544                 return 0L;
1545             }
1546             if (!frames.contains(childID)) {
1547                 return 0L;
1548             }
1549             return twkGetParentFrame(childID);
1550         } finally {
1551             unlockPage();
1552         }
1553     }
1554 
1555     public List&lt;Long&gt; getChildFrames(long parentID) {
1556         lockPage();
1557         try {
1558             log.fine(&quot;getChildFrames: parent = &quot; + parentID);
1559             if (isDisposed) {
1560                 log.fine(&quot;getChildFrames() request for a disposed web page.&quot;);
1561                 return null;
1562             }
1563             if (!frames.contains(parentID)) {
1564                 return null;
1565             }
1566             long[] children = twkGetChildFrames(parentID);
1567             List&lt;Long&gt; childrenList = new LinkedList&lt;Long&gt;();
1568             for (long child : children) {
1569                 childrenList.add(Long.valueOf(child));
1570             }
1571             return childrenList;
1572         } finally {
1573             unlockPage();
1574         }
1575     }
1576 
1577     public WCRectangle getVisibleRect(long frameID) {
1578         lockPage();
1579         try {
1580             if (!frames.contains(frameID)) {
1581                 return null;
1582             }
1583             int[] arr = twkGetVisibleRect(frameID);
1584             if (arr != null) {
1585                 return new WCRectangle(arr[0], arr[1], arr[2], arr[3]);
1586             }
1587             return null;
1588         } finally {
1589             unlockPage();
1590         }
1591     }
1592 
1593     public void scrollToPosition(long frameID, WCPoint p) {
1594         lockPage();
1595         try {
1596             if (!frames.contains(frameID)) {
1597                 return;
1598             }
1599             twkScrollToPosition(frameID, p.getIntX(), p.getIntY());
1600         } finally {
1601             unlockPage();
1602         }
1603     }
1604 
1605     public WCSize getContentSize(long frameID) {
1606         lockPage();
1607         try {
1608             if (!frames.contains(frameID)) {
1609                 return null;
1610             }
1611             int[] arr = twkGetContentSize(frameID);
1612             if (arr != null) {
1613                 return new WCSize(arr[0], arr[1]);
1614             }
1615             return null;
1616         } finally {
1617             unlockPage();
1618         }
1619     }
1620 
1621     // ---- DOM ---- //
1622 
1623     public Document getDocument(long frameID) {
1624         lockPage();
1625         try {
1626             log.fine(&quot;getDocument&quot;);
1627             if (isDisposed) {
1628                 log.fine(&quot;getDocument() request for a disposed web page.&quot;);
1629                 return null;
1630             }
1631 
1632             if (!frames.contains(frameID)) {
1633                 return null;
1634             }
1635             return twkGetDocument(frameID);
1636         } finally {
1637             unlockPage();
1638         }
1639     }
1640 
1641     public Element getOwnerElement(long frameID) {
1642         lockPage();
1643         try {
1644             log.fine(&quot;getOwnerElement&quot;);
1645             if (isDisposed) {
1646                 log.fine(&quot;getOwnerElement() request for a disposed web page.&quot;);
1647                 return null;
1648             }
1649 
1650             if (!frames.contains(frameID)) {
1651                 return null;
1652             }
1653             return twkGetOwnerElement(frameID);
1654         } finally {
1655             unlockPage();
1656         }
1657     }
1658 
1659    // ---- EDITING SUPPORT ---- //
1660 
1661     public boolean executeCommand(String command, String value) {
1662         lockPage();
1663         try {
1664             if (log.isLoggable(Level.FINE)) {
1665                 log.fine(&quot;command: [{0}], value: [{1}]&quot;,
1666                         new Object[] {command, value});
1667             }
1668             if (isDisposed) {
1669                 log.fine(&quot;Web page is already disposed&quot;);
1670                 return false;
1671             }
1672 
1673             boolean result = twkExecuteCommand(getPage(), command, value);
1674 
1675             log.fine(&quot;result: [{0}]&quot;, result);
1676             return result;
1677         } finally {
1678             unlockPage();
1679         }
1680     }
1681 
1682     public boolean queryCommandEnabled(String command) {
1683         lockPage();
1684         try {
1685             log.fine(&quot;command: [{0}]&quot;, command);
1686             if (isDisposed) {
1687                 log.fine(&quot;Web page is already disposed&quot;);
1688                 return false;
1689             }
1690 
1691             boolean result = twkQueryCommandEnabled(getPage(), command);
1692 
1693             log.fine(&quot;result: [{0}]&quot;, result);
1694             return result;
1695         } finally {
1696             unlockPage();
1697         }
1698     }
1699 
1700     public boolean queryCommandState(String command) {
1701         lockPage();
1702         try {
1703             log.fine(&quot;command: [{0}]&quot;, command);
1704             if (isDisposed) {
1705                 log.fine(&quot;Web page is already disposed&quot;);
1706                 return false;
1707             }
1708 
1709             boolean result = twkQueryCommandState(getPage(), command);
1710 
1711             log.fine(&quot;result: [{0}]&quot;, result);
1712             return result;
1713         } finally {
1714             unlockPage();
1715         }
1716     }
1717 
1718     public String queryCommandValue(String command) {
1719         lockPage();
1720         try {
1721             log.fine(&quot;command: [{0}]&quot;, command);
1722             if (isDisposed) {
1723                 log.fine(&quot;Web page is already disposed&quot;);
1724                 return null;
1725             }
1726 
1727             String result = twkQueryCommandValue(getPage(), command);
1728 
1729             log.fine(&quot;result: [{0}]&quot;, result);
1730             return result;
1731         } finally {
1732             unlockPage();
1733         }
1734     }
1735 
1736     public boolean isEditable() {
1737         lockPage();
1738         try {
1739             log.fine(&quot;isEditable&quot;);
1740             if (isDisposed) {
1741                 log.fine(&quot;isEditable() request for a disposed web page.&quot;);
1742                 return false;
1743             }
1744 
1745             return twkIsEditable(getPage());
1746         } finally {
1747             unlockPage();
1748         }
1749     }
1750 
1751     public void setEditable(boolean editable) {
1752         lockPage();
1753         try {
1754             log.fine(&quot;setEditable&quot;);
1755             if (isDisposed) {
1756                 log.fine(&quot;setEditable() request for a disposed web page.&quot;);
1757                 return;
1758             }
1759 
1760             twkSetEditable(getPage(), editable);
1761         } finally {
1762             unlockPage();
1763         }
1764     }
1765 
1766     /**
1767      * @return HTML content of the frame,
1768      *         or null if frame document is absent or non-HTML.
1769      */
1770     public String getHtml(long frameID) {
1771         lockPage();
1772         try {
1773             log.fine(&quot;getHtml&quot;);
1774             if (isDisposed) {
1775                 log.fine(&quot;getHtml() request for a disposed web page.&quot;);
1776                 return null;
1777             }
1778             if (!frames.contains(frameID)) {
1779                 return null;
1780             }
1781             return twkGetHtml(frameID);
1782         } finally {
1783             unlockPage();
1784         }
1785     }
1786 
1787     // ---- PRINTING SUPPORT ---- //
1788 
1789     public int beginPrinting(float width, float height) {
1790         lockPage();
1791         try {
1792             if (isDisposed) {
1793                 log.warning(&quot;beginPrinting() called for a disposed web page.&quot;);
1794                 return 0;
1795             }
1796             AtomicReference&lt;Integer&gt; retVal = new AtomicReference&lt;&gt;(0);
1797             final CountDownLatch l = new CountDownLatch(1);
1798             Invoker.getInvoker().invokeOnEventThread(() -&gt; {
1799                 try {
1800                     int nPages = twkBeginPrinting(getPage(), width, height);
1801                     retVal.set(nPages);
1802                 } finally {
1803                     l.countDown();
1804                 }
1805             });
1806 
1807             try {
1808                 l.await();
1809             } catch (InterruptedException e) {
1810                 throw new RuntimeException(e);
1811             }
1812             return retVal.get();
1813         } finally {
1814             unlockPage();
1815         }
1816     }
1817 
1818     public void endPrinting() {
1819         lockPage();
1820         try {
1821             if (isDisposed) {
1822                 log.warning(&quot;endPrinting() called for a disposed web page.&quot;);
1823                 return;
1824             }
1825             final CountDownLatch l = new CountDownLatch(1);
1826             Invoker.getInvoker().invokeOnEventThread(() -&gt; {
1827                 try {
1828                     twkEndPrinting(getPage());
1829                 } finally {
1830                     l.countDown();
1831                 }
1832             });
1833 
1834             try {
1835                 l.await();
1836             } catch (InterruptedException e) {
1837                 throw new RuntimeException(e);
1838             }
1839         } finally {
1840             unlockPage();
1841         }
1842     }
1843 
1844     public void print(final WCGraphicsContext gc, final int pageNumber, final float width) {
1845         lockPage();
1846         try {
1847             if (isDisposed) {
1848                 log.warning(&quot;print() called for a disposed web page.&quot;);
1849                 return;
1850             }
1851             final WCRenderQueue rq = WCGraphicsManager.getGraphicsManager().
1852                     createRenderQueue(null, true);
1853             final CountDownLatch l = new CountDownLatch(1);
1854             Invoker.getInvoker().invokeOnEventThread(() -&gt; {
1855                 try {
1856                     twkPrint(getPage(), rq, pageNumber, width);
1857                 } finally {
1858                     l.countDown();
1859                 }
1860             });
1861 
1862             try {
1863                 l.await();
1864             } catch (InterruptedException e) {
1865                 rq.dispose();
1866                 return;
1867             }
1868             rq.decode(gc);
1869         } finally {
1870             unlockPage();
1871         }
1872     }
1873 
1874     public int getPageHeight() {
1875         return getFrameHeight(getMainFrame());
1876     }
1877 
1878     public int getFrameHeight(long frameID) {
1879         lockPage();
1880         try {
1881             log.fine(&quot;Get page height&quot;);
1882             if (isDisposed) {
1883                 log.fine(&quot;getFrameHeight() request for a disposed web page.&quot;);
1884                 return 0;
1885             }
1886             if (!frames.contains(frameID)) {
1887                 return 0;
1888             }
1889             int height = twkGetFrameHeight(frameID);
1890             log.fine(&quot;Height = &quot; + height);
1891             return height;
1892         } finally {
1893             unlockPage();
1894         }
1895     }
1896 
1897     public float adjustFrameHeight(long frameID,
1898                                    float oldTop, float oldBottom, float bottomLimit)
1899     {
1900         lockPage();
1901         try {
1902             log.fine(&quot;Adjust page height&quot;);
1903             if (isDisposed) {
1904                 log.fine(&quot;adjustFrameHeight() request for a disposed web page.&quot;);
1905                 return 0;
1906             }
1907             if (!frames.contains(frameID)) {
1908                 return 0;
1909             }
1910             return twkAdjustFrameHeight(frameID, oldTop, oldBottom, bottomLimit);
1911         } finally {
1912             unlockPage();
1913         }
1914     }
1915 
1916     // ---- SETTINGS ---- //
1917 
1918     /**
1919      * Returns the usePageCache settings field.
1920      * @return {@code true} if this object uses the page cache,
1921      *         {@code false} otherwise.
1922      */
1923     public boolean getUsePageCache() {
1924         lockPage();
1925         try {
1926             return twkGetUsePageCache(getPage());
1927         } finally {
1928             unlockPage();
1929         }
1930     }
1931 
1932     /**
1933      * Sets the usePageCache settings field.
1934      * @param usePageCache {@code true} to use the page cache,
1935      *        {@code false} to not use the page cache.
1936      */
1937     public void setUsePageCache(boolean usePageCache) {
1938         lockPage();
1939         try {
1940             twkSetUsePageCache(getPage(), usePageCache);
1941         } finally {
1942             unlockPage();
1943         }
1944     }
1945 
1946     public boolean getDeveloperExtrasEnabled() {
1947         lockPage();
1948         try {
1949             boolean result = twkGetDeveloperExtrasEnabled(getPage());
1950             log.fine(&quot;Getting developerExtrasEnabled, result: [{0}]&quot;, result);
1951             return result;
1952         } finally {
1953             unlockPage();
1954         }
1955     }
1956 
1957     public void setDeveloperExtrasEnabled(boolean enabled) {
1958         lockPage();
1959         try {
1960             log.fine(&quot;Setting developerExtrasEnabled, value: [{0}]&quot;, enabled);
1961             twkSetDeveloperExtrasEnabled(getPage(), enabled);
1962         } finally {
1963             unlockPage();
1964         }
1965     }
1966 
1967     public boolean isJavaScriptEnabled() {
1968         lockPage();
1969         try {
1970             return twkIsJavaScriptEnabled(getPage());
1971         } finally {
1972             unlockPage();
1973         }
1974     }
1975 
1976     public void setJavaScriptEnabled(boolean enable) {
1977         lockPage();
1978         try {
1979             twkSetJavaScriptEnabled(getPage(), enable);
1980         } finally {
1981             unlockPage();
1982         }
1983     }
1984 
1985     public boolean isContextMenuEnabled() {
1986         lockPage();
1987         try {
1988             return twkIsContextMenuEnabled(getPage());
1989         } finally {
1990             unlockPage();
1991         }
1992     }
1993 
1994     public void setContextMenuEnabled(boolean enable) {
1995         lockPage();
1996         try {
1997             twkSetContextMenuEnabled(getPage(), enable);
1998         } finally {
1999             unlockPage();
2000         }
2001     }
2002 
2003     public void setUserStyleSheetLocation(String url) {
2004         lockPage();
2005         try {
2006             twkSetUserStyleSheetLocation(getPage(), url);
2007         } finally {
2008             unlockPage();
2009         }
2010     }
2011 
2012     public String getUserAgent() {
2013         lockPage();
2014         try {
2015             return twkGetUserAgent(getPage());
2016         } finally {
2017             unlockPage();
2018         }
2019     }
2020 
2021     public void setUserAgent(String userAgent) {
2022         lockPage();
2023         try {
2024             twkSetUserAgent(getPage(), userAgent);
2025         } finally {
2026             unlockPage();
2027         }
2028     }
2029 
2030     public void setLocalStorageDatabasePath(String path) {
2031         lockPage();
2032         try {
2033             twkSetLocalStorageDatabasePath(getPage(), path);
2034         } finally {
2035             unlockPage();
2036         }
2037     }
2038 
2039     public void setLocalStorageEnabled(boolean enabled) {
2040         lockPage();
2041         try {
2042             twkSetLocalStorageEnabled(getPage(), enabled);
2043         } finally {
2044             unlockPage();
2045         }
2046     }
2047 
2048     // ---- INSPECTOR SUPPORT ---- //
2049 
2050     public void connectInspectorFrontend() {
2051         lockPage();
2052         try {
2053             log.fine(&quot;Connecting inspector frontend&quot;);
2054             twkConnectInspectorFrontend(getPage());
2055         } finally {
2056             unlockPage();
2057         }
2058     }
2059 
2060     public void disconnectInspectorFrontend() {
2061         lockPage();
2062         try {
2063             log.fine(&quot;Disconnecting inspector frontend&quot;);
2064             twkDisconnectInspectorFrontend(getPage());
2065         } finally {
2066             unlockPage();
2067         }
2068     }
2069 
2070     public void dispatchInspectorMessageFromFrontend(String message) {
2071         lockPage();
2072         try {
2073             if (log.isLoggable(Level.FINE)) {
2074                 log.fine(&quot;Dispatching inspector message from frontend, &quot;
2075                         + &quot;message: [{0}]&quot;,  message);
2076             }
2077             twkDispatchInspectorMessageFromFrontend(getPage(), message);
2078         } finally {
2079             unlockPage();
2080         }
2081     }
2082 
2083     // *************************************************************************
2084     // Native callbacks
2085     // *************************************************************************
2086 
2087     private void fwkFrameCreated(long frameID) {
2088         log.fine(&quot;Frame created: frame = &quot; + frameID);
2089         if (frames.contains(frameID)) {
2090             log.fine(&quot;Error in fwkFrameCreated: frame is already in frames&quot;);
2091             return;
2092         }
2093         frames.add(frameID);
2094     }
2095 
2096     private void fwkFrameDestroyed(long frameID) {
2097         log.fine(&quot;Frame destroyed: frame = &quot; + frameID);
2098         if (!frames.contains(frameID)) {
2099             log.fine(&quot;Error in fwkFrameDestroyed: frame is not found in frames&quot;);
2100             return;
2101         }
2102         frames.remove(frameID);
2103     }
2104 
2105     private void fwkRepaint(int x, int y, int w, int h) {
2106         lockPage();
2107         try {
2108             if (paintLog.isLoggable(Level.FINEST)) {
2109                 paintLog.finest(&quot;x: {0}, y: {1}, w: {2}, h: {3}&quot;,
2110                         new Object[] {x, y, w, h});
2111             }
2112             addDirtyRect(new WCRectangle(x, y, w, h));
2113         } finally {
2114             unlockPage();
2115         }
2116     }
2117 
2118     private void fwkScroll(int x, int y, int w, int h, int deltaX, int deltaY) {
2119         if (paintLog.isLoggable(Level.FINEST)) {
2120             paintLog.finest(&quot;Scroll: &quot; + x + &quot; &quot; + y + &quot; &quot; + w + &quot; &quot; + h + &quot;  &quot; + deltaX + &quot; &quot; + deltaY);
2121         }
2122         if (pageClient == null || !pageClient.isBackBufferSupported()) {
2123             paintLog.finest(&quot;blit scrolling is switched off&quot;);
2124             // TODO: check why we return void, not boolean (see ScrollView::m_canBlitOnScroll)
2125             return;
2126         }
2127         scroll(x, y, w, h, deltaX, deltaY);
2128     }
2129 
2130     private void fwkTransferFocus(boolean forward) {
2131         log.finer(&quot;Transfer focus &quot; + (forward ? &quot;forward&quot; : &quot;backward&quot;));
2132 
2133         if (pageClient != null) {
2134             pageClient.transferFocus(forward);
2135         }
2136     }
2137 
2138     private void fwkSetCursor(long id) {
2139         log.finer(&quot;Set cursor: &quot; + id);
2140 
2141         if (pageClient != null) {
2142             pageClient.setCursor(id);
2143         }
2144     }
2145 
2146     private void fwkSetFocus(boolean focus) {
2147         log.finer(&quot;Set focus: &quot; + (focus ? &quot;true&quot; : &quot;false&quot;));
2148 
2149         if (pageClient != null) {
2150             pageClient.setFocus(focus);
2151         }
2152     }
2153 
2154     private void fwkSetTooltip(String tooltip) {
2155         log.finer(&quot;Set tooltip: &quot; + tooltip);
2156 
2157         if (pageClient != null) {
2158             pageClient.setTooltip(tooltip);
2159         }
2160     }
2161 
2162     private void fwkPrint() {
2163         log.finer(&quot;Print&quot;);
2164 
2165         if (uiClient != null) {
2166             uiClient.print();
2167         }
2168     }
2169 
2170     private void fwkSetRequestURL(long pFrame, int id, String url) {
2171         log.finer(&quot;Set request URL: id = &quot; + id + &quot;, url = &quot; + url);
2172 
2173         synchronized (requestURLs) {
2174             requestURLs.put(id, url);
2175         }
2176     }
2177 
2178     private void fwkRemoveRequestURL(long pFrame, int id) {
2179         log.finer(&quot;Set request URL: id = &quot; + id);
2180 
2181         synchronized (requestURLs) {
2182             requestURLs.remove(id);
2183             requestStarted.remove(id);
2184         }
2185     }
2186 
2187     private WebPage fwkCreateWindow(
2188             boolean menu, boolean status, boolean toolbar, boolean resizable) {
2189         log.finer(&quot;Create window&quot;);
2190 
2191         if (uiClient != null) {
2192             return uiClient.createPage(menu, status, toolbar, resizable);
2193         }
2194         return null;
2195     }
2196 
2197     private void fwkShowWindow() {
2198         log.finer(&quot;Show window&quot;);
2199 
2200         if (uiClient != null) {
2201             uiClient.showView();
2202         }
2203     }
2204 
2205     private void fwkCloseWindow() {
2206         log.finer(&quot;Close window&quot;);
2207 
2208         if (permitCloseWindowAction()) {
2209             if (uiClient != null) {
2210                 uiClient.closePage();
2211             }
2212         }
2213     }
2214 
2215     private WCRectangle fwkGetWindowBounds() {
2216         log.fine(&quot;Get window bounds&quot;);
2217 
2218         if (uiClient != null) {
2219             WCRectangle bounds = uiClient.getViewBounds();
2220             if (bounds != null) {
2221                 return bounds;
2222             }
2223         }
2224         return fwkGetPageBounds();
2225     }
2226 
2227     private void fwkSetWindowBounds(int x, int y, int w, int h) {
2228         log.finer(&quot;Set window bounds: &quot; + x + &quot; &quot; + y + &quot; &quot; + w + &quot; &quot; + h);
2229 
2230         if (uiClient != null) {
2231             uiClient.setViewBounds(new WCRectangle(x, y, w, h));
2232         }
2233     }
2234 
2235     private WCRectangle fwkGetPageBounds() {
2236         log.finer(&quot;Get page bounds&quot;);
2237         return new WCRectangle(0, 0, width, height);
2238     }
2239 
2240     private void fwkSetScrollbarsVisible(boolean visible) {
2241         // TODO: handle this request internally
2242     }
2243 
2244     private void fwkSetStatusbarText(String text) {
2245         log.finer(&quot;Set statusbar text: &quot; + text);
2246 
2247         if (uiClient != null) {
2248             uiClient.setStatusbarText(text);
2249         }
2250     }
2251 
2252     private String[] fwkChooseFile(String initialFileName, boolean multiple, String mimeFilters) {
2253         log.finer(&quot;Choose file, initial=&quot; + initialFileName);
2254 
2255         return uiClient != null
2256                 ? uiClient.chooseFile(initialFileName, multiple, mimeFilters)
2257                 : null;
2258     }
2259 
2260     private void fwkStartDrag(
2261           Object image,
2262           int imageOffsetX, int imageOffsetY,
2263           int eventPosX, int eventPosY,
2264           String[] mimeTypes, Object[] values,
2265           boolean isImageSource)
2266     {
2267         log.finer(&quot;Start drag: &quot;);
2268         if (uiClient != null) {
2269             uiClient.startDrag(
2270                   WCImage.getImage(image),
2271                   imageOffsetX, imageOffsetY,
2272                   eventPosX, eventPosY,
2273                   mimeTypes, values,
2274                   isImageSource);
2275         }
2276     }
2277 
2278     private WCPoint fwkScreenToWindow(WCPoint ptScreen) {
2279         log.finer(&quot;fwkScreenToWindow&quot;);
2280 
2281         if (pageClient != null) {
2282             return pageClient.screenToWindow(ptScreen);
2283         }
2284         return ptScreen;
2285     }
2286 
2287     private WCPoint fwkWindowToScreen(WCPoint ptWindow) {
2288         log.finer(&quot;fwkWindowToScreen&quot;);
2289 
2290         if (pageClient != null) {
2291             return pageClient.windowToScreen(ptWindow);
2292         }
2293         return ptWindow;
2294     }
2295 
2296 
2297     private void fwkAlert(String text) {
2298         log.fine(&quot;JavaScript alert(): text = &quot; + text);
2299 
2300         if (uiClient != null) {
2301             uiClient.alert(text);
2302         }
2303     }
2304 
2305     private boolean fwkConfirm(String text) {
2306         log.fine(&quot;JavaScript confirm(): text = &quot; + text);
2307 
2308         if (uiClient != null) {
2309             return uiClient.confirm(text);
2310         }
2311         return false;
2312     }
2313 
2314     private String fwkPrompt(String text, String defaultValue) {
2315         log.fine(&quot;JavaScript prompt(): text = &quot; + text + &quot;, default = &quot; + defaultValue);
2316 
2317         if (uiClient != null) {
2318             return uiClient.prompt(text, defaultValue);
2319         }
2320         return null;
2321     }
2322 
2323     private boolean fwkCanRunBeforeUnloadConfirmPanel() {
2324         log.fine(&quot;JavaScript canRunBeforeUnloadConfirmPanel()&quot;);
2325 
2326         if (uiClient != null) {
2327             return uiClient.canRunBeforeUnloadConfirmPanel();
2328         }
2329         return false;
2330     }
2331 
2332     private boolean fwkRunBeforeUnloadConfirmPanel(String message) {
2333         log.fine(&quot;JavaScript runBeforeUnloadConfirmPanel(): message = &quot; + message);
2334 
2335         if (uiClient != null) {
2336             return uiClient.runBeforeUnloadConfirmPanel(message);
2337         }
2338         return false;
2339     }
2340 
2341     private void fwkAddMessageToConsole(String message, int lineNumber,
2342             String sourceId)
2343     {
2344         log.fine(&quot;fwkAddMessageToConsole(): message = &quot; + message
2345                 + &quot;, lineNumber = &quot; + lineNumber + &quot;, sourceId = &quot; + sourceId);
2346         if (pageClient != null) {
2347             pageClient.addMessageToConsole(message, lineNumber, sourceId);
2348         }
2349     }
2350 
2351     private void fwkFireLoadEvent(long frameID, int state,
2352                                   String url, String contentType,
2353                                   double progress, int errorCode)
2354     {
2355         log.finer(&quot;Load event: pFrame = &quot; + frameID + &quot;, state = &quot; + state +
2356                 &quot;, url = &quot; + url + &quot;, contenttype=&quot; + contentType +
2357                 &quot;, progress = &quot; + progress + &quot;, error = &quot; + errorCode);
2358 
2359         fireLoadEvent(frameID, state, url, contentType, progress, errorCode);
2360     }
2361 
2362     private void fwkFireResourceLoadEvent(long frameID, int state,
2363                                           int id, String contentType,
2364                                           double progress, int errorCode)
2365     {
2366         log.finer(&quot;Resource load event: pFrame = &quot; + frameID + &quot;, state = &quot; + state +
2367                 &quot;, id = &quot; + id + &quot;, contenttype=&quot; + contentType +
2368                 &quot;, progress = &quot; + progress + &quot;, error = &quot; + errorCode);
2369 
2370         String url = requestURLs.get(id);
2371         if (url == null) {
2372             log.fine(&quot;Error in fwkFireResourceLoadEvent: unknown request id &quot; + id);
2373             return;
2374         }
2375 
2376         int eventState = state;
2377         // convert second and all subsequent STARTED into REDIRECTED
2378         if (state == LoadListenerClient.RESOURCE_STARTED) {
2379             if (requestStarted.contains(id)) {
2380                 eventState = LoadListenerClient.RESOURCE_REDIRECTED;
2381             } else {
2382                 requestStarted.add(id);
2383             }
2384         }
2385 
2386         fireResourceLoadEvent(frameID, eventState, url, contentType, progress, errorCode);
2387     }
2388 
2389     private boolean fwkPermitNavigateAction(long pFrame, String url) {
2390         log.fine(&quot;Policy: permit NAVIGATE: pFrame = &quot; + pFrame + &quot;, url = &quot; + url);
2391 
2392         if (policyClient != null) {
2393             return policyClient.permitNavigateAction(pFrame, str2url(url));
2394         }
2395         return true;
2396     }
2397 
2398     private boolean fwkPermitRedirectAction(long pFrame, String url) {
2399         log.fine(&quot;Policy: permit REDIRECT: pFrame = &quot; + pFrame + &quot;, url = &quot; + url);
2400 
2401         if (policyClient != null) {
2402             return policyClient.permitRedirectAction(pFrame, str2url(url));
2403         }
2404         return true;
2405     }
2406 
2407     private boolean fwkPermitAcceptResourceAction(long pFrame, String url) {
2408         log.fine(&quot;Policy: permit ACCEPT_RESOURCE: pFrame + &quot; + pFrame + &quot;, url = &quot; + url);
2409 
2410         if (policyClient != null) {
2411             return policyClient.permitAcceptResourceAction(pFrame, str2url(url));
2412         }
2413         return true;
2414     }
2415 
2416     private boolean fwkPermitSubmitDataAction(long pFrame, String url,
2417                                               String httpMethod, boolean isSubmit)
2418     {
2419         log.fine(&quot;Policy: permit &quot; + (isSubmit ? &quot;&quot; : &quot;RE&quot;) + &quot;SUBMIT_DATA: pFrame = &quot; +
2420                 pFrame + &quot;, url = &quot; + url + &quot;, httpMethod = &quot; + httpMethod);
2421 
2422         if (policyClient != null) {
2423             if (isSubmit) {
2424                 return policyClient.permitSubmitDataAction(pFrame, str2url(url), httpMethod);
2425             } else {
2426                 return policyClient.permitResubmitDataAction(pFrame, str2url(url), httpMethod);
2427             }
2428         }
2429         return true;
2430     }
2431 
2432     private boolean fwkPermitEnableScriptsAction(long pFrame, String url) {
2433         log.fine(&quot;Policy: permit ENABLE_SCRIPTS: pFrame + &quot; + pFrame + &quot;, url = &quot; + url);
2434 
2435         if (policyClient != null) {
2436             return policyClient.permitEnableScriptsAction(pFrame, str2url(url));
2437         }
2438         return true;
2439     }
2440 
2441     private boolean fwkPermitNewWindowAction(long pFrame, String url) {
2442         log.fine(&quot;Policy: permit NEW_PAGE: pFrame = &quot; + pFrame + &quot;, url = &quot; + url);
2443 
2444         if (policyClient != null) {
2445             return policyClient.permitNewPageAction(pFrame, str2url(url));
2446         }
2447         return true;
2448     }
2449 
2450     // Called from fwkCloseWindow, that&#39;s why no &quot;fwk&quot; prefix
2451     private boolean permitCloseWindowAction() {
2452         log.fine(&quot;Policy: permit CLOSE_PAGE&quot;);
2453 
2454         if (policyClient != null) {
2455             // Unfortunately, webkit doesn&#39;t provide an information about what
2456             // web frame initiated close window request, so using main frame here
2457             return policyClient.permitClosePageAction(getMainFrame());
2458         }
2459         return true;
2460     }
2461 
2462     private void fwkRepaintAll() {
2463         log.fine(&quot;Repainting the entire page&quot;);
2464         repaintAll();
2465     }
2466 
2467     private boolean fwkSendInspectorMessageToFrontend(String message) {
2468         if (log.isLoggable(Level.FINE)) {
2469             log.fine(&quot;Sending inspector message to frontend, message: [{0}]&quot;,
2470                     message);
2471         }
2472         boolean result = false;
2473         if (inspectorClient != null) {
2474             log.fine(&quot;Invoking inspector client&quot;);
2475             result = inspectorClient.sendMessageToFrontend(message);
2476         }
2477         if (log.isLoggable(Level.FINE)) {
2478             log.fine(&quot;Result: [{0}]&quot;, result);
2479         }
2480         return result;
2481     }
2482 
2483     // ---- DumpRenderTree support ---- //
2484 
2485     public static int getWorkerThreadCount() {
2486         return twkWorkerThreadCount();
2487     }
2488 
2489     private static native int twkWorkerThreadCount();
2490 
2491     private void fwkDidClearWindowObject(long pContext, long pWindowObject) {
2492         if (pageClient != null) {
2493             pageClient.didClearWindowObject(pContext, pWindowObject);
2494         }
2495     }
2496 
2497     // *************************************************************************
2498     // Private methods
2499     // *************************************************************************
2500 
2501     private URL str2url(String url) {
2502         try {
2503             return newURL(url);
2504         } catch (MalformedURLException ex) {
2505             log.fine(&quot;Exception while converting \&quot;&quot; + url + &quot;\&quot; to URL&quot;, ex);
2506         }
2507         return null;
2508     }
2509 
2510     private void fireLoadEvent(long frameID, int state, String url,
2511             String contentType, double progress, int errorCode)
2512     {
2513         for (LoadListenerClient l : loadListenerClients) {
2514             l.dispatchLoadEvent(frameID, state, url, contentType, progress, errorCode);
2515         }
2516     }
2517 
2518     private void fireResourceLoadEvent(long frameID, int state, String url,
2519             String contentType, double progress, int errorCode)
2520     {
2521         for (LoadListenerClient l : loadListenerClients) {
2522             l.dispatchResourceLoadEvent(frameID, state, url, contentType, progress, errorCode);
2523         }
2524     }
2525 
2526     private void repaintAll() {
2527         dirtyRects.clear();
2528         addDirtyRect(new WCRectangle(0, 0, width, height));
2529     }
2530 
2531     // Package scope method for testing
2532     int test_getFramesCount() {
2533         return frames.size();
2534     }
2535 
2536     // *************************************************************************
2537     // Native methods
2538     // *************************************************************************
2539 
2540     private static native void twkInitWebCore(boolean useJIT, boolean useDFGJIT, boolean useCSS3D);
2541     private native long twkCreatePage(boolean editable);
2542     private native void twkInit(long pPage, boolean usePlugins, float devicePixelScale);
2543     private native void twkDestroyPage(long pPage);
2544 
2545     private native long twkGetMainFrame(long pPage);
2546     private native long twkGetParentFrame(long pFrame);
2547     private native long[] twkGetChildFrames(long pFrame);
2548 
2549     private native String twkGetName(long pFrame);
2550     private native String twkGetURL(long pFrame);
2551     private native String twkGetInnerText(long pFrame);
2552     private native String twkGetRenderTree(long pFrame);
2553     private native String twkGetContentType(long pFrame);
2554     private native String twkGetTitle(long pFrame);
2555     private native String twkGetIconURL(long pFrame);
2556     private native static Document twkGetDocument(long pFrame);
2557     private native static Element twkGetOwnerElement(long pFrame);
2558 
2559     private native void twkOpen(long pFrame, String url);
2560     private native void twkOverridePreference(long pPage, String key, String value);
2561     private native void twkResetToConsistentStateBeforeTesting(long pPage);
2562     private native void twkLoad(long pFrame, String text, String contentType);
2563     private native boolean twkIsLoading(long pFrame);
2564     private native void twkStop(long pFrame);
2565     private native void twkStopAll(long pPage); // sync
2566     private native void twkRefresh(long pFrame);
2567 
2568     private native boolean twkGoBackForward(long pPage, int distance);
2569 
2570     private native boolean twkCopy(long pFrame);
2571     private native boolean twkFindInPage(long pPage,
2572                                          String stringToFind, boolean forward,
2573                                          boolean wrap, boolean matchCase);
2574     private native boolean twkFindInFrame(long pFrame,
2575                                           String stringToFind, boolean forward,
2576                                           boolean wrap, boolean matchCase);
2577 
2578     private native float twkGetZoomFactor(long pFrame, boolean textOnly);
2579     private native void twkSetZoomFactor(long pFrame, float zoomFactor, boolean textOnly);
2580 
2581     private native Object twkExecuteScript(long pFrame, String script);
2582 
2583     private native void twkReset(long pFrame);
2584 
2585     private native int twkGetFrameHeight(long pFrame);
2586     private native int twkBeginPrinting(long pPage, float width, float height);
2587     private native void twkEndPrinting(long pPage);
2588     private native void twkPrint(long pPage, WCRenderQueue gc, int pageNumber, float width);
2589     private native float twkAdjustFrameHeight(long pFrame, float oldTop, float oldBottom, float bottomLimit);
2590 
2591     private native int[] twkGetVisibleRect(long pFrame);
2592     private native void twkScrollToPosition(long pFrame, int x, int y);
2593     private native int[] twkGetContentSize(long pFrame);
2594     private native void twkSetTransparent(long pFrame, boolean isTransparent);
2595     private native void twkSetBackgroundColor(long pFrame, int backgroundColor);
2596 
2597     private native void twkSetBounds(long pPage, int x, int y, int w, int h);
2598     private native void twkPrePaint(long pPage);
2599     private native void twkUpdateContent(long pPage, WCRenderQueue rq, int x, int y, int w, int h);
2600     private native void twkPostPaint(long pPage, WCRenderQueue rq,
2601                                      int x, int y, int w, int h);
2602 
2603     private native String twkGetEncoding(long pPage);
2604     private native void twkSetEncoding(long pPage, String encoding);
2605 
2606     private native void twkProcessFocusEvent(long pPage, int id, int direction);
2607     private native boolean twkProcessKeyEvent(long pPage, int type, String text,
2608                                               String keyIdentifier,
2609                                               int windowsVirtualKeyCode,
2610                                               boolean shift, boolean ctrl,
2611                                               boolean alt, boolean meta, double when);
2612     private native boolean twkProcessMouseEvent(long pPage, int id,
2613                                                 int button, int clickCount,
2614                                                 int x, int y, int sx, int sy,
2615                                                 boolean shift, boolean control, boolean alt, boolean meta,
2616                                                 boolean popupTrigger, double when);
2617     private native boolean twkProcessMouseWheelEvent(long pPage,
2618                                                      int x, int y, int sx, int sy,
2619                                                      float dx, float dy,
2620                                                      boolean shift, boolean control, boolean alt, boolean meta,
2621                                                      double when);
2622     private native boolean twkProcessInputTextChange(long pPage, String committed, String composed,
2623                                                      int[] attributes, int caretPosition);
2624     private native boolean twkProcessCaretPositionChange(long pPage, int caretPosition);
2625     private native int[] twkGetTextLocation(long pPage, int charIndex);
2626     private native int twkGetInsertPositionOffset(long pPage);
2627     private native int twkGetCommittedTextLength(long pPage);
2628     private native String twkGetCommittedText(long pPage);
2629     private native String twkGetSelectedText(long pPage);
2630 
2631     private native int twkProcessDrag(long page,
2632             int commandId,
2633             String[] mimeTypes, String[] values,
2634             int x, int y,
2635             int screenX, int screenY,
2636             int dndActionId);
2637 
2638     private native boolean twkExecuteCommand(long page, String command,
2639                                              String value);
2640     private native boolean twkQueryCommandEnabled(long page, String command);
2641     private native boolean twkQueryCommandState(long page, String command);
2642     private native String twkQueryCommandValue(long page, String command);
2643     private native boolean twkIsEditable(long page);
2644     private native void twkSetEditable(long page, boolean editable);
2645     private native String twkGetHtml(long pFrame);
2646 
2647     private native boolean twkGetUsePageCache(long page);
2648     private native void twkSetUsePageCache(long page, boolean usePageCache);
2649     private native boolean twkGetDeveloperExtrasEnabled(long page);
2650     private native void twkSetDeveloperExtrasEnabled(long page,
2651                                                      boolean enabled);
2652     private native boolean twkIsJavaScriptEnabled(long page);
2653     private native void twkSetJavaScriptEnabled(long page, boolean enable);
2654     private native boolean twkIsContextMenuEnabled(long page);
2655     private native void twkSetContextMenuEnabled(long page, boolean enable);
2656     private native void twkSetUserStyleSheetLocation(long page, String url);
2657     private native String twkGetUserAgent(long page);
2658     private native void twkSetUserAgent(long page, String userAgent);
2659     private native void twkSetLocalStorageDatabasePath(long page, String path);
2660     private native void twkSetLocalStorageEnabled(long page, boolean enabled);
2661 
2662     private native int twkGetUnloadEventListenersCount(long pFrame);
2663 
2664     private native void twkConnectInspectorFrontend(long pPage);
2665     private native void twkDisconnectInspectorFrontend(long pPage);
2666     private native void twkDispatchInspectorMessageFromFrontend(long pPage,
2667                                                                 String message);
2668     private static native void twkDoJSCGarbageCollection();
2669 }
    </pre>
  </body>
</html>
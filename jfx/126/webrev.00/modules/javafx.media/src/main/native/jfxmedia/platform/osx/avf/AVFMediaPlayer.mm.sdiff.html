<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFMediaPlayer.mm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AVFAudioSpectrumUnit.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>modules/javafx.media/src/main/native/jfxmedia/platform/osx/avf/AVFMediaPlayer.mm</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 70             FOURCC_CHAR(fcc &gt;&gt; 16),
 71             FOURCC_CHAR(fcc &gt;&gt; 8),
 72             FOURCC_CHAR(fcc)];
 73 }
 74 
 75 #if DUMP_TRACK_INFO
 76 static void append_log(NSMutableString *s, NSString *fmt, ...) {
 77     va_list args;
 78     va_start(args, fmt);
 79     NSString *appString = [[NSString alloc] initWithFormat:fmt arguments:args];
 80     [s appendFormat:@&quot;%@\n&quot;, appString];
 81     va_end(args);
 82 }
 83 #define TRACK_LOG(fmt, ...) append_log(trackLog, fmt, ##__VA_ARGS__)
 84 #else
 85 #define TRACK_LOG(...) {}
 86 #endif
 87 
 88 @implementation AVFMediaPlayer
 89 
<span class="line-modified"> 90 static void SpectrumCallbackProc(void *context, double duration);</span>
 91 
 92 static CVReturn displayLinkCallback(CVDisplayLinkRef displayLink,
 93                                     const CVTimeStamp *inNow,
 94                                     const CVTimeStamp *inOutputTime,
 95                                     CVOptionFlags flagsIn,
 96                                     CVOptionFlags *flagsOut,
 97                                     void *displayLinkContext);
 98 
 99 + (BOOL) playerAvailable {
100     // Check if AVPlayerItemVideoOutput exists, if not we&#39;re running on 10.7 or
101     // earlier which is no longer supported
102     Class klass = objc_getClass(&quot;AVPlayerItemVideoOutput&quot;);
103     return (klass != nil);
104 }
105 
106 - (id) initWithURL:(NSURL *)source eventHandler:(CJavaPlayerEventDispatcher*)hdlr {
107     if ((self = [super init]) != nil) {
108         previousWidth = -1;
109         previousHeight = -1;
110         previousPlayerState = kPlayerState_UNKNOWN;
</pre>
<hr />
<pre>
634                                FourCCToNSString(format)] UTF8String]));
635             [self setFallbackVideoFormat];
636             return;
637         }
638         // Can&#39;t use this frame, report an error and ignore it
639         LOGGER_DEBUGMSG(message);
640         return;
641     }
642 
643     if (previousWidth &lt; 0 || previousHeight &lt; 0
644         || previousWidth != frame-&gt;GetWidth() || previousHeight != frame-&gt;GetHeight())
645     {
646         // Send/Queue frame size changed event
647         previousWidth = frame-&gt;GetWidth();
648         previousHeight = frame-&gt;GetHeight();
649         eventHandler-&gt;SendFrameSizeChangedEvent(previousWidth, previousHeight);
650     }
651     eventHandler-&gt;SendNewFrameEvent(frame);
652 }
653 
<span class="line-modified">654 - (void) sendSpectrumEventDuration:(double)duration {</span>
655     if (eventHandler) {
<span class="line-modified">656         double timestamp = self.currentTime;</span>


657         eventHandler-&gt;SendAudioSpectrumEvent(timestamp, duration);
658     }
659 }
660 
661 @end
662 
<span class="line-modified">663 static void SpectrumCallbackProc(void *context, double duration) {</span>
664     if (context) {
665         AVFMediaPlayer *player = (__bridge AVFMediaPlayer*)context;
<span class="line-modified">666         [player sendSpectrumEventDuration:duration];</span>
667     }
668 }
669 
670 static CVReturn displayLinkCallback(CVDisplayLinkRef displayLink, const CVTimeStamp *inNow, const CVTimeStamp *inOutputTime, CVOptionFlags flagsIn, CVOptionFlags *flagsOut, void *displayLinkContext)
671 {
672     AVFMediaPlayer *self = (__bridge AVFMediaPlayer *)displayLinkContext;
673     AVPlayerItemVideoOutput *playerItemVideoOutput = self.playerOutput;
674 
675     // The displayLink calls back at every vsync (screen refresh)
676     // Compute itemTime for the next vsync
677     CMTime outputItemTime = [playerItemVideoOutput itemTimeForCVTimeStamp:*inOutputTime];
678     if ([playerItemVideoOutput hasNewPixelBufferForItemTime:outputItemTime]) {
679         CVPixelBufferRef pixBuff = [playerItemVideoOutput copyPixelBufferForItemTime:outputItemTime itemTimeForDisplay:NULL];
680         // Copy the pixel buffer to be displayed next and add it to AVSampleBufferDisplayLayer for display
681         double frameTime = CMTimeGetSeconds(outputItemTime);
682         [self sendPixelBuffer:pixBuff frameTime:frameTime hostTime:inOutputTime-&gt;hostTime];
683         self.hlsBugResetCount = 0;
684 
685         CVBufferRelease(pixBuff);
686     } else {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 70             FOURCC_CHAR(fcc &gt;&gt; 16),
 71             FOURCC_CHAR(fcc &gt;&gt; 8),
 72             FOURCC_CHAR(fcc)];
 73 }
 74 
 75 #if DUMP_TRACK_INFO
 76 static void append_log(NSMutableString *s, NSString *fmt, ...) {
 77     va_list args;
 78     va_start(args, fmt);
 79     NSString *appString = [[NSString alloc] initWithFormat:fmt arguments:args];
 80     [s appendFormat:@&quot;%@\n&quot;, appString];
 81     va_end(args);
 82 }
 83 #define TRACK_LOG(fmt, ...) append_log(trackLog, fmt, ##__VA_ARGS__)
 84 #else
 85 #define TRACK_LOG(...) {}
 86 #endif
 87 
 88 @implementation AVFMediaPlayer
 89 
<span class="line-modified"> 90 static void SpectrumCallbackProc(void *context, double duration, double timestamp);</span>
 91 
 92 static CVReturn displayLinkCallback(CVDisplayLinkRef displayLink,
 93                                     const CVTimeStamp *inNow,
 94                                     const CVTimeStamp *inOutputTime,
 95                                     CVOptionFlags flagsIn,
 96                                     CVOptionFlags *flagsOut,
 97                                     void *displayLinkContext);
 98 
 99 + (BOOL) playerAvailable {
100     // Check if AVPlayerItemVideoOutput exists, if not we&#39;re running on 10.7 or
101     // earlier which is no longer supported
102     Class klass = objc_getClass(&quot;AVPlayerItemVideoOutput&quot;);
103     return (klass != nil);
104 }
105 
106 - (id) initWithURL:(NSURL *)source eventHandler:(CJavaPlayerEventDispatcher*)hdlr {
107     if ((self = [super init]) != nil) {
108         previousWidth = -1;
109         previousHeight = -1;
110         previousPlayerState = kPlayerState_UNKNOWN;
</pre>
<hr />
<pre>
634                                FourCCToNSString(format)] UTF8String]));
635             [self setFallbackVideoFormat];
636             return;
637         }
638         // Can&#39;t use this frame, report an error and ignore it
639         LOGGER_DEBUGMSG(message);
640         return;
641     }
642 
643     if (previousWidth &lt; 0 || previousHeight &lt; 0
644         || previousWidth != frame-&gt;GetWidth() || previousHeight != frame-&gt;GetHeight())
645     {
646         // Send/Queue frame size changed event
647         previousWidth = frame-&gt;GetWidth();
648         previousHeight = frame-&gt;GetHeight();
649         eventHandler-&gt;SendFrameSizeChangedEvent(previousWidth, previousHeight);
650     }
651     eventHandler-&gt;SendNewFrameEvent(frame);
652 }
653 
<span class="line-modified">654 - (void) sendSpectrumEventDuration:(double)duration timestamp:(double)timestamp {</span>
655     if (eventHandler) {
<span class="line-modified">656         if (timestamp &lt; 0) {</span>
<span class="line-added">657             timestamp = self.currentTime;</span>
<span class="line-added">658         }</span>
659         eventHandler-&gt;SendAudioSpectrumEvent(timestamp, duration);
660     }
661 }
662 
663 @end
664 
<span class="line-modified">665 static void SpectrumCallbackProc(void *context, double duration, double timestamp) {</span>
666     if (context) {
667         AVFMediaPlayer *player = (__bridge AVFMediaPlayer*)context;
<span class="line-modified">668         [player sendSpectrumEventDuration:duration timestamp:timestamp];</span>
669     }
670 }
671 
672 static CVReturn displayLinkCallback(CVDisplayLinkRef displayLink, const CVTimeStamp *inNow, const CVTimeStamp *inOutputTime, CVOptionFlags flagsIn, CVOptionFlags *flagsOut, void *displayLinkContext)
673 {
674     AVFMediaPlayer *self = (__bridge AVFMediaPlayer *)displayLinkContext;
675     AVPlayerItemVideoOutput *playerItemVideoOutput = self.playerOutput;
676 
677     // The displayLink calls back at every vsync (screen refresh)
678     // Compute itemTime for the next vsync
679     CMTime outputItemTime = [playerItemVideoOutput itemTimeForCVTimeStamp:*inOutputTime];
680     if ([playerItemVideoOutput hasNewPixelBufferForItemTime:outputItemTime]) {
681         CVPixelBufferRef pixBuff = [playerItemVideoOutput copyPixelBufferForItemTime:outputItemTime itemTimeForDisplay:NULL];
682         // Copy the pixel buffer to be displayed next and add it to AVSampleBufferDisplayLayer for display
683         double frameTime = CMTimeGetSeconds(outputItemTime);
684         [self sendPixelBuffer:pixBuff frameTime:frameTime hostTime:inOutputTime-&gt;hostTime];
685         self.hlsBugResetCount = 0;
686 
687         CVBufferRelease(pixBuff);
688     } else {
</pre>
</td>
</tr>
</table>
<center><a href="AVFAudioSpectrumUnit.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
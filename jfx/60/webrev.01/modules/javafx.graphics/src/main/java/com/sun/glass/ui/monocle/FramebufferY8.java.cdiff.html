<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/FramebufferY8.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EPDSystem.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../../tests/system/src/test/java/test/com/sun/glass/ui/monocle/EPDSettingsTest.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/FramebufferY8.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 91,28 ***</span>
       * pixels. Luma Y&#39; can be calculated from gamma-corrected R&#39;G&#39;B&#39; using the
       * following coefficients. This method uses the coefficients from Rec. 709,
       * which defines the same primaries and white point as the sRGB color space.
       * &lt;pre&gt;{@code
       * Simple average:  Y&#39; = (R&#39; + G&#39; + B&#39;) / 3
<span class="line-modified">!      * Rec. 601 (SDTV): Y&#39; = 0.299  × R&#39; + 0.587  × G&#39; + 0.114  × B&#39;</span>
<span class="line-modified">!      * Rec. 709 (HDTV): Y&#39; = 0.2126 × R&#39; + 0.7152 × G&#39; + 0.0722 × B&#39;</span>
<span class="line-modified">!      * Rec. 2100 (HDR): Y&#39; = 0.2627 × R&#39; + 0.6780 × G&#39; + 0.0593 × B&#39;</span>
       * }&lt;/pre&gt;
       *
       * @implNote Java rounds toward zero when converting a {@code float} to an
<span class="line-modified">!      * {@code int}, so this method adds 0.5 before the type conversion to round</span>
<span class="line-modified">!      * to the nearest integer.</span>
       *
       * @param source the source integer buffer in ARGB32 format
       * @param target the target byte buffer in Y8 format
       */
      private void copyNextPixel(IntBuffer source, ByteBuffer target) {
          int pixel32 = source.get();
          int r = (pixel32 &gt;&gt; 16) &amp; 0xFF;
          int g = (pixel32 &gt;&gt; 8) &amp; 0xFF;
          int b = pixel32 &amp; 0xFF;
<span class="line-modified">!         int y = (int) (0.2126f * r + 0.7152f * g + 0.0722f * b + 0.5f);</span>
          target.put((byte) y);
      }
  
      /**
       * Copies the next 32-bit ARGB32 pixel to a short buffer with 16-bit RGB565
<span class="line-new-header">--- 91,29 ---</span>
       * pixels. Luma Y&#39; can be calculated from gamma-corrected R&#39;G&#39;B&#39; using the
       * following coefficients. This method uses the coefficients from Rec. 709,
       * which defines the same primaries and white point as the sRGB color space.
       * &lt;pre&gt;{@code
       * Simple average:  Y&#39; = (R&#39; + G&#39; + B&#39;) / 3
<span class="line-modified">!      * Rec. 601 (SDTV): Y&#39; = 0.299  * R&#39; + 0.587  * G&#39; + 0.114  * B&#39;</span>
<span class="line-modified">!      * Rec. 709 (HDTV): Y&#39; = 0.2126 * R&#39; + 0.7152 * G&#39; + 0.0722 * B&#39;</span>
<span class="line-modified">!      * Rec. 2100 (HDR): Y&#39; = 0.2627 * R&#39; + 0.6780 * G&#39; + 0.0593 * B&#39;</span>
       * }&lt;/pre&gt;
       *
       * @implNote Java rounds toward zero when converting a {@code float} to an
<span class="line-modified">!      * {@code int}. The calculation of luma could be rounded to the nearest</span>
<span class="line-modified">!      * integer by adding 0.5 before the type conversion, but the extra operation</span>
<span class="line-added">+      * seems unnecessary for a display with only 16 levels of gray.</span>
       *
       * @param source the source integer buffer in ARGB32 format
       * @param target the target byte buffer in Y8 format
       */
      private void copyNextPixel(IntBuffer source, ByteBuffer target) {
          int pixel32 = source.get();
          int r = (pixel32 &gt;&gt; 16) &amp; 0xFF;
          int g = (pixel32 &gt;&gt; 8) &amp; 0xFF;
          int b = pixel32 &amp; 0xFF;
<span class="line-modified">!         int y = (int) (0.2126f * r + 0.7152f * g + 0.0722f * b);</span>
          target.put((byte) y);
      }
  
      /**
       * Copies the next 32-bit ARGB32 pixel to a short buffer with 16-bit RGB565
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,11 ***</span>
              }
              default:
                  String msg = MessageFormat.format(&quot;byteDepth={0}&quot;, byteDepth);
                  logger.severe(msg);
                  throw new IllegalStateException(msg);
<span class="line-removed">- </span>
          }
      }
  
      /**
       * Copies the contents of the composition buffer to the output buffer,
<span class="line-new-header">--- 186,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,11 ***</span>
              }
              default:
                  String msg = MessageFormat.format(&quot;byteDepth={0}&quot;, byteDepth);
                  logger.severe(msg);
                  throw new IllegalStateException(msg);
<span class="line-removed">- </span>
          }
      }
  
      @Override
      public String toString() {
<span class="line-new-header">--- 245,10 ---</span>
</pre>
<center><a href="EPDSystem.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../../tests/system/src/test/java/test/com/sun/glass/ui/monocle/EPDSettingsTest.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
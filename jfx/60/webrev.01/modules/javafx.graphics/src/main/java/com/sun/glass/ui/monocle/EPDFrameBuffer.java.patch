diff a/modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/EPDFrameBuffer.java b/modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/EPDFrameBuffer.java
--- a/modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/EPDFrameBuffer.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/EPDFrameBuffer.java
@@ -67,10 +67,15 @@
      * EPDC driver and when the driver powers down the EPDC and display power
      * supplies.
      */
     private static final int POWERDOWN_DELAY = 1_000;
 
+    /**
+     * Linux system error: ENOTTY 25 Inappropriate ioctl for device.
+     */
+    private static final int ENOTTY = 25;
+
     private final PlatformLogger logger = Logging.getJavaFXLogger();
     private final EPDSettings settings;
     private final LinuxSystem system;
     private final EPDSystem driver;
     private final long fd;
@@ -294,10 +299,20 @@
      * <li>{@link EPDSystem#WAVEFORM_MODE_GC16}</li>
      * <li>{@link EPDSystem#WAVEFORM_MODE_GC4}</li>
      * <li>{@link EPDSystem#WAVEFORM_MODE_A2}</li>
      * </ul>
      *
+     * @implNote This method fails on the Kobo Glo HD Model N437 with the error
+     * ENOTTY (25), "Inappropriate ioctl for device." The driver on that device
+     * uses an extended structure with four additional integers, changing its
+     * size and its corresponding request code. This method could use the
+     * extended structure, but the driver on the Kobo Glo HD ignores it and
+     * returns immediately, anyway. Furthermore, newer devices support both the
+     * current structure and the extended one, but define the extra fields in a
+     * different order. Therefore, simply use the current structure and ignore
+     * an error of ENOTTY, picking up the default values for any extra fields.
+     *
      * @param init the initialization mode for clearing the screen to all white
      * @param du the direct update mode for changing any gray values to either
      * all black or all white
      * @param gc4 the mode for 4-level (2-bit) grayscale images and text
      * @param gc8 the mode for 8-level (3-bit) grayscale images and text
@@ -306,11 +321,11 @@
      */
     private void setWaveformModes(int init, int du, int gc4, int gc8, int gc16, int gc32) {
         var modes = new MxcfbWaveformModes();
         modes.setModes(modes.p, init, du, gc4, gc8, gc16, gc32);
         int rc = system.ioctl(fd, driver.MXCFB_SET_WAVEFORM_MODES, modes.p);
-        if (rc != 0) {
+        if (rc != 0 && system.errno() != ENOTTY) {
             logger.severe("Failed setting waveform modes: {0} ({1})",
                     system.getErrorMessage(), system.errno());
         }
     }
 
@@ -323,11 +338,11 @@
      * @param temp the temperature in degrees Celsius
      */
     private void setTemperature(int temp) {
         int rc = driver.ioctl(fd, driver.MXCFB_SET_TEMPERATURE, temp);
         if (rc != 0) {
-            logger.severe("Failed setting temperature to {2} °C: {0} ({1})",
+            logger.severe("Failed setting temperature to {2} degrees Celsius: {0} ({1})",
                     system.getErrorMessage(), system.errno(), temp);
         }
     }
 
     /**
@@ -419,11 +434,11 @@
         int rc = system.ioctl(fd, driver.MXCFB_SEND_UPDATE, update.p);
         if (rc != 0) {
             logger.severe("Failed sending update {2}: {0} ({1})",
                     system.getErrorMessage(), system.errno(), Integer.toUnsignedLong(updateMarker));
         } else if (logger.isLoggable(Level.FINER)) {
-            logger.finer("Sent update: {0} × {1}, waveform {2}, selected {3}, flags 0x{4}, marker {5}",
+            logger.finer("Sent update: {0} x {1}, waveform {2}, selected {3}, flags 0x{4}, marker {5}",
                     update.getUpdateRegionWidth(update.p), update.getUpdateRegionHeight(update.p),
                     waveformMode, update.getWaveformMode(update.p),
                     Integer.toHexString(update.getFlags(update.p)).toUpperCase(),
                     Integer.toUnsignedLong(updateMarker));
         }
@@ -480,11 +495,11 @@
         int rc = system.ioctl(fd, driver.MXCFB_GET_PWRDOWN_DELAY, integer.p);
         if (rc != 0) {
             logger.severe("Failed getting power-down delay: {0} ({1})",
                     system.getErrorMessage(), system.errno());
         }
-        return integer.getInteger(integer.p);
+        return integer.get(integer.p);
     }
 
     /**
      * Selects a scheme for the flow of updates within the driver.
      *
@@ -569,34 +584,77 @@
         /*
          * Allocates a direct byte buffer to avoid bug JDK-8201567,
          * "QuantumRenderer modifies buffer in use by JavaFX Application Thread"
          * <https://bugs.openjdk.java.net/browse/JDK-8201567>.
          */
-        int size = xresVirtual * yresVirtual * Integer.SIZE;
+        int size = xresVirtual * yres * Integer.BYTES;
         return ByteBuffer.allocateDirect(size);
     }
 
     /**
      * Creates a new mapping of the Linux frame buffer device into memory.
      *
+     * @implNote The virtual y-resolution reported by the device driver can be
+     * wrong, as shown by the following example on the Kobo Glo HD Model N437
+     * which reports 2,304 pixels when the correct value is 1,152 pixels
+     * (6,782,976 / 5,888). Therefore, this method cannot use the frame buffer
+     * virtual resolution to calculate its size.
+     *
+     * <pre>{@code
+     * $ sudo fbset -i
+     *
+     * mode "1448x1072-46"
+     * # D: 80.000 MHz, H: 50.188 kHz, V: 46.385 Hz
+     * geometry 1448 1072 1472 2304 32
+     * timings 12500 16 102 4 4 28 2
+     * rgba 8/16,8/8,8/0,8/24
+     * endmode
+     *
+     * Frame buffer device information:
+     * Name        : mxc_epdc_fb
+     * Address     : 0x88000000
+     * Size        : 6782976
+     * Type        : PACKED PIXELS
+     * Visual      : TRUECOLOR
+     * XPanStep    : 1
+     * YPanStep    : 1
+     * YWrapStep   : 0
+     * LineLength  : 5888
+     * Accelerator : No
+     * }</pre>
+     *
      * @return a byte buffer containing the mapping of the Linux frame buffer
-     * device
+     * device if successful; otherwise {@code null}
      */
     ByteBuffer getMappedBuffer() {
-        int size = xresVirtual * yresVirtual * bytesPerPixel;
+        ByteBuffer buffer = null;
+        int size = xresVirtual * yres * bytesPerPixel;
+        logger.fine("Mapping frame buffer: {0} bytes", size);
         long addr = system.mmap(0l, size, LinuxSystem.PROT_WRITE, LinuxSystem.MAP_SHARED, fd, 0);
-        return addr == LinuxSystem.MAP_FAILED ? null : C.getC().NewDirectByteBuffer(addr, size);
+        if (addr == LinuxSystem.MAP_FAILED) {
+            logger.severe("Failed mapping {2} bytes of frame buffer: {0} ({1})",
+                    system.getErrorMessage(), system.errno(), size);
+        } else {
+            buffer = C.getC().NewDirectByteBuffer(addr, size);
+        }
+        return buffer;
     }
 
     /**
      * Deletes the mapping of the Linux frame buffer device.
      *
      * @param buffer the byte buffer containing the mapping of the Linux frame
      * buffer device
      */
     void releaseMappedBuffer(ByteBuffer buffer) {
-        system.munmap(C.getC().GetDirectBufferAddress(buffer), buffer.capacity());
+        int size = buffer.capacity();
+        logger.fine("Unmapping frame buffer: {0} bytes", size);
+        int rc = system.munmap(C.getC().GetDirectBufferAddress(buffer), size);
+        if (rc != 0) {
+            logger.severe("Failed unmapping {2} bytes of frame buffer: {0} ({1})",
+                    system.getErrorMessage(), system.errno(), size);
+        }
     }
 
     /**
      * Closes the Linux frame buffer device.
      */
@@ -612,30 +670,35 @@
     long getNativeHandle() {
         return fd;
     }
 
     /**
-     * Gets the virtual horizontal resolution of the frame buffer. See the notes
-     * for the {@linkplain EPDFrameBuffer#EPDFrameBuffer constructor} above.
+     * Gets the frame buffer width in pixels. See the notes for the
+     * {@linkplain EPDFrameBuffer#EPDFrameBuffer constructor} above.
+     *
+     * @implNote When using an 8-bit, unrotated, and uninverted frame buffer in
+     * the Y8 pixel format, the Kobo Clara HD Model N249 works only when this
+     * method returns the visible x-resolution ({@code xres}) instead of the
+     * normal virtual x-resolution ({@code xresVirtual}).
      *
-     * @return the virtual width in pixels
+     * @return the width in pixels
      */
     int getWidth() {
-        return xresVirtual;
+        return settings.getWidthVisible ? xres : xresVirtual;
     }
 
     /**
-     * Gets the visible vertical resolution of the frame buffer.
+     * Gets the frame buffer height in pixels.
      *
-     * @return the visible height in pixels
+     * @return the height in pixels
      */
     int getHeight() {
         return yres;
     }
 
     /**
-     * Gets the color depth of the frame buffer.
+     * Gets the frame buffer color depth in bits per pixel.
      *
      * @return the color depth in bits per pixel
      */
     int getBitDepth() {
         return bitsPerPixel;

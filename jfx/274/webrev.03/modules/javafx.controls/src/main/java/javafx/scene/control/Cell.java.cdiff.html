<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.controls/src/main/java/javafx/scene/control/Cell.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../javafx.fxml/src/main/docs/javafx/fxml/doc-files/introduction_to_fxml.html.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/Cell.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 573,10 ***</span>
<span class="line-new-header">--- 573,11 ---</span>
       * Public API                                                              *
       *                                                                         *
       **************************************************************************/
  
      /**
<span class="line-added">+      * Starts an edit to the value of the cell.</span>
       * Call this function to transition from a non-editing state into an editing
       * state, if the cell is editable. If this cell is already in an editing
       * state, it will stay in it.
       */
      public void startEdit() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 584,41 ***</span>
              setEditing(true);
          }
      }
  
      /**
       * Call this function to transition from an editing state into a non-editing
       * state, without saving any user input.
       */
      public void cancelEdit() {
          if (isEditing()) {
              setEditing(false);
          }
      }
  
      /**
       * Call this function when appropriate (based on the user interaction requirements
       * of your cell editing user interface) to do two things:
       *
       * &lt;ol&gt;
<span class="line-modified">!      *     &lt;li&gt;Fire the appropriate events back to the backing UI control (e.g.</span>
       *     {@link ListView}). This will begin the process of pushing this edit
       *     back to the relevant data source / property (although it does not
       *     guarantee that this will be successful - that is dependent upon the
       *     specific edit commit handler being used). Refer to the UI control
       *     class javadoc for more detail.&lt;/li&gt;
       *     &lt;li&gt;Begin the transition from an editing state into a non-editing state.&lt;/li&gt;
       * &lt;/ol&gt;
       *
       * &lt;p&gt;In general there is no need to override this method in custom cell
       * implementations - it should be sufficient to simply call this method
<span class="line-modified">!      * when appropriate (e.g. when the user pressed the Enter key, you may do something</span>
       * like {@code cell.commitEdit(converter.fromString(textField.getText()));}&lt;/p&gt;
       *
<span class="line-modified">!      * @param newValue The value as input by the end user, which should be</span>
       *      persisted in the relevant way given the data source underpinning the
<span class="line-modified">!      *      user interface and the install edit commit handler of the UI control.</span>
       */
      public void commitEdit(T newValue) {
          if (isEditing()) {
              setEditing(false);
          }
<span class="line-new-header">--- 585,43 ---</span>
              setEditing(true);
          }
      }
  
      /**
<span class="line-added">+      * Cancels an edit to the value of the cell.</span>
       * Call this function to transition from an editing state into a non-editing
       * state, without saving any user input.
       */
      public void cancelEdit() {
          if (isEditing()) {
              setEditing(false);
          }
      }
  
      /**
<span class="line-added">+      * Commits an edit to the value of the cell.</span>
       * Call this function when appropriate (based on the user interaction requirements
       * of your cell editing user interface) to do two things:
       *
       * &lt;ol&gt;
<span class="line-modified">!      *     &lt;li&gt;Fire the appropriate events back to the backing UI control (e.g.,</span>
       *     {@link ListView}). This will begin the process of pushing this edit
       *     back to the relevant data source / property (although it does not
       *     guarantee that this will be successful - that is dependent upon the
       *     specific edit commit handler being used). Refer to the UI control
       *     class javadoc for more detail.&lt;/li&gt;
       *     &lt;li&gt;Begin the transition from an editing state into a non-editing state.&lt;/li&gt;
       * &lt;/ol&gt;
       *
       * &lt;p&gt;In general there is no need to override this method in custom cell
       * implementations - it should be sufficient to simply call this method
<span class="line-modified">!      * when appropriate (e.g., when the user pressed the Enter key, you may do something</span>
       * like {@code cell.commitEdit(converter.fromString(textField.getText()));}&lt;/p&gt;
       *
<span class="line-modified">!      * @param newValue the value as input by the end user, which should be</span>
       *      persisted in the relevant way given the data source underpinning the
<span class="line-modified">!      *      user interface and the install edit commit handler of the UI control</span>
       */
      public void commitEdit(T newValue) {
          if (isEditing()) {
              setEditing(false);
          }
</pre>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../javafx.fxml/src/main/docs/javafx/fxml/doc-files/introduction_to_fxml.html.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.graphics/src/main/java/com/sun/javafx/scene/PointLightHelper.java b/modules/javafx.graphics/src/main/java/com/sun/javafx/scene/PointLightHelper.java
--- a/modules/javafx.graphics/src/main/java/com/sun/javafx/scene/PointLightHelper.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/javafx/scene/PointLightHelper.java
@@ -72,6 +72,6 @@
 
     public interface PointLightAccessor {
         NGNode doCreatePeer(Node node);
         void doUpdatePeer(Node node);
     }
-}
+}
diff a/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGShape3D.java b/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGShape3D.java
--- a/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGShape3D.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGShape3D.java
@@ -182,11 +182,12 @@
         while (pointLightIdx < 3) {
                 // Reset any previously set lights
                 meshView.setPointLight(pointLightIdx++,
                         0, 0, 0, // x y z
                         0, 0, 0, 0, // r g b w
-                        1, 0, 0, 0); // ca la qa maxRange
+                        NGPointLight.getDefaultCa(), NGPointLight.getDefaultLa(), NGPointLight.getDefaultQa(),
+                        NGPointLight.getDefaultMaxRange());
         }
 
         meshView.render(g);
     }
 
diff a/modules/javafx.graphics/src/main/java/javafx/scene/PointLight.java b/modules/javafx.graphics/src/main/java/javafx/scene/PointLight.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/PointLight.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/PointLight.java
@@ -103,11 +103,11 @@
      * Nodes that are inside the light's range can still be excluded from the light's effect by removing them from
      * its {@link #getScope() scope} (or including them in its {@link #getExclusionScope() exclusion scope}). If a
      * node is known to always be outside of the light's range, it is more performant to exclude it from its scope.
      *
      * @defaultValue {@code Double.POSITIVE_INFINITY}
-     * @since 14
+     * @since 16
      */
     private DoubleProperty maxRange;
 
     public final void setMaxRange(double value) {
         maxRangeProperty().set(value);
@@ -132,11 +132,11 @@
      * {@code attn = 1 / (ca + la * dist + qa * dist^2)}
      * <p>
      * where {@code dist} is the distance between the light source and the pixel.
      *
      * @defaultValue 1
-     * @since 14
+     * @since 16
      */
     private DoubleProperty constantAttenuation;
 
     public final void setConstantAttenuation(double value) {
         constantAttenuationProperty().set(value);
@@ -161,27 +161,27 @@
      * {@code attn = 1 / (ca + la * dist + qa * dist^2)}
      * <p>
      * where {@code dist} is the distance between the light source and the pixel.
      *
      * @defaultValue 0
-     * @since 14
+     * @since 16
      */
     private DoubleProperty linearAttenuation;
 
     public final void setLinearAttenuation(double value) {
         linearAttenuationProperty().set(value);
     }
 
-    private static final double DEFAULT_LINEAR_CONSTANT = NGPointLight.getDefaultLa();
+    private static final double DEFAULT_LINEAR_ATTENUATION = NGPointLight.getDefaultLa();
 
     public final double getLinearAttenuation() {
-        return linearAttenuation == null ? DEFAULT_LINEAR_CONSTANT : linearAttenuation.get();
+        return linearAttenuation == null ? DEFAULT_LINEAR_ATTENUATION : linearAttenuation.get();
     }
 
     public final DoubleProperty linearAttenuationProperty() {
         if (linearAttenuation == null) {
-            linearAttenuation = getLightDoubleProperty("linearAttenuation", DEFAULT_LINEAR_CONSTANT);
+            linearAttenuation = getLightDoubleProperty("linearAttenuation", DEFAULT_LINEAR_ATTENUATION);
         }
         return linearAttenuation;
     }
 
     /**
@@ -190,27 +190,27 @@
      * {@code attn = 1 / (ca + la * dist + qa * dist^2)}
      * <p>
      * where {@code dist} is the distance between the light source and the pixel.
      *
      * @defaultValue 0
-     * @since 14
+     * @since 16
      */
     private DoubleProperty quadraticAttenuation;
 
     public final void setQuadraticAttenuation(double value) {
         quadraticAttenuationProperty().set(value);
     }
 
-    private static final double DEFAULT_QUADRATIC_CONSTANT = NGPointLight.getDefaultQa();
+    private static final double DEFAULT_QUADRATIC_ATTENUATION = NGPointLight.getDefaultQa();
 
     public final double getQuadraticAttenuation() {
-        return quadraticAttenuation == null ? DEFAULT_QUADRATIC_CONSTANT : quadraticAttenuation.get();
+        return quadraticAttenuation == null ? DEFAULT_QUADRATIC_ATTENUATION : quadraticAttenuation.get();
     }
 
     public final DoubleProperty quadraticAttenuationProperty() {
         if (quadraticAttenuation == null) {
-            quadraticAttenuation = getLightDoubleProperty("quadraticAttenuation", DEFAULT_QUADRATIC_CONSTANT);
+            quadraticAttenuation = getLightDoubleProperty("quadraticAttenuation", DEFAULT_QUADRATIC_ATTENUATION);
         }
         return quadraticAttenuation;
     }
 
     /*
diff a/modules/javafx.graphics/src/main/native-prism-d3d/hlsl/psMath.h b/modules/javafx.graphics/src/main/native-prism-d3d/hlsl/psMath.h
--- a/modules/javafx.graphics/src/main/native-prism-d3d/hlsl/psMath.h
+++ b/modules/javafx.graphics/src/main/native-prism-d3d/hlsl/psMath.h
@@ -67,13 +67,13 @@
         float dist = length(L[i].xyz);
         if (dist <= gLightRange[i].x) {
             float ca = gLightAttenuation[i].x;
             float la = gLightAttenuation[i].y;
             float qa = gLightAttenuation[i].z;
-            float attn = 1.0 / (ca + la * dist + qa * dist * dist);
+            float attenuatedColor = gLightColor[i].xyz / (ca + la * dist + qa * dist * dist);
 
             float3 l = normalize(L[i].xyz);
-            d += saturate(dot(n, l)) * gLightColor[i].xyz * attn;
-            s += pow(saturate(dot(-refl, l)), power) * gLightColor[i].xyz * attn;
+            d += saturate(dot(n, l)) * attenuatedColor;
+            s += pow(saturate(dot(-refl, l)), power) * attenuatedColor;
         }
     }
 }
diff a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main1Light.frag b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main1Light.frag
--- a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main1Light.frag
+++ b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main1Light.frag
@@ -86,13 +86,13 @@
         vec3 refl = reflect(normalize(eyePos), n);
         vec3 l = normalize(lightTangentSpacePositions[0].xyz);
 
         float power = specular.a;
 
-        float att = 1.0 / (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);
-        d = clamp(dot(n, l), 0.0, 1.0) * (lights[0].color).rgb * att;
-        s = pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[0].color.rgb * att;
+        float attenuatedColor = (lights[0].color).rgb / (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);
+        d = clamp(dot(n, l), 0.0, 1.0) * attenuatedColor;
+        s = pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;
     }
     vec3 rez = (ambientColor + d) * diffuse.xyz + s * specular.rgb;
     rez += apply_selfIllum().xyz;
 
     gl_FragColor = vec4(clamp(rez, 0.0, 1.0), diffuse.a);
diff a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main2Lights.frag b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main2Lights.frag
--- a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main2Lights.frag
+++ b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main2Lights.frag
@@ -85,22 +85,22 @@
 
     float maxRange = lights[0].range;
     float dist = length(lightTangentSpacePositions[0].xyz);
     if (dist <= maxRange) {
         vec3 l = normalize(lightTangentSpacePositions[0].xyz);
-        float att = 1.0 / (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);
-        d += clamp(dot(n,l), 0.0, 1.0) * (lights[0].color).rgb * att;
-        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[0].color.rgb * att;
+        float attenuatedColor = (lights[0].color).rgb / (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);
+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;
+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;
     }
 
     maxRange = lights[1].range;
     dist = length(lightTangentSpacePositions[1].xyz);
     if (dist <= maxRange) {
         vec3 l = normalize(lightTangentSpacePositions[1].xyz);
-        float att = 1.0 / (lights[1].attn.x + lights[1].attn.y * dist + lights[1].attn.z * dist * dist);
-        d += clamp(dot(n,l), 0.0, 1.0) * (lights[1].color).rgb * att;
-        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[1].color.rgb * att;
+        float attenuatedColor = (lights[1].color).rgb / (lights[1].attn.x + lights[1].attn.y * dist + lights[1].attn.z * dist * dist);
+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;
+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;
     }
     vec3 rez = (ambientColor + d) * diffuse.xyz + s * specular.rgb;
     rez += apply_selfIllum().xyz;
 
     gl_FragColor = vec4(clamp(rez, 0.0, 1.0) , diffuse.a);
diff a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main3Lights.frag b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main3Lights.frag
--- a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main3Lights.frag
+++ b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main3Lights.frag
@@ -85,31 +85,31 @@
 
     float maxRange = lights[0].range;
     float dist = length(lightTangentSpacePositions[0].xyz);
     if (dist <= maxRange) {
         vec3 l = normalize(lightTangentSpacePositions[0].xyz);
-        float att = 1.0 / (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);
-        d += clamp(dot(n,l), 0.0, 1.0) * (lights[0].color).rgb * att;
-        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[0].color.rgb * att;
+        float attenuatedColor = (lights[0].color).rgb / (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);
+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;
+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;
     }
 
     maxRange = lights[1].range;
     dist = length(lightTangentSpacePositions[1].xyz);
     if (dist <= maxRange) {
         vec3 l = normalize(lightTangentSpacePositions[1].xyz);
-        float att = 1.0 / (lights[1].attn.x + lights[1].attn.y * dist + lights[1].attn.z * dist * dist);
-        d += clamp(dot(n,l), 0.0, 1.0) * (lights[1].color).rgb * att;
-        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[1].color.rgb * att;
+        float attenuatedColor = (lights[1].color).rgb / (lights[1].attn.x + lights[1].attn.y * dist + lights[1].attn.z * dist * dist);
+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;
+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;
     }
 
     maxRange = lights[2].range;
     dist = length(lightTangentSpacePositions[2].xyz);
     if (dist <= maxRange) {
         vec3 l = normalize(lightTangentSpacePositions[2].xyz);
-        float att = 1.0 / (lights[2].attn.x + lights[2].attn.y * dist + lights[2].attn.z * dist * dist);
-        d += clamp(dot(n,l), 0.0, 1.0) * (lights[2].color).rgb * att;
-        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[2].color.rgb * att;
+        float attenuatedColor = (lights[2].color).rgb / (lights[2].attn.x + lights[2].attn.y * dist + lights[2].attn.z * dist * dist);
+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;
+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;
     }
 
     vec3 rez = (ambientColor + d) * diffuse.xyz + s * specular.rgb;
     rez += apply_selfIllum().xyz;
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_window.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 219     gtk_widget_set_events(gtk_widget, GDK_ALL_EVENTS_MASK);
 220     gtk_widget_set_app_paintable(gtk_widget, TRUE);
 221 
 222     glass_gtk_configure_transparency_and_realize(gtk_widget, frame_type == TRANSPARENT);
 223     gtk_window_set_title(GTK_WINDOW(gtk_widget), &quot;&quot;);
 224 
 225     gdk_window = gtk_widget_get_window(gtk_widget);
 226     g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
 227 
 228     glass_dnd_attach_context(this);
 229 
 230     gdk_windowManagerFunctions = wmf;
 231     if (wmf) {
 232         gdk_window_set_functions(gdk_window, wmf);
 233     }
 234 
 235     if (frame_type != TITLED) {
 236         gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);
 237     }
 238 



 239     connect_signals(gtk_widget, this);
 240 }
 241 
 242 void WindowContext::paint(void *data, jint width, jint height) {
 243 #if GTK_CHECK_VERSION(3, 0, 0)
 244     cairo_region_t *region = gdk_window_get_clip_region(gdk_window);
 245 #if GTK_CHECK_VERSION(3, 22, 0)
 246     GdkDrawingContext *dcontext = gdk_window_begin_draw_frame(gdk_window, region);
 247     cairo_t *context = gdk_drawing_context_get_cairo_context(dcontext);
 248 #else
 249     gdk_window_begin_paint_region(gdk_window, region);
 250     cairo_t* context = gdk_cairo_create(gdk_window);
 251 #endif
 252 #else
 253     cairo_t *context = gdk_cairo_create(gdk_window);
 254 #endif
 255 
 256     if (bg_color.is_set) {
 257         cairo_set_source_rgba(context, bg_color.red, bg_color.green, bg_color.blue,
 258                                 (frame_type == TRANSPARENT) ? 0 : 1);
</pre>
<hr />
<pre>
 307 }
 308 
 309 GtkWindow *WindowContext::get_gtk_window() {
 310     return GTK_WINDOW(gtk_widget);
 311 }
 312 
 313 WindowGeometry WindowContext::get_geometry() {
 314     return geometry;
 315 }
 316 
 317 jobject WindowContext::get_jwindow() {
 318     return jwindow;
 319 }
 320 
 321 jobject WindowContext::get_jview() {
 322     return jview;
 323 }
 324 
 325 void WindowContext::process_map() {
 326     map_received = true;

 327     apply_geometry();
 328 }
 329 
 330 void WindowContext::process_focus(GdkEventFocus *event) {
 331     if (!event-&gt;in &amp;&amp; WindowContext::sm_mouse_drag_window == this) {
 332         ungrab_mouse_drag_focus();
 333     }
 334 
 335     if (!event-&gt;in &amp;&amp; WindowContext::sm_grab_window == this) {
 336         ungrab_focus();
 337     }
 338 
 339     if (xim.enabled &amp;&amp; xim.ic) {
 340         if (event-&gt;in) {
 341             XSetICFocus(xim.ic);
 342         } else {
 343             XUnsetICFocus(xim.ic);
 344         }
 345     }
 346 
</pre>
<hr />
<pre>
 359 
 360 void WindowContext::process_property_notify(GdkEventProperty *event) {
 361     if (event-&gt;window == gdk_window) {
 362         if (event-&gt;atom == atom_net_wm_state) {
 363             process_net_wm_property();
 364         } else if (event-&gt;atom == atom_net_wm_frame_extents) {
 365             if (frame_type != TITLED) {
 366                 return;
 367             }
 368 
 369             int top, left, bottom, right;
 370 
 371             if (get_frame_extents_property(&amp;top, &amp;left, &amp;bottom, &amp;right)) {
 372                 if (top + left + bottom + right &gt; 0) {
 373                     geometry.frame_extents_received = true;
 374                     geometry.adjust_w = left + right;
 375                     geometry.adjust_h = top + bottom;
 376                     geometry.view_x = left;
 377                     geometry.view_y = top;
 378 
<span class="line-removed"> 379                     save_cached_extents();</span>
<span class="line-removed"> 380 </span>
 381                     // set bounds again to set to correct window size that must
 382                     // be the total width and height accounting extents
 383                     // this is ignored if size is &quot;content size&quot; instead of &quot;window size&quot;
 384                     if (geometry.window_size_set) {
 385                         set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);
 386                     }
 387 
 388                     // force position notify so java will know about view_y and view_x
 389                     size_position_notify(false, true);
 390                 }
 391             }
 392         }
 393     }
 394 }
 395 
 396 void WindowContext::process_configure() {
 397     calculate_adjustments();
 398 
 399     gint x, y, w, h, gtk_w, gtk_h;
 400 
</pre>
<hr />
<pre>
1188     --events_processing_cnt;
1189 }
1190 
1191 size_t WindowContext::get_events_count() {
1192     return events_processing_cnt;
1193 }
1194 
1195 ///////////////////////// PROTECTED
1196 
1197 void WindowContext::applyShapeMask(void *data, uint width, uint height) {
1198     if (frame_type != TRANSPARENT) {
1199         return;
1200     }
1201 
1202     glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
1203 }
1204 
1205 ///////////////////////// PRIVATE
1206 
1207 // This function calculate the deltas between window and window + decoration (titleblar, borders).
<span class="line-modified">1208 // It&#39;s used when frame extents are not yet received or when the window manager does not support</span>
<span class="line-removed">1209 // the _NET_FRAME_EXTENTS extension. Gdk functions are based on frame extents but will try harder</span>
<span class="line-removed">1210 // if it&#39;s not available.</span>
1211 void WindowContext::calculate_adjustments() {
<span class="line-modified">1212     if (frame_type != TITLED || geometry.frame_extents_received) {</span>

1213         return;
1214     }
1215 
<span class="line-modified">1216     gint x, y;</span>
1217     gdk_window_get_origin(gdk_window, &amp;x, &amp;y);
<span class="line-removed">1218 </span>
<span class="line-removed">1219     gint rx, ry;</span>
1220     gdk_window_get_root_origin(gdk_window, &amp;rx, &amp;ry);
1221 
1222     if (rx != x || ry != y) {
1223         // the left extends are correct - the right one is guessed to be the same
1224         geometry.adjust_w = (x - rx) * 2;
1225         // guess that bottom size is the same as left and right
1226         geometry.adjust_h = (y - ry) + (x - rx);
1227 
1228         // those will be correct
1229         geometry.view_x = (x - rx);
1230         geometry.view_y = (y - ry);
1231 
<span class="line-modified">1232         save_cached_extents();</span>
<span class="line-modified">1233     } else {</span>
<span class="line-modified">1234         CachedExtents c = (window_type == NORMAL) ? normal_extents : utility_extents;</span>
<span class="line-removed">1235         geometry.adjust_w = c.adjust_w;</span>
<span class="line-removed">1236         geometry.adjust_h = c.adjust_h;</span>
<span class="line-removed">1237         geometry.view_x = c.view_x;</span>
<span class="line-removed">1238         geometry.view_y = c.view_y;</span>
<span class="line-removed">1239     }</span>
<span class="line-removed">1240 </span>
<span class="line-removed">1241     apply_geometry();</span>
<span class="line-removed">1242 }</span>
<span class="line-removed">1243 </span>
<span class="line-removed">1244 void WindowContext::save_cached_extents() {</span>
<span class="line-removed">1245     if (frame_type != TITLED) {</span>
<span class="line-removed">1246         return;</span>
<span class="line-removed">1247     }</span>
1248 
<span class="line-modified">1249     if (window_type == NORMAL) {</span>
<span class="line-modified">1250         normal_extents.adjust_w = geometry.adjust_w;</span>
<span class="line-removed">1251         normal_extents.adjust_h = geometry.adjust_h;</span>
<span class="line-removed">1252         normal_extents.view_x = geometry.view_x;</span>
<span class="line-removed">1253         normal_extents.view_y = geometry.view_y;</span>
<span class="line-removed">1254     } else {</span>
<span class="line-removed">1255         utility_extents.adjust_w = geometry.adjust_w;</span>
<span class="line-removed">1256         utility_extents.adjust_h = geometry.adjust_h;</span>
<span class="line-removed">1257         utility_extents.view_x = geometry.view_x;</span>
<span class="line-removed">1258         utility_extents.view_y = geometry.view_y;</span>
1259     }
1260 }
1261 
1262 void WindowContext::apply_geometry() {
1263     if (!map_received) {
1264         return;
1265     }
1266 
1267     GdkGeometry gdk_geometry;
1268     gdk_geometry.win_gravity = GDK_GRAVITY_NORTH_WEST;
1269 
1270     if ((!geometry.resizable || !geometry.enabled) &amp;&amp; !(is_maximized || is_fullscreen)) {
1271         // not resizeable
1272         int w = (geometry.current_w - geometry.adjust_w) &gt; 0
1273                 ? geometry.current_w - geometry.adjust_w
1274                 : geometry.current_cw;
1275 
1276         int h = (geometry.current_h - geometry.adjust_h) &gt; 0
1277                 ? geometry.current_h - geometry.adjust_h
1278                 : geometry.current_ch;
</pre>
</td>
<td>
<hr />
<pre>
 219     gtk_widget_set_events(gtk_widget, GDK_ALL_EVENTS_MASK);
 220     gtk_widget_set_app_paintable(gtk_widget, TRUE);
 221 
 222     glass_gtk_configure_transparency_and_realize(gtk_widget, frame_type == TRANSPARENT);
 223     gtk_window_set_title(GTK_WINDOW(gtk_widget), &quot;&quot;);
 224 
 225     gdk_window = gtk_widget_get_window(gtk_widget);
 226     g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
 227 
 228     glass_dnd_attach_context(this);
 229 
 230     gdk_windowManagerFunctions = wmf;
 231     if (wmf) {
 232         gdk_window_set_functions(gdk_window, wmf);
 233     }
 234 
 235     if (frame_type != TITLED) {
 236         gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);
 237     }
 238 
<span class="line-added"> 239     geometry.frame_extents_supported = gdk_x11_screen_supports_net_wm_hint(gdk_screen_get_default(),</span>
<span class="line-added"> 240                                                                            atom_net_wm_frame_extents);</span>
<span class="line-added"> 241 </span>
 242     connect_signals(gtk_widget, this);
 243 }
 244 
 245 void WindowContext::paint(void *data, jint width, jint height) {
 246 #if GTK_CHECK_VERSION(3, 0, 0)
 247     cairo_region_t *region = gdk_window_get_clip_region(gdk_window);
 248 #if GTK_CHECK_VERSION(3, 22, 0)
 249     GdkDrawingContext *dcontext = gdk_window_begin_draw_frame(gdk_window, region);
 250     cairo_t *context = gdk_drawing_context_get_cairo_context(dcontext);
 251 #else
 252     gdk_window_begin_paint_region(gdk_window, region);
 253     cairo_t* context = gdk_cairo_create(gdk_window);
 254 #endif
 255 #else
 256     cairo_t *context = gdk_cairo_create(gdk_window);
 257 #endif
 258 
 259     if (bg_color.is_set) {
 260         cairo_set_source_rgba(context, bg_color.red, bg_color.green, bg_color.blue,
 261                                 (frame_type == TRANSPARENT) ? 0 : 1);
</pre>
<hr />
<pre>
 310 }
 311 
 312 GtkWindow *WindowContext::get_gtk_window() {
 313     return GTK_WINDOW(gtk_widget);
 314 }
 315 
 316 WindowGeometry WindowContext::get_geometry() {
 317     return geometry;
 318 }
 319 
 320 jobject WindowContext::get_jwindow() {
 321     return jwindow;
 322 }
 323 
 324 jobject WindowContext::get_jview() {
 325     return jview;
 326 }
 327 
 328 void WindowContext::process_map() {
 329     map_received = true;
<span class="line-added"> 330     calculate_adjustments();</span>
 331     apply_geometry();
 332 }
 333 
 334 void WindowContext::process_focus(GdkEventFocus *event) {
 335     if (!event-&gt;in &amp;&amp; WindowContext::sm_mouse_drag_window == this) {
 336         ungrab_mouse_drag_focus();
 337     }
 338 
 339     if (!event-&gt;in &amp;&amp; WindowContext::sm_grab_window == this) {
 340         ungrab_focus();
 341     }
 342 
 343     if (xim.enabled &amp;&amp; xim.ic) {
 344         if (event-&gt;in) {
 345             XSetICFocus(xim.ic);
 346         } else {
 347             XUnsetICFocus(xim.ic);
 348         }
 349     }
 350 
</pre>
<hr />
<pre>
 363 
 364 void WindowContext::process_property_notify(GdkEventProperty *event) {
 365     if (event-&gt;window == gdk_window) {
 366         if (event-&gt;atom == atom_net_wm_state) {
 367             process_net_wm_property();
 368         } else if (event-&gt;atom == atom_net_wm_frame_extents) {
 369             if (frame_type != TITLED) {
 370                 return;
 371             }
 372 
 373             int top, left, bottom, right;
 374 
 375             if (get_frame_extents_property(&amp;top, &amp;left, &amp;bottom, &amp;right)) {
 376                 if (top + left + bottom + right &gt; 0) {
 377                     geometry.frame_extents_received = true;
 378                     geometry.adjust_w = left + right;
 379                     geometry.adjust_h = top + bottom;
 380                     geometry.view_x = left;
 381                     geometry.view_y = top;
 382 


 383                     // set bounds again to set to correct window size that must
 384                     // be the total width and height accounting extents
 385                     // this is ignored if size is &quot;content size&quot; instead of &quot;window size&quot;
 386                     if (geometry.window_size_set) {
 387                         set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);
 388                     }
 389 
 390                     // force position notify so java will know about view_y and view_x
 391                     size_position_notify(false, true);
 392                 }
 393             }
 394         }
 395     }
 396 }
 397 
 398 void WindowContext::process_configure() {
 399     calculate_adjustments();
 400 
 401     gint x, y, w, h, gtk_w, gtk_h;
 402 
</pre>
<hr />
<pre>
1190     --events_processing_cnt;
1191 }
1192 
1193 size_t WindowContext::get_events_count() {
1194     return events_processing_cnt;
1195 }
1196 
1197 ///////////////////////// PROTECTED
1198 
1199 void WindowContext::applyShapeMask(void *data, uint width, uint height) {
1200     if (frame_type != TRANSPARENT) {
1201         return;
1202     }
1203 
1204     glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
1205 }
1206 
1207 ///////////////////////// PRIVATE
1208 
1209 // This function calculate the deltas between window and window + decoration (titleblar, borders).
<span class="line-modified">1210 // It&#39;s used when the window manager does not support the _NET_FRAME_EXTENTS extension.</span>


1211 void WindowContext::calculate_adjustments() {
<span class="line-modified">1212     // if WM supports _NET_FRAME_EXTENTS, wait for it</span>
<span class="line-added">1213     if (frame_type != TITLED || geometry.frame_extents_supported) {</span>
1214         return;
1215     }
1216 
<span class="line-modified">1217     gint x, y, rx, ry;</span>
1218     gdk_window_get_origin(gdk_window, &amp;x, &amp;y);


1219     gdk_window_get_root_origin(gdk_window, &amp;rx, &amp;ry);
1220 
1221     if (rx != x || ry != y) {
1222         // the left extends are correct - the right one is guessed to be the same
1223         geometry.adjust_w = (x - rx) * 2;
1224         // guess that bottom size is the same as left and right
1225         geometry.adjust_h = (y - ry) + (x - rx);
1226 
1227         // those will be correct
1228         geometry.view_x = (x - rx);
1229         geometry.view_y = (y - ry);
1230 
<span class="line-modified">1231         if (geometry.window_size_set) {</span>
<span class="line-modified">1232             set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);</span>
<span class="line-modified">1233         }</span>













1234 
<span class="line-modified">1235         // force position notify so java will know about view_y and view_x</span>
<span class="line-modified">1236         size_position_notify(false, true);</span>








1237     }
1238 }
1239 
1240 void WindowContext::apply_geometry() {
1241     if (!map_received) {
1242         return;
1243     }
1244 
1245     GdkGeometry gdk_geometry;
1246     gdk_geometry.win_gravity = GDK_GRAVITY_NORTH_WEST;
1247 
1248     if ((!geometry.resizable || !geometry.enabled) &amp;&amp; !(is_maximized || is_fullscreen)) {
1249         // not resizeable
1250         int w = (geometry.current_w - geometry.adjust_w) &gt; 0
1251                 ? geometry.current_w - geometry.adjust_w
1252                 : geometry.current_cw;
1253 
1254         int h = (geometry.current_h - geometry.adjust_h) &gt; 0
1255                 ? geometry.current_h - geometry.adjust_h
1256                 : geometry.current_ch;
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_window.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
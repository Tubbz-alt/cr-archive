<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_window.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 395 void WindowContext::process_configure() {
 396     gint x, y, w, h, gtk_w, gtk_h;
 397 
 398     gtk_window_get_position(GTK_WINDOW(gtk_widget), &amp;x, &amp;y);
 399     gtk_window_get_size(GTK_WINDOW(gtk_widget), &amp;gtk_w, &amp;gtk_h);
 400 
 401     w = gtk_w + geometry.adjust_w;
 402     h = gtk_h + geometry.adjust_h;
 403 
 404     gboolean pos_changed = geometry.current_x != x || geometry.current_y != y;
 405     gboolean size_changed = geometry.current_w != w || geometry.current_h != h
 406                             || geometry.current_cw != gtk_w || geometry.current_ch != gtk_h;
 407 
 408     geometry.current_x = x;
 409     geometry.current_y = y;
 410     geometry.current_w = w;
 411     geometry.current_h = h;
 412     geometry.current_cw = gtk_w;
 413     geometry.current_ch = gtk_h;
 414 





 415     size_position_notify(size_changed, pos_changed);
 416 }
 417 
 418 void WindowContext::process_destroy() {
 419     if (owner) {
 420         owner-&gt;remove_child(this);
 421     }
 422 
 423     if (WindowContext::sm_mouse_drag_window == this) {
 424         ungrab_mouse_drag_focus();
 425     }
 426 
 427     if (WindowContext::sm_grab_window == this) {
 428         ungrab_focus();
 429     }
 430 
 431     std::set&lt;WindowContext *&gt;::iterator it;
 432     for (it = children.begin(); it != children.end(); ++it) {
 433         // FIX JDK-8226537: this method calls set_owner(NULL) which prevents
 434         // WindowContext::process_destroy() to call remove_child() (because children
</pre>
<hr />
<pre>
 950             // in this case - the window manager will not support the programatic
 951             // request to iconify - so we need to disable this until we are restored.
 952             GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MINIMIZE);
 953             gdk_window_set_functions(gdk_window, wmf);
 954         }
 955         gtk_window_iconify(GTK_WINDOW(gtk_widget));
 956     } else {
 957         gtk_window_deiconify(GTK_WINDOW(gtk_widget));
 958         activate_window();
 959     }
 960 }
 961 
 962 void WindowContext::set_maximized(bool maximize) {
 963     is_maximized = maximize;
 964 
 965     if (maximize) {
 966         // enable the functionality
 967         GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);
 968         gdk_window_set_functions(gdk_window, wmf);
 969 

 970         gtk_window_maximize(GTK_WINDOW(gtk_widget));
 971     } else {
 972         gtk_window_unmaximize(GTK_WINDOW(gtk_widget));
 973     }
 974 }
 975 
 976 void WindowContext::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
 977     // this will tell if adjustments are needed - that&#39;s because GTK does not have full window size
 978     // values, just content values. Frame extents (window decorations) are handled by the window manager.
 979     geometry.needs_ajustment = (w &gt; 0 || h &gt; 0) || geometry.needs_ajustment;
 980 
 981     // newW / newH always content sizes compatible with GTK+
 982     // if window has no decoration, adjustments will be ZERO
 983     // this will always be content size
 984     int newW, newH;
 985     if (w &gt; 0) {
 986         newW = w - geometry.adjust_w;
 987         geometry.current_w = newW;
 988     } else {
 989         newW = cw;
 990     }
 991 
 992     if (h &gt; 0) {
 993         newH = h - geometry.adjust_h;
 994         geometry.current_h = newH;
 995     } else {
 996         newH = ch;
 997     }
 998 
 999     gboolean size_changed = FALSE;
1000     gboolean pos_changed = FALSE;
1001 
1002     if (newW &gt; 0 &amp;&amp; newH &gt; 0) {
1003         size_changed = TRUE;
1004 
1005         // content size
1006         geometry.current_cw = newW;
1007         geometry.current_ch = newH;


1008 
1009         if (visible_received) {
1010             // call apply_geometry() to let gtk_window_resize succeed, because it&#39;s bound to
1011             // geometry constraints
1012             apply_geometry();
1013             gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);
1014         } else {
1015             gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);
1016         }
1017     }
1018 
1019     if (xSet || ySet) {
1020         int newX = (xSet) ? x : geometry.current_x;
1021         int newY = (ySet) ? y : geometry.current_y;
1022 
1023         if (newX != geometry.current_x || newY != geometry.current_y) {
1024             pos_changed = TRUE;
1025             geometry.current_x = newX;
1026             geometry.current_y = newY;
1027             gtk_window_move(GTK_WINDOW(gtk_widget), newX, newY);
</pre>
<hr />
<pre>
1155         CHECK_JNI_EXCEPTION(mainEnv)
1156     }
1157 }
1158 
1159 void WindowContext::restack(bool restack) {
1160     gdk_window_restack(gdk_window, NULL, restack ? TRUE : FALSE);
1161 }
1162 
1163 void WindowContext::request_focus() {
1164     //JDK-8212060: Window show and then move glitch.
1165     //The WindowContext::set_visible will take care of showing the window.
1166     //The below code will only handle later request_focus.
1167     if (is_visible()) {
1168         gtk_window_present(GTK_WINDOW(gtk_widget));
1169     }
1170 }
1171 
1172 void WindowContext::enter_fullscreen() {
1173     is_fullscreen = TRUE;
1174 
<span class="line-modified">1175 // workaround gtk+ bug</span>
<span class="line-removed">1176 #if !GTK_CHECK_VERSION(3, 22, 0)</span>
<span class="line-removed">1177     // this is content size</span>
<span class="line-removed">1178     geometry.unfullscreen_w = geometry.current_cw;</span>
<span class="line-removed">1179     geometry.unfullscreen_h = geometry.current_ch;</span>
<span class="line-removed">1180 #endif</span>
<span class="line-removed">1181 </span>
1182     gtk_window_fullscreen(GTK_WINDOW(gtk_widget));
1183 }
1184 
1185 void WindowContext::exit_fullscreen() {
1186     is_fullscreen = FALSE;
1187     gtk_window_unfullscreen(GTK_WINDOW(gtk_widget));
<span class="line-removed">1188 </span>
<span class="line-removed">1189 // It was a Gtk+ that got fixed</span>
<span class="line-removed">1190 #if !GTK_CHECK_VERSION(3, 22, 0)</span>
<span class="line-removed">1191     set_bounds(0, 0, false, false, -1, -1, geometry.unfullscreen_w, geometry.unfullscreen_h);</span>
<span class="line-removed">1192 #endif</span>
1193 }
1194 
1195 // Applied to a temporary full screen window to prevent sending events to Java
1196 void WindowContext::detach_from_java() {
1197     if (jview) {
1198         mainEnv-&gt;DeleteGlobalRef(jview);
1199         jview = NULL;
1200     }
1201     if (jwindow) {
1202         mainEnv-&gt;DeleteGlobalRef(jwindow);
1203         jwindow = NULL;
1204     }
1205 }
1206 
1207 void WindowContext::increment_events_counter() {
1208     ++events_processing_cnt;
1209 }
1210 
1211 void WindowContext::decrement_events_counter() {
1212     --events_processing_cnt;
1213 }
1214 
1215 size_t WindowContext::get_events_count() {
1216     return events_processing_cnt;
1217 }
1218 
1219 ///////////////////////// PROTECTED
1220 
1221 void WindowContext::applyShapeMask(void *data, uint width, uint height) {
1222     if (frame_type != TRANSPARENT) {
1223         return;
1224     }
1225 
1226     glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
1227 }
1228 
1229 ///////////////////////// PRIVATE
1230 
















1231 // This function calculate the deltas between window and window + decoration (titlebar, borders).
1232 // It&#39;s used when the window manager does not support the _NET_FRAME_EXTENTS extension or when
1233 // it&#39;s not received on time.
1234 void WindowContext::calculate_adjustments() {
1235     if (frame_type != TITLED || geometry.frame_extents_received) {
1236         return;
1237     }
1238 
1239     gint x, y, rx, ry;
1240     gdk_window_get_origin(gdk_window, &amp;x, &amp;y);
1241     gdk_window_get_root_origin(gdk_window, &amp;rx, &amp;ry);
1242 
1243     if (rx != x || ry != y) {
1244         // the left extends are correct - the right one is guessed to be the same
1245         geometry.adjust_w = (x - rx) * 2;
1246         // guess that bottom size is the same as left and right
1247         geometry.adjust_h = (y - ry) + (x - rx);
1248 
1249         // those will be correct
1250         geometry.view_x = (x - rx);
</pre>
</td>
<td>
<hr />
<pre>
 395 void WindowContext::process_configure() {
 396     gint x, y, w, h, gtk_w, gtk_h;
 397 
 398     gtk_window_get_position(GTK_WINDOW(gtk_widget), &amp;x, &amp;y);
 399     gtk_window_get_size(GTK_WINDOW(gtk_widget), &amp;gtk_w, &amp;gtk_h);
 400 
 401     w = gtk_w + geometry.adjust_w;
 402     h = gtk_h + geometry.adjust_h;
 403 
 404     gboolean pos_changed = geometry.current_x != x || geometry.current_y != y;
 405     gboolean size_changed = geometry.current_w != w || geometry.current_h != h
 406                             || geometry.current_cw != gtk_w || geometry.current_ch != gtk_h;
 407 
 408     geometry.current_x = x;
 409     geometry.current_y = y;
 410     geometry.current_w = w;
 411     geometry.current_h = h;
 412     geometry.current_cw = gtk_w;
 413     geometry.current_ch = gtk_h;
 414 
<span class="line-added"> 415     if (!is_fullscreen &amp;&amp; !is_maximized) {</span>
<span class="line-added"> 416         geometry.last_cw = gtk_w;</span>
<span class="line-added"> 417         geometry.last_ch = gtk_h;</span>
<span class="line-added"> 418     }</span>
<span class="line-added"> 419 </span>
 420     size_position_notify(size_changed, pos_changed);
 421 }
 422 
 423 void WindowContext::process_destroy() {
 424     if (owner) {
 425         owner-&gt;remove_child(this);
 426     }
 427 
 428     if (WindowContext::sm_mouse_drag_window == this) {
 429         ungrab_mouse_drag_focus();
 430     }
 431 
 432     if (WindowContext::sm_grab_window == this) {
 433         ungrab_focus();
 434     }
 435 
 436     std::set&lt;WindowContext *&gt;::iterator it;
 437     for (it = children.begin(); it != children.end(); ++it) {
 438         // FIX JDK-8226537: this method calls set_owner(NULL) which prevents
 439         // WindowContext::process_destroy() to call remove_child() (because children
</pre>
<hr />
<pre>
 955             // in this case - the window manager will not support the programatic
 956             // request to iconify - so we need to disable this until we are restored.
 957             GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MINIMIZE);
 958             gdk_window_set_functions(gdk_window, wmf);
 959         }
 960         gtk_window_iconify(GTK_WINDOW(gtk_widget));
 961     } else {
 962         gtk_window_deiconify(GTK_WINDOW(gtk_widget));
 963         activate_window();
 964     }
 965 }
 966 
 967 void WindowContext::set_maximized(bool maximize) {
 968     is_maximized = maximize;
 969 
 970     if (maximize) {
 971         // enable the functionality
 972         GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);
 973         gdk_window_set_functions(gdk_window, wmf);
 974 
<span class="line-added"> 975         ensure_window_size();</span>
 976         gtk_window_maximize(GTK_WINDOW(gtk_widget));
 977     } else {
 978         gtk_window_unmaximize(GTK_WINDOW(gtk_widget));
 979     }
 980 }
 981 
 982 void WindowContext::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
 983     // this will tell if adjustments are needed - that&#39;s because GTK does not have full window size
 984     // values, just content values. Frame extents (window decorations) are handled by the window manager.
 985     geometry.needs_ajustment = (w &gt; 0 || h &gt; 0) || geometry.needs_ajustment;
 986 
 987     // newW / newH always content sizes compatible with GTK+
 988     // if window has no decoration, adjustments will be ZERO
 989     // this will always be content size
 990     int newW, newH;
 991     if (w &gt; 0) {
 992         newW = w - geometry.adjust_w;
 993         geometry.current_w = newW;
 994     } else {
 995         newW = cw;
 996     }
 997 
 998     if (h &gt; 0) {
 999         newH = h - geometry.adjust_h;
1000         geometry.current_h = newH;
1001     } else {
1002         newH = ch;
1003     }
1004 
1005     gboolean size_changed = FALSE;
1006     gboolean pos_changed = FALSE;
1007 
1008     if (newW &gt; 0 &amp;&amp; newH &gt; 0) {
1009         size_changed = TRUE;
1010 
1011         // content size
1012         geometry.current_cw = newW;
1013         geometry.current_ch = newH;
<span class="line-added">1014         geometry.last_cw = newW;</span>
<span class="line-added">1015         geometry.last_ch = newH;</span>
1016 
1017         if (visible_received) {
1018             // call apply_geometry() to let gtk_window_resize succeed, because it&#39;s bound to
1019             // geometry constraints
1020             apply_geometry();
1021             gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);
1022         } else {
1023             gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);
1024         }
1025     }
1026 
1027     if (xSet || ySet) {
1028         int newX = (xSet) ? x : geometry.current_x;
1029         int newY = (ySet) ? y : geometry.current_y;
1030 
1031         if (newX != geometry.current_x || newY != geometry.current_y) {
1032             pos_changed = TRUE;
1033             geometry.current_x = newX;
1034             geometry.current_y = newY;
1035             gtk_window_move(GTK_WINDOW(gtk_widget), newX, newY);
</pre>
<hr />
<pre>
1163         CHECK_JNI_EXCEPTION(mainEnv)
1164     }
1165 }
1166 
1167 void WindowContext::restack(bool restack) {
1168     gdk_window_restack(gdk_window, NULL, restack ? TRUE : FALSE);
1169 }
1170 
1171 void WindowContext::request_focus() {
1172     //JDK-8212060: Window show and then move glitch.
1173     //The WindowContext::set_visible will take care of showing the window.
1174     //The below code will only handle later request_focus.
1175     if (is_visible()) {
1176         gtk_window_present(GTK_WINDOW(gtk_widget));
1177     }
1178 }
1179 
1180 void WindowContext::enter_fullscreen() {
1181     is_fullscreen = TRUE;
1182 
<span class="line-modified">1183     ensure_window_size();</span>






1184     gtk_window_fullscreen(GTK_WINDOW(gtk_widget));
1185 }
1186 
1187 void WindowContext::exit_fullscreen() {
1188     is_fullscreen = FALSE;
1189     gtk_window_unfullscreen(GTK_WINDOW(gtk_widget));





1190 }
1191 
1192 // Applied to a temporary full screen window to prevent sending events to Java
1193 void WindowContext::detach_from_java() {
1194     if (jview) {
1195         mainEnv-&gt;DeleteGlobalRef(jview);
1196         jview = NULL;
1197     }
1198     if (jwindow) {
1199         mainEnv-&gt;DeleteGlobalRef(jwindow);
1200         jwindow = NULL;
1201     }
1202 }
1203 
1204 void WindowContext::increment_events_counter() {
1205     ++events_processing_cnt;
1206 }
1207 
1208 void WindowContext::decrement_events_counter() {
1209     --events_processing_cnt;
1210 }
1211 
1212 size_t WindowContext::get_events_count() {
1213     return events_processing_cnt;
1214 }
1215 
1216 ///////////////////////// PROTECTED
1217 
1218 void WindowContext::applyShapeMask(void *data, uint width, uint height) {
1219     if (frame_type != TRANSPARENT) {
1220         return;
1221     }
1222 
1223     glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
1224 }
1225 
1226 ///////////////////////// PRIVATE
1227 
<span class="line-added">1228 // this is to work-around past gtk+ bug</span>
<span class="line-added">1229 void WindowContext::ensure_window_size() {</span>
<span class="line-added">1230 #if !GTK_CHECK_VERSION(3, 22, 30)</span>
<span class="line-added">1231     gint w, h;</span>
<span class="line-added">1232 #ifdef GLASS_GTK3</span>
<span class="line-added">1233     gdk_window_get_geometry(gdk_window, NULL, NULL, &amp;w, &amp;h);</span>
<span class="line-added">1234 #else</span>
<span class="line-added">1235     gdk_window_get_geometry(gdk_window, NULL, NULL, &amp;w, &amp;h, NULL);</span>
<span class="line-added">1236 #endif</span>
<span class="line-added">1237     if ((geometry.last_cw &gt; 0 &amp;&amp; geometry.last_ch &gt; 0)</span>
<span class="line-added">1238         &amp;&amp; (geometry.last_cw != w || geometry.last_ch != h)) {</span>
<span class="line-added">1239         gdk_window_resize(gdk_window, geometry.last_cw, geometry.last_ch);</span>
<span class="line-added">1240     }</span>
<span class="line-added">1241 #endif</span>
<span class="line-added">1242 }</span>
<span class="line-added">1243 </span>
1244 // This function calculate the deltas between window and window + decoration (titlebar, borders).
1245 // It&#39;s used when the window manager does not support the _NET_FRAME_EXTENTS extension or when
1246 // it&#39;s not received on time.
1247 void WindowContext::calculate_adjustments() {
1248     if (frame_type != TITLED || geometry.frame_extents_received) {
1249         return;
1250     }
1251 
1252     gint x, y, rx, ry;
1253     gdk_window_get_origin(gdk_window, &amp;x, &amp;y);
1254     gdk_window_get_root_origin(gdk_window, &amp;rx, &amp;ry);
1255 
1256     if (rx != x || ry != y) {
1257         // the left extends are correct - the right one is guessed to be the same
1258         geometry.adjust_w = (x - rx) * 2;
1259         // guess that bottom size is the same as left and right
1260         geometry.adjust_h = (y - ry) + (x - rx);
1261 
1262         // those will be correct
1263         geometry.view_x = (x - rx);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_window.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
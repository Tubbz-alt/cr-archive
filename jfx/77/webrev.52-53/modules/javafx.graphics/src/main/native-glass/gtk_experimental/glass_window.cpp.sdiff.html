<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-glass/gtk_experimental/glass_window.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="glass_screen.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>modules/javafx.graphics/src/main/native-glass/gtk_experimental/glass_window.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 224     gtk_window_set_title(GTK_WINDOW(gtk_widget), &quot;&quot;);
 225 
 226     gdk_window = gtk_widget_get_window(gtk_widget);
 227     g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
 228 
 229     glass_dnd_attach_context(this);
 230 
 231     gdk_windowManagerFunctions = wmf;
 232     if (wmf) {
 233         gdk_window_set_functions(gdk_window, wmf);
 234     }
 235 
 236     if (frame_type != TITLED) {
 237         gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);
 238     }
 239 
 240     connect_signals(gtk_widget, this);
 241 }
 242 
 243 void WindowContext::paint(void *data, jint width, jint height) {
<span class="line-modified"> 244 #if GTK_CHECK_VERSION(3, 0, 0)</span>
 245     cairo_region_t *region = gdk_window_get_clip_region(gdk_window);
<span class="line-removed"> 246 #if GTK_CHECK_VERSION(3, 22, 0)</span>
<span class="line-removed"> 247     GdkDrawingContext *dcontext = gdk_window_begin_draw_frame(gdk_window, region);</span>
<span class="line-removed"> 248     cairo_t *context = gdk_drawing_context_get_cairo_context(dcontext);</span>
<span class="line-removed"> 249 #else</span>
 250     gdk_window_begin_paint_region(gdk_window, region);
 251     cairo_t* context = gdk_cairo_create(gdk_window);
<span class="line-removed"> 252 #endif</span>
 253 #else
 254     cairo_t *context = gdk_cairo_create(gdk_window);
 255 #endif
 256 
 257     if (bg_color.is_set) {
 258         cairo_set_source_rgba(context, bg_color.red, bg_color.green, bg_color.blue,
 259                                 (frame_type == TRANSPARENT) ? 0 : 1);
 260         cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);
 261         cairo_paint(context);
 262     }
 263 
 264     cairo_surface_t *cairo_surface;
 265     cairo_surface = cairo_image_surface_create_for_data(
 266             (unsigned char *) data,
 267             CAIRO_FORMAT_ARGB32,
 268             width, height, width * 4);
 269 
 270     cairo_set_source_surface(context, cairo_surface, 0, 0);
 271 
 272     applyShapeMask(data, width, height);
 273     cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);
 274     cairo_paint(context);
 275 
<span class="line-modified"> 276 #if GTK_CHECK_VERSION(3, 0, 0)</span>
<span class="line-removed"> 277 #if GTK_CHECK_VERSION(3, 22, 0)</span>
<span class="line-removed"> 278     gdk_window_end_draw_frame(gdk_window, dcontext);</span>
<span class="line-removed"> 279     cairo_region_destroy(region);</span>
<span class="line-removed"> 280 #else</span>
 281     gdk_window_end_paint(gdk_window);
 282     cairo_region_destroy(region);
 283     cairo_destroy(context);
<span class="line-removed"> 284 #endif</span>
 285 #else
 286     cairo_destroy(context);
 287 #endif
 288 
 289     cairo_surface_destroy(cairo_surface);
 290 }
 291 
 292 bool WindowContext::isEnabled() {
 293     if (jwindow) {
 294         bool result = (JNI_TRUE == mainEnv-&gt;CallBooleanMethod(jwindow, jWindowIsEnabled));
 295         LOG_EXCEPTION(mainEnv)
 296         return result;
 297     } else {
 298         return false;
 299     }
 300 }
 301 
 302 GdkWindow *WindowContext::get_gdk_window() {
 303     return gdk_window;
 304 }
</pre>
<hr />
<pre>
1209 }
1210 
1211 size_t WindowContext::get_events_count() {
1212     return events_processing_cnt;
1213 }
1214 
1215 ///////////////////////// PROTECTED
1216 
1217 void WindowContext::applyShapeMask(void *data, uint width, uint height) {
1218     if (frame_type != TRANSPARENT) {
1219         return;
1220     }
1221 
1222     glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
1223 }
1224 
1225 ///////////////////////// PRIVATE
1226 
1227 // this is to work-around past gtk+ bug
1228 void WindowContext::ensure_window_size() {
<span class="line-removed">1229 #if !GTK_CHECK_VERSION(3, 22, 30)</span>
1230     gint w, h;
1231 #ifdef GLASS_GTK3
1232     gdk_window_get_geometry(gdk_window, NULL, NULL, &amp;w, &amp;h);
1233 #else
1234     gdk_window_get_geometry(gdk_window, NULL, NULL, &amp;w, &amp;h, NULL);
1235 #endif
1236     if ((geometry.last_cw &gt; 0 &amp;&amp; geometry.last_ch &gt; 0)
1237         &amp;&amp; (geometry.last_cw != w || geometry.last_ch != h)) {
1238         gdk_window_resize(gdk_window, geometry.last_cw, geometry.last_ch);
1239     }
<span class="line-removed">1240 #endif</span>
1241 }
1242 
1243 // This function calculate the deltas between window and window + decoration (titlebar, borders).
1244 // It&#39;s used when the window manager does not support the _NET_FRAME_EXTENTS extension or when
1245 // it&#39;s not received on time.
1246 void WindowContext::calculate_adjustments() {
1247     if (frame_type != TITLED || geometry.frame_extents_received) {
1248         return;
1249     }
1250 
1251     gint x, y, rx, ry;
1252     gdk_window_get_origin(gdk_window, &amp;x, &amp;y);
1253     gdk_window_get_root_origin(gdk_window, &amp;rx, &amp;ry);
1254 
1255     if (rx != x || ry != y) {
1256         // the left extends are correct - the right one is guessed to be the same
1257         geometry.adjust_w = (x - rx) * 2;
1258         // guess that bottom size is the same as left and right
1259         geometry.adjust_h = (y - ry) + (x - rx);
1260 
</pre>
<hr />
<pre>
1407     }
1408     return false;
1409 }
1410 
1411 bool WindowContext::effective_on_top() {
1412     if (owner) {
1413         WindowContext *topO = dynamic_cast&lt;WindowContext *&gt;(owner);
1414         return (topO &amp;&amp; topO-&gt;effective_on_top()) || on_top;
1415     }
1416     return on_top;
1417 }
1418 
1419 bool WindowContext::grab_mouse_drag_focus(GdkWindow * gdk_w, GdkEvent * event, GdkCursor * cursor, bool owner_events) {
1420     if (is_grab_disabled()) {
1421         return true;
1422     }
1423 
1424     ungrab_mouse_drag_focus();
1425 
1426 #ifdef GLASS_GTK3
<span class="line-removed">1427 #if GTK_CHECK_VERSION(3, 20, 0)</span>
<span class="line-removed">1428     if (event != NULL) {</span>
<span class="line-removed">1429         grab_pointer = gdk_event_get_seat(event);</span>
<span class="line-removed">1430     } else {</span>
<span class="line-removed">1431         grab_pointer = gdk_display_get_default_seat(gtk_widget_get_display(gtk_widget));</span>
<span class="line-removed">1432     }</span>
<span class="line-removed">1433 </span>
<span class="line-removed">1434     GdkGrabStatus status = gdk_seat_grab((GdkSeat *) grab_pointer, gdk_w,</span>
<span class="line-removed">1435                                           GDK_SEAT_CAPABILITY_POINTER, owner_events, cursor, NULL, NULL, NULL);</span>
<span class="line-removed">1436 #else</span>
1437     if (event != NULL) {
1438         grab_pointer = gdk_event_get_device (event);
1439     } else {
1440         grab_pointer = gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gtk_widget_get_display(gtk_widget)));
1441     }
1442 
1443     GdkGrabStatus status = gdk_device_grab((GdkDevice *) grab_pointer, gdk_w, GDK_OWNERSHIP_WINDOW, owner_events,
1444                                                 (GdkEventMask)
1445                                                       (GDK_POINTER_MOTION_MASK
1446                                                           | GDK_POINTER_MOTION_HINT_MASK
1447                                                           | GDK_BUTTON_MOTION_MASK
1448                                                           | GDK_BUTTON1_MOTION_MASK
1449                                                           | GDK_BUTTON2_MOTION_MASK
1450                                                           | GDK_BUTTON3_MOTION_MASK
1451                                                           | GDK_BUTTON_PRESS_MASK
1452                                                           | GDK_BUTTON_RELEASE_MASK), cursor, GDK_CURRENT_TIME);
<span class="line-removed">1453 #endif</span>
1454 #else
1455     GdkGrabStatus status = gdk_pointer_grab(gdk_w, owner_events,
1456                                                 (GdkEventMask)
1457                                                       (GDK_POINTER_MOTION_MASK
1458                                                           | GDK_POINTER_MOTION_HINT_MASK
1459                                                           | GDK_BUTTON_MOTION_MASK
1460                                                           | GDK_BUTTON1_MOTION_MASK
1461                                                           | GDK_BUTTON2_MOTION_MASK
1462                                                           | GDK_BUTTON3_MOTION_MASK
1463                                                           | GDK_BUTTON_PRESS_MASK
1464                                                           | GDK_BUTTON_RELEASE_MASK), NULL, cursor, GDK_CURRENT_TIME);
1465 #endif
1466     WindowContext::sm_mouse_drag_window = this;
1467 
1468     return (status == GDK_GRAB_SUCCESS) ? true : false;
1469 }
1470 
1471 void WindowContext::ungrab_mouse_drag_focus() {
1472     if (!grab_pointer) {
1473         return;
1474     }
1475 
1476 #ifdef GLASS_GTK3
<span class="line-removed">1477 #if GTK_CHECK_VERSION(3, 20, 0)</span>
<span class="line-removed">1478     gdk_seat_ungrab((GdkSeat *) grab_pointer);</span>
<span class="line-removed">1479 #else</span>
1480     gdk_device_ungrab((GdkDevice *) grab_pointer, GDK_CURRENT_TIME);
<span class="line-removed">1481 #endif</span>
1482 #else
1483     gdk_pointer_ungrab(GDK_CURRENT_TIME);
1484 #endif
1485     grab_pointer = NULL;
1486     WindowContext::sm_mouse_drag_window = NULL;
1487 
1488     if (WindowContext::sm_grab_window) {
1489         WindowContext::sm_grab_window-&gt;grab_focus();
1490     }
1491 }
1492 
1493 WindowContext::~WindowContext() {
1494     if (xim.ic) {
1495         XDestroyIC(xim.ic);
1496         xim.ic = NULL;
1497     }
1498     if (xim.im) {
1499         XCloseIM(xim.im);
1500         xim.im = NULL;
1501     }
</pre>
</td>
<td>
<hr />
<pre>
 224     gtk_window_set_title(GTK_WINDOW(gtk_widget), &quot;&quot;);
 225 
 226     gdk_window = gtk_widget_get_window(gtk_widget);
 227     g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
 228 
 229     glass_dnd_attach_context(this);
 230 
 231     gdk_windowManagerFunctions = wmf;
 232     if (wmf) {
 233         gdk_window_set_functions(gdk_window, wmf);
 234     }
 235 
 236     if (frame_type != TITLED) {
 237         gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);
 238     }
 239 
 240     connect_signals(gtk_widget, this);
 241 }
 242 
 243 void WindowContext::paint(void *data, jint width, jint height) {
<span class="line-modified"> 244 #ifdef GLASS_GTK3</span>
 245     cairo_region_t *region = gdk_window_get_clip_region(gdk_window);




 246     gdk_window_begin_paint_region(gdk_window, region);
 247     cairo_t* context = gdk_cairo_create(gdk_window);

 248 #else
 249     cairo_t *context = gdk_cairo_create(gdk_window);
 250 #endif
 251 
 252     if (bg_color.is_set) {
 253         cairo_set_source_rgba(context, bg_color.red, bg_color.green, bg_color.blue,
 254                                 (frame_type == TRANSPARENT) ? 0 : 1);
 255         cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);
 256         cairo_paint(context);
 257     }
 258 
 259     cairo_surface_t *cairo_surface;
 260     cairo_surface = cairo_image_surface_create_for_data(
 261             (unsigned char *) data,
 262             CAIRO_FORMAT_ARGB32,
 263             width, height, width * 4);
 264 
 265     cairo_set_source_surface(context, cairo_surface, 0, 0);
 266 
 267     applyShapeMask(data, width, height);
 268     cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);
 269     cairo_paint(context);
 270 
<span class="line-modified"> 271 #ifdef GLASS_GTK3</span>




 272     gdk_window_end_paint(gdk_window);
 273     cairo_region_destroy(region);
 274     cairo_destroy(context);

 275 #else
 276     cairo_destroy(context);
 277 #endif
 278 
 279     cairo_surface_destroy(cairo_surface);
 280 }
 281 
 282 bool WindowContext::isEnabled() {
 283     if (jwindow) {
 284         bool result = (JNI_TRUE == mainEnv-&gt;CallBooleanMethod(jwindow, jWindowIsEnabled));
 285         LOG_EXCEPTION(mainEnv)
 286         return result;
 287     } else {
 288         return false;
 289     }
 290 }
 291 
 292 GdkWindow *WindowContext::get_gdk_window() {
 293     return gdk_window;
 294 }
</pre>
<hr />
<pre>
1199 }
1200 
1201 size_t WindowContext::get_events_count() {
1202     return events_processing_cnt;
1203 }
1204 
1205 ///////////////////////// PROTECTED
1206 
1207 void WindowContext::applyShapeMask(void *data, uint width, uint height) {
1208     if (frame_type != TRANSPARENT) {
1209         return;
1210     }
1211 
1212     glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
1213 }
1214 
1215 ///////////////////////// PRIVATE
1216 
1217 // this is to work-around past gtk+ bug
1218 void WindowContext::ensure_window_size() {

1219     gint w, h;
1220 #ifdef GLASS_GTK3
1221     gdk_window_get_geometry(gdk_window, NULL, NULL, &amp;w, &amp;h);
1222 #else
1223     gdk_window_get_geometry(gdk_window, NULL, NULL, &amp;w, &amp;h, NULL);
1224 #endif
1225     if ((geometry.last_cw &gt; 0 &amp;&amp; geometry.last_ch &gt; 0)
1226         &amp;&amp; (geometry.last_cw != w || geometry.last_ch != h)) {
1227         gdk_window_resize(gdk_window, geometry.last_cw, geometry.last_ch);
1228     }

1229 }
1230 
1231 // This function calculate the deltas between window and window + decoration (titlebar, borders).
1232 // It&#39;s used when the window manager does not support the _NET_FRAME_EXTENTS extension or when
1233 // it&#39;s not received on time.
1234 void WindowContext::calculate_adjustments() {
1235     if (frame_type != TITLED || geometry.frame_extents_received) {
1236         return;
1237     }
1238 
1239     gint x, y, rx, ry;
1240     gdk_window_get_origin(gdk_window, &amp;x, &amp;y);
1241     gdk_window_get_root_origin(gdk_window, &amp;rx, &amp;ry);
1242 
1243     if (rx != x || ry != y) {
1244         // the left extends are correct - the right one is guessed to be the same
1245         geometry.adjust_w = (x - rx) * 2;
1246         // guess that bottom size is the same as left and right
1247         geometry.adjust_h = (y - ry) + (x - rx);
1248 
</pre>
<hr />
<pre>
1395     }
1396     return false;
1397 }
1398 
1399 bool WindowContext::effective_on_top() {
1400     if (owner) {
1401         WindowContext *topO = dynamic_cast&lt;WindowContext *&gt;(owner);
1402         return (topO &amp;&amp; topO-&gt;effective_on_top()) || on_top;
1403     }
1404     return on_top;
1405 }
1406 
1407 bool WindowContext::grab_mouse_drag_focus(GdkWindow * gdk_w, GdkEvent * event, GdkCursor * cursor, bool owner_events) {
1408     if (is_grab_disabled()) {
1409         return true;
1410     }
1411 
1412     ungrab_mouse_drag_focus();
1413 
1414 #ifdef GLASS_GTK3










1415     if (event != NULL) {
1416         grab_pointer = gdk_event_get_device (event);
1417     } else {
1418         grab_pointer = gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gtk_widget_get_display(gtk_widget)));
1419     }
1420 
1421     GdkGrabStatus status = gdk_device_grab((GdkDevice *) grab_pointer, gdk_w, GDK_OWNERSHIP_WINDOW, owner_events,
1422                                                 (GdkEventMask)
1423                                                       (GDK_POINTER_MOTION_MASK
1424                                                           | GDK_POINTER_MOTION_HINT_MASK
1425                                                           | GDK_BUTTON_MOTION_MASK
1426                                                           | GDK_BUTTON1_MOTION_MASK
1427                                                           | GDK_BUTTON2_MOTION_MASK
1428                                                           | GDK_BUTTON3_MOTION_MASK
1429                                                           | GDK_BUTTON_PRESS_MASK
1430                                                           | GDK_BUTTON_RELEASE_MASK), cursor, GDK_CURRENT_TIME);

1431 #else
1432     GdkGrabStatus status = gdk_pointer_grab(gdk_w, owner_events,
1433                                                 (GdkEventMask)
1434                                                       (GDK_POINTER_MOTION_MASK
1435                                                           | GDK_POINTER_MOTION_HINT_MASK
1436                                                           | GDK_BUTTON_MOTION_MASK
1437                                                           | GDK_BUTTON1_MOTION_MASK
1438                                                           | GDK_BUTTON2_MOTION_MASK
1439                                                           | GDK_BUTTON3_MOTION_MASK
1440                                                           | GDK_BUTTON_PRESS_MASK
1441                                                           | GDK_BUTTON_RELEASE_MASK), NULL, cursor, GDK_CURRENT_TIME);
1442 #endif
1443     WindowContext::sm_mouse_drag_window = this;
1444 
1445     return (status == GDK_GRAB_SUCCESS) ? true : false;
1446 }
1447 
1448 void WindowContext::ungrab_mouse_drag_focus() {
1449     if (!grab_pointer) {
1450         return;
1451     }
1452 
1453 #ifdef GLASS_GTK3



1454     gdk_device_ungrab((GdkDevice *) grab_pointer, GDK_CURRENT_TIME);

1455 #else
1456     gdk_pointer_ungrab(GDK_CURRENT_TIME);
1457 #endif
1458     grab_pointer = NULL;
1459     WindowContext::sm_mouse_drag_window = NULL;
1460 
1461     if (WindowContext::sm_grab_window) {
1462         WindowContext::sm_grab_window-&gt;grab_focus();
1463     }
1464 }
1465 
1466 WindowContext::~WindowContext() {
1467     if (xim.ic) {
1468         XDestroyIC(xim.ic);
1469         xim.ic = NULL;
1470     }
1471     if (xim.im) {
1472         XCloseIM(xim.im);
1473         xim.im = NULL;
1474     }
</pre>
</td>
</tr>
</table>
<center><a href="glass_screen.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
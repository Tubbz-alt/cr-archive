<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_window.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 219     gtk_widget_set_events(gtk_widget, GDK_ALL_EVENTS_MASK);
 220     gtk_widget_set_app_paintable(gtk_widget, TRUE);
 221 
 222     glass_gtk_configure_transparency_and_realize(gtk_widget, frame_type == TRANSPARENT);
 223     gtk_window_set_title(GTK_WINDOW(gtk_widget), &quot;&quot;);
 224 
 225     gdk_window = gtk_widget_get_window(gtk_widget);
 226     g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
 227 
 228     glass_dnd_attach_context(this);
 229 
 230     gdk_windowManagerFunctions = wmf;
 231     if (wmf) {
 232         gdk_window_set_functions(gdk_window, wmf);
 233     }
 234 
 235     if (frame_type != TITLED) {
 236         gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);
 237     }
 238 
<span class="line-removed"> 239     geometry.frame_extents_supported = gdk_x11_screen_supports_net_wm_hint(gdk_screen_get_default(),</span>
<span class="line-removed"> 240                                                                            atom_net_wm_frame_extents);</span>
<span class="line-removed"> 241 </span>
 242     connect_signals(gtk_widget, this);
 243 }
 244 
 245 void WindowContext::paint(void *data, jint width, jint height) {
 246 #if GTK_CHECK_VERSION(3, 0, 0)
 247     cairo_region_t *region = gdk_window_get_clip_region(gdk_window);
 248 #if GTK_CHECK_VERSION(3, 22, 0)
 249     GdkDrawingContext *dcontext = gdk_window_begin_draw_frame(gdk_window, region);
 250     cairo_t *context = gdk_drawing_context_get_cairo_context(dcontext);
 251 #else
 252     gdk_window_begin_paint_region(gdk_window, region);
 253     cairo_t* context = gdk_cairo_create(gdk_window);
 254 #endif
 255 #else
 256     cairo_t *context = gdk_cairo_create(gdk_window);
 257 #endif
 258 
 259     if (bg_color.is_set) {
 260         cairo_set_source_rgba(context, bg_color.red, bg_color.green, bg_color.blue,
 261                                 (frame_type == TRANSPARENT) ? 0 : 1);
</pre>
<hr />
<pre>
 366         if (event-&gt;atom == atom_net_wm_state) {
 367             process_net_wm_property();
 368         } else if (event-&gt;atom == atom_net_wm_frame_extents) {
 369             if (frame_type != TITLED) {
 370                 return;
 371             }
 372 
 373             int top, left, bottom, right;
 374 
 375             if (get_frame_extents_property(&amp;top, &amp;left, &amp;bottom, &amp;right)) {
 376                 if (top + left + bottom + right &gt; 0) {
 377                     geometry.frame_extents_received = true;
 378                     geometry.adjust_w = left + right;
 379                     geometry.adjust_h = top + bottom;
 380                     geometry.view_x = left;
 381                     geometry.view_y = top;
 382 
 383                     // set bounds again to set to correct window size that must
 384                     // be the total width and height accounting extents
 385                     // this is ignored if size is &quot;content size&quot; instead of &quot;window size&quot;
<span class="line-modified"> 386                     if (geometry.window_size_set) {</span>
 387                         set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);
 388                     }
 389 
 390                     // force position notify so java will know about view_y and view_x
 391                     size_position_notify(false, true);
 392                 }
 393             }
 394         }
 395     }
 396 }
 397 
 398 void WindowContext::process_configure() {
<span class="line-removed"> 399     calculate_adjustments();</span>
<span class="line-removed"> 400 </span>
 401     gint x, y, w, h, gtk_w, gtk_h;
 402 
 403     gtk_window_get_position(GTK_WINDOW(gtk_widget), &amp;x, &amp;y);
 404     gtk_window_get_size(GTK_WINDOW(gtk_widget), &amp;gtk_w, &amp;gtk_h);
 405 
 406     w = gtk_w + geometry.adjust_w;
 407     h = gtk_h + geometry.adjust_h;
 408 
 409     gboolean pos_changed = geometry.current_x != x || geometry.current_y != y;
 410     gboolean size_changed = geometry.current_w != w || geometry.current_h != h
 411                             || geometry.current_cw != gtk_w || geometry.current_ch != gtk_h;
 412 
 413     geometry.current_x = x;
 414     geometry.current_y = y;
 415     geometry.current_w = w;
 416     geometry.current_h = h;
 417     geometry.current_cw = gtk_w;
 418     geometry.current_ch = gtk_h;
 419 
 420     size_position_notify(size_changed, pos_changed);
</pre>
<hr />
<pre>
 960         gtk_window_deiconify(GTK_WINDOW(gtk_widget));
 961         activate_window();
 962     }
 963 }
 964 
 965 void WindowContext::set_maximized(bool maximize) {
 966     is_maximized = maximize;
 967 
 968     if (maximize) {
 969         // enable the functionality
 970         GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);
 971         gdk_window_set_functions(gdk_window, wmf);
 972 
 973         gtk_window_maximize(GTK_WINDOW(gtk_widget));
 974     } else {
 975         gtk_window_unmaximize(GTK_WINDOW(gtk_widget));
 976     }
 977 }
 978 
 979 void WindowContext::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
<span class="line-removed"> 980     calculate_adjustments();</span>
<span class="line-removed"> 981 </span>
 982     // newW / newH always content sizes compatible with GTK+
 983     // if window has no decoration, adjustments will be ZERO
 984     int newW = w &gt; 0 ? w - geometry.adjust_w : cw;
 985     int newH = h &gt; 0 ? h - geometry.adjust_h : ch;
 986 
 987     gboolean size_changed = FALSE;
 988     gboolean pos_changed = FALSE;
 989 
<span class="line-modified"> 990     geometry.window_size_set = (w &gt; 0 || h &gt; 0);</span>


 991 
 992     if (newW &gt; 0 &amp;&amp; newH &gt; 0) {
 993         size_changed = TRUE;
 994 
 995         geometry.current_cw = newW;
 996         geometry.current_ch = newH;
 997         geometry.current_w = newW + geometry.adjust_w;
 998         geometry.current_h = newH + geometry.adjust_h;
 999 
1000         if (visible_received) {
1001             // update constraints if not resized by the user interface so it will
1002             // let gtk_window_resize succeed, because it&#39;s bound to geometry constraints
1003             apply_geometry();
1004             gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);
1005         } else {
1006             gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);
1007         }
1008     }
1009 
1010     if (xSet || ySet) {
</pre>
<hr />
<pre>
1190     --events_processing_cnt;
1191 }
1192 
1193 size_t WindowContext::get_events_count() {
1194     return events_processing_cnt;
1195 }
1196 
1197 ///////////////////////// PROTECTED
1198 
1199 void WindowContext::applyShapeMask(void *data, uint width, uint height) {
1200     if (frame_type != TRANSPARENT) {
1201         return;
1202     }
1203 
1204     glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
1205 }
1206 
1207 ///////////////////////// PRIVATE
1208 
1209 // This function calculate the deltas between window and window + decoration (titleblar, borders).
<span class="line-modified">1210 // It&#39;s used when the window manager does not support the _NET_FRAME_EXTENTS extension.</span>

1211 void WindowContext::calculate_adjustments() {
1212     // if WM supports _NET_FRAME_EXTENTS, wait for it
<span class="line-modified">1213     if (frame_type != TITLED || geometry.frame_extents_supported) {</span>
1214         return;
1215     }
1216 
1217     gint x, y, rx, ry;
1218     gdk_window_get_origin(gdk_window, &amp;x, &amp;y);
1219     gdk_window_get_root_origin(gdk_window, &amp;rx, &amp;ry);
1220 
1221     if (rx != x || ry != y) {
1222         // the left extends are correct - the right one is guessed to be the same
1223         geometry.adjust_w = (x - rx) * 2;
1224         // guess that bottom size is the same as left and right
1225         geometry.adjust_h = (y - ry) + (x - rx);
1226 
1227         // those will be correct
1228         geometry.view_x = (x - rx);
1229         geometry.view_y = (y - ry);
1230 
<span class="line-modified">1231         if (geometry.window_size_set) {</span>
1232             set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);
1233         }
1234 
1235         // force position notify so java will know about view_y and view_x
1236         size_position_notify(false, true);
1237     }
1238 }
1239 
1240 void WindowContext::apply_geometry() {
1241     if (!map_received) {
1242         return;
1243     }
1244 
1245     GdkGeometry gdk_geometry;
1246     gdk_geometry.win_gravity = GDK_GRAVITY_NORTH_WEST;
1247 




1248     if ((!geometry.resizable || !geometry.enabled) &amp;&amp; !(is_maximized || is_fullscreen)) {
1249         // not resizeable
<span class="line-modified">1250         int w = (geometry.current_w - geometry.adjust_w) &gt; 0</span>
<span class="line-modified">1251                 ? geometry.current_w - geometry.adjust_w</span>
1252                 : geometry.current_cw;
1253 
<span class="line-modified">1254         int h = (geometry.current_h - geometry.adjust_h) &gt; 0</span>
<span class="line-modified">1255                 ? geometry.current_h - geometry.adjust_h</span>
1256                 : geometry.current_ch;
1257 
1258         gdk_geometry.min_width = gdk_geometry.max_width = w;
1259         gdk_geometry.min_height = gdk_geometry.max_height = h;
1260     } else {
<span class="line-modified">1261         gdk_geometry.min_width = (geometry.minw - geometry.adjust_w) &gt; 0</span>
<span class="line-modified">1262                                  ? geometry.minw - geometry.adjust_w : 1;</span>
<span class="line-modified">1263         gdk_geometry.min_height = (geometry.minh - geometry.adjust_h) &gt; 0</span>
<span class="line-modified">1264                                   ? geometry.minh - geometry.adjust_h : 1;</span>
<span class="line-modified">1265 </span>
<span class="line-modified">1266         gdk_geometry.max_width = (geometry.maxw - geometry.adjust_w &gt; 0)</span>
<span class="line-modified">1267                                  ? geometry.maxw - geometry.adjust_w : G_MAXINT;</span>
<span class="line-modified">1268         gdk_geometry.max_height = (geometry.maxh - geometry.adjust_h &gt; 0)</span>
<span class="line-modified">1269                                   ? geometry.maxh - geometry.adjust_h : G_MAXINT;</span>
1270     }
1271 
1272     gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &amp;gdk_geometry,
1273                                   (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE | GDK_HINT_WIN_GRAVITY));
1274 }
1275 
1276 bool WindowContext::get_frame_extents_property(int *top, int *left,
1277                                                int *bottom, int *right) {
1278     unsigned long *extents;
1279 
1280     if (gdk_property_get(gdk_window,
1281                          atom_net_wm_frame_extents,
1282                          gdk_atom_intern(&quot;CARDINAL&quot;, FALSE),
1283                          0,
1284                          sizeof(unsigned long) * 4,
1285                          FALSE,
1286                          NULL,
1287                          NULL,
1288                          NULL,
1289                          (guchar * *) &amp; extents)) {
</pre>
</td>
<td>
<hr />
<pre>
 219     gtk_widget_set_events(gtk_widget, GDK_ALL_EVENTS_MASK);
 220     gtk_widget_set_app_paintable(gtk_widget, TRUE);
 221 
 222     glass_gtk_configure_transparency_and_realize(gtk_widget, frame_type == TRANSPARENT);
 223     gtk_window_set_title(GTK_WINDOW(gtk_widget), &quot;&quot;);
 224 
 225     gdk_window = gtk_widget_get_window(gtk_widget);
 226     g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
 227 
 228     glass_dnd_attach_context(this);
 229 
 230     gdk_windowManagerFunctions = wmf;
 231     if (wmf) {
 232         gdk_window_set_functions(gdk_window, wmf);
 233     }
 234 
 235     if (frame_type != TITLED) {
 236         gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);
 237     }
 238 



 239     connect_signals(gtk_widget, this);
 240 }
 241 
 242 void WindowContext::paint(void *data, jint width, jint height) {
 243 #if GTK_CHECK_VERSION(3, 0, 0)
 244     cairo_region_t *region = gdk_window_get_clip_region(gdk_window);
 245 #if GTK_CHECK_VERSION(3, 22, 0)
 246     GdkDrawingContext *dcontext = gdk_window_begin_draw_frame(gdk_window, region);
 247     cairo_t *context = gdk_drawing_context_get_cairo_context(dcontext);
 248 #else
 249     gdk_window_begin_paint_region(gdk_window, region);
 250     cairo_t* context = gdk_cairo_create(gdk_window);
 251 #endif
 252 #else
 253     cairo_t *context = gdk_cairo_create(gdk_window);
 254 #endif
 255 
 256     if (bg_color.is_set) {
 257         cairo_set_source_rgba(context, bg_color.red, bg_color.green, bg_color.blue,
 258                                 (frame_type == TRANSPARENT) ? 0 : 1);
</pre>
<hr />
<pre>
 363         if (event-&gt;atom == atom_net_wm_state) {
 364             process_net_wm_property();
 365         } else if (event-&gt;atom == atom_net_wm_frame_extents) {
 366             if (frame_type != TITLED) {
 367                 return;
 368             }
 369 
 370             int top, left, bottom, right;
 371 
 372             if (get_frame_extents_property(&amp;top, &amp;left, &amp;bottom, &amp;right)) {
 373                 if (top + left + bottom + right &gt; 0) {
 374                     geometry.frame_extents_received = true;
 375                     geometry.adjust_w = left + right;
 376                     geometry.adjust_h = top + bottom;
 377                     geometry.view_x = left;
 378                     geometry.view_y = top;
 379 
 380                     // set bounds again to set to correct window size that must
 381                     // be the total width and height accounting extents
 382                     // this is ignored if size is &quot;content size&quot; instead of &quot;window size&quot;
<span class="line-modified"> 383                     if (geometry.needs_ajustment) {</span>
 384                         set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);
 385                     }
 386 
 387                     // force position notify so java will know about view_y and view_x
 388                     size_position_notify(false, true);
 389                 }
 390             }
 391         }
 392     }
 393 }
 394 
 395 void WindowContext::process_configure() {


 396     gint x, y, w, h, gtk_w, gtk_h;
 397 
 398     gtk_window_get_position(GTK_WINDOW(gtk_widget), &amp;x, &amp;y);
 399     gtk_window_get_size(GTK_WINDOW(gtk_widget), &amp;gtk_w, &amp;gtk_h);
 400 
 401     w = gtk_w + geometry.adjust_w;
 402     h = gtk_h + geometry.adjust_h;
 403 
 404     gboolean pos_changed = geometry.current_x != x || geometry.current_y != y;
 405     gboolean size_changed = geometry.current_w != w || geometry.current_h != h
 406                             || geometry.current_cw != gtk_w || geometry.current_ch != gtk_h;
 407 
 408     geometry.current_x = x;
 409     geometry.current_y = y;
 410     geometry.current_w = w;
 411     geometry.current_h = h;
 412     geometry.current_cw = gtk_w;
 413     geometry.current_ch = gtk_h;
 414 
 415     size_position_notify(size_changed, pos_changed);
</pre>
<hr />
<pre>
 955         gtk_window_deiconify(GTK_WINDOW(gtk_widget));
 956         activate_window();
 957     }
 958 }
 959 
 960 void WindowContext::set_maximized(bool maximize) {
 961     is_maximized = maximize;
 962 
 963     if (maximize) {
 964         // enable the functionality
 965         GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);
 966         gdk_window_set_functions(gdk_window, wmf);
 967 
 968         gtk_window_maximize(GTK_WINDOW(gtk_widget));
 969     } else {
 970         gtk_window_unmaximize(GTK_WINDOW(gtk_widget));
 971     }
 972 }
 973 
 974 void WindowContext::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {


 975     // newW / newH always content sizes compatible with GTK+
 976     // if window has no decoration, adjustments will be ZERO
 977     int newW = w &gt; 0 ? w - geometry.adjust_w : cw;
 978     int newH = h &gt; 0 ? h - geometry.adjust_h : ch;
 979 
 980     gboolean size_changed = FALSE;
 981     gboolean pos_changed = FALSE;
 982 
<span class="line-modified"> 983     // this will tell if adjustments are needed - that&#39;s because GTK does not have full window size</span>
<span class="line-added"> 984     // values, just content values. Frame extents (window decorations) are handled by the window manager.</span>
<span class="line-added"> 985     geometry.needs_ajustment = (w &gt; 0 || h &gt; 0) || geometry.needs_ajustment;</span>
 986 
 987     if (newW &gt; 0 &amp;&amp; newH &gt; 0) {
 988         size_changed = TRUE;
 989 
 990         geometry.current_cw = newW;
 991         geometry.current_ch = newH;
 992         geometry.current_w = newW + geometry.adjust_w;
 993         geometry.current_h = newH + geometry.adjust_h;
 994 
 995         if (visible_received) {
 996             // update constraints if not resized by the user interface so it will
 997             // let gtk_window_resize succeed, because it&#39;s bound to geometry constraints
 998             apply_geometry();
 999             gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);
1000         } else {
1001             gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);
1002         }
1003     }
1004 
1005     if (xSet || ySet) {
</pre>
<hr />
<pre>
1185     --events_processing_cnt;
1186 }
1187 
1188 size_t WindowContext::get_events_count() {
1189     return events_processing_cnt;
1190 }
1191 
1192 ///////////////////////// PROTECTED
1193 
1194 void WindowContext::applyShapeMask(void *data, uint width, uint height) {
1195     if (frame_type != TRANSPARENT) {
1196         return;
1197     }
1198 
1199     glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
1200 }
1201 
1202 ///////////////////////// PRIVATE
1203 
1204 // This function calculate the deltas between window and window + decoration (titleblar, borders).
<span class="line-modified">1205 // It&#39;s used when the window manager does not support the _NET_FRAME_EXTENTS extension or when</span>
<span class="line-added">1206 // it&#39;s not received on time.</span>
1207 void WindowContext::calculate_adjustments() {
1208     // if WM supports _NET_FRAME_EXTENTS, wait for it
<span class="line-modified">1209     if (frame_type != TITLED || geometry.frame_extents_received) {</span>
1210         return;
1211     }
1212 
1213     gint x, y, rx, ry;
1214     gdk_window_get_origin(gdk_window, &amp;x, &amp;y);
1215     gdk_window_get_root_origin(gdk_window, &amp;rx, &amp;ry);
1216 
1217     if (rx != x || ry != y) {
1218         // the left extends are correct - the right one is guessed to be the same
1219         geometry.adjust_w = (x - rx) * 2;
1220         // guess that bottom size is the same as left and right
1221         geometry.adjust_h = (y - ry) + (x - rx);
1222 
1223         // those will be correct
1224         geometry.view_x = (x - rx);
1225         geometry.view_y = (y - ry);
1226 
<span class="line-modified">1227         if (geometry.needs_ajustment) {</span>
1228             set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);
1229         }
1230 
1231         // force position notify so java will know about view_y and view_x
1232         size_position_notify(false, true);
1233     }
1234 }
1235 
1236 void WindowContext::apply_geometry() {
1237     if (!map_received) {
1238         return;
1239     }
1240 
1241     GdkGeometry gdk_geometry;
1242     gdk_geometry.win_gravity = GDK_GRAVITY_NORTH_WEST;
1243 
<span class="line-added">1244     // if window size was never set, adjustments are not needed</span>
<span class="line-added">1245     int adjust_w = (geometry.needs_ajustment) ? geometry.adjust_w : 0;</span>
<span class="line-added">1246     int adjust_h = (geometry.needs_ajustment) ? geometry.adjust_h : 0;</span>
<span class="line-added">1247 </span>
1248     if ((!geometry.resizable || !geometry.enabled) &amp;&amp; !(is_maximized || is_fullscreen)) {
1249         // not resizeable
<span class="line-modified">1250         int w = (geometry.current_w - adjust_w) &gt; 0</span>
<span class="line-modified">1251                 ? geometry.current_w - adjust_w</span>
1252                 : geometry.current_cw;
1253 
<span class="line-modified">1254         int h = (geometry.current_h - adjust_h) &gt; 0</span>
<span class="line-modified">1255                 ? geometry.current_h - adjust_h</span>
1256                 : geometry.current_ch;
1257 
1258         gdk_geometry.min_width = gdk_geometry.max_width = w;
1259         gdk_geometry.min_height = gdk_geometry.max_height = h;
1260     } else {
<span class="line-modified">1261         gdk_geometry.min_width = (geometry.minw - adjust_w) &gt; 0</span>
<span class="line-modified">1262                                  ? geometry.minw - adjust_w : 1;</span>
<span class="line-modified">1263         gdk_geometry.min_height = (geometry.minh - adjust_h) &gt; 0</span>
<span class="line-modified">1264                                   ? geometry.minh - adjust_h : 1;</span>
<span class="line-modified">1265 </span>
<span class="line-modified">1266         gdk_geometry.max_width = (geometry.maxw - adjust_w &gt; 0)</span>
<span class="line-modified">1267                                  ? geometry.maxw - adjust_w : G_MAXINT;</span>
<span class="line-modified">1268         gdk_geometry.max_height = (geometry.maxh - adjust_h &gt; 0)</span>
<span class="line-modified">1269                                   ? geometry.maxh - adjust_h : G_MAXINT;</span>
1270     }
1271 
1272     gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &amp;gdk_geometry,
1273                                   (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE | GDK_HINT_WIN_GRAVITY));
1274 }
1275 
1276 bool WindowContext::get_frame_extents_property(int *top, int *left,
1277                                                int *bottom, int *right) {
1278     unsigned long *extents;
1279 
1280     if (gdk_property_get(gdk_window,
1281                          atom_net_wm_frame_extents,
1282                          gdk_atom_intern(&quot;CARDINAL&quot;, FALSE),
1283                          0,
1284                          sizeof(unsigned long) * 4,
1285                          FALSE,
1286                          NULL,
1287                          NULL,
1288                          NULL,
1289                          (guchar * *) &amp; extents)) {
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_window.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_window.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 170 
 171 WindowContext * WindowContext::sm_mouse_drag_window = NULL;
 172 WindowContext * WindowContext::sm_grab_window = NULL;
 173 
 174 WindowContext::WindowContext(jobject _jwindow, WindowContext *_owner, long _screen,
 175                                    WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :
 176         screen(_screen),
 177         frame_type(_frame_type),
 178         window_type(type),
 179         owner(_owner),
 180         jview(NULL),
 181         map_received(false),
 182         visible_received(false),
 183         on_top(false),
 184         is_fullscreen(false),
 185         is_iconified(false),
 186         is_maximized(false),
 187         is_mouse_entered(false),
 188         can_be_deleted(false),
 189         events_processing_cnt(0),
<span class="line-modified"> 190         pointer_device(NULL) {</span>
 191 
 192     jwindow = mainEnv-&gt;NewGlobalRef(_jwindow);
 193 
 194     gtk_widget = gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);
 195 
 196     if (gchar * app_name = get_application_name()) {
 197         gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);
 198         g_free(app_name);
 199     }
 200 
 201     if (owner) {
 202         owner-&gt;add_child(this);
 203         if (on_top_inherited()) {
 204             gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);
 205         }
 206     }
 207 
 208     if (type == UTILITY) {
 209         gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);
 210     }
</pre>
<hr />
<pre>
 496             break;
 497         case MOUSE_BACK_BTN:
 498             mask = GDK_BUTTON4_MASK;
 499             break;
 500         case MOUSE_FORWARD_BTN:
 501             mask = GDK_BUTTON5_MASK;
 502             break;
 503     }
 504 
 505     if (press) {
 506         state |= mask;
 507     } else {
 508         state &amp;= ~mask;
 509     }
 510 
 511     // Upper layers expects from us Windows behavior:
 512     // all mouse events should be delivered to window where drag begins
 513     // and no exit/enter event should be reported during this drag.
 514     // We can grab mouse pointer for these needs.
 515     if (press) {
<span class="line-modified"> 516         grab_mouse_drag_focus(gdk_window, NULL, true);</span>
 517     } else {
 518         if ((event-&gt;state &amp; MOUSE_BUTTONS_MASK)
 519             &amp;&amp; !(state &amp; MOUSE_BUTTONS_MASK)) { // all buttons released
 520             ungrab_mouse_drag_focus();
 521         } else if (event-&gt;button == 8 || event-&gt;button == 9) {
 522             // GDK X backend interprets button press events for buttons 4-7 as
 523             // scroll events so GDK_BUTTON4_MASK and GDK_BUTTON5_MASK will never
 524             // be set on the event-&gt;state from GDK. Thus we cannot check if all
 525             // buttons have been released in the usual way (as above).
 526             ungrab_mouse_drag_focus();
 527         }
 528     }
 529 
 530     jint button = gtk_button_number_to_mouse_button(event-&gt;button);
 531 
 532     if (jview &amp;&amp; button != com_sun_glass_events_MouseEvent_BUTTON_NONE) {
 533         mainEnv-&gt;CallVoidMethod(jview, jViewNotifyMouse,
 534                                 press ? com_sun_glass_events_MouseEvent_DOWN : com_sun_glass_events_MouseEvent_UP,
 535                                 button,
 536                                 (jint) event-&gt;x, (jint) event-&gt;y,
</pre>
<hr />
<pre>
 886                                     0, 0,
 887                                     0,
 888                                     JNI_FALSE,
 889                                     JNI_FALSE);
 890             CHECK_JNI_EXCEPTION(mainEnv)
 891         }
 892     }
 893 
 894     if (visible) {
 895         visible_received = TRUE;
 896     }
 897 
 898     //JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order
 899     if (visible &amp;&amp; jwindow &amp;&amp; isEnabled()) {
 900         mainEnv-&gt;CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);
 901         CHECK_JNI_EXCEPTION(mainEnv);
 902     }
 903 }
 904 
 905 void WindowContext::set_cursor(GdkCursor *cursor) {
<span class="line-modified"> 906     if (!is_in_drag()) {</span>
<span class="line-modified"> 907         if (WindowContext::sm_mouse_drag_window) {</span>
<span class="line-modified"> 908             grab_mouse_drag_focus(WindowContext::sm_mouse_drag_window-&gt;get_gdk_window(), cursor, false);</span>
<span class="line-modified"> 909         } else if (WindowContext::sm_grab_window) {</span>
<span class="line-modified"> 910             grab_mouse_drag_focus(WindowContext::sm_grab_window-&gt;get_gdk_window(), cursor, true);</span>
<span class="line-modified"> 911         }</span>
<span class="line-modified"> 912     }</span>

 913 
 914     gdk_window_set_cursor(gdk_window, cursor);
 915 }
 916 
 917 void WindowContext::set_level(int level) {
 918     if (level == com_sun_glass_ui_Window_Level_NORMAL) {
 919         on_top = false;
 920     } else if (level == com_sun_glass_ui_Window_Level_FLOATING
 921                || level == com_sun_glass_ui_Window_Level_TOPMOST) {
 922         on_top = true;
 923     }
 924     // We need to emulate always on top behaviour on child windows
 925 
 926     if (!on_top_inherited()) {
 927         update_ontop_tree(on_top);
 928     }
 929 }
 930 
 931 void WindowContext::set_background(float r, float g, float b) {
 932     bg_color.red = r;
</pre>
<hr />
<pre>
1104 }
1105 
1106 void WindowContext::show_or_hide_children(bool show) {
1107     std::set&lt;WindowContext *&gt;::iterator it;
1108     for (it = children.begin(); it != children.end(); ++it) {
1109         (*it)-&gt;set_minimized(!show);
1110         (*it)-&gt;show_or_hide_children(show);
1111     }
1112 }
1113 
1114 bool WindowContext::is_visible() {
1115     return gtk_widget_get_visible(gtk_widget);
1116 }
1117 
1118 bool WindowContext::is_dead() {
1119     return can_be_deleted;
1120 }
1121 
1122 bool WindowContext::grab_focus() {
1123     if (WindowContext::sm_mouse_drag_window
<span class="line-modified">1124             || grab_mouse_drag_focus(gdk_window, NULL, true)) {</span>
1125         WindowContext::sm_grab_window = this;
1126         return true;
1127     } else {
1128         return false;
1129     }
1130 }
1131 
1132 void WindowContext::ungrab_focus() {
1133     if (!WindowContext::sm_mouse_drag_window) {
1134         ungrab_mouse_drag_focus();
1135     }
1136 
1137     WindowContext::sm_grab_window = NULL;
1138 
1139     if (jwindow) {
1140         mainEnv-&gt;CallVoidMethod(jwindow, jWindowNotifyFocusUngrab);
1141         CHECK_JNI_EXCEPTION(mainEnv)
1142     }
1143 }
1144 
</pre>
<hr />
<pre>
1364     WindowContext *o = owner;
1365     while (o) {
1366         WindowContext *topO = dynamic_cast&lt;WindowContext *&gt;(o);
1367         if (!topO) break;
1368         if (topO-&gt;on_top) {
1369             return true;
1370         }
1371         o = topO-&gt;owner;
1372     }
1373     return false;
1374 }
1375 
1376 bool WindowContext::effective_on_top() {
1377     if (owner) {
1378         WindowContext *topO = dynamic_cast&lt;WindowContext *&gt;(owner);
1379         return (topO &amp;&amp; topO-&gt;effective_on_top()) || on_top;
1380     }
1381     return on_top;
1382 }
1383 
<span class="line-modified">1384 GdkDevice * WindowContext::get_pointer_device() {</span>
<span class="line-removed">1385     GdkDevice * device;</span>
<span class="line-removed">1386 #ifdef GLASS_GTK3</span>
<span class="line-removed">1387 #if GTK_CHECK_VERSION(3, 20, 0)</span>
<span class="line-removed">1388     device = gdk_seat_get_pointer(gdk_display_get_default_seat(gtk_widget_get_display(gtk_widget)));</span>
<span class="line-removed">1389 #else</span>
<span class="line-removed">1390     device = gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gtk_widget_get_display(gtk_widget)));</span>
<span class="line-removed">1391 #endif</span>
<span class="line-removed">1392 #else</span>
<span class="line-removed">1393     // gtk2</span>
<span class="line-removed">1394     device = gdk_display_get_core_pointer(gtk_widget_get_display(gtk_widget));</span>
<span class="line-removed">1395 #endif</span>
<span class="line-removed">1396 </span>
<span class="line-removed">1397     return device;</span>
<span class="line-removed">1398 }</span>
<span class="line-removed">1399 </span>
<span class="line-removed">1400 bool WindowContext::grab_mouse_drag_focus(GdkWindow * gdk_w, GdkCursor * cursor, bool owner_events) {</span>
1401     if (is_grab_disabled()) {
1402         return true;
1403     }
1404 
1405     ungrab_mouse_drag_focus();
1406 
<span class="line-removed">1407     pointer_device = get_pointer_device();</span>
1408 #ifdef GLASS_GTK3
1409 #if GTK_CHECK_VERSION(3, 20, 0)
<span class="line-modified">1410     GdkGrabStatus status = gdk_seat_grab(gdk_device_get_seat(pointer_device), gdk_w,</span>
<span class="line-modified">1411                                           GDK_SEAT_CAPABILITY_ALL_POINTING, owner_events, cursor, NULL, NULL, NULL);</span>






1412 #else
<span class="line-modified">1413     GdkGrabStatus status = gdk_device_grab(pointer_device, gdk_w, GDK_OWNERSHIP_WINDOW, owner_events,</span>






1414                                                 (GdkEventMask)
1415                                                       (GDK_POINTER_MOTION_MASK
1416                                                           | GDK_POINTER_MOTION_HINT_MASK
1417                                                           | GDK_BUTTON_MOTION_MASK
1418                                                           | GDK_BUTTON1_MOTION_MASK
1419                                                           | GDK_BUTTON2_MOTION_MASK
1420                                                           | GDK_BUTTON3_MOTION_MASK
1421                                                           | GDK_BUTTON_PRESS_MASK
1422                                                           | GDK_BUTTON_RELEASE_MASK), cursor, GDK_CURRENT_TIME);
1423 #endif
1424 #else
1425     GdkGrabStatus status = gdk_pointer_grab(gdk_w, owner_events,
1426                                                 (GdkEventMask)
1427                                                       (GDK_POINTER_MOTION_MASK
1428                                                           | GDK_POINTER_MOTION_HINT_MASK
1429                                                           | GDK_BUTTON_MOTION_MASK
1430                                                           | GDK_BUTTON1_MOTION_MASK
1431                                                           | GDK_BUTTON2_MOTION_MASK
1432                                                           | GDK_BUTTON3_MOTION_MASK
1433                                                           | GDK_BUTTON_PRESS_MASK
1434                                                           | GDK_BUTTON_RELEASE_MASK), NULL, cursor, GDK_CURRENT_TIME);
1435 #endif
1436     WindowContext::sm_mouse_drag_window = this;
1437 
1438     return (status == GDK_GRAB_SUCCESS) ? true : false;
1439 }
1440 
1441 void WindowContext::ungrab_mouse_drag_focus() {
<span class="line-modified">1442     if (!pointer_device) {</span>
1443         return;
1444     }
1445 
1446 #ifdef GLASS_GTK3
1447 #if GTK_CHECK_VERSION(3, 20, 0)
<span class="line-modified">1448     gdk_seat_ungrab(gdk_device_get_seat(pointer_device));</span>
1449 #else
<span class="line-modified">1450     gdk_device_ungrab(pointer_device, GDK_CURRENT_TIME);</span>
1451 #endif
1452 #else
1453     gdk_pointer_ungrab(GDK_CURRENT_TIME);
1454 #endif
<span class="line-modified">1455     pointer_device = NULL;</span>
1456     WindowContext::sm_mouse_drag_window = NULL;
1457 
1458     if (WindowContext::sm_grab_window) {
1459         WindowContext::sm_grab_window-&gt;grab_focus();
1460     }
1461 }
1462 
1463 WindowContext::~WindowContext() {
1464     if (xim.ic) {
1465         XDestroyIC(xim.ic);
1466         xim.ic = NULL;
1467     }
1468     if (xim.im) {
1469         XCloseIM(xim.im);
1470         xim.im = NULL;
1471     }
1472 
1473     gtk_widget_destroy(gtk_widget);
1474 }
</pre>
</td>
<td>
<hr />
<pre>
 170 
 171 WindowContext * WindowContext::sm_mouse_drag_window = NULL;
 172 WindowContext * WindowContext::sm_grab_window = NULL;
 173 
 174 WindowContext::WindowContext(jobject _jwindow, WindowContext *_owner, long _screen,
 175                                    WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :
 176         screen(_screen),
 177         frame_type(_frame_type),
 178         window_type(type),
 179         owner(_owner),
 180         jview(NULL),
 181         map_received(false),
 182         visible_received(false),
 183         on_top(false),
 184         is_fullscreen(false),
 185         is_iconified(false),
 186         is_maximized(false),
 187         is_mouse_entered(false),
 188         can_be_deleted(false),
 189         events_processing_cnt(0),
<span class="line-modified"> 190         grab_pointer(NULL) {</span>
 191 
 192     jwindow = mainEnv-&gt;NewGlobalRef(_jwindow);
 193 
 194     gtk_widget = gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);
 195 
 196     if (gchar * app_name = get_application_name()) {
 197         gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);
 198         g_free(app_name);
 199     }
 200 
 201     if (owner) {
 202         owner-&gt;add_child(this);
 203         if (on_top_inherited()) {
 204             gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);
 205         }
 206     }
 207 
 208     if (type == UTILITY) {
 209         gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);
 210     }
</pre>
<hr />
<pre>
 496             break;
 497         case MOUSE_BACK_BTN:
 498             mask = GDK_BUTTON4_MASK;
 499             break;
 500         case MOUSE_FORWARD_BTN:
 501             mask = GDK_BUTTON5_MASK;
 502             break;
 503     }
 504 
 505     if (press) {
 506         state |= mask;
 507     } else {
 508         state &amp;= ~mask;
 509     }
 510 
 511     // Upper layers expects from us Windows behavior:
 512     // all mouse events should be delivered to window where drag begins
 513     // and no exit/enter event should be reported during this drag.
 514     // We can grab mouse pointer for these needs.
 515     if (press) {
<span class="line-modified"> 516         grab_mouse_drag_focus(gdk_window, (GdkEvent *) event, NULL, true);</span>
 517     } else {
 518         if ((event-&gt;state &amp; MOUSE_BUTTONS_MASK)
 519             &amp;&amp; !(state &amp; MOUSE_BUTTONS_MASK)) { // all buttons released
 520             ungrab_mouse_drag_focus();
 521         } else if (event-&gt;button == 8 || event-&gt;button == 9) {
 522             // GDK X backend interprets button press events for buttons 4-7 as
 523             // scroll events so GDK_BUTTON4_MASK and GDK_BUTTON5_MASK will never
 524             // be set on the event-&gt;state from GDK. Thus we cannot check if all
 525             // buttons have been released in the usual way (as above).
 526             ungrab_mouse_drag_focus();
 527         }
 528     }
 529 
 530     jint button = gtk_button_number_to_mouse_button(event-&gt;button);
 531 
 532     if (jview &amp;&amp; button != com_sun_glass_events_MouseEvent_BUTTON_NONE) {
 533         mainEnv-&gt;CallVoidMethod(jview, jViewNotifyMouse,
 534                                 press ? com_sun_glass_events_MouseEvent_DOWN : com_sun_glass_events_MouseEvent_UP,
 535                                 button,
 536                                 (jint) event-&gt;x, (jint) event-&gt;y,
</pre>
<hr />
<pre>
 886                                     0, 0,
 887                                     0,
 888                                     JNI_FALSE,
 889                                     JNI_FALSE);
 890             CHECK_JNI_EXCEPTION(mainEnv)
 891         }
 892     }
 893 
 894     if (visible) {
 895         visible_received = TRUE;
 896     }
 897 
 898     //JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order
 899     if (visible &amp;&amp; jwindow &amp;&amp; isEnabled()) {
 900         mainEnv-&gt;CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);
 901         CHECK_JNI_EXCEPTION(mainEnv);
 902     }
 903 }
 904 
 905 void WindowContext::set_cursor(GdkCursor *cursor) {
<span class="line-modified"> 906 //  FIXME: seems invalid on Gtk+3</span>
<span class="line-modified"> 907 //    if (!is_in_drag()) {</span>
<span class="line-modified"> 908 //        if (WindowContext::sm_mouse_drag_window) {</span>
<span class="line-modified"> 909 //            grab_mouse_drag_focus(WindowContext::sm_mouse_drag_window-&gt;get_gdk_window(), NULL, cursor, false);</span>
<span class="line-modified"> 910 //        } else if (WindowContext::sm_grab_window) {</span>
<span class="line-modified"> 911 //            grab_mouse_drag_focus(WindowContext::sm_grab_window-&gt;get_gdk_window(), NULL, cursor, true);</span>
<span class="line-modified"> 912 //        }</span>
<span class="line-added"> 913 //    }</span>
 914 
 915     gdk_window_set_cursor(gdk_window, cursor);
 916 }
 917 
 918 void WindowContext::set_level(int level) {
 919     if (level == com_sun_glass_ui_Window_Level_NORMAL) {
 920         on_top = false;
 921     } else if (level == com_sun_glass_ui_Window_Level_FLOATING
 922                || level == com_sun_glass_ui_Window_Level_TOPMOST) {
 923         on_top = true;
 924     }
 925     // We need to emulate always on top behaviour on child windows
 926 
 927     if (!on_top_inherited()) {
 928         update_ontop_tree(on_top);
 929     }
 930 }
 931 
 932 void WindowContext::set_background(float r, float g, float b) {
 933     bg_color.red = r;
</pre>
<hr />
<pre>
1105 }
1106 
1107 void WindowContext::show_or_hide_children(bool show) {
1108     std::set&lt;WindowContext *&gt;::iterator it;
1109     for (it = children.begin(); it != children.end(); ++it) {
1110         (*it)-&gt;set_minimized(!show);
1111         (*it)-&gt;show_or_hide_children(show);
1112     }
1113 }
1114 
1115 bool WindowContext::is_visible() {
1116     return gtk_widget_get_visible(gtk_widget);
1117 }
1118 
1119 bool WindowContext::is_dead() {
1120     return can_be_deleted;
1121 }
1122 
1123 bool WindowContext::grab_focus() {
1124     if (WindowContext::sm_mouse_drag_window
<span class="line-modified">1125             || grab_mouse_drag_focus(gdk_window, NULL, NULL, true)) {</span>
1126         WindowContext::sm_grab_window = this;
1127         return true;
1128     } else {
1129         return false;
1130     }
1131 }
1132 
1133 void WindowContext::ungrab_focus() {
1134     if (!WindowContext::sm_mouse_drag_window) {
1135         ungrab_mouse_drag_focus();
1136     }
1137 
1138     WindowContext::sm_grab_window = NULL;
1139 
1140     if (jwindow) {
1141         mainEnv-&gt;CallVoidMethod(jwindow, jWindowNotifyFocusUngrab);
1142         CHECK_JNI_EXCEPTION(mainEnv)
1143     }
1144 }
1145 
</pre>
<hr />
<pre>
1365     WindowContext *o = owner;
1366     while (o) {
1367         WindowContext *topO = dynamic_cast&lt;WindowContext *&gt;(o);
1368         if (!topO) break;
1369         if (topO-&gt;on_top) {
1370             return true;
1371         }
1372         o = topO-&gt;owner;
1373     }
1374     return false;
1375 }
1376 
1377 bool WindowContext::effective_on_top() {
1378     if (owner) {
1379         WindowContext *topO = dynamic_cast&lt;WindowContext *&gt;(owner);
1380         return (topO &amp;&amp; topO-&gt;effective_on_top()) || on_top;
1381     }
1382     return on_top;
1383 }
1384 
<span class="line-modified">1385 bool WindowContext::grab_mouse_drag_focus(GdkWindow * gdk_w, GdkEvent * event, GdkCursor * cursor, bool owner_events) {</span>
















1386     if (is_grab_disabled()) {
1387         return true;
1388     }
1389 
1390     ungrab_mouse_drag_focus();
1391 

1392 #ifdef GLASS_GTK3
1393 #if GTK_CHECK_VERSION(3, 20, 0)
<span class="line-modified">1394     if (event != NULL) {</span>
<span class="line-modified">1395         grab_pointer = gdk_event_get_seat(event);</span>
<span class="line-added">1396     } else {</span>
<span class="line-added">1397         grab_pointer = gdk_display_get_default_seat(gtk_widget_get_display(gtk_widget));</span>
<span class="line-added">1398     }</span>
<span class="line-added">1399 </span>
<span class="line-added">1400     GdkGrabStatus status = gdk_seat_grab((GdkSeat *) grab_pointer, gdk_w,</span>
<span class="line-added">1401                                           GDK_SEAT_CAPABILITY_POINTER, owner_events, cursor, NULL, NULL, NULL);</span>
1402 #else
<span class="line-modified">1403     if (event != NULL) {</span>
<span class="line-added">1404         grab_pointer = gdk_event_get_device (event);</span>
<span class="line-added">1405     } else {</span>
<span class="line-added">1406         grab_pointer = gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gtk_widget_get_display(gtk_widget)));</span>
<span class="line-added">1407     }</span>
<span class="line-added">1408 </span>
<span class="line-added">1409     GdkGrabStatus status = gdk_device_grab((GdkDevice *) grab_pointer, gdk_w, GDK_OWNERSHIP_WINDOW, owner_events,</span>
1410                                                 (GdkEventMask)
1411                                                       (GDK_POINTER_MOTION_MASK
1412                                                           | GDK_POINTER_MOTION_HINT_MASK
1413                                                           | GDK_BUTTON_MOTION_MASK
1414                                                           | GDK_BUTTON1_MOTION_MASK
1415                                                           | GDK_BUTTON2_MOTION_MASK
1416                                                           | GDK_BUTTON3_MOTION_MASK
1417                                                           | GDK_BUTTON_PRESS_MASK
1418                                                           | GDK_BUTTON_RELEASE_MASK), cursor, GDK_CURRENT_TIME);
1419 #endif
1420 #else
1421     GdkGrabStatus status = gdk_pointer_grab(gdk_w, owner_events,
1422                                                 (GdkEventMask)
1423                                                       (GDK_POINTER_MOTION_MASK
1424                                                           | GDK_POINTER_MOTION_HINT_MASK
1425                                                           | GDK_BUTTON_MOTION_MASK
1426                                                           | GDK_BUTTON1_MOTION_MASK
1427                                                           | GDK_BUTTON2_MOTION_MASK
1428                                                           | GDK_BUTTON3_MOTION_MASK
1429                                                           | GDK_BUTTON_PRESS_MASK
1430                                                           | GDK_BUTTON_RELEASE_MASK), NULL, cursor, GDK_CURRENT_TIME);
1431 #endif
1432     WindowContext::sm_mouse_drag_window = this;
1433 
1434     return (status == GDK_GRAB_SUCCESS) ? true : false;
1435 }
1436 
1437 void WindowContext::ungrab_mouse_drag_focus() {
<span class="line-modified">1438     if (!grab_pointer) {</span>
1439         return;
1440     }
1441 
1442 #ifdef GLASS_GTK3
1443 #if GTK_CHECK_VERSION(3, 20, 0)
<span class="line-modified">1444     gdk_seat_ungrab((GdkSeat *) grab_pointer);</span>
1445 #else
<span class="line-modified">1446     gdk_device_ungrab((GdkDevice *) grab_pointer, GDK_CURRENT_TIME);</span>
1447 #endif
1448 #else
1449     gdk_pointer_ungrab(GDK_CURRENT_TIME);
1450 #endif
<span class="line-modified">1451     grab_pointer = NULL;</span>
1452     WindowContext::sm_mouse_drag_window = NULL;
1453 
1454     if (WindowContext::sm_grab_window) {
1455         WindowContext::sm_grab_window-&gt;grab_focus();
1456     }
1457 }
1458 
1459 WindowContext::~WindowContext() {
1460     if (xim.ic) {
1461         XDestroyIC(xim.ic);
1462         xim.ic = NULL;
1463     }
1464     if (xim.im) {
1465         XCloseIM(xim.im);
1466         xim.im = NULL;
1467     }
1468 
1469     gtk_widget_destroy(gtk_widget);
1470 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_window.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
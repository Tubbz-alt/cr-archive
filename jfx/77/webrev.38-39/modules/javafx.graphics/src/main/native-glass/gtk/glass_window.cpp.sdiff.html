<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 887                                     0,
 888                                     JNI_FALSE,
 889                                     JNI_FALSE);
 890             CHECK_JNI_EXCEPTION(mainEnv)
 891         }
 892     }
 893 
 894     if (visible) {
 895         visible_received = TRUE;
 896     }
 897 
 898     //JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order
 899     if (visible &amp;&amp; jwindow &amp;&amp; isEnabled()) {
 900         mainEnv-&gt;CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);
 901         CHECK_JNI_EXCEPTION(mainEnv);
 902     }
 903 }
 904 
 905 void WindowContext::set_cursor(GdkCursor *cursor) {
 906 // This seems to have no no effect on either Gtk+2 or Gtk+3

 907 //    if (!is_in_drag()) {
 908 //        if (WindowContext::sm_mouse_drag_window) {
 909 //            grab_mouse_drag_focus(WindowContext::sm_mouse_drag_window-&gt;get_gdk_window(), NULL, cursor, false);
 910 //        } else if (WindowContext::sm_grab_window) {
 911 //            grab_mouse_drag_focus(WindowContext::sm_grab_window-&gt;get_gdk_window(), NULL, cursor, true);
 912 //        }
 913 //    }
 914 
 915     gdk_window_set_cursor(gdk_window, cursor);
 916 }
 917 
 918 void WindowContext::set_level(int level) {
 919     if (level == com_sun_glass_ui_Window_Level_NORMAL) {
 920         on_top = false;
 921     } else if (level == com_sun_glass_ui_Window_Level_FLOATING
 922                || level == com_sun_glass_ui_Window_Level_TOPMOST) {
 923         on_top = true;
 924     }
 925     // We need to emulate always on top behaviour on child windows
 926 
</pre>
<hr />
<pre>
1197 void WindowContext::decrement_events_counter() {
1198     --events_processing_cnt;
1199 }
1200 
1201 size_t WindowContext::get_events_count() {
1202     return events_processing_cnt;
1203 }
1204 
1205 ///////////////////////// PROTECTED
1206 
1207 void WindowContext::applyShapeMask(void *data, uint width, uint height) {
1208     if (frame_type != TRANSPARENT) {
1209         return;
1210     }
1211 
1212     glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
1213 }
1214 
1215 ///////////////////////// PRIVATE
1216 
<span class="line-modified">1217 // This function calculate the deltas between window and window + decoration (titleblar, borders).</span>
1218 // It&#39;s used when the window manager does not support the _NET_FRAME_EXTENTS extension or when
1219 // it&#39;s not received on time.
1220 void WindowContext::calculate_adjustments() {
<span class="line-removed">1221     // if WM supports _NET_FRAME_EXTENTS, wait for it</span>
1222     if (frame_type != TITLED || geometry.frame_extents_received) {
1223         return;
1224     }
1225 
1226     gint x, y, rx, ry;
1227     gdk_window_get_origin(gdk_window, &amp;x, &amp;y);
1228     gdk_window_get_root_origin(gdk_window, &amp;rx, &amp;ry);
1229 
1230     if (rx != x || ry != y) {
1231         // the left extends are correct - the right one is guessed to be the same
1232         geometry.adjust_w = (x - rx) * 2;
1233         // guess that bottom size is the same as left and right
1234         geometry.adjust_h = (y - ry) + (x - rx);
1235 
1236         // those will be correct
1237         geometry.view_x = (x - rx);
1238         geometry.view_y = (y - ry);
1239 
1240         if (geometry.needs_ajustment) {
1241             set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);
</pre>
</td>
<td>
<hr />
<pre>
 887                                     0,
 888                                     JNI_FALSE,
 889                                     JNI_FALSE);
 890             CHECK_JNI_EXCEPTION(mainEnv)
 891         }
 892     }
 893 
 894     if (visible) {
 895         visible_received = TRUE;
 896     }
 897 
 898     //JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order
 899     if (visible &amp;&amp; jwindow &amp;&amp; isEnabled()) {
 900         mainEnv-&gt;CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);
 901         CHECK_JNI_EXCEPTION(mainEnv);
 902     }
 903 }
 904 
 905 void WindowContext::set_cursor(GdkCursor *cursor) {
 906 // This seems to have no no effect on either Gtk+2 or Gtk+3
<span class="line-added"> 907 // Also note that re-enabling this will break grab on Gtk 3.20+</span>
 908 //    if (!is_in_drag()) {
 909 //        if (WindowContext::sm_mouse_drag_window) {
 910 //            grab_mouse_drag_focus(WindowContext::sm_mouse_drag_window-&gt;get_gdk_window(), NULL, cursor, false);
 911 //        } else if (WindowContext::sm_grab_window) {
 912 //            grab_mouse_drag_focus(WindowContext::sm_grab_window-&gt;get_gdk_window(), NULL, cursor, true);
 913 //        }
 914 //    }
 915 
 916     gdk_window_set_cursor(gdk_window, cursor);
 917 }
 918 
 919 void WindowContext::set_level(int level) {
 920     if (level == com_sun_glass_ui_Window_Level_NORMAL) {
 921         on_top = false;
 922     } else if (level == com_sun_glass_ui_Window_Level_FLOATING
 923                || level == com_sun_glass_ui_Window_Level_TOPMOST) {
 924         on_top = true;
 925     }
 926     // We need to emulate always on top behaviour on child windows
 927 
</pre>
<hr />
<pre>
1198 void WindowContext::decrement_events_counter() {
1199     --events_processing_cnt;
1200 }
1201 
1202 size_t WindowContext::get_events_count() {
1203     return events_processing_cnt;
1204 }
1205 
1206 ///////////////////////// PROTECTED
1207 
1208 void WindowContext::applyShapeMask(void *data, uint width, uint height) {
1209     if (frame_type != TRANSPARENT) {
1210         return;
1211     }
1212 
1213     glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
1214 }
1215 
1216 ///////////////////////// PRIVATE
1217 
<span class="line-modified">1218 // This function calculate the deltas between window and window + decoration (titlebar, borders).</span>
1219 // It&#39;s used when the window manager does not support the _NET_FRAME_EXTENTS extension or when
1220 // it&#39;s not received on time.
1221 void WindowContext::calculate_adjustments() {

1222     if (frame_type != TITLED || geometry.frame_extents_received) {
1223         return;
1224     }
1225 
1226     gint x, y, rx, ry;
1227     gdk_window_get_origin(gdk_window, &amp;x, &amp;y);
1228     gdk_window_get_root_origin(gdk_window, &amp;rx, &amp;ry);
1229 
1230     if (rx != x || ry != y) {
1231         // the left extends are correct - the right one is guessed to be the same
1232         geometry.adjust_w = (x - rx) * 2;
1233         // guess that bottom size is the same as left and right
1234         geometry.adjust_h = (y - ry) + (x - rx);
1235 
1236         // those will be correct
1237         geometry.view_x = (x - rx);
1238         geometry.view_y = (y - ry);
1239 
1240         if (geometry.needs_ajustment) {
1241             set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
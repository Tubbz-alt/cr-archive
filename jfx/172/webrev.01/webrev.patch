diff a/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/ComboBoxListViewBehavior.java b/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/ComboBoxListViewBehavior.java
--- a/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/ComboBoxListViewBehavior.java
+++ b/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/ComboBoxListViewBehavior.java
@@ -24,57 +24,11 @@
  */
 
 package com.sun.javafx.scene.control.behavior;
 
 import javafx.scene.control.ComboBox;
-import javafx.scene.control.ComboBoxBase;
-import javafx.scene.control.SelectionModel;
-import com.sun.javafx.scene.control.inputmap.InputMap;
-
-import static javafx.scene.input.KeyCode.DOWN;
-import static javafx.scene.input.KeyCode.UP;
 
 public class ComboBoxListViewBehavior<T> extends ComboBoxBaseBehavior<T> {
-
-    /***************************************************************************
-     *                                                                         *
-     * Constructors                                                            *
-     *                                                                         *
-     **************************************************************************/
-
-    /**
-     *
-     */
     public ComboBoxListViewBehavior(final ComboBox<T> comboBox) {
         super(comboBox);
-
-        // Add these bindings as a child input map, so they take precedence
-        InputMap<ComboBoxBase<T>> comboBoxListViewInputMap = new InputMap<>(comboBox);
-        comboBoxListViewInputMap.getMappings().addAll(
-            new InputMap.KeyMapping(UP, e -> selectPrevious()),
-            new InputMap.KeyMapping(DOWN, e -> selectNext())
-        );
-        addDefaultChildMap(getInputMap(), comboBoxListViewInputMap);
-    }
-
-    /***************************************************************************
-     *                                                                         *
-     * Key event handling                                                      *
-     *                                                                         *
-     **************************************************************************/
-
-    private ComboBox<T> getComboBox() {
-        return (ComboBox<T>) getNode();
-    }
-
-    private void selectPrevious() {
-        SelectionModel<T> sm = getComboBox().getSelectionModel();
-        if (sm == null) return;
-        sm.selectPrevious();
-    }
-
-    private void selectNext() {
-        SelectionModel<T> sm = getComboBox().getSelectionModel();
-        if (sm == null) return;
-        sm.selectNext();
     }
 }
diff a/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/FocusTraversalInputMap.java b/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/FocusTraversalInputMap.java
--- a/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/FocusTraversalInputMap.java
+++ b/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/FocusTraversalInputMap.java
@@ -43,34 +43,47 @@
 import static javafx.scene.input.KeyCode.UP;
 
 public class FocusTraversalInputMap<N extends Node> {
 
     private static final List<InputMap.Mapping<?>> mappings = new ArrayList<>();
+    private static final List<InputMap.Mapping<?>> arrowKeyMappings = new ArrayList<>();
+    private static final List<InputMap.Mapping<?>> modifierArrowKeyMappings = new ArrayList<>();
     static {
-        mappings.add(new KeyMapping(UP, e -> traverseUp(e)));
-        mappings.add(new KeyMapping(DOWN, e -> traverseDown(e)));
-        mappings.add(new KeyMapping(LEFT, e -> traverseLeft(e)));
-        mappings.add(new KeyMapping(RIGHT, e -> traverseRight(e)));
-        mappings.add(new KeyMapping(TAB, e -> traverseNext(e)));
-        mappings.add(new KeyMapping(new KeyBinding(TAB).shift(), e -> traversePrevious(e)));
+        arrowKeyMappings.add(new KeyMapping(UP, e -> traverseUp(e)));
+        arrowKeyMappings.add(new KeyMapping(DOWN, e -> traverseDown(e)));
+        arrowKeyMappings.add(new KeyMapping(LEFT, e -> traverseLeft(e)));
+        arrowKeyMappings.add(new KeyMapping(RIGHT, e -> traverseRight(e)));
 
-        mappings.add(new KeyMapping(new KeyBinding(UP).shift().alt().ctrl(), e -> traverseUp(e)));
-        mappings.add(new KeyMapping(new KeyBinding(DOWN).shift().alt().ctrl(), e -> traverseDown(e)));
-        mappings.add(new KeyMapping(new KeyBinding(LEFT).shift().alt().ctrl(), e -> traverseLeft(e)));
-        mappings.add(new KeyMapping(new KeyBinding(RIGHT).shift().alt().ctrl(), e -> traverseRight(e)));
-        mappings.add(new KeyMapping(new KeyBinding(TAB).shift().alt().ctrl(), e -> traverseNext(e)));
-        mappings.add(new KeyMapping(new KeyBinding(TAB).alt().ctrl(), e -> traversePrevious(e)));
+        modifierArrowKeyMappings.add(new KeyMapping(TAB, e -> traverseNext(e)));
+        modifierArrowKeyMappings.add(new KeyMapping(new KeyBinding(TAB).shift(), e -> traversePrevious(e)));
+        modifierArrowKeyMappings.add(new KeyMapping(new KeyBinding(UP).shift().alt().ctrl(), e -> traverseUp(e)));
+        modifierArrowKeyMappings.add(new KeyMapping(new KeyBinding(DOWN).shift().alt().ctrl(), e -> traverseDown(e)));
+        modifierArrowKeyMappings.add(new KeyMapping(new KeyBinding(LEFT).shift().alt().ctrl(), e -> traverseLeft(e)));
+        modifierArrowKeyMappings.add(new KeyMapping(new KeyBinding(RIGHT).shift().alt().ctrl(), e -> traverseRight(e)));
+        modifierArrowKeyMappings.add(new KeyMapping(new KeyBinding(TAB).shift().alt().ctrl(), e -> traverseNext(e)));
+        modifierArrowKeyMappings.add(new KeyMapping(new KeyBinding(TAB).alt().ctrl(), e -> traversePrevious(e)));
+
+        mappings.addAll(arrowKeyMappings);
+        mappings.addAll(modifierArrowKeyMappings);
     }
 
     private FocusTraversalInputMap() {
         // no-op, just forcing use of static method
     }
 
     public static InputMap.Mapping<?>[] getFocusTraversalMappings() {
         return mappings.toArray(new InputMap.Mapping[mappings.size()]);
     }
 
+    public static InputMap.Mapping<?>[] getArrowKeyMappings() {
+        return arrowKeyMappings.toArray(new InputMap.Mapping[arrowKeyMappings.size()]);
+    }
+
+    public static InputMap.Mapping<?>[] getModifierArrowKeyMappings() {
+        return modifierArrowKeyMappings.toArray(new InputMap.Mapping[modifierArrowKeyMappings.size()]);
+    }
+
     public static <N extends Node> InputMap<N> createInputMap(N node) {
         InputMap<N> inputMap = new InputMap<>(node);
         inputMap.getMappings().addAll(getFocusTraversalMappings());
         return inputMap;
     }
diff a/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/ListViewBehavior.java b/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/ListViewBehavior.java
--- a/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/ListViewBehavior.java
+++ b/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/ListViewBehavior.java
@@ -76,11 +76,11 @@
 
         // create a map for listView-specific mappings
         listViewInputMap = createInputMap();
 
         // add focus traversal mappings
-        addDefaultMapping(listViewInputMap, FocusTraversalInputMap.getFocusTraversalMappings());
+        addDefaultMapping(listViewInputMap, FocusTraversalInputMap.getModifierArrowKeyMappings());
         addDefaultMapping(listViewInputMap,
             new KeyMapping(HOME, e -> selectFirstRow()),
             new KeyMapping(END, e -> selectLastRow()),
             new KeyMapping(new KeyBinding(HOME).shift(), e -> selectAllToFirstRow()),
             new KeyMapping(new KeyBinding(END).shift(), e -> selectAllToLastRow()),
@@ -96,11 +96,10 @@
             new KeyMapping(ENTER, e -> activate()),
             new KeyMapping(SPACE, e -> activate()),
             new KeyMapping(F2, e -> activate()),
             new KeyMapping(ESCAPE, e -> cancelEdit()),
 
-            new KeyMapping(new KeyBinding(A).shortcut(), e -> selectAll()),
             new KeyMapping(new KeyBinding(HOME).shortcut(), e -> focusFirstRow()),
             new KeyMapping(new KeyBinding(END).shortcut(), e -> focusLastRow()),
             new KeyMapping(new KeyBinding(PAGE_UP).shortcut(), e -> focusPageUp()),
             new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut(), e -> focusPageDown()),
 
@@ -195,10 +194,17 @@
         if (Utils.isTwoLevelFocus()) {
             tlFocus = new TwoLevelFocusListBehavior(control); // needs to be last.
         }
     }
 
+    public void updateSelectionModeKeyMapping(SelectionMode selectionMode) {
+        if (selectionMode.equals(SelectionMode.SINGLE)) {
+            removeMapping(new KeyBinding(A).shortcut());
+        } else {
+            addDefaultMapping(listViewInputMap, new KeyMapping(new KeyBinding(A).shortcut(), e -> selectAll()));
+        }
+    }
 
 
     /***************************************************************************
      *                                                                         *
      * Implementation of BehaviorBase API                                      *
diff a/modules/javafx.controls/src/main/java/javafx/scene/control/skin/ListViewSkin.java b/modules/javafx.controls/src/main/java/javafx/scene/control/skin/ListViewSkin.java
--- a/modules/javafx.controls/src/main/java/javafx/scene/control/skin/ListViewSkin.java
+++ b/modules/javafx.controls/src/main/java/javafx/scene/control/skin/ListViewSkin.java
@@ -29,10 +29,12 @@
 import java.util.List;
 
 import com.sun.javafx.scene.control.Properties;
 import javafx.beans.InvalidationListener;
 import javafx.beans.WeakInvalidationListener;
+import javafx.beans.value.ChangeListener;
+import javafx.beans.value.WeakChangeListener;
 import javafx.collections.FXCollections;
 import javafx.collections.ListChangeListener;
 import javafx.collections.MapChangeListener;
 import javafx.collections.ObservableList;
 import javafx.collections.ObservableMap;
@@ -48,10 +50,11 @@
 import javafx.scene.control.IndexedCell;
 import javafx.scene.control.Label;
 import javafx.scene.control.ListCell;
 import javafx.scene.control.ListView;
 import javafx.scene.control.MultipleSelectionModel;
+import javafx.scene.control.SelectionMode;
 import javafx.scene.control.SelectionModel;
 import com.sun.javafx.scene.control.behavior.ListViewBehavior;
 import javafx.scene.input.MouseEvent;
 import javafx.scene.layout.StackPane;
 
@@ -258,12 +261,33 @@
         });
         registerChangeListener(control.placeholderProperty(), o -> updatePlaceholderRegionVisibility());
         registerChangeListener(control.fixedCellSizeProperty(), o ->
             flow.setFixedCellSize(control.getFixedCellSize())
         );
+
+        if (control.getSelectionModel() != null) {
+            behavior.updateSelectionModeKeyMapping(control.getSelectionModel().getSelectionMode());
+            control.getSelectionModel().selectionModeProperty().addListener(weakSelectionModeCL);
+        }
+        control.selectionModelProperty().addListener(weakSelectionModelCL);
     }
 
+    ChangeListener<SelectionMode> selectionModeCL = (ov, oldMode, newMode) -> {
+        behavior.updateSelectionModeKeyMapping(newMode);
+    };
+    WeakChangeListener<SelectionMode> weakSelectionModeCL = new WeakChangeListener<>(selectionModeCL);
+
+    ChangeListener<MultipleSelectionModel<?>> selectionModelCL = (ov, oldSM, newSM) -> {
+        if (oldSM != null) {
+            oldSM.selectionModeProperty().removeListener(weakSelectionModeCL);
+        }
+        if (newSM != null) {
+            behavior.updateSelectionModeKeyMapping(newSM.getSelectionMode());
+            newSM.selectionModeProperty().addListener(weakSelectionModeCL);
+        }
+    };
+    WeakChangeListener<MultipleSelectionModel<?>> weakSelectionModelCL = new WeakChangeListener<>(selectionModelCL);
 
 
     /***************************************************************************
      *                                                                         *
      * Public API                                                              *
@@ -278,10 +302,14 @@
         getSkinnable().itemsProperty().removeListener(weakItemsChangeListener);
         if (listViewItems != null) {
             listViewItems.removeListener(weakListViewItemsListener);
             listViewItems = null;
         }
+        getSkinnable().selectionModelProperty().removeListener(weakSelectionModelCL);
+        if (getSkinnable().getSelectionModel() != null) {
+            getSkinnable().getSelectionModel().selectionModeProperty().removeListener(weakSelectionModeCL);
+        }
         // flow related cleanup
         // leaking without nulling factory
         flow.setCellFactory(null);
         // for completeness - but no effect with/out?
         flow.getVbar().removeEventFilter(MouseEvent.MOUSE_PRESSED, ml);
diff a/modules/javafx.controls/src/test/java/test/javafx/scene/control/ComboBoxTest.java b/modules/javafx.controls/src/test/java/test/javafx/scene/control/ComboBoxTest.java
--- a/modules/javafx.controls/src/test/java/test/javafx/scene/control/ComboBoxTest.java
+++ b/modules/javafx.controls/src/test/java/test/javafx/scene/control/ComboBoxTest.java
@@ -1332,10 +1332,46 @@
         assertTrue(cb.isShowing());
 
         sl.dispose();
     }
 
+    @Test public void test_ArrowKeysWhenPopupIsShowing() {
+        final ComboBox<String> cb = new ComboBox<>(FXCollections.observableArrayList("a", "b", "c"));
+        cb.setEditable(true);
+        StageLoader sl = new StageLoader(cb);
+        KeyEventFirer keyboard = new KeyEventFirer(cb);
+
+        new StageLoader(cb);
+
+        assertFalse(cb.isShowing());
+        cb.requestFocus();
+        keyboard.doDownArrowPress(KeyModifier.ALT);  // show the popup
+        assertTrue(cb.isShowing());
+
+        // Enter some text
+        keyboard.doKeyTyped(KeyCode.A);
+        keyboard.doKeyTyped(KeyCode.C);
+        assertEquals("AC", cb.getEditor().getText());
+
+        // Test LEFT key
+        keyboard.doLeftArrowPress();
+        keyboard.doKeyTyped(KeyCode.B);
+        assertEquals("ABC", cb.getEditor().getText());
+
+        // Test RIGHT key
+        keyboard.doRightArrowPress();
+        keyboard.doKeyTyped(KeyCode.D);
+        assertEquals("ABCD", cb.getEditor().getText());
+
+        // Test CTRL + A key
+        assertEquals("", cb.getEditor().getSelectedText());
+        keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
+        assertEquals("ABCD", cb.getEditor().getSelectedText());
+
+        sl.dispose();
+    }
+
     @Test public void test_rt36280_nonEditable_enterHidesShowingPopup() {
         final ComboBox<String> cb = new ComboBox<>(FXCollections.observableArrayList("a", "b", "c"));
         StageLoader sl = new StageLoader(cb);
         KeyEventFirer cbKeyboard = new KeyEventFirer(cb);
 
diff a/modules/javafx.controls/src/test/java/test/javafx/scene/control/ListViewTest.java b/modules/javafx.controls/src/test/java/test/javafx/scene/control/ListViewTest.java
--- a/modules/javafx.controls/src/test/java/test/javafx/scene/control/ListViewTest.java
+++ b/modules/javafx.controls/src/test/java/test/javafx/scene/control/ListViewTest.java
@@ -169,10 +169,44 @@
         MultipleSelectionModel<String> sm = ListViewShim.<String>getListViewBitSetSelectionModel(listView);
         listView.setSelectionModel(sm);
         assertSame(sm, sm);
     }
 
+    @Test public void test_SwitchingSelectionModel() {
+        ListView<String> listView = new ListView<>();
+        listView.getItems().addAll("a", "b", "c", "d");
+
+        MultipleSelectionModel<String> sm;
+        StageLoader sl = new StageLoader(listView);
+        KeyEventFirer keyboard = new KeyEventFirer(listView);
+
+        MultipleSelectionModel<String> smMultiple = ListViewShim.<String>getListViewBitSetSelectionModel(listView);
+        smMultiple.setSelectionMode(SelectionMode.MULTIPLE);
+        MultipleSelectionModel<String> smSingle = ListViewShim.<String>getListViewBitSetSelectionModel(listView);
+        smSingle.setSelectionMode(SelectionMode.SINGLE);
+
+        listView.setSelectionModel(smMultiple);
+        sm = listView.getSelectionModel();
+
+        assertEquals(0, sm.getSelectedItems().size());
+        sm.clearAndSelect(0);
+        assertEquals(1, sm.getSelectedItems().size());
+        keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
+        assertEquals(4, sm.getSelectedItems().size());
+
+        listView.setSelectionModel(smSingle);
+        sm = listView.getSelectionModel();
+
+        assertEquals(0, sm.getSelectedItems().size());
+        sm.clearAndSelect(0);
+        assertEquals(1, sm.getSelectedItems().size());
+        keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
+        assertEquals(1, sm.getSelectedItems().size());
+
+        sl.dispose();
+    }
+
     @Test public void canSetSelectedItemToAnItemEvenWhenThereAreNoItems() {
         final String randomString = new String("I AM A CRAZY RANDOM STRING");
         sm.select(randomString);
         assertEquals(-1, sm.getSelectedIndex());
         assertSame(randomString, sm.getSelectedItem());
@@ -1463,10 +1497,41 @@
         assertEquals("b", sm.getSelectedItems().get(1));
 
         sl.dispose();
     }
 
+    @Test public void test_switchingSelectionMode() {
+        ListView<String> listView = new ListView<>();
+        listView.getItems().addAll("a", "b", "c", "d");
+
+        MultipleSelectionModel<String> sm = listView.getSelectionModel();
+        StageLoader sl = new StageLoader(listView);
+        KeyEventFirer keyboard = new KeyEventFirer(listView);
+
+        assertEquals(0, sm.getSelectedItems().size());
+        sm.clearAndSelect(0);
+        assertEquals(1, sm.getSelectedItems().size());
+        keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
+        assertEquals(1, sm.getSelectedItems().size());
+
+        sm.setSelectionMode(SelectionMode.MULTIPLE);
+        keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
+        assertEquals(4, sm.getSelectedItems().size());
+
+        sm.setSelectionMode(SelectionMode.SINGLE);
+        assertEquals(1, sm.getSelectedItems().size());
+        keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
+        assertEquals(1, sm.getSelectedItems().size());
+
+        sm.setSelectionMode(SelectionMode.MULTIPLE);
+        assertEquals(1, sm.getSelectedItems().size());
+        keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
+        assertEquals(4, sm.getSelectedItems().size());
+
+        sl.dispose();
+    }
+
     @Test public void test_rt_16068_firstElement_selectAndRemoveSameRow() {
         // select and then remove the 'a' item, selection and focus should both
         // stay at the first row, now 'b'
         test_rt_16068(0, 0, 0);
     }

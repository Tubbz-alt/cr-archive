<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/javafx/scene/control/skin/ListViewSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javafx.scene.control.skin;
 27 
 28 import java.util.ArrayList;
 29 import java.util.List;
 30 
 31 import com.sun.javafx.scene.control.Properties;
 32 import javafx.beans.InvalidationListener;
 33 import javafx.beans.WeakInvalidationListener;
 34 import javafx.beans.value.ChangeListener;
 35 import javafx.beans.value.WeakChangeListener;
 36 import javafx.collections.FXCollections;
 37 import javafx.collections.ListChangeListener;
 38 import javafx.collections.MapChangeListener;
 39 import javafx.collections.ObservableList;
 40 import javafx.collections.ObservableMap;
 41 import javafx.collections.WeakListChangeListener;
 42 import javafx.event.EventHandler;
 43 import javafx.geometry.Orientation;
 44 import javafx.scene.AccessibleAction;
 45 import javafx.scene.AccessibleAttribute;
 46 import javafx.scene.Node;
 47 import javafx.scene.control.Control;
 48 import javafx.scene.control.FocusModel;
 49 import javafx.scene.control.IndexedCell;
 50 import javafx.scene.control.Label;
 51 import javafx.scene.control.ListCell;
 52 import javafx.scene.control.ListView;
 53 import javafx.scene.control.MultipleSelectionModel;
 54 import javafx.scene.control.SelectionMode;
 55 import javafx.scene.control.SelectionModel;
 56 import com.sun.javafx.scene.control.behavior.ListViewBehavior;
 57 import javafx.scene.input.MouseEvent;
 58 import javafx.scene.layout.StackPane;
 59 
 60 import java.security.AccessController;
 61 import java.security.PrivilegedAction;
 62 
 63 import com.sun.javafx.scene.control.skin.resources.ControlResources;
 64 
 65 /**
 66  * Default skin implementation for the {@link ListView} control.
 67  *
 68  * @see ListView
 69  * @since 9
 70  */
 71 public class ListViewSkin&lt;T&gt; extends VirtualContainerBase&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; {
 72 
 73     /***************************************************************************
 74      *                                                                         *
 75      * Static Fields                                                           *
 76      *                                                                         *
 77      **************************************************************************/
 78 
 79     // RT-34744 : IS_PANNABLE will be false unless
 80     // javafx.scene.control.skin.ListViewSkin.pannable
 81     // is set to true. This is done in order to make ListView functional
 82     // on embedded systems with touch screens which do not generate scroll
 83     // events for touch drag gestures.
 84     private static final boolean IS_PANNABLE =
 85             AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.control.skin.ListViewSkin.pannable&quot;));
 86 
 87 
 88 
 89     /***************************************************************************
 90      *                                                                         *
 91      * Internal Fields                                                         *
 92      *                                                                         *
 93      **************************************************************************/
 94 
 95     // JDK-8090129: This constant should not be static, because the
 96     // Locale may change between instances.
 97     private static final String EMPTY_LIST_TEXT = ControlResources.getString(&quot;ListView.noContent&quot;);
 98 
 99     private final VirtualFlow&lt;ListCell&lt;T&gt;&gt; flow;
100 
101     /**
102      * Region placed over the top of the flow (and possibly the header row) if
103      * there is no data.
104      */
105     // FIXME this should not be a StackPane
106     private StackPane placeholderRegion;
107     private Node placeholderNode;
108 
109     private ObservableList&lt;T&gt; listViewItems;
110     private final InvalidationListener itemsChangeListener = observable -&gt; updateListViewItems();
111 
112     private boolean needCellsRebuilt = true;
113     private boolean needCellsReconfigured = false;
114 
115     private int itemCount = -1;
116     private ListViewBehavior&lt;T&gt; behavior;
117 
118 
119 
120     /***************************************************************************
121      *                                                                         *
122      * Listeners                                                               *
123      *                                                                         *
124      **************************************************************************/
125 
126     private MapChangeListener&lt;Object, Object&gt; propertiesMapListener = c -&gt; {
127         if (! c.wasAdded()) return;
128         if (Properties.RECREATE.equals(c.getKey())) {
129             needCellsRebuilt = true;
130             getSkinnable().requestLayout();
131             getSkinnable().getProperties().remove(Properties.RECREATE);
132         }
133     };
134 
135     private final ListChangeListener&lt;T&gt; listViewItemsListener = new ListChangeListener&lt;T&gt;() {
136         @Override public void onChanged(Change&lt;? extends T&gt; c) {
137             while (c.next()) {
138                 if (c.wasReplaced()) {
139                     // RT-28397: Support for when an item is replaced with itself (but
140                     // updated internal values that should be shown visually).
141                     // This code was updated for RT-36714 to not update all cells,
142                     // just those affected by the change
143                     for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
144                         flow.setCellDirty(i);
145                     }
146 
147                     break;
148                 } else if (c.getRemovedSize() == itemCount) {
149                     // RT-22463: If the user clears out an items list then we
150                     // should reset all cells (in particular their contained
151                     // items) such that a subsequent addition to the list of
152                     // an item which equals the old item (but is rendered
153                     // differently) still displays as expected (i.e. with the
154                     // updated display, not the old display).
155                     itemCount = 0;
156                     break;
157                 }
158             }
159 
160             // fix for RT-37853
161             getSkinnable().edit(-1);
162 
163             markItemCountDirty();
164             getSkinnable().requestLayout();
165         }
166     };
167 
168     private final WeakListChangeListener&lt;T&gt; weakListViewItemsListener =
169             new WeakListChangeListener&lt;T&gt;(listViewItemsListener);
170 
171 
172 
173     /***************************************************************************
174      *                                                                         *
175      * Constructors                                                            *
176      *                                                                         *
177      **************************************************************************/
178 
179     /**
180      * Creates a new ListViewSkin instance, installing the necessary child
181      * nodes into the Control {@link Control#getChildren() children} list, as
182      * well as the necessary input mappings for handling key, mouse, etc events.
183      *
184      * @param control The control that this skin should be installed onto.
185      */
186     public ListViewSkin(final ListView&lt;T&gt; control) {
187         super(control);
188 
189         // install default input map for the ListView control
190         behavior = new ListViewBehavior&lt;&gt;(control);
191 //        control.setInputMap(behavior.getInputMap());
192 
193         // init the behavior &#39;closures&#39;
194         behavior.setOnFocusPreviousRow(() -&gt; onFocusPreviousCell());
195         behavior.setOnFocusNextRow(() -&gt; onFocusNextCell());
196         behavior.setOnMoveToFirstCell(() -&gt; onMoveToFirstCell());
197         behavior.setOnMoveToLastCell(() -&gt; onMoveToLastCell());
198         behavior.setOnSelectPreviousRow(() -&gt; onSelectPreviousCell());
199         behavior.setOnSelectNextRow(() -&gt; onSelectNextCell());
200         behavior.setOnScrollPageDown(this::onScrollPageDown);
201         behavior.setOnScrollPageUp(this::onScrollPageUp);
202 
203         updateListViewItems();
204 
205         // init the VirtualFlow
206         flow = getVirtualFlow();
207         flow.setId(&quot;virtual-flow&quot;);
208         flow.setPannable(IS_PANNABLE);
209         flow.setVertical(control.getOrientation() == Orientation.VERTICAL);
210         flow.setCellFactory(flow -&gt; createCell());
211         flow.setFixedCellSize(control.getFixedCellSize());
212         getChildren().add(flow);
213 
214         EventHandler&lt;MouseEvent&gt; ml = event -&gt; {
215             // RT-15127: cancel editing on scroll. This is a bit extreme
216             // (we are cancelling editing on touching the scrollbars).
217             // This can be improved at a later date.
218             if (control.getEditingIndex() &gt; -1) {
219                 control.edit(-1);
220             }
221 
222             // This ensures that the list maintains the focus, even when the vbar
223             // and hbar controls inside the flow are clicked. Without this, the
224             // focus border will not be shown when the user interacts with the
225             // scrollbars, and more importantly, keyboard navigation won&#39;t be
226             // available to the user.
227             if (control.isFocusTraversable()) {
228                 control.requestFocus();
229             }
230         };
231         flow.getVbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);
232         flow.getHbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);
233 
234         updateItemCount();
235 
236         control.itemsProperty().addListener(new WeakInvalidationListener(itemsChangeListener));
237 
238         final ObservableMap&lt;Object, Object&gt; properties = control.getProperties();
239         properties.remove(Properties.RECREATE);
240         properties.addListener(propertiesMapListener);
241 
242         // Register listeners
243         registerChangeListener(control.itemsProperty(), o -&gt; updateListViewItems());
244         registerChangeListener(control.orientationProperty(), o -&gt;
245             flow.setVertical(control.getOrientation() == Orientation.VERTICAL)
246         );
247         registerChangeListener(control.cellFactoryProperty(), o -&gt; flow.recreateCells());
248         registerChangeListener(control.parentProperty(), o -&gt; {
249             if (control.getParent() != null &amp;&amp; control.isVisible()) {
250                 control.requestLayout();
251             }
252         });
253         registerChangeListener(control.placeholderProperty(), o -&gt; updatePlaceholderRegionVisibility());
254         registerChangeListener(control.fixedCellSizeProperty(), o -&gt;
255             flow.setFixedCellSize(control.getFixedCellSize())
256         );
257 
258         if (control.getSelectionModel() != null) {
259             behavior.updateSelectionModeKeyMapping(control.getSelectionModel().getSelectionMode());
260             control.getSelectionModel().selectionModeProperty().addListener(weakSelectionModeCL);
261         }
262         control.selectionModelProperty().addListener(weakSelectionModelCL);
263     }
264 
265     ChangeListener&lt;SelectionMode&gt; selectionModeCL = (ov, oldMode, newMode) -&gt; {
266         behavior.updateSelectionModeKeyMapping(newMode);
267     };
268     WeakChangeListener&lt;SelectionMode&gt; weakSelectionModeCL = new WeakChangeListener&lt;&gt;(selectionModeCL);
269 
270     ChangeListener&lt;MultipleSelectionModel&lt;?&gt;&gt; selectionModelCL = (ov, oldSM, newSM) -&gt; {
271         if (oldSM != null) {
272             oldSM.selectionModeProperty().removeListener(weakSelectionModeCL);
273         }
274         if (newSM != null) {
275             behavior.updateSelectionModeKeyMapping(newSM.getSelectionMode());
276             newSM.selectionModeProperty().addListener(weakSelectionModeCL);
277         }
278     };
279     WeakChangeListener&lt;MultipleSelectionModel&lt;?&gt;&gt; weakSelectionModelCL = new WeakChangeListener&lt;&gt;(selectionModelCL);
280 
281 
282     /***************************************************************************
283      *                                                                         *
284      * Public API                                                              *
285      *                                                                         *
286      **************************************************************************/
287 
288     /** {@inheritDoc} */
289     @Override public void dispose() {
290         getSkinnable().selectionModelProperty().removeListener(weakSelectionModelCL);
291         if (getSkinnable().getSelectionModel() != null) {
292             getSkinnable().getSelectionModel().selectionModeProperty().removeListener(weakSelectionModeCL);
293         }
294         super.dispose();
295 
296         if (behavior != null) {
297             behavior.dispose();
298         }
299     }
300 
301     /** {@inheritDoc} */
302     @Override protected void layoutChildren(final double x, final double y,
303                                             final double w, final double h) {
304         super.layoutChildren(x, y, w, h);
305 
306         if (needCellsRebuilt) {
307             flow.rebuildCells();
308         } else if (needCellsReconfigured) {
309             flow.reconfigureCells();
310         }
311 
312         needCellsRebuilt = false;
313         needCellsReconfigured = false;
314 
315         if (getItemCount() == 0) {
316             // show message overlay instead of empty listview
317             if (placeholderRegion != null) {
318                 placeholderRegion.setVisible(w &gt; 0 &amp;&amp; h &gt; 0);
319                 placeholderRegion.resizeRelocate(x, y, w, h);
320             }
321         } else {
322             flow.resizeRelocate(x, y, w, h);
323         }
324     }
325 
326     /** {@inheritDoc} */
327     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
328         checkState();
329 
330         if (getItemCount() == 0) {
331             if (placeholderRegion == null) {
332                 updatePlaceholderRegionVisibility();
333             }
334             if (placeholderRegion != null) {
335                 return placeholderRegion.prefWidth(height) + leftInset + rightInset;
336             }
337         }
338 
339         return computePrefHeight(-1, topInset, rightInset, bottomInset, leftInset) * 0.618033987;
340     }
341 
342     /** {@inheritDoc} */
343     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
344         return 400;
345     }
346 
347     /** {@inheritDoc} */
348     @Override protected int getItemCount() {
349         return itemCount;
350     }
351 
352     /** {@inheritDoc} */
353     @Override protected void updateItemCount() {
354         if (flow == null) return;
355 
356         int oldCount = itemCount;
357         int newCount = listViewItems == null ? 0 : listViewItems.size();
358 
359         itemCount = newCount;
360 
361         flow.setCellCount(newCount);
362 
363         updatePlaceholderRegionVisibility();
364         if (newCount != oldCount) {
365             requestRebuildCells();
366         } else {
367             needCellsReconfigured = true;
368         }
369     }
370 
371     /** {@inheritDoc} */
372     @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
373         switch (attribute) {
374             case FOCUS_ITEM: {
375                 FocusModel&lt;?&gt; fm = getSkinnable().getFocusModel();
376                 int focusedIndex = fm.getFocusedIndex();
377                 if (focusedIndex == -1) {
378                     if (placeholderRegion != null &amp;&amp; placeholderRegion.isVisible()) {
379                         return placeholderRegion.getChildren().get(0);
380                     }
381                     if (getItemCount() &gt; 0) {
382                         focusedIndex = 0;
383                     } else {
384                         return null;
385                     }
386                 }
387                 return flow.getPrivateCell(focusedIndex);
388             }
389             case ITEM_COUNT: return getItemCount();
390             case ITEM_AT_INDEX: {
391                 Integer rowIndex = (Integer)parameters[0];
392                 if (rowIndex == null) return null;
393                 if (0 &lt;= rowIndex &amp;&amp; rowIndex &lt; getItemCount()) {
394                     return flow.getPrivateCell(rowIndex);
395                 }
396                 return null;
397             }
398             case SELECTED_ITEMS: {
399                 MultipleSelectionModel&lt;T&gt; sm = getSkinnable().getSelectionModel();
400                 ObservableList&lt;Integer&gt; indices = sm.getSelectedIndices();
401                 List&lt;Node&gt; selection = new ArrayList&lt;&gt;(indices.size());
402                 for (int i : indices) {
403                     ListCell&lt;T&gt; row = flow.getPrivateCell(i);
404                     if (row != null) selection.add(row);
405                 }
406                 return FXCollections.observableArrayList(selection);
407             }
408             case VERTICAL_SCROLLBAR: return flow.getVbar();
409             case HORIZONTAL_SCROLLBAR: return flow.getHbar();
410             default: return super.queryAccessibleAttribute(attribute, parameters);
411         }
412     }
413 
414     /** {@inheritDoc} */
415     @Override protected void executeAccessibleAction(AccessibleAction action, Object... parameters) {
416         switch (action) {
417             case SHOW_ITEM: {
418                 Node item = (Node)parameters[0];
419                 if (item instanceof ListCell) {
420                     @SuppressWarnings(&quot;unchecked&quot;)
421                     ListCell&lt;T&gt; cell = (ListCell&lt;T&gt;)item;
422                     flow.scrollTo(cell.getIndex());
423                 }
424                 break;
425             }
426             case SET_SELECTED_ITEMS: {
427                 @SuppressWarnings(&quot;unchecked&quot;)
428                 ObservableList&lt;Node&gt; items = (ObservableList&lt;Node&gt;)parameters[0];
429                 if (items != null) {
430                     MultipleSelectionModel&lt;T&gt; sm = getSkinnable().getSelectionModel();
431                     if (sm != null) {
432                         sm.clearSelection();
433                         for (Node item : items) {
434                             if (item instanceof ListCell) {
435                                 @SuppressWarnings(&quot;unchecked&quot;)
436                                 ListCell&lt;T&gt; cell = (ListCell&lt;T&gt;)item;
437                                 sm.select(cell.getIndex());
438                             }
439                         }
440                     }
441                 }
442                 break;
443             }
444             default: super.executeAccessibleAction(action, parameters);
445         }
446     }
447 
448 
449 
450     /***************************************************************************
451      *                                                                         *
452      * Private implementation                                                  *
453      *                                                                         *
454      **************************************************************************/
455 
456     /** {@inheritDoc} */
457     private ListCell&lt;T&gt; createCell() {
458         ListCell&lt;T&gt; cell;
459         if (getSkinnable().getCellFactory() != null) {
460             cell = getSkinnable().getCellFactory().call(getSkinnable());
461         } else {
462             cell = createDefaultCellImpl();
463         }
464 
465         cell.updateListView(getSkinnable());
466 
467         return cell;
468     }
469 
470     private void updateListViewItems() {
471         if (listViewItems != null) {
472             listViewItems.removeListener(weakListViewItemsListener);
473         }
474 
475         this.listViewItems = getSkinnable().getItems();
476 
477         if (listViewItems != null) {
478             listViewItems.addListener(weakListViewItemsListener);
479         }
480 
481         markItemCountDirty();
482         getSkinnable().requestLayout();
483     }
484 
485     private final void updatePlaceholderRegionVisibility() {
486         boolean visible = getItemCount() == 0;
487 
488         if (visible) {
489             placeholderNode = getSkinnable().getPlaceholder();
490             if (placeholderNode == null &amp;&amp; (EMPTY_LIST_TEXT != null &amp;&amp; ! EMPTY_LIST_TEXT.isEmpty())) {
491                 placeholderNode = new Label();
492                 ((Label)placeholderNode).setText(EMPTY_LIST_TEXT);
493             }
494 
495             if (placeholderNode != null) {
496                 if (placeholderRegion == null) {
497                     placeholderRegion = new StackPane();
498                     placeholderRegion.getStyleClass().setAll(&quot;placeholder&quot;);
499                     getChildren().add(placeholderRegion);
500                 }
501 
502                 placeholderRegion.getChildren().setAll(placeholderNode);
503             }
504         }
505 
506         flow.setVisible(!visible);
507         if (placeholderRegion != null) {
508             placeholderRegion.setVisible(visible);
509         }
510     }
511 
512     private static &lt;T&gt; ListCell&lt;T&gt; createDefaultCellImpl() {
513         return new ListCell&lt;T&gt;() {
514             @Override public void updateItem(T item, boolean empty) {
515                 super.updateItem(item, empty);
516 
517                 if (empty) {
518                     setText(null);
519                     setGraphic(null);
520                 } else if (item instanceof Node) {
521                     setText(null);
522                     Node currentNode = getGraphic();
523                     Node newNode = (Node) item;
524                     if (currentNode == null || ! currentNode.equals(newNode)) {
525                         setGraphic(newNode);
526                     }
527                 } else {
528                     /**
529                      * This label is used if the item associated with this cell is to be
530                      * represented as a String. While we will lazily instantiate it
531                      * we never clear it, being more afraid of object churn than a minor
532                      * &quot;leak&quot; (which will not become a &quot;major&quot; leak).
533                      */
534                     setText(item == null ? &quot;null&quot; : item.toString());
535                     setGraphic(null);
536                 }
537             }
538         };
539     }
540 
541     private void onFocusPreviousCell() {
542         FocusModel&lt;T&gt; fm = getSkinnable().getFocusModel();
543         if (fm == null) return;
544         flow.scrollTo(fm.getFocusedIndex());
545     }
546 
547     private void onFocusNextCell() {
548         FocusModel&lt;T&gt; fm = getSkinnable().getFocusModel();
549         if (fm == null) return;
550         flow.scrollTo(fm.getFocusedIndex());
551     }
552 
553     private void onSelectPreviousCell() {
554         SelectionModel&lt;T&gt; sm = getSkinnable().getSelectionModel();
555         if (sm == null) return;
556 
557         int pos = sm.getSelectedIndex();
558         flow.scrollTo(pos);
559 
560         // Fix for RT-11299
561         IndexedCell&lt;T&gt; cell = flow.getFirstVisibleCell();
562         if (cell == null || pos &lt; cell.getIndex()) {
563             flow.setPosition(pos / (double) getItemCount());
564         }
565     }
566 
567     private void onSelectNextCell() {
568         SelectionModel&lt;T&gt; sm = getSkinnable().getSelectionModel();
569         if (sm == null) return;
570 
571         int pos = sm.getSelectedIndex();
572         flow.scrollTo(pos);
573 
574         // Fix for RT-11299
575         ListCell&lt;T&gt; cell = flow.getLastVisibleCell();
576         if (cell == null || cell.getIndex() &lt; pos) {
577             flow.setPosition(pos / (double) getItemCount());
578         }
579     }
580 
581     private void onMoveToFirstCell() {
582         flow.scrollTo(0);
583         flow.setPosition(0);
584     }
585 
586     private void onMoveToLastCell() {
587 //        SelectionModel sm = getSkinnable().getSelectionModel();
588 //        if (sm == null) return;
589 //
590         int endPos = getItemCount() - 1;
591 //        sm.select(endPos);
592         flow.scrollTo(endPos);
593         flow.setPosition(1);
594     }
595 
596     /**
597      * Function used to scroll the container down by one &#39;page&#39;, although
598      * if this is a horizontal container, then the scrolling will be to the right.
599      */
600     private int onScrollPageDown(boolean isFocusDriven) {
601         ListCell&lt;T&gt; lastVisibleCell = flow.getLastVisibleCellWithinViewport();
602         if (lastVisibleCell == null) return -1;
603 
604         final SelectionModel&lt;T&gt; sm = getSkinnable().getSelectionModel();
605         final FocusModel&lt;T&gt; fm = getSkinnable().getFocusModel();
606         if (sm == null || fm == null) return -1;
607 
608         int lastVisibleCellIndex = lastVisibleCell.getIndex();
609 
610 //        boolean isSelected = sm.isSelected(lastVisibleCellIndex) || fm.isFocused(lastVisibleCellIndex) || lastVisibleCellIndex == anchor;
611         // isSelected represents focus OR selection
612         boolean isSelected = false;
613         if (isFocusDriven) {
614             isSelected = lastVisibleCell.isFocused() || fm.isFocused(lastVisibleCellIndex);
615         } else {
616             isSelected = lastVisibleCell.isSelected() || sm.isSelected(lastVisibleCellIndex);
617         }
618 
619         if (isSelected) {
620             boolean isLeadIndex = (isFocusDriven &amp;&amp; fm.getFocusedIndex() == lastVisibleCellIndex)
621                                || (! isFocusDriven &amp;&amp; sm.getSelectedIndex() == lastVisibleCellIndex);
622 
623             if (isLeadIndex) {
624                 // if the last visible cell is selected, we want to shift that cell up
625                 // to be the top-most cell, or at least as far to the top as we can go.
626                 flow.scrollToTop(lastVisibleCell);
627 
628                 ListCell&lt;T&gt; newLastVisibleCell = flow.getLastVisibleCellWithinViewport();
629                 lastVisibleCell = newLastVisibleCell == null ? lastVisibleCell : newLastVisibleCell;
630             }
631         } else {
632             // if the selection is not on the &#39;bottom&#39; most cell, we firstly move
633             // the selection down to that, without scrolling the contents, so
634             // this is a no-op
635         }
636 
637         int newSelectionIndex = lastVisibleCell.getIndex();
638         flow.scrollTo(lastVisibleCell);
639         return newSelectionIndex;
640     }
641 
642     /**
643      * Function used to scroll the container up by one &#39;page&#39;, although
644      * if this is a horizontal container, then the scrolling will be to the left.
645      */
646     private int onScrollPageUp(boolean isFocusDriven) {
647         ListCell&lt;T&gt; firstVisibleCell = flow.getFirstVisibleCellWithinViewport();
648         if (firstVisibleCell == null) return -1;
649 
650         final SelectionModel&lt;T&gt; sm = getSkinnable().getSelectionModel();
651         final FocusModel&lt;T&gt; fm = getSkinnable().getFocusModel();
652         if (sm == null || fm == null) return -1;
653 
654         int firstVisibleCellIndex = firstVisibleCell.getIndex();
655 
656         // isSelected represents focus OR selection
657         boolean isSelected = false;
658         if (isFocusDriven) {
659             isSelected = firstVisibleCell.isFocused() || fm.isFocused(firstVisibleCellIndex);
660         } else {
661             isSelected = firstVisibleCell.isSelected() || sm.isSelected(firstVisibleCellIndex);
662         }
663 
664         if (isSelected) {
665             boolean isLeadIndex = (isFocusDriven &amp;&amp; fm.getFocusedIndex() == firstVisibleCellIndex)
666                                || (! isFocusDriven &amp;&amp; sm.getSelectedIndex() == firstVisibleCellIndex);
667 
668             if (isLeadIndex) {
669                 // if the first visible cell is selected, we want to shift that cell down
670                 // to be the bottom-most cell, or at least as far to the bottom as we can go.
671                 flow.scrollToBottom(firstVisibleCell);
672 
673                 ListCell&lt;T&gt; newFirstVisibleCell = flow.getFirstVisibleCellWithinViewport();
674                 firstVisibleCell = newFirstVisibleCell == null ? firstVisibleCell : newFirstVisibleCell;
675             }
676         } else {
677             // if the selection is not on the &#39;top&#39; most cell, we firstly move
678             // the selection up to that, without scrolling the contents, so
679             // this is a no-op
680         }
681 
682         int newSelectionIndex = firstVisibleCell.getIndex();
683         flow.scrollTo(firstVisibleCell);
684         return newSelectionIndex;
685     }
686 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/test/java/test/javafx/scene/control/ListCellTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package test.javafx.scene.control;
 27 
 28 import javafx.scene.control.skin.ListCellSkin;
 29 import javafx.beans.InvalidationListener;
 30 import javafx.collections.FXCollections;
 31 import javafx.collections.ListChangeListener;
 32 import javafx.collections.ObservableList;
 33 
 34 import javafx.scene.control.FocusModel;
 35 import javafx.scene.control.ListCell;
 36 import javafx.scene.control.ListCellShim;
 37 import javafx.scene.control.ListView;
 38 import javafx.scene.control.MultipleSelectionModel;
 39 import javafx.scene.control.MultipleSelectionModelBaseShim;
 40 import javafx.scene.control.SelectionMode;
 41 import org.junit.Before;
 42 import org.junit.Ignore;
 43 import org.junit.Test;
 44 
<a name="1" id="anc1"></a><span class="line-added"> 45 import static javafx.scene.control.ControlShim.*;</span>
 46 import static test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils.*;
 47 import static org.junit.Assert.*;
 48 
 49 /**
 50  */
 51 public class ListCellTest {
 52     private ListCell&lt;String&gt; cell;
 53     private ListView&lt;String&gt; list;
 54     private ObservableList&lt;String&gt; model;
 55 
 56     @Before public void setup() {
 57         cell = new ListCell&lt;String&gt;();
 58         model = FXCollections.observableArrayList(&quot;Apples&quot;, &quot;Oranges&quot;, &quot;Pears&quot;);
 59         list = new ListView&lt;String&gt;(model);
 60     }
 61 
 62     /*********************************************************************
 63      * Tests for the constructors                                        *
 64      ********************************************************************/
 65 
 66     @Test public void styleClassIs_list_cell_byDefault() {
 67         assertStyleClassContains(cell, &quot;list-cell&quot;);
 68     }
 69 
 70     // The item should be null by default because the index is -1 by default
 71     @Test public void itemIsNullByDefault() {
 72         assertNull(cell.getItem());
 73     }
 74 
 75     /*********************************************************************
 76      * Tests for the listView property                                   *
 77      ********************************************************************/
 78 
 79     @Test public void listViewIsNullByDefault() {
 80         assertNull(cell.getListView());
 81         assertNull(cell.listViewProperty().get());
 82     }
 83 
 84     @Test public void updateListViewUpdatesListView() {
 85         cell.updateListView(list);
 86         assertSame(list, cell.getListView());
 87         assertSame(list, cell.listViewProperty().get());
 88     }
 89 
 90     @Test public void canSetListViewBackToNull() {
 91         cell.updateListView(list);
 92         cell.updateListView(null);
 93         assertNull(cell.getListView());
 94         assertNull(cell.listViewProperty().get());
 95     }
 96 
 97     @Test public void listViewPropertyReturnsCorrectBean() {
 98         assertSame(cell, cell.listViewProperty().getBean());
 99     }
100 
101     @Test public void listViewPropertyNameIs_listView() {
102         assertEquals(&quot;listView&quot;, cell.listViewProperty().getName());
103     }
104 
105     @Test public void updateListViewWithNullFocusModelResultsInNoException() {
106         cell.updateListView(list);
107         list.setFocusModel(null);
108         cell.updateListView(new ListView());
109     }
110 
111     @Test public void updateListViewWithNullFocusModelResultsInNoException2() {
112         list.setFocusModel(null);
113         cell.updateListView(list);
114         cell.updateListView(new ListView());
115     }
116 
117     @Test public void updateListViewWithNullFocusModelResultsInNoException3() {
118         cell.updateListView(list);
119         ListView list2 = new ListView();
120         list2.setFocusModel(null);
121         cell.updateListView(list2);
122     }
123 
124     @Test public void updateListViewWithNullSelectionModelResultsInNoException() {
125         cell.updateListView(list);
126         list.setSelectionModel(null);
127         cell.updateListView(new ListView());
128     }
129 
130     @Test public void updateListViewWithNullSelectionModelResultsInNoException2() {
131         list.setSelectionModel(null);
132         cell.updateListView(list);
133         cell.updateListView(new ListView());
134     }
135 
136     @Test public void updateListViewWithNullSelectionModelResultsInNoException3() {
137         cell.updateListView(list);
138         ListView list2 = new ListView();
139         list2.setSelectionModel(null);
140         cell.updateListView(list2);
141     }
142 
143     @Test public void updateListViewWithNullItemsResultsInNoException() {
144         cell.updateListView(list);
145         list.setItems(null);
146         cell.updateListView(new ListView());
147     }
148 
149     @Test public void updateListViewWithNullItemsResultsInNoException2() {
150         list.setItems(null);
151         cell.updateListView(list);
152         cell.updateListView(new ListView());
153     }
154 
155     @Test public void updateListViewWithNullItemsResultsInNoException3() {
156         cell.updateListView(list);
157         ListView list2 = new ListView();
158         list2.setItems(null);
159         cell.updateListView(list2);
160     }
161 
162     /*********************************************************************
163      * Tests for the item property. It should be updated whenever the    *
164      * index, or listView changes, including the listView&#39;s items.       *
165      ********************************************************************/
166 
167     @Test public void itemMatchesIndexWithinListItems() {
168         cell.updateIndex(0);
169         cell.updateListView(list);
170         assertSame(model.get(0), cell.getItem());
171         cell.updateIndex(1);
172         assertSame(model.get(1), cell.getItem());
173     }
174 
175     @Test public void itemMatchesIndexWithinListItems2() {
176         cell.updateListView(list);
177         cell.updateIndex(0);
178         assertSame(model.get(0), cell.getItem());
179         cell.updateIndex(1);
180         assertSame(model.get(1), cell.getItem());
181     }
182 
183     @Test public void itemIsNullWhenIndexIsOutOfRange() {
184         cell.updateIndex(50);
185         cell.updateListView(list);
186         assertNull(cell.getItem());
187     }
188 
189     @Test public void itemIsNullWhenIndexIsOutOfRange2() {
190         cell.updateListView(list);
191         cell.updateIndex(50);
192         assertNull(cell.getItem());
193     }
194 
195     // Above were the simple tests. Now we check various circumstances
196     // to make sure the item is updated correctly.
197 
198     @Test public void itemIsUpdatedWhenItWasOutOfRangeButUpdatesToListViewItemsMakesItInRange() {
199         cell.updateIndex(4);
200         cell.updateListView(list);
201         model.addAll(&quot;Pumpkin&quot;, &quot;Lemon&quot;);
202         assertSame(model.get(4), cell.getItem());
203     }
204 
205     @Test public void itemIsUpdatedWhenItWasInRangeButUpdatesToListViewItemsMakesItOutOfRange() {
206         cell.updateIndex(2);
207         cell.updateListView(list);
208         assertSame(model.get(2), cell.getItem());
209         model.remove(2);
210         assertNull(cell.getItem());
211     }
212 
213     @Test public void itemIsUpdatedWhenListViewItemsIsUpdated() {
214         cell.updateIndex(1);
215         cell.updateListView(list);
216         assertSame(model.get(1), cell.getItem());
217         model.set(1, &quot;Lime&quot;);
218         assertEquals(&quot;Lime&quot;, cell.getItem());
219     }
220 
221     @Test public void itemIsUpdatedWhenListViewItemsHasNewItemInsertedBeforeIndex() {
222         cell.updateIndex(1);
223         cell.updateListView(list);
224         assertSame(model.get(1), cell.getItem());
225         String previous = model.get(0);
226         model.add(0, &quot;Lime&quot;);
227         assertEquals(previous, cell.getItem());
228     }
229 
230     @Test public void itemIsUpdatedWhenListViewItemsHasItemRemovedBeforeIndex() {
231         cell.updateIndex(1);
232         cell.updateListView(list);
233         assertSame(model.get(1), cell.getItem());
234         String other = model.get(2);
235         model.remove(0);
236         assertEquals(other, cell.getItem());
237     }
238 
239     @Test public void itemIsUpdatedWhenListViewItemsIsReplaced() {
240         ObservableList&lt;String&gt; model2 = FXCollections.observableArrayList(&quot;Water&quot;, &quot;Juice&quot;, &quot;Soda&quot;);
241         cell.updateIndex(1);
242         cell.updateListView(list);
243         list.setItems(model2);
244         assertEquals(&quot;Juice&quot;, cell.getItem());
245     }
246 
247     @Test public void itemIsUpdatedWhenListViewIsReplaced() {
248         cell.updateIndex(2);
249         cell.updateListView(list);
250         ObservableList&lt;String&gt; model2 = FXCollections.observableArrayList(&quot;Water&quot;, &quot;Juice&quot;, &quot;Soda&quot;);
251         ListView&lt;String&gt; listView2 = new ListView&lt;String&gt;(model2);
252         cell.updateListView(listView2);
253         assertEquals(&quot;Soda&quot;, cell.getItem());
254     }
255 
256     @Test public void replaceItemsWithANull() {
257         cell.updateIndex(0);
258         cell.updateListView(list);
259         list.setItems(null);
260         assertNull(cell.getItem());
261     }
262 
263     @Test public void replaceItemsWithANull_ListenersRemovedFromFormerList() {
264         cell.updateIndex(0);
265         cell.updateListView(list);
266         ListChangeListener listener = getListChangeListener(cell, &quot;weakItemsListener&quot;);
267         assertListenerListContains(model, listener);
268         list.setItems(null);
269         assertListenerListDoesNotContain(model, listener);
270     }
271 
272     @Test public void replaceANullItemsWithNotNull() {
273         cell.updateIndex(0);
274         cell.updateListView(list);
275         list.setItems(null);
276         ObservableList&lt;String&gt; model2 = FXCollections.observableArrayList(&quot;Water&quot;, &quot;Juice&quot;, &quot;Soda&quot;);
277         list.setItems(model2);
278         assertEquals(&quot;Water&quot;, cell.getItem());
279     }
280 
281     /*********************************************************************
282      * Tests for the selection listener                                  *
283      ********************************************************************/
284 
285     @Test public void selectionOnSelectionModelIsReflectedInCells() {
286         cell.updateListView(list);
287         cell.updateIndex(0);
288 
289         ListCell&lt;String&gt; other = new ListCell&lt;String&gt;();
290         other.updateListView(list);
291         other.updateIndex(1);
292 
293         list.getSelectionModel().selectFirst();
294         assertTrue(cell.isSelected());
295         assertFalse(other.isSelected());
296     }
297 
298     @Test public void changesToSelectionOnSelectionModelAreReflectedInCells() {
299         cell.updateListView(list);
300         cell.updateIndex(0);
301 
302         ListCell&lt;String&gt; other = new ListCell&lt;String&gt;();
303         other.updateListView(list);
304         other.updateIndex(1);
305 
306         // Because the ListView is in single selection mode, calling
307         // selectNext causes a loss of focus for the first cell.
308         list.getSelectionModel().selectFirst();
309         list.getSelectionModel().selectNext();
310         assertFalse(cell.isSelected());
311         assertTrue(other.isSelected());
312     }
313 
314     @Test public void replacingTheSelectionModelCausesSelectionOnCellsToBeUpdated() {
315         // Cell is configured to represent row 0, which is selected.
316         cell.updateListView(list);
317         cell.updateIndex(0);
318         list.getSelectionModel().select(0);
319 
320         // Other is configured to represent row 1 which is not selected.
321         ListCell&lt;String&gt; other = new ListCell&lt;String&gt;();
322         other.updateListView(list);
323         other.updateIndex(1);
324 
325         // The replacement selection model has row 1 selected, not row 0
326         MultipleSelectionModel&lt;String&gt; selectionModel = new SelectionModelMock();
327         selectionModel.select(1);
328 
329         list.setSelectionModel(selectionModel);
330         assertFalse(cell.isSelected());
331         assertTrue(other.isSelected());
332     }
333 
334     @Test public void changesToSelectionOnSelectionModelAreReflectedInCells_MultipleSelection() {
335         list.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
336         cell.updateListView(list);
337         cell.updateIndex(0);
338 
339         ListCell&lt;String&gt; other = new ListCell&lt;String&gt;();
340         other.updateListView(list);
341         other.updateIndex(1);
342 
343         list.getSelectionModel().selectFirst();
344         list.getSelectionModel().selectNext();
345         assertTrue(cell.isSelected());
346         assertTrue(other.isSelected());
347     }
348 
349     @Test public void replacingTheSelectionModelCausesSelectionOnCellsToBeUpdated_MultipleSelection() {
350         // Cell is configured to represent row 0, which is selected.
351         cell.updateListView(list);
352         cell.updateIndex(0);
353         list.getSelectionModel().select(0);
354 
355         // Other is configured to represent row 1 which is not selected.
356         ListCell&lt;String&gt; other = new ListCell&lt;String&gt;();
357         other.updateListView(list);
358         other.updateIndex(1);
359 
360         // The replacement selection model has row 0 and 1 selected
361         MultipleSelectionModel&lt;String&gt; selectionModel = new SelectionModelMock();
362         selectionModel.setSelectionMode(SelectionMode.MULTIPLE);
363         selectionModel.selectIndices(0, 1);
364 
365         list.setSelectionModel(selectionModel);
366         assertTrue(cell.isSelected());
367         assertTrue(other.isSelected());
368     }
369 
370     @Test public void replaceANullSelectionModel() {
371         // Cell is configured to represent row 0, which is selected.
372         list.setSelectionModel(null);
373         cell.updateIndex(0);
374         cell.updateListView(list);
375 
376         // Other is configured to represent row 1 which is not selected.
377         ListCell&lt;String&gt; other = new ListCell&lt;String&gt;();
378         other.updateListView(list);
379         other.updateIndex(1);
380 
381         // The replacement selection model has row 1 selected
382         MultipleSelectionModel&lt;String&gt; selectionModel = new SelectionModelMock();
383         selectionModel.select(1);
384 
385         list.setSelectionModel(selectionModel);
386         assertFalse(cell.isSelected());
387         assertTrue(other.isSelected());
388     }
389 
390     @Test public void setANullSelectionModel() {
391         // Cell is configured to represent row 0, which is selected.
392         cell.updateIndex(0);
393         cell.updateListView(list);
394 
395         // Other is configured to represent row 1 which is not selected.
396         ListCell&lt;String&gt; other = new ListCell&lt;String&gt;();
397         other.updateListView(list);
398         other.updateIndex(1);
399 
400         // Replace with a null selection model, which should clear selection
401         list.setSelectionModel(null);
402         assertFalse(cell.isSelected());
403         assertFalse(other.isSelected());
404     }
405 
406     @Ignore @Test public void replacingTheSelectionModelRemovesTheListenerFromTheOldModel() {
407         cell.updateIndex(0);
408         cell.updateListView(list);
409         MultipleSelectionModel&lt;String&gt; sm = list.getSelectionModel();
410         ListChangeListener listener = getListChangeListener(cell, &quot;weakSelectedListener&quot;);
411         assertListenerListContains(sm.getSelectedIndices(), listener);
412         list.setSelectionModel(new SelectionModelMock());
413         assertListenerListDoesNotContain(sm.getSelectedIndices(), listener);
414     }
415 
416     /*********************************************************************
417      * Tests for the focus listener                                      *
418      ********************************************************************/
419 
420     @Test public void focusOnFocusModelIsReflectedInCells() {
421         cell.updateListView(list);
422         cell.updateIndex(0);
423 
424         ListCell&lt;String&gt; other = new ListCell&lt;String&gt;();
425         other.updateListView(list);
426         other.updateIndex(1);
427 
428         list.getFocusModel().focus(0);
429         assertTrue(cell.isFocused());
430         assertFalse(other.isFocused());
431     }
432 
433     @Test public void changesToFocusOnFocusModelAreReflectedInCells() {
434         cell.updateListView(list);
435         cell.updateIndex(0);
436 
437         ListCell&lt;String&gt; other = new ListCell&lt;String&gt;();
438         other.updateListView(list);
439         other.updateIndex(1);
440 
441         list.getFocusModel().focus(0);
442         list.getFocusModel().focus(1);
443         assertFalse(cell.isFocused());
444         assertTrue(other.isFocused());
445     }
446 
447     @Test public void replacingTheFocusModelCausesFocusOnCellsToBeUpdated() {
448         // Cell is configured to represent row 0, which is focused.
449         cell.updateListView(list);
450         cell.updateIndex(0);
451         list.getFocusModel().focus(0);
452 
453         // Other is configured to represent row 1 which is not focused.
454         ListCell&lt;String&gt; other = new ListCell&lt;String&gt;();
455         other.updateListView(list);
456         other.updateIndex(1);
457 
458         // The replacement focus model has row 1 selected, not row 0
459         FocusModel&lt;String&gt; focusModel = new FocusModelMock();
460         focusModel.focus(1);
461 
462         list.setFocusModel(focusModel);
463         assertFalse(cell.isFocused());
464         assertTrue(other.isFocused());
465     }
466 
467     @Test public void replaceANullFocusModel() {
468         // Cell is configured to represent row 0, which is focused.
469         list.setFocusModel(null);
470         cell.updateIndex(0);
471         cell.updateListView(list);
472 
473         // Other is configured to represent row 1 which is not focused
474         ListCell&lt;String&gt; other = new ListCell&lt;String&gt;();
475         other.updateListView(list);
476         other.updateIndex(1);
477 
478         // The replacement focus model has row 1 focused
479         FocusModel&lt;String&gt; focusModel = new FocusModelMock();
480         focusModel.focus(1);
481 
482         list.setFocusModel(focusModel);
483         assertFalse(cell.isFocused());
484         assertTrue(other.isFocused());
485     }
486 
487     @Test public void setANullFocusModel() {
488         // Cell is configured to represent row 0, which is focused.
489         cell.updateIndex(0);
490         cell.updateListView(list);
491 
492         // Other is configured to represent row 1 which is not focused.
493         ListCell&lt;String&gt; other = new ListCell&lt;&gt;();
494         other.updateListView(list);
495         other.updateIndex(1);
496 
497         // Replace with a null focus model, which should clear focused
498         list.setFocusModel(null);
499         assertFalse(cell.isFocused());
500         assertFalse(other.isFocused());
501     }
502 
503     @Test public void replacingTheFocusModelRemovesTheListenerFromTheOldModel() {
504         cell.updateIndex(0);
505         cell.updateListView(list);
506         FocusModel&lt;String&gt; fm = list.getFocusModel();
507         InvalidationListener listener = getInvalidationListener(cell, &quot;weakFocusedListener&quot;);
508         assertValueListenersContains(fm.focusedIndexProperty(), listener);
509         list.setFocusModel(new FocusModelMock());
510         assertValueListenersDoesNotContain(fm.focusedIndexProperty(), listener);
511     }
512 
513     /*********************************************************************
514      * Tests for all things related to editing one of these guys         *
515      ********************************************************************/
516 
517     // startEdit()
518     @Test public void editOnListViewResultsInEditingInCell() {
519         list.setEditable(true);
520         cell.updateListView(list);
521         cell.updateIndex(1);
522         list.edit(1);
523         assertTrue(cell.isEditing());
524     }
525 
526     @Test public void editOnListViewResultsInNotEditingInCellWhenDifferentIndex() {
527         list.setEditable(true);
528         cell.updateListView(list);
529         cell.updateIndex(1);
530         list.edit(0);
531         assertFalse(cell.isEditing());
532     }
533 
534     @Test public void editCellWithNullListViewResultsInNoExceptions() {
535         cell.updateIndex(1);
536         cell.startEdit();
537     }
538 
539     @Test public void editCellOnNonEditableListDoesNothing() {
540         cell.updateIndex(1);
541         cell.updateListView(list);
542         cell.startEdit();
543         assertFalse(cell.isEditing());
544         assertEquals(-1, list.getEditingIndex());
545     }
546 
547     @Test public void editCellWithListResultsInUpdatedEditingIndexProperty() {
548         list.setEditable(true);
549         cell.updateListView(list);
550         cell.updateIndex(1);
551         cell.startEdit();
552         assertEquals(1, list.getEditingIndex());
553     }
554 
555     @Test public void editCellFiresEventOnList() {
556         list.setEditable(true);
557         cell.updateListView(list);
558         cell.updateIndex(2);
559         final boolean[] called = new boolean[] { false };
560         list.setOnEditStart(event -&gt; {
561             called[0] = true;
562         });
563         cell.startEdit();
564         assertTrue(called[0]);
565     }
566 
567     // commitEdit()
568     @Test public void commitWhenListIsNullIsOK() {
569         cell.updateIndex(1);
570         cell.startEdit();
571         cell.commitEdit(&quot;Watermelon&quot;);
572     }
573 
574     @Test public void commitWhenListIsNotNullWillUpdateTheItemsList() {
575         list.setEditable(true);
576         cell.updateListView(list);
577         cell.updateIndex(1);
578         cell.startEdit();
579         cell.commitEdit(&quot;Watermelon&quot;);
580         assertEquals(&quot;Watermelon&quot;, list.getItems().get(1));
581     }
582 
583     @Test public void commitSendsEventToList() {
584         list.setEditable(true);
585         cell.updateListView(list);
586         cell.updateIndex(1);
587         cell.startEdit();
588         final boolean[] called = new boolean[] { false };
589         list.setOnEditCommit(event -&gt; {
590             called[0] = true;
591         });
592         cell.commitEdit(&quot;Watermelon&quot;);
593         assertTrue(called[0]);
594     }
595 
596     @Test public void afterCommitListViewEditingIndexIsNegativeOne() {
597         list.setEditable(true);
598         cell.updateListView(list);
599         cell.updateIndex(1);
600         cell.startEdit();
601         cell.commitEdit(&quot;Watermelon&quot;);
602         assertEquals(-1, list.getEditingIndex());
603         assertFalse(cell.isEditing());
604     }
605 
606     // cancelEdit()
607     @Test public void cancelEditCanBeCalledWhileListViewIsNull() {
608         cell.updateIndex(1);
609         cell.startEdit();
610         cell.cancelEdit();
611     }
612 
613     @Test public void cancelEditFiresChangeEvent() {
614         list.setEditable(true);
615         cell.updateListView(list);
616         cell.updateIndex(1);
617         cell.startEdit();
618         final boolean[] called = new boolean[] { false };
619         list.setOnEditCancel(event -&gt; {
620             called[0] = true;
621         });
622         cell.cancelEdit();
623         assertTrue(called[0]);
624     }
625 
626     @Test public void cancelSetsListViewEditingIndexToNegativeOne() {
627         list.setEditable(true);
628         cell.updateListView(list);
629         cell.updateIndex(1);
630         cell.startEdit();
631         cell.cancelEdit();
632         assertEquals(-1, list.getEditingIndex());
633         assertFalse(cell.isEditing());
634     }
635 
636     @Test public void movingListCellEditingIndexCausesCurrentlyInEditCellToCancel() {
637         list.setEditable(true);
638         cell.updateListView(list);
639         cell.updateIndex(0);
640         cell.startEdit();
641 
642         ListCell other = new ListCell();
643         other.updateListView(list);
644         other.updateIndex(1);
645         list.edit(1);
646 
647         assertTrue(other.isEditing());
648         assertFalse(cell.isEditing());
649     }
650 
651     // When the list view item&#39;s change and affects a cell that is editing, then what?
652     // When the list cell&#39;s index is changed while it is editing, then what?
653 
654 
655     private final class SelectionModelMock extends MultipleSelectionModelBaseShim&lt;String&gt; {
656         @Override protected int getItemCount() {
657             return model.size();
658         }
659 
660         @Override protected String getModelItem(int index) {
661             return model.get(index);
662         }
663 
664         @Override protected void focus(int index) {
665             // no op
666         }
667 
668         @Override protected int getFocusedIndex() {
669             return list.getFocusModel().getFocusedIndex();
670         }
671     };
672 
673     private final class FocusModelMock extends FocusModel {
674         @Override protected int getItemCount() {
675             return model.size();
676         }
677 
678         @Override protected Object getModelItem(int row) {
679             return model.get(row);
680         }
681     }
682 
683     private int rt_29923_count = 0;
684     @Test public void test_rt_29923() {
685         // setup test
686         cell = new ListCellShim&lt;String&gt;() {
687             @Override public void updateItem(String item, boolean empty) {
688                 super.updateItem(item, empty);
689                 rt_29923_count++;
690             }
691         };
692         list.getItems().setAll(null, null, null);
693         cell.updateListView(list);
694 
695         rt_29923_count = 0;
696         cell.updateIndex(0);
697         assertNull(cell.getItem());
698         assertFalse(cell.isEmpty());
699         assertEquals(1, rt_29923_count);
700 
701         cell.updateIndex(1);
702         assertNull(cell.getItem());
703         assertFalse(cell.isEmpty());
704 
705         // This test used to be as shown below....but due to RT-33108, it changed
706         // to the enabled code beneath. Refer to the first comment in RT-33108
707         // for more detail, but in short we can&#39;t optimise and not call updateItem
708         // when the new and old items are the same - doing so means we can end
709         // up with bad bindings, etc in the individual cells (in other words,
710         // even if their item has not changed, the rest of their state may have)
711 //        assertEquals(1, rt_29923_count);    // even though the index has changed,
712 //                                            // the item is the same, so we don&#39;t
713 //                                            // update the cell item.
714         assertEquals(2, rt_29923_count);
715     }
716 
717     @Test public void test_rt_33106() {
718         cell.updateListView(list);
719         list.setItems(null);
720         cell.updateIndex(1);
721     }
722 
723     @Test public void test_jdk_8151524() {
724         ListCell cell = new ListCell();
725         cell.setSkin(new ListCellSkin(cell));
726     }
<a name="2" id="anc2"></a><span class="line-added">727 </span>
<span class="line-added">728     /**</span>
<span class="line-added">729      * Test that min/max/pref height respect fixedCellSize.</span>
<span class="line-added">730      * Sanity test when fixing JDK-8246745.</span>
<span class="line-added">731      */</span>
<span class="line-added">732     @Test</span>
<span class="line-added">733     public void testListCellHeights() {</span>
<span class="line-added">734         ListCell&lt;Object&gt; cell =  new ListCell&lt;&gt;();</span>
<span class="line-added">735         ListView&lt;Object&gt; listView = new ListView&lt;&gt;();</span>
<span class="line-added">736         cell.updateListView(listView);</span>
<span class="line-added">737         installDefaultSkin(cell);</span>
<span class="line-added">738         listView.setFixedCellSize(100);</span>
<span class="line-added">739         assertEquals(&quot;pref height must be fixedCellSize&quot;,</span>
<span class="line-added">740                 listView.getFixedCellSize(),</span>
<span class="line-added">741                 cell.prefHeight(-1), 1);</span>
<span class="line-added">742         assertEquals(&quot;min height must be fixedCellSize&quot;,</span>
<span class="line-added">743                 listView.getFixedCellSize(),</span>
<span class="line-added">744                 cell.minHeight(-1), 1);</span>
<span class="line-added">745         assertEquals(&quot;max height must be fixedCellSize&quot;,</span>
<span class="line-added">746                 listView.getFixedCellSize(),</span>
<span class="line-added">747                 cell.maxHeight(-1), 1);</span>
<span class="line-added">748     }</span>
<span class="line-added">749 </span>
<span class="line-added">750 </span>
751 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
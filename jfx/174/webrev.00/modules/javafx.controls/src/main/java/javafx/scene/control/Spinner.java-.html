<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.controls/src/main/java/javafx/scene/control/Spinner.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package javafx.scene.control;
 26 
 27 import com.sun.javafx.scene.control.FakeFocusTextField;
 28 import javafx.beans.property.StringProperty;
 29 import javafx.scene.control.skin.SpinnerSkin;
 30 import javafx.beans.NamedArg;
 31 import javafx.beans.property.BooleanProperty;
 32 import javafx.beans.property.ObjectProperty;
 33 import javafx.beans.property.ReadOnlyObjectProperty;
 34 import javafx.beans.property.ReadOnlyObjectWrapper;
 35 import javafx.beans.property.SimpleBooleanProperty;
 36 import javafx.beans.property.SimpleObjectProperty;
 37 import javafx.beans.value.WritableValue;
 38 import javafx.collections.MapChangeListener;
 39 import javafx.collections.ObservableList;
 40 import javafx.scene.AccessibleAction;
 41 import javafx.scene.AccessibleAttribute;
 42 import javafx.scene.AccessibleRole;
 43 import javafx.util.Duration;
 44 import javafx.util.StringConverter;
 45 
 46 import java.math.BigDecimal;
 47 import java.time.LocalDate;
 48 import java.time.LocalTime;
 49 import java.time.temporal.TemporalUnit;
 50 
 51 import javafx.css.CssMetaData;
 52 import javafx.css.converter.DurationConverter;
 53 import javafx.css.Styleable;
 54 import javafx.css.StyleableObjectProperty;
 55 import javafx.css.StyleableProperty;
 56 import javafx.css.SimpleStyleableObjectProperty;
 57 
 58 import java.util.ArrayList;
 59 import java.util.Collections;
 60 import java.util.List;
 61 
 62 /**
 63  * A single line text field that lets the user select a number or an object
 64  * value from an ordered sequence. Spinners typically provide a pair of tiny
 65  * arrow buttons for stepping through the elements of the sequence. The keyboard
 66  * up/down arrow keys also cycle through the elements. The user may also be
 67  * allowed to type a (legal) value directly into the spinner. Although combo
 68  * boxes provide similar functionality, spinners are sometimes preferred because
 69  * they don&#39;t require a drop down list that can obscure important data, and also
 70  * because they allow for features such as
 71  * {@link SpinnerValueFactory#wrapAroundProperty() wrapping}
 72  * and simpler specification of &#39;infinite&#39; data models (the
 73  * {@link SpinnerValueFactory SpinnerValueFactory}, rather than using a
 74  * {@link javafx.collections.ObservableList ObservableList} data model like many
 75  * other JavaFX UI controls.
 76  *
 77  * &lt;p&gt;A Spinner&#39;s sequence value is defined by its
 78  * {@link SpinnerValueFactory SpinnerValueFactory}. The value factory
 79  * can be specified as a constructor argument and changed with the
 80  * {@link #valueFactoryProperty() value factory property}. SpinnerValueFactory
 81  * classes for some common types are provided with JavaFX, including:
 82  *
 83  * &lt;ul&gt;
 84  *     &lt;li&gt;{@link SpinnerValueFactory.IntegerSpinnerValueFactory}&lt;/li&gt;
 85  *     &lt;li&gt;{@link SpinnerValueFactory.DoubleSpinnerValueFactory}&lt;/li&gt;
 86  *     &lt;li&gt;{@link SpinnerValueFactory.ListSpinnerValueFactory}&lt;/li&gt;
 87  * &lt;/ul&gt;
 88  *
 89  * &lt;p&gt;A Spinner has a TextField child component that is responsible for displaying
 90  * and potentially changing the current {@link #valueProperty() value} of the
 91  * Spinner, which is called the {@link #editorProperty() editor}. By default the
 92  * Spinner is non-editable, but input can be accepted if the
 93  * {@link #editableProperty() editable property} is set to true. The Spinner
 94  * editor stays in sync with the value factory by listening for changes to the
 95  * {@link SpinnerValueFactory#valueProperty() value property} of the value factory.
 96  * If the user has changed the value displayed in the editor it is possible for
 97  * the Spinner {@link #valueProperty() value} to differ from that of the editor.
 98  * To make sure the model has the same value as the editor, the user must commit
 99  * the edit using the Enter key.
100  *
101  * &lt;p&gt;Example:
102  * &lt;pre&gt;Spinner spinner = new Spinner(0, 10, 5);&lt;/pre&gt;
103  *
104  * &lt;img src=&quot;doc-files/Spinner.png&quot; alt=&quot;Image of the Spinner control&quot;&gt;
105  *
106  * @see SpinnerValueFactory
107  * @param &lt;T&gt; The type of all values that can be iterated through in the Spinner.
108  *            Common types include Integer and String.
109  * @since JavaFX 8u40
110  */
111 public class Spinner&lt;T&gt; extends Control {
112 
113     // default style class, puts arrows on right, stacked vertically
114     private static final String DEFAULT_STYLE_CLASS = &quot;spinner&quot;;
115 
116     /** The arrows are placed on the right of the Spinner, pointing horizontally (i.e. left and right). */
117     public static final String STYLE_CLASS_ARROWS_ON_RIGHT_HORIZONTAL = &quot;arrows-on-right-horizontal&quot;;
118 
119     /** The arrows are placed on the left of the Spinner, pointing vertically (i.e. up and down). */
120     public static final String STYLE_CLASS_ARROWS_ON_LEFT_VERTICAL = &quot;arrows-on-left-vertical&quot;;
121 
122     /** The arrows are placed on the left of the Spinner, pointing horizontally (i.e. left and right). */
123     public static final String STYLE_CLASS_ARROWS_ON_LEFT_HORIZONTAL = &quot;arrows-on-left-horizontal&quot;;
124 
125     /** The arrows are placed above and beneath the spinner, stretching to take the entire width. */
126     public static final String STYLE_CLASS_SPLIT_ARROWS_VERTICAL = &quot;split-arrows-vertical&quot;;
127 
128     /** The decrement arrow is placed on the left of the Spinner, and the increment on the right. */
129     public static final String STYLE_CLASS_SPLIT_ARROWS_HORIZONTAL = &quot;split-arrows-horizontal&quot;;
130 
131 
132 
133     /***************************************************************************
134      *                                                                         *
135      * Constructors                                                            *
136      *                                                                         *
137      **************************************************************************/
138 
139     /**
140      * Constructs a default Spinner instance, with the default &#39;spinner&#39; style
141      * class and a non-editable editor.
142      */
143     public Spinner() {
144         getStyleClass().add(DEFAULT_STYLE_CLASS);
145         setAccessibleRole(AccessibleRole.SPINNER);
146 
147         getEditor().setOnAction(action -&gt; {
148             commitValue();
149         });
150 
151         getEditor().editableProperty().bind(editableProperty());
152 
153         value.addListener((o, oldValue, newValue) -&gt; setText(newValue));
154 
155         // Fix for RT-29885
156         getProperties().addListener((MapChangeListener&lt;Object, Object&gt;) change -&gt; {
157             if (change.wasAdded()) {
158                 if (change.getKey() == &quot;FOCUSED&quot;) {
159                     setFocused((Boolean)change.getValueAdded());
160                     getProperties().remove(&quot;FOCUSED&quot;);
161                 }
162             }
163         });
164         // End of fix for RT-29885
165 
166         focusedProperty().addListener(o -&gt; {
167             if (!isFocused()) {
168                 commitValue();
169             }
170         });
171     }
172 
173     /**
174      * Creates a Spinner instance with the
175      * {@link #valueFactoryProperty() value factory} set to be an instance
176      * of {@link SpinnerValueFactory.IntegerSpinnerValueFactory}. Note that
177      * if this constructor is called, the only valid generic type for the
178      * Spinner instance is Integer, i.e. Spinner&amp;lt;Integer&amp;gt;.
179      *
180      * @param min The minimum allowed integer value for the Spinner.
181      * @param max The maximum allowed integer value for the Spinner.
182      * @param initialValue The value of the Spinner when first instantiated, must
183      *                     be within the bounds of the min and max arguments, or
184      *                     else the min value will be used.
185      */
186     public Spinner(@NamedArg(&quot;min&quot;) int min,
187                    @NamedArg(&quot;max&quot;) int max,
188                    @NamedArg(&quot;initialValue&quot;) int initialValue) {
189         // This only works if the Spinner is of type Integer
190         this((SpinnerValueFactory&lt;T&gt;)new SpinnerValueFactory.IntegerSpinnerValueFactory(min, max, initialValue));
191     }
192 
193     /**
194      * Creates a Spinner instance with the
195      * {@link #valueFactoryProperty() value factory} set to be an instance
196      * of {@link SpinnerValueFactory.IntegerSpinnerValueFactory}. Note that
197      * if this constructor is called, the only valid generic type for the
198      * Spinner instance is Integer, i.e. Spinner&amp;lt;Integer&amp;gt;.
199      *
200      * @param min The minimum allowed integer value for the Spinner.
201      * @param max The maximum allowed integer value for the Spinner.
202      * @param initialValue The value of the Spinner when first instantiated, must
203      *                     be within the bounds of the min and max arguments, or
204      *                     else the min value will be used.
205      * @param amountToStepBy The amount to increment or decrement by, per step.
206      */
207     public Spinner(@NamedArg(&quot;min&quot;) int min,
208                    @NamedArg(&quot;max&quot;) int max,
209                    @NamedArg(&quot;initialValue&quot;) int initialValue,
210                    @NamedArg(&quot;amountToStepBy&quot;) int amountToStepBy) {
211         // This only works if the Spinner is of type Integer
212         this((SpinnerValueFactory&lt;T&gt;)new SpinnerValueFactory.IntegerSpinnerValueFactory(min, max, initialValue, amountToStepBy));
213     }
214 
215     /**
216      * Creates a Spinner instance with the
217      * {@link #valueFactoryProperty() value factory} set to be an instance
218      * of {@link SpinnerValueFactory.DoubleSpinnerValueFactory}. Note that
219      * if this constructor is called, the only valid generic type for the
220      * Spinner instance is Double, i.e. Spinner&amp;lt;Double&amp;gt;.
221      *
222      * @param min The minimum allowed double value for the Spinner.
223      * @param max The maximum allowed double value for the Spinner.
224      * @param initialValue The value of the Spinner when first instantiated, must
225      *                     be within the bounds of the min and max arguments, or
226      *                     else the min value will be used.
227      */
228     public Spinner(@NamedArg(&quot;min&quot;) double min,
229                    @NamedArg(&quot;max&quot;) double max,
230                    @NamedArg(&quot;initialValue&quot;) double initialValue) {
231         // This only works if the Spinner is of type Double
232         this((SpinnerValueFactory&lt;T&gt;)new SpinnerValueFactory.DoubleSpinnerValueFactory(min, max, initialValue));
233     }
234 
235     /**
236      * Creates a Spinner instance with the
237      * {@link #valueFactoryProperty() value factory} set to be an instance
238      * of {@link SpinnerValueFactory.DoubleSpinnerValueFactory}. Note that
239      * if this constructor is called, the only valid generic type for the
240      * Spinner instance is Double, i.e. Spinner&amp;lt;Double&amp;gt;.
241      *
242      * @param min The minimum allowed double value for the Spinner.
243      * @param max The maximum allowed double value for the Spinner.
244      * @param initialValue The value of the Spinner when first instantiated, must
245      *                     be within the bounds of the min and max arguments, or
246      *                     else the min value will be used.
247      * @param amountToStepBy The amount to increment or decrement by, per step.
248      */
249     public Spinner(@NamedArg(&quot;min&quot;) double min,
250                    @NamedArg(&quot;max&quot;) double max,
251                    @NamedArg(&quot;initialValue&quot;) double initialValue,
252                    @NamedArg(&quot;amountToStepBy&quot;) double amountToStepBy) {
253         // This only works if the Spinner is of type Double
254         this((SpinnerValueFactory&lt;T&gt;)new SpinnerValueFactory.DoubleSpinnerValueFactory(min, max, initialValue, amountToStepBy));
255     }
256 
257     /**
258      * Creates a Spinner instance with the
259      * {@link #valueFactoryProperty() value factory} set to be an instance
260      * of {@link SpinnerValueFactory.LocalDateSpinnerValueFactory}. Note that
261      * if this constructor is called, the only valid generic type for the
262      * Spinner instance is LocalDate, i.e. Spinner&amp;lt;LocalDate&amp;gt;.
263      *
264      * @param min The minimum allowed LocalDate value for the Spinner.
265      * @param max The maximum allowed LocalDate value for the Spinner.
266      * @param initialValue The value of the Spinner when first instantiated, must
267      *                     be within the bounds of the min and max arguments, or
268      *                     else the min value will be used.
269      */
270     Spinner(@NamedArg(&quot;min&quot;) LocalDate min,
271                    @NamedArg(&quot;max&quot;) LocalDate max,
272                    @NamedArg(&quot;initialValue&quot;) LocalDate initialValue) {
273         // This only works if the Spinner is of type LocalDate
274         this((SpinnerValueFactory&lt;T&gt;)new SpinnerValueFactory.LocalDateSpinnerValueFactory(min, max, initialValue));
275     }
276 
277     /**
278      * Creates a Spinner instance with the
279      * {@link #valueFactoryProperty() value factory} set to be an instance
280      * of {@link SpinnerValueFactory.LocalDateSpinnerValueFactory}. Note that
281      * if this constructor is called, the only valid generic type for the
282      * Spinner instance is LocalDate, i.e. Spinner&amp;lt;LocalDate&amp;gt;.
283      *
284      * @param min The minimum allowed LocalDate value for the Spinner.
285      * @param max The maximum allowed LocalDate value for the Spinner.
286      * @param initialValue The value of the Spinner when first instantiated, must
287      *                     be within the bounds of the min and max arguments, or
288      *                     else the min value will be used.
289      * @param amountToStepBy The amount to increment or decrement by, per step.
290      * @param temporalUnit The size of each step (e.g. day, week, month, year, etc).
291      */
292     Spinner(@NamedArg(&quot;min&quot;) LocalDate min,
293                    @NamedArg(&quot;max&quot;) LocalDate max,
294                    @NamedArg(&quot;initialValue&quot;) LocalDate initialValue,
295                    @NamedArg(&quot;amountToStepBy&quot;) long amountToStepBy,
296                    @NamedArg(&quot;temporalUnit&quot;) TemporalUnit temporalUnit) {
297         // This only works if the Spinner is of type LocalDate
298         this((SpinnerValueFactory&lt;T&gt;)new SpinnerValueFactory.LocalDateSpinnerValueFactory(min, max, initialValue, amountToStepBy, temporalUnit));
299     }
300 
301     /**
302      * Creates a Spinner instance with the
303      * {@link #valueFactoryProperty() value factory} set to be an instance
304      * of {@link SpinnerValueFactory.LocalTimeSpinnerValueFactory}. Note that
305      * if this constructor is called, the only valid generic type for the
306      * Spinner instance is LocalTime, i.e. Spinner&amp;lt;LocalTime&amp;gt;.
307      *
308      * @param min The minimum allowed LocalTime value for the Spinner.
309      * @param max The maximum allowed LocalTime value for the Spinner.
310      * @param initialValue The value of the Spinner when first instantiated, must
311      *                     be within the bounds of the min and max arguments, or
312      *                     else the min value will be used.
313      */
314     Spinner(@NamedArg(&quot;min&quot;) LocalTime min,
315                    @NamedArg(&quot;max&quot;) LocalTime max,
316                    @NamedArg(&quot;initialValue&quot;) LocalTime initialValue) {
317         // This only works if the Spinner is of type LocalTime
318         this((SpinnerValueFactory&lt;T&gt;)new SpinnerValueFactory.LocalTimeSpinnerValueFactory(min, max, initialValue));
319     }
320 
321     /**
322      * Creates a Spinner instance with the
323      * {@link #valueFactoryProperty() value factory} set to be an instance
324      * of {@link SpinnerValueFactory.LocalTimeSpinnerValueFactory}. Note that
325      * if this constructor is called, the only valid generic type for the
326      * Spinner instance is LocalTime, i.e. Spinner&amp;lt;LocalTime&amp;gt;.
327      *
328      * @param min The minimum allowed LocalTime value for the Spinner.
329      * @param max The maximum allowed LocalTime value for the Spinner.
330      * @param initialValue The value of the Spinner when first instantiated, must
331      *                     be within the bounds of the min and max arguments, or
332      *                     else the min value will be used.
333      * @param amountToStepBy The amount to increment or decrement by, per step.
334      * @param temporalUnit The size of each step (e.g. hour, minute, second, etc).
335      */
336     Spinner(@NamedArg(&quot;min&quot;) LocalTime min,
337                    @NamedArg(&quot;max&quot;) LocalTime max,
338                    @NamedArg(&quot;initialValue&quot;) LocalTime initialValue,
339                    @NamedArg(&quot;amountToStepBy&quot;) long amountToStepBy,
340                    @NamedArg(&quot;temporalUnit&quot;) TemporalUnit temporalUnit) {
341         // This only works if the Spinner is of type LocalTime
342         this((SpinnerValueFactory&lt;T&gt;)new SpinnerValueFactory.LocalTimeSpinnerValueFactory(min, max, initialValue, amountToStepBy, temporalUnit));
343     }
344 
345     /**
346      * Creates a Spinner instance with the
347      * {@link #valueFactoryProperty() value factory} set to be an instance
348      * of {@link SpinnerValueFactory.ListSpinnerValueFactory}. The
349      * Spinner {@link #valueProperty() value property} will be set to the first
350      * element of the list, if an element exists, or null otherwise.
351      *
352      * @param items A list of items that will be stepped through in the Spinner.
353      */
354     public Spinner(@NamedArg(&quot;items&quot;) ObservableList&lt;T&gt; items) {
355         this(new SpinnerValueFactory.ListSpinnerValueFactory&lt;T&gt;(items));
356     }
357 
358     /**
359      * Creates a Spinner instance with the given value factory set.
360      *
361      * @param valueFactory The {@link #valueFactoryProperty() value factory} to use.
362      */
363     public Spinner(@NamedArg(&quot;valueFactory&quot;) SpinnerValueFactory&lt;T&gt; valueFactory) {
364         this();
365 
366         setValueFactory(valueFactory);
367     }
368 
369 
370 
371     /***************************************************************************
372      *                                                                         *
373      * Public API                                                              *
374      *                                                                         *
375      **************************************************************************/
376 
377     /**
378      * Attempts to increment the {@link #valueFactoryProperty() value factory}
379      * by one step, by calling the {@link SpinnerValueFactory#increment(int)}
380      * method with an argument of one. If the value factory is null, an
381      * IllegalStateException is thrown.
382      *
383      * @throws IllegalStateException if the value factory returned by
384      *      calling {@link #getValueFactory()} is null.
385      */
386     public void increment() {
387         increment(1);
388     }
389 
390     /**
391      * Attempts to increment the {@link #valueFactoryProperty() value factory}
392      * by the given number of steps, by calling the
393      * {@link SpinnerValueFactory#increment(int)}
394      * method and forwarding the steps argument to it. If the value factory is
395      * null, an IllegalStateException is thrown.
396      *
397      * @param steps The number of increments that should be performed on the value.
398      * @throws IllegalStateException if the value factory returned by
399      *      calling {@link #getValueFactory()} is null.
400      */
401     public void increment(int steps) {
402         SpinnerValueFactory&lt;T&gt; valueFactory = getValueFactory();
403         if (valueFactory == null) {
404             throw new IllegalStateException(&quot;Can&#39;t increment Spinner with a null SpinnerValueFactory&quot;);
405         }
406         commitValue();
407         valueFactory.increment(steps);
408     }
409 
410     /**
411      * Attempts to decrement the {@link #valueFactoryProperty() value factory}
412      * by one step, by calling the {@link SpinnerValueFactory#decrement(int)}
413      * method with an argument of one. If the value factory is null, an
414      * IllegalStateException is thrown.
415      *
416      * @throws IllegalStateException if the value factory returned by
417      *      calling {@link #getValueFactory()} is null.
418      */
419     public void decrement() {
420         decrement(1);
421     }
422 
423     /**
424      * Attempts to decrement the {@link #valueFactoryProperty() value factory}
425      * by the given number of steps, by calling the
426      * {@link SpinnerValueFactory#decrement(int)}
427      * method and forwarding the steps argument to it. If the value factory is
428      * null, an IllegalStateException is thrown.
429      *
430      * @param steps The number of decrements that should be performed on the value.
431      * @throws IllegalStateException if the value factory returned by
432      *      calling {@link #getValueFactory()} is null.
433      */
434     public void decrement(int steps) {
435         SpinnerValueFactory&lt;T&gt; valueFactory = getValueFactory();
436         if (valueFactory == null) {
437             throw new IllegalStateException(&quot;Can&#39;t decrement Spinner with a null SpinnerValueFactory&quot;);
438         }
439         commitValue();
440         valueFactory.decrement(steps);
441     }
442 
443     /** {@inheritDoc} */
444     @Override protected Skin&lt;?&gt; createDefaultSkin() {
445         return new SpinnerSkin&lt;&gt;(this);
446     }
447 
448     /**
449      * If the Spinner is {@link #editableProperty() editable}, calling this method will attempt to
450      * commit the current text and convert it to a {@link #valueProperty() value}.
451      * @since 9
452      */
453     public final void commitValue() {
454         if (!isEditable()) return;
455         String text = getEditor().getText();
456         SpinnerValueFactory&lt;T&gt; valueFactory = getValueFactory();
457         if (valueFactory != null) {
458             StringConverter&lt;T&gt; converter = valueFactory.getConverter();
459             if (converter != null) {
460                 T value = converter.fromString(text);
461                 valueFactory.setValue(value);
462             }
463         }
464     }
465 
466     /**
467      * If the Spinner is {@link #editableProperty() editable}, calling this method will attempt to
468      * replace the editor text with the last committed {@link #valueProperty() value}.
469      * @since 9
470      */
471     public final void cancelEdit() {
472         if (!isEditable()) return;
473         final T committedValue = getValue();
474         SpinnerValueFactory&lt;T&gt; valueFactory = getValueFactory();
475         if (valueFactory != null) {
476             StringConverter&lt;T&gt; converter = valueFactory.getConverter();
477             if (converter != null) {
478                 String valueString = converter.toString(committedValue);
479                 getEditor().setText(valueString);
480             }
481         }
482     }
483 
484 
485 
486     /***************************************************************************
487      *                                                                         *
488      * Properties                                                              *
489      *                                                                         *
490      **************************************************************************/
491 
492     // --- value (a read only, bound property to the value factory value property)
493     /**
494      * The value property on Spinner is a read-only property, as it is bound to
495      * the SpinnerValueFactory
496      * {@link SpinnerValueFactory#valueProperty() value property}. Should the
497      * {@link #valueFactoryProperty() value factory} change, this value property
498      * will be unbound from the old value factory and bound to the new one.
499      *
500      * &lt;p&gt;If developers wish to modify the value property, they may do so with
501      * code in the following form:
502      *
503      * &lt;pre&gt;
504      * {@code
505      * Object newValue = ...;
506      * spinner.getValueFactory().setValue(newValue);
507      * }&lt;/pre&gt;
508      */
509     private ReadOnlyObjectWrapper&lt;T&gt; value = new ReadOnlyObjectWrapper&lt;T&gt;(this, &quot;value&quot;);
510     public final T getValue() {
511         return value.get();
512     }
513     public final ReadOnlyObjectProperty&lt;T&gt; valueProperty() {
514         return value;
515     }
516 
517 
518     // --- valueFactory
519     /**
520      * The value factory is the model behind the JavaFX Spinner control - without
521      * a value factory installed a Spinner is unusable. It is the role of the
522      * value factory to handle almost all aspects of the Spinner, including:
523      *
524      * &lt;ul&gt;
525      *     &lt;li&gt;Representing the current state of the {@link SpinnerValueFactory#valueProperty() value},&lt;/li&gt;
526      *     &lt;li&gt;{@link SpinnerValueFactory#increment(int) Incrementing}
527      *         and {@link SpinnerValueFactory#decrement(int) decrementing} the
528      *         value, with one or more steps per call,&lt;/li&gt;
529      *     &lt;li&gt;{@link SpinnerValueFactory#converterProperty() Converting} text input
530      *         from the user (via the Spinner {@link #editorProperty() editor},&lt;/li&gt;
531      *     &lt;li&gt;Converting {@link SpinnerValueFactory#converterProperty() objects to user-readable strings}
532      *         for display on screen&lt;/li&gt;
533      * &lt;/ul&gt;
534      */
535     private ObjectProperty&lt;SpinnerValueFactory&lt;T&gt;&gt; valueFactory =
536             new SimpleObjectProperty&lt;SpinnerValueFactory&lt;T&gt;&gt;(this, &quot;valueFactory&quot;) {
537                 @Override protected void invalidated() {
538                     value.unbind();
539 
540                     SpinnerValueFactory&lt;T&gt; newFactory = get();
541                     if (newFactory != null) {
542                         // this binding is what ensures the Spinner.valueProperty()
543                         // properly represents the value in the value factory
544                         value.bind(newFactory.valueProperty());
545                     }
546                 }
547             };
548     public final void setValueFactory(SpinnerValueFactory&lt;T&gt; value) {
549         valueFactory.setValue(value);
550     }
551     public final SpinnerValueFactory&lt;T&gt; getValueFactory() {
552         return valueFactory.get();
553     }
554     public final ObjectProperty&lt;SpinnerValueFactory&lt;T&gt;&gt; valueFactoryProperty() {
555         return valueFactory;
556     }
557 
558 
559     // --- editable
560     /**
561      * The editable property is used to specify whether user input is able to
562      * be typed into the Spinner {@link #editorProperty() editor}. If editable
563      * is true, user input will be received once the user types and presses
564      * the Enter key. At this point the input is passed to the
565      * SpinnerValueFactory {@link SpinnerValueFactory#converterProperty() converter}
566      * {@link javafx.util.StringConverter#fromString(String)} method.
567      * The returned value from this call (of type T) is then sent to the
568      * {@link SpinnerValueFactory#setValue(Object)} method. If the value
569      * is valid, it will remain as the value. If it is invalid, the value factory
570      * will need to react accordingly and back out this change.
571      */
572     private BooleanProperty editable;
573     public final void setEditable(boolean value) {
574         editableProperty().set(value);
575     }
576     public final boolean isEditable() {
577         return editable == null ? true : editable.get();
578     }
579     public final BooleanProperty editableProperty() {
580         if (editable == null) {
581             editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
582         }
583         return editable;
584     }
585 
586 
587     // --- editor
588     /**
589      * The editor used by the Spinner control.
590      * @return the editor property
591      */
592     public final ReadOnlyObjectProperty&lt;TextField&gt; editorProperty() {
593         if (editor == null) {
594             editor = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;editor&quot;);
595             textField = new FakeFocusTextField();
596             textField.tooltipProperty().bind(tooltipProperty());
597             editor.set(textField);
598         }
599         return editor.getReadOnlyProperty();
600     }
601     private TextField textField;
602     private ReadOnlyObjectWrapper&lt;TextField&gt; editor;
603     public final TextField getEditor() {
604         return editorProperty().get();
605     }
606 
607 
608     // --- prompt text
609     /**
610      * The prompt text to display in the {@code Spinner}, or
611      * {@code null} if no prompt text is displayed.
612      * @return the prompt text property
613      * @since 9
614      */
615     public final StringProperty promptTextProperty() { return getEditor().promptTextProperty(); }
616     public final String getPromptText() { return getEditor().getPromptText(); }
617     public final void setPromptText(String value) { getEditor().setPromptText(value); }
618 
619     private final ObjectProperty&lt;Duration&gt; initialDelay =
620                             new SimpleStyleableObjectProperty&lt;&gt;(INITIAL_DELAY,
621                             this, &quot;initialDelay&quot;, new Duration(300));
622 
623     /**
624      * The duration that the mouse has to be pressed on an arrow button
625      * before the next value steps. Successive step duration is set using
626      * {@link #repeatDelayProperty() repeat delay}.
627      *
628      * @return inital delay property
629      * @since 11
630      * @defaultValue 300ms
631      */
632     public final ObjectProperty&lt;Duration&gt; initialDelayProperty() {
633         return initialDelay;
634     }
635 
636     public final void setInitialDelay(Duration value) {
637         if (value != null) {
638             initialDelay.set(value);
639         }
640     }
641 
642     public final Duration getInitialDelay() {
643         return initialDelay.get();
644     }
645 
646     private final ObjectProperty&lt;Duration&gt; repeatDelay =
647                             new SimpleStyleableObjectProperty&lt;&gt;(REPEAT_DELAY,
648                             this, &quot;repeatDelay&quot;, new Duration(60));
649 
650     /**
651      * The duration that the mouse has to be pressed for each successive step
652      * after the first value steps. Initial step duration is set using
653      * {@link #initialDelayProperty() initial delay}.
654      *
655      * @return repeat delay property
656      * @since 11
657      * @defaultValue 60ms
658      */
659     public final ObjectProperty&lt;Duration&gt; repeatDelayProperty() {
660         return repeatDelay;
661     }
662 
663     public final void setRepeatDelay(Duration value) {
664         if (value != null) {
665             repeatDelay.set(value);
666         }
667     }
668 
669     public final Duration getRepeatDelay() {
670         return repeatDelay.get();
671     }
672 
673     /***************************************************************************
674      *                                                                         *
675      * Stylesheet Handling                                                     *
676      *                                                                         *
677      **************************************************************************/
678 
679     private static final CssMetaData&lt;Spinner&lt;?&gt;,Duration&gt; INITIAL_DELAY =
680                                     new CssMetaData&lt;Spinner&lt;?&gt;,Duration&gt;(&quot;-fx-initial-delay&quot;,
681                                         DurationConverter.getInstance(), new Duration(300)) {
682 
683         @Override
684         public boolean isSettable(Spinner&lt;?&gt; spinner) {
685             return !spinner.initialDelayProperty().isBound();
686         }
687 
688         @Override
689         public StyleableProperty&lt;Duration&gt; getStyleableProperty(Spinner&lt;?&gt; spinner) {
690             return (StyleableProperty&lt;Duration&gt;)(WritableValue&lt;Duration&gt;)spinner.initialDelayProperty();
691         }
692     };
693 
694     private static final CssMetaData&lt;Spinner&lt;?&gt;,Duration&gt; REPEAT_DELAY =
695                                    new CssMetaData&lt;Spinner&lt;?&gt;,Duration&gt;(&quot;-fx-repeat-delay&quot;,
696                                         DurationConverter.getInstance(), new Duration(60)) {
697 
698         @Override
699         public boolean isSettable(Spinner&lt;?&gt; spinner) {
700             return !spinner.repeatDelayProperty().isBound();
701         }
702 
703         @Override
704         public StyleableProperty&lt;Duration&gt; getStyleableProperty(Spinner&lt;?&gt; spinner) {
705             return (StyleableProperty&lt;Duration&gt;)(WritableValue&lt;Duration&gt;)spinner.repeatDelayProperty();
706         }
707     };
708 
709     private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
710     static {
711         final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
712             new ArrayList&lt;&gt;(Control.getClassCssMetaData());
713         styleables.add(INITIAL_DELAY);
714         styleables.add(REPEAT_DELAY);
715         STYLEABLES = Collections.unmodifiableList(styleables);
716     }
717 
718     /*
719      * @return The CssMetaData associated with this class, which may include the
720      * CssMetaData of its superclasses.
721      * @since 11
722      */
723     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
724         return STYLEABLES;
725     }
726 
727     /*
728      * {@inheritDoc}
729      * @since 11
730      */
731     @Override
732     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
733         return getClassCssMetaData();
734     }
735 
736     /***************************************************************************
737      *                                                                         *
738      * Implementation                                                          *
739      *                                                                         *
740      **************************************************************************/
741 
742     /*
743      * Update the TextField based on the current value
744      */
745     private void setText(T value) {
746         String text = null;
747 
748         SpinnerValueFactory&lt;T&gt; valueFactory = getValueFactory();
749         if (valueFactory != null) {
750             StringConverter&lt;T&gt; converter = valueFactory.getConverter();
751             if (converter != null) {
752                 text = converter.toString(value);
753             }
754         }
755 
756         notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
757         if (text == null) {
758             if (value == null) {
759                 getEditor().clear();
760                 return;
761             } else {
762                 text = value.toString();
763             }
764         }
765 
766         getEditor().setText(text);
767     }
768 
769     /*
770      * Convenience method to support wrapping values around their min / max
771      * constraints. Used by the SpinnerValueFactory implementations when
772      * the Spinner wrapAround property is true.
773      */
774     static int wrapValue(int value, int min, int max) {
775         if (max == 0) {
776             throw new RuntimeException();
777         }
778 
779         int r = value % max;
780         if (r &gt; min &amp;&amp; max &lt; min) {
781             r = r + max - min;
782         } else if (r &lt; min &amp;&amp; max &gt; min) {
783             r = r + max - min;
784         }
785         return r;
786     }
787 
788     /*
789      * Convenience method to support wrapping values around their min / max
790      * constraints. Used by the SpinnerValueFactory implementations when
791      * the Spinner wrapAround property is true.
792      */
793     static BigDecimal wrapValue(BigDecimal value, BigDecimal min, BigDecimal max) {
794         if (max.doubleValue() == 0) {
795             throw new RuntimeException();
796         }
797 
798         // note that this wrap method differs from the others where we take the
799         // difference - in this approach we wrap to the min or max - it feels better
800         // to go from 1 to 0, rather than 1 to 0.05 (where max is 1 and step is 0.05).
801         if (value.compareTo(min) &lt; 0) {
802             return max;
803         } else if (value.compareTo(max) &gt; 0) {
804             return min;
805         }
806         return value;
807     }
808 
809 
810 
811     /***************************************************************************
812      *                                                                         *
813      * Accessibility handling                                                  *
814      *                                                                         *
815      **************************************************************************/
816 
817     /** {@inheritDoc} */
818     @Override
819     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
820         switch (attribute) {
821             case TEXT: {
822                 T value = getValue();
823                 SpinnerValueFactory&lt;T&gt; factory = getValueFactory();
824                 if (factory != null) {
825                     StringConverter&lt;T&gt; converter = factory.getConverter();
826                     if (converter != null) {
827                         return converter.toString(value);
828                     }
829                 }
830                 return value != null ? value.toString() : &quot;&quot;;
831             }
832             default: return super.queryAccessibleAttribute(attribute, parameters);
833         }
834     }
835 
836     /** {@inheritDoc} */
837     @Override
838     public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
839         switch (action) {
840             case INCREMENT:
841                 increment();
842                 break;
843             case DECREMENT:
844                 decrement();
845                 break;
846             default: super.executeAccessibleAction(action);
847         }
848     }
849 
850 }
    </pre>
  </body>
</html>
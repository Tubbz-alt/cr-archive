<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/SpinnerValueFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javafx.scene.control;
  26 
  27 import javafx.beans.NamedArg;
  28 import javafx.beans.property.BooleanProperty;
  29 import javafx.beans.property.DoubleProperty;
  30 import javafx.beans.property.IntegerProperty;
  31 import javafx.beans.property.LongProperty;
  32 import javafx.beans.property.ObjectProperty;
  33 import javafx.beans.property.SimpleBooleanProperty;
  34 import javafx.beans.property.SimpleDoubleProperty;
  35 import javafx.beans.property.SimpleIntegerProperty;
  36 import javafx.beans.property.SimpleLongProperty;
  37 import javafx.beans.property.SimpleObjectProperty;
  38 import javafx.collections.ListChangeListener;
  39 import javafx.collections.ObservableList;
  40 import javafx.collections.WeakListChangeListener;
  41 import javafx.util.StringConverter;
  42 import javafx.util.converter.IntegerStringConverter;
  43 
  44 import java.lang.ref.WeakReference;
  45 import java.math.BigDecimal;
  46 import java.text.DecimalFormat;
  47 import java.text.ParseException;
  48 import java.time.Duration;
  49 import java.time.LocalDate;
  50 import java.time.LocalTime;
  51 import java.time.format.DateTimeFormatter;
  52 import java.time.format.FormatStyle;
  53 import java.time.temporal.ChronoUnit;
  54 import java.time.temporal.TemporalUnit;
  55 import java.util.List;
  56 
  57 /**
  58  * The SpinnerValueFactory is the model behind the JavaFX
  59  * {@link Spinner Spinner control} - without a value factory installed a
  60  * Spinner is unusable. It is the role of the value factory to handle almost all
  61  * aspects of the Spinner, including:
  62  *
  63  * &lt;ul&gt;
  64  *     &lt;li&gt;Representing the current state of the {@link javafx.scene.control.SpinnerValueFactory#valueProperty() value},&lt;/li&gt;
  65  *     &lt;li&gt;{@link SpinnerValueFactory#increment(int) Incrementing}
  66  *         and {@link SpinnerValueFactory#decrement(int) decrementing} the
  67  *         value, with one or more steps per call,&lt;/li&gt;
  68  *     &lt;li&gt;{@link javafx.scene.control.SpinnerValueFactory#converterProperty() Converting} text input
  69  *         from the user (via the Spinner {@link Spinner#editorProperty() editor},&lt;/li&gt;
  70  *     &lt;li&gt;Converting {@link javafx.scene.control.SpinnerValueFactory#converterProperty() objects to user-readable strings}
  71  *         for display on screen&lt;/li&gt;
  72  * &lt;/ul&gt;
  73  *
  74  * &lt;p&gt;SpinnerValueFactory classes for some common types are provided with JavaFX, including:
  75  *
  76  * &lt;ul&gt;
  77  *     &lt;li&gt;{@link SpinnerValueFactory.IntegerSpinnerValueFactory}&lt;/li&gt;
  78  *     &lt;li&gt;{@link SpinnerValueFactory.DoubleSpinnerValueFactory}&lt;/li&gt;
  79  *     &lt;li&gt;{@link SpinnerValueFactory.ListSpinnerValueFactory}&lt;/li&gt;
  80  * &lt;/ul&gt;
  81  *
  82  * @param &lt;T&gt; The type of the data this value factory deals with, which must
  83  *            coincide with the type of the Spinner that the value factory is set on.
  84  * @see Spinner
  85  * @see SpinnerValueFactory.IntegerSpinnerValueFactory
  86  * @see SpinnerValueFactory.DoubleSpinnerValueFactory
  87  * @see SpinnerValueFactory.ListSpinnerValueFactory
  88  * @since JavaFX 8u40
  89  */
  90 public abstract class SpinnerValueFactory&lt;T&gt; {
  91 
  92     /***************************************************************************
  93      *                                                                         *
  94      * Private fields                                                          *
  95      *                                                                         *
  96      **************************************************************************/
  97 
  98 
  99 
 100     /***************************************************************************
 101      *                                                                         *
 102      * Abstract methods                                                        *
 103      *                                                                         *
 104      **************************************************************************/
 105 
 106     /**
 107      * Attempts to decrement the {@link #valueProperty() value} by the given
 108      * number of steps.
 109      *
 110      * @param steps The number of decrements that should be performed on the value.
 111      */
 112     public abstract void decrement(int steps);
 113 
 114 
 115     /**
 116      * Attempts to omcrement the {@link #valueProperty() value} by the given
 117      * number of steps.
 118      *
 119      * @param steps The number of increments that should be performed on the value.
 120      */
 121     public abstract void increment(int steps);
 122 
 123 
 124 
 125     /***************************************************************************
 126      *                                                                         *
 127      * Properties                                                              *
 128      *                                                                         *
 129      **************************************************************************/
 130 
 131     // --- value
 132     /**
 133      * Represents the current value of the SpinnerValueFactory, or null if no
 134      * value has been set.
 135      */
 136     private ObjectProperty&lt;T&gt; value = new SimpleObjectProperty&lt;&gt;(this, &quot;value&quot;);
 137     public final T getValue() {
 138         return value.get();
 139     }
 140     public final void setValue(T newValue) {
 141         value.set(newValue);
 142     }
 143     public final ObjectProperty&lt;T&gt; valueProperty() {
 144         return value;
 145     }
 146 
 147 
 148     // --- converter
 149     /**
 150      * Converts the user-typed input (when the Spinner is
 151      * {@link Spinner#editableProperty() editable}) to an object of type T,
 152      * such that the input may be retrieved via the  {@link #valueProperty() value}
 153      * property.
 154      */
 155     private ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converter = new SimpleObjectProperty&lt;&gt;(this, &quot;converter&quot;);
 156     public final StringConverter&lt;T&gt; getConverter() {
 157         return converter.get();
 158     }
 159     public final void setConverter(StringConverter&lt;T&gt; newValue) {
 160         converter.set(newValue);
 161     }
 162     public final ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converterProperty() {
 163         return converter;
 164     }
 165 
 166 
 167     // --- wrapAround
 168     /**
 169      * The wrapAround property is used to specify whether the value factory should
 170      * be circular. For example, should an integer-based value model increment
 171      * from the maximum value back to the minimum value (and vice versa).
 172      */
 173     private BooleanProperty wrapAround;
 174     public final void setWrapAround(boolean value) {
 175         wrapAroundProperty().set(value);
 176     }
 177     public final boolean isWrapAround() {
 178         return wrapAround == null ? false : wrapAround.get();
 179     }
 180     public final BooleanProperty wrapAroundProperty() {
 181         if (wrapAround == null) {
 182             wrapAround = new SimpleBooleanProperty(this, &quot;wrapAround&quot;, false);
 183         }
 184         return wrapAround;
 185     }
 186 
 187 
 188 
 189     /***************************************************************************
 190      *                                                                         *
 191      * Subclasses of SpinnerValueFactory                                       *
 192      *                                                                         *
 193      **************************************************************************/
 194 
 195     /**
 196      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
 197      * a list of values.
 198      *
 199      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
 200      * simply as shown below, which may be adequate in many cases, but it is important
 201      * for users to ensure that this suits their needs (and adjust when necessary):
 202      *
 203      * &lt;pre&gt;
 204      * setConverter(new StringConverter&amp;lt;T&amp;gt;() {
 205      *     &amp;#064;Override public String toString(T value) {
 206      *         if (value == null) {
 207      *             return &quot;&quot;;
 208      *         }
 209      *         return value.toString();
 210      *     }
 211      *
 212      *     &amp;#064;Override public T fromString(String string) {
 213      *         return (T) string;
 214      *     }
 215      * });&lt;/pre&gt;
 216      *
 217      * @param &lt;T&gt; The type of the elements in the {@link java.util.List}.
 218      * @since JavaFX 8u40
 219      */
 220     public static class ListSpinnerValueFactory&lt;T&gt; extends SpinnerValueFactory&lt;T&gt; {
 221 
 222         /***********************************************************************
 223          *                                                                     *
 224          * Private fields                                                      *
 225          *                                                                     *
 226          **********************************************************************/
 227 
 228         private int currentIndex = 0;
 229 
 230         private final ListChangeListener&lt;T&gt; itemsContentObserver = c -&gt; {
 231             // the items content has changed. We do not try to find the current
 232             // item, instead we remain at the currentIndex, if possible, or else
 233             // we go back to index 0, and if that fails, we go to null
 234             updateCurrentIndex();
 235         };
 236 
 237         private WeakListChangeListener&lt;T&gt; weakItemsContentObserver =
 238                 new WeakListChangeListener&lt;T&gt;(itemsContentObserver);
 239 
 240 
 241 
 242         /***********************************************************************
 243          *                                                                     *
 244          * Constructors                                                        *
 245          *                                                                     *
 246          **********************************************************************/
 247 
 248         /**
 249          * Creates a new instance of the ListSpinnerValueFactory with the given
 250          * list used as the list to step through.
 251          *
 252          * @param items The list of items to step through with the Spinner.
 253          */
 254         public ListSpinnerValueFactory(@NamedArg(&quot;items&quot;) ObservableList&lt;T&gt; items) {
 255             setItems(items);
 256             setConverter(new StringConverter&lt;T&gt;() {
 257                 @Override public String toString(T value) {
 258                     if (value == null) {
 259                         return &quot;&quot;;
 260                     }
 261                     return value.toString();
 262                 }
 263 
 264                 @Override public T fromString(String string) {
 265                     return (T) string;
 266                 }
 267             });
 268 
 269             valueProperty().addListener((o, oldValue, newValue) -&gt; {
 270                 // when the value is set, we need to react to ensure it is a
 271                 // valid value (and if not, blow up appropriately)
 272                 int newIndex = -1;
 273                 if (items.contains(newValue)) {
 274                     newIndex = items.indexOf(newValue);
 275                 } else {
 276                     // add newValue to list
 277                     items.add(newValue);
 278                     newIndex = items.indexOf(newValue);
 279                 }
 280                 currentIndex = newIndex;
 281             });
 282             setValue(_getValue(currentIndex));
 283         }
 284 
 285 
 286 
 287         /***********************************************************************
 288          *                                                                     *
 289          * Properties                                                          *
 290          *                                                                     *
 291          **********************************************************************/
 292         // --- Items
 293         private ObjectProperty&lt;ObservableList&lt;T&gt;&gt; items;
 294 
 295         /**
 296          * Sets the underlying data model for the ListSpinnerValueFactory. Note that it has a generic
 297          * type that must match the type of the Spinner itself.
 298          * @param value the list of items
 299          */
 300         public final void setItems(ObservableList&lt;T&gt; value) {
 301             itemsProperty().set(value);
 302         }
 303 
 304         /**
 305          * Returns an {@link javafx.collections.ObservableList} that contains the items currently able
 306          * to be iterated through by the user. This may be null if
 307          * {@link #setItems(javafx.collections.ObservableList)} has previously been
 308          * called, however, by default it is an empty ObservableList.
 309          *
 310          * @return An ObservableList containing the items to be shown to the user, or
 311          *      null if the items have previously been set to null.
 312          */
 313         public final ObservableList&lt;T&gt; getItems() {
 314             return items == null ? null : items.get();
 315         }
 316 
 317         /**
 318          * The underlying data model for the ListView. Note that it has a generic
 319          * type that must match the type of the ListView itself.
 320          * @return the list of items
 321          */
 322         public final ObjectProperty&lt;ObservableList&lt;T&gt;&gt; itemsProperty() {
 323             if (items == null) {
 324                 items = new SimpleObjectProperty&lt;ObservableList&lt;T&gt;&gt;(this, &quot;items&quot;) {
 325                     WeakReference&lt;ObservableList&lt;T&gt;&gt; oldItemsRef;
 326 
 327                     @Override protected void invalidated() {
 328                         ObservableList&lt;T&gt; oldItems = oldItemsRef == null ? null : oldItemsRef.get();
 329                         ObservableList&lt;T&gt; newItems = getItems();
 330 
 331                         // update listeners
 332                         if (oldItems != null) {
 333                             oldItems.removeListener(weakItemsContentObserver);
 334                         }
 335                         if (newItems != null) {
 336                             newItems.addListener(weakItemsContentObserver);
 337                         }
 338 
 339                         // update the current value based on the index
 340                         updateCurrentIndex();
 341 
 342                         oldItemsRef = new WeakReference&lt;&gt;(getItems());
 343                     }
 344                 };
 345             }
 346             return items;
 347         }
 348 
 349 
 350 
 351         /***********************************************************************
 352          *                                                                     *
 353          * Overridden methods                                                  *
 354          *                                                                     *
 355          **********************************************************************/
 356 
 357         /** {@inheritDoc} */
 358         @Override public void decrement(int steps) {
 359             final int max = getItemsSize() - 1;
 360             int newIndex = currentIndex - steps;
 361             currentIndex = newIndex &gt;= 0 ? newIndex : (isWrapAround() ? Spinner.wrapValue(newIndex, 0, max + 1) : 0);
 362             setValue(_getValue(currentIndex));
 363         }
 364 
 365         /** {@inheritDoc} */
 366         @Override public void increment(int steps) {
 367             final int max = getItemsSize() - 1;
 368             int newIndex = currentIndex + steps;
 369             currentIndex = newIndex &lt;= max ? newIndex : (isWrapAround() ? Spinner.wrapValue(newIndex, 0, max + 1) : max);
 370             setValue(_getValue(currentIndex));
 371         }
 372 
 373 
 374 
 375         /***********************************************************************
 376          *                                                                     *
 377          * Private implementation                                              *
 378          *                                                                     *
 379          **********************************************************************/
 380         private int getItemsSize() {
 381             List&lt;T&gt; items = getItems();
 382             return items == null ? 0 : items.size();
 383         }
 384 
 385         private void updateCurrentIndex() {
 386             int itemsSize = getItemsSize();
 387             if (currentIndex &lt; 0 || currentIndex &gt;= itemsSize) {
 388                 currentIndex = 0;
 389             }
 390             setValue(_getValue(currentIndex));
 391         }
 392 
 393         private T _getValue(int index) {
 394             List&lt;T&gt; items = getItems();
 395             return items == null ? null : (index &gt;= 0 &amp;&amp; index &lt; items.size()) ? items.get(index) : null;
 396         }
 397     }
 398 
 399 
 400 
 401     /**
 402      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
 403      * integer values.
 404      *
 405      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
 406      * as an {@link javafx.util.converter.IntegerStringConverter} instance.
 407      *
 408      * @since JavaFX 8u40
 409      */
 410     public static class IntegerSpinnerValueFactory extends SpinnerValueFactory&lt;Integer&gt; {
 411 
 412         /***********************************************************************
 413          *                                                                     *
 414          * Constructors                                                        *
 415          *                                                                     *
 416          **********************************************************************/
 417 
 418         /**
 419          * Constructs a new IntegerSpinnerValueFactory that sets the initial value
 420          * to be equal to the min value, and a default {@code amountToStepBy} of one.
 421          *
 422          * @param min The minimum allowed integer value for the Spinner.
 423          * @param max The maximum allowed integer value for the Spinner.
 424          */
 425         public IntegerSpinnerValueFactory(@NamedArg(&quot;min&quot;) int min,
 426                                           @NamedArg(&quot;max&quot;) int max) {
 427             this(min, max, min);
 428         }
 429 
 430         /**
 431          * Constructs a new IntegerSpinnerValueFactory with a default
 432          * {@code amountToStepBy} of one.
 433          *
 434          * @param min The minimum allowed integer value for the Spinner.
 435          * @param max The maximum allowed integer value for the Spinner.
 436          * @param initialValue The value of the Spinner when first instantiated, must
 437          *                     be within the bounds of the min and max arguments, or
 438          *                     else the min value will be used.
 439          */
 440         public IntegerSpinnerValueFactory(@NamedArg(&quot;min&quot;) int min,
 441                                           @NamedArg(&quot;max&quot;) int max,
 442                                           @NamedArg(&quot;initialValue&quot;) int initialValue) {
 443             this(min, max, initialValue, 1);
 444         }
 445 
 446         /**
 447          * Constructs a new IntegerSpinnerValueFactory.
 448          *
 449          * @param min The minimum allowed integer value for the Spinner.
 450          * @param max The maximum allowed integer value for the Spinner.
 451          * @param initialValue The value of the Spinner when first instantiated, must
 452          *                     be within the bounds of the min and max arguments, or
 453          *                     else the min value will be used.
 454          * @param amountToStepBy The amount to increment or decrement by, per step.
 455          */
 456         public IntegerSpinnerValueFactory(@NamedArg(&quot;min&quot;) int min,
 457                                           @NamedArg(&quot;max&quot;) int max,
 458                                           @NamedArg(&quot;initialValue&quot;) int initialValue,
 459                                           @NamedArg(&quot;amountToStepBy&quot;) int amountToStepBy) {
 460             setMin(min);
 461             setMax(max);
 462             setAmountToStepBy(amountToStepBy);
 463             setConverter(new IntegerStringConverter());
 464 
 465             valueProperty().addListener((o, oldValue, newValue) -&gt; {
 466                 // when the value is set, we need to react to ensure it is a
 467                 // valid value (and if not, blow up appropriately)
 468                 if (newValue &lt; getMin()) {
 469                     setValue(getMin());
 470                 } else if (newValue &gt; getMax()) {
 471                     setValue(getMax());
 472                 }
 473             });
 474             setValue(initialValue &gt;= min &amp;&amp; initialValue &lt;= max ? initialValue : min);
 475         }
 476 
 477 
 478         /***********************************************************************
 479          *                                                                     *
 480          * Properties                                                          *
 481          *                                                                     *
 482          **********************************************************************/
 483 
 484         // --- min
 485         private IntegerProperty min = new SimpleIntegerProperty(this, &quot;min&quot;) {
 486             @Override protected void invalidated() {
 487                 Integer currentValue = IntegerSpinnerValueFactory.this.getValue();
 488                 if (currentValue == null) {
 489                     return;
 490                 }
 491 
 492                 int newMin = get();
 493                 if (newMin &gt; getMax()) {
 494                     setMin(getMax());
 495                     return;
 496                 }
 497 
 498                 if (currentValue &lt; newMin) {
 499                     IntegerSpinnerValueFactory.this.setValue(newMin);
 500                 }
 501             }
 502         };
 503 
 504         public final void setMin(int value) {
 505             min.set(value);
 506         }
 507         public final int getMin() {
 508             return min.get();
 509         }
 510         /**
 511          * Sets the minimum allowable value for this value factory
 512          * @return the minimum allowable value for this value factory
 513          */
 514         public final IntegerProperty minProperty() {
 515             return min;
 516         }
 517 
 518         // --- max
 519         private IntegerProperty max = new SimpleIntegerProperty(this, &quot;max&quot;) {
 520             @Override protected void invalidated() {
 521                 Integer currentValue = IntegerSpinnerValueFactory.this.getValue();
 522                 if (currentValue == null) {
 523                     return;
 524                 }
 525 
 526                 int newMax = get();
 527                 if (newMax &lt; getMin()) {
 528                     setMax(getMin());
 529                     return;
 530                 }
 531 
 532                 if (currentValue &gt; newMax) {
 533                     IntegerSpinnerValueFactory.this.setValue(newMax);
 534                 }
 535             }
 536         };
 537 
 538         public final void setMax(int value) {
 539             max.set(value);
 540         }
 541         public final int getMax() {
 542             return max.get();
 543         }
 544         /**
 545          * Sets the maximum allowable value for this value factory
 546          * @return the maximum allowable value for this value factory
 547          */
 548         public final IntegerProperty maxProperty() {
 549             return max;
 550         }
 551 
 552         // --- amountToStepBy
 553         private IntegerProperty amountToStepBy = new SimpleIntegerProperty(this, &quot;amountToStepBy&quot;);
 554         public final void setAmountToStepBy(int value) {
 555             amountToStepBy.set(value);
 556         }
 557         public final int getAmountToStepBy() {
 558             return amountToStepBy.get();
 559         }
 560         /**
 561          * Sets the amount to increment or decrement by, per step.
 562          * @return the amount to increment or decrement by, per step
 563          */
 564         public final IntegerProperty amountToStepByProperty() {
 565             return amountToStepBy;
 566         }
 567 
 568 
 569 
 570         /***********************************************************************
 571          *                                                                     *
 572          * Overridden methods                                                  *
 573          *                                                                     *
 574          **********************************************************************/
 575 
 576         /** {@inheritDoc} */
 577         @Override public void decrement(int steps) {
 578             final int min = getMin();
 579             final int max = getMax();
 580             final int newIndex = getValue() - steps * getAmountToStepBy();
<a name="2" id="anc2"></a><span class="line-modified"> 581             setValue(newIndex &gt;= min ? newIndex : (isWrapAround() ? Spinner.wrapValue(newIndex, min, max) + 1 : min));</span>
 582         }
 583 
 584         /** {@inheritDoc} */
 585         @Override public void increment(int steps) {
 586             final int min = getMin();
 587             final int max = getMax();
 588             final int currentValue = getValue();
 589             final int newIndex = currentValue + steps * getAmountToStepBy();
<a name="3" id="anc3"></a><span class="line-modified"> 590             setValue(newIndex &lt;= max ? newIndex : (isWrapAround() ? Spinner.wrapValue(newIndex, min, max) - 1 : max));</span>
 591         }
 592     }
 593 
<a name="4" id="anc4"></a><span class="line-removed"> 594 </span>
<span class="line-removed"> 595 </span>
 596     /**
 597      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
 598      * double values.
 599      *
 600      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
 601      * simply as shown below, which may be adequate in many cases, but it is important
 602      * for users to ensure that this suits their needs (and adjust when necessary). The
 603      * main point to note is that this {@link javafx.util.StringConverter} embeds
 604      * within it a {@link java.text.DecimalFormat} instance that shows the Double
 605      * to two decimal places. This is used for both the toString and fromString
 606      * methods:
 607      *
 608      * &lt;pre&gt;
 609      * setConverter(new StringConverter&amp;lt;Double&amp;gt;() {
 610      *     private final DecimalFormat df = new DecimalFormat(&quot;#.##&quot;);
 611      *
 612      *     &amp;#064;Override public String toString(Double value) {
 613      *         // If the specified value is null, return a zero-length String
 614      *         if (value == null) {
 615      *             return &quot;&quot;;
 616      *         }
 617      *
 618      *         return df.format(value);
 619      *     }
 620      *
 621      *     &amp;#064;Override public Double fromString(String value) {
 622      *         try {
 623      *             // If the specified value is null or zero-length, return null
 624      *             if (value == null) {
 625      *                 return null;
 626      *             }
 627      *
 628      *             value = value.trim();
 629      *
 630      *             if (value.length() &amp;lt; 1) {
 631      *                 return null;
 632      *             }
 633      *
 634      *             // Perform the requested parsing
 635      *             return df.parse(value).doubleValue();
 636      *         } catch (ParseException ex) {
 637      *             throw new RuntimeException(ex);
 638      *         }
 639      *     }
 640      * });&lt;/pre&gt;
 641      *
 642      * @since JavaFX 8u40
 643      */
 644     public static class DoubleSpinnerValueFactory extends SpinnerValueFactory&lt;Double&gt; {
 645 
 646         /**
 647          * Constructs a new DoubleSpinnerValueFactory that sets the initial value
 648          * to be equal to the min value, and a default {@code amountToStepBy} of
 649          * one.
 650          *
 651          * @param min The minimum allowed double value for the Spinner.
 652          * @param max The maximum allowed double value for the Spinner.
 653          */
 654         public DoubleSpinnerValueFactory(@NamedArg(&quot;min&quot;) double min,
 655                                          @NamedArg(&quot;max&quot;) double max) {
 656             this(min, max, min);
 657         }
 658 
 659         /**
 660          * Constructs a new DoubleSpinnerValueFactory with a default
 661          * {@code amountToStepBy} of one.
 662          *
 663          * @param min The minimum allowed double value for the Spinner.
 664          * @param max The maximum allowed double value for the Spinner.
 665          * @param initialValue The value of the Spinner when first instantiated, must
 666          *                     be within the bounds of the min and max arguments, or
 667          *                     else the min value will be used.
 668          */
 669         public DoubleSpinnerValueFactory(@NamedArg(&quot;min&quot;) double min,
 670                                          @NamedArg(&quot;max&quot;) double max,
 671                                          @NamedArg(&quot;initialValue&quot;) double initialValue) {
 672             this(min, max, initialValue, 1);
 673         }
 674 
 675         /**
 676          * Constructs a new DoubleSpinnerValueFactory.
 677          *
 678          * @param min The minimum allowed double value for the Spinner.
 679          * @param max The maximum allowed double value for the Spinner.
 680          * @param initialValue The value of the Spinner when first instantiated, must
 681          *                     be within the bounds of the min and max arguments, or
 682          *                     else the min value will be used.
 683          * @param amountToStepBy The amount to increment or decrement by, per step.
 684          */
 685         public DoubleSpinnerValueFactory(@NamedArg(&quot;min&quot;) double min,
 686                                          @NamedArg(&quot;max&quot;) double max,
 687                                          @NamedArg(&quot;initialValue&quot;) double initialValue,
 688                                          @NamedArg(&quot;amountToStepBy&quot;) double amountToStepBy) {
 689             setMin(min);
 690             setMax(max);
 691             setAmountToStepBy(amountToStepBy);
 692             setConverter(new StringConverter&lt;Double&gt;() {
 693                 private final DecimalFormat df = new DecimalFormat(&quot;#.##&quot;);
 694 
 695                 @Override public String toString(Double value) {
 696                     // If the specified value is null, return a zero-length String
 697                     if (value == null) {
 698                         return &quot;&quot;;
 699                     }
 700 
 701                     return df.format(value);
 702                 }
 703 
 704                 @Override public Double fromString(String value) {
 705                     try {
 706                         // If the specified value is null or zero-length, return null
 707                         if (value == null) {
 708                             return null;
 709                         }
 710 
 711                         value = value.trim();
 712 
 713                         if (value.length() &lt; 1) {
 714                             return null;
 715                         }
 716 
 717                         // Perform the requested parsing
 718                         return df.parse(value).doubleValue();
 719                     } catch (ParseException ex) {
 720                         throw new RuntimeException(ex);
 721                     }
 722                 }
 723             });
 724 
 725             valueProperty().addListener((o, oldValue, newValue) -&gt; {
 726                 if (newValue == null) return;
 727 
 728                 // when the value is set, we need to react to ensure it is a
 729                 // valid value (and if not, blow up appropriately)
 730                 if (newValue &lt; getMin()) {
 731                     setValue(getMin());
 732                 } else if (newValue &gt; getMax()) {
 733                     setValue(getMax());
 734                 }
 735             });
 736             setValue(initialValue &gt;= min &amp;&amp; initialValue &lt;= max ? initialValue : min);
 737         }
 738 
 739 
 740 
 741         /***********************************************************************
 742          *                                                                     *
 743          * Properties                                                          *
 744          *                                                                     *
 745          **********************************************************************/
 746 
 747         // --- min
 748         private DoubleProperty min = new SimpleDoubleProperty(this, &quot;min&quot;) {
 749             @Override protected void invalidated() {
 750                 Double currentValue = DoubleSpinnerValueFactory.this.getValue();
 751                 if (currentValue == null) {
 752                     return;
 753                 }
 754 
 755                 final double newMin = get();
 756                 if (newMin &gt; getMax()) {
 757                     setMin(getMax());
 758                     return;
 759                 }
 760 
 761                 if (currentValue &lt; newMin) {
 762                     DoubleSpinnerValueFactory.this.setValue(newMin);
 763                 }
 764             }
 765         };
 766 
 767         public final void setMin(double value) {
 768             min.set(value);
 769         }
 770         public final double getMin() {
 771             return min.get();
 772         }
 773         /**
 774          * Sets the minimum allowable value for this value factory
 775          * @return the minimum allowable value for this value factory
 776          */
 777         public final DoubleProperty minProperty() {
 778             return min;
 779         }
 780 
 781         // --- max
 782         private DoubleProperty max = new SimpleDoubleProperty(this, &quot;max&quot;) {
 783             @Override protected void invalidated() {
 784                 Double currentValue = DoubleSpinnerValueFactory.this.getValue();
 785                 if (currentValue == null) {
 786                     return;
 787                 }
 788 
 789                 final double newMax = get();
 790                 if (newMax &lt; getMin()) {
 791                     setMax(getMin());
 792                     return;
 793                 }
 794 
 795                 if (currentValue &gt; newMax) {
 796                     DoubleSpinnerValueFactory.this.setValue(newMax);
 797                 }
 798             }
 799         };
 800 
 801         public final void setMax(double value) {
 802             max.set(value);
 803         }
 804         public final double getMax() {
 805             return max.get();
 806         }
 807         /**
 808          * Sets the maximum allowable value for this value factory
 809          * @return the maximum allowable value for this value factory
 810          */
 811         public final DoubleProperty maxProperty() {
 812             return max;
 813         }
 814 
 815         // --- amountToStepBy
 816         private DoubleProperty amountToStepBy = new SimpleDoubleProperty(this, &quot;amountToStepBy&quot;);
 817         public final void setAmountToStepBy(double value) {
 818             amountToStepBy.set(value);
 819         }
 820         public final double getAmountToStepBy() {
 821             return amountToStepBy.get();
 822         }
 823         /**
 824          * Sets the amount to increment or decrement by, per step.
 825          * @return the amount to increment or decrement by, per step
 826          */
 827         public final DoubleProperty amountToStepByProperty() {
 828             return amountToStepBy;
 829         }
 830 
 831 
 832 
 833         /** {@inheritDoc} */
 834         @Override public void decrement(int steps) {
 835             final BigDecimal currentValue = BigDecimal.valueOf(getValue());
 836             final BigDecimal minBigDecimal = BigDecimal.valueOf(getMin());
 837             final BigDecimal maxBigDecimal = BigDecimal.valueOf(getMax());
 838             final BigDecimal amountToStepByBigDecimal = BigDecimal.valueOf(getAmountToStepBy());
 839             BigDecimal newValue = currentValue.subtract(amountToStepByBigDecimal.multiply(BigDecimal.valueOf(steps)));
 840             setValue(newValue.compareTo(minBigDecimal) &gt;= 0 ? newValue.doubleValue() :
 841                     (isWrapAround() ? Spinner.wrapValue(newValue, minBigDecimal, maxBigDecimal).doubleValue() : getMin()));
 842         }
 843 
 844         /** {@inheritDoc} */
 845         @Override public void increment(int steps) {
 846             final BigDecimal currentValue = BigDecimal.valueOf(getValue());
 847             final BigDecimal minBigDecimal = BigDecimal.valueOf(getMin());
 848             final BigDecimal maxBigDecimal = BigDecimal.valueOf(getMax());
 849             final BigDecimal amountToStepByBigDecimal = BigDecimal.valueOf(getAmountToStepBy());
 850             BigDecimal newValue = currentValue.add(amountToStepByBigDecimal.multiply(BigDecimal.valueOf(steps)));
 851             setValue(newValue.compareTo(maxBigDecimal) &lt;= 0 ? newValue.doubleValue() :
 852                     (isWrapAround() ? Spinner.wrapValue(newValue, minBigDecimal, maxBigDecimal).doubleValue() : getMax()));
 853         }
 854     }
 855 
 856     /**
 857      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
 858      * {@link java.time.LocalDate} values.
 859      *
 860      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
 861      * simply as shown below, which may be adequate in many cases, but it is important
 862      * for users to ensure that this suits their needs (and adjust when necessary):
 863      *
 864      * &lt;pre&gt;
 865      * setConverter(new StringConverter&amp;lt;LocalDate&amp;gt;() {
 866      *     &amp;#064;Override public String toString(LocalDate object) {
 867      *         if (object == null) {
 868      *             return &quot;&quot;;
 869      *         }
 870      *         return object.toString();
 871      *     }
 872      *
 873      *     &amp;#064;Override public LocalDate fromString(String string) {
 874      *         return LocalDate.parse(string);
 875      *     }
 876      * });&lt;/pre&gt;
 877      */
 878     static class LocalDateSpinnerValueFactory extends SpinnerValueFactory&lt;LocalDate&gt; {
 879 
 880         /**
 881          * Creates a new instance of the LocalDateSpinnerValueFactory, using the
 882          * value returned by calling {@code LocalDate#now()} as the initial value,
 883          * and using a stepping amount of one day.
 884          */
 885         public LocalDateSpinnerValueFactory() {
 886             this(LocalDate.now());
 887         }
 888 
 889         /**
 890          * Creates a new instance of the LocalDateSpinnerValueFactory, using the
 891          * provided initial value, and a stepping amount of one day.
 892          *
 893          * @param initialValue The value of the Spinner when first instantiated.
 894          */
 895         public LocalDateSpinnerValueFactory(@NamedArg(&quot;initialValue&quot;) LocalDate initialValue) {
 896             this(LocalDate.MIN, LocalDate.MAX, initialValue);
 897         }
 898 
 899         /**
 900          * Creates a new instance of the LocalDateSpinnerValueFactory, using the
 901          * provided initial value, and a stepping amount of one day.
 902          *
 903          * @param min The minimum allowed double value for the Spinner.
 904          * @param max The maximum allowed double value for the Spinner.
 905          * @param initialValue The value of the Spinner when first instantiated.
 906          */
 907         public LocalDateSpinnerValueFactory(@NamedArg(&quot;min&quot;) LocalDate min,
 908                                             @NamedArg(&quot;min&quot;) LocalDate max,
 909                                             @NamedArg(&quot;initialValue&quot;) LocalDate initialValue) {
 910             this(min, max, initialValue, 1, ChronoUnit.DAYS);
 911         }
 912 
 913         /**
 914          * Creates a new instance of the LocalDateSpinnerValueFactory, using the
 915          * provided min, max, and initial values, as well as the amount to step
 916          * by and {@link java.time.temporal.TemporalUnit}.
 917          *
 918          * &lt;p&gt;To better understand, here are a few examples:
 919          *
 920          * &lt;ul&gt;
 921          *     &lt;li&gt;&lt;strong&gt;To step by one day from today: &lt;/strong&gt; {@code new LocalDateSpinnerValueFactory(LocalDate.MIN, LocalDate.MAX, LocalDate.now(), 1, ChronoUnit.DAYS)}&lt;/li&gt;
 922          *     &lt;li&gt;&lt;strong&gt;To step by one month from today: &lt;/strong&gt; {@code new LocalDateSpinnerValueFactory(LocalDate.MIN, LocalDate.MAX, LocalDate.now(), 1, ChronoUnit.MONTHS)}&lt;/li&gt;
 923          *     &lt;li&gt;&lt;strong&gt;To step by one year from today: &lt;/strong&gt; {@code new LocalDateSpinnerValueFactory(LocalDate.MIN, LocalDate.MAX, LocalDate.now(), 1, ChronoUnit.YEARS)}&lt;/li&gt;
 924          * &lt;/ul&gt;
 925          *
 926          * @param min The minimum allowed double value for the Spinner.
 927          * @param max The maximum allowed double value for the Spinner.
 928          * @param initialValue The value of the Spinner when first instantiated.
 929          * @param amountToStepBy The amount to increment or decrement by, per step.
 930          * @param temporalUnit The size of each step (e.g. day, week, month, year, etc)
 931          */
 932         public LocalDateSpinnerValueFactory(@NamedArg(&quot;min&quot;) LocalDate min,
 933                                             @NamedArg(&quot;min&quot;) LocalDate max,
 934                                             @NamedArg(&quot;initialValue&quot;) LocalDate initialValue,
 935                                             @NamedArg(&quot;amountToStepBy&quot;) long amountToStepBy,
 936                                             @NamedArg(&quot;temporalUnit&quot;) TemporalUnit temporalUnit) {
 937             setMin(min);
 938             setMax(max);
 939             setAmountToStepBy(amountToStepBy);
 940             setTemporalUnit(temporalUnit);
 941             setConverter(new StringConverter&lt;LocalDate&gt;() {
 942                 @Override public String toString(LocalDate object) {
 943                     if (object == null) {
 944                         return &quot;&quot;;
 945                     }
 946                     return object.toString();
 947                 }
 948 
 949                 @Override public LocalDate fromString(String string) {
 950                     return LocalDate.parse(string);
 951                 }
 952             });
 953 
 954             valueProperty().addListener((o, oldValue, newValue) -&gt; {
 955                 // when the value is set, we need to react to ensure it is a
 956                 // valid value (and if not, blow up appropriately)
 957                 if (getMin() != null &amp;&amp; newValue.isBefore(getMin())) {
 958                     setValue(getMin());
 959                 } else if (getMax() != null &amp;&amp; newValue.isAfter(getMax())) {
 960                     setValue(getMax());
 961                 }
 962             });
 963             setValue(initialValue != null ? initialValue : LocalDate.now());
 964         }
 965 
 966 
 967 
 968         /***********************************************************************
 969          *                                                                     *
 970          * Properties                                                          *
 971          *                                                                     *
 972          **********************************************************************/
 973 
 974         // --- min
 975         private ObjectProperty&lt;LocalDate&gt; min = new SimpleObjectProperty&lt;LocalDate&gt;(this, &quot;min&quot;) {
 976             @Override protected void invalidated() {
 977                 LocalDate currentValue = LocalDateSpinnerValueFactory.this.getValue();
 978                 if (currentValue == null) {
 979                     return;
 980                 }
 981 
 982                 final LocalDate newMin = get();
 983                 if (newMin.isAfter(getMax())) {
 984                     setMin(getMax());
 985                     return;
 986                 }
 987 
 988                 if (currentValue.isBefore(newMin)) {
 989                     LocalDateSpinnerValueFactory.this.setValue(newMin);
 990                 }
 991             }
 992         };
 993 
 994         public final void setMin(LocalDate value) {
 995             min.set(value);
 996         }
 997         public final LocalDate getMin() {
 998             return min.get();
 999         }
1000         /**
1001          * Sets the minimum allowable value for this value factory
1002          */
1003         public final ObjectProperty&lt;LocalDate&gt; minProperty() {
1004             return min;
1005         }
1006 
1007         // --- max
1008         private ObjectProperty&lt;LocalDate&gt; max = new SimpleObjectProperty&lt;LocalDate&gt;(this, &quot;max&quot;) {
1009             @Override protected void invalidated() {
1010                 LocalDate currentValue = LocalDateSpinnerValueFactory.this.getValue();
1011                 if (currentValue == null) {
1012                     return;
1013                 }
1014 
1015                 final LocalDate newMax = get();
1016                 if (newMax.isBefore(getMin())) {
1017                     setMax(getMin());
1018                     return;
1019                 }
1020 
1021                 if (currentValue.isAfter(newMax)) {
1022                     LocalDateSpinnerValueFactory.this.setValue(newMax);
1023                 }
1024             }
1025         };
1026 
1027         public final void setMax(LocalDate value) {
1028             max.set(value);
1029         }
1030         public final LocalDate getMax() {
1031             return max.get();
1032         }
1033         /**
1034          * Sets the maximum allowable value for this value factory
1035          */
1036         public final ObjectProperty&lt;LocalDate&gt; maxProperty() {
1037             return max;
1038         }
1039 
1040         // --- temporalUnit
1041         private ObjectProperty&lt;TemporalUnit&gt; temporalUnit = new SimpleObjectProperty&lt;&gt;(this, &quot;temporalUnit&quot;);
1042         public final void setTemporalUnit(TemporalUnit value) {
1043             temporalUnit.set(value);
1044         }
1045         public final TemporalUnit getTemporalUnit() {
1046             return temporalUnit.get();
1047         }
1048         /**
1049          * The size of each step (e.g. day, week, month, year, etc).
1050          */
1051         public final ObjectProperty&lt;TemporalUnit&gt; temporalUnitProperty() {
1052             return temporalUnit;
1053         }
1054 
1055         // --- amountToStepBy
1056         private LongProperty amountToStepBy = new SimpleLongProperty(this, &quot;amountToStepBy&quot;);
1057         public final void setAmountToStepBy(long value) {
1058             amountToStepBy.set(value);
1059         }
1060         public final long getAmountToStepBy() {
1061             return amountToStepBy.get();
1062         }
1063         /**
1064          * Sets the amount to increment or decrement by, per step.
1065          */
1066         public final LongProperty amountToStepByProperty() {
1067             return amountToStepBy;
1068         }
1069 
1070 
1071 
1072         /***********************************************************************
1073          *                                                                     *
1074          * Overridden methods                                                  *
1075          *                                                                     *
1076          **********************************************************************/
1077 
1078         /** {@inheritDoc} */
1079         @Override public void decrement(int steps) {
1080             final LocalDate currentValue = getValue();
1081             final LocalDate min = getMin();
1082             LocalDate newValue = currentValue.minus(getAmountToStepBy() * steps, getTemporalUnit());
1083 
1084             if (min != null &amp;&amp; isWrapAround() &amp;&amp; newValue.isBefore(min)) {
1085                 // we need to wrap around
1086                 newValue = getMax();
1087             }
1088 
1089             setValue(newValue);
1090         }
1091 
1092         /** {@inheritDoc} */
1093         @Override public void increment(int steps) {
1094             final LocalDate currentValue = getValue();
1095             final LocalDate max = getMax();
1096             LocalDate newValue = currentValue.plus(getAmountToStepBy() * steps, getTemporalUnit());
1097 
1098             if (max != null &amp;&amp; isWrapAround() &amp;&amp; newValue.isAfter(max)) {
1099                 // we need to wrap around
1100                 newValue = getMin();
1101             }
1102 
1103             setValue(newValue);
1104         }
1105     }
1106 
1107 
1108 
1109 
1110 
1111     /**
1112      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
1113      * {@link java.time.LocalTime} values.
1114      *
1115      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
1116      * simply as shown below, which may be adequate in many cases, but it is important
1117      * for users to ensure that this suits their needs (and adjust when necessary):
1118      *
1119      * &lt;pre&gt;
1120      * setConverter(new StringConverter&amp;lt;LocalTime&amp;gt;() {
1121      *     &amp;#064;Override public String toString(LocalTime object) {
1122      *         if (object == null) {
1123      *             return &quot;&quot;;
1124      *         }
1125      *         return object.toString();
1126      *     }
1127      *
1128      *     &amp;#064;Override public LocalTime fromString(String string) {
1129      *         return LocalTime.parse(string);
1130      *     }
1131      * });&lt;/pre&gt;
1132      */
1133     static class LocalTimeSpinnerValueFactory extends SpinnerValueFactory&lt;LocalTime&gt; {
1134 
1135         /**
1136          * Creates a new instance of the LocalTimepinnerValueFactory, using the
1137          * value returned by calling {@code LocalTime#now()} as the initial value,
1138          * and using a stepping amount of one day.
1139          */
1140         public LocalTimeSpinnerValueFactory() {
1141             this(LocalTime.now());
1142         }
1143 
1144         /**
1145          * Creates a new instance of the LocalTimeSpinnerValueFactory, using the
1146          * provided initial value, and a stepping amount of one hour.
1147          *
1148          * @param initialValue The value of the Spinner when first instantiated.
1149          */
1150         public LocalTimeSpinnerValueFactory(@NamedArg(&quot;initialValue&quot;) LocalTime initialValue) {
1151             this(LocalTime.MIN, LocalTime.MAX, initialValue);
1152         }
1153 
1154         /**
1155          * Creates a new instance of the LocalTimeSpinnerValueFactory, using the
1156          * provided initial value, and a stepping amount of one hour.
1157          *
1158          * @param min The minimum allowed double value for the Spinner.
1159          * @param max The maximum allowed double value for the Spinner.
1160          * @param initialValue The value of the Spinner when first instantiated.
1161          */
1162         public LocalTimeSpinnerValueFactory(@NamedArg(&quot;min&quot;) LocalTime min,
1163                                             @NamedArg(&quot;min&quot;) LocalTime max,
1164                                             @NamedArg(&quot;initialValue&quot;) LocalTime initialValue) {
1165             this(min, max, initialValue, 1, ChronoUnit.HOURS);
1166         }
1167 
1168         /**
1169          * Creates a new instance of the LocalTimeSpinnerValueFactory, using the
1170          * provided min, max, and initial values, as well as the amount to step
1171          * by and {@link java.time.temporal.TemporalUnit}.
1172          *
1173          * &lt;p&gt;To better understand, here are a few examples:
1174          *
1175          * &lt;ul&gt;
1176          *     &lt;li&gt;&lt;strong&gt;To step by one hour from the current time: &lt;/strong&gt; {@code new LocalTimeSpinnerValueFactory(LocalTime.MIN, LocalTime.MAX, LocalTime.now(), 1, ChronoUnit.HOURS)}&lt;/li&gt;
1177          *     &lt;li&gt;&lt;strong&gt;To step by one minute from the current time: &lt;/strong&gt; {@code new LocalTimeSpinnerValueFactory(LocalTime.MIN, LocalTime.MAX, LocalTime.now(), 1, ChronoUnit.MINUTES)}&lt;/li&gt;
1178          * &lt;/ul&gt;
1179          *
1180          * @param min The minimum allowed double value for the Spinner.
1181          * @param max The maximum allowed double value for the Spinner.
1182          * @param initialValue The value of the Spinner when first instantiated.
1183          * @param amountToStepBy The amount to increment or decrement by, per step.
1184          * @param temporalUnit The size of each step (e.g. day, week, month, year, etc)
1185          */
1186         public LocalTimeSpinnerValueFactory(@NamedArg(&quot;min&quot;) LocalTime min,
1187                                             @NamedArg(&quot;min&quot;) LocalTime max,
1188                                             @NamedArg(&quot;initialValue&quot;) LocalTime initialValue,
1189                                             @NamedArg(&quot;amountToStepBy&quot;) long amountToStepBy,
1190                                             @NamedArg(&quot;temporalUnit&quot;) TemporalUnit temporalUnit) {
1191             setMin(min);
1192             setMax(max);
1193             setAmountToStepBy(amountToStepBy);
1194             setTemporalUnit(temporalUnit);
1195             setConverter(new StringConverter&lt;LocalTime&gt;() {
1196                 private DateTimeFormatter dtf = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT);
1197 
1198                 @Override public String toString(LocalTime localTime) {
1199                     if (localTime == null) {
1200                         return &quot;&quot;;
1201                     }
1202                     return localTime.format(dtf);
1203                 }
1204 
1205                 @Override public LocalTime fromString(String string) {
1206                     return LocalTime.parse(string);
1207                 }
1208             });
1209 
1210             valueProperty().addListener((o, oldValue, newValue) -&gt; {
1211                 // when the value is set, we need to react to ensure it is a
1212                 // valid value (and if not, blow up appropriately)
1213                 if (getMin() != null &amp;&amp; newValue.isBefore(getMin())) {
1214                     setValue(getMin());
1215                 } else if (getMax() != null &amp;&amp; newValue.isAfter(getMax())) {
1216                     setValue(getMax());
1217                 }
1218             });
1219             setValue(initialValue != null ? initialValue : LocalTime.now());
1220         }
1221 
1222 
1223 
1224         /***********************************************************************
1225          *                                                                     *
1226          * Properties                                                          *
1227          *                                                                     *
1228          **********************************************************************/
1229 
1230         // --- min
1231         private ObjectProperty&lt;LocalTime&gt; min = new SimpleObjectProperty&lt;LocalTime&gt;(this, &quot;min&quot;) {
1232             @Override protected void invalidated() {
1233                 LocalTime currentValue = LocalTimeSpinnerValueFactory.this.getValue();
1234                 if (currentValue == null) {
1235                     return;
1236                 }
1237 
1238                 final LocalTime newMin = get();
1239                 if (newMin.isAfter(getMax())) {
1240                     setMin(getMax());
1241                     return;
1242                 }
1243 
1244                 if (currentValue.isBefore(newMin)) {
1245                     LocalTimeSpinnerValueFactory.this.setValue(newMin);
1246                 }
1247             }
1248         };
1249 
1250         public final void setMin(LocalTime value) {
1251             min.set(value);
1252         }
1253         public final LocalTime getMin() {
1254             return min.get();
1255         }
1256         /**
1257          * Sets the minimum allowable value for this value factory
1258          */
1259         public final ObjectProperty&lt;LocalTime&gt; minProperty() {
1260             return min;
1261         }
1262 
1263         // --- max
1264         private ObjectProperty&lt;LocalTime&gt; max = new SimpleObjectProperty&lt;LocalTime&gt;(this, &quot;max&quot;) {
1265             @Override protected void invalidated() {
1266                 LocalTime currentValue = LocalTimeSpinnerValueFactory.this.getValue();
1267                 if (currentValue == null) {
1268                     return;
1269                 }
1270 
1271                 final LocalTime newMax = get();
1272                 if (newMax.isBefore(getMin())) {
1273                     setMax(getMin());
1274                     return;
1275                 }
1276 
1277                 if (currentValue.isAfter(newMax)) {
1278                     LocalTimeSpinnerValueFactory.this.setValue(newMax);
1279                 }
1280             }
1281         };
1282 
1283         public final void setMax(LocalTime value) {
1284             max.set(value);
1285         }
1286         public final LocalTime getMax() {
1287             return max.get();
1288         }
1289         /**
1290          * Sets the maximum allowable value for this value factory
1291          */
1292         public final ObjectProperty&lt;LocalTime&gt; maxProperty() {
1293             return max;
1294         }
1295 
1296         // --- temporalUnit
1297         private ObjectProperty&lt;TemporalUnit&gt; temporalUnit = new SimpleObjectProperty&lt;&gt;(this, &quot;temporalUnit&quot;);
1298         public final void setTemporalUnit(TemporalUnit value) {
1299             temporalUnit.set(value);
1300         }
1301         public final TemporalUnit getTemporalUnit() {
1302             return temporalUnit.get();
1303         }
1304         /**
1305          * The size of each step (e.g. day, week, month, year, etc).
1306          */
1307         public final ObjectProperty&lt;TemporalUnit&gt; temporalUnitProperty() {
1308             return temporalUnit;
1309         }
1310 
1311         // --- amountToStepBy
1312         private LongProperty amountToStepBy = new SimpleLongProperty(this, &quot;amountToStepBy&quot;);
1313         public final void setAmountToStepBy(long value) {
1314             amountToStepBy.set(value);
1315         }
1316         public final long getAmountToStepBy() {
1317             return amountToStepBy.get();
1318         }
1319         /**
1320          * Sets the amount to increment or decrement by, per step.
1321          */
1322         public final LongProperty amountToStepByProperty() {
1323             return amountToStepBy;
1324         }
1325 
1326 
1327 
1328         /***********************************************************************
1329          *                                                                     *
1330          * Overridden methods                                                  *
1331          *                                                                     *
1332          **********************************************************************/
1333 
1334         /** {@inheritDoc} */
1335         @Override public void decrement(int steps) {
1336             final LocalTime currentValue = getValue();
1337             final LocalTime min = getMin();
1338 
1339             final Duration duration = Duration.of(getAmountToStepBy() * steps, getTemporalUnit());
1340 
1341             final long durationInSeconds = duration.toMinutes() * 60;
1342             final long currentValueInSeconds = currentValue.toSecondOfDay();
1343 
1344             if (! isWrapAround() &amp;&amp; durationInSeconds &gt; currentValueInSeconds) {
1345                 setValue(min == null ? LocalTime.MIN : min);
1346             } else {
1347                 setValue(currentValue.minus(duration));
1348             }
1349         }
1350 
1351         /** {@inheritDoc} */
1352         @Override public void increment(int steps) {
1353             final LocalTime currentValue = getValue();
1354             final LocalTime max = getMax();
1355 
1356             final Duration duration = Duration.of(getAmountToStepBy() * steps, getTemporalUnit());
1357 
1358             final long durationInSeconds = duration.toMinutes() * 60;
1359             final long currentValueInSeconds = currentValue.toSecondOfDay();
1360 
1361             if (! isWrapAround() &amp;&amp; durationInSeconds &gt; (LocalTime.MAX.toSecondOfDay() - currentValueInSeconds)) {
1362                 setValue(max == null ? LocalTime.MAX : max);
1363             } else {
1364                 setValue(currentValue.plus(duration));
1365             }
1366         }
1367     }
1368 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
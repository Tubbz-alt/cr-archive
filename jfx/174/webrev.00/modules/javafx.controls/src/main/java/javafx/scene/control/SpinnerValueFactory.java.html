<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/javafx/scene/control/SpinnerValueFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javafx.scene.control;
  26 
  27 import javafx.beans.NamedArg;
  28 import javafx.beans.property.BooleanProperty;
  29 import javafx.beans.property.DoubleProperty;
  30 import javafx.beans.property.IntegerProperty;
  31 import javafx.beans.property.LongProperty;
  32 import javafx.beans.property.ObjectProperty;
  33 import javafx.beans.property.SimpleBooleanProperty;
  34 import javafx.beans.property.SimpleDoubleProperty;
  35 import javafx.beans.property.SimpleIntegerProperty;
  36 import javafx.beans.property.SimpleLongProperty;
  37 import javafx.beans.property.SimpleObjectProperty;
  38 import javafx.collections.ListChangeListener;
  39 import javafx.collections.ObservableList;
  40 import javafx.collections.WeakListChangeListener;
  41 import javafx.util.StringConverter;
  42 import javafx.util.converter.IntegerStringConverter;
  43 
  44 import java.lang.ref.WeakReference;
  45 import java.math.BigDecimal;
  46 import java.text.DecimalFormat;
  47 import java.text.ParseException;
  48 import java.time.Duration;
  49 import java.time.LocalDate;
  50 import java.time.LocalTime;
  51 import java.time.format.DateTimeFormatter;
  52 import java.time.format.FormatStyle;
  53 import java.time.temporal.ChronoUnit;
  54 import java.time.temporal.TemporalUnit;
  55 import java.util.List;
  56 
  57 /**
  58  * The SpinnerValueFactory is the model behind the JavaFX
  59  * {@link Spinner Spinner control} - without a value factory installed a
  60  * Spinner is unusable. It is the role of the value factory to handle almost all
  61  * aspects of the Spinner, including:
  62  *
  63  * &lt;ul&gt;
  64  *     &lt;li&gt;Representing the current state of the {@link javafx.scene.control.SpinnerValueFactory#valueProperty() value},&lt;/li&gt;
  65  *     &lt;li&gt;{@link SpinnerValueFactory#increment(int) Incrementing}
  66  *         and {@link SpinnerValueFactory#decrement(int) decrementing} the
  67  *         value, with one or more steps per call,&lt;/li&gt;
  68  *     &lt;li&gt;{@link javafx.scene.control.SpinnerValueFactory#converterProperty() Converting} text input
  69  *         from the user (via the Spinner {@link Spinner#editorProperty() editor},&lt;/li&gt;
  70  *     &lt;li&gt;Converting {@link javafx.scene.control.SpinnerValueFactory#converterProperty() objects to user-readable strings}
  71  *         for display on screen&lt;/li&gt;
  72  * &lt;/ul&gt;
  73  *
  74  * &lt;p&gt;SpinnerValueFactory classes for some common types are provided with JavaFX, including:
  75  *
  76  * &lt;ul&gt;
  77  *     &lt;li&gt;{@link SpinnerValueFactory.IntegerSpinnerValueFactory}&lt;/li&gt;
  78  *     &lt;li&gt;{@link SpinnerValueFactory.DoubleSpinnerValueFactory}&lt;/li&gt;
  79  *     &lt;li&gt;{@link SpinnerValueFactory.ListSpinnerValueFactory}&lt;/li&gt;
  80  * &lt;/ul&gt;
  81  *
  82  * @param &lt;T&gt; The type of the data this value factory deals with, which must
  83  *            coincide with the type of the Spinner that the value factory is set on.
  84  * @see Spinner
  85  * @see SpinnerValueFactory.IntegerSpinnerValueFactory
  86  * @see SpinnerValueFactory.DoubleSpinnerValueFactory
  87  * @see SpinnerValueFactory.ListSpinnerValueFactory
  88  * @since JavaFX 8u40
  89  */
  90 public abstract class SpinnerValueFactory&lt;T&gt; {
  91 
  92     /***************************************************************************
  93      *                                                                         *
  94      * Private fields                                                          *
  95      *                                                                         *
  96      **************************************************************************/
  97 
  98 
  99 
 100     /***************************************************************************
 101      *                                                                         *
 102      * Abstract methods                                                        *
 103      *                                                                         *
 104      **************************************************************************/
 105 
 106     /**
 107      * Attempts to decrement the {@link #valueProperty() value} by the given
 108      * number of steps.
 109      *
 110      * @param steps The number of decrements that should be performed on the value.
 111      */
 112     public abstract void decrement(int steps);
 113 
 114 
 115     /**
 116      * Attempts to omcrement the {@link #valueProperty() value} by the given
 117      * number of steps.
 118      *
 119      * @param steps The number of increments that should be performed on the value.
 120      */
 121     public abstract void increment(int steps);
 122 
 123 
 124 
 125     /***************************************************************************
 126      *                                                                         *
 127      * Properties                                                              *
 128      *                                                                         *
 129      **************************************************************************/
 130 
 131     // --- value
 132     /**
 133      * Represents the current value of the SpinnerValueFactory, or null if no
 134      * value has been set.
 135      */
 136     private ObjectProperty&lt;T&gt; value = new SimpleObjectProperty&lt;&gt;(this, &quot;value&quot;);
 137     public final T getValue() {
 138         return value.get();
 139     }
 140     public final void setValue(T newValue) {
 141         value.set(newValue);
 142     }
 143     public final ObjectProperty&lt;T&gt; valueProperty() {
 144         return value;
 145     }
 146 
 147 
 148     // --- converter
 149     /**
 150      * Converts the user-typed input (when the Spinner is
 151      * {@link Spinner#editableProperty() editable}) to an object of type T,
 152      * such that the input may be retrieved via the  {@link #valueProperty() value}
 153      * property.
 154      */
 155     private ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converter = new SimpleObjectProperty&lt;&gt;(this, &quot;converter&quot;);
 156     public final StringConverter&lt;T&gt; getConverter() {
 157         return converter.get();
 158     }
 159     public final void setConverter(StringConverter&lt;T&gt; newValue) {
 160         converter.set(newValue);
 161     }
 162     public final ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converterProperty() {
 163         return converter;
 164     }
 165 
 166 
 167     // --- wrapAround
 168     /**
 169      * The wrapAround property is used to specify whether the value factory should
 170      * be circular. For example, should an integer-based value model increment
 171      * from the maximum value back to the minimum value (and vice versa).
 172      */
 173     private BooleanProperty wrapAround;
 174     public final void setWrapAround(boolean value) {
 175         wrapAroundProperty().set(value);
 176     }
 177     public final boolean isWrapAround() {
 178         return wrapAround == null ? false : wrapAround.get();
 179     }
 180     public final BooleanProperty wrapAroundProperty() {
 181         if (wrapAround == null) {
 182             wrapAround = new SimpleBooleanProperty(this, &quot;wrapAround&quot;, false);
 183         }
 184         return wrapAround;
 185     }
 186 
 187 
 188 
 189     /***************************************************************************
 190      *                                                                         *
 191      * Subclasses of SpinnerValueFactory                                       *
 192      *                                                                         *
 193      **************************************************************************/
 194 
 195     /**
 196      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
 197      * a list of values.
 198      *
 199      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
 200      * simply as shown below, which may be adequate in many cases, but it is important
 201      * for users to ensure that this suits their needs (and adjust when necessary):
 202      *
 203      * &lt;pre&gt;
 204      * setConverter(new StringConverter&amp;lt;T&amp;gt;() {
 205      *     &amp;#064;Override public String toString(T value) {
 206      *         if (value == null) {
 207      *             return &quot;&quot;;
 208      *         }
 209      *         return value.toString();
 210      *     }
 211      *
 212      *     &amp;#064;Override public T fromString(String string) {
 213      *         return (T) string;
 214      *     }
 215      * });&lt;/pre&gt;
 216      *
 217      * @param &lt;T&gt; The type of the elements in the {@link java.util.List}.
 218      * @since JavaFX 8u40
 219      */
 220     public static class ListSpinnerValueFactory&lt;T&gt; extends SpinnerValueFactory&lt;T&gt; {
 221 
 222         /***********************************************************************
 223          *                                                                     *
 224          * Private fields                                                      *
 225          *                                                                     *
 226          **********************************************************************/
 227 
 228         private int currentIndex = 0;
 229 
 230         private final ListChangeListener&lt;T&gt; itemsContentObserver = c -&gt; {
 231             // the items content has changed. We do not try to find the current
 232             // item, instead we remain at the currentIndex, if possible, or else
 233             // we go back to index 0, and if that fails, we go to null
 234             updateCurrentIndex();
 235         };
 236 
 237         private WeakListChangeListener&lt;T&gt; weakItemsContentObserver =
 238                 new WeakListChangeListener&lt;T&gt;(itemsContentObserver);
 239 
 240 
 241 
 242         /***********************************************************************
 243          *                                                                     *
 244          * Constructors                                                        *
 245          *                                                                     *
 246          **********************************************************************/
 247 
 248         /**
 249          * Creates a new instance of the ListSpinnerValueFactory with the given
 250          * list used as the list to step through.
 251          *
 252          * @param items The list of items to step through with the Spinner.
 253          */
 254         public ListSpinnerValueFactory(@NamedArg(&quot;items&quot;) ObservableList&lt;T&gt; items) {
 255             setItems(items);
 256             setConverter(new StringConverter&lt;T&gt;() {
 257                 @Override public String toString(T value) {
 258                     if (value == null) {
 259                         return &quot;&quot;;
 260                     }
 261                     return value.toString();
 262                 }
 263 
 264                 @Override public T fromString(String string) {
 265                     return (T) string;
 266                 }
 267             });
 268 
 269             valueProperty().addListener((o, oldValue, newValue) -&gt; {
 270                 // when the value is set, we need to react to ensure it is a
 271                 // valid value (and if not, blow up appropriately)
 272                 int newIndex = -1;
 273                 if (items.contains(newValue)) {
 274                     newIndex = items.indexOf(newValue);
 275                 } else {
 276                     // add newValue to list
 277                     items.add(newValue);
 278                     newIndex = items.indexOf(newValue);
 279                 }
 280                 currentIndex = newIndex;
 281             });
 282             setValue(_getValue(currentIndex));
 283         }
 284 
 285 
 286 
 287         /***********************************************************************
 288          *                                                                     *
 289          * Properties                                                          *
 290          *                                                                     *
 291          **********************************************************************/
 292         // --- Items
 293         private ObjectProperty&lt;ObservableList&lt;T&gt;&gt; items;
 294 
 295         /**
 296          * Sets the underlying data model for the ListSpinnerValueFactory. Note that it has a generic
 297          * type that must match the type of the Spinner itself.
 298          * @param value the list of items
 299          */
 300         public final void setItems(ObservableList&lt;T&gt; value) {
 301             itemsProperty().set(value);
 302         }
 303 
 304         /**
 305          * Returns an {@link javafx.collections.ObservableList} that contains the items currently able
 306          * to be iterated through by the user. This may be null if
 307          * {@link #setItems(javafx.collections.ObservableList)} has previously been
 308          * called, however, by default it is an empty ObservableList.
 309          *
 310          * @return An ObservableList containing the items to be shown to the user, or
 311          *      null if the items have previously been set to null.
 312          */
 313         public final ObservableList&lt;T&gt; getItems() {
 314             return items == null ? null : items.get();
 315         }
 316 
 317         /**
 318          * The underlying data model for the ListView. Note that it has a generic
 319          * type that must match the type of the ListView itself.
 320          * @return the list of items
 321          */
 322         public final ObjectProperty&lt;ObservableList&lt;T&gt;&gt; itemsProperty() {
 323             if (items == null) {
 324                 items = new SimpleObjectProperty&lt;ObservableList&lt;T&gt;&gt;(this, &quot;items&quot;) {
 325                     WeakReference&lt;ObservableList&lt;T&gt;&gt; oldItemsRef;
 326 
 327                     @Override protected void invalidated() {
 328                         ObservableList&lt;T&gt; oldItems = oldItemsRef == null ? null : oldItemsRef.get();
 329                         ObservableList&lt;T&gt; newItems = getItems();
 330 
 331                         // update listeners
 332                         if (oldItems != null) {
 333                             oldItems.removeListener(weakItemsContentObserver);
 334                         }
 335                         if (newItems != null) {
 336                             newItems.addListener(weakItemsContentObserver);
 337                         }
 338 
 339                         // update the current value based on the index
 340                         updateCurrentIndex();
 341 
 342                         oldItemsRef = new WeakReference&lt;&gt;(getItems());
 343                     }
 344                 };
 345             }
 346             return items;
 347         }
 348 
 349 
 350 
 351         /***********************************************************************
 352          *                                                                     *
 353          * Overridden methods                                                  *
 354          *                                                                     *
 355          **********************************************************************/
 356 
 357         /** {@inheritDoc} */
 358         @Override public void decrement(int steps) {
 359             final int max = getItemsSize() - 1;
 360             int newIndex = currentIndex - steps;
 361             currentIndex = newIndex &gt;= 0 ? newIndex : (isWrapAround() ? Spinner.wrapValue(newIndex, 0, max + 1) : 0);
 362             setValue(_getValue(currentIndex));
 363         }
 364 
 365         /** {@inheritDoc} */
 366         @Override public void increment(int steps) {
 367             final int max = getItemsSize() - 1;
 368             int newIndex = currentIndex + steps;
 369             currentIndex = newIndex &lt;= max ? newIndex : (isWrapAround() ? Spinner.wrapValue(newIndex, 0, max + 1) : max);
 370             setValue(_getValue(currentIndex));
 371         }
 372 
 373 
 374 
 375         /***********************************************************************
 376          *                                                                     *
 377          * Private implementation                                              *
 378          *                                                                     *
 379          **********************************************************************/
 380         private int getItemsSize() {
 381             List&lt;T&gt; items = getItems();
 382             return items == null ? 0 : items.size();
 383         }
 384 
 385         private void updateCurrentIndex() {
 386             int itemsSize = getItemsSize();
 387             if (currentIndex &lt; 0 || currentIndex &gt;= itemsSize) {
 388                 currentIndex = 0;
 389             }
 390             setValue(_getValue(currentIndex));
 391         }
 392 
 393         private T _getValue(int index) {
 394             List&lt;T&gt; items = getItems();
 395             return items == null ? null : (index &gt;= 0 &amp;&amp; index &lt; items.size()) ? items.get(index) : null;
 396         }
 397     }
 398 
 399 
 400 
 401     /**
 402      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
 403      * integer values.
 404      *
 405      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
 406      * as an {@link javafx.util.converter.IntegerStringConverter} instance.
 407      *
 408      * @since JavaFX 8u40
 409      */
 410     public static class IntegerSpinnerValueFactory extends SpinnerValueFactory&lt;Integer&gt; {
 411 
 412         /***********************************************************************
 413          *                                                                     *
 414          * Constructors                                                        *
 415          *                                                                     *
 416          **********************************************************************/
 417 
 418         /**
 419          * Constructs a new IntegerSpinnerValueFactory that sets the initial value
 420          * to be equal to the min value, and a default {@code amountToStepBy} of one.
 421          *
 422          * @param min The minimum allowed integer value for the Spinner.
 423          * @param max The maximum allowed integer value for the Spinner.
 424          */
 425         public IntegerSpinnerValueFactory(@NamedArg(&quot;min&quot;) int min,
 426                                           @NamedArg(&quot;max&quot;) int max) {
 427             this(min, max, min);
 428         }
 429 
 430         /**
 431          * Constructs a new IntegerSpinnerValueFactory with a default
 432          * {@code amountToStepBy} of one.
 433          *
 434          * @param min The minimum allowed integer value for the Spinner.
 435          * @param max The maximum allowed integer value for the Spinner.
 436          * @param initialValue The value of the Spinner when first instantiated, must
 437          *                     be within the bounds of the min and max arguments, or
 438          *                     else the min value will be used.
 439          */
 440         public IntegerSpinnerValueFactory(@NamedArg(&quot;min&quot;) int min,
 441                                           @NamedArg(&quot;max&quot;) int max,
 442                                           @NamedArg(&quot;initialValue&quot;) int initialValue) {
 443             this(min, max, initialValue, 1);
 444         }
 445 
 446         /**
 447          * Constructs a new IntegerSpinnerValueFactory.
 448          *
 449          * @param min The minimum allowed integer value for the Spinner.
 450          * @param max The maximum allowed integer value for the Spinner.
 451          * @param initialValue The value of the Spinner when first instantiated, must
 452          *                     be within the bounds of the min and max arguments, or
 453          *                     else the min value will be used.
 454          * @param amountToStepBy The amount to increment or decrement by, per step.
 455          */
 456         public IntegerSpinnerValueFactory(@NamedArg(&quot;min&quot;) int min,
 457                                           @NamedArg(&quot;max&quot;) int max,
 458                                           @NamedArg(&quot;initialValue&quot;) int initialValue,
 459                                           @NamedArg(&quot;amountToStepBy&quot;) int amountToStepBy) {
 460             setMin(min);
 461             setMax(max);
 462             setAmountToStepBy(amountToStepBy);
 463             setConverter(new IntegerStringConverter());
 464 
 465             valueProperty().addListener((o, oldValue, newValue) -&gt; {
 466                 // when the value is set, we need to react to ensure it is a
 467                 // valid value (and if not, blow up appropriately)
 468                 if (newValue &lt; getMin()) {
 469                     setValue(getMin());
 470                 } else if (newValue &gt; getMax()) {
 471                     setValue(getMax());
 472                 }
 473             });
 474             setValue(initialValue &gt;= min &amp;&amp; initialValue &lt;= max ? initialValue : min);
 475         }
 476 
 477 
 478         /***********************************************************************
 479          *                                                                     *
 480          * Properties                                                          *
 481          *                                                                     *
 482          **********************************************************************/
 483 
 484         // --- min
 485         private IntegerProperty min = new SimpleIntegerProperty(this, &quot;min&quot;) {
 486             @Override protected void invalidated() {
 487                 Integer currentValue = IntegerSpinnerValueFactory.this.getValue();
 488                 if (currentValue == null) {
 489                     return;
 490                 }
 491 
 492                 int newMin = get();
 493                 if (newMin &gt; getMax()) {
 494                     setMin(getMax());
 495                     return;
 496                 }
 497 
 498                 if (currentValue &lt; newMin) {
 499                     IntegerSpinnerValueFactory.this.setValue(newMin);
 500                 }
 501             }
 502         };
 503 
 504         public final void setMin(int value) {
 505             min.set(value);
 506         }
 507         public final int getMin() {
 508             return min.get();
 509         }
 510         /**
 511          * Sets the minimum allowable value for this value factory
 512          * @return the minimum allowable value for this value factory
 513          */
 514         public final IntegerProperty minProperty() {
 515             return min;
 516         }
 517 
 518         // --- max
 519         private IntegerProperty max = new SimpleIntegerProperty(this, &quot;max&quot;) {
 520             @Override protected void invalidated() {
 521                 Integer currentValue = IntegerSpinnerValueFactory.this.getValue();
 522                 if (currentValue == null) {
 523                     return;
 524                 }
 525 
 526                 int newMax = get();
 527                 if (newMax &lt; getMin()) {
 528                     setMax(getMin());
 529                     return;
 530                 }
 531 
 532                 if (currentValue &gt; newMax) {
 533                     IntegerSpinnerValueFactory.this.setValue(newMax);
 534                 }
 535             }
 536         };
 537 
 538         public final void setMax(int value) {
 539             max.set(value);
 540         }
 541         public final int getMax() {
 542             return max.get();
 543         }
 544         /**
 545          * Sets the maximum allowable value for this value factory
 546          * @return the maximum allowable value for this value factory
 547          */
 548         public final IntegerProperty maxProperty() {
 549             return max;
 550         }
 551 
 552         // --- amountToStepBy
 553         private IntegerProperty amountToStepBy = new SimpleIntegerProperty(this, &quot;amountToStepBy&quot;);
 554         public final void setAmountToStepBy(int value) {
 555             amountToStepBy.set(value);
 556         }
 557         public final int getAmountToStepBy() {
 558             return amountToStepBy.get();
 559         }
 560         /**
 561          * Sets the amount to increment or decrement by, per step.
 562          * @return the amount to increment or decrement by, per step
 563          */
 564         public final IntegerProperty amountToStepByProperty() {
 565             return amountToStepBy;
 566         }
 567 
 568 
 569 
 570         /***********************************************************************
 571          *                                                                     *
 572          * Overridden methods                                                  *
 573          *                                                                     *
 574          **********************************************************************/
 575 
 576         /** {@inheritDoc} */
 577         @Override public void decrement(int steps) {
 578             final int min = getMin();
 579             final int max = getMax();
 580             final int newIndex = getValue() - steps * getAmountToStepBy();
 581             setValue(newIndex &gt;= min ? newIndex : (isWrapAround() ? Spinner.wrapValue(newIndex, min, max, false) : min));
 582         }
 583 
 584         /** {@inheritDoc} */
 585         @Override public void increment(int steps) {
 586             final int min = getMin();
 587             final int max = getMax();
 588             final int currentValue = getValue();
 589             final int newIndex = currentValue + steps * getAmountToStepBy();
 590             setValue(newIndex &lt;= max ? newIndex : (isWrapAround() ? Spinner.wrapValue(newIndex, min, max, true) : max));
 591         }
 592     }
 593 
 594     /**
 595      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
 596      * double values.
 597      *
 598      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
 599      * simply as shown below, which may be adequate in many cases, but it is important
 600      * for users to ensure that this suits their needs (and adjust when necessary). The
 601      * main point to note is that this {@link javafx.util.StringConverter} embeds
 602      * within it a {@link java.text.DecimalFormat} instance that shows the Double
 603      * to two decimal places. This is used for both the toString and fromString
 604      * methods:
 605      *
 606      * &lt;pre&gt;
 607      * setConverter(new StringConverter&amp;lt;Double&amp;gt;() {
 608      *     private final DecimalFormat df = new DecimalFormat(&quot;#.##&quot;);
 609      *
 610      *     &amp;#064;Override public String toString(Double value) {
 611      *         // If the specified value is null, return a zero-length String
 612      *         if (value == null) {
 613      *             return &quot;&quot;;
 614      *         }
 615      *
 616      *         return df.format(value);
 617      *     }
 618      *
 619      *     &amp;#064;Override public Double fromString(String value) {
 620      *         try {
 621      *             // If the specified value is null or zero-length, return null
 622      *             if (value == null) {
 623      *                 return null;
 624      *             }
 625      *
 626      *             value = value.trim();
 627      *
 628      *             if (value.length() &amp;lt; 1) {
 629      *                 return null;
 630      *             }
 631      *
 632      *             // Perform the requested parsing
 633      *             return df.parse(value).doubleValue();
 634      *         } catch (ParseException ex) {
 635      *             throw new RuntimeException(ex);
 636      *         }
 637      *     }
 638      * });&lt;/pre&gt;
 639      *
 640      * @since JavaFX 8u40
 641      */
 642     public static class DoubleSpinnerValueFactory extends SpinnerValueFactory&lt;Double&gt; {
 643 
 644         /**
 645          * Constructs a new DoubleSpinnerValueFactory that sets the initial value
 646          * to be equal to the min value, and a default {@code amountToStepBy} of
 647          * one.
 648          *
 649          * @param min The minimum allowed double value for the Spinner.
 650          * @param max The maximum allowed double value for the Spinner.
 651          */
 652         public DoubleSpinnerValueFactory(@NamedArg(&quot;min&quot;) double min,
 653                                          @NamedArg(&quot;max&quot;) double max) {
 654             this(min, max, min);
 655         }
 656 
 657         /**
 658          * Constructs a new DoubleSpinnerValueFactory with a default
 659          * {@code amountToStepBy} of one.
 660          *
 661          * @param min The minimum allowed double value for the Spinner.
 662          * @param max The maximum allowed double value for the Spinner.
 663          * @param initialValue The value of the Spinner when first instantiated, must
 664          *                     be within the bounds of the min and max arguments, or
 665          *                     else the min value will be used.
 666          */
 667         public DoubleSpinnerValueFactory(@NamedArg(&quot;min&quot;) double min,
 668                                          @NamedArg(&quot;max&quot;) double max,
 669                                          @NamedArg(&quot;initialValue&quot;) double initialValue) {
 670             this(min, max, initialValue, 1);
 671         }
 672 
 673         /**
 674          * Constructs a new DoubleSpinnerValueFactory.
 675          *
 676          * @param min The minimum allowed double value for the Spinner.
 677          * @param max The maximum allowed double value for the Spinner.
 678          * @param initialValue The value of the Spinner when first instantiated, must
 679          *                     be within the bounds of the min and max arguments, or
 680          *                     else the min value will be used.
 681          * @param amountToStepBy The amount to increment or decrement by, per step.
 682          */
 683         public DoubleSpinnerValueFactory(@NamedArg(&quot;min&quot;) double min,
 684                                          @NamedArg(&quot;max&quot;) double max,
 685                                          @NamedArg(&quot;initialValue&quot;) double initialValue,
 686                                          @NamedArg(&quot;amountToStepBy&quot;) double amountToStepBy) {
 687             setMin(min);
 688             setMax(max);
 689             setAmountToStepBy(amountToStepBy);
 690             setConverter(new StringConverter&lt;Double&gt;() {
 691                 private final DecimalFormat df = new DecimalFormat(&quot;#.##&quot;);
 692 
 693                 @Override public String toString(Double value) {
 694                     // If the specified value is null, return a zero-length String
 695                     if (value == null) {
 696                         return &quot;&quot;;
 697                     }
 698 
 699                     return df.format(value);
 700                 }
 701 
 702                 @Override public Double fromString(String value) {
 703                     try {
 704                         // If the specified value is null or zero-length, return null
 705                         if (value == null) {
 706                             return null;
 707                         }
 708 
 709                         value = value.trim();
 710 
 711                         if (value.length() &lt; 1) {
 712                             return null;
 713                         }
 714 
 715                         // Perform the requested parsing
 716                         return df.parse(value).doubleValue();
 717                     } catch (ParseException ex) {
 718                         throw new RuntimeException(ex);
 719                     }
 720                 }
 721             });
 722 
 723             valueProperty().addListener((o, oldValue, newValue) -&gt; {
 724                 if (newValue == null) return;
 725 
 726                 // when the value is set, we need to react to ensure it is a
 727                 // valid value (and if not, blow up appropriately)
 728                 if (newValue &lt; getMin()) {
 729                     setValue(getMin());
 730                 } else if (newValue &gt; getMax()) {
 731                     setValue(getMax());
 732                 }
 733             });
 734             setValue(initialValue &gt;= min &amp;&amp; initialValue &lt;= max ? initialValue : min);
 735         }
 736 
 737 
 738 
 739         /***********************************************************************
 740          *                                                                     *
 741          * Properties                                                          *
 742          *                                                                     *
 743          **********************************************************************/
 744 
 745         // --- min
 746         private DoubleProperty min = new SimpleDoubleProperty(this, &quot;min&quot;) {
 747             @Override protected void invalidated() {
 748                 Double currentValue = DoubleSpinnerValueFactory.this.getValue();
 749                 if (currentValue == null) {
 750                     return;
 751                 }
 752 
 753                 final double newMin = get();
 754                 if (newMin &gt; getMax()) {
 755                     setMin(getMax());
 756                     return;
 757                 }
 758 
 759                 if (currentValue &lt; newMin) {
 760                     DoubleSpinnerValueFactory.this.setValue(newMin);
 761                 }
 762             }
 763         };
 764 
 765         public final void setMin(double value) {
 766             min.set(value);
 767         }
 768         public final double getMin() {
 769             return min.get();
 770         }
 771         /**
 772          * Sets the minimum allowable value for this value factory
 773          * @return the minimum allowable value for this value factory
 774          */
 775         public final DoubleProperty minProperty() {
 776             return min;
 777         }
 778 
 779         // --- max
 780         private DoubleProperty max = new SimpleDoubleProperty(this, &quot;max&quot;) {
 781             @Override protected void invalidated() {
 782                 Double currentValue = DoubleSpinnerValueFactory.this.getValue();
 783                 if (currentValue == null) {
 784                     return;
 785                 }
 786 
 787                 final double newMax = get();
 788                 if (newMax &lt; getMin()) {
 789                     setMax(getMin());
 790                     return;
 791                 }
 792 
 793                 if (currentValue &gt; newMax) {
 794                     DoubleSpinnerValueFactory.this.setValue(newMax);
 795                 }
 796             }
 797         };
 798 
 799         public final void setMax(double value) {
 800             max.set(value);
 801         }
 802         public final double getMax() {
 803             return max.get();
 804         }
 805         /**
 806          * Sets the maximum allowable value for this value factory
 807          * @return the maximum allowable value for this value factory
 808          */
 809         public final DoubleProperty maxProperty() {
 810             return max;
 811         }
 812 
 813         // --- amountToStepBy
 814         private DoubleProperty amountToStepBy = new SimpleDoubleProperty(this, &quot;amountToStepBy&quot;);
 815         public final void setAmountToStepBy(double value) {
 816             amountToStepBy.set(value);
 817         }
 818         public final double getAmountToStepBy() {
 819             return amountToStepBy.get();
 820         }
 821         /**
 822          * Sets the amount to increment or decrement by, per step.
 823          * @return the amount to increment or decrement by, per step
 824          */
 825         public final DoubleProperty amountToStepByProperty() {
 826             return amountToStepBy;
 827         }
 828 
 829 
 830 
 831         /** {@inheritDoc} */
 832         @Override public void decrement(int steps) {
 833             final BigDecimal currentValue = BigDecimal.valueOf(getValue());
 834             final BigDecimal minBigDecimal = BigDecimal.valueOf(getMin());
 835             final BigDecimal maxBigDecimal = BigDecimal.valueOf(getMax());
 836             final BigDecimal amountToStepByBigDecimal = BigDecimal.valueOf(getAmountToStepBy());
 837             BigDecimal newValue = currentValue.subtract(amountToStepByBigDecimal.multiply(BigDecimal.valueOf(steps)));
 838             setValue(newValue.compareTo(minBigDecimal) &gt;= 0 ? newValue.doubleValue() :
 839                     (isWrapAround() ? Spinner.wrapValue(newValue, minBigDecimal, maxBigDecimal).doubleValue() : getMin()));
 840         }
 841 
 842         /** {@inheritDoc} */
 843         @Override public void increment(int steps) {
 844             final BigDecimal currentValue = BigDecimal.valueOf(getValue());
 845             final BigDecimal minBigDecimal = BigDecimal.valueOf(getMin());
 846             final BigDecimal maxBigDecimal = BigDecimal.valueOf(getMax());
 847             final BigDecimal amountToStepByBigDecimal = BigDecimal.valueOf(getAmountToStepBy());
 848             BigDecimal newValue = currentValue.add(amountToStepByBigDecimal.multiply(BigDecimal.valueOf(steps)));
 849             setValue(newValue.compareTo(maxBigDecimal) &lt;= 0 ? newValue.doubleValue() :
 850                     (isWrapAround() ? Spinner.wrapValue(newValue, minBigDecimal, maxBigDecimal).doubleValue() : getMax()));
 851         }
 852     }
 853 
 854     /**
 855      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
 856      * {@link java.time.LocalDate} values.
 857      *
 858      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
 859      * simply as shown below, which may be adequate in many cases, but it is important
 860      * for users to ensure that this suits their needs (and adjust when necessary):
 861      *
 862      * &lt;pre&gt;
 863      * setConverter(new StringConverter&amp;lt;LocalDate&amp;gt;() {
 864      *     &amp;#064;Override public String toString(LocalDate object) {
 865      *         if (object == null) {
 866      *             return &quot;&quot;;
 867      *         }
 868      *         return object.toString();
 869      *     }
 870      *
 871      *     &amp;#064;Override public LocalDate fromString(String string) {
 872      *         return LocalDate.parse(string);
 873      *     }
 874      * });&lt;/pre&gt;
 875      */
 876     static class LocalDateSpinnerValueFactory extends SpinnerValueFactory&lt;LocalDate&gt; {
 877 
 878         /**
 879          * Creates a new instance of the LocalDateSpinnerValueFactory, using the
 880          * value returned by calling {@code LocalDate#now()} as the initial value,
 881          * and using a stepping amount of one day.
 882          */
 883         public LocalDateSpinnerValueFactory() {
 884             this(LocalDate.now());
 885         }
 886 
 887         /**
 888          * Creates a new instance of the LocalDateSpinnerValueFactory, using the
 889          * provided initial value, and a stepping amount of one day.
 890          *
 891          * @param initialValue The value of the Spinner when first instantiated.
 892          */
 893         public LocalDateSpinnerValueFactory(@NamedArg(&quot;initialValue&quot;) LocalDate initialValue) {
 894             this(LocalDate.MIN, LocalDate.MAX, initialValue);
 895         }
 896 
 897         /**
 898          * Creates a new instance of the LocalDateSpinnerValueFactory, using the
 899          * provided initial value, and a stepping amount of one day.
 900          *
 901          * @param min The minimum allowed double value for the Spinner.
 902          * @param max The maximum allowed double value for the Spinner.
 903          * @param initialValue The value of the Spinner when first instantiated.
 904          */
 905         public LocalDateSpinnerValueFactory(@NamedArg(&quot;min&quot;) LocalDate min,
 906                                             @NamedArg(&quot;min&quot;) LocalDate max,
 907                                             @NamedArg(&quot;initialValue&quot;) LocalDate initialValue) {
 908             this(min, max, initialValue, 1, ChronoUnit.DAYS);
 909         }
 910 
 911         /**
 912          * Creates a new instance of the LocalDateSpinnerValueFactory, using the
 913          * provided min, max, and initial values, as well as the amount to step
 914          * by and {@link java.time.temporal.TemporalUnit}.
 915          *
 916          * &lt;p&gt;To better understand, here are a few examples:
 917          *
 918          * &lt;ul&gt;
 919          *     &lt;li&gt;&lt;strong&gt;To step by one day from today: &lt;/strong&gt; {@code new LocalDateSpinnerValueFactory(LocalDate.MIN, LocalDate.MAX, LocalDate.now(), 1, ChronoUnit.DAYS)}&lt;/li&gt;
 920          *     &lt;li&gt;&lt;strong&gt;To step by one month from today: &lt;/strong&gt; {@code new LocalDateSpinnerValueFactory(LocalDate.MIN, LocalDate.MAX, LocalDate.now(), 1, ChronoUnit.MONTHS)}&lt;/li&gt;
 921          *     &lt;li&gt;&lt;strong&gt;To step by one year from today: &lt;/strong&gt; {@code new LocalDateSpinnerValueFactory(LocalDate.MIN, LocalDate.MAX, LocalDate.now(), 1, ChronoUnit.YEARS)}&lt;/li&gt;
 922          * &lt;/ul&gt;
 923          *
 924          * @param min The minimum allowed double value for the Spinner.
 925          * @param max The maximum allowed double value for the Spinner.
 926          * @param initialValue The value of the Spinner when first instantiated.
 927          * @param amountToStepBy The amount to increment or decrement by, per step.
 928          * @param temporalUnit The size of each step (e.g. day, week, month, year, etc)
 929          */
 930         public LocalDateSpinnerValueFactory(@NamedArg(&quot;min&quot;) LocalDate min,
 931                                             @NamedArg(&quot;min&quot;) LocalDate max,
 932                                             @NamedArg(&quot;initialValue&quot;) LocalDate initialValue,
 933                                             @NamedArg(&quot;amountToStepBy&quot;) long amountToStepBy,
 934                                             @NamedArg(&quot;temporalUnit&quot;) TemporalUnit temporalUnit) {
 935             setMin(min);
 936             setMax(max);
 937             setAmountToStepBy(amountToStepBy);
 938             setTemporalUnit(temporalUnit);
 939             setConverter(new StringConverter&lt;LocalDate&gt;() {
 940                 @Override public String toString(LocalDate object) {
 941                     if (object == null) {
 942                         return &quot;&quot;;
 943                     }
 944                     return object.toString();
 945                 }
 946 
 947                 @Override public LocalDate fromString(String string) {
 948                     return LocalDate.parse(string);
 949                 }
 950             });
 951 
 952             valueProperty().addListener((o, oldValue, newValue) -&gt; {
 953                 // when the value is set, we need to react to ensure it is a
 954                 // valid value (and if not, blow up appropriately)
 955                 if (getMin() != null &amp;&amp; newValue.isBefore(getMin())) {
 956                     setValue(getMin());
 957                 } else if (getMax() != null &amp;&amp; newValue.isAfter(getMax())) {
 958                     setValue(getMax());
 959                 }
 960             });
 961             setValue(initialValue != null ? initialValue : LocalDate.now());
 962         }
 963 
 964 
 965 
 966         /***********************************************************************
 967          *                                                                     *
 968          * Properties                                                          *
 969          *                                                                     *
 970          **********************************************************************/
 971 
 972         // --- min
 973         private ObjectProperty&lt;LocalDate&gt; min = new SimpleObjectProperty&lt;LocalDate&gt;(this, &quot;min&quot;) {
 974             @Override protected void invalidated() {
 975                 LocalDate currentValue = LocalDateSpinnerValueFactory.this.getValue();
 976                 if (currentValue == null) {
 977                     return;
 978                 }
 979 
 980                 final LocalDate newMin = get();
 981                 if (newMin.isAfter(getMax())) {
 982                     setMin(getMax());
 983                     return;
 984                 }
 985 
 986                 if (currentValue.isBefore(newMin)) {
 987                     LocalDateSpinnerValueFactory.this.setValue(newMin);
 988                 }
 989             }
 990         };
 991 
 992         public final void setMin(LocalDate value) {
 993             min.set(value);
 994         }
 995         public final LocalDate getMin() {
 996             return min.get();
 997         }
 998         /**
 999          * Sets the minimum allowable value for this value factory
1000          */
1001         public final ObjectProperty&lt;LocalDate&gt; minProperty() {
1002             return min;
1003         }
1004 
1005         // --- max
1006         private ObjectProperty&lt;LocalDate&gt; max = new SimpleObjectProperty&lt;LocalDate&gt;(this, &quot;max&quot;) {
1007             @Override protected void invalidated() {
1008                 LocalDate currentValue = LocalDateSpinnerValueFactory.this.getValue();
1009                 if (currentValue == null) {
1010                     return;
1011                 }
1012 
1013                 final LocalDate newMax = get();
1014                 if (newMax.isBefore(getMin())) {
1015                     setMax(getMin());
1016                     return;
1017                 }
1018 
1019                 if (currentValue.isAfter(newMax)) {
1020                     LocalDateSpinnerValueFactory.this.setValue(newMax);
1021                 }
1022             }
1023         };
1024 
1025         public final void setMax(LocalDate value) {
1026             max.set(value);
1027         }
1028         public final LocalDate getMax() {
1029             return max.get();
1030         }
1031         /**
1032          * Sets the maximum allowable value for this value factory
1033          */
1034         public final ObjectProperty&lt;LocalDate&gt; maxProperty() {
1035             return max;
1036         }
1037 
1038         // --- temporalUnit
1039         private ObjectProperty&lt;TemporalUnit&gt; temporalUnit = new SimpleObjectProperty&lt;&gt;(this, &quot;temporalUnit&quot;);
1040         public final void setTemporalUnit(TemporalUnit value) {
1041             temporalUnit.set(value);
1042         }
1043         public final TemporalUnit getTemporalUnit() {
1044             return temporalUnit.get();
1045         }
1046         /**
1047          * The size of each step (e.g. day, week, month, year, etc).
1048          */
1049         public final ObjectProperty&lt;TemporalUnit&gt; temporalUnitProperty() {
1050             return temporalUnit;
1051         }
1052 
1053         // --- amountToStepBy
1054         private LongProperty amountToStepBy = new SimpleLongProperty(this, &quot;amountToStepBy&quot;);
1055         public final void setAmountToStepBy(long value) {
1056             amountToStepBy.set(value);
1057         }
1058         public final long getAmountToStepBy() {
1059             return amountToStepBy.get();
1060         }
1061         /**
1062          * Sets the amount to increment or decrement by, per step.
1063          */
1064         public final LongProperty amountToStepByProperty() {
1065             return amountToStepBy;
1066         }
1067 
1068 
1069 
1070         /***********************************************************************
1071          *                                                                     *
1072          * Overridden methods                                                  *
1073          *                                                                     *
1074          **********************************************************************/
1075 
1076         /** {@inheritDoc} */
1077         @Override public void decrement(int steps) {
1078             final LocalDate currentValue = getValue();
1079             final LocalDate min = getMin();
1080             LocalDate newValue = currentValue.minus(getAmountToStepBy() * steps, getTemporalUnit());
1081 
1082             if (min != null &amp;&amp; isWrapAround() &amp;&amp; newValue.isBefore(min)) {
1083                 // we need to wrap around
1084                 newValue = getMax();
1085             }
1086 
1087             setValue(newValue);
1088         }
1089 
1090         /** {@inheritDoc} */
1091         @Override public void increment(int steps) {
1092             final LocalDate currentValue = getValue();
1093             final LocalDate max = getMax();
1094             LocalDate newValue = currentValue.plus(getAmountToStepBy() * steps, getTemporalUnit());
1095 
1096             if (max != null &amp;&amp; isWrapAround() &amp;&amp; newValue.isAfter(max)) {
1097                 // we need to wrap around
1098                 newValue = getMin();
1099             }
1100 
1101             setValue(newValue);
1102         }
1103     }
1104 
1105 
1106 
1107 
1108 
1109     /**
1110      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
1111      * {@link java.time.LocalTime} values.
1112      *
1113      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
1114      * simply as shown below, which may be adequate in many cases, but it is important
1115      * for users to ensure that this suits their needs (and adjust when necessary):
1116      *
1117      * &lt;pre&gt;
1118      * setConverter(new StringConverter&amp;lt;LocalTime&amp;gt;() {
1119      *     &amp;#064;Override public String toString(LocalTime object) {
1120      *         if (object == null) {
1121      *             return &quot;&quot;;
1122      *         }
1123      *         return object.toString();
1124      *     }
1125      *
1126      *     &amp;#064;Override public LocalTime fromString(String string) {
1127      *         return LocalTime.parse(string);
1128      *     }
1129      * });&lt;/pre&gt;
1130      */
1131     static class LocalTimeSpinnerValueFactory extends SpinnerValueFactory&lt;LocalTime&gt; {
1132 
1133         /**
1134          * Creates a new instance of the LocalTimepinnerValueFactory, using the
1135          * value returned by calling {@code LocalTime#now()} as the initial value,
1136          * and using a stepping amount of one day.
1137          */
1138         public LocalTimeSpinnerValueFactory() {
1139             this(LocalTime.now());
1140         }
1141 
1142         /**
1143          * Creates a new instance of the LocalTimeSpinnerValueFactory, using the
1144          * provided initial value, and a stepping amount of one hour.
1145          *
1146          * @param initialValue The value of the Spinner when first instantiated.
1147          */
1148         public LocalTimeSpinnerValueFactory(@NamedArg(&quot;initialValue&quot;) LocalTime initialValue) {
1149             this(LocalTime.MIN, LocalTime.MAX, initialValue);
1150         }
1151 
1152         /**
1153          * Creates a new instance of the LocalTimeSpinnerValueFactory, using the
1154          * provided initial value, and a stepping amount of one hour.
1155          *
1156          * @param min The minimum allowed double value for the Spinner.
1157          * @param max The maximum allowed double value for the Spinner.
1158          * @param initialValue The value of the Spinner when first instantiated.
1159          */
1160         public LocalTimeSpinnerValueFactory(@NamedArg(&quot;min&quot;) LocalTime min,
1161                                             @NamedArg(&quot;min&quot;) LocalTime max,
1162                                             @NamedArg(&quot;initialValue&quot;) LocalTime initialValue) {
1163             this(min, max, initialValue, 1, ChronoUnit.HOURS);
1164         }
1165 
1166         /**
1167          * Creates a new instance of the LocalTimeSpinnerValueFactory, using the
1168          * provided min, max, and initial values, as well as the amount to step
1169          * by and {@link java.time.temporal.TemporalUnit}.
1170          *
1171          * &lt;p&gt;To better understand, here are a few examples:
1172          *
1173          * &lt;ul&gt;
1174          *     &lt;li&gt;&lt;strong&gt;To step by one hour from the current time: &lt;/strong&gt; {@code new LocalTimeSpinnerValueFactory(LocalTime.MIN, LocalTime.MAX, LocalTime.now(), 1, ChronoUnit.HOURS)}&lt;/li&gt;
1175          *     &lt;li&gt;&lt;strong&gt;To step by one minute from the current time: &lt;/strong&gt; {@code new LocalTimeSpinnerValueFactory(LocalTime.MIN, LocalTime.MAX, LocalTime.now(), 1, ChronoUnit.MINUTES)}&lt;/li&gt;
1176          * &lt;/ul&gt;
1177          *
1178          * @param min The minimum allowed double value for the Spinner.
1179          * @param max The maximum allowed double value for the Spinner.
1180          * @param initialValue The value of the Spinner when first instantiated.
1181          * @param amountToStepBy The amount to increment or decrement by, per step.
1182          * @param temporalUnit The size of each step (e.g. day, week, month, year, etc)
1183          */
1184         public LocalTimeSpinnerValueFactory(@NamedArg(&quot;min&quot;) LocalTime min,
1185                                             @NamedArg(&quot;min&quot;) LocalTime max,
1186                                             @NamedArg(&quot;initialValue&quot;) LocalTime initialValue,
1187                                             @NamedArg(&quot;amountToStepBy&quot;) long amountToStepBy,
1188                                             @NamedArg(&quot;temporalUnit&quot;) TemporalUnit temporalUnit) {
1189             setMin(min);
1190             setMax(max);
1191             setAmountToStepBy(amountToStepBy);
1192             setTemporalUnit(temporalUnit);
1193             setConverter(new StringConverter&lt;LocalTime&gt;() {
1194                 private DateTimeFormatter dtf = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT);
1195 
1196                 @Override public String toString(LocalTime localTime) {
1197                     if (localTime == null) {
1198                         return &quot;&quot;;
1199                     }
1200                     return localTime.format(dtf);
1201                 }
1202 
1203                 @Override public LocalTime fromString(String string) {
1204                     return LocalTime.parse(string);
1205                 }
1206             });
1207 
1208             valueProperty().addListener((o, oldValue, newValue) -&gt; {
1209                 // when the value is set, we need to react to ensure it is a
1210                 // valid value (and if not, blow up appropriately)
1211                 if (getMin() != null &amp;&amp; newValue.isBefore(getMin())) {
1212                     setValue(getMin());
1213                 } else if (getMax() != null &amp;&amp; newValue.isAfter(getMax())) {
1214                     setValue(getMax());
1215                 }
1216             });
1217             setValue(initialValue != null ? initialValue : LocalTime.now());
1218         }
1219 
1220 
1221 
1222         /***********************************************************************
1223          *                                                                     *
1224          * Properties                                                          *
1225          *                                                                     *
1226          **********************************************************************/
1227 
1228         // --- min
1229         private ObjectProperty&lt;LocalTime&gt; min = new SimpleObjectProperty&lt;LocalTime&gt;(this, &quot;min&quot;) {
1230             @Override protected void invalidated() {
1231                 LocalTime currentValue = LocalTimeSpinnerValueFactory.this.getValue();
1232                 if (currentValue == null) {
1233                     return;
1234                 }
1235 
1236                 final LocalTime newMin = get();
1237                 if (newMin.isAfter(getMax())) {
1238                     setMin(getMax());
1239                     return;
1240                 }
1241 
1242                 if (currentValue.isBefore(newMin)) {
1243                     LocalTimeSpinnerValueFactory.this.setValue(newMin);
1244                 }
1245             }
1246         };
1247 
1248         public final void setMin(LocalTime value) {
1249             min.set(value);
1250         }
1251         public final LocalTime getMin() {
1252             return min.get();
1253         }
1254         /**
1255          * Sets the minimum allowable value for this value factory
1256          */
1257         public final ObjectProperty&lt;LocalTime&gt; minProperty() {
1258             return min;
1259         }
1260 
1261         // --- max
1262         private ObjectProperty&lt;LocalTime&gt; max = new SimpleObjectProperty&lt;LocalTime&gt;(this, &quot;max&quot;) {
1263             @Override protected void invalidated() {
1264                 LocalTime currentValue = LocalTimeSpinnerValueFactory.this.getValue();
1265                 if (currentValue == null) {
1266                     return;
1267                 }
1268 
1269                 final LocalTime newMax = get();
1270                 if (newMax.isBefore(getMin())) {
1271                     setMax(getMin());
1272                     return;
1273                 }
1274 
1275                 if (currentValue.isAfter(newMax)) {
1276                     LocalTimeSpinnerValueFactory.this.setValue(newMax);
1277                 }
1278             }
1279         };
1280 
1281         public final void setMax(LocalTime value) {
1282             max.set(value);
1283         }
1284         public final LocalTime getMax() {
1285             return max.get();
1286         }
1287         /**
1288          * Sets the maximum allowable value for this value factory
1289          */
1290         public final ObjectProperty&lt;LocalTime&gt; maxProperty() {
1291             return max;
1292         }
1293 
1294         // --- temporalUnit
1295         private ObjectProperty&lt;TemporalUnit&gt; temporalUnit = new SimpleObjectProperty&lt;&gt;(this, &quot;temporalUnit&quot;);
1296         public final void setTemporalUnit(TemporalUnit value) {
1297             temporalUnit.set(value);
1298         }
1299         public final TemporalUnit getTemporalUnit() {
1300             return temporalUnit.get();
1301         }
1302         /**
1303          * The size of each step (e.g. day, week, month, year, etc).
1304          */
1305         public final ObjectProperty&lt;TemporalUnit&gt; temporalUnitProperty() {
1306             return temporalUnit;
1307         }
1308 
1309         // --- amountToStepBy
1310         private LongProperty amountToStepBy = new SimpleLongProperty(this, &quot;amountToStepBy&quot;);
1311         public final void setAmountToStepBy(long value) {
1312             amountToStepBy.set(value);
1313         }
1314         public final long getAmountToStepBy() {
1315             return amountToStepBy.get();
1316         }
1317         /**
1318          * Sets the amount to increment or decrement by, per step.
1319          */
1320         public final LongProperty amountToStepByProperty() {
1321             return amountToStepBy;
1322         }
1323 
1324 
1325 
1326         /***********************************************************************
1327          *                                                                     *
1328          * Overridden methods                                                  *
1329          *                                                                     *
1330          **********************************************************************/
1331 
1332         /** {@inheritDoc} */
1333         @Override public void decrement(int steps) {
1334             final LocalTime currentValue = getValue();
1335             final LocalTime min = getMin();
1336 
1337             final Duration duration = Duration.of(getAmountToStepBy() * steps, getTemporalUnit());
1338 
1339             final long durationInSeconds = duration.toMinutes() * 60;
1340             final long currentValueInSeconds = currentValue.toSecondOfDay();
1341 
1342             if (! isWrapAround() &amp;&amp; durationInSeconds &gt; currentValueInSeconds) {
1343                 setValue(min == null ? LocalTime.MIN : min);
1344             } else {
1345                 setValue(currentValue.minus(duration));
1346             }
1347         }
1348 
1349         /** {@inheritDoc} */
1350         @Override public void increment(int steps) {
1351             final LocalTime currentValue = getValue();
1352             final LocalTime max = getMax();
1353 
1354             final Duration duration = Duration.of(getAmountToStepBy() * steps, getTemporalUnit());
1355 
1356             final long durationInSeconds = duration.toMinutes() * 60;
1357             final long currentValueInSeconds = currentValue.toSecondOfDay();
1358 
1359             if (! isWrapAround() &amp;&amp; durationInSeconds &gt; (LocalTime.MAX.toSecondOfDay() - currentValueInSeconds)) {
1360                 setValue(max == null ? LocalTime.MAX : max);
1361             } else {
1362                 setValue(currentValue.plus(duration));
1363             }
1364         }
1365     }
1366 }
    </pre>
  </body>
</html>
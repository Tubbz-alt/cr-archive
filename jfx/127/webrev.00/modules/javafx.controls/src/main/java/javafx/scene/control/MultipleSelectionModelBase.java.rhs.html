<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/MultipleSelectionModelBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javafx.scene.control;
 27 
 28 import com.sun.javafx.collections.NonIterableChange;
 29 import static javafx.scene.control.SelectionMode.SINGLE;
 30 
 31 import java.util.*;
 32 import java.util.stream.Collectors;
 33 import java.util.stream.IntStream;
 34 
 35 import com.sun.javafx.scene.control.MultipleAdditionAndRemovedChange;
 36 import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
 37 import com.sun.javafx.scene.control.SelectedItemsReadOnlyObservableList;
 38 import javafx.collections.ListChangeListener;
 39 import javafx.collections.ObservableList;
 40 import javafx.collections.ObservableListBase;
 41 import javafx.util.Callback;
 42 
 43 import javafx.util.Pair;
 44 
 45 
 46 /**
 47  * An abstract class that implements more of the abstract MultipleSelectionModel
 48  * abstract class. However, this class is package-protected and not intended
 49  * for public use.
 50  *
 51  * @param &lt;T&gt; The type of the underlying data model for the UI control.
 52  */
 53 abstract class MultipleSelectionModelBase&lt;T&gt; extends MultipleSelectionModel&lt;T&gt; {
 54 
 55     /***********************************************************************
 56      *                                                                     *
 57      * Constructors                                                        *
 58      *                                                                     *
 59      **********************************************************************/
 60 
 61     public MultipleSelectionModelBase() {
 62         selectedIndexProperty().addListener(valueModel -&gt; {
 63             // we used to lazily retrieve the selected item, but now we just
 64             // do it when the selection changes. This is hardly likely to be
 65             // expensive, and we still lazily handle the multiple selection
 66             // cases over in MultipleSelectionModel.
 67             setSelectedItem(getModelItem(getSelectedIndex()));
 68         });
 69 
 70         selectedIndices = new SelectedIndicesList();
 71 
 72         selectedItems = new SelectedItemsReadOnlyObservableList&lt;T&gt;(selectedIndices, () -&gt; getItemCount()) {
 73             @Override protected T getModelItem(int index) {
 74                 return MultipleSelectionModelBase.this.getModelItem(index);
 75             }
 76         };
 77     }
 78 
 79 
 80 
 81     /***********************************************************************
 82      *                                                                     *
 83      * Observable properties                                               *
 84      *                                                                     *
 85      **********************************************************************/
 86 
 87     /*
 88      * We only maintain the values of the selectedIndex and selectedIndices
 89      * properties. The value of the selectedItem and selectedItems properties
 90      * is determined on-demand. We fire the SELECTED_ITEM and SELECTED_ITEMS
 91      * property change events whenever the related SELECTED_INDEX or
 92      * SELECTED_INDICES properties change.
 93      *
 94      * This means that the cost of the ListViewSelectionModel is cheap in most
 95      * cases, assuming that the end-consumer isn&#39;t calling getSelectedItems
 96      * too aggressively. Of course, this is only an issue when the ListViewModel
 97      * is being populated by some remote, expensive to query data source.
 98      *
 99      * In addition, we do not provide ObservableLists for the selected indices or the
100      * selected items properties, as this would allow the API consumer to add
101      * observers to these ObservableLists. This would make life tougher as we would
102      * then be forced to keep these ObservableLists in-sync at all times, which for
103      * the selectedItems ObservableList, would require potentially a lot of work and
104      * memory. Instead, we return a List, and allow for changes to these Lists
105      * to be observed through the SELECTED_INDICES and SELECTED_ITEMS
106      * properties.
107      */
108 
109 
110     final SelectedIndicesList selectedIndices;
111     @Override public ObservableList&lt;Integer&gt; getSelectedIndices() {
112         return selectedIndices;
113     }
114 
115     private final ObservableListBase&lt;T&gt; selectedItems;
116     @Override public ObservableList&lt;T&gt; getSelectedItems() {
117         return selectedItems;
118     }
119 
120 
121 
122     /***********************************************************************
123      *                                                                     *
124      * Internal field                                                      *
125      *                                                                     *
126      **********************************************************************/
127 
128     ListChangeListener.Change selectedItemChange;
129 
130 
131 
132     /***********************************************************************
133      *                                                                     *
134      * Public selection API                                                *
135      *                                                                     *
136      **********************************************************************/
137 
138     /**
139      * Returns the number of items in the data model that underpins the control.
140      * An example would be that a ListView selection model would likely return
141      * &lt;code&gt;listView.getItems().size()&lt;/code&gt;. The valid range of selectable
142      * indices is between 0 and whatever is returned by this method.
143      * @return the number of items in the data model that underpins the control
144      */
145     protected abstract int getItemCount();
146 
147     /**
148      * Returns the item at the given index. An example using ListView would be
149      * &lt;code&gt;listView.getItems().get(index)&lt;/code&gt;.
150      *
151      * @param index The index of the item that is requested from the underlying
152      *      data model.
153      * @return Returns null if the index is out of bounds, or an element of type
154      *      T that is related to the given index.
155      */
156     protected abstract T getModelItem(int index);
157     protected abstract void focus(int index);
158     protected abstract int getFocusedIndex();
159 
160     static class ShiftParams {
161         private final int clearIndex;
162         private final int setIndex;
163         private final boolean selected;
164 
165         ShiftParams(int clearIndex, int setIndex, boolean selected) {
166             this.clearIndex = clearIndex;
167             this.setIndex = setIndex;
168             this.selected = selected;
169         }
170 
171         public final int getClearIndex() {
172             return clearIndex;
173         }
174 
175         public final int getSetIndex() {
176             return setIndex;
177         }
178 
179         public final boolean isSelected() {
180             return selected;
181         }
182     }
183 
184     // package only
185     void shiftSelection(int position, int shift, final Callback&lt;ShiftParams, Void&gt; callback) {
186         shiftSelection(Arrays.asList(new Pair&lt;&gt;(position, shift)), callback);
187     }
188 
189     void shiftSelection(List&lt;Pair&lt;Integer, Integer&gt;&gt; shifts, final Callback&lt;ShiftParams, Void&gt; callback) {
190         int selectedIndicesCardinality = selectedIndices.size(); // number of true bits
191         if (selectedIndicesCardinality == 0) return;
192 
193         int selectedIndicesSize = selectedIndices.bitsetSize();   // number of bits reserved
194 
195         int[] perm = new int[selectedIndicesSize];
196         Arrays.fill(perm, -1);
197 
198         // sort the list so that we iterate from highest position to lowest position
199         Collections.sort(shifts, (s1, s2) -&gt; Integer.compare(s2.getKey(), s1.getKey()));
200         final int lowestShiftPosition = shifts.get(shifts.size() - 1).getKey();
201 
202         // make a copy of the selectedIndices before so we can compare to it afterwards
203         BitSet selectedIndicesCopy = (BitSet) selectedIndices.bitset.clone();
204 
205         startAtomic();
206         for (Pair&lt;Integer, Integer&gt; shift : shifts) {
207             doShift(shift, callback, perm);
208         }
209         stopAtomic();
210 
211         // strip out all useless -1 default values from the perm array
212         final int[] prunedPerm = Arrays.stream(perm).filter(value -&gt; value &gt; -1).toArray();
213         final boolean hasSelectionChanged = prunedPerm.length &gt; 0;
214 
215         // This ensure that the selection remains accurate when a shift occurs.
216         final int selectedIndex = getSelectedIndex();
217         if (selectedIndex &gt;= lowestShiftPosition &amp;&amp; selectedIndex &gt; -1) {
218             // sum up the total shift, where the position is less than or equal
219             // to the previously selected index
220             int totalShift = shifts.stream()
221                     .filter(shift -&gt; shift.getKey() &lt;= selectedIndex)
222                     .mapToInt(shift -&gt; shift.getValue())
223                     .sum();
224 
225             // Fix for RT-38787: we used to not enter this block if
226             // selectedIndex + shift resulted in a value less than zero, whereas
227             // now we just set the newSelectionLead to zero in that instance.
228             // There exists unit tests that cover this.
229             final int newSelectionLead = Math.max(0, selectedIndex + totalShift);
230 
231             setSelectedIndex(newSelectionLead);
232 
233             // added the selectedIndices call for RT-30356.
234             // changed to check if hasPermutated, and to call select(..) for RT-40010.
235             // This forces the selection event to go through the system and fire
236             // the necessary events.
237             if (hasSelectionChanged) {
238                 selectedIndices.set(newSelectionLead, true);
239             } else {
240                 select(newSelectionLead);
241             }
242 
243             // removed due to RT-27185
244 //            focus(newSelectionLead);
245         }
246 
247         if (hasSelectionChanged) {
248             // work out what indices were removed and added
249             BitSet removed = (BitSet) selectedIndicesCopy.clone();
250             removed.andNot(selectedIndices.bitset);
251 
252             BitSet added = (BitSet) selectedIndices.bitset.clone();
253             added.andNot(selectedIndicesCopy);
254 
255             selectedIndices.reset();
256             selectedIndices.callObservers(new MultipleAdditionAndRemovedChange&lt;&gt;(
257                     added.stream().boxed().collect(Collectors.toList()),
258                     removed.stream().boxed().collect(Collectors.toList()),
259                     selectedIndices
260             ));
261         }
262     }
263 
264     private void doShift(Pair&lt;Integer, Integer&gt; shiftPair, final Callback&lt;ShiftParams, Void&gt; callback, int[] perm) {
265         final int position = shiftPair.getKey();
266         final int shift = shiftPair.getValue();
267 
268         // with no check here, we get RT-15024
269         if (position &lt; 0) return;
270         if (shift == 0) return;
271 
272         int idx = (int) Arrays.stream(perm).filter(value -&gt; value &gt; -1).count();
273 
274         int selectedIndicesSize = selectedIndices.bitsetSize() - idx;   // number of bits reserved
275 
276         if (shift &gt; 0) {
277             for (int i = selectedIndicesSize - 1; i &gt;= position &amp;&amp; i &gt;= 0; i--) {
278                 boolean selected = selectedIndices.isSelected(i);
279 
280                 if (callback == null) {
281                     selectedIndices.clear(i);
282                     selectedIndices.set(i + shift, selected);
283                 } else {
284                     callback.call(new ShiftParams(i, i + shift, selected));
285                 }
286 
287                 if (selected) {
288                     perm[idx++] = i + 1;
289                 }
290             }
291             selectedIndices.clear(position);
292         } else if (shift &lt; 0) {
293             for (int i = position; i &lt; selectedIndicesSize; i++) {
294                 if ((i + shift) &lt; 0) continue;
295                 if ((i + 1 + shift) &lt; position) continue;
296                 boolean selected = selectedIndices.isSelected(i + 1);
297 
298                 if (callback == null) {
299                     selectedIndices.clear(i + 1);
300                     selectedIndices.set(i + 1 + shift, selected);
301                 } else {
302                     callback.call(new ShiftParams(i + 1, i + 1 + shift, selected));
303                 }
304 
305                 if (selected) {
306                     perm[idx++] = i;
307                 }
308             }
309         }
310     }
311 
312     void startAtomic() {
313         selectedIndices.startAtomic();
314     }
315 
316     void stopAtomic() {
317         selectedIndices.stopAtomic();
318     }
319 
320     boolean isAtomic() {
321         return selectedIndices.isAtomic();
322     }
323 
324     @Override public void clearAndSelect(int row) {
325         if (row &lt; 0 || row &gt;= getItemCount()) {
326             clearSelection();
327             return;
328         }
329 
330         final boolean wasSelected = isSelected(row);
331 
332         // RT-33558 if this method has been called with a given row, and that
333         // row is the only selected row currently, then this method becomes a no-op.
334         if (wasSelected &amp;&amp; getSelectedIndices().size() == 1) {
335             // before we return, we double-check that the selected item
336             // is equal to the item in the given index
337             if (getSelectedItem() == getModelItem(row)) {
338                 return;
339             }
340         }
341 
342         // firstly we make a copy of the selection, so that we can send out
343         // the correct details in the selection change event.
344         // We remove the new selection from the list seeing as it is not removed.
345         BitSet selectedIndicesCopy = new BitSet();
346         selectedIndicesCopy.or(selectedIndices.bitset);
347         selectedIndicesCopy.clear(row);
348         List&lt;Integer&gt; previousSelectedIndices = new SelectedIndicesList(selectedIndicesCopy);
349 
350         // RT-32411 We used to call quietClearSelection() here, but this
351         // resulted in the selectedItems and selectedIndices lists never
352         // reporting that they were empty.
353         // makeAtomic toggle added to resolve RT-32618
354         startAtomic();
355 
356         // then clear the current selection
357         clearSelection();
358 
359         // and select the new row
360         select(row);
361         stopAtomic();
362 
363         // fire off a single add/remove/replace notification (rather than
364         // individual remove and add notifications) - see RT-33324
365         ListChangeListener.Change&lt;Integer&gt; change;
366 
367         /*
368          * getFrom() documentation:
369          *   If wasAdded is true, the interval contains all the values that were added.
370          *   If wasPermutated is true, the interval marks the values that were permutated.
371          *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
372          *   return the same number - the place where the removed elements were positioned in the list.
373          */
374         if (wasSelected) {
375             change = ControlUtils.buildClearAndSelectChange(selectedIndices, previousSelectedIndices, row);
376         } else {
377             int changeIndex = Math.max(0, selectedIndices.indexOf(row));
378             change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
379                     changeIndex, changeIndex+1, previousSelectedIndices, selectedIndices);
380         }
381 
382         selectedIndices.callObservers(change);
383     }
384 
385     @Override public void select(int row) {
386         if (row == -1) {
387             clearSelection();
388             return;
389         }
390         if (row &lt; 0 || row &gt;= getItemCount()) {
391             return;
392         }
393 
394         boolean isSameRow = row == getSelectedIndex();
395         T currentItem = getSelectedItem();
396         T newItem = getModelItem(row);
397         boolean isSameItem = newItem != null &amp;&amp; newItem.equals(currentItem);
398         boolean fireUpdatedItemEvent = isSameRow &amp;&amp; ! isSameItem;
399 
400         // focus must come first so that we have the anchors set appropriately
401         focus(row);
402 
403         if (! selectedIndices.isSelected(row)) {
404             if (getSelectionMode() == SINGLE) {
405                 startAtomic();
406                 quietClearSelection();
407                 stopAtomic();
408             }
409             selectedIndices.set(row);
410         }
411 
412         setSelectedIndex(row);
413 
414         if (fireUpdatedItemEvent) {
415             setSelectedItem(newItem);
416         }
417     }
418 
419     @Override public void select(T obj) {
420 //        if (getItemCount() &lt;= 0) return;
421 
422         if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
423             clearSelection();
424             return;
425         }
426 
427         // We have no option but to iterate through the model and select the
428         // first occurrence of the given object. Once we find the first one, we
429         // don&#39;t proceed to select any others.
430         Object rowObj = null;
431         for (int i = 0, max = getItemCount(); i &lt; max; i++) {
432             rowObj = getModelItem(i);
433             if (rowObj == null) continue;
434 
435             if (rowObj.equals(obj)) {
436                 if (isSelected(i)) {
437                     return;
438                 }
439 
440                 if (getSelectionMode() == SINGLE) {
441                     quietClearSelection();
442                 }
443 
444                 select(i);
445                 return;
446             }
447         }
448 
449         // if we are here, we did not find the item in the entire data model.
450         // Even still, we allow for this item to be set to the give object.
451         // We expect that in concrete subclasses of this class we observe the
452         // data model such that we check to see if the given item exists in it,
453         // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
454         setSelectedIndex(-1);
455         setSelectedItem(obj);
456     }
457 
458     @Override public void selectIndices(int row, int... rows) {
459         if (rows == null || rows.length == 0) {
460             select(row);
461             return;
462         }
463 
464         /*
465          * Performance optimisation - if multiple selection is disabled, only
466          * process the end-most row index.
467          */
468 
469         int rowCount = getItemCount();
470 
471         if (getSelectionMode() == SINGLE) {
472             quietClearSelection();
473 
474             for (int i = rows.length - 1; i &gt;= 0; i--) {
475                 int index = rows[i];
476                 if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
477                     selectedIndices.set(index);
478                     select(index);
479                     break;
480                 }
481             }
482 
483             if (selectedIndices.isEmpty()) {
484                 if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
485                     selectedIndices.set(row);
486                     select(row);
487                 }
488             }
489         } else {
490             selectedIndices.set(row, rows);
491 
492             IntStream.concat(IntStream.of(row), IntStream.of(rows))
493                      .filter(index -&gt; index &gt;= 0 &amp;&amp; index &lt; rowCount)
494                      .reduce((first, second) -&gt; second)
495                      .ifPresent(lastIndex -&gt; {
496                          setSelectedIndex(lastIndex);
497                          focus(lastIndex);
498                          setSelectedItem(getModelItem(lastIndex));
499                      });
500         }
501     }
502 
503     @Override public void selectAll() {
504         if (getSelectionMode() == SINGLE) return;
505 
506         if (getItemCount() &lt;= 0) return;
507 
508         final int rowCount = getItemCount();
509         final int focusedIndex = getFocusedIndex();
510 
511         // set all selected indices to true
512         clearSelection();
513         selectedIndices.set(0, rowCount, true);
514 
515         if (focusedIndex == -1) {
516             setSelectedIndex(rowCount - 1);
517             focus(rowCount - 1);
518         } else {
519             setSelectedIndex(focusedIndex);
520             focus(focusedIndex);
521         }
522     }
523 
524     @Override public void selectFirst() {
525         if (getSelectionMode() == SINGLE) {
526             quietClearSelection();
527         }
528 
529         if (getItemCount() &gt; 0) {
530             select(0);
531         }
532     }
533 
534     @Override public void selectLast() {
535         if (getSelectionMode() == SINGLE) {
536             quietClearSelection();
537         }
538 
539         int numItems = getItemCount();
540         if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
541             select(numItems - 1);
542         }
543     }
544 
545     @Override public void clearSelection(int index) {
546         if (index &lt; 0) return;
547 
548         // TODO shouldn&#39;t directly access like this
549         // TODO might need to update focus and / or selected index/item
550         boolean wasEmpty = selectedIndices.isEmpty();
551         selectedIndices.clear(index);
552 
553         if (! wasEmpty &amp;&amp; selectedIndices.isEmpty()) {
554             clearSelection();
555         }
556     }
557 
558     @Override public void clearSelection() {
559         quietClearSelection();
560 
561         if (! isAtomic()) {
562             setSelectedIndex(-1);
563             focus(-1);
564         }
565     }
566 
567     private void quietClearSelection() {
568         selectedIndices.clear();
569     }
570 
571     @Override public boolean isSelected(int index) {
572         // Note the change in semantics here - we used to check to ensure that
573         // the index is less than the item count, but now simply ensure that
574         // it is less than the length of the selectedIndices bitset. This helps
575         // to resolve issues such as RT-26721, where isSelected(int) was being
576         // called for indices that exceeded the item count, as a TreeItem (e.g.
577         // the root) was being collapsed.
578 //        if (index &gt;= 0 &amp;&amp; index &lt; getItemCount()) {
579         if (index &gt;= 0 &amp;&amp; index &lt; selectedIndices.bitsetSize()) {
580             return selectedIndices.isSelected(index);
581         }
582 
583         return false;
584     }
585 
586     @Override public boolean isEmpty() {
587         return selectedIndices.isEmpty();
588     }
589 
590     @Override public void selectPrevious() {
591         int focusIndex = getFocusedIndex();
592 
593         if (getSelectionMode() == SINGLE) {
594             quietClearSelection();
595         }
596 
597         if (focusIndex == -1) {
598             select(getItemCount() - 1);
599         } else if (focusIndex &gt; 0) {
600             select(focusIndex - 1);
601         }
602     }
603 
604     @Override public void selectNext() {
605         int focusIndex = getFocusedIndex();
606 
607         if (getSelectionMode() == SINGLE) {
608             quietClearSelection();
609         }
610 
611         if (focusIndex == -1) {
612             select(0);
613         } else if (focusIndex != getItemCount() -1) {
614             select(focusIndex + 1);
615         }
616     }
617 
618 
619 
620     /***********************************************************************
621      *                                                                     *
622      * Private implementation                                              *
623      *                                                                     *
624      **********************************************************************/
625 
626     class SelectedIndicesList extends ReadOnlyUnbackedObservableList&lt;Integer&gt; {
627         private final BitSet bitset;
628 
<a name="1" id="anc1"></a><span class="line-added">629         private int size = -1;</span>
630         private int lastGetIndex = -1;
631         private int lastGetValue = -1;
632 
633         // Fix for RT-20945 (and numerous other issues!)
634         private int atomicityCount = 0;
635 
636 //        @Override
637 //        public void callObservers(Change&lt;Integer&gt; c) {
638 //            throw new RuntimeException(&quot;callObservers unavailable&quot;);
639 //        }
640 
641         public SelectedIndicesList() {
642             this(new BitSet());
643         }
644 
645         public SelectedIndicesList(BitSet bitset) {
646             this.bitset = bitset;
647         }
648 
649         boolean isAtomic() {
650             return atomicityCount &gt; 0;
651         }
652         void startAtomic() {
653             atomicityCount++;
654         }
655         void stopAtomic() {
656             atomicityCount = Math.max(0, atomicityCount - 1);
657         }
658 
659         // Returns the selected index at the given index.
660         // e.g. if our selectedIndices are [1,3,5], then an index of 2 will return 5 here.
661         @Override public Integer get(int index) {
662             final int itemCount = size();
663             if (index &lt; 0 || index &gt;= itemCount)  {
664                 throw new IndexOutOfBoundsException(index + &quot; &gt;= &quot; + itemCount);
665             }
666 
667             if (index == (lastGetIndex + 1) &amp;&amp; lastGetValue &lt; itemCount) {
668                 // we&#39;re iterating forward in order, short circuit for
669                 // performance reasons (RT-39776)
670                 lastGetIndex++;
671                 lastGetValue = bitset.nextSetBit(lastGetValue + 1);
672                 return lastGetValue;
673             } else if (index == (lastGetIndex - 1) &amp;&amp; lastGetValue &gt; 0) {
674                 // we&#39;re iterating backward in order, short circuit for
675                 // performance reasons (RT-39776)
676                 lastGetIndex--;
677                 lastGetValue = bitset.previousSetBit(lastGetValue - 1);
678                 return lastGetValue;
679             } else {
680                 for (lastGetIndex = 0, lastGetValue = bitset.nextSetBit(0);
681                      lastGetValue &gt;= 0 || lastGetIndex == index;
682                      lastGetIndex++, lastGetValue = bitset.nextSetBit(lastGetValue + 1)) {
683                     if (lastGetIndex == index) {
684                         return lastGetValue;
685                     }
686                 }
687             }
688 
689             return -1;
690         }
691 
692         public void set(int index) {
693             if (!isValidIndex(index) || isSelected(index)) {
694                 return;
695             }
696 
697             _beginChange();
<a name="2" id="anc2"></a><span class="line-added">698             size = -1;</span>
699             bitset.set(index);
700             int indicesIndex = indexOf(index);
701             _nextAdd(indicesIndex, indicesIndex + 1);
702             _endChange();
703         }
704 
705         private boolean isValidIndex(int index) {
706             return index &gt;= 0 &amp;&amp; index &lt; getItemCount();
707         }
708 
709         public void set(int index, boolean isSet) {
710             if (isSet) {
711                 set(index);
712             } else {
713                 clear(index);
714             }
715         }
716 
717         public void set(int index, int end, boolean isSet) {
718             _beginChange();
<a name="3" id="anc3"></a><span class="line-added">719             size = -1;</span>
720             if (isSet) {
721                 bitset.set(index, end, isSet);
722                 int indicesIndex = indexOf(index);
723                 int span = end - index;
724                 _nextAdd(indicesIndex, indicesIndex + span);
725             } else {
726                 // TODO handle remove
727                 bitset.set(index, end, isSet);
728             }
729             _endChange();
730         }
731 
732         public void set(int index, int... indices) {
733             if (indices == null || indices.length == 0) {
734                 set(index);
735             } else {
736                 // we reduce down to the minimal number of changes possible
737                 // by finding all contiguous indices, of all indices that are
738                 // not already selected, and which are in the valid range
739                 startAtomic();
740                 List&lt;Integer&gt; sortedNewIndices =
741                         IntStream.concat(IntStream.of(index), IntStream.of(indices))
742                         .distinct()
743                         .filter(this::isValidIndex)
744                         .filter(this::isNotSelected)
745                         .sorted()
746                         .boxed()
747                         .peek(this::set) // we also set here, but it&#39;s atomic!
748                         .collect(Collectors.toList());
749                 stopAtomic();
750 
751                 final int size = sortedNewIndices.size();
752                 if (size == 0) {
753                     // no-op
754                 } else if (size == 1) {
755                     _beginChange();
756                     int _index = sortedNewIndices.get(0);
757                     int indicesIndex = indexOf(_index);
758                     _nextAdd(indicesIndex, indicesIndex + 1);
759                     _endChange();
760                 } else {
761                     _beginChange();
762                     int pos = 0;
763                     int start = 0;
764                     int end = 0;
765 
766                     // starting from pos, we keep going until the value is
767                     // not the next value
768                     int startValue = sortedNewIndices.get(pos++);
769                     start = indexOf(startValue);
770                     end = start + 1;
771                     int endValue = startValue;
772                     while (pos &lt; size) {
773                         int previousEndValue = endValue;
774                         endValue = sortedNewIndices.get(pos++);
775                         ++end;
776                         if (previousEndValue != (endValue - 1)) {
777                             _nextAdd(start, end);
778                             start = end;
779                             continue;
780                         }
781 
782                         // special case for when we get to the point where the loop is about to end
783                         // and we have uncommitted changes to fire.
784                         if (pos == size) {
785                             _nextAdd(start, start + pos);
786                         }
787                     }
788 
789                     _endChange();
790                 }
791             }
792         }
793 
794         public void clear() {
795             _beginChange();
796             List&lt;Integer&gt; removed = bitset.stream().boxed().collect(Collectors.toList());
<a name="4" id="anc4"></a><span class="line-added">797             size = 0;</span>
798             bitset.clear();
799             _nextRemove(0, removed);
800             _endChange();
801         }
802 
803         public void clear(int index) {
804             if (!bitset.get(index)) return;
805 
806             _beginChange();
<a name="5" id="anc5"></a><span class="line-added">807             size = -1;</span>
808             bitset.clear(index);
809             _nextRemove(index, index);
810             _endChange();
811         }
812 
813 //        public void clearAndSelect(int index) {
814 //            if (index &lt; 0 || index &gt;= getItemCount()) {
815 //                clearSelection();
816 //                return;
817 //            }
818 //
819 //            final boolean wasSelected = isSelected(index);
820 //
821 //            // RT-33558 if this method has been called with a given row, and that
822 //            // row is the only selected row currently, then this method becomes a no-op.
823 //            if (wasSelected &amp;&amp; getSelectedIndices().size() == 1) {
824 //                // before we return, we double-check that the selected item
825 //                // is equal to the item in the given index
826 //                if (getSelectedItem() == getModelItem(index)) {
827 //                    return;
828 //                }
829 //            }
830 //
831 //            List&lt;Integer&gt; removed = bitset.stream().boxed().collect(Collectors.toList());
832 //            boolean isSelected = removed.contains(index);
833 //            if (isSelected) {
834 //                removed.remove((Object)index);
835 //            }
836 //
837 //            if (removed.isEmpty()) {
838 //                set(index);
839 //            }
840 //
841 //            bitset.clear();
842 //            bitset.set(index);
843 //            _beginChange();
844 //            if (isSelected) {
845 //                _nextRemove(0, removed);
846 //            } else {
847 //                _nextAdd(0, 1);
848 //                _nextRemove(0, removed);
849 //            }
850 //            _endChange();
851 //        }
852 
853         public boolean isSelected(int index) {
854             return bitset.get(index);
855         }
856 
857         public boolean isNotSelected(int index) {
858             return !isSelected(index);
859         }
860 
861         /** Returns number of true bits in BitSet */
862         @Override public int size() {
<a name="6" id="anc6"></a><span class="line-modified">863             if(size&gt;=0){</span>
<span class="line-added">864                 return size;</span>
<span class="line-added">865             }</span>
<span class="line-added">866             size = bitset.cardinality();</span>
<span class="line-added">867             return size;</span>
868         }
869 
870         /** Returns the number of bits reserved in the BitSet */
871         public int bitsetSize() {
872             return bitset.size();
873         }
874 
875         @Override public int indexOf(Object obj) {
<a name="7" id="anc7"></a><span class="line-modified">876             if (!(obj instanceof Number)) {</span>
<span class="line-modified">877                 return -1;</span>
<span class="line-added">878             }</span>
<span class="line-added">879             Number n = (Number) obj;</span>
<span class="line-added">880             int index = n.intValue();</span>
<span class="line-added">881             if(!bitset.get(index)) {</span>
<span class="line-added">882                 return -1;</span>
<span class="line-added">883             }</span>
<span class="line-added">884             // is left most bit</span>
<span class="line-added">885             if(index==0) {</span>
<span class="line-added">886                 return 0;</span>
<span class="line-added">887             }</span>
<span class="line-added">888 </span>
<span class="line-added">889             // is right most bit</span>
<span class="line-added">890             if( index == bitset.length()-1 ){</span>
<span class="line-added">891                 return size()-1;</span>
<span class="line-added">892             }</span>
<span class="line-added">893 </span>
<span class="line-added">894             // count right bit</span>
<span class="line-added">895             if( index &gt; bitset.length()/2 ) {</span>
<span class="line-added">896                 int count = 1;</span>
<span class="line-added">897                 for (;;) {</span>
<span class="line-added">898                     index = bitset.nextSetBit(index + 1);</span>
<span class="line-added">899                     if (index &lt; 0) {</span>
<span class="line-added">900                         break;</span>
<span class="line-added">901                     }</span>
<span class="line-added">902                     count++;</span>
<span class="line-added">903                 }</span>
<span class="line-added">904                 return size() - count;</span>
<span class="line-added">905             }</span>
<span class="line-added">906 </span>
<span class="line-added">907             // count left bit</span>
<span class="line-added">908             // return (int)bitset.stream().takeWhile(i-&gt;i&lt;index).count();</span>
<span class="line-added">909             int count = 0;</span>
<span class="line-added">910             for(;;){</span>
<span class="line-added">911                 index = bitset.previousSetBit(index-1);</span>
<span class="line-added">912                 if(index&lt;0){</span>
<span class="line-added">913                     break;</span>
<span class="line-added">914                 }</span>
<span class="line-added">915                 count++;</span>
<span class="line-added">916             }</span>
<span class="line-added">917             return count;</span>
918         }
919 
920         @Override public boolean contains(Object o) {
921             if (o instanceof Number) {
922                 Number n = (Number) o;
923                 int index = n.intValue();
924 
925                 return index &gt;= 0 &amp;&amp; index &lt; bitset.length() &amp;&amp;
926                         bitset.get(index);
927             }
928 
929             return false;
930         }
931 
932         public void reset() {
933             this.lastGetIndex = -1;
934             this.lastGetValue = -1;
935         }
936 
937         @Override public void _beginChange() {
938             if (!isAtomic()) {
939                 super._beginChange();
940             }
941         }
942 
943         @Override public void _endChange() {
944             if (!isAtomic()) {
945                 super._endChange();
946             }
947         }
948 
949         @Override public final void _nextUpdate(int pos) {
950             if (!isAtomic()) {
951                 nextUpdate(pos);
952             }
953         }
954 
955         @Override public final void _nextSet(int idx, Integer old) {
956             if (!isAtomic()) {
957                 nextSet(idx, old);
958             }
959         }
960 
961         @Override public final void _nextReplace(int from, int to, List&lt;? extends Integer&gt; removed) {
962             if (!isAtomic()) {
963                 nextReplace(from, to, removed);
964             }
965         }
966 
967         @Override public final void _nextRemove(int idx, List&lt;? extends Integer&gt; removed) {
968             if (!isAtomic()) {
969                 nextRemove(idx, removed);
970             }
971         }
972 
973         @Override public final void _nextRemove(int idx, Integer removed) {
974             if (!isAtomic()) {
975                 nextRemove(idx, removed);
976             }
977         }
978 
979         @Override public final void _nextPermutation(int from, int to, int[] perm) {
980             if (!isAtomic()) {
981                 nextPermutation(from, to, perm);
982             }
983         }
984 
985         @Override public final void _nextAdd(int from, int to) {
986             if (!isAtomic()) {
987                 nextAdd(from, to);
988             }
989         }
990     }
991 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
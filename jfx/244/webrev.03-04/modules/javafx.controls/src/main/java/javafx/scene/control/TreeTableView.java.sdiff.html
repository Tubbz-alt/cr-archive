<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1793         return getVisibleLeafColumns().indexOf(column);
1794     }
1795 
1796     /**
1797      * Returns the TreeTableColumn in the given column index, relative to all other
1798      * visible leaf columns.
1799      * @param column the column
1800      * @return the TreeTableColumn in the given column index, relative to all other
1801      * visible leaf columns
1802      */
1803     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1804         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1805         return visibleLeafColumns.get(column);
1806     }
1807 
1808     private boolean sortingInProgress;
1809     boolean isSortingInProgress() {
1810         return sortingInProgress;
1811     }
1812 
<span class="line-removed">1813     private boolean sortTreeOfSelectedItems = true;</span>
<span class="line-removed">1814     boolean isSortTreeOfSelectedItems() {</span>
<span class="line-removed">1815         return sortTreeOfSelectedItems;</span>
<span class="line-removed">1816     }</span>
<span class="line-removed">1817 </span>
1818     /**
1819      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1820      * often than not it is not necessary to call this method directly, as it is
1821      * automatically called when the {@link #getSortOrder() sort order},
1822      * {@link #sortPolicyProperty() sort policy}, or the state of the
1823      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1824      * change. In other words, this method should only be called directly when
1825      * something external changes and a sort is required.
1826      */
1827     public void sort() {
1828         sortingInProgress = true;
1829         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1830 
1831         // update the Comparator property
1832         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1833         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1834 
1835         // fire the onSort event and check if it is consumed, if
1836         // so, don&#39;t run the sort
1837         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
</pre>
<hr />
<pre>
1844             // sortLock = true;
1845             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1846             // sortLock = false;
1847             sortingInProgress = false;
1848             return;
1849         }
1850 
1851         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1852         final int itemCount = prevState.size();
1853 
1854         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1855         // sort events - instead we send a single permutation event at the end
1856         // of this method.
1857         getSelectionModel().startAtomic();
1858 
1859         // get the sort policy and run it
1860         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
1861         if (sortPolicy == null) return;
1862         Boolean success = sortPolicy.call(this);
1863 
<span class="line-modified">1864         if (getSortMode() == TreeSortMode.ALL_DESCENDANTS &amp;&amp; isSortTreeOfSelectedItems()) {</span>
1865             Set&lt;TreeItem&lt;S&gt;&gt; sortedParents = new HashSet&lt;&gt;();
1866             for (TreeTablePosition&lt;S,?&gt; selectedPosition : prevState) {
1867                 TreeItem&lt;S&gt; parent = selectedPosition.getTreeItem().getParent();
1868                 while (parent != null &amp;&amp; sortedParents.add(parent)) {
1869                     parent.getChildren();
1870                     parent = parent.getParent();
1871                 }
1872             }
1873         }
1874         getSelectionModel().stopAtomic();
1875 
1876         if (success == null || ! success) {
1877             // the sort was a failure. Need to backout if possible
1878             sortLock = true;
1879             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1880             setComparator(oldComparator);
1881             sortLock = false;
1882         } else {
1883             // sorting was a success, now we possibly fire an event on the
1884             // selection model that the items list has &#39;permutated&#39; to a new ordering
</pre>
</td>
<td>
<hr />
<pre>
1793         return getVisibleLeafColumns().indexOf(column);
1794     }
1795 
1796     /**
1797      * Returns the TreeTableColumn in the given column index, relative to all other
1798      * visible leaf columns.
1799      * @param column the column
1800      * @return the TreeTableColumn in the given column index, relative to all other
1801      * visible leaf columns
1802      */
1803     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1804         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1805         return visibleLeafColumns.get(column);
1806     }
1807 
1808     private boolean sortingInProgress;
1809     boolean isSortingInProgress() {
1810         return sortingInProgress;
1811     }
1812 





1813     /**
1814      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1815      * often than not it is not necessary to call this method directly, as it is
1816      * automatically called when the {@link #getSortOrder() sort order},
1817      * {@link #sortPolicyProperty() sort policy}, or the state of the
1818      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1819      * change. In other words, this method should only be called directly when
1820      * something external changes and a sort is required.
1821      */
1822     public void sort() {
1823         sortingInProgress = true;
1824         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1825 
1826         // update the Comparator property
1827         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1828         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1829 
1830         // fire the onSort event and check if it is consumed, if
1831         // so, don&#39;t run the sort
1832         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
</pre>
<hr />
<pre>
1839             // sortLock = true;
1840             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1841             // sortLock = false;
1842             sortingInProgress = false;
1843             return;
1844         }
1845 
1846         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1847         final int itemCount = prevState.size();
1848 
1849         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1850         // sort events - instead we send a single permutation event at the end
1851         // of this method.
1852         getSelectionModel().startAtomic();
1853 
1854         // get the sort policy and run it
1855         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
1856         if (sortPolicy == null) return;
1857         Boolean success = sortPolicy.call(this);
1858 
<span class="line-modified">1859         if (getSortMode() == TreeSortMode.ALL_DESCENDANTS) {</span>
1860             Set&lt;TreeItem&lt;S&gt;&gt; sortedParents = new HashSet&lt;&gt;();
1861             for (TreeTablePosition&lt;S,?&gt; selectedPosition : prevState) {
1862                 TreeItem&lt;S&gt; parent = selectedPosition.getTreeItem().getParent();
1863                 while (parent != null &amp;&amp; sortedParents.add(parent)) {
1864                     parent.getChildren();
1865                     parent = parent.getParent();
1866                 }
1867             }
1868         }
1869         getSelectionModel().stopAtomic();
1870 
1871         if (success == null || ! success) {
1872             // the sort was a failure. Need to backout if possible
1873             sortLock = true;
1874             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1875             setComparator(oldComparator);
1876             sortLock = false;
1877         } else {
1878             // sorting was a success, now we possibly fire an event on the
1879             // selection model that the items list has &#39;permutated&#39; to a new ordering
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
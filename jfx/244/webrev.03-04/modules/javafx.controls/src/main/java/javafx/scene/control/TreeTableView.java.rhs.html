<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import com.sun.javafx.collections.MappingChange;
  29 import com.sun.javafx.collections.NonIterableChange;
  30 import com.sun.javafx.scene.control.Properties;
  31 import com.sun.javafx.scene.control.SelectedCellsMap;
  32 
  33 import com.sun.javafx.scene.control.behavior.TableCellBehavior;
  34 import com.sun.javafx.scene.control.behavior.TableCellBehaviorBase;
  35 import com.sun.javafx.scene.control.behavior.TreeTableCellBehavior;
  36 
  37 import javafx.beans.property.DoubleProperty;
  38 import javafx.css.CssMetaData;
  39 import javafx.css.PseudoClass;
  40 
  41 import javafx.css.converter.SizeConverter;
  42 import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
  43 import com.sun.javafx.scene.control.TableColumnComparatorBase;
  44 
  45 import javafx.css.Styleable;
  46 import javafx.css.StyleableDoubleProperty;
  47 import javafx.css.StyleableProperty;
  48 import javafx.event.WeakEventHandler;
  49 
  50 import javafx.scene.control.skin.TreeTableViewSkin;
  51 
  52 import java.lang.ref.SoftReference;
  53 import java.lang.ref.WeakReference;
  54 import java.util.ArrayList;
  55 import java.util.Collection;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashMap;
  59 import java.util.HashSet;
  60 import java.util.LinkedHashSet;
  61 import java.util.List;
  62 import java.util.Map;
  63 import java.util.Set;
  64 import java.util.WeakHashMap;
  65 
  66 import javafx.application.Platform;
  67 import javafx.beans.DefaultProperty;
  68 import javafx.beans.InvalidationListener;
  69 import javafx.beans.WeakInvalidationListener;
  70 import javafx.beans.property.BooleanProperty;
  71 import javafx.beans.property.ObjectProperty;
  72 import javafx.beans.property.ObjectPropertyBase;
  73 import javafx.beans.property.ReadOnlyIntegerProperty;
  74 import javafx.beans.property.ReadOnlyIntegerWrapper;
  75 import javafx.beans.property.ReadOnlyObjectProperty;
  76 import javafx.beans.property.ReadOnlyObjectWrapper;
  77 import javafx.beans.property.SimpleBooleanProperty;
  78 import javafx.beans.property.SimpleObjectProperty;
  79 import javafx.beans.value.ChangeListener;
  80 import javafx.beans.value.WeakChangeListener;
  81 import javafx.beans.value.WritableValue;
  82 import javafx.collections.FXCollections;
  83 import javafx.collections.ListChangeListener;
  84 import javafx.collections.MapChangeListener;
  85 import javafx.collections.ObservableList;
  86 import javafx.collections.WeakListChangeListener;
  87 import javafx.event.Event;
  88 import javafx.event.EventHandler;
  89 import javafx.event.EventType;
  90 import javafx.scene.AccessibleAttribute;
  91 import javafx.scene.AccessibleRole;
  92 import javafx.scene.Node;
  93 import javafx.scene.layout.Region;
  94 import javafx.util.Callback;
  95 
  96 /**
  97  * The TreeTableView control is designed to visualize an unlimited number of rows
  98  * of data, broken out into columns. The TreeTableView control is conceptually
  99  * very similar to the {@link TreeView} and {@link TableView} controls,
 100  * and as you read on you&#39;ll come to see the APIs are largely the same.
 101  * However, to give a high-level overview, you&#39;ll note that the TreeTableView
 102  * uses the same {@link TreeItem} API as {@link TreeView},
 103  * and that you therefore are required to simply set the
 104  * {@link #rootProperty() root node} in the TreeTableView. Similarly, the
 105  * TreeTableView control makes use of the same TableColumn-based approach that
 106  * the {@link TableView} control uses, except instead of using the
 107  * TableView-specific {@link TableColumn} class, you should instead use the
 108  * TreeTableView-specific {@link TreeTableColumn} class instead. For an
 109  * example on how to create a TreeTableView instance, refer to the &#39;Creating a
 110  * TreeTableView&#39; control section below.
 111  *
 112  * &lt;p&gt;As with the {@link TableView} control, the TreeTableView control has a
 113  * number of features, including:
 114  * &lt;ul&gt;
 115  * &lt;li&gt;Powerful {@link TreeTableColumn} API:
 116  *   &lt;ul&gt;
 117  *   &lt;li&gt;Support for {@link TreeTableColumn#cellFactoryProperty() cell factories} to
 118  *      easily customize {@link Cell cell} contents in both rendering and editing
 119  *      states.
 120  *   &lt;li&gt;Specification of {@link TreeTableColumn#minWidthProperty() minWidth}/
 121  *      {@link TreeTableColumn#prefWidthProperty() prefWidth}/
 122  *      {@link TreeTableColumn#maxWidthProperty() maxWidth},
 123  *      and also {@link TreeTableColumn#resizableProperty() fixed width columns}.
 124  *   &lt;li&gt;Width resizing by the user at runtime.
 125  *   &lt;li&gt;Column reordering by the user at runtime.
 126  *   &lt;li&gt;Built-in support for {@link TreeTableColumn#getColumns() column nesting}
 127  *   &lt;/ul&gt;
 128  * &lt;li&gt;Different {@link #columnResizePolicyProperty() resizing policies} to
 129  *      dictate what happens when the user resizes columns.
 130  * &lt;li&gt;Support for {@link #getSortOrder() multiple column sorting} by clicking
 131  *      the column header (hold down Shift keyboard key whilst clicking on a
 132  *      header to sort by multiple columns).
 133  * &lt;/ul&gt;
 134  *
 135  * &lt;h2&gt;Creating a TreeTableView&lt;/h2&gt;
 136  *
 137  * &lt;p&gt;Creating a TreeTableView is a multi-step process, and also depends on the
 138  * underlying data model needing to be represented. For this example we&#39;ll use
 139  * the TreeTableView to visualise a file system, and will therefore make use
 140  * of an imaginary (and vastly simplified) File class as defined below:
 141  *
 142  * &lt;pre&gt; {@code public class File {
 143  *     private StringProperty name;
 144  *     public void setName(String value) { nameProperty().set(value); }
 145  *     public String getName() { return nameProperty().get(); }
 146  *     public StringProperty nameProperty() {
 147  *         if (name == null) name = new SimpleStringProperty(this, &quot;name&quot;);
 148  *         return name;
 149  *     }
 150  *
 151  *     private LongProperty lastModified;
 152  *     public void setLastModified(long value) { lastModifiedProperty().set(value); }
 153  *     public long getLastModified() { return lastModifiedProperty().get(); }
 154  *     public LongProperty lastModifiedProperty() {
 155  *         if (lastModified == null) lastModified = new SimpleLongProperty(this, &quot;lastModified&quot;);
 156  *         return lastModified;
 157  *     }
 158  *
 159  *     public File(String name, long size) {
 160  *         setName(name);
 161  *         setSize(size);
 162  *     }
 163  * }}&lt;/pre&gt;
 164  *
 165  * &lt;p&gt;The data we will use for this example is a single root with 3 files:
 166  *
 167  * &lt;pre&gt; {@code File rootFile = new File(&quot;Images&quot;, 900);
 168  * List&lt;File&gt; files = List.of(
 169  *     new File(&quot;Cat.png&quot;, 300),
 170  *     new File(&quot;Dog.png&quot;, 500),
 171  *     new File(&quot;Bird.png&quot;, 100));}&lt;/pre&gt;
 172  *
 173  * &lt;p&gt;Firstly, we need to create a data model. As mentioned, for this example,
 174  * we&#39;ll be representing a file system using File instances. To do this, we need
 175  * to define the root node of the tree table and its hierarchy:
 176  *
 177  * &lt;pre&gt; {@code TreeItem&lt;File&gt; root = new TreeItem&lt;&gt;(rootFile);
 178  * files.forEach(file -&gt; root.getChildren().add(new TreeItem&lt;&gt;(file)));}&lt;/pre&gt;
 179  *
 180  * &lt;p&gt; Then we create a TreeTableView instance:
 181  *
 182  * &lt;pre&gt; {@code TreeTableView&lt;File&gt; treeTable = new TreeTableView&lt;&gt;(root);}&lt;/pre&gt;
 183  *
 184  * &lt;p&gt;With the root set as such, the TreeTableView will automatically update whenever
 185  * the {@link TreeItem#getChildren() children} of the root change.
 186  *
 187  * &lt;p&gt;At this point we have a TreeTableView hooked up to observe the root
 188  * TreeItem instance. The missing ingredient
 189  * now is the means of splitting out the data contained within the model and
 190  * representing it in one or more {@link TreeTableColumn} instances. To
 191  * create a two-column TreeTableView to show the file name and size
 192  * properties, we write:
 193  *
 194  * &lt;pre&gt; {@code TreeTableColumns&lt;File, String&gt; fileNameCol = new TreeTableColumn&lt;&gt;(&quot;Filename&quot;);
 195  * TreeTableColumns&lt;File, Long&gt; sizeCol = new TreeTableColumn&lt;&gt;(&quot;Size&quot;);
 196  *
 197  * treeTable.getColumns().setAll(fileNameCol, sizeCol);}&lt;/pre&gt;
 198  *
 199  * &lt;p&gt;With the code shown above we have nearly fully defined the minimum properties
 200  * required to create a TreeTableView instance. The only thing missing is the
 201  * {@link javafx.scene.control.TreeTableColumn#cellValueFactoryProperty() cell value factories}
 202  * for the two columns - it is these that are responsible for determining the value
 203  * of a cell in a given row. Commonly these can be specified using the
 204  * {@link javafx.scene.control.cell.TreeItemPropertyValueFactory} class, but
 205  * failing that you can also create an anonymous inner class and do whatever is
 206  * necessary. For example, using {@link javafx.scene.control.cell.TreeItemPropertyValueFactory}
 207  * you would do the following:
 208  *
 209  * &lt;pre&gt; {@code fileNameCol.setCellValueFactory(new TreeItemPropertyValueFactory(rootFile.nameProperty().getName()));
 210  * sizeCol.setCellValueFactory(new TreeItemPropertyValueFactory(rootFile.sizeProperty().getName()));}&lt;/pre&gt;
 211  *
 212  * &lt;img src=&quot;doc-files/TreeTableView.png&quot; alt=&quot;Image of the TreeTableView control&quot;&gt;
 213  *
 214  * &lt;p&gt;Running this code will result in a TreeTableView as shown above with two columns
 215  * for name and size. Any other properties the File class might have will not be shown,
 216  * as no TreeTableColumns are defined for them.
 217  *
 218  * &lt;h3&gt;TreeTableView support for classes that don&#39;t contain properties&lt;/h3&gt;
 219  *
 220  * &lt;p&gt;The code shown above is the shortest possible code for creating a TreeTableView
 221  * when the domain objects are designed with JavaFX properties in mind
 222  * (additionally, {@link javafx.scene.control.cell.TreeItemPropertyValueFactory} supports
 223  * normal JavaBean properties too, although there is a caveat to this, so refer
 224  * to the class documentation for more information). When this is not the case,
 225  * it is necessary to provide a custom cell value factory. More information
 226  * about cell value factories can be found in the {@link TreeTableColumn} API
 227  * documentation, but briefly, here is how a TreeTableColumns could be specified:
 228  *
 229  * &lt;pre&gt; {@code firstNameCol.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;Person, String&gt;, ObservableValue&lt;String&gt;&gt;() {
 230  *     public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;Person, String&gt; p) {
 231  *         // p.getValue() returns the TreeItem&lt;Person&gt; instance for a particular TreeTableView row,
 232  *         // p.getValue().getValue() returns the Person instance inside the TreeItem&lt;Person&gt;
 233  *         return p.getValue().getValue().firstNameProperty();
 234  *     }
 235  * });
 236  *
 237  * // or with a lambda expression:
 238  * firstNameCol.setCellValueFactory(p -&gt; p.getValue().getValue().firstNameProperty());}&lt;/pre&gt;
 239  *
 240  * &lt;h3&gt;TreeTableView Selection / Focus APIs&lt;/h3&gt;
 241  * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 242  * {@link SelectionModel} and {@link FocusModel} classes. A TreeTableView has at most
 243  * one instance of each of these classes, available from
 244  * {@link #selectionModelProperty() selectionModel} and
 245  * {@link #focusModelProperty() focusModel} properties, respectively.
 246  * Whilst it is possible to use this API to set a new selection model, in
 247  * most circumstances this is not necessary - the default selection and focus
 248  * models should work in most circumstances.
 249  *
 250  * &lt;p&gt;The default {@link SelectionModel} used when instantiating a TreeTableView is
 251  * an implementation of the {@link MultipleSelectionModel} abstract class.
 252  * However, as noted in the API documentation for
 253  * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 254  * property, the default value is {@link SelectionMode#SINGLE}. To enable
 255  * multiple selection in a default TreeTableView instance, it is therefore necessary
 256  * to do the following:
 257  *
 258  * &lt;pre&gt; {@code treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 259  *
 260  * &lt;h3&gt;Customizing TreeTableView Visuals&lt;/h3&gt;
 261  * &lt;p&gt;The visuals of the TreeTableView can be entirely customized by replacing the
 262  * default {@link #rowFactoryProperty() row factory}. A row factory is used to
 263  * generate {@link TreeTableRow} instances, which are used to represent an entire
 264  * row in the TreeTableView.
 265  *
 266  * &lt;p&gt;In many cases, this is not what is desired however, as it is more commonly
 267  * the case that cells be customized on a per-column basis, not a per-row basis.
 268  * It is therefore important to note that a {@link TreeTableRow} is not a
 269  * {@link TreeTableCell}. A  {@link TreeTableRow} is simply a container for zero or more
 270  * {@link TreeTableCell}, and in most circumstances it is more likely that you&#39;ll
 271  * want to create custom TreeTableCells, rather than TreeTableRows. The primary use case
 272  * for creating custom TreeTableRow instances would most probably be to introduce
 273  * some form of column spanning support.
 274  *
 275  * &lt;p&gt;You can create custom {@link TreeTableCell} instances per column by assigning
 276  * the appropriate function to the TreeTableColumns
 277  * {@link TreeTableColumn#cellFactoryProperty() cell factory} property.
 278  *
 279  * &lt;p&gt;See the {@link Cell} class documentation for a more complete
 280  * description of how to write custom Cells.
 281  *
 282  * &lt;h3&gt;Editing&lt;/h3&gt;
 283  * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 284  * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 285  *
 286  * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 287  * than when a cell is not being edited. This is the responsibility of the
 288  * {@link Cell} implementation being used. For TreeTableView, it is highly
 289  * recommended that editing be
 290  * {@link javafx.scene.control.TreeTableColumn#cellFactoryProperty() per-TreeTableColumn},
 291  * rather than {@link #rowFactoryProperty() per row}, as more often than not
 292  * you want users to edit each column value differently, and this approach allows
 293  * for editors specific to each column. It is your choice whether the cell is
 294  * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 295  * or to switch to a different UI when editing begins (e.g. when a double-click
 296  * is received on a cell).&lt;/p&gt;
 297  *
 298  * &lt;p&gt;To know when editing has been requested on a cell,
 299  * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 300  * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 301  * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 302  * appropriate (e.g. set the text to null and set the graphic to be a
 303  * {@link TextField}). Additionally, you should also override
 304  * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 305  * when the editing concludes. In both cases it is important that you also
 306  * ensure that you call the super method to have the cell perform all duties it
 307  * must do to enter or exit its editing mode.&lt;/p&gt;
 308  *
 309  * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 310  * interested in is how to commit or cancel the editing that is taking place. This is your
 311  * responsibility as the cell factory provider. Your cell implementation will know
 312  * when the editing is over, based on the user input (e.g. when the user presses
 313  * the Enter or ESC keys on their keyboard). When this happens, it is your
 314  * responsibility to call {@link Cell#commitEdit(Object)} or
 315  * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 316  *
 317  * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 318  * TreeTableView, which you can observe by adding an {@link EventHandler} via
 319  * {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 320  * you can also observe edit events for
 321  * {@link TreeTableColumn#setOnEditStart(javafx.event.EventHandler) edit start}
 322  * and {@link TreeTableColumn#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 323  *
 324  * &lt;p&gt;By default the TreeTableColumn edit commit handler is non-null, with a default
 325  * handler that attempts to overwrite the property value for the
 326  * item in the currently-being-edited row. It is able to do this as the
 327  * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 328  * is passed along to the edit commit handler via the
 329  * {@link javafx.scene.control.TreeTableColumn.CellEditEvent CellEditEvent} that is
 330  * fired. It is simply a matter of calling
 331  * {@link javafx.scene.control.TreeTableColumn.CellEditEvent#getNewValue()} to
 332  * retrieve this value.
 333  *
 334  * &lt;p&gt;It is very important to note that if you call
 335  * {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler)} with your own
 336  * {@link EventHandler}, then you will be removing the default handler. Unless
 337  * you then handle the writeback to the property (or the relevant data source),
 338  * nothing will happen. You can work around this by using the
 339  * {@link TreeTableColumn#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 340  * method to add a {@link TreeTableColumn#EDIT_COMMIT_EVENT} {@link EventType} with
 341  * your desired {@link EventHandler} as the second argument. Using this method,
 342  * you will not replace the default implementation, but you will be notified when
 343  * an edit commit has occurred.&lt;/p&gt;
 344  *
 345  * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 346  * Fortunately, JavaFX ships with a number of pre-built cell factories that
 347  * handle all the editing requirements on your behalf. You can find these
 348  * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 349  *
 350  * @see TreeTableColumn
 351  * @see TreeTablePosition
 352  * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView.
 353  * @since JavaFX 8.0
 354  */
 355 @DefaultProperty(&quot;root&quot;)
 356 public class TreeTableView&lt;S&gt; extends Control {
 357 
 358     /***************************************************************************
 359      *                                                                         *
 360      * Constructors                                                            *
 361      *                                                                         *
 362      **************************************************************************/
 363 
 364     /**
 365      * Creates an empty TreeTableView.
 366      *
 367      * &lt;p&gt;Refer to the {@link TreeTableView} class documentation for details on the
 368      * default state of other properties.
 369      */
 370     public TreeTableView() {
 371         this(null);
 372     }
 373 
 374     /**
 375      * Creates a TreeTableView with the provided root node.
 376      *
 377      * &lt;p&gt;Refer to the {@link TreeTableView} class documentation for details on the
 378      * default state of other properties.
 379      *
 380      * @param root The node to be the root in this TreeTableView.
 381      */
 382     public TreeTableView(TreeItem&lt;S&gt; root) {
 383         getStyleClass().setAll(DEFAULT_STYLE_CLASS);
 384         setAccessibleRole(AccessibleRole.TREE_TABLE_VIEW);
 385 
 386         setRoot(root);
 387         updateExpandedItemCount(root);
 388 
 389         // install default selection and focus models - it&#39;s unlikely this will be changed
 390         // by many users.
 391         setSelectionModel(new TreeTableViewArrayListSelectionModel&lt;S&gt;(this));
 392         setFocusModel(new TreeTableViewFocusModel&lt;S&gt;(this));
 393 
 394         // we watch the columns list, such that when it changes we can update
 395         // the leaf columns and visible leaf columns lists (which are read-only).
 396         getColumns().addListener(weakColumnsObserver);
 397 
 398         // watch for changes to the sort order list - and when it changes run
 399         // the sort method.
 400         getSortOrder().addListener((ListChangeListener.Change&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; c) -&gt; {
 401             doSort(TableUtil.SortEventType.SORT_ORDER_CHANGE, c);
 402         });
 403 
 404         // We&#39;re watching for changes to the content width such
 405         // that the resize policy can be run if necessary. This comes from
 406         // TreeTableViewSkin.
 407         getProperties().addListener((MapChangeListener&lt;Object, Object&gt;) c -&gt; {
 408             if (c.wasAdded() &amp;&amp; TableView.SET_CONTENT_WIDTH.equals(c.getKey())) {
 409                 if (c.getValueAdded() instanceof Number) {
 410                     setContentWidth((Double) c.getValueAdded());
 411                 }
 412                 getProperties().remove(TableView.SET_CONTENT_WIDTH);
 413             }
 414         });
 415 
 416         isInited = true;
 417     }
 418 
 419 
 420 
 421     /***************************************************************************
 422      *                                                                         *
 423      * Static properties and methods                                           *
 424      *                                                                         *
 425      **************************************************************************/
 426 
 427     /**
 428      * An EventType that indicates some edit event has occurred. It is the parent
 429      * type of all other edit events: {@link #editStartEvent},
 430      *  {@link #editCommitEvent} and {@link #editCancelEvent}.
 431      *
 432      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 433      * @return An EventType that indicates some edit event has occurred
 434      */
 435     @SuppressWarnings(&quot;unchecked&quot;)
 436     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editAnyEvent() {
 437         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_ANY_EVENT;
 438     }
 439     private static final EventType&lt;?&gt; EDIT_ANY_EVENT =
 440             new EventType&lt;&gt;(Event.ANY, &quot;TREE_TABLE_VIEW_EDIT&quot;);
 441 
 442     /**
 443      * An EventType used to indicate that an edit event has started within the
 444      * TreeTableView upon which the event was fired.
 445      *
 446      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 447      * @return An EventType used to indicate that an edit event has started
 448      */
 449     @SuppressWarnings(&quot;unchecked&quot;)
 450     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editStartEvent() {
 451         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_START_EVENT;
 452     }
 453     private static final EventType&lt;?&gt; EDIT_START_EVENT =
 454             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_START&quot;);
 455 
 456     /**
 457      * An EventType used to indicate that an edit event has just been canceled
 458      * within the TreeTableView upon which the event was fired.
 459      *
 460      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 461      * @return An EventType used to indicate that an edit event has just been
 462      *      canceled
 463      */
 464     @SuppressWarnings(&quot;unchecked&quot;)
 465     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editCancelEvent() {
 466         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_CANCEL_EVENT;
 467     }
 468     private static final EventType&lt;?&gt; EDIT_CANCEL_EVENT =
 469             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_CANCEL&quot;);
 470 
 471     /**
 472      * An EventType that is used to indicate that an edit in a TreeTableView has been
 473      * committed. This means that user has made changes to the data of a
 474      * TreeItem, and that the UI should be updated.
 475      *
 476      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 477      * @return An EventType that is used to indicate that an edit in a TreeTableView
 478      *      has been committed
 479      */
 480     @SuppressWarnings(&quot;unchecked&quot;)
 481     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editCommitEvent() {
 482         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_COMMIT_EVENT;
 483     }
 484     private static final EventType&lt;?&gt; EDIT_COMMIT_EVENT =
 485             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_COMMIT&quot;);
 486 
 487     /**
 488      * Returns the number of levels of &#39;indentation&#39; of the given TreeItem,
 489      * based on how many times {@link javafx.scene.control.TreeItem#getParent()}
 490      * can be recursively called. If the TreeItem does not have any parent set,
 491      * the returned value will be zero. For each time getParent() is recursively
 492      * called, the returned value is incremented by one.
 493      *
 494      * &lt;p&gt;&lt;strong&gt;Important note: &lt;/strong&gt;This method is deprecated as it does
 495      * not consider the root node. This means that this method will iterate
 496      * past the root node of the TreeTableView control, if the root node has a parent.
 497      * If this is important, call {@link TreeTableView#getTreeItemLevel(TreeItem)}
 498      * instead.
 499      *
 500      * @param node The TreeItem for which the level is needed.
 501      * @return An integer representing the number of parents above the given node,
 502      *         or -1 if the given TreeItem is null.
 503      * @deprecated This method does not correctly calculate the distance from the
 504      *          given TreeItem to the root of the TreeTableView. As of JavaFX 8.0_20,
 505      *          the proper way to do this is via
 506      *          {@link TreeTableView#getTreeItemLevel(TreeItem)}
 507      */
 508     @Deprecated(since=&quot;8u20&quot;)
 509     public static int getNodeLevel(TreeItem&lt;?&gt; node) {
 510         return TreeView.getNodeLevel(node);
 511     }
 512 
 513     /**
 514      * &lt;p&gt;Very simple resize policy that just resizes the specified column by the
 515      * provided delta and shifts all other columns (to the right of the given column)
 516      * further to the right (when the delta is positive) or to the left (when the
 517      * delta is negative).
 518      *
 519      * &lt;p&gt;It also handles the case where we have nested columns by sharing the new space,
 520      * or subtracting the removed space, evenly between all immediate children columns.
 521      * Of course, the immediate children may themselves be nested, and they would
 522      * then use this policy on their children.
 523      */
 524     public static final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; UNCONSTRAINED_RESIZE_POLICY =
 525             new Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;() {
 526 
 527         @Override public String toString() {
 528             return &quot;unconstrained-resize&quot;;
 529         }
 530 
 531         @Override public Boolean call(TreeTableView.ResizeFeatures prop) {
 532             double result = TableUtil.resize(prop.getColumn(), prop.getDelta());
 533             return Double.compare(result, 0.0) == 0;
 534         }
 535     };
 536 
 537     /**
 538      * &lt;p&gt;Simple policy that ensures the width of all visible leaf columns in
 539      * this table sum up to equal the width of the table itself.
 540      *
 541      * &lt;p&gt;When the user resizes a column width with this policy, the table automatically
 542      * adjusts the width of the right hand side columns. When the user increases a
 543      * column width, the table decreases the width of the rightmost column until it
 544      * reaches its minimum width. Then it decreases the width of the second
 545      * rightmost column until it reaches minimum width and so on. When all right
 546      * hand side columns reach minimum size, the user cannot increase the size of
 547      * resized column any more.
 548      */
 549     public static final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; CONSTRAINED_RESIZE_POLICY =
 550             new Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;() {
 551 
 552         private boolean isFirstRun = true;
 553 
 554         @Override public String toString() {
 555             return &quot;constrained-resize&quot;;
 556         }
 557 
 558         @Override public Boolean call(TreeTableView.ResizeFeatures prop) {
 559             TreeTableView&lt;?&gt; table = prop.getTable();
 560             List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumns = table.getVisibleLeafColumns();
 561             Boolean result = TableUtil.constrainedResize(prop,
 562                                                isFirstRun,
 563                                                table.contentWidth,
 564                                                visibleLeafColumns);
 565             isFirstRun = ! isFirstRun ? false : ! result;
 566             return result;
 567         }
 568     };
 569 
 570     /**
 571      * The default {@link #sortPolicyProperty() sort policy} that this TreeTableView
 572      * will use if no other policy is specified. The sort policy is a simple
 573      * {@link Callback} that accepts a TreeTableView as the sole argument and expects
 574      * a Boolean response representing whether the sort succeeded or not. A Boolean
 575      * response of true represents success, and a response of false (or null) will
 576      * be considered to represent failure.
 577      */
 578     public static final Callback&lt;TreeTableView, Boolean&gt; DEFAULT_SORT_POLICY = new Callback&lt;TreeTableView, Boolean&gt;() {
 579         @Override public Boolean call(TreeTableView table) {
 580             try {
 581                 TreeItem rootItem = table.getRoot();
 582                 if (rootItem == null) return false;
 583 
 584                 TreeSortMode sortMode = table.getSortMode();
 585                 if (sortMode == null) return false;
 586 
 587                 rootItem.lastSortMode = sortMode;
 588                 rootItem.lastComparator = table.getComparator();
 589                 rootItem.sort();
 590                 return true;
 591             } catch (UnsupportedOperationException e) {
 592                 // TODO might need to support other exception types including:
 593                 // ClassCastException - if the class of the specified element prevents it from being added to this list
 594                 // NullPointerException - if the specified element is null and this list does not permit null elements
 595                 // IllegalArgumentException - if some property of this element prevents it from being added to this list
 596 
 597                 // If we are here the list does not support sorting, so we gracefully
 598                 // fail the sort request and ensure the UI is put back to its previous
 599                 // state. This is handled in the code that calls the sort policy.
 600 
 601                 return false;
 602             }
 603         }
 604     };
 605 
 606 
 607 
 608     /***************************************************************************
 609      *                                                                         *
 610      * Instance Variables                                                      *
 611      *                                                                         *
 612      **************************************************************************/
 613 
 614     // used in the tree item modification event listener. Used by the
 615     // layoutChildren method to determine whether the tree item count should
 616     // be recalculated.
 617     private boolean expandedItemCountDirty = true;
 618 
 619     // Used in the getTreeItem(int row) method to act as a cache.
 620     // See RT-26716 for the justification and performance gains.
 621     private Map&lt;Integer, SoftReference&lt;TreeItem&lt;S&gt;&gt;&gt; treeItemCacheMap = new HashMap&lt;&gt;();
 622 
 623     // this is the only publicly writable list for columns. This represents the
 624     // columns as they are given initially by the developer.
 625     private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = FXCollections.observableArrayList();
 626 
 627     // Finally, as convenience, we also have an observable list that contains
 628     // only the leaf columns that are currently visible.
 629     private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; visibleLeafColumns = FXCollections.observableArrayList();
 630     private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; unmodifiableVisibleLeafColumns = FXCollections.unmodifiableObservableList(visibleLeafColumns);
 631 
 632     // Allows for multiple column sorting based on the order of the TreeTableColumns
 633     // in this observableArrayList. Each TreeTableColumn is responsible for whether it is
 634     // sorted using ascending or descending order.
 635     private ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = FXCollections.observableArrayList();
 636 
 637     // width of VirtualFlow minus the vbar width
 638     // package protected for testing only
 639     double contentWidth;
 640 
 641     // Used to minimise the amount of work performed prior to the table being
 642     // completely initialised. In particular it reduces the amount of column
 643     // resize operations that occur, which slightly improves startup time.
 644     private boolean isInited = false;
 645 
 646 
 647 
 648     /***************************************************************************
 649      *                                                                         *
 650      * Callbacks and Events                                                    *
 651      *                                                                         *
 652      **************************************************************************/
 653 
 654     // we use this to forward events that have bubbled up TreeItem instances
 655     // to the TreeTableViewSkin, to force it to recalculate teh item count and redraw
 656     // if necessary
 657     private final EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; rootEvent = e -&gt; {
 658         // this forces layoutChildren at the next pulse, and therefore
 659         // updates the item count if necessary
 660         EventType&lt;?&gt; eventType = e.getEventType();
 661         boolean match = false;
 662         while (eventType != null) {
 663             if (eventType.equals(TreeItem.&lt;S&gt;expandedItemCountChangeEvent())) {
 664                 match = true;
 665                 break;
 666             }
 667             eventType = eventType.getSuperType();
 668         }
 669 
 670         if (match) {
 671             expandedItemCountDirty = true;
 672             requestLayout();
 673         }
 674     };
 675 
 676     private final ListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt; columnsObserver = new ListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt;() {
 677         @Override public void onChanged(ListChangeListener.Change&lt;? extends TreeTableColumn&lt;S,?&gt;&gt; c) {
 678             final List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getColumns();
 679 
 680             // Fix for RT-39822 - don&#39;t allow the same column to be installed twice
 681             while (c.next()) {
 682                 if (c.wasAdded()) {
 683                     List&lt;TreeTableColumn&lt;S,?&gt;&gt; duplicates = new ArrayList&lt;&gt;();
 684                     for (TreeTableColumn&lt;S,?&gt; addedColumn : c.getAddedSubList()) {
 685                         if (addedColumn == null) continue;
 686 
 687                         int count = 0;
 688                         for (TreeTableColumn&lt;S,?&gt; column : columns) {
 689                             if (addedColumn == column) {
 690                                 count++;
 691                             }
 692                         }
 693 
 694                         if (count &gt; 1) {
 695                             duplicates.add(addedColumn);
 696                         }
 697                     }
 698 
 699                     if (!duplicates.isEmpty()) {
 700                         String titleList = &quot;&quot;;
 701                         for (TreeTableColumn&lt;S,?&gt; dupe : duplicates) {
 702                             titleList += &quot;&#39;&quot; + dupe.getText() + &quot;&#39;, &quot;;
 703                         }
 704                         throw new IllegalStateException(&quot;Duplicate TreeTableColumns detected in TreeTableView columns list with titles &quot; + titleList);
 705                     }
 706                 }
 707             }
 708             c.reset();
 709 
 710             // Fix for RT-15194: Need to remove removed columns from the
 711             // sortOrder list.
 712             List&lt;TreeTableColumn&lt;S,?&gt;&gt; toRemove = new ArrayList&lt;TreeTableColumn&lt;S,?&gt;&gt;();
 713             while (c.next()) {
 714                 final List&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; removed = c.getRemoved();
 715                 final List&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; added = c.getAddedSubList();
 716 
 717                 if (c.wasRemoved()) {
 718                     toRemove.addAll(removed);
 719                     for (TreeTableColumn&lt;S,?&gt; tc : removed) {
 720                         tc.setTreeTableView(null);
 721                     }
 722                 }
 723 
 724                 if (c.wasAdded()) {
 725                     toRemove.removeAll(added);
 726                     for (TreeTableColumn&lt;S,?&gt; tc : added) {
 727                         tc.setTreeTableView(TreeTableView.this);
 728                     }
 729                 }
 730 
 731                 // set up listeners
 732                 TableUtil.removeColumnsListener(removed, weakColumnsObserver);
 733                 TableUtil.addColumnsListener(added, weakColumnsObserver);
 734 
 735                 TableUtil.removeTableColumnListener(c.getRemoved(),
 736                         weakColumnVisibleObserver,
 737                         weakColumnSortableObserver,
 738                         weakColumnSortTypeObserver,
 739                         weakColumnComparatorObserver);
 740                 TableUtil.addTableColumnListener(c.getAddedSubList(),
 741                         weakColumnVisibleObserver,
 742                         weakColumnSortableObserver,
 743                         weakColumnSortTypeObserver,
 744                         weakColumnComparatorObserver);
 745             }
 746 
 747             // We don&#39;t maintain a bind for leafColumns, we simply call this update
 748             // function behind the scenes in the appropriate places.
 749             updateVisibleLeafColumns();
 750 
 751             sortOrder.removeAll(toRemove);
 752 
 753             // Fix for RT-38892.
 754             final TreeTableViewFocusModel&lt;S&gt; fm = getFocusModel();
 755             final TreeTableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
 756             c.reset();
 757 
 758             // we need to collect together all removed and all added columns, because
 759             // the code below works on the actually removed columns. If we perform
 760             // the code within this while loop, we&#39;ll be deselecting columns that
 761             // should be deselected (because they have just moved place, for example).
 762             List&lt;TreeTableColumn&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;();
 763             List&lt;TreeTableColumn&lt;S,?&gt;&gt; added = new ArrayList&lt;&gt;();
 764             while (c.next()) {
 765                 if (c.wasRemoved()) {
 766                     removed.addAll(c.getRemoved());
 767                 }
 768                 if (c.wasAdded()) {
 769                     added.addAll(c.getAddedSubList());
 770                 }
 771             }
 772             removed.removeAll(added);
 773 
 774 
 775             // Fix for focus - we simply move focus to a cell to the left
 776             // of the focused cell if the focused cell was located within
 777             // a column that has been removed.
 778             if (fm != null) {
 779                 TreeTablePosition&lt;S, ?&gt; focusedCell = fm.getFocusedCell();
 780                 boolean match = false;
 781                 for (TreeTableColumn&lt;S, ?&gt; tc : removed) {
 782                     match = focusedCell != null &amp;&amp; focusedCell.getTableColumn() == tc;
 783                     if (match) {
 784                         break;
 785                     }
 786                 }
 787 
 788                 if (match) {
 789                     int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(focusedCell.getTableColumn(), 0);
 790                     int newFocusColumnIndex =
 791                             matchingColumnIndex == 0 ? 0 :
 792                                     Math.min(getVisibleLeafColumns().size() - 1, matchingColumnIndex - 1);
 793                     fm.focus(focusedCell.getRow(), getVisibleLeafColumn(newFocusColumnIndex));
 794                 }
 795             }
 796 
 797             // Fix for selection - we remove selection from all cells that
 798             // were within the removed column.
 799             if (sm != null) {
 800                 List&lt;TreeTablePosition&gt; selectedCells = new ArrayList&lt;&gt;(sm.getSelectedCells());
 801                 for (TreeTablePosition selectedCell : selectedCells) {
 802                     boolean match = false;
 803                     for (TreeTableColumn&lt;S, ?&gt; tc : removed) {
 804                         match = selectedCell != null &amp;&amp; selectedCell.getTableColumn() == tc;
 805                         if (match) break;
 806                     }
 807 
 808                     if (match) {
 809                         // we can&#39;t just use the selectedCell.getTableColumn(), as that
 810                         // column no longer exists and therefore its index is not correct.
 811                         int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(selectedCell.getTableColumn(), -1);
 812                         if (matchingColumnIndex == -1) continue;
 813 
 814                         if (sm instanceof TreeTableViewArrayListSelectionModel) {
 815                             // Also, because the table column no longer exists in the columns
 816                             // list at this point, we can&#39;t just call:
 817                             // sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
 818                             // as the tableColumn would map to an index of -1, which means that
 819                             // selection will not be cleared. Instead, we have to create
 820                             // a new TablePosition with a fixed column index and use that.
 821                             TreeTablePosition&lt;S,?&gt; fixedTablePosition =
 822                                     new TreeTablePosition&lt;S,Object&gt;(TreeTableView.this,
 823                                             selectedCell.getRow(),
 824                                             selectedCell.getTableColumn());
 825                             fixedTablePosition.fixedColumnIndex = matchingColumnIndex;
 826 
 827                             ((TreeTableViewArrayListSelectionModel)sm).clearSelection(fixedTablePosition);
 828                         } else {
 829                             sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
 830                         }
 831                     }
 832                 }
 833             }
 834 
 835 
 836             // update the lastKnownColumnIndex map
 837             lastKnownColumnIndex.clear();
 838             for (TreeTableColumn&lt;S,?&gt; tc : getColumns()) {
 839                 int index = getVisibleLeafIndex(tc);
 840                 if (index &gt; -1) {
 841                     lastKnownColumnIndex.put(tc, index);
 842                 }
 843             }
 844         }
 845     };
 846 
 847     private final WeakHashMap&lt;TreeTableColumn&lt;S,?&gt;, Integer&gt; lastKnownColumnIndex = new WeakHashMap&lt;&gt;();
 848 
 849     private final InvalidationListener columnVisibleObserver = valueModel -&gt; {
 850         updateVisibleLeafColumns();
 851     };
 852 
 853     private final InvalidationListener columnSortableObserver = valueModel -&gt; {
 854         TreeTableColumn col = (TreeTableColumn) ((BooleanProperty)valueModel).getBean();
 855         if (! getSortOrder().contains(col)) return;
 856         doSort(TableUtil.SortEventType.COLUMN_SORTABLE_CHANGE, col);
 857     };
 858 
 859     private final InvalidationListener columnSortTypeObserver = valueModel -&gt; {
 860         TreeTableColumn col = (TreeTableColumn) ((ObjectProperty)valueModel).getBean();
 861         if (! getSortOrder().contains(col)) return;
 862         doSort(TableUtil.SortEventType.COLUMN_SORT_TYPE_CHANGE, col);
 863     };
 864 
 865     private final InvalidationListener columnComparatorObserver = valueModel -&gt; {
 866         TreeTableColumn col = (TreeTableColumn) ((SimpleObjectProperty)valueModel).getBean();
 867         if (! getSortOrder().contains(col)) return;
 868         doSort(TableUtil.SortEventType.COLUMN_COMPARATOR_CHANGE, col);
 869     };
 870 
 871     /* proxy pseudo-class state change from selectionModel&#39;s cellSelectionEnabledProperty */
 872     private final InvalidationListener cellSelectionModelInvalidationListener = o -&gt; {
 873         boolean isCellSelection = ((BooleanProperty)o).get();
 874         pseudoClassStateChanged(PSEUDO_CLASS_CELL_SELECTION,  isCellSelection);
 875         pseudoClassStateChanged(PSEUDO_CLASS_ROW_SELECTION,  !isCellSelection);
 876     };
 877 
 878     private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakRootEventListener;
 879 
 880     private final WeakInvalidationListener weakColumnVisibleObserver =
 881             new WeakInvalidationListener(columnVisibleObserver);
 882 
 883     private final WeakInvalidationListener weakColumnSortableObserver =
 884             new WeakInvalidationListener(columnSortableObserver);
 885 
 886     private final WeakInvalidationListener weakColumnSortTypeObserver =
 887             new WeakInvalidationListener(columnSortTypeObserver);
 888 
 889     private final WeakInvalidationListener weakColumnComparatorObserver =
 890             new WeakInvalidationListener(columnComparatorObserver);
 891 
 892     private final WeakListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt; weakColumnsObserver =
 893             new WeakListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt;(columnsObserver);
 894 
 895     private final WeakInvalidationListener weakCellSelectionModelInvalidationListener =
 896             new WeakInvalidationListener(cellSelectionModelInvalidationListener);
 897 
 898 
 899 
 900     /***************************************************************************
 901      *                                                                         *
 902      * Properties                                                              *
 903      *                                                                         *
 904      **************************************************************************/
 905 
 906     // --- Root
 907     private ObjectProperty&lt;TreeItem&lt;S&gt;&gt; root = new SimpleObjectProperty&lt;TreeItem&lt;S&gt;&gt;(this, &quot;root&quot;) {
 908         private WeakReference&lt;TreeItem&lt;S&gt;&gt; weakOldItem;
 909 
 910         @Override protected void invalidated() {
 911             TreeItem&lt;S&gt; oldTreeItem = weakOldItem == null ? null : weakOldItem.get();
 912             if (oldTreeItem != null &amp;&amp; weakRootEventListener != null) {
 913                 oldTreeItem.removeEventHandler(TreeItem.&lt;S&gt;treeNotificationEvent(), weakRootEventListener);
 914             }
 915 
 916             TreeItem&lt;S&gt; root = getRoot();
 917             if (root != null) {
 918                 weakRootEventListener = new WeakEventHandler&lt;&gt;(rootEvent);
 919                 getRoot().addEventHandler(TreeItem.&lt;S&gt;treeNotificationEvent(), weakRootEventListener);
 920                 weakOldItem = new WeakReference&lt;&gt;(root);
 921             }
 922 
 923             // Fix for RT-35763
 924             getSortOrder().clear();
 925 
 926             expandedItemCountDirty = true;
 927             updateRootExpanded();
 928         }
 929     };
 930 
 931     /**
 932      * Sets the root node in this TreeTableView. See the {@link TreeItem} class level
 933      * documentation for more details.
 934      *
 935      * @param value The {@link TreeItem} that will be placed at the root of the
 936      *      TreeTableView.
 937      */
 938     public final void setRoot(TreeItem&lt;S&gt; value) {
 939         rootProperty().set(value);
 940     }
 941 
 942     /**
 943      * Returns the current root node of this TreeTableView, or null if no root node
 944      * is specified.
 945      * @return The current root node, or null if no root node exists.
 946      */
 947     public final TreeItem&lt;S&gt; getRoot() {
 948         return root == null ? null : root.get();
 949     }
 950 
 951     /**
 952      * Property representing the root node of the TreeTableView.
 953      * @return the root property
 954      */
 955     public final ObjectProperty&lt;TreeItem&lt;S&gt;&gt; rootProperty() {
 956         return root;
 957     }
 958 
 959 
 960 
 961     // --- Show Root
 962     private BooleanProperty showRoot;
 963 
 964     /**
 965      * Specifies whether the root {@code TreeItem} should be shown within this
 966      * TreeTableView.
 967      *
 968      * @param value If true, the root TreeItem will be shown, and if false it
 969      *      will be hidden.
 970      */
 971     public final void setShowRoot(boolean value) {
 972         showRootProperty().set(value);
 973     }
 974 
 975     /**
 976      * Returns true if the root of the TreeTableView should be shown, and false if
 977      * it should not. By default, the root TreeItem is visible in the TreeTableView.
 978      * @return true if the root of the TreeTableView should be shown
 979      */
 980     public final boolean isShowRoot() {
 981         return showRoot == null ? true : showRoot.get();
 982     }
 983 
 984     /**
 985      * Property that represents whether or not the TreeTableView root node is visible.
 986      * @return the show root property
 987      */
 988     public final BooleanProperty showRootProperty() {
 989         if (showRoot == null) {
 990             showRoot = new SimpleBooleanProperty(this, &quot;showRoot&quot;, true) {
 991                 @Override protected void invalidated() {
 992                     updateRootExpanded();
 993                     updateExpandedItemCount(getRoot());
 994                 }
 995             };
 996         }
 997         return showRoot;
 998     }
 999 
1000 
1001 
1002     // --- Tree Column
1003     private ObjectProperty&lt;TreeTableColumn&lt;S,?&gt;&gt; treeColumn;
1004     /**
1005      * Property that represents which column should have the disclosure node
1006      * shown in it (that is, the column with the arrow). By default this will be
1007      * the left-most column if this property is null, otherwise it will be the
1008      * specified column assuming it is non-null and contained within the
1009      * {@link #getVisibleLeafColumns() visible leaf columns} list.
1010      * @return the tree column property
1011      */
1012     public final ObjectProperty&lt;TreeTableColumn&lt;S,?&gt;&gt; treeColumnProperty() {
1013         if (treeColumn == null) {
1014             treeColumn = new SimpleObjectProperty&lt;&gt;(this, &quot;treeColumn&quot;, null);
1015         }
1016         return treeColumn;
1017     }
1018     public final void setTreeColumn(TreeTableColumn&lt;S,?&gt; value) {
1019         treeColumnProperty().set(value);
1020     }
1021     public final TreeTableColumn&lt;S,?&gt; getTreeColumn() {
1022         return treeColumn == null ? null : treeColumn.get();
1023     }
1024 
1025 
1026 
1027     // --- Selection Model
1028     private ObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt; selectionModel;
1029 
1030     /**
1031      * Sets the {@link MultipleSelectionModel} to be used in the TreeTableView.
1032      * Despite a TreeTableView requiring a &lt;code&gt;&lt;b&gt;Multiple&lt;/b&gt;SelectionModel&lt;/code&gt;,
1033      * it is possible to configure it to only allow single selection (see
1034      * {@link MultipleSelectionModel#setSelectionMode(javafx.scene.control.SelectionMode)}
1035      * for more information).
1036      * @param value the {@link MultipleSelectionModel} to be used
1037      */
1038     public final void setSelectionModel(TreeTableViewSelectionModel&lt;S&gt; value) {
1039         selectionModelProperty().set(value);
1040     }
1041 
1042     /**
1043      * Returns the currently installed selection model.
1044      * @return the currently installed selection model
1045      */
1046     public final TreeTableViewSelectionModel&lt;S&gt; getSelectionModel() {
1047         return selectionModel == null ? null : selectionModel.get();
1048     }
1049 
1050     /**
1051      * The SelectionModel provides the API through which it is possible
1052      * to select single or multiple items within a TreeTableView, as  well as inspect
1053      * which rows have been selected by the user. Note that it has a generic
1054      * type that must match the type of the TreeTableView itself.
1055      * @return the selection model property
1056      */
1057     public final ObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt; selectionModelProperty() {
1058         if (selectionModel == null) {
1059             selectionModel = new SimpleObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt;(this, &quot;selectionModel&quot;) {
1060 
1061                 TreeTableViewSelectionModel&lt;S&gt; oldValue = null;
1062 
1063                 @Override protected void invalidated() {
1064                     // need to listen to the cellSelectionEnabledProperty
1065                     // in order to set pseudo-class state
1066                     if (oldValue != null) {
1067                         oldValue.cellSelectionEnabledProperty().removeListener(weakCellSelectionModelInvalidationListener);
1068 
1069                         if (oldValue instanceof TreeTableViewArrayListSelectionModel) {
1070                             ((TreeTableViewArrayListSelectionModel)oldValue).dispose();
1071                         }
1072                     }
1073 
1074                     oldValue = get();
1075 
1076                     if (oldValue != null) {
1077                         oldValue.cellSelectionEnabledProperty().addListener(weakCellSelectionModelInvalidationListener);
1078                         // fake invalidation to ensure updated pseudo-class states
1079                         weakCellSelectionModelInvalidationListener.invalidated(oldValue.cellSelectionEnabledProperty());
1080                     }
1081                 }
1082             };
1083         }
1084         return selectionModel;
1085     }
1086 
1087 
1088     // --- Focus Model
1089     private ObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt; focusModel;
1090 
1091     /**
1092      * Sets the {@link FocusModel} to be used in the TreeTableView.
1093      * @param value the {@link FocusModel} to be used
1094      */
1095     public final void setFocusModel(TreeTableViewFocusModel&lt;S&gt; value) {
1096         focusModelProperty().set(value);
1097     }
1098 
1099     /**
1100      * Returns the currently installed {@link FocusModel}.
1101      * @return the currently installed {@link FocusModel}
1102      */
1103     public final TreeTableViewFocusModel&lt;S&gt; getFocusModel() {
1104         return focusModel == null ? null : focusModel.get();
1105     }
1106 
1107     /**
1108      * The FocusModel provides the API through which it is possible
1109      * to control focus on zero or one rows of the TreeTableView. Generally the
1110      * default implementation should be more than sufficient.
1111      * @return the focus model property
1112      */
1113     public final ObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt; focusModelProperty() {
1114         if (focusModel == null) {
1115             focusModel = new SimpleObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt;(this, &quot;focusModel&quot;);
1116         }
1117         return focusModel;
1118     }
1119 
1120 
1121     // --- Tree node count
1122     /**
1123      * &lt;p&gt;Represents the number of tree nodes presently able to be visible in the
1124      * TreeTableView. This is essentially the count of all expanded tree items, and
1125      * their children.
1126      *
1127      * &lt;p&gt;For example, if just the root node is visible, the expandedItemCount will
1128      * be one. If the root had three children and the root was expanded, the value
1129      * will be four.
1130      */
1131     private ReadOnlyIntegerWrapper expandedItemCount = new ReadOnlyIntegerWrapper(this, &quot;expandedItemCount&quot;, 0);
1132     public final ReadOnlyIntegerProperty expandedItemCountProperty() {
1133         return expandedItemCount.getReadOnlyProperty();
1134     }
1135     private void setExpandedItemCount(int value) {
1136         expandedItemCount.set(value);
1137     }
1138     public final int getExpandedItemCount() {
1139         if (expandedItemCountDirty) {
1140             updateExpandedItemCount(getRoot());
1141         }
1142         return expandedItemCount.get();
1143     }
1144 
1145 
1146     // --- Editable
1147     private BooleanProperty editable;
1148     public final void setEditable(boolean value) {
1149         editableProperty().set(value);
1150     }
1151     public final boolean isEditable() {
1152         return editable == null ? false : editable.get();
1153     }
1154     /**
1155      * Specifies whether this TreeTableView is editable - only if the TreeTableView and
1156      * the TreeCells within it are both editable will a TreeCell be able to go
1157      * into their editing state.
1158      * @return the editable property
1159      */
1160     public final BooleanProperty editableProperty() {
1161         if (editable == null) {
1162             editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
1163         }
1164         return editable;
1165     }
1166 
1167 
1168     // --- Editing Cell
1169     private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCell;
1170     private void setEditingCell(TreeTablePosition&lt;S,?&gt; value) {
1171         editingCellPropertyImpl().set(value);
1172     }
1173     public final TreeTablePosition&lt;S,?&gt; getEditingCell() {
1174         return editingCell == null ? null : editingCell.get();
1175     }
1176 
1177     /**
1178      * Represents the current cell being edited, or null if
1179      * there is no cell being edited.
1180      * @return the editing cell property
1181      */
1182     public final ReadOnlyObjectProperty&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCellProperty() {
1183         return editingCellPropertyImpl().getReadOnlyProperty();
1184     }
1185 
1186     private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCellPropertyImpl() {
1187         if (editingCell == null) {
1188             editingCell = new ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt;(this, &quot;editingCell&quot;);
1189         }
1190         return editingCell;
1191     }
1192 
1193 
1194     // --- Table menu button visible
1195     private BooleanProperty tableMenuButtonVisible;
1196     /**
1197      * This controls whether a menu button is available when the user clicks
1198      * in a designated space within the TableView, within which is a radio menu
1199      * item for each TreeTableColumn in this table. This menu allows for the user to
1200      * show and hide all TreeTableColumns easily.
1201      * @return the table menu button visible property
1202      */
1203     public final BooleanProperty tableMenuButtonVisibleProperty() {
1204         if (tableMenuButtonVisible == null) {
1205             tableMenuButtonVisible = new SimpleBooleanProperty(this, &quot;tableMenuButtonVisible&quot;);
1206         }
1207         return tableMenuButtonVisible;
1208     }
1209     public final void setTableMenuButtonVisible (boolean value) {
1210         tableMenuButtonVisibleProperty().set(value);
1211     }
1212     public final boolean isTableMenuButtonVisible() {
1213         return tableMenuButtonVisible == null ? false : tableMenuButtonVisible.get();
1214     }
1215 
1216 
1217     // --- Column Resize Policy
1218     private ObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt; columnResizePolicy;
1219     public final void setColumnResizePolicy(Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; callback) {
1220         columnResizePolicyProperty().set(callback);
1221     }
1222     public final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; getColumnResizePolicy() {
1223         return columnResizePolicy == null ? UNCONSTRAINED_RESIZE_POLICY : columnResizePolicy.get();
1224     }
1225 
1226     /**
1227      * This is the function called when the user completes a column-resize
1228      * operation. The two most common policies are available as static functions
1229      * in the TableView class: {@link #UNCONSTRAINED_RESIZE_POLICY} and
1230      * {@link #CONSTRAINED_RESIZE_POLICY}.
1231      * @return the column resize policy property
1232      */
1233     public final ObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt; columnResizePolicyProperty() {
1234         if (columnResizePolicy == null) {
1235             columnResizePolicy = new SimpleObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt;(this, &quot;columnResizePolicy&quot;, UNCONSTRAINED_RESIZE_POLICY) {
1236                 private Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; oldPolicy;
1237 
1238                 @Override protected void invalidated() {
1239                     if (isInited) {
1240                         get().call(new TreeTableView.ResizeFeatures(TreeTableView.this, null, 0.0));
1241 
1242                         if (oldPolicy != null) {
1243                             PseudoClass state = PseudoClass.getPseudoClass(oldPolicy.toString());
1244                             pseudoClassStateChanged(state, false);
1245                         }
1246                         if (get() != null) {
1247                             PseudoClass state = PseudoClass.getPseudoClass(get().toString());
1248                             pseudoClassStateChanged(state, true);
1249                         }
1250                         oldPolicy = get();
1251                     }
1252                 }
1253             };
1254         }
1255         return columnResizePolicy;
1256     }
1257 
1258 
1259     // --- Row Factory
1260     private ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt; rowFactory;
1261 
1262     /**
1263      * A function which produces a TreeTableRow. The system is responsible for
1264      * reusing TreeTableRows. Return from this function a TreeTableRow which
1265      * might be usable for representing a single row in a TableView.
1266      * &lt;p&gt;
1267      * Note that a TreeTableRow is &lt;b&gt;not&lt;/b&gt; a TableCell. A TreeTableRow is
1268      * simply a container for a TableCell, and in most circumstances it is more
1269      * likely that you&#39;ll want to create custom TableCells, rather than
1270      * TreeTableRows. The primary use case for creating custom TreeTableRow
1271      * instances would most probably be to introduce some form of column
1272      * spanning support.
1273      * &lt;p&gt;
1274      * You can create custom TableCell instances per column by assigning the
1275      * appropriate function to the cellFactory property in the TreeTableColumn class.
1276      * @return the row factory property
1277      */
1278     public final ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt; rowFactoryProperty() {
1279         if (rowFactory == null) {
1280             rowFactory = new SimpleObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt;(this, &quot;rowFactory&quot;);
1281         }
1282         return rowFactory;
1283     }
1284     public final void setRowFactory(Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt; value) {
1285         rowFactoryProperty().set(value);
1286     }
1287     public final Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt; getRowFactory() {
1288         return rowFactory == null ? null : rowFactory.get();
1289     }
1290 
1291 
1292     // --- Placeholder Node
1293     private ObjectProperty&lt;Node&gt; placeholder;
1294     /**
1295      * This Node is shown to the user when the table has no content to show.
1296      * This may be the case because the table model has no data in the first
1297      * place, that a filter has been applied to the table model, resulting
1298      * in there being nothing to show the user, or that there are no currently
1299      * visible columns.
1300      * @return the placeholder property
1301      */
1302     public final ObjectProperty&lt;Node&gt; placeholderProperty() {
1303         if (placeholder == null) {
1304             placeholder = new SimpleObjectProperty&lt;Node&gt;(this, &quot;placeholder&quot;);
1305         }
1306         return placeholder;
1307     }
1308     public final void setPlaceholder(Node value) {
1309         placeholderProperty().set(value);
1310     }
1311     public final Node getPlaceholder() {
1312         return placeholder == null ? null : placeholder.get();
1313     }
1314 
1315 
1316     // --- Fixed cell size
1317     private DoubleProperty fixedCellSize;
1318 
1319     /**
1320      * Sets the new fixed cell size for this control. Any value greater than
1321      * zero will enable fixed cell size mode, whereas a zero or negative value
1322      * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
1323      * mode.
1324      *
1325      * @param value The new fixed cell size value, or a value less than or equal
1326      *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
1327      * @since JavaFX 8.0
1328      */
1329     public final void setFixedCellSize(double value) {
1330         fixedCellSizeProperty().set(value);
1331     }
1332 
1333     /**
1334      * Returns the fixed cell size value. A value less than or equal to zero is
1335      * used to represent that fixed cell size mode is disabled, and a value
1336      * greater than zero represents the size of all cells in this control.
1337      *
1338      * @return A double representing the fixed cell size of this control, or a
1339      *      value less than or equal to zero if fixed cell size mode is disabled.
1340      * @since JavaFX 8.0
1341      */
1342     public final double getFixedCellSize() {
1343         return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
1344     }
1345     /**
1346      * Specifies whether this control has cells that are a fixed height (of the
1347      * specified value). If this value is less than or equal to zero,
1348      * then all cells are individually sized and positioned. This is a slow
1349      * operation. Therefore, when performance matters and developers are not
1350      * dependent on variable cell sizes it is a good idea to set the fixed cell
1351      * size value. Generally cells are around 24px, so setting a fixed cell size
1352      * of 24 is likely to result in very little difference in visuals, but a
1353      * improvement to performance.
1354      *
1355      * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
1356      * This should not be confused with the -fx-cell-size property. The difference
1357      * between these two CSS properties is that -fx-cell-size will size all
1358      * cells to the specified size, but it will not enforce that this is the
1359      * only size (thus allowing for variable cell sizes, and preventing the
1360      * performance gains from being possible). Therefore, when performance matters
1361      * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
1362      * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
1363      *
1364      * @return the fixed cell size property
1365      * @since JavaFX 8.0
1366      */
1367     public final DoubleProperty fixedCellSizeProperty() {
1368         if (fixedCellSize == null) {
1369             fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
1370                 @Override public CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt; getCssMetaData() {
1371                     return StyleableProperties.FIXED_CELL_SIZE;
1372                 }
1373 
1374                 @Override public Object getBean() {
1375                     return TreeTableView.this;
1376                 }
1377 
1378                 @Override public String getName() {
1379                     return &quot;fixedCellSize&quot;;
1380                 }
1381             };
1382         }
1383         return fixedCellSize;
1384     }
1385 
1386 
1387     // --- SortMode
1388     /**
1389      * Specifies the sort mode to use when sorting the contents of this TreeTableView,
1390      * should any columns be specified in the {@link #getSortOrder() sort order}
1391      * list.
1392      */
1393     private ObjectProperty&lt;TreeSortMode&gt; sortMode;
1394     public final ObjectProperty&lt;TreeSortMode&gt; sortModeProperty() {
1395         if (sortMode == null) {
1396             sortMode = new SimpleObjectProperty&lt;&gt;(this, &quot;sortMode&quot;, TreeSortMode.ALL_DESCENDANTS);
1397         }
1398         return sortMode;
1399     }
1400     public final void setSortMode(TreeSortMode value) {
1401         sortModeProperty().set(value);
1402     }
1403     public final TreeSortMode getSortMode() {
1404         return sortMode == null ? TreeSortMode.ALL_DESCENDANTS : sortMode.get();
1405     }
1406 
1407 
1408     // --- Comparator (built via sortOrder list, so read-only)
1409     /**
1410      * The comparator property is a read-only property that is representative of the
1411      * current state of the {@link #getSortOrder() sort order} list. The sort
1412      * order list contains the columns that have been added to it either programmatically
1413      * or via a user clicking on the headers themselves.
1414      */
1415     private ReadOnlyObjectWrapper&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparator;
1416     private void setComparator(Comparator&lt;TreeItem&lt;S&gt;&gt; value) {
1417         comparatorPropertyImpl().set(value);
1418     }
1419     public final Comparator&lt;TreeItem&lt;S&gt;&gt; getComparator() {
1420         return comparator == null ? null : comparator.get();
1421     }
1422     public final ReadOnlyObjectProperty&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparatorProperty() {
1423         return comparatorPropertyImpl().getReadOnlyProperty();
1424     }
1425     private ReadOnlyObjectWrapper&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparatorPropertyImpl() {
1426         if (comparator == null) {
1427             comparator = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;comparator&quot;);
1428         }
1429         return comparator;
1430     }
1431 
1432 
1433     // --- sortPolicy
1434     /**
1435      * The sort policy specifies how sorting in this TreeTableView should be performed.
1436      * For example, a basic sort policy may just recursively sort the children of
1437      * the root tree item, whereas a more advanced sort policy may call to a
1438      * database to perform the necessary sorting on the server-side.
1439      *
1440      * &lt;p&gt;TreeTableView ships with a {@link TableView#DEFAULT_SORT_POLICY default
1441      * sort policy} that does precisely as mentioned above: it simply attempts
1442      * to sort the tree hierarchy in-place.
1443      *
1444      * &lt;p&gt;It is recommended that rather than override the {@link TreeTableView#sort() sort}
1445      * method that a different sort policy be provided instead.
1446      */
1447     private ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt; sortPolicy;
1448     public final void setSortPolicy(Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; callback) {
1449         sortPolicyProperty().set(callback);
1450     }
1451     @SuppressWarnings(&quot;unchecked&quot;)
1452     public final Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; getSortPolicy() {
1453         return sortPolicy == null ?
1454                 (Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY :
1455                 sortPolicy.get();
1456     }
1457     @SuppressWarnings(&quot;unchecked&quot;)
1458     public final ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt; sortPolicyProperty() {
1459         if (sortPolicy == null) {
1460             sortPolicy = new SimpleObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt;(
1461                     this, &quot;sortPolicy&quot;, (Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY) {
1462                 @Override protected void invalidated() {
1463                     sort();
1464                 }
1465             };
1466         }
1467         return sortPolicy;
1468     }
1469 
1470 
1471     // onSort
1472     /**
1473      * Called when there&#39;s a request to sort the control.
1474      */
1475     private ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt; onSort;
1476 
1477     public void setOnSort(EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; value) {
1478         onSortProperty().set(value);
1479     }
1480 
1481     public EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; getOnSort() {
1482         if( onSort != null ) {
1483             return onSort.get();
1484         }
1485         return null;
1486     }
1487 
1488     public ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt; onSortProperty() {
1489         if( onSort == null ) {
1490             onSort = new ObjectPropertyBase&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt;() {
1491                 @Override protected void invalidated() {
1492                     EventType&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; eventType = SortEvent.sortEvent();
1493                     EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; eventHandler = get();
1494                     setEventHandler(eventType, eventHandler);
1495                 }
1496 
1497                 @Override public Object getBean() {
1498                     return TreeTableView.this;
1499                 }
1500 
1501                 @Override public String getName() {
1502                     return &quot;onSort&quot;;
1503                 }
1504             };
1505         }
1506         return onSort;
1507     }
1508 
1509 
1510 
1511     /***************************************************************************
1512      *                                                                         *
1513      * Public API                                                              *
1514      *                                                                         *
1515      **************************************************************************/
1516 
1517     /** {@inheritDoc} */
1518     @Override protected void layoutChildren() {
1519         if (expandedItemCountDirty) {
1520             updateExpandedItemCount(getRoot());
1521         }
1522 
1523         super.layoutChildren();
1524     }
1525 
1526     /**
1527      * Scrolls the TreeTableView such that the item in the given index is visible to
1528      * the end user.
1529      *
1530      * @param index The index that should be made visible to the user, assuming
1531      *      of course that it is greater than, or equal to 0, and less than the
1532      *      number of the visible items in the TreeTableView.
1533      */
1534     public void scrollTo(int index) {
1535         ControlUtils.scrollToIndex(this, index);
1536     }
1537 
1538     /**
1539      * Called when there&#39;s a request to scroll an index into view using {@link #scrollTo(int)}
1540      */
1541     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;
1542 
1543     public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
1544         onScrollToProperty().set(value);
1545     }
1546 
1547     public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
1548         if( onScrollTo != null ) {
1549             return onScrollTo.get();
1550         }
1551         return null;
1552     }
1553 
1554     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
1555         if( onScrollTo == null ) {
1556             onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
1557                 @Override protected void invalidated() {
1558                     setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
1559                 }
1560 
1561                 @Override public Object getBean() {
1562                     return TreeTableView.this;
1563                 }
1564 
1565                 @Override public String getName() {
1566                     return &quot;onScrollTo&quot;;
1567                 }
1568             };
1569         }
1570         return onScrollTo;
1571     }
1572 
1573     /**
1574      * Scrolls the TreeTableView so that the given column is visible within the viewport.
1575      * @param column The column that should be visible to the user.
1576      */
1577     public void scrollToColumn(TreeTableColumn&lt;S, ?&gt; column) {
1578         ControlUtils.scrollToColumn(this, column);
1579     }
1580 
1581     /**
1582      * Scrolls the TreeTableView so that the given index is visible within the viewport.
1583      * @param columnIndex The index of a column that should be visible to the user.
1584      */
1585     public void scrollToColumnIndex(int columnIndex) {
1586         if( getColumns() != null ) {
1587             ControlUtils.scrollToColumn(this, getColumns().get(columnIndex));
1588         }
1589     }
1590 
1591     /**
1592      * Called when there&#39;s a request to scroll a column into view using {@link #scrollToColumn(TreeTableColumn)}
1593      * or {@link #scrollToColumnIndex(int)}
1594      */
1595     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumn;
1596 
1597     public void setOnScrollToColumn(EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; value) {
1598         onScrollToColumnProperty().set(value);
1599     }
1600 
1601     public EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; getOnScrollToColumn() {
1602         if( onScrollToColumn != null ) {
1603             return onScrollToColumn.get();
1604         }
1605         return null;
1606     }
1607 
1608     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumnProperty() {
1609         if( onScrollToColumn == null ) {
1610             onScrollToColumn = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt;() {
1611                 @Override
1612                 protected void invalidated() {
1613                     EventType&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; type = ScrollToEvent.scrollToColumn();
1614                     setEventHandler(type, get());
1615                 }
1616                 @Override
1617                 public Object getBean() {
1618                     return TreeTableView.this;
1619                 }
1620 
1621                 @Override
1622                 public String getName() {
1623                     return &quot;onScrollToColumn&quot;;
1624                 }
1625             };
1626         }
1627         return onScrollToColumn;
1628     }
1629 
1630     /**
1631      * Returns the index position of the given TreeItem, assuming that it is
1632      * currently accessible through the tree hierarchy (most notably, that all
1633      * parent tree items are expanded). If a parent tree item is collapsed,
1634      * the result is that this method will return -1 to indicate that the
1635      * given tree item is not accessible in the tree.
1636      *
1637      * @param item The TreeItem for which the index is sought.
1638      * @return An integer representing the location in the current TreeTableView of the
1639      *      first instance of the given TreeItem, or -1 if it is null or can not
1640      *      be found (for example, if a parent (all the way up to the root) is
1641      *      collapsed).
1642      */
1643     public int getRow(TreeItem&lt;S&gt; item) {
1644         return TreeUtil.getRow(item, getRoot(), expandedItemCountDirty, isShowRoot());
1645     }
1646 
1647     /**
1648      * Returns the TreeItem in the given index, or null if it is out of bounds.
1649      *
1650      * @param row The index of the TreeItem being sought.
1651      * @return The TreeItem in the given index, or null if it is out of bounds.
1652      */
1653     public TreeItem&lt;S&gt; getTreeItem(int row) {
1654         if (row &lt; 0) return null;
1655 
1656         // normalize the requested row based on whether showRoot is set
1657         final int _row = isShowRoot() ? row : (row + 1);
1658 
1659         if (expandedItemCountDirty) {
1660             updateExpandedItemCount(getRoot());
1661         } else {
1662             if (treeItemCacheMap.containsKey(_row)) {
1663                 SoftReference&lt;TreeItem&lt;S&gt;&gt; treeItemRef = treeItemCacheMap.get(_row);
1664                 TreeItem&lt;S&gt; treeItem = treeItemRef.get();
1665                 if (treeItem != null) {
1666                     return treeItem;
1667                 }
1668             }
1669         }
1670 
1671         TreeItem&lt;S&gt; treeItem = TreeUtil.getItem(getRoot(), _row, expandedItemCountDirty);
1672         treeItemCacheMap.put(_row, new SoftReference&lt;&gt;(treeItem));
1673         return treeItem;
1674     }
1675 
1676     /**
1677      * Returns the number of levels of &#39;indentation&#39; of the given TreeItem,
1678      * based on how many times getParent() can be recursively called. If the
1679      * given TreeItem is the root node of this TreeTableView, or if the TreeItem
1680      * does not have any parent set, the returned value will be zero. For each
1681      * time getParent() is recursively called, the returned value is incremented
1682      * by one.
1683      *
1684      * @param node The TreeItem for which the level is needed.
1685      * @return An integer representing the number of parents above the given node,
1686      *         or -1 if the given TreeItem is null.
1687      */
1688     public int getTreeItemLevel(TreeItem&lt;?&gt; node) {
1689         final TreeItem&lt;?&gt; root = getRoot();
1690 
1691         if (node == null) return -1;
1692         if (node == root) return 0;
1693 
1694         int level = 0;
1695         TreeItem&lt;?&gt; parent = node.getParent();
1696         while (parent != null) {
1697             level++;
1698 
1699             if (parent == root) {
1700                 break;
1701             }
1702 
1703             parent = parent.getParent();
1704         }
1705 
1706         return level;
1707     }
1708 
1709     /**
1710      * The TreeTableColumns that are part of this TableView. As the user reorders
1711      * the TableView columns, this list will be updated to reflect the current
1712      * visual ordering.
1713      *
1714      * &lt;p&gt;Note: to display any data in a TableView, there must be at least one
1715      * TreeTableColumn in this ObservableList.&lt;/p&gt;
1716      * @return the table table column
1717      */
1718     public final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getColumns() {
1719         return columns;
1720     }
1721 
1722     /**
1723      * The sortOrder list defines the order in which {@link TreeTableColumn} instances
1724      * are sorted. An empty sortOrder list means that no sorting is being applied
1725      * on the TableView. If the sortOrder list has one TreeTableColumn within it,
1726      * the TableView will be sorted using the
1727      * {@link TreeTableColumn#sortTypeProperty() sortType} and
1728      * {@link TreeTableColumn#comparatorProperty() comparator} properties of this
1729      * TreeTableColumn (assuming
1730      * {@link TreeTableColumn#sortableProperty() TreeTableColumn.sortable} is true).
1731      * If the sortOrder list contains multiple TreeTableColumn instances, then
1732      * the TableView is firstly sorted based on the properties of the first
1733      * TreeTableColumn. If two elements are considered equal, then the second
1734      * TreeTableColumn in the list is used to determine ordering. This repeats until
1735      * the results from all TreeTableColumn comparators are considered, if necessary.
1736      *
1737      * @return An ObservableList containing zero or more TreeTableColumn instances.
1738      */
1739     public final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getSortOrder() {
1740         return sortOrder;
1741     }
1742 
1743     /**
1744      * Applies the currently installed resize policy against the given column,
1745      * resizing it based on the delta value provided.
1746      * @param column the column
1747      * @param delta the delta
1748      * @return true if column resizing is applied
1749      */
1750     public boolean resizeColumn(TreeTableColumn&lt;S,?&gt; column, double delta) {
1751         if (column == null || Double.compare(delta, 0.0) == 0) return false;
1752 
1753         boolean allowed = getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, column, delta));
1754         if (!allowed) return false;
1755         return true;
1756     }
1757 
1758     /**
1759      * Causes the cell at the given row/column view indexes to switch into
1760      * its editing state, if it is not already in it, and assuming that the
1761      * TableView and column are also editable.
1762      * @param row the row
1763      * @param column the column
1764      */
1765     public void edit(int row, TreeTableColumn&lt;S,?&gt; column) {
1766         if (!isEditable() || (column != null &amp;&amp; ! column.isEditable())) {
1767             return;
1768         }
1769 
1770         if (row &lt; 0 &amp;&amp; column == null) {
1771             setEditingCell(null);
1772         } else {
1773             setEditingCell(new TreeTablePosition&lt;&gt;(this, row, column));
1774         }
1775     }
1776 
1777     /**
1778      * Returns an unmodifiable list containing the currently visible leaf columns.
1779      * @return an unmodifiable list containing the currently visible leaf columns
1780      */
1781     public ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getVisibleLeafColumns() {
1782         return unmodifiableVisibleLeafColumns;
1783     }
1784 
1785     /**
1786      * Returns the position of the given column, relative to all other
1787      * visible leaf columns.
1788      * @param column the column
1789      * @return the position of the given column, relative to all other
1790      * visible leaf columns
1791      */
1792     public int getVisibleLeafIndex(TreeTableColumn&lt;S,?&gt; column) {
1793         return getVisibleLeafColumns().indexOf(column);
1794     }
1795 
1796     /**
1797      * Returns the TreeTableColumn in the given column index, relative to all other
1798      * visible leaf columns.
1799      * @param column the column
1800      * @return the TreeTableColumn in the given column index, relative to all other
1801      * visible leaf columns
1802      */
1803     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1804         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1805         return visibleLeafColumns.get(column);
1806     }
1807 
1808     private boolean sortingInProgress;
1809     boolean isSortingInProgress() {
1810         return sortingInProgress;
1811     }
1812 
<a name="1" id="anc1"></a>




1813     /**
1814      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1815      * often than not it is not necessary to call this method directly, as it is
1816      * automatically called when the {@link #getSortOrder() sort order},
1817      * {@link #sortPolicyProperty() sort policy}, or the state of the
1818      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1819      * change. In other words, this method should only be called directly when
1820      * something external changes and a sort is required.
1821      */
1822     public void sort() {
1823         sortingInProgress = true;
1824         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1825 
1826         // update the Comparator property
1827         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1828         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1829 
1830         // fire the onSort event and check if it is consumed, if
1831         // so, don&#39;t run the sort
1832         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
1833         fireEvent(sortEvent);
1834         if (sortEvent.isConsumed()) {
1835             // if the sort is consumed we could back out the last action (the code
1836             // is commented out right below), but we don&#39;t as we take it as a
1837             // sign that the developer has decided to handle the event themselves.
1838 
1839             // sortLock = true;
1840             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1841             // sortLock = false;
1842             sortingInProgress = false;
1843             return;
1844         }
1845 
1846         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1847         final int itemCount = prevState.size();
1848 
1849         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1850         // sort events - instead we send a single permutation event at the end
1851         // of this method.
1852         getSelectionModel().startAtomic();
1853 
1854         // get the sort policy and run it
1855         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
1856         if (sortPolicy == null) return;
1857         Boolean success = sortPolicy.call(this);
1858 
<a name="2" id="anc2"></a><span class="line-modified">1859         if (getSortMode() == TreeSortMode.ALL_DESCENDANTS) {</span>
1860             Set&lt;TreeItem&lt;S&gt;&gt; sortedParents = new HashSet&lt;&gt;();
1861             for (TreeTablePosition&lt;S,?&gt; selectedPosition : prevState) {
1862                 TreeItem&lt;S&gt; parent = selectedPosition.getTreeItem().getParent();
1863                 while (parent != null &amp;&amp; sortedParents.add(parent)) {
1864                     parent.getChildren();
1865                     parent = parent.getParent();
1866                 }
1867             }
1868         }
1869         getSelectionModel().stopAtomic();
1870 
1871         if (success == null || ! success) {
1872             // the sort was a failure. Need to backout if possible
1873             sortLock = true;
1874             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1875             setComparator(oldComparator);
1876             sortLock = false;
1877         } else {
1878             // sorting was a success, now we possibly fire an event on the
1879             // selection model that the items list has &#39;permutated&#39; to a new ordering
1880 
1881             // FIXME we should support alternative selection model implementations!
1882             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1883                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1884                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1885 
1886                 List&lt;TreeTablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
1887                 for (int i = 0; i &lt; itemCount; i++) {
1888                     TreeTablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
1889                     if (!newState.contains(prevItem)) {
1890                         removed.add(prevItem);
1891                     }
1892                 }
1893                 if (!removed.isEmpty()) {
1894                     // the sort operation effectively permutates the selectedCells list,
1895                     // but we cannot fire a permutation event as we are talking about
1896                     // TreeTablePosition&#39;s changing (which may reside in the same list
1897                     // position before and after the sort). Therefore, we need to fire
1898                     // a single add/remove event to cover the added and removed positions.
1899                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
1900                     sm.fireCustomSelectedCellsListChangeEvent(c);
1901                 }
1902             }
1903             getSelectionModel().setSelectedIndex(getRow(getSelectionModel().getSelectedItem()));
1904             getFocusModel().focus(getSelectionModel().getSelectedIndex());
1905         }
1906         sortingInProgress = false;
1907     }
1908 
1909     /**
1910      * Calling {@code refresh()} forces the TreeTableView control to recreate and
1911      * repopulate the cells necessary to populate the visual bounds of the control.
1912      * In other words, this forces the TreeTableView to update what it is showing to
1913      * the user. This is useful in cases where the underlying data source has
1914      * changed in a way that is not observed by the TreeTableView itself.
1915      *
1916      * @since JavaFX 8u60
1917      */
1918     public void refresh() {
1919         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1920     }
1921 
1922 
1923 
1924     /***************************************************************************
1925      *                                                                         *
1926      * Private Implementation                                                  *
1927      *                                                                         *
1928      **************************************************************************/
1929 
1930     private boolean sortLock = false;
1931     private TableUtil.SortEventType lastSortEventType = null;
1932     private Object[] lastSortEventSupportInfo = null;
1933 
1934     private void doSort(final TableUtil.SortEventType sortEventType, final Object... supportInfo) {
1935         if (sortLock) {
1936             return;
1937         }
1938 
1939         this.lastSortEventType = sortEventType;
1940         this.lastSortEventSupportInfo = supportInfo;
1941         sort();
1942         this.lastSortEventType = null;
1943         this.lastSortEventSupportInfo = null;
1944     }
1945 
1946     private void updateExpandedItemCount(TreeItem&lt;S&gt; treeItem) {
1947         setExpandedItemCount(TreeUtil.updateExpandedItemCount(treeItem, expandedItemCountDirty, isShowRoot()));
1948 
1949         if (expandedItemCountDirty) {
1950             // this is a very inefficient thing to do, but for now having a cache
1951             // is better than nothing at all...
1952             treeItemCacheMap.clear();
1953         }
1954 
1955         expandedItemCountDirty = false;
1956     }
1957 
1958     private void updateRootExpanded() {
1959         // if we aren&#39;t showing the root, and the root isn&#39;t expanded, we expand
1960         // it now so that something is shown.
1961         if (!isShowRoot() &amp;&amp; getRoot() != null &amp;&amp; ! getRoot().isExpanded()) {
1962             getRoot().setExpanded(true);
1963         }
1964     }
1965 
1966 
1967     // --- Content width
1968     private void setContentWidth(double contentWidth) {
1969         this.contentWidth = contentWidth;
1970         if (isInited) {
1971             // sometimes the current column resize policy will have to modify the
1972             // column width of all columns in the table if the table width changes,
1973             // so we short-circuit the resize function and just go straight there
1974             // with a null TreeTableColumn, which indicates to the resize policy function
1975             // that it shouldn&#39;t actually do anything specific to one column.
1976             getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, null, 0.0));
1977         }
1978     }
1979 
1980     /**
1981      * Recomputes the currently visible leaf columns in this TableView.
1982      */
1983     private void updateVisibleLeafColumns() {
1984         // update visible leaf columns list
1985         List&lt;TreeTableColumn&lt;S,?&gt;&gt; cols = new ArrayList&lt;TreeTableColumn&lt;S,?&gt;&gt;();
1986         buildVisibleLeafColumns(getColumns(), cols);
1987         visibleLeafColumns.setAll(cols);
1988 
1989         // sometimes the current column resize policy will have to modify the
1990         // column width of all columns in the table if the table width changes,
1991         // so we short-circuit the resize function and just go straight there
1992         // with a null TreeTableColumn, which indicates to the resize policy function
1993         // that it shouldn&#39;t actually do anything specific to one column.
1994         getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, null, 0.0));
1995     }
1996 
1997     private void buildVisibleLeafColumns(List&lt;TreeTableColumn&lt;S,?&gt;&gt; cols, List&lt;TreeTableColumn&lt;S,?&gt;&gt; vlc) {
1998         for (TreeTableColumn&lt;S,?&gt; c : cols) {
1999             if (c == null) continue;
2000 
2001             boolean hasChildren = ! c.getColumns().isEmpty();
2002 
2003             if (hasChildren) {
2004                 buildVisibleLeafColumns(c.getColumns(), vlc);
2005             } else if (c.isVisible()) {
2006                 vlc.add(c);
2007             }
2008         }
2009     }
2010 
2011 
2012 
2013     /***************************************************************************
2014      *                                                                         *
2015      * Stylesheet Handling                                                     *
2016      *                                                                         *
2017      **************************************************************************/
2018 
2019     private static final String DEFAULT_STYLE_CLASS = &quot;tree-table-view&quot;;
2020 
2021     private static final PseudoClass PSEUDO_CLASS_CELL_SELECTION =
2022             PseudoClass.getPseudoClass(&quot;cell-selection&quot;);
2023     private static final PseudoClass PSEUDO_CLASS_ROW_SELECTION =
2024             PseudoClass.getPseudoClass(&quot;row-selection&quot;);
2025 
2026     private static class StyleableProperties {
2027         private static final CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
2028                 new CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
2029                                                      SizeConverter.getInstance(),
2030                                                      Region.USE_COMPUTED_SIZE) {
2031 
2032                     @Override public Double getInitialValue(TreeTableView&lt;?&gt; node) {
2033                         return node.getFixedCellSize();
2034                     }
2035 
2036                     @Override public boolean isSettable(TreeTableView&lt;?&gt; n) {
2037                         return n.fixedCellSize == null || !n.fixedCellSize.isBound();
2038                     }
2039 
2040                     @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(TreeTableView&lt;?&gt; n) {
2041                         return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;) n.fixedCellSizeProperty();
2042                     }
2043                 };
2044 
2045         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
2046         static {
2047             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
2048                     new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
2049             styleables.add(FIXED_CELL_SIZE);
2050             STYLEABLES = Collections.unmodifiableList(styleables);
2051         }
2052     }
2053 
2054     /**
2055      * @return The CssMetaData associated with this class, which may include the
2056      * CssMetaData of its superclasses.
2057      */
2058     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
2059         return StyleableProperties.STYLEABLES;
2060     }
2061 
2062     /**
2063      * {@inheritDoc}
2064      * @since JavaFX 8.0
2065      */
2066     @Override
2067     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
2068         return getClassCssMetaData();
2069     }
2070 
2071     /** {@inheritDoc} */
2072     @Override protected Skin&lt;?&gt; createDefaultSkin() {
2073         return new TreeTableViewSkin&lt;S&gt;(this);
2074     }
2075 
2076 
2077 
2078     /***************************************************************************
2079      *                                                                         *
2080      * Accessibility handling                                                  *
2081      *                                                                         *
2082      **************************************************************************/
2083 
2084     /** {@inheritDoc} */
2085     @Override
2086     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
2087         switch (attribute) {
2088             case ROW_COUNT: return getExpandedItemCount();
2089             case COLUMN_COUNT: return getVisibleLeafColumns().size();
2090 
2091             /*
2092              * TreeTableViewSkin returns TreeTableRows back to TreeTableView.
2093              * TreeTableRowSkin returns TreeTableCells back to TreeTableRow.
2094              */
2095             case SELECTED_ITEMS: {
2096                 @SuppressWarnings(&quot;unchecked&quot;)
2097                 ObservableList&lt;TreeTableRow&lt;S&gt;&gt; rows = (ObservableList&lt;TreeTableRow&lt;S&gt;&gt;)super.queryAccessibleAttribute(attribute, parameters);
2098                 List&lt;Node&gt; selection = new ArrayList&lt;&gt;();
2099                 for (TreeTableRow&lt;S&gt; row : rows) {
2100                     @SuppressWarnings(&quot;unchecked&quot;)
2101                     ObservableList&lt;Node&gt; cells = (ObservableList&lt;Node&gt;)row.queryAccessibleAttribute(attribute, parameters);
2102                     if (cells != null) selection.addAll(cells);
2103                 }
2104                 return FXCollections.observableArrayList(selection);
2105             }
2106             case FOCUS_ITEM: {
2107                 Node row = (Node)super.queryAccessibleAttribute(attribute, parameters);
2108                 if (row == null) return null;
2109                 Node cell = (Node)row.queryAccessibleAttribute(attribute, parameters);
2110                 /* cell equals to null means the row is a placeholder node */
2111                 return cell != null ?  cell : row;
2112             }
2113             case CELL_AT_ROW_COLUMN: {
2114                 @SuppressWarnings(&quot;unchecked&quot;)
2115                 TreeTableRow&lt;S&gt; row = (TreeTableRow&lt;S&gt;)super.queryAccessibleAttribute(attribute, parameters);
2116                 return row != null ? row.queryAccessibleAttribute(attribute, parameters) : null;
2117             }
2118             case MULTIPLE_SELECTION: {
2119                 TreeTableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
2120                 return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
2121             }
2122             default: return super.queryAccessibleAttribute(attribute, parameters);
2123         }
2124     }
2125 
2126     /***************************************************************************
2127      *                                                                         *
2128      * Support Classes                                                         *
2129      *                                                                         *
2130      **************************************************************************/
2131 
2132      /**
2133       * An immutable wrapper class for use in the TableView
2134      * {@link TreeTableView#columnResizePolicyProperty() column resize} functionality.
2135       * @since JavaFX 8.0
2136       */
2137      public static class ResizeFeatures&lt;S&gt; extends ResizeFeaturesBase&lt;TreeItem&lt;S&gt;&gt; {
2138         private TreeTableView&lt;S&gt; treeTable;
2139 
2140         /**
2141          * Creates an instance of this class, with the provided TreeTableView,
2142          * TreeTableColumn and delta values being set and stored in this immutable
2143          * instance.
2144          *
2145          * @param treeTable The TreeTableView upon which the resize operation is occurring.
2146          * @param column The column upon which the resize is occurring, or null
2147          *      if this ResizeFeatures instance is being created as a result of a
2148          *      TreeTableView resize operation.
2149          * @param delta The amount of horizontal space added or removed in the
2150          *      resize operation.
2151          */
2152         public ResizeFeatures(TreeTableView&lt;S&gt; treeTable, TreeTableColumn&lt;S,?&gt; column, Double delta) {
2153             super(column, delta);
2154             this.treeTable = treeTable;
2155         }
2156 
2157         /**
2158          * Returns the column upon which the resize is occurring, or null
2159          * if this ResizeFeatures instance was created as a result of a
2160          * TreeTableView resize operation.
2161          */
2162         @Override public TreeTableColumn&lt;S,?&gt; getColumn() {
2163             return (TreeTableColumn&lt;S,?&gt;) super.getColumn();
2164         }
2165 
2166         /**
2167          * Returns the TreeTableView upon which the resize operation is occurring.
2168          * @return the TreeTableView upon which the resize operation is occurring
2169          */
2170         public TreeTableView&lt;S&gt; getTable() { return treeTable; }
2171     }
2172 
2173 
2174 
2175     /**
2176      * An {@link Event} subclass used specifically in TreeTableView for representing
2177      * edit-related events. It provides additional API to easily access the
2178      * TreeItem that the edit event took place on, as well as the input provided
2179      * by the end user.
2180      *
2181      * @param &lt;S&gt; The type of the input, which is the same type as the TreeTableView
2182      *      itself.
2183      * @since JavaFX 8.0
2184      */
2185     public static class EditEvent&lt;S&gt; extends Event {
2186         private static final long serialVersionUID = -4437033058917528976L;
2187 
2188         /**
2189          * Common supertype for all edit event types.
2190          */
2191         public static final EventType&lt;?&gt; ANY = EDIT_ANY_EVENT;
2192 
2193         private final TreeTableView&lt;S&gt; source;
2194         private final S oldValue;
2195         private final S newValue;
2196         private transient final TreeItem&lt;S&gt; treeItem;
2197 
2198         /**
2199          * Creates a new EditEvent instance to represent an edit event. This
2200          * event is used for {@link #editStartEvent()},
2201          * {@link #editCommitEvent()} and {@link #editCancelEvent()} types.
2202          * @param source the source
2203          * @param eventType the eventType
2204          * @param treeItem the treeItem
2205          * @param oldValue the oldValue
2206          * @param newValue the newValue
2207          */
2208         public EditEvent(TreeTableView&lt;S&gt; source,
2209                          EventType&lt;? extends TreeTableView.EditEvent&gt; eventType,
2210                          TreeItem&lt;S&gt; treeItem, S oldValue, S newValue) {
2211             super(source, Event.NULL_SOURCE_TARGET, eventType);
2212             this.source = source;
2213             this.oldValue = oldValue;
2214             this.newValue = newValue;
2215             this.treeItem = treeItem;
2216         }
2217 
2218         /**
2219          * Returns the TreeTableView upon which the edit took place.
2220          * @return the TreeTableView upon which the edit took place
2221          */
2222         @Override public TreeTableView&lt;S&gt; getSource() {
2223             return source;
2224         }
2225 
2226         /**
2227          * Returns the {@link TreeItem} upon which the edit took place.
2228          * @return the {@link TreeItem} upon which the edit took place
2229          */
2230         public TreeItem&lt;S&gt; getTreeItem() {
2231             return treeItem;
2232         }
2233 
2234         /**
2235          * Returns the new value input into the TreeItem by the end user.
2236          * @return the new value input into the TreeItem by the end user
2237          */
2238         public S getNewValue() {
2239             return newValue;
2240         }
2241 
2242         /**
2243          * Returns the old value that existed in the TreeItem prior to the current
2244          * edit event.
2245          * @return the old value that existed in the TreeItem prior to the current
2246          * edit event
2247          */
2248         public S getOldValue() {
2249             return oldValue;
2250         }
2251     }
2252 
2253 
2254 
2255      /**
2256      * A simple extension of the {@link SelectionModel} abstract class to
2257      * allow for special support for TreeTableView controls.
2258       *
2259      * @since JavaFX 8.0
2260      */
2261     public static abstract class TreeTableViewSelectionModel&lt;S&gt; extends
2262             TableSelectionModel&lt;TreeItem&lt;S&gt;&gt; {
2263 
2264         /***********************************************************************
2265          *                                                                     *
2266          * Private fields                                                      *
2267          *                                                                     *
2268          **********************************************************************/
2269 
2270         private final TreeTableView&lt;S&gt; treeTableView;
2271 
2272 
2273         /***********************************************************************
2274          *                                                                     *
2275          * Constructors                                                        *
2276          *                                                                     *
2277          **********************************************************************/
2278 
2279         /**
2280          * Builds a default TreeTableViewSelectionModel instance with the provided
2281          * TreeTableView.
2282          * @param treeTableView The TreeTableView upon which this selection model should
2283          *      operate.
2284          * @throws NullPointerException TreeTableView can not be null.
2285          */
2286         public TreeTableViewSelectionModel(final TreeTableView&lt;S&gt; treeTableView) {
2287             if (treeTableView == null) {
2288                 throw new NullPointerException(&quot;TreeTableView can not be null&quot;);
2289             }
2290 
2291             this.treeTableView = treeTableView;
2292         }
2293 
2294 
2295 
2296         /***********************************************************************
2297          *                                                                     *
2298          * Abstract API                                                        *
2299          *                                                                     *
2300          **********************************************************************/
2301 
2302          /**
2303          * A read-only ObservableList representing the currently selected cells
2304          * in this TreeTableView. Rather than directly modify this list, please
2305          * use the other methods provided in the TreeTableViewSelectionModel.
2306          * @return a list of selected cells
2307          */
2308         public abstract ObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; getSelectedCells();
2309 
2310 
2311 
2312         /***********************************************************************
2313          *                                                                     *
2314          * Public API                                                          *
2315          *                                                                     *
2316          **********************************************************************/
2317 
2318          /**
2319           * Returns the TreeTableView instance that this selection model is installed in.
2320          * @return the TreeTableView instance that this selection model is installed in
2321           */
2322          public TreeTableView&lt;S&gt; getTreeTableView() {
2323              return treeTableView;
2324          }
2325 
2326          /** {@inheritDoc} */
2327          @Override public TreeItem&lt;S&gt; getModelItem(int index) {
2328              return treeTableView.getTreeItem(index);
2329          }
2330 
2331          /** {@inheritDoc} */
2332          @Override protected int getItemCount() {
2333              return treeTableView.getExpandedItemCount();
2334          }
2335 
2336          /** {@inheritDoc} */
2337          @Override public void focus(int row) {
2338              focus(row, null);
2339          }
2340 
2341          /** {@inheritDoc} */
2342          @Override public int getFocusedIndex() {
2343              return getFocusedCell().getRow();
2344          }
2345 
2346          /** {@inheritDoc} */
2347          @Override public void selectRange(int minRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; minColumn,
2348                                            int maxRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; maxColumn) {
2349              final int minColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)minColumn);
2350              final int maxColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)maxColumn);
2351              for (int _row = minRow; _row &lt;= maxRow; _row++) {
2352                  for (int _col = minColumnIndex; _col &lt;= maxColumnIndex; _col++) {
2353                      select(_row, treeTableView.getVisibleLeafColumn(_col));
2354                  }
2355              }
2356          }
2357 
2358 
2359 
2360         /***********************************************************************
2361          *                                                                     *
2362          * Private implementation                                              *
2363          *                                                                     *
2364          **********************************************************************/
2365 
2366          private void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
2367              focus(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column));
2368          }
2369 
2370          private void focus(TreeTablePosition&lt;S,?&gt; pos) {
2371              if (getTreeTableView().getFocusModel() == null) return;
2372 
2373              getTreeTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
2374          }
2375 
2376          private TreeTablePosition&lt;S,?&gt; getFocusedCell() {
2377              if (treeTableView.getFocusModel() == null) {
2378                  return new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
2379              }
2380              return treeTableView.getFocusModel().getFocusedCell();
2381          }
2382      }
2383 
2384 
2385 
2386     /**
2387      * A primitive selection model implementation, using a List&lt;Integer&gt; to store all
2388      * selected indices.
2389      */
2390     // package for testing
2391     static class TreeTableViewArrayListSelectionModel&lt;S&gt; extends TreeTableViewSelectionModel&lt;S&gt; {
2392 
2393         private final MappingChange.Map&lt;TreeTablePosition&lt;S,?&gt;,Integer&gt; cellToIndicesMap = f -&gt; f.getRow();
2394 
2395         private TreeTableView&lt;S&gt; treeTableView = null;
2396 
2397         /***********************************************************************
2398          *                                                                     *
2399          * Constructors                                                        *
2400          *                                                                     *
2401          **********************************************************************/
2402 
2403         public TreeTableViewArrayListSelectionModel(final TreeTableView&lt;S&gt; treeTableView) {
2404             super(treeTableView);
2405             this.treeTableView = treeTableView;
2406 
2407             this.treeTableView.rootProperty().addListener(weakRootPropertyListener);
2408             this.treeTableView.showRootProperty().addListener(showRootPropertyListener);
2409             updateTreeEventListener(null, treeTableView.getRoot());
2410 
2411             selectedCellsMap = new SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt;(this::fireCustomSelectedCellsListChangeEvent) {
2412                 @Override public boolean isCellSelectionEnabled() {
2413                     return TreeTableViewArrayListSelectionModel.this.isCellSelectionEnabled();
2414                 }
2415             };
2416 
2417             selectedCellsSeq = new ReadOnlyUnbackedObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt;() {
2418                 @Override public TreeTablePosition&lt;S,?&gt; get(int i) {
2419                     return selectedCellsMap.get(i);
2420                 }
2421 
2422                 @Override public int size() {
2423                     return selectedCellsMap.size();
2424                 }
2425             };
2426 //            selectedCellsSeq.addListener((ListChangeListener&lt;? super TreeTablePosition&lt;S,?&gt;&gt;) c -&gt; {
2427 //                ControlUtils.updateSelectedIndices(this, c);
2428 //            });
2429 
2430             updateDefaultSelection();
2431 
2432             cellSelectionEnabledProperty().addListener(o -&gt; {
2433                 updateDefaultSelection();
2434                 TableCellBehaviorBase.setAnchor(treeTableView, getFocusedCell(), true);
2435             });
2436         }
2437 
2438         private void dispose() {
2439             this.treeTableView.rootProperty().removeListener(weakRootPropertyListener);
2440             this.treeTableView.showRootProperty().removeListener(showRootPropertyListener);
2441 
2442             TreeItem&lt;S&gt; root = this.treeTableView.getRoot();
2443             if (root != null) {
2444                 root.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
2445             }
2446         }
2447 
2448         private void updateTreeEventListener(TreeItem&lt;S&gt; oldRoot, TreeItem&lt;S&gt; newRoot) {
2449             if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
2450                 oldRoot.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
2451             }
2452 
2453             if (newRoot != null) {
2454                 weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
2455                 newRoot.addEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
2456             }
2457         }
2458 
2459         private ChangeListener&lt;TreeItem&lt;S&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
2460             updateDefaultSelection();
2461 
2462             updateTreeEventListener(oldValue, newValue);
2463         };
2464 
2465         private InvalidationListener showRootPropertyListener = o -&gt; {
2466             shiftSelection(0, treeTableView.isShowRoot() ? 1 : -1, null);
2467         };
2468 
2469         private EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; treeItemListener = new EventHandler&lt;&gt;() {
2470             @Override public void handle(TreeItem.TreeModificationEvent&lt;S&gt; e) {
2471 
2472                 if (getSelectedIndex() == -1 &amp;&amp; getSelectedItem() == null) return;
2473 
2474                 final TreeItem&lt;S&gt; treeItem = e.getTreeItem();
2475                 if (treeItem == null) return;
2476 
2477                 final int oldSelectedIndex = getSelectedIndex();
2478 
2479                 treeTableView.expandedItemCountDirty = true;
2480 
2481                 // we only shift selection from this row - everything before it
2482                 // is safe. We might change this below based on certain criteria
2483                 int startRow = treeTableView.getRow(treeItem);
2484 
2485                 int shift = 0;
2486                 ListChangeListener.Change&lt;? extends TreeItem&lt;?&gt;&gt; change = e.getChange();
2487                 if (change != null) {
2488                     change.next();
2489                 }
2490 
2491                 do {
2492                     final int addedSize = change == null ? 0 : change.getAddedSize();
2493                     final int removedSize = change == null ? 0 : change.getRemovedSize();
2494 
2495                     if (e.wasExpanded()) {
2496                         // need to shuffle selection by the number of visible children
2497                         shift += treeItem.getExpandedDescendentCount(false) - 1;
2498                         startRow++;
2499                     } else if (e.wasCollapsed()) {
2500                         // remove selection from any child treeItem, and also determine
2501                         // if any child item was selected (in which case the parent
2502                         // takes the selection on collapse)
2503                         treeItem.getExpandedDescendentCount(false);
2504                         final int count = treeItem.previousExpandedDescendentCount;
2505 
2506                         final int selectedIndex = getSelectedIndex();
2507                         final boolean wasPrimarySelectionInChild =
2508                                 selectedIndex &gt;= (startRow + 1) &amp;&amp;
2509                                         selectedIndex &lt; (startRow + count);
2510 
2511                         boolean wasAnyChildSelected = false;
2512                         final boolean isCellSelectionMode = isCellSelectionEnabled();
2513                         ObservableList&lt;TreeTableColumn&lt;S, ?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2514 
2515                         selectedIndices._beginChange();
2516                         final int from = startRow + 1;
2517                         final int to = startRow + count;
2518                         final List&lt;Integer&gt; removed = new ArrayList&lt;&gt;();
2519                         TreeTableColumn&lt;S, ?&gt; selectedColumn = null;
2520                         for (int i = from; i &lt; to; i++) {
2521                             // we have to handle cell selection mode differently than
2522                             // row selection mode. Refer to RT-34103 for the bug report
2523                             // that drove this change, but in short the issue was that
2524                             // when collapsing a branch that had selection, we were
2525                             // always calling isSelected(row), but that always returns
2526                             // false in cell selection mode.
2527                             if (isCellSelectionMode) {
2528                                 for (int column = 0; column &lt; columns.size(); column++) {
2529                                     final TreeTableColumn&lt;S, ?&gt; col = columns.get(column);
2530                                     if (isSelected(i, col)) {
2531                                         wasAnyChildSelected = true;
2532                                         clearSelection(i, col);
2533                                         selectedColumn = col;
2534                                     }
2535                                 }
2536                             } else {
2537                                 if (isSelected(i)) {
2538                                     wasAnyChildSelected = true;
2539                                     removed.add(i);
2540                                 }
2541                             }
2542                         }
2543 
2544                         ControlUtils.reducingChange(selectedIndices, removed);
2545 
2546                         for (int index : removed) {
2547                             startAtomic();
2548                             // we pass in false here to prevent a lookup into the TreeItem, as it is unnecessary
2549                             // and results in JDK-8152396
2550                             clearSelection(new TreeTablePosition&lt;&gt;(treeTableView, index, null, false));
2551                             stopAtomic();
2552                         }
2553                         selectedIndices._endChange();
2554 
2555                         // put selection onto the newly-collapsed tree item
2556                         if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
2557                             select(startRow, selectedColumn);
2558                         }
2559 
2560                         shift += -count + 1;
2561                         startRow++;
2562                     } else if (e.wasPermutated()) {
2563                         // Approach:
2564                         // Get the current selection.
2565                         // Create a new selection with updated index(row).
2566                         // Update the current selection with new selection.
2567                         // If sorting is in progress then one Selection change event will be sent from
2568                         // TreeTableView.sort() method, and should not be sent from here.
2569                         // else, in case otherwise, the selection change events would be generated.
2570                         // Do not call shiftSelection() in case of permutation change(when shift == 0).
2571 
2572                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; currentSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());
2573                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; updatedSelection = new ArrayList&lt;&gt;();
2574 
2575                         boolean selectionIndicesChanged = false;
2576                         for (TreeTablePosition&lt;S, ?&gt; selectedCell : currentSelection) {
2577                             int newRow = treeTableView.getRow(selectedCell.getTreeItem());
2578                             if (selectedCell.getRow() != newRow) {
2579                                 selectionIndicesChanged = true;
2580                             }
2581                             updatedSelection.add(new TreeTablePosition&lt;&gt;(selectedCell, newRow));
2582                         }
2583                         if (selectionIndicesChanged) {
2584                             if (treeTableView.isSortingInProgress()) {
2585                                 startAtomic();
2586                                 selectedCellsMap.setAll(updatedSelection);
2587                                 stopAtomic();
2588                             } else {
2589                                 startAtomic();
2590                                 quietClearSelection();
2591                                 stopAtomic();
2592                                 selectedCellsMap.setAll(updatedSelection);
2593                                 int selectedIndex = treeTableView.getRow(getSelectedItem());
2594                                 setSelectedIndex(selectedIndex);
2595                                 focus(selectedIndex);
2596                             }
2597                         }
2598                     } else if (e.wasAdded()) {
2599                         // shuffle selection by the number of added items
2600                         shift += treeItem.isExpanded() ? addedSize : 0;
2601 
2602                         // RT-32963: We were taking the startRow from the TreeItem
2603                         // in which the children were added, rather than from the
2604                         // actual position of the new child. This led to selection
2605                         // being moved off the parent TreeItem by mistake.
2606                         // The &#39;if (e.getAddedSize() == 1)&#39; condition here was
2607                         // subsequently commented out due to RT-33894.
2608                         startRow = treeTableView.getRow(e.getChange().getAddedSubList().get(0));
2609 
2610                         TreeTablePosition&lt;S, ?&gt; anchor = TreeTableCellBehavior.getAnchor(treeTableView, null);
2611                         if (anchor != null) {
2612                             boolean isAnchorSelected = isSelected(anchor.getRow(), anchor.getTableColumn());
2613                             if (isAnchorSelected) {
2614                                 TreeTablePosition&lt;S, ?&gt; newAnchor = new TreeTablePosition&lt;&gt;(treeTableView, anchor.getRow() + shift, anchor.getTableColumn());
2615                                 TreeTableCellBehavior.setAnchor(treeTableView, newAnchor, false);
2616                             }
2617                         }
2618                     } else if (e.wasRemoved()) {
2619                         // shuffle selection by the number of removed items
2620                         shift += treeItem.isExpanded() ? -removedSize : 0;
2621 
2622                         // the start row is incorrect - it is _not_ the index of the
2623                         // TreeItem in which the children were removed from (which is
2624                         // what it currently represents). We need to take the &#39;from&#39;
2625                         // value out of the event and make use of that to understand
2626                         // what actually changed inside the children list.
2627                         startRow += e.getFrom() + 1;
2628 
2629                         // whilst we are here, we should check if the removed items
2630                         // are part of the selectedItems list - and remove them
2631                         // from selection if they are (as per RT-15446)
2632                         final List&lt;Integer&gt; selectedIndices = getSelectedIndices();
2633                         final List&lt;TreeItem&lt;S&gt;&gt; selectedItems = getSelectedItems();
2634                         final TreeItem&lt;S&gt; selectedItem = getSelectedItem();
2635                         final List&lt;? extends TreeItem&lt;S&gt;&gt; removedChildren = e.getChange().getRemoved();
2636 
2637                         for (int i = 0; i &lt; selectedIndices.size() &amp;&amp; !selectedItems.isEmpty(); i++) {
2638                             int index = selectedIndices.get(i);
2639                             if (index &gt; selectedItems.size()) break;
2640 
2641                             if (removedChildren.size() == 1 &amp;&amp;
2642                                     selectedItems.size() == 1 &amp;&amp;
2643                                     selectedItem != null &amp;&amp;
2644                                     selectedItem.equals(removedChildren.get(0))) {
2645                                 // Bug fix for RT-28637
2646                                 if (oldSelectedIndex &lt; getItemCount()) {
2647                                     final int previousRow = oldSelectedIndex == 0 ? 0 : oldSelectedIndex - 1;
2648                                     TreeItem&lt;S&gt; newSelectedItem = getModelItem(previousRow);
2649                                     if (!selectedItem.equals(newSelectedItem)) {
2650                                         clearAndSelect(previousRow);
2651                                     }
2652                                 }
2653                             }
2654                         }
2655                     }
2656                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
2657 
2658                 if (shift != 0) {
2659                     shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {
2660                         @Override public Void call(ShiftParams param) {
2661 
2662                             // we make the shifts atomic, as otherwise listeners to
2663                             // the items / indices lists get a lot of intermediate
2664                             // noise. They eventually get the summary event fired
2665                             // from within shiftSelection, so this is ok.
2666                             startAtomic();
2667 
2668                             final int clearIndex = param.getClearIndex();
2669                             final int setIndex = param.getSetIndex();
2670                             TreeTablePosition&lt;S,?&gt; oldTP = null;
2671                             if (clearIndex &gt; -1) {
2672                                 for (int i = 0; i &lt; selectedCellsMap.size(); i++) {
2673                                     TreeTablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);
2674                                     if (tp.getRow() == clearIndex) {
2675                                         oldTP = tp;
2676                                         selectedCellsMap.remove(tp);
2677                                     } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {
2678                                         selectedCellsMap.remove(tp);
2679                                     }
2680                                 }
2681                             }
2682 
2683                             if (oldTP != null &amp;&amp; param.isSelected()) {
2684                                 TreeTablePosition&lt;S,?&gt; newTP = new TreeTablePosition&lt;&gt;(
2685                                         treeTableView, param.getSetIndex(), oldTP.getTableColumn());
2686 
2687                                 selectedCellsMap.add(newTP);
2688                             }
2689 
2690                             stopAtomic();
2691 
2692                             return null;
2693                         }
2694                     });
2695                 }
2696             }
2697         };
2698 
2699         private WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
2700                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
2701 
2702         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
2703 
2704 
2705 
2706         /***********************************************************************
2707          *                                                                     *
2708          * Observable properties (and getters/setters)                         *
2709          *                                                                     *
2710          **********************************************************************/
2711 
2712         // the only &#39;proper&#39; internal data structure, selectedItems and selectedIndices
2713         // are both &#39;read-only and unbacked&#39;.
2714         private final SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsMap;
2715 
2716         private final ReadOnlyUnbackedObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsSeq;
2717         @Override public ObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; getSelectedCells() {
2718             return selectedCellsSeq;
2719         }
2720 
2721 
2722         /***********************************************************************
2723          *                                                                     *
2724          * Internal properties                                                 *
2725          *                                                                     *
2726          **********************************************************************/
2727 
2728 
2729 
2730         /***********************************************************************
2731          *                                                                     *
2732          * Public selection API                                                *
2733          *                                                                     *
2734          **********************************************************************/
2735 
2736         @Override public void clearAndSelect(int row) {
2737             clearAndSelect(row, null);
2738         }
2739 
2740         @Override public void clearAndSelect(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
2741             if (row &lt; 0 || row &gt;= getItemCount()) return;
2742 
2743             final TreeTablePosition&lt;S,?&gt; newTablePosition = new TreeTablePosition&lt;&gt;(getTreeTableView(), row, (TreeTableColumn&lt;S,?&gt;)column);
2744             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
2745 
2746             // replace the anchor
2747             TreeTableCellBehavior.setAnchor(treeTableView, newTablePosition, false);
2748 
2749             // firstly we make a copy of the selection, so that we can send out
2750             // the correct details in the selection change event.
2751             List&lt;TreeTablePosition&lt;S,?&gt;&gt; previousSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());
2752 
2753             // secondly we check if we can short-circuit out of here because the new selection
2754             // equals the current selection
2755             final boolean wasSelected = isSelected(row, column);
2756             if (wasSelected &amp;&amp; previousSelection.size() == 1) {
2757                 // before we return, we double-check that the selected item
2758                 // is equal to the item in the given index
2759                 TreeTablePosition&lt;S,?&gt; selectedCell = getSelectedCells().get(0);
2760                 if (getSelectedItem() == getModelItem(row)) {
2761                     if (selectedCell.getRow() == row &amp;&amp; selectedCell.getTableColumn() == column) {
2762                         return;
2763                     }
2764                 }
2765             }
2766 
2767             // RT-32411: We used to call quietClearSelection() here, but this
2768             // resulted in the selectedItems and selectedIndices lists never
2769             // reporting that they were empty.
2770             // makeAtomic toggle added to resolve RT-32618
2771             startAtomic();
2772 
2773             // then clear the current selection
2774             clearSelection();
2775 
2776             // and select the new cell
2777             select(row, column);
2778 
2779             stopAtomic();
2780 
2781             // We remove the new selection from the list seeing as it is not removed.
2782             if (isCellSelectionEnabled) {
2783                 previousSelection.remove(newTablePosition);
2784             } else {
2785                 for (TreeTablePosition&lt;S,?&gt; tp : previousSelection) {
2786                     if (tp.getRow() == row) {
2787                         previousSelection.remove(tp);
2788                         break;
2789                     }
2790                 }
2791             }
2792 
2793             // fire off a single add/remove/replace notification (rather than
2794             // individual remove and add notifications) - see RT-33324
2795             ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; change;
2796 
2797             /*
2798              * getFrom() documentation:
2799              *   If wasAdded is true, the interval contains all the values that were added.
2800              *   If wasPermutated is true, the interval marks the values that were permutated.
2801              *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
2802              *   return the same number - the place where the removed elements were positioned in the list.
2803              */
2804             if (wasSelected) {
2805                 change = ControlUtils.buildClearAndSelectChange(selectedCellsSeq, previousSelection, row);
2806             } else {
2807                 final int changeIndex = isCellSelectionEnabled ? 0 : Math.max(0, selectedCellsSeq.indexOf(newTablePosition));
2808                 final int changeSize = isCellSelectionEnabled ? getSelectedCells().size() : 1;
2809                 change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
2810                         changeIndex, changeIndex + changeSize, previousSelection, selectedCellsSeq);
2811 //                selectedCellsSeq._beginChange();
2812 //                selectedCellsSeq._nextAdd(changeIndex, changeIndex + changeSize);
2813 //                selectedCellsSeq._nextRemove(changeIndex, previousSelection);
2814 //                selectedCellsSeq._endChange();
2815             }
2816 
2817             fireCustomSelectedCellsListChangeEvent(change);
2818         }
2819 
2820         @Override public void select(int row) {
2821             select(row, null);
2822         }
2823 
2824         @Override public void select(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
2825             // TODO we need to bring in the TreeView selection stuff here...
2826             if (row &lt; 0 || row &gt;= getRowCount()) return;
2827 
2828             // if I&#39;m in cell selection mode but the column is null, select each
2829             // of the contained cells individually
2830             if (isCellSelectionEnabled() &amp;&amp; column == null) {
2831                 List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2832                 for (int i = 0; i &lt; columns.size(); i++) {
2833                     select(row, columns.get(i));
2834                 }
2835                 return;
2836             }
2837 
2838             if (TableCellBehavior.hasDefaultAnchor(treeTableView)) {
2839                 TableCellBehavior.removeAnchor(treeTableView);
2840             }
2841 
2842             if (getSelectionMode() == SelectionMode.SINGLE) {
2843                 quietClearSelection();
2844             }
2845             selectedCellsMap.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, (TreeTableColumn&lt;S,?&gt;)column));
2846 
2847             updateSelectedIndex(row);
2848             focus(row, (TreeTableColumn&lt;S, ?&gt;) column);
2849         }
2850 
2851         @Override public void select(TreeItem&lt;S&gt; obj) {
2852             if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
2853                 clearSelection();
2854                 return;
2855             }
2856 
2857             int firstIndex = treeTableView.getRow(obj);
2858             if (firstIndex &gt; -1) {
2859                 if (isSelected(firstIndex)) {
2860                     return;
2861                 }
2862 
2863                 if (getSelectionMode() == SelectionMode.SINGLE) {
2864                     quietClearSelection();
2865                 }
2866 
2867                 select(firstIndex);
2868             } else {
2869                 // if we are here, we did not find the item in the entire data model.
2870                 // Even still, we allow for this item to be set to the give object.
2871                 // We expect that in concrete subclasses of this class we observe the
2872                 // data model such that we check to see if the given item exists in it,
2873                 // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
2874                 setSelectedIndex(-1);
2875                 setSelectedItem(obj);
2876             }
2877         }
2878 
2879         @Override public void selectIndices(int row, int... rows) {
2880             if (rows == null) {
2881                 select(row);
2882                 return;
2883             }
2884 
2885             /*
2886              * Performance optimisation - if multiple selection is disabled, only
2887              * process the end-most row index.
2888              */
2889             int rowCount = getRowCount();
2890 
2891             if (getSelectionMode() == SelectionMode.SINGLE) {
2892                 quietClearSelection();
2893 
2894                 for (int i = rows.length - 1; i &gt;= 0; i--) {
2895                     int index = rows[i];
2896                     if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
2897                         select(index);
2898                         break;
2899                     }
2900                 }
2901 
2902                 if (selectedCellsMap.isEmpty()) {
2903                     if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
2904                         select(row);
2905                     }
2906                 }
2907             } else {
2908                 int lastIndex = -1;
2909                 Set&lt;TreeTablePosition&lt;S,?&gt;&gt; positions = new LinkedHashSet&lt;&gt;();
2910 
2911                 // --- firstly, we special-case the non-varargs &#39;row&#39; argument
2912                 if (row &gt;= 0 &amp;&amp; row &lt; rowCount) {
2913                     // if I&#39;m in cell selection mode, we want to select each
2914                     // of the contained cells individually
2915                     if (isCellSelectionEnabled()) {
2916                         List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2917                         for (int column = 0; column &lt; columns.size(); column++) {
2918                             if (! selectedCellsMap.isSelected(row, column)) {
2919                                 positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, columns.get(column)));
2920                             }
2921                         }
2922                     } else {
2923                         boolean match = selectedCellsMap.isSelected(row, -1);
2924                         if (!match) {
2925                             positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, null));
2926                         }
2927                     }
2928 
2929                     lastIndex = row;
2930                 }
2931 
2932                 // --- now we iterate through all varargs values
2933                 for (int i = 0; i &lt; rows.length; i++) {
2934                     int index = rows[i];
2935                     if (index &lt; 0 || index &gt;= rowCount) continue;
2936                     lastIndex = index;
2937 
2938                     if (isCellSelectionEnabled()) {
2939                         List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2940                         for (int column = 0; column &lt; columns.size(); column++) {
2941                             if (! selectedCellsMap.isSelected(index, column)) {
2942                                 positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), index, columns.get(column)));
2943                                 lastIndex = index;
2944                             }
2945                         }
2946                     } else {
2947                         if (! selectedCellsMap.isSelected(index, -1)) {
2948                             // if we are here then we have successfully gotten through the for-loop above
2949                             positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), index, null));
2950                         }
2951                     }
2952                 }
2953 
2954                 selectedCellsMap.addAll(positions);
2955 
2956                 if (lastIndex != -1) {
2957                     select(lastIndex);
2958                 }
2959             }
2960         }
2961 
2962         @Override public void selectAll() {
2963             if (getSelectionMode() == SelectionMode.SINGLE) return;
2964 
2965             if (isCellSelectionEnabled()) {
2966                 List&lt;TreeTablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
2967                 TreeTableColumn&lt;S,?&gt; column;
2968                 TreeTablePosition&lt;S,?&gt; tp = null;
2969                 for (int col = 0; col &lt; getTreeTableView().getVisibleLeafColumns().size(); col++) {
2970                     column = getTreeTableView().getVisibleLeafColumns().get(col);
2971                     for (int row = 0; row &lt; getRowCount(); row++) {
2972                         tp = new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column);
2973                         indices.add(tp);
2974                     }
2975                 }
2976                 selectedCellsMap.setAll(indices);
2977 
2978                 if (tp != null) {
2979                     select(tp.getRow(), tp.getTableColumn());
2980                     focus(tp.getRow(), tp.getTableColumn());
2981                 }
2982             } else {
2983                 List&lt;TreeTablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
2984                 for (int i = 0; i &lt; getRowCount(); i++) {
2985                     indices.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), i, null));
2986                 }
2987                 selectedCellsMap.setAll(indices);
2988 
2989                 int focusedIndex = getFocusedIndex();
2990                 if (focusedIndex == -1) {
2991                     final int itemCount = getItemCount();
2992                     if (itemCount &gt; 0) {
2993                         select(itemCount - 1);
2994                         focus(indices.get(indices.size() - 1));
2995                     }
2996                 } else {
2997                     select(focusedIndex);
2998                     focus(focusedIndex);
2999                 }
3000             }
3001         }
3002 
3003         @Override public void selectRange(int minRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; minColumn,
3004                                           int maxRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; maxColumn) {
3005             if (getSelectionMode() == SelectionMode.SINGLE) {
3006                 quietClearSelection();
3007                 select(maxRow, maxColumn);
3008                 return;
3009             }
3010 
3011             startAtomic();
3012 
3013             final int itemCount = getItemCount();
3014             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
3015 
3016             final int minColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)minColumn);
3017             final int maxColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)maxColumn);
3018             final int _minColumnIndex = Math.min(minColumnIndex, maxColumnIndex);
3019             final int _maxColumnIndex = Math.max(minColumnIndex, maxColumnIndex);
3020 
3021             final int _minRow = Math.min(minRow, maxRow);
3022             final int _maxRow = Math.max(minRow, maxRow);
3023 
3024             List&lt;TreeTablePosition&lt;S,?&gt;&gt; cellsToSelect = new ArrayList&lt;&gt;();
3025 
3026             for (int _row = _minRow; _row &lt;= _maxRow; _row++) {
3027                 // begin copy/paste of select(int, column) method (with some
3028                 // slight modifications)
3029                 if (_row &lt; 0 || _row &gt;= itemCount) continue;
3030 
3031                 if (! isCellSelectionEnabled) {
3032                     cellsToSelect.add(new TreeTablePosition&lt;&gt;(treeTableView, _row, (TreeTableColumn&lt;S,?&gt;)minColumn));
3033                 } else {
3034                     for (int _col = _minColumnIndex; _col &lt;= _maxColumnIndex; _col++) {
3035                         final TreeTableColumn&lt;S, ?&gt; column = treeTableView.getVisibleLeafColumn(_col);
3036 
3037                         // if I&#39;m in cell selection mode but the column is null, I don&#39;t want
3038                         // to select the whole row instead...
3039                         if (column == null &amp;&amp; isCellSelectionEnabled) continue;
3040 
3041                         cellsToSelect.add(new TreeTablePosition&lt;&gt;(treeTableView, _row, column));
3042                         // end copy/paste
3043                     }
3044                 }
3045             }
3046 
3047             // to prevent duplication we remove all currently selected cells from
3048             // our list of cells to select.
3049             cellsToSelect.removeAll(getSelectedCells());
3050 
3051             selectedCellsMap.addAll(cellsToSelect);
3052             stopAtomic();
3053 
3054             // fire off events
3055             // Note that focus and selection always goes to maxRow, not _maxRow.
3056             updateSelectedIndex(maxRow);
3057             focus(maxRow, (TreeTableColumn&lt;S,?&gt;)maxColumn);
3058 
3059             final TreeTableColumn&lt;S,?&gt; startColumn = (TreeTableColumn&lt;S,?&gt;)minColumn;
3060             final TreeTableColumn&lt;S,?&gt; endColumn = isCellSelectionEnabled ? (TreeTableColumn&lt;S,?&gt;)maxColumn : startColumn;
3061             final int startChangeIndex = selectedCellsMap.indexOf(new TreeTablePosition&lt;&gt;(treeTableView, minRow, startColumn));
3062             final int endChangeIndex = selectedCellsMap.indexOf(new TreeTablePosition&lt;&gt;(treeTableView, maxRow, endColumn));
3063 
3064             if (startChangeIndex &gt; -1 &amp;&amp; endChangeIndex &gt; -1) {
3065                 final int startIndex = Math.min(startChangeIndex, endChangeIndex);
3066                 final int endIndex = Math.max(startChangeIndex, endChangeIndex);
3067 
3068                 ListChangeListener.Change c = new NonIterableChange.SimpleAddChange&lt;&gt;(startIndex, endIndex + 1, selectedCellsSeq);
3069                 fireCustomSelectedCellsListChangeEvent(c);
3070 //                selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextAdd(startIndex, endIndex + 1));
3071             }
3072         }
3073 
3074         @Override public void clearSelection(int index) {
3075             clearSelection(index, null);
3076         }
3077 
3078         @Override
3079         public void clearSelection(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
3080             clearSelection(new TreeTablePosition&lt;S,Object&gt;(getTreeTableView(), row, (TreeTableColumn)column));
3081         }
3082 
3083         private void clearSelection(TreeTablePosition&lt;S,?&gt; tp) {
3084             final boolean csMode = isCellSelectionEnabled();
3085             final int row = tp.getRow();
3086             final boolean columnIsNull = tp.getTableColumn() == null;
3087 
3088             List&lt;TreeTablePosition&gt; toRemove = new ArrayList&lt;&gt;();
3089             for (TreeTablePosition pos : getSelectedCells()) {
3090                 if (!csMode) {
3091                     if (pos.getRow() == row) {
3092                         toRemove.add(pos);
3093                         break;
3094                     }
3095                 } else {
3096                     if (columnIsNull &amp;&amp; pos.getRow() == row) {
3097                         // if we are in cell selection mode and the column is null,
3098                         // we remove all items in the row
3099                         toRemove.add(pos);
3100                     } else if (pos.equals(tp)) {
3101                         toRemove.add(tp);
3102                         break;
3103                     }
3104                 }
3105             }
3106             toRemove.stream().forEach(selectedCellsMap::remove);
3107 
3108             if (isEmpty() &amp;&amp; ! isAtomic()) {
3109                 updateSelectedIndex(-1);
3110                 selectedCellsMap.clear();
3111             }
3112         }
3113 
3114         @Override public void clearSelection() {
3115             final List&lt;TreeTablePosition&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;((Collection)getSelectedCells());
3116 
3117             quietClearSelection();
3118 
3119             if (! isAtomic()) {
3120                 updateSelectedIndex(-1);
3121                 focus(-1);
3122 
3123                 if (!removed.isEmpty()) {
3124 //                    selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextRemove(0, removed));
3125                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange&lt;TreeTablePosition&lt;S, ?&gt;&gt;(0, 0, selectedCellsSeq) {
3126                         @Override public List&lt;TreeTablePosition&lt;S, ?&gt;&gt; getRemoved() {
3127                             return removed;
3128                         }
3129                     };
3130                     fireCustomSelectedCellsListChangeEvent(c);
3131                 }
3132             }
3133         }
3134 
3135         private void quietClearSelection() {
3136             startAtomic();
3137             selectedCellsMap.clear();
3138             stopAtomic();
3139         }
3140 
3141         @Override public boolean isSelected(int index) {
3142             return isSelected(index, null);
3143         }
3144 
3145         @Override public boolean isSelected(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
3146             // When in cell selection mode, if the column is null, then we interpret
3147             // the users query to be asking if _all_ of the cells in the row are selected,
3148             // rather than if _any_ of the cells in the row are selected.
3149             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
3150             if (isCellSelectionEnabled &amp;&amp; column == null) {
3151                 int columnCount = treeTableView.getVisibleLeafColumns().size();
3152                 for (int col = 0; col &lt; columnCount; col++) {
3153                     if (!selectedCellsMap.isSelected(row, col)) {
3154                         return false;
3155                     }
3156                 }
3157                 return true;
3158             } else {
3159                 int columnIndex = !isCellSelectionEnabled || column == null ? -1 : treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S, ?&gt;) column);
3160                 return selectedCellsMap.isSelected(row, columnIndex);
3161             }
3162         }
3163 
3164         @Override public boolean isEmpty() {
3165             return selectedCellsMap.isEmpty();
3166         }
3167 
3168         @Override public void selectPrevious() {
3169             if (isCellSelectionEnabled()) {
3170                 // in cell selection mode, we have to wrap around, going from
3171                 // right-to-left, and then wrapping to the end of the previous line
3172                 TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3173                 if (pos.getColumn() - 1 &gt;= 0) {
3174                     // go to previous row
3175                     select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
3176                 } else if (pos.getRow() &lt; getRowCount() - 1) {
3177                     // wrap to end of previous row
3178                     select(pos.getRow() - 1, getTableColumn(getTreeTableView().getVisibleLeafColumns().size() - 1));
3179                 }
3180             } else {
3181                 int focusIndex = getFocusedIndex();
3182                 if (focusIndex == -1) {
3183                     select(getRowCount() - 1);
3184                 } else if (focusIndex &gt; 0) {
3185                     select(focusIndex - 1);
3186                 }
3187             }
3188         }
3189 
3190         @Override public void selectNext() {
3191             if (isCellSelectionEnabled()) {
3192                 // in cell selection mode, we have to wrap around, going from
3193                 // left-to-right, and then wrapping to the start of the next line
3194                 TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3195                 if (pos.getColumn() + 1 &lt; getTreeTableView().getVisibleLeafColumns().size()) {
3196                     // go to next column
3197                     select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
3198                 } else if (pos.getRow() &lt; getRowCount() - 1) {
3199                     // wrap to start of next row
3200                     select(pos.getRow() + 1, getTableColumn(0));
3201                 }
3202             } else {
3203                 int focusIndex = getFocusedIndex();
3204                 if (focusIndex == -1) {
3205                     select(0);
3206                 } else if (focusIndex &lt; getRowCount() -1) {
3207                     select(focusIndex + 1);
3208                 }
3209             }
3210         }
3211 
3212         @Override public void selectAboveCell() {
3213             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3214             if (pos.getRow() == -1) {
3215                 select(getRowCount() - 1);
3216             } else if (pos.getRow() &gt; 0) {
3217                 select(pos.getRow() - 1, pos.getTableColumn());
3218             }
3219         }
3220 
3221         @Override public void selectBelowCell() {
3222             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3223 
3224             if (pos.getRow() == -1) {
3225                 select(0);
3226             } else if (pos.getRow() &lt; getRowCount() -1) {
3227                 select(pos.getRow() + 1, pos.getTableColumn());
3228             }
3229         }
3230 
3231         @Override public void selectFirst() {
3232             TreeTablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
3233 
3234             if (getSelectionMode() == SelectionMode.SINGLE) {
3235                 quietClearSelection();
3236             }
3237 
3238             if (getRowCount() &gt; 0) {
3239                 if (isCellSelectionEnabled()) {
3240                     select(0, focusedCell.getTableColumn());
3241                 } else {
3242                     select(0);
3243                 }
3244             }
3245         }
3246 
3247         @Override public void selectLast() {
3248             TreeTablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
3249 
3250             if (getSelectionMode() == SelectionMode.SINGLE) {
3251                 quietClearSelection();
3252             }
3253 
3254             int numItems = getRowCount();
3255             if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
3256                 if (isCellSelectionEnabled()) {
3257                     select(numItems - 1, focusedCell.getTableColumn());
3258                 } else {
3259                     select(numItems - 1);
3260                 }
3261             }
3262         }
3263 
3264         @Override public void selectLeftCell() {
3265             if (! isCellSelectionEnabled()) return;
3266 
3267             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3268             if (pos.getColumn() - 1 &gt;= 0) {
3269                 select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
3270             }
3271         }
3272 
3273         @Override public void selectRightCell() {
3274             if (! isCellSelectionEnabled()) return;
3275 
3276             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3277             if (pos.getColumn() + 1 &lt; getTreeTableView().getVisibleLeafColumns().size()) {
3278                 select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
3279             }
3280         }
3281 
3282 
3283 
3284         /***********************************************************************
3285          *                                                                     *
3286          * Support code                                                        *
3287          *                                                                     *
3288          **********************************************************************/
3289 
3290         private void updateDefaultSelection() {
3291             // when the items list totally changes, we should clear out
3292             // the selection
3293             int newSelectionIndex = -1;
3294             TreeItem&lt;S&gt; selectedItem = getSelectedItem();
3295             if (selectedItem != null) {
3296                 newSelectionIndex = treeTableView.getRow(selectedItem);
3297             }
3298 
3299             // we put focus onto the first item, if there is at least
3300             // one item in the list
3301             int newFocusIndex = newSelectionIndex != -1 ? newSelectionIndex : treeTableView.getExpandedItemCount() &gt; 0 ? 0 : -1;
3302 
3303             clearSelection();
3304             select(newSelectionIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
3305             focus(newFocusIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
3306         }
3307 
3308         private TreeTableColumn&lt;S,?&gt; getTableColumn(int pos) {
3309             return getTreeTableView().getVisibleLeafColumn(pos);
3310         }
3311 
3312         // Gets a table column to the left or right of the current one, given an offset
3313         private TreeTableColumn&lt;S,?&gt; getTableColumn(TreeTableColumn&lt;S,?&gt; column, int offset) {
3314             int columnIndex = getTreeTableView().getVisibleLeafIndex(column);
3315             int newColumnIndex = columnIndex + offset;
3316             return getTreeTableView().getVisibleLeafColumn(newColumnIndex);
3317         }
3318 
3319         private void updateSelectedIndex(int row) {
3320             setSelectedIndex(row);
3321             setSelectedItem(getModelItem(row));
3322         }
3323 
3324         @Override public void focus(int row) {
3325             focus(row, null);
3326         }
3327 
3328         private void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
3329             focus(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column));
3330         }
3331 
3332         private void focus(TreeTablePosition&lt;S,?&gt; pos) {
3333             if (getTreeTableView().getFocusModel() == null) return;
3334 
3335             getTreeTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
3336             getTreeTableView().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
3337         }
3338 
3339         @Override public int getFocusedIndex() {
3340             return getFocusedCell().getRow();
3341         }
3342 
3343         private TreeTablePosition&lt;S,?&gt; getFocusedCell() {
3344             if (treeTableView.getFocusModel() == null) {
3345                 return new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
3346             }
3347             return treeTableView.getFocusModel().getFocusedCell();
3348         }
3349 
3350         private int getRowCount() {
3351             return treeTableView.getExpandedItemCount();
3352         }
3353 
3354         private void fireCustomSelectedCellsListChangeEvent(ListChangeListener.Change&lt;? extends TreeTablePosition&lt;S,?&gt;&gt; c) {
3355             ControlUtils.updateSelectedIndices(this, c);
3356 
3357             if (isAtomic()) {
3358                 return;
3359             }
3360 
3361             selectedCellsSeq.callObservers(new MappingChange&lt;&gt;(c, MappingChange.NOOP_MAP, selectedCellsSeq));
3362         }
3363     }
3364 
3365 
3366 
3367 
3368     /**
3369      * A {@link FocusModel} with additional functionality to support the requirements
3370      * of a TableView control.
3371      *
3372      * @see TableView
3373      * @since JavaFX 8.0
3374      */
3375     public static class TreeTableViewFocusModel&lt;S&gt; extends TableFocusModel&lt;TreeItem&lt;S&gt;, TreeTableColumn&lt;S,?&gt;&gt; {
3376 
3377         private final TreeTableView&lt;S&gt; treeTableView;
3378 
3379         private final TreeTablePosition EMPTY_CELL;
3380 
3381         /**
3382          * Creates a default TableViewFocusModel instance that will be used to
3383          * manage focus of the provided TableView control.
3384          *
3385          * @param treeTableView The tableView upon which this focus model operates.
3386          * @throws NullPointerException The TableView argument can not be null.
3387          */
3388         public TreeTableViewFocusModel(final TreeTableView&lt;S&gt; treeTableView) {
3389             if (treeTableView == null) {
3390                 throw new NullPointerException(&quot;TableView can not be null&quot;);
3391             }
3392 
3393             this.treeTableView = treeTableView;
3394             this.EMPTY_CELL = new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
3395 
3396             this.treeTableView.rootProperty().addListener(weakRootPropertyListener);
3397             updateTreeEventListener(null, treeTableView.getRoot());
3398 
3399             int focusRow = getItemCount() &gt; 0 ? 0 : -1;
3400             TreeTablePosition&lt;S,?&gt; pos = new TreeTablePosition&lt;&gt;(treeTableView, focusRow, null);
3401             setFocusedCell(pos);
3402 
3403             showRootListener = obs -&gt; {
3404                 if (isFocused(0)) {
3405                     focus(-1);
3406                     focus(0);
3407                 }
3408             };
3409             treeTableView.showRootProperty().addListener(new WeakInvalidationListener(showRootListener));
3410 
3411             focusedCellProperty().addListener(o -&gt; {
3412                 treeTableView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
3413             });
3414         }
3415 
3416         private final ChangeListener&lt;TreeItem&lt;S&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
3417             updateTreeEventListener(oldValue, newValue);
3418         };
3419 
3420         private final WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
3421                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
3422 
3423         private final InvalidationListener showRootListener;
3424 
3425         private void updateTreeEventListener(TreeItem&lt;S&gt; oldRoot, TreeItem&lt;S&gt; newRoot) {
3426             if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
3427                 oldRoot.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
3428             }
3429 
3430             if (newRoot != null) {
3431                 weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
3432                 newRoot.addEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
3433             }
3434         }
3435 
3436         private EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; treeItemListener = new EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt;() {
3437             @Override public void handle(TreeItem.TreeModificationEvent&lt;S&gt; e) {
3438                 // don&#39;t shift focus if the event occurred on a tree item after
3439                 // the focused row, or if there is no focus index at present
3440                 if (getFocusedIndex() == -1) return;
3441 
3442                 int shift = 0;
3443                 if (e.getChange() != null) {
3444                     e.getChange().next();
3445                 }
3446 
3447                 do {
3448                     int row = treeTableView.getRow(e.getTreeItem());
3449 
3450                     if (e.wasExpanded()) {
3451                         if (row &lt; getFocusedIndex()) {
3452                             // need to shuffle selection by the number of visible children
3453                             shift += e.getTreeItem().getExpandedDescendentCount(false) - 1;
3454                         }
3455                     } else if (e.wasCollapsed()) {
3456                         if (row &lt; getFocusedIndex()) {
3457                             // need to shuffle selection by the number of visible children
3458                             // that were just hidden
3459                             shift += -e.getTreeItem().previousExpandedDescendentCount + 1;
3460                         }
3461                     } else if (e.wasAdded()) {
3462                         // get the TreeItem the event occurred on - we only need to
3463                         // shift if the tree item is expanded
3464                         TreeItem&lt;S&gt; eventTreeItem = e.getTreeItem();
3465                         if (eventTreeItem.isExpanded()) {
3466                             for (int i = 0; i &lt; e.getAddedChildren().size(); i++) {
3467                                 // get the added item and determine the row it is in
3468                                 TreeItem&lt;S&gt; item = e.getAddedChildren().get(i);
3469                                 row = treeTableView.getRow(item);
3470 
3471                                 if (item != null &amp;&amp; row &lt;= (shift+getFocusedIndex())) {
3472                                     shift += item.getExpandedDescendentCount(false);
3473                                 }
3474                             }
3475                         }
3476                     } else if (e.wasRemoved()) {
3477                         row += e.getFrom() + 1;
3478 
3479                         for (int i = 0; i &lt; e.getRemovedChildren().size(); i++) {
3480                             TreeItem&lt;S&gt; item = e.getRemovedChildren().get(i);
3481                             if (item != null &amp;&amp; item.equals(getFocusedItem())) {
3482                                 focus(Math.max(0, getFocusedIndex() - 1));
3483                                 return;
3484                             }
3485                         }
3486 
3487                         if (row &lt;= getFocusedIndex()) {
3488                             // shuffle selection by the number of removed items
3489                             shift += e.getTreeItem().isExpanded() ? -e.getRemovedSize() : 0;
3490                         }
3491                     }
3492                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
3493 
3494                 if (shift != 0) {
3495                     TreeTablePosition&lt;S, ?&gt; focusedCell = getFocusedCell();
3496                     final int newFocus = focusedCell.getRow() + shift;
3497                     if (newFocus &gt;= 0) {
3498                         Platform.runLater(() -&gt; focus(newFocus, focusedCell.getTableColumn()));
3499                     }
3500                 }
3501             }
3502         };
3503 
3504         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
3505 
3506         /** {@inheritDoc} */
3507         @Override protected int getItemCount() {
3508 //            if (tableView.getItems() == null) return -1;
3509 //            return tableView.getItems().size();
3510             return treeTableView.getExpandedItemCount();
3511         }
3512 
3513         /** {@inheritDoc} */
3514         @Override protected TreeItem&lt;S&gt; getModelItem(int index) {
3515             if (index &lt; 0 || index &gt;= getItemCount()) return null;
3516             return treeTableView.getTreeItem(index);
3517         }
3518 
3519         /**
3520          * The position of the current item in the TableView which has the focus.
3521          */
3522         private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCell;
3523         public final ReadOnlyObjectProperty&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCellProperty() {
3524             return focusedCellPropertyImpl().getReadOnlyProperty();
3525         }
3526         private void setFocusedCell(TreeTablePosition&lt;S,?&gt; value) { focusedCellPropertyImpl().set(value);  }
3527         public final TreeTablePosition&lt;S,?&gt; getFocusedCell() { return focusedCell == null ? EMPTY_CELL : focusedCell.get(); }
3528 
3529         private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCellPropertyImpl() {
3530             if (focusedCell == null) {
3531                 focusedCell = new ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt;(EMPTY_CELL) {
3532                     private TreeTablePosition&lt;S,?&gt; old;
3533                     @Override protected void invalidated() {
3534                         if (get() == null) return;
3535 
3536                         if (old == null || !old.equals(get())) {
3537                             setFocusedIndex(get().getRow());
3538                             setFocusedItem(getModelItem(getValue().getRow()));
3539 
3540                             old = get();
3541                         }
3542                     }
3543 
3544                     @Override
3545                     public Object getBean() {
3546                         return TreeTableView.TreeTableViewFocusModel.this;
3547                     }
3548 
3549                     @Override
3550                     public String getName() {
3551                         return &quot;focusedCell&quot;;
3552                     }
3553                 };
3554             }
3555             return focusedCell;
3556         }
3557 
3558 
3559         /**
3560          * Causes the item at the given index to receive the focus.
3561          *
3562          * @param row The row index of the item to give focus to.
3563          * @param column The column of the item to give focus to. Can be null.
3564          */
3565         @Override public void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
3566             if (row &lt; 0 || row &gt;= getItemCount()) {
3567                 setFocusedCell(EMPTY_CELL);
3568             } else {
3569                 TreeTablePosition&lt;S,?&gt; oldFocusCell = getFocusedCell();
3570                 TreeTablePosition&lt;S,?&gt; newFocusCell = new TreeTablePosition&lt;&gt;(treeTableView, row, column);
3571                 setFocusedCell(newFocusCell);
3572 
3573                 if (newFocusCell.equals(oldFocusCell)) {
3574                     // manually update the focus properties to ensure consistency
3575                     setFocusedIndex(row);
3576                     setFocusedItem(getModelItem(row));
3577                 }
3578             }
3579         }
3580 
3581         /**
3582          * Convenience method for setting focus on a particular row or cell
3583          * using a {@link TablePosition}.
3584          *
3585          * @param pos The table position where focus should be set.
3586          */
3587         public void focus(TreeTablePosition&lt;S,?&gt; pos) {
3588             if (pos == null) return;
3589             focus(pos.getRow(), pos.getTableColumn());
3590         }
3591 
3592 
3593         /***********************************************************************
3594          *                                                                     *
3595          * Public API                                                          *
3596          *                                                                     *
3597          **********************************************************************/
3598 
3599         /**
3600          * Tests whether the row / cell at the given location currently has the
3601          * focus within the TableView.
3602          */
3603         @Override public boolean isFocused(int row, TreeTableColumn&lt;S,?&gt; column) {
3604             if (row &lt; 0 || row &gt;= getItemCount()) return false;
3605 
3606             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3607             boolean columnMatch = column == null || column.equals(cell.getTableColumn());
3608 
3609             return cell.getRow() == row &amp;&amp; columnMatch;
3610         }
3611 
3612         /**
3613          * Causes the item at the given index to receive the focus. This does not
3614          * cause the current selection to change. Updates the focusedItem and
3615          * focusedIndex properties such that &lt;code&gt;focusedIndex = -1&lt;/code&gt; unless
3616          * &lt;pre&gt;&lt;code&gt;0 &amp;lt;= index &amp;lt; model size&lt;/code&gt;&lt;/pre&gt;.
3617          *
3618          * @param index The index of the item to get focus.
3619          */
3620         @Override public void focus(int index) {
3621             if (treeTableView.expandedItemCountDirty) {
3622                 treeTableView.updateExpandedItemCount(treeTableView.getRoot());
3623             }
3624 
3625             if (index &lt; 0 || index &gt;= getItemCount()) {
3626                 setFocusedCell(EMPTY_CELL);
3627             } else {
3628                 setFocusedCell(new TreeTablePosition&lt;&gt;(treeTableView, index, null));
3629             }
3630         }
3631 
3632         /**
3633          * Attempts to move focus to the cell above the currently focused cell.
3634          */
3635         @Override public void focusAboveCell() {
3636             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3637 
3638             if (getFocusedIndex() == -1) {
3639                 focus(getItemCount() - 1, cell.getTableColumn());
3640             } else if (getFocusedIndex() &gt; 0) {
3641                 focus(getFocusedIndex() - 1, cell.getTableColumn());
3642             }
3643         }
3644 
3645         /**
3646          * Attempts to move focus to the cell below the currently focused cell.
3647          */
3648         @Override public void focusBelowCell() {
3649             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3650             if (getFocusedIndex() == -1) {
3651                 focus(0, cell.getTableColumn());
3652             } else if (getFocusedIndex() != getItemCount() -1) {
3653                 focus(getFocusedIndex() + 1, cell.getTableColumn());
3654             }
3655         }
3656 
3657         /**
3658          * Attempts to move focus to the cell to the left of the currently focused cell.
3659          */
3660         @Override public void focusLeftCell() {
3661             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3662             if (cell.getColumn() &lt;= 0) return;
3663             focus(cell.getRow(), getTableColumn(cell.getTableColumn(), -1));
3664         }
3665 
3666         /**
3667          * Attempts to move focus to the cell to the right of the the currently focused cell.
3668          */
3669         @Override public void focusRightCell() {
3670             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3671             if (cell.getColumn() == getColumnCount() - 1) return;
3672             focus(cell.getRow(), getTableColumn(cell.getTableColumn(), 1));
3673         }
3674 
3675         /** {@inheritDoc} */
3676         @Override public void focusPrevious() {
3677             if (getFocusedIndex() == -1) {
3678                 focus(0);
3679             } else if (getFocusedIndex() &gt; 0) {
3680                 focusAboveCell();
3681             }
3682         }
3683 
3684         /** {@inheritDoc} */
3685         @Override public void focusNext() {
3686             if (getFocusedIndex() == -1) {
3687                 focus(0);
3688             } else if (getFocusedIndex() != getItemCount() -1) {
3689                 focusBelowCell();
3690             }
3691         }
3692 
3693 
3694 
3695          /***********************************************************************
3696          *                                                                     *
3697          * Private Implementation                                              *
3698          *                                                                     *
3699          **********************************************************************/
3700 
3701         private int getColumnCount() {
3702             return treeTableView.getVisibleLeafColumns().size();
3703         }
3704 
3705         // Gets a table column to the left or right of the current one, given an offset
3706         private TreeTableColumn&lt;S,?&gt; getTableColumn(TreeTableColumn&lt;S,?&gt; column, int offset) {
3707             int columnIndex = treeTableView.getVisibleLeafIndex(column);
3708             int newColumnIndex = columnIndex + offset;
3709             return treeTableView.getVisibleLeafColumn(newColumnIndex);
3710         }
3711     }
3712 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
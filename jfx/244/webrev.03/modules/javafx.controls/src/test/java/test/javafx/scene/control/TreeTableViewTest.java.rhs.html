<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/test/java/test/javafx/scene/control/TreeTableViewTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package test.javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.control.TableColumnBaseHelper;
  29 import static test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils.assertStyleClassContains;
  30 import static javafx.scene.control.TreeTableColumn.SortType.ASCENDING;
  31 import static javafx.scene.control.TreeTableColumn.SortType.DESCENDING;
  32 import static org.junit.Assert.*;
  33 import static org.junit.Assert.assertEquals;
  34 
  35 import java.util.ArrayList;
  36 import java.util.Comparator;
  37 import java.util.List;
  38 import java.util.Objects;
  39 import java.util.concurrent.atomic.AtomicInteger;
  40 import java.util.function.Consumer;
  41 import java.util.function.Supplier;
  42 import java.util.stream.Collectors;
  43 
  44 import com.sun.javafx.scene.control.behavior.TreeTableCellBehavior;
  45 import javafx.beans.property.ReadOnlyIntegerWrapper;
  46 import javafx.collections.transformation.FilteredList;
  47 import javafx.scene.control.TableColumn;
  48 import javafx.scene.control.TableView;
  49 import test.com.sun.javafx.scene.control.infrastructure.KeyEventFirer;
  50 import test.com.sun.javafx.scene.control.infrastructure.KeyModifier;
  51 import test.com.sun.javafx.scene.control.infrastructure.MouseEventFirer;
  52 import javafx.scene.control.skin.TreeTableCellSkin;
  53 import test.com.sun.javafx.scene.control.test.Data;
  54 
  55 import javafx.application.Platform;
  56 import javafx.beans.InvalidationListener;
  57 import javafx.beans.Observable;
  58 import javafx.beans.binding.Bindings;
  59 import javafx.beans.binding.ObjectBinding;
  60 import javafx.beans.property.ObjectProperty;
  61 import javafx.beans.property.ReadOnlyBooleanWrapper;
  62 import javafx.beans.property.ReadOnlyObjectWrapper;
  63 import javafx.beans.property.ReadOnlyStringWrapper;
  64 import javafx.beans.property.SimpleObjectProperty;
  65 import javafx.beans.property.SimpleStringProperty;
  66 import javafx.collections.FXCollections;
  67 import javafx.collections.ListChangeListener;
  68 import javafx.collections.ObservableList;
  69 import javafx.event.EventHandler;
  70 import javafx.scene.Group;
  71 import javafx.scene.Node;
  72 import javafx.scene.Scene;
  73 import javafx.scene.control.TreeTableView.TreeTableViewFocusModel;
  74 import javafx.scene.control.cell.*;
  75 import javafx.scene.image.ImageView;
  76 import javafx.scene.input.KeyCode;
  77 import javafx.scene.layout.StackPane;
  78 import javafx.scene.layout.VBox;
  79 import javafx.scene.paint.Color;
  80 import javafx.scene.shape.Circle;
  81 import javafx.scene.shape.Rectangle;
  82 import javafx.stage.Stage;
  83 import javafx.util.Callback;
  84 
  85 import org.junit.Before;
  86 import org.junit.Ignore;
  87 import org.junit.Test;
  88 
  89 import com.sun.javafx.scene.control.TableColumnComparatorBase.TreeTableColumnComparator;
  90 import test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils;
  91 import test.com.sun.javafx.scene.control.infrastructure.StageLoader;
  92 import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;
  93 import com.sun.javafx.scene.control.VirtualScrollBar;
  94 import test.com.sun.javafx.scene.control.test.Person;
  95 import test.com.sun.javafx.scene.control.test.RT_22463_Person;
  96 import com.sun.javafx.tk.Toolkit;
  97 import javafx.scene.control.Button;
  98 import javafx.scene.control.Cell;
  99 import javafx.scene.control.FocusModel;
 100 import javafx.scene.control.IndexedCell;
 101 import javafx.scene.control.MultipleSelectionModel;
 102 import javafx.scene.control.MultipleSelectionModelBaseShim;
 103 import javafx.scene.control.SelectionMode;
 104 import javafx.scene.control.TableColumnBaseShim;
 105 import javafx.scene.control.TableSelectionModel;
 106 import javafx.scene.control.TextField;
 107 import javafx.scene.control.TreeItem;
 108 import javafx.scene.control.TreeTableCell;
 109 import javafx.scene.control.TreeTableCellShim;
 110 import javafx.scene.control.TreeTableColumn;
 111 import javafx.scene.control.TreeTablePosition;
 112 import javafx.scene.control.TreeTableRow;
 113 import javafx.scene.control.TreeTableRowShim;
 114 import javafx.scene.control.TreeTableView;
 115 import javafx.scene.control.TreeTableViewShim;
 116 import javafx.scene.control.TreeView;
 117 
 118 public class TreeTableViewTest {
 119     private TreeTableView&lt;String&gt; treeTableView;
 120     private TreeTableView.TreeTableViewSelectionModel sm;
 121     private TreeTableViewFocusModel&lt;String&gt; fm;
 122 
 123 
 124     // sample data #1
 125     private TreeItem&lt;String&gt; root;
 126     private TreeItem&lt;String&gt; child1;
 127     private TreeItem&lt;String&gt; child2;
 128     private TreeItem&lt;String&gt; child3;
 129 
 130     // sample data #1
 131     private TreeItem&lt;String&gt; myCompanyRootNode;
 132         private TreeItem&lt;String&gt; salesDepartment;
 133             private TreeItem&lt;String&gt; ethanWilliams;
 134             private TreeItem&lt;String&gt; emmaJones;
 135             private TreeItem&lt;String&gt; michaelBrown;
 136             private TreeItem&lt;String&gt; annaBlack;
 137             private TreeItem&lt;String&gt; rodgerYork;
 138             private TreeItem&lt;String&gt; susanCollins;
 139 
 140         private TreeItem&lt;String&gt; itSupport;
 141             private TreeItem&lt;String&gt; mikeGraham;
 142             private TreeItem&lt;String&gt; judyMayer;
 143             private TreeItem&lt;String&gt; gregorySmith;
 144 
 145     @Before public void setup() {
 146         treeTableView = new TreeTableView&lt;String&gt;();
 147         sm = treeTableView.getSelectionModel();
 148         fm = treeTableView.getFocusModel();
 149 
 150         // build sample data #2, even though it may not be used...
 151         myCompanyRootNode = new TreeItem&lt;String&gt;(&quot;MyCompany Human Resources&quot;);
 152         salesDepartment = new TreeItem&lt;String&gt;(&quot;Sales Department&quot;);
 153             ethanWilliams = new TreeItem&lt;String&gt;(&quot;Ethan Williams&quot;);
 154             emmaJones = new TreeItem&lt;String&gt;(&quot;Emma Jones&quot;);
 155             michaelBrown = new TreeItem&lt;String&gt;(&quot;Michael Brown&quot;);
 156             annaBlack = new TreeItem&lt;String&gt;(&quot;Anna Black&quot;);
 157             rodgerYork = new TreeItem&lt;String&gt;(&quot;Rodger York&quot;);
 158             susanCollins = new TreeItem&lt;String&gt;(&quot;Susan Collins&quot;);
 159 
 160         itSupport = new TreeItem&lt;String&gt;(&quot;IT Support&quot;);
 161             mikeGraham = new TreeItem&lt;String&gt;(&quot;Mike Graham&quot;);
 162             judyMayer = new TreeItem&lt;String&gt;(&quot;Judy Mayer&quot;);
 163             gregorySmith = new TreeItem&lt;String&gt;(&quot;Gregory Smith&quot;);
 164 
 165         myCompanyRootNode.getChildren().setAll(
 166             salesDepartment,
 167             itSupport
 168         );
 169         salesDepartment.getChildren().setAll(
 170             ethanWilliams,
 171             emmaJones,
 172             michaelBrown,
 173             annaBlack,
 174             rodgerYork,
 175             susanCollins
 176         );
 177         itSupport.getChildren().setAll(
 178             mikeGraham,
 179             judyMayer,
 180             gregorySmith
 181         );
 182     }
 183 
 184     private void installChildren() {
 185         root = new TreeItem&lt;String&gt;(&quot;Root&quot;);
 186         child1 = new TreeItem&lt;String&gt;(&quot;Child 1&quot;);
 187         child2 = new TreeItem&lt;String&gt;(&quot;Child 2&quot;);
 188         child3 = new TreeItem&lt;String&gt;(&quot;Child 3&quot;);
 189         root.setExpanded(true);
 190         root.getChildren().setAll(child1, child2, child3);
 191         treeTableView.setRoot(root);
 192     }
 193 
 194     private String debug() {
 195         StringBuilder sb = new StringBuilder(&quot;Selected Cells: [&quot;);
 196 
 197         List&lt;TreeTablePosition&lt;?,?&gt;&gt; cells = sm.getSelectedCells();
 198         for (TreeTablePosition cell : cells) {
 199             sb.append(&quot;(&quot;);
 200             sb.append(cell.getRow());
 201             sb.append(&quot;,&quot;);
 202             sb.append(cell.getColumn());
 203             sb.append(&quot;), &quot;);
 204         }
 205 
 206         sb.append(&quot;] \nFocus: &quot; + fm.getFocusedIndex());
 207 //        sb.append(&quot; \nAnchor: &quot; + getAnchor());
 208         return sb.toString();
 209     }
 210 
 211     @Test public void ensureCorrectInitialState() {
 212         installChildren();
 213         assertEquals(0, treeTableView.getRow(root));
 214         assertEquals(1, treeTableView.getRow(child1));
 215         assertEquals(2, treeTableView.getRow(child2));
 216         assertEquals(3, treeTableView.getRow(child3));
 217     }
 218 
 219 
 220 
 221 
 222 
 223 
 224 
 225 
 226     /***************************************************************************
 227      *
 228      *
 229      * Tests taken from TableViewTest
 230      * (scroll down further for the TreeViewTests)
 231      *
 232      *
 233      **************************************************************************/
 234 
 235     /*********************************************************************
 236      * Tests for the constructors                                        *
 237      ********************************************************************/
 238 
 239     @Test public void noArgConstructorSetsNonNullSelectionModel() {
 240         assertNotNull(sm);
 241     }
 242 
 243     @Test public void noArgConstructor_selectedItemIsNull() {
 244         assertNull(sm.getSelectedItem());
 245     }
 246 
 247     @Test public void noArgConstructor_selectedIndexIsNegativeOne() {
 248         assertEquals(-1, sm.getSelectedIndex());
 249     }
 250 
 251     @Test public void noArgConstructorSetsNonNullSortPolicy() {
 252         assertNotNull(treeTableView.getSortPolicy());
 253     }
 254 
 255     @Test public void noArgConstructorSetsNullComparator() {
 256         assertNull(treeTableView.getComparator());
 257     }
 258 
 259     @Test public void noArgConstructorSetsNullOnSort() {
 260         assertNull(treeTableView.getOnSort());
 261     }
 262 
 263 //    @Test public void singleArgConstructorSetsNonNullSelectionModel() {
 264 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 265 //        assertNotNull(b2.getSelectionModel());
 266 //    }
 267 //
 268 //    @Test public void singleArgConstructorAllowsNullItems() {
 269 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(null);
 270 //        assertNull(b2.getItems());
 271 //    }
 272 //
 273 //    @Test public void singleArgConstructorTakesItems() {
 274 //        ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;Hi&quot;);
 275 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(items);
 276 //        assertSame(items, b2.getItems());
 277 //    }
 278 //
 279 //    @Test public void singleArgConstructor_selectedItemIsNull() {
 280 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 281 //        assertNull(b2.getSelectionModel().getSelectedItem());
 282 //    }
 283 //
 284 //    @Test public void singleArgConstructor_selectedIndexIsNegativeOne() {
 285 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 286 //        assertEquals(-1, b2.getSelectionModel().getSelectedIndex());
 287 //    }
 288 
 289     /*********************************************************************
 290      * Tests for columns                                                 *
 291      ********************************************************************/
 292 
 293     @Test public void testColumns() {
 294         TreeTableColumn col1 = new TreeTableColumn();
 295 
 296         assertNotNull(treeTableView.getColumns());
 297         assertEquals(0, treeTableView.getColumns().size());
 298 
 299         treeTableView.getColumns().add(col1);
 300         assertEquals(1, treeTableView.getColumns().size());
 301 
 302         treeTableView.getColumns().remove(col1);
 303         assertEquals(0, treeTableView.getColumns().size());
 304     }
 305 
 306     @Test public void testVisibleLeafColumns() {
 307         TreeTableColumn col1 = new TreeTableColumn();
 308 
 309         assertNotNull(treeTableView.getColumns());
 310         assertEquals(0, treeTableView.getColumns().size());
 311 
 312         treeTableView.getColumns().add(col1);
 313         assertEquals(1, treeTableView.getVisibleLeafColumns().size());
 314 
 315         treeTableView.getColumns().remove(col1);
 316         assertEquals(0, treeTableView.getVisibleLeafColumns().size());
 317     }
 318 
 319     @Test public void testSortOrderCleanup() {
 320         TreeTableView treeTableView = new TreeTableView();
 321         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 322         first.setCellValueFactory(new PropertyValueFactory(&quot;firstName&quot;));
 323         TreeTableColumn&lt;String,String&gt; second = new TreeTableColumn&lt;String,String&gt;(&quot;second&quot;);
 324         second.setCellValueFactory(new PropertyValueFactory(&quot;lastName&quot;));
 325         treeTableView.getColumns().addAll(first, second);
 326         treeTableView.getSortOrder().setAll(first, second);
 327         treeTableView.getColumns().remove(first);
 328         assertFalse(treeTableView.getSortOrder().contains(first));
 329     }
 330 
 331 
 332     /*********************************************************************
 333      * Tests for new sorting API in JavaFX 8.0                           *
 334      ********************************************************************/
 335 
 336     private TreeItem&lt;String&gt; apple, orange, banana;
 337 
 338     // TODO test for sort policies returning null
 339     // TODO test for changing column sortType out of order
 340 
 341     private static final Callback&lt;TreeTableView&lt;String&gt;, Boolean&gt; NO_SORT_FAILED_SORT_POLICY =
 342             treeTableView1 -&gt; false;
 343 
 344     private static final Callback&lt;TreeTableView&lt;String&gt;, Boolean&gt; SORT_SUCCESS_ASCENDING_SORT_POLICY =
 345             treeTableView1 -&gt; {
 346                 if (treeTableView1.getSortOrder().isEmpty()) return true;
 347                 FXCollections.sort(treeTableView1.getRoot().getChildren(), new Comparator&lt;TreeItem&lt;String&gt;&gt;() {
 348                     @Override public int compare(TreeItem&lt;String&gt; o1, TreeItem&lt;String&gt; o2) {
 349                         return o1.getValue().compareTo(o2.getValue());
 350                     }
 351                 });
 352                 return true;
 353             };
 354 
 355     private TreeTableColumn&lt;String, String&gt; initSortTestStructure() {
 356         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
 357         col.setSortType(ASCENDING);
 358         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
 359         treeTableView.getColumns().add(col);
 360 
 361         TreeItem&lt;String&gt; newRoot = new TreeItem&lt;String&gt;(&quot;root&quot;);
 362         newRoot.setExpanded(true);
 363         newRoot.getChildren().addAll(
 364                 apple  = new TreeItem(&quot;Apple&quot;),
 365                 orange = new TreeItem(&quot;Orange&quot;),
 366                 banana = new TreeItem(&quot;Banana&quot;));
 367 
 368         treeTableView.setRoot(newRoot);
 369 
 370         return col;
 371     }
 372 
<a name="1" id="anc1"></a><span class="line-added"> 373     private int countSelectedIndexChangeEvent;</span>
<span class="line-added"> 374     private int countSelectedItemChangeEvent;</span>
<span class="line-added"> 375     private int countSelectedIndicesChangeEvent;</span>
<span class="line-added"> 376     private int countSelectedItemsChangeEvent;</span>
<span class="line-added"> 377     private TreeItem&lt;String&gt; selectedItemBefore;</span>
<span class="line-added"> 378     private List&lt;TreeItem&lt;String&gt;&gt; selectedItemsBefore;</span>
<span class="line-added"> 379     private List&lt;Integer&gt; selectedIndicesBefore;</span>
<span class="line-added"> 380     private List&lt;TreeTablePosition&lt;String,?&gt;&gt; selectedCellsBefore;</span>
<span class="line-added"> 381 </span>
<span class="line-added"> 382     @Test public void testSelectionUpdatesCorrectlyAfterSort() {</span>
<span class="line-added"> 383         TreeTableColumn&lt;String, String&gt; col = setupForPermutationTest();</span>
<span class="line-added"> 384         treeTableView.getSortOrder().add(col);</span>
<span class="line-added"> 385         verifySelectionAfterPermutation();</span>
<span class="line-added"> 386     }</span>
<span class="line-added"> 387 </span>
<span class="line-added"> 388     @Test public void testSelectionUpdatesCorrectlyAfterRootSetAll() {</span>
<span class="line-added"> 389         setupForPermutationTest();</span>
<span class="line-added"> 390         reverseChildrenOrder(treeTableView.getRoot());</span>
<span class="line-added"> 391         verifySelectionAfterPermutation();</span>
<span class="line-added"> 392     }</span>
<span class="line-added"> 393 </span>
<span class="line-added"> 394     @Test public void testSelectionUpdatesCorrectlyAfterChildSetAll() {</span>
<span class="line-added"> 395         setupForPermutationTest();</span>
<span class="line-added"> 396         reverseChildrenOrder(((TreeItem&lt;String&gt;)sm.getSelectedItem()).getParent());</span>
<span class="line-added"> 397         verifySelectionAfterPermutation();</span>
<span class="line-added"> 398     }</span>
<span class="line-added"> 399 </span>
<span class="line-added"> 400     private void reverseChildrenOrder(TreeItem&lt;String&gt; treeItem) {</span>
<span class="line-added"> 401         List&lt;TreeItem&lt;String&gt;&gt; childrenReversed = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 402         int childrenSize = treeItem.getChildren().size();</span>
<span class="line-added"> 403         for (int i = 0; i &lt; childrenSize; i++) {</span>
<span class="line-added"> 404             childrenReversed.add(treeItem.getChildren().get(childrenSize - 1 - i));</span>
<span class="line-added"> 405         }</span>
<span class="line-added"> 406         treeItem.getChildren().setAll(childrenReversed);</span>
<span class="line-added"> 407     }</span>
<span class="line-added"> 408 </span>
<span class="line-added"> 409     private TreeTableColumn&lt;String, String&gt; setupForPermutationTest() {</span>
<span class="line-added"> 410         countSelectedIndexChangeEvent = 0;</span>
<span class="line-added"> 411         countSelectedItemChangeEvent = 0;</span>
<span class="line-added"> 412         countSelectedIndicesChangeEvent = 0;</span>
<span class="line-added"> 413         countSelectedItemsChangeEvent = 0;</span>
<span class="line-added"> 414 </span>
<span class="line-added"> 415         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);</span>
<span class="line-added"> 416         col.setSortType(DESCENDING);</span>
<span class="line-added"> 417         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));</span>
<span class="line-added"> 418         treeTableView.getColumns().add(col);</span>
<span class="line-added"> 419 </span>
<span class="line-added"> 420         TreeItem&lt;String&gt; treeRoot = new TreeItem&lt;String&gt;(&quot;root&quot;);</span>
<span class="line-added"> 421         treeRoot.setExpanded(true);</span>
<span class="line-added"> 422         treeTableView.setRoot(treeRoot);</span>
<span class="line-added"> 423 </span>
<span class="line-added"> 424         final int FIRST_LEVEL_COUNT = 8;</span>
<span class="line-added"> 425         for (int i = 0; i &lt; FIRST_LEVEL_COUNT; i++) {</span>
<span class="line-added"> 426             TreeItem&lt;String&gt; ti = new TreeItem&lt;&gt;( &quot;&quot; + i);</span>
<span class="line-added"> 427             ti.setExpanded(true);</span>
<span class="line-added"> 428             treeRoot.getChildren().add(ti);</span>
<span class="line-added"> 429 </span>
<span class="line-added"> 430             for (int j = 0; j &lt; FIRST_LEVEL_COUNT - 1; j++) {</span>
<span class="line-added"> 431                 TreeItem&lt;String&gt; tj = new TreeItem&lt;&gt;(&quot;&quot; + i + j);</span>
<span class="line-added"> 432                 tj.setExpanded(true);</span>
<span class="line-added"> 433                 ti.getChildren().add(tj);</span>
<span class="line-added"> 434 </span>
<span class="line-added"> 435                 for (int k = 0; k &lt; FIRST_LEVEL_COUNT - 2; k++) {</span>
<span class="line-added"> 436                     TreeItem&lt;String&gt; tk = new TreeItem&lt;&gt;(&quot;&quot; + i + j + k);</span>
<span class="line-added"> 437                     tk.setExpanded(true);</span>
<span class="line-added"> 438                     tj.getChildren().add(tk);</span>
<span class="line-added"> 439 </span>
<span class="line-added"> 440                     for (int l = 0; l &lt; FIRST_LEVEL_COUNT - 3; l++) {</span>
<span class="line-added"> 441                         TreeItem&lt;String&gt; tl = new TreeItem&lt;&gt;(&quot;&quot; + i + j + k + l);</span>
<span class="line-added"> 442                         tl.setExpanded(true);</span>
<span class="line-added"> 443                         tk.getChildren().add(tl);</span>
<span class="line-added"> 444 </span>
<span class="line-added"> 445                         for (int m = 0; m &lt; FIRST_LEVEL_COUNT - 4; m++) {</span>
<span class="line-added"> 446                             TreeItem&lt;String&gt; tm = new TreeItem&lt;&gt;(&quot;&quot; + i + j + k + l + m);</span>
<span class="line-added"> 447                             tl.getChildren().add(tm);</span>
<span class="line-added"> 448                         }</span>
<span class="line-added"> 449                     }</span>
<span class="line-added"> 450                 }</span>
<span class="line-added"> 451             }</span>
<span class="line-added"> 452         }</span>
<span class="line-added"> 453 </span>
<span class="line-added"> 454         sm.setSelectionMode(SelectionMode.MULTIPLE);</span>
<span class="line-added"> 455         int indices[] = new int[] {1, 400, 800, 1200, 1600, 2000, 2400, 2800, 3200, 3600, 4000, 4400, 4800, 5200, 5600, 6000, 6400};</span>
<span class="line-added"> 456         sm.selectIndices(1, 400, 800, 1200, 1600, 2000, 2400, 2800, 3200, 3600, 4000, 4400, 4800, 5200, 5600, 6000, 6400);</span>
<span class="line-added"> 457 </span>
<span class="line-added"> 458         // Sanity checks</span>
<span class="line-added"> 459         assertEquals(indices.length, sm.getSelectedIndices().size());</span>
<span class="line-added"> 460         assertEquals(indices.length, sm.getSelectedItems().size());</span>
<span class="line-added"> 461         assertEquals(indices.length, sm.getSelectedCells().size());</span>
<span class="line-added"> 462         assertEquals(indices[indices.length - 1], sm.getSelectedIndex());</span>
<span class="line-added"> 463         assertEquals(treeTableView.getTreeItem(indices[indices.length - 1]), sm.getSelectedItem());</span>
<span class="line-added"> 464 </span>
<span class="line-added"> 465         selectedItemBefore = (TreeItem&lt;String&gt;) sm.getSelectedItem();</span>
<span class="line-added"> 466         selectedItemsBefore = new ArrayList&lt;&gt;(sm.getSelectedItems());</span>
<span class="line-added"> 467         selectedIndicesBefore = new ArrayList&lt;&gt;(sm.getSelectedIndices());</span>
<span class="line-added"> 468         selectedCellsBefore = new ArrayList&lt;&gt;(sm.getSelectedCells());</span>
<span class="line-added"> 469 </span>
<span class="line-added"> 470         sm.selectedIndexProperty().addListener(ov -&gt; {</span>
<span class="line-added"> 471             countSelectedIndexChangeEvent++;</span>
<span class="line-added"> 472             assertEquals(selectedItemBefore, treeTableView.getTreeItem(sm.getSelectedIndex()));</span>
<span class="line-added"> 473         });</span>
<span class="line-added"> 474         sm.selectedItemProperty().addListener(l -&gt; {</span>
<span class="line-added"> 475             countSelectedItemChangeEvent++;</span>
<span class="line-added"> 476         });</span>
<span class="line-added"> 477         sm.getSelectedIndices().addListener((ListChangeListener) c -&gt; {</span>
<span class="line-added"> 478             countSelectedIndicesChangeEvent++;</span>
<span class="line-added"> 479             c.next();</span>
<span class="line-added"> 480             if (c.wasRemoved()) {</span>
<span class="line-added"> 481                 assertTrue(selectedIndicesBefore.equals(c.getRemoved()));</span>
<span class="line-added"> 482             }</span>
<span class="line-added"> 483             verifySelectedIndices(c.getAddedSubList());</span>
<span class="line-added"> 484             verifySelectedIndices(c.getList());</span>
<span class="line-added"> 485         });</span>
<span class="line-added"> 486         sm.getSelectedItems().addListener((ListChangeListener) c -&gt; {</span>
<span class="line-added"> 487             countSelectedItemsChangeEvent++;</span>
<span class="line-added"> 488             c.next();</span>
<span class="line-added"> 489             if (c.wasRemoved()) {</span>
<span class="line-added"> 490                 verifySelectedItems(c.getRemoved());</span>
<span class="line-added"> 491             }</span>
<span class="line-added"> 492             verifySelectedItems(c.getAddedSubList());</span>
<span class="line-added"> 493             verifySelectedItems(c.getList());</span>
<span class="line-added"> 494         });</span>
<span class="line-added"> 495 </span>
<span class="line-added"> 496         return col;</span>
<span class="line-added"> 497     }</span>
<span class="line-added"> 498 </span>
<span class="line-added"> 499     private void verifySelectedCells(List&lt;TreeTablePosition&lt;String, ?&gt;&gt; selectedCells) {</span>
<span class="line-added"> 500         assertEquals(selectedCellsBefore.size(), selectedCells.size());</span>
<span class="line-added"> 501         for (TreeTablePosition beforePos : selectedCellsBefore) {</span>
<span class="line-added"> 502             boolean isCellStillSelected = false;</span>
<span class="line-added"> 503             for (TreeTablePosition afterPos : selectedCells) {</span>
<span class="line-added"> 504                 if ((beforePos.getTreeItem() == afterPos.getTreeItem()) &amp;&amp;</span>
<span class="line-added"> 505                         (beforePos.getTableColumn() == afterPos.getTableColumn()) &amp;&amp;</span>
<span class="line-added"> 506                         (beforePos.getColumn() == afterPos.getColumn())) {</span>
<span class="line-added"> 507                     isCellStillSelected = true;</span>
<span class="line-added"> 508                 }</span>
<span class="line-added"> 509             }</span>
<span class="line-added"> 510             assertTrue(&quot;The item (&quot; + beforePos.getRow() + &quot;, &quot; + beforePos.getColumn() +</span>
<span class="line-added"> 511                     &quot;) lost selection during permutation&quot;, isCellStillSelected);</span>
<span class="line-added"> 512         }</span>
<span class="line-added"> 513     }</span>
<span class="line-added"> 514 </span>
<span class="line-added"> 515     private void verifySelectedItems(List&lt;TreeItem&lt;String&gt;&gt; selectedItems) {</span>
<span class="line-added"> 516         assertEquals(selectedItemsBefore.size(), selectedItems.size());</span>
<span class="line-added"> 517         for (TreeItem&lt;String&gt; item : selectedItemsBefore) {</span>
<span class="line-added"> 518             assertTrue(&quot;The item (&quot; + item + &quot;) lost selection during permutation&quot;,</span>
<span class="line-added"> 519                     selectedItems.contains(item));</span>
<span class="line-added"> 520         }</span>
<span class="line-added"> 521     }</span>
<span class="line-added"> 522 </span>
<span class="line-added"> 523     private void verifySelectedIndices(List&lt;Integer&gt; currentIndices) {</span>
<span class="line-added"> 524         assertEquals(selectedIndicesBefore.size(), currentIndices.size());</span>
<span class="line-added"> 525         for (Integer row : currentIndices) {</span>
<span class="line-added"> 526             assertTrue(selectedItemsBefore.contains(treeTableView.getTreeItem(row)));</span>
<span class="line-added"> 527         }</span>
<span class="line-added"> 528     }</span>
<span class="line-added"> 529 </span>
<span class="line-added"> 530     private void verifySelectionAfterPermutation() {</span>
<span class="line-added"> 531         assertEquals(1, countSelectedIndexChangeEvent);</span>
<span class="line-added"> 532         assertEquals(0, countSelectedItemChangeEvent);</span>
<span class="line-added"> 533         assertEquals(1, countSelectedIndicesChangeEvent);</span>
<span class="line-added"> 534         assertEquals(1, countSelectedItemsChangeEvent);</span>
<span class="line-added"> 535 </span>
<span class="line-added"> 536         assertEquals(&quot;Selected Item should remain same&quot;, selectedItemBefore, sm.getSelectedItem());</span>
<span class="line-added"> 537         assertEquals(&quot;Selected index should be updated&quot;, treeTableView.getRow(selectedItemBefore), sm.getSelectedIndex());</span>
<span class="line-added"> 538 </span>
<span class="line-added"> 539         verifySelectedCells(sm.getSelectedCells());</span>
<span class="line-added"> 540         verifySelectedItems(sm.getSelectedItems());</span>
<span class="line-added"> 541         verifySelectedIndices(sm.getSelectedIndices());</span>
<span class="line-added"> 542     }</span>
<span class="line-added"> 543 </span>
 544     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 545     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeSortOrderList() {
 546         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 547         treeTableView.setOnSort(event -&gt; {
 548             event.consume();
 549         });
 550 
 551         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 552         treeTableView.getSortOrder().add(col);
 553         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 554 
 555         // the sort order list should be returned back to its original state
 556         assertTrue(treeTableView.getSortOrder().isEmpty());
 557     }
 558 
 559     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeSortOrderList() {
 560         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 561         treeTableView.setOnSort(event -&gt; {
 562             // do not consume here - this allows the sort to happen
 563         });
 564 
 565         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 566         treeTableView.getSortOrder().add(col);
 567         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 568 
 569         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 570     }
 571 
 572     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 573     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_AscendingToDescending() {
 574         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 575         assertEquals(ASCENDING, col.getSortType());
 576         treeTableView.getSortOrder().add(col);
 577         treeTableView.setOnSort(event -&gt; {
 578             event.consume();
 579         });
 580 
 581         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 582 
 583         // when we change from ASCENDING to DESCENDING we don&#39;t expect the sort
 584         // to actually change (and in fact we expect the sort type to resort
 585         // back to being ASCENDING)
 586         col.setSortType(DESCENDING);
 587         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 588         assertEquals(ASCENDING, col.getSortType());
 589 
 590         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 591     }
 592 
 593     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_AscendingToDescending() {
 594         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 595         assertEquals(ASCENDING, col.getSortType());
 596         treeTableView.getSortOrder().add(col);
 597         treeTableView.setOnSort(event -&gt; {
 598             // do not consume here - this allows the sort to happen
 599         });
 600 
 601         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 602 
 603         col.setSortType(DESCENDING);
 604         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 605         assertEquals(DESCENDING, col.getSortType());
 606 
 607         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 608     }
 609 
 610     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 611     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_DescendingToNull() {
 612         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 613         col.setSortType(DESCENDING);
 614         assertEquals(DESCENDING, col.getSortType());
 615         treeTableView.getSortOrder().add(col);
 616         treeTableView.setOnSort(event -&gt; {
 617             event.consume();
 618         });
 619 
 620         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 621 
 622         col.setSortType(null);
 623         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 624         assertEquals(DESCENDING, col.getSortType());
 625 
 626         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 627     }
 628 
 629     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_DescendingToNull() {
 630         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 631         col.setSortType(DESCENDING);
 632         assertEquals(DESCENDING, col.getSortType());
 633         treeTableView.getSortOrder().add(col);
 634         treeTableView.setOnSort(event -&gt; {
 635             // do not consume here - this allows the sort to happen
 636         });
 637 
 638         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 639 
 640         col.setSortType(null);
 641         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 642         assertNull(col.getSortType());
 643 
 644         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 645     }
 646 
 647     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 648     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_NullToAscending() {
 649         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 650         col.setSortType(null);
 651         assertNull(col.getSortType());
 652         treeTableView.getSortOrder().add(col);
 653         treeTableView.setOnSort(event -&gt; {
 654             event.consume();
 655         });
 656 
 657         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 658 
 659         col.setSortType(ASCENDING);
 660         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 661         assertNull(col.getSortType());
 662 
 663         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 664     }
 665 
 666     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_NullToAscending() {
 667         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 668         col.setSortType(null);
 669         assertNull(col.getSortType());
 670         treeTableView.getSortOrder().add(col);
 671         treeTableView.setOnSort(event -&gt; {
 672             // do not consume here - this allows the sort to happen
 673         });
 674 
 675         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 676 
 677         col.setSortType(ASCENDING);
 678         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 679         assertEquals(ASCENDING, col.getSortType());
 680 
 681         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 682     }
 683 
 684     @Test public void testSortMethodWithNullSortPolicy() {
 685         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 686         treeTableView.setSortPolicy(null);
 687         assertNull(treeTableView.getSortPolicy());
 688         treeTableView.sort();
 689     }
 690 
 691     @Test public void testChangingSortPolicyUpdatesItemsList() {
 692         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 693         col.setSortType(DESCENDING);
 694         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 695         treeTableView.getSortOrder().add(col);
 696         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 697         treeTableView.setSortPolicy(SORT_SUCCESS_ASCENDING_SORT_POLICY);
 698         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 699     }
 700 
 701     @Test public void testChangingSortPolicyDoesNotUpdateItemsListWhenTheSortOrderListIsEmpty() {
 702         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 703         col.setSortType(DESCENDING);
 704         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 705 
 706         treeTableView.setSortPolicy(SORT_SUCCESS_ASCENDING_SORT_POLICY);
 707         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 708     }
 709 
 710     @Test public void testFailedSortPolicyBacksOutLastChange_sortOrderAddition() {
 711         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 712         col.setSortType(DESCENDING);
 713         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 714         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 715 
 716         treeTableView.getSortOrder().add(col);
 717 
 718         // no sort should be run (as we have a custom sort policy), and the
 719         // sortOrder list should be empty as the sortPolicy failed
 720         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 721         assertTrue(treeTableView.getSortOrder().isEmpty());
 722     }
 723 
 724     @Test public void testFailedSortPolicyBacksOutLastChange_sortOrderRemoval() {
 725         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 726         col.setSortType(DESCENDING);
 727         treeTableView.getSortOrder().add(col);
 728         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 729 
 730         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 731 
 732         // even though we remove the column from the sort order here, because the
 733         // sort policy fails the items list should remain unchanged and the sort
 734         // order list should continue to have the column in it.
 735         treeTableView.getSortOrder().remove(col);
 736         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 737         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 738     }
 739 
 740     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_ascendingToDescending() {
 741         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 742         col.setSortType(ASCENDING);
 743         treeTableView.getSortOrder().add(col);
 744         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 745 
 746         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 747 
 748         col.setSortType(DESCENDING);
 749         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 750         assertEquals(ASCENDING, col.getSortType());
 751     }
 752 
 753     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_descendingToNull() {
 754         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 755         col.setSortType(DESCENDING);
 756         treeTableView.getSortOrder().add(col);
 757         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 758 
 759         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 760 
 761         col.setSortType(null);
 762         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 763         assertEquals(DESCENDING, col.getSortType());
 764     }
 765 
 766     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_nullToAscending() {
 767         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 768         col.setSortType(null);
 769         treeTableView.getSortOrder().add(col);
 770         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 771 
 772         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 773 
 774         col.setSortType(ASCENDING);
 775         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 776         assertNull(col.getSortType());
 777     }
 778 
 779     @Test public void testComparatorChangesInSyncWithSortOrder_1() {
 780         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 781         assertNull(treeTableView.getComparator());
 782         assertTrue(treeTableView.getSortOrder().isEmpty());
 783 
 784         treeTableView.getSortOrder().add(col);
 785         TreeTableColumnComparator c = (TreeTableColumnComparator)treeTableView.getComparator();
 786         assertNotNull(c);
 787         VirtualFlowTestUtils.assertListContainsItemsInOrder(c.getColumns(), col);
 788     }
 789 
 790     @Test public void testComparatorChangesInSyncWithSortOrder_2() {
 791         // same as test above
 792         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 793         assertNull(treeTableView.getComparator());
 794         assertTrue(treeTableView.getSortOrder().isEmpty());
 795 
 796         treeTableView.getSortOrder().add(col);
 797         TreeTableColumnComparator c = (TreeTableColumnComparator)treeTableView.getComparator();
 798         assertNotNull(c);
 799         VirtualFlowTestUtils.assertListContainsItemsInOrder(c.getColumns(), col);
 800 
 801         // now remove column from sort order, and the comparator should go to
 802         // being null
 803         treeTableView.getSortOrder().remove(col);
 804         assertNull(treeTableView.getComparator());
 805     }
 806 
 807     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortOrderAddition() {
 808         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 809         final TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 810 
 811         col.setSortType(DESCENDING);
 812         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 813         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 814 
 815         treeTableView.getSortOrder().add(col);
 816 
 817         assertEquals(oldComparator, treeTableView.getComparator());
 818     }
 819 
 820     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortOrderRemoval() {
 821         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 822         TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 823         assertNull(oldComparator);
 824 
 825         col.setSortType(DESCENDING);
 826         treeTableView.getSortOrder().add(col);
 827         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 828         oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 829         VirtualFlowTestUtils.assertListContainsItemsInOrder(oldComparator.getColumns(), col);
 830 
 831         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 832         treeTableView.getSortOrder().remove(col);
 833 
 834         assertTrue(treeTableView.getSortOrder().contains(col));
 835         VirtualFlowTestUtils.assertListContainsItemsInOrder(oldComparator.getColumns(), col);
 836     }
 837 
 838     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortTypeChange() {
 839         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 840         final TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 841         assertNull(oldComparator);
 842 
 843         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 844         treeTableView.getSortOrder().add(col);
 845         col.setSortType(ASCENDING);
 846 
 847         assertTrue(treeTableView.getSortOrder().isEmpty());
 848         assertNull(oldComparator);
 849     }
 850 
 851 
 852 
 853     /*********************************************************************
 854      * Tests for specific bugs                                           *
 855      ********************************************************************/
 856 //    @Test public void test_rt16019() {
 857 //        // RT-16019: NodeMemory TableView tests fail with
 858 //        // IndexOutOfBoundsException (ObservableListWrapper.java:336)
 859 //        TreeTableView treeTableView = new TreeTableView();
 860 //        for (int i = 0; i &lt; 1000; i++) {
 861 //            treeTableView.getItems().add(&quot;data &quot; + i);
 862 //        }
 863 //    }
 864 //
 865 //    @Test public void test_rt15793() {
 866 //        // ListView/TableView selectedIndex is 0 although the items list is empty
 867 //        final TreeTableView tv = new TreeTableView();
 868 //        final ObservableList list = FXCollections.observableArrayList();
 869 //        tv.setItems(list);
 870 //        list.add(&quot;toto&quot;);
 871 //        tv.getSelectionModel().select(0);
 872 //        assertEquals(0, tv.getSelectionModel().getSelectedIndex());
 873 //        list.remove(0);
 874 //        assertEquals(-1, tv.getSelectionModel().getSelectedIndex());
 875 //    }
 876 //
 877 //    @Test public void test_rt17522_focusShouldMoveWhenItemAddedAtFocusIndex() {
 878 //        final TreeTableView lv = new TreeTableView();
 879 //        FocusModel fm = lv.getFocusModel();
 880 //        lv.getItems().add(&quot;row1&quot;);
 881 //        fm.focus(0);
 882 //        assertTrue(fm.isFocused(0));
 883 //
 884 //        lv.getItems().add(0, &quot;row0&quot;);
 885 //        assertTrue(fm.isFocused(1));
 886 //    }
 887 //
 888 //    @Test public void test_rt17522_focusShouldMoveWhenItemAddedBeforeFocusIndex() {
 889 //        final TreeTableView lv = new TreeTableView();
 890 //        FocusModel fm = lv.getFocusModel();
 891 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 892 //        fm.focus(1);
 893 //        assertTrue(fm.isFocused(1));
 894 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 895 //
 896 //        lv.getItems().add(1, &quot;row0&quot;);
 897 //        assertTrue(fm.isFocused(2));
 898 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 899 //        assertFalse(fm.isFocused(1));
 900 //    }
 901 //
 902 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemAddedAfterFocusIndex() {
 903 //        final TreeTableView lv = new TreeTableView();
 904 //        FocusModel fm = lv.getFocusModel();
 905 //        lv.getItems().addAll(&quot;row1&quot;);
 906 //        fm.focus(0);
 907 //        assertTrue(fm.isFocused(0));
 908 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 909 //
 910 //        lv.getItems().add(1, &quot;row2&quot;);
 911 //        assertTrue(fm.isFocused(0));
 912 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 913 //        assertFalse(fm.isFocused(1));
 914 //    }
 915 //
 916 //    @Test public void test_rt17522_focusShouldBeResetWhenFocusedItemIsRemoved() {
 917 //        final TreeTableView lv = new TreeTableView();
 918 //        FocusModel fm = lv.getFocusModel();
 919 //        lv.getItems().add(&quot;row1&quot;);
 920 //        fm.focus(0);
 921 //        assertTrue(fm.isFocused(0));
 922 //
 923 //        lv.getItems().remove(&quot;row1&quot;);
 924 //        assertTrue(fm.getFocusedIndex() == -1);
 925 //        assertNull(fm.getFocusedItem());
 926 //    }
 927 //
 928 //    @Test public void test_rt17522_focusShouldMoveWhenItemRemovedBeforeFocusIndex() {
 929 //        final TreeTableView lv = new TreeTableView();
 930 //        FocusModel fm = lv.getFocusModel();
 931 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 932 //        fm.focus(1);
 933 //        assertTrue(fm.isFocused(1));
 934 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 935 //
 936 //        lv.getItems().remove(&quot;row1&quot;);
 937 //        assertTrue(fm.isFocused(0));
 938 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 939 //    }
 940 //
 941 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemRemovedAfterFocusIndex() {
 942 //        final TreeTableView lv = new TreeTableView();
 943 //        FocusModel fm = lv.getFocusModel();
 944 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 945 //        fm.focus(0);
 946 //        assertTrue(fm.isFocused(0));
 947 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 948 //
 949 //        lv.getItems().remove(&quot;row2&quot;);
 950 //        assertTrue(fm.isFocused(0));
 951 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 952 //    }
 953 //
 954 //    @Test public void test_rt18385() {
 955 //        treeTableView.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;);
 956 //        sm.select(1);
 957 //        treeTableView.getItems().add(&quot;Another Row&quot;);
 958 //        assertEquals(1, sm.getSelectedIndices().size());
 959 //        assertEquals(1, sm.getSelectedItems().size());
 960 //        assertEquals(1, sm.getSelectedCells().size());
 961 //    }
 962 
 963     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsFalse_columnEditableIsFalse() {
 964         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 965         first.setEditable(false);
 966         treeTableView.getColumns().add(first);
 967         treeTableView.setEditable(false);
 968         treeTableView.edit(1, first);
 969         assertEquals(null, treeTableView.getEditingCell());
 970     }
 971 
 972     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsFalse_columnEditableIsTrue() {
 973         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 974         first.setEditable(true);
 975         treeTableView.getColumns().add(first);
 976         treeTableView.setEditable(false);
 977         treeTableView.edit(1, first);
 978         assertEquals(null, treeTableView.getEditingCell());
 979     }
 980 
 981     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsTrue_columnEditableIsFalse() {
 982         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 983         first.setEditable(false);
 984         treeTableView.getColumns().add(first);
 985         treeTableView.setEditable(true);
 986         treeTableView.edit(1, first);
 987         assertEquals(null, treeTableView.getEditingCell());
 988     }
 989 
 990     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsTrue_columnEditableIsTrue() {
 991         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 992         first.setEditable(true);
 993         treeTableView.getColumns().add(first);
 994         treeTableView.setEditable(true);
 995         treeTableView.edit(1, first);
 996         assertEquals(new TreeTablePosition(treeTableView, 1, first), treeTableView.getEditingCell());
 997     }
 998 
 999 //    @Test public void test_rt14451() {
1000 //        treeTableView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
1001 //        sm.setSelectionMode(SelectionMode.MULTIPLE);
1002 //        sm.selectRange(0, 2); // select from 0 (inclusive) to 2 (exclusive)
1003 //        assertEquals(2, sm.getSelectedIndices().size());
1004 //    }
1005 //
1006 //    @Test public void test_rt21586() {
1007 //        treeTableView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
1008 //        treeTableView.getSelectionModel().select(1);
1009 //        assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1010 //        assertEquals(&quot;Orange&quot;, treeTableView.getSelectionModel().getSelectedItem());
1011 //
1012 //        treeTableView.getItems().setAll(&quot;Kiwifruit&quot;, &quot;Pineapple&quot;, &quot;Grape&quot;);
1013 //        assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1014 //        assertNull(treeTableView.getSelectionModel().getSelectedItem());
1015 //    }
1016 
1017 
1018 
1019 
1020 
1021 
1022 
1023 
1024 
1025 
1026 
1027 
1028 
1029 
1030 
1031     /***************************************************************************
1032      *
1033      *
1034      * Tests taken from TreeViewTest
1035      *
1036      *
1037      **************************************************************************/
1038 
1039 
1040 
1041 
1042     /*********************************************************************
1043      * Tests for the constructors                                        *
1044      ********************************************************************/
1045 
1046     @Test public void noArgConstructorSetsTheStyleClass() {
1047         assertStyleClassContains(treeTableView, &quot;tree-table-view&quot;);
1048     }
1049 
1050     @Test public void noArgConstructorSetsNullItems() {
1051         assertNull(treeTableView.getRoot());
1052     }
1053 
1054     @Test public void singleArgConstructorSetsTheStyleClass() {
1055         final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(new TreeItem&lt;String&gt;(&quot;Hi&quot;));
1056         assertStyleClassContains(b2, &quot;tree-table-view&quot;);
1057     }
1058 
1059     /*********************************************************************
1060      * Tests for selection model                                         *
1061      ********************************************************************/
1062 
1063     @Test public void selectionModelCanBeNull() {
1064         treeTableView.setSelectionModel(null);
1065         assertNull(treeTableView.getSelectionModel());
1066     }
1067 
1068     @Test public void selectionModelCanBeBound() {
1069         TableSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm =
1070                 TreeTableViewShim.&lt;String&gt;get_TreeTableViewArrayListSelectionModel(treeTableView);
1071         ObjectProperty&lt;TreeTableView.TreeTableViewSelectionModel&lt;String&gt;&gt; other =
1072                 new SimpleObjectProperty(sm);
1073         treeTableView.selectionModelProperty().bind(other);
1074         assertSame(sm, treeTableView.getSelectionModel());
1075     }
1076 
1077     @Test public void selectionModelCanBeChanged() {
1078         TableSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm =
1079                 TreeTableViewShim.&lt;String&gt;get_TreeTableViewArrayListSelectionModel(treeTableView);
1080         TreeTableViewShim.&lt;String&gt;setSelectionModel(treeTableView, sm);
1081         assertSame(sm, treeTableView.getSelectionModel());
1082     }
1083 
1084     @Test public void canSetSelectedItemToAnItemEvenWhenThereAreNoItems() {
1085         TreeItem&lt;String&gt; element = new TreeItem&lt;String&gt;(&quot;I AM A CRAZY RANDOM STRING&quot;);
1086         treeTableView.getSelectionModel().select(element);
1087         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1088         assertSame(element, treeTableView.getSelectionModel().getSelectedItem());
1089     }
1090 
1091     @Test public void canSetSelectedItemToAnItemNotInTheDataModel() {
1092         installChildren();
1093         TreeItem&lt;String&gt; element = new TreeItem&lt;String&gt;(&quot;I AM A CRAZY RANDOM STRING&quot;);
1094         treeTableView.getSelectionModel().select(element);
1095         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1096         assertSame(element, treeTableView.getSelectionModel().getSelectedItem());
1097     }
1098 
1099     @Test public void settingTheSelectedItemToAnItemInItemsResultsInTheCorrectSelectedIndex() {
1100         installChildren();
1101         treeTableView.getSelectionModel().select(child1);
1102         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1103         assertSame(child1, treeTableView.getSelectionModel().getSelectedItem());
1104     }
1105 
1106     @Ignore(&quot;Not yet supported&quot;)
1107     @Test public void settingTheSelectedItemToANonexistantItemAndThenSettingItemsWhichContainsItResultsInCorrectSelectedIndex() {
1108         treeTableView.getSelectionModel().select(child1);
1109         installChildren();
1110         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1111         assertSame(child1, treeTableView.getSelectionModel().getSelectedItem());
1112     }
1113 
1114     @Ignore(&quot;Not yet supported&quot;)
1115     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex0() {
1116         installChildren();
1117         treeTableView.getSelectionModel().select(0);
1118         treeTableView.setRoot(null);
1119         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1120         assertEquals(null, treeTableView.getSelectionModel().getSelectedItem());
1121     }
1122 
1123     @Ignore(&quot;Not yet supported&quot;)
1124     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex2() {
1125         installChildren();
1126         treeTableView.getSelectionModel().select(2);
1127         treeTableView.setRoot(null);
1128         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1129         assertEquals(null, treeTableView.getSelectionModel().getSelectedItem());
1130     }
1131 
1132     @Ignore(&quot;Not yet supported&quot;)
1133     @Test public void ensureSelectedItemRemainsAccurateWhenItemsAreCleared() {
1134         installChildren();
1135         treeTableView.getSelectionModel().select(2);
1136         treeTableView.setRoot(null);
1137         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1138         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1139 
1140         TreeItem&lt;String&gt; newRoot = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1141         TreeItem&lt;String&gt; newChild1 = new TreeItem&lt;String&gt;(&quot;New Child 1&quot;);
1142         TreeItem&lt;String&gt; newChild2 = new TreeItem&lt;String&gt;(&quot;New Child 2&quot;);
1143         TreeItem&lt;String&gt; newChild3 = new TreeItem&lt;String&gt;(&quot;New Child 3&quot;);
1144         newRoot.setExpanded(true);
1145         newRoot.getChildren().setAll(newChild1, newChild2, newChild3);
1146         treeTableView.setRoot(root);
1147 
1148         treeTableView.getSelectionModel().select(2);
1149         assertEquals(newChild2, treeTableView.getSelectionModel().getSelectedItem());
1150     }
1151 
1152     @Test public void ensureSelectionIsCorrectWhenItemsChange() {
1153         installChildren();
1154         treeTableView.getSelectionModel().select(0);
1155         assertEquals(root, treeTableView.getSelectionModel().getSelectedItem());
1156 
1157         TreeItem newRoot = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1158         treeTableView.setRoot(newRoot);
1159         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1160         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1161         assertEquals(0, treeTableView.getFocusModel().getFocusedIndex());
1162         assertEquals(newRoot, treeTableView.getFocusModel().getFocusedItem());
1163     }
1164 
1165     @Test public void ensureSelectionRemainsOnBranchWhenExpanded() {
1166         installChildren();
1167         root.setExpanded(false);
1168         treeTableView.getSelectionModel().select(0);
1169         assertTrue(treeTableView.getSelectionModel().isSelected(0));
1170         root.setExpanded(true);
1171         assertTrue(treeTableView.getSelectionModel().isSelected(0));
1172         assertTrue(treeTableView.getSelectionModel().getSelectedItems().contains(root));
1173     }
1174 
1175     /*********************************************************************
1176      * Tests for misc                                                    *
1177      ********************************************************************/
1178     @Test public void ensureRootIndexIsZeroWhenRootIsShowing() {
1179         installChildren();
1180         assertEquals(0, treeTableView.getRow(root));
1181     }
1182 
1183     @Test public void ensureRootIndexIsNegativeOneWhenRootIsNotShowing() {
1184         installChildren();
1185         treeTableView.setShowRoot(false);
1186         assertEquals(-1, treeTableView.getRow(root));
1187     }
1188 
1189     @Test public void ensureCorrectIndexWhenRootTreeItemHasParent() {
1190         installChildren();
1191         treeTableView.setRoot(child1);
1192         assertEquals(-1, treeTableView.getRow(root));
1193         assertEquals(0, treeTableView.getRow(child1));
1194         assertEquals(1, treeTableView.getRow(child2));
1195         assertEquals(2, treeTableView.getRow(child3));
1196     }
1197 
1198     @Test public void ensureCorrectIndexWhenRootTreeItemHasParentAndRootIsNotShowing() {
1199         installChildren();
1200         treeTableView.setRoot(child1);
1201         treeTableView.setShowRoot(false);
1202 
1203         // despite the fact there are children in this tree, in reality none are
1204         // visible as the root node has no children (only siblings), and the
1205         // root node is not visible.
1206         assertEquals(0, treeTableView.getExpandedItemCount());
1207 
1208         assertEquals(-1, treeTableView.getRow(root));
1209         assertEquals(-1, treeTableView.getRow(child1));
1210         assertEquals(-1, treeTableView.getRow(child2));
1211         assertEquals(-1, treeTableView.getRow(child3));
1212     }
1213 
1214     @Test public void ensureCorrectIndexWhenRootTreeItemIsCollapsed() {
1215         installChildren();
1216         root.setExpanded(false);
1217         assertEquals(0, treeTableView.getRow(root));
1218 
1219         // note that the indices are negative, as these children rows are not
1220         // visible in the tree
1221         assertEquals(-1, treeTableView.getRow(child1));
1222         assertEquals(-1, treeTableView.getRow(child2));
1223         assertEquals(-1, treeTableView.getRow(child3));
1224     }
1225 
1226 //    @Test public void removingLastTest() {
1227 //        TreeTableView tree_view = new TreeTableView();
1228 //        MultipleSelectionModel sm = tree_view.getSelectionModel();
1229 //        TreeItem&lt;String&gt; tree_model = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1230 //        TreeItem node = new TreeItem(&quot;Data item&quot;);
1231 //        tree_model.getChildren().add(node);
1232 //        tree_view.setRoot(tree_model);
1233 //        tree_model.setExpanded(true);
1234 //        // select the &#39;Data item&#39; in the selection model
1235 //        sm.select(tree_model.getChildren().get(0));
1236 //        // remove the &#39;Data item&#39; from the root node
1237 //        tree_model.getChildren().remove(sm.getSelectedItem());
1238 //        // assert the there are no selected items any longer
1239 //        assertTrue(&quot;items: &quot; + sm.getSelectedItem(), sm.getSelectedItems().isEmpty());
1240 //    }
1241 
1242     /*********************************************************************
1243      * Tests from bug reports                                            *
1244      ********************************************************************/
1245     @Ignore @Test public void test_rt17112() {
1246         TreeItem&lt;String&gt; root1 = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1247         root1.setExpanded(true);
1248         addChildren(root1, &quot;child&quot;);
1249         for (TreeItem child : root1.getChildren()) {
1250             addChildren(child, (String)child.getValue());
1251             child.setExpanded(true);
1252         }
1253 
1254         final TreeTableView treeTableView1 = new TreeTableView();
1255         final MultipleSelectionModel sm = treeTableView1.getSelectionModel();
1256         sm.setSelectionMode(SelectionMode.MULTIPLE);
1257         treeTableView1.setRoot(root1);
1258 
1259         final TreeItem&lt;String&gt; rt17112_child1 = root1.getChildren().get(1);
1260         final TreeItem&lt;String&gt; rt17112_child1_0 = rt17112_child1.getChildren().get(0);
1261         final TreeItem&lt;String&gt; rt17112_child2 = root1.getChildren().get(2);
1262 
1263         sm.getSelectedItems().addListener(new InvalidationListener() {
1264             int count = 0;
1265             @Override public void invalidated(Observable observable) {
1266                 if (count == 0) {
1267                     assertEquals(rt17112_child1_0, sm.getSelectedItem());
1268                     assertEquals(1, sm.getSelectedIndices().size());
1269                     assertEquals(6, sm.getSelectedIndex());
1270                     assertTrue(treeTableView1.getFocusModel().isFocused(6));
1271                 } else if (count == 1) {
1272                     assertEquals(rt17112_child1, sm.getSelectedItem());
1273                     assertFalse(sm.getSelectedItems().contains(rt17112_child2));
1274                     assertEquals(1, sm.getSelectedIndices().size());
1275                     assertTrue(treeTableView1.getFocusModel().isFocused(5));
1276                 }
1277                 count++;
1278             }
1279         });
1280 
1281         // this triggers the first callback above, so that count == 0
1282         sm.select(rt17112_child1_0);
1283 
1284         // this triggers the second callback above, so that count == 1
1285         rt17112_child1.setExpanded(false);
1286     }
1287     private void addChildren(TreeItem parent, String name) {
1288         for (int i=0; i&lt;3; i++) {
1289             TreeItem&lt;String&gt; ti = new TreeItem&lt;String&gt;(name+&quot;-&quot;+i);
1290             parent.getChildren().add(ti);
1291         }
1292     }
1293 
1294     @Test public void test_rt17522_focusShouldMoveWhenItemAddedAtFocusIndex_1() {
1295         installChildren();
1296         FocusModel fm = treeTableView.getFocusModel();
1297         fm.focus(1);    // focus on child1
1298         assertTrue(fm.isFocused(1));
1299         assertEquals(child1, fm.getFocusedItem());
1300 
1301         TreeItem child0 = new TreeItem(&quot;child0&quot;);
1302         root.getChildren().add(0, child0);  // 0th index == position of child1 in root
1303 
1304         assertEquals(child1, fm.getFocusedItem());
1305         assertTrue(fm.isFocused(2));
1306     }
1307 
1308     @Test public void test_rt17522_focusShouldMoveWhenItemAddedBeforeFocusIndex_1() {
1309         installChildren();
1310         FocusModel fm = treeTableView.getFocusModel();
1311         fm.focus(1);    // focus on child1
1312         assertTrue(fm.isFocused(1));
1313 
1314         TreeItem child0 = new TreeItem(&quot;child0&quot;);
1315         root.getChildren().add(0, child0);
1316         assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(2));
1317     }
1318 
1319     @Test public void test_rt17522_focusShouldNotMoveWhenItemAddedAfterFocusIndex_1() {
1320         installChildren();
1321         FocusModel fm = treeTableView.getFocusModel();
1322         fm.focus(1);    // focus on child1
1323         assertTrue(fm.isFocused(1));
1324 
1325         TreeItem child4 = new TreeItem(&quot;child4&quot;);
1326         root.getChildren().add(3, child4);
1327         assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(1));
1328     }
1329 
1330     @Test public void test_rt17522_focusShouldBeMovedWhenFocusedItemIsRemoved_1() {
1331         installChildren();
1332         FocusModel fm = treeTableView.getFocusModel();
1333         fm.focus(1);
1334         assertTrue(fm.isFocused(1));
1335 
1336         root.getChildren().remove(child1);
1337         assertEquals(0, fm.getFocusedIndex());
1338         assertEquals(treeTableView.getTreeItem(0), fm.getFocusedItem());
1339     }
1340 
1341     @Test public void test_rt17522_focusShouldMoveWhenItemRemovedBeforeFocusIndex_1() {
1342         installChildren();
1343         FocusModel fm = treeTableView.getFocusModel();
1344         fm.focus(2);
1345         assertTrue(fm.isFocused(2));
1346 
1347         root.getChildren().remove(child1);
1348         assertTrue(fm.isFocused(1));
1349         assertEquals(child2, fm.getFocusedItem());
1350     }
1351 
1352 //    This test fails as, in TreeTableView FocusModel, we do not know the index of the
1353 //    removed tree items, which means we don&#39;t know whether they existed before
1354 //    or after the focused item.
1355 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemRemovedAfterFocusIndex() {
1356 //        installChildren();
1357 //        FocusModel fm = treeTableView.getFocusModel();
1358 //        fm.focus(1);
1359 //        assertTrue(fm.isFocused(1));
1360 //
1361 //        root.getChildren().remove(child3);
1362 //        assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(1));
1363 //        assertEquals(child1, fm.getFocusedItem());
1364 //    }
1365 
1366     @Test public void test_rt18385() {
1367         installChildren();
1368 //        table.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;);
1369         treeTableView.getSelectionModel().select(1);
1370         treeTableView.getRoot().getChildren().add(new TreeItem(&quot;Another Row&quot;));
1371         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndices().size());
1372         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1373     }
1374 
1375     @Test public void test_rt18339_onlyEditWhenTreeTableViewIsEditable_editableIsFalse() {
1376         TreeItem root = new TreeItem(&quot;root&quot;);
1377         root.getChildren().setAll(
1378                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1379                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1380                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1381                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1382                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1383         root.setExpanded(true);
1384 
1385         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1386 
1387         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1388         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1389 
1390         table.setEditable(false);
1391         table.edit(0,firstNameCol);
1392         assertNull(table.getEditingCell());
1393     }
1394 
1395     @Test public void test_rt18339_onlyEditWhenTreeTableViewIsEditable_editableIsTrue() {
1396         TreeItem root = new TreeItem(&quot;root&quot;);
1397         root.getChildren().setAll(
1398                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1399                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1400                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1401                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1402                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1403         root.setExpanded(true);
1404 
1405         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1406 
1407         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1408         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1409 
1410         table.setEditable(true);
1411         table.edit(0,firstNameCol);
1412         assertEquals(root, table.getEditingCell().getTreeItem());
1413     }
1414 
1415     @Test public void test_rt14451() {
1416         installChildren();
1417         treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
1418         treeTableView.getSelectionModel().selectRange(0, 2); // select from 0 (inclusive) to 2 (exclusive)
1419         assertEquals(2, treeTableView.getSelectionModel().getSelectedIndices().size());
1420     }
1421 
1422     @Test public void test_rt21586() {
1423         installChildren();
1424         treeTableView.getSelectionModel().select(1);
1425         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1426         assertEquals(child1, treeTableView.getSelectionModel().getSelectedItem());
1427 
1428         TreeItem root = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1429         TreeItem child1 = new TreeItem&lt;String&gt;(&quot;New Child 1&quot;);
1430         TreeItem child2 = new TreeItem&lt;String&gt;(&quot;New Child 2&quot;);
1431         TreeItem child3 = new TreeItem&lt;String&gt;(&quot;New Child 3&quot;);
1432         root.setExpanded(true);
1433         root.getChildren().setAll(child1, child2, child3);
1434         treeTableView.setRoot(root);
1435         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1436         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1437         assertEquals(0, treeTableView.getFocusModel().getFocusedIndex());
1438         assertEquals(root, treeTableView.getFocusModel().getFocusedItem());
1439     }
1440 
1441     @Test public void test_rt27181() {
1442         myCompanyRootNode.setExpanded(true);
1443         treeTableView.setRoot(myCompanyRootNode);
1444 
1445         // start test
1446         salesDepartment.setExpanded(true);
1447         treeTableView.getSelectionModel().select(salesDepartment);
1448 
1449         assertEquals(1, treeTableView.getFocusModel().getFocusedIndex());
1450         itSupport.setExpanded(true);
1451         assertEquals(1, treeTableView.getFocusModel().getFocusedIndex());
1452     }
1453 
1454     @Test public void test_rt27185() {
1455         myCompanyRootNode.setExpanded(true);
1456         treeTableView.setRoot(myCompanyRootNode);
1457 
1458         // start test
1459         itSupport.setExpanded(true);
1460         treeTableView.getSelectionModel().select(mikeGraham);
1461 
1462         assertEquals(mikeGraham, treeTableView.getFocusModel().getFocusedItem());
1463         salesDepartment.setExpanded(true);
1464         assertEquals(mikeGraham, treeTableView.getFocusModel().getFocusedItem());
1465     }
1466 
1467     @Ignore(&quot;Bug hasn&#39;t been fixed yet&quot;)
1468     @Test public void test_rt28114() {
1469         myCompanyRootNode.setExpanded(true);
1470         treeTableView.setRoot(myCompanyRootNode);
1471 
1472         // start test
1473         itSupport.setExpanded(true);
1474         treeTableView.getSelectionModel().select(itSupport);
1475         assertEquals(itSupport, treeTableView.getFocusModel().getFocusedItem());
1476         assertEquals(itSupport, treeTableView.getSelectionModel().getSelectedItem());
1477         assertTrue(! itSupport.isLeaf());
1478         assertTrue(itSupport.isExpanded());
1479 
1480         itSupport.getChildren().remove(mikeGraham);
1481         assertEquals(itSupport, treeTableView.getFocusModel().getFocusedItem());
1482         assertEquals(itSupport, treeTableView.getSelectionModel().getSelectedItem());
1483         assertTrue(itSupport.isLeaf());
1484         assertTrue(!itSupport.isExpanded());
1485     }
1486 
1487     @Test public void test_rt27820_1() {
1488         TreeItem root = new TreeItem(&quot;root&quot;);
1489         root.setExpanded(true);
1490         TreeItem child = new TreeItem(&quot;child&quot;);
1491         root.getChildren().add(child);
1492         treeTableView.setRoot(root);
1493 
1494         treeTableView.getSelectionModel().select(0);
1495         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1496         assertEquals(root, treeTableView.getSelectionModel().getSelectedItem());
1497 
1498         treeTableView.setRoot(null);
1499         assertEquals(0, treeTableView.getSelectionModel().getSelectedItems().size());
1500         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1501     }
1502 
1503     @Test public void test_rt27820_2() {
1504         TreeItem root = new TreeItem(&quot;root&quot;);
1505         root.setExpanded(true);
1506         TreeItem child = new TreeItem(&quot;child&quot;);
1507         root.getChildren().add(child);
1508         treeTableView.setRoot(root);
1509 
1510         treeTableView.getSelectionModel().select(1);
1511         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1512         assertEquals(child, treeTableView.getSelectionModel().getSelectedItem());
1513 
1514         treeTableView.setRoot(null);
1515         assertEquals(0, treeTableView.getSelectionModel().getSelectedItems().size());
1516         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1517     }
1518 
1519     @Test public void test_rt28390() {
1520         // There should be no NPE when a TreeTableView is shown and the disclosure
1521         // node is null in a TreeCell
1522         TreeItem root = new TreeItem(&quot;root&quot;);
1523         treeTableView.setRoot(root);
1524 
1525         // install a custom cell factory that forces the disclosure node to be
1526         // null (because by default a null disclosure node will be replaced by
1527         // a non-null one).
1528         treeTableView.setRowFactory(new Callback() {
1529             @Override public Object call(Object p) {
1530                 TreeTableRow treeCell = new TreeTableRowShim() {
1531                     {
1532                         disclosureNodeProperty().addListener((ov, t, t1) -&gt; {
1533                             setDisclosureNode(null);
1534                         });
1535                     }
1536 
1537                     @Override public void updateItem(Object item, boolean empty) {
1538                         super.updateItem(item, empty);
1539                         setText(item == null ? &quot;&quot; : item.toString());
1540                     }
1541                 };
1542                 treeCell.setDisclosureNode(null);
1543                 return treeCell;
1544             }
1545         });
1546 
1547         try {
1548             Group group = new Group();
1549             group.getChildren().setAll(treeTableView);
1550             Scene scene = new Scene(group);
1551             Stage stage = new Stage();
1552             stage.setScene(scene);
1553             stage.show();
1554         } catch (NullPointerException e) {
1555             System.out.println(&quot;A null disclosure node is valid, so we shouldn&#39;t have an NPE here.&quot;);
1556             e.printStackTrace();
1557             assertTrue(false);
1558         }
1559     }
1560 
1561     @Ignore(&quot;This test begun failing when createDefaultCellImpl was removed from TreeTableViewSkin on 28/3/2013&quot;)
1562     @Test public void test_rt28534() {
1563         TreeItem root = new TreeItem(&quot;root&quot;);
1564         root.getChildren().setAll(
1565                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1566                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1567                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1568                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1569                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1570         root.setExpanded(true);
1571 
1572         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1573 
1574         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1575         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1576 
1577         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1578         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1579 
1580         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1581         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1582 
1583         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1584 
1585         VirtualFlowTestUtils.assertRowsNotEmpty(table, 0, 6); // rows 0 - 6 should be filled
1586         VirtualFlowTestUtils.assertRowsEmpty(table, 6, -1); // rows 6+ should be empty
1587 
1588         // now we replace the data and expect the cells that have no data
1589         // to be empty
1590         root.getChildren().setAll(
1591                 new TreeItem(new Person(&quot;*_*Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1592                 new TreeItem(new Person(&quot;_Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1593 
1594         VirtualFlowTestUtils.assertRowsNotEmpty(table, 0, 3); // rows 0 - 3 should be filled
1595         VirtualFlowTestUtils.assertRowsEmpty(table, 3, -1); // rows 3+ should be empty
1596     }
1597 
1598     @Test public void test_rt22463() {
1599         final TreeTableView&lt;RT_22463_Person&gt; table = new TreeTableView&lt;RT_22463_Person&gt;();
1600         table.setTableMenuButtonVisible(true);
1601         TreeTableColumn c1 = new TreeTableColumn(&quot;Id&quot;);
1602         TreeTableColumn c2 = new TreeTableColumn(&quot;Name&quot;);
1603         c1.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, Long&gt;(&quot;id&quot;));
1604         c2.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;name&quot;));
1605         table.getColumns().addAll(c1, c2);
1606 
1607         RT_22463_Person rootPerson = new RT_22463_Person();
1608         rootPerson.setName(&quot;Root&quot;);
1609         TreeItem&lt;RT_22463_Person&gt; root = new TreeItem&lt;RT_22463_Person&gt;(rootPerson);
1610         root.setExpanded(true);
1611 
1612         table.setRoot(root);
1613 
1614         // before the change things display fine
1615         RT_22463_Person p1 = new RT_22463_Person();
1616         p1.setId(1l);
1617         p1.setName(&quot;name1&quot;);
1618         RT_22463_Person p2 = new RT_22463_Person();
1619         p2.setId(2l);
1620         p2.setName(&quot;name2&quot;);
1621         root.getChildren().addAll(
1622                 new TreeItem&lt;RT_22463_Person&gt;(p1),
1623                 new TreeItem&lt;RT_22463_Person&gt;(p2));
1624         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;1&quot;, &quot;name1&quot;);
1625         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;2&quot;, &quot;name2&quot;);
1626 
1627         // now we change the persons but they are still equal as the ID&#39;s don&#39;t
1628         // change - but the items list is cleared so the cells should update
1629         RT_22463_Person new_p1 = new RT_22463_Person();
1630         new_p1.setId(1l);
1631         new_p1.setName(&quot;updated name1&quot;);
1632         RT_22463_Person new_p2 = new RT_22463_Person();
1633         new_p2.setId(2l);
1634         new_p2.setName(&quot;updated name2&quot;);
1635         root.getChildren().clear();
1636         root.getChildren().setAll(
1637                 new TreeItem&lt;RT_22463_Person&gt;(new_p1),
1638                 new TreeItem&lt;RT_22463_Person&gt;(new_p2));
1639         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;1&quot;, &quot;updated name1&quot;);
1640         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;2&quot;, &quot;updated name2&quot;);
1641     }
1642 
1643     @Test public void test_rt28637() {
1644         TreeItem&lt;String&gt; s1, s2, s3, s4;
1645         ObservableList&lt;TreeItem&lt;String&gt;&gt; items = FXCollections.observableArrayList(
1646                 s1 = new TreeItem&lt;String&gt;(&quot;String1&quot;),
1647                 s2 = new TreeItem&lt;String&gt;(&quot;String2&quot;),
1648                 s3 = new TreeItem&lt;String&gt;(&quot;String3&quot;),
1649                 s4 = new TreeItem&lt;String&gt;(&quot;String4&quot;));
1650 
1651         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;String&gt;();
1652 
1653         TreeItem&lt;String&gt; root = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1654         root.setExpanded(true);
1655         treeTableView.setRoot(root);
1656         treeTableView.setShowRoot(false);
1657         root.getChildren().addAll(items);
1658 
1659         treeTableView.getSelectionModel().select(0);
1660         assertEquals((Object)s1, treeTableView.getSelectionModel().getSelectedItem());
1661         assertEquals((Object)s1, treeTableView.getSelectionModel().getSelectedItems().get(0));
1662         assertEquals(0, treeTableView.getSelectionModel().getSelectedIndex());
1663 
1664         root.getChildren().remove(treeTableView.getSelectionModel().getSelectedItem());
1665         assertEquals((Object)s2, treeTableView.getSelectionModel().getSelectedItem());
1666         assertEquals((Object)s2, treeTableView.getSelectionModel().getSelectedItems().get(0));
1667         assertEquals(0, treeTableView.getSelectionModel().getSelectedIndex());
1668     }
1669 
1670     @Test public void test_rt24844() {
1671         // p1 == lowest first name
1672         TreeItem&lt;Person&gt; p0, p1, p2, p3, p4;
1673 
1674         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1675             p3 = new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1676             p2 = new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1677             p1 = new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1678             p0 = new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1679             p4 = new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1680 
1681         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1682 
1683         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1684         root.setExpanded(true);
1685         table.setRoot(root);
1686         table.setShowRoot(false);
1687         root.getChildren().setAll(persons);
1688 
1689         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1690         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1691 
1692         // set dummy comparator to lock items in place until new comparator is set
1693         firstNameCol.setComparator((t, t1) -&gt; 0);
1694 
1695         table.getColumns().addAll(firstNameCol);
1696         table.getSortOrder().add(firstNameCol);
1697 
1698         // ensure the existing order is as expected
1699         assertEquals(p3, root.getChildren().get(0));
1700         assertEquals(p2, root.getChildren().get(1));
1701         assertEquals(p1, root.getChildren().get(2));
1702         assertEquals(p0, root.getChildren().get(3));
1703         assertEquals(p4, root.getChildren().get(4));
1704 
1705         // set a new comparator
1706         firstNameCol.setComparator((t, t1) -&gt; t.toString().compareTo(t1.toString()));
1707 
1708         // ensure the new order is as expected
1709         assertEquals(p0, root.getChildren().get(0));
1710         assertEquals(p1, root.getChildren().get(1));
1711         assertEquals(p2, root.getChildren().get(2));
1712         assertEquals(p3, root.getChildren().get(3));
1713         assertEquals(p4, root.getChildren().get(4));
1714     }
1715 
1716     @Test public void test_rt29331() {
1717         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;();
1718 
1719         // p1 == lowest first name
1720         TreeItem&lt;Person&gt; p0, p1, p2, p3, p4;
1721 
1722         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1723         firstNameCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1724 
1725         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1726         lastNameCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1727 
1728         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1729         emailCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1730 
1731         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1732         parentColumn.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1733 
1734         table.getColumns().addAll(parentColumn);
1735 
1736         // table is setup, now hide the &#39;last name&#39; column
1737         emailCol.setVisible(false);
1738         assertFalse(emailCol.isVisible());
1739 
1740         // reorder columns inside the parent column
1741         parentColumn.getColumns().setAll(emailCol, firstNameCol, lastNameCol);
1742 
1743         // the email column should not become visible after this, but it does
1744         assertFalse(emailCol.isVisible());
1745     }
1746 
1747     private int rt29330_count = 0;
1748     @Test public void test_rt29330_1() {
1749         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1750                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1751                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1752                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1753                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1754                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1755 
1756         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1757 
1758         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1759         root.setExpanded(true);
1760         table.setRoot(root);
1761         table.setShowRoot(false);
1762         root.getChildren().setAll(persons);
1763 
1764         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1765         table.getColumns().addAll(parentColumn);
1766 
1767         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1768         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1769 
1770         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1771         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1772 
1773         parentColumn.getColumns().addAll(firstNameCol, lastNameCol);
1774 
1775         table.setOnSort(event -&gt; {
1776             rt29330_count++;
1777         });
1778 
1779         // test preconditions
1780         assertEquals(ASCENDING, lastNameCol.getSortType());
1781         assertEquals(0, rt29330_count);
1782 
1783         table.getSortOrder().add(lastNameCol);
1784         assertEquals(1, rt29330_count);
1785 
1786         lastNameCol.setSortType(DESCENDING);
1787         assertEquals(2, rt29330_count);
1788 
1789         lastNameCol.setSortType(null);
1790         assertEquals(3, rt29330_count);
1791 
1792         lastNameCol.setSortType(ASCENDING);
1793         assertEquals(4, rt29330_count);
1794     }
1795 
1796     @Test public void test_rt29330_2() {
1797         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1798                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1799                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1800                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1801                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1802                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1803 
1804         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1805 
1806         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1807         root.setExpanded(true);
1808         table.setRoot(root);
1809         table.setShowRoot(false);
1810         root.getChildren().setAll(persons);
1811 
1812         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1813         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1814 
1815         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1816         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1817 
1818         // this test differs from the previous one by installing the parent column
1819         // into the tableview after it has the children added into it
1820         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1821         parentColumn.getColumns().addAll(firstNameCol, lastNameCol);
1822         table.getColumns().addAll(parentColumn);
1823 
1824         table.setOnSort(event -&gt; {
1825             rt29330_count++;
1826         });
1827 
1828         // test preconditions
1829         assertEquals(ASCENDING, lastNameCol.getSortType());
1830         assertEquals(0, rt29330_count);
1831 
1832         table.getSortOrder().add(lastNameCol);
1833         assertEquals(1, rt29330_count);
1834 
1835         lastNameCol.setSortType(DESCENDING);
1836         assertEquals(2, rt29330_count);
1837 
1838         lastNameCol.setSortType(null);
1839         assertEquals(3, rt29330_count);
1840 
1841         lastNameCol.setSortType(ASCENDING);
1842         assertEquals(4, rt29330_count);
1843     }
1844 
1845     @Test public void test_rt29313_selectedIndices() {
1846         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1847                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1848                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1849                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1850                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1851                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1852 
1853         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1854 
1855         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1856         root.setExpanded(true);
1857         table.setRoot(root);
1858         table.setShowRoot(false);
1859         root.getChildren().setAll(persons);
1860 
1861         TableSelectionModel sm = table.getSelectionModel();
1862 
1863         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1864         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1865 
1866         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1867         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1868 
1869         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1870         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1871 
1872         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1873         sm.setCellSelectionEnabled(true);
1874         sm.setSelectionMode(SelectionMode.MULTIPLE);
1875 
1876         assertTrue(sm.getSelectedIndices().isEmpty());
1877 
1878         // only (0,0) should be selected, so selected indices should be [0]
1879         sm.select(0, firstNameCol);
1880         assertEquals(1, sm.getSelectedIndices().size());
1881 
1882         // now (0,0) and (1,0) should be selected, so selected indices should be [0, 1]
1883         sm.select(1, firstNameCol);
1884         assertEquals(2, sm.getSelectedIndices().size());
1885 
1886         // now (0,0), (1,0) and (1,1) should be selected, but selected indices
1887         // should remain as [0, 1], as we don&#39;t want selected indices to become
1888         // [0,1,1] (which is what RT-29313 is about)
1889         sm.select(1, lastNameCol);
1890         assertEquals(2, sm.getSelectedIndices().size());
1891         assertEquals(0, sm.getSelectedIndices().get(0));
1892         assertEquals(1, sm.getSelectedIndices().get(1));
1893     }
1894 
1895     @Test public void test_rt29313_selectedItems() {
1896         TreeItem&lt;Person&gt; p0, p1;
1897         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1898                 p0 = new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1899                 p1 = new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1900                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1901                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1902                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1903 
1904         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1905 
1906         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1907         root.setExpanded(true);
1908         table.setRoot(root);
1909         table.setShowRoot(false);
1910         root.getChildren().setAll(persons);
1911 
1912         TableSelectionModel sm = table.getSelectionModel();
1913 
1914         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1915         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1916 
1917         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1918         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1919 
1920         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1921         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1922 
1923         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1924         sm.setCellSelectionEnabled(true);
1925         sm.setSelectionMode(SelectionMode.MULTIPLE);
1926 
1927         assertTrue(sm.getSelectedItems().isEmpty());
1928 
1929         // only (0,0) should be selected, so selected items should be [p0]
1930         sm.select(0, firstNameCol);
1931         assertEquals(1, sm.getSelectedItems().size());
1932 
1933         // now (0,0) and (1,0) should be selected, so selected items should be [p0, p1]
1934         sm.select(1, firstNameCol);
1935         assertEquals(2, sm.getSelectedItems().size());
1936 
1937         // now (0,0), (1,0) and (1,1) should be selected, but selected items
1938         // should remain as [p0, p1], as we don&#39;t want selected items to become
1939         // [p0,p1,p1] (which is what RT-29313 is about)
1940         sm.select(1, lastNameCol);
1941         assertEquals(2, sm.getSelectedItems().size());
1942         assertEquals(p0, sm.getSelectedItems().get(0));
1943         assertEquals(p1, sm.getSelectedItems().get(1));
1944     }
1945 
1946     @Test public void test_rt29566() {
1947         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1948                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1949                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1950                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1951                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1952                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1953 
1954         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1955 
1956         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1957         root.setExpanded(true);
1958         table.setRoot(root);
1959         table.setShowRoot(false);
1960         root.getChildren().setAll(persons);
1961 
1962         TableSelectionModel sm = table.getSelectionModel();
1963 
1964         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1965         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1966 
1967         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1968         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1969 
1970         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1971         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1972 
1973         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1974 
1975         // test the state before we hide and re-add a column
1976         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;);
1977         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;);
1978         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;);
1979         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;);
1980         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;);
1981 
1982         // hide the last name column, and test cells again
1983         table.getColumns().remove(lastNameCol);
1984         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;jacob.smith@example.com&quot;);
1985         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;isabella.johnson@example.com&quot;);
1986         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;ethan.williams@example.com&quot;);
1987         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;emma.jones@example.com&quot;);
1988         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;michael.brown@example.com&quot;);
1989 
1990         // re-add the last name column - we should go back to the original state.
1991         // However, what appears to be happening is that, for some reason, some
1992         // of the cells from the removed column do not reappear - meaning in this case
1993         // some of the last name values will not be where we expect them to be.
1994         // This is clearly not ideal!
1995         table.getColumns().add(1, lastNameCol);
1996         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;);
1997         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;);
1998         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;);
1999         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;);
2000         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;);
2001     }
2002 
2003     @Test public void test_rt29390() {
2004         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
2005                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2006                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2007                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2008                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
2009                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2010                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2011                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2012                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
2013                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2014                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2015                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2016                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
2017                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2018                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2019                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2020                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)
2021         ));
2022 
2023         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
2024         table.setMaxHeight(50);
2025         table.setPrefHeight(50);
2026 
2027         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
2028         root.setExpanded(true);
2029         table.setRoot(root);
2030         table.setShowRoot(false);
2031         root.getChildren().setAll(persons);
2032 
2033         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2034         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
2035 
2036         table.getColumns().add(firstNameCol);
2037 
2038         Toolkit.getToolkit().firePulse();
2039 
2040         // we want the vertical scrollbar
2041         VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowVerticalScrollbar(table);
2042 
2043         assertNotNull(scrollBar);
2044         assertTrue(scrollBar.isVisible());
2045         assertTrue(scrollBar.getVisibleAmount() &gt; 0.0);
2046         assertTrue(scrollBar.getVisibleAmount() &lt; 1.0);
2047 
2048         // this next test is likely to be brittle, but we&#39;ll see...If it is the
2049         // cause of failure then it can be commented out
2050         assertEquals(0.0625, scrollBar.getVisibleAmount(), 0.0);
2051     }
2052 
2053     @Test public void test_rt29676_withText() {
2054         // set up test
2055         TreeTableView&lt;Data&gt; treeTableView = new TreeTableView&lt;Data&gt;();
2056         treeTableView.setMaxWidth(100);
2057 
2058         TreeItem&lt;Data&gt; root = new TreeItem&lt;Data&gt;(new Data(&quot;Root&quot;));
2059         treeTableView.setRoot(root);
2060         addLevel(root, 0, 30);
2061 
2062         treeTableView.getRoot().setExpanded(true);
2063         TreeTableColumn&lt;Data, String&gt; column = new TreeTableColumn&lt;Data, String&gt;(&quot;Items&#39; name&quot;);
2064         column.setCellValueFactory(p -&gt; new ReadOnlyStringWrapper(p.getValue().getValue().getData()));
2065         treeTableView.getColumns().add(column);
2066 
2067         // show treeTableView
2068         StageLoader sl = new StageLoader(treeTableView);
2069 
2070         // expand all collapsed branches
2071         root.setExpanded(true);
2072         for (int i = 0; i &lt; root.getChildren().size(); i++) {
2073             TreeItem&lt;Data&gt; child = root.getChildren().get(i);
2074             child.setExpanded(true);
2075         }
2076 
2077         // get all cells and ensure their content is as expected
2078         int cellCount = VirtualFlowTestUtils.getCellCount(treeTableView);
2079         for (int i = 0; i &lt; cellCount; i++) {
2080             // get the TreeTableRow
2081             final TreeTableRow rowCell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, i);
2082             final TreeItem treeItem = rowCell.getTreeItem();
2083             if (treeItem == null) continue;
2084 
2085             final boolean isBranch = ! treeItem.isLeaf();
2086 
2087             // then check its children
2088             List&lt;Node&gt; children = rowCell.getChildrenUnmodifiable();
2089             for (int j = 0; j &lt; children.size(); j++) {
2090                 final Node child = children.get(j);
2091 
2092                 assertTrue(child.isVisible());
2093                 assertNotNull(child.getParent());
2094                 assertNotNull(child.getScene());
2095 
2096                 if (child.getStyleClass().contains(&quot;tree-disclosure-node&quot;)) {
2097                     // no-op
2098                 }
2099 
2100                 if (child.getStyleClass().contains(&quot;tree-table-cell&quot;)) {
2101                     TreeTableCell cell = (TreeTableCell) child;
2102                     assertNotNull(cell.getText());
2103                     assertFalse(cell.getText().isEmpty());
2104                 }
2105             }
2106         }
2107 
2108         sl.dispose();
2109     }
2110     private void addLevel(TreeItem&lt;Data&gt; item, int level, int length) {
2111         for (int i = 0; i &lt; 3; i++) {
2112             StringBuilder builder = new StringBuilder();
2113             builder.append(&quot;Level &quot; + level + &quot; Item &quot; + item);
2114             if (length &gt; 0) {
2115                 builder.append(&quot; l&quot;);
2116                 for (int j = 0; j &lt; length; j++) {
2117                     builder.append(&quot;o&quot;);
2118                 }
2119                 builder.append(&quot;ng&quot;);
2120             }
2121             String itemString = builder.toString();
2122             TreeItem&lt;Data&gt; child = new TreeItem&lt;Data&gt;(new Data(itemString));
2123             if (level &lt; 3 - 1) {
2124                 addLevel(child, level + 1, length);
2125             }
2126             item.getChildren().add(child);
2127         }
2128     }
2129 
2130     @Test public void test_rt27180_collapseBranch_childSelected_singleSelection() {
2131         sm.setCellSelectionEnabled(false);
2132         sm.setSelectionMode(SelectionMode.SINGLE);
2133 
2134         treeTableView.setRoot(myCompanyRootNode);
2135         myCompanyRootNode.setExpanded(true);
2136         salesDepartment.setExpanded(true);
2137         itSupport.setExpanded(true);
2138         sm.select(2);                   // ethanWilliams
2139         assertFalse(sm.isSelected(1));  // salesDepartment
2140         assertTrue(sm.isSelected(2));   // ethanWilliams
2141         assertTrue(treeTableView.getFocusModel().isFocused(2));
2142         assertEquals(1, sm.getSelectedCells().size());
2143 
2144         // now collapse the salesDepartment, selection should
2145         // not jump down to the itSupport people
2146         salesDepartment.setExpanded(false);
2147         assertTrue(sm.getSelectedIndices().toString(), sm.isSelected(1));   // salesDepartment
2148         assertTrue(treeTableView.getFocusModel().isFocused(1));
2149         assertEquals(1, sm.getSelectedCells().size());
2150     }
2151 
2152     @Test public void test_rt27180_collapseBranch_laterSiblingSelected_singleSelection() {
2153         sm.setCellSelectionEnabled(false);
2154         sm.setSelectionMode(SelectionMode.SINGLE);
2155 
2156         treeTableView.setRoot(myCompanyRootNode);
2157         myCompanyRootNode.setExpanded(true);
2158         salesDepartment.setExpanded(true);
2159         itSupport.setExpanded(true);
2160         sm.select(8);                   // itSupport
2161         assertFalse(sm.isSelected(1));  // salesDepartment
2162         assertTrue(sm.isSelected(8));   // itSupport
2163         assertTrue(treeTableView.getFocusModel().isFocused(8));
2164         assertEquals(1, sm.getSelectedIndices().size());
2165 
2166         salesDepartment.setExpanded(false);
2167         assertTrue(debug(), sm.isSelected(2));   // itSupport
2168         assertTrue(treeTableView.getFocusModel().isFocused(2));
2169         assertEquals(1, sm.getSelectedIndices().size());
2170     }
2171 
2172     @Test public void test_rt27180_collapseBranch_laterSiblingAndChildrenSelected() {
2173         sm.setSelectionMode(SelectionMode.MULTIPLE);
2174         sm.setCellSelectionEnabled(false);
2175 
2176         treeTableView.setRoot(myCompanyRootNode);
2177         myCompanyRootNode.setExpanded(true);
2178         salesDepartment.setExpanded(true);
2179         itSupport.setExpanded(true);
2180         sm.clearSelection();
2181         sm.selectIndices(8, 9, 10);     // itSupport, and two people
2182         assertFalse(sm.isSelected(1));  // salesDepartment
2183         assertTrue(sm.isSelected(8));   // itSupport
2184         assertTrue(sm.isSelected(9));   // mikeGraham
2185         assertTrue(sm.isSelected(10));  // judyMayer
2186         assertTrue(treeTableView.getFocusModel().isFocused(10));
2187         assertEquals(debug(), 3, sm.getSelectedIndices().size());
2188 
2189         salesDepartment.setExpanded(false);
2190         assertTrue(debug(), sm.isSelected(2));   // itSupport
2191         assertTrue(sm.isSelected(3));   // mikeGraham
2192         assertTrue(sm.isSelected(4));   // judyMayer
2193         assertTrue(treeTableView.getFocusModel().isFocused(4));
2194         assertEquals(3, sm.getSelectedIndices().size());
2195     }
2196 
2197     @Test public void test_rt27180_expandBranch_laterSiblingSelected_singleSelection() {
2198         sm.setCellSelectionEnabled(false);
2199         sm.setSelectionMode(SelectionMode.SINGLE);
2200 
2201         treeTableView.setRoot(myCompanyRootNode);
2202         myCompanyRootNode.setExpanded(true);
2203         salesDepartment.setExpanded(false);
2204         itSupport.setExpanded(true);
2205         sm.select(2);                   // itSupport
2206         assertFalse(sm.isSelected(1));  // salesDepartment
2207         assertTrue(sm.isSelected(2));   // itSupport
2208         assertTrue(treeTableView.getFocusModel().isFocused(2));
2209         assertEquals(1, sm.getSelectedIndices().size());
2210 
2211         salesDepartment.setExpanded(true);
2212         assertTrue(debug(), sm.isSelected(8));   // itSupport
2213         assertTrue(treeTableView.getFocusModel().isFocused(8));
2214         assertEquals(1, sm.getSelectedIndices().size());
2215     }
2216 
2217     @Test public void test_rt27180_expandBranch_laterSiblingAndChildrenSelected() {
2218         sm.setSelectionMode(SelectionMode.MULTIPLE);
2219         sm.setCellSelectionEnabled(false);
2220 
2221         treeTableView.setRoot(myCompanyRootNode);
2222         myCompanyRootNode.setExpanded(true);
2223         salesDepartment.setExpanded(false);
2224         itSupport.setExpanded(true);
2225         sm.clearSelection();
2226         sm.selectIndices(2,3,4);     // itSupport, and two people
2227         assertFalse(sm.isSelected(1));  // salesDepartment
2228         assertTrue(sm.isSelected(2));   // itSupport
2229         assertTrue(sm.isSelected(3));   // mikeGraham
2230         assertTrue(sm.isSelected(4));  // judyMayer
2231         assertTrue(treeTableView.getFocusModel().isFocused(4));
2232         assertEquals(3, sm.getSelectedIndices().size());
2233 
2234         salesDepartment.setExpanded(true);
2235         assertTrue(debug(), sm.isSelected(8));   // itSupport
2236         assertTrue(sm.isSelected(9));   // mikeGraham
2237         assertTrue(sm.isSelected(10));   // judyMayer
2238         assertTrue(treeTableView.getFocusModel().isFocused(10));
2239         assertEquals(3, sm.getSelectedIndices().size());
2240     }
2241 
2242     @Test public void test_rt30400() {
2243         // create a treetableview that&#39;ll render cells using the check box cell factory
2244         TreeItem&lt;String&gt; rootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
2245         final TreeTableView&lt;String&gt; tableView = new TreeTableView&lt;String&gt;(rootItem);
2246         tableView.setMinHeight(100);
2247         tableView.setPrefHeight(100);
2248 
2249         TreeTableColumn&lt;String, String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2250         firstNameCol.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
2251         firstNameCol.setCellFactory(CheckBoxTreeTableCell.forTreeTableColumn(param -&gt; new ReadOnlyBooleanWrapper(true)));
2252         tableView.getColumns().add(firstNameCol);
2253 
2254         // because only the first row has data, all other rows should be
2255         // empty (and not contain check boxes - we just check the first four here)
2256         VirtualFlowTestUtils.assertRowsNotEmpty(tableView, 0, 1);
2257         VirtualFlowTestUtils.assertCellNotEmpty(VirtualFlowTestUtils.getCell(tableView, 0));
2258         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 1));
2259         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 2));
2260         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 3));
2261     }
2262 
2263     @Ignore(&quot;This bug is not yet fixed&quot;)
2264     @Test public void test_rt31165() {
2265         installChildren();
2266         treeTableView.setEditable(true);
2267 
2268         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2269         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(&quot;TEST&quot;));
2270         firstNameCol.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
2271         firstNameCol.setEditable(true);
2272 
2273         treeTableView.getColumns().add(firstNameCol);
2274 
2275         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 1, 0);
2276         assertEquals(&quot;TEST&quot;, cell.getText());
2277         assertFalse(cell.isEditing());
2278 
2279         treeTableView.edit(1, firstNameCol);
2280 
2281         assertEquals(child1, treeTableView.getEditingCell().getTreeItem());
2282         assertTrue(cell.isEditing());
2283 
2284         VirtualFlowTestUtils.getVirtualFlow(treeTableView).requestLayout();
2285         Toolkit.getToolkit().firePulse();
2286 
2287         assertEquals(child1, treeTableView.getEditingCell().getTreeItem());
2288         assertTrue(cell.isEditing());
2289     }
2290 
2291     @Test public void test_rt31404() {
2292         installChildren();
2293 
2294         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2295         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2296 
2297         treeTableView.getColumns().add(firstNameCol);
2298 
2299         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 0, 0);
2300         assertEquals(&quot;Root&quot;, cell.getText());
2301 
2302         treeTableView.setShowRoot(false);
2303         assertEquals(&quot;Child 1&quot;, cell.getText());
2304     }
2305 
2306     @Test public void test_rt31471() {
2307         installChildren();
2308 
2309         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2310         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2311 
2312         treeTableView.getColumns().add(firstNameCol);
2313 
2314         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 0);
2315         assertEquals(&quot;Root&quot;, cell.getItem());
2316 
2317         treeTableView.setFixedCellSize(50);
2318 
2319         VirtualFlowTestUtils.getVirtualFlow(treeTableView).requestLayout();
2320         Toolkit.getToolkit().firePulse();
2321 
2322         assertEquals(&quot;Root&quot;, cell.getItem());
2323         assertEquals(50, cell.getHeight(), 0.00);
2324     }
2325 
2326     @Test public void test_rt30466() {
2327         final Node graphic1 = new Circle(6.75, Color.RED);
2328         final Node graphic2 = new Circle(6.75, Color.GREEN);
2329 
2330         installChildren();
2331 
2332         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2333         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2334 
2335         treeTableView.getColumns().add(firstNameCol);
2336 
2337         TreeTableRow cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2338         assertEquals(&quot;Root&quot;, cell.getItem());
2339 
2340         // set the first graphic - which we expect to see as a child of the cell
2341         root.setGraphic(graphic1);
2342         cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2343         boolean matchGraphic1 = false;
2344         boolean matchGraphic2 = false;
2345         for (Node n : cell.getChildrenUnmodifiable()) {
2346             if (n == graphic1) {
2347                 matchGraphic1 = true;
2348             }
2349             if (n == graphic2) {
2350                 matchGraphic2 = true;
2351             }
2352         }
2353         assertTrue(matchGraphic1);
2354         assertFalse(matchGraphic2);
2355 
2356         // set the second graphic - which we also expect to see - but of course graphic1 should not be a child any longer
2357         root.setGraphic(graphic2);
2358         cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2359         matchGraphic1 = false;
2360         matchGraphic2 = false;
2361         for (Node n : cell.getChildrenUnmodifiable()) {
2362             if (n == graphic1) {
2363                 matchGraphic1 = true;
2364             }
2365             if (n == graphic2) {
2366                 matchGraphic2 = true;
2367             }
2368         }
2369         assertFalse(matchGraphic1);
2370         assertTrue(matchGraphic2);
2371     }
2372 
2373     private int rt_31200_count = 0;
2374     @Test public void test_rt_31200_tableCell() {
2375         rt_31200_count = 0;
2376 
2377         installChildren();
2378         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2379         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2380         treeTableView.getColumns().add(firstNameCol);
2381 
2382         firstNameCol.setCellFactory(new Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2383             @Override
2384             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; param) {
2385                 return new TreeTableCellShim&lt;String, String&gt;() {
2386                     ImageView view = new ImageView();
2387 
2388                     {
2389                         setGraphic(view);
2390                     }
2391 
2392                     ;
2393 
2394                     @Override
2395                     public void updateItem(String item, boolean empty) {
2396                         if (getItem() == null ? item == null : getItem().equals(item)) {
2397                             rt_31200_count++;
2398                         }
2399                         super.updateItem(item, empty);
2400                         if (item == null || empty) {
2401                             view.setImage(null);
2402                             setText(null);
2403                         } else {
2404                             setText(item);
2405                         }
2406                     }
2407                 };
2408             }
2409         });
2410 
2411         StageLoader sl = new StageLoader(treeTableView);
2412 
2413         assertEquals(12, rt_31200_count);
2414 
2415         // resize the stage
2416         sl.getStage().setHeight(250);
2417         Toolkit.getToolkit().firePulse();
2418         sl.getStage().setHeight(50);
2419         Toolkit.getToolkit().firePulse();
2420         assertEquals(12, rt_31200_count);
2421 
2422         sl.dispose();
2423     }
2424 
2425     @Test public void test_rt_31200_tableRow() {
2426         rt_31200_count = 0;
2427 
2428         installChildren();
2429         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2430         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2431         treeTableView.getColumns().add(firstNameCol);
2432 
2433         treeTableView.setRowFactory(new Callback&lt;TreeTableView&lt;String&gt;, TreeTableRow&lt;String&gt;&gt;() {
2434             @Override
2435             public TreeTableRow&lt;String&gt; call(TreeTableView&lt;String&gt; param) {
2436                 return new TreeTableRowShim&lt;String&gt;() {
2437                     ImageView view = new ImageView();
2438 
2439                     {
2440                         setGraphic(view);
2441                     }
2442 
2443                     ;
2444 
2445                     @Override
2446                     public void updateItem(String item, boolean empty) {
2447                         if (getItem() == null ? item == null : getItem().equals(item)) {
2448                             rt_31200_count++;
2449                         }
2450                         super.updateItem(item, empty);
2451                         if (item == null || empty) {
2452                             view.setImage(null);
2453                             setText(null);
2454                         } else {
2455                             setText(item.toString());
2456                         }
2457                     }
2458                 };
2459             }
2460         });
2461 
2462         StageLoader sl = new StageLoader(treeTableView);
2463 
2464         assertEquals(21, rt_31200_count);
2465 
2466         // resize the stage
2467         sl.getStage().setHeight(250);
2468         Toolkit.getToolkit().firePulse();
2469         sl.getStage().setHeight(50);
2470         Toolkit.getToolkit().firePulse();
2471         assertEquals(21, rt_31200_count);
2472 
2473         sl.dispose();
2474     }
2475 
2476     @Test public void test_rt_31727() {
2477         installChildren();
2478         treeTableView.setEditable(true);
2479 
2480         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2481         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(&quot;TEST&quot;));
2482         firstNameCol.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
2483         firstNameCol.setEditable(true);
2484 
2485         treeTableView.getColumns().add(firstNameCol);
2486 
2487         treeTableView.setEditable(true);
2488         firstNameCol.setEditable(true);
2489 
2490         // do a normal edit
2491         treeTableView.edit(0, firstNameCol);
2492         TreeTablePosition editingCell = treeTableView.getEditingCell();
2493         assertNotNull(editingCell);
2494         assertEquals(0, editingCell.getRow());
2495         assertEquals(0, editingCell.getColumn());
2496         assertEquals(firstNameCol, editingCell.getTableColumn());
2497         assertEquals(treeTableView, editingCell.getTreeTableView());
2498 
2499         // cancel editing
2500         treeTableView.edit(-1, null);
2501         editingCell = treeTableView.getEditingCell();
2502         assertNull(editingCell);
2503     }
2504 
2505     @Test public void test_rt_21517() {
2506         installChildren();
2507 
2508 //        final TableSelectionModel sm = t.getSelectionModel();
2509         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2510         col.setSortType(ASCENDING);
2511         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2512         treeTableView.getColumns().add(col);
2513 
2514         // test pre-conditions
2515         assertEquals(0, sm.getSelectedCells().size());
2516         assertEquals(0, sm.getSelectedItems().size());
2517         assertEquals(0, sm.getSelectedIndices().size());
2518 
2519         // select the 4th row (that is, the third child of the root)
2520         sm.select(3);
2521         assertTrue(sm.isSelected(3));
2522         assertEquals(3, sm.getSelectedIndex());
2523         assertEquals(1, sm.getSelectedIndices().size());
2524         assertTrue(sm.getSelectedIndices().contains(3));
2525         assertEquals(child3, sm.getSelectedItem());
2526         assertEquals(1, sm.getSelectedItems().size());
2527         assertTrue(sm.getSelectedItems().contains(child3));
2528 
2529         // we also want to test visually
2530         TreeTableRow rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2531         assertFalse(rootRow.isSelected());
2532         TreeTableRow child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 3);
2533         assertTrue(child3Row.isSelected());
2534 
2535         // sort tableview by firstname column in ascending (default) order
2536         // (so aaa continues to come first)
2537         treeTableView.getSortOrder().add(col);
2538 
2539         // nothing should have changed
2540         assertTrue(sm.isSelected(3));
2541         assertEquals(3, sm.getSelectedIndex());
2542         assertEquals(1, sm.getSelectedIndices().size());
2543         assertTrue(sm.getSelectedIndices().contains(3));
2544         assertEquals(child3, sm.getSelectedItem());
2545         assertEquals(1, sm.getSelectedItems().size());
2546         assertTrue(sm.getSelectedItems().contains(child3));
2547         rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2548         assertFalse(rootRow.isSelected());
2549         child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 3);
2550         assertTrue(child3Row.isSelected());
2551 
2552         // continue to sort tableview by firstname column, but now in descending
2553         // order, (so ccc to come first)
2554         col.setSortType(TreeTableColumn.SortType.DESCENDING);
2555 
2556         // now test to ensure that CCC is still the only selected item, but now
2557         // located in index 1 (as the first child of the root)
2558         assertTrue(debug(), sm.isSelected(1));
2559         assertEquals(1, sm.getSelectedIndex());
2560         assertEquals(1, sm.getSelectedIndices().size());
2561         assertTrue(sm.getSelectedIndices().contains(1));
2562         assertEquals(child3, sm.getSelectedItem());
2563         assertEquals(1, sm.getSelectedItems().size());
2564         assertTrue(sm.getSelectedItems().contains(child3));
2565 
2566         // we also want to test visually
2567         rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2568         assertFalse(rootRow.isSelected());
2569         child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 1);
2570         assertTrue(child3Row.isSelected());
2571     }
2572 
2573     @Test public void test_rt_30484_treeTableCell() {
2574         installChildren();
2575 
2576         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2577         col.setSortType(ASCENDING);
2578         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2579         treeTableView.getColumns().add(col);
2580 
2581         col.setCellFactory(new Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2582             @Override
2583             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; param) {
2584                 return new TreeTableCellShim&lt;String, String&gt;() {
2585                     Rectangle graphic = new Rectangle(10, 10, Color.RED);
2586                     { setGraphic(graphic); };
2587 
2588                     @Override public void updateItem(String item, boolean empty) {
2589                         super.updateItem(item, empty);
2590                         if (item == null || empty) {
2591                             graphic.setVisible(false);
2592                             setText(null);
2593                         } else {
2594                             graphic.setVisible(true);
2595                             setText(item);
2596                         }
2597                     }
2598                 };
2599             }
2600         });
2601 
2602         // First four rows have content, so the graphic should show.
2603         // All other rows have no content, so graphic should not show.
2604 
2605         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    0, 0);
2606         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    1, 0);
2607         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    2, 0);
2608         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    3, 0);
2609         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 4, 0);
2610         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 5, 0);
2611     }
2612 
2613     @Test public void test_rt_30484_treeTableRow() {
2614         installChildren();
2615 
2616         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2617         col.setSortType(ASCENDING);
2618         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2619         treeTableView.getColumns().add(col);
2620 
2621         treeTableView.setRowFactory(new Callback&lt;TreeTableView&lt;String&gt;, TreeTableRow&lt;String&gt;&gt;() {
2622             @Override public TreeTableRow&lt;String&gt; call(TreeTableView&lt;String&gt; param) {
2623                 return new TreeTableRowShim&lt;String&gt;() {
2624                     Rectangle graphic = new Rectangle(10, 10, Color.RED);
2625                     { setGraphic(graphic); };
2626 
2627                     @Override public void updateItem(String item, boolean empty) {
2628                         super.updateItem(item, empty);
2629                         if (item == null || empty) {
2630                             graphic.setVisible(false);
2631                             setText(null);
2632                         } else {
2633                             graphic.setVisible(true);
2634                             setText(item.toString());
2635                         }
2636                     }
2637                 };
2638             }
2639         });
2640 
2641         // First two rows have content, so the graphic should show.
2642         // All other rows have no content, so graphic should not show.
2643 
2644         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    0);
2645         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    1);
2646         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    2);
2647         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    3);
2648         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 4);
2649         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 5);
2650     }
2651 
2652     private int rt_31015_count = 0;
2653     @Test public void test_rt_31015() {
2654         installChildren();
2655         root.getChildren().clear();
2656         treeTableView.setEditable(true);
2657 
2658         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2659         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2660         treeTableView.getColumns().add(col);
2661 
2662         //Set cell factory for cells that allow editing
2663         Callback&lt;TreeTableColumn&lt;String,String&gt;, TreeTableCell&lt;String, String&gt;&gt; cellFactory = new Callback&lt;TreeTableColumn&lt;String,String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2664             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; p) {
2665                 return new TreeTableCell&lt;String, String&gt;() {
2666                     @Override public void cancelEdit() {
2667                         super.cancelEdit();
2668                         rt_31015_count++;
2669                     }
2670                 };
2671             }
2672         };
2673         col.setCellFactory(cellFactory);
2674 
2675         StageLoader sl = new StageLoader(treeTableView);
2676 
2677         assertEquals(0, rt_31015_count);
2678 
2679         treeTableView.edit(0, col);
2680         assertEquals(0, rt_31015_count);
2681 
2682         treeTableView.edit(-1, null);
2683         assertEquals(1, rt_31015_count);
2684 
2685         sl.dispose();
2686     }
2687 
2688     @Test public void test_rt_30688() {
2689         installChildren();
2690         root.getChildren().clear();
2691         treeTableView.setColumnResizePolicy(TreeTableView.CONSTRAINED_RESIZE_POLICY);
2692 
2693         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2694         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2695         treeTableView.getColumns().add(col);
2696 
2697         StageLoader sl = new StageLoader(treeTableView);
2698 
2699         assertEquals(TreeTableViewShim.get_contentWidth(treeTableView),
2700                 TableColumnBaseShim.getWidth(col), 0.0);
2701 
2702         sl.dispose();
2703     }
2704 
2705     private int rt_29650_start_count = 0;
2706     private int rt_29650_commit_count = 0;
2707     private int rt_29650_cancel_count = 0;
2708     @Test public void test_rt_29650() {
2709         installChildren();
2710         treeTableView.setEditable(true);
2711 
2712         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2713         Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt; factory = TextFieldTreeTableCell.forTreeTableColumn();
2714         col.setCellFactory(factory);
2715         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2716         treeTableView.getColumns().add(col);
2717 
2718         col.setOnEditStart(t -&gt; {
2719             rt_29650_start_count++;
2720         });
2721         col.setOnEditCommit(t -&gt; {
2722             rt_29650_commit_count++;
2723         });
2724         col.setOnEditCancel(t -&gt; {
2725             rt_29650_cancel_count++;
2726         });
2727 
2728         StageLoader sl = new StageLoader(treeTableView);
2729 
2730         treeTableView.edit(0, col);
2731 
2732         Toolkit.getToolkit().firePulse();
2733 
2734         TreeTableCell rootCell = (TreeTableCell) VirtualFlowTestUtils.getCell(treeTableView, 0, 0);
2735         TextField textField = (TextField) rootCell.getGraphic();
2736         textField.setText(&quot;Testing!&quot;);
2737         KeyEventFirer keyboard = new KeyEventFirer(textField);
2738         keyboard.doKeyPress(KeyCode.ENTER);
2739 
2740         // TODO should the following assert be enabled?
2741 //        assertEquals(&quot;Testing!&quot;, listView.getItems().get(0));
2742         assertEquals(1, rt_29650_start_count);
2743         assertEquals(1, rt_29650_commit_count);
2744         assertEquals(0, rt_29650_cancel_count);
2745 
2746         sl.dispose();
2747     }
2748 
2749     private int rt_29849_start_count = 0;
2750     @Test public void test_rt_29849() {
2751         installChildren();
2752         treeTableView.setEditable(true);
2753 
2754         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2755         col.setEditable(true);
2756         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2757         treeTableView.getColumns().add(col);
2758 
2759         col.setOnEditStart(t -&gt; {
2760             rt_29849_start_count++;
2761         });
2762 
2763         // load the table so the default cells are created
2764         StageLoader sl = new StageLoader(treeTableView);
2765 
2766         // now replace the cell factory
2767         Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt; factory = TextFieldTreeTableCell.forTreeTableColumn();
2768         col.setCellFactory(factory);
2769 
2770         Toolkit.getToolkit().firePulse();
2771 
2772         // now start an edit and count the start edit events - it should be just 1
2773         treeTableView.edit(0, col);
2774         assertEquals(1, rt_29849_start_count);
2775 
2776         sl.dispose();
2777     }
2778 
2779     @Test public void test_rt_34327() {
2780         // by default the comparator is null.
2781         // NOTE: this method (prior to the fix as part of RT-34327) would have
2782         // returned Comparator&lt;String&gt;, but after the fix it correctly returns
2783         // a Comparator&lt;TreeItem&lt;String&gt;&gt;
2784         Comparator nonGenericComparator = treeTableView.getComparator();
2785         Comparator&lt;TreeItem&lt;String&gt;&gt; genericComparator = treeTableView.getComparator();
2786         assertNull(nonGenericComparator);
2787         assertNull(genericComparator);
2788 
2789         // add in a column and some data
2790         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2791         col.setEditable(true);
2792         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2793         treeTableView.getColumns().add(col);
2794 
2795         installChildren();
2796 
2797         // sort by that column
2798         treeTableView.getSortOrder().add(col);
2799 
2800         // get the new comparator, which should no longer be null
2801         nonGenericComparator = treeTableView.getComparator();
2802         genericComparator = treeTableView.getComparator();
2803         assertNotNull(nonGenericComparator);
2804         assertNotNull(genericComparator);
2805 
2806         // now, as noted above, previously we would use the Comparator to compare
2807         // two String instances, which would fail at runtime as the Comparator
2808         // was actually expecting to compare two TreeItem&lt;String&gt;, but the API
2809         // was failing us.
2810         try {
2811             nonGenericComparator.compare(&quot;abc&quot;, &quot;def&quot;);
2812             fail(&quot;This should not work!&quot;);
2813         } catch (ClassCastException e) {
2814             // if we get the exception, we&#39;re happy
2815         }
2816 
2817         try {
2818             Object string1 = &quot;abc&quot;;
2819             Object string2 = &quot;def&quot;;
2820             genericComparator.compare((TreeItem&lt;String&gt;)string1, (TreeItem&lt;String&gt;)string2);
2821             fail(&quot;This should not work!&quot;);
2822         } catch (ClassCastException e) {
2823             // if we get the exception, we&#39;re happy
2824         }
2825     }
2826 
2827     @Test public void test_rt26718() {
2828         treeTableView.setRoot(new TreeItem(&quot;Root&quot;));
2829         treeTableView.getRoot().setExpanded(true);
2830 
2831         for (int i = 0; i &lt; 4; i++) {
2832             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2833             treeTableView.getRoot().getChildren().add(parent);
2834 
2835             for (int j = 0; j &lt; 4; j++) {
2836                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2837                 parent.getChildren().add(child);
2838             }
2839         }
2840 
2841         treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2842 
2843         final TreeItem item0 = treeTableView.getTreeItem(1);
2844         final TreeItem item1 = treeTableView.getTreeItem(2);
2845 
2846         assertEquals(&quot;item - 0&quot;, item0.getValue());
2847         assertEquals(&quot;item - 1&quot;, item1.getValue());
2848 
2849         item0.setExpanded(true);
2850         item1.setExpanded(true);
2851         Toolkit.getToolkit().firePulse();
2852 
2853         treeTableView.getSelectionModel().selectRange(0, 8);
2854         assertEquals(8, treeTableView.getSelectionModel().getSelectedIndices().size());
2855         assertEquals(7, treeTableView.getSelectionModel().getSelectedIndex());
2856         assertEquals(7, treeTableView.getFocusModel().getFocusedIndex());
2857 
2858         // collapse item0 - but because the selected and focused indices are
2859         // not children of item 0, they should remain where they are (but of
2860         // course be shifted up). The bug was that focus was moving up to item0,
2861         // which makes no sense
2862         item0.setExpanded(false);
2863         Toolkit.getToolkit().firePulse();
2864         assertEquals(3, treeTableView.getSelectionModel().getSelectedIndex());
2865         assertEquals(3, treeTableView.getFocusModel().getFocusedIndex());
2866     }
2867 
2868 //    @Ignore(&quot;Test started intermittently failing, most probably due to RT-36855 changeset&quot;)
2869     @Test public void test_rt_34493() {
2870         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
2871             new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;))
2872         );
2873 
2874         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
2875 
2876         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
2877         root.setExpanded(true);
2878         table.setRoot(root);
2879         table.setShowRoot(false);
2880         root.getChildren().setAll(persons);
2881 
2882         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
2883         first.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
2884 
2885         TreeTableColumn last = new TreeTableColumn(&quot;Last Name&quot;);
2886         last.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
2887 
2888         TreeTableColumn email = new TreeTableColumn(&quot;Email&quot;);
2889         email.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
2890 
2891         table.getColumns().addAll(first, last, email);
2892 
2893         // load the table
2894         StageLoader sl = new StageLoader(table);
2895 
2896         // resize the last column
2897         TableColumnBaseHelper.setWidth(last, 400);
2898         assertEquals(400, last.getWidth(), 0.0);
2899 
2900         // hide the first column
2901         table.getColumns().remove(first);
2902         Toolkit.getToolkit().firePulse();
2903 
2904         // the last column should still be 400px, not the default width or any
2905         // other value (based on the width of the content in that column)
2906         assertEquals(400, last.getWidth(), 0.0);
2907 
2908         sl.dispose();
2909     }
2910 
2911     @Test public void test_rt26721_collapseParent_firstRootChild() {
2912         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
2913         table.setRoot(new TreeItem(&quot;Root&quot;));
2914         table.getRoot().setExpanded(true);
2915 
2916         for (int i = 0; i &lt; 4; i++) {
2917             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2918             table.getRoot().getChildren().add(parent);
2919 
2920             for (int j = 0; j &lt; 4; j++) {
2921                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2922                 parent.getChildren().add(child);
2923             }
2924         }
2925 
2926         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2927 
2928         final TreeItem&lt;String&gt; item0 = table.getTreeItem(1);
2929         final TreeItem&lt;String&gt; item0child0 = item0.getChildren().get(0);
2930         final TreeItem&lt;String&gt; item1 = table.getTreeItem(2);
2931 
2932         assertEquals(&quot;item - 0&quot;, item0.getValue());
2933         assertEquals(&quot;item - 1&quot;, item1.getValue());
2934 
2935         item0.setExpanded(true);
2936         item1.setExpanded(true);
2937         Toolkit.getToolkit().firePulse();
2938 
2939         // select the first child of item0
2940         table.getSelectionModel().select(item0child0);
2941 
2942         assertEquals(item0child0, table.getSelectionModel().getSelectedItem());
2943         assertEquals(item0child0, table.getFocusModel().getFocusedItem());
2944 
2945         // collapse item0 - we expect the selection / focus to move up to item0
2946         item0.setExpanded(false);
2947         Toolkit.getToolkit().firePulse();
2948         assertEquals(item0, table.getSelectionModel().getSelectedItem());
2949         assertEquals(item0, table.getFocusModel().getFocusedItem());
2950     }
2951 
2952     @Test public void test_rt26721_collapseParent_lastRootChild() {
2953         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
2954         table.setRoot(new TreeItem(&quot;Root&quot;));
2955         table.getRoot().setExpanded(true);
2956 
2957         for (int i = 0; i &lt; 4; i++) {
2958             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2959             table.getRoot().getChildren().add(parent);
2960 
2961             for (int j = 0; j &lt; 4; j++) {
2962                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2963                 parent.getChildren().add(child);
2964             }
2965         }
2966 
2967         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2968 
2969         final TreeItem&lt;String&gt; item3 = table.getTreeItem(4);
2970         final TreeItem&lt;String&gt; item3child0 = item3.getChildren().get(0);
2971 
2972         assertEquals(&quot;item - 3&quot;, item3.getValue());
2973         assertEquals(&quot;item - 3 0&quot;, item3child0.getValue());
2974 
2975         item3.setExpanded(true);
2976         Toolkit.getToolkit().firePulse();
2977 
2978         // select the first child of item0
2979         table.getSelectionModel().select(item3child0);
2980 
2981         assertEquals(item3child0, table.getSelectionModel().getSelectedItem());
2982         assertEquals(item3child0, table.getFocusModel().getFocusedItem());
2983 
2984         // collapse item3 - we expect the selection / focus to move up to item3
2985         item3.setExpanded(false);
2986         Toolkit.getToolkit().firePulse();
2987         assertEquals(item3, table.getSelectionModel().getSelectedItem());
2988         assertEquals(item3, table.getFocusModel().getFocusedItem());
2989     }
2990 
2991     @Test public void test_rt26721_collapseGrandParent() {
2992         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
2993         table.setRoot(new TreeItem(&quot;Root&quot;));
2994         table.getRoot().setExpanded(true);
2995 
2996         for (int i = 0; i &lt; 4; i++) {
2997             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2998             table.getRoot().getChildren().add(parent);
2999 
3000             for (int j = 0; j &lt; 4; j++) {
3001                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
3002                 parent.getChildren().add(child);
3003             }
3004         }
3005 
3006         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
3007 
3008         final TreeItem&lt;String&gt; item0 = table.getTreeItem(1);
3009         final TreeItem&lt;String&gt; item0child0 = item0.getChildren().get(0);
3010         final TreeItem&lt;String&gt; item1 = table.getTreeItem(2);
3011 
3012         assertEquals(&quot;item - 0&quot;, item0.getValue());
3013         assertEquals(&quot;item - 1&quot;, item1.getValue());
3014 
3015         item0.setExpanded(true);
3016         item1.setExpanded(true);
3017         Toolkit.getToolkit().firePulse();
3018 
3019         // select the first child of item0
3020         table.getSelectionModel().select(item0child0);
3021 
3022         assertEquals(item0child0, table.getSelectionModel().getSelectedItem());
3023         assertEquals(item0child0, table.getFocusModel().getFocusedItem());
3024 
3025         // collapse root - we expect the selection / focus to move up to root
3026         table.getRoot().setExpanded(false);
3027         Toolkit.getToolkit().firePulse();
3028         assertEquals(table.getRoot(), table.getSelectionModel().getSelectedItem());
3029         assertEquals(table.getRoot(), table.getFocusModel().getFocusedItem());
3030     }
3031 
3032     @Test public void test_rt_34685_directEditCall_cellSelectionMode() {
3033         test_rt_34685_commitCount = 0;
3034         test_rt_34685(false, true);
3035     }
3036 
3037     @Test public void test_rt_34685_directEditCall_rowSelectionMode() {
3038         test_rt_34685_commitCount = 0;
3039         test_rt_34685(false, false);
3040     }
3041 
3042     @Test public void test_rt_34685_mouseDoubleClick_cellSelectionMode() {
3043         test_rt_34685_commitCount = 0;
3044         test_rt_34685(true, true);
3045     }
3046 
3047     @Test public void test_rt_34685_mouseDoubleClick_rowSelectionMode() {
3048         test_rt_34685_commitCount = 0;
3049         test_rt_34685(true, false);
3050     }
3051 
3052     private int test_rt_34685_commitCount = 0;
3053     private void test_rt_34685(boolean useMouseToInitiateEdit, boolean cellSelectionModeEnabled) {
3054         assertEquals(0, test_rt_34685_commitCount);
3055 
3056         Person person1;
3057         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
3058             new TreeItem&lt;&gt;(person1 = new Person(&quot;John&quot;, &quot;Smith&quot;, &quot;john.smith@example.com&quot;))
3059         );
3060 
3061         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
3062         table.getSelectionModel().setCellSelectionEnabled(cellSelectionModeEnabled);
3063         table.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
3064         table.setEditable(true);
3065 
3066         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
3067         root.setExpanded(true);
3068         table.setRoot(root);
3069         table.setShowRoot(false);
3070         root.getChildren().setAll(persons);
3071 
3072         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
3073         first.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
3074         first.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
3075 
3076         EventHandler&lt;TreeTableColumn.CellEditEvent&lt;Person, String&gt;&gt; onEditCommit = first.getOnEditCommit();
3077         first.setOnEditCommit(new EventHandler&lt;TreeTableColumn.CellEditEvent&lt;Person, String&gt;&gt;() {
3078             @Override public void handle(TreeTableColumn.CellEditEvent&lt;Person, String&gt; event) {
3079                 test_rt_34685_commitCount++;
3080                 onEditCommit.handle(event);
3081             }
3082         });
3083 
3084         table.getColumns().addAll(first);
3085 
3086         // get the cell at (0,0) - we&#39;re hiding the root row
3087         VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = true;
3088         TreeTableCell cell = (TreeTableCell) VirtualFlowTestUtils.getCell(table, 0, 0);
3089         VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = false;
3090         assertTrue(cell.getSkin() instanceof TreeTableCellSkin);
3091         assertNull(cell.getGraphic());
3092         assertEquals(&quot;John&quot;, cell.getText());
3093         assertEquals(&quot;John&quot;, person1.getFirstName());
3094 
3095         // set the table to be editing the first cell at 0,0
3096         if (useMouseToInitiateEdit) {
3097             MouseEventFirer mouse = new MouseEventFirer(cell);
3098             mouse.fireMousePressAndRelease(2, 10, 10);  // click 10 pixels in and 10 pixels down
3099             mouse.dispose();
3100         } else {
3101             table.edit(0,first);
3102         }
3103 
3104         Toolkit.getToolkit().firePulse();
3105         assertNotNull(cell.getGraphic());
3106         assertTrue(cell.getGraphic() instanceof TextField);
3107 
3108         TextField textField = (TextField) cell.getGraphic();
3109         assertEquals(&quot;John&quot;, textField.getText());
3110 
3111         textField.setText(&quot;Andrew&quot;);
3112         textField.requestFocus();
3113         Toolkit.getToolkit().firePulse();
3114 
3115         KeyEventFirer keyboard = new KeyEventFirer(textField);
3116         keyboard.doKeyPress(KeyCode.ENTER);
3117 
3118         VirtualFlowTestUtils.getVirtualFlow(table).requestLayout();
3119         Toolkit.getToolkit().firePulse();
3120 
3121         VirtualFlowTestUtils.assertTableCellTextEquals(table, 0, 0, &quot;Andrew&quot;);
3122         assertEquals(&quot;Andrew&quot;, cell.getText());
3123         assertEquals(&quot;Andrew&quot;, person1.getFirstName());
3124         assertEquals(1, test_rt_34685_commitCount);
3125     }
3126 
3127     @Test public void test_rt34694() {
3128         TreeItem treeNode = new TreeItem(&quot;Controls&quot;);
3129         treeNode.getChildren().addAll(
3130                 new TreeItem(&quot;Button&quot;),
3131                 new TreeItem(&quot;ButtonBar&quot;),
3132                 new TreeItem(&quot;LinkBar&quot;),
3133                 new TreeItem(&quot;LinkButton&quot;),
3134                 new TreeItem(&quot;PopUpButton&quot;),
3135                 new TreeItem(&quot;ToggleButtonBar&quot;)
3136         );
3137 
3138         final TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3139         table.setRoot(treeNode);
3140         treeNode.setExpanded(true);
3141 
3142         table.getSelectionModel().select(0);
3143         assertTrue(table.getSelectionModel().isSelected(0));
3144         assertTrue(table.getFocusModel().isFocused(0));
3145 
3146         treeNode.getChildren().clear();
3147         treeNode.getChildren().addAll(
3148                 new TreeItem(&quot;Button1&quot;),
3149                 new TreeItem(&quot;ButtonBar1&quot;),
3150                 new TreeItem(&quot;LinkBar1&quot;),
3151                 new TreeItem(&quot;LinkButton1&quot;),
3152                 new TreeItem(&quot;PopUpButton1&quot;),
3153                 new TreeItem(&quot;ToggleButtonBar1&quot;)
3154         );
3155         Toolkit.getToolkit().firePulse();
3156 
3157         assertTrue(table.getSelectionModel().isSelected(0));
3158         assertTrue(table.getFocusModel().isFocused(0));
3159     }
3160 
3161     private int test_rt_35213_eventCount = 0;
3162     @Test public void test_rt35213() {
3163         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;();
3164 
3165         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Boss&quot;);
3166         view.setRoot(root);
3167 
3168         TreeItem&lt;String&gt; group1 = new TreeItem&lt;&gt;(&quot;Group 1&quot;);
3169         TreeItem&lt;String&gt; group2 = new TreeItem&lt;&gt;(&quot;Group 2&quot;);
3170         TreeItem&lt;String&gt; group3 = new TreeItem&lt;&gt;(&quot;Group 3&quot;);
3171 
3172         root.getChildren().addAll(group1, group2, group3);
3173 
3174         TreeItem&lt;String&gt; employee1 = new TreeItem&lt;&gt;(&quot;Employee 1&quot;);
3175         TreeItem&lt;String&gt; employee2 = new TreeItem&lt;&gt;(&quot;Employee 2&quot;);
3176 
3177         group2.getChildren().addAll(employee1, employee2);
3178 
3179         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;Name&quot;);
3180         nameColumn.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
3181         view.getColumns().add(nameColumn);
3182 
3183         view.expandedItemCountProperty().addListener((observableValue, oldCount, newCount) -&gt; {
3184 
3185             // DEBUG OUTPUT
3186 //                System.out.println(&quot;new expanded item count: &quot; + newCount.intValue());
3187 //                for (int i = 0; i &lt; newCount.intValue(); i++) {
3188 //                    TreeItem&lt;String&gt; item = view.getTreeItem(i);
3189 //                    String text = item.getValue();
3190 //                    System.out.println(&quot;person found at index &quot; + i + &quot; is &quot; + text);
3191 //                }
3192 //                System.out.println(&quot;------------------------------------------&quot;);
3193 
3194             if (test_rt_35213_eventCount == 0) {
3195                 assertEquals(4, newCount);
3196                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3197                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3198                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3199                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(3).getValue());
3200             } else if (test_rt_35213_eventCount == 1) {
3201                 assertEquals(6, newCount);
3202                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3203                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3204                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3205                 assertEquals(&quot;Employee 1&quot;, view.getTreeItem(3).getValue());
3206                 assertEquals(&quot;Employee 2&quot;, view.getTreeItem(4).getValue());
3207                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(5).getValue());
3208             } else if (test_rt_35213_eventCount == 2) {
3209                 assertEquals(4, newCount);
3210                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3211                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3212                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3213                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(3).getValue());
3214             }
3215 
3216             test_rt_35213_eventCount++;
3217         });
3218 
3219         StageLoader sl = new StageLoader(view);
3220 
3221         root.setExpanded(true);
3222         Toolkit.getToolkit().firePulse();
3223 
3224         group2.setExpanded(true);
3225         Toolkit.getToolkit().firePulse();
3226 
3227         group2.setExpanded(false);
3228         Toolkit.getToolkit().firePulse();
3229 
3230         sl.dispose();
3231     }
3232 
3233     @Test public void test_rt23245_itemIsInTree() {
3234         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;String&gt;();
3235         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3236         for (int i = 0; i &lt; 10; i++) {
3237             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3238             item.setExpanded(true);
3239             items.add(item);
3240         }
3241 
3242         // link the items up so that the next item is the child of the current item
3243         for (int i = 0; i &lt; 9; i++) {
3244             items.get(i).getChildren().add(items.get(i + 1));
3245         }
3246 
3247         view.setRoot(items.get(0));
3248 
3249         for (int i = 0; i &lt; 10; i++) {
3250             // we expect the level of the tree item at the ith position to be
3251             // 0, as every iteration we are setting the ith item as the root.
3252             assertEquals(0, view.getTreeItemLevel(items.get(i)));
3253 
3254             // whilst we are testing, we should also ensure that the ith item
3255             // is indeed the root item, and that the ith item is indeed the item
3256             // at the 0th position
3257             assertEquals(items.get(i), view.getRoot());
3258             assertEquals(items.get(i), view.getTreeItem(0));
3259 
3260             // shuffle the next item into the root position (keeping its parent
3261             // chain intact - which is what exposes this issue in the first place).
3262             if (i &lt; 9) {
3263                 view.setRoot(items.get(i + 1));
3264             }
3265         }
3266     }
3267 
3268     @Test public void test_rt23245_itemIsNotInTree_noRootNode() {
3269         final TreeView&lt;String&gt; view = new TreeView&lt;String&gt;();
3270         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3271         for (int i = 0; i &lt; 10; i++) {
3272             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3273             item.setExpanded(true);
3274             items.add(item);
3275         }
3276 
3277         // link the items up so that the next item is the child of the current item
3278         for (int i = 0; i &lt; 9; i++) {
3279             items.get(i).getChildren().add(items.get(i + 1));
3280         }
3281 
3282         for (int i = 0; i &lt; 10; i++) {
3283             // because we have no root (and we are not changing the root like
3284             // the previous test), we expect the tree item level of the item
3285             // in the ith position to be i.
3286             assertEquals(i, view.getTreeItemLevel(items.get(i)));
3287 
3288             // all items requested from the TreeView should be null, as the
3289             // TreeView does not have a root item
3290             assertNull(view.getTreeItem(i));
3291         }
3292     }
3293 
3294     @Test public void test_rt23245_itemIsNotInTree_withUnrelatedRootNode() {
3295         final TreeView&lt;String&gt; view = new TreeView&lt;String&gt;();
3296         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3297         for (int i = 0; i &lt; 10; i++) {
3298             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3299             item.setExpanded(true);
3300             items.add(item);
3301         }
3302 
3303         // link the items up so that the next item is the child of the current item
3304         for (int i = 0; i &lt; 9; i++) {
3305             items.get(i).getChildren().add(items.get(i + 1));
3306         }
3307 
3308         view.setRoot(new TreeItem(&quot;Unrelated root node&quot;));
3309 
3310         for (int i = 0; i &lt; 10; i++) {
3311             // because we have no root (and we are not changing the root like
3312             // the previous test), we expect the tree item level of the item
3313             // in the ith position to be i.
3314             assertEquals(i, view.getTreeItemLevel(items.get(i)));
3315 
3316             // all items requested from the TreeView should be null except for
3317             // the root node
3318             assertNull(view.getTreeItem(i + 1));
3319         }
3320     }
3321 
3322     @Test public void test_rt35039_setRoot() {
3323         TreeItem aabbaa = new TreeItem(&quot;aabbaa&quot;);
3324         TreeItem bbc = new TreeItem(&quot;bbc&quot;);
3325 
3326         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3327         root.setExpanded(true);
3328         root.getChildren().setAll(aabbaa, bbc);
3329 
3330         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3331         treeView.setRoot(root);
3332 
3333         StageLoader sl = new StageLoader(treeView);
3334 
3335         // Selection starts in row -1
3336         assertNull(treeView.getSelectionModel().getSelectedItem());
3337 
3338         // select &quot;bbc&quot; and ensure everything is set to that
3339         treeView.getSelectionModel().select(2);
3340         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3341 
3342         // change the items list - but retain the same content. We expect
3343         // that &quot;bbc&quot; remains selected as it is still in the list
3344         treeView.setRoot(root);
3345         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3346 
3347         sl.dispose();
3348     }
3349 
3350     @Test public void test_rt35039_resetRootChildren() {
3351         TreeItem aabbaa = new TreeItem(&quot;aabbaa&quot;);
3352         TreeItem bbc = new TreeItem(&quot;bbc&quot;);
3353 
3354         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3355         root.setExpanded(true);
3356         root.getChildren().setAll(aabbaa, bbc);
3357 
3358         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3359         treeView.setRoot(root);
3360 
3361         StageLoader sl = new StageLoader(treeView);
3362 
3363         // Selection starts in row -1
3364         assertNull(treeView.getSelectionModel().getSelectedItem());
3365 
3366         // select &quot;bbc&quot; and ensure everything is set to that
3367         treeView.getSelectionModel().select(2);
3368         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3369 
3370         // change the items list - but retain the same content. We expect
3371         // that &quot;bbc&quot; remains selected as it is still in the list
3372         root.getChildren().setAll(aabbaa, bbc);
3373         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3374 
3375         sl.dispose();
3376     }
3377 
3378     @Test public void test_rt35763() {
3379         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3380         root.setExpanded(true);
3381         TreeItem aaa = new TreeItem(&quot;aaa&quot;);
3382         TreeItem bbb = new TreeItem(&quot;bbb&quot;);
3383         root.getChildren().setAll(bbb, aaa);
3384 
3385         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3386 
3387         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3388         col.setCellValueFactory(param -&gt; param.getValue().valueProperty());
3389 
3390         treeView.getColumns().add(col);
3391         treeView.setRoot(root);
3392 
3393         assertEquals(root, treeView.getTreeItem(0));
3394         assertEquals(bbb, treeView.getTreeItem(1));
3395         assertEquals(aaa,treeView.getTreeItem(2));
3396 
3397         // change sort order - expect items to be sorted
3398         treeView.getSortOrder().setAll(col);
3399 
3400         assertEquals(1, treeView.getSortOrder().size());
3401         assertEquals(col, treeView.getSortOrder().get(0));
3402 
3403         Toolkit.getToolkit().firePulse();
3404 
3405         assertEquals(root, treeView.getTreeItem(0));
3406         assertEquals(bbb, treeView.getTreeItem(2));
3407         assertEquals(aaa,treeView.getTreeItem(1));
3408 
3409         // set new items into items list - expect sortOrder list to be reset
3410         // and the items list to remain unsorted
3411         TreeItem&lt;String&gt; root2 = new TreeItem&lt;&gt;(&quot;Root&quot;);
3412         root2.setExpanded(true);
3413         TreeItem ccc = new TreeItem(&quot;ccc&quot;);
3414         TreeItem ddd = new TreeItem(&quot;ddd&quot;);
3415         root2.getChildren().setAll(ddd, ccc);
3416         treeView.setRoot(root2);
3417 
3418         assertEquals(root2, treeView.getTreeItem(0));
3419         assertEquals(ddd, treeView.getTreeItem(1));
3420         assertEquals(ccc,treeView.getTreeItem(2));
3421 
3422         assertTrue(treeView.getSortOrder().isEmpty());
3423     }
3424 
3425     @Test public void test_rt35857() {
3426         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3427         root.setExpanded(true);
3428         TreeItem a = new TreeItem(&quot;A&quot;);
3429         TreeItem b = new TreeItem(&quot;B&quot;);
3430         TreeItem c = new TreeItem(&quot;C&quot;);
3431         root.getChildren().setAll(a, b, c);
3432 
3433         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;String&gt;(root);
3434 
3435         treeTableView.getSelectionModel().select(1);
3436 
3437         ObservableList&lt;TreeItem&lt;String&gt;&gt; selectedItems = treeTableView.getSelectionModel().getSelectedItems();
3438         assertEquals(1, selectedItems.size());
3439         assertEquals(&quot;A&quot;, selectedItems.get(0).getValue());
3440 
3441         root.getChildren().removeAll(selectedItems);
3442         assertEquals(2, root.getChildren().size());
3443         assertEquals(&quot;B&quot;, root.getChildren().get(0).getValue());
3444         assertEquals(&quot;C&quot;, root.getChildren().get(1).getValue());
3445     }
3446 
3447     private int rt36452_instanceCount = 0;
3448     @Test public void test_rt36452() {
3449         TreeTableColumn&lt;String, String&gt; myColumn = new TreeTableColumn&lt;String,String&gt;();
3450         myColumn.setCellValueFactory((item)-&gt;(new ReadOnlyObjectWrapper&lt;&gt;(item.getValue().getValue())));
3451         myColumn.setCellFactory(column -&gt; new TreeTableCell&lt;String, String&gt;() {
3452             {
3453                 rt36452_instanceCount++;
3454             }
3455         });
3456 
3457         TreeTableView&lt;String&gt; ttv = new TreeTableView&lt;&gt;();
3458         ttv.setShowRoot(false);
3459         ttv.getColumns().add(myColumn);
3460 
3461         TreeItem&lt;String&gt; treeRootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
3462         treeRootItem.setExpanded(true);
3463 
3464         for (int i = 0; i &lt; 100; i++) {
3465             treeRootItem.getChildren().add(new TreeItem&lt;&gt;(&quot;Child: &quot; + i));
3466         }
3467 
3468         ttv.setRoot(treeRootItem);
3469         ttv.setFixedCellSize(25);
3470 
3471         StackPane root = new StackPane();
3472         root.getChildren().add(ttv);
3473 
3474         StageLoader sl = new StageLoader(root);
3475 
3476         final int cellCountAtStart = rt36452_instanceCount;
3477 
3478         // start scrolling
3479         for (int i = 0; i &lt; 100; i++) {
3480             ttv.scrollTo(i);
3481             Toolkit.getToolkit().firePulse();
3482         }
3483 
3484         // we don&#39;t mind if an extra few cells are created. What we are really
3485         // testing for here is that we don&#39;t end up with an order of magnitude
3486         // extra cells.
3487         // On my machine the cellCountAtStart is 16. Before this issue was fixed
3488         // I would end up with 102 instances after running this test. Once the
3489         // bug was fixed, I would consistently see that 17 cells had been
3490         // created in total.
3491         // However, for now, we&#39;ll test on the assumption that across all
3492         // platforms we only get one extra cell created, and we can loosen this
3493         // up if necessary.
3494         assertEquals(cellCountAtStart + 1, rt36452_instanceCount);
3495 
3496         sl.dispose();
3497     }
3498 
3499     @Test public void test_rt25679_rowSelection() {
3500         test_rt25679(true);
3501     }
3502 
3503     @Test public void test_rt25679_cellSelection() {
3504         test_rt25679(false);
3505     }
3506 
3507     private void test_rt25679(boolean rowSelection) {
3508         Button focusBtn = new Button(&quot;Focus here&quot;);
3509 
3510         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3511         root.getChildren().setAll(new TreeItem(&quot;a&quot;), new TreeItem(&quot;b&quot;));
3512         root.setExpanded(true);
3513 
3514         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
3515         TreeTableColumn&lt;String, String&gt; tableColumn = new TreeTableColumn&lt;&gt;();
3516         tableColumn.setCellValueFactory(rowValue -&gt; new SimpleStringProperty(rowValue.getValue().getValue()));
3517         treeView.getColumns().add(tableColumn);
3518 
3519         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = treeView.getSelectionModel();
3520         sm.setCellSelectionEnabled(! rowSelection);
3521 
3522         VBox vbox = new VBox(focusBtn, treeView);
3523 
3524         StageLoader sl = new StageLoader(vbox);
3525         sl.getStage().requestFocus();
3526         focusBtn.requestFocus();
3527         Toolkit.getToolkit().firePulse();
3528 
3529         // test initial state
3530         assertEquals(sl.getStage().getScene().getFocusOwner(), focusBtn);
3531         assertTrue(focusBtn.isFocused());
3532         assertEquals(-1, sm.getSelectedIndex());
3533         assertNull(sm.getSelectedItem());
3534 
3535         // move focus to the TreeTableView
3536         treeView.requestFocus();
3537 
3538         // ensure that there is a selection (where previously there was not one)
3539         assertEquals(sl.getStage().getScene().getFocusOwner(), treeView);
3540         assertTrue(treeView.isFocused());
3541 
3542         if (rowSelection) {
3543             assertEquals(0, sm.getSelectedIndices().size());
3544             assertNull(sm.getSelectedItem());
3545             assertFalse(sm.isSelected(0));
3546             assertEquals(0, sm.getSelectedCells().size());
3547         } else {
3548             assertFalse(sm.isSelected(0, tableColumn));
3549             assertEquals(0, sm.getSelectedCells().size());
3550         }
3551 
3552         sl.dispose();
3553     }
3554 
3555     @Test public void test_rt36885() {
3556         test_rt36885(false);
3557     }
3558 
3559     @Test public void test_rt36885_addChildAfterSelection() {
3560         test_rt36885(true);
3561     }
3562 
3563     private void test_rt36885(boolean addChildToAAfterSelection) {
3564         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);         // 0
3565                 TreeItem&lt;String&gt; a = new TreeItem&lt;&gt;(&quot;a&quot;);       // 1
3566                     TreeItem&lt;String&gt; a1 = new TreeItem&lt;&gt;(&quot;a1&quot;); // a expanded = 2, a collapsed = -1
3567             TreeItem&lt;String&gt; b = new TreeItem&lt;&gt;(&quot;b&quot;);           // a expanded = 3, a collapsed = 2
3568                 TreeItem&lt;String&gt; b1 = new TreeItem&lt;&gt;(&quot;b1&quot;);     // a expanded = 4, a collapsed = 3
3569                 TreeItem&lt;String&gt; b2 = new TreeItem&lt;&gt;(&quot;b2&quot;);     // a expanded = 5, a collapsed = 4
3570 
3571         root.setExpanded(true);
3572         root.getChildren().setAll(a, b);
3573 
3574         a.setExpanded(false);
3575         if (!addChildToAAfterSelection) {
3576             a.getChildren().add(a1);
3577         }
3578 
3579         b.setExpanded(true);
3580         b.getChildren().addAll(b1, b2);
3581 
3582         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
3583         TreeTableColumn&lt;String, String&gt; tableColumn = new TreeTableColumn&lt;&gt;();
3584         tableColumn.setCellValueFactory(rowValue -&gt; new SimpleStringProperty(rowValue.getValue().getValue()));
3585         treeView.getColumns().add(tableColumn);
3586 
3587         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = treeView.getSelectionModel();
3588         FocusModel&lt;TreeItem&lt;String&gt;&gt; fm = treeView.getFocusModel();
3589 
3590         sm.select(b1);
3591         assertEquals(3, sm.getSelectedIndex());
3592         assertEquals(b1, sm.getSelectedItem());
3593         assertEquals(3, fm.getFocusedIndex());
3594         assertEquals(b1, fm.getFocusedItem());
3595 
3596         if (addChildToAAfterSelection) {
3597             a.getChildren().add(a1);
3598         }
3599 
3600         a.setExpanded(true);
3601         assertEquals(4, sm.getSelectedIndex());
3602         assertEquals(b1, sm.getSelectedItem());
3603         assertEquals(4, fm.getFocusedIndex());
3604         assertEquals(b1, fm.getFocusedItem());
3605     }
3606 
3607     private int rt_37061_index_counter = 0;
3608     private int rt_37061_item_counter = 0;
3609     @Test public void test_rt_37061() {
3610         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
3611         root.setExpanded(true);
3612         TreeTableView&lt;Integer&gt; tv = new TreeTableView&lt;&gt;();
3613         tv.setRoot(root);
3614         tv.getSelectionModel().select(0);
3615 
3616         // note we add the listeners after the selection is made, so the counters
3617         // at this point are still both at zero.
3618         tv.getSelectionModel().selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; {
3619             rt_37061_index_counter++;
3620         });
3621 
3622         tv.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; {
3623             rt_37061_item_counter++;
3624         });
3625 
3626         // add a new item. This does not impact the selected index or selected item
3627         // so the counters should remain at zero.
3628         tv.getRoot().getChildren().add(new TreeItem(&quot;1&quot;));
3629         assertEquals(0, rt_37061_index_counter);
3630         assertEquals(0, rt_37061_item_counter);
3631     }
3632 
3633     @Test public void test_rt_37054_noScroll() {
3634         test_rt_37054(false);
3635     }
3636 
3637     @Test public void test_rt_37054_scroll() {
3638         test_rt_37054(true);
3639     }
3640 
3641     private void test_rt_37054(boolean scroll) {
3642         ObjectProperty&lt;Integer&gt; offset = new SimpleObjectProperty&lt;Integer&gt;(0);
3643 
3644         // create table with a bunch of rows and 1 column...
3645         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
3646         root.setExpanded(true);
3647         for (int i = 1; i &lt;= 50; i++) {
3648             root.getChildren().add(new TreeItem&lt;&gt;(i));
3649         }
3650 
3651         final TreeTableColumn&lt;Integer, Integer&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3652 
3653         final TreeTableView&lt;Integer&gt; table = new TreeTableView&lt;&gt;(root);
3654         table.getColumns().add( column );
3655         column.setPrefWidth( 150 );
3656 
3657         // each cell displays x, where x = &quot;cell row number + offset&quot;
3658         column.setCellValueFactory( cdf -&gt; new ObjectBinding&lt;Integer&gt;() {
3659             { super.bind( offset ); }
3660 
3661             @Override protected Integer computeValue() {
3662                 return cdf.getValue().getValue() + offset.get();
3663             }
3664         });
3665 
3666         StackPane stack = new StackPane();
3667         stack.getChildren().add(table);
3668         StageLoader sl = new StageLoader(stack);
3669 
3670         int index = scroll ? 0 : 25;
3671 
3672         if (scroll) {
3673             // we scroll to force the table cells to update the objects they observe
3674             table.scrollTo(index);
3675             Toolkit.getToolkit().firePulse();
3676         }
3677 
3678         TreeTableCell cell = (TreeTableCell) VirtualFlowTestUtils.getCell(table, index + 3, 0);
3679         final int initialValue = (Integer) cell.getItem();
3680 
3681         // increment the offset value
3682         offset.setValue(offset.get() + 1);
3683         Toolkit.getToolkit().firePulse();
3684 
3685         final int incrementedValue = (Integer) cell.getItem();
3686         assertEquals(initialValue + 1, incrementedValue);
3687 
3688         sl.dispose();
3689     }
3690 
3691     private int rt_37395_index_addCount = 0;
3692     private int rt_37395_index_removeCount = 0;
3693     private int rt_37395_index_permutationCount = 0;
3694     private int rt_37395_item_addCount = 0;
3695     private int rt_37395_item_removeCount = 0;
3696     private int rt_37395_item_permutationCount = 0;
3697 
3698     @Test public void test_rt_37395() {
3699         // table items - 3 items, 2nd item has 2 children
3700         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3701 
3702         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
3703         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
3704         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
3705 
3706         root.getChildren().add(new TreeItem&lt;&gt;(&quot;one&quot;));
3707         root.getChildren().add(two);
3708         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
3709 
3710         // table columns - 1 column; name
3711         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3712         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3713         nameColumn.setPrefWidth(200);
3714 
3715         // table
3716         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3717         table.setShowRoot(false);
3718         table.setRoot(root);
3719         table.getColumns().addAll(nameColumn);
3720 
3721         TreeTableView.TreeTableViewSelectionModel sm = table.getSelectionModel();
3722         sm.getSelectedIndices().addListener(new ListChangeListener&lt;Integer&gt;() {
3723             @Override public void onChanged(Change&lt;? extends Integer&gt; c) {
3724                 while (c.next()) {
3725                     if (c.wasRemoved()) {
3726                         c.getRemoved().forEach(item -&gt; {
3727                             if (item == null) {
3728                                 fail(&quot;Removed index should never be null&quot;);
3729                             } else {
3730                                 rt_37395_index_removeCount++;
3731                             }
3732                         });
3733                     }
3734                     if (c.wasAdded()) {
3735                         c.getAddedSubList().forEach(item -&gt; {
3736                             rt_37395_index_addCount++;
3737                         });
3738                     }
3739                     if (c.wasPermutated()) {
3740                         rt_37395_index_permutationCount++;
3741                     }
3742                 }
3743             }
3744         });
3745         sm.getSelectedItems().addListener(new ListChangeListener&lt;TreeItem&lt;String&gt;&gt;() {
3746             @Override public void onChanged(Change&lt;? extends TreeItem&lt;String&gt;&gt; c) {
3747                 while (c.next()) {
3748                     if (c.wasRemoved()) {
3749                         c.getRemoved().forEach(item -&gt; {
3750                             if (item == null) {
3751                                 fail(&quot;Removed item should never be null&quot;);
3752                             } else {
3753                                 rt_37395_item_removeCount++;
3754                             }
3755                         });
3756                     }
3757                     if (c.wasAdded()) {
3758                         c.getAddedSubList().forEach(item -&gt; {
3759                             rt_37395_item_addCount++;
3760                         });
3761                     }
3762                     if (c.wasPermutated()) {
3763                         rt_37395_item_permutationCount++;
3764                     }
3765                 }
3766             }
3767         });
3768 
3769         assertEquals(0, rt_37395_index_removeCount);
3770         assertEquals(0, rt_37395_index_addCount);
3771         assertEquals(0, rt_37395_index_permutationCount);
3772         assertEquals(0, rt_37395_item_removeCount);
3773         assertEquals(0, rt_37395_item_addCount);
3774         assertEquals(0, rt_37395_item_permutationCount);
3775 
3776         StageLoader sl = new StageLoader(table);
3777 
3778         // step one: select item &#39;three&#39; in index 2
3779         sm.select(2);
3780         assertEquals(0, rt_37395_index_removeCount);
3781         assertEquals(1, rt_37395_index_addCount);
3782         assertEquals(0, rt_37395_index_permutationCount);
3783         assertEquals(0, rt_37395_item_removeCount);
3784         assertEquals(1, rt_37395_item_addCount);
3785         assertEquals(0, rt_37395_item_permutationCount);
3786 
3787         // step two: expand item &#39;two&#39;
3788         // The first part of the bug report was that we received add/remove
3789         // change events here, when in reality we shouldn&#39;t have, so lets enforce
3790         // that. We do expect a permutation event on the index, as it has been
3791         // pushed down, but this should not result in an item permutation event,
3792         // as it remains unchanged
3793         two.setExpanded(true);
3794         assertEquals(1, rt_37395_index_removeCount);
3795         assertEquals(2, rt_37395_index_addCount);
3796         assertEquals(0, rt_37395_index_permutationCount);
3797         assertEquals(0, rt_37395_item_removeCount);
3798         assertEquals(1, rt_37395_item_addCount);
3799         assertEquals(0, rt_37395_item_permutationCount);
3800 
3801         // step three: collapse item &#39;two&#39;
3802         // Same argument as in step two above: no addition or removal, just a
3803         // permutation on the index
3804         two.setExpanded(false);
3805         assertEquals(2, rt_37395_index_removeCount);
3806         assertEquals(3, rt_37395_index_addCount);
3807         assertEquals(0, rt_37395_index_permutationCount);
3808         assertEquals(0, rt_37395_item_removeCount);
3809         assertEquals(1, rt_37395_item_addCount);
3810         assertEquals(0, rt_37395_item_permutationCount);
3811 
3812         sl.dispose();
3813     }
3814 
3815     @Test public void test_rt_37429() {
3816         // table items - 3 items, 2nd item has 2 children
3817         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3818 
3819         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
3820         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
3821         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
3822         two.setExpanded(true);
3823 
3824         root.getChildren().add(new TreeItem&lt;&gt;(&quot;one&quot;));
3825         root.getChildren().add(two);
3826         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
3827 
3828         // table columns - 1 column; name
3829         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3830         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3831         nameColumn.setPrefWidth(200);
3832 
3833         // table
3834         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3835         table.setShowRoot(false);
3836         table.setRoot(root);
3837         table.getColumns().addAll(nameColumn);
3838 
3839         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
3840             while (c.next()) {
3841                 if(c.wasRemoved()) {
3842                     // The removed list of items must be iterated or the AIOOBE will
3843                     // not be thrown when getAddedSubList is called.
3844                     c.getRemoved().forEach(item -&gt; {});
3845                 }
3846 
3847                 if (c.wasAdded()) {
3848                     c.getAddedSubList();
3849                 }
3850             }
3851         });
3852 
3853         StageLoader sl = new StageLoader(table);
3854 
3855         ControlTestUtils.runWithExceptionHandler(() -&gt; {
3856             table.getSelectionModel().select(0);
3857             table.getSortOrder().add(nameColumn);
3858         });
3859 
3860         sl.dispose();
3861     }
3862 
3863     private int rt_37429_items_change_count = 0;
3864     private int rt_37429_cells_change_count = 0;
3865     @Test public void test_rt_37429_sortEventsShouldNotFireExtraChangeEvents() {
3866         // table items - 3 items, 2nd item has 2 children
3867         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3868 
3869         root.getChildren().add(new TreeItem&lt;&gt;(&quot;a&quot;));
3870         root.getChildren().add(new TreeItem&lt;&gt;(&quot;c&quot;));
3871         root.getChildren().add(new TreeItem&lt;&gt;(&quot;b&quot;));
3872 
3873         // table columns - 1 column; name
3874         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3875         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3876         nameColumn.setPrefWidth(200);
3877 
3878         // table
3879         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3880         table.setShowRoot(false);
3881         table.setRoot(root);
3882         table.getColumns().addAll(nameColumn);
3883 
3884         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
3885             while (c.next()) {
3886                 rt_37429_items_change_count++;
3887             }
3888         });
3889         table.getSelectionModel().getSelectedCells().addListener((ListChangeListener&lt;TreeTablePosition&lt;String, ?&gt;&gt;) c -&gt; {
3890             while (c.next()) {
3891                 rt_37429_cells_change_count++;
3892             }
3893         });
3894 
3895         StageLoader sl = new StageLoader(table);
3896 
3897         assertEquals(0, rt_37429_items_change_count);
3898         assertEquals(0, rt_37429_cells_change_count);
3899 
3900         table.getSelectionModel().select(0);
3901         assertEquals(1, rt_37429_items_change_count);
3902         assertEquals(1, rt_37429_cells_change_count);
3903 
3904         table.getSortOrder().add(nameColumn);
3905         assertEquals(1, rt_37429_items_change_count);
3906         assertEquals(1, rt_37429_cells_change_count);
3907 
3908         nameColumn.setSortType(TreeTableColumn.SortType.DESCENDING);
3909         assertEquals(1, rt_37429_items_change_count);
3910         assertEquals(2, rt_37429_cells_change_count);
3911 
3912         nameColumn.setSortType(TreeTableColumn.SortType.ASCENDING);
3913         assertEquals(1, rt_37429_items_change_count);
3914         assertEquals(3, rt_37429_cells_change_count);
3915 
3916         sl.dispose();
3917     }
3918 
3919     private int rt_37538_count = 0;
3920     @Test public void test_rt_37538_noCNextCall() {
3921         test_rt_37538(false, false);
3922     }
3923 
3924     @Test public void test_rt_37538_callCNextOnce() {
3925         test_rt_37538(true, false);
3926     }
3927 
3928     @Test public void test_rt_37538_callCNextInLoop() {
3929         test_rt_37538(false, true);
3930     }
3931 
3932     private void test_rt_37538(boolean callCNextOnce, boolean callCNextInLoop) {
3933         // create table with a bunch of rows and 1 column...
3934         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
3935         root.setExpanded(true);
3936         for (int i = 1; i &lt;= 50; i++) {
3937             root.getChildren().add(new TreeItem&lt;&gt;(i));
3938         }
3939 
3940         final TreeTableColumn&lt;Integer, Integer&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3941         column.setCellValueFactory( cdf -&gt; new ReadOnlyObjectWrapper&lt;Integer&gt;(cdf.getValue().getValue()));
3942 
3943         final TreeTableView&lt;Integer&gt; table = new TreeTableView&lt;&gt;(root);
3944         table.getColumns().add( column );
3945 
3946         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;Integer&gt;&gt; c) -&gt; {
3947             if (callCNextOnce) {
3948                 c.next();
3949             } else if (callCNextInLoop) {
3950                 while (c.next()) {
3951                     // no-op
3952                 }
3953             }
3954 
3955             if (rt_37538_count &gt;= 1) {
3956                 Thread.dumpStack();
3957                 fail(&quot;This method should only be called once&quot;);
3958             }
3959 
3960             rt_37538_count++;
3961         });
3962 
3963         StageLoader sl = new StageLoader(table);
3964         assertEquals(0, rt_37538_count);
3965         table.getSelectionModel().select(0);
3966         assertEquals(1, rt_37538_count);
3967         sl.dispose();
3968     }
3969 
3970     @Test public void test_rt_37593() {
3971         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3972 
3973         TreeItem&lt;String&gt; one = new TreeItem&lt;&gt;(&quot;one&quot;);
3974         root.getChildren().add(one);
3975 
3976         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
3977         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
3978         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
3979         root.getChildren().add(two);
3980 
3981         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
3982 
3983         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3984         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3985 
3986         treeTableView.setShowRoot(false);
3987         treeTableView.setRoot(root);
3988         treeTableView.getColumns().addAll(nameColumn);
3989 
3990         treeTableView.getSortOrder().add(nameColumn);
3991         nameColumn.setSortType(TreeTableColumn.SortType.DESCENDING);
3992         sm.select(one);
3993 
3994         // at this point, the &#39;one&#39; item should be in row 2
3995         assertTrue(sm.isSelected(2));
3996         assertEquals(one, sm.getSelectedItem());
3997 
3998         two.setExpanded(true);
3999 
4000         // we should end up with the selection being on index 4, which is the
4001         // final location of the &#39;one&#39; tree item, after sorting and expanding &#39;two&#39;
4002         assertEquals(one, sm.getSelectedItem());
4003         assertTrue(debug(), sm.isSelected(4));
4004 
4005         // this line would create a NPE
4006         VirtualFlowTestUtils.clickOnRow(treeTableView, 4, true);
4007 
4008         // The mouse click should not change selection at all
4009         assertEquals(one, sm.getSelectedItem());
4010         assertTrue(debug(), sm.isSelected(4));
4011     }
4012 
4013     @Test public void test_rt_35395_testCell_fixedCellSize() {
4014         test_rt_35395(true, true);
4015     }
4016 
4017     @Test public void test_rt_35395_testCell_notFixedCellSize() {
4018         test_rt_35395(true, false);
4019     }
4020 
4021     @Ignore(&quot;Fix not yet developed for TreeTableView&quot;)
4022     @Test public void test_rt_35395_testRow_fixedCellSize() {
4023         test_rt_35395(false, true);
4024     }
4025 
4026     @Ignore(&quot;Fix not yet developed for TreeTableView&quot;)
4027     @Test public void test_rt_35395_testRow_notFixedCellSize() {
4028         test_rt_35395(false, false);
4029     }
4030 
4031     private int rt_35395_counter;
4032     private void test_rt_35395(boolean testCell, boolean useFixedCellSize) {
4033         rt_35395_counter = 0;
4034 
4035         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;green&quot;);
4036         root.setExpanded(true);
4037         for (int i = 0; i &lt; 20; i++) {
4038             root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;red&quot;), new TreeItem&lt;&gt;(&quot;green&quot;), new TreeItem&lt;&gt;(&quot;blue&quot;), new TreeItem&lt;&gt;(&quot;purple&quot;));
4039         }
4040 
4041         TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;(root);
4042         if (useFixedCellSize) {
4043             treeTableView.setFixedCellSize(24);
4044         }
4045         treeTableView.setRowFactory(tv -&gt; new TreeTableRowShim&lt;String&gt;() {
4046             @Override public void updateItem(String color, boolean empty) {
4047                 rt_35395_counter += testCell ? 0 : 1;
4048                 super.updateItem(color, empty);
4049             }
4050         });
4051 
4052         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4053         column.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
4054         column.setCellFactory(tv -&gt; new TreeTableCellShim&lt;String,String&gt;() {
4055             @Override public void updateItem(String color, boolean empty) {
4056                 rt_35395_counter += testCell ? 1 : 0;
4057                 super.updateItem(color, empty);
4058                 setText(null);
4059                 if (empty) {
4060                     setGraphic(null);
4061                 } else {
4062                     Rectangle rect = new Rectangle(16, 16);
4063                     rect.setStyle(&quot;-fx-fill: &quot; + color);
4064                     setGraphic(rect);
4065                 }
4066             }
4067         });
4068         treeTableView.getColumns().addAll(column);
4069 
4070         StageLoader sl = new StageLoader(treeTableView);
4071 
4072         Platform.runLater(() -&gt; {
4073             rt_35395_counter = 0;
4074             root.getChildren().set(10, new TreeItem&lt;&gt;(&quot;yellow&quot;));
4075             Platform.runLater(() -&gt; {
4076                 Toolkit.getToolkit().firePulse();
4077                 assertEquals(1, rt_35395_counter);
4078                 rt_35395_counter = 0;
4079                 root.getChildren().set(30, new TreeItem&lt;&gt;(&quot;yellow&quot;));
4080                 Platform.runLater(() -&gt; {
4081                     Toolkit.getToolkit().firePulse();
4082                     assertEquals(0, rt_35395_counter);
4083                     rt_35395_counter = 0;
4084                     treeTableView.scrollTo(5);
4085                     Platform.runLater(() -&gt; {
4086                         Toolkit.getToolkit().firePulse();
4087                         assertEquals(useFixedCellSize ? 5 : 5, rt_35395_counter);
4088                         rt_35395_counter = 0;
4089                         treeTableView.scrollTo(55);
4090                         Platform.runLater(() -&gt; {
4091                             Toolkit.getToolkit().firePulse();
4092 
4093                             assertEquals(useFixedCellSize ? 7 : 59, rt_35395_counter);
4094                             sl.dispose();
4095                         });
4096                     });
4097                 });
4098             });
4099         });
4100     }
4101 
4102     @Test public void test_rt_37632() {
4103         final TreeItem&lt;String&gt; rootOne = new TreeItem&lt;&gt;(&quot;Root 1&quot;);
4104         final TreeItem&lt;String&gt; rootTwo = new TreeItem&lt;&gt;(&quot;Root 2&quot;);
4105 
4106         TreeTableColumn&lt;String,String&gt; tableColumn = new TreeTableColumn(&quot;column&quot;);
4107         tableColumn.setCellValueFactory(c -&gt; new ReadOnlyStringWrapper(c.getValue().getValue()));
4108 
4109         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;();
4110         treeTableView.getColumns().addAll(tableColumn);
4111         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeTableView.getSelectionModel();
4112         treeTableView.setRoot(rootOne);
4113         treeTableView.getSelectionModel().selectFirst();
4114 
4115         assertEquals(0, sm.getSelectedIndex());
4116         assertEquals(rootOne, sm.getSelectedItem());
4117         assertEquals(1, sm.getSelectedIndices().size());
4118         assertEquals(0, (int) sm.getSelectedIndices().get(0));
4119         assertEquals(1, sm.getSelectedItems().size());
4120         assertEquals(rootOne, sm.getSelectedItems().get(0));
4121 
4122         treeTableView.setRoot(rootTwo);
4123 
4124         assertEquals(-1, sm.getSelectedIndex());
4125         assertNull(sm.getSelectedItem());
4126         assertEquals(0, sm.getSelectedIndices().size());
4127         assertEquals(0, sm.getSelectedItems().size());
4128     }
4129 
4130     private TreeTableView&lt;Person&gt; test_rt_38464_createControl() {
4131         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
4132                 new TreeItem&lt;&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
4133                 new TreeItem&lt;&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
4134                 new TreeItem&lt;&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
4135                 new TreeItem&lt;&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
4136                 new TreeItem&lt;&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
4137 
4138         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
4139         table.setShowRoot(false);
4140 
4141         TreeItem&lt;Person&gt; root = new TreeItem&lt;&gt;(new Person(&quot;Root&quot;, null, null));
4142         root.setExpanded(true);
4143         root.getChildren().setAll(persons);
4144         table.setRoot(root);
4145 
4146 
4147 
4148         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
4149         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
4150 
4151         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
4152         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
4153 
4154         table.getColumns().addAll(firstNameCol, lastNameCol);
4155 
4156         return table;
4157     }
4158 
4159     @Test public void test_rt_38464_rowSelection_selectFirstRowOnly() {
4160         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4161         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4162         sm.setCellSelectionEnabled(false);
4163         sm.setSelectionMode(SelectionMode.MULTIPLE);
4164 
4165         sm.select(0);
4166 
4167         assertTrue(sm.isSelected(0));
4168         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4169         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4170 
4171         assertEquals(1, sm.getSelectedIndices().size());
4172         assertEquals(1, sm.getSelectedItems().size());
4173         assertEquals(1, sm.getSelectedCells().size());
4174     }
4175 
4176     @Test public void test_rt_38464_rowSelection_selectFirstRowAndThenCallNoOpMethods() {
4177         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4178         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4179         sm.setCellSelectionEnabled(false);
4180         sm.setSelectionMode(SelectionMode.MULTIPLE);
4181 
4182         sm.select(0);               // select first row
4183         sm.select(0);               // this should be a no-op
4184         sm.select(0, table.getColumns().get(0)); // so should this, as we are in row selection mode
4185         sm.select(0, table.getColumns().get(1));  // and same here
4186 
4187         assertTrue(sm.isSelected(0));
4188         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4189         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4190 
4191         assertEquals(1, sm.getSelectedIndices().size());
4192         assertEquals(1, sm.getSelectedItems().size());
4193         assertEquals(1, sm.getSelectedCells().size());
4194     }
4195 
4196 
4197     @Test public void test_rt_38464_cellSelection_selectFirstRowOnly() {
4198         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4199         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4200         sm.setCellSelectionEnabled(true);
4201         sm.setSelectionMode(SelectionMode.MULTIPLE);
4202 
4203         // select first row. This should be translated into selection of all
4204         // cells in this row, and (as of JDK 9) _does_ result in the row itself being
4205         // considered selected.
4206         sm.select(0);
4207 
4208         assertTrue(sm.isSelected(0));
4209         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4210         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4211 
4212         assertEquals(1, sm.getSelectedIndices().size());
4213         assertEquals(1, sm.getSelectedItems().size());
4214         assertEquals(2, sm.getSelectedCells().size());
4215     }
4216 
4217     @Test public void test_rt_38464_cellSelection_selectFirstRowAndThenCallNoOpMethods() {
4218         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4219         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4220         sm.setCellSelectionEnabled(true);
4221         sm.setSelectionMode(SelectionMode.MULTIPLE);
4222 
4223         // select first row. This should be translated into selection of all
4224         // cells in this row, and (as of JDK 9) _does_ result in the row itself being
4225         // considered selected.
4226         sm.select(0);                            // select first row
4227         sm.select(0, table.getColumns().get(0)); // This line and the next should be no-ops
4228         sm.select(0, table.getColumns().get(1));
4229 
4230         assertTrue(sm.isSelected(0));
4231         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4232         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4233 
4234         assertEquals(1, sm.getSelectedIndices().size());
4235         assertEquals(1, sm.getSelectedItems().size());
4236         assertEquals(2, sm.getSelectedCells().size());
4237     }
4238 
4239     @Test public void test_rt38464_selectCellMultipleTimes() {
4240         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4241         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4242         sm.setCellSelectionEnabled(true);
4243         sm.setSelectionMode(SelectionMode.MULTIPLE);
4244 
4245         // default selection when in cell selection mode
4246         assertEquals(0, sm.getSelectedCells().size());
4247         assertEquals(0, sm.getSelectedItems().size());
4248         assertEquals(0, sm.getSelectedIndices().size());
4249 
4250         // select the first cell
4251         sm.select(0, table.getColumns().get(0));
4252         assertEquals(1, sm.getSelectedCells().size());
4253         assertEquals(1, sm.getSelectedItems().size());
4254         assertEquals(1, sm.getSelectedIndices().size());
4255 
4256         // select the first cell....again
4257         sm.select(0, table.getColumns().get(0));
4258         assertEquals(1, sm.getSelectedCells().size());
4259         assertEquals(1, sm.getSelectedItems().size());
4260         assertEquals(1, sm.getSelectedIndices().size());
4261     }
4262 
4263     @Test public void test_rt38464_selectCellThenRow() {
4264         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4265         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4266         sm.setCellSelectionEnabled(true);
4267         sm.setSelectionMode(SelectionMode.MULTIPLE);
4268 
4269         // default selection when in cell selection mode
4270         assertEquals(0, sm.getSelectedCells().size());
4271         assertEquals(0, sm.getSelectedItems().size());
4272         assertEquals(0, sm.getSelectedIndices().size());
4273 
4274         // select the first cell
4275         sm.select(0, table.getColumns().get(0));
4276         assertEquals(1, sm.getSelectedCells().size());
4277         assertEquals(1, sm.getSelectedItems().size());
4278         assertEquals(1, sm.getSelectedIndices().size());
4279 
4280         // select the first row
4281         sm.select(0);
4282 
4283         // we go to 2 here as all cells in the row become selected. What we do
4284         // not expect is to go to 3, as that would mean duplication
4285         assertEquals(2, sm.getSelectedCells().size());
4286         assertEquals(1, sm.getSelectedItems().size());
4287         assertEquals(1, sm.getSelectedIndices().size());
4288     }
4289 
4290     @Test public void test_rt38464_selectRowThenCell() {
4291         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4292         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4293         sm.setCellSelectionEnabled(true);
4294         sm.setSelectionMode(SelectionMode.MULTIPLE);
4295 
4296         // default selection when in cell selection mode
4297         assertEquals(0, sm.getSelectedCells().size());
4298         assertEquals(0, sm.getSelectedItems().size());
4299         assertEquals(0, sm.getSelectedIndices().size());
4300 
4301         // select the first row
4302         sm.select(0);
4303 
4304         // we go to 2 here as all cells in the row become selected.
4305         assertEquals(2, sm.getSelectedCells().size());
4306         assertEquals(1, sm.getSelectedItems().size());
4307         assertEquals(1, sm.getSelectedIndices().size());
4308 
4309         // select the first cell - no change is expected
4310         sm.select(0, table.getColumns().get(0));
4311         assertEquals(2, sm.getSelectedCells().size());
4312         assertEquals(1, sm.getSelectedItems().size());
4313         assertEquals(1, sm.getSelectedIndices().size());
4314     }
4315 
4316     @Test public void test_rt38464_selectTests_cellSelection_singleSelection_selectsOneRow() {
4317         test_rt38464_selectTests(true, true, true);
4318     }
4319 
4320     @Test public void test_rt38464_selectTests_cellSelection_singleSelection_selectsTwoRows() {
4321         test_rt38464_selectTests(true, true, false);
4322     }
4323 
4324     @Test public void test_rt38464_selectTests_cellSelection_multipleSelection_selectsOneRow() {
4325         test_rt38464_selectTests(true, false, true);
4326     }
4327 
4328     @Test public void test_rt38464_selectTests_cellSelection_multipleSelection_selectsTwoRows() {
4329         test_rt38464_selectTests(true, false, false);
4330     }
4331 
4332     @Test public void test_rt38464_selectTests_rowSelection_singleSelection_selectsOneRow() {
4333         test_rt38464_selectTests(false, true, true);
4334     }
4335 
4336     @Test public void test_rt38464_selectTests_rowSelection_singleSelection_selectsTwoRows() {
4337         test_rt38464_selectTests(false, true, false);
4338     }
4339 
4340     @Test public void test_rt38464_selectTests_rowSelection_multipleSelection_selectsOneRow() {
4341         test_rt38464_selectTests(false, false, true);
4342     }
4343 
4344     @Test public void test_rt38464_selectTests_rowSelection_multipleSelection_selectsTwoRows() {
4345         test_rt38464_selectTests(false, false, false);
4346     }
4347 
4348     private void test_rt38464_selectTests(boolean cellSelection, boolean singleSelection, boolean selectsOneRow) {
4349         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4350         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4351         sm.setCellSelectionEnabled(cellSelection);
4352         sm.setSelectionMode(singleSelection ? SelectionMode.SINGLE : SelectionMode.MULTIPLE);
4353 
4354         // default selection when in cell selection mode
4355         assertEquals(0, sm.getSelectedCells().size());
4356         assertEquals(0, sm.getSelectedItems().size());
4357         assertEquals(0, sm.getSelectedIndices().size());
4358 
4359         if (selectsOneRow) {
4360             sm.select(0);
4361         } else {
4362             // select the first two rows
4363             sm.selectIndices(0, 1);
4364         }
4365 
4366         final int expectedCells = singleSelection                    ? 1 :
4367                                   selectsOneRow   &amp;&amp; cellSelection   ? 2 :
4368                                   selectsOneRow   &amp;&amp; !cellSelection  ? 1 :
4369                                   !selectsOneRow  &amp;&amp; cellSelection   ? 4 :
4370                                /* !selectsOneRow  &amp;&amp; !cellSelection */ 2;
4371 
4372         final int expectedItems = singleSelection ? 1 :
4373                 selectsOneRow   ? 1 : 2;
4374 
4375         assertEquals(expectedCells, sm.getSelectedCells().size());
4376         assertEquals(expectedItems, sm.getSelectedItems().size());
4377         assertEquals(expectedItems, sm.getSelectedIndices().size());
4378 
4379         // we expect the table column of all selected cells, in this instance,
4380         // to be null as we have not explicitly stated a column, nor have we clicked
4381         // on a column. The only alternative is to use the first column.
4382         for (TreeTablePosition&lt;?,?&gt; tp : sm.getSelectedCells()) {
4383             if (cellSelection) {
4384                 assertNotNull(tp.getTableColumn());
4385             } else {
4386                 assertNull(tp.getTableColumn());
4387             }
4388         }
4389     }
4390 
4391     @Test public void test_rt_37853_replaceRoot() {
4392         test_rt_37853(true);
4393     }
4394 
4395     @Test public void test_rt_37853_replaceRootChildren() {
4396         test_rt_37853(false);
4397     }
4398 
4399     private int rt_37853_cancelCount;
4400     private int rt_37853_commitCount;
4401     public void test_rt_37853(boolean replaceRoot) {
4402         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;&gt;(&quot;first&quot;);
4403         first.setEditable(true);
4404         first.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
4405         treeTableView.getColumns().add(first);
4406         treeTableView.setEditable(true);
4407         treeTableView.setRoot(new TreeItem&lt;&gt;(&quot;Root&quot;));
4408         treeTableView.getRoot().setExpanded(true);
4409 
4410         for (int i = 0; i &lt; 10; i++) {
4411             treeTableView.getRoot().getChildren().add(new TreeItem&lt;&gt;(&quot;&quot; + i));
4412         }
4413 
4414         StageLoader sl = new StageLoader(treeTableView);
4415 
4416         first.setOnEditCancel(editEvent -&gt; rt_37853_cancelCount++);
4417         first.setOnEditCommit(editEvent -&gt; rt_37853_commitCount++);
4418 
4419         assertEquals(0, rt_37853_cancelCount);
4420         assertEquals(0, rt_37853_commitCount);
4421 
4422         treeTableView.edit(1, first);
4423         assertNotNull(treeTableView.getEditingCell());
4424 
4425         if (replaceRoot) {
4426             treeTableView.setRoot(new TreeItem&lt;&gt;(&quot;New Root&quot;));
4427         } else {
4428             treeTableView.getRoot().getChildren().clear();
4429             for (int i = 0; i &lt; 10; i++) {
4430                 treeTableView.getRoot().getChildren().add(new TreeItem&lt;&gt;(&quot;new item &quot; + i));
4431             }
4432         }
4433         assertEquals(1, rt_37853_cancelCount);
4434         assertEquals(0, rt_37853_commitCount);
4435 
4436         sl.dispose();
4437     }
4438 
4439 
4440     /**************************************************************************
4441      *
4442      * Tests (and related code) for RT-38892
4443      *
4444      *************************************************************************/
4445 
4446     private final Supplier&lt;TreeTableColumn&lt;Person,String&gt;&gt; columnCallable = () -&gt; {
4447         TreeTableColumn&lt;Person,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Last Name&quot;);
4448         column.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person,String&gt;(&quot;lastName&quot;));
4449         return column;
4450     };
4451 
4452     private TreeTableColumn&lt;Person, String&gt; test_rt_38892_firstNameCol;
4453     private TreeTableColumn&lt;Person, String&gt; test_rt_38892_lastNameCol;
4454 
4455     private TreeTableView&lt;Person&gt; init_test_rt_38892() {
4456         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
4457                 new TreeItem&lt;&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
4458                 new TreeItem&lt;&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
4459                 new TreeItem&lt;&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
4460                 new TreeItem&lt;&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
4461                 new TreeItem&lt;&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
4462 
4463         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
4464         table.setShowRoot(false);
4465         table.getSelectionModel().setCellSelectionEnabled(true);
4466         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
4467 
4468         TreeItem&lt;Person&gt; root = new TreeItem&lt;&gt;(new Person(&quot;Root&quot;, null, null));
4469         root.setExpanded(true);
4470         root.getChildren().setAll(persons);
4471         table.setRoot(root);
4472 
4473         test_rt_38892_firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
4474         test_rt_38892_firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(&quot;firstName&quot;));
4475         test_rt_38892_lastNameCol = columnCallable.get();
4476         table.getColumns().addAll(test_rt_38892_firstNameCol, test_rt_38892_lastNameCol);
4477 
4478         return table;
4479     }
4480 
4481     @Test public void test_rt_38892_focusMovesToLeftWhenPossible() {
4482         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4483 
4484         TreeTableView.TreeTableViewFocusModel&lt;Person&gt; fm = table.getFocusModel();
4485         fm.focus(0, test_rt_38892_lastNameCol);
4486 
4487         // assert pre-conditions
4488         assertEquals(0, fm.getFocusedIndex());
4489         assertEquals(0, fm.getFocusedCell().getRow());
4490         assertEquals(test_rt_38892_lastNameCol, fm.getFocusedCell().getTableColumn());
4491         assertEquals(1, fm.getFocusedCell().getColumn());
4492 
4493         // now remove column where focus is and replace it with a new column.
4494         // We expect focus to move to the left one cell.
4495         table.getColumns().remove(1);
4496         table.getColumns().add(columnCallable.get());
4497 
4498         assertEquals(0, fm.getFocusedIndex());
4499         assertEquals(0, fm.getFocusedCell().getRow());
4500         assertEquals(test_rt_38892_firstNameCol, fm.getFocusedCell().getTableColumn());
4501         assertEquals(0, fm.getFocusedCell().getColumn());
4502     }
4503 
4504     @Test public void test_rt_38892_removeLeftMostColumn() {
4505         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4506 
4507         TreeTableView.TreeTableViewFocusModel&lt;Person&gt; fm = table.getFocusModel();
4508         fm.focus(0, test_rt_38892_firstNameCol);
4509 
4510         // assert pre-conditions
4511         assertEquals(0, fm.getFocusedIndex());
4512         assertEquals(0, fm.getFocusedCell().getRow());
4513         assertEquals(test_rt_38892_firstNameCol, fm.getFocusedCell().getTableColumn());
4514         assertEquals(0, fm.getFocusedCell().getColumn());
4515 
4516         // now remove column where focus is and replace it with a new column.
4517         // In the current (non-specified) behavior, this results in focus being
4518         // shifted to a cell in the remaining column, even when we add a new column
4519         // as we index based on the column, not on its index.
4520         table.getColumns().remove(0);
4521         TreeTableColumn&lt;Person,String&gt; newColumn = columnCallable.get();
4522         table.getColumns().add(0, newColumn);
4523 
4524         assertEquals(0, fm.getFocusedIndex());
4525         assertEquals(0, fm.getFocusedCell().getRow());
4526         assertEquals(test_rt_38892_lastNameCol, fm.getFocusedCell().getTableColumn());
4527         assertEquals(0, fm.getFocusedCell().getColumn());
4528     }
4529 
4530     @Test public void test_rt_38892_removeSelectionFromCellsInRemovedColumn() {
4531         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4532 
4533         TreeTableView.TreeTableViewSelectionModel sm = table.getSelectionModel();
4534         sm.select(0, test_rt_38892_firstNameCol);
4535         sm.select(1, test_rt_38892_lastNameCol);    // this should go
4536         sm.select(2, test_rt_38892_firstNameCol);
4537         sm.select(3, test_rt_38892_lastNameCol);    // so should this
4538         sm.select(4, test_rt_38892_firstNameCol);
4539 
4540         assertEquals(5, sm.getSelectedCells().size());
4541 
4542         table.getColumns().remove(1);
4543 
4544         assertEquals(3, sm.getSelectedCells().size());
4545         assertTrue(sm.isSelected(0, test_rt_38892_firstNameCol));
4546         assertFalse(sm.isSelected(1, test_rt_38892_lastNameCol));
4547         assertTrue(sm.isSelected(2, test_rt_38892_firstNameCol));
4548         assertFalse(sm.isSelected(3, test_rt_38892_lastNameCol));
4549         assertTrue(sm.isSelected(4, test_rt_38892_firstNameCol));
4550     }
4551 
4552     @Test public void test_rt_38787_remove_b() {
4553         // Remove &#39;b&#39;, selection moves to &#39;a&#39;
4554         test_rt_38787(&quot;a&quot;, 0, 1);
4555     }
4556 
4557     @Test public void test_rt_38787_remove_b_c() {
4558         // Remove &#39;b&#39; and &#39;c&#39;, selection moves to &#39;a&#39;
4559         test_rt_38787(&quot;a&quot;, 0, 1, 2);
4560     }
4561 
4562     @Test public void test_rt_38787_remove_c_d() {
4563         // Remove &#39;c&#39; and &#39;d&#39;, selection moves to &#39;b&#39;
4564         test_rt_38787(&quot;b&quot;, 1, 2, 3);
4565     }
4566 
4567     @Test public void test_rt_38787_remove_a() {
4568         // Remove &#39;a&#39;, selection moves to &#39;b&#39;, now in index 0
4569         test_rt_38787(&quot;b&quot;, 0, 0);
4570     }
4571 
4572     private void test_rt_38787(String expectedItem, int expectedIndex, int... indicesToRemove) {
4573         TreeItem&lt;String&gt; a, b, c, d;
4574         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4575         root.setExpanded(true);
4576         root.getChildren().addAll(
4577                 a = new TreeItem&lt;String&gt;(&quot;a&quot;),
4578                 b = new TreeItem&lt;String&gt;(&quot;b&quot;),
4579                 c = new TreeItem&lt;String&gt;(&quot;c&quot;),
4580                 d = new TreeItem&lt;String&gt;(&quot;d&quot;)
4581         );
4582 
4583         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4584         stringTreeTableView.setShowRoot(false);
4585 
4586         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4587         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4588         stringTreeTableView.getColumns().add(column);
4589 
4590         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4591         sm.select(b);
4592 
4593         // test pre-conditions
4594         assertEquals(1, sm.getSelectedIndex());
4595         assertEquals(1, (int)sm.getSelectedIndices().get(0));
4596         assertEquals(b, sm.getSelectedItem());
4597         assertEquals(b, sm.getSelectedItems().get(0));
4598         assertFalse(sm.isSelected(0));
4599         assertTrue(sm.isSelected(1));
4600         assertFalse(sm.isSelected(2));
4601 
4602         // removing items
4603         List&lt;TreeItem&lt;String&gt;&gt; itemsToRemove = new ArrayList&lt;&gt;(indicesToRemove.length);
4604         for (int index : indicesToRemove) {
4605             itemsToRemove.add(root.getChildren().get(index));
4606         }
4607         root.getChildren().removeAll(itemsToRemove);
4608 
4609         // testing against expectations
4610         assertEquals(expectedIndex, sm.getSelectedIndex());
4611         assertEquals(expectedIndex, (int)sm.getSelectedIndices().get(0));
4612         assertEquals(expectedItem, sm.getSelectedItem().getValue());
4613         assertEquals(expectedItem, sm.getSelectedItems().get(0).getValue());
4614     }
4615 
4616     private int rt_38341_indices_count = 0;
4617     private int rt_38341_items_count = 0;
4618     @Test public void test_rt_38341() {
4619         Callback&lt;Integer, TreeItem&lt;String&gt;&gt; callback = number -&gt; {
4620             final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root &quot; + number);
4621             final TreeItem&lt;String&gt; child = new TreeItem&lt;&gt;(&quot;Child &quot; + number);
4622 
4623             root.getChildren().add(child);
4624             return root;
4625         };
4626 
4627         final TreeItem&lt;String&gt; root = new TreeItem&lt;String&gt;();
4628         root.setExpanded(true);
4629         root.getChildren().addAll(callback.call(1), callback.call(2));
4630 
4631         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;(root);
4632         treeTableView.setShowRoot(false);
4633 
4634         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4635         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4636         treeTableView.getColumns().add(column);
4637 
4638         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeTableView.getSelectionModel();
4639         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) c -&gt; rt_38341_indices_count++);
4640         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; rt_38341_items_count++);
4641 
4642         assertEquals(0, rt_38341_indices_count);
4643         assertEquals(0, rt_38341_items_count);
4644 
4645         // expand the first child of root, and select it (note: root isn&#39;t visible)
4646         root.getChildren().get(0).setExpanded(true);
4647         sm.select(1);
4648         assertEquals(1, sm.getSelectedIndex());
4649         assertEquals(1, sm.getSelectedIndices().size());
4650         assertEquals(1, (int)sm.getSelectedIndices().get(0));
4651         assertEquals(1, sm.getSelectedItems().size());
4652         assertEquals(&quot;Child 1&quot;, sm.getSelectedItem().getValue());
4653         assertEquals(&quot;Child 1&quot;, sm.getSelectedItems().get(0).getValue());
4654 
4655         assertEquals(1, rt_38341_indices_count);
4656         assertEquals(1, rt_38341_items_count);
4657 
4658         // now delete it
4659         root.getChildren().get(0).getChildren().remove(0);
4660 
4661         // selection should move to the childs parent in index 0
4662         assertEquals(0, sm.getSelectedIndex());
4663         assertEquals(1, sm.getSelectedIndices().size());
4664         assertEquals(0, (int)sm.getSelectedIndices().get(0));
4665         assertEquals(1, sm.getSelectedItems().size());
4666         assertEquals(&quot;Root 1&quot;, sm.getSelectedItem().getValue());
4667         assertEquals(&quot;Root 1&quot;, sm.getSelectedItems().get(0).getValue());
4668 
4669         // we also expect there to be an event in the selection model for
4670         // selected indices and selected items
4671         assertEquals(2, rt_38341_indices_count);
4672         assertEquals(2, rt_38341_items_count);
4673     }
4674 
4675     private int rt_38943_index_count = 0;
4676     private int rt_38943_item_count = 0;
4677     @Test public void test_rt_38943() {
4678         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4679         root.setExpanded(true);
4680         root.getChildren().addAll(
4681             new TreeItem&lt;&gt;(&quot;a&quot;),
4682             new TreeItem&lt;&gt;(&quot;b&quot;),
4683             new TreeItem&lt;&gt;(&quot;c&quot;),
4684             new TreeItem&lt;&gt;(&quot;d&quot;)
4685         );
4686 
4687         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4688         stringTreeTableView.setShowRoot(false);
4689 
4690         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4691         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4692         stringTreeTableView.getColumns().add(column);
4693 
4694         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4695 
4696         sm.selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_index_count++);
4697         sm.selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_item_count++);
4698 
4699         assertEquals(-1, sm.getSelectedIndex());
4700         assertNull(sm.getSelectedItem());
4701         assertEquals(0, rt_38943_index_count);
4702         assertEquals(0, rt_38943_item_count);
4703 
4704         sm.select(0);
4705         assertEquals(0, sm.getSelectedIndex());
4706         assertEquals(&quot;a&quot;, sm.getSelectedItem().getValue());
4707         assertEquals(1, rt_38943_index_count);
4708         assertEquals(1, rt_38943_item_count);
4709 
4710         sm.clearSelection(0);
4711         assertEquals(-1, sm.getSelectedIndex());
4712         assertNull(sm.getSelectedItem());
4713         assertEquals(2, rt_38943_index_count);
4714         assertEquals(2, rt_38943_item_count);
4715     }
4716 
4717     @Test public void test_rt_38884() {
4718         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4719         final TreeItem&lt;String&gt; foo = new TreeItem&lt;&gt;(&quot;foo&quot;);
4720 
4721         TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
4722         treeView.setShowRoot(false);
4723         root.setExpanded(true);
4724 
4725         treeView.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;String&gt;&gt; c) -&gt; {
4726             while (c.next()) {
4727                 if (c.wasRemoved()) {
4728                     assertTrue(c.getRemovedSize() &gt; 0);
4729 
4730                     List&lt;? extends TreeItem&lt;String&gt;&gt; removed = c.getRemoved();
4731                     TreeItem&lt;String&gt; removedItem = null;
4732                     try {
4733                         removedItem = removed.get(0);
4734                     } catch (Exception e) {
4735                         fail();
4736                     }
4737 
4738                     assertEquals(foo, removedItem);
4739                 }
4740             }
4741         });
4742 
4743         root.getChildren().add(foo);
4744         treeView.getSelectionModel().select(0);
4745         root.getChildren().clear();
4746     }
4747 
4748     private int rt_37360_add_count = 0;
4749     private int rt_37360_remove_count = 0;
4750     @Test public void test_rt_37360() {
4751         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4752         root.setExpanded(true);
4753         root.getChildren().addAll(
4754                 new TreeItem&lt;&gt;(&quot;a&quot;),
4755                 new TreeItem&lt;&gt;(&quot;b&quot;)
4756         );
4757 
4758         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4759         stringTreeTableView.setShowRoot(false);
4760 
4761         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4762         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4763         stringTreeTableView.getColumns().add(column);
4764 
4765         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4766         sm.setSelectionMode(SelectionMode.MULTIPLE);
4767         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
4768             while (c.next()) {
4769                 if (c.wasAdded()) {
4770                     rt_37360_add_count += c.getAddedSize();
4771                 }
4772                 if (c.wasRemoved()) {
4773                     rt_37360_remove_count += c.getRemovedSize();
4774                 }
4775             }
4776         });
4777 
4778         assertEquals(0, sm.getSelectedItems().size());
4779         assertEquals(0, rt_37360_add_count);
4780         assertEquals(0, rt_37360_remove_count);
4781 
4782         sm.select(0);
4783         assertEquals(1, sm.getSelectedItems().size());
4784         assertEquals(1, rt_37360_add_count);
4785         assertEquals(0, rt_37360_remove_count);
4786 
4787         sm.select(1);
4788         assertEquals(2, sm.getSelectedItems().size());
4789         assertEquals(2, rt_37360_add_count);
4790         assertEquals(0, rt_37360_remove_count);
4791 
4792         sm.clearAndSelect(1);
4793         assertEquals(1, sm.getSelectedItems().size());
4794         assertEquals(2, rt_37360_add_count);
4795         assertEquals(1, rt_37360_remove_count);
4796     }
4797 
4798     private int rt_37366_count = 0;
4799     @Test public void test_rt_37366() {
4800         final TreeItem&lt;String&gt; treeItem2 = new TreeItem&lt;&gt;(&quot;Item 2&quot;);
4801         treeItem2.getChildren().addAll(new TreeItem&lt;&gt;(&quot;Item 21&quot;), new TreeItem&lt;&gt;(&quot;Item 22&quot;));
4802 
4803         final TreeItem&lt;String&gt; root1 = new TreeItem&lt;&gt;(&quot;Root Node 1&quot;);
4804         TreeItem&lt;String&gt; treeItem1 = new TreeItem&lt;&gt;(&quot;Item 1&quot;);
4805         root1.getChildren().addAll(treeItem1, treeItem2, new TreeItem&lt;&gt;(&quot;Item 3&quot;));
4806         root1.setExpanded(true);
4807 
4808         final TreeItem&lt;String&gt; root2 = new TreeItem&lt;&gt;(&quot;Root Node 2&quot;);
4809 
4810         final TreeItem&lt;String&gt; hiddenRoot = new TreeItem&lt;&gt;(&quot;Hidden Root Node&quot;);
4811         hiddenRoot.getChildren().add(root1);
4812         hiddenRoot.getChildren().add(root2);
4813 
4814         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(hiddenRoot);
4815         treeView.setShowRoot(false);
4816 
4817         AtomicInteger step = new AtomicInteger();
4818         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeView.getSelectionModel();
4819         sm.setSelectionMode(SelectionMode.MULTIPLE);
4820         sm.getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;String&gt;&gt; c) -&gt; {
4821             switch (step.get()) {
4822                 case 0: {
4823                     // we expect treeItem1 to be the only item added
4824                     while (c.next()) {
4825                         assertFalse(c.wasRemoved());
4826                         assertTrue(c.wasAdded());
4827                         assertEquals(1, c.getAddedSize());
4828                         assertTrue(c.getAddedSubList().contains(treeItem1));
4829                     }
4830                     break;
4831                 }
4832                 case 1: {
4833                     // we expect treeItem2 to be the only item added
4834                     while (c.next()) {
4835                         assertFalse(c.wasRemoved());
4836                         assertTrue(c.wasAdded());
4837                         assertEquals(1, c.getAddedSize());
4838                         assertTrue(c.getAddedSubList().contains(treeItem2));
4839                     }
4840                     break;
4841                 }
4842                 case 2: {
4843                     // we expect treeItem1 and treeItem2 to be removed in one separate event,
4844                     // and then we expect a separate event for root1 to be added. Therefore,
4845                     // once the remove event is received, we will increment the step to test for
4846                     // the addition
4847                     boolean wasRemoved = false;
4848                     while (c.next()) {
4849                         if (c.wasAdded()) {
4850                             fail(&quot;no addition expected yet&quot;);
4851                         }
4852                         if (c.wasRemoved()) {
4853                             assertTrue(c.getRemoved().containsAll(FXCollections.observableArrayList(treeItem1, treeItem2)));
4854                             wasRemoved = true;
4855                         }
4856                     }
4857                     if (!wasRemoved) {
4858                         fail(&quot;Expected a remove operation&quot;);
4859                     }
4860                     step.incrementAndGet();
4861                     break;
4862                 }
4863                 case 3: {
4864                     boolean wasAdded = false;
4865                     while (c.next()) {
4866                         if (c.wasAdded()) {
4867                             assertEquals(1, c.getAddedSize());
4868                             assertTrue(c.getAddedSubList().contains(root1));
4869                             wasAdded = true;
4870                         }
4871                         if (c.wasRemoved()) {
4872                             fail(&quot;no removal expected now&quot;);
4873                         }
4874                     }
4875                     if (!wasAdded) {
4876                         fail(&quot;Expected an add operation&quot;);
4877                     }
4878                     break;
4879                 }
4880             }
4881             rt_37366_count++;
4882         });
4883 
4884         assertEquals(0, rt_37366_count);
4885 
4886         step.set(0);
4887         sm.select(1); // select &quot;Item 1&quot;
4888         assertEquals(1, rt_37366_count);
4889         assertFalse(sm.isSelected(0));
4890         assertTrue(sm.isSelected(1));
4891         assertFalse(sm.isSelected(2));
4892 
4893         step.set(1);
4894         sm.select(2); // select &quot;Item 2&quot;
4895         assertEquals(2, rt_37366_count);
4896         assertFalse(sm.isSelected(0));
4897         assertTrue(sm.isSelected(1));
4898         assertTrue(sm.isSelected(2));
4899 
4900         step.set(2);
4901         root1.setExpanded(false); // collapse &quot;Root Node 1&quot; and deselect the two children, moving selection up to &quot;Root Node 1&quot;
4902         assertEquals(4, rt_37366_count);
4903         assertTrue(sm.isSelected(0));
4904         assertFalse(sm.isSelected(1));
4905         assertFalse(sm.isSelected(2));
4906     }
4907 
4908     @Test public void test_rt_38491() {
4909         TreeItem&lt;String&gt; a;
4910         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4911         root.setExpanded(true);
4912         root.getChildren().addAll(
4913                 a = new TreeItem&lt;&gt;(&quot;a&quot;),
4914                 new TreeItem&lt;&gt;(&quot;b&quot;)
4915         );
4916 
4917         TreeTableView&lt;String&gt; stringTreeView = new TreeTableView&lt;&gt;(root);
4918         stringTreeView.setShowRoot(false);
4919 
4920         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4921         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4922         stringTreeView.getColumns().add(column);
4923 
4924         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeView.getSelectionModel();
4925         sm.setSelectionMode(SelectionMode.MULTIPLE);
4926 
4927         TreeTableViewFocusModel&lt;String&gt; fm = stringTreeView.getFocusModel();
4928 
4929         StageLoader sl = new StageLoader(stringTreeView);
4930 
4931         // test pre-conditions
4932         assertTrue(sm.isEmpty());
4933         assertEquals(a, fm.getFocusedItem());
4934         assertEquals(0, fm.getFocusedIndex());
4935 
4936         // click on row 0
4937 //        VirtualFlowTestUtils.clickOnRow(stringTreeView, 0);
4938         sm.select(0, column);
4939         assertTrue(sm.isSelected(0));
4940         assertEquals(a, sm.getSelectedItem());
4941         assertTrue(fm.isFocused(0));
4942         assertEquals(a, fm.getFocusedItem());
4943         assertEquals(0, fm.getFocusedIndex());
4944         assertEquals(0, fm.getFocusedCell().getRow());
4945         assertEquals(column, fm.getFocusedCell().getTableColumn());
4946 
4947         TreeTablePosition&lt;String, ?&gt; anchor = TreeTableCellBehavior.getAnchor(stringTreeView, null);
4948         assertNotNull(anchor);
4949         assertTrue(TreeTableCellBehavior.hasNonDefaultAnchor(stringTreeView));
4950         assertEquals(0, anchor.getRow());
4951 
4952         // now add a new item at row 0. This has the effect of pushing down
4953         // the selected item into row 1.
4954         root.getChildren().add(0, new TreeItem(&quot;z&quot;));
4955 
4956         // The first bug was that selection and focus were not moving down to
4957         // be on row 1, so we test that now
4958         assertFalse(sm.isSelected(0));
4959         assertFalse(fm.isFocused(0));
4960         assertTrue(sm.isSelected(1));
4961         assertEquals(a, sm.getSelectedItem());
4962         assertTrue(fm.isFocused(1));
4963         assertEquals(a, fm.getFocusedItem());
4964         assertEquals(1, fm.getFocusedIndex());
4965         assertEquals(1, fm.getFocusedCell().getRow());
4966         assertEquals(column, fm.getFocusedCell().getTableColumn());
4967 
4968         // The second bug was that the anchor was not being pushed down as well
4969         // (when it should).
4970         anchor = TreeTableCellBehavior.getAnchor(stringTreeView, null);
4971         assertNotNull(anchor);
4972         assertTrue(TreeTableCellBehavior.hasNonDefaultAnchor(stringTreeView));
4973         assertEquals(1, anchor.getRow());
4974         assertEquals(column, anchor.getTableColumn());
4975 
4976         sl.dispose();
4977     }
4978 
4979     private final ObservableList&lt;TreeItem&lt;String&gt;&gt; rt_39256_list = FXCollections.observableArrayList();
4980     @Test public void test_rt_39256() {
4981         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4982         root.setExpanded(true);
4983         root.getChildren().addAll(
4984                 new TreeItem&lt;&gt;(&quot;a&quot;),
4985                 new TreeItem&lt;&gt;(&quot;b&quot;),
4986                 new TreeItem&lt;&gt;(&quot;c&quot;),
4987                 new TreeItem&lt;&gt;(&quot;d&quot;)
4988         );
4989 
4990         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4991         stringTreeTableView.setShowRoot(false);
4992 
4993         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4994         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4995         stringTreeTableView.getColumns().add(column);
4996 
4997         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4998         sm.setSelectionMode(SelectionMode.MULTIPLE);
4999 
5000 //        rt_39256_list.addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) change -&gt; {
5001 //            while (change.next()) {
5002 //                System.err.println(&quot;number of selected persons (in bound list): &quot; + change.getList().size());
5003 //            }
5004 //        });
5005 
5006         Bindings.bindContent(rt_39256_list, sm.getSelectedItems());
5007 
5008         assertEquals(0, sm.getSelectedItems().size());
5009         assertEquals(0, rt_39256_list.size());
5010 
5011         sm.selectAll();
5012         assertEquals(4, sm.getSelectedItems().size());
5013         assertEquals(4, rt_39256_list.size());
5014 
5015         sm.selectAll();
5016         assertEquals(4, sm.getSelectedItems().size());
5017         assertEquals(4, rt_39256_list.size());
5018 
5019         sm.selectAll();
5020         assertEquals(4, sm.getSelectedItems().size());
5021         assertEquals(4, rt_39256_list.size());
5022     }
5023 
5024     private final ObservableList&lt;TreeItem&lt;String&gt;&gt; rt_39482_list = FXCollections.observableArrayList();
5025     @Test public void test_rt_39482() {
5026         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5027         root.setExpanded(true);
5028         root.getChildren().addAll(
5029                 new TreeItem&lt;&gt;(&quot;a&quot;),
5030                 new TreeItem&lt;&gt;(&quot;b&quot;),
5031                 new TreeItem&lt;&gt;(&quot;c&quot;),
5032                 new TreeItem&lt;&gt;(&quot;d&quot;)
5033         );
5034 
5035         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5036         stringTreeTableView.setShowRoot(false);
5037 
5038         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5039         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5040         stringTreeTableView.getColumns().add(column);
5041 
5042         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5043         sm.setSelectionMode(SelectionMode.MULTIPLE);
5044 
5045 //        rt_39256_list.addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) change -&gt; {
5046 //            while (change.next()) {
5047 //                System.err.println(&quot;number of selected persons (in bound list): &quot; + change.getList().size());
5048 //            }
5049 //        });
5050 
5051         Bindings.bindContent(rt_39482_list, sm.getSelectedItems());
5052 
5053         assertEquals(0, sm.getSelectedItems().size());
5054         assertEquals(0, rt_39482_list.size());
5055 
5056         test_rt_39482_selectRow(&quot;a&quot;, sm, 0, column);
5057         test_rt_39482_selectRow(&quot;b&quot;, sm, 1, column);
5058         test_rt_39482_selectRow(&quot;c&quot;, sm, 2, column);
5059         test_rt_39482_selectRow(&quot;d&quot;, sm, 3, column);
5060     }
5061 
5062     private void test_rt_39482_selectRow(String expectedString,
5063                                          TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm,
5064                                          int rowToSelect,
5065                                          TreeTableColumn&lt;String,String&gt; columnToSelect) {
5066         System.out.println(&quot;\nSelect row &quot; + rowToSelect);
5067         sm.selectAll();
5068         assertEquals(4, sm.getSelectedCells().size());
5069         assertEquals(4, sm.getSelectedIndices().size());
5070         assertEquals(4, sm.getSelectedItems().size());
5071         assertEquals(4, rt_39482_list.size());
5072 
5073         sm.clearAndSelect(rowToSelect, columnToSelect);
5074         assertEquals(1, sm.getSelectedCells().size());
5075         assertEquals(1, sm.getSelectedIndices().size());
5076         assertEquals(1, sm.getSelectedItems().size());
5077         assertEquals(expectedString, sm.getSelectedItem().getValue());
5078         assertEquals(expectedString, rt_39482_list.get(0).getValue());
5079         assertEquals(1, rt_39482_list.size());
5080     }
5081 
5082     @Test public void test_rt_39559_useSM_selectAll() {
5083         test_rt_39559(true);
5084     }
5085 
5086     @Test public void test_rt_39559_useKeyboard_selectAll() {
5087         test_rt_39559(false);
5088     }
5089 
5090     private void test_rt_39559(boolean useSMSelectAll) {
5091         TreeItem&lt;String&gt; a, b;
5092         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5093         root.setExpanded(true);
5094         root.getChildren().addAll(
5095                 a = new TreeItem&lt;&gt;(&quot;a&quot;),
5096                 b = new TreeItem&lt;&gt;(&quot;b&quot;),
5097                 new TreeItem&lt;&gt;(&quot;c&quot;),
5098                 new TreeItem&lt;&gt;(&quot;d&quot;)
5099         );
5100 
5101         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5102         stringTreeTableView.setShowRoot(false);
5103 
5104         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5105         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5106         stringTreeTableView.getColumns().add(column);
5107 
5108         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5109         sm.setSelectionMode(SelectionMode.MULTIPLE);
5110 
5111         StageLoader sl = new StageLoader(stringTreeTableView);
5112         KeyEventFirer keyboard = new KeyEventFirer(stringTreeTableView);
5113 
5114         assertEquals(0, sm.getSelectedItems().size());
5115 
5116         sm.clearAndSelect(0);
5117 
5118         if (useSMSelectAll) {
5119             sm.selectAll();
5120         } else {
5121             keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
5122         }
5123 
5124         assertEquals(4, sm.getSelectedItems().size());
5125         assertEquals(0, ((TreeTablePosition) TreeTableCellBehavior.getAnchor(stringTreeTableView, null)).getRow());
5126 
5127         keyboard.doKeyPress(KeyCode.DOWN, KeyModifier.SHIFT);
5128 
5129         assertEquals(0, ((TreeTablePosition) TreeTableCellBehavior.getAnchor(stringTreeTableView, null)).getRow());
5130         assertEquals(2, sm.getSelectedItems().size());
5131         assertEquals(a, sm.getSelectedItems().get(0));
5132         assertEquals(b, sm.getSelectedItems().get(1));
5133 
5134         sl.dispose();
5135     }
5136 
5137     @Test public void test_rt_16068_firstElement_selectAndRemoveSameRow() {
5138         // select and then remove the &#39;a&#39; item, selection and focus should both
5139         // stay at the first row, now &#39;b&#39;
5140         test_rt_16068(0, 0, 0);
5141     }
5142 
5143     @Test public void test_rt_16068_firstElement_selectRowAndRemoveLaterSibling() {
5144         // select row &#39;a&#39;, and remove row &#39;c&#39;, selection and focus should not change
5145         test_rt_16068(0, 2, 0);
5146     }
5147 
5148     @Test public void test_rt_16068_middleElement_selectAndRemoveSameRow() {
5149         // select and then remove the &#39;b&#39; item, selection and focus should both
5150         // move up one row to the &#39;a&#39; item
5151         test_rt_16068(1, 1, 0);
5152     }
5153 
5154     @Test public void test_rt_16068_middleElement_selectRowAndRemoveLaterSibling() {
5155         // select row &#39;b&#39;, and remove row &#39;c&#39;, selection and focus should not change
5156         test_rt_16068(1, 2, 1);
5157     }
5158 
5159     @Test public void test_rt_16068_middleElement_selectRowAndRemoveEarlierSibling() {
5160         // select row &#39;b&#39;, and remove row &#39;a&#39;, selection and focus should move up
5161         // one row, remaining on &#39;b&#39;
5162         test_rt_16068(1, 0, 0);
5163     }
5164 
5165     @Test public void test_rt_16068_lastElement_selectAndRemoveSameRow() {
5166         // select and then remove the &#39;d&#39; item, selection and focus should both
5167         // move up one row to the &#39;c&#39; item
5168         test_rt_16068(3, 3, 2);
5169     }
5170 
5171     @Test public void test_rt_16068_lastElement_selectRowAndRemoveEarlierSibling() {
5172         // select row &#39;d&#39;, and remove row &#39;a&#39;, selection and focus should move up
5173         // one row, remaining on &#39;d&#39;
5174         test_rt_16068(3, 0, 2);
5175     }
5176 
5177     private void test_rt_16068(int indexToSelect, int indexToRemove, int expectedIndex) {
5178         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5179         root.setExpanded(true);
5180         root.getChildren().addAll(
5181                 new TreeItem&lt;&gt;(&quot;a&quot;), // 0
5182                 new TreeItem&lt;&gt;(&quot;b&quot;), // 1
5183                 new TreeItem&lt;&gt;(&quot;c&quot;), // 2
5184                 new TreeItem&lt;&gt;(&quot;d&quot;)  // 3
5185         );
5186 
5187         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5188         stringTreeTableView.setShowRoot(false);
5189 
5190         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5191         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5192         stringTreeTableView.getColumns().add(column);
5193 
5194         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5195         FocusModel&lt;TreeItem&lt;String&gt;&gt; fm = stringTreeTableView.getFocusModel();
5196 
5197         sm.select(indexToSelect);
5198         assertEquals(indexToSelect, sm.getSelectedIndex());
5199         assertEquals(root.getChildren().get(indexToSelect).getValue(), sm.getSelectedItem().getValue());
5200         assertEquals(indexToSelect, fm.getFocusedIndex());
5201         assertEquals(root.getChildren().get(indexToSelect).getValue(), fm.getFocusedItem().getValue());
5202 
5203         root.getChildren().remove(indexToRemove);
5204         assertEquals(expectedIndex, sm.getSelectedIndex());
5205         assertEquals(root.getChildren().get(expectedIndex).getValue(), sm.getSelectedItem().getValue());
5206         assertEquals(debug(), expectedIndex, fm.getFocusedIndex());
5207         assertEquals(root.getChildren().get(expectedIndex).getValue(), fm.getFocusedItem().getValue());
5208     }
5209 
5210     @Test public void test_rt_39675() {
5211         TreeItem&lt;String&gt; b;
5212         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5213         root.setExpanded(true);
5214         root.getChildren().addAll(
5215                 new TreeItem&lt;&gt;(&quot;a&quot;),
5216                 b = new TreeItem&lt;&gt;(&quot;b&quot;),
5217                 new TreeItem&lt;&gt;(&quot;c&quot;),
5218                 new TreeItem&lt;&gt;(&quot;d&quot;)
5219         );
5220 
5221         b.setExpanded(true);
5222         b.getChildren().addAll(
5223                 new TreeItem&lt;&gt;(&quot;b1&quot;),
5224                 new TreeItem&lt;&gt;(&quot;b2&quot;),
5225                 new TreeItem&lt;&gt;(&quot;b3&quot;),
5226                 new TreeItem&lt;&gt;(&quot;b4&quot;)
5227         );
5228 
5229         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5230 
5231         TreeTableColumn&lt;String,String&gt; column0 = new TreeTableColumn&lt;&gt;(&quot;Column1&quot;);
5232         column0.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5233 
5234         TreeTableColumn&lt;String,String&gt; column1 = new TreeTableColumn&lt;&gt;(&quot;Column2&quot;);
5235         column1.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5236 
5237         TreeTableColumn&lt;String,String&gt; column2 = new TreeTableColumn&lt;&gt;(&quot;Column3&quot;);
5238         column2.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5239 
5240         stringTreeTableView.getColumns().addAll(column0, column1, column2);
5241 
5242         sm = stringTreeTableView.getSelectionModel();
5243         sm.setSelectionMode(SelectionMode.SINGLE);
5244         sm.setCellSelectionEnabled(true);
5245 
5246         StageLoader sl = new StageLoader(stringTreeTableView);
5247 
5248         assertEquals(0, sm.getSelectedItems().size());
5249 
5250         sm.clearAndSelect(4, column0);  // select &#39;b2&#39; in row 4, column 0
5251         assertTrue(sm.isSelected(4, column0));
5252         assertEquals(1, sm.getSelectedCells().size());
5253         assertEquals(&quot;b2&quot;, ((TreeItem)sm.getSelectedItem()).getValue());
5254 
5255         // collapse the &#39;b&#39; tree item, selection and focus should go to
5256         // the &#39;b&#39; tree item in row 2, column 0
5257         b.setExpanded(false);
5258         assertTrue(sm.isSelected(2, column0));
5259         assertEquals(1, sm.getSelectedCells().size());
5260         assertEquals(&quot;b&quot;, ((TreeItem)sm.getSelectedItem()).getValue());
5261 
5262         sl.dispose();
5263     }
5264 
5265 
5266     private ObservableList&lt;String&gt; test_rt_39661_setup() {
5267         ObservableList&lt;String&gt;  rawItems = FXCollections.observableArrayList(
5268                 &quot;9-item&quot;, &quot;8-item&quot;, &quot;7-item&quot;, &quot;6-item&quot;,
5269                 &quot;5-item&quot;, &quot;4-item&quot;, &quot;3-item&quot;, &quot;2-item&quot;, &quot;1-item&quot;);
5270         root = createSubTree(&quot;root&quot;, rawItems);
5271         root.setExpanded(true);
5272         treeTableView = new TreeTableView(root);
5273         return rawItems;
5274     }
5275 
5276     private TreeItem createSubTree(Object item, ObservableList&lt;String&gt; rawItems) {
5277         TreeItem child = new TreeItem(item);
5278         child.getChildren().setAll(rawItems.stream()
5279                 .map(rawItem -&gt; new TreeItem(rawItem))
5280                 .collect(Collectors.toList()));
5281         return child;
5282     }
5283 
5284     @Test public void test_rt_39661_rowLessThanExpandedItemCount() {
5285         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5286         TreeItem child = createSubTree(&quot;child&quot;, rawItems);
5287         TreeItem grandChild = (TreeItem) child.getChildren().get(rawItems.size() - 1);
5288         root.getChildren().add(child);
5289         assertTrue(&quot;row of item must be less than expandedItemCount, but was: &quot; + treeTableView.getRow(grandChild),
5290                 treeTableView.getRow(grandChild) &lt; treeTableView.getExpandedItemCount());
5291     }
5292 
5293     @Test public void test_rt_39661_rowOfGrandChildParentCollapsedUpdatedOnInsertAbove() {
5294         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5295         int grandIndex = 2;
5296         int childIndex = 3;
5297 
5298         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5299         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5300         root.getChildren().add(childIndex, child);
5301 
5302         int rowOfGrand = treeTableView.getRow(grandChild);
5303         root.getChildren().add(childIndex - 1, createSubTree(&quot;other&quot;, rawItems));
5304 
5305         assertEquals(-1, treeTableView.getRow(grandChild));
5306     }
5307 
5308     @Test public void test_rt_39661_rowOfGrandChildParentCollapsedUpdatedOnInsertAboveWithoutAccess() {
5309         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5310         int grandIndex = 2;
5311         int childIndex = 3;
5312 
5313         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5314         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5315         root.getChildren().add(childIndex, child);
5316 
5317         int rowOfGrand = 7; //treeTableView.getRow(grandChild);
5318         root.getChildren().add(childIndex, createSubTree(&quot;other&quot;, rawItems));
5319 
5320         assertEquals(-1, treeTableView.getRow(grandChild));
5321     }
5322 
5323     @Test public void test_rt_39661_rowOfGrandChildParentExpandedUpdatedOnInsertAbove() {
5324         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5325         int grandIndex = 2;
5326         int childIndex = 3;
5327         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5328         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5329         child.setExpanded(true);
5330         root.getChildren().add(childIndex, child);
5331         int rowOfGrand = treeTableView.getRow(grandChild);
5332         root.getChildren().add(childIndex -1, createSubTree(&quot;other&quot;, rawItems));
5333         assertEquals(rowOfGrand + 1, treeTableView.getRow(grandChild));
5334     }
5335 
5336     /**
5337      * Testing getRow on grandChild: compare collapsed/expanded parent.
5338      */
5339     @Test public void test_rt_39661_rowOfGrandChildDependsOnParentExpansion() {
5340         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5341         int grandIndex = 2;
5342         int childIndex = 3;
5343 
5344         TreeItem collapsedChild = createSubTree(&quot;addedChild&quot;, rawItems);
5345         TreeItem collapsedGrandChild = (TreeItem) collapsedChild.getChildren().get(grandIndex);
5346         root.getChildren().add(childIndex, collapsedChild);
5347 
5348         int collapedGrandIndex = treeTableView.getRow(collapsedGrandChild);
5349         int collapsedRowCount = treeTableView.getExpandedItemCount();
5350 
5351         // start again
5352         test_rt_39661_setup();
5353         assertEquals(collapsedRowCount - 1, treeTableView.getExpandedItemCount());
5354         TreeItem expandedChild = createSubTree(&quot;addedChild2&quot;, rawItems);
5355         TreeItem expandedGrandChild = (TreeItem) expandedChild.getChildren().get(grandIndex);
5356         expandedChild.setExpanded(true);
5357 
5358         root.getChildren().add(childIndex, expandedChild);
5359         assertNotSame(&quot;getRow must depend on expansionState &quot; + collapedGrandIndex,
5360                 collapedGrandIndex, treeTableView.getRow(expandedGrandChild));
5361     }
5362 
5363     @Test public void test_rt_39661_rowOfGrandChildInCollapsedChild() {
5364         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5365 
5366         // create a collapsed new child to insert into the root
5367         TreeItem newChild = createSubTree(&quot;added-child&quot;, rawItems);
5368         TreeItem grandChild = (TreeItem) newChild.getChildren().get(2);
5369         root.getChildren().add(6, newChild);
5370 
5371         // query the row of a grand-child
5372         int row = treeTableView.getRow(grandChild);
5373 
5374         // grandChild not visible, row coordinate in tree is not available
5375         assertEquals(&quot;grandChild not visible&quot;, -1, row);
5376 
5377         // the other way round: if we get a row, expect the item at the row be the grandChild
5378         if (row &gt; -1) {
5379             assertEquals(grandChild, treeTableView.getTreeItem(row));
5380         }
5381     }
5382 
5383     @Test public void test_rt_39661_rowOfRootChild() {
5384         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5385         int index = 2;
5386 
5387         TreeItem child = (TreeItem) root.getChildren().get(index);
5388         assertEquals(index + 1, treeTableView.getRow(child));
5389     }
5390 
5391     @Test public void test_rt_39661_expandedItemCount() {
5392         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5393         int initialRowCount = treeTableView.getExpandedItemCount();
5394         assertEquals(root.getChildren().size() + 1, initialRowCount);
5395 
5396         TreeItem collapsedChild = createSubTree(&quot;collapsed-child&quot;, rawItems);
5397         root.getChildren().add(collapsedChild);
5398         assertEquals(initialRowCount + 1, treeTableView.getExpandedItemCount());
5399 
5400         TreeItem expandedChild = createSubTree(&quot;expanded-child&quot;, rawItems);
5401         expandedChild.setExpanded(true);
5402         root.getChildren().add(0, expandedChild);
5403         assertEquals(2 * initialRowCount + 1, treeTableView.getExpandedItemCount());
5404     }
5405 
5406     private int test_rt_39822_count = 0;
5407     @Test public void test_rt_39822() {
5408         // get the current exception handler before replacing with our own,
5409         // as ListListenerHelp intercepts the exception otherwise
5410         final Thread.UncaughtExceptionHandler exceptionHandler = Thread.currentThread().getUncaughtExceptionHandler();
5411         Thread.currentThread().setUncaughtExceptionHandler((t, e) -&gt; {
5412 
5413             if (test_rt_39822_count == 0) {
5414                 test_rt_39822_count++;
5415                 if (! (e instanceof IllegalStateException)) {
5416                     e.printStackTrace();
5417                     fail(&quot;Expected IllegalStateException, instead got &quot; + e);
5418                 }
5419             } else {
5420                 // don&#39;t care
5421                 test_rt_39822_count++;
5422             }
5423         });
5424 
5425         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
5426         TreeTableColumn&lt;String, String&gt; col1 = new TreeTableColumn&lt;&gt;(&quot;Foo&quot;);
5427         table.getColumns().addAll(col1, col1);  // add column twice
5428 
5429         StageLoader sl = null;
5430         try {
5431             sl = new StageLoader(table);
5432         } finally {
5433             if (sl != null) {
5434                 sl.dispose();
5435             }
5436 
5437             // reset the exception handler
5438             Thread.currentThread().setUncaughtExceptionHandler(exceptionHandler);
5439         }
5440     }
5441 
5442     private int test_rt_39842_count = 0;
5443     @Test public void test_rt_39842_selectLeftDown() {
5444         test_rt_39842(true, false);
5445     }
5446 
5447     @Test public void test_rt_39842_selectLeftUp() {
5448         test_rt_39842(true, true);
5449     }
5450 
5451     @Test public void test_rt_39842_selectRightDown() {
5452         test_rt_39842(false, false);
5453     }
5454 
5455     @Test public void test_rt_39842_selectRightUp() {
5456         test_rt_39842(false, true);
5457     }
5458 
5459     private void test_rt_39842(boolean selectToLeft, boolean selectUpwards) {
5460         test_rt_39842_count = 0;
5461 
5462         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
5463         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
5464 
5465         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
5466         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
5467 
5468         TreeItem root = new TreeItem(&quot;root&quot;);
5469         root.getChildren().setAll(
5470                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
5471                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
5472                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
5473                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
5474                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
5475         root.setExpanded(true);
5476 
5477         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;(root);
5478         table.setShowRoot(false);
5479         table.getColumns().addAll(firstNameCol, lastNameCol);
5480 
5481         sm = table.getSelectionModel();
5482         sm.setCellSelectionEnabled(true);
5483         sm.setSelectionMode(SelectionMode.MULTIPLE);
5484         sm.getSelectedCells().addListener((ListChangeListener) c -&gt; test_rt_39842_count++);
5485 
5486         StageLoader sl = new StageLoader(table);
5487 
5488         assertEquals(0, test_rt_39842_count);
5489 
5490         if (selectToLeft) {
5491             if (selectUpwards) {
5492                 sm.selectRange(3, lastNameCol, 0, firstNameCol);
5493             } else {
5494                 sm.selectRange(0, lastNameCol, 3, firstNameCol);
5495             }
5496         } else {
5497             if (selectUpwards) {
5498                 sm.selectRange(3, firstNameCol, 0, lastNameCol);
5499             } else {
5500                 sm.selectRange(0, firstNameCol, 3, lastNameCol);
5501             }
5502         }
5503 
5504         // test model state
5505         assertEquals(8, sm.getSelectedCells().size());
5506         assertEquals(1, test_rt_39842_count);
5507 
5508         // test visual state
5509         for (int row = 0; row &lt;= 3; row++) {
5510             for (int column = 0; column &lt;= 1; column++) {
5511                 IndexedCell cell = VirtualFlowTestUtils.getCell(table, row, column);
5512                 assertTrue(cell.isSelected());
5513             }
5514         }
5515 
5516         sl.dispose();
5517     }
5518 
5519     @Test public void test_rt_22599() {
5520         TreeItem&lt;RT22599_DataType&gt; root = new TreeItem&lt;&gt;();
5521         root.getChildren().setAll(
5522                 new TreeItem&lt;&gt;(new RT22599_DataType(1, &quot;row1&quot;)),
5523                 new TreeItem&lt;&gt;(new RT22599_DataType(2, &quot;row2&quot;)),
5524                 new TreeItem&lt;&gt;(new RT22599_DataType(3, &quot;row3&quot;)));
5525         root.setExpanded(true);
5526 
5527         TreeTableColumn&lt;RT22599_DataType, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;Header&quot;);
5528         col.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue().text));
5529 
5530         TreeTableView&lt;RT22599_DataType&gt; table = new TreeTableView&lt;&gt;(root);
5531         table.setShowRoot(false);
5532         table.getColumns().addAll(col);
5533 
5534         StageLoader sl = new StageLoader(table);
5535 
5536         // testing initial state
5537         assertNotNull(table.getSkin());
5538         assertEquals(&quot;row1&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5539         assertEquals(&quot;row2&quot;, VirtualFlowTestUtils.getCell(table, 1, 0).getText());
5540         assertEquals(&quot;row3&quot;, VirtualFlowTestUtils.getCell(table, 2, 0).getText());
5541 
5542         // change row 0 (where &quot;row1&quot; currently resides), keeping same id.
5543         // Because &#39;set&#39; is called, the control should update to the new content
5544         // without any user interaction
5545         TreeItem&lt;RT22599_DataType&gt; data;
5546         root.getChildren().set(0, data = new TreeItem&lt;&gt;(new RT22599_DataType(0, &quot;row1a&quot;)));
5547         Toolkit.getToolkit().firePulse();
5548         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5549 
5550         // change the row 0 (where we currently have &quot;row1a&quot;) value directly.
5551         // Because there is no associated property, this won&#39;t be observed, so
5552         // the control should still show &quot;row1a&quot; rather than &quot;row1b&quot;
5553         data.getValue().text = &quot;row1b&quot;;
5554         Toolkit.getToolkit().firePulse();
5555         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5556 
5557         // call refresh() to force a refresh of all visible cells
5558         table.refresh();
5559         Toolkit.getToolkit().firePulse();
5560         assertEquals(&quot;row1b&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5561 
5562         sl.dispose();
5563     }
5564 
5565     private static class RT22599_DataType {
5566         public int id = 0;
5567         public String text = &quot;&quot;;
5568 
5569         public RT22599_DataType(int id, String text) {
5570             this.id = id;
5571             this.text = text;
5572         }
5573 
5574         @Override public boolean equals(Object obj) {
5575             if (obj == null) return false;
5576             return id == ((RT22599_DataType)obj).id;
5577         }
5578     }
5579 
5580     private int rt_39966_count = 0;
5581     @Test public void test_rt_39966() {
5582         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5583         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;(root);
5584         table.setShowRoot(true);
5585 
5586         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5587         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5588         table.getColumns().add(column);
5589 
5590         StageLoader sl = new StageLoader(table);
5591 
5592         // initially there is no selection
5593         assertTrue(table.getSelectionModel().isEmpty());
5594 
5595         table.getSelectionModel().selectedItemProperty().addListener((value, s1, s2) -&gt; {
5596             if (rt_39966_count == 0) {
5597                 rt_39966_count++;
5598                 assertFalse(table.getSelectionModel().isEmpty());
5599             } else {
5600                 assertTrue(table.getSelectionModel().isEmpty());
5601             }
5602         });
5603 
5604         // our assertion two lines down always succeeds. What fails is our
5605         // assertion above within the listener.
5606         table.getSelectionModel().select(0);
5607         assertFalse(table.getSelectionModel().isEmpty());
5608 
5609         table.setRoot(null);
5610         assertTrue(table.getSelectionModel().isEmpty());
5611 
5612         sl.dispose();
5613     }
5614 
5615     /**
5616      * Bullet 1: selected index must be updated
5617      * Corner case: last selected. Fails for core
5618      */
5619     @Test public void test_rt_40012_selectedAtLastOnDisjointRemoveItemsAbove() {
5620         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5621         root.setExpanded(true);
5622         root.getChildren().addAll(
5623             new TreeItem&lt;&gt;(&quot;0&quot;),
5624             new TreeItem&lt;&gt;(&quot;1&quot;),
5625             new TreeItem&lt;&gt;(&quot;2&quot;),
5626             new TreeItem&lt;&gt;(&quot;3&quot;),
5627             new TreeItem&lt;&gt;(&quot;4&quot;),
5628             new TreeItem&lt;&gt;(&quot;5&quot;)
5629         );
5630 
5631         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5632         stringTreeTableView.setShowRoot(false);
5633         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5634 
5635         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5636         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5637         stringTreeTableView.getColumns().add(column);
5638 
5639         int last = root.getChildren().size() - 1;
5640 
5641         // selecting item &quot;5&quot;
5642         sm.select(last);
5643 
5644         // disjoint remove of 2 elements above the last selected
5645         // Removing &quot;1&quot; and &quot;3&quot;
5646         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5647 
5648         // selection should move up two places such that it remains on item &quot;5&quot;,
5649         // but in index (last - 2).
5650         int expected = last - 2;
5651         assertEquals(&quot;5&quot;, sm.getSelectedItem().getValue());
5652         assertEquals(&quot;selected index after disjoint removes above&quot;, expected, sm.getSelectedIndex());
5653     }
5654 
5655     /**
5656      * Variant of 1: if selectedIndex is not updated,
5657      * the old index is no longer valid
5658      * for accessing the items.
5659      */
5660     @Test public void test_rt_40012_accessSelectedAtLastOnDisjointRemoveItemsAbove() {
5661         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5662         root.setExpanded(true);
5663         root.getChildren().addAll(
5664                 new TreeItem&lt;&gt;(&quot;0&quot;),
5665                 new TreeItem&lt;&gt;(&quot;1&quot;),
5666                 new TreeItem&lt;&gt;(&quot;2&quot;),
5667                 new TreeItem&lt;&gt;(&quot;3&quot;),
5668                 new TreeItem&lt;&gt;(&quot;4&quot;),
5669                 new TreeItem&lt;&gt;(&quot;5&quot;)
5670         );
5671 
5672         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5673         stringTreeTableView.setShowRoot(false);
5674         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5675 
5676         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5677         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5678         stringTreeTableView.getColumns().add(column);
5679 
5680         int last = root.getChildren().size() - 1;
5681 
5682         // selecting item &quot;5&quot;
5683         sm.select(last);
5684 
5685         // disjoint remove of 2 elements above the last selected
5686         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5687         int selected = sm.getSelectedIndex();
5688         if (selected &gt; -1) {
5689             root.getChildren().get(selected);
5690         }
5691     }
5692 
5693     /**
5694      * Bullet 2: selectedIndex notification count
5695      *
5696      * Note that we don&#39;t use the corner case of having the last index selected
5697      * (which fails already on updating the index)
5698      */
5699     private int rt_40012_count = 0;
5700     @Test public void test_rt_40012_selectedIndexNotificationOnDisjointRemovesAbove() {
5701         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5702         root.setExpanded(true);
5703         root.getChildren().addAll(
5704                 new TreeItem&lt;&gt;(&quot;0&quot;),
5705                 new TreeItem&lt;&gt;(&quot;1&quot;),
5706                 new TreeItem&lt;&gt;(&quot;2&quot;),
5707                 new TreeItem&lt;&gt;(&quot;3&quot;),
5708                 new TreeItem&lt;&gt;(&quot;4&quot;),
5709                 new TreeItem&lt;&gt;(&quot;5&quot;)
5710         );
5711 
5712         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5713         stringTreeTableView.setShowRoot(false);
5714         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5715 
5716         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5717         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5718         stringTreeTableView.getColumns().add(column);
5719 
5720         int last = root.getChildren().size() - 2;
5721         sm.select(last);
5722         assertEquals(last, sm.getSelectedIndex());
5723 
5724         rt_40012_count = 0;
5725         sm.selectedIndexProperty().addListener(o -&gt; rt_40012_count++);
5726 
5727         // disjoint remove of 2 elements above the last selected
5728         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5729         assertEquals(&quot;sanity: selectedIndex must be shifted by -2&quot;, last - 2, sm.getSelectedIndex());
5730         assertEquals(&quot;must fire single event on removes above&quot;, 1, rt_40012_count);
5731     }
5732 
5733     /**
5734      * Bullet 3: unchanged selectedItem must not fire change
5735      */
5736     @Test
5737     public void test_rt_40012_selectedItemNotificationOnDisjointRemovesAbove() {
5738         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5739         root.setExpanded(true);
5740         root.getChildren().addAll(
5741                 new TreeItem&lt;&gt;(&quot;0&quot;),
5742                 new TreeItem&lt;&gt;(&quot;1&quot;),
5743                 new TreeItem&lt;&gt;(&quot;2&quot;),
5744                 new TreeItem&lt;&gt;(&quot;3&quot;),
5745                 new TreeItem&lt;&gt;(&quot;4&quot;),
5746                 new TreeItem&lt;&gt;(&quot;5&quot;)
5747         );
5748 
5749         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5750         stringTreeTableView.setShowRoot(false);
5751         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5752 
5753         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5754         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5755         stringTreeTableView.getColumns().add(column);
5756 
5757         int last = root.getChildren().size() - 2;
5758         Object lastItem = root.getChildren().get(last);
5759         sm.select(last);
5760         assertEquals(lastItem, sm.getSelectedItem());
5761 
5762         rt_40012_count = 0;
5763         sm.selectedItemProperty().addListener(o -&gt; rt_40012_count++);
5764 
5765         // disjoint remove of 2 elements above the last selected
5766         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5767         assertEquals(&quot;sanity: selectedItem unchanged&quot;, lastItem, sm.getSelectedItem());
5768         assertEquals(&quot;must not fire on unchanged selected item&quot;, 0, rt_40012_count);
5769     }
5770 
5771     private int rt_40010_count = 0;
5772     @Test public void test_rt_40010() {
5773         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5774         TreeItem&lt;String&gt; child = new TreeItem&lt;&gt;(&quot;child&quot;);
5775         root.setExpanded(true);
5776         root.getChildren().addAll(child);
5777 
5778         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5779         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5780 
5781         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5782         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5783         stringTreeTableView.getColumns().add(column);
5784 
5785         sm.getSelectedIndices().addListener((ListChangeListener&lt;? super Integer&gt;) l -&gt; rt_40010_count++);
5786         sm.getSelectedItems().addListener((ListChangeListener&lt;? super TreeItem&lt;String&gt;&gt;) l -&gt; rt_40010_count++);
5787 
5788         assertEquals(0, rt_40010_count);
5789 
5790         sm.select(1);
5791         assertEquals(1, sm.getSelectedIndex());
5792         assertEquals(child, sm.getSelectedItem());
5793         assertEquals(2, rt_40010_count);
5794 
5795         root.getChildren().remove(child);
5796         assertEquals(0, sm.getSelectedIndex());
5797         assertEquals(root, sm.getSelectedItem());
5798         assertEquals(4, rt_40010_count);
5799     }
5800 
5801     /**
5802      * ClearAndSelect fires invalid change event if selectedIndex is unchanged.
5803      */
5804     private int rt_40212_count = 0;
5805     @Test public void test_rt_40212() {
5806         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5807         root.setExpanded(true);
5808         root.getChildren().addAll(
5809                 new TreeItem&lt;&gt;(&quot;0&quot;),
5810                 new TreeItem&lt;&gt;(&quot;1&quot;),
5811                 new TreeItem&lt;&gt;(&quot;2&quot;),
5812                 new TreeItem&lt;&gt;(&quot;3&quot;),
5813                 new TreeItem&lt;&gt;(&quot;4&quot;),
5814                 new TreeItem&lt;&gt;(&quot;5&quot;)
5815         );
5816 
5817         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5818         stringTreeTableView.setShowRoot(false);
5819 
5820         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5821         sm.setSelectionMode(SelectionMode.MULTIPLE);
5822 
5823         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5824         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5825         stringTreeTableView.getColumns().add(column);
5826 
5827         sm.selectRange(3, 5);
5828         int selected = sm.getSelectedIndex();
5829 
5830         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) change -&gt; {
5831             assertEquals(&quot;sanity: selectedIndex unchanged&quot;, selected, sm.getSelectedIndex());
5832             while(change.next()) {
5833                 assertEquals(&quot;single event on clearAndSelect already selected&quot;, 1, ++rt_40212_count);
5834 
5835                 boolean type = change.wasAdded() || change.wasRemoved() || change.wasPermutated() || change.wasUpdated();
5836                 assertTrue(&quot;at least one of the change types must be true&quot;, type);
5837             }
5838         });
5839 
5840         sm.clearAndSelect(selected);
5841     }
5842 
5843     @Test public void test_rt_40280() {
5844         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;();
5845         StageLoader sl = new StageLoader(view);
5846         MultipleSelectionModelBaseShim.getFocusedIndex(view.getSelectionModel());
5847         view.getFocusModel().getFocusedIndex();
5848         sl.dispose();
5849     }
5850 
5851     @Test public void test_rt_40278_showRoot() {
5852         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5853         root.setExpanded(true);
5854         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5855 
5856         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5857         view.setShowRoot(false);
5858         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5859 
5860         assertFalse(&quot;sanity: test setup such that root is not showing&quot;, view.isShowRoot());
5861         sm.select(0);
5862         assertEquals(0, sm.getSelectedIndex());
5863         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5864         view.setShowRoot(true);
5865         assertEquals(1, sm.getSelectedIndex());
5866         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5867     }
5868 
5869     @Test public void test_rt_40278_hideRoot_selectionOnChild() {
5870         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5871         root.setExpanded(true);
5872         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5873 
5874         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5875         view.setShowRoot(true);
5876         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5877 
5878         assertTrue(&quot;sanity: test setup such that root is showing&quot;, view.isShowRoot());
5879         sm.select(1);
5880         assertEquals(1, sm.getSelectedIndex());
5881         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5882         view.setShowRoot(false);
5883         assertEquals(0, sm.getSelectedIndex());
5884         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5885     }
5886 
5887     @Test public void test_rt_40278_hideRoot_selectionOnRoot() {
5888         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5889         root.setExpanded(true);
5890         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5891 
5892         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5893         view.setShowRoot(true);
5894         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5895 
5896         assertTrue(&quot;sanity: test setup such that root is showing&quot;, view.isShowRoot());
5897         sm.select(0);
5898         assertEquals(0, sm.getSelectedIndex());
5899         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5900         view.setShowRoot(false);
5901         assertEquals(0, sm.getSelectedIndex());
5902         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5903     }
5904 
5905     /**
5906      * Test list change of selectedIndices on setIndices. Fails for core ..
5907      */
5908     @Test public void test_rt_40263() {
5909         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(-1);
5910         root.setExpanded(true);
5911 
5912         for (int i = 0; i &lt; 10; i++) {
5913             root.getChildren().add(new TreeItem&lt;Integer&gt;(i));
5914         }
5915 
5916         final TreeTableView&lt;Integer&gt; view = new TreeTableView&lt;&gt;(root);
5917         TreeTableView.TreeTableViewSelectionModel&lt;Integer&gt; sm = view.getSelectionModel();
5918         sm.setSelectionMode(SelectionMode.MULTIPLE);
5919 
5920         int[] indices = new int[]{2, 5, 7};
5921         ListChangeListener&lt;Integer&gt; l = c -&gt; {
5922             // firstly, we expect only one change
5923             int subChanges = 0;
5924             while(c.next()) {
5925                 subChanges++;
5926             }
5927             assertEquals(1, subChanges);
5928 
5929             // secondly, we expect the added size to be three, as that is the
5930             // number of items selected
5931             c.reset();
5932             c.next();
5933             System.out.println(&quot;Added items: &quot; + c.getAddedSubList());
5934             assertEquals(indices.length, c.getAddedSize());
5935             assertArrayEquals(indices, c.getAddedSubList().stream().mapToInt(i -&gt; i).toArray());
5936         };
5937         sm.getSelectedIndices().addListener(l);
5938         sm.selectIndices(indices[0], indices);
5939     }
5940 
5941     @Test public void test_rt_40319_toRight_toBottom()          { test_rt_40319(true, true, false);   }
5942     @Test public void test_rt_40319_toRight_toTop()             { test_rt_40319(true, false, false);  }
5943     @Test public void test_rt_40319_toLeft_toBottom()           { test_rt_40319(false, true, false);  }
5944     @Test public void test_rt_40319_toLeft_toTop()              { test_rt_40319(false, false, false); }
5945     @Test public void test_rt_40319_toRight_toBottom_useMouse() { test_rt_40319(true, true, true);    }
5946     @Test public void test_rt_40319_toRight_toTop_useMouse()    { test_rt_40319(true, false, true);   }
5947     @Test public void test_rt_40319_toLeft_toBottom_useMouse()  { test_rt_40319(false, true, true);   }
5948     @Test public void test_rt_40319_toLeft_toTop_useMouse()     { test_rt_40319(false, false, true);  }
5949 
5950     private void test_rt_40319(boolean toRight, boolean toBottom, boolean useMouse) {
5951         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5952         root.setExpanded(true);
5953         root.getChildren().addAll(
5954                 new TreeItem&lt;&gt;(&quot;0&quot;),
5955                 new TreeItem&lt;&gt;(&quot;1&quot;),
5956                 new TreeItem&lt;&gt;(&quot;2&quot;),
5957                 new TreeItem&lt;&gt;(&quot;3&quot;),
5958                 new TreeItem&lt;&gt;(&quot;4&quot;),
5959                 new TreeItem&lt;&gt;(&quot;5&quot;)
5960         );
5961 
5962         TreeTableView&lt;String&gt; t = new TreeTableView&lt;&gt;(root);
5963         t.setShowRoot(false);
5964 
5965         sm = t.getSelectionModel();
5966         sm.setSelectionMode(SelectionMode.MULTIPLE);
5967 
5968         TreeTableColumn&lt;String,String&gt; c1 = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5969         c1.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5970         TreeTableColumn&lt;String,String&gt; c2 = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5971         c2.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5972         t.getColumns().addAll(c1, c2);
5973 
5974         final int startIndex = toRight ? 0 : 2;
5975         final int endIndex = toRight ? 2 : 0;
5976         final TreeTableColumn&lt;String,String&gt; startColumn = toBottom ? c1 : c2;
5977         final TreeTableColumn&lt;String,String&gt; endColumn = toBottom ? c2 : c1;
5978 
5979         sm.select(startIndex, startColumn);
5980 
5981         if (useMouse) {
5982             Cell endCell = VirtualFlowTestUtils.getCell(t, endIndex, toRight ? 1 : 0);
5983             MouseEventFirer mouse = new MouseEventFirer(endCell);
5984             mouse.fireMousePressAndRelease(KeyModifier.SHIFT);
5985         } else {
5986             t.getSelectionModel().selectRange(startIndex, startColumn, endIndex, endColumn);
5987         }
5988 
5989         assertEquals(3, sm.getSelectedItems().size());
5990         assertEquals(3, sm.getSelectedIndices().size());
5991         assertEquals(3, sm.getSelectedCells().size());
5992     }
5993 
5994     @Test public void test_jdk_8147483() {
5995         TreeItem&lt;Number&gt; root = new TreeItem&lt;&gt;(0);
5996         root.setExpanded(true);
5997 
5998         final TreeTableView&lt;Number&gt; view = new TreeTableView&lt;&gt;(root);
5999         view.setShowRoot(false);
6000 
6001         AtomicInteger cellUpdateCount = new AtomicInteger();
6002         AtomicInteger rowCreateCount = new AtomicInteger();
6003 
6004         TreeTableColumn&lt;Number, Number&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
6005         column.setCellValueFactory(cdf -&gt; new ReadOnlyIntegerWrapper(0));
6006         column.setCellFactory( ttc -&gt; new TreeTableCell&lt;Number,Number&gt;() {
6007             @Override protected void updateItem(Number item, boolean empty) {
6008                 cellUpdateCount.incrementAndGet();
6009                 super.updateItem(item, empty);
6010             }
6011         });
6012         view.getColumns().add(column);
6013 
6014         view.setRowFactory(t -&gt; {
6015             rowCreateCount.incrementAndGet();
6016             return new TreeTableRow&lt;&gt;();
6017         });
6018 
6019         assertEquals(0, cellUpdateCount.get());
6020         assertEquals(0, rowCreateCount.get());
6021 
6022         StageLoader sl = new StageLoader(view);
6023 
6024         // Before the fix, we got cellUpdateCount = 18 and rowCreateCount = 17 for the first add below.
6025         // After the second add, these numbers went to 53 and 17 respectively.
6026         // Because these numbers might differ on other systems, we simply record the values after
6027         // the first add, and then we expect the cellUpdateCount to increase by one, and rowCreateCount to
6028         // not increase at all.
6029         root.getChildren().add(new TreeItem(1));
6030         Toolkit.getToolkit().firePulse();
6031         final int firstCellUpdateCount = cellUpdateCount.get();
6032         final int firstRowCreateCount = rowCreateCount.get();
6033 
6034         root.getChildren().add(new TreeItem(2));
6035         Toolkit.getToolkit().firePulse();
6036         assertEquals(firstCellUpdateCount+1, cellUpdateCount.get());
6037         assertEquals(firstRowCreateCount, rowCreateCount.get());
6038 
6039         root.getChildren().add(new TreeItem(3));
6040         Toolkit.getToolkit().firePulse();
6041         assertEquals(firstCellUpdateCount+2, cellUpdateCount.get());
6042         assertEquals(firstRowCreateCount, rowCreateCount.get());
6043 
6044         sl.dispose();
6045     }
6046 
6047     @Test public void test_jdk_8144681_removeColumn() {
6048         TreeTableView&lt;Book&gt; table = new TreeTableView&lt;&gt;();
6049 
6050         TreeItem&lt;Book&gt; root = new TreeItem&lt;&gt;();
6051         root.getChildren().addAll(
6052                 new TreeItem&lt;&gt;(new Book(&quot;Book 1&quot;, &quot;Author 1&quot;, &quot;Remark 1&quot;))
6053                 , new TreeItem&lt;&gt;(new Book(&quot;Book 2&quot;, &quot;Author 2&quot;, &quot;Remark 2&quot;))
6054                 , new TreeItem&lt;&gt;(new Book(&quot;Book 3&quot;, &quot;Author 3&quot;, &quot;Remark 3&quot;))
6055                 , new TreeItem&lt;&gt;(new Book(&quot;Book 4&quot;, &quot;Author 4&quot;, &quot;Remark 4&quot;)));
6056         table.setRoot(root);
6057 
6058         String[] columns = { &quot;title&quot;, &quot;author&quot;, &quot;remark&quot; };
6059         for (String prop : columns) {
6060             TreeTableColumn&lt;Book, String&gt; col = new TreeTableColumn&lt;&gt;(prop);
6061             col.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(prop));
6062             table.getColumns().add(col);
6063         }
6064         table.setColumnResizePolicy(TreeTableView.UNCONSTRAINED_RESIZE_POLICY);
6065         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
6066         table.getSelectionModel().setCellSelectionEnabled(true);
6067 
6068         table.getSelectionModel().selectAll();
6069 
6070         ControlTestUtils.runWithExceptionHandler(() -&gt; table.getColumns().remove(2));
6071     }
6072 
6073     @Test public void test_jdk_8144681_moveColumn() {
6074         TreeTableView&lt;Book&gt; table = new TreeTableView&lt;&gt;();
6075 
6076         TreeItem&lt;Book&gt; root = new TreeItem&lt;&gt;();
6077         root.getChildren().addAll(
6078                 new TreeItem&lt;&gt;(new Book(&quot;Book 1&quot;, &quot;Author 1&quot;, &quot;Remark 1&quot;))
6079                 , new TreeItem&lt;&gt;(new Book(&quot;Book 2&quot;, &quot;Author 2&quot;, &quot;Remark 2&quot;))
6080                 , new TreeItem&lt;&gt;(new Book(&quot;Book 3&quot;, &quot;Author 3&quot;, &quot;Remark 3&quot;))
6081                 , new TreeItem&lt;&gt;(new Book(&quot;Book 4&quot;, &quot;Author 4&quot;, &quot;Remark 4&quot;)));
6082         table.setRoot(root);
6083 
6084         String[] columns = { &quot;title&quot;, &quot;author&quot;, &quot;remark&quot; };
6085         for (String prop : columns) {
6086             TreeTableColumn&lt;Book, String&gt; col = new TreeTableColumn&lt;&gt;(prop);
6087             col.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(prop));
6088             table.getColumns().add(col);
6089         }
6090         table.setColumnResizePolicy(TreeTableView.UNCONSTRAINED_RESIZE_POLICY);
6091         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
6092         table.getSelectionModel().setCellSelectionEnabled(true);
6093 
6094         table.getSelectionModel().selectAll();
6095 
6096         ControlTestUtils.runWithExceptionHandler(() -&gt; {
6097             table.getColumns().setAll(table.getColumns().get(0), table.getColumns().get(2), table.getColumns().get(1));
6098         });
6099     }
6100 
6101     private static class Book {
6102         private SimpleStringProperty title = new SimpleStringProperty();
6103         private SimpleStringProperty author = new SimpleStringProperty();
6104         private SimpleStringProperty remark = new SimpleStringProperty();
6105 
6106         public Book(String title, String author, String remark) {
6107             super();
6108             setTitle(title);
6109             setAuthor(author);
6110             setRemark(remark);
6111         }
6112 
6113         public SimpleStringProperty titleProperty() {
6114             return this.title;
6115         }
6116 
6117         public java.lang.String getTitle() {
6118             return this.titleProperty().get();
6119         }
6120 
6121         public void setTitle(final java.lang.String title) {
6122             this.titleProperty().set(title);
6123         }
6124 
6125         public SimpleStringProperty authorProperty() {
6126             return this.author;
6127         }
6128 
6129         public java.lang.String getAuthor() {
6130             return this.authorProperty().get();
6131         }
6132 
6133         public void setAuthor(final java.lang.String author) {
6134             this.authorProperty().set(author);
6135         }
6136 
6137         public SimpleStringProperty remarkProperty() {
6138             return this.remark;
6139         }
6140 
6141         public java.lang.String getRemark() {
6142             return this.remarkProperty().get();
6143         }
6144 
6145         public void setRemark(final java.lang.String remark) {
6146             this.remarkProperty().set(remark);
6147         }
6148 
6149         @Override
6150         public String toString() {
6151             return String.format(&quot;%s(%s) - %s&quot;, getTitle(), getAuthor(), getRemark());
6152         }
6153     }
6154 
6155     @Test public void test_jdk_8157205() {
6156         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6157         childNode1.setExpanded(true);
6158         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6159         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6160         childNode1.getChildren().addAll(item1, item2);
6161 
6162         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6163         root.setExpanded(true);
6164         root.getChildren().add(childNode1);
6165 
6166         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6167         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6168         sm.setSelectionMode(SelectionMode.MULTIPLE);
6169 
6170         AtomicInteger step = new AtomicInteger();
6171 
6172         AtomicInteger indicesEventCount = new AtomicInteger();
6173         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;)c -&gt; {
6174             switch (step.get()) {
6175                 case 0: {
6176                     // expect to see [1,2,3] added at index 0
6177                     c.next();
6178                     assertEquals(3, c.getAddedSize());
6179                     assertTrue(&quot;added: &quot; + c.getAddedSubList(),
6180                             c.getAddedSubList().containsAll(FXCollections.observableArrayList(1,2,3)));
6181                     assertEquals(0, c.getFrom());
6182                     break;
6183                 }
6184                 case 1: {
6185                     // expect to see [2,3] removed
6186                     List&lt;Integer&gt; removed = new ArrayList&lt;&gt;();
6187                     while (c.next()) {
6188                         if (c.wasRemoved()) {
6189                             removed.addAll(c.getRemoved());
6190                         } else {
6191                             fail(&quot;Unexpected state&quot;);
6192                         }
6193                     }
6194                     if (!removed.isEmpty()) {
6195                         assertTrue(removed.containsAll(FXCollections.observableArrayList(2,3)));
6196                     }
6197                     break;
6198                 }
6199             }
6200 
6201             indicesEventCount.incrementAndGet();
6202         });
6203 
6204         AtomicInteger itemsEventCount = new AtomicInteger();
6205         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;)c -&gt; {
6206             switch (step.get()) {
6207                 case 0: {
6208                     // expect to see [1,2,3] added at index 0
6209                     c.next();
6210                     assertEquals(3, c.getAddedSize());
6211                     assertTrue(&quot;added: &quot; + c.getAddedSubList(),
6212                             c.getAddedSubList().containsAll(FXCollections.observableArrayList(childNode1, item1, item2)));
6213                     assertEquals(0, c.getFrom());
6214                     break;
6215                 }
6216                 case 1: {
6217                     // expect to see [2,3] removed
6218                     List&lt;TreeItem&lt;String&gt;&gt; removed = new ArrayList&lt;&gt;();
6219                     while (c.next()) {
6220                         if (c.wasRemoved()) {
6221                             removed.addAll(c.getRemoved());
6222                         } else {
6223                             fail(&quot;Unexpected state&quot;);
6224                         }
6225                     }
6226                     if (!removed.isEmpty()) {
6227                         assertTrue(removed.containsAll(FXCollections.observableArrayList(item1, item2)));
6228                     }
6229                     break;
6230                 }
6231             }
6232 
6233             itemsEventCount.incrementAndGet();
6234         });
6235 
6236         assertEquals(0, indicesEventCount.get());
6237         assertEquals(0, itemsEventCount.get());
6238 
6239         step.set(0);
6240         sm.selectIndices(1,2,3); // select Child Node 1 and both children
6241         assertTrue(sm.isSelected(1));
6242         assertTrue(sm.isSelected(2));
6243         assertTrue(sm.isSelected(3));
6244         assertEquals(3, sm.getSelectedIndices().size());
6245         assertEquals(3, sm.getSelectedItems().size());
6246         assertEquals(1, indicesEventCount.get());
6247         assertEquals(1, itemsEventCount.get());
6248 
6249         step.set(1);
6250         System.out.println(&quot;about to collapse now&quot;);
6251         childNode1.setExpanded(false); // collapse Child Node 1 and expect both children to be deselected
6252         assertTrue(sm.isSelected(1));
6253         assertFalse(sm.isSelected(2));
6254         assertFalse(sm.isSelected(3));
6255         assertEquals(1, sm.getSelectedIndices().size());
6256         assertEquals(1, sm.getSelectedItems().size());
6257         assertEquals(2, indicesEventCount.get());
6258         assertEquals(2, itemsEventCount.get());
6259 
6260         step.set(2);
6261         childNode1.setExpanded(true); // expand Child Node 1 and expect both children to still be deselected
6262         assertTrue(sm.isSelected(1));
6263         assertFalse(sm.isSelected(2));
6264         assertFalse(sm.isSelected(3));
6265         assertEquals(1, sm.getSelectedIndices().size());
6266         assertEquals(1, sm.getSelectedItems().size());
6267         assertEquals(2, indicesEventCount.get());
6268         assertEquals(2, itemsEventCount.get());
6269     }
6270 
6271     @Test public void test_jdk_8157285() {
6272         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6273         childNode1.setExpanded(true);
6274         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6275         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6276         childNode1.getChildren().addAll(item1, item2);
6277 
6278         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6279         root.setExpanded(true);
6280         root.getChildren().add(childNode1);
6281 
6282         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6283         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6284         sm.setSelectionMode(SelectionMode.MULTIPLE);
6285 
6286         view.expandedItemCountProperty().addListener((observable, oldCount, newCount) -&gt; {
6287             if (childNode1.isExpanded()) return;
6288             System.out.println(sm.getSelectedIndices());
6289             System.out.println(sm.getSelectedItems());
6290             assertTrue(sm.isSelected(1));
6291             assertFalse(sm.isSelected(2));
6292             assertFalse(sm.isSelected(3));
6293             assertEquals(1, sm.getSelectedIndices().size());
6294             assertEquals(1, sm.getSelectedItems().size());
6295         });
6296 
6297         sm.selectIndices(1,2,3); // select Child Node 1 and both children
6298         assertTrue(sm.isSelected(1));
6299         assertTrue(sm.isSelected(2));
6300         assertTrue(sm.isSelected(3));
6301         assertEquals(3, sm.getSelectedIndices().size());
6302         assertEquals(3, sm.getSelectedItems().size());
6303 
6304         // collapse Child Node 1 and expect both children to be deselected,
6305         // and that in the expandedItemCount listener that we get the right values
6306         // in the selectedIndices and selectedItems list
6307         childNode1.setExpanded(false);
6308     }
6309 
6310     @Test public void test_jdk_8152396() {
6311         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6312         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6313         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6314         childNode1.getChildren().addAll(item1, item2);
6315 
6316         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6317         root.setExpanded(true);
6318         root.getChildren().add(childNode1);
6319 
6320         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6321         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6322         sm.setSelectionMode(SelectionMode.MULTIPLE);
6323 
6324         view.expandedItemCountProperty().addListener((observable, oldCount, newCount) -&gt; {
6325             if (newCount.intValue() &gt; oldCount.intValue()) {
6326                 for (int index: sm.getSelectedIndices()) {
6327                     TreeItem&lt;String&gt; item = view.getTreeItem(index);
6328 
6329                     if (item != null &amp;&amp; item.isExpanded() &amp;&amp; !item.getChildren().isEmpty()) {
6330                         int startIndex = index + 1;
6331                         int maxCount = startIndex + item.getChildren().size();
6332 
6333                         sm.selectRange(startIndex, maxCount);
6334                     }
6335                 }
6336             }
6337         });
6338 
6339         FilteredList filteredList = sm.getSelectedItems().filtered(Objects::nonNull);
6340 
6341         StageLoader sl = new StageLoader(view);
6342 
6343         sm.select(1);
6344         childNode1.setExpanded(true);
6345         Toolkit.getToolkit().firePulse();
6346 
6347         // collapse Child Node 1 and expect both children to be deselected,
6348         // and that the filtered list does not throw an exception
6349         assertEquals(3, filteredList.size());
6350         ControlTestUtils.runWithExceptionHandler(() -&gt; childNode1.setExpanded(false));
6351 
6352         Toolkit.getToolkit().firePulse();
6353         assertEquals(1, filteredList.size());
6354 
6355         sl.dispose();
6356     }
6357 
6358     @Test public void test_jdk_8160771() {
6359         TreeTableView table = new TreeTableView();
6360         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
6361         table.getColumns().add(first);
6362         table.getVisibleLeafColumns().addListener((ListChangeListener) c -&gt; {
6363             c.next();
6364             assertTrue(c.wasAdded());
6365             assertSame(table, ((TreeTableColumn) c.getAddedSubList().get(0)).getTreeTableView());
6366         });
6367         TreeTableColumn last = new TreeTableColumn(&quot;Last Name&quot;);
6368         table.getColumns().add(0, last);
6369     }
6370 
6371     private void test_jdk_8169642(Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; before,
6372                                   Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; afterDescending,
6373                                   Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; afterAscending) {
6374         final TreeItem&lt;String&gt; rootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
6375         rootItem.setExpanded(true);
6376         rootItem.getChildren().addAll(new TreeItem&lt;&gt;(&quot;first child&quot;), new TreeItem&lt;&gt;(&quot;second child&quot;), new TreeItem&lt;&gt;(&quot;third child&quot;));
6377 
6378         final TreeTableView&lt;String&gt; tree = new TreeTableView&lt;&gt;(rootItem);
6379         final TreeTableColumn&lt;String, String&gt; column = new TreeTableColumn&lt;&gt;(&quot;first column&quot;);
6380         column.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
6381         tree.getColumns().add(column);
6382 
6383         TreeTableView.TreeTableViewSelectionModel sm = tree.getSelectionModel();
6384         sm.setSelectionMode(SelectionMode.MULTIPLE);
6385 
6386         assertTrue(sm.isEmpty());
6387         before.accept(sm);
6388 
6389         tree.getSortOrder().add(column);
6390         column.setSortType(TreeTableColumn.SortType.DESCENDING);
6391         afterDescending.accept(sm);
6392 
6393         column.setSortType(TreeTableColumn.SortType.ASCENDING);
6394         afterAscending.accept(sm);
6395     }
6396 
6397     @Test public void test_jdk_8169642_1_only() {
6398         test_jdk_8169642(
6399             sm -&gt; {
6400                 // select &#39;first&#39;
6401                 sm.select(1);
6402                 assertTrue(sm.isSelected(1));
6403                 assertEquals(1, sm.getSelectedCells().size());
6404             },
6405             sm -&gt; {
6406                 assertTrue(sm.isSelected(3));
6407                 assertEquals(1, sm.getSelectedCells().size());
6408             },
6409             sm -&gt; {
6410                 assertTrue(sm.isSelected(1));
6411                 assertEquals(1, sm.getSelectedCells().size());
6412             }
6413         );
6414     }
6415 
6416     @Test public void test_jdk_8169642_2_only() {
6417         test_jdk_8169642(
6418             sm -&gt; {
6419                 // select &#39;second&#39;
6420                 sm.select(2);
6421                 assertTrue(sm.isSelected(2));
6422                 assertEquals(1, sm.getSelectedCells().size());
6423             },
6424             sm -&gt; {
6425                 assertTrue(sm.isSelected(2));
6426                 assertEquals(1, sm.getSelectedCells().size());
6427             },
6428             sm -&gt; {
6429                 assertTrue(sm.isSelected(2));
6430                 assertEquals(1, sm.getSelectedCells().size());
6431             }
6432         );
6433     }
6434 
6435     @Test public void test_jdk_8169642_1_and_3() {
6436         test_jdk_8169642(
6437             sm -&gt; {
6438                 // select &#39;first&#39; and &#39;third&#39;, they should flip positions
6439                 sm.select(1);
6440                 sm.select(3);
6441                 assertTrue(sm.isSelected(1));
6442                 assertTrue(sm.isSelected(3));
6443                 assertEquals(2, sm.getSelectedCells().size());
6444             },
6445             sm -&gt; {
6446                 assertTrue(sm.isSelected(1));
6447                 assertTrue(sm.isSelected(3));
6448                 assertEquals(2, sm.getSelectedCells().size());
6449             },
6450             sm -&gt; {
6451                 assertTrue(sm.isSelected(1));
6452                 assertTrue(sm.isSelected(3));
6453                 assertEquals(2, sm.getSelectedCells().size());
6454             }
6455         );
6456     }
6457 
6458     @Test public void test_jdk_8169642_0_and_3() {
6459         test_jdk_8169642(
6460                 sm -&gt; {
6461                     // select &#39;root&#39; and &#39;third&#39;
6462                     sm.select(0);
6463                     sm.select(3);
6464                     assertTrue(sm.isSelected(0));
6465                     assertTrue(sm.isSelected(3));
6466                     assertEquals(2, sm.getSelectedCells().size());
6467                 },
6468                 sm -&gt; {
6469                     assertTrue(sm.isSelected(0));
6470                     assertTrue(sm.isSelected(1));
6471                     assertEquals(2, sm.getSelectedCells().size());
6472                 },
6473                 sm -&gt; {
6474                     assertTrue(sm.isSelected(0));
6475                     assertTrue(sm.isSelected(3));
6476                     assertEquals(2, sm.getSelectedCells().size());
6477                 }
6478         );
6479     }
6480 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
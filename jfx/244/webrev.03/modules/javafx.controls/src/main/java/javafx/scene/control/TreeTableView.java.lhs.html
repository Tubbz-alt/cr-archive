<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import com.sun.javafx.collections.MappingChange;
  29 import com.sun.javafx.collections.NonIterableChange;
  30 import com.sun.javafx.scene.control.Properties;
  31 import com.sun.javafx.scene.control.SelectedCellsMap;
  32 
  33 import com.sun.javafx.scene.control.behavior.TableCellBehavior;
  34 import com.sun.javafx.scene.control.behavior.TableCellBehaviorBase;
  35 import com.sun.javafx.scene.control.behavior.TreeTableCellBehavior;
  36 
  37 import javafx.beans.property.DoubleProperty;
  38 import javafx.css.CssMetaData;
  39 import javafx.css.PseudoClass;
  40 
  41 import javafx.css.converter.SizeConverter;
  42 import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
  43 import com.sun.javafx.scene.control.TableColumnComparatorBase;
  44 
  45 import javafx.css.Styleable;
  46 import javafx.css.StyleableDoubleProperty;
  47 import javafx.css.StyleableProperty;
  48 import javafx.event.WeakEventHandler;
  49 
  50 import javafx.scene.control.skin.TreeTableViewSkin;
  51 
  52 import java.lang.ref.SoftReference;
  53 import java.lang.ref.WeakReference;
  54 import java.util.ArrayList;
  55 import java.util.Collection;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashMap;
<a name="1" id="anc1"></a>
  59 import java.util.LinkedHashSet;
  60 import java.util.List;
  61 import java.util.Map;
  62 import java.util.Set;
  63 import java.util.WeakHashMap;
  64 
  65 import javafx.application.Platform;
  66 import javafx.beans.DefaultProperty;
  67 import javafx.beans.InvalidationListener;
  68 import javafx.beans.WeakInvalidationListener;
  69 import javafx.beans.property.BooleanProperty;
  70 import javafx.beans.property.ObjectProperty;
  71 import javafx.beans.property.ObjectPropertyBase;
  72 import javafx.beans.property.ReadOnlyIntegerProperty;
  73 import javafx.beans.property.ReadOnlyIntegerWrapper;
  74 import javafx.beans.property.ReadOnlyObjectProperty;
  75 import javafx.beans.property.ReadOnlyObjectWrapper;
  76 import javafx.beans.property.SimpleBooleanProperty;
  77 import javafx.beans.property.SimpleObjectProperty;
  78 import javafx.beans.value.ChangeListener;
  79 import javafx.beans.value.WeakChangeListener;
  80 import javafx.beans.value.WritableValue;
  81 import javafx.collections.FXCollections;
  82 import javafx.collections.ListChangeListener;
  83 import javafx.collections.MapChangeListener;
  84 import javafx.collections.ObservableList;
  85 import javafx.collections.WeakListChangeListener;
  86 import javafx.event.Event;
  87 import javafx.event.EventHandler;
  88 import javafx.event.EventType;
  89 import javafx.scene.AccessibleAttribute;
  90 import javafx.scene.AccessibleRole;
  91 import javafx.scene.Node;
  92 import javafx.scene.layout.Region;
  93 import javafx.util.Callback;
  94 
  95 /**
  96  * The TreeTableView control is designed to visualize an unlimited number of rows
  97  * of data, broken out into columns. The TreeTableView control is conceptually
  98  * very similar to the {@link TreeView} and {@link TableView} controls,
  99  * and as you read on you&#39;ll come to see the APIs are largely the same.
 100  * However, to give a high-level overview, you&#39;ll note that the TreeTableView
 101  * uses the same {@link TreeItem} API as {@link TreeView},
 102  * and that you therefore are required to simply set the
 103  * {@link #rootProperty() root node} in the TreeTableView. Similarly, the
 104  * TreeTableView control makes use of the same TableColumn-based approach that
 105  * the {@link TableView} control uses, except instead of using the
 106  * TableView-specific {@link TableColumn} class, you should instead use the
 107  * TreeTableView-specific {@link TreeTableColumn} class instead. For an
 108  * example on how to create a TreeTableView instance, refer to the &#39;Creating a
 109  * TreeTableView&#39; control section below.
 110  *
 111  * &lt;p&gt;As with the {@link TableView} control, the TreeTableView control has a
 112  * number of features, including:
 113  * &lt;ul&gt;
 114  * &lt;li&gt;Powerful {@link TreeTableColumn} API:
 115  *   &lt;ul&gt;
 116  *   &lt;li&gt;Support for {@link TreeTableColumn#cellFactoryProperty() cell factories} to
 117  *      easily customize {@link Cell cell} contents in both rendering and editing
 118  *      states.
 119  *   &lt;li&gt;Specification of {@link TreeTableColumn#minWidthProperty() minWidth}/
 120  *      {@link TreeTableColumn#prefWidthProperty() prefWidth}/
 121  *      {@link TreeTableColumn#maxWidthProperty() maxWidth},
 122  *      and also {@link TreeTableColumn#resizableProperty() fixed width columns}.
 123  *   &lt;li&gt;Width resizing by the user at runtime.
 124  *   &lt;li&gt;Column reordering by the user at runtime.
 125  *   &lt;li&gt;Built-in support for {@link TreeTableColumn#getColumns() column nesting}
 126  *   &lt;/ul&gt;
 127  * &lt;li&gt;Different {@link #columnResizePolicyProperty() resizing policies} to
 128  *      dictate what happens when the user resizes columns.
 129  * &lt;li&gt;Support for {@link #getSortOrder() multiple column sorting} by clicking
 130  *      the column header (hold down Shift keyboard key whilst clicking on a
 131  *      header to sort by multiple columns).
 132  * &lt;/ul&gt;
 133  *
 134  * &lt;h2&gt;Creating a TreeTableView&lt;/h2&gt;
 135  *
 136  * &lt;p&gt;Creating a TreeTableView is a multi-step process, and also depends on the
 137  * underlying data model needing to be represented. For this example we&#39;ll use
 138  * the TreeTableView to visualise a file system, and will therefore make use
 139  * of an imaginary (and vastly simplified) File class as defined below:
 140  *
 141  * &lt;pre&gt; {@code public class File {
 142  *     private StringProperty name;
 143  *     public void setName(String value) { nameProperty().set(value); }
 144  *     public String getName() { return nameProperty().get(); }
 145  *     public StringProperty nameProperty() {
 146  *         if (name == null) name = new SimpleStringProperty(this, &quot;name&quot;);
 147  *         return name;
 148  *     }
 149  *
 150  *     private LongProperty lastModified;
 151  *     public void setLastModified(long value) { lastModifiedProperty().set(value); }
 152  *     public long getLastModified() { return lastModifiedProperty().get(); }
 153  *     public LongProperty lastModifiedProperty() {
 154  *         if (lastModified == null) lastModified = new SimpleLongProperty(this, &quot;lastModified&quot;);
 155  *         return lastModified;
 156  *     }
 157  *
 158  *     public File(String name, long size) {
 159  *         setName(name);
 160  *         setSize(size);
 161  *     }
 162  * }}&lt;/pre&gt;
 163  *
 164  * &lt;p&gt;The data we will use for this example is a single root with 3 files:
 165  *
 166  * &lt;pre&gt; {@code File rootFile = new File(&quot;Images&quot;, 900);
 167  * List&lt;File&gt; files = List.of(
 168  *     new File(&quot;Cat.png&quot;, 300),
 169  *     new File(&quot;Dog.png&quot;, 500),
 170  *     new File(&quot;Bird.png&quot;, 100));}&lt;/pre&gt;
 171  *
 172  * &lt;p&gt;Firstly, we need to create a data model. As mentioned, for this example,
 173  * we&#39;ll be representing a file system using File instances. To do this, we need
 174  * to define the root node of the tree table and its hierarchy:
 175  *
 176  * &lt;pre&gt; {@code TreeItem&lt;File&gt; root = new TreeItem&lt;&gt;(rootFile);
 177  * files.forEach(file -&gt; root.getChildren().add(new TreeItem&lt;&gt;(file)));}&lt;/pre&gt;
 178  *
 179  * &lt;p&gt; Then we create a TreeTableView instance:
 180  *
 181  * &lt;pre&gt; {@code TreeTableView&lt;File&gt; treeTable = new TreeTableView&lt;&gt;(root);}&lt;/pre&gt;
 182  *
 183  * &lt;p&gt;With the root set as such, the TreeTableView will automatically update whenever
 184  * the {@link TreeItem#getChildren() children} of the root change.
 185  *
 186  * &lt;p&gt;At this point we have a TreeTableView hooked up to observe the root
 187  * TreeItem instance. The missing ingredient
 188  * now is the means of splitting out the data contained within the model and
 189  * representing it in one or more {@link TreeTableColumn} instances. To
 190  * create a two-column TreeTableView to show the file name and size
 191  * properties, we write:
 192  *
 193  * &lt;pre&gt; {@code TreeTableColumns&lt;File, String&gt; fileNameCol = new TreeTableColumn&lt;&gt;(&quot;Filename&quot;);
 194  * TreeTableColumns&lt;File, Long&gt; sizeCol = new TreeTableColumn&lt;&gt;(&quot;Size&quot;);
 195  *
 196  * treeTable.getColumns().setAll(fileNameCol, sizeCol);}&lt;/pre&gt;
 197  *
 198  * &lt;p&gt;With the code shown above we have nearly fully defined the minimum properties
 199  * required to create a TreeTableView instance. The only thing missing is the
 200  * {@link javafx.scene.control.TreeTableColumn#cellValueFactoryProperty() cell value factories}
 201  * for the two columns - it is these that are responsible for determining the value
 202  * of a cell in a given row. Commonly these can be specified using the
 203  * {@link javafx.scene.control.cell.TreeItemPropertyValueFactory} class, but
 204  * failing that you can also create an anonymous inner class and do whatever is
 205  * necessary. For example, using {@link javafx.scene.control.cell.TreeItemPropertyValueFactory}
 206  * you would do the following:
 207  *
 208  * &lt;pre&gt; {@code fileNameCol.setCellValueFactory(new TreeItemPropertyValueFactory(rootFile.nameProperty().getName()));
 209  * sizeCol.setCellValueFactory(new TreeItemPropertyValueFactory(rootFile.sizeProperty().getName()));}&lt;/pre&gt;
 210  *
 211  * &lt;img src=&quot;doc-files/TreeTableView.png&quot; alt=&quot;Image of the TreeTableView control&quot;&gt;
 212  *
 213  * &lt;p&gt;Running this code will result in a TreeTableView as shown above with two columns
 214  * for name and size. Any other properties the File class might have will not be shown,
 215  * as no TreeTableColumns are defined for them.
 216  *
 217  * &lt;h3&gt;TreeTableView support for classes that don&#39;t contain properties&lt;/h3&gt;
 218  *
 219  * &lt;p&gt;The code shown above is the shortest possible code for creating a TreeTableView
 220  * when the domain objects are designed with JavaFX properties in mind
 221  * (additionally, {@link javafx.scene.control.cell.TreeItemPropertyValueFactory} supports
 222  * normal JavaBean properties too, although there is a caveat to this, so refer
 223  * to the class documentation for more information). When this is not the case,
 224  * it is necessary to provide a custom cell value factory. More information
 225  * about cell value factories can be found in the {@link TreeTableColumn} API
 226  * documentation, but briefly, here is how a TreeTableColumns could be specified:
 227  *
 228  * &lt;pre&gt; {@code firstNameCol.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;Person, String&gt;, ObservableValue&lt;String&gt;&gt;() {
 229  *     public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;Person, String&gt; p) {
 230  *         // p.getValue() returns the TreeItem&lt;Person&gt; instance for a particular TreeTableView row,
 231  *         // p.getValue().getValue() returns the Person instance inside the TreeItem&lt;Person&gt;
 232  *         return p.getValue().getValue().firstNameProperty();
 233  *     }
 234  * });
 235  *
 236  * // or with a lambda expression:
 237  * firstNameCol.setCellValueFactory(p -&gt; p.getValue().getValue().firstNameProperty());}&lt;/pre&gt;
 238  *
 239  * &lt;h3&gt;TreeTableView Selection / Focus APIs&lt;/h3&gt;
 240  * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 241  * {@link SelectionModel} and {@link FocusModel} classes. A TreeTableView has at most
 242  * one instance of each of these classes, available from
 243  * {@link #selectionModelProperty() selectionModel} and
 244  * {@link #focusModelProperty() focusModel} properties, respectively.
 245  * Whilst it is possible to use this API to set a new selection model, in
 246  * most circumstances this is not necessary - the default selection and focus
 247  * models should work in most circumstances.
 248  *
 249  * &lt;p&gt;The default {@link SelectionModel} used when instantiating a TreeTableView is
 250  * an implementation of the {@link MultipleSelectionModel} abstract class.
 251  * However, as noted in the API documentation for
 252  * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 253  * property, the default value is {@link SelectionMode#SINGLE}. To enable
 254  * multiple selection in a default TreeTableView instance, it is therefore necessary
 255  * to do the following:
 256  *
 257  * &lt;pre&gt; {@code treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 258  *
 259  * &lt;h3&gt;Customizing TreeTableView Visuals&lt;/h3&gt;
 260  * &lt;p&gt;The visuals of the TreeTableView can be entirely customized by replacing the
 261  * default {@link #rowFactoryProperty() row factory}. A row factory is used to
 262  * generate {@link TreeTableRow} instances, which are used to represent an entire
 263  * row in the TreeTableView.
 264  *
 265  * &lt;p&gt;In many cases, this is not what is desired however, as it is more commonly
 266  * the case that cells be customized on a per-column basis, not a per-row basis.
 267  * It is therefore important to note that a {@link TreeTableRow} is not a
 268  * {@link TreeTableCell}. A  {@link TreeTableRow} is simply a container for zero or more
 269  * {@link TreeTableCell}, and in most circumstances it is more likely that you&#39;ll
 270  * want to create custom TreeTableCells, rather than TreeTableRows. The primary use case
 271  * for creating custom TreeTableRow instances would most probably be to introduce
 272  * some form of column spanning support.
 273  *
 274  * &lt;p&gt;You can create custom {@link TreeTableCell} instances per column by assigning
 275  * the appropriate function to the TreeTableColumns
 276  * {@link TreeTableColumn#cellFactoryProperty() cell factory} property.
 277  *
 278  * &lt;p&gt;See the {@link Cell} class documentation for a more complete
 279  * description of how to write custom Cells.
 280  *
 281  * &lt;h3&gt;Editing&lt;/h3&gt;
 282  * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 283  * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 284  *
 285  * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 286  * than when a cell is not being edited. This is the responsibility of the
 287  * {@link Cell} implementation being used. For TreeTableView, it is highly
 288  * recommended that editing be
 289  * {@link javafx.scene.control.TreeTableColumn#cellFactoryProperty() per-TreeTableColumn},
 290  * rather than {@link #rowFactoryProperty() per row}, as more often than not
 291  * you want users to edit each column value differently, and this approach allows
 292  * for editors specific to each column. It is your choice whether the cell is
 293  * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 294  * or to switch to a different UI when editing begins (e.g. when a double-click
 295  * is received on a cell).&lt;/p&gt;
 296  *
 297  * &lt;p&gt;To know when editing has been requested on a cell,
 298  * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 299  * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 300  * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 301  * appropriate (e.g. set the text to null and set the graphic to be a
 302  * {@link TextField}). Additionally, you should also override
 303  * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 304  * when the editing concludes. In both cases it is important that you also
 305  * ensure that you call the super method to have the cell perform all duties it
 306  * must do to enter or exit its editing mode.&lt;/p&gt;
 307  *
 308  * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 309  * interested in is how to commit or cancel the editing that is taking place. This is your
 310  * responsibility as the cell factory provider. Your cell implementation will know
 311  * when the editing is over, based on the user input (e.g. when the user presses
 312  * the Enter or ESC keys on their keyboard). When this happens, it is your
 313  * responsibility to call {@link Cell#commitEdit(Object)} or
 314  * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 315  *
 316  * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 317  * TreeTableView, which you can observe by adding an {@link EventHandler} via
 318  * {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 319  * you can also observe edit events for
 320  * {@link TreeTableColumn#setOnEditStart(javafx.event.EventHandler) edit start}
 321  * and {@link TreeTableColumn#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 322  *
 323  * &lt;p&gt;By default the TreeTableColumn edit commit handler is non-null, with a default
 324  * handler that attempts to overwrite the property value for the
 325  * item in the currently-being-edited row. It is able to do this as the
 326  * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 327  * is passed along to the edit commit handler via the
 328  * {@link javafx.scene.control.TreeTableColumn.CellEditEvent CellEditEvent} that is
 329  * fired. It is simply a matter of calling
 330  * {@link javafx.scene.control.TreeTableColumn.CellEditEvent#getNewValue()} to
 331  * retrieve this value.
 332  *
 333  * &lt;p&gt;It is very important to note that if you call
 334  * {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler)} with your own
 335  * {@link EventHandler}, then you will be removing the default handler. Unless
 336  * you then handle the writeback to the property (or the relevant data source),
 337  * nothing will happen. You can work around this by using the
 338  * {@link TreeTableColumn#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 339  * method to add a {@link TreeTableColumn#EDIT_COMMIT_EVENT} {@link EventType} with
 340  * your desired {@link EventHandler} as the second argument. Using this method,
 341  * you will not replace the default implementation, but you will be notified when
 342  * an edit commit has occurred.&lt;/p&gt;
 343  *
 344  * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 345  * Fortunately, JavaFX ships with a number of pre-built cell factories that
 346  * handle all the editing requirements on your behalf. You can find these
 347  * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 348  *
 349  * @see TreeTableColumn
 350  * @see TreeTablePosition
 351  * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView.
 352  * @since JavaFX 8.0
 353  */
 354 @DefaultProperty(&quot;root&quot;)
 355 public class TreeTableView&lt;S&gt; extends Control {
 356 
 357     /***************************************************************************
 358      *                                                                         *
 359      * Constructors                                                            *
 360      *                                                                         *
 361      **************************************************************************/
 362 
 363     /**
 364      * Creates an empty TreeTableView.
 365      *
 366      * &lt;p&gt;Refer to the {@link TreeTableView} class documentation for details on the
 367      * default state of other properties.
 368      */
 369     public TreeTableView() {
 370         this(null);
 371     }
 372 
 373     /**
 374      * Creates a TreeTableView with the provided root node.
 375      *
 376      * &lt;p&gt;Refer to the {@link TreeTableView} class documentation for details on the
 377      * default state of other properties.
 378      *
 379      * @param root The node to be the root in this TreeTableView.
 380      */
 381     public TreeTableView(TreeItem&lt;S&gt; root) {
 382         getStyleClass().setAll(DEFAULT_STYLE_CLASS);
 383         setAccessibleRole(AccessibleRole.TREE_TABLE_VIEW);
 384 
 385         setRoot(root);
 386         updateExpandedItemCount(root);
 387 
 388         // install default selection and focus models - it&#39;s unlikely this will be changed
 389         // by many users.
 390         setSelectionModel(new TreeTableViewArrayListSelectionModel&lt;S&gt;(this));
 391         setFocusModel(new TreeTableViewFocusModel&lt;S&gt;(this));
 392 
 393         // we watch the columns list, such that when it changes we can update
 394         // the leaf columns and visible leaf columns lists (which are read-only).
 395         getColumns().addListener(weakColumnsObserver);
 396 
 397         // watch for changes to the sort order list - and when it changes run
 398         // the sort method.
 399         getSortOrder().addListener((ListChangeListener.Change&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; c) -&gt; {
 400             doSort(TableUtil.SortEventType.SORT_ORDER_CHANGE, c);
 401         });
 402 
 403         // We&#39;re watching for changes to the content width such
 404         // that the resize policy can be run if necessary. This comes from
 405         // TreeTableViewSkin.
 406         getProperties().addListener((MapChangeListener&lt;Object, Object&gt;) c -&gt; {
 407             if (c.wasAdded() &amp;&amp; TableView.SET_CONTENT_WIDTH.equals(c.getKey())) {
 408                 if (c.getValueAdded() instanceof Number) {
 409                     setContentWidth((Double) c.getValueAdded());
 410                 }
 411                 getProperties().remove(TableView.SET_CONTENT_WIDTH);
 412             }
 413         });
 414 
 415         isInited = true;
 416     }
 417 
 418 
 419 
 420     /***************************************************************************
 421      *                                                                         *
 422      * Static properties and methods                                           *
 423      *                                                                         *
 424      **************************************************************************/
 425 
 426     /**
 427      * An EventType that indicates some edit event has occurred. It is the parent
 428      * type of all other edit events: {@link #editStartEvent},
 429      *  {@link #editCommitEvent} and {@link #editCancelEvent}.
 430      *
 431      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 432      * @return An EventType that indicates some edit event has occurred
 433      */
 434     @SuppressWarnings(&quot;unchecked&quot;)
 435     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editAnyEvent() {
 436         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_ANY_EVENT;
 437     }
 438     private static final EventType&lt;?&gt; EDIT_ANY_EVENT =
 439             new EventType&lt;&gt;(Event.ANY, &quot;TREE_TABLE_VIEW_EDIT&quot;);
 440 
 441     /**
 442      * An EventType used to indicate that an edit event has started within the
 443      * TreeTableView upon which the event was fired.
 444      *
 445      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 446      * @return An EventType used to indicate that an edit event has started
 447      */
 448     @SuppressWarnings(&quot;unchecked&quot;)
 449     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editStartEvent() {
 450         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_START_EVENT;
 451     }
 452     private static final EventType&lt;?&gt; EDIT_START_EVENT =
 453             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_START&quot;);
 454 
 455     /**
 456      * An EventType used to indicate that an edit event has just been canceled
 457      * within the TreeTableView upon which the event was fired.
 458      *
 459      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 460      * @return An EventType used to indicate that an edit event has just been
 461      *      canceled
 462      */
 463     @SuppressWarnings(&quot;unchecked&quot;)
 464     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editCancelEvent() {
 465         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_CANCEL_EVENT;
 466     }
 467     private static final EventType&lt;?&gt; EDIT_CANCEL_EVENT =
 468             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_CANCEL&quot;);
 469 
 470     /**
 471      * An EventType that is used to indicate that an edit in a TreeTableView has been
 472      * committed. This means that user has made changes to the data of a
 473      * TreeItem, and that the UI should be updated.
 474      *
 475      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 476      * @return An EventType that is used to indicate that an edit in a TreeTableView
 477      *      has been committed
 478      */
 479     @SuppressWarnings(&quot;unchecked&quot;)
 480     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editCommitEvent() {
 481         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_COMMIT_EVENT;
 482     }
 483     private static final EventType&lt;?&gt; EDIT_COMMIT_EVENT =
 484             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_COMMIT&quot;);
 485 
 486     /**
 487      * Returns the number of levels of &#39;indentation&#39; of the given TreeItem,
 488      * based on how many times {@link javafx.scene.control.TreeItem#getParent()}
 489      * can be recursively called. If the TreeItem does not have any parent set,
 490      * the returned value will be zero. For each time getParent() is recursively
 491      * called, the returned value is incremented by one.
 492      *
 493      * &lt;p&gt;&lt;strong&gt;Important note: &lt;/strong&gt;This method is deprecated as it does
 494      * not consider the root node. This means that this method will iterate
 495      * past the root node of the TreeTableView control, if the root node has a parent.
 496      * If this is important, call {@link TreeTableView#getTreeItemLevel(TreeItem)}
 497      * instead.
 498      *
 499      * @param node The TreeItem for which the level is needed.
 500      * @return An integer representing the number of parents above the given node,
 501      *         or -1 if the given TreeItem is null.
 502      * @deprecated This method does not correctly calculate the distance from the
 503      *          given TreeItem to the root of the TreeTableView. As of JavaFX 8.0_20,
 504      *          the proper way to do this is via
 505      *          {@link TreeTableView#getTreeItemLevel(TreeItem)}
 506      */
 507     @Deprecated(since=&quot;8u20&quot;)
 508     public static int getNodeLevel(TreeItem&lt;?&gt; node) {
 509         return TreeView.getNodeLevel(node);
 510     }
 511 
 512     /**
 513      * &lt;p&gt;Very simple resize policy that just resizes the specified column by the
 514      * provided delta and shifts all other columns (to the right of the given column)
 515      * further to the right (when the delta is positive) or to the left (when the
 516      * delta is negative).
 517      *
 518      * &lt;p&gt;It also handles the case where we have nested columns by sharing the new space,
 519      * or subtracting the removed space, evenly between all immediate children columns.
 520      * Of course, the immediate children may themselves be nested, and they would
 521      * then use this policy on their children.
 522      */
 523     public static final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; UNCONSTRAINED_RESIZE_POLICY =
 524             new Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;() {
 525 
 526         @Override public String toString() {
 527             return &quot;unconstrained-resize&quot;;
 528         }
 529 
 530         @Override public Boolean call(TreeTableView.ResizeFeatures prop) {
 531             double result = TableUtil.resize(prop.getColumn(), prop.getDelta());
 532             return Double.compare(result, 0.0) == 0;
 533         }
 534     };
 535 
 536     /**
 537      * &lt;p&gt;Simple policy that ensures the width of all visible leaf columns in
 538      * this table sum up to equal the width of the table itself.
 539      *
 540      * &lt;p&gt;When the user resizes a column width with this policy, the table automatically
 541      * adjusts the width of the right hand side columns. When the user increases a
 542      * column width, the table decreases the width of the rightmost column until it
 543      * reaches its minimum width. Then it decreases the width of the second
 544      * rightmost column until it reaches minimum width and so on. When all right
 545      * hand side columns reach minimum size, the user cannot increase the size of
 546      * resized column any more.
 547      */
 548     public static final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; CONSTRAINED_RESIZE_POLICY =
 549             new Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;() {
 550 
 551         private boolean isFirstRun = true;
 552 
 553         @Override public String toString() {
 554             return &quot;constrained-resize&quot;;
 555         }
 556 
 557         @Override public Boolean call(TreeTableView.ResizeFeatures prop) {
 558             TreeTableView&lt;?&gt; table = prop.getTable();
 559             List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumns = table.getVisibleLeafColumns();
 560             Boolean result = TableUtil.constrainedResize(prop,
 561                                                isFirstRun,
 562                                                table.contentWidth,
 563                                                visibleLeafColumns);
 564             isFirstRun = ! isFirstRun ? false : ! result;
 565             return result;
 566         }
 567     };
 568 
 569     /**
 570      * The default {@link #sortPolicyProperty() sort policy} that this TreeTableView
 571      * will use if no other policy is specified. The sort policy is a simple
 572      * {@link Callback} that accepts a TreeTableView as the sole argument and expects
 573      * a Boolean response representing whether the sort succeeded or not. A Boolean
 574      * response of true represents success, and a response of false (or null) will
 575      * be considered to represent failure.
 576      */
 577     public static final Callback&lt;TreeTableView, Boolean&gt; DEFAULT_SORT_POLICY = new Callback&lt;TreeTableView, Boolean&gt;() {
 578         @Override public Boolean call(TreeTableView table) {
 579             try {
 580                 TreeItem rootItem = table.getRoot();
 581                 if (rootItem == null) return false;
 582 
 583                 TreeSortMode sortMode = table.getSortMode();
 584                 if (sortMode == null) return false;
 585 
 586                 rootItem.lastSortMode = sortMode;
 587                 rootItem.lastComparator = table.getComparator();
 588                 rootItem.sort();
 589                 return true;
 590             } catch (UnsupportedOperationException e) {
 591                 // TODO might need to support other exception types including:
 592                 // ClassCastException - if the class of the specified element prevents it from being added to this list
 593                 // NullPointerException - if the specified element is null and this list does not permit null elements
 594                 // IllegalArgumentException - if some property of this element prevents it from being added to this list
 595 
 596                 // If we are here the list does not support sorting, so we gracefully
 597                 // fail the sort request and ensure the UI is put back to its previous
 598                 // state. This is handled in the code that calls the sort policy.
 599 
 600                 return false;
 601             }
 602         }
 603     };
 604 
 605 
 606 
 607     /***************************************************************************
 608      *                                                                         *
 609      * Instance Variables                                                      *
 610      *                                                                         *
 611      **************************************************************************/
 612 
 613     // used in the tree item modification event listener. Used by the
 614     // layoutChildren method to determine whether the tree item count should
 615     // be recalculated.
 616     private boolean expandedItemCountDirty = true;
 617 
 618     // Used in the getTreeItem(int row) method to act as a cache.
 619     // See RT-26716 for the justification and performance gains.
 620     private Map&lt;Integer, SoftReference&lt;TreeItem&lt;S&gt;&gt;&gt; treeItemCacheMap = new HashMap&lt;&gt;();
 621 
 622     // this is the only publicly writable list for columns. This represents the
 623     // columns as they are given initially by the developer.
 624     private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = FXCollections.observableArrayList();
 625 
 626     // Finally, as convenience, we also have an observable list that contains
 627     // only the leaf columns that are currently visible.
 628     private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; visibleLeafColumns = FXCollections.observableArrayList();
 629     private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; unmodifiableVisibleLeafColumns = FXCollections.unmodifiableObservableList(visibleLeafColumns);
 630 
 631     // Allows for multiple column sorting based on the order of the TreeTableColumns
 632     // in this observableArrayList. Each TreeTableColumn is responsible for whether it is
 633     // sorted using ascending or descending order.
 634     private ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = FXCollections.observableArrayList();
 635 
 636     // width of VirtualFlow minus the vbar width
 637     // package protected for testing only
 638     double contentWidth;
 639 
 640     // Used to minimise the amount of work performed prior to the table being
 641     // completely initialised. In particular it reduces the amount of column
 642     // resize operations that occur, which slightly improves startup time.
 643     private boolean isInited = false;
 644 
 645 
 646 
 647     /***************************************************************************
 648      *                                                                         *
 649      * Callbacks and Events                                                    *
 650      *                                                                         *
 651      **************************************************************************/
 652 
 653     // we use this to forward events that have bubbled up TreeItem instances
 654     // to the TreeTableViewSkin, to force it to recalculate teh item count and redraw
 655     // if necessary
 656     private final EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; rootEvent = e -&gt; {
 657         // this forces layoutChildren at the next pulse, and therefore
 658         // updates the item count if necessary
 659         EventType&lt;?&gt; eventType = e.getEventType();
 660         boolean match = false;
 661         while (eventType != null) {
 662             if (eventType.equals(TreeItem.&lt;S&gt;expandedItemCountChangeEvent())) {
 663                 match = true;
 664                 break;
 665             }
 666             eventType = eventType.getSuperType();
 667         }
 668 
 669         if (match) {
 670             expandedItemCountDirty = true;
 671             requestLayout();
 672         }
 673     };
 674 
 675     private final ListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt; columnsObserver = new ListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt;() {
 676         @Override public void onChanged(ListChangeListener.Change&lt;? extends TreeTableColumn&lt;S,?&gt;&gt; c) {
 677             final List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getColumns();
 678 
 679             // Fix for RT-39822 - don&#39;t allow the same column to be installed twice
 680             while (c.next()) {
 681                 if (c.wasAdded()) {
 682                     List&lt;TreeTableColumn&lt;S,?&gt;&gt; duplicates = new ArrayList&lt;&gt;();
 683                     for (TreeTableColumn&lt;S,?&gt; addedColumn : c.getAddedSubList()) {
 684                         if (addedColumn == null) continue;
 685 
 686                         int count = 0;
 687                         for (TreeTableColumn&lt;S,?&gt; column : columns) {
 688                             if (addedColumn == column) {
 689                                 count++;
 690                             }
 691                         }
 692 
 693                         if (count &gt; 1) {
 694                             duplicates.add(addedColumn);
 695                         }
 696                     }
 697 
 698                     if (!duplicates.isEmpty()) {
 699                         String titleList = &quot;&quot;;
 700                         for (TreeTableColumn&lt;S,?&gt; dupe : duplicates) {
 701                             titleList += &quot;&#39;&quot; + dupe.getText() + &quot;&#39;, &quot;;
 702                         }
 703                         throw new IllegalStateException(&quot;Duplicate TreeTableColumns detected in TreeTableView columns list with titles &quot; + titleList);
 704                     }
 705                 }
 706             }
 707             c.reset();
 708 
 709             // Fix for RT-15194: Need to remove removed columns from the
 710             // sortOrder list.
 711             List&lt;TreeTableColumn&lt;S,?&gt;&gt; toRemove = new ArrayList&lt;TreeTableColumn&lt;S,?&gt;&gt;();
 712             while (c.next()) {
 713                 final List&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; removed = c.getRemoved();
 714                 final List&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; added = c.getAddedSubList();
 715 
 716                 if (c.wasRemoved()) {
 717                     toRemove.addAll(removed);
 718                     for (TreeTableColumn&lt;S,?&gt; tc : removed) {
 719                         tc.setTreeTableView(null);
 720                     }
 721                 }
 722 
 723                 if (c.wasAdded()) {
 724                     toRemove.removeAll(added);
 725                     for (TreeTableColumn&lt;S,?&gt; tc : added) {
 726                         tc.setTreeTableView(TreeTableView.this);
 727                     }
 728                 }
 729 
 730                 // set up listeners
 731                 TableUtil.removeColumnsListener(removed, weakColumnsObserver);
 732                 TableUtil.addColumnsListener(added, weakColumnsObserver);
 733 
 734                 TableUtil.removeTableColumnListener(c.getRemoved(),
 735                         weakColumnVisibleObserver,
 736                         weakColumnSortableObserver,
 737                         weakColumnSortTypeObserver,
 738                         weakColumnComparatorObserver);
 739                 TableUtil.addTableColumnListener(c.getAddedSubList(),
 740                         weakColumnVisibleObserver,
 741                         weakColumnSortableObserver,
 742                         weakColumnSortTypeObserver,
 743                         weakColumnComparatorObserver);
 744             }
 745 
 746             // We don&#39;t maintain a bind for leafColumns, we simply call this update
 747             // function behind the scenes in the appropriate places.
 748             updateVisibleLeafColumns();
 749 
 750             sortOrder.removeAll(toRemove);
 751 
 752             // Fix for RT-38892.
 753             final TreeTableViewFocusModel&lt;S&gt; fm = getFocusModel();
 754             final TreeTableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
 755             c.reset();
 756 
 757             // we need to collect together all removed and all added columns, because
 758             // the code below works on the actually removed columns. If we perform
 759             // the code within this while loop, we&#39;ll be deselecting columns that
 760             // should be deselected (because they have just moved place, for example).
 761             List&lt;TreeTableColumn&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;();
 762             List&lt;TreeTableColumn&lt;S,?&gt;&gt; added = new ArrayList&lt;&gt;();
 763             while (c.next()) {
 764                 if (c.wasRemoved()) {
 765                     removed.addAll(c.getRemoved());
 766                 }
 767                 if (c.wasAdded()) {
 768                     added.addAll(c.getAddedSubList());
 769                 }
 770             }
 771             removed.removeAll(added);
 772 
 773 
 774             // Fix for focus - we simply move focus to a cell to the left
 775             // of the focused cell if the focused cell was located within
 776             // a column that has been removed.
 777             if (fm != null) {
 778                 TreeTablePosition&lt;S, ?&gt; focusedCell = fm.getFocusedCell();
 779                 boolean match = false;
 780                 for (TreeTableColumn&lt;S, ?&gt; tc : removed) {
 781                     match = focusedCell != null &amp;&amp; focusedCell.getTableColumn() == tc;
 782                     if (match) {
 783                         break;
 784                     }
 785                 }
 786 
 787                 if (match) {
 788                     int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(focusedCell.getTableColumn(), 0);
 789                     int newFocusColumnIndex =
 790                             matchingColumnIndex == 0 ? 0 :
 791                                     Math.min(getVisibleLeafColumns().size() - 1, matchingColumnIndex - 1);
 792                     fm.focus(focusedCell.getRow(), getVisibleLeafColumn(newFocusColumnIndex));
 793                 }
 794             }
 795 
 796             // Fix for selection - we remove selection from all cells that
 797             // were within the removed column.
 798             if (sm != null) {
 799                 List&lt;TreeTablePosition&gt; selectedCells = new ArrayList&lt;&gt;(sm.getSelectedCells());
 800                 for (TreeTablePosition selectedCell : selectedCells) {
 801                     boolean match = false;
 802                     for (TreeTableColumn&lt;S, ?&gt; tc : removed) {
 803                         match = selectedCell != null &amp;&amp; selectedCell.getTableColumn() == tc;
 804                         if (match) break;
 805                     }
 806 
 807                     if (match) {
 808                         // we can&#39;t just use the selectedCell.getTableColumn(), as that
 809                         // column no longer exists and therefore its index is not correct.
 810                         int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(selectedCell.getTableColumn(), -1);
 811                         if (matchingColumnIndex == -1) continue;
 812 
 813                         if (sm instanceof TreeTableViewArrayListSelectionModel) {
 814                             // Also, because the table column no longer exists in the columns
 815                             // list at this point, we can&#39;t just call:
 816                             // sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
 817                             // as the tableColumn would map to an index of -1, which means that
 818                             // selection will not be cleared. Instead, we have to create
 819                             // a new TablePosition with a fixed column index and use that.
 820                             TreeTablePosition&lt;S,?&gt; fixedTablePosition =
 821                                     new TreeTablePosition&lt;S,Object&gt;(TreeTableView.this,
 822                                             selectedCell.getRow(),
 823                                             selectedCell.getTableColumn());
 824                             fixedTablePosition.fixedColumnIndex = matchingColumnIndex;
 825 
 826                             ((TreeTableViewArrayListSelectionModel)sm).clearSelection(fixedTablePosition);
 827                         } else {
 828                             sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
 829                         }
 830                     }
 831                 }
 832             }
 833 
 834 
 835             // update the lastKnownColumnIndex map
 836             lastKnownColumnIndex.clear();
 837             for (TreeTableColumn&lt;S,?&gt; tc : getColumns()) {
 838                 int index = getVisibleLeafIndex(tc);
 839                 if (index &gt; -1) {
 840                     lastKnownColumnIndex.put(tc, index);
 841                 }
 842             }
 843         }
 844     };
 845 
 846     private final WeakHashMap&lt;TreeTableColumn&lt;S,?&gt;, Integer&gt; lastKnownColumnIndex = new WeakHashMap&lt;&gt;();
 847 
 848     private final InvalidationListener columnVisibleObserver = valueModel -&gt; {
 849         updateVisibleLeafColumns();
 850     };
 851 
 852     private final InvalidationListener columnSortableObserver = valueModel -&gt; {
 853         TreeTableColumn col = (TreeTableColumn) ((BooleanProperty)valueModel).getBean();
 854         if (! getSortOrder().contains(col)) return;
 855         doSort(TableUtil.SortEventType.COLUMN_SORTABLE_CHANGE, col);
 856     };
 857 
 858     private final InvalidationListener columnSortTypeObserver = valueModel -&gt; {
 859         TreeTableColumn col = (TreeTableColumn) ((ObjectProperty)valueModel).getBean();
 860         if (! getSortOrder().contains(col)) return;
 861         doSort(TableUtil.SortEventType.COLUMN_SORT_TYPE_CHANGE, col);
 862     };
 863 
 864     private final InvalidationListener columnComparatorObserver = valueModel -&gt; {
 865         TreeTableColumn col = (TreeTableColumn) ((SimpleObjectProperty)valueModel).getBean();
 866         if (! getSortOrder().contains(col)) return;
 867         doSort(TableUtil.SortEventType.COLUMN_COMPARATOR_CHANGE, col);
 868     };
 869 
 870     /* proxy pseudo-class state change from selectionModel&#39;s cellSelectionEnabledProperty */
 871     private final InvalidationListener cellSelectionModelInvalidationListener = o -&gt; {
 872         boolean isCellSelection = ((BooleanProperty)o).get();
 873         pseudoClassStateChanged(PSEUDO_CLASS_CELL_SELECTION,  isCellSelection);
 874         pseudoClassStateChanged(PSEUDO_CLASS_ROW_SELECTION,  !isCellSelection);
 875     };
 876 
 877     private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakRootEventListener;
 878 
 879     private final WeakInvalidationListener weakColumnVisibleObserver =
 880             new WeakInvalidationListener(columnVisibleObserver);
 881 
 882     private final WeakInvalidationListener weakColumnSortableObserver =
 883             new WeakInvalidationListener(columnSortableObserver);
 884 
 885     private final WeakInvalidationListener weakColumnSortTypeObserver =
 886             new WeakInvalidationListener(columnSortTypeObserver);
 887 
 888     private final WeakInvalidationListener weakColumnComparatorObserver =
 889             new WeakInvalidationListener(columnComparatorObserver);
 890 
 891     private final WeakListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt; weakColumnsObserver =
 892             new WeakListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt;(columnsObserver);
 893 
 894     private final WeakInvalidationListener weakCellSelectionModelInvalidationListener =
 895             new WeakInvalidationListener(cellSelectionModelInvalidationListener);
 896 
 897 
 898 
 899     /***************************************************************************
 900      *                                                                         *
 901      * Properties                                                              *
 902      *                                                                         *
 903      **************************************************************************/
 904 
 905     // --- Root
 906     private ObjectProperty&lt;TreeItem&lt;S&gt;&gt; root = new SimpleObjectProperty&lt;TreeItem&lt;S&gt;&gt;(this, &quot;root&quot;) {
 907         private WeakReference&lt;TreeItem&lt;S&gt;&gt; weakOldItem;
 908 
 909         @Override protected void invalidated() {
 910             TreeItem&lt;S&gt; oldTreeItem = weakOldItem == null ? null : weakOldItem.get();
 911             if (oldTreeItem != null &amp;&amp; weakRootEventListener != null) {
 912                 oldTreeItem.removeEventHandler(TreeItem.&lt;S&gt;treeNotificationEvent(), weakRootEventListener);
 913             }
 914 
 915             TreeItem&lt;S&gt; root = getRoot();
 916             if (root != null) {
 917                 weakRootEventListener = new WeakEventHandler&lt;&gt;(rootEvent);
 918                 getRoot().addEventHandler(TreeItem.&lt;S&gt;treeNotificationEvent(), weakRootEventListener);
 919                 weakOldItem = new WeakReference&lt;&gt;(root);
 920             }
 921 
 922             // Fix for RT-35763
 923             getSortOrder().clear();
 924 
 925             expandedItemCountDirty = true;
 926             updateRootExpanded();
 927         }
 928     };
 929 
 930     /**
 931      * Sets the root node in this TreeTableView. See the {@link TreeItem} class level
 932      * documentation for more details.
 933      *
 934      * @param value The {@link TreeItem} that will be placed at the root of the
 935      *      TreeTableView.
 936      */
 937     public final void setRoot(TreeItem&lt;S&gt; value) {
 938         rootProperty().set(value);
 939     }
 940 
 941     /**
 942      * Returns the current root node of this TreeTableView, or null if no root node
 943      * is specified.
 944      * @return The current root node, or null if no root node exists.
 945      */
 946     public final TreeItem&lt;S&gt; getRoot() {
 947         return root == null ? null : root.get();
 948     }
 949 
 950     /**
 951      * Property representing the root node of the TreeTableView.
 952      * @return the root property
 953      */
 954     public final ObjectProperty&lt;TreeItem&lt;S&gt;&gt; rootProperty() {
 955         return root;
 956     }
 957 
 958 
 959 
 960     // --- Show Root
 961     private BooleanProperty showRoot;
 962 
 963     /**
 964      * Specifies whether the root {@code TreeItem} should be shown within this
 965      * TreeTableView.
 966      *
 967      * @param value If true, the root TreeItem will be shown, and if false it
 968      *      will be hidden.
 969      */
 970     public final void setShowRoot(boolean value) {
 971         showRootProperty().set(value);
 972     }
 973 
 974     /**
 975      * Returns true if the root of the TreeTableView should be shown, and false if
 976      * it should not. By default, the root TreeItem is visible in the TreeTableView.
 977      * @return true if the root of the TreeTableView should be shown
 978      */
 979     public final boolean isShowRoot() {
 980         return showRoot == null ? true : showRoot.get();
 981     }
 982 
 983     /**
 984      * Property that represents whether or not the TreeTableView root node is visible.
 985      * @return the show root property
 986      */
 987     public final BooleanProperty showRootProperty() {
 988         if (showRoot == null) {
 989             showRoot = new SimpleBooleanProperty(this, &quot;showRoot&quot;, true) {
 990                 @Override protected void invalidated() {
 991                     updateRootExpanded();
 992                     updateExpandedItemCount(getRoot());
 993                 }
 994             };
 995         }
 996         return showRoot;
 997     }
 998 
 999 
1000 
1001     // --- Tree Column
1002     private ObjectProperty&lt;TreeTableColumn&lt;S,?&gt;&gt; treeColumn;
1003     /**
1004      * Property that represents which column should have the disclosure node
1005      * shown in it (that is, the column with the arrow). By default this will be
1006      * the left-most column if this property is null, otherwise it will be the
1007      * specified column assuming it is non-null and contained within the
1008      * {@link #getVisibleLeafColumns() visible leaf columns} list.
1009      * @return the tree column property
1010      */
1011     public final ObjectProperty&lt;TreeTableColumn&lt;S,?&gt;&gt; treeColumnProperty() {
1012         if (treeColumn == null) {
1013             treeColumn = new SimpleObjectProperty&lt;&gt;(this, &quot;treeColumn&quot;, null);
1014         }
1015         return treeColumn;
1016     }
1017     public final void setTreeColumn(TreeTableColumn&lt;S,?&gt; value) {
1018         treeColumnProperty().set(value);
1019     }
1020     public final TreeTableColumn&lt;S,?&gt; getTreeColumn() {
1021         return treeColumn == null ? null : treeColumn.get();
1022     }
1023 
1024 
1025 
1026     // --- Selection Model
1027     private ObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt; selectionModel;
1028 
1029     /**
1030      * Sets the {@link MultipleSelectionModel} to be used in the TreeTableView.
1031      * Despite a TreeTableView requiring a &lt;code&gt;&lt;b&gt;Multiple&lt;/b&gt;SelectionModel&lt;/code&gt;,
1032      * it is possible to configure it to only allow single selection (see
1033      * {@link MultipleSelectionModel#setSelectionMode(javafx.scene.control.SelectionMode)}
1034      * for more information).
1035      * @param value the {@link MultipleSelectionModel} to be used
1036      */
1037     public final void setSelectionModel(TreeTableViewSelectionModel&lt;S&gt; value) {
1038         selectionModelProperty().set(value);
1039     }
1040 
1041     /**
1042      * Returns the currently installed selection model.
1043      * @return the currently installed selection model
1044      */
1045     public final TreeTableViewSelectionModel&lt;S&gt; getSelectionModel() {
1046         return selectionModel == null ? null : selectionModel.get();
1047     }
1048 
1049     /**
1050      * The SelectionModel provides the API through which it is possible
1051      * to select single or multiple items within a TreeTableView, as  well as inspect
1052      * which rows have been selected by the user. Note that it has a generic
1053      * type that must match the type of the TreeTableView itself.
1054      * @return the selection model property
1055      */
1056     public final ObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt; selectionModelProperty() {
1057         if (selectionModel == null) {
1058             selectionModel = new SimpleObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt;(this, &quot;selectionModel&quot;) {
1059 
1060                 TreeTableViewSelectionModel&lt;S&gt; oldValue = null;
1061 
1062                 @Override protected void invalidated() {
1063                     // need to listen to the cellSelectionEnabledProperty
1064                     // in order to set pseudo-class state
1065                     if (oldValue != null) {
1066                         oldValue.cellSelectionEnabledProperty().removeListener(weakCellSelectionModelInvalidationListener);
1067 
1068                         if (oldValue instanceof TreeTableViewArrayListSelectionModel) {
1069                             ((TreeTableViewArrayListSelectionModel)oldValue).dispose();
1070                         }
1071                     }
1072 
1073                     oldValue = get();
1074 
1075                     if (oldValue != null) {
1076                         oldValue.cellSelectionEnabledProperty().addListener(weakCellSelectionModelInvalidationListener);
1077                         // fake invalidation to ensure updated pseudo-class states
1078                         weakCellSelectionModelInvalidationListener.invalidated(oldValue.cellSelectionEnabledProperty());
1079                     }
1080                 }
1081             };
1082         }
1083         return selectionModel;
1084     }
1085 
1086 
1087     // --- Focus Model
1088     private ObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt; focusModel;
1089 
1090     /**
1091      * Sets the {@link FocusModel} to be used in the TreeTableView.
1092      * @param value the {@link FocusModel} to be used
1093      */
1094     public final void setFocusModel(TreeTableViewFocusModel&lt;S&gt; value) {
1095         focusModelProperty().set(value);
1096     }
1097 
1098     /**
1099      * Returns the currently installed {@link FocusModel}.
1100      * @return the currently installed {@link FocusModel}
1101      */
1102     public final TreeTableViewFocusModel&lt;S&gt; getFocusModel() {
1103         return focusModel == null ? null : focusModel.get();
1104     }
1105 
1106     /**
1107      * The FocusModel provides the API through which it is possible
1108      * to control focus on zero or one rows of the TreeTableView. Generally the
1109      * default implementation should be more than sufficient.
1110      * @return the focus model property
1111      */
1112     public final ObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt; focusModelProperty() {
1113         if (focusModel == null) {
1114             focusModel = new SimpleObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt;(this, &quot;focusModel&quot;);
1115         }
1116         return focusModel;
1117     }
1118 
1119 
1120     // --- Tree node count
1121     /**
1122      * &lt;p&gt;Represents the number of tree nodes presently able to be visible in the
1123      * TreeTableView. This is essentially the count of all expanded tree items, and
1124      * their children.
1125      *
1126      * &lt;p&gt;For example, if just the root node is visible, the expandedItemCount will
1127      * be one. If the root had three children and the root was expanded, the value
1128      * will be four.
1129      */
1130     private ReadOnlyIntegerWrapper expandedItemCount = new ReadOnlyIntegerWrapper(this, &quot;expandedItemCount&quot;, 0);
1131     public final ReadOnlyIntegerProperty expandedItemCountProperty() {
1132         return expandedItemCount.getReadOnlyProperty();
1133     }
1134     private void setExpandedItemCount(int value) {
1135         expandedItemCount.set(value);
1136     }
1137     public final int getExpandedItemCount() {
1138         if (expandedItemCountDirty) {
1139             updateExpandedItemCount(getRoot());
1140         }
1141         return expandedItemCount.get();
1142     }
1143 
1144 
1145     // --- Editable
1146     private BooleanProperty editable;
1147     public final void setEditable(boolean value) {
1148         editableProperty().set(value);
1149     }
1150     public final boolean isEditable() {
1151         return editable == null ? false : editable.get();
1152     }
1153     /**
1154      * Specifies whether this TreeTableView is editable - only if the TreeTableView and
1155      * the TreeCells within it are both editable will a TreeCell be able to go
1156      * into their editing state.
1157      * @return the editable property
1158      */
1159     public final BooleanProperty editableProperty() {
1160         if (editable == null) {
1161             editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
1162         }
1163         return editable;
1164     }
1165 
1166 
1167     // --- Editing Cell
1168     private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCell;
1169     private void setEditingCell(TreeTablePosition&lt;S,?&gt; value) {
1170         editingCellPropertyImpl().set(value);
1171     }
1172     public final TreeTablePosition&lt;S,?&gt; getEditingCell() {
1173         return editingCell == null ? null : editingCell.get();
1174     }
1175 
1176     /**
1177      * Represents the current cell being edited, or null if
1178      * there is no cell being edited.
1179      * @return the editing cell property
1180      */
1181     public final ReadOnlyObjectProperty&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCellProperty() {
1182         return editingCellPropertyImpl().getReadOnlyProperty();
1183     }
1184 
1185     private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCellPropertyImpl() {
1186         if (editingCell == null) {
1187             editingCell = new ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt;(this, &quot;editingCell&quot;);
1188         }
1189         return editingCell;
1190     }
1191 
1192 
1193     // --- Table menu button visible
1194     private BooleanProperty tableMenuButtonVisible;
1195     /**
1196      * This controls whether a menu button is available when the user clicks
1197      * in a designated space within the TableView, within which is a radio menu
1198      * item for each TreeTableColumn in this table. This menu allows for the user to
1199      * show and hide all TreeTableColumns easily.
1200      * @return the table menu button visible property
1201      */
1202     public final BooleanProperty tableMenuButtonVisibleProperty() {
1203         if (tableMenuButtonVisible == null) {
1204             tableMenuButtonVisible = new SimpleBooleanProperty(this, &quot;tableMenuButtonVisible&quot;);
1205         }
1206         return tableMenuButtonVisible;
1207     }
1208     public final void setTableMenuButtonVisible (boolean value) {
1209         tableMenuButtonVisibleProperty().set(value);
1210     }
1211     public final boolean isTableMenuButtonVisible() {
1212         return tableMenuButtonVisible == null ? false : tableMenuButtonVisible.get();
1213     }
1214 
1215 
1216     // --- Column Resize Policy
1217     private ObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt; columnResizePolicy;
1218     public final void setColumnResizePolicy(Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; callback) {
1219         columnResizePolicyProperty().set(callback);
1220     }
1221     public final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; getColumnResizePolicy() {
1222         return columnResizePolicy == null ? UNCONSTRAINED_RESIZE_POLICY : columnResizePolicy.get();
1223     }
1224 
1225     /**
1226      * This is the function called when the user completes a column-resize
1227      * operation. The two most common policies are available as static functions
1228      * in the TableView class: {@link #UNCONSTRAINED_RESIZE_POLICY} and
1229      * {@link #CONSTRAINED_RESIZE_POLICY}.
1230      * @return the column resize policy property
1231      */
1232     public final ObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt; columnResizePolicyProperty() {
1233         if (columnResizePolicy == null) {
1234             columnResizePolicy = new SimpleObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt;(this, &quot;columnResizePolicy&quot;, UNCONSTRAINED_RESIZE_POLICY) {
1235                 private Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; oldPolicy;
1236 
1237                 @Override protected void invalidated() {
1238                     if (isInited) {
1239                         get().call(new TreeTableView.ResizeFeatures(TreeTableView.this, null, 0.0));
1240 
1241                         if (oldPolicy != null) {
1242                             PseudoClass state = PseudoClass.getPseudoClass(oldPolicy.toString());
1243                             pseudoClassStateChanged(state, false);
1244                         }
1245                         if (get() != null) {
1246                             PseudoClass state = PseudoClass.getPseudoClass(get().toString());
1247                             pseudoClassStateChanged(state, true);
1248                         }
1249                         oldPolicy = get();
1250                     }
1251                 }
1252             };
1253         }
1254         return columnResizePolicy;
1255     }
1256 
1257 
1258     // --- Row Factory
1259     private ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt; rowFactory;
1260 
1261     /**
1262      * A function which produces a TreeTableRow. The system is responsible for
1263      * reusing TreeTableRows. Return from this function a TreeTableRow which
1264      * might be usable for representing a single row in a TableView.
1265      * &lt;p&gt;
1266      * Note that a TreeTableRow is &lt;b&gt;not&lt;/b&gt; a TableCell. A TreeTableRow is
1267      * simply a container for a TableCell, and in most circumstances it is more
1268      * likely that you&#39;ll want to create custom TableCells, rather than
1269      * TreeTableRows. The primary use case for creating custom TreeTableRow
1270      * instances would most probably be to introduce some form of column
1271      * spanning support.
1272      * &lt;p&gt;
1273      * You can create custom TableCell instances per column by assigning the
1274      * appropriate function to the cellFactory property in the TreeTableColumn class.
1275      * @return the row factory property
1276      */
1277     public final ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt; rowFactoryProperty() {
1278         if (rowFactory == null) {
1279             rowFactory = new SimpleObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt;(this, &quot;rowFactory&quot;);
1280         }
1281         return rowFactory;
1282     }
1283     public final void setRowFactory(Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt; value) {
1284         rowFactoryProperty().set(value);
1285     }
1286     public final Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt; getRowFactory() {
1287         return rowFactory == null ? null : rowFactory.get();
1288     }
1289 
1290 
1291     // --- Placeholder Node
1292     private ObjectProperty&lt;Node&gt; placeholder;
1293     /**
1294      * This Node is shown to the user when the table has no content to show.
1295      * This may be the case because the table model has no data in the first
1296      * place, that a filter has been applied to the table model, resulting
1297      * in there being nothing to show the user, or that there are no currently
1298      * visible columns.
1299      * @return the placeholder property
1300      */
1301     public final ObjectProperty&lt;Node&gt; placeholderProperty() {
1302         if (placeholder == null) {
1303             placeholder = new SimpleObjectProperty&lt;Node&gt;(this, &quot;placeholder&quot;);
1304         }
1305         return placeholder;
1306     }
1307     public final void setPlaceholder(Node value) {
1308         placeholderProperty().set(value);
1309     }
1310     public final Node getPlaceholder() {
1311         return placeholder == null ? null : placeholder.get();
1312     }
1313 
1314 
1315     // --- Fixed cell size
1316     private DoubleProperty fixedCellSize;
1317 
1318     /**
1319      * Sets the new fixed cell size for this control. Any value greater than
1320      * zero will enable fixed cell size mode, whereas a zero or negative value
1321      * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
1322      * mode.
1323      *
1324      * @param value The new fixed cell size value, or a value less than or equal
1325      *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
1326      * @since JavaFX 8.0
1327      */
1328     public final void setFixedCellSize(double value) {
1329         fixedCellSizeProperty().set(value);
1330     }
1331 
1332     /**
1333      * Returns the fixed cell size value. A value less than or equal to zero is
1334      * used to represent that fixed cell size mode is disabled, and a value
1335      * greater than zero represents the size of all cells in this control.
1336      *
1337      * @return A double representing the fixed cell size of this control, or a
1338      *      value less than or equal to zero if fixed cell size mode is disabled.
1339      * @since JavaFX 8.0
1340      */
1341     public final double getFixedCellSize() {
1342         return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
1343     }
1344     /**
1345      * Specifies whether this control has cells that are a fixed height (of the
1346      * specified value). If this value is less than or equal to zero,
1347      * then all cells are individually sized and positioned. This is a slow
1348      * operation. Therefore, when performance matters and developers are not
1349      * dependent on variable cell sizes it is a good idea to set the fixed cell
1350      * size value. Generally cells are around 24px, so setting a fixed cell size
1351      * of 24 is likely to result in very little difference in visuals, but a
1352      * improvement to performance.
1353      *
1354      * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
1355      * This should not be confused with the -fx-cell-size property. The difference
1356      * between these two CSS properties is that -fx-cell-size will size all
1357      * cells to the specified size, but it will not enforce that this is the
1358      * only size (thus allowing for variable cell sizes, and preventing the
1359      * performance gains from being possible). Therefore, when performance matters
1360      * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
1361      * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
1362      *
1363      * @return the fixed cell size property
1364      * @since JavaFX 8.0
1365      */
1366     public final DoubleProperty fixedCellSizeProperty() {
1367         if (fixedCellSize == null) {
1368             fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
1369                 @Override public CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt; getCssMetaData() {
1370                     return StyleableProperties.FIXED_CELL_SIZE;
1371                 }
1372 
1373                 @Override public Object getBean() {
1374                     return TreeTableView.this;
1375                 }
1376 
1377                 @Override public String getName() {
1378                     return &quot;fixedCellSize&quot;;
1379                 }
1380             };
1381         }
1382         return fixedCellSize;
1383     }
1384 
1385 
1386     // --- SortMode
1387     /**
1388      * Specifies the sort mode to use when sorting the contents of this TreeTableView,
1389      * should any columns be specified in the {@link #getSortOrder() sort order}
1390      * list.
1391      */
1392     private ObjectProperty&lt;TreeSortMode&gt; sortMode;
1393     public final ObjectProperty&lt;TreeSortMode&gt; sortModeProperty() {
1394         if (sortMode == null) {
1395             sortMode = new SimpleObjectProperty&lt;&gt;(this, &quot;sortMode&quot;, TreeSortMode.ALL_DESCENDANTS);
1396         }
1397         return sortMode;
1398     }
1399     public final void setSortMode(TreeSortMode value) {
1400         sortModeProperty().set(value);
1401     }
1402     public final TreeSortMode getSortMode() {
1403         return sortMode == null ? TreeSortMode.ALL_DESCENDANTS : sortMode.get();
1404     }
1405 
1406 
1407     // --- Comparator (built via sortOrder list, so read-only)
1408     /**
1409      * The comparator property is a read-only property that is representative of the
1410      * current state of the {@link #getSortOrder() sort order} list. The sort
1411      * order list contains the columns that have been added to it either programmatically
1412      * or via a user clicking on the headers themselves.
1413      */
1414     private ReadOnlyObjectWrapper&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparator;
1415     private void setComparator(Comparator&lt;TreeItem&lt;S&gt;&gt; value) {
1416         comparatorPropertyImpl().set(value);
1417     }
1418     public final Comparator&lt;TreeItem&lt;S&gt;&gt; getComparator() {
1419         return comparator == null ? null : comparator.get();
1420     }
1421     public final ReadOnlyObjectProperty&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparatorProperty() {
1422         return comparatorPropertyImpl().getReadOnlyProperty();
1423     }
1424     private ReadOnlyObjectWrapper&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparatorPropertyImpl() {
1425         if (comparator == null) {
1426             comparator = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;comparator&quot;);
1427         }
1428         return comparator;
1429     }
1430 
1431 
1432     // --- sortPolicy
1433     /**
1434      * The sort policy specifies how sorting in this TreeTableView should be performed.
1435      * For example, a basic sort policy may just recursively sort the children of
1436      * the root tree item, whereas a more advanced sort policy may call to a
1437      * database to perform the necessary sorting on the server-side.
1438      *
1439      * &lt;p&gt;TreeTableView ships with a {@link TableView#DEFAULT_SORT_POLICY default
1440      * sort policy} that does precisely as mentioned above: it simply attempts
1441      * to sort the tree hierarchy in-place.
1442      *
1443      * &lt;p&gt;It is recommended that rather than override the {@link TreeTableView#sort() sort}
1444      * method that a different sort policy be provided instead.
1445      */
1446     private ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt; sortPolicy;
1447     public final void setSortPolicy(Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; callback) {
1448         sortPolicyProperty().set(callback);
1449     }
1450     @SuppressWarnings(&quot;unchecked&quot;)
1451     public final Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; getSortPolicy() {
1452         return sortPolicy == null ?
1453                 (Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY :
1454                 sortPolicy.get();
1455     }
1456     @SuppressWarnings(&quot;unchecked&quot;)
1457     public final ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt; sortPolicyProperty() {
1458         if (sortPolicy == null) {
1459             sortPolicy = new SimpleObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt;(
1460                     this, &quot;sortPolicy&quot;, (Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY) {
1461                 @Override protected void invalidated() {
1462                     sort();
1463                 }
1464             };
1465         }
1466         return sortPolicy;
1467     }
1468 
1469 
1470     // onSort
1471     /**
1472      * Called when there&#39;s a request to sort the control.
1473      */
1474     private ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt; onSort;
1475 
1476     public void setOnSort(EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; value) {
1477         onSortProperty().set(value);
1478     }
1479 
1480     public EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; getOnSort() {
1481         if( onSort != null ) {
1482             return onSort.get();
1483         }
1484         return null;
1485     }
1486 
1487     public ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt; onSortProperty() {
1488         if( onSort == null ) {
1489             onSort = new ObjectPropertyBase&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt;() {
1490                 @Override protected void invalidated() {
1491                     EventType&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; eventType = SortEvent.sortEvent();
1492                     EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; eventHandler = get();
1493                     setEventHandler(eventType, eventHandler);
1494                 }
1495 
1496                 @Override public Object getBean() {
1497                     return TreeTableView.this;
1498                 }
1499 
1500                 @Override public String getName() {
1501                     return &quot;onSort&quot;;
1502                 }
1503             };
1504         }
1505         return onSort;
1506     }
1507 
1508 
1509 
1510     /***************************************************************************
1511      *                                                                         *
1512      * Public API                                                              *
1513      *                                                                         *
1514      **************************************************************************/
1515 
1516     /** {@inheritDoc} */
1517     @Override protected void layoutChildren() {
1518         if (expandedItemCountDirty) {
1519             updateExpandedItemCount(getRoot());
1520         }
1521 
1522         super.layoutChildren();
1523     }
1524 
1525     /**
1526      * Scrolls the TreeTableView such that the item in the given index is visible to
1527      * the end user.
1528      *
1529      * @param index The index that should be made visible to the user, assuming
1530      *      of course that it is greater than, or equal to 0, and less than the
1531      *      number of the visible items in the TreeTableView.
1532      */
1533     public void scrollTo(int index) {
1534         ControlUtils.scrollToIndex(this, index);
1535     }
1536 
1537     /**
1538      * Called when there&#39;s a request to scroll an index into view using {@link #scrollTo(int)}
1539      */
1540     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;
1541 
1542     public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
1543         onScrollToProperty().set(value);
1544     }
1545 
1546     public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
1547         if( onScrollTo != null ) {
1548             return onScrollTo.get();
1549         }
1550         return null;
1551     }
1552 
1553     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
1554         if( onScrollTo == null ) {
1555             onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
1556                 @Override protected void invalidated() {
1557                     setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
1558                 }
1559 
1560                 @Override public Object getBean() {
1561                     return TreeTableView.this;
1562                 }
1563 
1564                 @Override public String getName() {
1565                     return &quot;onScrollTo&quot;;
1566                 }
1567             };
1568         }
1569         return onScrollTo;
1570     }
1571 
1572     /**
1573      * Scrolls the TreeTableView so that the given column is visible within the viewport.
1574      * @param column The column that should be visible to the user.
1575      */
1576     public void scrollToColumn(TreeTableColumn&lt;S, ?&gt; column) {
1577         ControlUtils.scrollToColumn(this, column);
1578     }
1579 
1580     /**
1581      * Scrolls the TreeTableView so that the given index is visible within the viewport.
1582      * @param columnIndex The index of a column that should be visible to the user.
1583      */
1584     public void scrollToColumnIndex(int columnIndex) {
1585         if( getColumns() != null ) {
1586             ControlUtils.scrollToColumn(this, getColumns().get(columnIndex));
1587         }
1588     }
1589 
1590     /**
1591      * Called when there&#39;s a request to scroll a column into view using {@link #scrollToColumn(TreeTableColumn)}
1592      * or {@link #scrollToColumnIndex(int)}
1593      */
1594     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumn;
1595 
1596     public void setOnScrollToColumn(EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; value) {
1597         onScrollToColumnProperty().set(value);
1598     }
1599 
1600     public EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; getOnScrollToColumn() {
1601         if( onScrollToColumn != null ) {
1602             return onScrollToColumn.get();
1603         }
1604         return null;
1605     }
1606 
1607     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumnProperty() {
1608         if( onScrollToColumn == null ) {
1609             onScrollToColumn = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt;() {
1610                 @Override
1611                 protected void invalidated() {
1612                     EventType&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; type = ScrollToEvent.scrollToColumn();
1613                     setEventHandler(type, get());
1614                 }
1615                 @Override
1616                 public Object getBean() {
1617                     return TreeTableView.this;
1618                 }
1619 
1620                 @Override
1621                 public String getName() {
1622                     return &quot;onScrollToColumn&quot;;
1623                 }
1624             };
1625         }
1626         return onScrollToColumn;
1627     }
1628 
1629     /**
1630      * Returns the index position of the given TreeItem, assuming that it is
1631      * currently accessible through the tree hierarchy (most notably, that all
1632      * parent tree items are expanded). If a parent tree item is collapsed,
1633      * the result is that this method will return -1 to indicate that the
1634      * given tree item is not accessible in the tree.
1635      *
1636      * @param item The TreeItem for which the index is sought.
1637      * @return An integer representing the location in the current TreeTableView of the
1638      *      first instance of the given TreeItem, or -1 if it is null or can not
1639      *      be found (for example, if a parent (all the way up to the root) is
1640      *      collapsed).
1641      */
1642     public int getRow(TreeItem&lt;S&gt; item) {
1643         return TreeUtil.getRow(item, getRoot(), expandedItemCountDirty, isShowRoot());
1644     }
1645 
1646     /**
1647      * Returns the TreeItem in the given index, or null if it is out of bounds.
1648      *
1649      * @param row The index of the TreeItem being sought.
1650      * @return The TreeItem in the given index, or null if it is out of bounds.
1651      */
1652     public TreeItem&lt;S&gt; getTreeItem(int row) {
1653         if (row &lt; 0) return null;
1654 
1655         // normalize the requested row based on whether showRoot is set
1656         final int _row = isShowRoot() ? row : (row + 1);
1657 
1658         if (expandedItemCountDirty) {
1659             updateExpandedItemCount(getRoot());
1660         } else {
1661             if (treeItemCacheMap.containsKey(_row)) {
1662                 SoftReference&lt;TreeItem&lt;S&gt;&gt; treeItemRef = treeItemCacheMap.get(_row);
1663                 TreeItem&lt;S&gt; treeItem = treeItemRef.get();
1664                 if (treeItem != null) {
1665                     return treeItem;
1666                 }
1667             }
1668         }
1669 
1670         TreeItem&lt;S&gt; treeItem = TreeUtil.getItem(getRoot(), _row, expandedItemCountDirty);
1671         treeItemCacheMap.put(_row, new SoftReference&lt;&gt;(treeItem));
1672         return treeItem;
1673     }
1674 
1675     /**
1676      * Returns the number of levels of &#39;indentation&#39; of the given TreeItem,
1677      * based on how many times getParent() can be recursively called. If the
1678      * given TreeItem is the root node of this TreeTableView, or if the TreeItem
1679      * does not have any parent set, the returned value will be zero. For each
1680      * time getParent() is recursively called, the returned value is incremented
1681      * by one.
1682      *
1683      * @param node The TreeItem for which the level is needed.
1684      * @return An integer representing the number of parents above the given node,
1685      *         or -1 if the given TreeItem is null.
1686      */
1687     public int getTreeItemLevel(TreeItem&lt;?&gt; node) {
1688         final TreeItem&lt;?&gt; root = getRoot();
1689 
1690         if (node == null) return -1;
1691         if (node == root) return 0;
1692 
1693         int level = 0;
1694         TreeItem&lt;?&gt; parent = node.getParent();
1695         while (parent != null) {
1696             level++;
1697 
1698             if (parent == root) {
1699                 break;
1700             }
1701 
1702             parent = parent.getParent();
1703         }
1704 
1705         return level;
1706     }
1707 
1708     /**
1709      * The TreeTableColumns that are part of this TableView. As the user reorders
1710      * the TableView columns, this list will be updated to reflect the current
1711      * visual ordering.
1712      *
1713      * &lt;p&gt;Note: to display any data in a TableView, there must be at least one
1714      * TreeTableColumn in this ObservableList.&lt;/p&gt;
1715      * @return the table table column
1716      */
1717     public final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getColumns() {
1718         return columns;
1719     }
1720 
1721     /**
1722      * The sortOrder list defines the order in which {@link TreeTableColumn} instances
1723      * are sorted. An empty sortOrder list means that no sorting is being applied
1724      * on the TableView. If the sortOrder list has one TreeTableColumn within it,
1725      * the TableView will be sorted using the
1726      * {@link TreeTableColumn#sortTypeProperty() sortType} and
1727      * {@link TreeTableColumn#comparatorProperty() comparator} properties of this
1728      * TreeTableColumn (assuming
1729      * {@link TreeTableColumn#sortableProperty() TreeTableColumn.sortable} is true).
1730      * If the sortOrder list contains multiple TreeTableColumn instances, then
1731      * the TableView is firstly sorted based on the properties of the first
1732      * TreeTableColumn. If two elements are considered equal, then the second
1733      * TreeTableColumn in the list is used to determine ordering. This repeats until
1734      * the results from all TreeTableColumn comparators are considered, if necessary.
1735      *
1736      * @return An ObservableList containing zero or more TreeTableColumn instances.
1737      */
1738     public final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getSortOrder() {
1739         return sortOrder;
1740     }
1741 
1742     /**
1743      * Applies the currently installed resize policy against the given column,
1744      * resizing it based on the delta value provided.
1745      * @param column the column
1746      * @param delta the delta
1747      * @return true if column resizing is applied
1748      */
1749     public boolean resizeColumn(TreeTableColumn&lt;S,?&gt; column, double delta) {
1750         if (column == null || Double.compare(delta, 0.0) == 0) return false;
1751 
1752         boolean allowed = getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, column, delta));
1753         if (!allowed) return false;
1754         return true;
1755     }
1756 
1757     /**
1758      * Causes the cell at the given row/column view indexes to switch into
1759      * its editing state, if it is not already in it, and assuming that the
1760      * TableView and column are also editable.
1761      * @param row the row
1762      * @param column the column
1763      */
1764     public void edit(int row, TreeTableColumn&lt;S,?&gt; column) {
1765         if (!isEditable() || (column != null &amp;&amp; ! column.isEditable())) {
1766             return;
1767         }
1768 
1769         if (row &lt; 0 &amp;&amp; column == null) {
1770             setEditingCell(null);
1771         } else {
1772             setEditingCell(new TreeTablePosition&lt;&gt;(this, row, column));
1773         }
1774     }
1775 
1776     /**
1777      * Returns an unmodifiable list containing the currently visible leaf columns.
1778      * @return an unmodifiable list containing the currently visible leaf columns
1779      */
1780     public ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getVisibleLeafColumns() {
1781         return unmodifiableVisibleLeafColumns;
1782     }
1783 
1784     /**
1785      * Returns the position of the given column, relative to all other
1786      * visible leaf columns.
1787      * @param column the column
1788      * @return the position of the given column, relative to all other
1789      * visible leaf columns
1790      */
1791     public int getVisibleLeafIndex(TreeTableColumn&lt;S,?&gt; column) {
1792         return getVisibleLeafColumns().indexOf(column);
1793     }
1794 
1795     /**
1796      * Returns the TreeTableColumn in the given column index, relative to all other
1797      * visible leaf columns.
1798      * @param column the column
1799      * @return the TreeTableColumn in the given column index, relative to all other
1800      * visible leaf columns
1801      */
1802     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1803         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1804         return visibleLeafColumns.get(column);
1805     }
1806 
<a name="2" id="anc2"></a>









1807     /**
1808      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1809      * often than not it is not necessary to call this method directly, as it is
1810      * automatically called when the {@link #getSortOrder() sort order},
1811      * {@link #sortPolicyProperty() sort policy}, or the state of the
1812      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1813      * change. In other words, this method should only be called directly when
1814      * something external changes and a sort is required.
1815      */
1816     public void sort() {
<a name="3" id="anc3"></a>
1817         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1818 
1819         // update the Comparator property
1820         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1821         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1822 
1823         // fire the onSort event and check if it is consumed, if
1824         // so, don&#39;t run the sort
1825         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
1826         fireEvent(sortEvent);
1827         if (sortEvent.isConsumed()) {
1828             // if the sort is consumed we could back out the last action (the code
1829             // is commented out right below), but we don&#39;t as we take it as a
1830             // sign that the developer has decided to handle the event themselves.
1831 
1832             // sortLock = true;
1833             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1834             // sortLock = false;
<a name="4" id="anc4"></a>
1835             return;
1836         }
1837 
1838         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1839         final int itemCount = prevState.size();
1840 
1841         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1842         // sort events - instead we send a single permutation event at the end
1843         // of this method.
1844         getSelectionModel().startAtomic();
1845 
1846         // get the sort policy and run it
1847         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
1848         if (sortPolicy == null) return;
1849         Boolean success = sortPolicy.call(this);
1850 
<a name="5" id="anc5"></a>









1851         getSelectionModel().stopAtomic();
1852 
1853         if (success == null || ! success) {
1854             // the sort was a failure. Need to backout if possible
1855             sortLock = true;
1856             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1857             setComparator(oldComparator);
1858             sortLock = false;
1859         } else {
1860             // sorting was a success, now we possibly fire an event on the
1861             // selection model that the items list has &#39;permutated&#39; to a new ordering
1862 
1863             // FIXME we should support alternative selection model implementations!
1864             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1865                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1866                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1867 
1868                 List&lt;TreeTablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
1869                 for (int i = 0; i &lt; itemCount; i++) {
1870                     TreeTablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
1871                     if (!newState.contains(prevItem)) {
1872                         removed.add(prevItem);
1873                     }
1874                 }
<a name="6" id="anc6"></a><span class="line-removed">1875 </span>
1876                 if (!removed.isEmpty()) {
1877                     // the sort operation effectively permutates the selectedCells list,
1878                     // but we cannot fire a permutation event as we are talking about
1879                     // TreeTablePosition&#39;s changing (which may reside in the same list
1880                     // position before and after the sort). Therefore, we need to fire
1881                     // a single add/remove event to cover the added and removed positions.
1882                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
1883                     sm.fireCustomSelectedCellsListChangeEvent(c);
1884                 }
1885             }
<a name="7" id="anc7"></a>

1886         }
<a name="8" id="anc8"></a>
1887     }
1888 
1889     /**
1890      * Calling {@code refresh()} forces the TreeTableView control to recreate and
1891      * repopulate the cells necessary to populate the visual bounds of the control.
1892      * In other words, this forces the TreeTableView to update what it is showing to
1893      * the user. This is useful in cases where the underlying data source has
1894      * changed in a way that is not observed by the TreeTableView itself.
1895      *
1896      * @since JavaFX 8u60
1897      */
1898     public void refresh() {
1899         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1900     }
1901 
1902 
1903 
1904     /***************************************************************************
1905      *                                                                         *
1906      * Private Implementation                                                  *
1907      *                                                                         *
1908      **************************************************************************/
1909 
1910     private boolean sortLock = false;
1911     private TableUtil.SortEventType lastSortEventType = null;
1912     private Object[] lastSortEventSupportInfo = null;
1913 
1914     private void doSort(final TableUtil.SortEventType sortEventType, final Object... supportInfo) {
1915         if (sortLock) {
1916             return;
1917         }
1918 
1919         this.lastSortEventType = sortEventType;
1920         this.lastSortEventSupportInfo = supportInfo;
1921         sort();
1922         this.lastSortEventType = null;
1923         this.lastSortEventSupportInfo = null;
1924     }
1925 
1926     private void updateExpandedItemCount(TreeItem&lt;S&gt; treeItem) {
1927         setExpandedItemCount(TreeUtil.updateExpandedItemCount(treeItem, expandedItemCountDirty, isShowRoot()));
1928 
1929         if (expandedItemCountDirty) {
1930             // this is a very inefficient thing to do, but for now having a cache
1931             // is better than nothing at all...
1932             treeItemCacheMap.clear();
1933         }
1934 
1935         expandedItemCountDirty = false;
1936     }
1937 
1938     private void updateRootExpanded() {
1939         // if we aren&#39;t showing the root, and the root isn&#39;t expanded, we expand
1940         // it now so that something is shown.
1941         if (!isShowRoot() &amp;&amp; getRoot() != null &amp;&amp; ! getRoot().isExpanded()) {
1942             getRoot().setExpanded(true);
1943         }
1944     }
1945 
1946 
1947     // --- Content width
1948     private void setContentWidth(double contentWidth) {
1949         this.contentWidth = contentWidth;
1950         if (isInited) {
1951             // sometimes the current column resize policy will have to modify the
1952             // column width of all columns in the table if the table width changes,
1953             // so we short-circuit the resize function and just go straight there
1954             // with a null TreeTableColumn, which indicates to the resize policy function
1955             // that it shouldn&#39;t actually do anything specific to one column.
1956             getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, null, 0.0));
1957         }
1958     }
1959 
1960     /**
1961      * Recomputes the currently visible leaf columns in this TableView.
1962      */
1963     private void updateVisibleLeafColumns() {
1964         // update visible leaf columns list
1965         List&lt;TreeTableColumn&lt;S,?&gt;&gt; cols = new ArrayList&lt;TreeTableColumn&lt;S,?&gt;&gt;();
1966         buildVisibleLeafColumns(getColumns(), cols);
1967         visibleLeafColumns.setAll(cols);
1968 
1969         // sometimes the current column resize policy will have to modify the
1970         // column width of all columns in the table if the table width changes,
1971         // so we short-circuit the resize function and just go straight there
1972         // with a null TreeTableColumn, which indicates to the resize policy function
1973         // that it shouldn&#39;t actually do anything specific to one column.
1974         getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, null, 0.0));
1975     }
1976 
1977     private void buildVisibleLeafColumns(List&lt;TreeTableColumn&lt;S,?&gt;&gt; cols, List&lt;TreeTableColumn&lt;S,?&gt;&gt; vlc) {
1978         for (TreeTableColumn&lt;S,?&gt; c : cols) {
1979             if (c == null) continue;
1980 
1981             boolean hasChildren = ! c.getColumns().isEmpty();
1982 
1983             if (hasChildren) {
1984                 buildVisibleLeafColumns(c.getColumns(), vlc);
1985             } else if (c.isVisible()) {
1986                 vlc.add(c);
1987             }
1988         }
1989     }
1990 
1991 
1992 
1993     /***************************************************************************
1994      *                                                                         *
1995      * Stylesheet Handling                                                     *
1996      *                                                                         *
1997      **************************************************************************/
1998 
1999     private static final String DEFAULT_STYLE_CLASS = &quot;tree-table-view&quot;;
2000 
2001     private static final PseudoClass PSEUDO_CLASS_CELL_SELECTION =
2002             PseudoClass.getPseudoClass(&quot;cell-selection&quot;);
2003     private static final PseudoClass PSEUDO_CLASS_ROW_SELECTION =
2004             PseudoClass.getPseudoClass(&quot;row-selection&quot;);
2005 
2006     private static class StyleableProperties {
2007         private static final CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
2008                 new CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
2009                                                      SizeConverter.getInstance(),
2010                                                      Region.USE_COMPUTED_SIZE) {
2011 
2012                     @Override public Double getInitialValue(TreeTableView&lt;?&gt; node) {
2013                         return node.getFixedCellSize();
2014                     }
2015 
2016                     @Override public boolean isSettable(TreeTableView&lt;?&gt; n) {
2017                         return n.fixedCellSize == null || !n.fixedCellSize.isBound();
2018                     }
2019 
2020                     @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(TreeTableView&lt;?&gt; n) {
2021                         return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;) n.fixedCellSizeProperty();
2022                     }
2023                 };
2024 
2025         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
2026         static {
2027             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
2028                     new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
2029             styleables.add(FIXED_CELL_SIZE);
2030             STYLEABLES = Collections.unmodifiableList(styleables);
2031         }
2032     }
2033 
2034     /**
2035      * @return The CssMetaData associated with this class, which may include the
2036      * CssMetaData of its superclasses.
2037      */
2038     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
2039         return StyleableProperties.STYLEABLES;
2040     }
2041 
2042     /**
2043      * {@inheritDoc}
2044      * @since JavaFX 8.0
2045      */
2046     @Override
2047     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
2048         return getClassCssMetaData();
2049     }
2050 
2051     /** {@inheritDoc} */
2052     @Override protected Skin&lt;?&gt; createDefaultSkin() {
2053         return new TreeTableViewSkin&lt;S&gt;(this);
2054     }
2055 
2056 
2057 
2058     /***************************************************************************
2059      *                                                                         *
2060      * Accessibility handling                                                  *
2061      *                                                                         *
2062      **************************************************************************/
2063 
2064     /** {@inheritDoc} */
2065     @Override
2066     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
2067         switch (attribute) {
2068             case ROW_COUNT: return getExpandedItemCount();
2069             case COLUMN_COUNT: return getVisibleLeafColumns().size();
2070 
2071             /*
2072              * TreeTableViewSkin returns TreeTableRows back to TreeTableView.
2073              * TreeTableRowSkin returns TreeTableCells back to TreeTableRow.
2074              */
2075             case SELECTED_ITEMS: {
2076                 @SuppressWarnings(&quot;unchecked&quot;)
2077                 ObservableList&lt;TreeTableRow&lt;S&gt;&gt; rows = (ObservableList&lt;TreeTableRow&lt;S&gt;&gt;)super.queryAccessibleAttribute(attribute, parameters);
2078                 List&lt;Node&gt; selection = new ArrayList&lt;&gt;();
2079                 for (TreeTableRow&lt;S&gt; row : rows) {
2080                     @SuppressWarnings(&quot;unchecked&quot;)
2081                     ObservableList&lt;Node&gt; cells = (ObservableList&lt;Node&gt;)row.queryAccessibleAttribute(attribute, parameters);
2082                     if (cells != null) selection.addAll(cells);
2083                 }
2084                 return FXCollections.observableArrayList(selection);
2085             }
2086             case FOCUS_ITEM: {
2087                 Node row = (Node)super.queryAccessibleAttribute(attribute, parameters);
2088                 if (row == null) return null;
2089                 Node cell = (Node)row.queryAccessibleAttribute(attribute, parameters);
2090                 /* cell equals to null means the row is a placeholder node */
2091                 return cell != null ?  cell : row;
2092             }
2093             case CELL_AT_ROW_COLUMN: {
2094                 @SuppressWarnings(&quot;unchecked&quot;)
2095                 TreeTableRow&lt;S&gt; row = (TreeTableRow&lt;S&gt;)super.queryAccessibleAttribute(attribute, parameters);
2096                 return row != null ? row.queryAccessibleAttribute(attribute, parameters) : null;
2097             }
2098             case MULTIPLE_SELECTION: {
2099                 TreeTableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
2100                 return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
2101             }
2102             default: return super.queryAccessibleAttribute(attribute, parameters);
2103         }
2104     }
2105 
2106     /***************************************************************************
2107      *                                                                         *
2108      * Support Classes                                                         *
2109      *                                                                         *
2110      **************************************************************************/
2111 
2112      /**
2113       * An immutable wrapper class for use in the TableView
2114      * {@link TreeTableView#columnResizePolicyProperty() column resize} functionality.
2115       * @since JavaFX 8.0
2116       */
2117      public static class ResizeFeatures&lt;S&gt; extends ResizeFeaturesBase&lt;TreeItem&lt;S&gt;&gt; {
2118         private TreeTableView&lt;S&gt; treeTable;
2119 
2120         /**
2121          * Creates an instance of this class, with the provided TreeTableView,
2122          * TreeTableColumn and delta values being set and stored in this immutable
2123          * instance.
2124          *
2125          * @param treeTable The TreeTableView upon which the resize operation is occurring.
2126          * @param column The column upon which the resize is occurring, or null
2127          *      if this ResizeFeatures instance is being created as a result of a
2128          *      TreeTableView resize operation.
2129          * @param delta The amount of horizontal space added or removed in the
2130          *      resize operation.
2131          */
2132         public ResizeFeatures(TreeTableView&lt;S&gt; treeTable, TreeTableColumn&lt;S,?&gt; column, Double delta) {
2133             super(column, delta);
2134             this.treeTable = treeTable;
2135         }
2136 
2137         /**
2138          * Returns the column upon which the resize is occurring, or null
2139          * if this ResizeFeatures instance was created as a result of a
2140          * TreeTableView resize operation.
2141          */
2142         @Override public TreeTableColumn&lt;S,?&gt; getColumn() {
2143             return (TreeTableColumn&lt;S,?&gt;) super.getColumn();
2144         }
2145 
2146         /**
2147          * Returns the TreeTableView upon which the resize operation is occurring.
2148          * @return the TreeTableView upon which the resize operation is occurring
2149          */
2150         public TreeTableView&lt;S&gt; getTable() { return treeTable; }
2151     }
2152 
2153 
2154 
2155     /**
2156      * An {@link Event} subclass used specifically in TreeTableView for representing
2157      * edit-related events. It provides additional API to easily access the
2158      * TreeItem that the edit event took place on, as well as the input provided
2159      * by the end user.
2160      *
2161      * @param &lt;S&gt; The type of the input, which is the same type as the TreeTableView
2162      *      itself.
2163      * @since JavaFX 8.0
2164      */
2165     public static class EditEvent&lt;S&gt; extends Event {
2166         private static final long serialVersionUID = -4437033058917528976L;
2167 
2168         /**
2169          * Common supertype for all edit event types.
2170          */
2171         public static final EventType&lt;?&gt; ANY = EDIT_ANY_EVENT;
2172 
2173         private final TreeTableView&lt;S&gt; source;
2174         private final S oldValue;
2175         private final S newValue;
2176         private transient final TreeItem&lt;S&gt; treeItem;
2177 
2178         /**
2179          * Creates a new EditEvent instance to represent an edit event. This
2180          * event is used for {@link #editStartEvent()},
2181          * {@link #editCommitEvent()} and {@link #editCancelEvent()} types.
2182          * @param source the source
2183          * @param eventType the eventType
2184          * @param treeItem the treeItem
2185          * @param oldValue the oldValue
2186          * @param newValue the newValue
2187          */
2188         public EditEvent(TreeTableView&lt;S&gt; source,
2189                          EventType&lt;? extends TreeTableView.EditEvent&gt; eventType,
2190                          TreeItem&lt;S&gt; treeItem, S oldValue, S newValue) {
2191             super(source, Event.NULL_SOURCE_TARGET, eventType);
2192             this.source = source;
2193             this.oldValue = oldValue;
2194             this.newValue = newValue;
2195             this.treeItem = treeItem;
2196         }
2197 
2198         /**
2199          * Returns the TreeTableView upon which the edit took place.
2200          * @return the TreeTableView upon which the edit took place
2201          */
2202         @Override public TreeTableView&lt;S&gt; getSource() {
2203             return source;
2204         }
2205 
2206         /**
2207          * Returns the {@link TreeItem} upon which the edit took place.
2208          * @return the {@link TreeItem} upon which the edit took place
2209          */
2210         public TreeItem&lt;S&gt; getTreeItem() {
2211             return treeItem;
2212         }
2213 
2214         /**
2215          * Returns the new value input into the TreeItem by the end user.
2216          * @return the new value input into the TreeItem by the end user
2217          */
2218         public S getNewValue() {
2219             return newValue;
2220         }
2221 
2222         /**
2223          * Returns the old value that existed in the TreeItem prior to the current
2224          * edit event.
2225          * @return the old value that existed in the TreeItem prior to the current
2226          * edit event
2227          */
2228         public S getOldValue() {
2229             return oldValue;
2230         }
2231     }
2232 
2233 
2234 
2235      /**
2236      * A simple extension of the {@link SelectionModel} abstract class to
2237      * allow for special support for TreeTableView controls.
2238       *
2239      * @since JavaFX 8.0
2240      */
2241     public static abstract class TreeTableViewSelectionModel&lt;S&gt; extends
2242             TableSelectionModel&lt;TreeItem&lt;S&gt;&gt; {
2243 
2244         /***********************************************************************
2245          *                                                                     *
2246          * Private fields                                                      *
2247          *                                                                     *
2248          **********************************************************************/
2249 
2250         private final TreeTableView&lt;S&gt; treeTableView;
2251 
2252 
2253         /***********************************************************************
2254          *                                                                     *
2255          * Constructors                                                        *
2256          *                                                                     *
2257          **********************************************************************/
2258 
2259         /**
2260          * Builds a default TreeTableViewSelectionModel instance with the provided
2261          * TreeTableView.
2262          * @param treeTableView The TreeTableView upon which this selection model should
2263          *      operate.
2264          * @throws NullPointerException TreeTableView can not be null.
2265          */
2266         public TreeTableViewSelectionModel(final TreeTableView&lt;S&gt; treeTableView) {
2267             if (treeTableView == null) {
2268                 throw new NullPointerException(&quot;TreeTableView can not be null&quot;);
2269             }
2270 
2271             this.treeTableView = treeTableView;
2272         }
2273 
2274 
2275 
2276         /***********************************************************************
2277          *                                                                     *
2278          * Abstract API                                                        *
2279          *                                                                     *
2280          **********************************************************************/
2281 
2282          /**
2283          * A read-only ObservableList representing the currently selected cells
2284          * in this TreeTableView. Rather than directly modify this list, please
2285          * use the other methods provided in the TreeTableViewSelectionModel.
2286          * @return a list of selected cells
2287          */
2288         public abstract ObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; getSelectedCells();
2289 
2290 
2291 
2292         /***********************************************************************
2293          *                                                                     *
2294          * Public API                                                          *
2295          *                                                                     *
2296          **********************************************************************/
2297 
2298          /**
2299           * Returns the TreeTableView instance that this selection model is installed in.
2300          * @return the TreeTableView instance that this selection model is installed in
2301           */
2302          public TreeTableView&lt;S&gt; getTreeTableView() {
2303              return treeTableView;
2304          }
2305 
2306          /** {@inheritDoc} */
2307          @Override public TreeItem&lt;S&gt; getModelItem(int index) {
2308              return treeTableView.getTreeItem(index);
2309          }
2310 
2311          /** {@inheritDoc} */
2312          @Override protected int getItemCount() {
2313              return treeTableView.getExpandedItemCount();
2314          }
2315 
2316          /** {@inheritDoc} */
2317          @Override public void focus(int row) {
2318              focus(row, null);
2319          }
2320 
2321          /** {@inheritDoc} */
2322          @Override public int getFocusedIndex() {
2323              return getFocusedCell().getRow();
2324          }
2325 
2326          /** {@inheritDoc} */
2327          @Override public void selectRange(int minRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; minColumn,
2328                                            int maxRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; maxColumn) {
2329              final int minColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)minColumn);
2330              final int maxColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)maxColumn);
2331              for (int _row = minRow; _row &lt;= maxRow; _row++) {
2332                  for (int _col = minColumnIndex; _col &lt;= maxColumnIndex; _col++) {
2333                      select(_row, treeTableView.getVisibleLeafColumn(_col));
2334                  }
2335              }
2336          }
2337 
2338 
2339 
2340         /***********************************************************************
2341          *                                                                     *
2342          * Private implementation                                              *
2343          *                                                                     *
2344          **********************************************************************/
2345 
2346          private void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
2347              focus(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column));
2348          }
2349 
2350          private void focus(TreeTablePosition&lt;S,?&gt; pos) {
2351              if (getTreeTableView().getFocusModel() == null) return;
2352 
2353              getTreeTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
2354          }
2355 
2356          private TreeTablePosition&lt;S,?&gt; getFocusedCell() {
2357              if (treeTableView.getFocusModel() == null) {
2358                  return new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
2359              }
2360              return treeTableView.getFocusModel().getFocusedCell();
2361          }
2362      }
2363 
2364 
2365 
2366     /**
2367      * A primitive selection model implementation, using a List&lt;Integer&gt; to store all
2368      * selected indices.
2369      */
2370     // package for testing
2371     static class TreeTableViewArrayListSelectionModel&lt;S&gt; extends TreeTableViewSelectionModel&lt;S&gt; {
2372 
2373         private final MappingChange.Map&lt;TreeTablePosition&lt;S,?&gt;,Integer&gt; cellToIndicesMap = f -&gt; f.getRow();
2374 
2375         private TreeTableView&lt;S&gt; treeTableView = null;
2376 
2377         /***********************************************************************
2378          *                                                                     *
2379          * Constructors                                                        *
2380          *                                                                     *
2381          **********************************************************************/
2382 
2383         public TreeTableViewArrayListSelectionModel(final TreeTableView&lt;S&gt; treeTableView) {
2384             super(treeTableView);
2385             this.treeTableView = treeTableView;
2386 
2387             this.treeTableView.rootProperty().addListener(weakRootPropertyListener);
2388             this.treeTableView.showRootProperty().addListener(showRootPropertyListener);
2389             updateTreeEventListener(null, treeTableView.getRoot());
2390 
2391             selectedCellsMap = new SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt;(this::fireCustomSelectedCellsListChangeEvent) {
2392                 @Override public boolean isCellSelectionEnabled() {
2393                     return TreeTableViewArrayListSelectionModel.this.isCellSelectionEnabled();
2394                 }
2395             };
2396 
2397             selectedCellsSeq = new ReadOnlyUnbackedObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt;() {
2398                 @Override public TreeTablePosition&lt;S,?&gt; get(int i) {
2399                     return selectedCellsMap.get(i);
2400                 }
2401 
2402                 @Override public int size() {
2403                     return selectedCellsMap.size();
2404                 }
2405             };
2406 //            selectedCellsSeq.addListener((ListChangeListener&lt;? super TreeTablePosition&lt;S,?&gt;&gt;) c -&gt; {
2407 //                ControlUtils.updateSelectedIndices(this, c);
2408 //            });
2409 
2410             updateDefaultSelection();
2411 
2412             cellSelectionEnabledProperty().addListener(o -&gt; {
2413                 updateDefaultSelection();
2414                 TableCellBehaviorBase.setAnchor(treeTableView, getFocusedCell(), true);
2415             });
2416         }
2417 
2418         private void dispose() {
2419             this.treeTableView.rootProperty().removeListener(weakRootPropertyListener);
2420             this.treeTableView.showRootProperty().removeListener(showRootPropertyListener);
2421 
2422             TreeItem&lt;S&gt; root = this.treeTableView.getRoot();
2423             if (root != null) {
2424                 root.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
2425             }
2426         }
2427 
2428         private void updateTreeEventListener(TreeItem&lt;S&gt; oldRoot, TreeItem&lt;S&gt; newRoot) {
2429             if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
2430                 oldRoot.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
2431             }
2432 
2433             if (newRoot != null) {
2434                 weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
2435                 newRoot.addEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
2436             }
2437         }
2438 
2439         private ChangeListener&lt;TreeItem&lt;S&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
2440             updateDefaultSelection();
2441 
2442             updateTreeEventListener(oldValue, newValue);
2443         };
2444 
2445         private InvalidationListener showRootPropertyListener = o -&gt; {
2446             shiftSelection(0, treeTableView.isShowRoot() ? 1 : -1, null);
2447         };
2448 
2449         private EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; treeItemListener = new EventHandler&lt;&gt;() {
2450             @Override public void handle(TreeItem.TreeModificationEvent&lt;S&gt; e) {
2451 
2452                 if (getSelectedIndex() == -1 &amp;&amp; getSelectedItem() == null) return;
2453 
2454                 final TreeItem&lt;S&gt; treeItem = e.getTreeItem();
2455                 if (treeItem == null) return;
2456 
2457                 final int oldSelectedIndex = getSelectedIndex();
2458 
2459                 treeTableView.expandedItemCountDirty = true;
2460 
2461                 // we only shift selection from this row - everything before it
2462                 // is safe. We might change this below based on certain criteria
2463                 int startRow = treeTableView.getRow(treeItem);
2464 
2465                 int shift = 0;
2466                 ListChangeListener.Change&lt;? extends TreeItem&lt;?&gt;&gt; change = e.getChange();
2467                 if (change != null) {
2468                     change.next();
2469                 }
2470 
2471                 do {
2472                     final int addedSize = change == null ? 0 : change.getAddedSize();
2473                     final int removedSize = change == null ? 0 : change.getRemovedSize();
2474 
2475                     if (e.wasExpanded()) {
2476                         // need to shuffle selection by the number of visible children
2477                         shift += treeItem.getExpandedDescendentCount(false) - 1;
2478                         startRow++;
2479                     } else if (e.wasCollapsed()) {
2480                         // remove selection from any child treeItem, and also determine
2481                         // if any child item was selected (in which case the parent
2482                         // takes the selection on collapse)
2483                         treeItem.getExpandedDescendentCount(false);
2484                         final int count = treeItem.previousExpandedDescendentCount;
2485 
2486                         final int selectedIndex = getSelectedIndex();
2487                         final boolean wasPrimarySelectionInChild =
2488                                 selectedIndex &gt;= (startRow + 1) &amp;&amp;
2489                                         selectedIndex &lt; (startRow + count);
2490 
2491                         boolean wasAnyChildSelected = false;
2492                         final boolean isCellSelectionMode = isCellSelectionEnabled();
2493                         ObservableList&lt;TreeTableColumn&lt;S, ?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2494 
2495                         selectedIndices._beginChange();
2496                         final int from = startRow + 1;
2497                         final int to = startRow + count;
2498                         final List&lt;Integer&gt; removed = new ArrayList&lt;&gt;();
2499                         TreeTableColumn&lt;S, ?&gt; selectedColumn = null;
2500                         for (int i = from; i &lt; to; i++) {
2501                             // we have to handle cell selection mode differently than
2502                             // row selection mode. Refer to RT-34103 for the bug report
2503                             // that drove this change, but in short the issue was that
2504                             // when collapsing a branch that had selection, we were
2505                             // always calling isSelected(row), but that always returns
2506                             // false in cell selection mode.
2507                             if (isCellSelectionMode) {
2508                                 for (int column = 0; column &lt; columns.size(); column++) {
2509                                     final TreeTableColumn&lt;S, ?&gt; col = columns.get(column);
2510                                     if (isSelected(i, col)) {
2511                                         wasAnyChildSelected = true;
2512                                         clearSelection(i, col);
2513                                         selectedColumn = col;
2514                                     }
2515                                 }
2516                             } else {
2517                                 if (isSelected(i)) {
2518                                     wasAnyChildSelected = true;
2519                                     removed.add(i);
2520                                 }
2521                             }
2522                         }
2523 
2524                         ControlUtils.reducingChange(selectedIndices, removed);
2525 
2526                         for (int index : removed) {
2527                             startAtomic();
2528                             // we pass in false here to prevent a lookup into the TreeItem, as it is unnecessary
2529                             // and results in JDK-8152396
2530                             clearSelection(new TreeTablePosition&lt;&gt;(treeTableView, index, null, false));
2531                             stopAtomic();
2532                         }
2533                         selectedIndices._endChange();
2534 
2535                         // put selection onto the newly-collapsed tree item
2536                         if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
2537                             select(startRow, selectedColumn);
2538                         }
2539 
2540                         shift += -count + 1;
2541                         startRow++;
2542                     } else if (e.wasPermutated()) {
<a name="9" id="anc9"></a><span class="line-modified">2543                         // General approach:</span>
<span class="line-modified">2544                         //   -- detected a sort has happened</span>
<span class="line-modified">2545                         //   -- Create a permutation lookup map (1)</span>
<span class="line-modified">2546                         //   -- dump all the selected indices into a list (2)</span>
<span class="line-modified">2547                         //   -- create a list containing the new indices (3)</span>
<span class="line-modified">2548                         //   -- for each previously-selected index (4)</span>
<span class="line-modified">2549                         //     -- if index is in the permutation lookup map</span>
<span class="line-modified">2550                         //       -- add the new index to the new indices list</span>
<span class="line-modified">2551                         //   -- Perform batch selection (5)</span>
<span class="line-modified">2552 </span>
<span class="line-modified">2553                         startAtomic();</span>
<span class="line-removed">2554 </span>
<span class="line-removed">2555                         final int offset = startRow + 1;</span>
<span class="line-removed">2556 </span>
<span class="line-removed">2557                         // (1)</span>
<span class="line-removed">2558                         int length = e.getTo() - e.getFrom();</span>
<span class="line-removed">2559                         HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;&gt; (length);</span>
<span class="line-removed">2560                         for (int i = e.getFrom(); i &lt; e.getTo(); i++) {</span>
<span class="line-removed">2561                             pMap.put(i, e.getChange().getPermutation(i));</span>
<span class="line-removed">2562                         }</span>
2563 
<a name="10" id="anc10"></a><span class="line-removed">2564                         // (2)</span>
<span class="line-removed">2565                         List&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedIndices = new ArrayList&lt;&gt;(getSelectedCells());</span>
<span class="line-removed">2566 </span>
<span class="line-removed">2567                         // (3)</span>
<span class="line-removed">2568                         List&lt;TreeTablePosition&lt;S,?&gt;&gt; newIndices = new ArrayList&lt;&gt;(selectedIndices.size());</span>
<span class="line-removed">2569 </span>
<span class="line-removed">2570                         // (4)</span>
2571                         boolean selectionIndicesChanged = false;
<a name="11" id="anc11"></a><span class="line-modified">2572                         for (int i = 0; i &lt; selectedIndices.size(); i++) {</span>
<span class="line-modified">2573                             final TreeTablePosition&lt;S,?&gt; oldIndex = selectedIndices.get(i);</span>
<span class="line-modified">2574                             final int oldRow = oldIndex.getRow() - offset;</span>
<span class="line-modified">2575 </span>
<span class="line-removed">2576                             if (pMap.containsKey(oldRow)) {</span>
<span class="line-removed">2577                                 int newIndex = pMap.get(oldRow) + offset;</span>
<span class="line-removed">2578 </span>
<span class="line-removed">2579                                 selectionIndicesChanged = selectionIndicesChanged || newIndex != oldRow;</span>
<span class="line-removed">2580 </span>
<span class="line-removed">2581                                 newIndices.add(new TreeTablePosition&lt;&gt;(oldIndex.getTreeTableView(), newIndex, oldIndex.getTableColumn()));</span>
<span class="line-removed">2582                             }</span>
<span class="line-removed">2583 </span>
<span class="line-removed">2584                             // check if the root element of this event was selected, so that we can retain it</span>
<span class="line-removed">2585                             if (oldIndex.getRow() == startRow) {</span>
<span class="line-removed">2586                                 newIndices.add(new TreeTablePosition&lt;&gt;(oldIndex.getTreeTableView(), oldIndex.getRow(), oldIndex.getTableColumn()));</span>
2587                             }
<a name="12" id="anc12"></a>
2588                         }
<a name="13" id="anc13"></a><span class="line-removed">2589 </span>
2590                         if (selectionIndicesChanged) {
<a name="14" id="anc14"></a><span class="line-modified">2591                             // (5)</span>
<span class="line-modified">2592                             quietClearSelection();</span>
<span class="line-modified">2593                             stopAtomic();</span>
<span class="line-modified">2594 </span>
<span class="line-modified">2595                             selectedCellsMap.setAll(newIndices);</span>
<span class="line-modified">2596 </span>
<span class="line-modified">2597                             final int offsetOldIndex = oldSelectedIndex - offset;</span>
<span class="line-modified">2598                             if (offsetOldIndex &gt;= 0 &amp;&amp; offsetOldIndex &lt; getItemCount()) {</span>
<span class="line-modified">2599                                 int newIndex = e.getChange().getPermutation(offsetOldIndex);</span>
<span class="line-modified">2600                                 setSelectedIndex(newIndex + offset);</span>
<span class="line-modified">2601                                 focus(newIndex + offset);</span>

2602                             }
<a name="15" id="anc15"></a><span class="line-removed">2603                         } else {</span>
<span class="line-removed">2604                             stopAtomic();</span>
2605                         }
2606                     } else if (e.wasAdded()) {
2607                         // shuffle selection by the number of added items
2608                         shift += treeItem.isExpanded() ? addedSize : 0;
2609 
2610                         // RT-32963: We were taking the startRow from the TreeItem
2611                         // in which the children were added, rather than from the
2612                         // actual position of the new child. This led to selection
2613                         // being moved off the parent TreeItem by mistake.
2614                         // The &#39;if (e.getAddedSize() == 1)&#39; condition here was
2615                         // subsequently commented out due to RT-33894.
2616                         startRow = treeTableView.getRow(e.getChange().getAddedSubList().get(0));
2617 
2618                         TreeTablePosition&lt;S, ?&gt; anchor = TreeTableCellBehavior.getAnchor(treeTableView, null);
2619                         if (anchor != null) {
2620                             boolean isAnchorSelected = isSelected(anchor.getRow(), anchor.getTableColumn());
2621                             if (isAnchorSelected) {
2622                                 TreeTablePosition&lt;S, ?&gt; newAnchor = new TreeTablePosition&lt;&gt;(treeTableView, anchor.getRow() + shift, anchor.getTableColumn());
2623                                 TreeTableCellBehavior.setAnchor(treeTableView, newAnchor, false);
2624                             }
2625                         }
2626                     } else if (e.wasRemoved()) {
2627                         // shuffle selection by the number of removed items
2628                         shift += treeItem.isExpanded() ? -removedSize : 0;
2629 
2630                         // the start row is incorrect - it is _not_ the index of the
2631                         // TreeItem in which the children were removed from (which is
2632                         // what it currently represents). We need to take the &#39;from&#39;
2633                         // value out of the event and make use of that to understand
2634                         // what actually changed inside the children list.
2635                         startRow += e.getFrom() + 1;
2636 
2637                         // whilst we are here, we should check if the removed items
2638                         // are part of the selectedItems list - and remove them
2639                         // from selection if they are (as per RT-15446)
2640                         final List&lt;Integer&gt; selectedIndices = getSelectedIndices();
2641                         final List&lt;TreeItem&lt;S&gt;&gt; selectedItems = getSelectedItems();
2642                         final TreeItem&lt;S&gt; selectedItem = getSelectedItem();
2643                         final List&lt;? extends TreeItem&lt;S&gt;&gt; removedChildren = e.getChange().getRemoved();
2644 
2645                         for (int i = 0; i &lt; selectedIndices.size() &amp;&amp; !selectedItems.isEmpty(); i++) {
2646                             int index = selectedIndices.get(i);
2647                             if (index &gt; selectedItems.size()) break;
2648 
2649                             if (removedChildren.size() == 1 &amp;&amp;
2650                                     selectedItems.size() == 1 &amp;&amp;
2651                                     selectedItem != null &amp;&amp;
2652                                     selectedItem.equals(removedChildren.get(0))) {
2653                                 // Bug fix for RT-28637
2654                                 if (oldSelectedIndex &lt; getItemCount()) {
2655                                     final int previousRow = oldSelectedIndex == 0 ? 0 : oldSelectedIndex - 1;
2656                                     TreeItem&lt;S&gt; newSelectedItem = getModelItem(previousRow);
2657                                     if (!selectedItem.equals(newSelectedItem)) {
2658                                         clearAndSelect(previousRow);
2659                                     }
2660                                 }
2661                             }
2662                         }
2663                     }
2664                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
2665 
<a name="16" id="anc16"></a><span class="line-modified">2666                 shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {</span>
<span class="line-modified">2667                     @Override public Void call(ShiftParams param) {</span>
<span class="line-modified">2668 </span>
<span class="line-modified">2669                         // we make the shifts atomic, as otherwise listeners to</span>
<span class="line-modified">2670                         // the items / indices lists get a lot of intermediate</span>
<span class="line-modified">2671                         // noise. They eventually get the summary event fired</span>
<span class="line-modified">2672                         // from within shiftSelection, so this is ok.</span>
<span class="line-modified">2673                         startAtomic();</span>
<span class="line-modified">2674 </span>
<span class="line-modified">2675                         final int clearIndex = param.getClearIndex();</span>
<span class="line-modified">2676                         final int setIndex = param.getSetIndex();</span>
<span class="line-modified">2677                         TreeTablePosition&lt;S,?&gt; oldTP = null;</span>
<span class="line-modified">2678                         if (clearIndex &gt; -1) {</span>
<span class="line-modified">2679                             for (int i = 0; i &lt; selectedCellsMap.size(); i++) {</span>
<span class="line-modified">2680                                 TreeTablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);</span>
<span class="line-modified">2681                                 if (tp.getRow() == clearIndex) {</span>
<span class="line-modified">2682                                     oldTP = tp;</span>
<span class="line-modified">2683                                     selectedCellsMap.remove(tp);</span>
<span class="line-modified">2684                                 } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {</span>
<span class="line-modified">2685                                     selectedCellsMap.remove(tp);</span>


2686                                 }
2687                             }
<a name="17" id="anc17"></a><span class="line-removed">2688                         }</span>
2689 
<a name="18" id="anc18"></a><span class="line-modified">2690                         if (oldTP != null &amp;&amp; param.isSelected()) {</span>
<span class="line-modified">2691                             TreeTablePosition&lt;S,?&gt; newTP = new TreeTablePosition&lt;&gt;(</span>
<span class="line-modified">2692                                     treeTableView, param.getSetIndex(), oldTP.getTableColumn());</span>
2693 
<a name="19" id="anc19"></a><span class="line-modified">2694                             selectedCellsMap.add(newTP);</span>
<span class="line-modified">2695                         }</span>
2696 
<a name="20" id="anc20"></a><span class="line-modified">2697                         stopAtomic();</span>
2698 
<a name="21" id="anc21"></a><span class="line-modified">2699                         return null;</span>
<span class="line-modified">2700                     }</span>
<span class="line-modified">2701                 });</span>

2702             }
2703         };
2704 
2705         private WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
2706                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
2707 
2708         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
2709 
2710 
2711 
2712         /***********************************************************************
2713          *                                                                     *
2714          * Observable properties (and getters/setters)                         *
2715          *                                                                     *
2716          **********************************************************************/
2717 
2718         // the only &#39;proper&#39; internal data structure, selectedItems and selectedIndices
2719         // are both &#39;read-only and unbacked&#39;.
2720         private final SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsMap;
2721 
2722         private final ReadOnlyUnbackedObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsSeq;
2723         @Override public ObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; getSelectedCells() {
2724             return selectedCellsSeq;
2725         }
2726 
2727 
2728         /***********************************************************************
2729          *                                                                     *
2730          * Internal properties                                                 *
2731          *                                                                     *
2732          **********************************************************************/
2733 
2734 
2735 
2736         /***********************************************************************
2737          *                                                                     *
2738          * Public selection API                                                *
2739          *                                                                     *
2740          **********************************************************************/
2741 
2742         @Override public void clearAndSelect(int row) {
2743             clearAndSelect(row, null);
2744         }
2745 
2746         @Override public void clearAndSelect(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
2747             if (row &lt; 0 || row &gt;= getItemCount()) return;
2748 
2749             final TreeTablePosition&lt;S,?&gt; newTablePosition = new TreeTablePosition&lt;&gt;(getTreeTableView(), row, (TreeTableColumn&lt;S,?&gt;)column);
2750             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
2751 
2752             // replace the anchor
2753             TreeTableCellBehavior.setAnchor(treeTableView, newTablePosition, false);
2754 
2755             // firstly we make a copy of the selection, so that we can send out
2756             // the correct details in the selection change event.
2757             List&lt;TreeTablePosition&lt;S,?&gt;&gt; previousSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());
2758 
2759             // secondly we check if we can short-circuit out of here because the new selection
2760             // equals the current selection
2761             final boolean wasSelected = isSelected(row, column);
2762             if (wasSelected &amp;&amp; previousSelection.size() == 1) {
2763                 // before we return, we double-check that the selected item
2764                 // is equal to the item in the given index
2765                 TreeTablePosition&lt;S,?&gt; selectedCell = getSelectedCells().get(0);
2766                 if (getSelectedItem() == getModelItem(row)) {
2767                     if (selectedCell.getRow() == row &amp;&amp; selectedCell.getTableColumn() == column) {
2768                         return;
2769                     }
2770                 }
2771             }
2772 
2773             // RT-32411: We used to call quietClearSelection() here, but this
2774             // resulted in the selectedItems and selectedIndices lists never
2775             // reporting that they were empty.
2776             // makeAtomic toggle added to resolve RT-32618
2777             startAtomic();
2778 
2779             // then clear the current selection
2780             clearSelection();
2781 
2782             // and select the new cell
2783             select(row, column);
2784 
2785             stopAtomic();
2786 
2787             // We remove the new selection from the list seeing as it is not removed.
2788             if (isCellSelectionEnabled) {
2789                 previousSelection.remove(newTablePosition);
2790             } else {
2791                 for (TreeTablePosition&lt;S,?&gt; tp : previousSelection) {
2792                     if (tp.getRow() == row) {
2793                         previousSelection.remove(tp);
2794                         break;
2795                     }
2796                 }
2797             }
2798 
2799             // fire off a single add/remove/replace notification (rather than
2800             // individual remove and add notifications) - see RT-33324
2801             ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; change;
2802 
2803             /*
2804              * getFrom() documentation:
2805              *   If wasAdded is true, the interval contains all the values that were added.
2806              *   If wasPermutated is true, the interval marks the values that were permutated.
2807              *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
2808              *   return the same number - the place where the removed elements were positioned in the list.
2809              */
2810             if (wasSelected) {
2811                 change = ControlUtils.buildClearAndSelectChange(selectedCellsSeq, previousSelection, row);
2812             } else {
2813                 final int changeIndex = isCellSelectionEnabled ? 0 : Math.max(0, selectedCellsSeq.indexOf(newTablePosition));
2814                 final int changeSize = isCellSelectionEnabled ? getSelectedCells().size() : 1;
2815                 change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
2816                         changeIndex, changeIndex + changeSize, previousSelection, selectedCellsSeq);
2817 //                selectedCellsSeq._beginChange();
2818 //                selectedCellsSeq._nextAdd(changeIndex, changeIndex + changeSize);
2819 //                selectedCellsSeq._nextRemove(changeIndex, previousSelection);
2820 //                selectedCellsSeq._endChange();
2821             }
2822 
2823             fireCustomSelectedCellsListChangeEvent(change);
2824         }
2825 
2826         @Override public void select(int row) {
2827             select(row, null);
2828         }
2829 
2830         @Override public void select(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
2831             // TODO we need to bring in the TreeView selection stuff here...
2832             if (row &lt; 0 || row &gt;= getRowCount()) return;
2833 
2834             // if I&#39;m in cell selection mode but the column is null, select each
2835             // of the contained cells individually
2836             if (isCellSelectionEnabled() &amp;&amp; column == null) {
2837                 List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2838                 for (int i = 0; i &lt; columns.size(); i++) {
2839                     select(row, columns.get(i));
2840                 }
2841                 return;
2842             }
2843 
2844             if (TableCellBehavior.hasDefaultAnchor(treeTableView)) {
2845                 TableCellBehavior.removeAnchor(treeTableView);
2846             }
2847 
2848             if (getSelectionMode() == SelectionMode.SINGLE) {
2849                 quietClearSelection();
2850             }
2851             selectedCellsMap.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, (TreeTableColumn&lt;S,?&gt;)column));
2852 
2853             updateSelectedIndex(row);
2854             focus(row, (TreeTableColumn&lt;S, ?&gt;) column);
2855         }
2856 
2857         @Override public void select(TreeItem&lt;S&gt; obj) {
2858             if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
2859                 clearSelection();
2860                 return;
2861             }
2862 
2863             int firstIndex = treeTableView.getRow(obj);
2864             if (firstIndex &gt; -1) {
2865                 if (isSelected(firstIndex)) {
2866                     return;
2867                 }
2868 
2869                 if (getSelectionMode() == SelectionMode.SINGLE) {
2870                     quietClearSelection();
2871                 }
2872 
2873                 select(firstIndex);
2874             } else {
2875                 // if we are here, we did not find the item in the entire data model.
2876                 // Even still, we allow for this item to be set to the give object.
2877                 // We expect that in concrete subclasses of this class we observe the
2878                 // data model such that we check to see if the given item exists in it,
2879                 // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
2880                 setSelectedIndex(-1);
2881                 setSelectedItem(obj);
2882             }
2883         }
2884 
2885         @Override public void selectIndices(int row, int... rows) {
2886             if (rows == null) {
2887                 select(row);
2888                 return;
2889             }
2890 
2891             /*
2892              * Performance optimisation - if multiple selection is disabled, only
2893              * process the end-most row index.
2894              */
2895             int rowCount = getRowCount();
2896 
2897             if (getSelectionMode() == SelectionMode.SINGLE) {
2898                 quietClearSelection();
2899 
2900                 for (int i = rows.length - 1; i &gt;= 0; i--) {
2901                     int index = rows[i];
2902                     if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
2903                         select(index);
2904                         break;
2905                     }
2906                 }
2907 
2908                 if (selectedCellsMap.isEmpty()) {
2909                     if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
2910                         select(row);
2911                     }
2912                 }
2913             } else {
2914                 int lastIndex = -1;
2915                 Set&lt;TreeTablePosition&lt;S,?&gt;&gt; positions = new LinkedHashSet&lt;&gt;();
2916 
2917                 // --- firstly, we special-case the non-varargs &#39;row&#39; argument
2918                 if (row &gt;= 0 &amp;&amp; row &lt; rowCount) {
2919                     // if I&#39;m in cell selection mode, we want to select each
2920                     // of the contained cells individually
2921                     if (isCellSelectionEnabled()) {
2922                         List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2923                         for (int column = 0; column &lt; columns.size(); column++) {
2924                             if (! selectedCellsMap.isSelected(row, column)) {
2925                                 positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, columns.get(column)));
2926                             }
2927                         }
2928                     } else {
2929                         boolean match = selectedCellsMap.isSelected(row, -1);
2930                         if (!match) {
2931                             positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, null));
2932                         }
2933                     }
2934 
2935                     lastIndex = row;
2936                 }
2937 
2938                 // --- now we iterate through all varargs values
2939                 for (int i = 0; i &lt; rows.length; i++) {
2940                     int index = rows[i];
2941                     if (index &lt; 0 || index &gt;= rowCount) continue;
2942                     lastIndex = index;
2943 
2944                     if (isCellSelectionEnabled()) {
2945                         List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2946                         for (int column = 0; column &lt; columns.size(); column++) {
2947                             if (! selectedCellsMap.isSelected(index, column)) {
2948                                 positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), index, columns.get(column)));
2949                                 lastIndex = index;
2950                             }
2951                         }
2952                     } else {
2953                         if (! selectedCellsMap.isSelected(index, -1)) {
2954                             // if we are here then we have successfully gotten through the for-loop above
2955                             positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), index, null));
2956                         }
2957                     }
2958                 }
2959 
2960                 selectedCellsMap.addAll(positions);
2961 
2962                 if (lastIndex != -1) {
2963                     select(lastIndex);
2964                 }
2965             }
2966         }
2967 
2968         @Override public void selectAll() {
2969             if (getSelectionMode() == SelectionMode.SINGLE) return;
2970 
2971             if (isCellSelectionEnabled()) {
2972                 List&lt;TreeTablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
2973                 TreeTableColumn&lt;S,?&gt; column;
2974                 TreeTablePosition&lt;S,?&gt; tp = null;
2975                 for (int col = 0; col &lt; getTreeTableView().getVisibleLeafColumns().size(); col++) {
2976                     column = getTreeTableView().getVisibleLeafColumns().get(col);
2977                     for (int row = 0; row &lt; getRowCount(); row++) {
2978                         tp = new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column);
2979                         indices.add(tp);
2980                     }
2981                 }
2982                 selectedCellsMap.setAll(indices);
2983 
2984                 if (tp != null) {
2985                     select(tp.getRow(), tp.getTableColumn());
2986                     focus(tp.getRow(), tp.getTableColumn());
2987                 }
2988             } else {
2989                 List&lt;TreeTablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
2990                 for (int i = 0; i &lt; getRowCount(); i++) {
2991                     indices.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), i, null));
2992                 }
2993                 selectedCellsMap.setAll(indices);
2994 
2995                 int focusedIndex = getFocusedIndex();
2996                 if (focusedIndex == -1) {
2997                     final int itemCount = getItemCount();
2998                     if (itemCount &gt; 0) {
2999                         select(itemCount - 1);
3000                         focus(indices.get(indices.size() - 1));
3001                     }
3002                 } else {
3003                     select(focusedIndex);
3004                     focus(focusedIndex);
3005                 }
3006             }
3007         }
3008 
3009         @Override public void selectRange(int minRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; minColumn,
3010                                           int maxRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; maxColumn) {
3011             if (getSelectionMode() == SelectionMode.SINGLE) {
3012                 quietClearSelection();
3013                 select(maxRow, maxColumn);
3014                 return;
3015             }
3016 
3017             startAtomic();
3018 
3019             final int itemCount = getItemCount();
3020             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
3021 
3022             final int minColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)minColumn);
3023             final int maxColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)maxColumn);
3024             final int _minColumnIndex = Math.min(minColumnIndex, maxColumnIndex);
3025             final int _maxColumnIndex = Math.max(minColumnIndex, maxColumnIndex);
3026 
3027             final int _minRow = Math.min(minRow, maxRow);
3028             final int _maxRow = Math.max(minRow, maxRow);
3029 
3030             List&lt;TreeTablePosition&lt;S,?&gt;&gt; cellsToSelect = new ArrayList&lt;&gt;();
3031 
3032             for (int _row = _minRow; _row &lt;= _maxRow; _row++) {
3033                 // begin copy/paste of select(int, column) method (with some
3034                 // slight modifications)
3035                 if (_row &lt; 0 || _row &gt;= itemCount) continue;
3036 
3037                 if (! isCellSelectionEnabled) {
3038                     cellsToSelect.add(new TreeTablePosition&lt;&gt;(treeTableView, _row, (TreeTableColumn&lt;S,?&gt;)minColumn));
3039                 } else {
3040                     for (int _col = _minColumnIndex; _col &lt;= _maxColumnIndex; _col++) {
3041                         final TreeTableColumn&lt;S, ?&gt; column = treeTableView.getVisibleLeafColumn(_col);
3042 
3043                         // if I&#39;m in cell selection mode but the column is null, I don&#39;t want
3044                         // to select the whole row instead...
3045                         if (column == null &amp;&amp; isCellSelectionEnabled) continue;
3046 
3047                         cellsToSelect.add(new TreeTablePosition&lt;&gt;(treeTableView, _row, column));
3048                         // end copy/paste
3049                     }
3050                 }
3051             }
3052 
3053             // to prevent duplication we remove all currently selected cells from
3054             // our list of cells to select.
3055             cellsToSelect.removeAll(getSelectedCells());
3056 
3057             selectedCellsMap.addAll(cellsToSelect);
3058             stopAtomic();
3059 
3060             // fire off events
3061             // Note that focus and selection always goes to maxRow, not _maxRow.
3062             updateSelectedIndex(maxRow);
3063             focus(maxRow, (TreeTableColumn&lt;S,?&gt;)maxColumn);
3064 
3065             final TreeTableColumn&lt;S,?&gt; startColumn = (TreeTableColumn&lt;S,?&gt;)minColumn;
3066             final TreeTableColumn&lt;S,?&gt; endColumn = isCellSelectionEnabled ? (TreeTableColumn&lt;S,?&gt;)maxColumn : startColumn;
3067             final int startChangeIndex = selectedCellsMap.indexOf(new TreeTablePosition&lt;&gt;(treeTableView, minRow, startColumn));
3068             final int endChangeIndex = selectedCellsMap.indexOf(new TreeTablePosition&lt;&gt;(treeTableView, maxRow, endColumn));
3069 
3070             if (startChangeIndex &gt; -1 &amp;&amp; endChangeIndex &gt; -1) {
3071                 final int startIndex = Math.min(startChangeIndex, endChangeIndex);
3072                 final int endIndex = Math.max(startChangeIndex, endChangeIndex);
3073 
3074                 ListChangeListener.Change c = new NonIterableChange.SimpleAddChange&lt;&gt;(startIndex, endIndex + 1, selectedCellsSeq);
3075                 fireCustomSelectedCellsListChangeEvent(c);
3076 //                selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextAdd(startIndex, endIndex + 1));
3077             }
3078         }
3079 
3080         @Override public void clearSelection(int index) {
3081             clearSelection(index, null);
3082         }
3083 
3084         @Override
3085         public void clearSelection(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
3086             clearSelection(new TreeTablePosition&lt;S,Object&gt;(getTreeTableView(), row, (TreeTableColumn)column));
3087         }
3088 
3089         private void clearSelection(TreeTablePosition&lt;S,?&gt; tp) {
3090             final boolean csMode = isCellSelectionEnabled();
3091             final int row = tp.getRow();
3092             final boolean columnIsNull = tp.getTableColumn() == null;
3093 
3094             List&lt;TreeTablePosition&gt; toRemove = new ArrayList&lt;&gt;();
3095             for (TreeTablePosition pos : getSelectedCells()) {
3096                 if (!csMode) {
3097                     if (pos.getRow() == row) {
3098                         toRemove.add(pos);
3099                         break;
3100                     }
3101                 } else {
3102                     if (columnIsNull &amp;&amp; pos.getRow() == row) {
3103                         // if we are in cell selection mode and the column is null,
3104                         // we remove all items in the row
3105                         toRemove.add(pos);
3106                     } else if (pos.equals(tp)) {
3107                         toRemove.add(tp);
3108                         break;
3109                     }
3110                 }
3111             }
3112             toRemove.stream().forEach(selectedCellsMap::remove);
3113 
3114             if (isEmpty() &amp;&amp; ! isAtomic()) {
3115                 updateSelectedIndex(-1);
3116                 selectedCellsMap.clear();
3117             }
3118         }
3119 
3120         @Override public void clearSelection() {
3121             final List&lt;TreeTablePosition&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;((Collection)getSelectedCells());
3122 
3123             quietClearSelection();
3124 
3125             if (! isAtomic()) {
3126                 updateSelectedIndex(-1);
3127                 focus(-1);
3128 
3129                 if (!removed.isEmpty()) {
3130 //                    selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextRemove(0, removed));
3131                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange&lt;TreeTablePosition&lt;S, ?&gt;&gt;(0, 0, selectedCellsSeq) {
3132                         @Override public List&lt;TreeTablePosition&lt;S, ?&gt;&gt; getRemoved() {
3133                             return removed;
3134                         }
3135                     };
3136                     fireCustomSelectedCellsListChangeEvent(c);
3137                 }
3138             }
3139         }
3140 
3141         private void quietClearSelection() {
3142             startAtomic();
3143             selectedCellsMap.clear();
3144             stopAtomic();
3145         }
3146 
3147         @Override public boolean isSelected(int index) {
3148             return isSelected(index, null);
3149         }
3150 
3151         @Override public boolean isSelected(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
3152             // When in cell selection mode, if the column is null, then we interpret
3153             // the users query to be asking if _all_ of the cells in the row are selected,
3154             // rather than if _any_ of the cells in the row are selected.
3155             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
3156             if (isCellSelectionEnabled &amp;&amp; column == null) {
3157                 int columnCount = treeTableView.getVisibleLeafColumns().size();
3158                 for (int col = 0; col &lt; columnCount; col++) {
3159                     if (!selectedCellsMap.isSelected(row, col)) {
3160                         return false;
3161                     }
3162                 }
3163                 return true;
3164             } else {
3165                 int columnIndex = !isCellSelectionEnabled || column == null ? -1 : treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S, ?&gt;) column);
3166                 return selectedCellsMap.isSelected(row, columnIndex);
3167             }
3168         }
3169 
3170         @Override public boolean isEmpty() {
3171             return selectedCellsMap.isEmpty();
3172         }
3173 
3174         @Override public void selectPrevious() {
3175             if (isCellSelectionEnabled()) {
3176                 // in cell selection mode, we have to wrap around, going from
3177                 // right-to-left, and then wrapping to the end of the previous line
3178                 TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3179                 if (pos.getColumn() - 1 &gt;= 0) {
3180                     // go to previous row
3181                     select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
3182                 } else if (pos.getRow() &lt; getRowCount() - 1) {
3183                     // wrap to end of previous row
3184                     select(pos.getRow() - 1, getTableColumn(getTreeTableView().getVisibleLeafColumns().size() - 1));
3185                 }
3186             } else {
3187                 int focusIndex = getFocusedIndex();
3188                 if (focusIndex == -1) {
3189                     select(getRowCount() - 1);
3190                 } else if (focusIndex &gt; 0) {
3191                     select(focusIndex - 1);
3192                 }
3193             }
3194         }
3195 
3196         @Override public void selectNext() {
3197             if (isCellSelectionEnabled()) {
3198                 // in cell selection mode, we have to wrap around, going from
3199                 // left-to-right, and then wrapping to the start of the next line
3200                 TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3201                 if (pos.getColumn() + 1 &lt; getTreeTableView().getVisibleLeafColumns().size()) {
3202                     // go to next column
3203                     select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
3204                 } else if (pos.getRow() &lt; getRowCount() - 1) {
3205                     // wrap to start of next row
3206                     select(pos.getRow() + 1, getTableColumn(0));
3207                 }
3208             } else {
3209                 int focusIndex = getFocusedIndex();
3210                 if (focusIndex == -1) {
3211                     select(0);
3212                 } else if (focusIndex &lt; getRowCount() -1) {
3213                     select(focusIndex + 1);
3214                 }
3215             }
3216         }
3217 
3218         @Override public void selectAboveCell() {
3219             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3220             if (pos.getRow() == -1) {
3221                 select(getRowCount() - 1);
3222             } else if (pos.getRow() &gt; 0) {
3223                 select(pos.getRow() - 1, pos.getTableColumn());
3224             }
3225         }
3226 
3227         @Override public void selectBelowCell() {
3228             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3229 
3230             if (pos.getRow() == -1) {
3231                 select(0);
3232             } else if (pos.getRow() &lt; getRowCount() -1) {
3233                 select(pos.getRow() + 1, pos.getTableColumn());
3234             }
3235         }
3236 
3237         @Override public void selectFirst() {
3238             TreeTablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
3239 
3240             if (getSelectionMode() == SelectionMode.SINGLE) {
3241                 quietClearSelection();
3242             }
3243 
3244             if (getRowCount() &gt; 0) {
3245                 if (isCellSelectionEnabled()) {
3246                     select(0, focusedCell.getTableColumn());
3247                 } else {
3248                     select(0);
3249                 }
3250             }
3251         }
3252 
3253         @Override public void selectLast() {
3254             TreeTablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
3255 
3256             if (getSelectionMode() == SelectionMode.SINGLE) {
3257                 quietClearSelection();
3258             }
3259 
3260             int numItems = getRowCount();
3261             if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
3262                 if (isCellSelectionEnabled()) {
3263                     select(numItems - 1, focusedCell.getTableColumn());
3264                 } else {
3265                     select(numItems - 1);
3266                 }
3267             }
3268         }
3269 
3270         @Override public void selectLeftCell() {
3271             if (! isCellSelectionEnabled()) return;
3272 
3273             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3274             if (pos.getColumn() - 1 &gt;= 0) {
3275                 select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
3276             }
3277         }
3278 
3279         @Override public void selectRightCell() {
3280             if (! isCellSelectionEnabled()) return;
3281 
3282             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3283             if (pos.getColumn() + 1 &lt; getTreeTableView().getVisibleLeafColumns().size()) {
3284                 select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
3285             }
3286         }
3287 
3288 
3289 
3290         /***********************************************************************
3291          *                                                                     *
3292          * Support code                                                        *
3293          *                                                                     *
3294          **********************************************************************/
3295 
3296         private void updateDefaultSelection() {
3297             // when the items list totally changes, we should clear out
3298             // the selection
3299             int newSelectionIndex = -1;
3300             TreeItem&lt;S&gt; selectedItem = getSelectedItem();
3301             if (selectedItem != null) {
3302                 newSelectionIndex = treeTableView.getRow(selectedItem);
3303             }
3304 
3305             // we put focus onto the first item, if there is at least
3306             // one item in the list
3307             int newFocusIndex = newSelectionIndex != -1 ? newSelectionIndex : treeTableView.getExpandedItemCount() &gt; 0 ? 0 : -1;
3308 
3309             clearSelection();
3310             select(newSelectionIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
3311             focus(newFocusIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
3312         }
3313 
3314         private TreeTableColumn&lt;S,?&gt; getTableColumn(int pos) {
3315             return getTreeTableView().getVisibleLeafColumn(pos);
3316         }
3317 
3318         // Gets a table column to the left or right of the current one, given an offset
3319         private TreeTableColumn&lt;S,?&gt; getTableColumn(TreeTableColumn&lt;S,?&gt; column, int offset) {
3320             int columnIndex = getTreeTableView().getVisibleLeafIndex(column);
3321             int newColumnIndex = columnIndex + offset;
3322             return getTreeTableView().getVisibleLeafColumn(newColumnIndex);
3323         }
3324 
3325         private void updateSelectedIndex(int row) {
3326             setSelectedIndex(row);
3327             setSelectedItem(getModelItem(row));
3328         }
3329 
3330         @Override public void focus(int row) {
3331             focus(row, null);
3332         }
3333 
3334         private void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
3335             focus(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column));
3336         }
3337 
3338         private void focus(TreeTablePosition&lt;S,?&gt; pos) {
3339             if (getTreeTableView().getFocusModel() == null) return;
3340 
3341             getTreeTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
3342             getTreeTableView().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
3343         }
3344 
3345         @Override public int getFocusedIndex() {
3346             return getFocusedCell().getRow();
3347         }
3348 
3349         private TreeTablePosition&lt;S,?&gt; getFocusedCell() {
3350             if (treeTableView.getFocusModel() == null) {
3351                 return new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
3352             }
3353             return treeTableView.getFocusModel().getFocusedCell();
3354         }
3355 
3356         private int getRowCount() {
3357             return treeTableView.getExpandedItemCount();
3358         }
3359 
3360         private void fireCustomSelectedCellsListChangeEvent(ListChangeListener.Change&lt;? extends TreeTablePosition&lt;S,?&gt;&gt; c) {
3361             ControlUtils.updateSelectedIndices(this, c);
3362 
3363             if (isAtomic()) {
3364                 return;
3365             }
3366 
3367             selectedCellsSeq.callObservers(new MappingChange&lt;&gt;(c, MappingChange.NOOP_MAP, selectedCellsSeq));
3368         }
3369     }
3370 
3371 
3372 
3373 
3374     /**
3375      * A {@link FocusModel} with additional functionality to support the requirements
3376      * of a TableView control.
3377      *
3378      * @see TableView
3379      * @since JavaFX 8.0
3380      */
3381     public static class TreeTableViewFocusModel&lt;S&gt; extends TableFocusModel&lt;TreeItem&lt;S&gt;, TreeTableColumn&lt;S,?&gt;&gt; {
3382 
3383         private final TreeTableView&lt;S&gt; treeTableView;
3384 
3385         private final TreeTablePosition EMPTY_CELL;
3386 
3387         /**
3388          * Creates a default TableViewFocusModel instance that will be used to
3389          * manage focus of the provided TableView control.
3390          *
3391          * @param treeTableView The tableView upon which this focus model operates.
3392          * @throws NullPointerException The TableView argument can not be null.
3393          */
3394         public TreeTableViewFocusModel(final TreeTableView&lt;S&gt; treeTableView) {
3395             if (treeTableView == null) {
3396                 throw new NullPointerException(&quot;TableView can not be null&quot;);
3397             }
3398 
3399             this.treeTableView = treeTableView;
3400             this.EMPTY_CELL = new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
3401 
3402             this.treeTableView.rootProperty().addListener(weakRootPropertyListener);
3403             updateTreeEventListener(null, treeTableView.getRoot());
3404 
3405             int focusRow = getItemCount() &gt; 0 ? 0 : -1;
3406             TreeTablePosition&lt;S,?&gt; pos = new TreeTablePosition&lt;&gt;(treeTableView, focusRow, null);
3407             setFocusedCell(pos);
3408 
3409             showRootListener = obs -&gt; {
3410                 if (isFocused(0)) {
3411                     focus(-1);
3412                     focus(0);
3413                 }
3414             };
3415             treeTableView.showRootProperty().addListener(new WeakInvalidationListener(showRootListener));
3416 
3417             focusedCellProperty().addListener(o -&gt; {
3418                 treeTableView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
3419             });
3420         }
3421 
3422         private final ChangeListener&lt;TreeItem&lt;S&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
3423             updateTreeEventListener(oldValue, newValue);
3424         };
3425 
3426         private final WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
3427                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
3428 
3429         private final InvalidationListener showRootListener;
3430 
3431         private void updateTreeEventListener(TreeItem&lt;S&gt; oldRoot, TreeItem&lt;S&gt; newRoot) {
3432             if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
3433                 oldRoot.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
3434             }
3435 
3436             if (newRoot != null) {
3437                 weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
3438                 newRoot.addEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
3439             }
3440         }
3441 
3442         private EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; treeItemListener = new EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt;() {
3443             @Override public void handle(TreeItem.TreeModificationEvent&lt;S&gt; e) {
3444                 // don&#39;t shift focus if the event occurred on a tree item after
3445                 // the focused row, or if there is no focus index at present
3446                 if (getFocusedIndex() == -1) return;
3447 
3448                 int shift = 0;
3449                 if (e.getChange() != null) {
3450                     e.getChange().next();
3451                 }
3452 
3453                 do {
3454                     int row = treeTableView.getRow(e.getTreeItem());
3455 
3456                     if (e.wasExpanded()) {
3457                         if (row &lt; getFocusedIndex()) {
3458                             // need to shuffle selection by the number of visible children
3459                             shift += e.getTreeItem().getExpandedDescendentCount(false) - 1;
3460                         }
3461                     } else if (e.wasCollapsed()) {
3462                         if (row &lt; getFocusedIndex()) {
3463                             // need to shuffle selection by the number of visible children
3464                             // that were just hidden
3465                             shift += -e.getTreeItem().previousExpandedDescendentCount + 1;
3466                         }
3467                     } else if (e.wasAdded()) {
3468                         // get the TreeItem the event occurred on - we only need to
3469                         // shift if the tree item is expanded
3470                         TreeItem&lt;S&gt; eventTreeItem = e.getTreeItem();
3471                         if (eventTreeItem.isExpanded()) {
3472                             for (int i = 0; i &lt; e.getAddedChildren().size(); i++) {
3473                                 // get the added item and determine the row it is in
3474                                 TreeItem&lt;S&gt; item = e.getAddedChildren().get(i);
3475                                 row = treeTableView.getRow(item);
3476 
3477                                 if (item != null &amp;&amp; row &lt;= (shift+getFocusedIndex())) {
3478                                     shift += item.getExpandedDescendentCount(false);
3479                                 }
3480                             }
3481                         }
3482                     } else if (e.wasRemoved()) {
3483                         row += e.getFrom() + 1;
3484 
3485                         for (int i = 0; i &lt; e.getRemovedChildren().size(); i++) {
3486                             TreeItem&lt;S&gt; item = e.getRemovedChildren().get(i);
3487                             if (item != null &amp;&amp; item.equals(getFocusedItem())) {
3488                                 focus(Math.max(0, getFocusedIndex() - 1));
3489                                 return;
3490                             }
3491                         }
3492 
3493                         if (row &lt;= getFocusedIndex()) {
3494                             // shuffle selection by the number of removed items
3495                             shift += e.getTreeItem().isExpanded() ? -e.getRemovedSize() : 0;
3496                         }
3497                     }
3498                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
3499 
3500                 if (shift != 0) {
3501                     TreeTablePosition&lt;S, ?&gt; focusedCell = getFocusedCell();
3502                     final int newFocus = focusedCell.getRow() + shift;
3503                     if (newFocus &gt;= 0) {
3504                         Platform.runLater(() -&gt; focus(newFocus, focusedCell.getTableColumn()));
3505                     }
3506                 }
3507             }
3508         };
3509 
3510         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
3511 
3512         /** {@inheritDoc} */
3513         @Override protected int getItemCount() {
3514 //            if (tableView.getItems() == null) return -1;
3515 //            return tableView.getItems().size();
3516             return treeTableView.getExpandedItemCount();
3517         }
3518 
3519         /** {@inheritDoc} */
3520         @Override protected TreeItem&lt;S&gt; getModelItem(int index) {
3521             if (index &lt; 0 || index &gt;= getItemCount()) return null;
3522             return treeTableView.getTreeItem(index);
3523         }
3524 
3525         /**
3526          * The position of the current item in the TableView which has the focus.
3527          */
3528         private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCell;
3529         public final ReadOnlyObjectProperty&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCellProperty() {
3530             return focusedCellPropertyImpl().getReadOnlyProperty();
3531         }
3532         private void setFocusedCell(TreeTablePosition&lt;S,?&gt; value) { focusedCellPropertyImpl().set(value);  }
3533         public final TreeTablePosition&lt;S,?&gt; getFocusedCell() { return focusedCell == null ? EMPTY_CELL : focusedCell.get(); }
3534 
3535         private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCellPropertyImpl() {
3536             if (focusedCell == null) {
3537                 focusedCell = new ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt;(EMPTY_CELL) {
3538                     private TreeTablePosition&lt;S,?&gt; old;
3539                     @Override protected void invalidated() {
3540                         if (get() == null) return;
3541 
3542                         if (old == null || !old.equals(get())) {
3543                             setFocusedIndex(get().getRow());
3544                             setFocusedItem(getModelItem(getValue().getRow()));
3545 
3546                             old = get();
3547                         }
3548                     }
3549 
3550                     @Override
3551                     public Object getBean() {
3552                         return TreeTableView.TreeTableViewFocusModel.this;
3553                     }
3554 
3555                     @Override
3556                     public String getName() {
3557                         return &quot;focusedCell&quot;;
3558                     }
3559                 };
3560             }
3561             return focusedCell;
3562         }
3563 
3564 
3565         /**
3566          * Causes the item at the given index to receive the focus.
3567          *
3568          * @param row The row index of the item to give focus to.
3569          * @param column The column of the item to give focus to. Can be null.
3570          */
3571         @Override public void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
3572             if (row &lt; 0 || row &gt;= getItemCount()) {
3573                 setFocusedCell(EMPTY_CELL);
3574             } else {
3575                 TreeTablePosition&lt;S,?&gt; oldFocusCell = getFocusedCell();
3576                 TreeTablePosition&lt;S,?&gt; newFocusCell = new TreeTablePosition&lt;&gt;(treeTableView, row, column);
3577                 setFocusedCell(newFocusCell);
3578 
3579                 if (newFocusCell.equals(oldFocusCell)) {
3580                     // manually update the focus properties to ensure consistency
3581                     setFocusedIndex(row);
3582                     setFocusedItem(getModelItem(row));
3583                 }
3584             }
3585         }
3586 
3587         /**
3588          * Convenience method for setting focus on a particular row or cell
3589          * using a {@link TablePosition}.
3590          *
3591          * @param pos The table position where focus should be set.
3592          */
3593         public void focus(TreeTablePosition&lt;S,?&gt; pos) {
3594             if (pos == null) return;
3595             focus(pos.getRow(), pos.getTableColumn());
3596         }
3597 
3598 
3599         /***********************************************************************
3600          *                                                                     *
3601          * Public API                                                          *
3602          *                                                                     *
3603          **********************************************************************/
3604 
3605         /**
3606          * Tests whether the row / cell at the given location currently has the
3607          * focus within the TableView.
3608          */
3609         @Override public boolean isFocused(int row, TreeTableColumn&lt;S,?&gt; column) {
3610             if (row &lt; 0 || row &gt;= getItemCount()) return false;
3611 
3612             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3613             boolean columnMatch = column == null || column.equals(cell.getTableColumn());
3614 
3615             return cell.getRow() == row &amp;&amp; columnMatch;
3616         }
3617 
3618         /**
3619          * Causes the item at the given index to receive the focus. This does not
3620          * cause the current selection to change. Updates the focusedItem and
3621          * focusedIndex properties such that &lt;code&gt;focusedIndex = -1&lt;/code&gt; unless
3622          * &lt;pre&gt;&lt;code&gt;0 &amp;lt;= index &amp;lt; model size&lt;/code&gt;&lt;/pre&gt;.
3623          *
3624          * @param index The index of the item to get focus.
3625          */
3626         @Override public void focus(int index) {
3627             if (treeTableView.expandedItemCountDirty) {
3628                 treeTableView.updateExpandedItemCount(treeTableView.getRoot());
3629             }
3630 
3631             if (index &lt; 0 || index &gt;= getItemCount()) {
3632                 setFocusedCell(EMPTY_CELL);
3633             } else {
3634                 setFocusedCell(new TreeTablePosition&lt;&gt;(treeTableView, index, null));
3635             }
3636         }
3637 
3638         /**
3639          * Attempts to move focus to the cell above the currently focused cell.
3640          */
3641         @Override public void focusAboveCell() {
3642             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3643 
3644             if (getFocusedIndex() == -1) {
3645                 focus(getItemCount() - 1, cell.getTableColumn());
3646             } else if (getFocusedIndex() &gt; 0) {
3647                 focus(getFocusedIndex() - 1, cell.getTableColumn());
3648             }
3649         }
3650 
3651         /**
3652          * Attempts to move focus to the cell below the currently focused cell.
3653          */
3654         @Override public void focusBelowCell() {
3655             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3656             if (getFocusedIndex() == -1) {
3657                 focus(0, cell.getTableColumn());
3658             } else if (getFocusedIndex() != getItemCount() -1) {
3659                 focus(getFocusedIndex() + 1, cell.getTableColumn());
3660             }
3661         }
3662 
3663         /**
3664          * Attempts to move focus to the cell to the left of the currently focused cell.
3665          */
3666         @Override public void focusLeftCell() {
3667             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3668             if (cell.getColumn() &lt;= 0) return;
3669             focus(cell.getRow(), getTableColumn(cell.getTableColumn(), -1));
3670         }
3671 
3672         /**
3673          * Attempts to move focus to the cell to the right of the the currently focused cell.
3674          */
3675         @Override public void focusRightCell() {
3676             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3677             if (cell.getColumn() == getColumnCount() - 1) return;
3678             focus(cell.getRow(), getTableColumn(cell.getTableColumn(), 1));
3679         }
3680 
3681         /** {@inheritDoc} */
3682         @Override public void focusPrevious() {
3683             if (getFocusedIndex() == -1) {
3684                 focus(0);
3685             } else if (getFocusedIndex() &gt; 0) {
3686                 focusAboveCell();
3687             }
3688         }
3689 
3690         /** {@inheritDoc} */
3691         @Override public void focusNext() {
3692             if (getFocusedIndex() == -1) {
3693                 focus(0);
3694             } else if (getFocusedIndex() != getItemCount() -1) {
3695                 focusBelowCell();
3696             }
3697         }
3698 
3699 
3700 
3701          /***********************************************************************
3702          *                                                                     *
3703          * Private Implementation                                              *
3704          *                                                                     *
3705          **********************************************************************/
3706 
3707         private int getColumnCount() {
3708             return treeTableView.getVisibleLeafColumns().size();
3709         }
3710 
3711         // Gets a table column to the left or right of the current one, given an offset
3712         private TreeTableColumn&lt;S,?&gt; getTableColumn(TreeTableColumn&lt;S,?&gt; column, int offset) {
3713             int columnIndex = treeTableView.getVisibleLeafIndex(column);
3714             int newColumnIndex = columnIndex + offset;
3715             return treeTableView.getVisibleLeafColumn(newColumnIndex);
3716         }
3717     }
3718 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import com.sun.javafx.collections.MappingChange;
  29 import com.sun.javafx.collections.NonIterableChange;
  30 import com.sun.javafx.scene.control.Properties;
  31 import com.sun.javafx.scene.control.SelectedCellsMap;
  32 
  33 import com.sun.javafx.scene.control.behavior.TableCellBehavior;
  34 import com.sun.javafx.scene.control.behavior.TableCellBehaviorBase;
  35 import com.sun.javafx.scene.control.behavior.TreeTableCellBehavior;
  36 
  37 import javafx.beans.property.DoubleProperty;
  38 import javafx.css.CssMetaData;
  39 import javafx.css.PseudoClass;
  40 
  41 import javafx.css.converter.SizeConverter;
  42 import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
  43 import com.sun.javafx.scene.control.TableColumnComparatorBase;
  44 
  45 import javafx.css.Styleable;
  46 import javafx.css.StyleableDoubleProperty;
  47 import javafx.css.StyleableProperty;
  48 import javafx.event.WeakEventHandler;
  49 
  50 import javafx.scene.control.skin.TreeTableViewSkin;
  51 
  52 import java.lang.ref.SoftReference;
  53 import java.lang.ref.WeakReference;
  54 import java.util.ArrayList;
  55 import java.util.Collection;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashMap;
  59 import java.util.HashSet;
  60 import java.util.LinkedHashSet;
  61 import java.util.List;
  62 import java.util.Map;
  63 import java.util.Set;
  64 import java.util.WeakHashMap;
  65 
  66 import javafx.application.Platform;
  67 import javafx.beans.DefaultProperty;
  68 import javafx.beans.InvalidationListener;
  69 import javafx.beans.WeakInvalidationListener;
  70 import javafx.beans.property.BooleanProperty;
  71 import javafx.beans.property.ObjectProperty;
  72 import javafx.beans.property.ObjectPropertyBase;
  73 import javafx.beans.property.ReadOnlyIntegerProperty;
  74 import javafx.beans.property.ReadOnlyIntegerWrapper;
  75 import javafx.beans.property.ReadOnlyObjectProperty;
  76 import javafx.beans.property.ReadOnlyObjectWrapper;
  77 import javafx.beans.property.SimpleBooleanProperty;
  78 import javafx.beans.property.SimpleObjectProperty;
  79 import javafx.beans.value.ChangeListener;
  80 import javafx.beans.value.WeakChangeListener;
  81 import javafx.beans.value.WritableValue;
  82 import javafx.collections.FXCollections;
  83 import javafx.collections.ListChangeListener;
  84 import javafx.collections.MapChangeListener;
  85 import javafx.collections.ObservableList;
  86 import javafx.collections.WeakListChangeListener;
  87 import javafx.event.Event;
  88 import javafx.event.EventHandler;
  89 import javafx.event.EventType;
  90 import javafx.scene.AccessibleAttribute;
  91 import javafx.scene.AccessibleRole;
  92 import javafx.scene.Node;
  93 import javafx.scene.layout.Region;
  94 import javafx.util.Callback;
  95 
  96 /**
  97  * The TreeTableView control is designed to visualize an unlimited number of rows
  98  * of data, broken out into columns. The TreeTableView control is conceptually
  99  * very similar to the {@link TreeView} and {@link TableView} controls,
 100  * and as you read on you&#39;ll come to see the APIs are largely the same.
 101  * However, to give a high-level overview, you&#39;ll note that the TreeTableView
 102  * uses the same {@link TreeItem} API as {@link TreeView},
 103  * and that you therefore are required to simply set the
 104  * {@link #rootProperty() root node} in the TreeTableView. Similarly, the
 105  * TreeTableView control makes use of the same TableColumn-based approach that
 106  * the {@link TableView} control uses, except instead of using the
 107  * TableView-specific {@link TableColumn} class, you should instead use the
 108  * TreeTableView-specific {@link TreeTableColumn} class instead. For an
 109  * example on how to create a TreeTableView instance, refer to the &#39;Creating a
 110  * TreeTableView&#39; control section below.
 111  *
 112  * &lt;p&gt;As with the {@link TableView} control, the TreeTableView control has a
 113  * number of features, including:
 114  * &lt;ul&gt;
 115  * &lt;li&gt;Powerful {@link TreeTableColumn} API:
 116  *   &lt;ul&gt;
 117  *   &lt;li&gt;Support for {@link TreeTableColumn#cellFactoryProperty() cell factories} to
 118  *      easily customize {@link Cell cell} contents in both rendering and editing
 119  *      states.
 120  *   &lt;li&gt;Specification of {@link TreeTableColumn#minWidthProperty() minWidth}/
 121  *      {@link TreeTableColumn#prefWidthProperty() prefWidth}/
 122  *      {@link TreeTableColumn#maxWidthProperty() maxWidth},
 123  *      and also {@link TreeTableColumn#resizableProperty() fixed width columns}.
 124  *   &lt;li&gt;Width resizing by the user at runtime.
 125  *   &lt;li&gt;Column reordering by the user at runtime.
 126  *   &lt;li&gt;Built-in support for {@link TreeTableColumn#getColumns() column nesting}
 127  *   &lt;/ul&gt;
 128  * &lt;li&gt;Different {@link #columnResizePolicyProperty() resizing policies} to
 129  *      dictate what happens when the user resizes columns.
 130  * &lt;li&gt;Support for {@link #getSortOrder() multiple column sorting} by clicking
 131  *      the column header (hold down Shift keyboard key whilst clicking on a
 132  *      header to sort by multiple columns).
 133  * &lt;/ul&gt;
 134  *
 135  * &lt;h2&gt;Creating a TreeTableView&lt;/h2&gt;
 136  *
 137  * &lt;p&gt;Creating a TreeTableView is a multi-step process, and also depends on the
 138  * underlying data model needing to be represented. For this example we&#39;ll use
 139  * the TreeTableView to visualise a file system, and will therefore make use
 140  * of an imaginary (and vastly simplified) File class as defined below:
 141  *
 142  * &lt;pre&gt; {@code public class File {
 143  *     private StringProperty name;
 144  *     public void setName(String value) { nameProperty().set(value); }
 145  *     public String getName() { return nameProperty().get(); }
 146  *     public StringProperty nameProperty() {
 147  *         if (name == null) name = new SimpleStringProperty(this, &quot;name&quot;);
 148  *         return name;
 149  *     }
 150  *
 151  *     private LongProperty lastModified;
 152  *     public void setLastModified(long value) { lastModifiedProperty().set(value); }
 153  *     public long getLastModified() { return lastModifiedProperty().get(); }
 154  *     public LongProperty lastModifiedProperty() {
 155  *         if (lastModified == null) lastModified = new SimpleLongProperty(this, &quot;lastModified&quot;);
 156  *         return lastModified;
 157  *     }
 158  *
 159  *     public File(String name, long size) {
 160  *         setName(name);
 161  *         setSize(size);
 162  *     }
 163  * }}&lt;/pre&gt;
 164  *
 165  * &lt;p&gt;The data we will use for this example is a single root with 3 files:
 166  *
 167  * &lt;pre&gt; {@code File rootFile = new File(&quot;Images&quot;, 900);
 168  * List&lt;File&gt; files = List.of(
 169  *     new File(&quot;Cat.png&quot;, 300),
 170  *     new File(&quot;Dog.png&quot;, 500),
 171  *     new File(&quot;Bird.png&quot;, 100));}&lt;/pre&gt;
 172  *
 173  * &lt;p&gt;Firstly, we need to create a data model. As mentioned, for this example,
 174  * we&#39;ll be representing a file system using File instances. To do this, we need
 175  * to define the root node of the tree table and its hierarchy:
 176  *
 177  * &lt;pre&gt; {@code TreeItem&lt;File&gt; root = new TreeItem&lt;&gt;(rootFile);
 178  * files.forEach(file -&gt; root.getChildren().add(new TreeItem&lt;&gt;(file)));}&lt;/pre&gt;
 179  *
 180  * &lt;p&gt; Then we create a TreeTableView instance:
 181  *
 182  * &lt;pre&gt; {@code TreeTableView&lt;File&gt; treeTable = new TreeTableView&lt;&gt;(root);}&lt;/pre&gt;
 183  *
 184  * &lt;p&gt;With the root set as such, the TreeTableView will automatically update whenever
 185  * the {@link TreeItem#getChildren() children} of the root change.
 186  *
 187  * &lt;p&gt;At this point we have a TreeTableView hooked up to observe the root
 188  * TreeItem instance. The missing ingredient
 189  * now is the means of splitting out the data contained within the model and
 190  * representing it in one or more {@link TreeTableColumn} instances. To
 191  * create a two-column TreeTableView to show the file name and size
 192  * properties, we write:
 193  *
 194  * &lt;pre&gt; {@code TreeTableColumns&lt;File, String&gt; fileNameCol = new TreeTableColumn&lt;&gt;(&quot;Filename&quot;);
 195  * TreeTableColumns&lt;File, Long&gt; sizeCol = new TreeTableColumn&lt;&gt;(&quot;Size&quot;);
 196  *
 197  * treeTable.getColumns().setAll(fileNameCol, sizeCol);}&lt;/pre&gt;
 198  *
 199  * &lt;p&gt;With the code shown above we have nearly fully defined the minimum properties
 200  * required to create a TreeTableView instance. The only thing missing is the
 201  * {@link javafx.scene.control.TreeTableColumn#cellValueFactoryProperty() cell value factories}
 202  * for the two columns - it is these that are responsible for determining the value
 203  * of a cell in a given row. Commonly these can be specified using the
 204  * {@link javafx.scene.control.cell.TreeItemPropertyValueFactory} class, but
 205  * failing that you can also create an anonymous inner class and do whatever is
 206  * necessary. For example, using {@link javafx.scene.control.cell.TreeItemPropertyValueFactory}
 207  * you would do the following:
 208  *
 209  * &lt;pre&gt; {@code fileNameCol.setCellValueFactory(new TreeItemPropertyValueFactory(rootFile.nameProperty().getName()));
 210  * sizeCol.setCellValueFactory(new TreeItemPropertyValueFactory(rootFile.sizeProperty().getName()));}&lt;/pre&gt;
 211  *
 212  * &lt;img src=&quot;doc-files/TreeTableView.png&quot; alt=&quot;Image of the TreeTableView control&quot;&gt;
 213  *
 214  * &lt;p&gt;Running this code will result in a TreeTableView as shown above with two columns
 215  * for name and size. Any other properties the File class might have will not be shown,
 216  * as no TreeTableColumns are defined for them.
 217  *
 218  * &lt;h3&gt;TreeTableView support for classes that don&#39;t contain properties&lt;/h3&gt;
 219  *
 220  * &lt;p&gt;The code shown above is the shortest possible code for creating a TreeTableView
 221  * when the domain objects are designed with JavaFX properties in mind
 222  * (additionally, {@link javafx.scene.control.cell.TreeItemPropertyValueFactory} supports
 223  * normal JavaBean properties too, although there is a caveat to this, so refer
 224  * to the class documentation for more information). When this is not the case,
 225  * it is necessary to provide a custom cell value factory. More information
 226  * about cell value factories can be found in the {@link TreeTableColumn} API
 227  * documentation, but briefly, here is how a TreeTableColumns could be specified:
 228  *
 229  * &lt;pre&gt; {@code firstNameCol.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;Person, String&gt;, ObservableValue&lt;String&gt;&gt;() {
 230  *     public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;Person, String&gt; p) {
 231  *         // p.getValue() returns the TreeItem&lt;Person&gt; instance for a particular TreeTableView row,
 232  *         // p.getValue().getValue() returns the Person instance inside the TreeItem&lt;Person&gt;
 233  *         return p.getValue().getValue().firstNameProperty();
 234  *     }
 235  * });
 236  *
 237  * // or with a lambda expression:
 238  * firstNameCol.setCellValueFactory(p -&gt; p.getValue().getValue().firstNameProperty());}&lt;/pre&gt;
 239  *
 240  * &lt;h3&gt;TreeTableView Selection / Focus APIs&lt;/h3&gt;
 241  * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 242  * {@link SelectionModel} and {@link FocusModel} classes. A TreeTableView has at most
 243  * one instance of each of these classes, available from
 244  * {@link #selectionModelProperty() selectionModel} and
 245  * {@link #focusModelProperty() focusModel} properties, respectively.
 246  * Whilst it is possible to use this API to set a new selection model, in
 247  * most circumstances this is not necessary - the default selection and focus
 248  * models should work in most circumstances.
 249  *
 250  * &lt;p&gt;The default {@link SelectionModel} used when instantiating a TreeTableView is
 251  * an implementation of the {@link MultipleSelectionModel} abstract class.
 252  * However, as noted in the API documentation for
 253  * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 254  * property, the default value is {@link SelectionMode#SINGLE}. To enable
 255  * multiple selection in a default TreeTableView instance, it is therefore necessary
 256  * to do the following:
 257  *
 258  * &lt;pre&gt; {@code treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 259  *
 260  * &lt;h3&gt;Customizing TreeTableView Visuals&lt;/h3&gt;
 261  * &lt;p&gt;The visuals of the TreeTableView can be entirely customized by replacing the
 262  * default {@link #rowFactoryProperty() row factory}. A row factory is used to
 263  * generate {@link TreeTableRow} instances, which are used to represent an entire
 264  * row in the TreeTableView.
 265  *
 266  * &lt;p&gt;In many cases, this is not what is desired however, as it is more commonly
 267  * the case that cells be customized on a per-column basis, not a per-row basis.
 268  * It is therefore important to note that a {@link TreeTableRow} is not a
 269  * {@link TreeTableCell}. A  {@link TreeTableRow} is simply a container for zero or more
 270  * {@link TreeTableCell}, and in most circumstances it is more likely that you&#39;ll
 271  * want to create custom TreeTableCells, rather than TreeTableRows. The primary use case
 272  * for creating custom TreeTableRow instances would most probably be to introduce
 273  * some form of column spanning support.
 274  *
 275  * &lt;p&gt;You can create custom {@link TreeTableCell} instances per column by assigning
 276  * the appropriate function to the TreeTableColumns
 277  * {@link TreeTableColumn#cellFactoryProperty() cell factory} property.
 278  *
 279  * &lt;p&gt;See the {@link Cell} class documentation for a more complete
 280  * description of how to write custom Cells.
 281  *
 282  * &lt;h3&gt;Editing&lt;/h3&gt;
 283  * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 284  * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 285  *
 286  * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 287  * than when a cell is not being edited. This is the responsibility of the
 288  * {@link Cell} implementation being used. For TreeTableView, it is highly
 289  * recommended that editing be
 290  * {@link javafx.scene.control.TreeTableColumn#cellFactoryProperty() per-TreeTableColumn},
 291  * rather than {@link #rowFactoryProperty() per row}, as more often than not
 292  * you want users to edit each column value differently, and this approach allows
 293  * for editors specific to each column. It is your choice whether the cell is
 294  * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 295  * or to switch to a different UI when editing begins (e.g. when a double-click
 296  * is received on a cell).&lt;/p&gt;
 297  *
 298  * &lt;p&gt;To know when editing has been requested on a cell,
 299  * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 300  * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 301  * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 302  * appropriate (e.g. set the text to null and set the graphic to be a
 303  * {@link TextField}). Additionally, you should also override
 304  * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 305  * when the editing concludes. In both cases it is important that you also
 306  * ensure that you call the super method to have the cell perform all duties it
 307  * must do to enter or exit its editing mode.&lt;/p&gt;
 308  *
 309  * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 310  * interested in is how to commit or cancel the editing that is taking place. This is your
 311  * responsibility as the cell factory provider. Your cell implementation will know
 312  * when the editing is over, based on the user input (e.g. when the user presses
 313  * the Enter or ESC keys on their keyboard). When this happens, it is your
 314  * responsibility to call {@link Cell#commitEdit(Object)} or
 315  * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 316  *
 317  * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 318  * TreeTableView, which you can observe by adding an {@link EventHandler} via
 319  * {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 320  * you can also observe edit events for
 321  * {@link TreeTableColumn#setOnEditStart(javafx.event.EventHandler) edit start}
 322  * and {@link TreeTableColumn#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 323  *
 324  * &lt;p&gt;By default the TreeTableColumn edit commit handler is non-null, with a default
 325  * handler that attempts to overwrite the property value for the
 326  * item in the currently-being-edited row. It is able to do this as the
 327  * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 328  * is passed along to the edit commit handler via the
 329  * {@link javafx.scene.control.TreeTableColumn.CellEditEvent CellEditEvent} that is
 330  * fired. It is simply a matter of calling
 331  * {@link javafx.scene.control.TreeTableColumn.CellEditEvent#getNewValue()} to
 332  * retrieve this value.
 333  *
 334  * &lt;p&gt;It is very important to note that if you call
 335  * {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler)} with your own
 336  * {@link EventHandler}, then you will be removing the default handler. Unless
 337  * you then handle the writeback to the property (or the relevant data source),
 338  * nothing will happen. You can work around this by using the
 339  * {@link TreeTableColumn#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 340  * method to add a {@link TreeTableColumn#EDIT_COMMIT_EVENT} {@link EventType} with
 341  * your desired {@link EventHandler} as the second argument. Using this method,
 342  * you will not replace the default implementation, but you will be notified when
 343  * an edit commit has occurred.&lt;/p&gt;
 344  *
 345  * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 346  * Fortunately, JavaFX ships with a number of pre-built cell factories that
 347  * handle all the editing requirements on your behalf. You can find these
 348  * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 349  *
 350  * @see TreeTableColumn
 351  * @see TreeTablePosition
 352  * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView.
 353  * @since JavaFX 8.0
 354  */
 355 @DefaultProperty(&quot;root&quot;)
 356 public class TreeTableView&lt;S&gt; extends Control {
 357 
 358     /***************************************************************************
 359      *                                                                         *
 360      * Constructors                                                            *
 361      *                                                                         *
 362      **************************************************************************/
 363 
 364     /**
 365      * Creates an empty TreeTableView.
 366      *
 367      * &lt;p&gt;Refer to the {@link TreeTableView} class documentation for details on the
 368      * default state of other properties.
 369      */
 370     public TreeTableView() {
 371         this(null);
 372     }
 373 
 374     /**
 375      * Creates a TreeTableView with the provided root node.
 376      *
 377      * &lt;p&gt;Refer to the {@link TreeTableView} class documentation for details on the
 378      * default state of other properties.
 379      *
 380      * @param root The node to be the root in this TreeTableView.
 381      */
 382     public TreeTableView(TreeItem&lt;S&gt; root) {
 383         getStyleClass().setAll(DEFAULT_STYLE_CLASS);
 384         setAccessibleRole(AccessibleRole.TREE_TABLE_VIEW);
 385 
 386         setRoot(root);
 387         updateExpandedItemCount(root);
 388 
 389         // install default selection and focus models - it&#39;s unlikely this will be changed
 390         // by many users.
 391         setSelectionModel(new TreeTableViewArrayListSelectionModel&lt;S&gt;(this));
 392         setFocusModel(new TreeTableViewFocusModel&lt;S&gt;(this));
 393 
 394         // we watch the columns list, such that when it changes we can update
 395         // the leaf columns and visible leaf columns lists (which are read-only).
 396         getColumns().addListener(weakColumnsObserver);
 397 
 398         // watch for changes to the sort order list - and when it changes run
 399         // the sort method.
 400         getSortOrder().addListener((ListChangeListener.Change&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; c) -&gt; {
 401             doSort(TableUtil.SortEventType.SORT_ORDER_CHANGE, c);
 402         });
 403 
 404         // We&#39;re watching for changes to the content width such
 405         // that the resize policy can be run if necessary. This comes from
 406         // TreeTableViewSkin.
 407         getProperties().addListener((MapChangeListener&lt;Object, Object&gt;) c -&gt; {
 408             if (c.wasAdded() &amp;&amp; TableView.SET_CONTENT_WIDTH.equals(c.getKey())) {
 409                 if (c.getValueAdded() instanceof Number) {
 410                     setContentWidth((Double) c.getValueAdded());
 411                 }
 412                 getProperties().remove(TableView.SET_CONTENT_WIDTH);
 413             }
 414         });
 415 
 416         isInited = true;
 417     }
 418 
 419 
 420 
 421     /***************************************************************************
 422      *                                                                         *
 423      * Static properties and methods                                           *
 424      *                                                                         *
 425      **************************************************************************/
 426 
 427     /**
 428      * An EventType that indicates some edit event has occurred. It is the parent
 429      * type of all other edit events: {@link #editStartEvent},
 430      *  {@link #editCommitEvent} and {@link #editCancelEvent}.
 431      *
 432      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 433      * @return An EventType that indicates some edit event has occurred
 434      */
 435     @SuppressWarnings(&quot;unchecked&quot;)
 436     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editAnyEvent() {
 437         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_ANY_EVENT;
 438     }
 439     private static final EventType&lt;?&gt; EDIT_ANY_EVENT =
 440             new EventType&lt;&gt;(Event.ANY, &quot;TREE_TABLE_VIEW_EDIT&quot;);
 441 
 442     /**
 443      * An EventType used to indicate that an edit event has started within the
 444      * TreeTableView upon which the event was fired.
 445      *
 446      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 447      * @return An EventType used to indicate that an edit event has started
 448      */
 449     @SuppressWarnings(&quot;unchecked&quot;)
 450     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editStartEvent() {
 451         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_START_EVENT;
 452     }
 453     private static final EventType&lt;?&gt; EDIT_START_EVENT =
 454             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_START&quot;);
 455 
 456     /**
 457      * An EventType used to indicate that an edit event has just been canceled
 458      * within the TreeTableView upon which the event was fired.
 459      *
 460      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 461      * @return An EventType used to indicate that an edit event has just been
 462      *      canceled
 463      */
 464     @SuppressWarnings(&quot;unchecked&quot;)
 465     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editCancelEvent() {
 466         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_CANCEL_EVENT;
 467     }
 468     private static final EventType&lt;?&gt; EDIT_CANCEL_EVENT =
 469             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_CANCEL&quot;);
 470 
 471     /**
 472      * An EventType that is used to indicate that an edit in a TreeTableView has been
 473      * committed. This means that user has made changes to the data of a
 474      * TreeItem, and that the UI should be updated.
 475      *
 476      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 477      * @return An EventType that is used to indicate that an edit in a TreeTableView
 478      *      has been committed
 479      */
 480     @SuppressWarnings(&quot;unchecked&quot;)
 481     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editCommitEvent() {
 482         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_COMMIT_EVENT;
 483     }
 484     private static final EventType&lt;?&gt; EDIT_COMMIT_EVENT =
 485             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_COMMIT&quot;);
 486 
 487     /**
 488      * Returns the number of levels of &#39;indentation&#39; of the given TreeItem,
 489      * based on how many times {@link javafx.scene.control.TreeItem#getParent()}
 490      * can be recursively called. If the TreeItem does not have any parent set,
 491      * the returned value will be zero. For each time getParent() is recursively
 492      * called, the returned value is incremented by one.
 493      *
 494      * &lt;p&gt;&lt;strong&gt;Important note: &lt;/strong&gt;This method is deprecated as it does
 495      * not consider the root node. This means that this method will iterate
 496      * past the root node of the TreeTableView control, if the root node has a parent.
 497      * If this is important, call {@link TreeTableView#getTreeItemLevel(TreeItem)}
 498      * instead.
 499      *
 500      * @param node The TreeItem for which the level is needed.
 501      * @return An integer representing the number of parents above the given node,
 502      *         or -1 if the given TreeItem is null.
 503      * @deprecated This method does not correctly calculate the distance from the
 504      *          given TreeItem to the root of the TreeTableView. As of JavaFX 8.0_20,
 505      *          the proper way to do this is via
 506      *          {@link TreeTableView#getTreeItemLevel(TreeItem)}
 507      */
 508     @Deprecated(since=&quot;8u20&quot;)
 509     public static int getNodeLevel(TreeItem&lt;?&gt; node) {
 510         return TreeView.getNodeLevel(node);
 511     }
 512 
 513     /**
 514      * &lt;p&gt;Very simple resize policy that just resizes the specified column by the
 515      * provided delta and shifts all other columns (to the right of the given column)
 516      * further to the right (when the delta is positive) or to the left (when the
 517      * delta is negative).
 518      *
 519      * &lt;p&gt;It also handles the case where we have nested columns by sharing the new space,
 520      * or subtracting the removed space, evenly between all immediate children columns.
 521      * Of course, the immediate children may themselves be nested, and they would
 522      * then use this policy on their children.
 523      */
 524     public static final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; UNCONSTRAINED_RESIZE_POLICY =
 525             new Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;() {
 526 
 527         @Override public String toString() {
 528             return &quot;unconstrained-resize&quot;;
 529         }
 530 
 531         @Override public Boolean call(TreeTableView.ResizeFeatures prop) {
 532             double result = TableUtil.resize(prop.getColumn(), prop.getDelta());
 533             return Double.compare(result, 0.0) == 0;
 534         }
 535     };
 536 
 537     /**
 538      * &lt;p&gt;Simple policy that ensures the width of all visible leaf columns in
 539      * this table sum up to equal the width of the table itself.
 540      *
 541      * &lt;p&gt;When the user resizes a column width with this policy, the table automatically
 542      * adjusts the width of the right hand side columns. When the user increases a
 543      * column width, the table decreases the width of the rightmost column until it
 544      * reaches its minimum width. Then it decreases the width of the second
 545      * rightmost column until it reaches minimum width and so on. When all right
 546      * hand side columns reach minimum size, the user cannot increase the size of
 547      * resized column any more.
 548      */
 549     public static final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; CONSTRAINED_RESIZE_POLICY =
 550             new Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;() {
 551 
 552         private boolean isFirstRun = true;
 553 
 554         @Override public String toString() {
 555             return &quot;constrained-resize&quot;;
 556         }
 557 
 558         @Override public Boolean call(TreeTableView.ResizeFeatures prop) {
 559             TreeTableView&lt;?&gt; table = prop.getTable();
 560             List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumns = table.getVisibleLeafColumns();
 561             Boolean result = TableUtil.constrainedResize(prop,
 562                                                isFirstRun,
 563                                                table.contentWidth,
 564                                                visibleLeafColumns);
 565             isFirstRun = ! isFirstRun ? false : ! result;
 566             return result;
 567         }
 568     };
 569 
 570     /**
 571      * The default {@link #sortPolicyProperty() sort policy} that this TreeTableView
 572      * will use if no other policy is specified. The sort policy is a simple
 573      * {@link Callback} that accepts a TreeTableView as the sole argument and expects
 574      * a Boolean response representing whether the sort succeeded or not. A Boolean
 575      * response of true represents success, and a response of false (or null) will
 576      * be considered to represent failure.
 577      */
 578     public static final Callback&lt;TreeTableView, Boolean&gt; DEFAULT_SORT_POLICY = new Callback&lt;TreeTableView, Boolean&gt;() {
 579         @Override public Boolean call(TreeTableView table) {
 580             try {
 581                 TreeItem rootItem = table.getRoot();
 582                 if (rootItem == null) return false;
 583 
 584                 TreeSortMode sortMode = table.getSortMode();
 585                 if (sortMode == null) return false;
 586 
 587                 rootItem.lastSortMode = sortMode;
 588                 rootItem.lastComparator = table.getComparator();
 589                 rootItem.sort();
 590                 return true;
 591             } catch (UnsupportedOperationException e) {
 592                 // TODO might need to support other exception types including:
 593                 // ClassCastException - if the class of the specified element prevents it from being added to this list
 594                 // NullPointerException - if the specified element is null and this list does not permit null elements
 595                 // IllegalArgumentException - if some property of this element prevents it from being added to this list
 596 
 597                 // If we are here the list does not support sorting, so we gracefully
 598                 // fail the sort request and ensure the UI is put back to its previous
 599                 // state. This is handled in the code that calls the sort policy.
 600 
 601                 return false;
 602             }
 603         }
 604     };
 605 
 606 
 607 
 608     /***************************************************************************
 609      *                                                                         *
 610      * Instance Variables                                                      *
 611      *                                                                         *
 612      **************************************************************************/
 613 
 614     // used in the tree item modification event listener. Used by the
 615     // layoutChildren method to determine whether the tree item count should
 616     // be recalculated.
 617     private boolean expandedItemCountDirty = true;
 618 
 619     // Used in the getTreeItem(int row) method to act as a cache.
 620     // See RT-26716 for the justification and performance gains.
 621     private Map&lt;Integer, SoftReference&lt;TreeItem&lt;S&gt;&gt;&gt; treeItemCacheMap = new HashMap&lt;&gt;();
 622 
 623     // this is the only publicly writable list for columns. This represents the
 624     // columns as they are given initially by the developer.
 625     private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = FXCollections.observableArrayList();
 626 
 627     // Finally, as convenience, we also have an observable list that contains
 628     // only the leaf columns that are currently visible.
 629     private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; visibleLeafColumns = FXCollections.observableArrayList();
 630     private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; unmodifiableVisibleLeafColumns = FXCollections.unmodifiableObservableList(visibleLeafColumns);
 631 
 632     // Allows for multiple column sorting based on the order of the TreeTableColumns
 633     // in this observableArrayList. Each TreeTableColumn is responsible for whether it is
 634     // sorted using ascending or descending order.
 635     private ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = FXCollections.observableArrayList();
 636 
 637     // width of VirtualFlow minus the vbar width
 638     // package protected for testing only
 639     double contentWidth;
 640 
 641     // Used to minimise the amount of work performed prior to the table being
 642     // completely initialised. In particular it reduces the amount of column
 643     // resize operations that occur, which slightly improves startup time.
 644     private boolean isInited = false;
 645 
 646 
 647 
 648     /***************************************************************************
 649      *                                                                         *
 650      * Callbacks and Events                                                    *
 651      *                                                                         *
 652      **************************************************************************/
 653 
 654     // we use this to forward events that have bubbled up TreeItem instances
 655     // to the TreeTableViewSkin, to force it to recalculate teh item count and redraw
 656     // if necessary
 657     private final EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; rootEvent = e -&gt; {
 658         // this forces layoutChildren at the next pulse, and therefore
 659         // updates the item count if necessary
 660         EventType&lt;?&gt; eventType = e.getEventType();
 661         boolean match = false;
 662         while (eventType != null) {
 663             if (eventType.equals(TreeItem.&lt;S&gt;expandedItemCountChangeEvent())) {
 664                 match = true;
 665                 break;
 666             }
 667             eventType = eventType.getSuperType();
 668         }
 669 
 670         if (match) {
 671             expandedItemCountDirty = true;
 672             requestLayout();
 673         }
 674     };
 675 
 676     private final ListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt; columnsObserver = new ListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt;() {
 677         @Override public void onChanged(ListChangeListener.Change&lt;? extends TreeTableColumn&lt;S,?&gt;&gt; c) {
 678             final List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getColumns();
 679 
 680             // Fix for RT-39822 - don&#39;t allow the same column to be installed twice
 681             while (c.next()) {
 682                 if (c.wasAdded()) {
 683                     List&lt;TreeTableColumn&lt;S,?&gt;&gt; duplicates = new ArrayList&lt;&gt;();
 684                     for (TreeTableColumn&lt;S,?&gt; addedColumn : c.getAddedSubList()) {
 685                         if (addedColumn == null) continue;
 686 
 687                         int count = 0;
 688                         for (TreeTableColumn&lt;S,?&gt; column : columns) {
 689                             if (addedColumn == column) {
 690                                 count++;
 691                             }
 692                         }
 693 
 694                         if (count &gt; 1) {
 695                             duplicates.add(addedColumn);
 696                         }
 697                     }
 698 
 699                     if (!duplicates.isEmpty()) {
 700                         String titleList = &quot;&quot;;
 701                         for (TreeTableColumn&lt;S,?&gt; dupe : duplicates) {
 702                             titleList += &quot;&#39;&quot; + dupe.getText() + &quot;&#39;, &quot;;
 703                         }
 704                         throw new IllegalStateException(&quot;Duplicate TreeTableColumns detected in TreeTableView columns list with titles &quot; + titleList);
 705                     }
 706                 }
 707             }
 708             c.reset();
 709 
 710             // Fix for RT-15194: Need to remove removed columns from the
 711             // sortOrder list.
 712             List&lt;TreeTableColumn&lt;S,?&gt;&gt; toRemove = new ArrayList&lt;TreeTableColumn&lt;S,?&gt;&gt;();
 713             while (c.next()) {
 714                 final List&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; removed = c.getRemoved();
 715                 final List&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; added = c.getAddedSubList();
 716 
 717                 if (c.wasRemoved()) {
 718                     toRemove.addAll(removed);
 719                     for (TreeTableColumn&lt;S,?&gt; tc : removed) {
 720                         tc.setTreeTableView(null);
 721                     }
 722                 }
 723 
 724                 if (c.wasAdded()) {
 725                     toRemove.removeAll(added);
 726                     for (TreeTableColumn&lt;S,?&gt; tc : added) {
 727                         tc.setTreeTableView(TreeTableView.this);
 728                     }
 729                 }
 730 
 731                 // set up listeners
 732                 TableUtil.removeColumnsListener(removed, weakColumnsObserver);
 733                 TableUtil.addColumnsListener(added, weakColumnsObserver);
 734 
 735                 TableUtil.removeTableColumnListener(c.getRemoved(),
 736                         weakColumnVisibleObserver,
 737                         weakColumnSortableObserver,
 738                         weakColumnSortTypeObserver,
 739                         weakColumnComparatorObserver);
 740                 TableUtil.addTableColumnListener(c.getAddedSubList(),
 741                         weakColumnVisibleObserver,
 742                         weakColumnSortableObserver,
 743                         weakColumnSortTypeObserver,
 744                         weakColumnComparatorObserver);
 745             }
 746 
 747             // We don&#39;t maintain a bind for leafColumns, we simply call this update
 748             // function behind the scenes in the appropriate places.
 749             updateVisibleLeafColumns();
 750 
 751             sortOrder.removeAll(toRemove);
 752 
 753             // Fix for RT-38892.
 754             final TreeTableViewFocusModel&lt;S&gt; fm = getFocusModel();
 755             final TreeTableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
 756             c.reset();
 757 
 758             // we need to collect together all removed and all added columns, because
 759             // the code below works on the actually removed columns. If we perform
 760             // the code within this while loop, we&#39;ll be deselecting columns that
 761             // should be deselected (because they have just moved place, for example).
 762             List&lt;TreeTableColumn&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;();
 763             List&lt;TreeTableColumn&lt;S,?&gt;&gt; added = new ArrayList&lt;&gt;();
 764             while (c.next()) {
 765                 if (c.wasRemoved()) {
 766                     removed.addAll(c.getRemoved());
 767                 }
 768                 if (c.wasAdded()) {
 769                     added.addAll(c.getAddedSubList());
 770                 }
 771             }
 772             removed.removeAll(added);
 773 
 774 
 775             // Fix for focus - we simply move focus to a cell to the left
 776             // of the focused cell if the focused cell was located within
 777             // a column that has been removed.
 778             if (fm != null) {
 779                 TreeTablePosition&lt;S, ?&gt; focusedCell = fm.getFocusedCell();
 780                 boolean match = false;
 781                 for (TreeTableColumn&lt;S, ?&gt; tc : removed) {
 782                     match = focusedCell != null &amp;&amp; focusedCell.getTableColumn() == tc;
 783                     if (match) {
 784                         break;
 785                     }
 786                 }
 787 
 788                 if (match) {
 789                     int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(focusedCell.getTableColumn(), 0);
 790                     int newFocusColumnIndex =
 791                             matchingColumnIndex == 0 ? 0 :
 792                                     Math.min(getVisibleLeafColumns().size() - 1, matchingColumnIndex - 1);
 793                     fm.focus(focusedCell.getRow(), getVisibleLeafColumn(newFocusColumnIndex));
 794                 }
 795             }
 796 
 797             // Fix for selection - we remove selection from all cells that
 798             // were within the removed column.
 799             if (sm != null) {
 800                 List&lt;TreeTablePosition&gt; selectedCells = new ArrayList&lt;&gt;(sm.getSelectedCells());
 801                 for (TreeTablePosition selectedCell : selectedCells) {
 802                     boolean match = false;
 803                     for (TreeTableColumn&lt;S, ?&gt; tc : removed) {
 804                         match = selectedCell != null &amp;&amp; selectedCell.getTableColumn() == tc;
 805                         if (match) break;
 806                     }
 807 
 808                     if (match) {
 809                         // we can&#39;t just use the selectedCell.getTableColumn(), as that
 810                         // column no longer exists and therefore its index is not correct.
 811                         int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(selectedCell.getTableColumn(), -1);
 812                         if (matchingColumnIndex == -1) continue;
 813 
 814                         if (sm instanceof TreeTableViewArrayListSelectionModel) {
 815                             // Also, because the table column no longer exists in the columns
 816                             // list at this point, we can&#39;t just call:
 817                             // sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
 818                             // as the tableColumn would map to an index of -1, which means that
 819                             // selection will not be cleared. Instead, we have to create
 820                             // a new TablePosition with a fixed column index and use that.
 821                             TreeTablePosition&lt;S,?&gt; fixedTablePosition =
 822                                     new TreeTablePosition&lt;S,Object&gt;(TreeTableView.this,
 823                                             selectedCell.getRow(),
 824                                             selectedCell.getTableColumn());
 825                             fixedTablePosition.fixedColumnIndex = matchingColumnIndex;
 826 
 827                             ((TreeTableViewArrayListSelectionModel)sm).clearSelection(fixedTablePosition);
 828                         } else {
 829                             sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
 830                         }
 831                     }
 832                 }
 833             }
 834 
 835 
 836             // update the lastKnownColumnIndex map
 837             lastKnownColumnIndex.clear();
 838             for (TreeTableColumn&lt;S,?&gt; tc : getColumns()) {
 839                 int index = getVisibleLeafIndex(tc);
 840                 if (index &gt; -1) {
 841                     lastKnownColumnIndex.put(tc, index);
 842                 }
 843             }
 844         }
 845     };
 846 
 847     private final WeakHashMap&lt;TreeTableColumn&lt;S,?&gt;, Integer&gt; lastKnownColumnIndex = new WeakHashMap&lt;&gt;();
 848 
 849     private final InvalidationListener columnVisibleObserver = valueModel -&gt; {
 850         updateVisibleLeafColumns();
 851     };
 852 
 853     private final InvalidationListener columnSortableObserver = valueModel -&gt; {
 854         TreeTableColumn col = (TreeTableColumn) ((BooleanProperty)valueModel).getBean();
 855         if (! getSortOrder().contains(col)) return;
 856         doSort(TableUtil.SortEventType.COLUMN_SORTABLE_CHANGE, col);
 857     };
 858 
 859     private final InvalidationListener columnSortTypeObserver = valueModel -&gt; {
 860         TreeTableColumn col = (TreeTableColumn) ((ObjectProperty)valueModel).getBean();
 861         if (! getSortOrder().contains(col)) return;
 862         doSort(TableUtil.SortEventType.COLUMN_SORT_TYPE_CHANGE, col);
 863     };
 864 
 865     private final InvalidationListener columnComparatorObserver = valueModel -&gt; {
 866         TreeTableColumn col = (TreeTableColumn) ((SimpleObjectProperty)valueModel).getBean();
 867         if (! getSortOrder().contains(col)) return;
 868         doSort(TableUtil.SortEventType.COLUMN_COMPARATOR_CHANGE, col);
 869     };
 870 
 871     /* proxy pseudo-class state change from selectionModel&#39;s cellSelectionEnabledProperty */
 872     private final InvalidationListener cellSelectionModelInvalidationListener = o -&gt; {
 873         boolean isCellSelection = ((BooleanProperty)o).get();
 874         pseudoClassStateChanged(PSEUDO_CLASS_CELL_SELECTION,  isCellSelection);
 875         pseudoClassStateChanged(PSEUDO_CLASS_ROW_SELECTION,  !isCellSelection);
 876     };
 877 
 878     private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakRootEventListener;
 879 
 880     private final WeakInvalidationListener weakColumnVisibleObserver =
 881             new WeakInvalidationListener(columnVisibleObserver);
 882 
 883     private final WeakInvalidationListener weakColumnSortableObserver =
 884             new WeakInvalidationListener(columnSortableObserver);
 885 
 886     private final WeakInvalidationListener weakColumnSortTypeObserver =
 887             new WeakInvalidationListener(columnSortTypeObserver);
 888 
 889     private final WeakInvalidationListener weakColumnComparatorObserver =
 890             new WeakInvalidationListener(columnComparatorObserver);
 891 
 892     private final WeakListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt; weakColumnsObserver =
 893             new WeakListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt;(columnsObserver);
 894 
 895     private final WeakInvalidationListener weakCellSelectionModelInvalidationListener =
 896             new WeakInvalidationListener(cellSelectionModelInvalidationListener);
 897 
 898 
 899 
 900     /***************************************************************************
 901      *                                                                         *
 902      * Properties                                                              *
 903      *                                                                         *
 904      **************************************************************************/
 905 
 906     // --- Root
 907     private ObjectProperty&lt;TreeItem&lt;S&gt;&gt; root = new SimpleObjectProperty&lt;TreeItem&lt;S&gt;&gt;(this, &quot;root&quot;) {
 908         private WeakReference&lt;TreeItem&lt;S&gt;&gt; weakOldItem;
 909 
 910         @Override protected void invalidated() {
 911             TreeItem&lt;S&gt; oldTreeItem = weakOldItem == null ? null : weakOldItem.get();
 912             if (oldTreeItem != null &amp;&amp; weakRootEventListener != null) {
 913                 oldTreeItem.removeEventHandler(TreeItem.&lt;S&gt;treeNotificationEvent(), weakRootEventListener);
 914             }
 915 
 916             TreeItem&lt;S&gt; root = getRoot();
 917             if (root != null) {
 918                 weakRootEventListener = new WeakEventHandler&lt;&gt;(rootEvent);
 919                 getRoot().addEventHandler(TreeItem.&lt;S&gt;treeNotificationEvent(), weakRootEventListener);
 920                 weakOldItem = new WeakReference&lt;&gt;(root);
 921             }
 922 
 923             // Fix for RT-35763
 924             getSortOrder().clear();
 925 
 926             expandedItemCountDirty = true;
 927             updateRootExpanded();
 928         }
 929     };
 930 
 931     /**
 932      * Sets the root node in this TreeTableView. See the {@link TreeItem} class level
 933      * documentation for more details.
 934      *
 935      * @param value The {@link TreeItem} that will be placed at the root of the
 936      *      TreeTableView.
 937      */
 938     public final void setRoot(TreeItem&lt;S&gt; value) {
 939         rootProperty().set(value);
 940     }
 941 
 942     /**
 943      * Returns the current root node of this TreeTableView, or null if no root node
 944      * is specified.
 945      * @return The current root node, or null if no root node exists.
 946      */
 947     public final TreeItem&lt;S&gt; getRoot() {
 948         return root == null ? null : root.get();
 949     }
 950 
 951     /**
 952      * Property representing the root node of the TreeTableView.
 953      * @return the root property
 954      */
 955     public final ObjectProperty&lt;TreeItem&lt;S&gt;&gt; rootProperty() {
 956         return root;
 957     }
 958 
 959 
 960 
 961     // --- Show Root
 962     private BooleanProperty showRoot;
 963 
 964     /**
 965      * Specifies whether the root {@code TreeItem} should be shown within this
 966      * TreeTableView.
 967      *
 968      * @param value If true, the root TreeItem will be shown, and if false it
 969      *      will be hidden.
 970      */
 971     public final void setShowRoot(boolean value) {
 972         showRootProperty().set(value);
 973     }
 974 
 975     /**
 976      * Returns true if the root of the TreeTableView should be shown, and false if
 977      * it should not. By default, the root TreeItem is visible in the TreeTableView.
 978      * @return true if the root of the TreeTableView should be shown
 979      */
 980     public final boolean isShowRoot() {
 981         return showRoot == null ? true : showRoot.get();
 982     }
 983 
 984     /**
 985      * Property that represents whether or not the TreeTableView root node is visible.
 986      * @return the show root property
 987      */
 988     public final BooleanProperty showRootProperty() {
 989         if (showRoot == null) {
 990             showRoot = new SimpleBooleanProperty(this, &quot;showRoot&quot;, true) {
 991                 @Override protected void invalidated() {
 992                     updateRootExpanded();
 993                     updateExpandedItemCount(getRoot());
 994                 }
 995             };
 996         }
 997         return showRoot;
 998     }
 999 
1000 
1001 
1002     // --- Tree Column
1003     private ObjectProperty&lt;TreeTableColumn&lt;S,?&gt;&gt; treeColumn;
1004     /**
1005      * Property that represents which column should have the disclosure node
1006      * shown in it (that is, the column with the arrow). By default this will be
1007      * the left-most column if this property is null, otherwise it will be the
1008      * specified column assuming it is non-null and contained within the
1009      * {@link #getVisibleLeafColumns() visible leaf columns} list.
1010      * @return the tree column property
1011      */
1012     public final ObjectProperty&lt;TreeTableColumn&lt;S,?&gt;&gt; treeColumnProperty() {
1013         if (treeColumn == null) {
1014             treeColumn = new SimpleObjectProperty&lt;&gt;(this, &quot;treeColumn&quot;, null);
1015         }
1016         return treeColumn;
1017     }
1018     public final void setTreeColumn(TreeTableColumn&lt;S,?&gt; value) {
1019         treeColumnProperty().set(value);
1020     }
1021     public final TreeTableColumn&lt;S,?&gt; getTreeColumn() {
1022         return treeColumn == null ? null : treeColumn.get();
1023     }
1024 
1025 
1026 
1027     // --- Selection Model
1028     private ObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt; selectionModel;
1029 
1030     /**
1031      * Sets the {@link MultipleSelectionModel} to be used in the TreeTableView.
1032      * Despite a TreeTableView requiring a &lt;code&gt;&lt;b&gt;Multiple&lt;/b&gt;SelectionModel&lt;/code&gt;,
1033      * it is possible to configure it to only allow single selection (see
1034      * {@link MultipleSelectionModel#setSelectionMode(javafx.scene.control.SelectionMode)}
1035      * for more information).
1036      * @param value the {@link MultipleSelectionModel} to be used
1037      */
1038     public final void setSelectionModel(TreeTableViewSelectionModel&lt;S&gt; value) {
1039         selectionModelProperty().set(value);
1040     }
1041 
1042     /**
1043      * Returns the currently installed selection model.
1044      * @return the currently installed selection model
1045      */
1046     public final TreeTableViewSelectionModel&lt;S&gt; getSelectionModel() {
1047         return selectionModel == null ? null : selectionModel.get();
1048     }
1049 
1050     /**
1051      * The SelectionModel provides the API through which it is possible
1052      * to select single or multiple items within a TreeTableView, as  well as inspect
1053      * which rows have been selected by the user. Note that it has a generic
1054      * type that must match the type of the TreeTableView itself.
1055      * @return the selection model property
1056      */
1057     public final ObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt; selectionModelProperty() {
1058         if (selectionModel == null) {
1059             selectionModel = new SimpleObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt;(this, &quot;selectionModel&quot;) {
1060 
1061                 TreeTableViewSelectionModel&lt;S&gt; oldValue = null;
1062 
1063                 @Override protected void invalidated() {
1064                     // need to listen to the cellSelectionEnabledProperty
1065                     // in order to set pseudo-class state
1066                     if (oldValue != null) {
1067                         oldValue.cellSelectionEnabledProperty().removeListener(weakCellSelectionModelInvalidationListener);
1068 
1069                         if (oldValue instanceof TreeTableViewArrayListSelectionModel) {
1070                             ((TreeTableViewArrayListSelectionModel)oldValue).dispose();
1071                         }
1072                     }
1073 
1074                     oldValue = get();
1075 
1076                     if (oldValue != null) {
1077                         oldValue.cellSelectionEnabledProperty().addListener(weakCellSelectionModelInvalidationListener);
1078                         // fake invalidation to ensure updated pseudo-class states
1079                         weakCellSelectionModelInvalidationListener.invalidated(oldValue.cellSelectionEnabledProperty());
1080                     }
1081                 }
1082             };
1083         }
1084         return selectionModel;
1085     }
1086 
1087 
1088     // --- Focus Model
1089     private ObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt; focusModel;
1090 
1091     /**
1092      * Sets the {@link FocusModel} to be used in the TreeTableView.
1093      * @param value the {@link FocusModel} to be used
1094      */
1095     public final void setFocusModel(TreeTableViewFocusModel&lt;S&gt; value) {
1096         focusModelProperty().set(value);
1097     }
1098 
1099     /**
1100      * Returns the currently installed {@link FocusModel}.
1101      * @return the currently installed {@link FocusModel}
1102      */
1103     public final TreeTableViewFocusModel&lt;S&gt; getFocusModel() {
1104         return focusModel == null ? null : focusModel.get();
1105     }
1106 
1107     /**
1108      * The FocusModel provides the API through which it is possible
1109      * to control focus on zero or one rows of the TreeTableView. Generally the
1110      * default implementation should be more than sufficient.
1111      * @return the focus model property
1112      */
1113     public final ObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt; focusModelProperty() {
1114         if (focusModel == null) {
1115             focusModel = new SimpleObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt;(this, &quot;focusModel&quot;);
1116         }
1117         return focusModel;
1118     }
1119 
1120 
1121     // --- Tree node count
1122     /**
1123      * &lt;p&gt;Represents the number of tree nodes presently able to be visible in the
1124      * TreeTableView. This is essentially the count of all expanded tree items, and
1125      * their children.
1126      *
1127      * &lt;p&gt;For example, if just the root node is visible, the expandedItemCount will
1128      * be one. If the root had three children and the root was expanded, the value
1129      * will be four.
1130      */
1131     private ReadOnlyIntegerWrapper expandedItemCount = new ReadOnlyIntegerWrapper(this, &quot;expandedItemCount&quot;, 0);
1132     public final ReadOnlyIntegerProperty expandedItemCountProperty() {
1133         return expandedItemCount.getReadOnlyProperty();
1134     }
1135     private void setExpandedItemCount(int value) {
1136         expandedItemCount.set(value);
1137     }
1138     public final int getExpandedItemCount() {
1139         if (expandedItemCountDirty) {
1140             updateExpandedItemCount(getRoot());
1141         }
1142         return expandedItemCount.get();
1143     }
1144 
1145 
1146     // --- Editable
1147     private BooleanProperty editable;
1148     public final void setEditable(boolean value) {
1149         editableProperty().set(value);
1150     }
1151     public final boolean isEditable() {
1152         return editable == null ? false : editable.get();
1153     }
1154     /**
1155      * Specifies whether this TreeTableView is editable - only if the TreeTableView and
1156      * the TreeCells within it are both editable will a TreeCell be able to go
1157      * into their editing state.
1158      * @return the editable property
1159      */
1160     public final BooleanProperty editableProperty() {
1161         if (editable == null) {
1162             editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
1163         }
1164         return editable;
1165     }
1166 
1167 
1168     // --- Editing Cell
1169     private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCell;
1170     private void setEditingCell(TreeTablePosition&lt;S,?&gt; value) {
1171         editingCellPropertyImpl().set(value);
1172     }
1173     public final TreeTablePosition&lt;S,?&gt; getEditingCell() {
1174         return editingCell == null ? null : editingCell.get();
1175     }
1176 
1177     /**
1178      * Represents the current cell being edited, or null if
1179      * there is no cell being edited.
1180      * @return the editing cell property
1181      */
1182     public final ReadOnlyObjectProperty&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCellProperty() {
1183         return editingCellPropertyImpl().getReadOnlyProperty();
1184     }
1185 
1186     private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCellPropertyImpl() {
1187         if (editingCell == null) {
1188             editingCell = new ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt;(this, &quot;editingCell&quot;);
1189         }
1190         return editingCell;
1191     }
1192 
1193 
1194     // --- Table menu button visible
1195     private BooleanProperty tableMenuButtonVisible;
1196     /**
1197      * This controls whether a menu button is available when the user clicks
1198      * in a designated space within the TableView, within which is a radio menu
1199      * item for each TreeTableColumn in this table. This menu allows for the user to
1200      * show and hide all TreeTableColumns easily.
1201      * @return the table menu button visible property
1202      */
1203     public final BooleanProperty tableMenuButtonVisibleProperty() {
1204         if (tableMenuButtonVisible == null) {
1205             tableMenuButtonVisible = new SimpleBooleanProperty(this, &quot;tableMenuButtonVisible&quot;);
1206         }
1207         return tableMenuButtonVisible;
1208     }
1209     public final void setTableMenuButtonVisible (boolean value) {
1210         tableMenuButtonVisibleProperty().set(value);
1211     }
1212     public final boolean isTableMenuButtonVisible() {
1213         return tableMenuButtonVisible == null ? false : tableMenuButtonVisible.get();
1214     }
1215 
1216 
1217     // --- Column Resize Policy
1218     private ObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt; columnResizePolicy;
1219     public final void setColumnResizePolicy(Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; callback) {
1220         columnResizePolicyProperty().set(callback);
1221     }
1222     public final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; getColumnResizePolicy() {
1223         return columnResizePolicy == null ? UNCONSTRAINED_RESIZE_POLICY : columnResizePolicy.get();
1224     }
1225 
1226     /**
1227      * This is the function called when the user completes a column-resize
1228      * operation. The two most common policies are available as static functions
1229      * in the TableView class: {@link #UNCONSTRAINED_RESIZE_POLICY} and
1230      * {@link #CONSTRAINED_RESIZE_POLICY}.
1231      * @return the column resize policy property
1232      */
1233     public final ObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt; columnResizePolicyProperty() {
1234         if (columnResizePolicy == null) {
1235             columnResizePolicy = new SimpleObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt;(this, &quot;columnResizePolicy&quot;, UNCONSTRAINED_RESIZE_POLICY) {
1236                 private Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; oldPolicy;
1237 
1238                 @Override protected void invalidated() {
1239                     if (isInited) {
1240                         get().call(new TreeTableView.ResizeFeatures(TreeTableView.this, null, 0.0));
1241 
1242                         if (oldPolicy != null) {
1243                             PseudoClass state = PseudoClass.getPseudoClass(oldPolicy.toString());
1244                             pseudoClassStateChanged(state, false);
1245                         }
1246                         if (get() != null) {
1247                             PseudoClass state = PseudoClass.getPseudoClass(get().toString());
1248                             pseudoClassStateChanged(state, true);
1249                         }
1250                         oldPolicy = get();
1251                     }
1252                 }
1253             };
1254         }
1255         return columnResizePolicy;
1256     }
1257 
1258 
1259     // --- Row Factory
1260     private ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt; rowFactory;
1261 
1262     /**
1263      * A function which produces a TreeTableRow. The system is responsible for
1264      * reusing TreeTableRows. Return from this function a TreeTableRow which
1265      * might be usable for representing a single row in a TableView.
1266      * &lt;p&gt;
1267      * Note that a TreeTableRow is &lt;b&gt;not&lt;/b&gt; a TableCell. A TreeTableRow is
1268      * simply a container for a TableCell, and in most circumstances it is more
1269      * likely that you&#39;ll want to create custom TableCells, rather than
1270      * TreeTableRows. The primary use case for creating custom TreeTableRow
1271      * instances would most probably be to introduce some form of column
1272      * spanning support.
1273      * &lt;p&gt;
1274      * You can create custom TableCell instances per column by assigning the
1275      * appropriate function to the cellFactory property in the TreeTableColumn class.
1276      * @return the row factory property
1277      */
1278     public final ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt; rowFactoryProperty() {
1279         if (rowFactory == null) {
1280             rowFactory = new SimpleObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt;(this, &quot;rowFactory&quot;);
1281         }
1282         return rowFactory;
1283     }
1284     public final void setRowFactory(Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt; value) {
1285         rowFactoryProperty().set(value);
1286     }
1287     public final Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt; getRowFactory() {
1288         return rowFactory == null ? null : rowFactory.get();
1289     }
1290 
1291 
1292     // --- Placeholder Node
1293     private ObjectProperty&lt;Node&gt; placeholder;
1294     /**
1295      * This Node is shown to the user when the table has no content to show.
1296      * This may be the case because the table model has no data in the first
1297      * place, that a filter has been applied to the table model, resulting
1298      * in there being nothing to show the user, or that there are no currently
1299      * visible columns.
1300      * @return the placeholder property
1301      */
1302     public final ObjectProperty&lt;Node&gt; placeholderProperty() {
1303         if (placeholder == null) {
1304             placeholder = new SimpleObjectProperty&lt;Node&gt;(this, &quot;placeholder&quot;);
1305         }
1306         return placeholder;
1307     }
1308     public final void setPlaceholder(Node value) {
1309         placeholderProperty().set(value);
1310     }
1311     public final Node getPlaceholder() {
1312         return placeholder == null ? null : placeholder.get();
1313     }
1314 
1315 
1316     // --- Fixed cell size
1317     private DoubleProperty fixedCellSize;
1318 
1319     /**
1320      * Sets the new fixed cell size for this control. Any value greater than
1321      * zero will enable fixed cell size mode, whereas a zero or negative value
1322      * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
1323      * mode.
1324      *
1325      * @param value The new fixed cell size value, or a value less than or equal
1326      *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
1327      * @since JavaFX 8.0
1328      */
1329     public final void setFixedCellSize(double value) {
1330         fixedCellSizeProperty().set(value);
1331     }
1332 
1333     /**
1334      * Returns the fixed cell size value. A value less than or equal to zero is
1335      * used to represent that fixed cell size mode is disabled, and a value
1336      * greater than zero represents the size of all cells in this control.
1337      *
1338      * @return A double representing the fixed cell size of this control, or a
1339      *      value less than or equal to zero if fixed cell size mode is disabled.
1340      * @since JavaFX 8.0
1341      */
1342     public final double getFixedCellSize() {
1343         return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
1344     }
1345     /**
1346      * Specifies whether this control has cells that are a fixed height (of the
1347      * specified value). If this value is less than or equal to zero,
1348      * then all cells are individually sized and positioned. This is a slow
1349      * operation. Therefore, when performance matters and developers are not
1350      * dependent on variable cell sizes it is a good idea to set the fixed cell
1351      * size value. Generally cells are around 24px, so setting a fixed cell size
1352      * of 24 is likely to result in very little difference in visuals, but a
1353      * improvement to performance.
1354      *
1355      * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
1356      * This should not be confused with the -fx-cell-size property. The difference
1357      * between these two CSS properties is that -fx-cell-size will size all
1358      * cells to the specified size, but it will not enforce that this is the
1359      * only size (thus allowing for variable cell sizes, and preventing the
1360      * performance gains from being possible). Therefore, when performance matters
1361      * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
1362      * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
1363      *
1364      * @return the fixed cell size property
1365      * @since JavaFX 8.0
1366      */
1367     public final DoubleProperty fixedCellSizeProperty() {
1368         if (fixedCellSize == null) {
1369             fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
1370                 @Override public CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt; getCssMetaData() {
1371                     return StyleableProperties.FIXED_CELL_SIZE;
1372                 }
1373 
1374                 @Override public Object getBean() {
1375                     return TreeTableView.this;
1376                 }
1377 
1378                 @Override public String getName() {
1379                     return &quot;fixedCellSize&quot;;
1380                 }
1381             };
1382         }
1383         return fixedCellSize;
1384     }
1385 
1386 
1387     // --- SortMode
1388     /**
1389      * Specifies the sort mode to use when sorting the contents of this TreeTableView,
1390      * should any columns be specified in the {@link #getSortOrder() sort order}
1391      * list.
1392      */
1393     private ObjectProperty&lt;TreeSortMode&gt; sortMode;
1394     public final ObjectProperty&lt;TreeSortMode&gt; sortModeProperty() {
1395         if (sortMode == null) {
1396             sortMode = new SimpleObjectProperty&lt;&gt;(this, &quot;sortMode&quot;, TreeSortMode.ALL_DESCENDANTS);
1397         }
1398         return sortMode;
1399     }
1400     public final void setSortMode(TreeSortMode value) {
1401         sortModeProperty().set(value);
1402     }
1403     public final TreeSortMode getSortMode() {
1404         return sortMode == null ? TreeSortMode.ALL_DESCENDANTS : sortMode.get();
1405     }
1406 
1407 
1408     // --- Comparator (built via sortOrder list, so read-only)
1409     /**
1410      * The comparator property is a read-only property that is representative of the
1411      * current state of the {@link #getSortOrder() sort order} list. The sort
1412      * order list contains the columns that have been added to it either programmatically
1413      * or via a user clicking on the headers themselves.
1414      */
1415     private ReadOnlyObjectWrapper&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparator;
1416     private void setComparator(Comparator&lt;TreeItem&lt;S&gt;&gt; value) {
1417         comparatorPropertyImpl().set(value);
1418     }
1419     public final Comparator&lt;TreeItem&lt;S&gt;&gt; getComparator() {
1420         return comparator == null ? null : comparator.get();
1421     }
1422     public final ReadOnlyObjectProperty&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparatorProperty() {
1423         return comparatorPropertyImpl().getReadOnlyProperty();
1424     }
1425     private ReadOnlyObjectWrapper&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparatorPropertyImpl() {
1426         if (comparator == null) {
1427             comparator = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;comparator&quot;);
1428         }
1429         return comparator;
1430     }
1431 
1432 
1433     // --- sortPolicy
1434     /**
1435      * The sort policy specifies how sorting in this TreeTableView should be performed.
1436      * For example, a basic sort policy may just recursively sort the children of
1437      * the root tree item, whereas a more advanced sort policy may call to a
1438      * database to perform the necessary sorting on the server-side.
1439      *
1440      * &lt;p&gt;TreeTableView ships with a {@link TableView#DEFAULT_SORT_POLICY default
1441      * sort policy} that does precisely as mentioned above: it simply attempts
1442      * to sort the tree hierarchy in-place.
1443      *
1444      * &lt;p&gt;It is recommended that rather than override the {@link TreeTableView#sort() sort}
1445      * method that a different sort policy be provided instead.
1446      */
1447     private ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt; sortPolicy;
1448     public final void setSortPolicy(Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; callback) {
1449         sortPolicyProperty().set(callback);
1450     }
1451     @SuppressWarnings(&quot;unchecked&quot;)
1452     public final Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; getSortPolicy() {
1453         return sortPolicy == null ?
1454                 (Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY :
1455                 sortPolicy.get();
1456     }
1457     @SuppressWarnings(&quot;unchecked&quot;)
1458     public final ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt; sortPolicyProperty() {
1459         if (sortPolicy == null) {
1460             sortPolicy = new SimpleObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt;(
1461                     this, &quot;sortPolicy&quot;, (Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY) {
1462                 @Override protected void invalidated() {
1463                     sort();
1464                 }
1465             };
1466         }
1467         return sortPolicy;
1468     }
1469 
1470 
1471     // onSort
1472     /**
1473      * Called when there&#39;s a request to sort the control.
1474      */
1475     private ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt; onSort;
1476 
1477     public void setOnSort(EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; value) {
1478         onSortProperty().set(value);
1479     }
1480 
1481     public EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; getOnSort() {
1482         if( onSort != null ) {
1483             return onSort.get();
1484         }
1485         return null;
1486     }
1487 
1488     public ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt; onSortProperty() {
1489         if( onSort == null ) {
1490             onSort = new ObjectPropertyBase&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt;() {
1491                 @Override protected void invalidated() {
1492                     EventType&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; eventType = SortEvent.sortEvent();
1493                     EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; eventHandler = get();
1494                     setEventHandler(eventType, eventHandler);
1495                 }
1496 
1497                 @Override public Object getBean() {
1498                     return TreeTableView.this;
1499                 }
1500 
1501                 @Override public String getName() {
1502                     return &quot;onSort&quot;;
1503                 }
1504             };
1505         }
1506         return onSort;
1507     }
1508 
1509 
1510 
1511     /***************************************************************************
1512      *                                                                         *
1513      * Public API                                                              *
1514      *                                                                         *
1515      **************************************************************************/
1516 
1517     /** {@inheritDoc} */
1518     @Override protected void layoutChildren() {
1519         if (expandedItemCountDirty) {
1520             updateExpandedItemCount(getRoot());
1521         }
1522 
1523         super.layoutChildren();
1524     }
1525 
1526     /**
1527      * Scrolls the TreeTableView such that the item in the given index is visible to
1528      * the end user.
1529      *
1530      * @param index The index that should be made visible to the user, assuming
1531      *      of course that it is greater than, or equal to 0, and less than the
1532      *      number of the visible items in the TreeTableView.
1533      */
1534     public void scrollTo(int index) {
1535         ControlUtils.scrollToIndex(this, index);
1536     }
1537 
1538     /**
1539      * Called when there&#39;s a request to scroll an index into view using {@link #scrollTo(int)}
1540      */
1541     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;
1542 
1543     public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
1544         onScrollToProperty().set(value);
1545     }
1546 
1547     public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
1548         if( onScrollTo != null ) {
1549             return onScrollTo.get();
1550         }
1551         return null;
1552     }
1553 
1554     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
1555         if( onScrollTo == null ) {
1556             onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
1557                 @Override protected void invalidated() {
1558                     setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
1559                 }
1560 
1561                 @Override public Object getBean() {
1562                     return TreeTableView.this;
1563                 }
1564 
1565                 @Override public String getName() {
1566                     return &quot;onScrollTo&quot;;
1567                 }
1568             };
1569         }
1570         return onScrollTo;
1571     }
1572 
1573     /**
1574      * Scrolls the TreeTableView so that the given column is visible within the viewport.
1575      * @param column The column that should be visible to the user.
1576      */
1577     public void scrollToColumn(TreeTableColumn&lt;S, ?&gt; column) {
1578         ControlUtils.scrollToColumn(this, column);
1579     }
1580 
1581     /**
1582      * Scrolls the TreeTableView so that the given index is visible within the viewport.
1583      * @param columnIndex The index of a column that should be visible to the user.
1584      */
1585     public void scrollToColumnIndex(int columnIndex) {
1586         if( getColumns() != null ) {
1587             ControlUtils.scrollToColumn(this, getColumns().get(columnIndex));
1588         }
1589     }
1590 
1591     /**
1592      * Called when there&#39;s a request to scroll a column into view using {@link #scrollToColumn(TreeTableColumn)}
1593      * or {@link #scrollToColumnIndex(int)}
1594      */
1595     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumn;
1596 
1597     public void setOnScrollToColumn(EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; value) {
1598         onScrollToColumnProperty().set(value);
1599     }
1600 
1601     public EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; getOnScrollToColumn() {
1602         if( onScrollToColumn != null ) {
1603             return onScrollToColumn.get();
1604         }
1605         return null;
1606     }
1607 
1608     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumnProperty() {
1609         if( onScrollToColumn == null ) {
1610             onScrollToColumn = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt;() {
1611                 @Override
1612                 protected void invalidated() {
1613                     EventType&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; type = ScrollToEvent.scrollToColumn();
1614                     setEventHandler(type, get());
1615                 }
1616                 @Override
1617                 public Object getBean() {
1618                     return TreeTableView.this;
1619                 }
1620 
1621                 @Override
1622                 public String getName() {
1623                     return &quot;onScrollToColumn&quot;;
1624                 }
1625             };
1626         }
1627         return onScrollToColumn;
1628     }
1629 
1630     /**
1631      * Returns the index position of the given TreeItem, assuming that it is
1632      * currently accessible through the tree hierarchy (most notably, that all
1633      * parent tree items are expanded). If a parent tree item is collapsed,
1634      * the result is that this method will return -1 to indicate that the
1635      * given tree item is not accessible in the tree.
1636      *
1637      * @param item The TreeItem for which the index is sought.
1638      * @return An integer representing the location in the current TreeTableView of the
1639      *      first instance of the given TreeItem, or -1 if it is null or can not
1640      *      be found (for example, if a parent (all the way up to the root) is
1641      *      collapsed).
1642      */
1643     public int getRow(TreeItem&lt;S&gt; item) {
1644         return TreeUtil.getRow(item, getRoot(), expandedItemCountDirty, isShowRoot());
1645     }
1646 
1647     /**
1648      * Returns the TreeItem in the given index, or null if it is out of bounds.
1649      *
1650      * @param row The index of the TreeItem being sought.
1651      * @return The TreeItem in the given index, or null if it is out of bounds.
1652      */
1653     public TreeItem&lt;S&gt; getTreeItem(int row) {
1654         if (row &lt; 0) return null;
1655 
1656         // normalize the requested row based on whether showRoot is set
1657         final int _row = isShowRoot() ? row : (row + 1);
1658 
1659         if (expandedItemCountDirty) {
1660             updateExpandedItemCount(getRoot());
1661         } else {
1662             if (treeItemCacheMap.containsKey(_row)) {
1663                 SoftReference&lt;TreeItem&lt;S&gt;&gt; treeItemRef = treeItemCacheMap.get(_row);
1664                 TreeItem&lt;S&gt; treeItem = treeItemRef.get();
1665                 if (treeItem != null) {
1666                     return treeItem;
1667                 }
1668             }
1669         }
1670 
1671         TreeItem&lt;S&gt; treeItem = TreeUtil.getItem(getRoot(), _row, expandedItemCountDirty);
1672         treeItemCacheMap.put(_row, new SoftReference&lt;&gt;(treeItem));
1673         return treeItem;
1674     }
1675 
1676     /**
1677      * Returns the number of levels of &#39;indentation&#39; of the given TreeItem,
1678      * based on how many times getParent() can be recursively called. If the
1679      * given TreeItem is the root node of this TreeTableView, or if the TreeItem
1680      * does not have any parent set, the returned value will be zero. For each
1681      * time getParent() is recursively called, the returned value is incremented
1682      * by one.
1683      *
1684      * @param node The TreeItem for which the level is needed.
1685      * @return An integer representing the number of parents above the given node,
1686      *         or -1 if the given TreeItem is null.
1687      */
1688     public int getTreeItemLevel(TreeItem&lt;?&gt; node) {
1689         final TreeItem&lt;?&gt; root = getRoot();
1690 
1691         if (node == null) return -1;
1692         if (node == root) return 0;
1693 
1694         int level = 0;
1695         TreeItem&lt;?&gt; parent = node.getParent();
1696         while (parent != null) {
1697             level++;
1698 
1699             if (parent == root) {
1700                 break;
1701             }
1702 
1703             parent = parent.getParent();
1704         }
1705 
1706         return level;
1707     }
1708 
1709     /**
1710      * The TreeTableColumns that are part of this TableView. As the user reorders
1711      * the TableView columns, this list will be updated to reflect the current
1712      * visual ordering.
1713      *
1714      * &lt;p&gt;Note: to display any data in a TableView, there must be at least one
1715      * TreeTableColumn in this ObservableList.&lt;/p&gt;
1716      * @return the table table column
1717      */
1718     public final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getColumns() {
1719         return columns;
1720     }
1721 
1722     /**
1723      * The sortOrder list defines the order in which {@link TreeTableColumn} instances
1724      * are sorted. An empty sortOrder list means that no sorting is being applied
1725      * on the TableView. If the sortOrder list has one TreeTableColumn within it,
1726      * the TableView will be sorted using the
1727      * {@link TreeTableColumn#sortTypeProperty() sortType} and
1728      * {@link TreeTableColumn#comparatorProperty() comparator} properties of this
1729      * TreeTableColumn (assuming
1730      * {@link TreeTableColumn#sortableProperty() TreeTableColumn.sortable} is true).
1731      * If the sortOrder list contains multiple TreeTableColumn instances, then
1732      * the TableView is firstly sorted based on the properties of the first
1733      * TreeTableColumn. If two elements are considered equal, then the second
1734      * TreeTableColumn in the list is used to determine ordering. This repeats until
1735      * the results from all TreeTableColumn comparators are considered, if necessary.
1736      *
1737      * @return An ObservableList containing zero or more TreeTableColumn instances.
1738      */
1739     public final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getSortOrder() {
1740         return sortOrder;
1741     }
1742 
1743     /**
1744      * Applies the currently installed resize policy against the given column,
1745      * resizing it based on the delta value provided.
1746      * @param column the column
1747      * @param delta the delta
1748      * @return true if column resizing is applied
1749      */
1750     public boolean resizeColumn(TreeTableColumn&lt;S,?&gt; column, double delta) {
1751         if (column == null || Double.compare(delta, 0.0) == 0) return false;
1752 
1753         boolean allowed = getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, column, delta));
1754         if (!allowed) return false;
1755         return true;
1756     }
1757 
1758     /**
1759      * Causes the cell at the given row/column view indexes to switch into
1760      * its editing state, if it is not already in it, and assuming that the
1761      * TableView and column are also editable.
1762      * @param row the row
1763      * @param column the column
1764      */
1765     public void edit(int row, TreeTableColumn&lt;S,?&gt; column) {
1766         if (!isEditable() || (column != null &amp;&amp; ! column.isEditable())) {
1767             return;
1768         }
1769 
1770         if (row &lt; 0 &amp;&amp; column == null) {
1771             setEditingCell(null);
1772         } else {
1773             setEditingCell(new TreeTablePosition&lt;&gt;(this, row, column));
1774         }
1775     }
1776 
1777     /**
1778      * Returns an unmodifiable list containing the currently visible leaf columns.
1779      * @return an unmodifiable list containing the currently visible leaf columns
1780      */
1781     public ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getVisibleLeafColumns() {
1782         return unmodifiableVisibleLeafColumns;
1783     }
1784 
1785     /**
1786      * Returns the position of the given column, relative to all other
1787      * visible leaf columns.
1788      * @param column the column
1789      * @return the position of the given column, relative to all other
1790      * visible leaf columns
1791      */
1792     public int getVisibleLeafIndex(TreeTableColumn&lt;S,?&gt; column) {
1793         return getVisibleLeafColumns().indexOf(column);
1794     }
1795 
1796     /**
1797      * Returns the TreeTableColumn in the given column index, relative to all other
1798      * visible leaf columns.
1799      * @param column the column
1800      * @return the TreeTableColumn in the given column index, relative to all other
1801      * visible leaf columns
1802      */
1803     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1804         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1805         return visibleLeafColumns.get(column);
1806     }
1807 
1808     private boolean sortingInProgress;
1809     boolean isSortingInProgress() {
1810         return sortingInProgress;
1811     }
1812 
1813     private boolean sortTreeOfSelectedItems = true;
1814     boolean isSortTreeOfSelectedItems() {
1815         return sortTreeOfSelectedItems;
1816     }
1817 
1818     /**
1819      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1820      * often than not it is not necessary to call this method directly, as it is
1821      * automatically called when the {@link #getSortOrder() sort order},
1822      * {@link #sortPolicyProperty() sort policy}, or the state of the
1823      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1824      * change. In other words, this method should only be called directly when
1825      * something external changes and a sort is required.
1826      */
1827     public void sort() {
1828         sortingInProgress = true;
1829         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1830 
1831         // update the Comparator property
1832         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1833         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1834 
1835         // fire the onSort event and check if it is consumed, if
1836         // so, don&#39;t run the sort
1837         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
1838         fireEvent(sortEvent);
1839         if (sortEvent.isConsumed()) {
1840             // if the sort is consumed we could back out the last action (the code
1841             // is commented out right below), but we don&#39;t as we take it as a
1842             // sign that the developer has decided to handle the event themselves.
1843 
1844             // sortLock = true;
1845             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1846             // sortLock = false;
1847             sortingInProgress = false;
1848             return;
1849         }
1850 
1851         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1852         final int itemCount = prevState.size();
1853 
1854         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1855         // sort events - instead we send a single permutation event at the end
1856         // of this method.
1857         getSelectionModel().startAtomic();
1858 
1859         // get the sort policy and run it
1860         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
1861         if (sortPolicy == null) return;
1862         Boolean success = sortPolicy.call(this);
1863 
1864         if (getSortMode() == TreeSortMode.ALL_DESCENDANTS &amp;&amp; isSortTreeOfSelectedItems()) {
1865             Set&lt;TreeItem&lt;S&gt;&gt; sortedParents = new HashSet&lt;&gt;();
1866             for (TreeTablePosition&lt;S,?&gt; selectedPosition : prevState) {
1867                 TreeItem&lt;S&gt; parent = selectedPosition.getTreeItem().getParent();
1868                 while (parent != null &amp;&amp; sortedParents.add(parent)) {
1869                     parent.getChildren();
1870                     parent = parent.getParent();
1871                 }
1872             }
1873         }
1874         getSelectionModel().stopAtomic();
1875 
1876         if (success == null || ! success) {
1877             // the sort was a failure. Need to backout if possible
1878             sortLock = true;
1879             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1880             setComparator(oldComparator);
1881             sortLock = false;
1882         } else {
1883             // sorting was a success, now we possibly fire an event on the
1884             // selection model that the items list has &#39;permutated&#39; to a new ordering
1885 
1886             // FIXME we should support alternative selection model implementations!
1887             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1888                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1889                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1890 
1891                 List&lt;TreeTablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
1892                 for (int i = 0; i &lt; itemCount; i++) {
1893                     TreeTablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
1894                     if (!newState.contains(prevItem)) {
1895                         removed.add(prevItem);
1896                     }
1897                 }
1898                 if (!removed.isEmpty()) {
1899                     // the sort operation effectively permutates the selectedCells list,
1900                     // but we cannot fire a permutation event as we are talking about
1901                     // TreeTablePosition&#39;s changing (which may reside in the same list
1902                     // position before and after the sort). Therefore, we need to fire
1903                     // a single add/remove event to cover the added and removed positions.
1904                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
1905                     sm.fireCustomSelectedCellsListChangeEvent(c);
1906                 }
1907             }
1908             getSelectionModel().setSelectedIndex(getRow(getSelectionModel().getSelectedItem()));
1909             getFocusModel().focus(getSelectionModel().getSelectedIndex());
1910         }
1911         sortingInProgress = false;
1912     }
1913 
1914     /**
1915      * Calling {@code refresh()} forces the TreeTableView control to recreate and
1916      * repopulate the cells necessary to populate the visual bounds of the control.
1917      * In other words, this forces the TreeTableView to update what it is showing to
1918      * the user. This is useful in cases where the underlying data source has
1919      * changed in a way that is not observed by the TreeTableView itself.
1920      *
1921      * @since JavaFX 8u60
1922      */
1923     public void refresh() {
1924         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1925     }
1926 
1927 
1928 
1929     /***************************************************************************
1930      *                                                                         *
1931      * Private Implementation                                                  *
1932      *                                                                         *
1933      **************************************************************************/
1934 
1935     private boolean sortLock = false;
1936     private TableUtil.SortEventType lastSortEventType = null;
1937     private Object[] lastSortEventSupportInfo = null;
1938 
1939     private void doSort(final TableUtil.SortEventType sortEventType, final Object... supportInfo) {
1940         if (sortLock) {
1941             return;
1942         }
1943 
1944         this.lastSortEventType = sortEventType;
1945         this.lastSortEventSupportInfo = supportInfo;
1946         sort();
1947         this.lastSortEventType = null;
1948         this.lastSortEventSupportInfo = null;
1949     }
1950 
1951     private void updateExpandedItemCount(TreeItem&lt;S&gt; treeItem) {
1952         setExpandedItemCount(TreeUtil.updateExpandedItemCount(treeItem, expandedItemCountDirty, isShowRoot()));
1953 
1954         if (expandedItemCountDirty) {
1955             // this is a very inefficient thing to do, but for now having a cache
1956             // is better than nothing at all...
1957             treeItemCacheMap.clear();
1958         }
1959 
1960         expandedItemCountDirty = false;
1961     }
1962 
1963     private void updateRootExpanded() {
1964         // if we aren&#39;t showing the root, and the root isn&#39;t expanded, we expand
1965         // it now so that something is shown.
1966         if (!isShowRoot() &amp;&amp; getRoot() != null &amp;&amp; ! getRoot().isExpanded()) {
1967             getRoot().setExpanded(true);
1968         }
1969     }
1970 
1971 
1972     // --- Content width
1973     private void setContentWidth(double contentWidth) {
1974         this.contentWidth = contentWidth;
1975         if (isInited) {
1976             // sometimes the current column resize policy will have to modify the
1977             // column width of all columns in the table if the table width changes,
1978             // so we short-circuit the resize function and just go straight there
1979             // with a null TreeTableColumn, which indicates to the resize policy function
1980             // that it shouldn&#39;t actually do anything specific to one column.
1981             getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, null, 0.0));
1982         }
1983     }
1984 
1985     /**
1986      * Recomputes the currently visible leaf columns in this TableView.
1987      */
1988     private void updateVisibleLeafColumns() {
1989         // update visible leaf columns list
1990         List&lt;TreeTableColumn&lt;S,?&gt;&gt; cols = new ArrayList&lt;TreeTableColumn&lt;S,?&gt;&gt;();
1991         buildVisibleLeafColumns(getColumns(), cols);
1992         visibleLeafColumns.setAll(cols);
1993 
1994         // sometimes the current column resize policy will have to modify the
1995         // column width of all columns in the table if the table width changes,
1996         // so we short-circuit the resize function and just go straight there
1997         // with a null TreeTableColumn, which indicates to the resize policy function
1998         // that it shouldn&#39;t actually do anything specific to one column.
1999         getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, null, 0.0));
2000     }
2001 
2002     private void buildVisibleLeafColumns(List&lt;TreeTableColumn&lt;S,?&gt;&gt; cols, List&lt;TreeTableColumn&lt;S,?&gt;&gt; vlc) {
2003         for (TreeTableColumn&lt;S,?&gt; c : cols) {
2004             if (c == null) continue;
2005 
2006             boolean hasChildren = ! c.getColumns().isEmpty();
2007 
2008             if (hasChildren) {
2009                 buildVisibleLeafColumns(c.getColumns(), vlc);
2010             } else if (c.isVisible()) {
2011                 vlc.add(c);
2012             }
2013         }
2014     }
2015 
2016 
2017 
2018     /***************************************************************************
2019      *                                                                         *
2020      * Stylesheet Handling                                                     *
2021      *                                                                         *
2022      **************************************************************************/
2023 
2024     private static final String DEFAULT_STYLE_CLASS = &quot;tree-table-view&quot;;
2025 
2026     private static final PseudoClass PSEUDO_CLASS_CELL_SELECTION =
2027             PseudoClass.getPseudoClass(&quot;cell-selection&quot;);
2028     private static final PseudoClass PSEUDO_CLASS_ROW_SELECTION =
2029             PseudoClass.getPseudoClass(&quot;row-selection&quot;);
2030 
2031     private static class StyleableProperties {
2032         private static final CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
2033                 new CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
2034                                                      SizeConverter.getInstance(),
2035                                                      Region.USE_COMPUTED_SIZE) {
2036 
2037                     @Override public Double getInitialValue(TreeTableView&lt;?&gt; node) {
2038                         return node.getFixedCellSize();
2039                     }
2040 
2041                     @Override public boolean isSettable(TreeTableView&lt;?&gt; n) {
2042                         return n.fixedCellSize == null || !n.fixedCellSize.isBound();
2043                     }
2044 
2045                     @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(TreeTableView&lt;?&gt; n) {
2046                         return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;) n.fixedCellSizeProperty();
2047                     }
2048                 };
2049 
2050         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
2051         static {
2052             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
2053                     new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
2054             styleables.add(FIXED_CELL_SIZE);
2055             STYLEABLES = Collections.unmodifiableList(styleables);
2056         }
2057     }
2058 
2059     /**
2060      * @return The CssMetaData associated with this class, which may include the
2061      * CssMetaData of its superclasses.
2062      */
2063     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
2064         return StyleableProperties.STYLEABLES;
2065     }
2066 
2067     /**
2068      * {@inheritDoc}
2069      * @since JavaFX 8.0
2070      */
2071     @Override
2072     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
2073         return getClassCssMetaData();
2074     }
2075 
2076     /** {@inheritDoc} */
2077     @Override protected Skin&lt;?&gt; createDefaultSkin() {
2078         return new TreeTableViewSkin&lt;S&gt;(this);
2079     }
2080 
2081 
2082 
2083     /***************************************************************************
2084      *                                                                         *
2085      * Accessibility handling                                                  *
2086      *                                                                         *
2087      **************************************************************************/
2088 
2089     /** {@inheritDoc} */
2090     @Override
2091     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
2092         switch (attribute) {
2093             case ROW_COUNT: return getExpandedItemCount();
2094             case COLUMN_COUNT: return getVisibleLeafColumns().size();
2095 
2096             /*
2097              * TreeTableViewSkin returns TreeTableRows back to TreeTableView.
2098              * TreeTableRowSkin returns TreeTableCells back to TreeTableRow.
2099              */
2100             case SELECTED_ITEMS: {
2101                 @SuppressWarnings(&quot;unchecked&quot;)
2102                 ObservableList&lt;TreeTableRow&lt;S&gt;&gt; rows = (ObservableList&lt;TreeTableRow&lt;S&gt;&gt;)super.queryAccessibleAttribute(attribute, parameters);
2103                 List&lt;Node&gt; selection = new ArrayList&lt;&gt;();
2104                 for (TreeTableRow&lt;S&gt; row : rows) {
2105                     @SuppressWarnings(&quot;unchecked&quot;)
2106                     ObservableList&lt;Node&gt; cells = (ObservableList&lt;Node&gt;)row.queryAccessibleAttribute(attribute, parameters);
2107                     if (cells != null) selection.addAll(cells);
2108                 }
2109                 return FXCollections.observableArrayList(selection);
2110             }
2111             case FOCUS_ITEM: {
2112                 Node row = (Node)super.queryAccessibleAttribute(attribute, parameters);
2113                 if (row == null) return null;
2114                 Node cell = (Node)row.queryAccessibleAttribute(attribute, parameters);
2115                 /* cell equals to null means the row is a placeholder node */
2116                 return cell != null ?  cell : row;
2117             }
2118             case CELL_AT_ROW_COLUMN: {
2119                 @SuppressWarnings(&quot;unchecked&quot;)
2120                 TreeTableRow&lt;S&gt; row = (TreeTableRow&lt;S&gt;)super.queryAccessibleAttribute(attribute, parameters);
2121                 return row != null ? row.queryAccessibleAttribute(attribute, parameters) : null;
2122             }
2123             case MULTIPLE_SELECTION: {
2124                 TreeTableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
2125                 return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
2126             }
2127             default: return super.queryAccessibleAttribute(attribute, parameters);
2128         }
2129     }
2130 
2131     /***************************************************************************
2132      *                                                                         *
2133      * Support Classes                                                         *
2134      *                                                                         *
2135      **************************************************************************/
2136 
2137      /**
2138       * An immutable wrapper class for use in the TableView
2139      * {@link TreeTableView#columnResizePolicyProperty() column resize} functionality.
2140       * @since JavaFX 8.0
2141       */
2142      public static class ResizeFeatures&lt;S&gt; extends ResizeFeaturesBase&lt;TreeItem&lt;S&gt;&gt; {
2143         private TreeTableView&lt;S&gt; treeTable;
2144 
2145         /**
2146          * Creates an instance of this class, with the provided TreeTableView,
2147          * TreeTableColumn and delta values being set and stored in this immutable
2148          * instance.
2149          *
2150          * @param treeTable The TreeTableView upon which the resize operation is occurring.
2151          * @param column The column upon which the resize is occurring, or null
2152          *      if this ResizeFeatures instance is being created as a result of a
2153          *      TreeTableView resize operation.
2154          * @param delta The amount of horizontal space added or removed in the
2155          *      resize operation.
2156          */
2157         public ResizeFeatures(TreeTableView&lt;S&gt; treeTable, TreeTableColumn&lt;S,?&gt; column, Double delta) {
2158             super(column, delta);
2159             this.treeTable = treeTable;
2160         }
2161 
2162         /**
2163          * Returns the column upon which the resize is occurring, or null
2164          * if this ResizeFeatures instance was created as a result of a
2165          * TreeTableView resize operation.
2166          */
2167         @Override public TreeTableColumn&lt;S,?&gt; getColumn() {
2168             return (TreeTableColumn&lt;S,?&gt;) super.getColumn();
2169         }
2170 
2171         /**
2172          * Returns the TreeTableView upon which the resize operation is occurring.
2173          * @return the TreeTableView upon which the resize operation is occurring
2174          */
2175         public TreeTableView&lt;S&gt; getTable() { return treeTable; }
2176     }
2177 
2178 
2179 
2180     /**
2181      * An {@link Event} subclass used specifically in TreeTableView for representing
2182      * edit-related events. It provides additional API to easily access the
2183      * TreeItem that the edit event took place on, as well as the input provided
2184      * by the end user.
2185      *
2186      * @param &lt;S&gt; The type of the input, which is the same type as the TreeTableView
2187      *      itself.
2188      * @since JavaFX 8.0
2189      */
2190     public static class EditEvent&lt;S&gt; extends Event {
2191         private static final long serialVersionUID = -4437033058917528976L;
2192 
2193         /**
2194          * Common supertype for all edit event types.
2195          */
2196         public static final EventType&lt;?&gt; ANY = EDIT_ANY_EVENT;
2197 
2198         private final TreeTableView&lt;S&gt; source;
2199         private final S oldValue;
2200         private final S newValue;
2201         private transient final TreeItem&lt;S&gt; treeItem;
2202 
2203         /**
2204          * Creates a new EditEvent instance to represent an edit event. This
2205          * event is used for {@link #editStartEvent()},
2206          * {@link #editCommitEvent()} and {@link #editCancelEvent()} types.
2207          * @param source the source
2208          * @param eventType the eventType
2209          * @param treeItem the treeItem
2210          * @param oldValue the oldValue
2211          * @param newValue the newValue
2212          */
2213         public EditEvent(TreeTableView&lt;S&gt; source,
2214                          EventType&lt;? extends TreeTableView.EditEvent&gt; eventType,
2215                          TreeItem&lt;S&gt; treeItem, S oldValue, S newValue) {
2216             super(source, Event.NULL_SOURCE_TARGET, eventType);
2217             this.source = source;
2218             this.oldValue = oldValue;
2219             this.newValue = newValue;
2220             this.treeItem = treeItem;
2221         }
2222 
2223         /**
2224          * Returns the TreeTableView upon which the edit took place.
2225          * @return the TreeTableView upon which the edit took place
2226          */
2227         @Override public TreeTableView&lt;S&gt; getSource() {
2228             return source;
2229         }
2230 
2231         /**
2232          * Returns the {@link TreeItem} upon which the edit took place.
2233          * @return the {@link TreeItem} upon which the edit took place
2234          */
2235         public TreeItem&lt;S&gt; getTreeItem() {
2236             return treeItem;
2237         }
2238 
2239         /**
2240          * Returns the new value input into the TreeItem by the end user.
2241          * @return the new value input into the TreeItem by the end user
2242          */
2243         public S getNewValue() {
2244             return newValue;
2245         }
2246 
2247         /**
2248          * Returns the old value that existed in the TreeItem prior to the current
2249          * edit event.
2250          * @return the old value that existed in the TreeItem prior to the current
2251          * edit event
2252          */
2253         public S getOldValue() {
2254             return oldValue;
2255         }
2256     }
2257 
2258 
2259 
2260      /**
2261      * A simple extension of the {@link SelectionModel} abstract class to
2262      * allow for special support for TreeTableView controls.
2263       *
2264      * @since JavaFX 8.0
2265      */
2266     public static abstract class TreeTableViewSelectionModel&lt;S&gt; extends
2267             TableSelectionModel&lt;TreeItem&lt;S&gt;&gt; {
2268 
2269         /***********************************************************************
2270          *                                                                     *
2271          * Private fields                                                      *
2272          *                                                                     *
2273          **********************************************************************/
2274 
2275         private final TreeTableView&lt;S&gt; treeTableView;
2276 
2277 
2278         /***********************************************************************
2279          *                                                                     *
2280          * Constructors                                                        *
2281          *                                                                     *
2282          **********************************************************************/
2283 
2284         /**
2285          * Builds a default TreeTableViewSelectionModel instance with the provided
2286          * TreeTableView.
2287          * @param treeTableView The TreeTableView upon which this selection model should
2288          *      operate.
2289          * @throws NullPointerException TreeTableView can not be null.
2290          */
2291         public TreeTableViewSelectionModel(final TreeTableView&lt;S&gt; treeTableView) {
2292             if (treeTableView == null) {
2293                 throw new NullPointerException(&quot;TreeTableView can not be null&quot;);
2294             }
2295 
2296             this.treeTableView = treeTableView;
2297         }
2298 
2299 
2300 
2301         /***********************************************************************
2302          *                                                                     *
2303          * Abstract API                                                        *
2304          *                                                                     *
2305          **********************************************************************/
2306 
2307          /**
2308          * A read-only ObservableList representing the currently selected cells
2309          * in this TreeTableView. Rather than directly modify this list, please
2310          * use the other methods provided in the TreeTableViewSelectionModel.
2311          * @return a list of selected cells
2312          */
2313         public abstract ObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; getSelectedCells();
2314 
2315 
2316 
2317         /***********************************************************************
2318          *                                                                     *
2319          * Public API                                                          *
2320          *                                                                     *
2321          **********************************************************************/
2322 
2323          /**
2324           * Returns the TreeTableView instance that this selection model is installed in.
2325          * @return the TreeTableView instance that this selection model is installed in
2326           */
2327          public TreeTableView&lt;S&gt; getTreeTableView() {
2328              return treeTableView;
2329          }
2330 
2331          /** {@inheritDoc} */
2332          @Override public TreeItem&lt;S&gt; getModelItem(int index) {
2333              return treeTableView.getTreeItem(index);
2334          }
2335 
2336          /** {@inheritDoc} */
2337          @Override protected int getItemCount() {
2338              return treeTableView.getExpandedItemCount();
2339          }
2340 
2341          /** {@inheritDoc} */
2342          @Override public void focus(int row) {
2343              focus(row, null);
2344          }
2345 
2346          /** {@inheritDoc} */
2347          @Override public int getFocusedIndex() {
2348              return getFocusedCell().getRow();
2349          }
2350 
2351          /** {@inheritDoc} */
2352          @Override public void selectRange(int minRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; minColumn,
2353                                            int maxRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; maxColumn) {
2354              final int minColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)minColumn);
2355              final int maxColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)maxColumn);
2356              for (int _row = minRow; _row &lt;= maxRow; _row++) {
2357                  for (int _col = minColumnIndex; _col &lt;= maxColumnIndex; _col++) {
2358                      select(_row, treeTableView.getVisibleLeafColumn(_col));
2359                  }
2360              }
2361          }
2362 
2363 
2364 
2365         /***********************************************************************
2366          *                                                                     *
2367          * Private implementation                                              *
2368          *                                                                     *
2369          **********************************************************************/
2370 
2371          private void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
2372              focus(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column));
2373          }
2374 
2375          private void focus(TreeTablePosition&lt;S,?&gt; pos) {
2376              if (getTreeTableView().getFocusModel() == null) return;
2377 
2378              getTreeTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
2379          }
2380 
2381          private TreeTablePosition&lt;S,?&gt; getFocusedCell() {
2382              if (treeTableView.getFocusModel() == null) {
2383                  return new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
2384              }
2385              return treeTableView.getFocusModel().getFocusedCell();
2386          }
2387      }
2388 
2389 
2390 
2391     /**
2392      * A primitive selection model implementation, using a List&lt;Integer&gt; to store all
2393      * selected indices.
2394      */
2395     // package for testing
2396     static class TreeTableViewArrayListSelectionModel&lt;S&gt; extends TreeTableViewSelectionModel&lt;S&gt; {
2397 
2398         private final MappingChange.Map&lt;TreeTablePosition&lt;S,?&gt;,Integer&gt; cellToIndicesMap = f -&gt; f.getRow();
2399 
2400         private TreeTableView&lt;S&gt; treeTableView = null;
2401 
2402         /***********************************************************************
2403          *                                                                     *
2404          * Constructors                                                        *
2405          *                                                                     *
2406          **********************************************************************/
2407 
2408         public TreeTableViewArrayListSelectionModel(final TreeTableView&lt;S&gt; treeTableView) {
2409             super(treeTableView);
2410             this.treeTableView = treeTableView;
2411 
2412             this.treeTableView.rootProperty().addListener(weakRootPropertyListener);
2413             this.treeTableView.showRootProperty().addListener(showRootPropertyListener);
2414             updateTreeEventListener(null, treeTableView.getRoot());
2415 
2416             selectedCellsMap = new SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt;(this::fireCustomSelectedCellsListChangeEvent) {
2417                 @Override public boolean isCellSelectionEnabled() {
2418                     return TreeTableViewArrayListSelectionModel.this.isCellSelectionEnabled();
2419                 }
2420             };
2421 
2422             selectedCellsSeq = new ReadOnlyUnbackedObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt;() {
2423                 @Override public TreeTablePosition&lt;S,?&gt; get(int i) {
2424                     return selectedCellsMap.get(i);
2425                 }
2426 
2427                 @Override public int size() {
2428                     return selectedCellsMap.size();
2429                 }
2430             };
2431 //            selectedCellsSeq.addListener((ListChangeListener&lt;? super TreeTablePosition&lt;S,?&gt;&gt;) c -&gt; {
2432 //                ControlUtils.updateSelectedIndices(this, c);
2433 //            });
2434 
2435             updateDefaultSelection();
2436 
2437             cellSelectionEnabledProperty().addListener(o -&gt; {
2438                 updateDefaultSelection();
2439                 TableCellBehaviorBase.setAnchor(treeTableView, getFocusedCell(), true);
2440             });
2441         }
2442 
2443         private void dispose() {
2444             this.treeTableView.rootProperty().removeListener(weakRootPropertyListener);
2445             this.treeTableView.showRootProperty().removeListener(showRootPropertyListener);
2446 
2447             TreeItem&lt;S&gt; root = this.treeTableView.getRoot();
2448             if (root != null) {
2449                 root.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
2450             }
2451         }
2452 
2453         private void updateTreeEventListener(TreeItem&lt;S&gt; oldRoot, TreeItem&lt;S&gt; newRoot) {
2454             if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
2455                 oldRoot.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
2456             }
2457 
2458             if (newRoot != null) {
2459                 weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
2460                 newRoot.addEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
2461             }
2462         }
2463 
2464         private ChangeListener&lt;TreeItem&lt;S&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
2465             updateDefaultSelection();
2466 
2467             updateTreeEventListener(oldValue, newValue);
2468         };
2469 
2470         private InvalidationListener showRootPropertyListener = o -&gt; {
2471             shiftSelection(0, treeTableView.isShowRoot() ? 1 : -1, null);
2472         };
2473 
2474         private EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; treeItemListener = new EventHandler&lt;&gt;() {
2475             @Override public void handle(TreeItem.TreeModificationEvent&lt;S&gt; e) {
2476 
2477                 if (getSelectedIndex() == -1 &amp;&amp; getSelectedItem() == null) return;
2478 
2479                 final TreeItem&lt;S&gt; treeItem = e.getTreeItem();
2480                 if (treeItem == null) return;
2481 
2482                 final int oldSelectedIndex = getSelectedIndex();
2483 
2484                 treeTableView.expandedItemCountDirty = true;
2485 
2486                 // we only shift selection from this row - everything before it
2487                 // is safe. We might change this below based on certain criteria
2488                 int startRow = treeTableView.getRow(treeItem);
2489 
2490                 int shift = 0;
2491                 ListChangeListener.Change&lt;? extends TreeItem&lt;?&gt;&gt; change = e.getChange();
2492                 if (change != null) {
2493                     change.next();
2494                 }
2495 
2496                 do {
2497                     final int addedSize = change == null ? 0 : change.getAddedSize();
2498                     final int removedSize = change == null ? 0 : change.getRemovedSize();
2499 
2500                     if (e.wasExpanded()) {
2501                         // need to shuffle selection by the number of visible children
2502                         shift += treeItem.getExpandedDescendentCount(false) - 1;
2503                         startRow++;
2504                     } else if (e.wasCollapsed()) {
2505                         // remove selection from any child treeItem, and also determine
2506                         // if any child item was selected (in which case the parent
2507                         // takes the selection on collapse)
2508                         treeItem.getExpandedDescendentCount(false);
2509                         final int count = treeItem.previousExpandedDescendentCount;
2510 
2511                         final int selectedIndex = getSelectedIndex();
2512                         final boolean wasPrimarySelectionInChild =
2513                                 selectedIndex &gt;= (startRow + 1) &amp;&amp;
2514                                         selectedIndex &lt; (startRow + count);
2515 
2516                         boolean wasAnyChildSelected = false;
2517                         final boolean isCellSelectionMode = isCellSelectionEnabled();
2518                         ObservableList&lt;TreeTableColumn&lt;S, ?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2519 
2520                         selectedIndices._beginChange();
2521                         final int from = startRow + 1;
2522                         final int to = startRow + count;
2523                         final List&lt;Integer&gt; removed = new ArrayList&lt;&gt;();
2524                         TreeTableColumn&lt;S, ?&gt; selectedColumn = null;
2525                         for (int i = from; i &lt; to; i++) {
2526                             // we have to handle cell selection mode differently than
2527                             // row selection mode. Refer to RT-34103 for the bug report
2528                             // that drove this change, but in short the issue was that
2529                             // when collapsing a branch that had selection, we were
2530                             // always calling isSelected(row), but that always returns
2531                             // false in cell selection mode.
2532                             if (isCellSelectionMode) {
2533                                 for (int column = 0; column &lt; columns.size(); column++) {
2534                                     final TreeTableColumn&lt;S, ?&gt; col = columns.get(column);
2535                                     if (isSelected(i, col)) {
2536                                         wasAnyChildSelected = true;
2537                                         clearSelection(i, col);
2538                                         selectedColumn = col;
2539                                     }
2540                                 }
2541                             } else {
2542                                 if (isSelected(i)) {
2543                                     wasAnyChildSelected = true;
2544                                     removed.add(i);
2545                                 }
2546                             }
2547                         }
2548 
2549                         ControlUtils.reducingChange(selectedIndices, removed);
2550 
2551                         for (int index : removed) {
2552                             startAtomic();
2553                             // we pass in false here to prevent a lookup into the TreeItem, as it is unnecessary
2554                             // and results in JDK-8152396
2555                             clearSelection(new TreeTablePosition&lt;&gt;(treeTableView, index, null, false));
2556                             stopAtomic();
2557                         }
2558                         selectedIndices._endChange();
2559 
2560                         // put selection onto the newly-collapsed tree item
2561                         if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
2562                             select(startRow, selectedColumn);
2563                         }
2564 
2565                         shift += -count + 1;
2566                         startRow++;
2567                     } else if (e.wasPermutated()) {
2568                         // Approach:
2569                         // Get the current selection.
2570                         // Create a new selection with updated index(row).
2571                         // Update the current selection with new selection.
2572                         // If sorting is in progress then one Selection change event will be sent from
2573                         // TreeTableView.sort() method, and should not be sent from here.
2574                         // else, in case otherwise, the selection change events would be generated.
2575                         // Do not call shiftSelection() in case of permutation change(when shift == 0).
2576 
2577                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; currentSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());
2578                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; updatedSelection = new ArrayList&lt;&gt;();
2579 
2580                         boolean selectionIndicesChanged = false;
2581                         for (TreeTablePosition&lt;S, ?&gt; selectedCell : currentSelection) {
2582                             int newRow = treeTableView.getRow(selectedCell.getTreeItem());
2583                             if (selectedCell.getRow() != newRow) {
2584                                 selectionIndicesChanged = true;
2585                             }
2586                             updatedSelection.add(new TreeTablePosition&lt;&gt;(selectedCell, newRow));
2587                         }
2588                         if (selectionIndicesChanged) {
2589                             if (treeTableView.isSortingInProgress()) {
2590                                 startAtomic();
2591                                 selectedCellsMap.setAll(updatedSelection);
2592                                 stopAtomic();
2593                             } else {
2594                                 startAtomic();
2595                                 quietClearSelection();
2596                                 stopAtomic();
2597                                 selectedCellsMap.setAll(updatedSelection);
2598                                 int selectedIndex = treeTableView.getRow(getSelectedItem());
2599                                 setSelectedIndex(selectedIndex);
2600                                 focus(selectedIndex);
2601                             }
2602                         }
2603                     } else if (e.wasAdded()) {
2604                         // shuffle selection by the number of added items
2605                         shift += treeItem.isExpanded() ? addedSize : 0;
2606 
2607                         // RT-32963: We were taking the startRow from the TreeItem
2608                         // in which the children were added, rather than from the
2609                         // actual position of the new child. This led to selection
2610                         // being moved off the parent TreeItem by mistake.
2611                         // The &#39;if (e.getAddedSize() == 1)&#39; condition here was
2612                         // subsequently commented out due to RT-33894.
2613                         startRow = treeTableView.getRow(e.getChange().getAddedSubList().get(0));
2614 
2615                         TreeTablePosition&lt;S, ?&gt; anchor = TreeTableCellBehavior.getAnchor(treeTableView, null);
2616                         if (anchor != null) {
2617                             boolean isAnchorSelected = isSelected(anchor.getRow(), anchor.getTableColumn());
2618                             if (isAnchorSelected) {
2619                                 TreeTablePosition&lt;S, ?&gt; newAnchor = new TreeTablePosition&lt;&gt;(treeTableView, anchor.getRow() + shift, anchor.getTableColumn());
2620                                 TreeTableCellBehavior.setAnchor(treeTableView, newAnchor, false);
2621                             }
2622                         }
2623                     } else if (e.wasRemoved()) {
2624                         // shuffle selection by the number of removed items
2625                         shift += treeItem.isExpanded() ? -removedSize : 0;
2626 
2627                         // the start row is incorrect - it is _not_ the index of the
2628                         // TreeItem in which the children were removed from (which is
2629                         // what it currently represents). We need to take the &#39;from&#39;
2630                         // value out of the event and make use of that to understand
2631                         // what actually changed inside the children list.
2632                         startRow += e.getFrom() + 1;
2633 
2634                         // whilst we are here, we should check if the removed items
2635                         // are part of the selectedItems list - and remove them
2636                         // from selection if they are (as per RT-15446)
2637                         final List&lt;Integer&gt; selectedIndices = getSelectedIndices();
2638                         final List&lt;TreeItem&lt;S&gt;&gt; selectedItems = getSelectedItems();
2639                         final TreeItem&lt;S&gt; selectedItem = getSelectedItem();
2640                         final List&lt;? extends TreeItem&lt;S&gt;&gt; removedChildren = e.getChange().getRemoved();
2641 
2642                         for (int i = 0; i &lt; selectedIndices.size() &amp;&amp; !selectedItems.isEmpty(); i++) {
2643                             int index = selectedIndices.get(i);
2644                             if (index &gt; selectedItems.size()) break;
2645 
2646                             if (removedChildren.size() == 1 &amp;&amp;
2647                                     selectedItems.size() == 1 &amp;&amp;
2648                                     selectedItem != null &amp;&amp;
2649                                     selectedItem.equals(removedChildren.get(0))) {
2650                                 // Bug fix for RT-28637
2651                                 if (oldSelectedIndex &lt; getItemCount()) {
2652                                     final int previousRow = oldSelectedIndex == 0 ? 0 : oldSelectedIndex - 1;
2653                                     TreeItem&lt;S&gt; newSelectedItem = getModelItem(previousRow);
2654                                     if (!selectedItem.equals(newSelectedItem)) {
2655                                         clearAndSelect(previousRow);
2656                                     }
2657                                 }
2658                             }
2659                         }
2660                     }
2661                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
2662 
2663                 if (shift != 0) {
2664                     shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {
2665                         @Override public Void call(ShiftParams param) {
2666 
2667                             // we make the shifts atomic, as otherwise listeners to
2668                             // the items / indices lists get a lot of intermediate
2669                             // noise. They eventually get the summary event fired
2670                             // from within shiftSelection, so this is ok.
2671                             startAtomic();
2672 
2673                             final int clearIndex = param.getClearIndex();
2674                             final int setIndex = param.getSetIndex();
2675                             TreeTablePosition&lt;S,?&gt; oldTP = null;
2676                             if (clearIndex &gt; -1) {
2677                                 for (int i = 0; i &lt; selectedCellsMap.size(); i++) {
2678                                     TreeTablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);
2679                                     if (tp.getRow() == clearIndex) {
2680                                         oldTP = tp;
2681                                         selectedCellsMap.remove(tp);
2682                                     } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {
2683                                         selectedCellsMap.remove(tp);
2684                                     }
2685                                 }
2686                             }
2687 
2688                             if (oldTP != null &amp;&amp; param.isSelected()) {
2689                                 TreeTablePosition&lt;S,?&gt; newTP = new TreeTablePosition&lt;&gt;(
2690                                         treeTableView, param.getSetIndex(), oldTP.getTableColumn());
2691 
2692                                 selectedCellsMap.add(newTP);
2693                             }
2694 
2695                             stopAtomic();
2696 
2697                             return null;
2698                         }
2699                     });
2700                 }
2701             }
2702         };
2703 
2704         private WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
2705                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
2706 
2707         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
2708 
2709 
2710 
2711         /***********************************************************************
2712          *                                                                     *
2713          * Observable properties (and getters/setters)                         *
2714          *                                                                     *
2715          **********************************************************************/
2716 
2717         // the only &#39;proper&#39; internal data structure, selectedItems and selectedIndices
2718         // are both &#39;read-only and unbacked&#39;.
2719         private final SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsMap;
2720 
2721         private final ReadOnlyUnbackedObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsSeq;
2722         @Override public ObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; getSelectedCells() {
2723             return selectedCellsSeq;
2724         }
2725 
2726 
2727         /***********************************************************************
2728          *                                                                     *
2729          * Internal properties                                                 *
2730          *                                                                     *
2731          **********************************************************************/
2732 
2733 
2734 
2735         /***********************************************************************
2736          *                                                                     *
2737          * Public selection API                                                *
2738          *                                                                     *
2739          **********************************************************************/
2740 
2741         @Override public void clearAndSelect(int row) {
2742             clearAndSelect(row, null);
2743         }
2744 
2745         @Override public void clearAndSelect(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
2746             if (row &lt; 0 || row &gt;= getItemCount()) return;
2747 
2748             final TreeTablePosition&lt;S,?&gt; newTablePosition = new TreeTablePosition&lt;&gt;(getTreeTableView(), row, (TreeTableColumn&lt;S,?&gt;)column);
2749             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
2750 
2751             // replace the anchor
2752             TreeTableCellBehavior.setAnchor(treeTableView, newTablePosition, false);
2753 
2754             // firstly we make a copy of the selection, so that we can send out
2755             // the correct details in the selection change event.
2756             List&lt;TreeTablePosition&lt;S,?&gt;&gt; previousSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());
2757 
2758             // secondly we check if we can short-circuit out of here because the new selection
2759             // equals the current selection
2760             final boolean wasSelected = isSelected(row, column);
2761             if (wasSelected &amp;&amp; previousSelection.size() == 1) {
2762                 // before we return, we double-check that the selected item
2763                 // is equal to the item in the given index
2764                 TreeTablePosition&lt;S,?&gt; selectedCell = getSelectedCells().get(0);
2765                 if (getSelectedItem() == getModelItem(row)) {
2766                     if (selectedCell.getRow() == row &amp;&amp; selectedCell.getTableColumn() == column) {
2767                         return;
2768                     }
2769                 }
2770             }
2771 
2772             // RT-32411: We used to call quietClearSelection() here, but this
2773             // resulted in the selectedItems and selectedIndices lists never
2774             // reporting that they were empty.
2775             // makeAtomic toggle added to resolve RT-32618
2776             startAtomic();
2777 
2778             // then clear the current selection
2779             clearSelection();
2780 
2781             // and select the new cell
2782             select(row, column);
2783 
2784             stopAtomic();
2785 
2786             // We remove the new selection from the list seeing as it is not removed.
2787             if (isCellSelectionEnabled) {
2788                 previousSelection.remove(newTablePosition);
2789             } else {
2790                 for (TreeTablePosition&lt;S,?&gt; tp : previousSelection) {
2791                     if (tp.getRow() == row) {
2792                         previousSelection.remove(tp);
2793                         break;
2794                     }
2795                 }
2796             }
2797 
2798             // fire off a single add/remove/replace notification (rather than
2799             // individual remove and add notifications) - see RT-33324
2800             ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; change;
2801 
2802             /*
2803              * getFrom() documentation:
2804              *   If wasAdded is true, the interval contains all the values that were added.
2805              *   If wasPermutated is true, the interval marks the values that were permutated.
2806              *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
2807              *   return the same number - the place where the removed elements were positioned in the list.
2808              */
2809             if (wasSelected) {
2810                 change = ControlUtils.buildClearAndSelectChange(selectedCellsSeq, previousSelection, row);
2811             } else {
2812                 final int changeIndex = isCellSelectionEnabled ? 0 : Math.max(0, selectedCellsSeq.indexOf(newTablePosition));
2813                 final int changeSize = isCellSelectionEnabled ? getSelectedCells().size() : 1;
2814                 change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
2815                         changeIndex, changeIndex + changeSize, previousSelection, selectedCellsSeq);
2816 //                selectedCellsSeq._beginChange();
2817 //                selectedCellsSeq._nextAdd(changeIndex, changeIndex + changeSize);
2818 //                selectedCellsSeq._nextRemove(changeIndex, previousSelection);
2819 //                selectedCellsSeq._endChange();
2820             }
2821 
2822             fireCustomSelectedCellsListChangeEvent(change);
2823         }
2824 
2825         @Override public void select(int row) {
2826             select(row, null);
2827         }
2828 
2829         @Override public void select(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
2830             // TODO we need to bring in the TreeView selection stuff here...
2831             if (row &lt; 0 || row &gt;= getRowCount()) return;
2832 
2833             // if I&#39;m in cell selection mode but the column is null, select each
2834             // of the contained cells individually
2835             if (isCellSelectionEnabled() &amp;&amp; column == null) {
2836                 List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2837                 for (int i = 0; i &lt; columns.size(); i++) {
2838                     select(row, columns.get(i));
2839                 }
2840                 return;
2841             }
2842 
2843             if (TableCellBehavior.hasDefaultAnchor(treeTableView)) {
2844                 TableCellBehavior.removeAnchor(treeTableView);
2845             }
2846 
2847             if (getSelectionMode() == SelectionMode.SINGLE) {
2848                 quietClearSelection();
2849             }
2850             selectedCellsMap.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, (TreeTableColumn&lt;S,?&gt;)column));
2851 
2852             updateSelectedIndex(row);
2853             focus(row, (TreeTableColumn&lt;S, ?&gt;) column);
2854         }
2855 
2856         @Override public void select(TreeItem&lt;S&gt; obj) {
2857             if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
2858                 clearSelection();
2859                 return;
2860             }
2861 
2862             int firstIndex = treeTableView.getRow(obj);
2863             if (firstIndex &gt; -1) {
2864                 if (isSelected(firstIndex)) {
2865                     return;
2866                 }
2867 
2868                 if (getSelectionMode() == SelectionMode.SINGLE) {
2869                     quietClearSelection();
2870                 }
2871 
2872                 select(firstIndex);
2873             } else {
2874                 // if we are here, we did not find the item in the entire data model.
2875                 // Even still, we allow for this item to be set to the give object.
2876                 // We expect that in concrete subclasses of this class we observe the
2877                 // data model such that we check to see if the given item exists in it,
2878                 // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
2879                 setSelectedIndex(-1);
2880                 setSelectedItem(obj);
2881             }
2882         }
2883 
2884         @Override public void selectIndices(int row, int... rows) {
2885             if (rows == null) {
2886                 select(row);
2887                 return;
2888             }
2889 
2890             /*
2891              * Performance optimisation - if multiple selection is disabled, only
2892              * process the end-most row index.
2893              */
2894             int rowCount = getRowCount();
2895 
2896             if (getSelectionMode() == SelectionMode.SINGLE) {
2897                 quietClearSelection();
2898 
2899                 for (int i = rows.length - 1; i &gt;= 0; i--) {
2900                     int index = rows[i];
2901                     if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
2902                         select(index);
2903                         break;
2904                     }
2905                 }
2906 
2907                 if (selectedCellsMap.isEmpty()) {
2908                     if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
2909                         select(row);
2910                     }
2911                 }
2912             } else {
2913                 int lastIndex = -1;
2914                 Set&lt;TreeTablePosition&lt;S,?&gt;&gt; positions = new LinkedHashSet&lt;&gt;();
2915 
2916                 // --- firstly, we special-case the non-varargs &#39;row&#39; argument
2917                 if (row &gt;= 0 &amp;&amp; row &lt; rowCount) {
2918                     // if I&#39;m in cell selection mode, we want to select each
2919                     // of the contained cells individually
2920                     if (isCellSelectionEnabled()) {
2921                         List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2922                         for (int column = 0; column &lt; columns.size(); column++) {
2923                             if (! selectedCellsMap.isSelected(row, column)) {
2924                                 positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, columns.get(column)));
2925                             }
2926                         }
2927                     } else {
2928                         boolean match = selectedCellsMap.isSelected(row, -1);
2929                         if (!match) {
2930                             positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, null));
2931                         }
2932                     }
2933 
2934                     lastIndex = row;
2935                 }
2936 
2937                 // --- now we iterate through all varargs values
2938                 for (int i = 0; i &lt; rows.length; i++) {
2939                     int index = rows[i];
2940                     if (index &lt; 0 || index &gt;= rowCount) continue;
2941                     lastIndex = index;
2942 
2943                     if (isCellSelectionEnabled()) {
2944                         List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2945                         for (int column = 0; column &lt; columns.size(); column++) {
2946                             if (! selectedCellsMap.isSelected(index, column)) {
2947                                 positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), index, columns.get(column)));
2948                                 lastIndex = index;
2949                             }
2950                         }
2951                     } else {
2952                         if (! selectedCellsMap.isSelected(index, -1)) {
2953                             // if we are here then we have successfully gotten through the for-loop above
2954                             positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), index, null));
2955                         }
2956                     }
2957                 }
2958 
2959                 selectedCellsMap.addAll(positions);
2960 
2961                 if (lastIndex != -1) {
2962                     select(lastIndex);
2963                 }
2964             }
2965         }
2966 
2967         @Override public void selectAll() {
2968             if (getSelectionMode() == SelectionMode.SINGLE) return;
2969 
2970             if (isCellSelectionEnabled()) {
2971                 List&lt;TreeTablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
2972                 TreeTableColumn&lt;S,?&gt; column;
2973                 TreeTablePosition&lt;S,?&gt; tp = null;
2974                 for (int col = 0; col &lt; getTreeTableView().getVisibleLeafColumns().size(); col++) {
2975                     column = getTreeTableView().getVisibleLeafColumns().get(col);
2976                     for (int row = 0; row &lt; getRowCount(); row++) {
2977                         tp = new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column);
2978                         indices.add(tp);
2979                     }
2980                 }
2981                 selectedCellsMap.setAll(indices);
2982 
2983                 if (tp != null) {
2984                     select(tp.getRow(), tp.getTableColumn());
2985                     focus(tp.getRow(), tp.getTableColumn());
2986                 }
2987             } else {
2988                 List&lt;TreeTablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
2989                 for (int i = 0; i &lt; getRowCount(); i++) {
2990                     indices.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), i, null));
2991                 }
2992                 selectedCellsMap.setAll(indices);
2993 
2994                 int focusedIndex = getFocusedIndex();
2995                 if (focusedIndex == -1) {
2996                     final int itemCount = getItemCount();
2997                     if (itemCount &gt; 0) {
2998                         select(itemCount - 1);
2999                         focus(indices.get(indices.size() - 1));
3000                     }
3001                 } else {
3002                     select(focusedIndex);
3003                     focus(focusedIndex);
3004                 }
3005             }
3006         }
3007 
3008         @Override public void selectRange(int minRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; minColumn,
3009                                           int maxRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; maxColumn) {
3010             if (getSelectionMode() == SelectionMode.SINGLE) {
3011                 quietClearSelection();
3012                 select(maxRow, maxColumn);
3013                 return;
3014             }
3015 
3016             startAtomic();
3017 
3018             final int itemCount = getItemCount();
3019             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
3020 
3021             final int minColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)minColumn);
3022             final int maxColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)maxColumn);
3023             final int _minColumnIndex = Math.min(minColumnIndex, maxColumnIndex);
3024             final int _maxColumnIndex = Math.max(minColumnIndex, maxColumnIndex);
3025 
3026             final int _minRow = Math.min(minRow, maxRow);
3027             final int _maxRow = Math.max(minRow, maxRow);
3028 
3029             List&lt;TreeTablePosition&lt;S,?&gt;&gt; cellsToSelect = new ArrayList&lt;&gt;();
3030 
3031             for (int _row = _minRow; _row &lt;= _maxRow; _row++) {
3032                 // begin copy/paste of select(int, column) method (with some
3033                 // slight modifications)
3034                 if (_row &lt; 0 || _row &gt;= itemCount) continue;
3035 
3036                 if (! isCellSelectionEnabled) {
3037                     cellsToSelect.add(new TreeTablePosition&lt;&gt;(treeTableView, _row, (TreeTableColumn&lt;S,?&gt;)minColumn));
3038                 } else {
3039                     for (int _col = _minColumnIndex; _col &lt;= _maxColumnIndex; _col++) {
3040                         final TreeTableColumn&lt;S, ?&gt; column = treeTableView.getVisibleLeafColumn(_col);
3041 
3042                         // if I&#39;m in cell selection mode but the column is null, I don&#39;t want
3043                         // to select the whole row instead...
3044                         if (column == null &amp;&amp; isCellSelectionEnabled) continue;
3045 
3046                         cellsToSelect.add(new TreeTablePosition&lt;&gt;(treeTableView, _row, column));
3047                         // end copy/paste
3048                     }
3049                 }
3050             }
3051 
3052             // to prevent duplication we remove all currently selected cells from
3053             // our list of cells to select.
3054             cellsToSelect.removeAll(getSelectedCells());
3055 
3056             selectedCellsMap.addAll(cellsToSelect);
3057             stopAtomic();
3058 
3059             // fire off events
3060             // Note that focus and selection always goes to maxRow, not _maxRow.
3061             updateSelectedIndex(maxRow);
3062             focus(maxRow, (TreeTableColumn&lt;S,?&gt;)maxColumn);
3063 
3064             final TreeTableColumn&lt;S,?&gt; startColumn = (TreeTableColumn&lt;S,?&gt;)minColumn;
3065             final TreeTableColumn&lt;S,?&gt; endColumn = isCellSelectionEnabled ? (TreeTableColumn&lt;S,?&gt;)maxColumn : startColumn;
3066             final int startChangeIndex = selectedCellsMap.indexOf(new TreeTablePosition&lt;&gt;(treeTableView, minRow, startColumn));
3067             final int endChangeIndex = selectedCellsMap.indexOf(new TreeTablePosition&lt;&gt;(treeTableView, maxRow, endColumn));
3068 
3069             if (startChangeIndex &gt; -1 &amp;&amp; endChangeIndex &gt; -1) {
3070                 final int startIndex = Math.min(startChangeIndex, endChangeIndex);
3071                 final int endIndex = Math.max(startChangeIndex, endChangeIndex);
3072 
3073                 ListChangeListener.Change c = new NonIterableChange.SimpleAddChange&lt;&gt;(startIndex, endIndex + 1, selectedCellsSeq);
3074                 fireCustomSelectedCellsListChangeEvent(c);
3075 //                selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextAdd(startIndex, endIndex + 1));
3076             }
3077         }
3078 
3079         @Override public void clearSelection(int index) {
3080             clearSelection(index, null);
3081         }
3082 
3083         @Override
3084         public void clearSelection(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
3085             clearSelection(new TreeTablePosition&lt;S,Object&gt;(getTreeTableView(), row, (TreeTableColumn)column));
3086         }
3087 
3088         private void clearSelection(TreeTablePosition&lt;S,?&gt; tp) {
3089             final boolean csMode = isCellSelectionEnabled();
3090             final int row = tp.getRow();
3091             final boolean columnIsNull = tp.getTableColumn() == null;
3092 
3093             List&lt;TreeTablePosition&gt; toRemove = new ArrayList&lt;&gt;();
3094             for (TreeTablePosition pos : getSelectedCells()) {
3095                 if (!csMode) {
3096                     if (pos.getRow() == row) {
3097                         toRemove.add(pos);
3098                         break;
3099                     }
3100                 } else {
3101                     if (columnIsNull &amp;&amp; pos.getRow() == row) {
3102                         // if we are in cell selection mode and the column is null,
3103                         // we remove all items in the row
3104                         toRemove.add(pos);
3105                     } else if (pos.equals(tp)) {
3106                         toRemove.add(tp);
3107                         break;
3108                     }
3109                 }
3110             }
3111             toRemove.stream().forEach(selectedCellsMap::remove);
3112 
3113             if (isEmpty() &amp;&amp; ! isAtomic()) {
3114                 updateSelectedIndex(-1);
3115                 selectedCellsMap.clear();
3116             }
3117         }
3118 
3119         @Override public void clearSelection() {
3120             final List&lt;TreeTablePosition&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;((Collection)getSelectedCells());
3121 
3122             quietClearSelection();
3123 
3124             if (! isAtomic()) {
3125                 updateSelectedIndex(-1);
3126                 focus(-1);
3127 
3128                 if (!removed.isEmpty()) {
3129 //                    selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextRemove(0, removed));
3130                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange&lt;TreeTablePosition&lt;S, ?&gt;&gt;(0, 0, selectedCellsSeq) {
3131                         @Override public List&lt;TreeTablePosition&lt;S, ?&gt;&gt; getRemoved() {
3132                             return removed;
3133                         }
3134                     };
3135                     fireCustomSelectedCellsListChangeEvent(c);
3136                 }
3137             }
3138         }
3139 
3140         private void quietClearSelection() {
3141             startAtomic();
3142             selectedCellsMap.clear();
3143             stopAtomic();
3144         }
3145 
3146         @Override public boolean isSelected(int index) {
3147             return isSelected(index, null);
3148         }
3149 
3150         @Override public boolean isSelected(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
3151             // When in cell selection mode, if the column is null, then we interpret
3152             // the users query to be asking if _all_ of the cells in the row are selected,
3153             // rather than if _any_ of the cells in the row are selected.
3154             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
3155             if (isCellSelectionEnabled &amp;&amp; column == null) {
3156                 int columnCount = treeTableView.getVisibleLeafColumns().size();
3157                 for (int col = 0; col &lt; columnCount; col++) {
3158                     if (!selectedCellsMap.isSelected(row, col)) {
3159                         return false;
3160                     }
3161                 }
3162                 return true;
3163             } else {
3164                 int columnIndex = !isCellSelectionEnabled || column == null ? -1 : treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S, ?&gt;) column);
3165                 return selectedCellsMap.isSelected(row, columnIndex);
3166             }
3167         }
3168 
3169         @Override public boolean isEmpty() {
3170             return selectedCellsMap.isEmpty();
3171         }
3172 
3173         @Override public void selectPrevious() {
3174             if (isCellSelectionEnabled()) {
3175                 // in cell selection mode, we have to wrap around, going from
3176                 // right-to-left, and then wrapping to the end of the previous line
3177                 TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3178                 if (pos.getColumn() - 1 &gt;= 0) {
3179                     // go to previous row
3180                     select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
3181                 } else if (pos.getRow() &lt; getRowCount() - 1) {
3182                     // wrap to end of previous row
3183                     select(pos.getRow() - 1, getTableColumn(getTreeTableView().getVisibleLeafColumns().size() - 1));
3184                 }
3185             } else {
3186                 int focusIndex = getFocusedIndex();
3187                 if (focusIndex == -1) {
3188                     select(getRowCount() - 1);
3189                 } else if (focusIndex &gt; 0) {
3190                     select(focusIndex - 1);
3191                 }
3192             }
3193         }
3194 
3195         @Override public void selectNext() {
3196             if (isCellSelectionEnabled()) {
3197                 // in cell selection mode, we have to wrap around, going from
3198                 // left-to-right, and then wrapping to the start of the next line
3199                 TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3200                 if (pos.getColumn() + 1 &lt; getTreeTableView().getVisibleLeafColumns().size()) {
3201                     // go to next column
3202                     select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
3203                 } else if (pos.getRow() &lt; getRowCount() - 1) {
3204                     // wrap to start of next row
3205                     select(pos.getRow() + 1, getTableColumn(0));
3206                 }
3207             } else {
3208                 int focusIndex = getFocusedIndex();
3209                 if (focusIndex == -1) {
3210                     select(0);
3211                 } else if (focusIndex &lt; getRowCount() -1) {
3212                     select(focusIndex + 1);
3213                 }
3214             }
3215         }
3216 
3217         @Override public void selectAboveCell() {
3218             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3219             if (pos.getRow() == -1) {
3220                 select(getRowCount() - 1);
3221             } else if (pos.getRow() &gt; 0) {
3222                 select(pos.getRow() - 1, pos.getTableColumn());
3223             }
3224         }
3225 
3226         @Override public void selectBelowCell() {
3227             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3228 
3229             if (pos.getRow() == -1) {
3230                 select(0);
3231             } else if (pos.getRow() &lt; getRowCount() -1) {
3232                 select(pos.getRow() + 1, pos.getTableColumn());
3233             }
3234         }
3235 
3236         @Override public void selectFirst() {
3237             TreeTablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
3238 
3239             if (getSelectionMode() == SelectionMode.SINGLE) {
3240                 quietClearSelection();
3241             }
3242 
3243             if (getRowCount() &gt; 0) {
3244                 if (isCellSelectionEnabled()) {
3245                     select(0, focusedCell.getTableColumn());
3246                 } else {
3247                     select(0);
3248                 }
3249             }
3250         }
3251 
3252         @Override public void selectLast() {
3253             TreeTablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
3254 
3255             if (getSelectionMode() == SelectionMode.SINGLE) {
3256                 quietClearSelection();
3257             }
3258 
3259             int numItems = getRowCount();
3260             if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
3261                 if (isCellSelectionEnabled()) {
3262                     select(numItems - 1, focusedCell.getTableColumn());
3263                 } else {
3264                     select(numItems - 1);
3265                 }
3266             }
3267         }
3268 
3269         @Override public void selectLeftCell() {
3270             if (! isCellSelectionEnabled()) return;
3271 
3272             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3273             if (pos.getColumn() - 1 &gt;= 0) {
3274                 select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
3275             }
3276         }
3277 
3278         @Override public void selectRightCell() {
3279             if (! isCellSelectionEnabled()) return;
3280 
3281             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3282             if (pos.getColumn() + 1 &lt; getTreeTableView().getVisibleLeafColumns().size()) {
3283                 select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
3284             }
3285         }
3286 
3287 
3288 
3289         /***********************************************************************
3290          *                                                                     *
3291          * Support code                                                        *
3292          *                                                                     *
3293          **********************************************************************/
3294 
3295         private void updateDefaultSelection() {
3296             // when the items list totally changes, we should clear out
3297             // the selection
3298             int newSelectionIndex = -1;
3299             TreeItem&lt;S&gt; selectedItem = getSelectedItem();
3300             if (selectedItem != null) {
3301                 newSelectionIndex = treeTableView.getRow(selectedItem);
3302             }
3303 
3304             // we put focus onto the first item, if there is at least
3305             // one item in the list
3306             int newFocusIndex = newSelectionIndex != -1 ? newSelectionIndex : treeTableView.getExpandedItemCount() &gt; 0 ? 0 : -1;
3307 
3308             clearSelection();
3309             select(newSelectionIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
3310             focus(newFocusIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
3311         }
3312 
3313         private TreeTableColumn&lt;S,?&gt; getTableColumn(int pos) {
3314             return getTreeTableView().getVisibleLeafColumn(pos);
3315         }
3316 
3317         // Gets a table column to the left or right of the current one, given an offset
3318         private TreeTableColumn&lt;S,?&gt; getTableColumn(TreeTableColumn&lt;S,?&gt; column, int offset) {
3319             int columnIndex = getTreeTableView().getVisibleLeafIndex(column);
3320             int newColumnIndex = columnIndex + offset;
3321             return getTreeTableView().getVisibleLeafColumn(newColumnIndex);
3322         }
3323 
3324         private void updateSelectedIndex(int row) {
3325             setSelectedIndex(row);
3326             setSelectedItem(getModelItem(row));
3327         }
3328 
3329         @Override public void focus(int row) {
3330             focus(row, null);
3331         }
3332 
3333         private void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
3334             focus(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column));
3335         }
3336 
3337         private void focus(TreeTablePosition&lt;S,?&gt; pos) {
3338             if (getTreeTableView().getFocusModel() == null) return;
3339 
3340             getTreeTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
3341             getTreeTableView().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
3342         }
3343 
3344         @Override public int getFocusedIndex() {
3345             return getFocusedCell().getRow();
3346         }
3347 
3348         private TreeTablePosition&lt;S,?&gt; getFocusedCell() {
3349             if (treeTableView.getFocusModel() == null) {
3350                 return new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
3351             }
3352             return treeTableView.getFocusModel().getFocusedCell();
3353         }
3354 
3355         private int getRowCount() {
3356             return treeTableView.getExpandedItemCount();
3357         }
3358 
3359         private void fireCustomSelectedCellsListChangeEvent(ListChangeListener.Change&lt;? extends TreeTablePosition&lt;S,?&gt;&gt; c) {
3360             ControlUtils.updateSelectedIndices(this, c);
3361 
3362             if (isAtomic()) {
3363                 return;
3364             }
3365 
3366             selectedCellsSeq.callObservers(new MappingChange&lt;&gt;(c, MappingChange.NOOP_MAP, selectedCellsSeq));
3367         }
3368     }
3369 
3370 
3371 
3372 
3373     /**
3374      * A {@link FocusModel} with additional functionality to support the requirements
3375      * of a TableView control.
3376      *
3377      * @see TableView
3378      * @since JavaFX 8.0
3379      */
3380     public static class TreeTableViewFocusModel&lt;S&gt; extends TableFocusModel&lt;TreeItem&lt;S&gt;, TreeTableColumn&lt;S,?&gt;&gt; {
3381 
3382         private final TreeTableView&lt;S&gt; treeTableView;
3383 
3384         private final TreeTablePosition EMPTY_CELL;
3385 
3386         /**
3387          * Creates a default TableViewFocusModel instance that will be used to
3388          * manage focus of the provided TableView control.
3389          *
3390          * @param treeTableView The tableView upon which this focus model operates.
3391          * @throws NullPointerException The TableView argument can not be null.
3392          */
3393         public TreeTableViewFocusModel(final TreeTableView&lt;S&gt; treeTableView) {
3394             if (treeTableView == null) {
3395                 throw new NullPointerException(&quot;TableView can not be null&quot;);
3396             }
3397 
3398             this.treeTableView = treeTableView;
3399             this.EMPTY_CELL = new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
3400 
3401             this.treeTableView.rootProperty().addListener(weakRootPropertyListener);
3402             updateTreeEventListener(null, treeTableView.getRoot());
3403 
3404             int focusRow = getItemCount() &gt; 0 ? 0 : -1;
3405             TreeTablePosition&lt;S,?&gt; pos = new TreeTablePosition&lt;&gt;(treeTableView, focusRow, null);
3406             setFocusedCell(pos);
3407 
3408             showRootListener = obs -&gt; {
3409                 if (isFocused(0)) {
3410                     focus(-1);
3411                     focus(0);
3412                 }
3413             };
3414             treeTableView.showRootProperty().addListener(new WeakInvalidationListener(showRootListener));
3415 
3416             focusedCellProperty().addListener(o -&gt; {
3417                 treeTableView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
3418             });
3419         }
3420 
3421         private final ChangeListener&lt;TreeItem&lt;S&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
3422             updateTreeEventListener(oldValue, newValue);
3423         };
3424 
3425         private final WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
3426                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
3427 
3428         private final InvalidationListener showRootListener;
3429 
3430         private void updateTreeEventListener(TreeItem&lt;S&gt; oldRoot, TreeItem&lt;S&gt; newRoot) {
3431             if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
3432                 oldRoot.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
3433             }
3434 
3435             if (newRoot != null) {
3436                 weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
3437                 newRoot.addEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
3438             }
3439         }
3440 
3441         private EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; treeItemListener = new EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt;() {
3442             @Override public void handle(TreeItem.TreeModificationEvent&lt;S&gt; e) {
3443                 // don&#39;t shift focus if the event occurred on a tree item after
3444                 // the focused row, or if there is no focus index at present
3445                 if (getFocusedIndex() == -1) return;
3446 
3447                 int shift = 0;
3448                 if (e.getChange() != null) {
3449                     e.getChange().next();
3450                 }
3451 
3452                 do {
3453                     int row = treeTableView.getRow(e.getTreeItem());
3454 
3455                     if (e.wasExpanded()) {
3456                         if (row &lt; getFocusedIndex()) {
3457                             // need to shuffle selection by the number of visible children
3458                             shift += e.getTreeItem().getExpandedDescendentCount(false) - 1;
3459                         }
3460                     } else if (e.wasCollapsed()) {
3461                         if (row &lt; getFocusedIndex()) {
3462                             // need to shuffle selection by the number of visible children
3463                             // that were just hidden
3464                             shift += -e.getTreeItem().previousExpandedDescendentCount + 1;
3465                         }
3466                     } else if (e.wasAdded()) {
3467                         // get the TreeItem the event occurred on - we only need to
3468                         // shift if the tree item is expanded
3469                         TreeItem&lt;S&gt; eventTreeItem = e.getTreeItem();
3470                         if (eventTreeItem.isExpanded()) {
3471                             for (int i = 0; i &lt; e.getAddedChildren().size(); i++) {
3472                                 // get the added item and determine the row it is in
3473                                 TreeItem&lt;S&gt; item = e.getAddedChildren().get(i);
3474                                 row = treeTableView.getRow(item);
3475 
3476                                 if (item != null &amp;&amp; row &lt;= (shift+getFocusedIndex())) {
3477                                     shift += item.getExpandedDescendentCount(false);
3478                                 }
3479                             }
3480                         }
3481                     } else if (e.wasRemoved()) {
3482                         row += e.getFrom() + 1;
3483 
3484                         for (int i = 0; i &lt; e.getRemovedChildren().size(); i++) {
3485                             TreeItem&lt;S&gt; item = e.getRemovedChildren().get(i);
3486                             if (item != null &amp;&amp; item.equals(getFocusedItem())) {
3487                                 focus(Math.max(0, getFocusedIndex() - 1));
3488                                 return;
3489                             }
3490                         }
3491 
3492                         if (row &lt;= getFocusedIndex()) {
3493                             // shuffle selection by the number of removed items
3494                             shift += e.getTreeItem().isExpanded() ? -e.getRemovedSize() : 0;
3495                         }
3496                     }
3497                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
3498 
3499                 if (shift != 0) {
3500                     TreeTablePosition&lt;S, ?&gt; focusedCell = getFocusedCell();
3501                     final int newFocus = focusedCell.getRow() + shift;
3502                     if (newFocus &gt;= 0) {
3503                         Platform.runLater(() -&gt; focus(newFocus, focusedCell.getTableColumn()));
3504                     }
3505                 }
3506             }
3507         };
3508 
3509         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
3510 
3511         /** {@inheritDoc} */
3512         @Override protected int getItemCount() {
3513 //            if (tableView.getItems() == null) return -1;
3514 //            return tableView.getItems().size();
3515             return treeTableView.getExpandedItemCount();
3516         }
3517 
3518         /** {@inheritDoc} */
3519         @Override protected TreeItem&lt;S&gt; getModelItem(int index) {
3520             if (index &lt; 0 || index &gt;= getItemCount()) return null;
3521             return treeTableView.getTreeItem(index);
3522         }
3523 
3524         /**
3525          * The position of the current item in the TableView which has the focus.
3526          */
3527         private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCell;
3528         public final ReadOnlyObjectProperty&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCellProperty() {
3529             return focusedCellPropertyImpl().getReadOnlyProperty();
3530         }
3531         private void setFocusedCell(TreeTablePosition&lt;S,?&gt; value) { focusedCellPropertyImpl().set(value);  }
3532         public final TreeTablePosition&lt;S,?&gt; getFocusedCell() { return focusedCell == null ? EMPTY_CELL : focusedCell.get(); }
3533 
3534         private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCellPropertyImpl() {
3535             if (focusedCell == null) {
3536                 focusedCell = new ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt;(EMPTY_CELL) {
3537                     private TreeTablePosition&lt;S,?&gt; old;
3538                     @Override protected void invalidated() {
3539                         if (get() == null) return;
3540 
3541                         if (old == null || !old.equals(get())) {
3542                             setFocusedIndex(get().getRow());
3543                             setFocusedItem(getModelItem(getValue().getRow()));
3544 
3545                             old = get();
3546                         }
3547                     }
3548 
3549                     @Override
3550                     public Object getBean() {
3551                         return TreeTableView.TreeTableViewFocusModel.this;
3552                     }
3553 
3554                     @Override
3555                     public String getName() {
3556                         return &quot;focusedCell&quot;;
3557                     }
3558                 };
3559             }
3560             return focusedCell;
3561         }
3562 
3563 
3564         /**
3565          * Causes the item at the given index to receive the focus.
3566          *
3567          * @param row The row index of the item to give focus to.
3568          * @param column The column of the item to give focus to. Can be null.
3569          */
3570         @Override public void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
3571             if (row &lt; 0 || row &gt;= getItemCount()) {
3572                 setFocusedCell(EMPTY_CELL);
3573             } else {
3574                 TreeTablePosition&lt;S,?&gt; oldFocusCell = getFocusedCell();
3575                 TreeTablePosition&lt;S,?&gt; newFocusCell = new TreeTablePosition&lt;&gt;(treeTableView, row, column);
3576                 setFocusedCell(newFocusCell);
3577 
3578                 if (newFocusCell.equals(oldFocusCell)) {
3579                     // manually update the focus properties to ensure consistency
3580                     setFocusedIndex(row);
3581                     setFocusedItem(getModelItem(row));
3582                 }
3583             }
3584         }
3585 
3586         /**
3587          * Convenience method for setting focus on a particular row or cell
3588          * using a {@link TablePosition}.
3589          *
3590          * @param pos The table position where focus should be set.
3591          */
3592         public void focus(TreeTablePosition&lt;S,?&gt; pos) {
3593             if (pos == null) return;
3594             focus(pos.getRow(), pos.getTableColumn());
3595         }
3596 
3597 
3598         /***********************************************************************
3599          *                                                                     *
3600          * Public API                                                          *
3601          *                                                                     *
3602          **********************************************************************/
3603 
3604         /**
3605          * Tests whether the row / cell at the given location currently has the
3606          * focus within the TableView.
3607          */
3608         @Override public boolean isFocused(int row, TreeTableColumn&lt;S,?&gt; column) {
3609             if (row &lt; 0 || row &gt;= getItemCount()) return false;
3610 
3611             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3612             boolean columnMatch = column == null || column.equals(cell.getTableColumn());
3613 
3614             return cell.getRow() == row &amp;&amp; columnMatch;
3615         }
3616 
3617         /**
3618          * Causes the item at the given index to receive the focus. This does not
3619          * cause the current selection to change. Updates the focusedItem and
3620          * focusedIndex properties such that &lt;code&gt;focusedIndex = -1&lt;/code&gt; unless
3621          * &lt;pre&gt;&lt;code&gt;0 &amp;lt;= index &amp;lt; model size&lt;/code&gt;&lt;/pre&gt;.
3622          *
3623          * @param index The index of the item to get focus.
3624          */
3625         @Override public void focus(int index) {
3626             if (treeTableView.expandedItemCountDirty) {
3627                 treeTableView.updateExpandedItemCount(treeTableView.getRoot());
3628             }
3629 
3630             if (index &lt; 0 || index &gt;= getItemCount()) {
3631                 setFocusedCell(EMPTY_CELL);
3632             } else {
3633                 setFocusedCell(new TreeTablePosition&lt;&gt;(treeTableView, index, null));
3634             }
3635         }
3636 
3637         /**
3638          * Attempts to move focus to the cell above the currently focused cell.
3639          */
3640         @Override public void focusAboveCell() {
3641             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3642 
3643             if (getFocusedIndex() == -1) {
3644                 focus(getItemCount() - 1, cell.getTableColumn());
3645             } else if (getFocusedIndex() &gt; 0) {
3646                 focus(getFocusedIndex() - 1, cell.getTableColumn());
3647             }
3648         }
3649 
3650         /**
3651          * Attempts to move focus to the cell below the currently focused cell.
3652          */
3653         @Override public void focusBelowCell() {
3654             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3655             if (getFocusedIndex() == -1) {
3656                 focus(0, cell.getTableColumn());
3657             } else if (getFocusedIndex() != getItemCount() -1) {
3658                 focus(getFocusedIndex() + 1, cell.getTableColumn());
3659             }
3660         }
3661 
3662         /**
3663          * Attempts to move focus to the cell to the left of the currently focused cell.
3664          */
3665         @Override public void focusLeftCell() {
3666             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3667             if (cell.getColumn() &lt;= 0) return;
3668             focus(cell.getRow(), getTableColumn(cell.getTableColumn(), -1));
3669         }
3670 
3671         /**
3672          * Attempts to move focus to the cell to the right of the the currently focused cell.
3673          */
3674         @Override public void focusRightCell() {
3675             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3676             if (cell.getColumn() == getColumnCount() - 1) return;
3677             focus(cell.getRow(), getTableColumn(cell.getTableColumn(), 1));
3678         }
3679 
3680         /** {@inheritDoc} */
3681         @Override public void focusPrevious() {
3682             if (getFocusedIndex() == -1) {
3683                 focus(0);
3684             } else if (getFocusedIndex() &gt; 0) {
3685                 focusAboveCell();
3686             }
3687         }
3688 
3689         /** {@inheritDoc} */
3690         @Override public void focusNext() {
3691             if (getFocusedIndex() == -1) {
3692                 focus(0);
3693             } else if (getFocusedIndex() != getItemCount() -1) {
3694                 focusBelowCell();
3695             }
3696         }
3697 
3698 
3699 
3700          /***********************************************************************
3701          *                                                                     *
3702          * Private Implementation                                              *
3703          *                                                                     *
3704          **********************************************************************/
3705 
3706         private int getColumnCount() {
3707             return treeTableView.getVisibleLeafColumns().size();
3708         }
3709 
3710         // Gets a table column to the left or right of the current one, given an offset
3711         private TreeTableColumn&lt;S,?&gt; getTableColumn(TreeTableColumn&lt;S,?&gt; column, int offset) {
3712             int columnIndex = treeTableView.getVisibleLeafIndex(column);
3713             int newColumnIndex = columnIndex + offset;
3714             return treeTableView.getVisibleLeafColumn(newColumnIndex);
3715         }
3716     }
3717 }
    </pre>
  </body>
</html>
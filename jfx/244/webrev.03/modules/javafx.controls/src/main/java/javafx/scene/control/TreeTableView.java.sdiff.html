<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TreeTablePosition.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/java/test/javafx/scene/control/TreeTableViewTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  39 import javafx.css.PseudoClass;
  40 
  41 import javafx.css.converter.SizeConverter;
  42 import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
  43 import com.sun.javafx.scene.control.TableColumnComparatorBase;
  44 
  45 import javafx.css.Styleable;
  46 import javafx.css.StyleableDoubleProperty;
  47 import javafx.css.StyleableProperty;
  48 import javafx.event.WeakEventHandler;
  49 
  50 import javafx.scene.control.skin.TreeTableViewSkin;
  51 
  52 import java.lang.ref.SoftReference;
  53 import java.lang.ref.WeakReference;
  54 import java.util.ArrayList;
  55 import java.util.Collection;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashMap;

  59 import java.util.LinkedHashSet;
  60 import java.util.List;
  61 import java.util.Map;
  62 import java.util.Set;
  63 import java.util.WeakHashMap;
  64 
  65 import javafx.application.Platform;
  66 import javafx.beans.DefaultProperty;
  67 import javafx.beans.InvalidationListener;
  68 import javafx.beans.WeakInvalidationListener;
  69 import javafx.beans.property.BooleanProperty;
  70 import javafx.beans.property.ObjectProperty;
  71 import javafx.beans.property.ObjectPropertyBase;
  72 import javafx.beans.property.ReadOnlyIntegerProperty;
  73 import javafx.beans.property.ReadOnlyIntegerWrapper;
  74 import javafx.beans.property.ReadOnlyObjectProperty;
  75 import javafx.beans.property.ReadOnlyObjectWrapper;
  76 import javafx.beans.property.SimpleBooleanProperty;
  77 import javafx.beans.property.SimpleObjectProperty;
  78 import javafx.beans.value.ChangeListener;
</pre>
<hr />
<pre>
1787      * @param column the column
1788      * @return the position of the given column, relative to all other
1789      * visible leaf columns
1790      */
1791     public int getVisibleLeafIndex(TreeTableColumn&lt;S,?&gt; column) {
1792         return getVisibleLeafColumns().indexOf(column);
1793     }
1794 
1795     /**
1796      * Returns the TreeTableColumn in the given column index, relative to all other
1797      * visible leaf columns.
1798      * @param column the column
1799      * @return the TreeTableColumn in the given column index, relative to all other
1800      * visible leaf columns
1801      */
1802     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1803         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1804         return visibleLeafColumns.get(column);
1805     }
1806 










1807     /**
1808      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1809      * often than not it is not necessary to call this method directly, as it is
1810      * automatically called when the {@link #getSortOrder() sort order},
1811      * {@link #sortPolicyProperty() sort policy}, or the state of the
1812      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1813      * change. In other words, this method should only be called directly when
1814      * something external changes and a sort is required.
1815      */
1816     public void sort() {

1817         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1818 
1819         // update the Comparator property
1820         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1821         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1822 
1823         // fire the onSort event and check if it is consumed, if
1824         // so, don&#39;t run the sort
1825         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
1826         fireEvent(sortEvent);
1827         if (sortEvent.isConsumed()) {
1828             // if the sort is consumed we could back out the last action (the code
1829             // is commented out right below), but we don&#39;t as we take it as a
1830             // sign that the developer has decided to handle the event themselves.
1831 
1832             // sortLock = true;
1833             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1834             // sortLock = false;

1835             return;
1836         }
1837 
1838         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1839         final int itemCount = prevState.size();
1840 
1841         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1842         // sort events - instead we send a single permutation event at the end
1843         // of this method.
1844         getSelectionModel().startAtomic();
1845 
1846         // get the sort policy and run it
1847         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
1848         if (sortPolicy == null) return;
1849         Boolean success = sortPolicy.call(this);
1850 










1851         getSelectionModel().stopAtomic();
1852 
1853         if (success == null || ! success) {
1854             // the sort was a failure. Need to backout if possible
1855             sortLock = true;
1856             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1857             setComparator(oldComparator);
1858             sortLock = false;
1859         } else {
1860             // sorting was a success, now we possibly fire an event on the
1861             // selection model that the items list has &#39;permutated&#39; to a new ordering
1862 
1863             // FIXME we should support alternative selection model implementations!
1864             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1865                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1866                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1867 
1868                 List&lt;TreeTablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
1869                 for (int i = 0; i &lt; itemCount; i++) {
1870                     TreeTablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
1871                     if (!newState.contains(prevItem)) {
1872                         removed.add(prevItem);
1873                     }
1874                 }
<span class="line-removed">1875 </span>
1876                 if (!removed.isEmpty()) {
1877                     // the sort operation effectively permutates the selectedCells list,
1878                     // but we cannot fire a permutation event as we are talking about
1879                     // TreeTablePosition&#39;s changing (which may reside in the same list
1880                     // position before and after the sort). Therefore, we need to fire
1881                     // a single add/remove event to cover the added and removed positions.
1882                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
1883                     sm.fireCustomSelectedCellsListChangeEvent(c);
1884                 }
1885             }


1886         }

1887     }
1888 
1889     /**
1890      * Calling {@code refresh()} forces the TreeTableView control to recreate and
1891      * repopulate the cells necessary to populate the visual bounds of the control.
1892      * In other words, this forces the TreeTableView to update what it is showing to
1893      * the user. This is useful in cases where the underlying data source has
1894      * changed in a way that is not observed by the TreeTableView itself.
1895      *
1896      * @since JavaFX 8u60
1897      */
1898     public void refresh() {
1899         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1900     }
1901 
1902 
1903 
1904     /***************************************************************************
1905      *                                                                         *
1906      * Private Implementation                                                  *
</pre>
<hr />
<pre>
2523 
2524                         ControlUtils.reducingChange(selectedIndices, removed);
2525 
2526                         for (int index : removed) {
2527                             startAtomic();
2528                             // we pass in false here to prevent a lookup into the TreeItem, as it is unnecessary
2529                             // and results in JDK-8152396
2530                             clearSelection(new TreeTablePosition&lt;&gt;(treeTableView, index, null, false));
2531                             stopAtomic();
2532                         }
2533                         selectedIndices._endChange();
2534 
2535                         // put selection onto the newly-collapsed tree item
2536                         if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
2537                             select(startRow, selectedColumn);
2538                         }
2539 
2540                         shift += -count + 1;
2541                         startRow++;
2542                     } else if (e.wasPermutated()) {
<span class="line-modified">2543                         // General approach:</span>
<span class="line-modified">2544                         //   -- detected a sort has happened</span>
<span class="line-modified">2545                         //   -- Create a permutation lookup map (1)</span>
<span class="line-modified">2546                         //   -- dump all the selected indices into a list (2)</span>
<span class="line-modified">2547                         //   -- create a list containing the new indices (3)</span>
<span class="line-modified">2548                         //   -- for each previously-selected index (4)</span>
<span class="line-modified">2549                         //     -- if index is in the permutation lookup map</span>
<span class="line-modified">2550                         //       -- add the new index to the new indices list</span>
<span class="line-modified">2551                         //   -- Perform batch selection (5)</span>
<span class="line-modified">2552 </span>
<span class="line-modified">2553                         startAtomic();</span>
<span class="line-removed">2554 </span>
<span class="line-removed">2555                         final int offset = startRow + 1;</span>
<span class="line-removed">2556 </span>
<span class="line-removed">2557                         // (1)</span>
<span class="line-removed">2558                         int length = e.getTo() - e.getFrom();</span>
<span class="line-removed">2559                         HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;&gt; (length);</span>
<span class="line-removed">2560                         for (int i = e.getFrom(); i &lt; e.getTo(); i++) {</span>
<span class="line-removed">2561                             pMap.put(i, e.getChange().getPermutation(i));</span>
<span class="line-removed">2562                         }</span>
2563 
<span class="line-removed">2564                         // (2)</span>
<span class="line-removed">2565                         List&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedIndices = new ArrayList&lt;&gt;(getSelectedCells());</span>
<span class="line-removed">2566 </span>
<span class="line-removed">2567                         // (3)</span>
<span class="line-removed">2568                         List&lt;TreeTablePosition&lt;S,?&gt;&gt; newIndices = new ArrayList&lt;&gt;(selectedIndices.size());</span>
<span class="line-removed">2569 </span>
<span class="line-removed">2570                         // (4)</span>
2571                         boolean selectionIndicesChanged = false;
<span class="line-modified">2572                         for (int i = 0; i &lt; selectedIndices.size(); i++) {</span>
<span class="line-modified">2573                             final TreeTablePosition&lt;S,?&gt; oldIndex = selectedIndices.get(i);</span>
<span class="line-modified">2574                             final int oldRow = oldIndex.getRow() - offset;</span>
<span class="line-modified">2575 </span>
<span class="line-removed">2576                             if (pMap.containsKey(oldRow)) {</span>
<span class="line-removed">2577                                 int newIndex = pMap.get(oldRow) + offset;</span>
<span class="line-removed">2578 </span>
<span class="line-removed">2579                                 selectionIndicesChanged = selectionIndicesChanged || newIndex != oldRow;</span>
<span class="line-removed">2580 </span>
<span class="line-removed">2581                                 newIndices.add(new TreeTablePosition&lt;&gt;(oldIndex.getTreeTableView(), newIndex, oldIndex.getTableColumn()));</span>
<span class="line-removed">2582                             }</span>
<span class="line-removed">2583 </span>
<span class="line-removed">2584                             // check if the root element of this event was selected, so that we can retain it</span>
<span class="line-removed">2585                             if (oldIndex.getRow() == startRow) {</span>
<span class="line-removed">2586                                 newIndices.add(new TreeTablePosition&lt;&gt;(oldIndex.getTreeTableView(), oldIndex.getRow(), oldIndex.getTableColumn()));</span>
2587                             }

2588                         }
<span class="line-removed">2589 </span>
2590                         if (selectionIndicesChanged) {
<span class="line-modified">2591                             // (5)</span>
<span class="line-modified">2592                             quietClearSelection();</span>
<span class="line-modified">2593                             stopAtomic();</span>
<span class="line-modified">2594 </span>
<span class="line-modified">2595                             selectedCellsMap.setAll(newIndices);</span>
<span class="line-modified">2596 </span>
<span class="line-modified">2597                             final int offsetOldIndex = oldSelectedIndex - offset;</span>
<span class="line-modified">2598                             if (offsetOldIndex &gt;= 0 &amp;&amp; offsetOldIndex &lt; getItemCount()) {</span>
<span class="line-modified">2599                                 int newIndex = e.getChange().getPermutation(offsetOldIndex);</span>
<span class="line-modified">2600                                 setSelectedIndex(newIndex + offset);</span>
<span class="line-modified">2601                                 focus(newIndex + offset);</span>

2602                             }
<span class="line-removed">2603                         } else {</span>
<span class="line-removed">2604                             stopAtomic();</span>
2605                         }
2606                     } else if (e.wasAdded()) {
2607                         // shuffle selection by the number of added items
2608                         shift += treeItem.isExpanded() ? addedSize : 0;
2609 
2610                         // RT-32963: We were taking the startRow from the TreeItem
2611                         // in which the children were added, rather than from the
2612                         // actual position of the new child. This led to selection
2613                         // being moved off the parent TreeItem by mistake.
2614                         // The &#39;if (e.getAddedSize() == 1)&#39; condition here was
2615                         // subsequently commented out due to RT-33894.
2616                         startRow = treeTableView.getRow(e.getChange().getAddedSubList().get(0));
2617 
2618                         TreeTablePosition&lt;S, ?&gt; anchor = TreeTableCellBehavior.getAnchor(treeTableView, null);
2619                         if (anchor != null) {
2620                             boolean isAnchorSelected = isSelected(anchor.getRow(), anchor.getTableColumn());
2621                             if (isAnchorSelected) {
2622                                 TreeTablePosition&lt;S, ?&gt; newAnchor = new TreeTablePosition&lt;&gt;(treeTableView, anchor.getRow() + shift, anchor.getTableColumn());
2623                                 TreeTableCellBehavior.setAnchor(treeTableView, newAnchor, false);
2624                             }
</pre>
<hr />
<pre>
2646                             int index = selectedIndices.get(i);
2647                             if (index &gt; selectedItems.size()) break;
2648 
2649                             if (removedChildren.size() == 1 &amp;&amp;
2650                                     selectedItems.size() == 1 &amp;&amp;
2651                                     selectedItem != null &amp;&amp;
2652                                     selectedItem.equals(removedChildren.get(0))) {
2653                                 // Bug fix for RT-28637
2654                                 if (oldSelectedIndex &lt; getItemCount()) {
2655                                     final int previousRow = oldSelectedIndex == 0 ? 0 : oldSelectedIndex - 1;
2656                                     TreeItem&lt;S&gt; newSelectedItem = getModelItem(previousRow);
2657                                     if (!selectedItem.equals(newSelectedItem)) {
2658                                         clearAndSelect(previousRow);
2659                                     }
2660                                 }
2661                             }
2662                         }
2663                     }
2664                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
2665 
<span class="line-modified">2666                 shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {</span>
<span class="line-modified">2667                     @Override public Void call(ShiftParams param) {</span>
<span class="line-modified">2668 </span>
<span class="line-modified">2669                         // we make the shifts atomic, as otherwise listeners to</span>
<span class="line-modified">2670                         // the items / indices lists get a lot of intermediate</span>
<span class="line-modified">2671                         // noise. They eventually get the summary event fired</span>
<span class="line-modified">2672                         // from within shiftSelection, so this is ok.</span>
<span class="line-modified">2673                         startAtomic();</span>
<span class="line-modified">2674 </span>
<span class="line-modified">2675                         final int clearIndex = param.getClearIndex();</span>
<span class="line-modified">2676                         final int setIndex = param.getSetIndex();</span>
<span class="line-modified">2677                         TreeTablePosition&lt;S,?&gt; oldTP = null;</span>
<span class="line-modified">2678                         if (clearIndex &gt; -1) {</span>
<span class="line-modified">2679                             for (int i = 0; i &lt; selectedCellsMap.size(); i++) {</span>
<span class="line-modified">2680                                 TreeTablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);</span>
<span class="line-modified">2681                                 if (tp.getRow() == clearIndex) {</span>
<span class="line-modified">2682                                     oldTP = tp;</span>
<span class="line-modified">2683                                     selectedCellsMap.remove(tp);</span>
<span class="line-modified">2684                                 } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {</span>
<span class="line-modified">2685                                     selectedCellsMap.remove(tp);</span>


2686                                 }
2687                             }
<span class="line-removed">2688                         }</span>
2689 
<span class="line-modified">2690                         if (oldTP != null &amp;&amp; param.isSelected()) {</span>
<span class="line-modified">2691                             TreeTablePosition&lt;S,?&gt; newTP = new TreeTablePosition&lt;&gt;(</span>
<span class="line-modified">2692                                     treeTableView, param.getSetIndex(), oldTP.getTableColumn());</span>
2693 
<span class="line-modified">2694                             selectedCellsMap.add(newTP);</span>
<span class="line-modified">2695                         }</span>
2696 
<span class="line-modified">2697                         stopAtomic();</span>
2698 
<span class="line-modified">2699                         return null;</span>
<span class="line-modified">2700                     }</span>
<span class="line-modified">2701                 });</span>

2702             }
2703         };
2704 
2705         private WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
2706                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
2707 
2708         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
2709 
2710 
2711 
2712         /***********************************************************************
2713          *                                                                     *
2714          * Observable properties (and getters/setters)                         *
2715          *                                                                     *
2716          **********************************************************************/
2717 
2718         // the only &#39;proper&#39; internal data structure, selectedItems and selectedIndices
2719         // are both &#39;read-only and unbacked&#39;.
2720         private final SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsMap;
2721 
</pre>
</td>
<td>
<hr />
<pre>
  39 import javafx.css.PseudoClass;
  40 
  41 import javafx.css.converter.SizeConverter;
  42 import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
  43 import com.sun.javafx.scene.control.TableColumnComparatorBase;
  44 
  45 import javafx.css.Styleable;
  46 import javafx.css.StyleableDoubleProperty;
  47 import javafx.css.StyleableProperty;
  48 import javafx.event.WeakEventHandler;
  49 
  50 import javafx.scene.control.skin.TreeTableViewSkin;
  51 
  52 import java.lang.ref.SoftReference;
  53 import java.lang.ref.WeakReference;
  54 import java.util.ArrayList;
  55 import java.util.Collection;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashMap;
<span class="line-added">  59 import java.util.HashSet;</span>
  60 import java.util.LinkedHashSet;
  61 import java.util.List;
  62 import java.util.Map;
  63 import java.util.Set;
  64 import java.util.WeakHashMap;
  65 
  66 import javafx.application.Platform;
  67 import javafx.beans.DefaultProperty;
  68 import javafx.beans.InvalidationListener;
  69 import javafx.beans.WeakInvalidationListener;
  70 import javafx.beans.property.BooleanProperty;
  71 import javafx.beans.property.ObjectProperty;
  72 import javafx.beans.property.ObjectPropertyBase;
  73 import javafx.beans.property.ReadOnlyIntegerProperty;
  74 import javafx.beans.property.ReadOnlyIntegerWrapper;
  75 import javafx.beans.property.ReadOnlyObjectProperty;
  76 import javafx.beans.property.ReadOnlyObjectWrapper;
  77 import javafx.beans.property.SimpleBooleanProperty;
  78 import javafx.beans.property.SimpleObjectProperty;
  79 import javafx.beans.value.ChangeListener;
</pre>
<hr />
<pre>
1788      * @param column the column
1789      * @return the position of the given column, relative to all other
1790      * visible leaf columns
1791      */
1792     public int getVisibleLeafIndex(TreeTableColumn&lt;S,?&gt; column) {
1793         return getVisibleLeafColumns().indexOf(column);
1794     }
1795 
1796     /**
1797      * Returns the TreeTableColumn in the given column index, relative to all other
1798      * visible leaf columns.
1799      * @param column the column
1800      * @return the TreeTableColumn in the given column index, relative to all other
1801      * visible leaf columns
1802      */
1803     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1804         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1805         return visibleLeafColumns.get(column);
1806     }
1807 
<span class="line-added">1808     private boolean sortingInProgress;</span>
<span class="line-added">1809     boolean isSortingInProgress() {</span>
<span class="line-added">1810         return sortingInProgress;</span>
<span class="line-added">1811     }</span>
<span class="line-added">1812 </span>
<span class="line-added">1813     private boolean sortTreeOfSelectedItems = true;</span>
<span class="line-added">1814     boolean isSortTreeOfSelectedItems() {</span>
<span class="line-added">1815         return sortTreeOfSelectedItems;</span>
<span class="line-added">1816     }</span>
<span class="line-added">1817 </span>
1818     /**
1819      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1820      * often than not it is not necessary to call this method directly, as it is
1821      * automatically called when the {@link #getSortOrder() sort order},
1822      * {@link #sortPolicyProperty() sort policy}, or the state of the
1823      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1824      * change. In other words, this method should only be called directly when
1825      * something external changes and a sort is required.
1826      */
1827     public void sort() {
<span class="line-added">1828         sortingInProgress = true;</span>
1829         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1830 
1831         // update the Comparator property
1832         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1833         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1834 
1835         // fire the onSort event and check if it is consumed, if
1836         // so, don&#39;t run the sort
1837         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
1838         fireEvent(sortEvent);
1839         if (sortEvent.isConsumed()) {
1840             // if the sort is consumed we could back out the last action (the code
1841             // is commented out right below), but we don&#39;t as we take it as a
1842             // sign that the developer has decided to handle the event themselves.
1843 
1844             // sortLock = true;
1845             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1846             // sortLock = false;
<span class="line-added">1847             sortingInProgress = false;</span>
1848             return;
1849         }
1850 
1851         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1852         final int itemCount = prevState.size();
1853 
1854         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1855         // sort events - instead we send a single permutation event at the end
1856         // of this method.
1857         getSelectionModel().startAtomic();
1858 
1859         // get the sort policy and run it
1860         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
1861         if (sortPolicy == null) return;
1862         Boolean success = sortPolicy.call(this);
1863 
<span class="line-added">1864         if (getSortMode() == TreeSortMode.ALL_DESCENDANTS &amp;&amp; isSortTreeOfSelectedItems()) {</span>
<span class="line-added">1865             Set&lt;TreeItem&lt;S&gt;&gt; sortedParents = new HashSet&lt;&gt;();</span>
<span class="line-added">1866             for (TreeTablePosition&lt;S,?&gt; selectedPosition : prevState) {</span>
<span class="line-added">1867                 TreeItem&lt;S&gt; parent = selectedPosition.getTreeItem().getParent();</span>
<span class="line-added">1868                 while (parent != null &amp;&amp; sortedParents.add(parent)) {</span>
<span class="line-added">1869                     parent.getChildren();</span>
<span class="line-added">1870                     parent = parent.getParent();</span>
<span class="line-added">1871                 }</span>
<span class="line-added">1872             }</span>
<span class="line-added">1873         }</span>
1874         getSelectionModel().stopAtomic();
1875 
1876         if (success == null || ! success) {
1877             // the sort was a failure. Need to backout if possible
1878             sortLock = true;
1879             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1880             setComparator(oldComparator);
1881             sortLock = false;
1882         } else {
1883             // sorting was a success, now we possibly fire an event on the
1884             // selection model that the items list has &#39;permutated&#39; to a new ordering
1885 
1886             // FIXME we should support alternative selection model implementations!
1887             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1888                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1889                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1890 
1891                 List&lt;TreeTablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
1892                 for (int i = 0; i &lt; itemCount; i++) {
1893                     TreeTablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
1894                     if (!newState.contains(prevItem)) {
1895                         removed.add(prevItem);
1896                     }
1897                 }

1898                 if (!removed.isEmpty()) {
1899                     // the sort operation effectively permutates the selectedCells list,
1900                     // but we cannot fire a permutation event as we are talking about
1901                     // TreeTablePosition&#39;s changing (which may reside in the same list
1902                     // position before and after the sort). Therefore, we need to fire
1903                     // a single add/remove event to cover the added and removed positions.
1904                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
1905                     sm.fireCustomSelectedCellsListChangeEvent(c);
1906                 }
1907             }
<span class="line-added">1908             getSelectionModel().setSelectedIndex(getRow(getSelectionModel().getSelectedItem()));</span>
<span class="line-added">1909             getFocusModel().focus(getSelectionModel().getSelectedIndex());</span>
1910         }
<span class="line-added">1911         sortingInProgress = false;</span>
1912     }
1913 
1914     /**
1915      * Calling {@code refresh()} forces the TreeTableView control to recreate and
1916      * repopulate the cells necessary to populate the visual bounds of the control.
1917      * In other words, this forces the TreeTableView to update what it is showing to
1918      * the user. This is useful in cases where the underlying data source has
1919      * changed in a way that is not observed by the TreeTableView itself.
1920      *
1921      * @since JavaFX 8u60
1922      */
1923     public void refresh() {
1924         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1925     }
1926 
1927 
1928 
1929     /***************************************************************************
1930      *                                                                         *
1931      * Private Implementation                                                  *
</pre>
<hr />
<pre>
2548 
2549                         ControlUtils.reducingChange(selectedIndices, removed);
2550 
2551                         for (int index : removed) {
2552                             startAtomic();
2553                             // we pass in false here to prevent a lookup into the TreeItem, as it is unnecessary
2554                             // and results in JDK-8152396
2555                             clearSelection(new TreeTablePosition&lt;&gt;(treeTableView, index, null, false));
2556                             stopAtomic();
2557                         }
2558                         selectedIndices._endChange();
2559 
2560                         // put selection onto the newly-collapsed tree item
2561                         if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
2562                             select(startRow, selectedColumn);
2563                         }
2564 
2565                         shift += -count + 1;
2566                         startRow++;
2567                     } else if (e.wasPermutated()) {
<span class="line-modified">2568                         // Approach:</span>
<span class="line-modified">2569                         // Get the current selection.</span>
<span class="line-modified">2570                         // Create a new selection with updated index(row).</span>
<span class="line-modified">2571                         // Update the current selection with new selection.</span>
<span class="line-modified">2572                         // If sorting is in progress then one Selection change event will be sent from</span>
<span class="line-modified">2573                         // TreeTableView.sort() method, and should not be sent from here.</span>
<span class="line-modified">2574                         // else, in case otherwise, the selection change events would be generated.</span>
<span class="line-modified">2575                         // Do not call shiftSelection() in case of permutation change(when shift == 0).</span>
<span class="line-modified">2576 </span>
<span class="line-modified">2577                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; currentSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());</span>
<span class="line-modified">2578                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; updatedSelection = new ArrayList&lt;&gt;();</span>









2579 







2580                         boolean selectionIndicesChanged = false;
<span class="line-modified">2581                         for (TreeTablePosition&lt;S, ?&gt; selectedCell : currentSelection) {</span>
<span class="line-modified">2582                             int newRow = treeTableView.getRow(selectedCell.getTreeItem());</span>
<span class="line-modified">2583                             if (selectedCell.getRow() != newRow) {</span>
<span class="line-modified">2584                                 selectionIndicesChanged = true;</span>











2585                             }
<span class="line-added">2586                             updatedSelection.add(new TreeTablePosition&lt;&gt;(selectedCell, newRow));</span>
2587                         }

2588                         if (selectionIndicesChanged) {
<span class="line-modified">2589                             if (treeTableView.isSortingInProgress()) {</span>
<span class="line-modified">2590                                 startAtomic();</span>
<span class="line-modified">2591                                 selectedCellsMap.setAll(updatedSelection);</span>
<span class="line-modified">2592                                 stopAtomic();</span>
<span class="line-modified">2593                             } else {</span>
<span class="line-modified">2594                                 startAtomic();</span>
<span class="line-modified">2595                                 quietClearSelection();</span>
<span class="line-modified">2596                                 stopAtomic();</span>
<span class="line-modified">2597                                 selectedCellsMap.setAll(updatedSelection);</span>
<span class="line-modified">2598                                 int selectedIndex = treeTableView.getRow(getSelectedItem());</span>
<span class="line-modified">2599                                 setSelectedIndex(selectedIndex);</span>
<span class="line-added">2600                                 focus(selectedIndex);</span>
2601                             }


2602                         }
2603                     } else if (e.wasAdded()) {
2604                         // shuffle selection by the number of added items
2605                         shift += treeItem.isExpanded() ? addedSize : 0;
2606 
2607                         // RT-32963: We were taking the startRow from the TreeItem
2608                         // in which the children were added, rather than from the
2609                         // actual position of the new child. This led to selection
2610                         // being moved off the parent TreeItem by mistake.
2611                         // The &#39;if (e.getAddedSize() == 1)&#39; condition here was
2612                         // subsequently commented out due to RT-33894.
2613                         startRow = treeTableView.getRow(e.getChange().getAddedSubList().get(0));
2614 
2615                         TreeTablePosition&lt;S, ?&gt; anchor = TreeTableCellBehavior.getAnchor(treeTableView, null);
2616                         if (anchor != null) {
2617                             boolean isAnchorSelected = isSelected(anchor.getRow(), anchor.getTableColumn());
2618                             if (isAnchorSelected) {
2619                                 TreeTablePosition&lt;S, ?&gt; newAnchor = new TreeTablePosition&lt;&gt;(treeTableView, anchor.getRow() + shift, anchor.getTableColumn());
2620                                 TreeTableCellBehavior.setAnchor(treeTableView, newAnchor, false);
2621                             }
</pre>
<hr />
<pre>
2643                             int index = selectedIndices.get(i);
2644                             if (index &gt; selectedItems.size()) break;
2645 
2646                             if (removedChildren.size() == 1 &amp;&amp;
2647                                     selectedItems.size() == 1 &amp;&amp;
2648                                     selectedItem != null &amp;&amp;
2649                                     selectedItem.equals(removedChildren.get(0))) {
2650                                 // Bug fix for RT-28637
2651                                 if (oldSelectedIndex &lt; getItemCount()) {
2652                                     final int previousRow = oldSelectedIndex == 0 ? 0 : oldSelectedIndex - 1;
2653                                     TreeItem&lt;S&gt; newSelectedItem = getModelItem(previousRow);
2654                                     if (!selectedItem.equals(newSelectedItem)) {
2655                                         clearAndSelect(previousRow);
2656                                     }
2657                                 }
2658                             }
2659                         }
2660                     }
2661                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
2662 
<span class="line-modified">2663                 if (shift != 0) {</span>
<span class="line-modified">2664                     shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {</span>
<span class="line-modified">2665                         @Override public Void call(ShiftParams param) {</span>
<span class="line-modified">2666 </span>
<span class="line-modified">2667                             // we make the shifts atomic, as otherwise listeners to</span>
<span class="line-modified">2668                             // the items / indices lists get a lot of intermediate</span>
<span class="line-modified">2669                             // noise. They eventually get the summary event fired</span>
<span class="line-modified">2670                             // from within shiftSelection, so this is ok.</span>
<span class="line-modified">2671                             startAtomic();</span>
<span class="line-modified">2672 </span>
<span class="line-modified">2673                             final int clearIndex = param.getClearIndex();</span>
<span class="line-modified">2674                             final int setIndex = param.getSetIndex();</span>
<span class="line-modified">2675                             TreeTablePosition&lt;S,?&gt; oldTP = null;</span>
<span class="line-modified">2676                             if (clearIndex &gt; -1) {</span>
<span class="line-modified">2677                                 for (int i = 0; i &lt; selectedCellsMap.size(); i++) {</span>
<span class="line-modified">2678                                     TreeTablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);</span>
<span class="line-modified">2679                                     if (tp.getRow() == clearIndex) {</span>
<span class="line-modified">2680                                         oldTP = tp;</span>
<span class="line-modified">2681                                         selectedCellsMap.remove(tp);</span>
<span class="line-modified">2682                                     } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {</span>
<span class="line-added">2683                                         selectedCellsMap.remove(tp);</span>
<span class="line-added">2684                                     }</span>
2685                                 }
2686                             }

2687 
<span class="line-modified">2688                             if (oldTP != null &amp;&amp; param.isSelected()) {</span>
<span class="line-modified">2689                                 TreeTablePosition&lt;S,?&gt; newTP = new TreeTablePosition&lt;&gt;(</span>
<span class="line-modified">2690                                         treeTableView, param.getSetIndex(), oldTP.getTableColumn());</span>
2691 
<span class="line-modified">2692                                 selectedCellsMap.add(newTP);</span>
<span class="line-modified">2693                             }</span>
2694 
<span class="line-modified">2695                             stopAtomic();</span>
2696 
<span class="line-modified">2697                             return null;</span>
<span class="line-modified">2698                         }</span>
<span class="line-modified">2699                     });</span>
<span class="line-added">2700                 }</span>
2701             }
2702         };
2703 
2704         private WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
2705                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
2706 
2707         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
2708 
2709 
2710 
2711         /***********************************************************************
2712          *                                                                     *
2713          * Observable properties (and getters/setters)                         *
2714          *                                                                     *
2715          **********************************************************************/
2716 
2717         // the only &#39;proper&#39; internal data structure, selectedItems and selectedIndices
2718         // are both &#39;read-only and unbacked&#39;.
2719         private final SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsMap;
2720 
</pre>
</td>
</tr>
</table>
<center><a href="TreeTablePosition.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/java/test/javafx/scene/control/TreeTableViewTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
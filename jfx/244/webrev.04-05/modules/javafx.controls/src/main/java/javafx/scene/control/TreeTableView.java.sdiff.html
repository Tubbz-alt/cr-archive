<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TreeTablePosition.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/java/test/javafx/scene/control/TreeTableViewTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1836             // is commented out right below), but we don&#39;t as we take it as a
1837             // sign that the developer has decided to handle the event themselves.
1838 
1839             // sortLock = true;
1840             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1841             // sortLock = false;
1842             sortingInProgress = false;
1843             return;
1844         }
1845 
1846         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1847         final int itemCount = prevState.size();
1848 
1849         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1850         // sort events - instead we send a single permutation event at the end
1851         // of this method.
1852         getSelectionModel().startAtomic();
1853 
1854         // get the sort policy and run it
1855         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
<span class="line-modified">1856         if (sortPolicy == null) return;</span>



1857         Boolean success = sortPolicy.call(this);
1858 
1859         if (getSortMode() == TreeSortMode.ALL_DESCENDANTS) {
1860             Set&lt;TreeItem&lt;S&gt;&gt; sortedParents = new HashSet&lt;&gt;();
1861             for (TreeTablePosition&lt;S,?&gt; selectedPosition : prevState) {
<span class="line-modified">1862                 TreeItem&lt;S&gt; parent = selectedPosition.getTreeItem().getParent();</span>
<span class="line-modified">1863                 while (parent != null &amp;&amp; sortedParents.add(parent)) {</span>
<span class="line-modified">1864                     parent.getChildren();</span>
<span class="line-modified">1865                     parent = parent.getParent();</span>





1866                 }
1867             }
1868         }
1869         getSelectionModel().stopAtomic();
1870 
1871         if (success == null || ! success) {
1872             // the sort was a failure. Need to backout if possible
1873             sortLock = true;
1874             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1875             setComparator(oldComparator);
1876             sortLock = false;
1877         } else {
1878             // sorting was a success, now we possibly fire an event on the
1879             // selection model that the items list has &#39;permutated&#39; to a new ordering
1880 
1881             // FIXME we should support alternative selection model implementations!
1882             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1883                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1884                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1885 
</pre>
</td>
<td>
<hr />
<pre>
1836             // is commented out right below), but we don&#39;t as we take it as a
1837             // sign that the developer has decided to handle the event themselves.
1838 
1839             // sortLock = true;
1840             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1841             // sortLock = false;
1842             sortingInProgress = false;
1843             return;
1844         }
1845 
1846         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1847         final int itemCount = prevState.size();
1848 
1849         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1850         // sort events - instead we send a single permutation event at the end
1851         // of this method.
1852         getSelectionModel().startAtomic();
1853 
1854         // get the sort policy and run it
1855         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
<span class="line-modified">1856         if (sortPolicy == null) {</span>
<span class="line-added">1857             sortingInProgress = false;</span>
<span class="line-added">1858             return;</span>
<span class="line-added">1859         }</span>
1860         Boolean success = sortPolicy.call(this);
1861 
1862         if (getSortMode() == TreeSortMode.ALL_DESCENDANTS) {
1863             Set&lt;TreeItem&lt;S&gt;&gt; sortedParents = new HashSet&lt;&gt;();
1864             for (TreeTablePosition&lt;S,?&gt; selectedPosition : prevState) {
<span class="line-modified">1865                 // This null check is not required ideally.</span>
<span class="line-modified">1866                 // The selectedPosition.getTreeItem() should always return a valid TreeItem.</span>
<span class="line-modified">1867                 // But, it is possible to be null due to JDK-8248217.</span>
<span class="line-modified">1868                 if (selectedPosition.getTreeItem() != null) {</span>
<span class="line-added">1869                     TreeItem&lt;S&gt; parent = selectedPosition.getTreeItem().getParent();</span>
<span class="line-added">1870                     while (parent != null &amp;&amp; sortedParents.add(parent)) {</span>
<span class="line-added">1871                         parent.getChildren();</span>
<span class="line-added">1872                         parent = parent.getParent();</span>
<span class="line-added">1873                     }</span>
1874                 }
1875             }
1876         }
1877         getSelectionModel().stopAtomic();
1878 
1879         if (success == null || ! success) {
1880             // the sort was a failure. Need to backout if possible
1881             sortLock = true;
1882             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1883             setComparator(oldComparator);
1884             sortLock = false;
1885         } else {
1886             // sorting was a success, now we possibly fire an event on the
1887             // selection model that the items list has &#39;permutated&#39; to a new ordering
1888 
1889             // FIXME we should support alternative selection model implementations!
1890             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1891                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1892                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1893 
</pre>
</td>
</tr>
</table>
<center><a href="TreeTablePosition.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/java/test/javafx/scene/control/TreeTableViewTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
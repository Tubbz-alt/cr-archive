<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.controls/src/test/java/test/javafx/scene/control/TreeTableViewTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package test.javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.control.TableColumnBaseHelper;
  29 import static test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils.assertStyleClassContains;
  30 import static javafx.scene.control.TreeTableColumn.SortType.ASCENDING;
  31 import static javafx.scene.control.TreeTableColumn.SortType.DESCENDING;
  32 import static org.junit.Assert.*;
  33 import static org.junit.Assert.assertEquals;
  34 
  35 import java.util.ArrayList;
  36 import java.util.Comparator;
  37 import java.util.List;
  38 import java.util.Objects;
  39 import java.util.concurrent.atomic.AtomicInteger;
  40 import java.util.function.Consumer;
  41 import java.util.function.Supplier;
  42 import java.util.stream.Collectors;
  43 
  44 import com.sun.javafx.scene.control.behavior.TreeTableCellBehavior;
  45 import javafx.beans.property.ReadOnlyIntegerWrapper;
  46 import javafx.collections.transformation.FilteredList;
  47 import javafx.scene.control.TableColumn;
  48 import javafx.scene.control.TableView;
  49 import test.com.sun.javafx.scene.control.infrastructure.KeyEventFirer;
  50 import test.com.sun.javafx.scene.control.infrastructure.KeyModifier;
  51 import test.com.sun.javafx.scene.control.infrastructure.MouseEventFirer;
  52 import javafx.scene.control.skin.TreeTableCellSkin;
  53 import test.com.sun.javafx.scene.control.test.Data;
  54 
  55 import javafx.application.Platform;
  56 import javafx.beans.InvalidationListener;
  57 import javafx.beans.Observable;
  58 import javafx.beans.binding.Bindings;
  59 import javafx.beans.binding.ObjectBinding;
  60 import javafx.beans.property.ObjectProperty;
  61 import javafx.beans.property.ReadOnlyBooleanWrapper;
  62 import javafx.beans.property.ReadOnlyObjectWrapper;
  63 import javafx.beans.property.ReadOnlyStringWrapper;
  64 import javafx.beans.property.SimpleObjectProperty;
  65 import javafx.beans.property.SimpleStringProperty;
  66 import javafx.collections.FXCollections;
  67 import javafx.collections.ListChangeListener;
  68 import javafx.collections.ObservableList;
  69 import javafx.event.EventHandler;
  70 import javafx.scene.Group;
  71 import javafx.scene.Node;
  72 import javafx.scene.Scene;
  73 import javafx.scene.control.TreeTableView.TreeTableViewFocusModel;
  74 import javafx.scene.control.cell.*;
  75 import javafx.scene.image.ImageView;
  76 import javafx.scene.input.KeyCode;
  77 import javafx.scene.layout.StackPane;
  78 import javafx.scene.layout.VBox;
  79 import javafx.scene.paint.Color;
  80 import javafx.scene.shape.Circle;
  81 import javafx.scene.shape.Rectangle;
  82 import javafx.stage.Stage;
  83 import javafx.util.Callback;
  84 
  85 import org.junit.Before;
  86 import org.junit.Ignore;
  87 import org.junit.Test;
  88 
  89 import com.sun.javafx.scene.control.TableColumnComparatorBase.TreeTableColumnComparator;
  90 import test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils;
  91 import test.com.sun.javafx.scene.control.infrastructure.StageLoader;
  92 import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;
  93 import com.sun.javafx.scene.control.VirtualScrollBar;
  94 import test.com.sun.javafx.scene.control.test.Person;
  95 import test.com.sun.javafx.scene.control.test.RT_22463_Person;
  96 import com.sun.javafx.tk.Toolkit;
  97 import javafx.scene.control.Button;
  98 import javafx.scene.control.Cell;
  99 import javafx.scene.control.FocusModel;
 100 import javafx.scene.control.IndexedCell;
 101 import javafx.scene.control.MultipleSelectionModel;
 102 import javafx.scene.control.MultipleSelectionModelBaseShim;
 103 import javafx.scene.control.SelectionMode;
 104 import javafx.scene.control.TableColumnBaseShim;
 105 import javafx.scene.control.TableSelectionModel;
 106 import javafx.scene.control.TextField;
 107 import javafx.scene.control.TreeItem;
 108 import javafx.scene.control.TreeTableCell;
 109 import javafx.scene.control.TreeTableCellShim;
 110 import javafx.scene.control.TreeTableColumn;
 111 import javafx.scene.control.TreeTablePosition;
 112 import javafx.scene.control.TreeTableRow;
 113 import javafx.scene.control.TreeTableRowShim;
 114 import javafx.scene.control.TreeTableView;
 115 import javafx.scene.control.TreeTableViewShim;
 116 import javafx.scene.control.TreeView;
 117 
 118 public class TreeTableViewTest {
 119     private TreeTableView&lt;String&gt; treeTableView;
 120     private TreeTableView.TreeTableViewSelectionModel sm;
 121     private TreeTableViewFocusModel&lt;String&gt; fm;
 122 
 123 
 124     // sample data #1
 125     private TreeItem&lt;String&gt; root;
 126     private TreeItem&lt;String&gt; child1;
 127     private TreeItem&lt;String&gt; child2;
 128     private TreeItem&lt;String&gt; child3;
 129 
 130     // sample data #1
 131     private TreeItem&lt;String&gt; myCompanyRootNode;
 132         private TreeItem&lt;String&gt; salesDepartment;
 133             private TreeItem&lt;String&gt; ethanWilliams;
 134             private TreeItem&lt;String&gt; emmaJones;
 135             private TreeItem&lt;String&gt; michaelBrown;
 136             private TreeItem&lt;String&gt; annaBlack;
 137             private TreeItem&lt;String&gt; rodgerYork;
 138             private TreeItem&lt;String&gt; susanCollins;
 139 
 140         private TreeItem&lt;String&gt; itSupport;
 141             private TreeItem&lt;String&gt; mikeGraham;
 142             private TreeItem&lt;String&gt; judyMayer;
 143             private TreeItem&lt;String&gt; gregorySmith;
 144 
 145     @Before public void setup() {
 146         treeTableView = new TreeTableView&lt;String&gt;();
 147         sm = treeTableView.getSelectionModel();
 148         fm = treeTableView.getFocusModel();
 149 
 150         // build sample data #2, even though it may not be used...
 151         myCompanyRootNode = new TreeItem&lt;String&gt;(&quot;MyCompany Human Resources&quot;);
 152         salesDepartment = new TreeItem&lt;String&gt;(&quot;Sales Department&quot;);
 153             ethanWilliams = new TreeItem&lt;String&gt;(&quot;Ethan Williams&quot;);
 154             emmaJones = new TreeItem&lt;String&gt;(&quot;Emma Jones&quot;);
 155             michaelBrown = new TreeItem&lt;String&gt;(&quot;Michael Brown&quot;);
 156             annaBlack = new TreeItem&lt;String&gt;(&quot;Anna Black&quot;);
 157             rodgerYork = new TreeItem&lt;String&gt;(&quot;Rodger York&quot;);
 158             susanCollins = new TreeItem&lt;String&gt;(&quot;Susan Collins&quot;);
 159 
 160         itSupport = new TreeItem&lt;String&gt;(&quot;IT Support&quot;);
 161             mikeGraham = new TreeItem&lt;String&gt;(&quot;Mike Graham&quot;);
 162             judyMayer = new TreeItem&lt;String&gt;(&quot;Judy Mayer&quot;);
 163             gregorySmith = new TreeItem&lt;String&gt;(&quot;Gregory Smith&quot;);
 164 
 165         myCompanyRootNode.getChildren().setAll(
 166             salesDepartment,
 167             itSupport
 168         );
 169         salesDepartment.getChildren().setAll(
 170             ethanWilliams,
 171             emmaJones,
 172             michaelBrown,
 173             annaBlack,
 174             rodgerYork,
 175             susanCollins
 176         );
 177         itSupport.getChildren().setAll(
 178             mikeGraham,
 179             judyMayer,
 180             gregorySmith
 181         );
 182     }
 183 
 184     private void installChildren() {
 185         root = new TreeItem&lt;String&gt;(&quot;Root&quot;);
 186         child1 = new TreeItem&lt;String&gt;(&quot;Child 1&quot;);
 187         child2 = new TreeItem&lt;String&gt;(&quot;Child 2&quot;);
 188         child3 = new TreeItem&lt;String&gt;(&quot;Child 3&quot;);
 189         root.setExpanded(true);
 190         root.getChildren().setAll(child1, child2, child3);
 191         treeTableView.setRoot(root);
 192     }
 193 
 194     private String debug() {
 195         StringBuilder sb = new StringBuilder(&quot;Selected Cells: [&quot;);
 196 
 197         List&lt;TreeTablePosition&lt;?,?&gt;&gt; cells = sm.getSelectedCells();
 198         for (TreeTablePosition cell : cells) {
 199             sb.append(&quot;(&quot;);
 200             sb.append(cell.getRow());
 201             sb.append(&quot;,&quot;);
 202             sb.append(cell.getColumn());
 203             sb.append(&quot;), &quot;);
 204         }
 205 
 206         sb.append(&quot;] \nFocus: &quot; + fm.getFocusedIndex());
 207 //        sb.append(&quot; \nAnchor: &quot; + getAnchor());
 208         return sb.toString();
 209     }
 210 
 211     @Test public void ensureCorrectInitialState() {
 212         installChildren();
 213         assertEquals(0, treeTableView.getRow(root));
 214         assertEquals(1, treeTableView.getRow(child1));
 215         assertEquals(2, treeTableView.getRow(child2));
 216         assertEquals(3, treeTableView.getRow(child3));
 217     }
 218 
 219 
 220 
 221 
 222 
 223 
 224 
 225 
 226     /***************************************************************************
 227      *
 228      *
 229      * Tests taken from TableViewTest
 230      * (scroll down further for the TreeViewTests)
 231      *
 232      *
 233      **************************************************************************/
 234 
 235     /*********************************************************************
 236      * Tests for the constructors                                        *
 237      ********************************************************************/
 238 
 239     @Test public void noArgConstructorSetsNonNullSelectionModel() {
 240         assertNotNull(sm);
 241     }
 242 
 243     @Test public void noArgConstructor_selectedItemIsNull() {
 244         assertNull(sm.getSelectedItem());
 245     }
 246 
 247     @Test public void noArgConstructor_selectedIndexIsNegativeOne() {
 248         assertEquals(-1, sm.getSelectedIndex());
 249     }
 250 
 251     @Test public void noArgConstructorSetsNonNullSortPolicy() {
 252         assertNotNull(treeTableView.getSortPolicy());
 253     }
 254 
 255     @Test public void noArgConstructorSetsNullComparator() {
 256         assertNull(treeTableView.getComparator());
 257     }
 258 
 259     @Test public void noArgConstructorSetsNullOnSort() {
 260         assertNull(treeTableView.getOnSort());
 261     }
 262 
 263 //    @Test public void singleArgConstructorSetsNonNullSelectionModel() {
 264 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 265 //        assertNotNull(b2.getSelectionModel());
 266 //    }
 267 //
 268 //    @Test public void singleArgConstructorAllowsNullItems() {
 269 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(null);
 270 //        assertNull(b2.getItems());
 271 //    }
 272 //
 273 //    @Test public void singleArgConstructorTakesItems() {
 274 //        ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;Hi&quot;);
 275 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(items);
 276 //        assertSame(items, b2.getItems());
 277 //    }
 278 //
 279 //    @Test public void singleArgConstructor_selectedItemIsNull() {
 280 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 281 //        assertNull(b2.getSelectionModel().getSelectedItem());
 282 //    }
 283 //
 284 //    @Test public void singleArgConstructor_selectedIndexIsNegativeOne() {
 285 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 286 //        assertEquals(-1, b2.getSelectionModel().getSelectedIndex());
 287 //    }
 288 
 289     /*********************************************************************
 290      * Tests for columns                                                 *
 291      ********************************************************************/
 292 
 293     @Test public void testColumns() {
 294         TreeTableColumn col1 = new TreeTableColumn();
 295 
 296         assertNotNull(treeTableView.getColumns());
 297         assertEquals(0, treeTableView.getColumns().size());
 298 
 299         treeTableView.getColumns().add(col1);
 300         assertEquals(1, treeTableView.getColumns().size());
 301 
 302         treeTableView.getColumns().remove(col1);
 303         assertEquals(0, treeTableView.getColumns().size());
 304     }
 305 
 306     @Test public void testVisibleLeafColumns() {
 307         TreeTableColumn col1 = new TreeTableColumn();
 308 
 309         assertNotNull(treeTableView.getColumns());
 310         assertEquals(0, treeTableView.getColumns().size());
 311 
 312         treeTableView.getColumns().add(col1);
 313         assertEquals(1, treeTableView.getVisibleLeafColumns().size());
 314 
 315         treeTableView.getColumns().remove(col1);
 316         assertEquals(0, treeTableView.getVisibleLeafColumns().size());
 317     }
 318 
 319     @Test public void testSortOrderCleanup() {
 320         TreeTableView treeTableView = new TreeTableView();
 321         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 322         first.setCellValueFactory(new PropertyValueFactory(&quot;firstName&quot;));
 323         TreeTableColumn&lt;String,String&gt; second = new TreeTableColumn&lt;String,String&gt;(&quot;second&quot;);
 324         second.setCellValueFactory(new PropertyValueFactory(&quot;lastName&quot;));
 325         treeTableView.getColumns().addAll(first, second);
 326         treeTableView.getSortOrder().setAll(first, second);
 327         treeTableView.getColumns().remove(first);
 328         assertFalse(treeTableView.getSortOrder().contains(first));
 329     }
 330 
 331 
 332     /*********************************************************************
 333      * Tests for new sorting API in JavaFX 8.0                           *
 334      ********************************************************************/
 335 
 336     private TreeItem&lt;String&gt; apple, orange, banana;
 337 
 338     // TODO test for sort policies returning null
 339     // TODO test for changing column sortType out of order
 340 
 341     private static final Callback&lt;TreeTableView&lt;String&gt;, Boolean&gt; NO_SORT_FAILED_SORT_POLICY =
 342             treeTableView1 -&gt; false;
 343 
 344     private static final Callback&lt;TreeTableView&lt;String&gt;, Boolean&gt; SORT_SUCCESS_ASCENDING_SORT_POLICY =
 345             treeTableView1 -&gt; {
 346                 if (treeTableView1.getSortOrder().isEmpty()) return true;
 347                 FXCollections.sort(treeTableView1.getRoot().getChildren(), new Comparator&lt;TreeItem&lt;String&gt;&gt;() {
 348                     @Override public int compare(TreeItem&lt;String&gt; o1, TreeItem&lt;String&gt; o2) {
 349                         return o1.getValue().compareTo(o2.getValue());
 350                     }
 351                 });
 352                 return true;
 353             };
 354 
 355     private TreeTableColumn&lt;String, String&gt; initSortTestStructure() {
 356         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
 357         col.setSortType(ASCENDING);
 358         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
 359         treeTableView.getColumns().add(col);
 360 
 361         TreeItem&lt;String&gt; newRoot = new TreeItem&lt;String&gt;(&quot;root&quot;);
 362         newRoot.setExpanded(true);
 363         newRoot.getChildren().addAll(
 364                 apple  = new TreeItem(&quot;Apple&quot;),
 365                 orange = new TreeItem(&quot;Orange&quot;),
 366                 banana = new TreeItem(&quot;Banana&quot;));
 367 
 368         treeTableView.setRoot(newRoot);
 369 
 370         return col;
 371     }
 372 
 373     private int countSelectedIndexChangeEvent;
 374     private int countSelectedItemChangeEvent;
 375     private int countSelectedIndicesChangeEvent;
 376     private int countSelectedItemsChangeEvent;
 377     private int expectedCountSelectedIndexChangeEvent;
 378     private int expectedCountSelectedItemChangeEvent;
 379     private int expectedCountSelectedIndicesChangeEvent;
 380     private int expectedCountSelectedItemsChangeEvent;
 381     private TreeItem&lt;String&gt; selectedItemBefore;
 382     private List&lt;TreeItem&lt;String&gt;&gt; selectedItemsBefore;
 383     private List&lt;Integer&gt; selectedIndicesBefore;
 384     private List&lt;TreeTablePosition&lt;String,?&gt;&gt; selectedCellsBefore;
 385 
 386     @Test public void testSelectionUpdatesCorrectlyAfterSort() {
 387         TreeTableColumn&lt;String, String&gt; col = setupForPermutationTest();
 388         treeTableView.getSortOrder().add(col);
 389         verifySelectionAfterPermutation();
 390     }
 391 
 392     @Test public void testSelectionUpdatesCorrectlyAfterRootReverseAndSetAll() {
 393         setupForPermutationTest();
 394         TreeItem&lt;String&gt; parentTreeItem = treeTableView.getRoot();
 395         List&lt;TreeItem&lt;String&gt;&gt; childrenReversed = getReverseChildrenOrder(parentTreeItem);
 396         parentTreeItem.getChildren().setAll(childrenReversed);
 397         verifySelectionAfterPermutation();
 398     }
 399 
 400     @Ignore(&quot;JDK-8248217&quot;)
 401     @Test public void testSelectionUpdatesCorrectlyAfterRemovingSelectedItem() {
 402         setupForPermutationTest();
 403         TreeItem&lt;String&gt; parentOfSelectedTreeItem = ((TreeItem&lt;String&gt;)sm.getSelectedItem()).getParent();
 404         expectedCountSelectedItemChangeEvent = 1;
 405         selectedItemBefore = treeTableView.getTreeItem(
 406                 (int)sm.getSelectedIndices().get(sm.getSelectedIndices().size() - 1));
 407         parentOfSelectedTreeItem.getChildren().remove(sm.getSelectedItem());
 408         verifySelectionAfterPermutation();
 409     }
 410 
 411     @Ignore(&quot;JDK-8248217&quot;)
 412     @Test public void testSelectionUpdatesCorrectlyAfterAddingAnItemBeforeSelectedItem() {
 413         setupForPermutationTest();
 414         TreeItem&lt;String&gt; parentOfSelectedTreeItem = ((TreeItem&lt;String&gt;)sm.getSelectedItem()).getParent();
 415         int indexOfSelectedItem = parentOfSelectedTreeItem.getChildren().indexOf(sm.getSelectedItem());
 416         if (indexOfSelectedItem &gt; 0) {
 417             indexOfSelectedItem--;
 418         }
 419         parentOfSelectedTreeItem.getChildren().add(indexOfSelectedItem, new TreeItem(&quot;AddingOne&quot;));
 420         verifySelectionAfterPermutation();
 421     }
 422 
 423     @Test public void testSelectionUpdatesCorrectlyAfterChildReverseAndSetAll() {
 424         setupForPermutationTest();
 425         TreeItem&lt;String&gt; parentTreeItem = ((TreeItem&lt;String&gt;)sm.getSelectedItem()).getParent();
 426         List&lt;TreeItem&lt;String&gt;&gt; childrenReversed = getReverseChildrenOrder(parentTreeItem);
 427         parentTreeItem.getChildren().setAll(childrenReversed);
 428         verifySelectionAfterPermutation();
 429     }
 430 
 431     @Ignore(&quot;JDK-8248217&quot;)
 432     @Test public void testSelectionUpdatesCorrectlyAfterChildReverseRemoveOneAndSetAll() {
 433         setupForPermutationTest();
 434         TreeItem&lt;String&gt; parentTreeItem = ((TreeItem&lt;String&gt;)sm.getSelectedItem()).getParent();
 435         List&lt;TreeItem&lt;String&gt;&gt; childrenReversed = getReverseChildrenOrder(parentTreeItem);
 436         childrenReversed.remove(0);
 437         parentTreeItem.getChildren().setAll(childrenReversed);
 438         verifySelectionAfterPermutation();
 439     }
 440 
 441     @Ignore(&quot;JDK-8248217&quot;)
 442     @Test public void testSelectionUpdatesCorrectlyAfterChildRemoveOneAndSetAll() {
 443         TreeTableColumn&lt;String, String&gt; col = setupForPermutationTest();
 444         TreeItem&lt;String&gt; parentTreeItem = ((TreeItem&lt;String&gt;)sm.getSelectedItem()).getParent();
 445         List&lt;TreeItem&lt;String&gt;&gt; children = new ArrayList&lt;&gt;(parentTreeItem.getChildren());
 446         children.remove(0);
 447         parentTreeItem.getChildren().setAll(children);
 448         verifySelectionAfterPermutation();
 449     }
 450 
 451     @Ignore(&quot;JDK-8248217&quot;)
 452     @Test public void testSelectionUpdatesCorrectlyAfterChildRemoveOneAndSetAllAndSort() {
 453         TreeTableColumn&lt;String, String&gt; col = setupForPermutationTest();
 454         TreeItem&lt;String&gt; parentTreeItem = ((TreeItem&lt;String&gt;)sm.getSelectedItem()).getParent();
 455         List&lt;TreeItem&lt;String&gt;&gt; children = new ArrayList&lt;&gt;(parentTreeItem.getChildren());
 456         children.remove(0);
 457         parentTreeItem.getChildren().setAll(children);
 458         treeTableView.getSortOrder().add(col);
 459         verifySelectionAfterPermutation();
 460     }
 461 
 462     private List&lt;TreeItem&lt;String&gt;&gt; getReverseChildrenOrder(TreeItem&lt;String&gt; treeItem) {
 463         List&lt;TreeItem&lt;String&gt;&gt; childrenReversed = new ArrayList&lt;&gt;();
 464         int childrenSize = treeItem.getChildren().size();
 465         for (int i = 0; i &lt; childrenSize; i++) {
 466             childrenReversed.add(treeItem.getChildren().get(childrenSize - 1 - i));
 467         }
 468         return childrenReversed;
 469     }
 470 
 471     private TreeTableColumn&lt;String, String&gt; setupForPermutationTest() {
 472         countSelectedIndexChangeEvent = 0;
 473         countSelectedItemChangeEvent = 0;
 474         countSelectedIndicesChangeEvent = 0;
 475         countSelectedItemsChangeEvent = 0;
 476         expectedCountSelectedIndexChangeEvent = 1;
 477         expectedCountSelectedItemChangeEvent = 0;
 478         expectedCountSelectedIndicesChangeEvent = 1;
 479         expectedCountSelectedItemsChangeEvent = 1;
 480 
 481         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
 482         col.setSortType(DESCENDING);
 483         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
 484         treeTableView.getColumns().add(col);
 485 
 486         TreeItem&lt;String&gt; treeRoot = new TreeItem&lt;String&gt;(&quot;root&quot;);
 487         treeRoot.setExpanded(true);
 488         treeTableView.setRoot(treeRoot);
 489 
 490         final int FIRST_LEVEL_COUNT = 8;
 491         for (int i = 0; i &lt; FIRST_LEVEL_COUNT; i++) {
 492             TreeItem&lt;String&gt; ti = new TreeItem&lt;&gt;( &quot;&quot; + i);
 493             ti.setExpanded(true);
 494             treeRoot.getChildren().add(ti);
 495 
 496             for (int j = 0; j &lt; FIRST_LEVEL_COUNT - 1; j++) {
 497                 TreeItem&lt;String&gt; tj = new TreeItem&lt;&gt;(&quot;&quot; + i + j);
 498                 tj.setExpanded(true);
 499                 ti.getChildren().add(tj);
 500 
 501                 for (int k = 0; k &lt; FIRST_LEVEL_COUNT - 2; k++) {
 502                     TreeItem&lt;String&gt; tk = new TreeItem&lt;&gt;(&quot;&quot; + i + j + k);
 503                     tk.setExpanded(true);
 504                     tj.getChildren().add(tk);
 505 
 506                     for (int l = 0; l &lt; FIRST_LEVEL_COUNT - 3; l++) {
 507                         TreeItem&lt;String&gt; tl = new TreeItem&lt;&gt;(&quot;&quot; + i + j + k + l);
 508                         tl.setExpanded(true);
 509                         tk.getChildren().add(tl);
 510 
 511                         for (int m = 0; m &lt; FIRST_LEVEL_COUNT - 4; m++) {
 512                             TreeItem&lt;String&gt; tm = new TreeItem&lt;&gt;(&quot;&quot; + i + j + k + l + m);
 513                             tl.getChildren().add(tm);
 514                         }
 515                     }
 516                 }
 517             }
 518         }
 519 
 520         sm.setSelectionMode(SelectionMode.MULTIPLE);
 521         int indices[] = new int[] {1, 400, 800, 1200, 1600, 2000, 2400, 2800, 3200, 3600, 4000, 4400, 4800, 5200, 5600, 6000, 6400};
 522         sm.selectIndices(1, 400, 800, 1200, 1600, 2000, 2400, 2800, 3200, 3600, 4000, 4400, 4800, 5200, 5600, 6000, 6400);
 523 
 524         // Sanity checks
 525         assertEquals(indices.length, sm.getSelectedIndices().size());
 526         assertEquals(indices.length, sm.getSelectedItems().size());
 527         assertEquals(indices.length, sm.getSelectedCells().size());
 528         assertEquals(indices[indices.length - 1], sm.getSelectedIndex());
 529         assertEquals(treeTableView.getTreeItem(indices[indices.length - 1]), sm.getSelectedItem());
 530 
 531         selectedItemBefore = (TreeItem&lt;String&gt;) sm.getSelectedItem();
 532         selectedItemsBefore = new ArrayList&lt;&gt;(sm.getSelectedItems());
 533         selectedIndicesBefore = new ArrayList&lt;&gt;(sm.getSelectedIndices());
 534         selectedCellsBefore = new ArrayList&lt;&gt;(sm.getSelectedCells());
 535 
 536         sm.selectedIndexProperty().addListener(ov -&gt; {
 537             countSelectedIndexChangeEvent++;
 538             assertEquals(selectedItemBefore, treeTableView.getTreeItem(sm.getSelectedIndex()));
 539         });
 540         sm.selectedItemProperty().addListener(l -&gt; {
 541             countSelectedItemChangeEvent++;
 542         });
 543         sm.getSelectedIndices().addListener((ListChangeListener) c -&gt; {
 544             countSelectedIndicesChangeEvent++;
 545             c.next();
 546             if (c.wasRemoved()) {
 547                 assertTrue(selectedIndicesBefore.equals(c.getRemoved()));
 548             }
 549             verifySelectedIndices(c.getAddedSubList());
 550             verifySelectedIndices(c.getList());
 551         });
 552         sm.getSelectedItems().addListener((ListChangeListener) c -&gt; {
 553             countSelectedItemsChangeEvent++;
 554             c.next();
 555             if (c.wasRemoved()) {
 556                 verifySelectedItems(c.getRemoved());
 557             }
 558             verifySelectedItems(c.getAddedSubList());
 559             verifySelectedItems(c.getList());
 560         });
 561 
 562         return col;
 563     }
 564 
 565     private void verifySelectedCells(List&lt;TreeTablePosition&lt;String, ?&gt;&gt; selectedCells) {
 566         assertEquals(selectedCellsBefore.size(), selectedCells.size());
 567         for (TreeTablePosition beforePos : selectedCellsBefore) {
 568             boolean isCellStillSelected = false;
 569             for (TreeTablePosition afterPos : selectedCells) {
 570                 if ((beforePos.getTreeItem() == afterPos.getTreeItem()) &amp;&amp;
 571                         (beforePos.getTableColumn() == afterPos.getTableColumn()) &amp;&amp;
 572                         (beforePos.getColumn() == afterPos.getColumn())) {
 573                     isCellStillSelected = true;
 574                 }
 575             }
 576             assertTrue(&quot;The item (&quot; + beforePos.getRow() + &quot;, &quot; + beforePos.getColumn() +
 577                     &quot;) lost selection during permutation&quot;, isCellStillSelected);
 578         }
 579     }
 580 
 581     private void verifySelectedItems(List&lt;TreeItem&lt;String&gt;&gt; selectedItems) {
 582         assertEquals(selectedItemsBefore.size(), selectedItems.size());
 583         for (TreeItem&lt;String&gt; item : selectedItemsBefore) {
 584             assertTrue(&quot;The item (&quot; + item + &quot;) lost selection during permutation&quot;,
 585                     selectedItems.contains(item));
 586         }
 587     }
 588 
 589     private void verifySelectedIndices(List&lt;Integer&gt; currentIndices) {
 590         assertEquals(selectedIndicesBefore.size(), currentIndices.size());
 591         for (Integer row : currentIndices) {
 592             assertTrue(selectedItemsBefore.contains(treeTableView.getTreeItem(row)));
 593         }
 594     }
 595 
 596     private void verifySelectionAfterPermutation() {
 597         assertEquals(expectedCountSelectedIndexChangeEvent, countSelectedIndexChangeEvent);
 598         assertEquals(expectedCountSelectedItemChangeEvent, countSelectedItemChangeEvent);
 599         assertEquals(expectedCountSelectedIndicesChangeEvent, countSelectedIndicesChangeEvent);
 600         assertEquals(expectedCountSelectedItemsChangeEvent, countSelectedItemsChangeEvent);
 601 
 602         assertEquals(&quot;Selected Item should remain same&quot;, selectedItemBefore, sm.getSelectedItem());
 603         assertEquals(&quot;Selected index should be updated&quot;, treeTableView.getRow(selectedItemBefore), sm.getSelectedIndex());
 604 
 605         verifySelectedCells(sm.getSelectedCells());
 606         verifySelectedItems(sm.getSelectedItems());
 607         verifySelectedIndices(sm.getSelectedIndices());
 608     }
 609 
 610     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 611     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeSortOrderList() {
 612         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 613         treeTableView.setOnSort(event -&gt; {
 614             event.consume();
 615         });
 616 
 617         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 618         treeTableView.getSortOrder().add(col);
 619         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 620 
 621         // the sort order list should be returned back to its original state
 622         assertTrue(treeTableView.getSortOrder().isEmpty());
 623     }
 624 
 625     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeSortOrderList() {
 626         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 627         treeTableView.setOnSort(event -&gt; {
 628             // do not consume here - this allows the sort to happen
 629         });
 630 
 631         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 632         treeTableView.getSortOrder().add(col);
 633         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 634 
 635         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 636     }
 637 
 638     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 639     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_AscendingToDescending() {
 640         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 641         assertEquals(ASCENDING, col.getSortType());
 642         treeTableView.getSortOrder().add(col);
 643         treeTableView.setOnSort(event -&gt; {
 644             event.consume();
 645         });
 646 
 647         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 648 
 649         // when we change from ASCENDING to DESCENDING we don&#39;t expect the sort
 650         // to actually change (and in fact we expect the sort type to resort
 651         // back to being ASCENDING)
 652         col.setSortType(DESCENDING);
 653         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 654         assertEquals(ASCENDING, col.getSortType());
 655 
 656         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 657     }
 658 
 659     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_AscendingToDescending() {
 660         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 661         assertEquals(ASCENDING, col.getSortType());
 662         treeTableView.getSortOrder().add(col);
 663         treeTableView.setOnSort(event -&gt; {
 664             // do not consume here - this allows the sort to happen
 665         });
 666 
 667         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 668 
 669         col.setSortType(DESCENDING);
 670         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 671         assertEquals(DESCENDING, col.getSortType());
 672 
 673         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 674     }
 675 
 676     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 677     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_DescendingToNull() {
 678         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 679         col.setSortType(DESCENDING);
 680         assertEquals(DESCENDING, col.getSortType());
 681         treeTableView.getSortOrder().add(col);
 682         treeTableView.setOnSort(event -&gt; {
 683             event.consume();
 684         });
 685 
 686         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 687 
 688         col.setSortType(null);
 689         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 690         assertEquals(DESCENDING, col.getSortType());
 691 
 692         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 693     }
 694 
 695     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_DescendingToNull() {
 696         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 697         col.setSortType(DESCENDING);
 698         assertEquals(DESCENDING, col.getSortType());
 699         treeTableView.getSortOrder().add(col);
 700         treeTableView.setOnSort(event -&gt; {
 701             // do not consume here - this allows the sort to happen
 702         });
 703 
 704         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 705 
 706         col.setSortType(null);
 707         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 708         assertNull(col.getSortType());
 709 
 710         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 711     }
 712 
 713     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 714     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_NullToAscending() {
 715         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 716         col.setSortType(null);
 717         assertNull(col.getSortType());
 718         treeTableView.getSortOrder().add(col);
 719         treeTableView.setOnSort(event -&gt; {
 720             event.consume();
 721         });
 722 
 723         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 724 
 725         col.setSortType(ASCENDING);
 726         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 727         assertNull(col.getSortType());
 728 
 729         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 730     }
 731 
 732     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_NullToAscending() {
 733         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 734         col.setSortType(null);
 735         assertNull(col.getSortType());
 736         treeTableView.getSortOrder().add(col);
 737         treeTableView.setOnSort(event -&gt; {
 738             // do not consume here - this allows the sort to happen
 739         });
 740 
 741         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 742 
 743         col.setSortType(ASCENDING);
 744         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 745         assertEquals(ASCENDING, col.getSortType());
 746 
 747         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 748     }
 749 
 750     @Test public void testSortMethodWithNullSortPolicy() {
 751         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 752         treeTableView.setSortPolicy(null);
 753         assertNull(treeTableView.getSortPolicy());
 754         treeTableView.sort();
 755     }
 756 
 757     @Test public void testChangingSortPolicyUpdatesItemsList() {
 758         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 759         col.setSortType(DESCENDING);
 760         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 761         treeTableView.getSortOrder().add(col);
 762         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 763         treeTableView.setSortPolicy(SORT_SUCCESS_ASCENDING_SORT_POLICY);
 764         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 765     }
 766 
 767     @Test public void testChangingSortPolicyDoesNotUpdateItemsListWhenTheSortOrderListIsEmpty() {
 768         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 769         col.setSortType(DESCENDING);
 770         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 771 
 772         treeTableView.setSortPolicy(SORT_SUCCESS_ASCENDING_SORT_POLICY);
 773         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 774     }
 775 
 776     @Test public void testFailedSortPolicyBacksOutLastChange_sortOrderAddition() {
 777         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 778         col.setSortType(DESCENDING);
 779         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 780         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 781 
 782         treeTableView.getSortOrder().add(col);
 783 
 784         // no sort should be run (as we have a custom sort policy), and the
 785         // sortOrder list should be empty as the sortPolicy failed
 786         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 787         assertTrue(treeTableView.getSortOrder().isEmpty());
 788     }
 789 
 790     @Test public void testFailedSortPolicyBacksOutLastChange_sortOrderRemoval() {
 791         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 792         col.setSortType(DESCENDING);
 793         treeTableView.getSortOrder().add(col);
 794         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 795 
 796         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 797 
 798         // even though we remove the column from the sort order here, because the
 799         // sort policy fails the items list should remain unchanged and the sort
 800         // order list should continue to have the column in it.
 801         treeTableView.getSortOrder().remove(col);
 802         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 803         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 804     }
 805 
 806     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_ascendingToDescending() {
 807         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 808         col.setSortType(ASCENDING);
 809         treeTableView.getSortOrder().add(col);
 810         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 811 
 812         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 813 
 814         col.setSortType(DESCENDING);
 815         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 816         assertEquals(ASCENDING, col.getSortType());
 817     }
 818 
 819     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_descendingToNull() {
 820         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 821         col.setSortType(DESCENDING);
 822         treeTableView.getSortOrder().add(col);
 823         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 824 
 825         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 826 
 827         col.setSortType(null);
 828         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 829         assertEquals(DESCENDING, col.getSortType());
 830     }
 831 
 832     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_nullToAscending() {
 833         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 834         col.setSortType(null);
 835         treeTableView.getSortOrder().add(col);
 836         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 837 
 838         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 839 
 840         col.setSortType(ASCENDING);
 841         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 842         assertNull(col.getSortType());
 843     }
 844 
 845     @Test public void testComparatorChangesInSyncWithSortOrder_1() {
 846         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 847         assertNull(treeTableView.getComparator());
 848         assertTrue(treeTableView.getSortOrder().isEmpty());
 849 
 850         treeTableView.getSortOrder().add(col);
 851         TreeTableColumnComparator c = (TreeTableColumnComparator)treeTableView.getComparator();
 852         assertNotNull(c);
 853         VirtualFlowTestUtils.assertListContainsItemsInOrder(c.getColumns(), col);
 854     }
 855 
 856     @Test public void testComparatorChangesInSyncWithSortOrder_2() {
 857         // same as test above
 858         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 859         assertNull(treeTableView.getComparator());
 860         assertTrue(treeTableView.getSortOrder().isEmpty());
 861 
 862         treeTableView.getSortOrder().add(col);
 863         TreeTableColumnComparator c = (TreeTableColumnComparator)treeTableView.getComparator();
 864         assertNotNull(c);
 865         VirtualFlowTestUtils.assertListContainsItemsInOrder(c.getColumns(), col);
 866 
 867         // now remove column from sort order, and the comparator should go to
 868         // being null
 869         treeTableView.getSortOrder().remove(col);
 870         assertNull(treeTableView.getComparator());
 871     }
 872 
 873     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortOrderAddition() {
 874         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 875         final TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 876 
 877         col.setSortType(DESCENDING);
 878         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 879         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 880 
 881         treeTableView.getSortOrder().add(col);
 882 
 883         assertEquals(oldComparator, treeTableView.getComparator());
 884     }
 885 
 886     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortOrderRemoval() {
 887         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 888         TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 889         assertNull(oldComparator);
 890 
 891         col.setSortType(DESCENDING);
 892         treeTableView.getSortOrder().add(col);
 893         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 894         oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 895         VirtualFlowTestUtils.assertListContainsItemsInOrder(oldComparator.getColumns(), col);
 896 
 897         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 898         treeTableView.getSortOrder().remove(col);
 899 
 900         assertTrue(treeTableView.getSortOrder().contains(col));
 901         VirtualFlowTestUtils.assertListContainsItemsInOrder(oldComparator.getColumns(), col);
 902     }
 903 
 904     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortTypeChange() {
 905         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 906         final TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 907         assertNull(oldComparator);
 908 
 909         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 910         treeTableView.getSortOrder().add(col);
 911         col.setSortType(ASCENDING);
 912 
 913         assertTrue(treeTableView.getSortOrder().isEmpty());
 914         assertNull(oldComparator);
 915     }
 916 
 917 
 918 
 919     /*********************************************************************
 920      * Tests for specific bugs                                           *
 921      ********************************************************************/
 922 //    @Test public void test_rt16019() {
 923 //        // RT-16019: NodeMemory TableView tests fail with
 924 //        // IndexOutOfBoundsException (ObservableListWrapper.java:336)
 925 //        TreeTableView treeTableView = new TreeTableView();
 926 //        for (int i = 0; i &lt; 1000; i++) {
 927 //            treeTableView.getItems().add(&quot;data &quot; + i);
 928 //        }
 929 //    }
 930 //
 931 //    @Test public void test_rt15793() {
 932 //        // ListView/TableView selectedIndex is 0 although the items list is empty
 933 //        final TreeTableView tv = new TreeTableView();
 934 //        final ObservableList list = FXCollections.observableArrayList();
 935 //        tv.setItems(list);
 936 //        list.add(&quot;toto&quot;);
 937 //        tv.getSelectionModel().select(0);
 938 //        assertEquals(0, tv.getSelectionModel().getSelectedIndex());
 939 //        list.remove(0);
 940 //        assertEquals(-1, tv.getSelectionModel().getSelectedIndex());
 941 //    }
 942 //
 943 //    @Test public void test_rt17522_focusShouldMoveWhenItemAddedAtFocusIndex() {
 944 //        final TreeTableView lv = new TreeTableView();
 945 //        FocusModel fm = lv.getFocusModel();
 946 //        lv.getItems().add(&quot;row1&quot;);
 947 //        fm.focus(0);
 948 //        assertTrue(fm.isFocused(0));
 949 //
 950 //        lv.getItems().add(0, &quot;row0&quot;);
 951 //        assertTrue(fm.isFocused(1));
 952 //    }
 953 //
 954 //    @Test public void test_rt17522_focusShouldMoveWhenItemAddedBeforeFocusIndex() {
 955 //        final TreeTableView lv = new TreeTableView();
 956 //        FocusModel fm = lv.getFocusModel();
 957 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 958 //        fm.focus(1);
 959 //        assertTrue(fm.isFocused(1));
 960 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 961 //
 962 //        lv.getItems().add(1, &quot;row0&quot;);
 963 //        assertTrue(fm.isFocused(2));
 964 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 965 //        assertFalse(fm.isFocused(1));
 966 //    }
 967 //
 968 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemAddedAfterFocusIndex() {
 969 //        final TreeTableView lv = new TreeTableView();
 970 //        FocusModel fm = lv.getFocusModel();
 971 //        lv.getItems().addAll(&quot;row1&quot;);
 972 //        fm.focus(0);
 973 //        assertTrue(fm.isFocused(0));
 974 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 975 //
 976 //        lv.getItems().add(1, &quot;row2&quot;);
 977 //        assertTrue(fm.isFocused(0));
 978 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 979 //        assertFalse(fm.isFocused(1));
 980 //    }
 981 //
 982 //    @Test public void test_rt17522_focusShouldBeResetWhenFocusedItemIsRemoved() {
 983 //        final TreeTableView lv = new TreeTableView();
 984 //        FocusModel fm = lv.getFocusModel();
 985 //        lv.getItems().add(&quot;row1&quot;);
 986 //        fm.focus(0);
 987 //        assertTrue(fm.isFocused(0));
 988 //
 989 //        lv.getItems().remove(&quot;row1&quot;);
 990 //        assertTrue(fm.getFocusedIndex() == -1);
 991 //        assertNull(fm.getFocusedItem());
 992 //    }
 993 //
 994 //    @Test public void test_rt17522_focusShouldMoveWhenItemRemovedBeforeFocusIndex() {
 995 //        final TreeTableView lv = new TreeTableView();
 996 //        FocusModel fm = lv.getFocusModel();
 997 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 998 //        fm.focus(1);
 999 //        assertTrue(fm.isFocused(1));
1000 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
1001 //
1002 //        lv.getItems().remove(&quot;row1&quot;);
1003 //        assertTrue(fm.isFocused(0));
1004 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
1005 //    }
1006 //
1007 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemRemovedAfterFocusIndex() {
1008 //        final TreeTableView lv = new TreeTableView();
1009 //        FocusModel fm = lv.getFocusModel();
1010 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
1011 //        fm.focus(0);
1012 //        assertTrue(fm.isFocused(0));
1013 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
1014 //
1015 //        lv.getItems().remove(&quot;row2&quot;);
1016 //        assertTrue(fm.isFocused(0));
1017 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
1018 //    }
1019 //
1020 //    @Test public void test_rt18385() {
1021 //        treeTableView.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;);
1022 //        sm.select(1);
1023 //        treeTableView.getItems().add(&quot;Another Row&quot;);
1024 //        assertEquals(1, sm.getSelectedIndices().size());
1025 //        assertEquals(1, sm.getSelectedItems().size());
1026 //        assertEquals(1, sm.getSelectedCells().size());
1027 //    }
1028 
1029     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsFalse_columnEditableIsFalse() {
1030         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
1031         first.setEditable(false);
1032         treeTableView.getColumns().add(first);
1033         treeTableView.setEditable(false);
1034         treeTableView.edit(1, first);
1035         assertEquals(null, treeTableView.getEditingCell());
1036     }
1037 
1038     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsFalse_columnEditableIsTrue() {
1039         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
1040         first.setEditable(true);
1041         treeTableView.getColumns().add(first);
1042         treeTableView.setEditable(false);
1043         treeTableView.edit(1, first);
1044         assertEquals(null, treeTableView.getEditingCell());
1045     }
1046 
1047     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsTrue_columnEditableIsFalse() {
1048         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
1049         first.setEditable(false);
1050         treeTableView.getColumns().add(first);
1051         treeTableView.setEditable(true);
1052         treeTableView.edit(1, first);
1053         assertEquals(null, treeTableView.getEditingCell());
1054     }
1055 
1056     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsTrue_columnEditableIsTrue() {
1057         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
1058         first.setEditable(true);
1059         treeTableView.getColumns().add(first);
1060         treeTableView.setEditable(true);
1061         treeTableView.edit(1, first);
1062         assertEquals(new TreeTablePosition(treeTableView, 1, first), treeTableView.getEditingCell());
1063     }
1064 
1065 //    @Test public void test_rt14451() {
1066 //        treeTableView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
1067 //        sm.setSelectionMode(SelectionMode.MULTIPLE);
1068 //        sm.selectRange(0, 2); // select from 0 (inclusive) to 2 (exclusive)
1069 //        assertEquals(2, sm.getSelectedIndices().size());
1070 //    }
1071 //
1072 //    @Test public void test_rt21586() {
1073 //        treeTableView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
1074 //        treeTableView.getSelectionModel().select(1);
1075 //        assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1076 //        assertEquals(&quot;Orange&quot;, treeTableView.getSelectionModel().getSelectedItem());
1077 //
1078 //        treeTableView.getItems().setAll(&quot;Kiwifruit&quot;, &quot;Pineapple&quot;, &quot;Grape&quot;);
1079 //        assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1080 //        assertNull(treeTableView.getSelectionModel().getSelectedItem());
1081 //    }
1082 
1083 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097     /***************************************************************************
1098      *
1099      *
1100      * Tests taken from TreeViewTest
1101      *
1102      *
1103      **************************************************************************/
1104 
1105 
1106 
1107 
1108     /*********************************************************************
1109      * Tests for the constructors                                        *
1110      ********************************************************************/
1111 
1112     @Test public void noArgConstructorSetsTheStyleClass() {
1113         assertStyleClassContains(treeTableView, &quot;tree-table-view&quot;);
1114     }
1115 
1116     @Test public void noArgConstructorSetsNullItems() {
1117         assertNull(treeTableView.getRoot());
1118     }
1119 
1120     @Test public void singleArgConstructorSetsTheStyleClass() {
1121         final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(new TreeItem&lt;String&gt;(&quot;Hi&quot;));
1122         assertStyleClassContains(b2, &quot;tree-table-view&quot;);
1123     }
1124 
1125     /*********************************************************************
1126      * Tests for selection model                                         *
1127      ********************************************************************/
1128 
1129     @Test public void selectionModelCanBeNull() {
1130         treeTableView.setSelectionModel(null);
1131         assertNull(treeTableView.getSelectionModel());
1132     }
1133 
1134     @Test public void selectionModelCanBeBound() {
1135         TableSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm =
1136                 TreeTableViewShim.&lt;String&gt;get_TreeTableViewArrayListSelectionModel(treeTableView);
1137         ObjectProperty&lt;TreeTableView.TreeTableViewSelectionModel&lt;String&gt;&gt; other =
1138                 new SimpleObjectProperty(sm);
1139         treeTableView.selectionModelProperty().bind(other);
1140         assertSame(sm, treeTableView.getSelectionModel());
1141     }
1142 
1143     @Test public void selectionModelCanBeChanged() {
1144         TableSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm =
1145                 TreeTableViewShim.&lt;String&gt;get_TreeTableViewArrayListSelectionModel(treeTableView);
1146         TreeTableViewShim.&lt;String&gt;setSelectionModel(treeTableView, sm);
1147         assertSame(sm, treeTableView.getSelectionModel());
1148     }
1149 
1150     @Test public void canSetSelectedItemToAnItemEvenWhenThereAreNoItems() {
1151         TreeItem&lt;String&gt; element = new TreeItem&lt;String&gt;(&quot;I AM A CRAZY RANDOM STRING&quot;);
1152         treeTableView.getSelectionModel().select(element);
1153         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1154         assertSame(element, treeTableView.getSelectionModel().getSelectedItem());
1155     }
1156 
1157     @Test public void canSetSelectedItemToAnItemNotInTheDataModel() {
1158         installChildren();
1159         TreeItem&lt;String&gt; element = new TreeItem&lt;String&gt;(&quot;I AM A CRAZY RANDOM STRING&quot;);
1160         treeTableView.getSelectionModel().select(element);
1161         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1162         assertSame(element, treeTableView.getSelectionModel().getSelectedItem());
1163     }
1164 
1165     @Test public void settingTheSelectedItemToAnItemInItemsResultsInTheCorrectSelectedIndex() {
1166         installChildren();
1167         treeTableView.getSelectionModel().select(child1);
1168         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1169         assertSame(child1, treeTableView.getSelectionModel().getSelectedItem());
1170     }
1171 
1172     @Ignore(&quot;Not yet supported&quot;)
1173     @Test public void settingTheSelectedItemToANonexistantItemAndThenSettingItemsWhichContainsItResultsInCorrectSelectedIndex() {
1174         treeTableView.getSelectionModel().select(child1);
1175         installChildren();
1176         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1177         assertSame(child1, treeTableView.getSelectionModel().getSelectedItem());
1178     }
1179 
1180     @Ignore(&quot;Not yet supported&quot;)
1181     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex0() {
1182         installChildren();
1183         treeTableView.getSelectionModel().select(0);
1184         treeTableView.setRoot(null);
1185         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1186         assertEquals(null, treeTableView.getSelectionModel().getSelectedItem());
1187     }
1188 
1189     @Ignore(&quot;Not yet supported&quot;)
1190     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex2() {
1191         installChildren();
1192         treeTableView.getSelectionModel().select(2);
1193         treeTableView.setRoot(null);
1194         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1195         assertEquals(null, treeTableView.getSelectionModel().getSelectedItem());
1196     }
1197 
1198     @Ignore(&quot;Not yet supported&quot;)
1199     @Test public void ensureSelectedItemRemainsAccurateWhenItemsAreCleared() {
1200         installChildren();
1201         treeTableView.getSelectionModel().select(2);
1202         treeTableView.setRoot(null);
1203         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1204         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1205 
1206         TreeItem&lt;String&gt; newRoot = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1207         TreeItem&lt;String&gt; newChild1 = new TreeItem&lt;String&gt;(&quot;New Child 1&quot;);
1208         TreeItem&lt;String&gt; newChild2 = new TreeItem&lt;String&gt;(&quot;New Child 2&quot;);
1209         TreeItem&lt;String&gt; newChild3 = new TreeItem&lt;String&gt;(&quot;New Child 3&quot;);
1210         newRoot.setExpanded(true);
1211         newRoot.getChildren().setAll(newChild1, newChild2, newChild3);
1212         treeTableView.setRoot(root);
1213 
1214         treeTableView.getSelectionModel().select(2);
1215         assertEquals(newChild2, treeTableView.getSelectionModel().getSelectedItem());
1216     }
1217 
1218     @Test public void ensureSelectionIsCorrectWhenItemsChange() {
1219         installChildren();
1220         treeTableView.getSelectionModel().select(0);
1221         assertEquals(root, treeTableView.getSelectionModel().getSelectedItem());
1222 
1223         TreeItem newRoot = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1224         treeTableView.setRoot(newRoot);
1225         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1226         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1227         assertEquals(0, treeTableView.getFocusModel().getFocusedIndex());
1228         assertEquals(newRoot, treeTableView.getFocusModel().getFocusedItem());
1229     }
1230 
1231     @Test public void ensureSelectionRemainsOnBranchWhenExpanded() {
1232         installChildren();
1233         root.setExpanded(false);
1234         treeTableView.getSelectionModel().select(0);
1235         assertTrue(treeTableView.getSelectionModel().isSelected(0));
1236         root.setExpanded(true);
1237         assertTrue(treeTableView.getSelectionModel().isSelected(0));
1238         assertTrue(treeTableView.getSelectionModel().getSelectedItems().contains(root));
1239     }
1240 
1241     /*********************************************************************
1242      * Tests for misc                                                    *
1243      ********************************************************************/
1244     @Test public void ensureRootIndexIsZeroWhenRootIsShowing() {
1245         installChildren();
1246         assertEquals(0, treeTableView.getRow(root));
1247     }
1248 
1249     @Test public void ensureRootIndexIsNegativeOneWhenRootIsNotShowing() {
1250         installChildren();
1251         treeTableView.setShowRoot(false);
1252         assertEquals(-1, treeTableView.getRow(root));
1253     }
1254 
1255     @Test public void ensureCorrectIndexWhenRootTreeItemHasParent() {
1256         installChildren();
1257         treeTableView.setRoot(child1);
1258         assertEquals(-1, treeTableView.getRow(root));
1259         assertEquals(0, treeTableView.getRow(child1));
1260         assertEquals(1, treeTableView.getRow(child2));
1261         assertEquals(2, treeTableView.getRow(child3));
1262     }
1263 
1264     @Test public void ensureCorrectIndexWhenRootTreeItemHasParentAndRootIsNotShowing() {
1265         installChildren();
1266         treeTableView.setRoot(child1);
1267         treeTableView.setShowRoot(false);
1268 
1269         // despite the fact there are children in this tree, in reality none are
1270         // visible as the root node has no children (only siblings), and the
1271         // root node is not visible.
1272         assertEquals(0, treeTableView.getExpandedItemCount());
1273 
1274         assertEquals(-1, treeTableView.getRow(root));
1275         assertEquals(-1, treeTableView.getRow(child1));
1276         assertEquals(-1, treeTableView.getRow(child2));
1277         assertEquals(-1, treeTableView.getRow(child3));
1278     }
1279 
1280     @Test public void ensureCorrectIndexWhenRootTreeItemIsCollapsed() {
1281         installChildren();
1282         root.setExpanded(false);
1283         assertEquals(0, treeTableView.getRow(root));
1284 
1285         // note that the indices are negative, as these children rows are not
1286         // visible in the tree
1287         assertEquals(-1, treeTableView.getRow(child1));
1288         assertEquals(-1, treeTableView.getRow(child2));
1289         assertEquals(-1, treeTableView.getRow(child3));
1290     }
1291 
1292 //    @Test public void removingLastTest() {
1293 //        TreeTableView tree_view = new TreeTableView();
1294 //        MultipleSelectionModel sm = tree_view.getSelectionModel();
1295 //        TreeItem&lt;String&gt; tree_model = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1296 //        TreeItem node = new TreeItem(&quot;Data item&quot;);
1297 //        tree_model.getChildren().add(node);
1298 //        tree_view.setRoot(tree_model);
1299 //        tree_model.setExpanded(true);
1300 //        // select the &#39;Data item&#39; in the selection model
1301 //        sm.select(tree_model.getChildren().get(0));
1302 //        // remove the &#39;Data item&#39; from the root node
1303 //        tree_model.getChildren().remove(sm.getSelectedItem());
1304 //        // assert the there are no selected items any longer
1305 //        assertTrue(&quot;items: &quot; + sm.getSelectedItem(), sm.getSelectedItems().isEmpty());
1306 //    }
1307 
1308     /*********************************************************************
1309      * Tests from bug reports                                            *
1310      ********************************************************************/
1311     @Ignore @Test public void test_rt17112() {
1312         TreeItem&lt;String&gt; root1 = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1313         root1.setExpanded(true);
1314         addChildren(root1, &quot;child&quot;);
1315         for (TreeItem child : root1.getChildren()) {
1316             addChildren(child, (String)child.getValue());
1317             child.setExpanded(true);
1318         }
1319 
1320         final TreeTableView treeTableView1 = new TreeTableView();
1321         final MultipleSelectionModel sm = treeTableView1.getSelectionModel();
1322         sm.setSelectionMode(SelectionMode.MULTIPLE);
1323         treeTableView1.setRoot(root1);
1324 
1325         final TreeItem&lt;String&gt; rt17112_child1 = root1.getChildren().get(1);
1326         final TreeItem&lt;String&gt; rt17112_child1_0 = rt17112_child1.getChildren().get(0);
1327         final TreeItem&lt;String&gt; rt17112_child2 = root1.getChildren().get(2);
1328 
1329         sm.getSelectedItems().addListener(new InvalidationListener() {
1330             int count = 0;
1331             @Override public void invalidated(Observable observable) {
1332                 if (count == 0) {
1333                     assertEquals(rt17112_child1_0, sm.getSelectedItem());
1334                     assertEquals(1, sm.getSelectedIndices().size());
1335                     assertEquals(6, sm.getSelectedIndex());
1336                     assertTrue(treeTableView1.getFocusModel().isFocused(6));
1337                 } else if (count == 1) {
1338                     assertEquals(rt17112_child1, sm.getSelectedItem());
1339                     assertFalse(sm.getSelectedItems().contains(rt17112_child2));
1340                     assertEquals(1, sm.getSelectedIndices().size());
1341                     assertTrue(treeTableView1.getFocusModel().isFocused(5));
1342                 }
1343                 count++;
1344             }
1345         });
1346 
1347         // this triggers the first callback above, so that count == 0
1348         sm.select(rt17112_child1_0);
1349 
1350         // this triggers the second callback above, so that count == 1
1351         rt17112_child1.setExpanded(false);
1352     }
1353     private void addChildren(TreeItem parent, String name) {
1354         for (int i=0; i&lt;3; i++) {
1355             TreeItem&lt;String&gt; ti = new TreeItem&lt;String&gt;(name+&quot;-&quot;+i);
1356             parent.getChildren().add(ti);
1357         }
1358     }
1359 
1360     @Test public void test_rt17522_focusShouldMoveWhenItemAddedAtFocusIndex_1() {
1361         installChildren();
1362         FocusModel fm = treeTableView.getFocusModel();
1363         fm.focus(1);    // focus on child1
1364         assertTrue(fm.isFocused(1));
1365         assertEquals(child1, fm.getFocusedItem());
1366 
1367         TreeItem child0 = new TreeItem(&quot;child0&quot;);
1368         root.getChildren().add(0, child0);  // 0th index == position of child1 in root
1369 
1370         assertEquals(child1, fm.getFocusedItem());
1371         assertTrue(fm.isFocused(2));
1372     }
1373 
1374     @Test public void test_rt17522_focusShouldMoveWhenItemAddedBeforeFocusIndex_1() {
1375         installChildren();
1376         FocusModel fm = treeTableView.getFocusModel();
1377         fm.focus(1);    // focus on child1
1378         assertTrue(fm.isFocused(1));
1379 
1380         TreeItem child0 = new TreeItem(&quot;child0&quot;);
1381         root.getChildren().add(0, child0);
1382         assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(2));
1383     }
1384 
1385     @Test public void test_rt17522_focusShouldNotMoveWhenItemAddedAfterFocusIndex_1() {
1386         installChildren();
1387         FocusModel fm = treeTableView.getFocusModel();
1388         fm.focus(1);    // focus on child1
1389         assertTrue(fm.isFocused(1));
1390 
1391         TreeItem child4 = new TreeItem(&quot;child4&quot;);
1392         root.getChildren().add(3, child4);
1393         assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(1));
1394     }
1395 
1396     @Test public void test_rt17522_focusShouldBeMovedWhenFocusedItemIsRemoved_1() {
1397         installChildren();
1398         FocusModel fm = treeTableView.getFocusModel();
1399         fm.focus(1);
1400         assertTrue(fm.isFocused(1));
1401 
1402         root.getChildren().remove(child1);
1403         assertEquals(0, fm.getFocusedIndex());
1404         assertEquals(treeTableView.getTreeItem(0), fm.getFocusedItem());
1405     }
1406 
1407     @Test public void test_rt17522_focusShouldMoveWhenItemRemovedBeforeFocusIndex_1() {
1408         installChildren();
1409         FocusModel fm = treeTableView.getFocusModel();
1410         fm.focus(2);
1411         assertTrue(fm.isFocused(2));
1412 
1413         root.getChildren().remove(child1);
1414         assertTrue(fm.isFocused(1));
1415         assertEquals(child2, fm.getFocusedItem());
1416     }
1417 
1418 //    This test fails as, in TreeTableView FocusModel, we do not know the index of the
1419 //    removed tree items, which means we don&#39;t know whether they existed before
1420 //    or after the focused item.
1421 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemRemovedAfterFocusIndex() {
1422 //        installChildren();
1423 //        FocusModel fm = treeTableView.getFocusModel();
1424 //        fm.focus(1);
1425 //        assertTrue(fm.isFocused(1));
1426 //
1427 //        root.getChildren().remove(child3);
1428 //        assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(1));
1429 //        assertEquals(child1, fm.getFocusedItem());
1430 //    }
1431 
1432     @Test public void test_rt18385() {
1433         installChildren();
1434 //        table.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;);
1435         treeTableView.getSelectionModel().select(1);
1436         treeTableView.getRoot().getChildren().add(new TreeItem(&quot;Another Row&quot;));
1437         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndices().size());
1438         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1439     }
1440 
1441     @Test public void test_rt18339_onlyEditWhenTreeTableViewIsEditable_editableIsFalse() {
1442         TreeItem root = new TreeItem(&quot;root&quot;);
1443         root.getChildren().setAll(
1444                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1445                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1446                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1447                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1448                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1449         root.setExpanded(true);
1450 
1451         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1452 
1453         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1454         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1455 
1456         table.setEditable(false);
1457         table.edit(0,firstNameCol);
1458         assertNull(table.getEditingCell());
1459     }
1460 
1461     @Test public void test_rt18339_onlyEditWhenTreeTableViewIsEditable_editableIsTrue() {
1462         TreeItem root = new TreeItem(&quot;root&quot;);
1463         root.getChildren().setAll(
1464                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1465                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1466                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1467                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1468                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1469         root.setExpanded(true);
1470 
1471         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1472 
1473         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1474         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1475 
1476         table.setEditable(true);
1477         table.edit(0,firstNameCol);
1478         assertEquals(root, table.getEditingCell().getTreeItem());
1479     }
1480 
1481     @Test public void test_rt14451() {
1482         installChildren();
1483         treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
1484         treeTableView.getSelectionModel().selectRange(0, 2); // select from 0 (inclusive) to 2 (exclusive)
1485         assertEquals(2, treeTableView.getSelectionModel().getSelectedIndices().size());
1486     }
1487 
1488     @Test public void test_rt21586() {
1489         installChildren();
1490         treeTableView.getSelectionModel().select(1);
1491         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1492         assertEquals(child1, treeTableView.getSelectionModel().getSelectedItem());
1493 
1494         TreeItem root = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1495         TreeItem child1 = new TreeItem&lt;String&gt;(&quot;New Child 1&quot;);
1496         TreeItem child2 = new TreeItem&lt;String&gt;(&quot;New Child 2&quot;);
1497         TreeItem child3 = new TreeItem&lt;String&gt;(&quot;New Child 3&quot;);
1498         root.setExpanded(true);
1499         root.getChildren().setAll(child1, child2, child3);
1500         treeTableView.setRoot(root);
1501         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1502         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1503         assertEquals(0, treeTableView.getFocusModel().getFocusedIndex());
1504         assertEquals(root, treeTableView.getFocusModel().getFocusedItem());
1505     }
1506 
1507     @Test public void test_rt27181() {
1508         myCompanyRootNode.setExpanded(true);
1509         treeTableView.setRoot(myCompanyRootNode);
1510 
1511         // start test
1512         salesDepartment.setExpanded(true);
1513         treeTableView.getSelectionModel().select(salesDepartment);
1514 
1515         assertEquals(1, treeTableView.getFocusModel().getFocusedIndex());
1516         itSupport.setExpanded(true);
1517         assertEquals(1, treeTableView.getFocusModel().getFocusedIndex());
1518     }
1519 
1520     @Test public void test_rt27185() {
1521         myCompanyRootNode.setExpanded(true);
1522         treeTableView.setRoot(myCompanyRootNode);
1523 
1524         // start test
1525         itSupport.setExpanded(true);
1526         treeTableView.getSelectionModel().select(mikeGraham);
1527 
1528         assertEquals(mikeGraham, treeTableView.getFocusModel().getFocusedItem());
1529         salesDepartment.setExpanded(true);
1530         assertEquals(mikeGraham, treeTableView.getFocusModel().getFocusedItem());
1531     }
1532 
1533     @Ignore(&quot;Bug hasn&#39;t been fixed yet&quot;)
1534     @Test public void test_rt28114() {
1535         myCompanyRootNode.setExpanded(true);
1536         treeTableView.setRoot(myCompanyRootNode);
1537 
1538         // start test
1539         itSupport.setExpanded(true);
1540         treeTableView.getSelectionModel().select(itSupport);
1541         assertEquals(itSupport, treeTableView.getFocusModel().getFocusedItem());
1542         assertEquals(itSupport, treeTableView.getSelectionModel().getSelectedItem());
1543         assertTrue(! itSupport.isLeaf());
1544         assertTrue(itSupport.isExpanded());
1545 
1546         itSupport.getChildren().remove(mikeGraham);
1547         assertEquals(itSupport, treeTableView.getFocusModel().getFocusedItem());
1548         assertEquals(itSupport, treeTableView.getSelectionModel().getSelectedItem());
1549         assertTrue(itSupport.isLeaf());
1550         assertTrue(!itSupport.isExpanded());
1551     }
1552 
1553     @Test public void test_rt27820_1() {
1554         TreeItem root = new TreeItem(&quot;root&quot;);
1555         root.setExpanded(true);
1556         TreeItem child = new TreeItem(&quot;child&quot;);
1557         root.getChildren().add(child);
1558         treeTableView.setRoot(root);
1559 
1560         treeTableView.getSelectionModel().select(0);
1561         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1562         assertEquals(root, treeTableView.getSelectionModel().getSelectedItem());
1563 
1564         treeTableView.setRoot(null);
1565         assertEquals(0, treeTableView.getSelectionModel().getSelectedItems().size());
1566         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1567     }
1568 
1569     @Test public void test_rt27820_2() {
1570         TreeItem root = new TreeItem(&quot;root&quot;);
1571         root.setExpanded(true);
1572         TreeItem child = new TreeItem(&quot;child&quot;);
1573         root.getChildren().add(child);
1574         treeTableView.setRoot(root);
1575 
1576         treeTableView.getSelectionModel().select(1);
1577         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1578         assertEquals(child, treeTableView.getSelectionModel().getSelectedItem());
1579 
1580         treeTableView.setRoot(null);
1581         assertEquals(0, treeTableView.getSelectionModel().getSelectedItems().size());
1582         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1583     }
1584 
1585     @Test public void test_rt28390() {
1586         // There should be no NPE when a TreeTableView is shown and the disclosure
1587         // node is null in a TreeCell
1588         TreeItem root = new TreeItem(&quot;root&quot;);
1589         treeTableView.setRoot(root);
1590 
1591         // install a custom cell factory that forces the disclosure node to be
1592         // null (because by default a null disclosure node will be replaced by
1593         // a non-null one).
1594         treeTableView.setRowFactory(new Callback() {
1595             @Override public Object call(Object p) {
1596                 TreeTableRow treeCell = new TreeTableRowShim() {
1597                     {
1598                         disclosureNodeProperty().addListener((ov, t, t1) -&gt; {
1599                             setDisclosureNode(null);
1600                         });
1601                     }
1602 
1603                     @Override public void updateItem(Object item, boolean empty) {
1604                         super.updateItem(item, empty);
1605                         setText(item == null ? &quot;&quot; : item.toString());
1606                     }
1607                 };
1608                 treeCell.setDisclosureNode(null);
1609                 return treeCell;
1610             }
1611         });
1612 
1613         try {
1614             Group group = new Group();
1615             group.getChildren().setAll(treeTableView);
1616             Scene scene = new Scene(group);
1617             Stage stage = new Stage();
1618             stage.setScene(scene);
1619             stage.show();
1620         } catch (NullPointerException e) {
1621             System.out.println(&quot;A null disclosure node is valid, so we shouldn&#39;t have an NPE here.&quot;);
1622             e.printStackTrace();
1623             assertTrue(false);
1624         }
1625     }
1626 
1627     @Ignore(&quot;This test begun failing when createDefaultCellImpl was removed from TreeTableViewSkin on 28/3/2013&quot;)
1628     @Test public void test_rt28534() {
1629         TreeItem root = new TreeItem(&quot;root&quot;);
1630         root.getChildren().setAll(
1631                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1632                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1633                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1634                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1635                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1636         root.setExpanded(true);
1637 
1638         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1639 
1640         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1641         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1642 
1643         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1644         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1645 
1646         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1647         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1648 
1649         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1650 
1651         VirtualFlowTestUtils.assertRowsNotEmpty(table, 0, 6); // rows 0 - 6 should be filled
1652         VirtualFlowTestUtils.assertRowsEmpty(table, 6, -1); // rows 6+ should be empty
1653 
1654         // now we replace the data and expect the cells that have no data
1655         // to be empty
1656         root.getChildren().setAll(
1657                 new TreeItem(new Person(&quot;*_*Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1658                 new TreeItem(new Person(&quot;_Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1659 
1660         VirtualFlowTestUtils.assertRowsNotEmpty(table, 0, 3); // rows 0 - 3 should be filled
1661         VirtualFlowTestUtils.assertRowsEmpty(table, 3, -1); // rows 3+ should be empty
1662     }
1663 
1664     @Test public void test_rt22463() {
1665         final TreeTableView&lt;RT_22463_Person&gt; table = new TreeTableView&lt;RT_22463_Person&gt;();
1666         table.setTableMenuButtonVisible(true);
1667         TreeTableColumn c1 = new TreeTableColumn(&quot;Id&quot;);
1668         TreeTableColumn c2 = new TreeTableColumn(&quot;Name&quot;);
1669         c1.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, Long&gt;(&quot;id&quot;));
1670         c2.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;name&quot;));
1671         table.getColumns().addAll(c1, c2);
1672 
1673         RT_22463_Person rootPerson = new RT_22463_Person();
1674         rootPerson.setName(&quot;Root&quot;);
1675         TreeItem&lt;RT_22463_Person&gt; root = new TreeItem&lt;RT_22463_Person&gt;(rootPerson);
1676         root.setExpanded(true);
1677 
1678         table.setRoot(root);
1679 
1680         // before the change things display fine
1681         RT_22463_Person p1 = new RT_22463_Person();
1682         p1.setId(1l);
1683         p1.setName(&quot;name1&quot;);
1684         RT_22463_Person p2 = new RT_22463_Person();
1685         p2.setId(2l);
1686         p2.setName(&quot;name2&quot;);
1687         root.getChildren().addAll(
1688                 new TreeItem&lt;RT_22463_Person&gt;(p1),
1689                 new TreeItem&lt;RT_22463_Person&gt;(p2));
1690         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;1&quot;, &quot;name1&quot;);
1691         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;2&quot;, &quot;name2&quot;);
1692 
1693         // now we change the persons but they are still equal as the ID&#39;s don&#39;t
1694         // change - but the items list is cleared so the cells should update
1695         RT_22463_Person new_p1 = new RT_22463_Person();
1696         new_p1.setId(1l);
1697         new_p1.setName(&quot;updated name1&quot;);
1698         RT_22463_Person new_p2 = new RT_22463_Person();
1699         new_p2.setId(2l);
1700         new_p2.setName(&quot;updated name2&quot;);
1701         root.getChildren().clear();
1702         root.getChildren().setAll(
1703                 new TreeItem&lt;RT_22463_Person&gt;(new_p1),
1704                 new TreeItem&lt;RT_22463_Person&gt;(new_p2));
1705         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;1&quot;, &quot;updated name1&quot;);
1706         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;2&quot;, &quot;updated name2&quot;);
1707     }
1708 
1709     @Test public void test_rt28637() {
1710         TreeItem&lt;String&gt; s1, s2, s3, s4;
1711         ObservableList&lt;TreeItem&lt;String&gt;&gt; items = FXCollections.observableArrayList(
1712                 s1 = new TreeItem&lt;String&gt;(&quot;String1&quot;),
1713                 s2 = new TreeItem&lt;String&gt;(&quot;String2&quot;),
1714                 s3 = new TreeItem&lt;String&gt;(&quot;String3&quot;),
1715                 s4 = new TreeItem&lt;String&gt;(&quot;String4&quot;));
1716 
1717         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;String&gt;();
1718 
1719         TreeItem&lt;String&gt; root = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1720         root.setExpanded(true);
1721         treeTableView.setRoot(root);
1722         treeTableView.setShowRoot(false);
1723         root.getChildren().addAll(items);
1724 
1725         treeTableView.getSelectionModel().select(0);
1726         assertEquals((Object)s1, treeTableView.getSelectionModel().getSelectedItem());
1727         assertEquals((Object)s1, treeTableView.getSelectionModel().getSelectedItems().get(0));
1728         assertEquals(0, treeTableView.getSelectionModel().getSelectedIndex());
1729 
1730         root.getChildren().remove(treeTableView.getSelectionModel().getSelectedItem());
1731         assertEquals((Object)s2, treeTableView.getSelectionModel().getSelectedItem());
1732         assertEquals((Object)s2, treeTableView.getSelectionModel().getSelectedItems().get(0));
1733         assertEquals(0, treeTableView.getSelectionModel().getSelectedIndex());
1734     }
1735 
1736     @Test public void test_rt24844() {
1737         // p1 == lowest first name
1738         TreeItem&lt;Person&gt; p0, p1, p2, p3, p4;
1739 
1740         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1741             p3 = new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1742             p2 = new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1743             p1 = new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1744             p0 = new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1745             p4 = new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1746 
1747         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1748 
1749         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1750         root.setExpanded(true);
1751         table.setRoot(root);
1752         table.setShowRoot(false);
1753         root.getChildren().setAll(persons);
1754 
1755         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1756         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1757 
1758         // set dummy comparator to lock items in place until new comparator is set
1759         firstNameCol.setComparator((t, t1) -&gt; 0);
1760 
1761         table.getColumns().addAll(firstNameCol);
1762         table.getSortOrder().add(firstNameCol);
1763 
1764         // ensure the existing order is as expected
1765         assertEquals(p3, root.getChildren().get(0));
1766         assertEquals(p2, root.getChildren().get(1));
1767         assertEquals(p1, root.getChildren().get(2));
1768         assertEquals(p0, root.getChildren().get(3));
1769         assertEquals(p4, root.getChildren().get(4));
1770 
1771         // set a new comparator
1772         firstNameCol.setComparator((t, t1) -&gt; t.toString().compareTo(t1.toString()));
1773 
1774         // ensure the new order is as expected
1775         assertEquals(p0, root.getChildren().get(0));
1776         assertEquals(p1, root.getChildren().get(1));
1777         assertEquals(p2, root.getChildren().get(2));
1778         assertEquals(p3, root.getChildren().get(3));
1779         assertEquals(p4, root.getChildren().get(4));
1780     }
1781 
1782     @Test public void test_rt29331() {
1783         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;();
1784 
1785         // p1 == lowest first name
1786         TreeItem&lt;Person&gt; p0, p1, p2, p3, p4;
1787 
1788         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1789         firstNameCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1790 
1791         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1792         lastNameCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1793 
1794         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1795         emailCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1796 
1797         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1798         parentColumn.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1799 
1800         table.getColumns().addAll(parentColumn);
1801 
1802         // table is setup, now hide the &#39;last name&#39; column
1803         emailCol.setVisible(false);
1804         assertFalse(emailCol.isVisible());
1805 
1806         // reorder columns inside the parent column
1807         parentColumn.getColumns().setAll(emailCol, firstNameCol, lastNameCol);
1808 
1809         // the email column should not become visible after this, but it does
1810         assertFalse(emailCol.isVisible());
1811     }
1812 
1813     private int rt29330_count = 0;
1814     @Test public void test_rt29330_1() {
1815         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1816                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1817                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1818                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1819                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1820                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1821 
1822         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1823 
1824         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1825         root.setExpanded(true);
1826         table.setRoot(root);
1827         table.setShowRoot(false);
1828         root.getChildren().setAll(persons);
1829 
1830         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1831         table.getColumns().addAll(parentColumn);
1832 
1833         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1834         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1835 
1836         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1837         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1838 
1839         parentColumn.getColumns().addAll(firstNameCol, lastNameCol);
1840 
1841         table.setOnSort(event -&gt; {
1842             rt29330_count++;
1843         });
1844 
1845         // test preconditions
1846         assertEquals(ASCENDING, lastNameCol.getSortType());
1847         assertEquals(0, rt29330_count);
1848 
1849         table.getSortOrder().add(lastNameCol);
1850         assertEquals(1, rt29330_count);
1851 
1852         lastNameCol.setSortType(DESCENDING);
1853         assertEquals(2, rt29330_count);
1854 
1855         lastNameCol.setSortType(null);
1856         assertEquals(3, rt29330_count);
1857 
1858         lastNameCol.setSortType(ASCENDING);
1859         assertEquals(4, rt29330_count);
1860     }
1861 
1862     @Test public void test_rt29330_2() {
1863         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1864                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1865                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1866                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1867                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1868                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1869 
1870         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1871 
1872         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1873         root.setExpanded(true);
1874         table.setRoot(root);
1875         table.setShowRoot(false);
1876         root.getChildren().setAll(persons);
1877 
1878         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1879         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1880 
1881         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1882         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1883 
1884         // this test differs from the previous one by installing the parent column
1885         // into the tableview after it has the children added into it
1886         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1887         parentColumn.getColumns().addAll(firstNameCol, lastNameCol);
1888         table.getColumns().addAll(parentColumn);
1889 
1890         table.setOnSort(event -&gt; {
1891             rt29330_count++;
1892         });
1893 
1894         // test preconditions
1895         assertEquals(ASCENDING, lastNameCol.getSortType());
1896         assertEquals(0, rt29330_count);
1897 
1898         table.getSortOrder().add(lastNameCol);
1899         assertEquals(1, rt29330_count);
1900 
1901         lastNameCol.setSortType(DESCENDING);
1902         assertEquals(2, rt29330_count);
1903 
1904         lastNameCol.setSortType(null);
1905         assertEquals(3, rt29330_count);
1906 
1907         lastNameCol.setSortType(ASCENDING);
1908         assertEquals(4, rt29330_count);
1909     }
1910 
1911     @Test public void test_rt29313_selectedIndices() {
1912         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1913                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1914                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1915                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1916                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1917                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1918 
1919         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1920 
1921         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1922         root.setExpanded(true);
1923         table.setRoot(root);
1924         table.setShowRoot(false);
1925         root.getChildren().setAll(persons);
1926 
1927         TableSelectionModel sm = table.getSelectionModel();
1928 
1929         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1930         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1931 
1932         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1933         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1934 
1935         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1936         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1937 
1938         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1939         sm.setCellSelectionEnabled(true);
1940         sm.setSelectionMode(SelectionMode.MULTIPLE);
1941 
1942         assertTrue(sm.getSelectedIndices().isEmpty());
1943 
1944         // only (0,0) should be selected, so selected indices should be [0]
1945         sm.select(0, firstNameCol);
1946         assertEquals(1, sm.getSelectedIndices().size());
1947 
1948         // now (0,0) and (1,0) should be selected, so selected indices should be [0, 1]
1949         sm.select(1, firstNameCol);
1950         assertEquals(2, sm.getSelectedIndices().size());
1951 
1952         // now (0,0), (1,0) and (1,1) should be selected, but selected indices
1953         // should remain as [0, 1], as we don&#39;t want selected indices to become
1954         // [0,1,1] (which is what RT-29313 is about)
1955         sm.select(1, lastNameCol);
1956         assertEquals(2, sm.getSelectedIndices().size());
1957         assertEquals(0, sm.getSelectedIndices().get(0));
1958         assertEquals(1, sm.getSelectedIndices().get(1));
1959     }
1960 
1961     @Test public void test_rt29313_selectedItems() {
1962         TreeItem&lt;Person&gt; p0, p1;
1963         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1964                 p0 = new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1965                 p1 = new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1966                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1967                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1968                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1969 
1970         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1971 
1972         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1973         root.setExpanded(true);
1974         table.setRoot(root);
1975         table.setShowRoot(false);
1976         root.getChildren().setAll(persons);
1977 
1978         TableSelectionModel sm = table.getSelectionModel();
1979 
1980         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1981         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1982 
1983         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1984         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1985 
1986         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1987         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1988 
1989         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1990         sm.setCellSelectionEnabled(true);
1991         sm.setSelectionMode(SelectionMode.MULTIPLE);
1992 
1993         assertTrue(sm.getSelectedItems().isEmpty());
1994 
1995         // only (0,0) should be selected, so selected items should be [p0]
1996         sm.select(0, firstNameCol);
1997         assertEquals(1, sm.getSelectedItems().size());
1998 
1999         // now (0,0) and (1,0) should be selected, so selected items should be [p0, p1]
2000         sm.select(1, firstNameCol);
2001         assertEquals(2, sm.getSelectedItems().size());
2002 
2003         // now (0,0), (1,0) and (1,1) should be selected, but selected items
2004         // should remain as [p0, p1], as we don&#39;t want selected items to become
2005         // [p0,p1,p1] (which is what RT-29313 is about)
2006         sm.select(1, lastNameCol);
2007         assertEquals(2, sm.getSelectedItems().size());
2008         assertEquals(p0, sm.getSelectedItems().get(0));
2009         assertEquals(p1, sm.getSelectedItems().get(1));
2010     }
2011 
2012     @Test public void test_rt29566() {
2013         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
2014                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2015                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2016                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2017                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
2018                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
2019 
2020         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
2021 
2022         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
2023         root.setExpanded(true);
2024         table.setRoot(root);
2025         table.setShowRoot(false);
2026         root.getChildren().setAll(persons);
2027 
2028         TableSelectionModel sm = table.getSelectionModel();
2029 
2030         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2031         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
2032 
2033         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
2034         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
2035 
2036         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
2037         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
2038 
2039         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
2040 
2041         // test the state before we hide and re-add a column
2042         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;);
2043         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;);
2044         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;);
2045         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;);
2046         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;);
2047 
2048         // hide the last name column, and test cells again
2049         table.getColumns().remove(lastNameCol);
2050         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;jacob.smith@example.com&quot;);
2051         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;isabella.johnson@example.com&quot;);
2052         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;ethan.williams@example.com&quot;);
2053         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;emma.jones@example.com&quot;);
2054         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;michael.brown@example.com&quot;);
2055 
2056         // re-add the last name column - we should go back to the original state.
2057         // However, what appears to be happening is that, for some reason, some
2058         // of the cells from the removed column do not reappear - meaning in this case
2059         // some of the last name values will not be where we expect them to be.
2060         // This is clearly not ideal!
2061         table.getColumns().add(1, lastNameCol);
2062         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;);
2063         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;);
2064         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;);
2065         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;);
2066         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;);
2067     }
2068 
2069     @Test public void test_rt29390() {
2070         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
2071                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2072                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2073                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2074                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
2075                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2076                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2077                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2078                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
2079                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2080                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2081                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2082                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
2083                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2084                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2085                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2086                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)
2087         ));
2088 
2089         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
2090         table.setMaxHeight(50);
2091         table.setPrefHeight(50);
2092 
2093         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
2094         root.setExpanded(true);
2095         table.setRoot(root);
2096         table.setShowRoot(false);
2097         root.getChildren().setAll(persons);
2098 
2099         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2100         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
2101 
2102         table.getColumns().add(firstNameCol);
2103 
2104         Toolkit.getToolkit().firePulse();
2105 
2106         // we want the vertical scrollbar
2107         VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowVerticalScrollbar(table);
2108 
2109         assertNotNull(scrollBar);
2110         assertTrue(scrollBar.isVisible());
2111         assertTrue(scrollBar.getVisibleAmount() &gt; 0.0);
2112         assertTrue(scrollBar.getVisibleAmount() &lt; 1.0);
2113 
2114         // this next test is likely to be brittle, but we&#39;ll see...If it is the
2115         // cause of failure then it can be commented out
2116         assertEquals(0.0625, scrollBar.getVisibleAmount(), 0.0);
2117     }
2118 
2119     @Test public void test_rt29676_withText() {
2120         // set up test
2121         TreeTableView&lt;Data&gt; treeTableView = new TreeTableView&lt;Data&gt;();
2122         treeTableView.setMaxWidth(100);
2123 
2124         TreeItem&lt;Data&gt; root = new TreeItem&lt;Data&gt;(new Data(&quot;Root&quot;));
2125         treeTableView.setRoot(root);
2126         addLevel(root, 0, 30);
2127 
2128         treeTableView.getRoot().setExpanded(true);
2129         TreeTableColumn&lt;Data, String&gt; column = new TreeTableColumn&lt;Data, String&gt;(&quot;Items&#39; name&quot;);
2130         column.setCellValueFactory(p -&gt; new ReadOnlyStringWrapper(p.getValue().getValue().getData()));
2131         treeTableView.getColumns().add(column);
2132 
2133         // show treeTableView
2134         StageLoader sl = new StageLoader(treeTableView);
2135 
2136         // expand all collapsed branches
2137         root.setExpanded(true);
2138         for (int i = 0; i &lt; root.getChildren().size(); i++) {
2139             TreeItem&lt;Data&gt; child = root.getChildren().get(i);
2140             child.setExpanded(true);
2141         }
2142 
2143         // get all cells and ensure their content is as expected
2144         int cellCount = VirtualFlowTestUtils.getCellCount(treeTableView);
2145         for (int i = 0; i &lt; cellCount; i++) {
2146             // get the TreeTableRow
2147             final TreeTableRow rowCell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, i);
2148             final TreeItem treeItem = rowCell.getTreeItem();
2149             if (treeItem == null) continue;
2150 
2151             final boolean isBranch = ! treeItem.isLeaf();
2152 
2153             // then check its children
2154             List&lt;Node&gt; children = rowCell.getChildrenUnmodifiable();
2155             for (int j = 0; j &lt; children.size(); j++) {
2156                 final Node child = children.get(j);
2157 
2158                 assertTrue(child.isVisible());
2159                 assertNotNull(child.getParent());
2160                 assertNotNull(child.getScene());
2161 
2162                 if (child.getStyleClass().contains(&quot;tree-disclosure-node&quot;)) {
2163                     // no-op
2164                 }
2165 
2166                 if (child.getStyleClass().contains(&quot;tree-table-cell&quot;)) {
2167                     TreeTableCell cell = (TreeTableCell) child;
2168                     assertNotNull(cell.getText());
2169                     assertFalse(cell.getText().isEmpty());
2170                 }
2171             }
2172         }
2173 
2174         sl.dispose();
2175     }
2176     private void addLevel(TreeItem&lt;Data&gt; item, int level, int length) {
2177         for (int i = 0; i &lt; 3; i++) {
2178             StringBuilder builder = new StringBuilder();
2179             builder.append(&quot;Level &quot; + level + &quot; Item &quot; + item);
2180             if (length &gt; 0) {
2181                 builder.append(&quot; l&quot;);
2182                 for (int j = 0; j &lt; length; j++) {
2183                     builder.append(&quot;o&quot;);
2184                 }
2185                 builder.append(&quot;ng&quot;);
2186             }
2187             String itemString = builder.toString();
2188             TreeItem&lt;Data&gt; child = new TreeItem&lt;Data&gt;(new Data(itemString));
2189             if (level &lt; 3 - 1) {
2190                 addLevel(child, level + 1, length);
2191             }
2192             item.getChildren().add(child);
2193         }
2194     }
2195 
2196     @Test public void test_rt27180_collapseBranch_childSelected_singleSelection() {
2197         sm.setCellSelectionEnabled(false);
2198         sm.setSelectionMode(SelectionMode.SINGLE);
2199 
2200         treeTableView.setRoot(myCompanyRootNode);
2201         myCompanyRootNode.setExpanded(true);
2202         salesDepartment.setExpanded(true);
2203         itSupport.setExpanded(true);
2204         sm.select(2);                   // ethanWilliams
2205         assertFalse(sm.isSelected(1));  // salesDepartment
2206         assertTrue(sm.isSelected(2));   // ethanWilliams
2207         assertTrue(treeTableView.getFocusModel().isFocused(2));
2208         assertEquals(1, sm.getSelectedCells().size());
2209 
2210         // now collapse the salesDepartment, selection should
2211         // not jump down to the itSupport people
2212         salesDepartment.setExpanded(false);
2213         assertTrue(sm.getSelectedIndices().toString(), sm.isSelected(1));   // salesDepartment
2214         assertTrue(treeTableView.getFocusModel().isFocused(1));
2215         assertEquals(1, sm.getSelectedCells().size());
2216     }
2217 
2218     @Test public void test_rt27180_collapseBranch_laterSiblingSelected_singleSelection() {
2219         sm.setCellSelectionEnabled(false);
2220         sm.setSelectionMode(SelectionMode.SINGLE);
2221 
2222         treeTableView.setRoot(myCompanyRootNode);
2223         myCompanyRootNode.setExpanded(true);
2224         salesDepartment.setExpanded(true);
2225         itSupport.setExpanded(true);
2226         sm.select(8);                   // itSupport
2227         assertFalse(sm.isSelected(1));  // salesDepartment
2228         assertTrue(sm.isSelected(8));   // itSupport
2229         assertTrue(treeTableView.getFocusModel().isFocused(8));
2230         assertEquals(1, sm.getSelectedIndices().size());
2231 
2232         salesDepartment.setExpanded(false);
2233         assertTrue(debug(), sm.isSelected(2));   // itSupport
2234         assertTrue(treeTableView.getFocusModel().isFocused(2));
2235         assertEquals(1, sm.getSelectedIndices().size());
2236     }
2237 
2238     @Test public void test_rt27180_collapseBranch_laterSiblingAndChildrenSelected() {
2239         sm.setSelectionMode(SelectionMode.MULTIPLE);
2240         sm.setCellSelectionEnabled(false);
2241 
2242         treeTableView.setRoot(myCompanyRootNode);
2243         myCompanyRootNode.setExpanded(true);
2244         salesDepartment.setExpanded(true);
2245         itSupport.setExpanded(true);
2246         sm.clearSelection();
2247         sm.selectIndices(8, 9, 10);     // itSupport, and two people
2248         assertFalse(sm.isSelected(1));  // salesDepartment
2249         assertTrue(sm.isSelected(8));   // itSupport
2250         assertTrue(sm.isSelected(9));   // mikeGraham
2251         assertTrue(sm.isSelected(10));  // judyMayer
2252         assertTrue(treeTableView.getFocusModel().isFocused(10));
2253         assertEquals(debug(), 3, sm.getSelectedIndices().size());
2254 
2255         salesDepartment.setExpanded(false);
2256         assertTrue(debug(), sm.isSelected(2));   // itSupport
2257         assertTrue(sm.isSelected(3));   // mikeGraham
2258         assertTrue(sm.isSelected(4));   // judyMayer
2259         assertTrue(treeTableView.getFocusModel().isFocused(4));
2260         assertEquals(3, sm.getSelectedIndices().size());
2261     }
2262 
2263     @Test public void test_rt27180_expandBranch_laterSiblingSelected_singleSelection() {
2264         sm.setCellSelectionEnabled(false);
2265         sm.setSelectionMode(SelectionMode.SINGLE);
2266 
2267         treeTableView.setRoot(myCompanyRootNode);
2268         myCompanyRootNode.setExpanded(true);
2269         salesDepartment.setExpanded(false);
2270         itSupport.setExpanded(true);
2271         sm.select(2);                   // itSupport
2272         assertFalse(sm.isSelected(1));  // salesDepartment
2273         assertTrue(sm.isSelected(2));   // itSupport
2274         assertTrue(treeTableView.getFocusModel().isFocused(2));
2275         assertEquals(1, sm.getSelectedIndices().size());
2276 
2277         salesDepartment.setExpanded(true);
2278         assertTrue(debug(), sm.isSelected(8));   // itSupport
2279         assertTrue(treeTableView.getFocusModel().isFocused(8));
2280         assertEquals(1, sm.getSelectedIndices().size());
2281     }
2282 
2283     @Test public void test_rt27180_expandBranch_laterSiblingAndChildrenSelected() {
2284         sm.setSelectionMode(SelectionMode.MULTIPLE);
2285         sm.setCellSelectionEnabled(false);
2286 
2287         treeTableView.setRoot(myCompanyRootNode);
2288         myCompanyRootNode.setExpanded(true);
2289         salesDepartment.setExpanded(false);
2290         itSupport.setExpanded(true);
2291         sm.clearSelection();
2292         sm.selectIndices(2,3,4);     // itSupport, and two people
2293         assertFalse(sm.isSelected(1));  // salesDepartment
2294         assertTrue(sm.isSelected(2));   // itSupport
2295         assertTrue(sm.isSelected(3));   // mikeGraham
2296         assertTrue(sm.isSelected(4));  // judyMayer
2297         assertTrue(treeTableView.getFocusModel().isFocused(4));
2298         assertEquals(3, sm.getSelectedIndices().size());
2299 
2300         salesDepartment.setExpanded(true);
2301         assertTrue(debug(), sm.isSelected(8));   // itSupport
2302         assertTrue(sm.isSelected(9));   // mikeGraham
2303         assertTrue(sm.isSelected(10));   // judyMayer
2304         assertTrue(treeTableView.getFocusModel().isFocused(10));
2305         assertEquals(3, sm.getSelectedIndices().size());
2306     }
2307 
2308     @Test public void test_rt30400() {
2309         // create a treetableview that&#39;ll render cells using the check box cell factory
2310         TreeItem&lt;String&gt; rootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
2311         final TreeTableView&lt;String&gt; tableView = new TreeTableView&lt;String&gt;(rootItem);
2312         tableView.setMinHeight(100);
2313         tableView.setPrefHeight(100);
2314 
2315         TreeTableColumn&lt;String, String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2316         firstNameCol.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
2317         firstNameCol.setCellFactory(CheckBoxTreeTableCell.forTreeTableColumn(param -&gt; new ReadOnlyBooleanWrapper(true)));
2318         tableView.getColumns().add(firstNameCol);
2319 
2320         // because only the first row has data, all other rows should be
2321         // empty (and not contain check boxes - we just check the first four here)
2322         VirtualFlowTestUtils.assertRowsNotEmpty(tableView, 0, 1);
2323         VirtualFlowTestUtils.assertCellNotEmpty(VirtualFlowTestUtils.getCell(tableView, 0));
2324         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 1));
2325         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 2));
2326         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 3));
2327     }
2328 
2329     @Ignore(&quot;This bug is not yet fixed&quot;)
2330     @Test public void test_rt31165() {
2331         installChildren();
2332         treeTableView.setEditable(true);
2333 
2334         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2335         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(&quot;TEST&quot;));
2336         firstNameCol.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
2337         firstNameCol.setEditable(true);
2338 
2339         treeTableView.getColumns().add(firstNameCol);
2340 
2341         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 1, 0);
2342         assertEquals(&quot;TEST&quot;, cell.getText());
2343         assertFalse(cell.isEditing());
2344 
2345         treeTableView.edit(1, firstNameCol);
2346 
2347         assertEquals(child1, treeTableView.getEditingCell().getTreeItem());
2348         assertTrue(cell.isEditing());
2349 
2350         VirtualFlowTestUtils.getVirtualFlow(treeTableView).requestLayout();
2351         Toolkit.getToolkit().firePulse();
2352 
2353         assertEquals(child1, treeTableView.getEditingCell().getTreeItem());
2354         assertTrue(cell.isEditing());
2355     }
2356 
2357     @Test public void test_rt31404() {
2358         installChildren();
2359 
2360         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2361         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2362 
2363         treeTableView.getColumns().add(firstNameCol);
2364 
2365         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 0, 0);
2366         assertEquals(&quot;Root&quot;, cell.getText());
2367 
2368         treeTableView.setShowRoot(false);
2369         assertEquals(&quot;Child 1&quot;, cell.getText());
2370     }
2371 
2372     @Test public void test_rt31471() {
2373         installChildren();
2374 
2375         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2376         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2377 
2378         treeTableView.getColumns().add(firstNameCol);
2379 
2380         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 0);
2381         assertEquals(&quot;Root&quot;, cell.getItem());
2382 
2383         treeTableView.setFixedCellSize(50);
2384 
2385         VirtualFlowTestUtils.getVirtualFlow(treeTableView).requestLayout();
2386         Toolkit.getToolkit().firePulse();
2387 
2388         assertEquals(&quot;Root&quot;, cell.getItem());
2389         assertEquals(50, cell.getHeight(), 0.00);
2390     }
2391 
2392     @Test public void test_rt30466() {
2393         final Node graphic1 = new Circle(6.75, Color.RED);
2394         final Node graphic2 = new Circle(6.75, Color.GREEN);
2395 
2396         installChildren();
2397 
2398         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2399         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2400 
2401         treeTableView.getColumns().add(firstNameCol);
2402 
2403         TreeTableRow cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2404         assertEquals(&quot;Root&quot;, cell.getItem());
2405 
2406         // set the first graphic - which we expect to see as a child of the cell
2407         root.setGraphic(graphic1);
2408         cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2409         boolean matchGraphic1 = false;
2410         boolean matchGraphic2 = false;
2411         for (Node n : cell.getChildrenUnmodifiable()) {
2412             if (n == graphic1) {
2413                 matchGraphic1 = true;
2414             }
2415             if (n == graphic2) {
2416                 matchGraphic2 = true;
2417             }
2418         }
2419         assertTrue(matchGraphic1);
2420         assertFalse(matchGraphic2);
2421 
2422         // set the second graphic - which we also expect to see - but of course graphic1 should not be a child any longer
2423         root.setGraphic(graphic2);
2424         cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2425         matchGraphic1 = false;
2426         matchGraphic2 = false;
2427         for (Node n : cell.getChildrenUnmodifiable()) {
2428             if (n == graphic1) {
2429                 matchGraphic1 = true;
2430             }
2431             if (n == graphic2) {
2432                 matchGraphic2 = true;
2433             }
2434         }
2435         assertFalse(matchGraphic1);
2436         assertTrue(matchGraphic2);
2437     }
2438 
2439     private int rt_31200_count = 0;
2440     @Test public void test_rt_31200_tableCell() {
2441         rt_31200_count = 0;
2442 
2443         installChildren();
2444         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2445         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2446         treeTableView.getColumns().add(firstNameCol);
2447 
2448         firstNameCol.setCellFactory(new Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2449             @Override
2450             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; param) {
2451                 return new TreeTableCellShim&lt;String, String&gt;() {
2452                     ImageView view = new ImageView();
2453 
2454                     {
2455                         setGraphic(view);
2456                     }
2457 
2458                     ;
2459 
2460                     @Override
2461                     public void updateItem(String item, boolean empty) {
2462                         if (getItem() == null ? item == null : getItem().equals(item)) {
2463                             rt_31200_count++;
2464                         }
2465                         super.updateItem(item, empty);
2466                         if (item == null || empty) {
2467                             view.setImage(null);
2468                             setText(null);
2469                         } else {
2470                             setText(item);
2471                         }
2472                     }
2473                 };
2474             }
2475         });
2476 
2477         StageLoader sl = new StageLoader(treeTableView);
2478 
2479         assertEquals(12, rt_31200_count);
2480 
2481         // resize the stage
2482         sl.getStage().setHeight(250);
2483         Toolkit.getToolkit().firePulse();
2484         sl.getStage().setHeight(50);
2485         Toolkit.getToolkit().firePulse();
2486         assertEquals(12, rt_31200_count);
2487 
2488         sl.dispose();
2489     }
2490 
2491     @Test public void test_rt_31200_tableRow() {
2492         rt_31200_count = 0;
2493 
2494         installChildren();
2495         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2496         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2497         treeTableView.getColumns().add(firstNameCol);
2498 
2499         treeTableView.setRowFactory(new Callback&lt;TreeTableView&lt;String&gt;, TreeTableRow&lt;String&gt;&gt;() {
2500             @Override
2501             public TreeTableRow&lt;String&gt; call(TreeTableView&lt;String&gt; param) {
2502                 return new TreeTableRowShim&lt;String&gt;() {
2503                     ImageView view = new ImageView();
2504 
2505                     {
2506                         setGraphic(view);
2507                     }
2508 
2509                     ;
2510 
2511                     @Override
2512                     public void updateItem(String item, boolean empty) {
2513                         if (getItem() == null ? item == null : getItem().equals(item)) {
2514                             rt_31200_count++;
2515                         }
2516                         super.updateItem(item, empty);
2517                         if (item == null || empty) {
2518                             view.setImage(null);
2519                             setText(null);
2520                         } else {
2521                             setText(item.toString());
2522                         }
2523                     }
2524                 };
2525             }
2526         });
2527 
2528         StageLoader sl = new StageLoader(treeTableView);
2529 
2530         assertEquals(21, rt_31200_count);
2531 
2532         // resize the stage
2533         sl.getStage().setHeight(250);
2534         Toolkit.getToolkit().firePulse();
2535         sl.getStage().setHeight(50);
2536         Toolkit.getToolkit().firePulse();
2537         assertEquals(21, rt_31200_count);
2538 
2539         sl.dispose();
2540     }
2541 
2542     @Test public void test_rt_31727() {
2543         installChildren();
2544         treeTableView.setEditable(true);
2545 
2546         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2547         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(&quot;TEST&quot;));
2548         firstNameCol.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
2549         firstNameCol.setEditable(true);
2550 
2551         treeTableView.getColumns().add(firstNameCol);
2552 
2553         treeTableView.setEditable(true);
2554         firstNameCol.setEditable(true);
2555 
2556         // do a normal edit
2557         treeTableView.edit(0, firstNameCol);
2558         TreeTablePosition editingCell = treeTableView.getEditingCell();
2559         assertNotNull(editingCell);
2560         assertEquals(0, editingCell.getRow());
2561         assertEquals(0, editingCell.getColumn());
2562         assertEquals(firstNameCol, editingCell.getTableColumn());
2563         assertEquals(treeTableView, editingCell.getTreeTableView());
2564 
2565         // cancel editing
2566         treeTableView.edit(-1, null);
2567         editingCell = treeTableView.getEditingCell();
2568         assertNull(editingCell);
2569     }
2570 
2571     @Test public void test_rt_21517() {
2572         installChildren();
2573 
2574 //        final TableSelectionModel sm = t.getSelectionModel();
2575         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2576         col.setSortType(ASCENDING);
2577         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2578         treeTableView.getColumns().add(col);
2579 
2580         // test pre-conditions
2581         assertEquals(0, sm.getSelectedCells().size());
2582         assertEquals(0, sm.getSelectedItems().size());
2583         assertEquals(0, sm.getSelectedIndices().size());
2584 
2585         // select the 4th row (that is, the third child of the root)
2586         sm.select(3);
2587         assertTrue(sm.isSelected(3));
2588         assertEquals(3, sm.getSelectedIndex());
2589         assertEquals(1, sm.getSelectedIndices().size());
2590         assertTrue(sm.getSelectedIndices().contains(3));
2591         assertEquals(child3, sm.getSelectedItem());
2592         assertEquals(1, sm.getSelectedItems().size());
2593         assertTrue(sm.getSelectedItems().contains(child3));
2594 
2595         // we also want to test visually
2596         TreeTableRow rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2597         assertFalse(rootRow.isSelected());
2598         TreeTableRow child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 3);
2599         assertTrue(child3Row.isSelected());
2600 
2601         // sort tableview by firstname column in ascending (default) order
2602         // (so aaa continues to come first)
2603         treeTableView.getSortOrder().add(col);
2604 
2605         // nothing should have changed
2606         assertTrue(sm.isSelected(3));
2607         assertEquals(3, sm.getSelectedIndex());
2608         assertEquals(1, sm.getSelectedIndices().size());
2609         assertTrue(sm.getSelectedIndices().contains(3));
2610         assertEquals(child3, sm.getSelectedItem());
2611         assertEquals(1, sm.getSelectedItems().size());
2612         assertTrue(sm.getSelectedItems().contains(child3));
2613         rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2614         assertFalse(rootRow.isSelected());
2615         child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 3);
2616         assertTrue(child3Row.isSelected());
2617 
2618         // continue to sort tableview by firstname column, but now in descending
2619         // order, (so ccc to come first)
2620         col.setSortType(TreeTableColumn.SortType.DESCENDING);
2621 
2622         // now test to ensure that CCC is still the only selected item, but now
2623         // located in index 1 (as the first child of the root)
2624         assertTrue(debug(), sm.isSelected(1));
2625         assertEquals(1, sm.getSelectedIndex());
2626         assertEquals(1, sm.getSelectedIndices().size());
2627         assertTrue(sm.getSelectedIndices().contains(1));
2628         assertEquals(child3, sm.getSelectedItem());
2629         assertEquals(1, sm.getSelectedItems().size());
2630         assertTrue(sm.getSelectedItems().contains(child3));
2631 
2632         // we also want to test visually
2633         rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2634         assertFalse(rootRow.isSelected());
2635         child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 1);
2636         assertTrue(child3Row.isSelected());
2637     }
2638 
2639     @Test public void test_rt_30484_treeTableCell() {
2640         installChildren();
2641 
2642         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2643         col.setSortType(ASCENDING);
2644         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2645         treeTableView.getColumns().add(col);
2646 
2647         col.setCellFactory(new Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2648             @Override
2649             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; param) {
2650                 return new TreeTableCellShim&lt;String, String&gt;() {
2651                     Rectangle graphic = new Rectangle(10, 10, Color.RED);
2652                     { setGraphic(graphic); };
2653 
2654                     @Override public void updateItem(String item, boolean empty) {
2655                         super.updateItem(item, empty);
2656                         if (item == null || empty) {
2657                             graphic.setVisible(false);
2658                             setText(null);
2659                         } else {
2660                             graphic.setVisible(true);
2661                             setText(item);
2662                         }
2663                     }
2664                 };
2665             }
2666         });
2667 
2668         // First four rows have content, so the graphic should show.
2669         // All other rows have no content, so graphic should not show.
2670 
2671         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    0, 0);
2672         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    1, 0);
2673         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    2, 0);
2674         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    3, 0);
2675         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 4, 0);
2676         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 5, 0);
2677     }
2678 
2679     @Test public void test_rt_30484_treeTableRow() {
2680         installChildren();
2681 
2682         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2683         col.setSortType(ASCENDING);
2684         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2685         treeTableView.getColumns().add(col);
2686 
2687         treeTableView.setRowFactory(new Callback&lt;TreeTableView&lt;String&gt;, TreeTableRow&lt;String&gt;&gt;() {
2688             @Override public TreeTableRow&lt;String&gt; call(TreeTableView&lt;String&gt; param) {
2689                 return new TreeTableRowShim&lt;String&gt;() {
2690                     Rectangle graphic = new Rectangle(10, 10, Color.RED);
2691                     { setGraphic(graphic); };
2692 
2693                     @Override public void updateItem(String item, boolean empty) {
2694                         super.updateItem(item, empty);
2695                         if (item == null || empty) {
2696                             graphic.setVisible(false);
2697                             setText(null);
2698                         } else {
2699                             graphic.setVisible(true);
2700                             setText(item.toString());
2701                         }
2702                     }
2703                 };
2704             }
2705         });
2706 
2707         // First two rows have content, so the graphic should show.
2708         // All other rows have no content, so graphic should not show.
2709 
2710         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    0);
2711         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    1);
2712         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    2);
2713         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    3);
2714         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 4);
2715         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 5);
2716     }
2717 
2718     private int rt_31015_count = 0;
2719     @Test public void test_rt_31015() {
2720         installChildren();
2721         root.getChildren().clear();
2722         treeTableView.setEditable(true);
2723 
2724         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2725         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2726         treeTableView.getColumns().add(col);
2727 
2728         //Set cell factory for cells that allow editing
2729         Callback&lt;TreeTableColumn&lt;String,String&gt;, TreeTableCell&lt;String, String&gt;&gt; cellFactory = new Callback&lt;TreeTableColumn&lt;String,String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2730             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; p) {
2731                 return new TreeTableCell&lt;String, String&gt;() {
2732                     @Override public void cancelEdit() {
2733                         super.cancelEdit();
2734                         rt_31015_count++;
2735                     }
2736                 };
2737             }
2738         };
2739         col.setCellFactory(cellFactory);
2740 
2741         StageLoader sl = new StageLoader(treeTableView);
2742 
2743         assertEquals(0, rt_31015_count);
2744 
2745         treeTableView.edit(0, col);
2746         assertEquals(0, rt_31015_count);
2747 
2748         treeTableView.edit(-1, null);
2749         assertEquals(1, rt_31015_count);
2750 
2751         sl.dispose();
2752     }
2753 
2754     @Test public void test_rt_30688() {
2755         installChildren();
2756         root.getChildren().clear();
2757         treeTableView.setColumnResizePolicy(TreeTableView.CONSTRAINED_RESIZE_POLICY);
2758 
2759         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2760         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2761         treeTableView.getColumns().add(col);
2762 
2763         StageLoader sl = new StageLoader(treeTableView);
2764 
2765         assertEquals(TreeTableViewShim.get_contentWidth(treeTableView),
2766                 TableColumnBaseShim.getWidth(col), 0.0);
2767 
2768         sl.dispose();
2769     }
2770 
2771     private int rt_29650_start_count = 0;
2772     private int rt_29650_commit_count = 0;
2773     private int rt_29650_cancel_count = 0;
2774     @Test public void test_rt_29650() {
2775         installChildren();
2776         treeTableView.setEditable(true);
2777 
2778         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2779         Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt; factory = TextFieldTreeTableCell.forTreeTableColumn();
2780         col.setCellFactory(factory);
2781         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2782         treeTableView.getColumns().add(col);
2783 
2784         col.setOnEditStart(t -&gt; {
2785             rt_29650_start_count++;
2786         });
2787         col.setOnEditCommit(t -&gt; {
2788             rt_29650_commit_count++;
2789         });
2790         col.setOnEditCancel(t -&gt; {
2791             rt_29650_cancel_count++;
2792         });
2793 
2794         StageLoader sl = new StageLoader(treeTableView);
2795 
2796         treeTableView.edit(0, col);
2797 
2798         Toolkit.getToolkit().firePulse();
2799 
2800         TreeTableCell rootCell = (TreeTableCell) VirtualFlowTestUtils.getCell(treeTableView, 0, 0);
2801         TextField textField = (TextField) rootCell.getGraphic();
2802         textField.setText(&quot;Testing!&quot;);
2803         KeyEventFirer keyboard = new KeyEventFirer(textField);
2804         keyboard.doKeyPress(KeyCode.ENTER);
2805 
2806         // TODO should the following assert be enabled?
2807 //        assertEquals(&quot;Testing!&quot;, listView.getItems().get(0));
2808         assertEquals(1, rt_29650_start_count);
2809         assertEquals(1, rt_29650_commit_count);
2810         assertEquals(0, rt_29650_cancel_count);
2811 
2812         sl.dispose();
2813     }
2814 
2815     private int rt_29849_start_count = 0;
2816     @Test public void test_rt_29849() {
2817         installChildren();
2818         treeTableView.setEditable(true);
2819 
2820         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2821         col.setEditable(true);
2822         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2823         treeTableView.getColumns().add(col);
2824 
2825         col.setOnEditStart(t -&gt; {
2826             rt_29849_start_count++;
2827         });
2828 
2829         // load the table so the default cells are created
2830         StageLoader sl = new StageLoader(treeTableView);
2831 
2832         // now replace the cell factory
2833         Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt; factory = TextFieldTreeTableCell.forTreeTableColumn();
2834         col.setCellFactory(factory);
2835 
2836         Toolkit.getToolkit().firePulse();
2837 
2838         // now start an edit and count the start edit events - it should be just 1
2839         treeTableView.edit(0, col);
2840         assertEquals(1, rt_29849_start_count);
2841 
2842         sl.dispose();
2843     }
2844 
2845     @Test public void test_rt_34327() {
2846         // by default the comparator is null.
2847         // NOTE: this method (prior to the fix as part of RT-34327) would have
2848         // returned Comparator&lt;String&gt;, but after the fix it correctly returns
2849         // a Comparator&lt;TreeItem&lt;String&gt;&gt;
2850         Comparator nonGenericComparator = treeTableView.getComparator();
2851         Comparator&lt;TreeItem&lt;String&gt;&gt; genericComparator = treeTableView.getComparator();
2852         assertNull(nonGenericComparator);
2853         assertNull(genericComparator);
2854 
2855         // add in a column and some data
2856         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2857         col.setEditable(true);
2858         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2859         treeTableView.getColumns().add(col);
2860 
2861         installChildren();
2862 
2863         // sort by that column
2864         treeTableView.getSortOrder().add(col);
2865 
2866         // get the new comparator, which should no longer be null
2867         nonGenericComparator = treeTableView.getComparator();
2868         genericComparator = treeTableView.getComparator();
2869         assertNotNull(nonGenericComparator);
2870         assertNotNull(genericComparator);
2871 
2872         // now, as noted above, previously we would use the Comparator to compare
2873         // two String instances, which would fail at runtime as the Comparator
2874         // was actually expecting to compare two TreeItem&lt;String&gt;, but the API
2875         // was failing us.
2876         try {
2877             nonGenericComparator.compare(&quot;abc&quot;, &quot;def&quot;);
2878             fail(&quot;This should not work!&quot;);
2879         } catch (ClassCastException e) {
2880             // if we get the exception, we&#39;re happy
2881         }
2882 
2883         try {
2884             Object string1 = &quot;abc&quot;;
2885             Object string2 = &quot;def&quot;;
2886             genericComparator.compare((TreeItem&lt;String&gt;)string1, (TreeItem&lt;String&gt;)string2);
2887             fail(&quot;This should not work!&quot;);
2888         } catch (ClassCastException e) {
2889             // if we get the exception, we&#39;re happy
2890         }
2891     }
2892 
2893     @Test public void test_rt26718() {
2894         treeTableView.setRoot(new TreeItem(&quot;Root&quot;));
2895         treeTableView.getRoot().setExpanded(true);
2896 
2897         for (int i = 0; i &lt; 4; i++) {
2898             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2899             treeTableView.getRoot().getChildren().add(parent);
2900 
2901             for (int j = 0; j &lt; 4; j++) {
2902                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2903                 parent.getChildren().add(child);
2904             }
2905         }
2906 
2907         treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2908 
2909         final TreeItem item0 = treeTableView.getTreeItem(1);
2910         final TreeItem item1 = treeTableView.getTreeItem(2);
2911 
2912         assertEquals(&quot;item - 0&quot;, item0.getValue());
2913         assertEquals(&quot;item - 1&quot;, item1.getValue());
2914 
2915         item0.setExpanded(true);
2916         item1.setExpanded(true);
2917         Toolkit.getToolkit().firePulse();
2918 
2919         treeTableView.getSelectionModel().selectRange(0, 8);
2920         assertEquals(8, treeTableView.getSelectionModel().getSelectedIndices().size());
2921         assertEquals(7, treeTableView.getSelectionModel().getSelectedIndex());
2922         assertEquals(7, treeTableView.getFocusModel().getFocusedIndex());
2923 
2924         // collapse item0 - but because the selected and focused indices are
2925         // not children of item 0, they should remain where they are (but of
2926         // course be shifted up). The bug was that focus was moving up to item0,
2927         // which makes no sense
2928         item0.setExpanded(false);
2929         Toolkit.getToolkit().firePulse();
2930         assertEquals(3, treeTableView.getSelectionModel().getSelectedIndex());
2931         assertEquals(3, treeTableView.getFocusModel().getFocusedIndex());
2932     }
2933 
2934 //    @Ignore(&quot;Test started intermittently failing, most probably due to RT-36855 changeset&quot;)
2935     @Test public void test_rt_34493() {
2936         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
2937             new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;))
2938         );
2939 
2940         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
2941 
2942         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
2943         root.setExpanded(true);
2944         table.setRoot(root);
2945         table.setShowRoot(false);
2946         root.getChildren().setAll(persons);
2947 
2948         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
2949         first.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
2950 
2951         TreeTableColumn last = new TreeTableColumn(&quot;Last Name&quot;);
2952         last.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
2953 
2954         TreeTableColumn email = new TreeTableColumn(&quot;Email&quot;);
2955         email.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
2956 
2957         table.getColumns().addAll(first, last, email);
2958 
2959         // load the table
2960         StageLoader sl = new StageLoader(table);
2961 
2962         // resize the last column
2963         TableColumnBaseHelper.setWidth(last, 400);
2964         assertEquals(400, last.getWidth(), 0.0);
2965 
2966         // hide the first column
2967         table.getColumns().remove(first);
2968         Toolkit.getToolkit().firePulse();
2969 
2970         // the last column should still be 400px, not the default width or any
2971         // other value (based on the width of the content in that column)
2972         assertEquals(400, last.getWidth(), 0.0);
2973 
2974         sl.dispose();
2975     }
2976 
2977     @Test public void test_rt26721_collapseParent_firstRootChild() {
2978         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
2979         table.setRoot(new TreeItem(&quot;Root&quot;));
2980         table.getRoot().setExpanded(true);
2981 
2982         for (int i = 0; i &lt; 4; i++) {
2983             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2984             table.getRoot().getChildren().add(parent);
2985 
2986             for (int j = 0; j &lt; 4; j++) {
2987                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2988                 parent.getChildren().add(child);
2989             }
2990         }
2991 
2992         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2993 
2994         final TreeItem&lt;String&gt; item0 = table.getTreeItem(1);
2995         final TreeItem&lt;String&gt; item0child0 = item0.getChildren().get(0);
2996         final TreeItem&lt;String&gt; item1 = table.getTreeItem(2);
2997 
2998         assertEquals(&quot;item - 0&quot;, item0.getValue());
2999         assertEquals(&quot;item - 1&quot;, item1.getValue());
3000 
3001         item0.setExpanded(true);
3002         item1.setExpanded(true);
3003         Toolkit.getToolkit().firePulse();
3004 
3005         // select the first child of item0
3006         table.getSelectionModel().select(item0child0);
3007 
3008         assertEquals(item0child0, table.getSelectionModel().getSelectedItem());
3009         assertEquals(item0child0, table.getFocusModel().getFocusedItem());
3010 
3011         // collapse item0 - we expect the selection / focus to move up to item0
3012         item0.setExpanded(false);
3013         Toolkit.getToolkit().firePulse();
3014         assertEquals(item0, table.getSelectionModel().getSelectedItem());
3015         assertEquals(item0, table.getFocusModel().getFocusedItem());
3016     }
3017 
3018     @Test public void test_rt26721_collapseParent_lastRootChild() {
3019         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3020         table.setRoot(new TreeItem(&quot;Root&quot;));
3021         table.getRoot().setExpanded(true);
3022 
3023         for (int i = 0; i &lt; 4; i++) {
3024             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
3025             table.getRoot().getChildren().add(parent);
3026 
3027             for (int j = 0; j &lt; 4; j++) {
3028                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
3029                 parent.getChildren().add(child);
3030             }
3031         }
3032 
3033         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
3034 
3035         final TreeItem&lt;String&gt; item3 = table.getTreeItem(4);
3036         final TreeItem&lt;String&gt; item3child0 = item3.getChildren().get(0);
3037 
3038         assertEquals(&quot;item - 3&quot;, item3.getValue());
3039         assertEquals(&quot;item - 3 0&quot;, item3child0.getValue());
3040 
3041         item3.setExpanded(true);
3042         Toolkit.getToolkit().firePulse();
3043 
3044         // select the first child of item0
3045         table.getSelectionModel().select(item3child0);
3046 
3047         assertEquals(item3child0, table.getSelectionModel().getSelectedItem());
3048         assertEquals(item3child0, table.getFocusModel().getFocusedItem());
3049 
3050         // collapse item3 - we expect the selection / focus to move up to item3
3051         item3.setExpanded(false);
3052         Toolkit.getToolkit().firePulse();
3053         assertEquals(item3, table.getSelectionModel().getSelectedItem());
3054         assertEquals(item3, table.getFocusModel().getFocusedItem());
3055     }
3056 
3057     @Test public void test_rt26721_collapseGrandParent() {
3058         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3059         table.setRoot(new TreeItem(&quot;Root&quot;));
3060         table.getRoot().setExpanded(true);
3061 
3062         for (int i = 0; i &lt; 4; i++) {
3063             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
3064             table.getRoot().getChildren().add(parent);
3065 
3066             for (int j = 0; j &lt; 4; j++) {
3067                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
3068                 parent.getChildren().add(child);
3069             }
3070         }
3071 
3072         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
3073 
3074         final TreeItem&lt;String&gt; item0 = table.getTreeItem(1);
3075         final TreeItem&lt;String&gt; item0child0 = item0.getChildren().get(0);
3076         final TreeItem&lt;String&gt; item1 = table.getTreeItem(2);
3077 
3078         assertEquals(&quot;item - 0&quot;, item0.getValue());
3079         assertEquals(&quot;item - 1&quot;, item1.getValue());
3080 
3081         item0.setExpanded(true);
3082         item1.setExpanded(true);
3083         Toolkit.getToolkit().firePulse();
3084 
3085         // select the first child of item0
3086         table.getSelectionModel().select(item0child0);
3087 
3088         assertEquals(item0child0, table.getSelectionModel().getSelectedItem());
3089         assertEquals(item0child0, table.getFocusModel().getFocusedItem());
3090 
3091         // collapse root - we expect the selection / focus to move up to root
3092         table.getRoot().setExpanded(false);
3093         Toolkit.getToolkit().firePulse();
3094         assertEquals(table.getRoot(), table.getSelectionModel().getSelectedItem());
3095         assertEquals(table.getRoot(), table.getFocusModel().getFocusedItem());
3096     }
3097 
3098     @Test public void test_rt_34685_directEditCall_cellSelectionMode() {
3099         test_rt_34685_commitCount = 0;
3100         test_rt_34685(false, true);
3101     }
3102 
3103     @Test public void test_rt_34685_directEditCall_rowSelectionMode() {
3104         test_rt_34685_commitCount = 0;
3105         test_rt_34685(false, false);
3106     }
3107 
3108     @Test public void test_rt_34685_mouseDoubleClick_cellSelectionMode() {
3109         test_rt_34685_commitCount = 0;
3110         test_rt_34685(true, true);
3111     }
3112 
3113     @Test public void test_rt_34685_mouseDoubleClick_rowSelectionMode() {
3114         test_rt_34685_commitCount = 0;
3115         test_rt_34685(true, false);
3116     }
3117 
3118     private int test_rt_34685_commitCount = 0;
3119     private void test_rt_34685(boolean useMouseToInitiateEdit, boolean cellSelectionModeEnabled) {
3120         assertEquals(0, test_rt_34685_commitCount);
3121 
3122         Person person1;
3123         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
3124             new TreeItem&lt;&gt;(person1 = new Person(&quot;John&quot;, &quot;Smith&quot;, &quot;john.smith@example.com&quot;))
3125         );
3126 
3127         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
3128         table.getSelectionModel().setCellSelectionEnabled(cellSelectionModeEnabled);
3129         table.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
3130         table.setEditable(true);
3131 
3132         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
3133         root.setExpanded(true);
3134         table.setRoot(root);
3135         table.setShowRoot(false);
3136         root.getChildren().setAll(persons);
3137 
3138         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
3139         first.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
3140         first.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
3141 
3142         EventHandler&lt;TreeTableColumn.CellEditEvent&lt;Person, String&gt;&gt; onEditCommit = first.getOnEditCommit();
3143         first.setOnEditCommit(new EventHandler&lt;TreeTableColumn.CellEditEvent&lt;Person, String&gt;&gt;() {
3144             @Override public void handle(TreeTableColumn.CellEditEvent&lt;Person, String&gt; event) {
3145                 test_rt_34685_commitCount++;
3146                 onEditCommit.handle(event);
3147             }
3148         });
3149 
3150         table.getColumns().addAll(first);
3151 
3152         // get the cell at (0,0) - we&#39;re hiding the root row
3153         VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = true;
3154         TreeTableCell cell = (TreeTableCell) VirtualFlowTestUtils.getCell(table, 0, 0);
3155         VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = false;
3156         assertTrue(cell.getSkin() instanceof TreeTableCellSkin);
3157         assertNull(cell.getGraphic());
3158         assertEquals(&quot;John&quot;, cell.getText());
3159         assertEquals(&quot;John&quot;, person1.getFirstName());
3160 
3161         // set the table to be editing the first cell at 0,0
3162         if (useMouseToInitiateEdit) {
3163             MouseEventFirer mouse = new MouseEventFirer(cell);
3164             mouse.fireMousePressAndRelease(2, 10, 10);  // click 10 pixels in and 10 pixels down
3165             mouse.dispose();
3166         } else {
3167             table.edit(0,first);
3168         }
3169 
3170         Toolkit.getToolkit().firePulse();
3171         assertNotNull(cell.getGraphic());
3172         assertTrue(cell.getGraphic() instanceof TextField);
3173 
3174         TextField textField = (TextField) cell.getGraphic();
3175         assertEquals(&quot;John&quot;, textField.getText());
3176 
3177         textField.setText(&quot;Andrew&quot;);
3178         textField.requestFocus();
3179         Toolkit.getToolkit().firePulse();
3180 
3181         KeyEventFirer keyboard = new KeyEventFirer(textField);
3182         keyboard.doKeyPress(KeyCode.ENTER);
3183 
3184         VirtualFlowTestUtils.getVirtualFlow(table).requestLayout();
3185         Toolkit.getToolkit().firePulse();
3186 
3187         VirtualFlowTestUtils.assertTableCellTextEquals(table, 0, 0, &quot;Andrew&quot;);
3188         assertEquals(&quot;Andrew&quot;, cell.getText());
3189         assertEquals(&quot;Andrew&quot;, person1.getFirstName());
3190         assertEquals(1, test_rt_34685_commitCount);
3191     }
3192 
3193     @Test public void test_rt34694() {
3194         TreeItem treeNode = new TreeItem(&quot;Controls&quot;);
3195         treeNode.getChildren().addAll(
3196                 new TreeItem(&quot;Button&quot;),
3197                 new TreeItem(&quot;ButtonBar&quot;),
3198                 new TreeItem(&quot;LinkBar&quot;),
3199                 new TreeItem(&quot;LinkButton&quot;),
3200                 new TreeItem(&quot;PopUpButton&quot;),
3201                 new TreeItem(&quot;ToggleButtonBar&quot;)
3202         );
3203 
3204         final TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3205         table.setRoot(treeNode);
3206         treeNode.setExpanded(true);
3207 
3208         table.getSelectionModel().select(0);
3209         assertTrue(table.getSelectionModel().isSelected(0));
3210         assertTrue(table.getFocusModel().isFocused(0));
3211 
3212         treeNode.getChildren().clear();
3213         treeNode.getChildren().addAll(
3214                 new TreeItem(&quot;Button1&quot;),
3215                 new TreeItem(&quot;ButtonBar1&quot;),
3216                 new TreeItem(&quot;LinkBar1&quot;),
3217                 new TreeItem(&quot;LinkButton1&quot;),
3218                 new TreeItem(&quot;PopUpButton1&quot;),
3219                 new TreeItem(&quot;ToggleButtonBar1&quot;)
3220         );
3221         Toolkit.getToolkit().firePulse();
3222 
3223         assertTrue(table.getSelectionModel().isSelected(0));
3224         assertTrue(table.getFocusModel().isFocused(0));
3225     }
3226 
3227     private int test_rt_35213_eventCount = 0;
3228     @Test public void test_rt35213() {
3229         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;();
3230 
3231         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Boss&quot;);
3232         view.setRoot(root);
3233 
3234         TreeItem&lt;String&gt; group1 = new TreeItem&lt;&gt;(&quot;Group 1&quot;);
3235         TreeItem&lt;String&gt; group2 = new TreeItem&lt;&gt;(&quot;Group 2&quot;);
3236         TreeItem&lt;String&gt; group3 = new TreeItem&lt;&gt;(&quot;Group 3&quot;);
3237 
3238         root.getChildren().addAll(group1, group2, group3);
3239 
3240         TreeItem&lt;String&gt; employee1 = new TreeItem&lt;&gt;(&quot;Employee 1&quot;);
3241         TreeItem&lt;String&gt; employee2 = new TreeItem&lt;&gt;(&quot;Employee 2&quot;);
3242 
3243         group2.getChildren().addAll(employee1, employee2);
3244 
3245         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;Name&quot;);
3246         nameColumn.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
3247         view.getColumns().add(nameColumn);
3248 
3249         view.expandedItemCountProperty().addListener((observableValue, oldCount, newCount) -&gt; {
3250 
3251             // DEBUG OUTPUT
3252 //                System.out.println(&quot;new expanded item count: &quot; + newCount.intValue());
3253 //                for (int i = 0; i &lt; newCount.intValue(); i++) {
3254 //                    TreeItem&lt;String&gt; item = view.getTreeItem(i);
3255 //                    String text = item.getValue();
3256 //                    System.out.println(&quot;person found at index &quot; + i + &quot; is &quot; + text);
3257 //                }
3258 //                System.out.println(&quot;------------------------------------------&quot;);
3259 
3260             if (test_rt_35213_eventCount == 0) {
3261                 assertEquals(4, newCount);
3262                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3263                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3264                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3265                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(3).getValue());
3266             } else if (test_rt_35213_eventCount == 1) {
3267                 assertEquals(6, newCount);
3268                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3269                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3270                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3271                 assertEquals(&quot;Employee 1&quot;, view.getTreeItem(3).getValue());
3272                 assertEquals(&quot;Employee 2&quot;, view.getTreeItem(4).getValue());
3273                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(5).getValue());
3274             } else if (test_rt_35213_eventCount == 2) {
3275                 assertEquals(4, newCount);
3276                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3277                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3278                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3279                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(3).getValue());
3280             }
3281 
3282             test_rt_35213_eventCount++;
3283         });
3284 
3285         StageLoader sl = new StageLoader(view);
3286 
3287         root.setExpanded(true);
3288         Toolkit.getToolkit().firePulse();
3289 
3290         group2.setExpanded(true);
3291         Toolkit.getToolkit().firePulse();
3292 
3293         group2.setExpanded(false);
3294         Toolkit.getToolkit().firePulse();
3295 
3296         sl.dispose();
3297     }
3298 
3299     @Test public void test_rt23245_itemIsInTree() {
3300         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;String&gt;();
3301         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3302         for (int i = 0; i &lt; 10; i++) {
3303             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3304             item.setExpanded(true);
3305             items.add(item);
3306         }
3307 
3308         // link the items up so that the next item is the child of the current item
3309         for (int i = 0; i &lt; 9; i++) {
3310             items.get(i).getChildren().add(items.get(i + 1));
3311         }
3312 
3313         view.setRoot(items.get(0));
3314 
3315         for (int i = 0; i &lt; 10; i++) {
3316             // we expect the level of the tree item at the ith position to be
3317             // 0, as every iteration we are setting the ith item as the root.
3318             assertEquals(0, view.getTreeItemLevel(items.get(i)));
3319 
3320             // whilst we are testing, we should also ensure that the ith item
3321             // is indeed the root item, and that the ith item is indeed the item
3322             // at the 0th position
3323             assertEquals(items.get(i), view.getRoot());
3324             assertEquals(items.get(i), view.getTreeItem(0));
3325 
3326             // shuffle the next item into the root position (keeping its parent
3327             // chain intact - which is what exposes this issue in the first place).
3328             if (i &lt; 9) {
3329                 view.setRoot(items.get(i + 1));
3330             }
3331         }
3332     }
3333 
3334     @Test public void test_rt23245_itemIsNotInTree_noRootNode() {
3335         final TreeView&lt;String&gt; view = new TreeView&lt;String&gt;();
3336         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3337         for (int i = 0; i &lt; 10; i++) {
3338             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3339             item.setExpanded(true);
3340             items.add(item);
3341         }
3342 
3343         // link the items up so that the next item is the child of the current item
3344         for (int i = 0; i &lt; 9; i++) {
3345             items.get(i).getChildren().add(items.get(i + 1));
3346         }
3347 
3348         for (int i = 0; i &lt; 10; i++) {
3349             // because we have no root (and we are not changing the root like
3350             // the previous test), we expect the tree item level of the item
3351             // in the ith position to be i.
3352             assertEquals(i, view.getTreeItemLevel(items.get(i)));
3353 
3354             // all items requested from the TreeView should be null, as the
3355             // TreeView does not have a root item
3356             assertNull(view.getTreeItem(i));
3357         }
3358     }
3359 
3360     @Test public void test_rt23245_itemIsNotInTree_withUnrelatedRootNode() {
3361         final TreeView&lt;String&gt; view = new TreeView&lt;String&gt;();
3362         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3363         for (int i = 0; i &lt; 10; i++) {
3364             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3365             item.setExpanded(true);
3366             items.add(item);
3367         }
3368 
3369         // link the items up so that the next item is the child of the current item
3370         for (int i = 0; i &lt; 9; i++) {
3371             items.get(i).getChildren().add(items.get(i + 1));
3372         }
3373 
3374         view.setRoot(new TreeItem(&quot;Unrelated root node&quot;));
3375 
3376         for (int i = 0; i &lt; 10; i++) {
3377             // because we have no root (and we are not changing the root like
3378             // the previous test), we expect the tree item level of the item
3379             // in the ith position to be i.
3380             assertEquals(i, view.getTreeItemLevel(items.get(i)));
3381 
3382             // all items requested from the TreeView should be null except for
3383             // the root node
3384             assertNull(view.getTreeItem(i + 1));
3385         }
3386     }
3387 
3388     @Test public void test_rt35039_setRoot() {
3389         TreeItem aabbaa = new TreeItem(&quot;aabbaa&quot;);
3390         TreeItem bbc = new TreeItem(&quot;bbc&quot;);
3391 
3392         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3393         root.setExpanded(true);
3394         root.getChildren().setAll(aabbaa, bbc);
3395 
3396         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3397         treeView.setRoot(root);
3398 
3399         StageLoader sl = new StageLoader(treeView);
3400 
3401         // Selection starts in row -1
3402         assertNull(treeView.getSelectionModel().getSelectedItem());
3403 
3404         // select &quot;bbc&quot; and ensure everything is set to that
3405         treeView.getSelectionModel().select(2);
3406         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3407 
3408         // change the items list - but retain the same content. We expect
3409         // that &quot;bbc&quot; remains selected as it is still in the list
3410         treeView.setRoot(root);
3411         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3412 
3413         sl.dispose();
3414     }
3415 
3416     @Test public void test_rt35039_resetRootChildren() {
3417         TreeItem aabbaa = new TreeItem(&quot;aabbaa&quot;);
3418         TreeItem bbc = new TreeItem(&quot;bbc&quot;);
3419 
3420         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3421         root.setExpanded(true);
3422         root.getChildren().setAll(aabbaa, bbc);
3423 
3424         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3425         treeView.setRoot(root);
3426 
3427         StageLoader sl = new StageLoader(treeView);
3428 
3429         // Selection starts in row -1
3430         assertNull(treeView.getSelectionModel().getSelectedItem());
3431 
3432         // select &quot;bbc&quot; and ensure everything is set to that
3433         treeView.getSelectionModel().select(2);
3434         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3435 
3436         // change the items list - but retain the same content. We expect
3437         // that &quot;bbc&quot; remains selected as it is still in the list
3438         root.getChildren().setAll(aabbaa, bbc);
3439         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3440 
3441         sl.dispose();
3442     }
3443 
3444     @Test public void test_rt35763() {
3445         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3446         root.setExpanded(true);
3447         TreeItem aaa = new TreeItem(&quot;aaa&quot;);
3448         TreeItem bbb = new TreeItem(&quot;bbb&quot;);
3449         root.getChildren().setAll(bbb, aaa);
3450 
3451         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3452 
3453         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3454         col.setCellValueFactory(param -&gt; param.getValue().valueProperty());
3455 
3456         treeView.getColumns().add(col);
3457         treeView.setRoot(root);
3458 
3459         assertEquals(root, treeView.getTreeItem(0));
3460         assertEquals(bbb, treeView.getTreeItem(1));
3461         assertEquals(aaa,treeView.getTreeItem(2));
3462 
3463         // change sort order - expect items to be sorted
3464         treeView.getSortOrder().setAll(col);
3465 
3466         assertEquals(1, treeView.getSortOrder().size());
3467         assertEquals(col, treeView.getSortOrder().get(0));
3468 
3469         Toolkit.getToolkit().firePulse();
3470 
3471         assertEquals(root, treeView.getTreeItem(0));
3472         assertEquals(bbb, treeView.getTreeItem(2));
3473         assertEquals(aaa,treeView.getTreeItem(1));
3474 
3475         // set new items into items list - expect sortOrder list to be reset
3476         // and the items list to remain unsorted
3477         TreeItem&lt;String&gt; root2 = new TreeItem&lt;&gt;(&quot;Root&quot;);
3478         root2.setExpanded(true);
3479         TreeItem ccc = new TreeItem(&quot;ccc&quot;);
3480         TreeItem ddd = new TreeItem(&quot;ddd&quot;);
3481         root2.getChildren().setAll(ddd, ccc);
3482         treeView.setRoot(root2);
3483 
3484         assertEquals(root2, treeView.getTreeItem(0));
3485         assertEquals(ddd, treeView.getTreeItem(1));
3486         assertEquals(ccc,treeView.getTreeItem(2));
3487 
3488         assertTrue(treeView.getSortOrder().isEmpty());
3489     }
3490 
3491     @Test public void test_rt35857() {
3492         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3493         root.setExpanded(true);
3494         TreeItem a = new TreeItem(&quot;A&quot;);
3495         TreeItem b = new TreeItem(&quot;B&quot;);
3496         TreeItem c = new TreeItem(&quot;C&quot;);
3497         root.getChildren().setAll(a, b, c);
3498 
3499         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;String&gt;(root);
3500 
3501         treeTableView.getSelectionModel().select(1);
3502 
3503         ObservableList&lt;TreeItem&lt;String&gt;&gt; selectedItems = treeTableView.getSelectionModel().getSelectedItems();
3504         assertEquals(1, selectedItems.size());
3505         assertEquals(&quot;A&quot;, selectedItems.get(0).getValue());
3506 
3507         root.getChildren().removeAll(selectedItems);
3508         assertEquals(2, root.getChildren().size());
3509         assertEquals(&quot;B&quot;, root.getChildren().get(0).getValue());
3510         assertEquals(&quot;C&quot;, root.getChildren().get(1).getValue());
3511     }
3512 
3513     private int rt36452_instanceCount = 0;
3514     @Test public void test_rt36452() {
3515         TreeTableColumn&lt;String, String&gt; myColumn = new TreeTableColumn&lt;String,String&gt;();
3516         myColumn.setCellValueFactory((item)-&gt;(new ReadOnlyObjectWrapper&lt;&gt;(item.getValue().getValue())));
3517         myColumn.setCellFactory(column -&gt; new TreeTableCell&lt;String, String&gt;() {
3518             {
3519                 rt36452_instanceCount++;
3520             }
3521         });
3522 
3523         TreeTableView&lt;String&gt; ttv = new TreeTableView&lt;&gt;();
3524         ttv.setShowRoot(false);
3525         ttv.getColumns().add(myColumn);
3526 
3527         TreeItem&lt;String&gt; treeRootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
3528         treeRootItem.setExpanded(true);
3529 
3530         for (int i = 0; i &lt; 100; i++) {
3531             treeRootItem.getChildren().add(new TreeItem&lt;&gt;(&quot;Child: &quot; + i));
3532         }
3533 
3534         ttv.setRoot(treeRootItem);
3535         ttv.setFixedCellSize(25);
3536 
3537         StackPane root = new StackPane();
3538         root.getChildren().add(ttv);
3539 
3540         StageLoader sl = new StageLoader(root);
3541 
3542         final int cellCountAtStart = rt36452_instanceCount;
3543 
3544         // start scrolling
3545         for (int i = 0; i &lt; 100; i++) {
3546             ttv.scrollTo(i);
3547             Toolkit.getToolkit().firePulse();
3548         }
3549 
3550         // we don&#39;t mind if an extra few cells are created. What we are really
3551         // testing for here is that we don&#39;t end up with an order of magnitude
3552         // extra cells.
3553         // On my machine the cellCountAtStart is 16. Before this issue was fixed
3554         // I would end up with 102 instances after running this test. Once the
3555         // bug was fixed, I would consistently see that 17 cells had been
3556         // created in total.
3557         // However, for now, we&#39;ll test on the assumption that across all
3558         // platforms we only get one extra cell created, and we can loosen this
3559         // up if necessary.
3560         assertEquals(cellCountAtStart + 1, rt36452_instanceCount);
3561 
3562         sl.dispose();
3563     }
3564 
3565     @Test public void test_rt25679_rowSelection() {
3566         test_rt25679(true);
3567     }
3568 
3569     @Test public void test_rt25679_cellSelection() {
3570         test_rt25679(false);
3571     }
3572 
3573     private void test_rt25679(boolean rowSelection) {
3574         Button focusBtn = new Button(&quot;Focus here&quot;);
3575 
3576         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3577         root.getChildren().setAll(new TreeItem(&quot;a&quot;), new TreeItem(&quot;b&quot;));
3578         root.setExpanded(true);
3579 
3580         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
3581         TreeTableColumn&lt;String, String&gt; tableColumn = new TreeTableColumn&lt;&gt;();
3582         tableColumn.setCellValueFactory(rowValue -&gt; new SimpleStringProperty(rowValue.getValue().getValue()));
3583         treeView.getColumns().add(tableColumn);
3584 
3585         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = treeView.getSelectionModel();
3586         sm.setCellSelectionEnabled(! rowSelection);
3587 
3588         VBox vbox = new VBox(focusBtn, treeView);
3589 
3590         StageLoader sl = new StageLoader(vbox);
3591         sl.getStage().requestFocus();
3592         focusBtn.requestFocus();
3593         Toolkit.getToolkit().firePulse();
3594 
3595         // test initial state
3596         assertEquals(sl.getStage().getScene().getFocusOwner(), focusBtn);
3597         assertTrue(focusBtn.isFocused());
3598         assertEquals(-1, sm.getSelectedIndex());
3599         assertNull(sm.getSelectedItem());
3600 
3601         // move focus to the TreeTableView
3602         treeView.requestFocus();
3603 
3604         // ensure that there is a selection (where previously there was not one)
3605         assertEquals(sl.getStage().getScene().getFocusOwner(), treeView);
3606         assertTrue(treeView.isFocused());
3607 
3608         if (rowSelection) {
3609             assertEquals(0, sm.getSelectedIndices().size());
3610             assertNull(sm.getSelectedItem());
3611             assertFalse(sm.isSelected(0));
3612             assertEquals(0, sm.getSelectedCells().size());
3613         } else {
3614             assertFalse(sm.isSelected(0, tableColumn));
3615             assertEquals(0, sm.getSelectedCells().size());
3616         }
3617 
3618         sl.dispose();
3619     }
3620 
3621     @Test public void test_rt36885() {
3622         test_rt36885(false);
3623     }
3624 
3625     @Test public void test_rt36885_addChildAfterSelection() {
3626         test_rt36885(true);
3627     }
3628 
3629     private void test_rt36885(boolean addChildToAAfterSelection) {
3630         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);         // 0
3631                 TreeItem&lt;String&gt; a = new TreeItem&lt;&gt;(&quot;a&quot;);       // 1
3632                     TreeItem&lt;String&gt; a1 = new TreeItem&lt;&gt;(&quot;a1&quot;); // a expanded = 2, a collapsed = -1
3633             TreeItem&lt;String&gt; b = new TreeItem&lt;&gt;(&quot;b&quot;);           // a expanded = 3, a collapsed = 2
3634                 TreeItem&lt;String&gt; b1 = new TreeItem&lt;&gt;(&quot;b1&quot;);     // a expanded = 4, a collapsed = 3
3635                 TreeItem&lt;String&gt; b2 = new TreeItem&lt;&gt;(&quot;b2&quot;);     // a expanded = 5, a collapsed = 4
3636 
3637         root.setExpanded(true);
3638         root.getChildren().setAll(a, b);
3639 
3640         a.setExpanded(false);
3641         if (!addChildToAAfterSelection) {
3642             a.getChildren().add(a1);
3643         }
3644 
3645         b.setExpanded(true);
3646         b.getChildren().addAll(b1, b2);
3647 
3648         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
3649         TreeTableColumn&lt;String, String&gt; tableColumn = new TreeTableColumn&lt;&gt;();
3650         tableColumn.setCellValueFactory(rowValue -&gt; new SimpleStringProperty(rowValue.getValue().getValue()));
3651         treeView.getColumns().add(tableColumn);
3652 
3653         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = treeView.getSelectionModel();
3654         FocusModel&lt;TreeItem&lt;String&gt;&gt; fm = treeView.getFocusModel();
3655 
3656         sm.select(b1);
3657         assertEquals(3, sm.getSelectedIndex());
3658         assertEquals(b1, sm.getSelectedItem());
3659         assertEquals(3, fm.getFocusedIndex());
3660         assertEquals(b1, fm.getFocusedItem());
3661 
3662         if (addChildToAAfterSelection) {
3663             a.getChildren().add(a1);
3664         }
3665 
3666         a.setExpanded(true);
3667         assertEquals(4, sm.getSelectedIndex());
3668         assertEquals(b1, sm.getSelectedItem());
3669         assertEquals(4, fm.getFocusedIndex());
3670         assertEquals(b1, fm.getFocusedItem());
3671     }
3672 
3673     private int rt_37061_index_counter = 0;
3674     private int rt_37061_item_counter = 0;
3675     @Test public void test_rt_37061() {
3676         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
3677         root.setExpanded(true);
3678         TreeTableView&lt;Integer&gt; tv = new TreeTableView&lt;&gt;();
3679         tv.setRoot(root);
3680         tv.getSelectionModel().select(0);
3681 
3682         // note we add the listeners after the selection is made, so the counters
3683         // at this point are still both at zero.
3684         tv.getSelectionModel().selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; {
3685             rt_37061_index_counter++;
3686         });
3687 
3688         tv.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; {
3689             rt_37061_item_counter++;
3690         });
3691 
3692         // add a new item. This does not impact the selected index or selected item
3693         // so the counters should remain at zero.
3694         tv.getRoot().getChildren().add(new TreeItem(&quot;1&quot;));
3695         assertEquals(0, rt_37061_index_counter);
3696         assertEquals(0, rt_37061_item_counter);
3697     }
3698 
3699     @Test public void test_rt_37054_noScroll() {
3700         test_rt_37054(false);
3701     }
3702 
3703     @Test public void test_rt_37054_scroll() {
3704         test_rt_37054(true);
3705     }
3706 
3707     private void test_rt_37054(boolean scroll) {
3708         ObjectProperty&lt;Integer&gt; offset = new SimpleObjectProperty&lt;Integer&gt;(0);
3709 
3710         // create table with a bunch of rows and 1 column...
3711         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
3712         root.setExpanded(true);
3713         for (int i = 1; i &lt;= 50; i++) {
3714             root.getChildren().add(new TreeItem&lt;&gt;(i));
3715         }
3716 
3717         final TreeTableColumn&lt;Integer, Integer&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3718 
3719         final TreeTableView&lt;Integer&gt; table = new TreeTableView&lt;&gt;(root);
3720         table.getColumns().add( column );
3721         column.setPrefWidth( 150 );
3722 
3723         // each cell displays x, where x = &quot;cell row number + offset&quot;
3724         column.setCellValueFactory( cdf -&gt; new ObjectBinding&lt;Integer&gt;() {
3725             { super.bind( offset ); }
3726 
3727             @Override protected Integer computeValue() {
3728                 return cdf.getValue().getValue() + offset.get();
3729             }
3730         });
3731 
3732         StackPane stack = new StackPane();
3733         stack.getChildren().add(table);
3734         StageLoader sl = new StageLoader(stack);
3735 
3736         int index = scroll ? 0 : 25;
3737 
3738         if (scroll) {
3739             // we scroll to force the table cells to update the objects they observe
3740             table.scrollTo(index);
3741             Toolkit.getToolkit().firePulse();
3742         }
3743 
3744         TreeTableCell cell = (TreeTableCell) VirtualFlowTestUtils.getCell(table, index + 3, 0);
3745         final int initialValue = (Integer) cell.getItem();
3746 
3747         // increment the offset value
3748         offset.setValue(offset.get() + 1);
3749         Toolkit.getToolkit().firePulse();
3750 
3751         final int incrementedValue = (Integer) cell.getItem();
3752         assertEquals(initialValue + 1, incrementedValue);
3753 
3754         sl.dispose();
3755     }
3756 
3757     private int rt_37395_index_addCount = 0;
3758     private int rt_37395_index_removeCount = 0;
3759     private int rt_37395_index_permutationCount = 0;
3760     private int rt_37395_item_addCount = 0;
3761     private int rt_37395_item_removeCount = 0;
3762     private int rt_37395_item_permutationCount = 0;
3763 
3764     @Test public void test_rt_37395() {
3765         // table items - 3 items, 2nd item has 2 children
3766         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3767 
3768         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
3769         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
3770         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
3771 
3772         root.getChildren().add(new TreeItem&lt;&gt;(&quot;one&quot;));
3773         root.getChildren().add(two);
3774         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
3775 
3776         // table columns - 1 column; name
3777         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3778         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3779         nameColumn.setPrefWidth(200);
3780 
3781         // table
3782         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3783         table.setShowRoot(false);
3784         table.setRoot(root);
3785         table.getColumns().addAll(nameColumn);
3786 
3787         TreeTableView.TreeTableViewSelectionModel sm = table.getSelectionModel();
3788         sm.getSelectedIndices().addListener(new ListChangeListener&lt;Integer&gt;() {
3789             @Override public void onChanged(Change&lt;? extends Integer&gt; c) {
3790                 while (c.next()) {
3791                     if (c.wasRemoved()) {
3792                         c.getRemoved().forEach(item -&gt; {
3793                             if (item == null) {
3794                                 fail(&quot;Removed index should never be null&quot;);
3795                             } else {
3796                                 rt_37395_index_removeCount++;
3797                             }
3798                         });
3799                     }
3800                     if (c.wasAdded()) {
3801                         c.getAddedSubList().forEach(item -&gt; {
3802                             rt_37395_index_addCount++;
3803                         });
3804                     }
3805                     if (c.wasPermutated()) {
3806                         rt_37395_index_permutationCount++;
3807                     }
3808                 }
3809             }
3810         });
3811         sm.getSelectedItems().addListener(new ListChangeListener&lt;TreeItem&lt;String&gt;&gt;() {
3812             @Override public void onChanged(Change&lt;? extends TreeItem&lt;String&gt;&gt; c) {
3813                 while (c.next()) {
3814                     if (c.wasRemoved()) {
3815                         c.getRemoved().forEach(item -&gt; {
3816                             if (item == null) {
3817                                 fail(&quot;Removed item should never be null&quot;);
3818                             } else {
3819                                 rt_37395_item_removeCount++;
3820                             }
3821                         });
3822                     }
3823                     if (c.wasAdded()) {
3824                         c.getAddedSubList().forEach(item -&gt; {
3825                             rt_37395_item_addCount++;
3826                         });
3827                     }
3828                     if (c.wasPermutated()) {
3829                         rt_37395_item_permutationCount++;
3830                     }
3831                 }
3832             }
3833         });
3834 
3835         assertEquals(0, rt_37395_index_removeCount);
3836         assertEquals(0, rt_37395_index_addCount);
3837         assertEquals(0, rt_37395_index_permutationCount);
3838         assertEquals(0, rt_37395_item_removeCount);
3839         assertEquals(0, rt_37395_item_addCount);
3840         assertEquals(0, rt_37395_item_permutationCount);
3841 
3842         StageLoader sl = new StageLoader(table);
3843 
3844         // step one: select item &#39;three&#39; in index 2
3845         sm.select(2);
3846         assertEquals(0, rt_37395_index_removeCount);
3847         assertEquals(1, rt_37395_index_addCount);
3848         assertEquals(0, rt_37395_index_permutationCount);
3849         assertEquals(0, rt_37395_item_removeCount);
3850         assertEquals(1, rt_37395_item_addCount);
3851         assertEquals(0, rt_37395_item_permutationCount);
3852 
3853         // step two: expand item &#39;two&#39;
3854         // The first part of the bug report was that we received add/remove
3855         // change events here, when in reality we shouldn&#39;t have, so lets enforce
3856         // that. We do expect a permutation event on the index, as it has been
3857         // pushed down, but this should not result in an item permutation event,
3858         // as it remains unchanged
3859         two.setExpanded(true);
3860         assertEquals(1, rt_37395_index_removeCount);
3861         assertEquals(2, rt_37395_index_addCount);
3862         assertEquals(0, rt_37395_index_permutationCount);
3863         assertEquals(0, rt_37395_item_removeCount);
3864         assertEquals(1, rt_37395_item_addCount);
3865         assertEquals(0, rt_37395_item_permutationCount);
3866 
3867         // step three: collapse item &#39;two&#39;
3868         // Same argument as in step two above: no addition or removal, just a
3869         // permutation on the index
3870         two.setExpanded(false);
3871         assertEquals(2, rt_37395_index_removeCount);
3872         assertEquals(3, rt_37395_index_addCount);
3873         assertEquals(0, rt_37395_index_permutationCount);
3874         assertEquals(0, rt_37395_item_removeCount);
3875         assertEquals(1, rt_37395_item_addCount);
3876         assertEquals(0, rt_37395_item_permutationCount);
3877 
3878         sl.dispose();
3879     }
3880 
3881     @Test public void test_rt_37429() {
3882         // table items - 3 items, 2nd item has 2 children
3883         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3884 
3885         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
3886         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
3887         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
3888         two.setExpanded(true);
3889 
3890         root.getChildren().add(new TreeItem&lt;&gt;(&quot;one&quot;));
3891         root.getChildren().add(two);
3892         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
3893 
3894         // table columns - 1 column; name
3895         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3896         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3897         nameColumn.setPrefWidth(200);
3898 
3899         // table
3900         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3901         table.setShowRoot(false);
3902         table.setRoot(root);
3903         table.getColumns().addAll(nameColumn);
3904 
3905         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
3906             while (c.next()) {
3907                 if(c.wasRemoved()) {
3908                     // The removed list of items must be iterated or the AIOOBE will
3909                     // not be thrown when getAddedSubList is called.
3910                     c.getRemoved().forEach(item -&gt; {});
3911                 }
3912 
3913                 if (c.wasAdded()) {
3914                     c.getAddedSubList();
3915                 }
3916             }
3917         });
3918 
3919         StageLoader sl = new StageLoader(table);
3920 
3921         ControlTestUtils.runWithExceptionHandler(() -&gt; {
3922             table.getSelectionModel().select(0);
3923             table.getSortOrder().add(nameColumn);
3924         });
3925 
3926         sl.dispose();
3927     }
3928 
3929     private int rt_37429_items_change_count = 0;
3930     private int rt_37429_cells_change_count = 0;
3931     @Test public void test_rt_37429_sortEventsShouldNotFireExtraChangeEvents() {
3932         // table items - 3 items, 2nd item has 2 children
3933         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3934 
3935         root.getChildren().add(new TreeItem&lt;&gt;(&quot;a&quot;));
3936         root.getChildren().add(new TreeItem&lt;&gt;(&quot;c&quot;));
3937         root.getChildren().add(new TreeItem&lt;&gt;(&quot;b&quot;));
3938 
3939         // table columns - 1 column; name
3940         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3941         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3942         nameColumn.setPrefWidth(200);
3943 
3944         // table
3945         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3946         table.setShowRoot(false);
3947         table.setRoot(root);
3948         table.getColumns().addAll(nameColumn);
3949 
3950         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
3951             while (c.next()) {
3952                 rt_37429_items_change_count++;
3953             }
3954         });
3955         table.getSelectionModel().getSelectedCells().addListener((ListChangeListener&lt;TreeTablePosition&lt;String, ?&gt;&gt;) c -&gt; {
3956             while (c.next()) {
3957                 rt_37429_cells_change_count++;
3958             }
3959         });
3960 
3961         StageLoader sl = new StageLoader(table);
3962 
3963         assertEquals(0, rt_37429_items_change_count);
3964         assertEquals(0, rt_37429_cells_change_count);
3965 
3966         table.getSelectionModel().select(0);
3967         assertEquals(1, rt_37429_items_change_count);
3968         assertEquals(1, rt_37429_cells_change_count);
3969 
3970         table.getSortOrder().add(nameColumn);
3971         assertEquals(1, rt_37429_items_change_count);
3972         assertEquals(1, rt_37429_cells_change_count);
3973 
3974         nameColumn.setSortType(TreeTableColumn.SortType.DESCENDING);
3975         assertEquals(1, rt_37429_items_change_count);
3976         assertEquals(2, rt_37429_cells_change_count);
3977 
3978         nameColumn.setSortType(TreeTableColumn.SortType.ASCENDING);
3979         assertEquals(1, rt_37429_items_change_count);
3980         assertEquals(3, rt_37429_cells_change_count);
3981 
3982         sl.dispose();
3983     }
3984 
3985     private int rt_37538_count = 0;
3986     @Test public void test_rt_37538_noCNextCall() {
3987         test_rt_37538(false, false);
3988     }
3989 
3990     @Test public void test_rt_37538_callCNextOnce() {
3991         test_rt_37538(true, false);
3992     }
3993 
3994     @Test public void test_rt_37538_callCNextInLoop() {
3995         test_rt_37538(false, true);
3996     }
3997 
3998     private void test_rt_37538(boolean callCNextOnce, boolean callCNextInLoop) {
3999         // create table with a bunch of rows and 1 column...
4000         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
4001         root.setExpanded(true);
4002         for (int i = 1; i &lt;= 50; i++) {
4003             root.getChildren().add(new TreeItem&lt;&gt;(i));
4004         }
4005 
4006         final TreeTableColumn&lt;Integer, Integer&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4007         column.setCellValueFactory( cdf -&gt; new ReadOnlyObjectWrapper&lt;Integer&gt;(cdf.getValue().getValue()));
4008 
4009         final TreeTableView&lt;Integer&gt; table = new TreeTableView&lt;&gt;(root);
4010         table.getColumns().add( column );
4011 
4012         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;Integer&gt;&gt; c) -&gt; {
4013             if (callCNextOnce) {
4014                 c.next();
4015             } else if (callCNextInLoop) {
4016                 while (c.next()) {
4017                     // no-op
4018                 }
4019             }
4020 
4021             if (rt_37538_count &gt;= 1) {
4022                 Thread.dumpStack();
4023                 fail(&quot;This method should only be called once&quot;);
4024             }
4025 
4026             rt_37538_count++;
4027         });
4028 
4029         StageLoader sl = new StageLoader(table);
4030         assertEquals(0, rt_37538_count);
4031         table.getSelectionModel().select(0);
4032         assertEquals(1, rt_37538_count);
4033         sl.dispose();
4034     }
4035 
4036     @Test public void test_rt_37593() {
4037         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
4038 
4039         TreeItem&lt;String&gt; one = new TreeItem&lt;&gt;(&quot;one&quot;);
4040         root.getChildren().add(one);
4041 
4042         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
4043         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
4044         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
4045         root.getChildren().add(two);
4046 
4047         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
4048 
4049         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
4050         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
4051 
4052         treeTableView.setShowRoot(false);
4053         treeTableView.setRoot(root);
4054         treeTableView.getColumns().addAll(nameColumn);
4055 
4056         treeTableView.getSortOrder().add(nameColumn);
4057         nameColumn.setSortType(TreeTableColumn.SortType.DESCENDING);
4058         sm.select(one);
4059 
4060         // at this point, the &#39;one&#39; item should be in row 2
4061         assertTrue(sm.isSelected(2));
4062         assertEquals(one, sm.getSelectedItem());
4063 
4064         two.setExpanded(true);
4065 
4066         // we should end up with the selection being on index 4, which is the
4067         // final location of the &#39;one&#39; tree item, after sorting and expanding &#39;two&#39;
4068         assertEquals(one, sm.getSelectedItem());
4069         assertTrue(debug(), sm.isSelected(4));
4070 
4071         // this line would create a NPE
4072         VirtualFlowTestUtils.clickOnRow(treeTableView, 4, true);
4073 
4074         // The mouse click should not change selection at all
4075         assertEquals(one, sm.getSelectedItem());
4076         assertTrue(debug(), sm.isSelected(4));
4077     }
4078 
4079     @Test public void test_rt_35395_testCell_fixedCellSize() {
4080         test_rt_35395(true, true);
4081     }
4082 
4083     @Test public void test_rt_35395_testCell_notFixedCellSize() {
4084         test_rt_35395(true, false);
4085     }
4086 
4087     @Ignore(&quot;Fix not yet developed for TreeTableView&quot;)
4088     @Test public void test_rt_35395_testRow_fixedCellSize() {
4089         test_rt_35395(false, true);
4090     }
4091 
4092     @Ignore(&quot;Fix not yet developed for TreeTableView&quot;)
4093     @Test public void test_rt_35395_testRow_notFixedCellSize() {
4094         test_rt_35395(false, false);
4095     }
4096 
4097     private int rt_35395_counter;
4098     private void test_rt_35395(boolean testCell, boolean useFixedCellSize) {
4099         rt_35395_counter = 0;
4100 
4101         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;green&quot;);
4102         root.setExpanded(true);
4103         for (int i = 0; i &lt; 20; i++) {
4104             root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;red&quot;), new TreeItem&lt;&gt;(&quot;green&quot;), new TreeItem&lt;&gt;(&quot;blue&quot;), new TreeItem&lt;&gt;(&quot;purple&quot;));
4105         }
4106 
4107         TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;(root);
4108         if (useFixedCellSize) {
4109             treeTableView.setFixedCellSize(24);
4110         }
4111         treeTableView.setRowFactory(tv -&gt; new TreeTableRowShim&lt;String&gt;() {
4112             @Override public void updateItem(String color, boolean empty) {
4113                 rt_35395_counter += testCell ? 0 : 1;
4114                 super.updateItem(color, empty);
4115             }
4116         });
4117 
4118         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4119         column.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
4120         column.setCellFactory(tv -&gt; new TreeTableCellShim&lt;String,String&gt;() {
4121             @Override public void updateItem(String color, boolean empty) {
4122                 rt_35395_counter += testCell ? 1 : 0;
4123                 super.updateItem(color, empty);
4124                 setText(null);
4125                 if (empty) {
4126                     setGraphic(null);
4127                 } else {
4128                     Rectangle rect = new Rectangle(16, 16);
4129                     rect.setStyle(&quot;-fx-fill: &quot; + color);
4130                     setGraphic(rect);
4131                 }
4132             }
4133         });
4134         treeTableView.getColumns().addAll(column);
4135 
4136         StageLoader sl = new StageLoader(treeTableView);
4137 
4138         Platform.runLater(() -&gt; {
4139             rt_35395_counter = 0;
4140             root.getChildren().set(10, new TreeItem&lt;&gt;(&quot;yellow&quot;));
4141             Platform.runLater(() -&gt; {
4142                 Toolkit.getToolkit().firePulse();
4143                 assertEquals(1, rt_35395_counter);
4144                 rt_35395_counter = 0;
4145                 root.getChildren().set(30, new TreeItem&lt;&gt;(&quot;yellow&quot;));
4146                 Platform.runLater(() -&gt; {
4147                     Toolkit.getToolkit().firePulse();
4148                     assertEquals(0, rt_35395_counter);
4149                     rt_35395_counter = 0;
4150                     treeTableView.scrollTo(5);
4151                     Platform.runLater(() -&gt; {
4152                         Toolkit.getToolkit().firePulse();
4153                         assertEquals(useFixedCellSize ? 5 : 5, rt_35395_counter);
4154                         rt_35395_counter = 0;
4155                         treeTableView.scrollTo(55);
4156                         Platform.runLater(() -&gt; {
4157                             Toolkit.getToolkit().firePulse();
4158 
4159                             assertEquals(useFixedCellSize ? 7 : 59, rt_35395_counter);
4160                             sl.dispose();
4161                         });
4162                     });
4163                 });
4164             });
4165         });
4166     }
4167 
4168     @Test public void test_rt_37632() {
4169         final TreeItem&lt;String&gt; rootOne = new TreeItem&lt;&gt;(&quot;Root 1&quot;);
4170         final TreeItem&lt;String&gt; rootTwo = new TreeItem&lt;&gt;(&quot;Root 2&quot;);
4171 
4172         TreeTableColumn&lt;String,String&gt; tableColumn = new TreeTableColumn(&quot;column&quot;);
4173         tableColumn.setCellValueFactory(c -&gt; new ReadOnlyStringWrapper(c.getValue().getValue()));
4174 
4175         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;();
4176         treeTableView.getColumns().addAll(tableColumn);
4177         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeTableView.getSelectionModel();
4178         treeTableView.setRoot(rootOne);
4179         treeTableView.getSelectionModel().selectFirst();
4180 
4181         assertEquals(0, sm.getSelectedIndex());
4182         assertEquals(rootOne, sm.getSelectedItem());
4183         assertEquals(1, sm.getSelectedIndices().size());
4184         assertEquals(0, (int) sm.getSelectedIndices().get(0));
4185         assertEquals(1, sm.getSelectedItems().size());
4186         assertEquals(rootOne, sm.getSelectedItems().get(0));
4187 
4188         treeTableView.setRoot(rootTwo);
4189 
4190         assertEquals(-1, sm.getSelectedIndex());
4191         assertNull(sm.getSelectedItem());
4192         assertEquals(0, sm.getSelectedIndices().size());
4193         assertEquals(0, sm.getSelectedItems().size());
4194     }
4195 
4196     private TreeTableView&lt;Person&gt; test_rt_38464_createControl() {
4197         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
4198                 new TreeItem&lt;&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
4199                 new TreeItem&lt;&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
4200                 new TreeItem&lt;&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
4201                 new TreeItem&lt;&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
4202                 new TreeItem&lt;&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
4203 
4204         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
4205         table.setShowRoot(false);
4206 
4207         TreeItem&lt;Person&gt; root = new TreeItem&lt;&gt;(new Person(&quot;Root&quot;, null, null));
4208         root.setExpanded(true);
4209         root.getChildren().setAll(persons);
4210         table.setRoot(root);
4211 
4212 
4213 
4214         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
4215         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
4216 
4217         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
4218         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
4219 
4220         table.getColumns().addAll(firstNameCol, lastNameCol);
4221 
4222         return table;
4223     }
4224 
4225     @Test public void test_rt_38464_rowSelection_selectFirstRowOnly() {
4226         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4227         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4228         sm.setCellSelectionEnabled(false);
4229         sm.setSelectionMode(SelectionMode.MULTIPLE);
4230 
4231         sm.select(0);
4232 
4233         assertTrue(sm.isSelected(0));
4234         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4235         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4236 
4237         assertEquals(1, sm.getSelectedIndices().size());
4238         assertEquals(1, sm.getSelectedItems().size());
4239         assertEquals(1, sm.getSelectedCells().size());
4240     }
4241 
4242     @Test public void test_rt_38464_rowSelection_selectFirstRowAndThenCallNoOpMethods() {
4243         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4244         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4245         sm.setCellSelectionEnabled(false);
4246         sm.setSelectionMode(SelectionMode.MULTIPLE);
4247 
4248         sm.select(0);               // select first row
4249         sm.select(0);               // this should be a no-op
4250         sm.select(0, table.getColumns().get(0)); // so should this, as we are in row selection mode
4251         sm.select(0, table.getColumns().get(1));  // and same here
4252 
4253         assertTrue(sm.isSelected(0));
4254         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4255         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4256 
4257         assertEquals(1, sm.getSelectedIndices().size());
4258         assertEquals(1, sm.getSelectedItems().size());
4259         assertEquals(1, sm.getSelectedCells().size());
4260     }
4261 
4262 
4263     @Test public void test_rt_38464_cellSelection_selectFirstRowOnly() {
4264         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4265         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4266         sm.setCellSelectionEnabled(true);
4267         sm.setSelectionMode(SelectionMode.MULTIPLE);
4268 
4269         // select first row. This should be translated into selection of all
4270         // cells in this row, and (as of JDK 9) _does_ result in the row itself being
4271         // considered selected.
4272         sm.select(0);
4273 
4274         assertTrue(sm.isSelected(0));
4275         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4276         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4277 
4278         assertEquals(1, sm.getSelectedIndices().size());
4279         assertEquals(1, sm.getSelectedItems().size());
4280         assertEquals(2, sm.getSelectedCells().size());
4281     }
4282 
4283     @Test public void test_rt_38464_cellSelection_selectFirstRowAndThenCallNoOpMethods() {
4284         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4285         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4286         sm.setCellSelectionEnabled(true);
4287         sm.setSelectionMode(SelectionMode.MULTIPLE);
4288 
4289         // select first row. This should be translated into selection of all
4290         // cells in this row, and (as of JDK 9) _does_ result in the row itself being
4291         // considered selected.
4292         sm.select(0);                            // select first row
4293         sm.select(0, table.getColumns().get(0)); // This line and the next should be no-ops
4294         sm.select(0, table.getColumns().get(1));
4295 
4296         assertTrue(sm.isSelected(0));
4297         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4298         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4299 
4300         assertEquals(1, sm.getSelectedIndices().size());
4301         assertEquals(1, sm.getSelectedItems().size());
4302         assertEquals(2, sm.getSelectedCells().size());
4303     }
4304 
4305     @Test public void test_rt38464_selectCellMultipleTimes() {
4306         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4307         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4308         sm.setCellSelectionEnabled(true);
4309         sm.setSelectionMode(SelectionMode.MULTIPLE);
4310 
4311         // default selection when in cell selection mode
4312         assertEquals(0, sm.getSelectedCells().size());
4313         assertEquals(0, sm.getSelectedItems().size());
4314         assertEquals(0, sm.getSelectedIndices().size());
4315 
4316         // select the first cell
4317         sm.select(0, table.getColumns().get(0));
4318         assertEquals(1, sm.getSelectedCells().size());
4319         assertEquals(1, sm.getSelectedItems().size());
4320         assertEquals(1, sm.getSelectedIndices().size());
4321 
4322         // select the first cell....again
4323         sm.select(0, table.getColumns().get(0));
4324         assertEquals(1, sm.getSelectedCells().size());
4325         assertEquals(1, sm.getSelectedItems().size());
4326         assertEquals(1, sm.getSelectedIndices().size());
4327     }
4328 
4329     @Test public void test_rt38464_selectCellThenRow() {
4330         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4331         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4332         sm.setCellSelectionEnabled(true);
4333         sm.setSelectionMode(SelectionMode.MULTIPLE);
4334 
4335         // default selection when in cell selection mode
4336         assertEquals(0, sm.getSelectedCells().size());
4337         assertEquals(0, sm.getSelectedItems().size());
4338         assertEquals(0, sm.getSelectedIndices().size());
4339 
4340         // select the first cell
4341         sm.select(0, table.getColumns().get(0));
4342         assertEquals(1, sm.getSelectedCells().size());
4343         assertEquals(1, sm.getSelectedItems().size());
4344         assertEquals(1, sm.getSelectedIndices().size());
4345 
4346         // select the first row
4347         sm.select(0);
4348 
4349         // we go to 2 here as all cells in the row become selected. What we do
4350         // not expect is to go to 3, as that would mean duplication
4351         assertEquals(2, sm.getSelectedCells().size());
4352         assertEquals(1, sm.getSelectedItems().size());
4353         assertEquals(1, sm.getSelectedIndices().size());
4354     }
4355 
4356     @Test public void test_rt38464_selectRowThenCell() {
4357         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4358         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4359         sm.setCellSelectionEnabled(true);
4360         sm.setSelectionMode(SelectionMode.MULTIPLE);
4361 
4362         // default selection when in cell selection mode
4363         assertEquals(0, sm.getSelectedCells().size());
4364         assertEquals(0, sm.getSelectedItems().size());
4365         assertEquals(0, sm.getSelectedIndices().size());
4366 
4367         // select the first row
4368         sm.select(0);
4369 
4370         // we go to 2 here as all cells in the row become selected.
4371         assertEquals(2, sm.getSelectedCells().size());
4372         assertEquals(1, sm.getSelectedItems().size());
4373         assertEquals(1, sm.getSelectedIndices().size());
4374 
4375         // select the first cell - no change is expected
4376         sm.select(0, table.getColumns().get(0));
4377         assertEquals(2, sm.getSelectedCells().size());
4378         assertEquals(1, sm.getSelectedItems().size());
4379         assertEquals(1, sm.getSelectedIndices().size());
4380     }
4381 
4382     @Test public void test_rt38464_selectTests_cellSelection_singleSelection_selectsOneRow() {
4383         test_rt38464_selectTests(true, true, true);
4384     }
4385 
4386     @Test public void test_rt38464_selectTests_cellSelection_singleSelection_selectsTwoRows() {
4387         test_rt38464_selectTests(true, true, false);
4388     }
4389 
4390     @Test public void test_rt38464_selectTests_cellSelection_multipleSelection_selectsOneRow() {
4391         test_rt38464_selectTests(true, false, true);
4392     }
4393 
4394     @Test public void test_rt38464_selectTests_cellSelection_multipleSelection_selectsTwoRows() {
4395         test_rt38464_selectTests(true, false, false);
4396     }
4397 
4398     @Test public void test_rt38464_selectTests_rowSelection_singleSelection_selectsOneRow() {
4399         test_rt38464_selectTests(false, true, true);
4400     }
4401 
4402     @Test public void test_rt38464_selectTests_rowSelection_singleSelection_selectsTwoRows() {
4403         test_rt38464_selectTests(false, true, false);
4404     }
4405 
4406     @Test public void test_rt38464_selectTests_rowSelection_multipleSelection_selectsOneRow() {
4407         test_rt38464_selectTests(false, false, true);
4408     }
4409 
4410     @Test public void test_rt38464_selectTests_rowSelection_multipleSelection_selectsTwoRows() {
4411         test_rt38464_selectTests(false, false, false);
4412     }
4413 
4414     private void test_rt38464_selectTests(boolean cellSelection, boolean singleSelection, boolean selectsOneRow) {
4415         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4416         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4417         sm.setCellSelectionEnabled(cellSelection);
4418         sm.setSelectionMode(singleSelection ? SelectionMode.SINGLE : SelectionMode.MULTIPLE);
4419 
4420         // default selection when in cell selection mode
4421         assertEquals(0, sm.getSelectedCells().size());
4422         assertEquals(0, sm.getSelectedItems().size());
4423         assertEquals(0, sm.getSelectedIndices().size());
4424 
4425         if (selectsOneRow) {
4426             sm.select(0);
4427         } else {
4428             // select the first two rows
4429             sm.selectIndices(0, 1);
4430         }
4431 
4432         final int expectedCells = singleSelection                    ? 1 :
4433                                   selectsOneRow   &amp;&amp; cellSelection   ? 2 :
4434                                   selectsOneRow   &amp;&amp; !cellSelection  ? 1 :
4435                                   !selectsOneRow  &amp;&amp; cellSelection   ? 4 :
4436                                /* !selectsOneRow  &amp;&amp; !cellSelection */ 2;
4437 
4438         final int expectedItems = singleSelection ? 1 :
4439                 selectsOneRow   ? 1 : 2;
4440 
4441         assertEquals(expectedCells, sm.getSelectedCells().size());
4442         assertEquals(expectedItems, sm.getSelectedItems().size());
4443         assertEquals(expectedItems, sm.getSelectedIndices().size());
4444 
4445         // we expect the table column of all selected cells, in this instance,
4446         // to be null as we have not explicitly stated a column, nor have we clicked
4447         // on a column. The only alternative is to use the first column.
4448         for (TreeTablePosition&lt;?,?&gt; tp : sm.getSelectedCells()) {
4449             if (cellSelection) {
4450                 assertNotNull(tp.getTableColumn());
4451             } else {
4452                 assertNull(tp.getTableColumn());
4453             }
4454         }
4455     }
4456 
4457     @Test public void test_rt_37853_replaceRoot() {
4458         test_rt_37853(true);
4459     }
4460 
4461     @Test public void test_rt_37853_replaceRootChildren() {
4462         test_rt_37853(false);
4463     }
4464 
4465     private int rt_37853_cancelCount;
4466     private int rt_37853_commitCount;
4467     public void test_rt_37853(boolean replaceRoot) {
4468         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;&gt;(&quot;first&quot;);
4469         first.setEditable(true);
4470         first.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
4471         treeTableView.getColumns().add(first);
4472         treeTableView.setEditable(true);
4473         treeTableView.setRoot(new TreeItem&lt;&gt;(&quot;Root&quot;));
4474         treeTableView.getRoot().setExpanded(true);
4475 
4476         for (int i = 0; i &lt; 10; i++) {
4477             treeTableView.getRoot().getChildren().add(new TreeItem&lt;&gt;(&quot;&quot; + i));
4478         }
4479 
4480         StageLoader sl = new StageLoader(treeTableView);
4481 
4482         first.setOnEditCancel(editEvent -&gt; rt_37853_cancelCount++);
4483         first.setOnEditCommit(editEvent -&gt; rt_37853_commitCount++);
4484 
4485         assertEquals(0, rt_37853_cancelCount);
4486         assertEquals(0, rt_37853_commitCount);
4487 
4488         treeTableView.edit(1, first);
4489         assertNotNull(treeTableView.getEditingCell());
4490 
4491         if (replaceRoot) {
4492             treeTableView.setRoot(new TreeItem&lt;&gt;(&quot;New Root&quot;));
4493         } else {
4494             treeTableView.getRoot().getChildren().clear();
4495             for (int i = 0; i &lt; 10; i++) {
4496                 treeTableView.getRoot().getChildren().add(new TreeItem&lt;&gt;(&quot;new item &quot; + i));
4497             }
4498         }
4499         assertEquals(1, rt_37853_cancelCount);
4500         assertEquals(0, rt_37853_commitCount);
4501 
4502         sl.dispose();
4503     }
4504 
4505 
4506     /**************************************************************************
4507      *
4508      * Tests (and related code) for RT-38892
4509      *
4510      *************************************************************************/
4511 
4512     private final Supplier&lt;TreeTableColumn&lt;Person,String&gt;&gt; columnCallable = () -&gt; {
4513         TreeTableColumn&lt;Person,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Last Name&quot;);
4514         column.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person,String&gt;(&quot;lastName&quot;));
4515         return column;
4516     };
4517 
4518     private TreeTableColumn&lt;Person, String&gt; test_rt_38892_firstNameCol;
4519     private TreeTableColumn&lt;Person, String&gt; test_rt_38892_lastNameCol;
4520 
4521     private TreeTableView&lt;Person&gt; init_test_rt_38892() {
4522         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
4523                 new TreeItem&lt;&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
4524                 new TreeItem&lt;&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
4525                 new TreeItem&lt;&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
4526                 new TreeItem&lt;&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
4527                 new TreeItem&lt;&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
4528 
4529         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
4530         table.setShowRoot(false);
4531         table.getSelectionModel().setCellSelectionEnabled(true);
4532         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
4533 
4534         TreeItem&lt;Person&gt; root = new TreeItem&lt;&gt;(new Person(&quot;Root&quot;, null, null));
4535         root.setExpanded(true);
4536         root.getChildren().setAll(persons);
4537         table.setRoot(root);
4538 
4539         test_rt_38892_firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
4540         test_rt_38892_firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(&quot;firstName&quot;));
4541         test_rt_38892_lastNameCol = columnCallable.get();
4542         table.getColumns().addAll(test_rt_38892_firstNameCol, test_rt_38892_lastNameCol);
4543 
4544         return table;
4545     }
4546 
4547     @Test public void test_rt_38892_focusMovesToLeftWhenPossible() {
4548         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4549 
4550         TreeTableView.TreeTableViewFocusModel&lt;Person&gt; fm = table.getFocusModel();
4551         fm.focus(0, test_rt_38892_lastNameCol);
4552 
4553         // assert pre-conditions
4554         assertEquals(0, fm.getFocusedIndex());
4555         assertEquals(0, fm.getFocusedCell().getRow());
4556         assertEquals(test_rt_38892_lastNameCol, fm.getFocusedCell().getTableColumn());
4557         assertEquals(1, fm.getFocusedCell().getColumn());
4558 
4559         // now remove column where focus is and replace it with a new column.
4560         // We expect focus to move to the left one cell.
4561         table.getColumns().remove(1);
4562         table.getColumns().add(columnCallable.get());
4563 
4564         assertEquals(0, fm.getFocusedIndex());
4565         assertEquals(0, fm.getFocusedCell().getRow());
4566         assertEquals(test_rt_38892_firstNameCol, fm.getFocusedCell().getTableColumn());
4567         assertEquals(0, fm.getFocusedCell().getColumn());
4568     }
4569 
4570     @Test public void test_rt_38892_removeLeftMostColumn() {
4571         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4572 
4573         TreeTableView.TreeTableViewFocusModel&lt;Person&gt; fm = table.getFocusModel();
4574         fm.focus(0, test_rt_38892_firstNameCol);
4575 
4576         // assert pre-conditions
4577         assertEquals(0, fm.getFocusedIndex());
4578         assertEquals(0, fm.getFocusedCell().getRow());
4579         assertEquals(test_rt_38892_firstNameCol, fm.getFocusedCell().getTableColumn());
4580         assertEquals(0, fm.getFocusedCell().getColumn());
4581 
4582         // now remove column where focus is and replace it with a new column.
4583         // In the current (non-specified) behavior, this results in focus being
4584         // shifted to a cell in the remaining column, even when we add a new column
4585         // as we index based on the column, not on its index.
4586         table.getColumns().remove(0);
4587         TreeTableColumn&lt;Person,String&gt; newColumn = columnCallable.get();
4588         table.getColumns().add(0, newColumn);
4589 
4590         assertEquals(0, fm.getFocusedIndex());
4591         assertEquals(0, fm.getFocusedCell().getRow());
4592         assertEquals(test_rt_38892_lastNameCol, fm.getFocusedCell().getTableColumn());
4593         assertEquals(0, fm.getFocusedCell().getColumn());
4594     }
4595 
4596     @Test public void test_rt_38892_removeSelectionFromCellsInRemovedColumn() {
4597         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4598 
4599         TreeTableView.TreeTableViewSelectionModel sm = table.getSelectionModel();
4600         sm.select(0, test_rt_38892_firstNameCol);
4601         sm.select(1, test_rt_38892_lastNameCol);    // this should go
4602         sm.select(2, test_rt_38892_firstNameCol);
4603         sm.select(3, test_rt_38892_lastNameCol);    // so should this
4604         sm.select(4, test_rt_38892_firstNameCol);
4605 
4606         assertEquals(5, sm.getSelectedCells().size());
4607 
4608         table.getColumns().remove(1);
4609 
4610         assertEquals(3, sm.getSelectedCells().size());
4611         assertTrue(sm.isSelected(0, test_rt_38892_firstNameCol));
4612         assertFalse(sm.isSelected(1, test_rt_38892_lastNameCol));
4613         assertTrue(sm.isSelected(2, test_rt_38892_firstNameCol));
4614         assertFalse(sm.isSelected(3, test_rt_38892_lastNameCol));
4615         assertTrue(sm.isSelected(4, test_rt_38892_firstNameCol));
4616     }
4617 
4618     @Test public void test_rt_38787_remove_b() {
4619         // Remove &#39;b&#39;, selection moves to &#39;a&#39;
4620         test_rt_38787(&quot;a&quot;, 0, 1);
4621     }
4622 
4623     @Test public void test_rt_38787_remove_b_c() {
4624         // Remove &#39;b&#39; and &#39;c&#39;, selection moves to &#39;a&#39;
4625         test_rt_38787(&quot;a&quot;, 0, 1, 2);
4626     }
4627 
4628     @Test public void test_rt_38787_remove_c_d() {
4629         // Remove &#39;c&#39; and &#39;d&#39;, selection moves to &#39;b&#39;
4630         test_rt_38787(&quot;b&quot;, 1, 2, 3);
4631     }
4632 
4633     @Test public void test_rt_38787_remove_a() {
4634         // Remove &#39;a&#39;, selection moves to &#39;b&#39;, now in index 0
4635         test_rt_38787(&quot;b&quot;, 0, 0);
4636     }
4637 
4638     private void test_rt_38787(String expectedItem, int expectedIndex, int... indicesToRemove) {
4639         TreeItem&lt;String&gt; a, b, c, d;
4640         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4641         root.setExpanded(true);
4642         root.getChildren().addAll(
4643                 a = new TreeItem&lt;String&gt;(&quot;a&quot;),
4644                 b = new TreeItem&lt;String&gt;(&quot;b&quot;),
4645                 c = new TreeItem&lt;String&gt;(&quot;c&quot;),
4646                 d = new TreeItem&lt;String&gt;(&quot;d&quot;)
4647         );
4648 
4649         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4650         stringTreeTableView.setShowRoot(false);
4651 
4652         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4653         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4654         stringTreeTableView.getColumns().add(column);
4655 
4656         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4657         sm.select(b);
4658 
4659         // test pre-conditions
4660         assertEquals(1, sm.getSelectedIndex());
4661         assertEquals(1, (int)sm.getSelectedIndices().get(0));
4662         assertEquals(b, sm.getSelectedItem());
4663         assertEquals(b, sm.getSelectedItems().get(0));
4664         assertFalse(sm.isSelected(0));
4665         assertTrue(sm.isSelected(1));
4666         assertFalse(sm.isSelected(2));
4667 
4668         // removing items
4669         List&lt;TreeItem&lt;String&gt;&gt; itemsToRemove = new ArrayList&lt;&gt;(indicesToRemove.length);
4670         for (int index : indicesToRemove) {
4671             itemsToRemove.add(root.getChildren().get(index));
4672         }
4673         root.getChildren().removeAll(itemsToRemove);
4674 
4675         // testing against expectations
4676         assertEquals(expectedIndex, sm.getSelectedIndex());
4677         assertEquals(expectedIndex, (int)sm.getSelectedIndices().get(0));
4678         assertEquals(expectedItem, sm.getSelectedItem().getValue());
4679         assertEquals(expectedItem, sm.getSelectedItems().get(0).getValue());
4680     }
4681 
4682     private int rt_38341_indices_count = 0;
4683     private int rt_38341_items_count = 0;
4684     @Test public void test_rt_38341() {
4685         Callback&lt;Integer, TreeItem&lt;String&gt;&gt; callback = number -&gt; {
4686             final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root &quot; + number);
4687             final TreeItem&lt;String&gt; child = new TreeItem&lt;&gt;(&quot;Child &quot; + number);
4688 
4689             root.getChildren().add(child);
4690             return root;
4691         };
4692 
4693         final TreeItem&lt;String&gt; root = new TreeItem&lt;String&gt;();
4694         root.setExpanded(true);
4695         root.getChildren().addAll(callback.call(1), callback.call(2));
4696 
4697         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;(root);
4698         treeTableView.setShowRoot(false);
4699 
4700         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4701         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4702         treeTableView.getColumns().add(column);
4703 
4704         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeTableView.getSelectionModel();
4705         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) c -&gt; rt_38341_indices_count++);
4706         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; rt_38341_items_count++);
4707 
4708         assertEquals(0, rt_38341_indices_count);
4709         assertEquals(0, rt_38341_items_count);
4710 
4711         // expand the first child of root, and select it (note: root isn&#39;t visible)
4712         root.getChildren().get(0).setExpanded(true);
4713         sm.select(1);
4714         assertEquals(1, sm.getSelectedIndex());
4715         assertEquals(1, sm.getSelectedIndices().size());
4716         assertEquals(1, (int)sm.getSelectedIndices().get(0));
4717         assertEquals(1, sm.getSelectedItems().size());
4718         assertEquals(&quot;Child 1&quot;, sm.getSelectedItem().getValue());
4719         assertEquals(&quot;Child 1&quot;, sm.getSelectedItems().get(0).getValue());
4720 
4721         assertEquals(1, rt_38341_indices_count);
4722         assertEquals(1, rt_38341_items_count);
4723 
4724         // now delete it
4725         root.getChildren().get(0).getChildren().remove(0);
4726 
4727         // selection should move to the childs parent in index 0
4728         assertEquals(0, sm.getSelectedIndex());
4729         assertEquals(1, sm.getSelectedIndices().size());
4730         assertEquals(0, (int)sm.getSelectedIndices().get(0));
4731         assertEquals(1, sm.getSelectedItems().size());
4732         assertEquals(&quot;Root 1&quot;, sm.getSelectedItem().getValue());
4733         assertEquals(&quot;Root 1&quot;, sm.getSelectedItems().get(0).getValue());
4734 
4735         // we also expect there to be an event in the selection model for
4736         // selected indices and selected items
4737         assertEquals(2, rt_38341_indices_count);
4738         assertEquals(2, rt_38341_items_count);
4739     }
4740 
4741     private int rt_38943_index_count = 0;
4742     private int rt_38943_item_count = 0;
4743     @Test public void test_rt_38943() {
4744         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4745         root.setExpanded(true);
4746         root.getChildren().addAll(
4747             new TreeItem&lt;&gt;(&quot;a&quot;),
4748             new TreeItem&lt;&gt;(&quot;b&quot;),
4749             new TreeItem&lt;&gt;(&quot;c&quot;),
4750             new TreeItem&lt;&gt;(&quot;d&quot;)
4751         );
4752 
4753         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4754         stringTreeTableView.setShowRoot(false);
4755 
4756         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4757         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4758         stringTreeTableView.getColumns().add(column);
4759 
4760         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4761 
4762         sm.selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_index_count++);
4763         sm.selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_item_count++);
4764 
4765         assertEquals(-1, sm.getSelectedIndex());
4766         assertNull(sm.getSelectedItem());
4767         assertEquals(0, rt_38943_index_count);
4768         assertEquals(0, rt_38943_item_count);
4769 
4770         sm.select(0);
4771         assertEquals(0, sm.getSelectedIndex());
4772         assertEquals(&quot;a&quot;, sm.getSelectedItem().getValue());
4773         assertEquals(1, rt_38943_index_count);
4774         assertEquals(1, rt_38943_item_count);
4775 
4776         sm.clearSelection(0);
4777         assertEquals(-1, sm.getSelectedIndex());
4778         assertNull(sm.getSelectedItem());
4779         assertEquals(2, rt_38943_index_count);
4780         assertEquals(2, rt_38943_item_count);
4781     }
4782 
4783     @Test public void test_rt_38884() {
4784         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4785         final TreeItem&lt;String&gt; foo = new TreeItem&lt;&gt;(&quot;foo&quot;);
4786 
4787         TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
4788         treeView.setShowRoot(false);
4789         root.setExpanded(true);
4790 
4791         treeView.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;String&gt;&gt; c) -&gt; {
4792             while (c.next()) {
4793                 if (c.wasRemoved()) {
4794                     assertTrue(c.getRemovedSize() &gt; 0);
4795 
4796                     List&lt;? extends TreeItem&lt;String&gt;&gt; removed = c.getRemoved();
4797                     TreeItem&lt;String&gt; removedItem = null;
4798                     try {
4799                         removedItem = removed.get(0);
4800                     } catch (Exception e) {
4801                         fail();
4802                     }
4803 
4804                     assertEquals(foo, removedItem);
4805                 }
4806             }
4807         });
4808 
4809         root.getChildren().add(foo);
4810         treeView.getSelectionModel().select(0);
4811         root.getChildren().clear();
4812     }
4813 
4814     private int rt_37360_add_count = 0;
4815     private int rt_37360_remove_count = 0;
4816     @Test public void test_rt_37360() {
4817         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4818         root.setExpanded(true);
4819         root.getChildren().addAll(
4820                 new TreeItem&lt;&gt;(&quot;a&quot;),
4821                 new TreeItem&lt;&gt;(&quot;b&quot;)
4822         );
4823 
4824         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4825         stringTreeTableView.setShowRoot(false);
4826 
4827         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4828         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4829         stringTreeTableView.getColumns().add(column);
4830 
4831         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4832         sm.setSelectionMode(SelectionMode.MULTIPLE);
4833         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
4834             while (c.next()) {
4835                 if (c.wasAdded()) {
4836                     rt_37360_add_count += c.getAddedSize();
4837                 }
4838                 if (c.wasRemoved()) {
4839                     rt_37360_remove_count += c.getRemovedSize();
4840                 }
4841             }
4842         });
4843 
4844         assertEquals(0, sm.getSelectedItems().size());
4845         assertEquals(0, rt_37360_add_count);
4846         assertEquals(0, rt_37360_remove_count);
4847 
4848         sm.select(0);
4849         assertEquals(1, sm.getSelectedItems().size());
4850         assertEquals(1, rt_37360_add_count);
4851         assertEquals(0, rt_37360_remove_count);
4852 
4853         sm.select(1);
4854         assertEquals(2, sm.getSelectedItems().size());
4855         assertEquals(2, rt_37360_add_count);
4856         assertEquals(0, rt_37360_remove_count);
4857 
4858         sm.clearAndSelect(1);
4859         assertEquals(1, sm.getSelectedItems().size());
4860         assertEquals(2, rt_37360_add_count);
4861         assertEquals(1, rt_37360_remove_count);
4862     }
4863 
4864     private int rt_37366_count = 0;
4865     @Test public void test_rt_37366() {
4866         final TreeItem&lt;String&gt; treeItem2 = new TreeItem&lt;&gt;(&quot;Item 2&quot;);
4867         treeItem2.getChildren().addAll(new TreeItem&lt;&gt;(&quot;Item 21&quot;), new TreeItem&lt;&gt;(&quot;Item 22&quot;));
4868 
4869         final TreeItem&lt;String&gt; root1 = new TreeItem&lt;&gt;(&quot;Root Node 1&quot;);
4870         TreeItem&lt;String&gt; treeItem1 = new TreeItem&lt;&gt;(&quot;Item 1&quot;);
4871         root1.getChildren().addAll(treeItem1, treeItem2, new TreeItem&lt;&gt;(&quot;Item 3&quot;));
4872         root1.setExpanded(true);
4873 
4874         final TreeItem&lt;String&gt; root2 = new TreeItem&lt;&gt;(&quot;Root Node 2&quot;);
4875 
4876         final TreeItem&lt;String&gt; hiddenRoot = new TreeItem&lt;&gt;(&quot;Hidden Root Node&quot;);
4877         hiddenRoot.getChildren().add(root1);
4878         hiddenRoot.getChildren().add(root2);
4879 
4880         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(hiddenRoot);
4881         treeView.setShowRoot(false);
4882 
4883         AtomicInteger step = new AtomicInteger();
4884         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeView.getSelectionModel();
4885         sm.setSelectionMode(SelectionMode.MULTIPLE);
4886         sm.getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;String&gt;&gt; c) -&gt; {
4887             switch (step.get()) {
4888                 case 0: {
4889                     // we expect treeItem1 to be the only item added
4890                     while (c.next()) {
4891                         assertFalse(c.wasRemoved());
4892                         assertTrue(c.wasAdded());
4893                         assertEquals(1, c.getAddedSize());
4894                         assertTrue(c.getAddedSubList().contains(treeItem1));
4895                     }
4896                     break;
4897                 }
4898                 case 1: {
4899                     // we expect treeItem2 to be the only item added
4900                     while (c.next()) {
4901                         assertFalse(c.wasRemoved());
4902                         assertTrue(c.wasAdded());
4903                         assertEquals(1, c.getAddedSize());
4904                         assertTrue(c.getAddedSubList().contains(treeItem2));
4905                     }
4906                     break;
4907                 }
4908                 case 2: {
4909                     // we expect treeItem1 and treeItem2 to be removed in one separate event,
4910                     // and then we expect a separate event for root1 to be added. Therefore,
4911                     // once the remove event is received, we will increment the step to test for
4912                     // the addition
4913                     boolean wasRemoved = false;
4914                     while (c.next()) {
4915                         if (c.wasAdded()) {
4916                             fail(&quot;no addition expected yet&quot;);
4917                         }
4918                         if (c.wasRemoved()) {
4919                             assertTrue(c.getRemoved().containsAll(FXCollections.observableArrayList(treeItem1, treeItem2)));
4920                             wasRemoved = true;
4921                         }
4922                     }
4923                     if (!wasRemoved) {
4924                         fail(&quot;Expected a remove operation&quot;);
4925                     }
4926                     step.incrementAndGet();
4927                     break;
4928                 }
4929                 case 3: {
4930                     boolean wasAdded = false;
4931                     while (c.next()) {
4932                         if (c.wasAdded()) {
4933                             assertEquals(1, c.getAddedSize());
4934                             assertTrue(c.getAddedSubList().contains(root1));
4935                             wasAdded = true;
4936                         }
4937                         if (c.wasRemoved()) {
4938                             fail(&quot;no removal expected now&quot;);
4939                         }
4940                     }
4941                     if (!wasAdded) {
4942                         fail(&quot;Expected an add operation&quot;);
4943                     }
4944                     break;
4945                 }
4946             }
4947             rt_37366_count++;
4948         });
4949 
4950         assertEquals(0, rt_37366_count);
4951 
4952         step.set(0);
4953         sm.select(1); // select &quot;Item 1&quot;
4954         assertEquals(1, rt_37366_count);
4955         assertFalse(sm.isSelected(0));
4956         assertTrue(sm.isSelected(1));
4957         assertFalse(sm.isSelected(2));
4958 
4959         step.set(1);
4960         sm.select(2); // select &quot;Item 2&quot;
4961         assertEquals(2, rt_37366_count);
4962         assertFalse(sm.isSelected(0));
4963         assertTrue(sm.isSelected(1));
4964         assertTrue(sm.isSelected(2));
4965 
4966         step.set(2);
4967         root1.setExpanded(false); // collapse &quot;Root Node 1&quot; and deselect the two children, moving selection up to &quot;Root Node 1&quot;
4968         assertEquals(4, rt_37366_count);
4969         assertTrue(sm.isSelected(0));
4970         assertFalse(sm.isSelected(1));
4971         assertFalse(sm.isSelected(2));
4972     }
4973 
4974     @Test public void test_rt_38491() {
4975         TreeItem&lt;String&gt; a;
4976         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4977         root.setExpanded(true);
4978         root.getChildren().addAll(
4979                 a = new TreeItem&lt;&gt;(&quot;a&quot;),
4980                 new TreeItem&lt;&gt;(&quot;b&quot;)
4981         );
4982 
4983         TreeTableView&lt;String&gt; stringTreeView = new TreeTableView&lt;&gt;(root);
4984         stringTreeView.setShowRoot(false);
4985 
4986         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4987         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4988         stringTreeView.getColumns().add(column);
4989 
4990         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeView.getSelectionModel();
4991         sm.setSelectionMode(SelectionMode.MULTIPLE);
4992 
4993         TreeTableViewFocusModel&lt;String&gt; fm = stringTreeView.getFocusModel();
4994 
4995         StageLoader sl = new StageLoader(stringTreeView);
4996 
4997         // test pre-conditions
4998         assertTrue(sm.isEmpty());
4999         assertEquals(a, fm.getFocusedItem());
5000         assertEquals(0, fm.getFocusedIndex());
5001 
5002         // click on row 0
5003 //        VirtualFlowTestUtils.clickOnRow(stringTreeView, 0);
5004         sm.select(0, column);
5005         assertTrue(sm.isSelected(0));
5006         assertEquals(a, sm.getSelectedItem());
5007         assertTrue(fm.isFocused(0));
5008         assertEquals(a, fm.getFocusedItem());
5009         assertEquals(0, fm.getFocusedIndex());
5010         assertEquals(0, fm.getFocusedCell().getRow());
5011         assertEquals(column, fm.getFocusedCell().getTableColumn());
5012 
5013         TreeTablePosition&lt;String, ?&gt; anchor = TreeTableCellBehavior.getAnchor(stringTreeView, null);
5014         assertNotNull(anchor);
5015         assertTrue(TreeTableCellBehavior.hasNonDefaultAnchor(stringTreeView));
5016         assertEquals(0, anchor.getRow());
5017 
5018         // now add a new item at row 0. This has the effect of pushing down
5019         // the selected item into row 1.
5020         root.getChildren().add(0, new TreeItem(&quot;z&quot;));
5021 
5022         // The first bug was that selection and focus were not moving down to
5023         // be on row 1, so we test that now
5024         assertFalse(sm.isSelected(0));
5025         assertFalse(fm.isFocused(0));
5026         assertTrue(sm.isSelected(1));
5027         assertEquals(a, sm.getSelectedItem());
5028         assertTrue(fm.isFocused(1));
5029         assertEquals(a, fm.getFocusedItem());
5030         assertEquals(1, fm.getFocusedIndex());
5031         assertEquals(1, fm.getFocusedCell().getRow());
5032         assertEquals(column, fm.getFocusedCell().getTableColumn());
5033 
5034         // The second bug was that the anchor was not being pushed down as well
5035         // (when it should).
5036         anchor = TreeTableCellBehavior.getAnchor(stringTreeView, null);
5037         assertNotNull(anchor);
5038         assertTrue(TreeTableCellBehavior.hasNonDefaultAnchor(stringTreeView));
5039         assertEquals(1, anchor.getRow());
5040         assertEquals(column, anchor.getTableColumn());
5041 
5042         sl.dispose();
5043     }
5044 
5045     private final ObservableList&lt;TreeItem&lt;String&gt;&gt; rt_39256_list = FXCollections.observableArrayList();
5046     @Test public void test_rt_39256() {
5047         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5048         root.setExpanded(true);
5049         root.getChildren().addAll(
5050                 new TreeItem&lt;&gt;(&quot;a&quot;),
5051                 new TreeItem&lt;&gt;(&quot;b&quot;),
5052                 new TreeItem&lt;&gt;(&quot;c&quot;),
5053                 new TreeItem&lt;&gt;(&quot;d&quot;)
5054         );
5055 
5056         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5057         stringTreeTableView.setShowRoot(false);
5058 
5059         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5060         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5061         stringTreeTableView.getColumns().add(column);
5062 
5063         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
5064         sm.setSelectionMode(SelectionMode.MULTIPLE);
5065 
5066 //        rt_39256_list.addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) change -&gt; {
5067 //            while (change.next()) {
5068 //                System.err.println(&quot;number of selected persons (in bound list): &quot; + change.getList().size());
5069 //            }
5070 //        });
5071 
5072         Bindings.bindContent(rt_39256_list, sm.getSelectedItems());
5073 
5074         assertEquals(0, sm.getSelectedItems().size());
5075         assertEquals(0, rt_39256_list.size());
5076 
5077         sm.selectAll();
5078         assertEquals(4, sm.getSelectedItems().size());
5079         assertEquals(4, rt_39256_list.size());
5080 
5081         sm.selectAll();
5082         assertEquals(4, sm.getSelectedItems().size());
5083         assertEquals(4, rt_39256_list.size());
5084 
5085         sm.selectAll();
5086         assertEquals(4, sm.getSelectedItems().size());
5087         assertEquals(4, rt_39256_list.size());
5088     }
5089 
5090     private final ObservableList&lt;TreeItem&lt;String&gt;&gt; rt_39482_list = FXCollections.observableArrayList();
5091     @Test public void test_rt_39482() {
5092         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5093         root.setExpanded(true);
5094         root.getChildren().addAll(
5095                 new TreeItem&lt;&gt;(&quot;a&quot;),
5096                 new TreeItem&lt;&gt;(&quot;b&quot;),
5097                 new TreeItem&lt;&gt;(&quot;c&quot;),
5098                 new TreeItem&lt;&gt;(&quot;d&quot;)
5099         );
5100 
5101         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5102         stringTreeTableView.setShowRoot(false);
5103 
5104         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5105         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5106         stringTreeTableView.getColumns().add(column);
5107 
5108         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5109         sm.setSelectionMode(SelectionMode.MULTIPLE);
5110 
5111 //        rt_39256_list.addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) change -&gt; {
5112 //            while (change.next()) {
5113 //                System.err.println(&quot;number of selected persons (in bound list): &quot; + change.getList().size());
5114 //            }
5115 //        });
5116 
5117         Bindings.bindContent(rt_39482_list, sm.getSelectedItems());
5118 
5119         assertEquals(0, sm.getSelectedItems().size());
5120         assertEquals(0, rt_39482_list.size());
5121 
5122         test_rt_39482_selectRow(&quot;a&quot;, sm, 0, column);
5123         test_rt_39482_selectRow(&quot;b&quot;, sm, 1, column);
5124         test_rt_39482_selectRow(&quot;c&quot;, sm, 2, column);
5125         test_rt_39482_selectRow(&quot;d&quot;, sm, 3, column);
5126     }
5127 
5128     private void test_rt_39482_selectRow(String expectedString,
5129                                          TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm,
5130                                          int rowToSelect,
5131                                          TreeTableColumn&lt;String,String&gt; columnToSelect) {
5132         System.out.println(&quot;\nSelect row &quot; + rowToSelect);
5133         sm.selectAll();
5134         assertEquals(4, sm.getSelectedCells().size());
5135         assertEquals(4, sm.getSelectedIndices().size());
5136         assertEquals(4, sm.getSelectedItems().size());
5137         assertEquals(4, rt_39482_list.size());
5138 
5139         sm.clearAndSelect(rowToSelect, columnToSelect);
5140         assertEquals(1, sm.getSelectedCells().size());
5141         assertEquals(1, sm.getSelectedIndices().size());
5142         assertEquals(1, sm.getSelectedItems().size());
5143         assertEquals(expectedString, sm.getSelectedItem().getValue());
5144         assertEquals(expectedString, rt_39482_list.get(0).getValue());
5145         assertEquals(1, rt_39482_list.size());
5146     }
5147 
5148     @Test public void test_rt_39559_useSM_selectAll() {
5149         test_rt_39559(true);
5150     }
5151 
5152     @Test public void test_rt_39559_useKeyboard_selectAll() {
5153         test_rt_39559(false);
5154     }
5155 
5156     private void test_rt_39559(boolean useSMSelectAll) {
5157         TreeItem&lt;String&gt; a, b;
5158         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5159         root.setExpanded(true);
5160         root.getChildren().addAll(
5161                 a = new TreeItem&lt;&gt;(&quot;a&quot;),
5162                 b = new TreeItem&lt;&gt;(&quot;b&quot;),
5163                 new TreeItem&lt;&gt;(&quot;c&quot;),
5164                 new TreeItem&lt;&gt;(&quot;d&quot;)
5165         );
5166 
5167         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5168         stringTreeTableView.setShowRoot(false);
5169 
5170         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5171         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5172         stringTreeTableView.getColumns().add(column);
5173 
5174         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5175         sm.setSelectionMode(SelectionMode.MULTIPLE);
5176 
5177         StageLoader sl = new StageLoader(stringTreeTableView);
5178         KeyEventFirer keyboard = new KeyEventFirer(stringTreeTableView);
5179 
5180         assertEquals(0, sm.getSelectedItems().size());
5181 
5182         sm.clearAndSelect(0);
5183 
5184         if (useSMSelectAll) {
5185             sm.selectAll();
5186         } else {
5187             keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
5188         }
5189 
5190         assertEquals(4, sm.getSelectedItems().size());
5191         assertEquals(0, ((TreeTablePosition) TreeTableCellBehavior.getAnchor(stringTreeTableView, null)).getRow());
5192 
5193         keyboard.doKeyPress(KeyCode.DOWN, KeyModifier.SHIFT);
5194 
5195         assertEquals(0, ((TreeTablePosition) TreeTableCellBehavior.getAnchor(stringTreeTableView, null)).getRow());
5196         assertEquals(2, sm.getSelectedItems().size());
5197         assertEquals(a, sm.getSelectedItems().get(0));
5198         assertEquals(b, sm.getSelectedItems().get(1));
5199 
5200         sl.dispose();
5201     }
5202 
5203     @Test public void test_rt_16068_firstElement_selectAndRemoveSameRow() {
5204         // select and then remove the &#39;a&#39; item, selection and focus should both
5205         // stay at the first row, now &#39;b&#39;
5206         test_rt_16068(0, 0, 0);
5207     }
5208 
5209     @Test public void test_rt_16068_firstElement_selectRowAndRemoveLaterSibling() {
5210         // select row &#39;a&#39;, and remove row &#39;c&#39;, selection and focus should not change
5211         test_rt_16068(0, 2, 0);
5212     }
5213 
5214     @Test public void test_rt_16068_middleElement_selectAndRemoveSameRow() {
5215         // select and then remove the &#39;b&#39; item, selection and focus should both
5216         // move up one row to the &#39;a&#39; item
5217         test_rt_16068(1, 1, 0);
5218     }
5219 
5220     @Test public void test_rt_16068_middleElement_selectRowAndRemoveLaterSibling() {
5221         // select row &#39;b&#39;, and remove row &#39;c&#39;, selection and focus should not change
5222         test_rt_16068(1, 2, 1);
5223     }
5224 
5225     @Test public void test_rt_16068_middleElement_selectRowAndRemoveEarlierSibling() {
5226         // select row &#39;b&#39;, and remove row &#39;a&#39;, selection and focus should move up
5227         // one row, remaining on &#39;b&#39;
5228         test_rt_16068(1, 0, 0);
5229     }
5230 
5231     @Test public void test_rt_16068_lastElement_selectAndRemoveSameRow() {
5232         // select and then remove the &#39;d&#39; item, selection and focus should both
5233         // move up one row to the &#39;c&#39; item
5234         test_rt_16068(3, 3, 2);
5235     }
5236 
5237     @Test public void test_rt_16068_lastElement_selectRowAndRemoveEarlierSibling() {
5238         // select row &#39;d&#39;, and remove row &#39;a&#39;, selection and focus should move up
5239         // one row, remaining on &#39;d&#39;
5240         test_rt_16068(3, 0, 2);
5241     }
5242 
5243     private void test_rt_16068(int indexToSelect, int indexToRemove, int expectedIndex) {
5244         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5245         root.setExpanded(true);
5246         root.getChildren().addAll(
5247                 new TreeItem&lt;&gt;(&quot;a&quot;), // 0
5248                 new TreeItem&lt;&gt;(&quot;b&quot;), // 1
5249                 new TreeItem&lt;&gt;(&quot;c&quot;), // 2
5250                 new TreeItem&lt;&gt;(&quot;d&quot;)  // 3
5251         );
5252 
5253         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5254         stringTreeTableView.setShowRoot(false);
5255 
5256         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5257         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5258         stringTreeTableView.getColumns().add(column);
5259 
5260         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5261         FocusModel&lt;TreeItem&lt;String&gt;&gt; fm = stringTreeTableView.getFocusModel();
5262 
5263         sm.select(indexToSelect);
5264         assertEquals(indexToSelect, sm.getSelectedIndex());
5265         assertEquals(root.getChildren().get(indexToSelect).getValue(), sm.getSelectedItem().getValue());
5266         assertEquals(indexToSelect, fm.getFocusedIndex());
5267         assertEquals(root.getChildren().get(indexToSelect).getValue(), fm.getFocusedItem().getValue());
5268 
5269         root.getChildren().remove(indexToRemove);
5270         assertEquals(expectedIndex, sm.getSelectedIndex());
5271         assertEquals(root.getChildren().get(expectedIndex).getValue(), sm.getSelectedItem().getValue());
5272         assertEquals(debug(), expectedIndex, fm.getFocusedIndex());
5273         assertEquals(root.getChildren().get(expectedIndex).getValue(), fm.getFocusedItem().getValue());
5274     }
5275 
5276     @Test public void test_rt_39675() {
5277         TreeItem&lt;String&gt; b;
5278         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5279         root.setExpanded(true);
5280         root.getChildren().addAll(
5281                 new TreeItem&lt;&gt;(&quot;a&quot;),
5282                 b = new TreeItem&lt;&gt;(&quot;b&quot;),
5283                 new TreeItem&lt;&gt;(&quot;c&quot;),
5284                 new TreeItem&lt;&gt;(&quot;d&quot;)
5285         );
5286 
5287         b.setExpanded(true);
5288         b.getChildren().addAll(
5289                 new TreeItem&lt;&gt;(&quot;b1&quot;),
5290                 new TreeItem&lt;&gt;(&quot;b2&quot;),
5291                 new TreeItem&lt;&gt;(&quot;b3&quot;),
5292                 new TreeItem&lt;&gt;(&quot;b4&quot;)
5293         );
5294 
5295         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5296 
5297         TreeTableColumn&lt;String,String&gt; column0 = new TreeTableColumn&lt;&gt;(&quot;Column1&quot;);
5298         column0.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5299 
5300         TreeTableColumn&lt;String,String&gt; column1 = new TreeTableColumn&lt;&gt;(&quot;Column2&quot;);
5301         column1.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5302 
5303         TreeTableColumn&lt;String,String&gt; column2 = new TreeTableColumn&lt;&gt;(&quot;Column3&quot;);
5304         column2.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5305 
5306         stringTreeTableView.getColumns().addAll(column0, column1, column2);
5307 
5308         sm = stringTreeTableView.getSelectionModel();
5309         sm.setSelectionMode(SelectionMode.SINGLE);
5310         sm.setCellSelectionEnabled(true);
5311 
5312         StageLoader sl = new StageLoader(stringTreeTableView);
5313 
5314         assertEquals(0, sm.getSelectedItems().size());
5315 
5316         sm.clearAndSelect(4, column0);  // select &#39;b2&#39; in row 4, column 0
5317         assertTrue(sm.isSelected(4, column0));
5318         assertEquals(1, sm.getSelectedCells().size());
5319         assertEquals(&quot;b2&quot;, ((TreeItem)sm.getSelectedItem()).getValue());
5320 
5321         // collapse the &#39;b&#39; tree item, selection and focus should go to
5322         // the &#39;b&#39; tree item in row 2, column 0
5323         b.setExpanded(false);
5324         assertTrue(sm.isSelected(2, column0));
5325         assertEquals(1, sm.getSelectedCells().size());
5326         assertEquals(&quot;b&quot;, ((TreeItem)sm.getSelectedItem()).getValue());
5327 
5328         sl.dispose();
5329     }
5330 
5331 
5332     private ObservableList&lt;String&gt; test_rt_39661_setup() {
5333         ObservableList&lt;String&gt;  rawItems = FXCollections.observableArrayList(
5334                 &quot;9-item&quot;, &quot;8-item&quot;, &quot;7-item&quot;, &quot;6-item&quot;,
5335                 &quot;5-item&quot;, &quot;4-item&quot;, &quot;3-item&quot;, &quot;2-item&quot;, &quot;1-item&quot;);
5336         root = createSubTree(&quot;root&quot;, rawItems);
5337         root.setExpanded(true);
5338         treeTableView = new TreeTableView(root);
5339         return rawItems;
5340     }
5341 
5342     private TreeItem createSubTree(Object item, ObservableList&lt;String&gt; rawItems) {
5343         TreeItem child = new TreeItem(item);
5344         child.getChildren().setAll(rawItems.stream()
5345                 .map(rawItem -&gt; new TreeItem(rawItem))
5346                 .collect(Collectors.toList()));
5347         return child;
5348     }
5349 
5350     @Test public void test_rt_39661_rowLessThanExpandedItemCount() {
5351         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5352         TreeItem child = createSubTree(&quot;child&quot;, rawItems);
5353         TreeItem grandChild = (TreeItem) child.getChildren().get(rawItems.size() - 1);
5354         root.getChildren().add(child);
5355         assertTrue(&quot;row of item must be less than expandedItemCount, but was: &quot; + treeTableView.getRow(grandChild),
5356                 treeTableView.getRow(grandChild) &lt; treeTableView.getExpandedItemCount());
5357     }
5358 
5359     @Test public void test_rt_39661_rowOfGrandChildParentCollapsedUpdatedOnInsertAbove() {
5360         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5361         int grandIndex = 2;
5362         int childIndex = 3;
5363 
5364         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5365         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5366         root.getChildren().add(childIndex, child);
5367 
5368         int rowOfGrand = treeTableView.getRow(grandChild);
5369         root.getChildren().add(childIndex - 1, createSubTree(&quot;other&quot;, rawItems));
5370 
5371         assertEquals(-1, treeTableView.getRow(grandChild));
5372     }
5373 
5374     @Test public void test_rt_39661_rowOfGrandChildParentCollapsedUpdatedOnInsertAboveWithoutAccess() {
5375         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5376         int grandIndex = 2;
5377         int childIndex = 3;
5378 
5379         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5380         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5381         root.getChildren().add(childIndex, child);
5382 
5383         int rowOfGrand = 7; //treeTableView.getRow(grandChild);
5384         root.getChildren().add(childIndex, createSubTree(&quot;other&quot;, rawItems));
5385 
5386         assertEquals(-1, treeTableView.getRow(grandChild));
5387     }
5388 
5389     @Test public void test_rt_39661_rowOfGrandChildParentExpandedUpdatedOnInsertAbove() {
5390         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5391         int grandIndex = 2;
5392         int childIndex = 3;
5393         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5394         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5395         child.setExpanded(true);
5396         root.getChildren().add(childIndex, child);
5397         int rowOfGrand = treeTableView.getRow(grandChild);
5398         root.getChildren().add(childIndex -1, createSubTree(&quot;other&quot;, rawItems));
5399         assertEquals(rowOfGrand + 1, treeTableView.getRow(grandChild));
5400     }
5401 
5402     /**
5403      * Testing getRow on grandChild: compare collapsed/expanded parent.
5404      */
5405     @Test public void test_rt_39661_rowOfGrandChildDependsOnParentExpansion() {
5406         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5407         int grandIndex = 2;
5408         int childIndex = 3;
5409 
5410         TreeItem collapsedChild = createSubTree(&quot;addedChild&quot;, rawItems);
5411         TreeItem collapsedGrandChild = (TreeItem) collapsedChild.getChildren().get(grandIndex);
5412         root.getChildren().add(childIndex, collapsedChild);
5413 
5414         int collapedGrandIndex = treeTableView.getRow(collapsedGrandChild);
5415         int collapsedRowCount = treeTableView.getExpandedItemCount();
5416 
5417         // start again
5418         test_rt_39661_setup();
5419         assertEquals(collapsedRowCount - 1, treeTableView.getExpandedItemCount());
5420         TreeItem expandedChild = createSubTree(&quot;addedChild2&quot;, rawItems);
5421         TreeItem expandedGrandChild = (TreeItem) expandedChild.getChildren().get(grandIndex);
5422         expandedChild.setExpanded(true);
5423 
5424         root.getChildren().add(childIndex, expandedChild);
5425         assertNotSame(&quot;getRow must depend on expansionState &quot; + collapedGrandIndex,
5426                 collapedGrandIndex, treeTableView.getRow(expandedGrandChild));
5427     }
5428 
5429     @Test public void test_rt_39661_rowOfGrandChildInCollapsedChild() {
5430         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5431 
5432         // create a collapsed new child to insert into the root
5433         TreeItem newChild = createSubTree(&quot;added-child&quot;, rawItems);
5434         TreeItem grandChild = (TreeItem) newChild.getChildren().get(2);
5435         root.getChildren().add(6, newChild);
5436 
5437         // query the row of a grand-child
5438         int row = treeTableView.getRow(grandChild);
5439 
5440         // grandChild not visible, row coordinate in tree is not available
5441         assertEquals(&quot;grandChild not visible&quot;, -1, row);
5442 
5443         // the other way round: if we get a row, expect the item at the row be the grandChild
5444         if (row &gt; -1) {
5445             assertEquals(grandChild, treeTableView.getTreeItem(row));
5446         }
5447     }
5448 
5449     @Test public void test_rt_39661_rowOfRootChild() {
5450         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5451         int index = 2;
5452 
5453         TreeItem child = (TreeItem) root.getChildren().get(index);
5454         assertEquals(index + 1, treeTableView.getRow(child));
5455     }
5456 
5457     @Test public void test_rt_39661_expandedItemCount() {
5458         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5459         int initialRowCount = treeTableView.getExpandedItemCount();
5460         assertEquals(root.getChildren().size() + 1, initialRowCount);
5461 
5462         TreeItem collapsedChild = createSubTree(&quot;collapsed-child&quot;, rawItems);
5463         root.getChildren().add(collapsedChild);
5464         assertEquals(initialRowCount + 1, treeTableView.getExpandedItemCount());
5465 
5466         TreeItem expandedChild = createSubTree(&quot;expanded-child&quot;, rawItems);
5467         expandedChild.setExpanded(true);
5468         root.getChildren().add(0, expandedChild);
5469         assertEquals(2 * initialRowCount + 1, treeTableView.getExpandedItemCount());
5470     }
5471 
5472     private int test_rt_39822_count = 0;
5473     @Test public void test_rt_39822() {
5474         // get the current exception handler before replacing with our own,
5475         // as ListListenerHelp intercepts the exception otherwise
5476         final Thread.UncaughtExceptionHandler exceptionHandler = Thread.currentThread().getUncaughtExceptionHandler();
5477         Thread.currentThread().setUncaughtExceptionHandler((t, e) -&gt; {
5478 
5479             if (test_rt_39822_count == 0) {
5480                 test_rt_39822_count++;
5481                 if (! (e instanceof IllegalStateException)) {
5482                     e.printStackTrace();
5483                     fail(&quot;Expected IllegalStateException, instead got &quot; + e);
5484                 }
5485             } else {
5486                 // don&#39;t care
5487                 test_rt_39822_count++;
5488             }
5489         });
5490 
5491         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
5492         TreeTableColumn&lt;String, String&gt; col1 = new TreeTableColumn&lt;&gt;(&quot;Foo&quot;);
5493         table.getColumns().addAll(col1, col1);  // add column twice
5494 
5495         StageLoader sl = null;
5496         try {
5497             sl = new StageLoader(table);
5498         } finally {
5499             if (sl != null) {
5500                 sl.dispose();
5501             }
5502 
5503             // reset the exception handler
5504             Thread.currentThread().setUncaughtExceptionHandler(exceptionHandler);
5505         }
5506     }
5507 
5508     private int test_rt_39842_count = 0;
5509     @Test public void test_rt_39842_selectLeftDown() {
5510         test_rt_39842(true, false);
5511     }
5512 
5513     @Test public void test_rt_39842_selectLeftUp() {
5514         test_rt_39842(true, true);
5515     }
5516 
5517     @Test public void test_rt_39842_selectRightDown() {
5518         test_rt_39842(false, false);
5519     }
5520 
5521     @Test public void test_rt_39842_selectRightUp() {
5522         test_rt_39842(false, true);
5523     }
5524 
5525     private void test_rt_39842(boolean selectToLeft, boolean selectUpwards) {
5526         test_rt_39842_count = 0;
5527 
5528         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
5529         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
5530 
5531         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
5532         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
5533 
5534         TreeItem root = new TreeItem(&quot;root&quot;);
5535         root.getChildren().setAll(
5536                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
5537                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
5538                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
5539                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
5540                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
5541         root.setExpanded(true);
5542 
5543         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;(root);
5544         table.setShowRoot(false);
5545         table.getColumns().addAll(firstNameCol, lastNameCol);
5546 
5547         sm = table.getSelectionModel();
5548         sm.setCellSelectionEnabled(true);
5549         sm.setSelectionMode(SelectionMode.MULTIPLE);
5550         sm.getSelectedCells().addListener((ListChangeListener) c -&gt; test_rt_39842_count++);
5551 
5552         StageLoader sl = new StageLoader(table);
5553 
5554         assertEquals(0, test_rt_39842_count);
5555 
5556         if (selectToLeft) {
5557             if (selectUpwards) {
5558                 sm.selectRange(3, lastNameCol, 0, firstNameCol);
5559             } else {
5560                 sm.selectRange(0, lastNameCol, 3, firstNameCol);
5561             }
5562         } else {
5563             if (selectUpwards) {
5564                 sm.selectRange(3, firstNameCol, 0, lastNameCol);
5565             } else {
5566                 sm.selectRange(0, firstNameCol, 3, lastNameCol);
5567             }
5568         }
5569 
5570         // test model state
5571         assertEquals(8, sm.getSelectedCells().size());
5572         assertEquals(1, test_rt_39842_count);
5573 
5574         // test visual state
5575         for (int row = 0; row &lt;= 3; row++) {
5576             for (int column = 0; column &lt;= 1; column++) {
5577                 IndexedCell cell = VirtualFlowTestUtils.getCell(table, row, column);
5578                 assertTrue(cell.isSelected());
5579             }
5580         }
5581 
5582         sl.dispose();
5583     }
5584 
5585     @Test public void test_rt_22599() {
5586         TreeItem&lt;RT22599_DataType&gt; root = new TreeItem&lt;&gt;();
5587         root.getChildren().setAll(
5588                 new TreeItem&lt;&gt;(new RT22599_DataType(1, &quot;row1&quot;)),
5589                 new TreeItem&lt;&gt;(new RT22599_DataType(2, &quot;row2&quot;)),
5590                 new TreeItem&lt;&gt;(new RT22599_DataType(3, &quot;row3&quot;)));
5591         root.setExpanded(true);
5592 
5593         TreeTableColumn&lt;RT22599_DataType, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;Header&quot;);
5594         col.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue().text));
5595 
5596         TreeTableView&lt;RT22599_DataType&gt; table = new TreeTableView&lt;&gt;(root);
5597         table.setShowRoot(false);
5598         table.getColumns().addAll(col);
5599 
5600         StageLoader sl = new StageLoader(table);
5601 
5602         // testing initial state
5603         assertNotNull(table.getSkin());
5604         assertEquals(&quot;row1&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5605         assertEquals(&quot;row2&quot;, VirtualFlowTestUtils.getCell(table, 1, 0).getText());
5606         assertEquals(&quot;row3&quot;, VirtualFlowTestUtils.getCell(table, 2, 0).getText());
5607 
5608         // change row 0 (where &quot;row1&quot; currently resides), keeping same id.
5609         // Because &#39;set&#39; is called, the control should update to the new content
5610         // without any user interaction
5611         TreeItem&lt;RT22599_DataType&gt; data;
5612         root.getChildren().set(0, data = new TreeItem&lt;&gt;(new RT22599_DataType(0, &quot;row1a&quot;)));
5613         Toolkit.getToolkit().firePulse();
5614         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5615 
5616         // change the row 0 (where we currently have &quot;row1a&quot;) value directly.
5617         // Because there is no associated property, this won&#39;t be observed, so
5618         // the control should still show &quot;row1a&quot; rather than &quot;row1b&quot;
5619         data.getValue().text = &quot;row1b&quot;;
5620         Toolkit.getToolkit().firePulse();
5621         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5622 
5623         // call refresh() to force a refresh of all visible cells
5624         table.refresh();
5625         Toolkit.getToolkit().firePulse();
5626         assertEquals(&quot;row1b&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5627 
5628         sl.dispose();
5629     }
5630 
5631     private static class RT22599_DataType {
5632         public int id = 0;
5633         public String text = &quot;&quot;;
5634 
5635         public RT22599_DataType(int id, String text) {
5636             this.id = id;
5637             this.text = text;
5638         }
5639 
5640         @Override public boolean equals(Object obj) {
5641             if (obj == null) return false;
5642             return id == ((RT22599_DataType)obj).id;
5643         }
5644     }
5645 
5646     private int rt_39966_count = 0;
5647     @Test public void test_rt_39966() {
5648         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5649         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;(root);
5650         table.setShowRoot(true);
5651 
5652         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5653         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5654         table.getColumns().add(column);
5655 
5656         StageLoader sl = new StageLoader(table);
5657 
5658         // initially there is no selection
5659         assertTrue(table.getSelectionModel().isEmpty());
5660 
5661         table.getSelectionModel().selectedItemProperty().addListener((value, s1, s2) -&gt; {
5662             if (rt_39966_count == 0) {
5663                 rt_39966_count++;
5664                 assertFalse(table.getSelectionModel().isEmpty());
5665             } else {
5666                 assertTrue(table.getSelectionModel().isEmpty());
5667             }
5668         });
5669 
5670         // our assertion two lines down always succeeds. What fails is our
5671         // assertion above within the listener.
5672         table.getSelectionModel().select(0);
5673         assertFalse(table.getSelectionModel().isEmpty());
5674 
5675         table.setRoot(null);
5676         assertTrue(table.getSelectionModel().isEmpty());
5677 
5678         sl.dispose();
5679     }
5680 
5681     /**
5682      * Bullet 1: selected index must be updated
5683      * Corner case: last selected. Fails for core
5684      */
5685     @Test public void test_rt_40012_selectedAtLastOnDisjointRemoveItemsAbove() {
5686         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5687         root.setExpanded(true);
5688         root.getChildren().addAll(
5689             new TreeItem&lt;&gt;(&quot;0&quot;),
5690             new TreeItem&lt;&gt;(&quot;1&quot;),
5691             new TreeItem&lt;&gt;(&quot;2&quot;),
5692             new TreeItem&lt;&gt;(&quot;3&quot;),
5693             new TreeItem&lt;&gt;(&quot;4&quot;),
5694             new TreeItem&lt;&gt;(&quot;5&quot;)
5695         );
5696 
5697         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5698         stringTreeTableView.setShowRoot(false);
5699         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5700 
5701         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5702         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5703         stringTreeTableView.getColumns().add(column);
5704 
5705         int last = root.getChildren().size() - 1;
5706 
5707         // selecting item &quot;5&quot;
5708         sm.select(last);
5709 
5710         // disjoint remove of 2 elements above the last selected
5711         // Removing &quot;1&quot; and &quot;3&quot;
5712         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5713 
5714         // selection should move up two places such that it remains on item &quot;5&quot;,
5715         // but in index (last - 2).
5716         int expected = last - 2;
5717         assertEquals(&quot;5&quot;, sm.getSelectedItem().getValue());
5718         assertEquals(&quot;selected index after disjoint removes above&quot;, expected, sm.getSelectedIndex());
5719     }
5720 
5721     /**
5722      * Variant of 1: if selectedIndex is not updated,
5723      * the old index is no longer valid
5724      * for accessing the items.
5725      */
5726     @Test public void test_rt_40012_accessSelectedAtLastOnDisjointRemoveItemsAbove() {
5727         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5728         root.setExpanded(true);
5729         root.getChildren().addAll(
5730                 new TreeItem&lt;&gt;(&quot;0&quot;),
5731                 new TreeItem&lt;&gt;(&quot;1&quot;),
5732                 new TreeItem&lt;&gt;(&quot;2&quot;),
5733                 new TreeItem&lt;&gt;(&quot;3&quot;),
5734                 new TreeItem&lt;&gt;(&quot;4&quot;),
5735                 new TreeItem&lt;&gt;(&quot;5&quot;)
5736         );
5737 
5738         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5739         stringTreeTableView.setShowRoot(false);
5740         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5741 
5742         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5743         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5744         stringTreeTableView.getColumns().add(column);
5745 
5746         int last = root.getChildren().size() - 1;
5747 
5748         // selecting item &quot;5&quot;
5749         sm.select(last);
5750 
5751         // disjoint remove of 2 elements above the last selected
5752         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5753         int selected = sm.getSelectedIndex();
5754         if (selected &gt; -1) {
5755             root.getChildren().get(selected);
5756         }
5757     }
5758 
5759     /**
5760      * Bullet 2: selectedIndex notification count
5761      *
5762      * Note that we don&#39;t use the corner case of having the last index selected
5763      * (which fails already on updating the index)
5764      */
5765     private int rt_40012_count = 0;
5766     @Test public void test_rt_40012_selectedIndexNotificationOnDisjointRemovesAbove() {
5767         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5768         root.setExpanded(true);
5769         root.getChildren().addAll(
5770                 new TreeItem&lt;&gt;(&quot;0&quot;),
5771                 new TreeItem&lt;&gt;(&quot;1&quot;),
5772                 new TreeItem&lt;&gt;(&quot;2&quot;),
5773                 new TreeItem&lt;&gt;(&quot;3&quot;),
5774                 new TreeItem&lt;&gt;(&quot;4&quot;),
5775                 new TreeItem&lt;&gt;(&quot;5&quot;)
5776         );
5777 
5778         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5779         stringTreeTableView.setShowRoot(false);
5780         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5781 
5782         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5783         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5784         stringTreeTableView.getColumns().add(column);
5785 
5786         int last = root.getChildren().size() - 2;
5787         sm.select(last);
5788         assertEquals(last, sm.getSelectedIndex());
5789 
5790         rt_40012_count = 0;
5791         sm.selectedIndexProperty().addListener(o -&gt; rt_40012_count++);
5792 
5793         // disjoint remove of 2 elements above the last selected
5794         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5795         assertEquals(&quot;sanity: selectedIndex must be shifted by -2&quot;, last - 2, sm.getSelectedIndex());
5796         assertEquals(&quot;must fire single event on removes above&quot;, 1, rt_40012_count);
5797     }
5798 
5799     /**
5800      * Bullet 3: unchanged selectedItem must not fire change
5801      */
5802     @Test
5803     public void test_rt_40012_selectedItemNotificationOnDisjointRemovesAbove() {
5804         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5805         root.setExpanded(true);
5806         root.getChildren().addAll(
5807                 new TreeItem&lt;&gt;(&quot;0&quot;),
5808                 new TreeItem&lt;&gt;(&quot;1&quot;),
5809                 new TreeItem&lt;&gt;(&quot;2&quot;),
5810                 new TreeItem&lt;&gt;(&quot;3&quot;),
5811                 new TreeItem&lt;&gt;(&quot;4&quot;),
5812                 new TreeItem&lt;&gt;(&quot;5&quot;)
5813         );
5814 
5815         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5816         stringTreeTableView.setShowRoot(false);
5817         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5818 
5819         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5820         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5821         stringTreeTableView.getColumns().add(column);
5822 
5823         int last = root.getChildren().size() - 2;
5824         Object lastItem = root.getChildren().get(last);
5825         sm.select(last);
5826         assertEquals(lastItem, sm.getSelectedItem());
5827 
5828         rt_40012_count = 0;
5829         sm.selectedItemProperty().addListener(o -&gt; rt_40012_count++);
5830 
5831         // disjoint remove of 2 elements above the last selected
5832         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5833         assertEquals(&quot;sanity: selectedItem unchanged&quot;, lastItem, sm.getSelectedItem());
5834         assertEquals(&quot;must not fire on unchanged selected item&quot;, 0, rt_40012_count);
5835     }
5836 
5837     private int rt_40010_count = 0;
5838     @Test public void test_rt_40010() {
5839         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5840         TreeItem&lt;String&gt; child = new TreeItem&lt;&gt;(&quot;child&quot;);
5841         root.setExpanded(true);
5842         root.getChildren().addAll(child);
5843 
5844         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5845         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5846 
5847         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5848         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5849         stringTreeTableView.getColumns().add(column);
5850 
5851         sm.getSelectedIndices().addListener((ListChangeListener&lt;? super Integer&gt;) l -&gt; rt_40010_count++);
5852         sm.getSelectedItems().addListener((ListChangeListener&lt;? super TreeItem&lt;String&gt;&gt;) l -&gt; rt_40010_count++);
5853 
5854         assertEquals(0, rt_40010_count);
5855 
5856         sm.select(1);
5857         assertEquals(1, sm.getSelectedIndex());
5858         assertEquals(child, sm.getSelectedItem());
5859         assertEquals(2, rt_40010_count);
5860 
5861         root.getChildren().remove(child);
5862         assertEquals(0, sm.getSelectedIndex());
5863         assertEquals(root, sm.getSelectedItem());
5864         assertEquals(4, rt_40010_count);
5865     }
5866 
5867     /**
5868      * ClearAndSelect fires invalid change event if selectedIndex is unchanged.
5869      */
5870     private int rt_40212_count = 0;
5871     @Test public void test_rt_40212() {
5872         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5873         root.setExpanded(true);
5874         root.getChildren().addAll(
5875                 new TreeItem&lt;&gt;(&quot;0&quot;),
5876                 new TreeItem&lt;&gt;(&quot;1&quot;),
5877                 new TreeItem&lt;&gt;(&quot;2&quot;),
5878                 new TreeItem&lt;&gt;(&quot;3&quot;),
5879                 new TreeItem&lt;&gt;(&quot;4&quot;),
5880                 new TreeItem&lt;&gt;(&quot;5&quot;)
5881         );
5882 
5883         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5884         stringTreeTableView.setShowRoot(false);
5885 
5886         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5887         sm.setSelectionMode(SelectionMode.MULTIPLE);
5888 
5889         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5890         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5891         stringTreeTableView.getColumns().add(column);
5892 
5893         sm.selectRange(3, 5);
5894         int selected = sm.getSelectedIndex();
5895 
5896         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) change -&gt; {
5897             assertEquals(&quot;sanity: selectedIndex unchanged&quot;, selected, sm.getSelectedIndex());
5898             while(change.next()) {
5899                 assertEquals(&quot;single event on clearAndSelect already selected&quot;, 1, ++rt_40212_count);
5900 
5901                 boolean type = change.wasAdded() || change.wasRemoved() || change.wasPermutated() || change.wasUpdated();
5902                 assertTrue(&quot;at least one of the change types must be true&quot;, type);
5903             }
5904         });
5905 
5906         sm.clearAndSelect(selected);
5907     }
5908 
5909     @Test public void test_rt_40280() {
5910         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;();
5911         StageLoader sl = new StageLoader(view);
5912         MultipleSelectionModelBaseShim.getFocusedIndex(view.getSelectionModel());
5913         view.getFocusModel().getFocusedIndex();
5914         sl.dispose();
5915     }
5916 
5917     @Test public void test_rt_40278_showRoot() {
5918         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5919         root.setExpanded(true);
5920         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5921 
5922         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5923         view.setShowRoot(false);
5924         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5925 
5926         assertFalse(&quot;sanity: test setup such that root is not showing&quot;, view.isShowRoot());
5927         sm.select(0);
5928         assertEquals(0, sm.getSelectedIndex());
5929         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5930         view.setShowRoot(true);
5931         assertEquals(1, sm.getSelectedIndex());
5932         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5933     }
5934 
5935     @Test public void test_rt_40278_hideRoot_selectionOnChild() {
5936         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5937         root.setExpanded(true);
5938         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5939 
5940         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5941         view.setShowRoot(true);
5942         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5943 
5944         assertTrue(&quot;sanity: test setup such that root is showing&quot;, view.isShowRoot());
5945         sm.select(1);
5946         assertEquals(1, sm.getSelectedIndex());
5947         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5948         view.setShowRoot(false);
5949         assertEquals(0, sm.getSelectedIndex());
5950         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5951     }
5952 
5953     @Test public void test_rt_40278_hideRoot_selectionOnRoot() {
5954         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5955         root.setExpanded(true);
5956         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5957 
5958         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5959         view.setShowRoot(true);
5960         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5961 
5962         assertTrue(&quot;sanity: test setup such that root is showing&quot;, view.isShowRoot());
5963         sm.select(0);
5964         assertEquals(0, sm.getSelectedIndex());
5965         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5966         view.setShowRoot(false);
5967         assertEquals(0, sm.getSelectedIndex());
5968         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5969     }
5970 
5971     /**
5972      * Test list change of selectedIndices on setIndices. Fails for core ..
5973      */
5974     @Test public void test_rt_40263() {
5975         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(-1);
5976         root.setExpanded(true);
5977 
5978         for (int i = 0; i &lt; 10; i++) {
5979             root.getChildren().add(new TreeItem&lt;Integer&gt;(i));
5980         }
5981 
5982         final TreeTableView&lt;Integer&gt; view = new TreeTableView&lt;&gt;(root);
5983         TreeTableView.TreeTableViewSelectionModel&lt;Integer&gt; sm = view.getSelectionModel();
5984         sm.setSelectionMode(SelectionMode.MULTIPLE);
5985 
5986         int[] indices = new int[]{2, 5, 7};
5987         ListChangeListener&lt;Integer&gt; l = c -&gt; {
5988             // firstly, we expect only one change
5989             int subChanges = 0;
5990             while(c.next()) {
5991                 subChanges++;
5992             }
5993             assertEquals(1, subChanges);
5994 
5995             // secondly, we expect the added size to be three, as that is the
5996             // number of items selected
5997             c.reset();
5998             c.next();
5999             System.out.println(&quot;Added items: &quot; + c.getAddedSubList());
6000             assertEquals(indices.length, c.getAddedSize());
6001             assertArrayEquals(indices, c.getAddedSubList().stream().mapToInt(i -&gt; i).toArray());
6002         };
6003         sm.getSelectedIndices().addListener(l);
6004         sm.selectIndices(indices[0], indices);
6005     }
6006 
6007     @Test public void test_rt_40319_toRight_toBottom()          { test_rt_40319(true, true, false);   }
6008     @Test public void test_rt_40319_toRight_toTop()             { test_rt_40319(true, false, false);  }
6009     @Test public void test_rt_40319_toLeft_toBottom()           { test_rt_40319(false, true, false);  }
6010     @Test public void test_rt_40319_toLeft_toTop()              { test_rt_40319(false, false, false); }
6011     @Test public void test_rt_40319_toRight_toBottom_useMouse() { test_rt_40319(true, true, true);    }
6012     @Test public void test_rt_40319_toRight_toTop_useMouse()    { test_rt_40319(true, false, true);   }
6013     @Test public void test_rt_40319_toLeft_toBottom_useMouse()  { test_rt_40319(false, true, true);   }
6014     @Test public void test_rt_40319_toLeft_toTop_useMouse()     { test_rt_40319(false, false, true);  }
6015 
6016     private void test_rt_40319(boolean toRight, boolean toBottom, boolean useMouse) {
6017         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
6018         root.setExpanded(true);
6019         root.getChildren().addAll(
6020                 new TreeItem&lt;&gt;(&quot;0&quot;),
6021                 new TreeItem&lt;&gt;(&quot;1&quot;),
6022                 new TreeItem&lt;&gt;(&quot;2&quot;),
6023                 new TreeItem&lt;&gt;(&quot;3&quot;),
6024                 new TreeItem&lt;&gt;(&quot;4&quot;),
6025                 new TreeItem&lt;&gt;(&quot;5&quot;)
6026         );
6027 
6028         TreeTableView&lt;String&gt; t = new TreeTableView&lt;&gt;(root);
6029         t.setShowRoot(false);
6030 
6031         sm = t.getSelectionModel();
6032         sm.setSelectionMode(SelectionMode.MULTIPLE);
6033 
6034         TreeTableColumn&lt;String,String&gt; c1 = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
6035         c1.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
6036         TreeTableColumn&lt;String,String&gt; c2 = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
6037         c2.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
6038         t.getColumns().addAll(c1, c2);
6039 
6040         final int startIndex = toRight ? 0 : 2;
6041         final int endIndex = toRight ? 2 : 0;
6042         final TreeTableColumn&lt;String,String&gt; startColumn = toBottom ? c1 : c2;
6043         final TreeTableColumn&lt;String,String&gt; endColumn = toBottom ? c2 : c1;
6044 
6045         sm.select(startIndex, startColumn);
6046 
6047         if (useMouse) {
6048             Cell endCell = VirtualFlowTestUtils.getCell(t, endIndex, toRight ? 1 : 0);
6049             MouseEventFirer mouse = new MouseEventFirer(endCell);
6050             mouse.fireMousePressAndRelease(KeyModifier.SHIFT);
6051         } else {
6052             t.getSelectionModel().selectRange(startIndex, startColumn, endIndex, endColumn);
6053         }
6054 
6055         assertEquals(3, sm.getSelectedItems().size());
6056         assertEquals(3, sm.getSelectedIndices().size());
6057         assertEquals(3, sm.getSelectedCells().size());
6058     }
6059 
6060     @Test public void test_jdk_8147483() {
6061         TreeItem&lt;Number&gt; root = new TreeItem&lt;&gt;(0);
6062         root.setExpanded(true);
6063 
6064         final TreeTableView&lt;Number&gt; view = new TreeTableView&lt;&gt;(root);
6065         view.setShowRoot(false);
6066 
6067         AtomicInteger cellUpdateCount = new AtomicInteger();
6068         AtomicInteger rowCreateCount = new AtomicInteger();
6069 
6070         TreeTableColumn&lt;Number, Number&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
6071         column.setCellValueFactory(cdf -&gt; new ReadOnlyIntegerWrapper(0));
6072         column.setCellFactory( ttc -&gt; new TreeTableCell&lt;Number,Number&gt;() {
6073             @Override protected void updateItem(Number item, boolean empty) {
6074                 cellUpdateCount.incrementAndGet();
6075                 super.updateItem(item, empty);
6076             }
6077         });
6078         view.getColumns().add(column);
6079 
6080         view.setRowFactory(t -&gt; {
6081             rowCreateCount.incrementAndGet();
6082             return new TreeTableRow&lt;&gt;();
6083         });
6084 
6085         assertEquals(0, cellUpdateCount.get());
6086         assertEquals(0, rowCreateCount.get());
6087 
6088         StageLoader sl = new StageLoader(view);
6089 
6090         // Before the fix, we got cellUpdateCount = 18 and rowCreateCount = 17 for the first add below.
6091         // After the second add, these numbers went to 53 and 17 respectively.
6092         // Because these numbers might differ on other systems, we simply record the values after
6093         // the first add, and then we expect the cellUpdateCount to increase by one, and rowCreateCount to
6094         // not increase at all.
6095         root.getChildren().add(new TreeItem(1));
6096         Toolkit.getToolkit().firePulse();
6097         final int firstCellUpdateCount = cellUpdateCount.get();
6098         final int firstRowCreateCount = rowCreateCount.get();
6099 
6100         root.getChildren().add(new TreeItem(2));
6101         Toolkit.getToolkit().firePulse();
6102         assertEquals(firstCellUpdateCount+1, cellUpdateCount.get());
6103         assertEquals(firstRowCreateCount, rowCreateCount.get());
6104 
6105         root.getChildren().add(new TreeItem(3));
6106         Toolkit.getToolkit().firePulse();
6107         assertEquals(firstCellUpdateCount+2, cellUpdateCount.get());
6108         assertEquals(firstRowCreateCount, rowCreateCount.get());
6109 
6110         sl.dispose();
6111     }
6112 
6113     @Test public void test_jdk_8144681_removeColumn() {
6114         TreeTableView&lt;Book&gt; table = new TreeTableView&lt;&gt;();
6115 
6116         TreeItem&lt;Book&gt; root = new TreeItem&lt;&gt;();
6117         root.getChildren().addAll(
6118                 new TreeItem&lt;&gt;(new Book(&quot;Book 1&quot;, &quot;Author 1&quot;, &quot;Remark 1&quot;))
6119                 , new TreeItem&lt;&gt;(new Book(&quot;Book 2&quot;, &quot;Author 2&quot;, &quot;Remark 2&quot;))
6120                 , new TreeItem&lt;&gt;(new Book(&quot;Book 3&quot;, &quot;Author 3&quot;, &quot;Remark 3&quot;))
6121                 , new TreeItem&lt;&gt;(new Book(&quot;Book 4&quot;, &quot;Author 4&quot;, &quot;Remark 4&quot;)));
6122         table.setRoot(root);
6123 
6124         String[] columns = { &quot;title&quot;, &quot;author&quot;, &quot;remark&quot; };
6125         for (String prop : columns) {
6126             TreeTableColumn&lt;Book, String&gt; col = new TreeTableColumn&lt;&gt;(prop);
6127             col.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(prop));
6128             table.getColumns().add(col);
6129         }
6130         table.setColumnResizePolicy(TreeTableView.UNCONSTRAINED_RESIZE_POLICY);
6131         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
6132         table.getSelectionModel().setCellSelectionEnabled(true);
6133 
6134         table.getSelectionModel().selectAll();
6135 
6136         ControlTestUtils.runWithExceptionHandler(() -&gt; table.getColumns().remove(2));
6137     }
6138 
6139     @Test public void test_jdk_8144681_moveColumn() {
6140         TreeTableView&lt;Book&gt; table = new TreeTableView&lt;&gt;();
6141 
6142         TreeItem&lt;Book&gt; root = new TreeItem&lt;&gt;();
6143         root.getChildren().addAll(
6144                 new TreeItem&lt;&gt;(new Book(&quot;Book 1&quot;, &quot;Author 1&quot;, &quot;Remark 1&quot;))
6145                 , new TreeItem&lt;&gt;(new Book(&quot;Book 2&quot;, &quot;Author 2&quot;, &quot;Remark 2&quot;))
6146                 , new TreeItem&lt;&gt;(new Book(&quot;Book 3&quot;, &quot;Author 3&quot;, &quot;Remark 3&quot;))
6147                 , new TreeItem&lt;&gt;(new Book(&quot;Book 4&quot;, &quot;Author 4&quot;, &quot;Remark 4&quot;)));
6148         table.setRoot(root);
6149 
6150         String[] columns = { &quot;title&quot;, &quot;author&quot;, &quot;remark&quot; };
6151         for (String prop : columns) {
6152             TreeTableColumn&lt;Book, String&gt; col = new TreeTableColumn&lt;&gt;(prop);
6153             col.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(prop));
6154             table.getColumns().add(col);
6155         }
6156         table.setColumnResizePolicy(TreeTableView.UNCONSTRAINED_RESIZE_POLICY);
6157         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
6158         table.getSelectionModel().setCellSelectionEnabled(true);
6159 
6160         table.getSelectionModel().selectAll();
6161 
6162         ControlTestUtils.runWithExceptionHandler(() -&gt; {
6163             table.getColumns().setAll(table.getColumns().get(0), table.getColumns().get(2), table.getColumns().get(1));
6164         });
6165     }
6166 
6167     private static class Book {
6168         private SimpleStringProperty title = new SimpleStringProperty();
6169         private SimpleStringProperty author = new SimpleStringProperty();
6170         private SimpleStringProperty remark = new SimpleStringProperty();
6171 
6172         public Book(String title, String author, String remark) {
6173             super();
6174             setTitle(title);
6175             setAuthor(author);
6176             setRemark(remark);
6177         }
6178 
6179         public SimpleStringProperty titleProperty() {
6180             return this.title;
6181         }
6182 
6183         public java.lang.String getTitle() {
6184             return this.titleProperty().get();
6185         }
6186 
6187         public void setTitle(final java.lang.String title) {
6188             this.titleProperty().set(title);
6189         }
6190 
6191         public SimpleStringProperty authorProperty() {
6192             return this.author;
6193         }
6194 
6195         public java.lang.String getAuthor() {
6196             return this.authorProperty().get();
6197         }
6198 
6199         public void setAuthor(final java.lang.String author) {
6200             this.authorProperty().set(author);
6201         }
6202 
6203         public SimpleStringProperty remarkProperty() {
6204             return this.remark;
6205         }
6206 
6207         public java.lang.String getRemark() {
6208             return this.remarkProperty().get();
6209         }
6210 
6211         public void setRemark(final java.lang.String remark) {
6212             this.remarkProperty().set(remark);
6213         }
6214 
6215         @Override
6216         public String toString() {
6217             return String.format(&quot;%s(%s) - %s&quot;, getTitle(), getAuthor(), getRemark());
6218         }
6219     }
6220 
6221     @Test public void test_jdk_8157205() {
6222         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6223         childNode1.setExpanded(true);
6224         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6225         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6226         childNode1.getChildren().addAll(item1, item2);
6227 
6228         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6229         root.setExpanded(true);
6230         root.getChildren().add(childNode1);
6231 
6232         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6233         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6234         sm.setSelectionMode(SelectionMode.MULTIPLE);
6235 
6236         AtomicInteger step = new AtomicInteger();
6237 
6238         AtomicInteger indicesEventCount = new AtomicInteger();
6239         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;)c -&gt; {
6240             switch (step.get()) {
6241                 case 0: {
6242                     // expect to see [1,2,3] added at index 0
6243                     c.next();
6244                     assertEquals(3, c.getAddedSize());
6245                     assertTrue(&quot;added: &quot; + c.getAddedSubList(),
6246                             c.getAddedSubList().containsAll(FXCollections.observableArrayList(1,2,3)));
6247                     assertEquals(0, c.getFrom());
6248                     break;
6249                 }
6250                 case 1: {
6251                     // expect to see [2,3] removed
6252                     List&lt;Integer&gt; removed = new ArrayList&lt;&gt;();
6253                     while (c.next()) {
6254                         if (c.wasRemoved()) {
6255                             removed.addAll(c.getRemoved());
6256                         } else {
6257                             fail(&quot;Unexpected state&quot;);
6258                         }
6259                     }
6260                     if (!removed.isEmpty()) {
6261                         assertTrue(removed.containsAll(FXCollections.observableArrayList(2,3)));
6262                     }
6263                     break;
6264                 }
6265             }
6266 
6267             indicesEventCount.incrementAndGet();
6268         });
6269 
6270         AtomicInteger itemsEventCount = new AtomicInteger();
6271         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;)c -&gt; {
6272             switch (step.get()) {
6273                 case 0: {
6274                     // expect to see [1,2,3] added at index 0
6275                     c.next();
6276                     assertEquals(3, c.getAddedSize());
6277                     assertTrue(&quot;added: &quot; + c.getAddedSubList(),
6278                             c.getAddedSubList().containsAll(FXCollections.observableArrayList(childNode1, item1, item2)));
6279                     assertEquals(0, c.getFrom());
6280                     break;
6281                 }
6282                 case 1: {
6283                     // expect to see [2,3] removed
6284                     List&lt;TreeItem&lt;String&gt;&gt; removed = new ArrayList&lt;&gt;();
6285                     while (c.next()) {
6286                         if (c.wasRemoved()) {
6287                             removed.addAll(c.getRemoved());
6288                         } else {
6289                             fail(&quot;Unexpected state&quot;);
6290                         }
6291                     }
6292                     if (!removed.isEmpty()) {
6293                         assertTrue(removed.containsAll(FXCollections.observableArrayList(item1, item2)));
6294                     }
6295                     break;
6296                 }
6297             }
6298 
6299             itemsEventCount.incrementAndGet();
6300         });
6301 
6302         assertEquals(0, indicesEventCount.get());
6303         assertEquals(0, itemsEventCount.get());
6304 
6305         step.set(0);
6306         sm.selectIndices(1,2,3); // select Child Node 1 and both children
6307         assertTrue(sm.isSelected(1));
6308         assertTrue(sm.isSelected(2));
6309         assertTrue(sm.isSelected(3));
6310         assertEquals(3, sm.getSelectedIndices().size());
6311         assertEquals(3, sm.getSelectedItems().size());
6312         assertEquals(1, indicesEventCount.get());
6313         assertEquals(1, itemsEventCount.get());
6314 
6315         step.set(1);
6316         System.out.println(&quot;about to collapse now&quot;);
6317         childNode1.setExpanded(false); // collapse Child Node 1 and expect both children to be deselected
6318         assertTrue(sm.isSelected(1));
6319         assertFalse(sm.isSelected(2));
6320         assertFalse(sm.isSelected(3));
6321         assertEquals(1, sm.getSelectedIndices().size());
6322         assertEquals(1, sm.getSelectedItems().size());
6323         assertEquals(2, indicesEventCount.get());
6324         assertEquals(2, itemsEventCount.get());
6325 
6326         step.set(2);
6327         childNode1.setExpanded(true); // expand Child Node 1 and expect both children to still be deselected
6328         assertTrue(sm.isSelected(1));
6329         assertFalse(sm.isSelected(2));
6330         assertFalse(sm.isSelected(3));
6331         assertEquals(1, sm.getSelectedIndices().size());
6332         assertEquals(1, sm.getSelectedItems().size());
6333         assertEquals(2, indicesEventCount.get());
6334         assertEquals(2, itemsEventCount.get());
6335     }
6336 
6337     @Test public void test_jdk_8157285() {
6338         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6339         childNode1.setExpanded(true);
6340         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6341         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6342         childNode1.getChildren().addAll(item1, item2);
6343 
6344         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6345         root.setExpanded(true);
6346         root.getChildren().add(childNode1);
6347 
6348         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6349         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6350         sm.setSelectionMode(SelectionMode.MULTIPLE);
6351 
6352         view.expandedItemCountProperty().addListener((observable, oldCount, newCount) -&gt; {
6353             if (childNode1.isExpanded()) return;
6354             System.out.println(sm.getSelectedIndices());
6355             System.out.println(sm.getSelectedItems());
6356             assertTrue(sm.isSelected(1));
6357             assertFalse(sm.isSelected(2));
6358             assertFalse(sm.isSelected(3));
6359             assertEquals(1, sm.getSelectedIndices().size());
6360             assertEquals(1, sm.getSelectedItems().size());
6361         });
6362 
6363         sm.selectIndices(1,2,3); // select Child Node 1 and both children
6364         assertTrue(sm.isSelected(1));
6365         assertTrue(sm.isSelected(2));
6366         assertTrue(sm.isSelected(3));
6367         assertEquals(3, sm.getSelectedIndices().size());
6368         assertEquals(3, sm.getSelectedItems().size());
6369 
6370         // collapse Child Node 1 and expect both children to be deselected,
6371         // and that in the expandedItemCount listener that we get the right values
6372         // in the selectedIndices and selectedItems list
6373         childNode1.setExpanded(false);
6374     }
6375 
6376     @Test public void test_jdk_8152396() {
6377         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6378         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6379         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6380         childNode1.getChildren().addAll(item1, item2);
6381 
6382         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6383         root.setExpanded(true);
6384         root.getChildren().add(childNode1);
6385 
6386         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6387         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6388         sm.setSelectionMode(SelectionMode.MULTIPLE);
6389 
6390         view.expandedItemCountProperty().addListener((observable, oldCount, newCount) -&gt; {
6391             if (newCount.intValue() &gt; oldCount.intValue()) {
6392                 for (int index: sm.getSelectedIndices()) {
6393                     TreeItem&lt;String&gt; item = view.getTreeItem(index);
6394 
6395                     if (item != null &amp;&amp; item.isExpanded() &amp;&amp; !item.getChildren().isEmpty()) {
6396                         int startIndex = index + 1;
6397                         int maxCount = startIndex + item.getChildren().size();
6398 
6399                         sm.selectRange(startIndex, maxCount);
6400                     }
6401                 }
6402             }
6403         });
6404 
6405         FilteredList filteredList = sm.getSelectedItems().filtered(Objects::nonNull);
6406 
6407         StageLoader sl = new StageLoader(view);
6408 
6409         sm.select(1);
6410         childNode1.setExpanded(true);
6411         Toolkit.getToolkit().firePulse();
6412 
6413         // collapse Child Node 1 and expect both children to be deselected,
6414         // and that the filtered list does not throw an exception
6415         assertEquals(3, filteredList.size());
6416         ControlTestUtils.runWithExceptionHandler(() -&gt; childNode1.setExpanded(false));
6417 
6418         Toolkit.getToolkit().firePulse();
6419         assertEquals(1, filteredList.size());
6420 
6421         sl.dispose();
6422     }
6423 
6424     @Test public void test_jdk_8160771() {
6425         TreeTableView table = new TreeTableView();
6426         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
6427         table.getColumns().add(first);
6428         table.getVisibleLeafColumns().addListener((ListChangeListener) c -&gt; {
6429             c.next();
6430             assertTrue(c.wasAdded());
6431             assertSame(table, ((TreeTableColumn) c.getAddedSubList().get(0)).getTreeTableView());
6432         });
6433         TreeTableColumn last = new TreeTableColumn(&quot;Last Name&quot;);
6434         table.getColumns().add(0, last);
6435     }
6436 
6437     private void test_jdk_8169642(Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; before,
6438                                   Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; afterDescending,
6439                                   Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; afterAscending) {
6440         final TreeItem&lt;String&gt; rootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
6441         rootItem.setExpanded(true);
6442         rootItem.getChildren().addAll(new TreeItem&lt;&gt;(&quot;first child&quot;), new TreeItem&lt;&gt;(&quot;second child&quot;), new TreeItem&lt;&gt;(&quot;third child&quot;));
6443 
6444         final TreeTableView&lt;String&gt; tree = new TreeTableView&lt;&gt;(rootItem);
6445         final TreeTableColumn&lt;String, String&gt; column = new TreeTableColumn&lt;&gt;(&quot;first column&quot;);
6446         column.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
6447         tree.getColumns().add(column);
6448 
6449         TreeTableView.TreeTableViewSelectionModel sm = tree.getSelectionModel();
6450         sm.setSelectionMode(SelectionMode.MULTIPLE);
6451 
6452         assertTrue(sm.isEmpty());
6453         before.accept(sm);
6454 
6455         tree.getSortOrder().add(column);
6456         column.setSortType(TreeTableColumn.SortType.DESCENDING);
6457         afterDescending.accept(sm);
6458 
6459         column.setSortType(TreeTableColumn.SortType.ASCENDING);
6460         afterAscending.accept(sm);
6461     }
6462 
6463     @Test public void test_jdk_8169642_1_only() {
6464         test_jdk_8169642(
6465             sm -&gt; {
6466                 // select &#39;first&#39;
6467                 sm.select(1);
6468                 assertTrue(sm.isSelected(1));
6469                 assertEquals(1, sm.getSelectedCells().size());
6470             },
6471             sm -&gt; {
6472                 assertTrue(sm.isSelected(3));
6473                 assertEquals(1, sm.getSelectedCells().size());
6474             },
6475             sm -&gt; {
6476                 assertTrue(sm.isSelected(1));
6477                 assertEquals(1, sm.getSelectedCells().size());
6478             }
6479         );
6480     }
6481 
6482     @Test public void test_jdk_8169642_2_only() {
6483         test_jdk_8169642(
6484             sm -&gt; {
6485                 // select &#39;second&#39;
6486                 sm.select(2);
6487                 assertTrue(sm.isSelected(2));
6488                 assertEquals(1, sm.getSelectedCells().size());
6489             },
6490             sm -&gt; {
6491                 assertTrue(sm.isSelected(2));
6492                 assertEquals(1, sm.getSelectedCells().size());
6493             },
6494             sm -&gt; {
6495                 assertTrue(sm.isSelected(2));
6496                 assertEquals(1, sm.getSelectedCells().size());
6497             }
6498         );
6499     }
6500 
6501     @Test public void test_jdk_8169642_1_and_3() {
6502         test_jdk_8169642(
6503             sm -&gt; {
6504                 // select &#39;first&#39; and &#39;third&#39;, they should flip positions
6505                 sm.select(1);
6506                 sm.select(3);
6507                 assertTrue(sm.isSelected(1));
6508                 assertTrue(sm.isSelected(3));
6509                 assertEquals(2, sm.getSelectedCells().size());
6510             },
6511             sm -&gt; {
6512                 assertTrue(sm.isSelected(1));
6513                 assertTrue(sm.isSelected(3));
6514                 assertEquals(2, sm.getSelectedCells().size());
6515             },
6516             sm -&gt; {
6517                 assertTrue(sm.isSelected(1));
6518                 assertTrue(sm.isSelected(3));
6519                 assertEquals(2, sm.getSelectedCells().size());
6520             }
6521         );
6522     }
6523 
6524     @Test public void test_jdk_8169642_0_and_3() {
6525         test_jdk_8169642(
6526                 sm -&gt; {
6527                     // select &#39;root&#39; and &#39;third&#39;
6528                     sm.select(0);
6529                     sm.select(3);
6530                     assertTrue(sm.isSelected(0));
6531                     assertTrue(sm.isSelected(3));
6532                     assertEquals(2, sm.getSelectedCells().size());
6533                 },
6534                 sm -&gt; {
6535                     assertTrue(sm.isSelected(0));
6536                     assertTrue(sm.isSelected(1));
6537                     assertEquals(2, sm.getSelectedCells().size());
6538                 },
6539                 sm -&gt; {
6540                     assertTrue(sm.isSelected(0));
6541                     assertTrue(sm.isSelected(3));
6542                     assertEquals(2, sm.getSelectedCells().size());
6543                 }
6544         );
6545     }
6546 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import com.sun.javafx.collections.MappingChange;
  29 import com.sun.javafx.collections.NonIterableChange;
  30 import com.sun.javafx.scene.control.Properties;
  31 import com.sun.javafx.scene.control.SelectedCellsMap;
  32 
  33 import com.sun.javafx.scene.control.behavior.TableCellBehavior;
  34 import com.sun.javafx.scene.control.behavior.TableCellBehaviorBase;
  35 import com.sun.javafx.scene.control.behavior.TreeTableCellBehavior;
  36 
  37 import javafx.beans.property.DoubleProperty;
  38 import javafx.css.CssMetaData;
  39 import javafx.css.PseudoClass;
  40 
  41 import javafx.css.converter.SizeConverter;
  42 import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
  43 import com.sun.javafx.scene.control.TableColumnComparatorBase;
  44 
  45 import javafx.css.Styleable;
  46 import javafx.css.StyleableDoubleProperty;
  47 import javafx.css.StyleableProperty;
  48 import javafx.event.WeakEventHandler;
  49 
  50 import javafx.scene.control.skin.TreeTableViewSkin;
  51 
  52 import java.lang.ref.SoftReference;
  53 import java.lang.ref.WeakReference;
  54 import java.util.ArrayList;
  55 import java.util.Collection;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashMap;
  59 import java.util.LinkedHashSet;
  60 import java.util.List;
  61 import java.util.Map;
  62 import java.util.Set;
  63 import java.util.WeakHashMap;
  64 
  65 import javafx.application.Platform;
  66 import javafx.beans.DefaultProperty;
  67 import javafx.beans.InvalidationListener;
  68 import javafx.beans.WeakInvalidationListener;
  69 import javafx.beans.property.BooleanProperty;
  70 import javafx.beans.property.ObjectProperty;
  71 import javafx.beans.property.ObjectPropertyBase;
  72 import javafx.beans.property.ReadOnlyIntegerProperty;
  73 import javafx.beans.property.ReadOnlyIntegerWrapper;
  74 import javafx.beans.property.ReadOnlyObjectProperty;
  75 import javafx.beans.property.ReadOnlyObjectWrapper;
  76 import javafx.beans.property.SimpleBooleanProperty;
  77 import javafx.beans.property.SimpleObjectProperty;
  78 import javafx.beans.value.ChangeListener;
  79 import javafx.beans.value.WeakChangeListener;
  80 import javafx.beans.value.WritableValue;
  81 import javafx.collections.FXCollections;
  82 import javafx.collections.ListChangeListener;
  83 import javafx.collections.MapChangeListener;
  84 import javafx.collections.ObservableList;
  85 import javafx.collections.WeakListChangeListener;
  86 import javafx.event.Event;
  87 import javafx.event.EventHandler;
  88 import javafx.event.EventType;
  89 import javafx.scene.AccessibleAttribute;
  90 import javafx.scene.AccessibleRole;
  91 import javafx.scene.Node;
  92 import javafx.scene.layout.Region;
  93 import javafx.util.Callback;
  94 
  95 /**
  96  * The TreeTableView control is designed to visualize an unlimited number of rows
  97  * of data, broken out into columns. The TreeTableView control is conceptually
  98  * very similar to the {@link TreeView} and {@link TableView} controls,
  99  * and as you read on you&#39;ll come to see the APIs are largely the same.
 100  * However, to give a high-level overview, you&#39;ll note that the TreeTableView
 101  * uses the same {@link TreeItem} API as {@link TreeView},
 102  * and that you therefore are required to simply set the
 103  * {@link #rootProperty() root node} in the TreeTableView. Similarly, the
 104  * TreeTableView control makes use of the same TableColumn-based approach that
 105  * the {@link TableView} control uses, except instead of using the
 106  * TableView-specific {@link TableColumn} class, you should instead use the
 107  * TreeTableView-specific {@link TreeTableColumn} class instead. For an
 108  * example on how to create a TreeTableView instance, refer to the &#39;Creating a
 109  * TreeTableView&#39; control section below.
 110  *
 111  * &lt;p&gt;As with the {@link TableView} control, the TreeTableView control has a
 112  * number of features, including:
 113  * &lt;ul&gt;
 114  * &lt;li&gt;Powerful {@link TreeTableColumn} API:
 115  *   &lt;ul&gt;
 116  *   &lt;li&gt;Support for {@link TreeTableColumn#cellFactoryProperty() cell factories} to
 117  *      easily customize {@link Cell cell} contents in both rendering and editing
 118  *      states.
 119  *   &lt;li&gt;Specification of {@link TreeTableColumn#minWidthProperty() minWidth}/
 120  *      {@link TreeTableColumn#prefWidthProperty() prefWidth}/
 121  *      {@link TreeTableColumn#maxWidthProperty() maxWidth},
 122  *      and also {@link TreeTableColumn#resizableProperty() fixed width columns}.
 123  *   &lt;li&gt;Width resizing by the user at runtime.
 124  *   &lt;li&gt;Column reordering by the user at runtime.
 125  *   &lt;li&gt;Built-in support for {@link TreeTableColumn#getColumns() column nesting}
 126  *   &lt;/ul&gt;
 127  * &lt;li&gt;Different {@link #columnResizePolicyProperty() resizing policies} to
 128  *      dictate what happens when the user resizes columns.
 129  * &lt;li&gt;Support for {@link #getSortOrder() multiple column sorting} by clicking
 130  *      the column header (hold down Shift keyboard key whilst clicking on a
 131  *      header to sort by multiple columns).
 132  * &lt;/ul&gt;
 133  *
 134  * &lt;h2&gt;Creating a TreeTableView&lt;/h2&gt;
 135  *
 136  * &lt;p&gt;Creating a TreeTableView is a multi-step process, and also depends on the
 137  * underlying data model needing to be represented. For this example we&#39;ll use
 138  * the TreeTableView to visualise a file system, and will therefore make use
 139  * of an imaginary (and vastly simplified) File class as defined below:
 140  *
 141  * &lt;pre&gt; {@code public class File {
 142  *     private StringProperty name;
 143  *     public void setName(String value) { nameProperty().set(value); }
 144  *     public String getName() { return nameProperty().get(); }
 145  *     public StringProperty nameProperty() {
 146  *         if (name == null) name = new SimpleStringProperty(this, &quot;name&quot;);
 147  *         return name;
 148  *     }
 149  *
 150  *     private LongProperty lastModified;
 151  *     public void setLastModified(long value) { lastModifiedProperty().set(value); }
 152  *     public long getLastModified() { return lastModifiedProperty().get(); }
 153  *     public LongProperty lastModifiedProperty() {
 154  *         if (lastModified == null) lastModified = new SimpleLongProperty(this, &quot;lastModified&quot;);
 155  *         return lastModified;
 156  *     }
 157  *
 158  *     public File(String name, long size) {
 159  *         setName(name);
 160  *         setSize(size);
 161  *     }
 162  * }}&lt;/pre&gt;
 163  *
 164  * &lt;p&gt;The data we will use for this example is a single root with 3 files:
 165  *
 166  * &lt;pre&gt; {@code File rootFile = new File(&quot;Images&quot;, 900);
 167  * List&lt;File&gt; files = List.of(
 168  *     new File(&quot;Cat.png&quot;, 300),
 169  *     new File(&quot;Dog.png&quot;, 500),
 170  *     new File(&quot;Bird.png&quot;, 100));}&lt;/pre&gt;
 171  *
 172  * &lt;p&gt;Firstly, we need to create a data model. As mentioned, for this example,
 173  * we&#39;ll be representing a file system using File instances. To do this, we need
 174  * to define the root node of the tree table and its hierarchy:
 175  *
 176  * &lt;pre&gt; {@code TreeItem&lt;File&gt; root = new TreeItem&lt;&gt;(rootFile);
 177  * files.forEach(file -&gt; root.getChildren().add(new TreeItem&lt;&gt;(file)));}&lt;/pre&gt;
 178  *
 179  * &lt;p&gt; Then we create a TreeTableView instance:
 180  *
 181  * &lt;pre&gt; {@code TreeTableView&lt;File&gt; treeTable = new TreeTableView&lt;&gt;(root);}&lt;/pre&gt;
 182  *
 183  * &lt;p&gt;With the root set as such, the TreeTableView will automatically update whenever
 184  * the {@link TreeItem#getChildren() children} of the root change.
 185  *
 186  * &lt;p&gt;At this point we have a TreeTableView hooked up to observe the root
 187  * TreeItem instance. The missing ingredient
 188  * now is the means of splitting out the data contained within the model and
 189  * representing it in one or more {@link TreeTableColumn} instances. To
 190  * create a two-column TreeTableView to show the file name and size
 191  * properties, we write:
 192  *
 193  * &lt;pre&gt; {@code TreeTableColumns&lt;File, String&gt; fileNameCol = new TreeTableColumn&lt;&gt;(&quot;Filename&quot;);
 194  * TreeTableColumns&lt;File, Long&gt; sizeCol = new TreeTableColumn&lt;&gt;(&quot;Size&quot;);
 195  *
 196  * treeTable.getColumns().setAll(fileNameCol, sizeCol);}&lt;/pre&gt;
 197  *
 198  * &lt;p&gt;With the code shown above we have nearly fully defined the minimum properties
 199  * required to create a TreeTableView instance. The only thing missing is the
 200  * {@link javafx.scene.control.TreeTableColumn#cellValueFactoryProperty() cell value factories}
 201  * for the two columns - it is these that are responsible for determining the value
 202  * of a cell in a given row. Commonly these can be specified using the
 203  * {@link javafx.scene.control.cell.TreeItemPropertyValueFactory} class, but
 204  * failing that you can also create an anonymous inner class and do whatever is
 205  * necessary. For example, using {@link javafx.scene.control.cell.TreeItemPropertyValueFactory}
 206  * you would do the following:
 207  *
 208  * &lt;pre&gt; {@code fileNameCol.setCellValueFactory(new TreeItemPropertyValueFactory(rootFile.nameProperty().getName()));
 209  * sizeCol.setCellValueFactory(new TreeItemPropertyValueFactory(rootFile.sizeProperty().getName()));}&lt;/pre&gt;
 210  *
 211  * &lt;img src=&quot;doc-files/TreeTableView.png&quot; alt=&quot;Image of the TreeTableView control&quot;&gt;
 212  *
 213  * &lt;p&gt;Running this code will result in a TreeTableView as shown above with two columns
 214  * for name and size. Any other properties the File class might have will not be shown,
 215  * as no TreeTableColumns are defined for them.
 216  *
 217  * &lt;h3&gt;TreeTableView support for classes that don&#39;t contain properties&lt;/h3&gt;
 218  *
 219  * &lt;p&gt;The code shown above is the shortest possible code for creating a TreeTableView
 220  * when the domain objects are designed with JavaFX properties in mind
 221  * (additionally, {@link javafx.scene.control.cell.TreeItemPropertyValueFactory} supports
 222  * normal JavaBean properties too, although there is a caveat to this, so refer
 223  * to the class documentation for more information). When this is not the case,
 224  * it is necessary to provide a custom cell value factory. More information
 225  * about cell value factories can be found in the {@link TreeTableColumn} API
 226  * documentation, but briefly, here is how a TreeTableColumns could be specified:
 227  *
 228  * &lt;pre&gt; {@code firstNameCol.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;Person, String&gt;, ObservableValue&lt;String&gt;&gt;() {
 229  *     public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;Person, String&gt; p) {
 230  *         // p.getValue() returns the TreeItem&lt;Person&gt; instance for a particular TreeTableView row,
 231  *         // p.getValue().getValue() returns the Person instance inside the TreeItem&lt;Person&gt;
 232  *         return p.getValue().getValue().firstNameProperty();
 233  *     }
 234  * });
 235  *
 236  * // or with a lambda expression:
 237  * firstNameCol.setCellValueFactory(p -&gt; p.getValue().getValue().firstNameProperty());}&lt;/pre&gt;
 238  *
 239  * &lt;h3&gt;TreeTableView Selection / Focus APIs&lt;/h3&gt;
 240  * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 241  * {@link SelectionModel} and {@link FocusModel} classes. A TreeTableView has at most
 242  * one instance of each of these classes, available from
 243  * {@link #selectionModelProperty() selectionModel} and
 244  * {@link #focusModelProperty() focusModel} properties, respectively.
 245  * Whilst it is possible to use this API to set a new selection model, in
 246  * most circumstances this is not necessary - the default selection and focus
 247  * models should work in most circumstances.
 248  *
 249  * &lt;p&gt;The default {@link SelectionModel} used when instantiating a TreeTableView is
 250  * an implementation of the {@link MultipleSelectionModel} abstract class.
 251  * However, as noted in the API documentation for
 252  * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 253  * property, the default value is {@link SelectionMode#SINGLE}. To enable
 254  * multiple selection in a default TreeTableView instance, it is therefore necessary
 255  * to do the following:
 256  *
 257  * &lt;pre&gt; {@code treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 258  *
 259  * &lt;h3&gt;Customizing TreeTableView Visuals&lt;/h3&gt;
 260  * &lt;p&gt;The visuals of the TreeTableView can be entirely customized by replacing the
 261  * default {@link #rowFactoryProperty() row factory}. A row factory is used to
 262  * generate {@link TreeTableRow} instances, which are used to represent an entire
 263  * row in the TreeTableView.
 264  *
 265  * &lt;p&gt;In many cases, this is not what is desired however, as it is more commonly
 266  * the case that cells be customized on a per-column basis, not a per-row basis.
 267  * It is therefore important to note that a {@link TreeTableRow} is not a
 268  * {@link TreeTableCell}. A  {@link TreeTableRow} is simply a container for zero or more
 269  * {@link TreeTableCell}, and in most circumstances it is more likely that you&#39;ll
 270  * want to create custom TreeTableCells, rather than TreeTableRows. The primary use case
 271  * for creating custom TreeTableRow instances would most probably be to introduce
 272  * some form of column spanning support.
 273  *
 274  * &lt;p&gt;You can create custom {@link TreeTableCell} instances per column by assigning
 275  * the appropriate function to the TreeTableColumns
 276  * {@link TreeTableColumn#cellFactoryProperty() cell factory} property.
 277  *
 278  * &lt;p&gt;See the {@link Cell} class documentation for a more complete
 279  * description of how to write custom Cells.
 280  *
 281  * &lt;h3&gt;Editing&lt;/h3&gt;
 282  * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 283  * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 284  *
 285  * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 286  * than when a cell is not being edited. This is the responsibility of the
 287  * {@link Cell} implementation being used. For TreeTableView, it is highly
 288  * recommended that editing be
 289  * {@link javafx.scene.control.TreeTableColumn#cellFactoryProperty() per-TreeTableColumn},
 290  * rather than {@link #rowFactoryProperty() per row}, as more often than not
 291  * you want users to edit each column value differently, and this approach allows
 292  * for editors specific to each column. It is your choice whether the cell is
 293  * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 294  * or to switch to a different UI when editing begins (e.g. when a double-click
 295  * is received on a cell).&lt;/p&gt;
 296  *
 297  * &lt;p&gt;To know when editing has been requested on a cell,
 298  * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 299  * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 300  * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 301  * appropriate (e.g. set the text to null and set the graphic to be a
 302  * {@link TextField}). Additionally, you should also override
 303  * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 304  * when the editing concludes. In both cases it is important that you also
 305  * ensure that you call the super method to have the cell perform all duties it
 306  * must do to enter or exit its editing mode.&lt;/p&gt;
 307  *
 308  * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 309  * interested in is how to commit or cancel the editing that is taking place. This is your
 310  * responsibility as the cell factory provider. Your cell implementation will know
 311  * when the editing is over, based on the user input (e.g. when the user presses
 312  * the Enter or ESC keys on their keyboard). When this happens, it is your
 313  * responsibility to call {@link Cell#commitEdit(Object)} or
 314  * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 315  *
 316  * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 317  * TreeTableView, which you can observe by adding an {@link EventHandler} via
 318  * {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 319  * you can also observe edit events for
 320  * {@link TreeTableColumn#setOnEditStart(javafx.event.EventHandler) edit start}
 321  * and {@link TreeTableColumn#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 322  *
 323  * &lt;p&gt;By default the TreeTableColumn edit commit handler is non-null, with a default
 324  * handler that attempts to overwrite the property value for the
 325  * item in the currently-being-edited row. It is able to do this as the
 326  * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 327  * is passed along to the edit commit handler via the
 328  * {@link javafx.scene.control.TreeTableColumn.CellEditEvent CellEditEvent} that is
 329  * fired. It is simply a matter of calling
 330  * {@link javafx.scene.control.TreeTableColumn.CellEditEvent#getNewValue()} to
 331  * retrieve this value.
 332  *
 333  * &lt;p&gt;It is very important to note that if you call
 334  * {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler)} with your own
 335  * {@link EventHandler}, then you will be removing the default handler. Unless
 336  * you then handle the writeback to the property (or the relevant data source),
 337  * nothing will happen. You can work around this by using the
 338  * {@link TreeTableColumn#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 339  * method to add a {@link TreeTableColumn#EDIT_COMMIT_EVENT} {@link EventType} with
 340  * your desired {@link EventHandler} as the second argument. Using this method,
 341  * you will not replace the default implementation, but you will be notified when
 342  * an edit commit has occurred.&lt;/p&gt;
 343  *
 344  * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 345  * Fortunately, JavaFX ships with a number of pre-built cell factories that
 346  * handle all the editing requirements on your behalf. You can find these
 347  * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 348  *
 349  * @see TreeTableColumn
 350  * @see TreeTablePosition
 351  * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView.
 352  * @since JavaFX 8.0
 353  */
 354 @DefaultProperty(&quot;root&quot;)
 355 public class TreeTableView&lt;S&gt; extends Control {
 356 
 357     /***************************************************************************
 358      *                                                                         *
 359      * Constructors                                                            *
 360      *                                                                         *
 361      **************************************************************************/
 362 
 363     /**
 364      * Creates an empty TreeTableView.
 365      *
 366      * &lt;p&gt;Refer to the {@link TreeTableView} class documentation for details on the
 367      * default state of other properties.
 368      */
 369     public TreeTableView() {
 370         this(null);
 371     }
 372 
 373     /**
 374      * Creates a TreeTableView with the provided root node.
 375      *
 376      * &lt;p&gt;Refer to the {@link TreeTableView} class documentation for details on the
 377      * default state of other properties.
 378      *
 379      * @param root The node to be the root in this TreeTableView.
 380      */
 381     public TreeTableView(TreeItem&lt;S&gt; root) {
 382         getStyleClass().setAll(DEFAULT_STYLE_CLASS);
 383         setAccessibleRole(AccessibleRole.TREE_TABLE_VIEW);
 384 
 385         setRoot(root);
 386         updateExpandedItemCount(root);
 387 
 388         // install default selection and focus models - it&#39;s unlikely this will be changed
 389         // by many users.
 390         setSelectionModel(new TreeTableViewArrayListSelectionModel&lt;S&gt;(this));
 391         setFocusModel(new TreeTableViewFocusModel&lt;S&gt;(this));
 392 
 393         // we watch the columns list, such that when it changes we can update
 394         // the leaf columns and visible leaf columns lists (which are read-only).
 395         getColumns().addListener(weakColumnsObserver);
 396 
 397         // watch for changes to the sort order list - and when it changes run
 398         // the sort method.
 399         getSortOrder().addListener((ListChangeListener.Change&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; c) -&gt; {
 400             doSort(TableUtil.SortEventType.SORT_ORDER_CHANGE, c);
 401         });
 402 
 403         // We&#39;re watching for changes to the content width such
 404         // that the resize policy can be run if necessary. This comes from
 405         // TreeTableViewSkin.
 406         getProperties().addListener((MapChangeListener&lt;Object, Object&gt;) c -&gt; {
 407             if (c.wasAdded() &amp;&amp; TableView.SET_CONTENT_WIDTH.equals(c.getKey())) {
 408                 if (c.getValueAdded() instanceof Number) {
 409                     setContentWidth((Double) c.getValueAdded());
 410                 }
 411                 getProperties().remove(TableView.SET_CONTENT_WIDTH);
 412             }
 413         });
 414 
 415         isInited = true;
 416     }
 417 
 418 
 419 
 420     /***************************************************************************
 421      *                                                                         *
 422      * Static properties and methods                                           *
 423      *                                                                         *
 424      **************************************************************************/
 425 
 426     /**
 427      * An EventType that indicates some edit event has occurred. It is the parent
 428      * type of all other edit events: {@link #editStartEvent},
 429      *  {@link #editCommitEvent} and {@link #editCancelEvent}.
 430      *
 431      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 432      * @return An EventType that indicates some edit event has occurred
 433      */
 434     @SuppressWarnings(&quot;unchecked&quot;)
 435     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editAnyEvent() {
 436         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_ANY_EVENT;
 437     }
 438     private static final EventType&lt;?&gt; EDIT_ANY_EVENT =
 439             new EventType&lt;&gt;(Event.ANY, &quot;TREE_TABLE_VIEW_EDIT&quot;);
 440 
 441     /**
 442      * An EventType used to indicate that an edit event has started within the
 443      * TreeTableView upon which the event was fired.
 444      *
 445      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 446      * @return An EventType used to indicate that an edit event has started
 447      */
 448     @SuppressWarnings(&quot;unchecked&quot;)
 449     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editStartEvent() {
 450         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_START_EVENT;
 451     }
 452     private static final EventType&lt;?&gt; EDIT_START_EVENT =
 453             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_START&quot;);
 454 
 455     /**
 456      * An EventType used to indicate that an edit event has just been canceled
 457      * within the TreeTableView upon which the event was fired.
 458      *
 459      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 460      * @return An EventType used to indicate that an edit event has just been
 461      *      canceled
 462      */
 463     @SuppressWarnings(&quot;unchecked&quot;)
 464     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editCancelEvent() {
 465         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_CANCEL_EVENT;
 466     }
 467     private static final EventType&lt;?&gt; EDIT_CANCEL_EVENT =
 468             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_CANCEL&quot;);
 469 
 470     /**
 471      * An EventType that is used to indicate that an edit in a TreeTableView has been
 472      * committed. This means that user has made changes to the data of a
 473      * TreeItem, and that the UI should be updated.
 474      *
 475      * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
 476      * @return An EventType that is used to indicate that an edit in a TreeTableView
 477      *      has been committed
 478      */
 479     @SuppressWarnings(&quot;unchecked&quot;)
 480     public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editCommitEvent() {
 481         return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_COMMIT_EVENT;
 482     }
 483     private static final EventType&lt;?&gt; EDIT_COMMIT_EVENT =
 484             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_COMMIT&quot;);
 485 
 486     /**
 487      * Returns the number of levels of &#39;indentation&#39; of the given TreeItem,
 488      * based on how many times {@link javafx.scene.control.TreeItem#getParent()}
 489      * can be recursively called. If the TreeItem does not have any parent set,
 490      * the returned value will be zero. For each time getParent() is recursively
 491      * called, the returned value is incremented by one.
 492      *
 493      * &lt;p&gt;&lt;strong&gt;Important note: &lt;/strong&gt;This method is deprecated as it does
 494      * not consider the root node. This means that this method will iterate
 495      * past the root node of the TreeTableView control, if the root node has a parent.
 496      * If this is important, call {@link TreeTableView#getTreeItemLevel(TreeItem)}
 497      * instead.
 498      *
 499      * @param node The TreeItem for which the level is needed.
 500      * @return An integer representing the number of parents above the given node,
 501      *         or -1 if the given TreeItem is null.
 502      * @deprecated This method does not correctly calculate the distance from the
 503      *          given TreeItem to the root of the TreeTableView. As of JavaFX 8.0_20,
 504      *          the proper way to do this is via
 505      *          {@link TreeTableView#getTreeItemLevel(TreeItem)}
 506      */
 507     @Deprecated(since=&quot;8u20&quot;)
 508     public static int getNodeLevel(TreeItem&lt;?&gt; node) {
 509         return TreeView.getNodeLevel(node);
 510     }
 511 
 512     /**
 513      * &lt;p&gt;Very simple resize policy that just resizes the specified column by the
 514      * provided delta and shifts all other columns (to the right of the given column)
 515      * further to the right (when the delta is positive) or to the left (when the
 516      * delta is negative).
 517      *
 518      * &lt;p&gt;It also handles the case where we have nested columns by sharing the new space,
 519      * or subtracting the removed space, evenly between all immediate children columns.
 520      * Of course, the immediate children may themselves be nested, and they would
 521      * then use this policy on their children.
 522      */
 523     public static final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; UNCONSTRAINED_RESIZE_POLICY =
 524             new Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;() {
 525 
 526         @Override public String toString() {
 527             return &quot;unconstrained-resize&quot;;
 528         }
 529 
 530         @Override public Boolean call(TreeTableView.ResizeFeatures prop) {
 531             double result = TableUtil.resize(prop.getColumn(), prop.getDelta());
 532             return Double.compare(result, 0.0) == 0;
 533         }
 534     };
 535 
 536     /**
 537      * &lt;p&gt;Simple policy that ensures the width of all visible leaf columns in
 538      * this table sum up to equal the width of the table itself.
 539      *
 540      * &lt;p&gt;When the user resizes a column width with this policy, the table automatically
 541      * adjusts the width of the right hand side columns. When the user increases a
 542      * column width, the table decreases the width of the rightmost column until it
 543      * reaches its minimum width. Then it decreases the width of the second
 544      * rightmost column until it reaches minimum width and so on. When all right
 545      * hand side columns reach minimum size, the user cannot increase the size of
 546      * resized column any more.
 547      */
 548     public static final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; CONSTRAINED_RESIZE_POLICY =
 549             new Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;() {
 550 
 551         private boolean isFirstRun = true;
 552 
 553         @Override public String toString() {
 554             return &quot;constrained-resize&quot;;
 555         }
 556 
 557         @Override public Boolean call(TreeTableView.ResizeFeatures prop) {
 558             TreeTableView&lt;?&gt; table = prop.getTable();
 559             List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumns = table.getVisibleLeafColumns();
 560             Boolean result = TableUtil.constrainedResize(prop,
 561                                                isFirstRun,
 562                                                table.contentWidth,
 563                                                visibleLeafColumns);
 564             isFirstRun = ! isFirstRun ? false : ! result;
 565             return result;
 566         }
 567     };
 568 
 569     /**
 570      * The default {@link #sortPolicyProperty() sort policy} that this TreeTableView
 571      * will use if no other policy is specified. The sort policy is a simple
 572      * {@link Callback} that accepts a TreeTableView as the sole argument and expects
 573      * a Boolean response representing whether the sort succeeded or not. A Boolean
 574      * response of true represents success, and a response of false (or null) will
 575      * be considered to represent failure.
 576      */
 577     public static final Callback&lt;TreeTableView, Boolean&gt; DEFAULT_SORT_POLICY = new Callback&lt;TreeTableView, Boolean&gt;() {
 578         @Override public Boolean call(TreeTableView table) {
 579             try {
 580                 TreeItem rootItem = table.getRoot();
 581                 if (rootItem == null) return false;
 582 
 583                 TreeSortMode sortMode = table.getSortMode();
 584                 if (sortMode == null) return false;
 585 
 586                 rootItem.lastSortMode = sortMode;
 587                 rootItem.lastComparator = table.getComparator();
 588                 rootItem.sort();
 589                 return true;
 590             } catch (UnsupportedOperationException e) {
 591                 // TODO might need to support other exception types including:
 592                 // ClassCastException - if the class of the specified element prevents it from being added to this list
 593                 // NullPointerException - if the specified element is null and this list does not permit null elements
 594                 // IllegalArgumentException - if some property of this element prevents it from being added to this list
 595 
 596                 // If we are here the list does not support sorting, so we gracefully
 597                 // fail the sort request and ensure the UI is put back to its previous
 598                 // state. This is handled in the code that calls the sort policy.
 599 
 600                 return false;
 601             }
 602         }
 603     };
 604 
 605 
 606 
 607     /***************************************************************************
 608      *                                                                         *
 609      * Instance Variables                                                      *
 610      *                                                                         *
 611      **************************************************************************/
 612 
 613     // used in the tree item modification event listener. Used by the
 614     // layoutChildren method to determine whether the tree item count should
 615     // be recalculated.
 616     private boolean expandedItemCountDirty = true;
 617 
 618     // Used in the getTreeItem(int row) method to act as a cache.
 619     // See RT-26716 for the justification and performance gains.
 620     private Map&lt;Integer, SoftReference&lt;TreeItem&lt;S&gt;&gt;&gt; treeItemCacheMap = new HashMap&lt;&gt;();
 621 
 622     // this is the only publicly writable list for columns. This represents the
 623     // columns as they are given initially by the developer.
 624     private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = FXCollections.observableArrayList();
 625 
 626     // Finally, as convenience, we also have an observable list that contains
 627     // only the leaf columns that are currently visible.
 628     private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; visibleLeafColumns = FXCollections.observableArrayList();
 629     private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; unmodifiableVisibleLeafColumns = FXCollections.unmodifiableObservableList(visibleLeafColumns);
 630 
 631     // Allows for multiple column sorting based on the order of the TreeTableColumns
 632     // in this observableArrayList. Each TreeTableColumn is responsible for whether it is
 633     // sorted using ascending or descending order.
 634     private ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = FXCollections.observableArrayList();
 635 
 636     // width of VirtualFlow minus the vbar width
 637     // package protected for testing only
 638     double contentWidth;
 639 
 640     // Used to minimise the amount of work performed prior to the table being
 641     // completely initialised. In particular it reduces the amount of column
 642     // resize operations that occur, which slightly improves startup time.
 643     private boolean isInited = false;
 644 
 645 
 646 
 647     /***************************************************************************
 648      *                                                                         *
 649      * Callbacks and Events                                                    *
 650      *                                                                         *
 651      **************************************************************************/
 652 
 653     // we use this to forward events that have bubbled up TreeItem instances
 654     // to the TreeTableViewSkin, to force it to recalculate teh item count and redraw
 655     // if necessary
 656     private final EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; rootEvent = e -&gt; {
 657         // this forces layoutChildren at the next pulse, and therefore
 658         // updates the item count if necessary
 659         EventType&lt;?&gt; eventType = e.getEventType();
 660         boolean match = false;
 661         while (eventType != null) {
 662             if (eventType.equals(TreeItem.&lt;S&gt;expandedItemCountChangeEvent())) {
 663                 match = true;
 664                 break;
 665             }
 666             eventType = eventType.getSuperType();
 667         }
 668 
 669         if (match) {
 670             expandedItemCountDirty = true;
 671             requestLayout();
 672         }
 673     };
 674 
 675     private final ListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt; columnsObserver = new ListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt;() {
 676         @Override public void onChanged(ListChangeListener.Change&lt;? extends TreeTableColumn&lt;S,?&gt;&gt; c) {
 677             final List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getColumns();
 678 
 679             // Fix for RT-39822 - don&#39;t allow the same column to be installed twice
 680             while (c.next()) {
 681                 if (c.wasAdded()) {
 682                     List&lt;TreeTableColumn&lt;S,?&gt;&gt; duplicates = new ArrayList&lt;&gt;();
 683                     for (TreeTableColumn&lt;S,?&gt; addedColumn : c.getAddedSubList()) {
 684                         if (addedColumn == null) continue;
 685 
 686                         int count = 0;
 687                         for (TreeTableColumn&lt;S,?&gt; column : columns) {
 688                             if (addedColumn == column) {
 689                                 count++;
 690                             }
 691                         }
 692 
 693                         if (count &gt; 1) {
 694                             duplicates.add(addedColumn);
 695                         }
 696                     }
 697 
 698                     if (!duplicates.isEmpty()) {
 699                         String titleList = &quot;&quot;;
 700                         for (TreeTableColumn&lt;S,?&gt; dupe : duplicates) {
 701                             titleList += &quot;&#39;&quot; + dupe.getText() + &quot;&#39;, &quot;;
 702                         }
 703                         throw new IllegalStateException(&quot;Duplicate TreeTableColumns detected in TreeTableView columns list with titles &quot; + titleList);
 704                     }
 705                 }
 706             }
 707             c.reset();
 708 
 709             // Fix for RT-15194: Need to remove removed columns from the
 710             // sortOrder list.
 711             List&lt;TreeTableColumn&lt;S,?&gt;&gt; toRemove = new ArrayList&lt;TreeTableColumn&lt;S,?&gt;&gt;();
 712             while (c.next()) {
 713                 final List&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; removed = c.getRemoved();
 714                 final List&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; added = c.getAddedSubList();
 715 
 716                 if (c.wasRemoved()) {
 717                     toRemove.addAll(removed);
 718                     for (TreeTableColumn&lt;S,?&gt; tc : removed) {
 719                         tc.setTreeTableView(null);
 720                     }
 721                 }
 722 
 723                 if (c.wasAdded()) {
 724                     toRemove.removeAll(added);
 725                     for (TreeTableColumn&lt;S,?&gt; tc : added) {
 726                         tc.setTreeTableView(TreeTableView.this);
 727                     }
 728                 }
 729 
 730                 // set up listeners
 731                 TableUtil.removeColumnsListener(removed, weakColumnsObserver);
 732                 TableUtil.addColumnsListener(added, weakColumnsObserver);
 733 
 734                 TableUtil.removeTableColumnListener(c.getRemoved(),
 735                         weakColumnVisibleObserver,
 736                         weakColumnSortableObserver,
 737                         weakColumnSortTypeObserver,
 738                         weakColumnComparatorObserver);
 739                 TableUtil.addTableColumnListener(c.getAddedSubList(),
 740                         weakColumnVisibleObserver,
 741                         weakColumnSortableObserver,
 742                         weakColumnSortTypeObserver,
 743                         weakColumnComparatorObserver);
 744             }
 745 
 746             // We don&#39;t maintain a bind for leafColumns, we simply call this update
 747             // function behind the scenes in the appropriate places.
 748             updateVisibleLeafColumns();
 749 
 750             sortOrder.removeAll(toRemove);
 751 
 752             // Fix for RT-38892.
 753             final TreeTableViewFocusModel&lt;S&gt; fm = getFocusModel();
 754             final TreeTableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
 755             c.reset();
 756 
 757             // we need to collect together all removed and all added columns, because
 758             // the code below works on the actually removed columns. If we perform
 759             // the code within this while loop, we&#39;ll be deselecting columns that
 760             // should be deselected (because they have just moved place, for example).
 761             List&lt;TreeTableColumn&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;();
 762             List&lt;TreeTableColumn&lt;S,?&gt;&gt; added = new ArrayList&lt;&gt;();
 763             while (c.next()) {
 764                 if (c.wasRemoved()) {
 765                     removed.addAll(c.getRemoved());
 766                 }
 767                 if (c.wasAdded()) {
 768                     added.addAll(c.getAddedSubList());
 769                 }
 770             }
 771             removed.removeAll(added);
 772 
 773 
 774             // Fix for focus - we simply move focus to a cell to the left
 775             // of the focused cell if the focused cell was located within
 776             // a column that has been removed.
 777             if (fm != null) {
 778                 TreeTablePosition&lt;S, ?&gt; focusedCell = fm.getFocusedCell();
 779                 boolean match = false;
 780                 for (TreeTableColumn&lt;S, ?&gt; tc : removed) {
 781                     match = focusedCell != null &amp;&amp; focusedCell.getTableColumn() == tc;
 782                     if (match) {
 783                         break;
 784                     }
 785                 }
 786 
 787                 if (match) {
 788                     int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(focusedCell.getTableColumn(), 0);
 789                     int newFocusColumnIndex =
 790                             matchingColumnIndex == 0 ? 0 :
 791                                     Math.min(getVisibleLeafColumns().size() - 1, matchingColumnIndex - 1);
 792                     fm.focus(focusedCell.getRow(), getVisibleLeafColumn(newFocusColumnIndex));
 793                 }
 794             }
 795 
 796             // Fix for selection - we remove selection from all cells that
 797             // were within the removed column.
 798             if (sm != null) {
 799                 List&lt;TreeTablePosition&gt; selectedCells = new ArrayList&lt;&gt;(sm.getSelectedCells());
 800                 for (TreeTablePosition selectedCell : selectedCells) {
 801                     boolean match = false;
 802                     for (TreeTableColumn&lt;S, ?&gt; tc : removed) {
 803                         match = selectedCell != null &amp;&amp; selectedCell.getTableColumn() == tc;
 804                         if (match) break;
 805                     }
 806 
 807                     if (match) {
 808                         // we can&#39;t just use the selectedCell.getTableColumn(), as that
 809                         // column no longer exists and therefore its index is not correct.
 810                         int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(selectedCell.getTableColumn(), -1);
 811                         if (matchingColumnIndex == -1) continue;
 812 
 813                         if (sm instanceof TreeTableViewArrayListSelectionModel) {
 814                             // Also, because the table column no longer exists in the columns
 815                             // list at this point, we can&#39;t just call:
 816                             // sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
 817                             // as the tableColumn would map to an index of -1, which means that
 818                             // selection will not be cleared. Instead, we have to create
 819                             // a new TablePosition with a fixed column index and use that.
 820                             TreeTablePosition&lt;S,?&gt; fixedTablePosition =
 821                                     new TreeTablePosition&lt;S,Object&gt;(TreeTableView.this,
 822                                             selectedCell.getRow(),
 823                                             selectedCell.getTableColumn());
 824                             fixedTablePosition.fixedColumnIndex = matchingColumnIndex;
 825 
 826                             ((TreeTableViewArrayListSelectionModel)sm).clearSelection(fixedTablePosition);
 827                         } else {
 828                             sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
 829                         }
 830                     }
 831                 }
 832             }
 833 
 834 
 835             // update the lastKnownColumnIndex map
 836             lastKnownColumnIndex.clear();
 837             for (TreeTableColumn&lt;S,?&gt; tc : getColumns()) {
 838                 int index = getVisibleLeafIndex(tc);
 839                 if (index &gt; -1) {
 840                     lastKnownColumnIndex.put(tc, index);
 841                 }
 842             }
 843         }
 844     };
 845 
 846     private final WeakHashMap&lt;TreeTableColumn&lt;S,?&gt;, Integer&gt; lastKnownColumnIndex = new WeakHashMap&lt;&gt;();
 847 
 848     private final InvalidationListener columnVisibleObserver = valueModel -&gt; {
 849         updateVisibleLeafColumns();
 850     };
 851 
 852     private final InvalidationListener columnSortableObserver = valueModel -&gt; {
 853         TreeTableColumn col = (TreeTableColumn) ((BooleanProperty)valueModel).getBean();
 854         if (! getSortOrder().contains(col)) return;
 855         doSort(TableUtil.SortEventType.COLUMN_SORTABLE_CHANGE, col);
 856     };
 857 
 858     private final InvalidationListener columnSortTypeObserver = valueModel -&gt; {
 859         TreeTableColumn col = (TreeTableColumn) ((ObjectProperty)valueModel).getBean();
 860         if (! getSortOrder().contains(col)) return;
 861         doSort(TableUtil.SortEventType.COLUMN_SORT_TYPE_CHANGE, col);
 862     };
 863 
 864     private final InvalidationListener columnComparatorObserver = valueModel -&gt; {
 865         TreeTableColumn col = (TreeTableColumn) ((SimpleObjectProperty)valueModel).getBean();
 866         if (! getSortOrder().contains(col)) return;
 867         doSort(TableUtil.SortEventType.COLUMN_COMPARATOR_CHANGE, col);
 868     };
 869 
 870     /* proxy pseudo-class state change from selectionModel&#39;s cellSelectionEnabledProperty */
 871     private final InvalidationListener cellSelectionModelInvalidationListener = o -&gt; {
 872         boolean isCellSelection = ((BooleanProperty)o).get();
 873         pseudoClassStateChanged(PSEUDO_CLASS_CELL_SELECTION,  isCellSelection);
 874         pseudoClassStateChanged(PSEUDO_CLASS_ROW_SELECTION,  !isCellSelection);
 875     };
 876 
 877     private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakRootEventListener;
 878 
 879     private final WeakInvalidationListener weakColumnVisibleObserver =
 880             new WeakInvalidationListener(columnVisibleObserver);
 881 
 882     private final WeakInvalidationListener weakColumnSortableObserver =
 883             new WeakInvalidationListener(columnSortableObserver);
 884 
 885     private final WeakInvalidationListener weakColumnSortTypeObserver =
 886             new WeakInvalidationListener(columnSortTypeObserver);
 887 
 888     private final WeakInvalidationListener weakColumnComparatorObserver =
 889             new WeakInvalidationListener(columnComparatorObserver);
 890 
 891     private final WeakListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt; weakColumnsObserver =
 892             new WeakListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt;(columnsObserver);
 893 
 894     private final WeakInvalidationListener weakCellSelectionModelInvalidationListener =
 895             new WeakInvalidationListener(cellSelectionModelInvalidationListener);
 896 
 897 
 898 
 899     /***************************************************************************
 900      *                                                                         *
 901      * Properties                                                              *
 902      *                                                                         *
 903      **************************************************************************/
 904 
 905     // --- Root
 906     private ObjectProperty&lt;TreeItem&lt;S&gt;&gt; root = new SimpleObjectProperty&lt;TreeItem&lt;S&gt;&gt;(this, &quot;root&quot;) {
 907         private WeakReference&lt;TreeItem&lt;S&gt;&gt; weakOldItem;
 908 
 909         @Override protected void invalidated() {
 910             TreeItem&lt;S&gt; oldTreeItem = weakOldItem == null ? null : weakOldItem.get();
 911             if (oldTreeItem != null &amp;&amp; weakRootEventListener != null) {
 912                 oldTreeItem.removeEventHandler(TreeItem.&lt;S&gt;treeNotificationEvent(), weakRootEventListener);
 913             }
 914 
 915             TreeItem&lt;S&gt; root = getRoot();
 916             if (root != null) {
 917                 weakRootEventListener = new WeakEventHandler&lt;&gt;(rootEvent);
 918                 getRoot().addEventHandler(TreeItem.&lt;S&gt;treeNotificationEvent(), weakRootEventListener);
 919                 weakOldItem = new WeakReference&lt;&gt;(root);
 920             }
 921 
 922             // Fix for RT-35763
 923             getSortOrder().clear();
 924 
 925             expandedItemCountDirty = true;
 926             updateRootExpanded();
 927         }
 928     };
 929 
 930     /**
 931      * Sets the root node in this TreeTableView. See the {@link TreeItem} class level
 932      * documentation for more details.
 933      *
 934      * @param value The {@link TreeItem} that will be placed at the root of the
 935      *      TreeTableView.
 936      */
 937     public final void setRoot(TreeItem&lt;S&gt; value) {
 938         rootProperty().set(value);
 939     }
 940 
 941     /**
 942      * Returns the current root node of this TreeTableView, or null if no root node
 943      * is specified.
 944      * @return The current root node, or null if no root node exists.
 945      */
 946     public final TreeItem&lt;S&gt; getRoot() {
 947         return root == null ? null : root.get();
 948     }
 949 
 950     /**
 951      * Property representing the root node of the TreeTableView.
 952      * @return the root property
 953      */
 954     public final ObjectProperty&lt;TreeItem&lt;S&gt;&gt; rootProperty() {
 955         return root;
 956     }
 957 
 958 
 959 
 960     // --- Show Root
 961     private BooleanProperty showRoot;
 962 
 963     /**
 964      * Specifies whether the root {@code TreeItem} should be shown within this
 965      * TreeTableView.
 966      *
 967      * @param value If true, the root TreeItem will be shown, and if false it
 968      *      will be hidden.
 969      */
 970     public final void setShowRoot(boolean value) {
 971         showRootProperty().set(value);
 972     }
 973 
 974     /**
 975      * Returns true if the root of the TreeTableView should be shown, and false if
 976      * it should not. By default, the root TreeItem is visible in the TreeTableView.
 977      * @return true if the root of the TreeTableView should be shown
 978      */
 979     public final boolean isShowRoot() {
 980         return showRoot == null ? true : showRoot.get();
 981     }
 982 
 983     /**
 984      * Property that represents whether or not the TreeTableView root node is visible.
 985      * @return the show root property
 986      */
 987     public final BooleanProperty showRootProperty() {
 988         if (showRoot == null) {
 989             showRoot = new SimpleBooleanProperty(this, &quot;showRoot&quot;, true) {
 990                 @Override protected void invalidated() {
 991                     updateRootExpanded();
 992                     updateExpandedItemCount(getRoot());
 993                 }
 994             };
 995         }
 996         return showRoot;
 997     }
 998 
 999 
1000 
1001     // --- Tree Column
1002     private ObjectProperty&lt;TreeTableColumn&lt;S,?&gt;&gt; treeColumn;
1003     /**
1004      * Property that represents which column should have the disclosure node
1005      * shown in it (that is, the column with the arrow). By default this will be
1006      * the left-most column if this property is null, otherwise it will be the
1007      * specified column assuming it is non-null and contained within the
1008      * {@link #getVisibleLeafColumns() visible leaf columns} list.
1009      * @return the tree column property
1010      */
1011     public final ObjectProperty&lt;TreeTableColumn&lt;S,?&gt;&gt; treeColumnProperty() {
1012         if (treeColumn == null) {
1013             treeColumn = new SimpleObjectProperty&lt;&gt;(this, &quot;treeColumn&quot;, null);
1014         }
1015         return treeColumn;
1016     }
1017     public final void setTreeColumn(TreeTableColumn&lt;S,?&gt; value) {
1018         treeColumnProperty().set(value);
1019     }
1020     public final TreeTableColumn&lt;S,?&gt; getTreeColumn() {
1021         return treeColumn == null ? null : treeColumn.get();
1022     }
1023 
1024 
1025 
1026     // --- Selection Model
1027     private ObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt; selectionModel;
1028 
1029     /**
1030      * Sets the {@link MultipleSelectionModel} to be used in the TreeTableView.
1031      * Despite a TreeTableView requiring a &lt;code&gt;&lt;b&gt;Multiple&lt;/b&gt;SelectionModel&lt;/code&gt;,
1032      * it is possible to configure it to only allow single selection (see
1033      * {@link MultipleSelectionModel#setSelectionMode(javafx.scene.control.SelectionMode)}
1034      * for more information).
1035      * @param value the {@link MultipleSelectionModel} to be used
1036      */
1037     public final void setSelectionModel(TreeTableViewSelectionModel&lt;S&gt; value) {
1038         selectionModelProperty().set(value);
1039     }
1040 
1041     /**
1042      * Returns the currently installed selection model.
1043      * @return the currently installed selection model
1044      */
1045     public final TreeTableViewSelectionModel&lt;S&gt; getSelectionModel() {
1046         return selectionModel == null ? null : selectionModel.get();
1047     }
1048 
1049     /**
1050      * The SelectionModel provides the API through which it is possible
1051      * to select single or multiple items within a TreeTableView, as  well as inspect
1052      * which rows have been selected by the user. Note that it has a generic
1053      * type that must match the type of the TreeTableView itself.
1054      * @return the selection model property
1055      */
1056     public final ObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt; selectionModelProperty() {
1057         if (selectionModel == null) {
1058             selectionModel = new SimpleObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt;(this, &quot;selectionModel&quot;) {
1059 
1060                 TreeTableViewSelectionModel&lt;S&gt; oldValue = null;
1061 
1062                 @Override protected void invalidated() {
1063                     // need to listen to the cellSelectionEnabledProperty
1064                     // in order to set pseudo-class state
1065                     if (oldValue != null) {
1066                         oldValue.cellSelectionEnabledProperty().removeListener(weakCellSelectionModelInvalidationListener);
1067 
1068                         if (oldValue instanceof TreeTableViewArrayListSelectionModel) {
1069                             ((TreeTableViewArrayListSelectionModel)oldValue).dispose();
1070                         }
1071                     }
1072 
1073                     oldValue = get();
1074 
1075                     if (oldValue != null) {
1076                         oldValue.cellSelectionEnabledProperty().addListener(weakCellSelectionModelInvalidationListener);
1077                         // fake invalidation to ensure updated pseudo-class states
1078                         weakCellSelectionModelInvalidationListener.invalidated(oldValue.cellSelectionEnabledProperty());
1079                     }
1080                 }
1081             };
1082         }
1083         return selectionModel;
1084     }
1085 
1086 
1087     // --- Focus Model
1088     private ObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt; focusModel;
1089 
1090     /**
1091      * Sets the {@link FocusModel} to be used in the TreeTableView.
1092      * @param value the {@link FocusModel} to be used
1093      */
1094     public final void setFocusModel(TreeTableViewFocusModel&lt;S&gt; value) {
1095         focusModelProperty().set(value);
1096     }
1097 
1098     /**
1099      * Returns the currently installed {@link FocusModel}.
1100      * @return the currently installed {@link FocusModel}
1101      */
1102     public final TreeTableViewFocusModel&lt;S&gt; getFocusModel() {
1103         return focusModel == null ? null : focusModel.get();
1104     }
1105 
1106     /**
1107      * The FocusModel provides the API through which it is possible
1108      * to control focus on zero or one rows of the TreeTableView. Generally the
1109      * default implementation should be more than sufficient.
1110      * @return the focus model property
1111      */
1112     public final ObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt; focusModelProperty() {
1113         if (focusModel == null) {
1114             focusModel = new SimpleObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt;(this, &quot;focusModel&quot;);
1115         }
1116         return focusModel;
1117     }
1118 
1119 
1120     // --- Tree node count
1121     /**
1122      * &lt;p&gt;Represents the number of tree nodes presently able to be visible in the
1123      * TreeTableView. This is essentially the count of all expanded tree items, and
1124      * their children.
1125      *
1126      * &lt;p&gt;For example, if just the root node is visible, the expandedItemCount will
1127      * be one. If the root had three children and the root was expanded, the value
1128      * will be four.
1129      */
1130     private ReadOnlyIntegerWrapper expandedItemCount = new ReadOnlyIntegerWrapper(this, &quot;expandedItemCount&quot;, 0);
1131     public final ReadOnlyIntegerProperty expandedItemCountProperty() {
1132         return expandedItemCount.getReadOnlyProperty();
1133     }
1134     private void setExpandedItemCount(int value) {
1135         expandedItemCount.set(value);
1136     }
1137     public final int getExpandedItemCount() {
1138         if (expandedItemCountDirty) {
1139             updateExpandedItemCount(getRoot());
1140         }
1141         return expandedItemCount.get();
1142     }
1143 
1144 
1145     // --- Editable
1146     private BooleanProperty editable;
1147     public final void setEditable(boolean value) {
1148         editableProperty().set(value);
1149     }
1150     public final boolean isEditable() {
1151         return editable == null ? false : editable.get();
1152     }
1153     /**
1154      * Specifies whether this TreeTableView is editable - only if the TreeTableView and
1155      * the TreeCells within it are both editable will a TreeCell be able to go
1156      * into their editing state.
1157      * @return the editable property
1158      */
1159     public final BooleanProperty editableProperty() {
1160         if (editable == null) {
1161             editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
1162         }
1163         return editable;
1164     }
1165 
1166 
1167     // --- Editing Cell
1168     private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCell;
1169     private void setEditingCell(TreeTablePosition&lt;S,?&gt; value) {
1170         editingCellPropertyImpl().set(value);
1171     }
1172     public final TreeTablePosition&lt;S,?&gt; getEditingCell() {
1173         return editingCell == null ? null : editingCell.get();
1174     }
1175 
1176     /**
1177      * Represents the current cell being edited, or null if
1178      * there is no cell being edited.
1179      * @return the editing cell property
1180      */
1181     public final ReadOnlyObjectProperty&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCellProperty() {
1182         return editingCellPropertyImpl().getReadOnlyProperty();
1183     }
1184 
1185     private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCellPropertyImpl() {
1186         if (editingCell == null) {
1187             editingCell = new ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt;(this, &quot;editingCell&quot;);
1188         }
1189         return editingCell;
1190     }
1191 
1192 
1193     // --- Table menu button visible
1194     private BooleanProperty tableMenuButtonVisible;
1195     /**
1196      * This controls whether a menu button is available when the user clicks
1197      * in a designated space within the TableView, within which is a radio menu
1198      * item for each TreeTableColumn in this table. This menu allows for the user to
1199      * show and hide all TreeTableColumns easily.
1200      * @return the table menu button visible property
1201      */
1202     public final BooleanProperty tableMenuButtonVisibleProperty() {
1203         if (tableMenuButtonVisible == null) {
1204             tableMenuButtonVisible = new SimpleBooleanProperty(this, &quot;tableMenuButtonVisible&quot;);
1205         }
1206         return tableMenuButtonVisible;
1207     }
1208     public final void setTableMenuButtonVisible (boolean value) {
1209         tableMenuButtonVisibleProperty().set(value);
1210     }
1211     public final boolean isTableMenuButtonVisible() {
1212         return tableMenuButtonVisible == null ? false : tableMenuButtonVisible.get();
1213     }
1214 
1215 
1216     // --- Column Resize Policy
1217     private ObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt; columnResizePolicy;
1218     public final void setColumnResizePolicy(Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; callback) {
1219         columnResizePolicyProperty().set(callback);
1220     }
1221     public final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; getColumnResizePolicy() {
1222         return columnResizePolicy == null ? UNCONSTRAINED_RESIZE_POLICY : columnResizePolicy.get();
1223     }
1224 
1225     /**
1226      * This is the function called when the user completes a column-resize
1227      * operation. The two most common policies are available as static functions
1228      * in the TableView class: {@link #UNCONSTRAINED_RESIZE_POLICY} and
1229      * {@link #CONSTRAINED_RESIZE_POLICY}.
1230      * @return the column resize policy property
1231      */
1232     public final ObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt; columnResizePolicyProperty() {
1233         if (columnResizePolicy == null) {
1234             columnResizePolicy = new SimpleObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt;(this, &quot;columnResizePolicy&quot;, UNCONSTRAINED_RESIZE_POLICY) {
1235                 private Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; oldPolicy;
1236 
1237                 @Override protected void invalidated() {
1238                     if (isInited) {
1239                         get().call(new TreeTableView.ResizeFeatures(TreeTableView.this, null, 0.0));
1240 
1241                         if (oldPolicy != null) {
1242                             PseudoClass state = PseudoClass.getPseudoClass(oldPolicy.toString());
1243                             pseudoClassStateChanged(state, false);
1244                         }
1245                         if (get() != null) {
1246                             PseudoClass state = PseudoClass.getPseudoClass(get().toString());
1247                             pseudoClassStateChanged(state, true);
1248                         }
1249                         oldPolicy = get();
1250                     }
1251                 }
1252             };
1253         }
1254         return columnResizePolicy;
1255     }
1256 
1257 
1258     // --- Row Factory
1259     private ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt; rowFactory;
1260 
1261     /**
1262      * A function which produces a TreeTableRow. The system is responsible for
1263      * reusing TreeTableRows. Return from this function a TreeTableRow which
1264      * might be usable for representing a single row in a TableView.
1265      * &lt;p&gt;
1266      * Note that a TreeTableRow is &lt;b&gt;not&lt;/b&gt; a TableCell. A TreeTableRow is
1267      * simply a container for a TableCell, and in most circumstances it is more
1268      * likely that you&#39;ll want to create custom TableCells, rather than
1269      * TreeTableRows. The primary use case for creating custom TreeTableRow
1270      * instances would most probably be to introduce some form of column
1271      * spanning support.
1272      * &lt;p&gt;
1273      * You can create custom TableCell instances per column by assigning the
1274      * appropriate function to the cellFactory property in the TreeTableColumn class.
1275      * @return the row factory property
1276      */
1277     public final ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt; rowFactoryProperty() {
1278         if (rowFactory == null) {
1279             rowFactory = new SimpleObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt;(this, &quot;rowFactory&quot;);
1280         }
1281         return rowFactory;
1282     }
1283     public final void setRowFactory(Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt; value) {
1284         rowFactoryProperty().set(value);
1285     }
1286     public final Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt; getRowFactory() {
1287         return rowFactory == null ? null : rowFactory.get();
1288     }
1289 
1290 
1291     // --- Placeholder Node
1292     private ObjectProperty&lt;Node&gt; placeholder;
1293     /**
1294      * This Node is shown to the user when the table has no content to show.
1295      * This may be the case because the table model has no data in the first
1296      * place, that a filter has been applied to the table model, resulting
1297      * in there being nothing to show the user, or that there are no currently
1298      * visible columns.
1299      * @return the placeholder property
1300      */
1301     public final ObjectProperty&lt;Node&gt; placeholderProperty() {
1302         if (placeholder == null) {
1303             placeholder = new SimpleObjectProperty&lt;Node&gt;(this, &quot;placeholder&quot;);
1304         }
1305         return placeholder;
1306     }
1307     public final void setPlaceholder(Node value) {
1308         placeholderProperty().set(value);
1309     }
1310     public final Node getPlaceholder() {
1311         return placeholder == null ? null : placeholder.get();
1312     }
1313 
1314 
1315     // --- Fixed cell size
1316     private DoubleProperty fixedCellSize;
1317 
1318     /**
1319      * Sets the new fixed cell size for this control. Any value greater than
1320      * zero will enable fixed cell size mode, whereas a zero or negative value
1321      * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
1322      * mode.
1323      *
1324      * @param value The new fixed cell size value, or a value less than or equal
1325      *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
1326      * @since JavaFX 8.0
1327      */
1328     public final void setFixedCellSize(double value) {
1329         fixedCellSizeProperty().set(value);
1330     }
1331 
1332     /**
1333      * Returns the fixed cell size value. A value less than or equal to zero is
1334      * used to represent that fixed cell size mode is disabled, and a value
1335      * greater than zero represents the size of all cells in this control.
1336      *
1337      * @return A double representing the fixed cell size of this control, or a
1338      *      value less than or equal to zero if fixed cell size mode is disabled.
1339      * @since JavaFX 8.0
1340      */
1341     public final double getFixedCellSize() {
1342         return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
1343     }
1344     /**
1345      * Specifies whether this control has cells that are a fixed height (of the
1346      * specified value). If this value is less than or equal to zero,
1347      * then all cells are individually sized and positioned. This is a slow
1348      * operation. Therefore, when performance matters and developers are not
1349      * dependent on variable cell sizes it is a good idea to set the fixed cell
1350      * size value. Generally cells are around 24px, so setting a fixed cell size
1351      * of 24 is likely to result in very little difference in visuals, but a
1352      * improvement to performance.
1353      *
1354      * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
1355      * This should not be confused with the -fx-cell-size property. The difference
1356      * between these two CSS properties is that -fx-cell-size will size all
1357      * cells to the specified size, but it will not enforce that this is the
1358      * only size (thus allowing for variable cell sizes, and preventing the
1359      * performance gains from being possible). Therefore, when performance matters
1360      * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
1361      * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
1362      *
1363      * @return the fixed cell size property
1364      * @since JavaFX 8.0
1365      */
1366     public final DoubleProperty fixedCellSizeProperty() {
1367         if (fixedCellSize == null) {
1368             fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
1369                 @Override public CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt; getCssMetaData() {
1370                     return StyleableProperties.FIXED_CELL_SIZE;
1371                 }
1372 
1373                 @Override public Object getBean() {
1374                     return TreeTableView.this;
1375                 }
1376 
1377                 @Override public String getName() {
1378                     return &quot;fixedCellSize&quot;;
1379                 }
1380             };
1381         }
1382         return fixedCellSize;
1383     }
1384 
1385 
1386     // --- SortMode
1387     /**
1388      * Specifies the sort mode to use when sorting the contents of this TreeTableView,
1389      * should any columns be specified in the {@link #getSortOrder() sort order}
1390      * list.
1391      */
1392     private ObjectProperty&lt;TreeSortMode&gt; sortMode;
1393     public final ObjectProperty&lt;TreeSortMode&gt; sortModeProperty() {
1394         if (sortMode == null) {
1395             sortMode = new SimpleObjectProperty&lt;&gt;(this, &quot;sortMode&quot;, TreeSortMode.ALL_DESCENDANTS);
1396         }
1397         return sortMode;
1398     }
1399     public final void setSortMode(TreeSortMode value) {
1400         sortModeProperty().set(value);
1401     }
1402     public final TreeSortMode getSortMode() {
1403         return sortMode == null ? TreeSortMode.ALL_DESCENDANTS : sortMode.get();
1404     }
1405 
1406 
1407     // --- Comparator (built via sortOrder list, so read-only)
1408     /**
1409      * The comparator property is a read-only property that is representative of the
1410      * current state of the {@link #getSortOrder() sort order} list. The sort
1411      * order list contains the columns that have been added to it either programmatically
1412      * or via a user clicking on the headers themselves.
1413      */
1414     private ReadOnlyObjectWrapper&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparator;
1415     private void setComparator(Comparator&lt;TreeItem&lt;S&gt;&gt; value) {
1416         comparatorPropertyImpl().set(value);
1417     }
1418     public final Comparator&lt;TreeItem&lt;S&gt;&gt; getComparator() {
1419         return comparator == null ? null : comparator.get();
1420     }
1421     public final ReadOnlyObjectProperty&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparatorProperty() {
1422         return comparatorPropertyImpl().getReadOnlyProperty();
1423     }
1424     private ReadOnlyObjectWrapper&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparatorPropertyImpl() {
1425         if (comparator == null) {
1426             comparator = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;comparator&quot;);
1427         }
1428         return comparator;
1429     }
1430 
1431 
1432     // --- sortPolicy
1433     /**
1434      * The sort policy specifies how sorting in this TreeTableView should be performed.
1435      * For example, a basic sort policy may just recursively sort the children of
1436      * the root tree item, whereas a more advanced sort policy may call to a
1437      * database to perform the necessary sorting on the server-side.
1438      *
1439      * &lt;p&gt;TreeTableView ships with a {@link TableView#DEFAULT_SORT_POLICY default
1440      * sort policy} that does precisely as mentioned above: it simply attempts
1441      * to sort the tree hierarchy in-place.
1442      *
1443      * &lt;p&gt;It is recommended that rather than override the {@link TreeTableView#sort() sort}
1444      * method that a different sort policy be provided instead.
1445      */
1446     private ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt; sortPolicy;
1447     public final void setSortPolicy(Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; callback) {
1448         sortPolicyProperty().set(callback);
1449     }
1450     @SuppressWarnings(&quot;unchecked&quot;)
1451     public final Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; getSortPolicy() {
1452         return sortPolicy == null ?
1453                 (Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY :
1454                 sortPolicy.get();
1455     }
1456     @SuppressWarnings(&quot;unchecked&quot;)
1457     public final ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt; sortPolicyProperty() {
1458         if (sortPolicy == null) {
1459             sortPolicy = new SimpleObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt;(
1460                     this, &quot;sortPolicy&quot;, (Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY) {
1461                 @Override protected void invalidated() {
1462                     sort();
1463                 }
1464             };
1465         }
1466         return sortPolicy;
1467     }
1468 
1469 
1470     // onSort
1471     /**
1472      * Called when there&#39;s a request to sort the control.
1473      */
1474     private ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt; onSort;
1475 
1476     public void setOnSort(EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; value) {
1477         onSortProperty().set(value);
1478     }
1479 
1480     public EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; getOnSort() {
1481         if( onSort != null ) {
1482             return onSort.get();
1483         }
1484         return null;
1485     }
1486 
1487     public ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt; onSortProperty() {
1488         if( onSort == null ) {
1489             onSort = new ObjectPropertyBase&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt;() {
1490                 @Override protected void invalidated() {
1491                     EventType&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; eventType = SortEvent.sortEvent();
1492                     EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; eventHandler = get();
1493                     setEventHandler(eventType, eventHandler);
1494                 }
1495 
1496                 @Override public Object getBean() {
1497                     return TreeTableView.this;
1498                 }
1499 
1500                 @Override public String getName() {
1501                     return &quot;onSort&quot;;
1502                 }
1503             };
1504         }
1505         return onSort;
1506     }
1507 
1508 
1509 
1510     /***************************************************************************
1511      *                                                                         *
1512      * Public API                                                              *
1513      *                                                                         *
1514      **************************************************************************/
1515 
1516     /** {@inheritDoc} */
1517     @Override protected void layoutChildren() {
1518         if (expandedItemCountDirty) {
1519             updateExpandedItemCount(getRoot());
1520         }
1521 
1522         super.layoutChildren();
1523     }
1524 
1525     /**
1526      * Scrolls the TreeTableView such that the item in the given index is visible to
1527      * the end user.
1528      *
1529      * @param index The index that should be made visible to the user, assuming
1530      *      of course that it is greater than, or equal to 0, and less than the
1531      *      number of the visible items in the TreeTableView.
1532      */
1533     public void scrollTo(int index) {
1534         ControlUtils.scrollToIndex(this, index);
1535     }
1536 
1537     /**
1538      * Called when there&#39;s a request to scroll an index into view using {@link #scrollTo(int)}
1539      */
1540     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;
1541 
1542     public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
1543         onScrollToProperty().set(value);
1544     }
1545 
1546     public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
1547         if( onScrollTo != null ) {
1548             return onScrollTo.get();
1549         }
1550         return null;
1551     }
1552 
1553     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
1554         if( onScrollTo == null ) {
1555             onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
1556                 @Override protected void invalidated() {
1557                     setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
1558                 }
1559 
1560                 @Override public Object getBean() {
1561                     return TreeTableView.this;
1562                 }
1563 
1564                 @Override public String getName() {
1565                     return &quot;onScrollTo&quot;;
1566                 }
1567             };
1568         }
1569         return onScrollTo;
1570     }
1571 
1572     /**
1573      * Scrolls the TreeTableView so that the given column is visible within the viewport.
1574      * @param column The column that should be visible to the user.
1575      */
1576     public void scrollToColumn(TreeTableColumn&lt;S, ?&gt; column) {
1577         ControlUtils.scrollToColumn(this, column);
1578     }
1579 
1580     /**
1581      * Scrolls the TreeTableView so that the given index is visible within the viewport.
1582      * @param columnIndex The index of a column that should be visible to the user.
1583      */
1584     public void scrollToColumnIndex(int columnIndex) {
1585         if( getColumns() != null ) {
1586             ControlUtils.scrollToColumn(this, getColumns().get(columnIndex));
1587         }
1588     }
1589 
1590     /**
1591      * Called when there&#39;s a request to scroll a column into view using {@link #scrollToColumn(TreeTableColumn)}
1592      * or {@link #scrollToColumnIndex(int)}
1593      */
1594     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumn;
1595 
1596     public void setOnScrollToColumn(EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; value) {
1597         onScrollToColumnProperty().set(value);
1598     }
1599 
1600     public EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; getOnScrollToColumn() {
1601         if( onScrollToColumn != null ) {
1602             return onScrollToColumn.get();
1603         }
1604         return null;
1605     }
1606 
1607     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumnProperty() {
1608         if( onScrollToColumn == null ) {
1609             onScrollToColumn = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt;() {
1610                 @Override
1611                 protected void invalidated() {
1612                     EventType&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; type = ScrollToEvent.scrollToColumn();
1613                     setEventHandler(type, get());
1614                 }
1615                 @Override
1616                 public Object getBean() {
1617                     return TreeTableView.this;
1618                 }
1619 
1620                 @Override
1621                 public String getName() {
1622                     return &quot;onScrollToColumn&quot;;
1623                 }
1624             };
1625         }
1626         return onScrollToColumn;
1627     }
1628 
1629     /**
1630      * Returns the index position of the given TreeItem, assuming that it is
1631      * currently accessible through the tree hierarchy (most notably, that all
1632      * parent tree items are expanded). If a parent tree item is collapsed,
1633      * the result is that this method will return -1 to indicate that the
1634      * given tree item is not accessible in the tree.
1635      *
1636      * @param item The TreeItem for which the index is sought.
1637      * @return An integer representing the location in the current TreeTableView of the
1638      *      first instance of the given TreeItem, or -1 if it is null or can not
1639      *      be found (for example, if a parent (all the way up to the root) is
1640      *      collapsed).
1641      */
1642     public int getRow(TreeItem&lt;S&gt; item) {
1643         return TreeUtil.getRow(item, getRoot(), expandedItemCountDirty, isShowRoot());
1644     }
1645 
1646     /**
1647      * Returns the TreeItem in the given index, or null if it is out of bounds.
1648      *
1649      * @param row The index of the TreeItem being sought.
1650      * @return The TreeItem in the given index, or null if it is out of bounds.
1651      */
1652     public TreeItem&lt;S&gt; getTreeItem(int row) {
1653         if (row &lt; 0) return null;
1654 
1655         // normalize the requested row based on whether showRoot is set
1656         final int _row = isShowRoot() ? row : (row + 1);
1657 
1658         if (expandedItemCountDirty) {
1659             updateExpandedItemCount(getRoot());
1660         } else {
1661             if (treeItemCacheMap.containsKey(_row)) {
1662                 SoftReference&lt;TreeItem&lt;S&gt;&gt; treeItemRef = treeItemCacheMap.get(_row);
1663                 TreeItem&lt;S&gt; treeItem = treeItemRef.get();
1664                 if (treeItem != null) {
1665                     return treeItem;
1666                 }
1667             }
1668         }
1669 
1670         TreeItem&lt;S&gt; treeItem = TreeUtil.getItem(getRoot(), _row, expandedItemCountDirty);
1671         treeItemCacheMap.put(_row, new SoftReference&lt;&gt;(treeItem));
1672         return treeItem;
1673     }
1674 
1675     /**
1676      * Returns the number of levels of &#39;indentation&#39; of the given TreeItem,
1677      * based on how many times getParent() can be recursively called. If the
1678      * given TreeItem is the root node of this TreeTableView, or if the TreeItem
1679      * does not have any parent set, the returned value will be zero. For each
1680      * time getParent() is recursively called, the returned value is incremented
1681      * by one.
1682      *
1683      * @param node The TreeItem for which the level is needed.
1684      * @return An integer representing the number of parents above the given node,
1685      *         or -1 if the given TreeItem is null.
1686      */
1687     public int getTreeItemLevel(TreeItem&lt;?&gt; node) {
1688         final TreeItem&lt;?&gt; root = getRoot();
1689 
1690         if (node == null) return -1;
1691         if (node == root) return 0;
1692 
1693         int level = 0;
1694         TreeItem&lt;?&gt; parent = node.getParent();
1695         while (parent != null) {
1696             level++;
1697 
1698             if (parent == root) {
1699                 break;
1700             }
1701 
1702             parent = parent.getParent();
1703         }
1704 
1705         return level;
1706     }
1707 
1708     /**
1709      * The TreeTableColumns that are part of this TableView. As the user reorders
1710      * the TableView columns, this list will be updated to reflect the current
1711      * visual ordering.
1712      *
1713      * &lt;p&gt;Note: to display any data in a TableView, there must be at least one
1714      * TreeTableColumn in this ObservableList.&lt;/p&gt;
1715      * @return the table table column
1716      */
1717     public final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getColumns() {
1718         return columns;
1719     }
1720 
1721     /**
1722      * The sortOrder list defines the order in which {@link TreeTableColumn} instances
1723      * are sorted. An empty sortOrder list means that no sorting is being applied
1724      * on the TableView. If the sortOrder list has one TreeTableColumn within it,
1725      * the TableView will be sorted using the
1726      * {@link TreeTableColumn#sortTypeProperty() sortType} and
1727      * {@link TreeTableColumn#comparatorProperty() comparator} properties of this
1728      * TreeTableColumn (assuming
1729      * {@link TreeTableColumn#sortableProperty() TreeTableColumn.sortable} is true).
1730      * If the sortOrder list contains multiple TreeTableColumn instances, then
1731      * the TableView is firstly sorted based on the properties of the first
1732      * TreeTableColumn. If two elements are considered equal, then the second
1733      * TreeTableColumn in the list is used to determine ordering. This repeats until
1734      * the results from all TreeTableColumn comparators are considered, if necessary.
1735      *
1736      * @return An ObservableList containing zero or more TreeTableColumn instances.
1737      */
1738     public final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getSortOrder() {
1739         return sortOrder;
1740     }
1741 
1742     /**
1743      * Applies the currently installed resize policy against the given column,
1744      * resizing it based on the delta value provided.
1745      * @param column the column
1746      * @param delta the delta
1747      * @return true if column resizing is applied
1748      */
1749     public boolean resizeColumn(TreeTableColumn&lt;S,?&gt; column, double delta) {
1750         if (column == null || Double.compare(delta, 0.0) == 0) return false;
1751 
1752         boolean allowed = getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, column, delta));
1753         if (!allowed) return false;
1754         return true;
1755     }
1756 
1757     /**
1758      * Causes the cell at the given row/column view indexes to switch into
1759      * its editing state, if it is not already in it, and assuming that the
1760      * TableView and column are also editable.
1761      * @param row the row
1762      * @param column the column
1763      */
1764     public void edit(int row, TreeTableColumn&lt;S,?&gt; column) {
1765         if (!isEditable() || (column != null &amp;&amp; ! column.isEditable())) {
1766             return;
1767         }
1768 
1769         if (row &lt; 0 &amp;&amp; column == null) {
1770             setEditingCell(null);
1771         } else {
1772             setEditingCell(new TreeTablePosition&lt;&gt;(this, row, column));
1773         }
1774     }
1775 
1776     /**
1777      * Returns an unmodifiable list containing the currently visible leaf columns.
1778      * @return an unmodifiable list containing the currently visible leaf columns
1779      */
1780     public ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getVisibleLeafColumns() {
1781         return unmodifiableVisibleLeafColumns;
1782     }
1783 
1784     /**
1785      * Returns the position of the given column, relative to all other
1786      * visible leaf columns.
1787      * @param column the column
1788      * @return the position of the given column, relative to all other
1789      * visible leaf columns
1790      */
1791     public int getVisibleLeafIndex(TreeTableColumn&lt;S,?&gt; column) {
1792         return getVisibleLeafColumns().indexOf(column);
1793     }
1794 
1795     /**
1796      * Returns the TreeTableColumn in the given column index, relative to all other
1797      * visible leaf columns.
1798      * @param column the column
1799      * @return the TreeTableColumn in the given column index, relative to all other
1800      * visible leaf columns
1801      */
1802     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1803         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1804         return visibleLeafColumns.get(column);
1805     }
1806 
<a name="1" id="anc1"></a><span class="line-modified">1807     boolean sortingInProgress;</span>
1808     boolean isSortingInProgress() {
1809         return sortingInProgress;
1810     }
1811 
1812     /**
1813      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1814      * often than not it is not necessary to call this method directly, as it is
1815      * automatically called when the {@link #getSortOrder() sort order},
1816      * {@link #sortPolicyProperty() sort policy}, or the state of the
1817      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1818      * change. In other words, this method should only be called directly when
1819      * something external changes and a sort is required.
1820      */
1821     public void sort() {
1822         sortingInProgress = true;
1823         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1824 
1825         // update the Comparator property
1826         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1827         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1828 
1829         // fire the onSort event and check if it is consumed, if
1830         // so, don&#39;t run the sort
1831         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
1832         fireEvent(sortEvent);
1833         if (sortEvent.isConsumed()) {
1834             // if the sort is consumed we could back out the last action (the code
1835             // is commented out right below), but we don&#39;t as we take it as a
1836             // sign that the developer has decided to handle the event themselves.
1837 
1838             // sortLock = true;
1839             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1840             // sortLock = false;
1841             sortingInProgress = false;
1842             return;
1843         }
1844 
1845         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1846         final int itemCount = prevState.size();
1847 
1848         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1849         // sort events - instead we send a single permutation event at the end
1850         // of this method.
1851         getSelectionModel().startAtomic();
1852 
1853         // get the sort policy and run it
1854         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
1855         if (sortPolicy == null) return;
1856         Boolean success = sortPolicy.call(this);
1857 
1858         getSelectionModel().stopAtomic();
1859 
1860         if (success == null || ! success) {
1861             // the sort was a failure. Need to backout if possible
1862             sortLock = true;
1863             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1864             setComparator(oldComparator);
1865             sortLock = false;
1866         } else {
1867             // sorting was a success, now we possibly fire an event on the
1868             // selection model that the items list has &#39;permutated&#39; to a new ordering
1869 
1870             // FIXME we should support alternative selection model implementations!
1871             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1872                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1873                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1874 
1875                 List&lt;TreeTablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
1876                 for (int i = 0; i &lt; itemCount; i++) {
1877                     TreeTablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
1878                     if (!newState.contains(prevItem)) {
1879                         removed.add(prevItem);
1880                     }
1881                 }
1882                 if (!removed.isEmpty()) {
1883                     // the sort operation effectively permutates the selectedCells list,
1884                     // but we cannot fire a permutation event as we are talking about
1885                     // TreeTablePosition&#39;s changing (which may reside in the same list
1886                     // position before and after the sort). Therefore, we need to fire
1887                     // a single add/remove event to cover the added and removed positions.
1888                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
1889                     sm.fireCustomSelectedCellsListChangeEvent(c);
1890                 }
1891             }
1892             getSelectionModel().setSelectedIndex(getRow(getSelectionModel().getSelectedItem()));
1893             getFocusModel().focus(getSelectionModel().getSelectedIndex());
1894         }
1895         sortingInProgress = false;
1896     }
1897 
1898     /**
1899      * Calling {@code refresh()} forces the TreeTableView control to recreate and
1900      * repopulate the cells necessary to populate the visual bounds of the control.
1901      * In other words, this forces the TreeTableView to update what it is showing to
1902      * the user. This is useful in cases where the underlying data source has
1903      * changed in a way that is not observed by the TreeTableView itself.
1904      *
1905      * @since JavaFX 8u60
1906      */
1907     public void refresh() {
1908         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1909     }
1910 
1911 
1912 
1913     /***************************************************************************
1914      *                                                                         *
1915      * Private Implementation                                                  *
1916      *                                                                         *
1917      **************************************************************************/
1918 
1919     private boolean sortLock = false;
1920     private TableUtil.SortEventType lastSortEventType = null;
1921     private Object[] lastSortEventSupportInfo = null;
1922 
1923     private void doSort(final TableUtil.SortEventType sortEventType, final Object... supportInfo) {
1924         if (sortLock) {
1925             return;
1926         }
1927 
1928         this.lastSortEventType = sortEventType;
1929         this.lastSortEventSupportInfo = supportInfo;
1930         sort();
1931         this.lastSortEventType = null;
1932         this.lastSortEventSupportInfo = null;
1933     }
1934 
1935     private void updateExpandedItemCount(TreeItem&lt;S&gt; treeItem) {
1936         setExpandedItemCount(TreeUtil.updateExpandedItemCount(treeItem, expandedItemCountDirty, isShowRoot()));
1937 
1938         if (expandedItemCountDirty) {
1939             // this is a very inefficient thing to do, but for now having a cache
1940             // is better than nothing at all...
1941             treeItemCacheMap.clear();
1942         }
1943 
1944         expandedItemCountDirty = false;
1945     }
1946 
1947     private void updateRootExpanded() {
1948         // if we aren&#39;t showing the root, and the root isn&#39;t expanded, we expand
1949         // it now so that something is shown.
1950         if (!isShowRoot() &amp;&amp; getRoot() != null &amp;&amp; ! getRoot().isExpanded()) {
1951             getRoot().setExpanded(true);
1952         }
1953     }
1954 
1955 
1956     // --- Content width
1957     private void setContentWidth(double contentWidth) {
1958         this.contentWidth = contentWidth;
1959         if (isInited) {
1960             // sometimes the current column resize policy will have to modify the
1961             // column width of all columns in the table if the table width changes,
1962             // so we short-circuit the resize function and just go straight there
1963             // with a null TreeTableColumn, which indicates to the resize policy function
1964             // that it shouldn&#39;t actually do anything specific to one column.
1965             getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, null, 0.0));
1966         }
1967     }
1968 
1969     /**
1970      * Recomputes the currently visible leaf columns in this TableView.
1971      */
1972     private void updateVisibleLeafColumns() {
1973         // update visible leaf columns list
1974         List&lt;TreeTableColumn&lt;S,?&gt;&gt; cols = new ArrayList&lt;TreeTableColumn&lt;S,?&gt;&gt;();
1975         buildVisibleLeafColumns(getColumns(), cols);
1976         visibleLeafColumns.setAll(cols);
1977 
1978         // sometimes the current column resize policy will have to modify the
1979         // column width of all columns in the table if the table width changes,
1980         // so we short-circuit the resize function and just go straight there
1981         // with a null TreeTableColumn, which indicates to the resize policy function
1982         // that it shouldn&#39;t actually do anything specific to one column.
1983         getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, null, 0.0));
1984     }
1985 
1986     private void buildVisibleLeafColumns(List&lt;TreeTableColumn&lt;S,?&gt;&gt; cols, List&lt;TreeTableColumn&lt;S,?&gt;&gt; vlc) {
1987         for (TreeTableColumn&lt;S,?&gt; c : cols) {
1988             if (c == null) continue;
1989 
1990             boolean hasChildren = ! c.getColumns().isEmpty();
1991 
1992             if (hasChildren) {
1993                 buildVisibleLeafColumns(c.getColumns(), vlc);
1994             } else if (c.isVisible()) {
1995                 vlc.add(c);
1996             }
1997         }
1998     }
1999 
2000 
2001 
2002     /***************************************************************************
2003      *                                                                         *
2004      * Stylesheet Handling                                                     *
2005      *                                                                         *
2006      **************************************************************************/
2007 
2008     private static final String DEFAULT_STYLE_CLASS = &quot;tree-table-view&quot;;
2009 
2010     private static final PseudoClass PSEUDO_CLASS_CELL_SELECTION =
2011             PseudoClass.getPseudoClass(&quot;cell-selection&quot;);
2012     private static final PseudoClass PSEUDO_CLASS_ROW_SELECTION =
2013             PseudoClass.getPseudoClass(&quot;row-selection&quot;);
2014 
2015     private static class StyleableProperties {
2016         private static final CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
2017                 new CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
2018                                                      SizeConverter.getInstance(),
2019                                                      Region.USE_COMPUTED_SIZE) {
2020 
2021                     @Override public Double getInitialValue(TreeTableView&lt;?&gt; node) {
2022                         return node.getFixedCellSize();
2023                     }
2024 
2025                     @Override public boolean isSettable(TreeTableView&lt;?&gt; n) {
2026                         return n.fixedCellSize == null || !n.fixedCellSize.isBound();
2027                     }
2028 
2029                     @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(TreeTableView&lt;?&gt; n) {
2030                         return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;) n.fixedCellSizeProperty();
2031                     }
2032                 };
2033 
2034         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
2035         static {
2036             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
2037                     new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
2038             styleables.add(FIXED_CELL_SIZE);
2039             STYLEABLES = Collections.unmodifiableList(styleables);
2040         }
2041     }
2042 
2043     /**
2044      * @return The CssMetaData associated with this class, which may include the
2045      * CssMetaData of its superclasses.
2046      */
2047     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
2048         return StyleableProperties.STYLEABLES;
2049     }
2050 
2051     /**
2052      * {@inheritDoc}
2053      * @since JavaFX 8.0
2054      */
2055     @Override
2056     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
2057         return getClassCssMetaData();
2058     }
2059 
2060     /** {@inheritDoc} */
2061     @Override protected Skin&lt;?&gt; createDefaultSkin() {
2062         return new TreeTableViewSkin&lt;S&gt;(this);
2063     }
2064 
2065 
2066 
2067     /***************************************************************************
2068      *                                                                         *
2069      * Accessibility handling                                                  *
2070      *                                                                         *
2071      **************************************************************************/
2072 
2073     /** {@inheritDoc} */
2074     @Override
2075     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
2076         switch (attribute) {
2077             case ROW_COUNT: return getExpandedItemCount();
2078             case COLUMN_COUNT: return getVisibleLeafColumns().size();
2079 
2080             /*
2081              * TreeTableViewSkin returns TreeTableRows back to TreeTableView.
2082              * TreeTableRowSkin returns TreeTableCells back to TreeTableRow.
2083              */
2084             case SELECTED_ITEMS: {
2085                 @SuppressWarnings(&quot;unchecked&quot;)
2086                 ObservableList&lt;TreeTableRow&lt;S&gt;&gt; rows = (ObservableList&lt;TreeTableRow&lt;S&gt;&gt;)super.queryAccessibleAttribute(attribute, parameters);
2087                 List&lt;Node&gt; selection = new ArrayList&lt;&gt;();
2088                 for (TreeTableRow&lt;S&gt; row : rows) {
2089                     @SuppressWarnings(&quot;unchecked&quot;)
2090                     ObservableList&lt;Node&gt; cells = (ObservableList&lt;Node&gt;)row.queryAccessibleAttribute(attribute, parameters);
2091                     if (cells != null) selection.addAll(cells);
2092                 }
2093                 return FXCollections.observableArrayList(selection);
2094             }
2095             case FOCUS_ITEM: {
2096                 Node row = (Node)super.queryAccessibleAttribute(attribute, parameters);
2097                 if (row == null) return null;
2098                 Node cell = (Node)row.queryAccessibleAttribute(attribute, parameters);
2099                 /* cell equals to null means the row is a placeholder node */
2100                 return cell != null ?  cell : row;
2101             }
2102             case CELL_AT_ROW_COLUMN: {
2103                 @SuppressWarnings(&quot;unchecked&quot;)
2104                 TreeTableRow&lt;S&gt; row = (TreeTableRow&lt;S&gt;)super.queryAccessibleAttribute(attribute, parameters);
2105                 return row != null ? row.queryAccessibleAttribute(attribute, parameters) : null;
2106             }
2107             case MULTIPLE_SELECTION: {
2108                 TreeTableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
2109                 return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
2110             }
2111             default: return super.queryAccessibleAttribute(attribute, parameters);
2112         }
2113     }
2114 
2115     /***************************************************************************
2116      *                                                                         *
2117      * Support Classes                                                         *
2118      *                                                                         *
2119      **************************************************************************/
2120 
2121      /**
2122       * An immutable wrapper class for use in the TableView
2123      * {@link TreeTableView#columnResizePolicyProperty() column resize} functionality.
2124       * @since JavaFX 8.0
2125       */
2126      public static class ResizeFeatures&lt;S&gt; extends ResizeFeaturesBase&lt;TreeItem&lt;S&gt;&gt; {
2127         private TreeTableView&lt;S&gt; treeTable;
2128 
2129         /**
2130          * Creates an instance of this class, with the provided TreeTableView,
2131          * TreeTableColumn and delta values being set and stored in this immutable
2132          * instance.
2133          *
2134          * @param treeTable The TreeTableView upon which the resize operation is occurring.
2135          * @param column The column upon which the resize is occurring, or null
2136          *      if this ResizeFeatures instance is being created as a result of a
2137          *      TreeTableView resize operation.
2138          * @param delta The amount of horizontal space added or removed in the
2139          *      resize operation.
2140          */
2141         public ResizeFeatures(TreeTableView&lt;S&gt; treeTable, TreeTableColumn&lt;S,?&gt; column, Double delta) {
2142             super(column, delta);
2143             this.treeTable = treeTable;
2144         }
2145 
2146         /**
2147          * Returns the column upon which the resize is occurring, or null
2148          * if this ResizeFeatures instance was created as a result of a
2149          * TreeTableView resize operation.
2150          */
2151         @Override public TreeTableColumn&lt;S,?&gt; getColumn() {
2152             return (TreeTableColumn&lt;S,?&gt;) super.getColumn();
2153         }
2154 
2155         /**
2156          * Returns the TreeTableView upon which the resize operation is occurring.
2157          * @return the TreeTableView upon which the resize operation is occurring
2158          */
2159         public TreeTableView&lt;S&gt; getTable() { return treeTable; }
2160     }
2161 
2162 
2163 
2164     /**
2165      * An {@link Event} subclass used specifically in TreeTableView for representing
2166      * edit-related events. It provides additional API to easily access the
2167      * TreeItem that the edit event took place on, as well as the input provided
2168      * by the end user.
2169      *
2170      * @param &lt;S&gt; The type of the input, which is the same type as the TreeTableView
2171      *      itself.
2172      * @since JavaFX 8.0
2173      */
2174     public static class EditEvent&lt;S&gt; extends Event {
2175         private static final long serialVersionUID = -4437033058917528976L;
2176 
2177         /**
2178          * Common supertype for all edit event types.
2179          */
2180         public static final EventType&lt;?&gt; ANY = EDIT_ANY_EVENT;
2181 
2182         private final TreeTableView&lt;S&gt; source;
2183         private final S oldValue;
2184         private final S newValue;
2185         private transient final TreeItem&lt;S&gt; treeItem;
2186 
2187         /**
2188          * Creates a new EditEvent instance to represent an edit event. This
2189          * event is used for {@link #editStartEvent()},
2190          * {@link #editCommitEvent()} and {@link #editCancelEvent()} types.
2191          * @param source the source
2192          * @param eventType the eventType
2193          * @param treeItem the treeItem
2194          * @param oldValue the oldValue
2195          * @param newValue the newValue
2196          */
2197         public EditEvent(TreeTableView&lt;S&gt; source,
2198                          EventType&lt;? extends TreeTableView.EditEvent&gt; eventType,
2199                          TreeItem&lt;S&gt; treeItem, S oldValue, S newValue) {
2200             super(source, Event.NULL_SOURCE_TARGET, eventType);
2201             this.source = source;
2202             this.oldValue = oldValue;
2203             this.newValue = newValue;
2204             this.treeItem = treeItem;
2205         }
2206 
2207         /**
2208          * Returns the TreeTableView upon which the edit took place.
2209          * @return the TreeTableView upon which the edit took place
2210          */
2211         @Override public TreeTableView&lt;S&gt; getSource() {
2212             return source;
2213         }
2214 
2215         /**
2216          * Returns the {@link TreeItem} upon which the edit took place.
2217          * @return the {@link TreeItem} upon which the edit took place
2218          */
2219         public TreeItem&lt;S&gt; getTreeItem() {
2220             return treeItem;
2221         }
2222 
2223         /**
2224          * Returns the new value input into the TreeItem by the end user.
2225          * @return the new value input into the TreeItem by the end user
2226          */
2227         public S getNewValue() {
2228             return newValue;
2229         }
2230 
2231         /**
2232          * Returns the old value that existed in the TreeItem prior to the current
2233          * edit event.
2234          * @return the old value that existed in the TreeItem prior to the current
2235          * edit event
2236          */
2237         public S getOldValue() {
2238             return oldValue;
2239         }
2240     }
2241 
2242 
2243 
2244      /**
2245      * A simple extension of the {@link SelectionModel} abstract class to
2246      * allow for special support for TreeTableView controls.
2247       *
2248      * @since JavaFX 8.0
2249      */
2250     public static abstract class TreeTableViewSelectionModel&lt;S&gt; extends
2251             TableSelectionModel&lt;TreeItem&lt;S&gt;&gt; {
2252 
2253         /***********************************************************************
2254          *                                                                     *
2255          * Private fields                                                      *
2256          *                                                                     *
2257          **********************************************************************/
2258 
2259         private final TreeTableView&lt;S&gt; treeTableView;
2260 
2261 
2262         /***********************************************************************
2263          *                                                                     *
2264          * Constructors                                                        *
2265          *                                                                     *
2266          **********************************************************************/
2267 
2268         /**
2269          * Builds a default TreeTableViewSelectionModel instance with the provided
2270          * TreeTableView.
2271          * @param treeTableView The TreeTableView upon which this selection model should
2272          *      operate.
2273          * @throws NullPointerException TreeTableView can not be null.
2274          */
2275         public TreeTableViewSelectionModel(final TreeTableView&lt;S&gt; treeTableView) {
2276             if (treeTableView == null) {
2277                 throw new NullPointerException(&quot;TreeTableView can not be null&quot;);
2278             }
2279 
2280             this.treeTableView = treeTableView;
2281         }
2282 
2283 
2284 
2285         /***********************************************************************
2286          *                                                                     *
2287          * Abstract API                                                        *
2288          *                                                                     *
2289          **********************************************************************/
2290 
2291          /**
2292          * A read-only ObservableList representing the currently selected cells
2293          * in this TreeTableView. Rather than directly modify this list, please
2294          * use the other methods provided in the TreeTableViewSelectionModel.
2295          * @return a list of selected cells
2296          */
2297         public abstract ObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; getSelectedCells();
2298 
2299 
2300 
2301         /***********************************************************************
2302          *                                                                     *
2303          * Public API                                                          *
2304          *                                                                     *
2305          **********************************************************************/
2306 
2307          /**
2308           * Returns the TreeTableView instance that this selection model is installed in.
2309          * @return the TreeTableView instance that this selection model is installed in
2310           */
2311          public TreeTableView&lt;S&gt; getTreeTableView() {
2312              return treeTableView;
2313          }
2314 
2315          /** {@inheritDoc} */
2316          @Override public TreeItem&lt;S&gt; getModelItem(int index) {
2317              return treeTableView.getTreeItem(index);
2318          }
2319 
2320          /** {@inheritDoc} */
2321          @Override protected int getItemCount() {
2322              return treeTableView.getExpandedItemCount();
2323          }
2324 
2325          /** {@inheritDoc} */
2326          @Override public void focus(int row) {
2327              focus(row, null);
2328          }
2329 
2330          /** {@inheritDoc} */
2331          @Override public int getFocusedIndex() {
2332              return getFocusedCell().getRow();
2333          }
2334 
2335          /** {@inheritDoc} */
2336          @Override public void selectRange(int minRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; minColumn,
2337                                            int maxRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; maxColumn) {
2338              final int minColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)minColumn);
2339              final int maxColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)maxColumn);
2340              for (int _row = minRow; _row &lt;= maxRow; _row++) {
2341                  for (int _col = minColumnIndex; _col &lt;= maxColumnIndex; _col++) {
2342                      select(_row, treeTableView.getVisibleLeafColumn(_col));
2343                  }
2344              }
2345          }
2346 
2347 
2348 
2349         /***********************************************************************
2350          *                                                                     *
2351          * Private implementation                                              *
2352          *                                                                     *
2353          **********************************************************************/
2354 
2355          private void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
2356              focus(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column));
2357          }
2358 
2359          private void focus(TreeTablePosition&lt;S,?&gt; pos) {
2360              if (getTreeTableView().getFocusModel() == null) return;
2361 
2362              getTreeTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
2363          }
2364 
2365          private TreeTablePosition&lt;S,?&gt; getFocusedCell() {
2366              if (treeTableView.getFocusModel() == null) {
2367                  return new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
2368              }
2369              return treeTableView.getFocusModel().getFocusedCell();
2370          }
2371      }
2372 
2373 
2374 
2375     /**
2376      * A primitive selection model implementation, using a List&lt;Integer&gt; to store all
2377      * selected indices.
2378      */
2379     // package for testing
2380     static class TreeTableViewArrayListSelectionModel&lt;S&gt; extends TreeTableViewSelectionModel&lt;S&gt; {
2381 
2382         private final MappingChange.Map&lt;TreeTablePosition&lt;S,?&gt;,Integer&gt; cellToIndicesMap = f -&gt; f.getRow();
2383 
2384         private TreeTableView&lt;S&gt; treeTableView = null;
2385 
2386         /***********************************************************************
2387          *                                                                     *
2388          * Constructors                                                        *
2389          *                                                                     *
2390          **********************************************************************/
2391 
2392         public TreeTableViewArrayListSelectionModel(final TreeTableView&lt;S&gt; treeTableView) {
2393             super(treeTableView);
2394             this.treeTableView = treeTableView;
2395 
2396             this.treeTableView.rootProperty().addListener(weakRootPropertyListener);
2397             this.treeTableView.showRootProperty().addListener(showRootPropertyListener);
2398             updateTreeEventListener(null, treeTableView.getRoot());
2399 
2400             selectedCellsMap = new SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt;(this::fireCustomSelectedCellsListChangeEvent) {
2401                 @Override public boolean isCellSelectionEnabled() {
2402                     return TreeTableViewArrayListSelectionModel.this.isCellSelectionEnabled();
2403                 }
2404             };
2405 
2406             selectedCellsSeq = new ReadOnlyUnbackedObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt;() {
2407                 @Override public TreeTablePosition&lt;S,?&gt; get(int i) {
2408                     return selectedCellsMap.get(i);
2409                 }
2410 
2411                 @Override public int size() {
2412                     return selectedCellsMap.size();
2413                 }
2414             };
2415 //            selectedCellsSeq.addListener((ListChangeListener&lt;? super TreeTablePosition&lt;S,?&gt;&gt;) c -&gt; {
2416 //                ControlUtils.updateSelectedIndices(this, c);
2417 //            });
2418 
2419             updateDefaultSelection();
2420 
2421             cellSelectionEnabledProperty().addListener(o -&gt; {
2422                 updateDefaultSelection();
2423                 TableCellBehaviorBase.setAnchor(treeTableView, getFocusedCell(), true);
2424             });
2425         }
2426 
2427         private void dispose() {
2428             this.treeTableView.rootProperty().removeListener(weakRootPropertyListener);
2429             this.treeTableView.showRootProperty().removeListener(showRootPropertyListener);
2430 
2431             TreeItem&lt;S&gt; root = this.treeTableView.getRoot();
2432             if (root != null) {
2433                 root.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
2434             }
2435         }
2436 
2437         private void updateTreeEventListener(TreeItem&lt;S&gt; oldRoot, TreeItem&lt;S&gt; newRoot) {
2438             if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
2439                 oldRoot.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
2440             }
2441 
2442             if (newRoot != null) {
2443                 weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
2444                 newRoot.addEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
2445             }
2446         }
2447 
2448         private ChangeListener&lt;TreeItem&lt;S&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
2449             updateDefaultSelection();
2450 
2451             updateTreeEventListener(oldValue, newValue);
2452         };
2453 
2454         private InvalidationListener showRootPropertyListener = o -&gt; {
2455             shiftSelection(0, treeTableView.isShowRoot() ? 1 : -1, null);
2456         };
2457 
2458         private EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; treeItemListener = new EventHandler&lt;&gt;() {
2459             @Override public void handle(TreeItem.TreeModificationEvent&lt;S&gt; e) {
2460 
2461                 if (getSelectedIndex() == -1 &amp;&amp; getSelectedItem() == null) return;
2462 
2463                 final TreeItem&lt;S&gt; treeItem = e.getTreeItem();
2464                 if (treeItem == null) return;
2465 
2466                 final int oldSelectedIndex = getSelectedIndex();
2467 
2468                 treeTableView.expandedItemCountDirty = true;
2469 
2470                 // we only shift selection from this row - everything before it
2471                 // is safe. We might change this below based on certain criteria
2472                 int startRow = treeTableView.getRow(treeItem);
2473 
2474                 int shift = 0;
2475                 ListChangeListener.Change&lt;? extends TreeItem&lt;?&gt;&gt; change = e.getChange();
2476                 if (change != null) {
2477                     change.next();
2478                 }
2479 
2480                 do {
2481                     final int addedSize = change == null ? 0 : change.getAddedSize();
2482                     final int removedSize = change == null ? 0 : change.getRemovedSize();
2483 
2484                     if (e.wasExpanded()) {
2485                         // need to shuffle selection by the number of visible children
2486                         shift += treeItem.getExpandedDescendentCount(false) - 1;
2487                         startRow++;
2488                     } else if (e.wasCollapsed()) {
2489                         // remove selection from any child treeItem, and also determine
2490                         // if any child item was selected (in which case the parent
2491                         // takes the selection on collapse)
2492                         treeItem.getExpandedDescendentCount(false);
2493                         final int count = treeItem.previousExpandedDescendentCount;
2494 
2495                         final int selectedIndex = getSelectedIndex();
2496                         final boolean wasPrimarySelectionInChild =
2497                                 selectedIndex &gt;= (startRow + 1) &amp;&amp;
2498                                         selectedIndex &lt; (startRow + count);
2499 
2500                         boolean wasAnyChildSelected = false;
2501                         final boolean isCellSelectionMode = isCellSelectionEnabled();
2502                         ObservableList&lt;TreeTableColumn&lt;S, ?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2503 
2504                         selectedIndices._beginChange();
2505                         final int from = startRow + 1;
2506                         final int to = startRow + count;
2507                         final List&lt;Integer&gt; removed = new ArrayList&lt;&gt;();
2508                         TreeTableColumn&lt;S, ?&gt; selectedColumn = null;
2509                         for (int i = from; i &lt; to; i++) {
2510                             // we have to handle cell selection mode differently than
2511                             // row selection mode. Refer to RT-34103 for the bug report
2512                             // that drove this change, but in short the issue was that
2513                             // when collapsing a branch that had selection, we were
2514                             // always calling isSelected(row), but that always returns
2515                             // false in cell selection mode.
2516                             if (isCellSelectionMode) {
2517                                 for (int column = 0; column &lt; columns.size(); column++) {
2518                                     final TreeTableColumn&lt;S, ?&gt; col = columns.get(column);
2519                                     if (isSelected(i, col)) {
2520                                         wasAnyChildSelected = true;
2521                                         clearSelection(i, col);
2522                                         selectedColumn = col;
2523                                     }
2524                                 }
2525                             } else {
2526                                 if (isSelected(i)) {
2527                                     wasAnyChildSelected = true;
2528                                     removed.add(i);
2529                                 }
2530                             }
2531                         }
2532 
2533                         ControlUtils.reducingChange(selectedIndices, removed);
2534 
2535                         for (int index : removed) {
2536                             startAtomic();
2537                             // we pass in false here to prevent a lookup into the TreeItem, as it is unnecessary
2538                             // and results in JDK-8152396
2539                             clearSelection(new TreeTablePosition&lt;&gt;(treeTableView, index, null, false));
2540                             stopAtomic();
2541                         }
2542                         selectedIndices._endChange();
2543 
2544                         // put selection onto the newly-collapsed tree item
2545                         if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
2546                             select(startRow, selectedColumn);
2547                         }
2548 
2549                         shift += -count + 1;
2550                         startRow++;
2551                     } else if (e.wasPermutated()) {
2552                         // Approach:
2553                         // Get the current selection.
2554                         // Create a new selection with updated index(row).
2555                         // Update the current selection with new selection.
2556                         // If sorting is in progress then Selection change events will be sent from
2557                         // sort() method, and should not be sent from here.
2558                         // else, in case otherwise, the selection change events would be generated.
2559                         // Do not call shiftSelection() in case of permutation change(when shift == 0).
2560 
2561                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; currentSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());
2562                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; updatedSelection = new ArrayList&lt;&gt;();
2563 
2564                         boolean selectionIndicesChanged = false;
2565                         for (TreeTablePosition&lt;S, ?&gt; selectedCell : currentSelection) {
2566                             int newRow = treeTableView.getRow(selectedCell.getTreeItem());
2567                             if (selectedCell.getRow() != newRow) {
2568                                 selectionIndicesChanged = true;
2569                             }
2570                             updatedSelection.add(new TreeTablePosition&lt;&gt;(selectedCell, newRow));
2571                         }
2572                         if (selectionIndicesChanged) {
2573                             if (treeTableView.isSortingInProgress()) {
2574                                 startAtomic();
2575                                 quietClearSelection();
2576                                 selectedCellsMap.setAll(updatedSelection);
2577                                 stopAtomic();
2578                             } else {
2579                                 startAtomic();
2580                                 quietClearSelection();
2581                                 stopAtomic();
2582                                 selectedCellsMap.setAll(updatedSelection);
2583                                 int selectedIndex = treeTableView.getRow(getSelectedItem());
2584                                 setSelectedIndex(selectedIndex);
2585                                 focus(selectedIndex);
2586                             }
2587                         }
2588                     } else if (e.wasAdded()) {
2589                         // shuffle selection by the number of added items
2590                         shift += treeItem.isExpanded() ? addedSize : 0;
2591 
2592                         // RT-32963: We were taking the startRow from the TreeItem
2593                         // in which the children were added, rather than from the
2594                         // actual position of the new child. This led to selection
2595                         // being moved off the parent TreeItem by mistake.
2596                         // The &#39;if (e.getAddedSize() == 1)&#39; condition here was
2597                         // subsequently commented out due to RT-33894.
2598                         startRow = treeTableView.getRow(e.getChange().getAddedSubList().get(0));
2599 
2600                         TreeTablePosition&lt;S, ?&gt; anchor = TreeTableCellBehavior.getAnchor(treeTableView, null);
2601                         if (anchor != null) {
2602                             boolean isAnchorSelected = isSelected(anchor.getRow(), anchor.getTableColumn());
2603                             if (isAnchorSelected) {
2604                                 TreeTablePosition&lt;S, ?&gt; newAnchor = new TreeTablePosition&lt;&gt;(treeTableView, anchor.getRow() + shift, anchor.getTableColumn());
2605                                 TreeTableCellBehavior.setAnchor(treeTableView, newAnchor, false);
2606                             }
2607                         }
2608                     } else if (e.wasRemoved()) {
2609                         // shuffle selection by the number of removed items
2610                         shift += treeItem.isExpanded() ? -removedSize : 0;
2611 
2612                         // the start row is incorrect - it is _not_ the index of the
2613                         // TreeItem in which the children were removed from (which is
2614                         // what it currently represents). We need to take the &#39;from&#39;
2615                         // value out of the event and make use of that to understand
2616                         // what actually changed inside the children list.
2617                         startRow += e.getFrom() + 1;
2618 
2619                         // whilst we are here, we should check if the removed items
2620                         // are part of the selectedItems list - and remove them
2621                         // from selection if they are (as per RT-15446)
2622                         final List&lt;Integer&gt; selectedIndices = getSelectedIndices();
2623                         final List&lt;TreeItem&lt;S&gt;&gt; selectedItems = getSelectedItems();
2624                         final TreeItem&lt;S&gt; selectedItem = getSelectedItem();
2625                         final List&lt;? extends TreeItem&lt;S&gt;&gt; removedChildren = e.getChange().getRemoved();
2626 
2627                         for (int i = 0; i &lt; selectedIndices.size() &amp;&amp; !selectedItems.isEmpty(); i++) {
2628                             int index = selectedIndices.get(i);
2629                             if (index &gt; selectedItems.size()) break;
2630 
2631                             if (removedChildren.size() == 1 &amp;&amp;
2632                                     selectedItems.size() == 1 &amp;&amp;
2633                                     selectedItem != null &amp;&amp;
2634                                     selectedItem.equals(removedChildren.get(0))) {
2635                                 // Bug fix for RT-28637
2636                                 if (oldSelectedIndex &lt; getItemCount()) {
2637                                     final int previousRow = oldSelectedIndex == 0 ? 0 : oldSelectedIndex - 1;
2638                                     TreeItem&lt;S&gt; newSelectedItem = getModelItem(previousRow);
2639                                     if (!selectedItem.equals(newSelectedItem)) {
2640                                         clearAndSelect(previousRow);
2641                                     }
2642                                 }
2643                             }
2644                         }
2645                     }
2646                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
2647 
2648                 if (shift != 0) {
2649                     shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {
2650                         @Override public Void call(ShiftParams param) {
2651 
2652                             // we make the shifts atomic, as otherwise listeners to
2653                             // the items / indices lists get a lot of intermediate
2654                             // noise. They eventually get the summary event fired
2655                             // from within shiftSelection, so this is ok.
2656                             startAtomic();
2657 
2658                             final int clearIndex = param.getClearIndex();
2659                             final int setIndex = param.getSetIndex();
2660                             TreeTablePosition&lt;S,?&gt; oldTP = null;
2661                             if (clearIndex &gt; -1) {
2662                                 for (int i = 0; i &lt; selectedCellsMap.size(); i++) {
2663                                     TreeTablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);
2664                                     if (tp.getRow() == clearIndex) {
2665                                         oldTP = tp;
2666                                         selectedCellsMap.remove(tp);
2667                                     } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {
2668                                         selectedCellsMap.remove(tp);
2669                                     }
2670                                 }
2671                             }
2672 
2673                             if (oldTP != null &amp;&amp; param.isSelected()) {
2674                                 TreeTablePosition&lt;S,?&gt; newTP = new TreeTablePosition&lt;&gt;(
2675                                         treeTableView, param.getSetIndex(), oldTP.getTableColumn());
2676 
2677                                 selectedCellsMap.add(newTP);
2678                             }
2679 
2680                             stopAtomic();
2681 
2682                             return null;
2683                         }
2684                     });
2685                 }
2686             }
2687         };
2688 
2689         private WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
2690                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
2691 
2692         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
2693 
2694 
2695 
2696         /***********************************************************************
2697          *                                                                     *
2698          * Observable properties (and getters/setters)                         *
2699          *                                                                     *
2700          **********************************************************************/
2701 
2702         // the only &#39;proper&#39; internal data structure, selectedItems and selectedIndices
2703         // are both &#39;read-only and unbacked&#39;.
2704         private final SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsMap;
2705 
2706         private final ReadOnlyUnbackedObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsSeq;
2707         @Override public ObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; getSelectedCells() {
2708             return selectedCellsSeq;
2709         }
2710 
2711 
2712         /***********************************************************************
2713          *                                                                     *
2714          * Internal properties                                                 *
2715          *                                                                     *
2716          **********************************************************************/
2717 
2718 
2719 
2720         /***********************************************************************
2721          *                                                                     *
2722          * Public selection API                                                *
2723          *                                                                     *
2724          **********************************************************************/
2725 
2726         @Override public void clearAndSelect(int row) {
2727             clearAndSelect(row, null);
2728         }
2729 
2730         @Override public void clearAndSelect(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
2731             if (row &lt; 0 || row &gt;= getItemCount()) return;
2732 
2733             final TreeTablePosition&lt;S,?&gt; newTablePosition = new TreeTablePosition&lt;&gt;(getTreeTableView(), row, (TreeTableColumn&lt;S,?&gt;)column);
2734             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
2735 
2736             // replace the anchor
2737             TreeTableCellBehavior.setAnchor(treeTableView, newTablePosition, false);
2738 
2739             // firstly we make a copy of the selection, so that we can send out
2740             // the correct details in the selection change event.
2741             List&lt;TreeTablePosition&lt;S,?&gt;&gt; previousSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());
2742 
2743             // secondly we check if we can short-circuit out of here because the new selection
2744             // equals the current selection
2745             final boolean wasSelected = isSelected(row, column);
2746             if (wasSelected &amp;&amp; previousSelection.size() == 1) {
2747                 // before we return, we double-check that the selected item
2748                 // is equal to the item in the given index
2749                 TreeTablePosition&lt;S,?&gt; selectedCell = getSelectedCells().get(0);
2750                 if (getSelectedItem() == getModelItem(row)) {
2751                     if (selectedCell.getRow() == row &amp;&amp; selectedCell.getTableColumn() == column) {
2752                         return;
2753                     }
2754                 }
2755             }
2756 
2757             // RT-32411: We used to call quietClearSelection() here, but this
2758             // resulted in the selectedItems and selectedIndices lists never
2759             // reporting that they were empty.
2760             // makeAtomic toggle added to resolve RT-32618
2761             startAtomic();
2762 
2763             // then clear the current selection
2764             clearSelection();
2765 
2766             // and select the new cell
2767             select(row, column);
2768 
2769             stopAtomic();
2770 
2771             // We remove the new selection from the list seeing as it is not removed.
2772             if (isCellSelectionEnabled) {
2773                 previousSelection.remove(newTablePosition);
2774             } else {
2775                 for (TreeTablePosition&lt;S,?&gt; tp : previousSelection) {
2776                     if (tp.getRow() == row) {
2777                         previousSelection.remove(tp);
2778                         break;
2779                     }
2780                 }
2781             }
2782 
2783             // fire off a single add/remove/replace notification (rather than
2784             // individual remove and add notifications) - see RT-33324
2785             ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; change;
2786 
2787             /*
2788              * getFrom() documentation:
2789              *   If wasAdded is true, the interval contains all the values that were added.
2790              *   If wasPermutated is true, the interval marks the values that were permutated.
2791              *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
2792              *   return the same number - the place where the removed elements were positioned in the list.
2793              */
2794             if (wasSelected) {
2795                 change = ControlUtils.buildClearAndSelectChange(selectedCellsSeq, previousSelection, row);
2796             } else {
2797                 final int changeIndex = isCellSelectionEnabled ? 0 : Math.max(0, selectedCellsSeq.indexOf(newTablePosition));
2798                 final int changeSize = isCellSelectionEnabled ? getSelectedCells().size() : 1;
2799                 change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
2800                         changeIndex, changeIndex + changeSize, previousSelection, selectedCellsSeq);
2801 //                selectedCellsSeq._beginChange();
2802 //                selectedCellsSeq._nextAdd(changeIndex, changeIndex + changeSize);
2803 //                selectedCellsSeq._nextRemove(changeIndex, previousSelection);
2804 //                selectedCellsSeq._endChange();
2805             }
2806 
2807             fireCustomSelectedCellsListChangeEvent(change);
2808         }
2809 
2810         @Override public void select(int row) {
2811             select(row, null);
2812         }
2813 
2814         @Override public void select(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
2815             // TODO we need to bring in the TreeView selection stuff here...
2816             if (row &lt; 0 || row &gt;= getRowCount()) return;
2817 
2818             // if I&#39;m in cell selection mode but the column is null, select each
2819             // of the contained cells individually
2820             if (isCellSelectionEnabled() &amp;&amp; column == null) {
2821                 List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2822                 for (int i = 0; i &lt; columns.size(); i++) {
2823                     select(row, columns.get(i));
2824                 }
2825                 return;
2826             }
2827 
2828             if (TableCellBehavior.hasDefaultAnchor(treeTableView)) {
2829                 TableCellBehavior.removeAnchor(treeTableView);
2830             }
2831 
2832             if (getSelectionMode() == SelectionMode.SINGLE) {
2833                 quietClearSelection();
2834             }
2835             selectedCellsMap.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, (TreeTableColumn&lt;S,?&gt;)column));
2836 
2837             updateSelectedIndex(row);
2838             focus(row, (TreeTableColumn&lt;S, ?&gt;) column);
2839         }
2840 
2841         @Override public void select(TreeItem&lt;S&gt; obj) {
2842             if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
2843                 clearSelection();
2844                 return;
2845             }
2846 
2847             int firstIndex = treeTableView.getRow(obj);
2848             if (firstIndex &gt; -1) {
2849                 if (isSelected(firstIndex)) {
2850                     return;
2851                 }
2852 
2853                 if (getSelectionMode() == SelectionMode.SINGLE) {
2854                     quietClearSelection();
2855                 }
2856 
2857                 select(firstIndex);
2858             } else {
2859                 // if we are here, we did not find the item in the entire data model.
2860                 // Even still, we allow for this item to be set to the give object.
2861                 // We expect that in concrete subclasses of this class we observe the
2862                 // data model such that we check to see if the given item exists in it,
2863                 // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
2864                 setSelectedIndex(-1);
2865                 setSelectedItem(obj);
2866             }
2867         }
2868 
2869         @Override public void selectIndices(int row, int... rows) {
2870             if (rows == null) {
2871                 select(row);
2872                 return;
2873             }
2874 
2875             /*
2876              * Performance optimisation - if multiple selection is disabled, only
2877              * process the end-most row index.
2878              */
2879             int rowCount = getRowCount();
2880 
2881             if (getSelectionMode() == SelectionMode.SINGLE) {
2882                 quietClearSelection();
2883 
2884                 for (int i = rows.length - 1; i &gt;= 0; i--) {
2885                     int index = rows[i];
2886                     if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
2887                         select(index);
2888                         break;
2889                     }
2890                 }
2891 
2892                 if (selectedCellsMap.isEmpty()) {
2893                     if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
2894                         select(row);
2895                     }
2896                 }
2897             } else {
2898                 int lastIndex = -1;
2899                 Set&lt;TreeTablePosition&lt;S,?&gt;&gt; positions = new LinkedHashSet&lt;&gt;();
2900 
2901                 // --- firstly, we special-case the non-varargs &#39;row&#39; argument
2902                 if (row &gt;= 0 &amp;&amp; row &lt; rowCount) {
2903                     // if I&#39;m in cell selection mode, we want to select each
2904                     // of the contained cells individually
2905                     if (isCellSelectionEnabled()) {
2906                         List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2907                         for (int column = 0; column &lt; columns.size(); column++) {
2908                             if (! selectedCellsMap.isSelected(row, column)) {
2909                                 positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, columns.get(column)));
2910                             }
2911                         }
2912                     } else {
2913                         boolean match = selectedCellsMap.isSelected(row, -1);
2914                         if (!match) {
2915                             positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, null));
2916                         }
2917                     }
2918 
2919                     lastIndex = row;
2920                 }
2921 
2922                 // --- now we iterate through all varargs values
2923                 for (int i = 0; i &lt; rows.length; i++) {
2924                     int index = rows[i];
2925                     if (index &lt; 0 || index &gt;= rowCount) continue;
2926                     lastIndex = index;
2927 
2928                     if (isCellSelectionEnabled()) {
2929                         List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
2930                         for (int column = 0; column &lt; columns.size(); column++) {
2931                             if (! selectedCellsMap.isSelected(index, column)) {
2932                                 positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), index, columns.get(column)));
2933                                 lastIndex = index;
2934                             }
2935                         }
2936                     } else {
2937                         if (! selectedCellsMap.isSelected(index, -1)) {
2938                             // if we are here then we have successfully gotten through the for-loop above
2939                             positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), index, null));
2940                         }
2941                     }
2942                 }
2943 
2944                 selectedCellsMap.addAll(positions);
2945 
2946                 if (lastIndex != -1) {
2947                     select(lastIndex);
2948                 }
2949             }
2950         }
2951 
2952         @Override public void selectAll() {
2953             if (getSelectionMode() == SelectionMode.SINGLE) return;
2954 
2955             if (isCellSelectionEnabled()) {
2956                 List&lt;TreeTablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
2957                 TreeTableColumn&lt;S,?&gt; column;
2958                 TreeTablePosition&lt;S,?&gt; tp = null;
2959                 for (int col = 0; col &lt; getTreeTableView().getVisibleLeafColumns().size(); col++) {
2960                     column = getTreeTableView().getVisibleLeafColumns().get(col);
2961                     for (int row = 0; row &lt; getRowCount(); row++) {
2962                         tp = new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column);
2963                         indices.add(tp);
2964                     }
2965                 }
2966                 selectedCellsMap.setAll(indices);
2967 
2968                 if (tp != null) {
2969                     select(tp.getRow(), tp.getTableColumn());
2970                     focus(tp.getRow(), tp.getTableColumn());
2971                 }
2972             } else {
2973                 List&lt;TreeTablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
2974                 for (int i = 0; i &lt; getRowCount(); i++) {
2975                     indices.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), i, null));
2976                 }
2977                 selectedCellsMap.setAll(indices);
2978 
2979                 int focusedIndex = getFocusedIndex();
2980                 if (focusedIndex == -1) {
2981                     final int itemCount = getItemCount();
2982                     if (itemCount &gt; 0) {
2983                         select(itemCount - 1);
2984                         focus(indices.get(indices.size() - 1));
2985                     }
2986                 } else {
2987                     select(focusedIndex);
2988                     focus(focusedIndex);
2989                 }
2990             }
2991         }
2992 
2993         @Override public void selectRange(int minRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; minColumn,
2994                                           int maxRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; maxColumn) {
2995             if (getSelectionMode() == SelectionMode.SINGLE) {
2996                 quietClearSelection();
2997                 select(maxRow, maxColumn);
2998                 return;
2999             }
3000 
3001             startAtomic();
3002 
3003             final int itemCount = getItemCount();
3004             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
3005 
3006             final int minColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)minColumn);
3007             final int maxColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)maxColumn);
3008             final int _minColumnIndex = Math.min(minColumnIndex, maxColumnIndex);
3009             final int _maxColumnIndex = Math.max(minColumnIndex, maxColumnIndex);
3010 
3011             final int _minRow = Math.min(minRow, maxRow);
3012             final int _maxRow = Math.max(minRow, maxRow);
3013 
3014             List&lt;TreeTablePosition&lt;S,?&gt;&gt; cellsToSelect = new ArrayList&lt;&gt;();
3015 
3016             for (int _row = _minRow; _row &lt;= _maxRow; _row++) {
3017                 // begin copy/paste of select(int, column) method (with some
3018                 // slight modifications)
3019                 if (_row &lt; 0 || _row &gt;= itemCount) continue;
3020 
3021                 if (! isCellSelectionEnabled) {
3022                     cellsToSelect.add(new TreeTablePosition&lt;&gt;(treeTableView, _row, (TreeTableColumn&lt;S,?&gt;)minColumn));
3023                 } else {
3024                     for (int _col = _minColumnIndex; _col &lt;= _maxColumnIndex; _col++) {
3025                         final TreeTableColumn&lt;S, ?&gt; column = treeTableView.getVisibleLeafColumn(_col);
3026 
3027                         // if I&#39;m in cell selection mode but the column is null, I don&#39;t want
3028                         // to select the whole row instead...
3029                         if (column == null &amp;&amp; isCellSelectionEnabled) continue;
3030 
3031                         cellsToSelect.add(new TreeTablePosition&lt;&gt;(treeTableView, _row, column));
3032                         // end copy/paste
3033                     }
3034                 }
3035             }
3036 
3037             // to prevent duplication we remove all currently selected cells from
3038             // our list of cells to select.
3039             cellsToSelect.removeAll(getSelectedCells());
3040 
3041             selectedCellsMap.addAll(cellsToSelect);
3042             stopAtomic();
3043 
3044             // fire off events
3045             // Note that focus and selection always goes to maxRow, not _maxRow.
3046             updateSelectedIndex(maxRow);
3047             focus(maxRow, (TreeTableColumn&lt;S,?&gt;)maxColumn);
3048 
3049             final TreeTableColumn&lt;S,?&gt; startColumn = (TreeTableColumn&lt;S,?&gt;)minColumn;
3050             final TreeTableColumn&lt;S,?&gt; endColumn = isCellSelectionEnabled ? (TreeTableColumn&lt;S,?&gt;)maxColumn : startColumn;
3051             final int startChangeIndex = selectedCellsMap.indexOf(new TreeTablePosition&lt;&gt;(treeTableView, minRow, startColumn));
3052             final int endChangeIndex = selectedCellsMap.indexOf(new TreeTablePosition&lt;&gt;(treeTableView, maxRow, endColumn));
3053 
3054             if (startChangeIndex &gt; -1 &amp;&amp; endChangeIndex &gt; -1) {
3055                 final int startIndex = Math.min(startChangeIndex, endChangeIndex);
3056                 final int endIndex = Math.max(startChangeIndex, endChangeIndex);
3057 
3058                 ListChangeListener.Change c = new NonIterableChange.SimpleAddChange&lt;&gt;(startIndex, endIndex + 1, selectedCellsSeq);
3059                 fireCustomSelectedCellsListChangeEvent(c);
3060 //                selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextAdd(startIndex, endIndex + 1));
3061             }
3062         }
3063 
3064         @Override public void clearSelection(int index) {
3065             clearSelection(index, null);
3066         }
3067 
3068         @Override
3069         public void clearSelection(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
3070             clearSelection(new TreeTablePosition&lt;S,Object&gt;(getTreeTableView(), row, (TreeTableColumn)column));
3071         }
3072 
3073         private void clearSelection(TreeTablePosition&lt;S,?&gt; tp) {
3074             final boolean csMode = isCellSelectionEnabled();
3075             final int row = tp.getRow();
3076             final boolean columnIsNull = tp.getTableColumn() == null;
3077 
3078             List&lt;TreeTablePosition&gt; toRemove = new ArrayList&lt;&gt;();
3079             for (TreeTablePosition pos : getSelectedCells()) {
3080                 if (!csMode) {
3081                     if (pos.getRow() == row) {
3082                         toRemove.add(pos);
3083                         break;
3084                     }
3085                 } else {
3086                     if (columnIsNull &amp;&amp; pos.getRow() == row) {
3087                         // if we are in cell selection mode and the column is null,
3088                         // we remove all items in the row
3089                         toRemove.add(pos);
3090                     } else if (pos.equals(tp)) {
3091                         toRemove.add(tp);
3092                         break;
3093                     }
3094                 }
3095             }
3096             toRemove.stream().forEach(selectedCellsMap::remove);
3097 
3098             if (isEmpty() &amp;&amp; ! isAtomic()) {
3099                 updateSelectedIndex(-1);
3100                 selectedCellsMap.clear();
3101             }
3102         }
3103 
3104         @Override public void clearSelection() {
3105             final List&lt;TreeTablePosition&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;((Collection)getSelectedCells());
3106 
3107             quietClearSelection();
3108 
3109             if (! isAtomic()) {
3110                 updateSelectedIndex(-1);
3111                 focus(-1);
3112 
3113                 if (!removed.isEmpty()) {
3114 //                    selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextRemove(0, removed));
3115                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange&lt;TreeTablePosition&lt;S, ?&gt;&gt;(0, 0, selectedCellsSeq) {
3116                         @Override public List&lt;TreeTablePosition&lt;S, ?&gt;&gt; getRemoved() {
3117                             return removed;
3118                         }
3119                     };
3120                     fireCustomSelectedCellsListChangeEvent(c);
3121                 }
3122             }
3123         }
3124 
3125         private void quietClearSelection() {
3126             startAtomic();
3127             selectedCellsMap.clear();
3128             stopAtomic();
3129         }
3130 
3131         @Override public boolean isSelected(int index) {
3132             return isSelected(index, null);
3133         }
3134 
3135         @Override public boolean isSelected(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
3136             // When in cell selection mode, if the column is null, then we interpret
3137             // the users query to be asking if _all_ of the cells in the row are selected,
3138             // rather than if _any_ of the cells in the row are selected.
3139             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
3140             if (isCellSelectionEnabled &amp;&amp; column == null) {
3141                 int columnCount = treeTableView.getVisibleLeafColumns().size();
3142                 for (int col = 0; col &lt; columnCount; col++) {
3143                     if (!selectedCellsMap.isSelected(row, col)) {
3144                         return false;
3145                     }
3146                 }
3147                 return true;
3148             } else {
3149                 int columnIndex = !isCellSelectionEnabled || column == null ? -1 : treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S, ?&gt;) column);
3150                 return selectedCellsMap.isSelected(row, columnIndex);
3151             }
3152         }
3153 
3154         @Override public boolean isEmpty() {
3155             return selectedCellsMap.isEmpty();
3156         }
3157 
3158         @Override public void selectPrevious() {
3159             if (isCellSelectionEnabled()) {
3160                 // in cell selection mode, we have to wrap around, going from
3161                 // right-to-left, and then wrapping to the end of the previous line
3162                 TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3163                 if (pos.getColumn() - 1 &gt;= 0) {
3164                     // go to previous row
3165                     select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
3166                 } else if (pos.getRow() &lt; getRowCount() - 1) {
3167                     // wrap to end of previous row
3168                     select(pos.getRow() - 1, getTableColumn(getTreeTableView().getVisibleLeafColumns().size() - 1));
3169                 }
3170             } else {
3171                 int focusIndex = getFocusedIndex();
3172                 if (focusIndex == -1) {
3173                     select(getRowCount() - 1);
3174                 } else if (focusIndex &gt; 0) {
3175                     select(focusIndex - 1);
3176                 }
3177             }
3178         }
3179 
3180         @Override public void selectNext() {
3181             if (isCellSelectionEnabled()) {
3182                 // in cell selection mode, we have to wrap around, going from
3183                 // left-to-right, and then wrapping to the start of the next line
3184                 TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3185                 if (pos.getColumn() + 1 &lt; getTreeTableView().getVisibleLeafColumns().size()) {
3186                     // go to next column
3187                     select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
3188                 } else if (pos.getRow() &lt; getRowCount() - 1) {
3189                     // wrap to start of next row
3190                     select(pos.getRow() + 1, getTableColumn(0));
3191                 }
3192             } else {
3193                 int focusIndex = getFocusedIndex();
3194                 if (focusIndex == -1) {
3195                     select(0);
3196                 } else if (focusIndex &lt; getRowCount() -1) {
3197                     select(focusIndex + 1);
3198                 }
3199             }
3200         }
3201 
3202         @Override public void selectAboveCell() {
3203             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3204             if (pos.getRow() == -1) {
3205                 select(getRowCount() - 1);
3206             } else if (pos.getRow() &gt; 0) {
3207                 select(pos.getRow() - 1, pos.getTableColumn());
3208             }
3209         }
3210 
3211         @Override public void selectBelowCell() {
3212             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3213 
3214             if (pos.getRow() == -1) {
3215                 select(0);
3216             } else if (pos.getRow() &lt; getRowCount() -1) {
3217                 select(pos.getRow() + 1, pos.getTableColumn());
3218             }
3219         }
3220 
3221         @Override public void selectFirst() {
3222             TreeTablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
3223 
3224             if (getSelectionMode() == SelectionMode.SINGLE) {
3225                 quietClearSelection();
3226             }
3227 
3228             if (getRowCount() &gt; 0) {
3229                 if (isCellSelectionEnabled()) {
3230                     select(0, focusedCell.getTableColumn());
3231                 } else {
3232                     select(0);
3233                 }
3234             }
3235         }
3236 
3237         @Override public void selectLast() {
3238             TreeTablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
3239 
3240             if (getSelectionMode() == SelectionMode.SINGLE) {
3241                 quietClearSelection();
3242             }
3243 
3244             int numItems = getRowCount();
3245             if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
3246                 if (isCellSelectionEnabled()) {
3247                     select(numItems - 1, focusedCell.getTableColumn());
3248                 } else {
3249                     select(numItems - 1);
3250                 }
3251             }
3252         }
3253 
3254         @Override public void selectLeftCell() {
3255             if (! isCellSelectionEnabled()) return;
3256 
3257             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3258             if (pos.getColumn() - 1 &gt;= 0) {
3259                 select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
3260             }
3261         }
3262 
3263         @Override public void selectRightCell() {
3264             if (! isCellSelectionEnabled()) return;
3265 
3266             TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
3267             if (pos.getColumn() + 1 &lt; getTreeTableView().getVisibleLeafColumns().size()) {
3268                 select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
3269             }
3270         }
3271 
3272 
3273 
3274         /***********************************************************************
3275          *                                                                     *
3276          * Support code                                                        *
3277          *                                                                     *
3278          **********************************************************************/
3279 
3280         private void updateDefaultSelection() {
3281             // when the items list totally changes, we should clear out
3282             // the selection
3283             int newSelectionIndex = -1;
3284             TreeItem&lt;S&gt; selectedItem = getSelectedItem();
3285             if (selectedItem != null) {
3286                 newSelectionIndex = treeTableView.getRow(selectedItem);
3287             }
3288 
3289             // we put focus onto the first item, if there is at least
3290             // one item in the list
3291             int newFocusIndex = newSelectionIndex != -1 ? newSelectionIndex : treeTableView.getExpandedItemCount() &gt; 0 ? 0 : -1;
3292 
3293             clearSelection();
3294             select(newSelectionIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
3295             focus(newFocusIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
3296         }
3297 
3298         private TreeTableColumn&lt;S,?&gt; getTableColumn(int pos) {
3299             return getTreeTableView().getVisibleLeafColumn(pos);
3300         }
3301 
3302         // Gets a table column to the left or right of the current one, given an offset
3303         private TreeTableColumn&lt;S,?&gt; getTableColumn(TreeTableColumn&lt;S,?&gt; column, int offset) {
3304             int columnIndex = getTreeTableView().getVisibleLeafIndex(column);
3305             int newColumnIndex = columnIndex + offset;
3306             return getTreeTableView().getVisibleLeafColumn(newColumnIndex);
3307         }
3308 
3309         private void updateSelectedIndex(int row) {
3310             setSelectedIndex(row);
3311             setSelectedItem(getModelItem(row));
3312         }
3313 
3314         @Override public void focus(int row) {
3315             focus(row, null);
3316         }
3317 
3318         private void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
3319             focus(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column));
3320         }
3321 
3322         private void focus(TreeTablePosition&lt;S,?&gt; pos) {
3323             if (getTreeTableView().getFocusModel() == null) return;
3324 
3325             getTreeTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
3326             getTreeTableView().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
3327         }
3328 
3329         @Override public int getFocusedIndex() {
3330             return getFocusedCell().getRow();
3331         }
3332 
3333         private TreeTablePosition&lt;S,?&gt; getFocusedCell() {
3334             if (treeTableView.getFocusModel() == null) {
3335                 return new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
3336             }
3337             return treeTableView.getFocusModel().getFocusedCell();
3338         }
3339 
3340         private int getRowCount() {
3341             return treeTableView.getExpandedItemCount();
3342         }
3343 
3344         private void fireCustomSelectedCellsListChangeEvent(ListChangeListener.Change&lt;? extends TreeTablePosition&lt;S,?&gt;&gt; c) {
3345             ControlUtils.updateSelectedIndices(this, c);
3346 
3347             if (isAtomic()) {
3348                 return;
3349             }
3350 
3351             selectedCellsSeq.callObservers(new MappingChange&lt;&gt;(c, MappingChange.NOOP_MAP, selectedCellsSeq));
3352         }
3353     }
3354 
3355 
3356 
3357 
3358     /**
3359      * A {@link FocusModel} with additional functionality to support the requirements
3360      * of a TableView control.
3361      *
3362      * @see TableView
3363      * @since JavaFX 8.0
3364      */
3365     public static class TreeTableViewFocusModel&lt;S&gt; extends TableFocusModel&lt;TreeItem&lt;S&gt;, TreeTableColumn&lt;S,?&gt;&gt; {
3366 
3367         private final TreeTableView&lt;S&gt; treeTableView;
3368 
3369         private final TreeTablePosition EMPTY_CELL;
3370 
3371         /**
3372          * Creates a default TableViewFocusModel instance that will be used to
3373          * manage focus of the provided TableView control.
3374          *
3375          * @param treeTableView The tableView upon which this focus model operates.
3376          * @throws NullPointerException The TableView argument can not be null.
3377          */
3378         public TreeTableViewFocusModel(final TreeTableView&lt;S&gt; treeTableView) {
3379             if (treeTableView == null) {
3380                 throw new NullPointerException(&quot;TableView can not be null&quot;);
3381             }
3382 
3383             this.treeTableView = treeTableView;
3384             this.EMPTY_CELL = new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
3385 
3386             this.treeTableView.rootProperty().addListener(weakRootPropertyListener);
3387             updateTreeEventListener(null, treeTableView.getRoot());
3388 
3389             int focusRow = getItemCount() &gt; 0 ? 0 : -1;
3390             TreeTablePosition&lt;S,?&gt; pos = new TreeTablePosition&lt;&gt;(treeTableView, focusRow, null);
3391             setFocusedCell(pos);
3392 
3393             showRootListener = obs -&gt; {
3394                 if (isFocused(0)) {
3395                     focus(-1);
3396                     focus(0);
3397                 }
3398             };
3399             treeTableView.showRootProperty().addListener(new WeakInvalidationListener(showRootListener));
3400 
3401             focusedCellProperty().addListener(o -&gt; {
3402                 treeTableView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
3403             });
3404         }
3405 
3406         private final ChangeListener&lt;TreeItem&lt;S&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
3407             updateTreeEventListener(oldValue, newValue);
3408         };
3409 
3410         private final WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
3411                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
3412 
3413         private final InvalidationListener showRootListener;
3414 
3415         private void updateTreeEventListener(TreeItem&lt;S&gt; oldRoot, TreeItem&lt;S&gt; newRoot) {
3416             if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
3417                 oldRoot.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
3418             }
3419 
3420             if (newRoot != null) {
3421                 weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
3422                 newRoot.addEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
3423             }
3424         }
3425 
3426         private EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; treeItemListener = new EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt;() {
3427             @Override public void handle(TreeItem.TreeModificationEvent&lt;S&gt; e) {
3428                 // don&#39;t shift focus if the event occurred on a tree item after
3429                 // the focused row, or if there is no focus index at present
3430                 if (getFocusedIndex() == -1) return;
3431 
3432                 int shift = 0;
3433                 if (e.getChange() != null) {
3434                     e.getChange().next();
3435                 }
3436 
3437                 do {
3438                     int row = treeTableView.getRow(e.getTreeItem());
3439 
3440                     if (e.wasExpanded()) {
3441                         if (row &lt; getFocusedIndex()) {
3442                             // need to shuffle selection by the number of visible children
3443                             shift += e.getTreeItem().getExpandedDescendentCount(false) - 1;
3444                         }
3445                     } else if (e.wasCollapsed()) {
3446                         if (row &lt; getFocusedIndex()) {
3447                             // need to shuffle selection by the number of visible children
3448                             // that were just hidden
3449                             shift += -e.getTreeItem().previousExpandedDescendentCount + 1;
3450                         }
3451                     } else if (e.wasAdded()) {
3452                         // get the TreeItem the event occurred on - we only need to
3453                         // shift if the tree item is expanded
3454                         TreeItem&lt;S&gt; eventTreeItem = e.getTreeItem();
3455                         if (eventTreeItem.isExpanded()) {
3456                             for (int i = 0; i &lt; e.getAddedChildren().size(); i++) {
3457                                 // get the added item and determine the row it is in
3458                                 TreeItem&lt;S&gt; item = e.getAddedChildren().get(i);
3459                                 row = treeTableView.getRow(item);
3460 
3461                                 if (item != null &amp;&amp; row &lt;= (shift+getFocusedIndex())) {
3462                                     shift += item.getExpandedDescendentCount(false);
3463                                 }
3464                             }
3465                         }
3466                     } else if (e.wasRemoved()) {
3467                         row += e.getFrom() + 1;
3468 
3469                         for (int i = 0; i &lt; e.getRemovedChildren().size(); i++) {
3470                             TreeItem&lt;S&gt; item = e.getRemovedChildren().get(i);
3471                             if (item != null &amp;&amp; item.equals(getFocusedItem())) {
3472                                 focus(Math.max(0, getFocusedIndex() - 1));
3473                                 return;
3474                             }
3475                         }
3476 
3477                         if (row &lt;= getFocusedIndex()) {
3478                             // shuffle selection by the number of removed items
3479                             shift += e.getTreeItem().isExpanded() ? -e.getRemovedSize() : 0;
3480                         }
3481                     }
3482                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
3483 
3484                 if (shift != 0) {
3485                     TreeTablePosition&lt;S, ?&gt; focusedCell = getFocusedCell();
3486                     final int newFocus = focusedCell.getRow() + shift;
3487                     if (newFocus &gt;= 0) {
3488                         Platform.runLater(() -&gt; focus(newFocus, focusedCell.getTableColumn()));
3489                     }
3490                 }
3491             }
3492         };
3493 
3494         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
3495 
3496         /** {@inheritDoc} */
3497         @Override protected int getItemCount() {
3498 //            if (tableView.getItems() == null) return -1;
3499 //            return tableView.getItems().size();
3500             return treeTableView.getExpandedItemCount();
3501         }
3502 
3503         /** {@inheritDoc} */
3504         @Override protected TreeItem&lt;S&gt; getModelItem(int index) {
3505             if (index &lt; 0 || index &gt;= getItemCount()) return null;
3506             return treeTableView.getTreeItem(index);
3507         }
3508 
3509         /**
3510          * The position of the current item in the TableView which has the focus.
3511          */
3512         private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCell;
3513         public final ReadOnlyObjectProperty&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCellProperty() {
3514             return focusedCellPropertyImpl().getReadOnlyProperty();
3515         }
3516         private void setFocusedCell(TreeTablePosition&lt;S,?&gt; value) { focusedCellPropertyImpl().set(value);  }
3517         public final TreeTablePosition&lt;S,?&gt; getFocusedCell() { return focusedCell == null ? EMPTY_CELL : focusedCell.get(); }
3518 
3519         private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCellPropertyImpl() {
3520             if (focusedCell == null) {
3521                 focusedCell = new ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt;(EMPTY_CELL) {
3522                     private TreeTablePosition&lt;S,?&gt; old;
3523                     @Override protected void invalidated() {
3524                         if (get() == null) return;
3525 
3526                         if (old == null || !old.equals(get())) {
3527                             setFocusedIndex(get().getRow());
3528                             setFocusedItem(getModelItem(getValue().getRow()));
3529 
3530                             old = get();
3531                         }
3532                     }
3533 
3534                     @Override
3535                     public Object getBean() {
3536                         return TreeTableView.TreeTableViewFocusModel.this;
3537                     }
3538 
3539                     @Override
3540                     public String getName() {
3541                         return &quot;focusedCell&quot;;
3542                     }
3543                 };
3544             }
3545             return focusedCell;
3546         }
3547 
3548 
3549         /**
3550          * Causes the item at the given index to receive the focus.
3551          *
3552          * @param row The row index of the item to give focus to.
3553          * @param column The column of the item to give focus to. Can be null.
3554          */
3555         @Override public void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
3556             if (row &lt; 0 || row &gt;= getItemCount()) {
3557                 setFocusedCell(EMPTY_CELL);
3558             } else {
3559                 TreeTablePosition&lt;S,?&gt; oldFocusCell = getFocusedCell();
3560                 TreeTablePosition&lt;S,?&gt; newFocusCell = new TreeTablePosition&lt;&gt;(treeTableView, row, column);
3561                 setFocusedCell(newFocusCell);
3562 
3563                 if (newFocusCell.equals(oldFocusCell)) {
3564                     // manually update the focus properties to ensure consistency
3565                     setFocusedIndex(row);
3566                     setFocusedItem(getModelItem(row));
3567                 }
3568             }
3569         }
3570 
3571         /**
3572          * Convenience method for setting focus on a particular row or cell
3573          * using a {@link TablePosition}.
3574          *
3575          * @param pos The table position where focus should be set.
3576          */
3577         public void focus(TreeTablePosition&lt;S,?&gt; pos) {
3578             if (pos == null) return;
3579             focus(pos.getRow(), pos.getTableColumn());
3580         }
3581 
3582 
3583         /***********************************************************************
3584          *                                                                     *
3585          * Public API                                                          *
3586          *                                                                     *
3587          **********************************************************************/
3588 
3589         /**
3590          * Tests whether the row / cell at the given location currently has the
3591          * focus within the TableView.
3592          */
3593         @Override public boolean isFocused(int row, TreeTableColumn&lt;S,?&gt; column) {
3594             if (row &lt; 0 || row &gt;= getItemCount()) return false;
3595 
3596             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3597             boolean columnMatch = column == null || column.equals(cell.getTableColumn());
3598 
3599             return cell.getRow() == row &amp;&amp; columnMatch;
3600         }
3601 
3602         /**
3603          * Causes the item at the given index to receive the focus. This does not
3604          * cause the current selection to change. Updates the focusedItem and
3605          * focusedIndex properties such that &lt;code&gt;focusedIndex = -1&lt;/code&gt; unless
3606          * &lt;pre&gt;&lt;code&gt;0 &amp;lt;= index &amp;lt; model size&lt;/code&gt;&lt;/pre&gt;.
3607          *
3608          * @param index The index of the item to get focus.
3609          */
3610         @Override public void focus(int index) {
3611             if (treeTableView.expandedItemCountDirty) {
3612                 treeTableView.updateExpandedItemCount(treeTableView.getRoot());
3613             }
3614 
3615             if (index &lt; 0 || index &gt;= getItemCount()) {
3616                 setFocusedCell(EMPTY_CELL);
3617             } else {
3618                 setFocusedCell(new TreeTablePosition&lt;&gt;(treeTableView, index, null));
3619             }
3620         }
3621 
3622         /**
3623          * Attempts to move focus to the cell above the currently focused cell.
3624          */
3625         @Override public void focusAboveCell() {
3626             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3627 
3628             if (getFocusedIndex() == -1) {
3629                 focus(getItemCount() - 1, cell.getTableColumn());
3630             } else if (getFocusedIndex() &gt; 0) {
3631                 focus(getFocusedIndex() - 1, cell.getTableColumn());
3632             }
3633         }
3634 
3635         /**
3636          * Attempts to move focus to the cell below the currently focused cell.
3637          */
3638         @Override public void focusBelowCell() {
3639             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3640             if (getFocusedIndex() == -1) {
3641                 focus(0, cell.getTableColumn());
3642             } else if (getFocusedIndex() != getItemCount() -1) {
3643                 focus(getFocusedIndex() + 1, cell.getTableColumn());
3644             }
3645         }
3646 
3647         /**
3648          * Attempts to move focus to the cell to the left of the currently focused cell.
3649          */
3650         @Override public void focusLeftCell() {
3651             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3652             if (cell.getColumn() &lt;= 0) return;
3653             focus(cell.getRow(), getTableColumn(cell.getTableColumn(), -1));
3654         }
3655 
3656         /**
3657          * Attempts to move focus to the cell to the right of the the currently focused cell.
3658          */
3659         @Override public void focusRightCell() {
3660             TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
3661             if (cell.getColumn() == getColumnCount() - 1) return;
3662             focus(cell.getRow(), getTableColumn(cell.getTableColumn(), 1));
3663         }
3664 
3665         /** {@inheritDoc} */
3666         @Override public void focusPrevious() {
3667             if (getFocusedIndex() == -1) {
3668                 focus(0);
3669             } else if (getFocusedIndex() &gt; 0) {
3670                 focusAboveCell();
3671             }
3672         }
3673 
3674         /** {@inheritDoc} */
3675         @Override public void focusNext() {
3676             if (getFocusedIndex() == -1) {
3677                 focus(0);
3678             } else if (getFocusedIndex() != getItemCount() -1) {
3679                 focusBelowCell();
3680             }
3681         }
3682 
3683 
3684 
3685          /***********************************************************************
3686          *                                                                     *
3687          * Private Implementation                                              *
3688          *                                                                     *
3689          **********************************************************************/
3690 
3691         private int getColumnCount() {
3692             return treeTableView.getVisibleLeafColumns().size();
3693         }
3694 
3695         // Gets a table column to the left or right of the current one, given an offset
3696         private TreeTableColumn&lt;S,?&gt; getTableColumn(TreeTableColumn&lt;S,?&gt; column, int offset) {
3697             int columnIndex = treeTableView.getVisibleLeafIndex(column);
3698             int newColumnIndex = columnIndex + offset;
3699             return treeTableView.getVisibleLeafColumn(newColumnIndex);
3700         }
3701     }
3702 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
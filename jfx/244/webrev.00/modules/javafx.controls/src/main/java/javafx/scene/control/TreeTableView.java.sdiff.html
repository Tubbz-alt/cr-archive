<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TreeTablePosition.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/java/test/javafx/scene/control/TreeTableViewTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1787      * @param column the column
1788      * @return the position of the given column, relative to all other
1789      * visible leaf columns
1790      */
1791     public int getVisibleLeafIndex(TreeTableColumn&lt;S,?&gt; column) {
1792         return getVisibleLeafColumns().indexOf(column);
1793     }
1794 
1795     /**
1796      * Returns the TreeTableColumn in the given column index, relative to all other
1797      * visible leaf columns.
1798      * @param column the column
1799      * @return the TreeTableColumn in the given column index, relative to all other
1800      * visible leaf columns
1801      */
1802     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1803         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1804         return visibleLeafColumns.get(column);
1805     }
1806 





1807     /**
1808      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1809      * often than not it is not necessary to call this method directly, as it is
1810      * automatically called when the {@link #getSortOrder() sort order},
1811      * {@link #sortPolicyProperty() sort policy}, or the state of the
1812      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1813      * change. In other words, this method should only be called directly when
1814      * something external changes and a sort is required.
1815      */
1816     public void sort() {

1817         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1818 
1819         // update the Comparator property
1820         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1821         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1822 
1823         // fire the onSort event and check if it is consumed, if
1824         // so, don&#39;t run the sort
1825         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
1826         fireEvent(sortEvent);
1827         if (sortEvent.isConsumed()) {
1828             // if the sort is consumed we could back out the last action (the code
1829             // is commented out right below), but we don&#39;t as we take it as a
1830             // sign that the developer has decided to handle the event themselves.
1831 
1832             // sortLock = true;
1833             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1834             // sortLock = false;

1835             return;
1836         }
1837 
1838         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1839         final int itemCount = prevState.size();
1840 
1841         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1842         // sort events - instead we send a single permutation event at the end
1843         // of this method.
1844         getSelectionModel().startAtomic();
1845 
1846         // get the sort policy and run it
1847         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
1848         if (sortPolicy == null) return;
1849         Boolean success = sortPolicy.call(this);
1850 
1851         getSelectionModel().stopAtomic();
1852 
1853         if (success == null || ! success) {
1854             // the sort was a failure. Need to backout if possible
1855             sortLock = true;
1856             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1857             setComparator(oldComparator);
1858             sortLock = false;
1859         } else {
1860             // sorting was a success, now we possibly fire an event on the
1861             // selection model that the items list has &#39;permutated&#39; to a new ordering
1862 
1863             // FIXME we should support alternative selection model implementations!
1864             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1865                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1866                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1867 
1868                 List&lt;TreeTablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
1869                 for (int i = 0; i &lt; itemCount; i++) {
1870                     TreeTablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
1871                     if (!newState.contains(prevItem)) {
1872                         removed.add(prevItem);
1873                     }
1874                 }
<span class="line-removed">1875 </span>
1876                 if (!removed.isEmpty()) {
1877                     // the sort operation effectively permutates the selectedCells list,
1878                     // but we cannot fire a permutation event as we are talking about
1879                     // TreeTablePosition&#39;s changing (which may reside in the same list
1880                     // position before and after the sort). Therefore, we need to fire
1881                     // a single add/remove event to cover the added and removed positions.
1882                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
1883                     sm.fireCustomSelectedCellsListChangeEvent(c);
1884                 }
1885             }


1886         }

1887     }
1888 
1889     /**
1890      * Calling {@code refresh()} forces the TreeTableView control to recreate and
1891      * repopulate the cells necessary to populate the visual bounds of the control.
1892      * In other words, this forces the TreeTableView to update what it is showing to
1893      * the user. This is useful in cases where the underlying data source has
1894      * changed in a way that is not observed by the TreeTableView itself.
1895      *
1896      * @since JavaFX 8u60
1897      */
1898     public void refresh() {
1899         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1900     }
1901 
1902 
1903 
1904     /***************************************************************************
1905      *                                                                         *
1906      * Private Implementation                                                  *
</pre>
<hr />
<pre>
2523 
2524                         ControlUtils.reducingChange(selectedIndices, removed);
2525 
2526                         for (int index : removed) {
2527                             startAtomic();
2528                             // we pass in false here to prevent a lookup into the TreeItem, as it is unnecessary
2529                             // and results in JDK-8152396
2530                             clearSelection(new TreeTablePosition&lt;&gt;(treeTableView, index, null, false));
2531                             stopAtomic();
2532                         }
2533                         selectedIndices._endChange();
2534 
2535                         // put selection onto the newly-collapsed tree item
2536                         if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
2537                             select(startRow, selectedColumn);
2538                         }
2539 
2540                         shift += -count + 1;
2541                         startRow++;
2542                     } else if (e.wasPermutated()) {
<span class="line-modified">2543                         // General approach:</span>
<span class="line-modified">2544                         //   -- detected a sort has happened</span>
<span class="line-modified">2545                         //   -- Create a permutation lookup map (1)</span>
<span class="line-modified">2546                         //   -- dump all the selected indices into a list (2)</span>
<span class="line-modified">2547                         //   -- create a list containing the new indices (3)</span>
<span class="line-modified">2548                         //   -- for each previously-selected index (4)</span>
<span class="line-modified">2549                         //     -- if index is in the permutation lookup map</span>
<span class="line-modified">2550                         //       -- add the new index to the new indices list</span>
<span class="line-modified">2551                         //   -- Perform batch selection (5)</span>
<span class="line-modified">2552 </span>
<span class="line-modified">2553                         startAtomic();</span>
<span class="line-removed">2554 </span>
<span class="line-removed">2555                         final int offset = startRow + 1;</span>
<span class="line-removed">2556 </span>
<span class="line-removed">2557                         // (1)</span>
<span class="line-removed">2558                         int length = e.getTo() - e.getFrom();</span>
<span class="line-removed">2559                         HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;&gt; (length);</span>
<span class="line-removed">2560                         for (int i = e.getFrom(); i &lt; e.getTo(); i++) {</span>
<span class="line-removed">2561                             pMap.put(i, e.getChange().getPermutation(i));</span>
<span class="line-removed">2562                         }</span>
2563 
<span class="line-removed">2564                         // (2)</span>
<span class="line-removed">2565                         List&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedIndices = new ArrayList&lt;&gt;(getSelectedCells());</span>
<span class="line-removed">2566 </span>
<span class="line-removed">2567                         // (3)</span>
<span class="line-removed">2568                         List&lt;TreeTablePosition&lt;S,?&gt;&gt; newIndices = new ArrayList&lt;&gt;(selectedIndices.size());</span>
<span class="line-removed">2569 </span>
<span class="line-removed">2570                         // (4)</span>
2571                         boolean selectionIndicesChanged = false;
<span class="line-modified">2572                         for (int i = 0; i &lt; selectedIndices.size(); i++) {</span>
<span class="line-modified">2573                             final TreeTablePosition&lt;S,?&gt; oldIndex = selectedIndices.get(i);</span>
<span class="line-modified">2574                             final int oldRow = oldIndex.getRow() - offset;</span>
<span class="line-modified">2575 </span>
<span class="line-removed">2576                             if (pMap.containsKey(oldRow)) {</span>
<span class="line-removed">2577                                 int newIndex = pMap.get(oldRow) + offset;</span>
<span class="line-removed">2578 </span>
<span class="line-removed">2579                                 selectionIndicesChanged = selectionIndicesChanged || newIndex != oldRow;</span>
<span class="line-removed">2580 </span>
<span class="line-removed">2581                                 newIndices.add(new TreeTablePosition&lt;&gt;(oldIndex.getTreeTableView(), newIndex, oldIndex.getTableColumn()));</span>
<span class="line-removed">2582                             }</span>
<span class="line-removed">2583 </span>
<span class="line-removed">2584                             // check if the root element of this event was selected, so that we can retain it</span>
<span class="line-removed">2585                             if (oldIndex.getRow() == startRow) {</span>
<span class="line-removed">2586                                 newIndices.add(new TreeTablePosition&lt;&gt;(oldIndex.getTreeTableView(), oldIndex.getRow(), oldIndex.getTableColumn()));</span>
2587                             }

2588                         }
<span class="line-removed">2589 </span>
2590                         if (selectionIndicesChanged) {
<span class="line-modified">2591                             // (5)</span>
<span class="line-modified">2592                             quietClearSelection();</span>
<span class="line-modified">2593                             stopAtomic();</span>
<span class="line-modified">2594 </span>
<span class="line-modified">2595                             selectedCellsMap.setAll(newIndices);</span>
<span class="line-modified">2596 </span>
<span class="line-modified">2597                             final int offsetOldIndex = oldSelectedIndex - offset;</span>
<span class="line-modified">2598                             if (offsetOldIndex &gt;= 0 &amp;&amp; offsetOldIndex &lt; getItemCount()) {</span>
<span class="line-modified">2599                                 int newIndex = e.getChange().getPermutation(offsetOldIndex);</span>
<span class="line-modified">2600                                 setSelectedIndex(newIndex + offset);</span>
<span class="line-modified">2601                                 focus(newIndex + offset);</span>


2602                             }
<span class="line-removed">2603                         } else {</span>
<span class="line-removed">2604                             stopAtomic();</span>
2605                         }
2606                     } else if (e.wasAdded()) {
2607                         // shuffle selection by the number of added items
2608                         shift += treeItem.isExpanded() ? addedSize : 0;
2609 
2610                         // RT-32963: We were taking the startRow from the TreeItem
2611                         // in which the children were added, rather than from the
2612                         // actual position of the new child. This led to selection
2613                         // being moved off the parent TreeItem by mistake.
2614                         // The &#39;if (e.getAddedSize() == 1)&#39; condition here was
2615                         // subsequently commented out due to RT-33894.
2616                         startRow = treeTableView.getRow(e.getChange().getAddedSubList().get(0));
2617 
2618                         TreeTablePosition&lt;S, ?&gt; anchor = TreeTableCellBehavior.getAnchor(treeTableView, null);
2619                         if (anchor != null) {
2620                             boolean isAnchorSelected = isSelected(anchor.getRow(), anchor.getTableColumn());
2621                             if (isAnchorSelected) {
2622                                 TreeTablePosition&lt;S, ?&gt; newAnchor = new TreeTablePosition&lt;&gt;(treeTableView, anchor.getRow() + shift, anchor.getTableColumn());
2623                                 TreeTableCellBehavior.setAnchor(treeTableView, newAnchor, false);
2624                             }
</pre>
<hr />
<pre>
2646                             int index = selectedIndices.get(i);
2647                             if (index &gt; selectedItems.size()) break;
2648 
2649                             if (removedChildren.size() == 1 &amp;&amp;
2650                                     selectedItems.size() == 1 &amp;&amp;
2651                                     selectedItem != null &amp;&amp;
2652                                     selectedItem.equals(removedChildren.get(0))) {
2653                                 // Bug fix for RT-28637
2654                                 if (oldSelectedIndex &lt; getItemCount()) {
2655                                     final int previousRow = oldSelectedIndex == 0 ? 0 : oldSelectedIndex - 1;
2656                                     TreeItem&lt;S&gt; newSelectedItem = getModelItem(previousRow);
2657                                     if (!selectedItem.equals(newSelectedItem)) {
2658                                         clearAndSelect(previousRow);
2659                                     }
2660                                 }
2661                             }
2662                         }
2663                     }
2664                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
2665 
<span class="line-modified">2666                 shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {</span>
<span class="line-modified">2667                     @Override public Void call(ShiftParams param) {</span>
<span class="line-modified">2668 </span>
<span class="line-modified">2669                         // we make the shifts atomic, as otherwise listeners to</span>
<span class="line-modified">2670                         // the items / indices lists get a lot of intermediate</span>
<span class="line-modified">2671                         // noise. They eventually get the summary event fired</span>
<span class="line-modified">2672                         // from within shiftSelection, so this is ok.</span>
<span class="line-modified">2673                         startAtomic();</span>
<span class="line-modified">2674 </span>
<span class="line-modified">2675                         final int clearIndex = param.getClearIndex();</span>
<span class="line-modified">2676                         final int setIndex = param.getSetIndex();</span>
<span class="line-modified">2677                         TreeTablePosition&lt;S,?&gt; oldTP = null;</span>
<span class="line-modified">2678                         if (clearIndex &gt; -1) {</span>
<span class="line-modified">2679                             for (int i = 0; i &lt; selectedCellsMap.size(); i++) {</span>
<span class="line-modified">2680                                 TreeTablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);</span>
<span class="line-modified">2681                                 if (tp.getRow() == clearIndex) {</span>
<span class="line-modified">2682                                     oldTP = tp;</span>
<span class="line-modified">2683                                     selectedCellsMap.remove(tp);</span>
<span class="line-modified">2684                                 } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {</span>
<span class="line-modified">2685                                     selectedCellsMap.remove(tp);</span>


2686                                 }
2687                             }
<span class="line-removed">2688                         }</span>
2689 
<span class="line-modified">2690                         if (oldTP != null &amp;&amp; param.isSelected()) {</span>
<span class="line-modified">2691                             TreeTablePosition&lt;S,?&gt; newTP = new TreeTablePosition&lt;&gt;(</span>
<span class="line-modified">2692                                     treeTableView, param.getSetIndex(), oldTP.getTableColumn());</span>
2693 
<span class="line-modified">2694                             selectedCellsMap.add(newTP);</span>
<span class="line-modified">2695                         }</span>
2696 
<span class="line-modified">2697                         stopAtomic();</span>
2698 
<span class="line-modified">2699                         return null;</span>
<span class="line-modified">2700                     }</span>
<span class="line-modified">2701                 });</span>

2702             }
2703         };
2704 
2705         private WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
2706                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
2707 
2708         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
2709 
2710 
2711 
2712         /***********************************************************************
2713          *                                                                     *
2714          * Observable properties (and getters/setters)                         *
2715          *                                                                     *
2716          **********************************************************************/
2717 
2718         // the only &#39;proper&#39; internal data structure, selectedItems and selectedIndices
2719         // are both &#39;read-only and unbacked&#39;.
2720         private final SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsMap;
2721 
</pre>
</td>
<td>
<hr />
<pre>
1787      * @param column the column
1788      * @return the position of the given column, relative to all other
1789      * visible leaf columns
1790      */
1791     public int getVisibleLeafIndex(TreeTableColumn&lt;S,?&gt; column) {
1792         return getVisibleLeafColumns().indexOf(column);
1793     }
1794 
1795     /**
1796      * Returns the TreeTableColumn in the given column index, relative to all other
1797      * visible leaf columns.
1798      * @param column the column
1799      * @return the TreeTableColumn in the given column index, relative to all other
1800      * visible leaf columns
1801      */
1802     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1803         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1804         return visibleLeafColumns.get(column);
1805     }
1806 
<span class="line-added">1807     boolean sortingInProgress;</span>
<span class="line-added">1808     protected boolean isSortingInProgress() {</span>
<span class="line-added">1809         return sortingInProgress;</span>
<span class="line-added">1810     }</span>
<span class="line-added">1811 </span>
1812     /**
1813      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1814      * often than not it is not necessary to call this method directly, as it is
1815      * automatically called when the {@link #getSortOrder() sort order},
1816      * {@link #sortPolicyProperty() sort policy}, or the state of the
1817      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1818      * change. In other words, this method should only be called directly when
1819      * something external changes and a sort is required.
1820      */
1821     public void sort() {
<span class="line-added">1822         sortingInProgress = true;</span>
1823         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1824 
1825         // update the Comparator property
1826         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1827         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1828 
1829         // fire the onSort event and check if it is consumed, if
1830         // so, don&#39;t run the sort
1831         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
1832         fireEvent(sortEvent);
1833         if (sortEvent.isConsumed()) {
1834             // if the sort is consumed we could back out the last action (the code
1835             // is commented out right below), but we don&#39;t as we take it as a
1836             // sign that the developer has decided to handle the event themselves.
1837 
1838             // sortLock = true;
1839             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1840             // sortLock = false;
<span class="line-added">1841             sortingInProgress = false;</span>
1842             return;
1843         }
1844 
1845         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1846         final int itemCount = prevState.size();
1847 
1848         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1849         // sort events - instead we send a single permutation event at the end
1850         // of this method.
1851         getSelectionModel().startAtomic();
1852 
1853         // get the sort policy and run it
1854         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
1855         if (sortPolicy == null) return;
1856         Boolean success = sortPolicy.call(this);
1857 
1858         getSelectionModel().stopAtomic();
1859 
1860         if (success == null || ! success) {
1861             // the sort was a failure. Need to backout if possible
1862             sortLock = true;
1863             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1864             setComparator(oldComparator);
1865             sortLock = false;
1866         } else {
1867             // sorting was a success, now we possibly fire an event on the
1868             // selection model that the items list has &#39;permutated&#39; to a new ordering
1869 
1870             // FIXME we should support alternative selection model implementations!
1871             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1872                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1873                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1874 
1875                 List&lt;TreeTablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
1876                 for (int i = 0; i &lt; itemCount; i++) {
1877                     TreeTablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
1878                     if (!newState.contains(prevItem)) {
1879                         removed.add(prevItem);
1880                     }
1881                 }

1882                 if (!removed.isEmpty()) {
1883                     // the sort operation effectively permutates the selectedCells list,
1884                     // but we cannot fire a permutation event as we are talking about
1885                     // TreeTablePosition&#39;s changing (which may reside in the same list
1886                     // position before and after the sort). Therefore, we need to fire
1887                     // a single add/remove event to cover the added and removed positions.
1888                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
1889                     sm.fireCustomSelectedCellsListChangeEvent(c);
1890                 }
1891             }
<span class="line-added">1892             getSelectionModel().setSelectedIndex(getRow(getSelectionModel().getSelectedItem()));</span>
<span class="line-added">1893             getFocusModel().focus(getSelectionModel().getSelectedIndex());</span>
1894         }
<span class="line-added">1895         sortingInProgress = false;</span>
1896     }
1897 
1898     /**
1899      * Calling {@code refresh()} forces the TreeTableView control to recreate and
1900      * repopulate the cells necessary to populate the visual bounds of the control.
1901      * In other words, this forces the TreeTableView to update what it is showing to
1902      * the user. This is useful in cases where the underlying data source has
1903      * changed in a way that is not observed by the TreeTableView itself.
1904      *
1905      * @since JavaFX 8u60
1906      */
1907     public void refresh() {
1908         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1909     }
1910 
1911 
1912 
1913     /***************************************************************************
1914      *                                                                         *
1915      * Private Implementation                                                  *
</pre>
<hr />
<pre>
2532 
2533                         ControlUtils.reducingChange(selectedIndices, removed);
2534 
2535                         for (int index : removed) {
2536                             startAtomic();
2537                             // we pass in false here to prevent a lookup into the TreeItem, as it is unnecessary
2538                             // and results in JDK-8152396
2539                             clearSelection(new TreeTablePosition&lt;&gt;(treeTableView, index, null, false));
2540                             stopAtomic();
2541                         }
2542                         selectedIndices._endChange();
2543 
2544                         // put selection onto the newly-collapsed tree item
2545                         if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
2546                             select(startRow, selectedColumn);
2547                         }
2548 
2549                         shift += -count + 1;
2550                         startRow++;
2551                     } else if (e.wasPermutated()) {
<span class="line-modified">2552                         // Approach:</span>
<span class="line-modified">2553                         // Get the current selection.</span>
<span class="line-modified">2554                         // Create a new selection with updated index(row).</span>
<span class="line-modified">2555                         // Update the current selection with new selection.</span>
<span class="line-modified">2556                         // If sorting is in progress then Selection change events will be sent from</span>
<span class="line-modified">2557                         // sort() method, and should not be sent from here.</span>
<span class="line-modified">2558                         // else, in case otherwise, the selection change events would be generated.</span>
<span class="line-modified">2559                         // Do not call shiftSelection() in case of permutation change(when shift == 0).</span>
<span class="line-modified">2560 </span>
<span class="line-modified">2561                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; currentSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());</span>
<span class="line-modified">2562                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; updatedSelection = new ArrayList&lt;&gt;();</span>









2563 







2564                         boolean selectionIndicesChanged = false;
<span class="line-modified">2565                         for (TreeTablePosition&lt;S, ?&gt; selectedCell : currentSelection) {</span>
<span class="line-modified">2566                             int newRow = treeTableView.getRow(selectedCell.getTreeItem());</span>
<span class="line-modified">2567                             if (selectedCell.getRow() != newRow) {</span>
<span class="line-modified">2568                                 selectionIndicesChanged = true;</span>











2569                             }
<span class="line-added">2570                             updatedSelection.add(new TreeTablePosition&lt;&gt;(selectedCell, newRow));</span>
2571                         }

2572                         if (selectionIndicesChanged) {
<span class="line-modified">2573                             if (treeTableView.isSortingInProgress()) {</span>
<span class="line-modified">2574                                 startAtomic();</span>
<span class="line-modified">2575                                 quietClearSelection();</span>
<span class="line-modified">2576                                 selectedCellsMap.setAll(updatedSelection);</span>
<span class="line-modified">2577                                 stopAtomic();</span>
<span class="line-modified">2578                             } else {</span>
<span class="line-modified">2579                                 startAtomic();</span>
<span class="line-modified">2580                                 quietClearSelection();</span>
<span class="line-modified">2581                                 stopAtomic();</span>
<span class="line-modified">2582                                 selectedCellsMap.setAll(updatedSelection);</span>
<span class="line-modified">2583                                 int selectedIndex = treeTableView.getRow(getSelectedItem());</span>
<span class="line-added">2584                                 setSelectedIndex(selectedIndex);</span>
<span class="line-added">2585                                 focus(selectedIndex);</span>
2586                             }


2587                         }
2588                     } else if (e.wasAdded()) {
2589                         // shuffle selection by the number of added items
2590                         shift += treeItem.isExpanded() ? addedSize : 0;
2591 
2592                         // RT-32963: We were taking the startRow from the TreeItem
2593                         // in which the children were added, rather than from the
2594                         // actual position of the new child. This led to selection
2595                         // being moved off the parent TreeItem by mistake.
2596                         // The &#39;if (e.getAddedSize() == 1)&#39; condition here was
2597                         // subsequently commented out due to RT-33894.
2598                         startRow = treeTableView.getRow(e.getChange().getAddedSubList().get(0));
2599 
2600                         TreeTablePosition&lt;S, ?&gt; anchor = TreeTableCellBehavior.getAnchor(treeTableView, null);
2601                         if (anchor != null) {
2602                             boolean isAnchorSelected = isSelected(anchor.getRow(), anchor.getTableColumn());
2603                             if (isAnchorSelected) {
2604                                 TreeTablePosition&lt;S, ?&gt; newAnchor = new TreeTablePosition&lt;&gt;(treeTableView, anchor.getRow() + shift, anchor.getTableColumn());
2605                                 TreeTableCellBehavior.setAnchor(treeTableView, newAnchor, false);
2606                             }
</pre>
<hr />
<pre>
2628                             int index = selectedIndices.get(i);
2629                             if (index &gt; selectedItems.size()) break;
2630 
2631                             if (removedChildren.size() == 1 &amp;&amp;
2632                                     selectedItems.size() == 1 &amp;&amp;
2633                                     selectedItem != null &amp;&amp;
2634                                     selectedItem.equals(removedChildren.get(0))) {
2635                                 // Bug fix for RT-28637
2636                                 if (oldSelectedIndex &lt; getItemCount()) {
2637                                     final int previousRow = oldSelectedIndex == 0 ? 0 : oldSelectedIndex - 1;
2638                                     TreeItem&lt;S&gt; newSelectedItem = getModelItem(previousRow);
2639                                     if (!selectedItem.equals(newSelectedItem)) {
2640                                         clearAndSelect(previousRow);
2641                                     }
2642                                 }
2643                             }
2644                         }
2645                     }
2646                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
2647 
<span class="line-modified">2648                 if (shift != 0) {</span>
<span class="line-modified">2649                     shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {</span>
<span class="line-modified">2650                         @Override public Void call(ShiftParams param) {</span>
<span class="line-modified">2651 </span>
<span class="line-modified">2652                             // we make the shifts atomic, as otherwise listeners to</span>
<span class="line-modified">2653                             // the items / indices lists get a lot of intermediate</span>
<span class="line-modified">2654                             // noise. They eventually get the summary event fired</span>
<span class="line-modified">2655                             // from within shiftSelection, so this is ok.</span>
<span class="line-modified">2656                             startAtomic();</span>
<span class="line-modified">2657 </span>
<span class="line-modified">2658                             final int clearIndex = param.getClearIndex();</span>
<span class="line-modified">2659                             final int setIndex = param.getSetIndex();</span>
<span class="line-modified">2660                             TreeTablePosition&lt;S,?&gt; oldTP = null;</span>
<span class="line-modified">2661                             if (clearIndex &gt; -1) {</span>
<span class="line-modified">2662                                 for (int i = 0; i &lt; selectedCellsMap.size(); i++) {</span>
<span class="line-modified">2663                                     TreeTablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);</span>
<span class="line-modified">2664                                     if (tp.getRow() == clearIndex) {</span>
<span class="line-modified">2665                                         oldTP = tp;</span>
<span class="line-modified">2666                                         selectedCellsMap.remove(tp);</span>
<span class="line-modified">2667                                     } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {</span>
<span class="line-added">2668                                         selectedCellsMap.remove(tp);</span>
<span class="line-added">2669                                     }</span>
2670                                 }
2671                             }

2672 
<span class="line-modified">2673                             if (oldTP != null &amp;&amp; param.isSelected()) {</span>
<span class="line-modified">2674                                 TreeTablePosition&lt;S,?&gt; newTP = new TreeTablePosition&lt;&gt;(</span>
<span class="line-modified">2675                                         treeTableView, param.getSetIndex(), oldTP.getTableColumn());</span>
2676 
<span class="line-modified">2677                                 selectedCellsMap.add(newTP);</span>
<span class="line-modified">2678                             }</span>
2679 
<span class="line-modified">2680                             stopAtomic();</span>
2681 
<span class="line-modified">2682                             return null;</span>
<span class="line-modified">2683                         }</span>
<span class="line-modified">2684                     });</span>
<span class="line-added">2685                 }</span>
2686             }
2687         };
2688 
2689         private WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
2690                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
2691 
2692         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
2693 
2694 
2695 
2696         /***********************************************************************
2697          *                                                                     *
2698          * Observable properties (and getters/setters)                         *
2699          *                                                                     *
2700          **********************************************************************/
2701 
2702         // the only &#39;proper&#39; internal data structure, selectedItems and selectedIndices
2703         // are both &#39;read-only and unbacked&#39;.
2704         private final SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsMap;
2705 
</pre>
</td>
</tr>
</table>
<center><a href="TreeTablePosition.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/java/test/javafx/scene/control/TreeTableViewTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
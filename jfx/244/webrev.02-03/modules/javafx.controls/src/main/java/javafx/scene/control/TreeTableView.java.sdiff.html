<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/java/test/javafx/scene/control/TreeTableViewTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  39 import javafx.css.PseudoClass;
  40 
  41 import javafx.css.converter.SizeConverter;
  42 import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
  43 import com.sun.javafx.scene.control.TableColumnComparatorBase;
  44 
  45 import javafx.css.Styleable;
  46 import javafx.css.StyleableDoubleProperty;
  47 import javafx.css.StyleableProperty;
  48 import javafx.event.WeakEventHandler;
  49 
  50 import javafx.scene.control.skin.TreeTableViewSkin;
  51 
  52 import java.lang.ref.SoftReference;
  53 import java.lang.ref.WeakReference;
  54 import java.util.ArrayList;
  55 import java.util.Collection;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashMap;

  59 import java.util.LinkedHashSet;
  60 import java.util.List;
  61 import java.util.Map;
  62 import java.util.Set;
  63 import java.util.WeakHashMap;
  64 
  65 import javafx.application.Platform;
  66 import javafx.beans.DefaultProperty;
  67 import javafx.beans.InvalidationListener;
  68 import javafx.beans.WeakInvalidationListener;
  69 import javafx.beans.property.BooleanProperty;
  70 import javafx.beans.property.ObjectProperty;
  71 import javafx.beans.property.ObjectPropertyBase;
  72 import javafx.beans.property.ReadOnlyIntegerProperty;
  73 import javafx.beans.property.ReadOnlyIntegerWrapper;
  74 import javafx.beans.property.ReadOnlyObjectProperty;
  75 import javafx.beans.property.ReadOnlyObjectWrapper;
  76 import javafx.beans.property.SimpleBooleanProperty;
  77 import javafx.beans.property.SimpleObjectProperty;
  78 import javafx.beans.value.ChangeListener;
</pre>
<hr />
<pre>
1792         return getVisibleLeafColumns().indexOf(column);
1793     }
1794 
1795     /**
1796      * Returns the TreeTableColumn in the given column index, relative to all other
1797      * visible leaf columns.
1798      * @param column the column
1799      * @return the TreeTableColumn in the given column index, relative to all other
1800      * visible leaf columns
1801      */
1802     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1803         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1804         return visibleLeafColumns.get(column);
1805     }
1806 
1807     private boolean sortingInProgress;
1808     boolean isSortingInProgress() {
1809         return sortingInProgress;
1810     }
1811 





1812     /**
1813      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1814      * often than not it is not necessary to call this method directly, as it is
1815      * automatically called when the {@link #getSortOrder() sort order},
1816      * {@link #sortPolicyProperty() sort policy}, or the state of the
1817      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1818      * change. In other words, this method should only be called directly when
1819      * something external changes and a sort is required.
1820      */
1821     public void sort() {
1822         sortingInProgress = true;
1823         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1824 
1825         // update the Comparator property
1826         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1827         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1828 
1829         // fire the onSort event and check if it is consumed, if
1830         // so, don&#39;t run the sort
1831         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
</pre>
<hr />
<pre>
1838             // sortLock = true;
1839             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1840             // sortLock = false;
1841             sortingInProgress = false;
1842             return;
1843         }
1844 
1845         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1846         final int itemCount = prevState.size();
1847 
1848         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1849         // sort events - instead we send a single permutation event at the end
1850         // of this method.
1851         getSelectionModel().startAtomic();
1852 
1853         // get the sort policy and run it
1854         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
1855         if (sortPolicy == null) return;
1856         Boolean success = sortPolicy.call(this);
1857 










1858         getSelectionModel().stopAtomic();
1859 
1860         if (success == null || ! success) {
1861             // the sort was a failure. Need to backout if possible
1862             sortLock = true;
1863             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1864             setComparator(oldComparator);
1865             sortLock = false;
1866         } else {
1867             // sorting was a success, now we possibly fire an event on the
1868             // selection model that the items list has &#39;permutated&#39; to a new ordering
1869 
1870             // FIXME we should support alternative selection model implementations!
1871             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1872                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1873                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1874 
1875                 List&lt;TreeTablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
1876                 for (int i = 0; i &lt; itemCount; i++) {
1877                     TreeTablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
</pre>
<hr />
<pre>
2536                             startAtomic();
2537                             // we pass in false here to prevent a lookup into the TreeItem, as it is unnecessary
2538                             // and results in JDK-8152396
2539                             clearSelection(new TreeTablePosition&lt;&gt;(treeTableView, index, null, false));
2540                             stopAtomic();
2541                         }
2542                         selectedIndices._endChange();
2543 
2544                         // put selection onto the newly-collapsed tree item
2545                         if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
2546                             select(startRow, selectedColumn);
2547                         }
2548 
2549                         shift += -count + 1;
2550                         startRow++;
2551                     } else if (e.wasPermutated()) {
2552                         // Approach:
2553                         // Get the current selection.
2554                         // Create a new selection with updated index(row).
2555                         // Update the current selection with new selection.
<span class="line-modified">2556                         // If sorting is in progress then Selection change events will be sent from</span>
<span class="line-modified">2557                         // sort() method, and should not be sent from here.</span>
2558                         // else, in case otherwise, the selection change events would be generated.
2559                         // Do not call shiftSelection() in case of permutation change(when shift == 0).
2560 
2561                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; currentSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());
2562                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; updatedSelection = new ArrayList&lt;&gt;();
2563 
2564                         boolean selectionIndicesChanged = false;
2565                         for (TreeTablePosition&lt;S, ?&gt; selectedCell : currentSelection) {
2566                             int newRow = treeTableView.getRow(selectedCell.getTreeItem());
2567                             if (selectedCell.getRow() != newRow) {
2568                                 selectionIndicesChanged = true;
2569                             }
2570                             updatedSelection.add(new TreeTablePosition&lt;&gt;(selectedCell, newRow));
2571                         }
2572                         if (selectionIndicesChanged) {
2573                             if (treeTableView.isSortingInProgress()) {
2574                                 startAtomic();
<span class="line-removed">2575                                 quietClearSelection();</span>
2576                                 selectedCellsMap.setAll(updatedSelection);
2577                                 stopAtomic();
2578                             } else {
2579                                 startAtomic();
2580                                 quietClearSelection();
2581                                 stopAtomic();
2582                                 selectedCellsMap.setAll(updatedSelection);
2583                                 int selectedIndex = treeTableView.getRow(getSelectedItem());
2584                                 setSelectedIndex(selectedIndex);
2585                                 focus(selectedIndex);
2586                             }
2587                         }
2588                     } else if (e.wasAdded()) {
2589                         // shuffle selection by the number of added items
2590                         shift += treeItem.isExpanded() ? addedSize : 0;
2591 
2592                         // RT-32963: We were taking the startRow from the TreeItem
2593                         // in which the children were added, rather than from the
2594                         // actual position of the new child. This led to selection
2595                         // being moved off the parent TreeItem by mistake.
</pre>
</td>
<td>
<hr />
<pre>
  39 import javafx.css.PseudoClass;
  40 
  41 import javafx.css.converter.SizeConverter;
  42 import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
  43 import com.sun.javafx.scene.control.TableColumnComparatorBase;
  44 
  45 import javafx.css.Styleable;
  46 import javafx.css.StyleableDoubleProperty;
  47 import javafx.css.StyleableProperty;
  48 import javafx.event.WeakEventHandler;
  49 
  50 import javafx.scene.control.skin.TreeTableViewSkin;
  51 
  52 import java.lang.ref.SoftReference;
  53 import java.lang.ref.WeakReference;
  54 import java.util.ArrayList;
  55 import java.util.Collection;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashMap;
<span class="line-added">  59 import java.util.HashSet;</span>
  60 import java.util.LinkedHashSet;
  61 import java.util.List;
  62 import java.util.Map;
  63 import java.util.Set;
  64 import java.util.WeakHashMap;
  65 
  66 import javafx.application.Platform;
  67 import javafx.beans.DefaultProperty;
  68 import javafx.beans.InvalidationListener;
  69 import javafx.beans.WeakInvalidationListener;
  70 import javafx.beans.property.BooleanProperty;
  71 import javafx.beans.property.ObjectProperty;
  72 import javafx.beans.property.ObjectPropertyBase;
  73 import javafx.beans.property.ReadOnlyIntegerProperty;
  74 import javafx.beans.property.ReadOnlyIntegerWrapper;
  75 import javafx.beans.property.ReadOnlyObjectProperty;
  76 import javafx.beans.property.ReadOnlyObjectWrapper;
  77 import javafx.beans.property.SimpleBooleanProperty;
  78 import javafx.beans.property.SimpleObjectProperty;
  79 import javafx.beans.value.ChangeListener;
</pre>
<hr />
<pre>
1793         return getVisibleLeafColumns().indexOf(column);
1794     }
1795 
1796     /**
1797      * Returns the TreeTableColumn in the given column index, relative to all other
1798      * visible leaf columns.
1799      * @param column the column
1800      * @return the TreeTableColumn in the given column index, relative to all other
1801      * visible leaf columns
1802      */
1803     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1804         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1805         return visibleLeafColumns.get(column);
1806     }
1807 
1808     private boolean sortingInProgress;
1809     boolean isSortingInProgress() {
1810         return sortingInProgress;
1811     }
1812 
<span class="line-added">1813     private boolean sortTreeOfSelectedItems = true;</span>
<span class="line-added">1814     boolean isSortTreeOfSelectedItems() {</span>
<span class="line-added">1815         return sortTreeOfSelectedItems;</span>
<span class="line-added">1816     }</span>
<span class="line-added">1817 </span>
1818     /**
1819      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1820      * often than not it is not necessary to call this method directly, as it is
1821      * automatically called when the {@link #getSortOrder() sort order},
1822      * {@link #sortPolicyProperty() sort policy}, or the state of the
1823      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1824      * change. In other words, this method should only be called directly when
1825      * something external changes and a sort is required.
1826      */
1827     public void sort() {
1828         sortingInProgress = true;
1829         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1830 
1831         // update the Comparator property
1832         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1833         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1834 
1835         // fire the onSort event and check if it is consumed, if
1836         // so, don&#39;t run the sort
1837         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
</pre>
<hr />
<pre>
1844             // sortLock = true;
1845             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1846             // sortLock = false;
1847             sortingInProgress = false;
1848             return;
1849         }
1850 
1851         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1852         final int itemCount = prevState.size();
1853 
1854         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1855         // sort events - instead we send a single permutation event at the end
1856         // of this method.
1857         getSelectionModel().startAtomic();
1858 
1859         // get the sort policy and run it
1860         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
1861         if (sortPolicy == null) return;
1862         Boolean success = sortPolicy.call(this);
1863 
<span class="line-added">1864         if (getSortMode() == TreeSortMode.ALL_DESCENDANTS &amp;&amp; isSortTreeOfSelectedItems()) {</span>
<span class="line-added">1865             Set&lt;TreeItem&lt;S&gt;&gt; sortedParents = new HashSet&lt;&gt;();</span>
<span class="line-added">1866             for (TreeTablePosition&lt;S,?&gt; selectedPosition : prevState) {</span>
<span class="line-added">1867                 TreeItem&lt;S&gt; parent = selectedPosition.getTreeItem().getParent();</span>
<span class="line-added">1868                 while (parent != null &amp;&amp; sortedParents.add(parent)) {</span>
<span class="line-added">1869                     parent.getChildren();</span>
<span class="line-added">1870                     parent = parent.getParent();</span>
<span class="line-added">1871                 }</span>
<span class="line-added">1872             }</span>
<span class="line-added">1873         }</span>
1874         getSelectionModel().stopAtomic();
1875 
1876         if (success == null || ! success) {
1877             // the sort was a failure. Need to backout if possible
1878             sortLock = true;
1879             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1880             setComparator(oldComparator);
1881             sortLock = false;
1882         } else {
1883             // sorting was a success, now we possibly fire an event on the
1884             // selection model that the items list has &#39;permutated&#39; to a new ordering
1885 
1886             // FIXME we should support alternative selection model implementations!
1887             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1888                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1889                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1890 
1891                 List&lt;TreeTablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
1892                 for (int i = 0; i &lt; itemCount; i++) {
1893                     TreeTablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
</pre>
<hr />
<pre>
2552                             startAtomic();
2553                             // we pass in false here to prevent a lookup into the TreeItem, as it is unnecessary
2554                             // and results in JDK-8152396
2555                             clearSelection(new TreeTablePosition&lt;&gt;(treeTableView, index, null, false));
2556                             stopAtomic();
2557                         }
2558                         selectedIndices._endChange();
2559 
2560                         // put selection onto the newly-collapsed tree item
2561                         if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
2562                             select(startRow, selectedColumn);
2563                         }
2564 
2565                         shift += -count + 1;
2566                         startRow++;
2567                     } else if (e.wasPermutated()) {
2568                         // Approach:
2569                         // Get the current selection.
2570                         // Create a new selection with updated index(row).
2571                         // Update the current selection with new selection.
<span class="line-modified">2572                         // If sorting is in progress then one Selection change event will be sent from</span>
<span class="line-modified">2573                         // TreeTableView.sort() method, and should not be sent from here.</span>
2574                         // else, in case otherwise, the selection change events would be generated.
2575                         // Do not call shiftSelection() in case of permutation change(when shift == 0).
2576 
2577                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; currentSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());
2578                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; updatedSelection = new ArrayList&lt;&gt;();
2579 
2580                         boolean selectionIndicesChanged = false;
2581                         for (TreeTablePosition&lt;S, ?&gt; selectedCell : currentSelection) {
2582                             int newRow = treeTableView.getRow(selectedCell.getTreeItem());
2583                             if (selectedCell.getRow() != newRow) {
2584                                 selectionIndicesChanged = true;
2585                             }
2586                             updatedSelection.add(new TreeTablePosition&lt;&gt;(selectedCell, newRow));
2587                         }
2588                         if (selectionIndicesChanged) {
2589                             if (treeTableView.isSortingInProgress()) {
2590                                 startAtomic();

2591                                 selectedCellsMap.setAll(updatedSelection);
2592                                 stopAtomic();
2593                             } else {
2594                                 startAtomic();
2595                                 quietClearSelection();
2596                                 stopAtomic();
2597                                 selectedCellsMap.setAll(updatedSelection);
2598                                 int selectedIndex = treeTableView.getRow(getSelectedItem());
2599                                 setSelectedIndex(selectedIndex);
2600                                 focus(selectedIndex);
2601                             }
2602                         }
2603                     } else if (e.wasAdded()) {
2604                         // shuffle selection by the number of added items
2605                         shift += treeItem.isExpanded() ? addedSize : 0;
2606 
2607                         // RT-32963: We were taking the startRow from the TreeItem
2608                         // in which the children were added, rather than from the
2609                         // actual position of the new child. This led to selection
2610                         // being moved off the parent TreeItem by mistake.
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/java/test/javafx/scene/control/TreeTableViewTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/java/test/javafx/scene/control/TreeTableViewTest.java.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -54,10 +54,11 @@</span>
  import java.util.ArrayList;
  import java.util.Collection;
  import java.util.Collections;
  import java.util.Comparator;
  import java.util.HashMap;
<span class="udiff-line-added">+ import java.util.HashSet;</span>
  import java.util.LinkedHashSet;
  import java.util.List;
  import java.util.Map;
  import java.util.Set;
  import java.util.WeakHashMap;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1807,10 +1808,15 @@</span>
      private boolean sortingInProgress;
      boolean isSortingInProgress() {
          return sortingInProgress;
      }
  
<span class="udiff-line-added">+     private boolean sortTreeOfSelectedItems = true;</span>
<span class="udiff-line-added">+     boolean isSortTreeOfSelectedItems() {</span>
<span class="udiff-line-added">+         return sortTreeOfSelectedItems;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * The sort method forces the TreeTableView to re-run its sorting algorithm. More
       * often than not it is not necessary to call this method directly, as it is
       * automatically called when the {@link #getSortOrder() sort order},
       * {@link #sortPolicyProperty() sort policy}, or the state of the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1853,10 +1859,20 @@</span>
          // get the sort policy and run it
          Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
          if (sortPolicy == null) return;
          Boolean success = sortPolicy.call(this);
  
<span class="udiff-line-added">+         if (getSortMode() == TreeSortMode.ALL_DESCENDANTS &amp;&amp; isSortTreeOfSelectedItems()) {</span>
<span class="udiff-line-added">+             Set&lt;TreeItem&lt;S&gt;&gt; sortedParents = new HashSet&lt;&gt;();</span>
<span class="udiff-line-added">+             for (TreeTablePosition&lt;S,?&gt; selectedPosition : prevState) {</span>
<span class="udiff-line-added">+                 TreeItem&lt;S&gt; parent = selectedPosition.getTreeItem().getParent();</span>
<span class="udiff-line-added">+                 while (parent != null &amp;&amp; sortedParents.add(parent)) {</span>
<span class="udiff-line-added">+                     parent.getChildren();</span>
<span class="udiff-line-added">+                     parent = parent.getParent();</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
          getSelectionModel().stopAtomic();
  
          if (success == null || ! success) {
              // the sort was a failure. Need to backout if possible
              sortLock = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2551,12 +2567,12 @@</span>
                      } else if (e.wasPermutated()) {
                          // Approach:
                          // Get the current selection.
                          // Create a new selection with updated index(row).
                          // Update the current selection with new selection.
<span class="udiff-line-modified-removed">-                         // If sorting is in progress then Selection change events will be sent from</span>
<span class="udiff-line-modified-removed">-                         // sort() method, and should not be sent from here.</span>
<span class="udiff-line-modified-added">+                         // If sorting is in progress then one Selection change event will be sent from</span>
<span class="udiff-line-modified-added">+                         // TreeTableView.sort() method, and should not be sent from here.</span>
                          // else, in case otherwise, the selection change events would be generated.
                          // Do not call shiftSelection() in case of permutation change(when shift == 0).
  
                          List&lt;TreeTablePosition&lt;S, ?&gt;&gt; currentSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());
                          List&lt;TreeTablePosition&lt;S, ?&gt;&gt; updatedSelection = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2570,11 +2586,10 @@</span>
                              updatedSelection.add(new TreeTablePosition&lt;&gt;(selectedCell, newRow));
                          }
                          if (selectionIndicesChanged) {
                              if (treeTableView.isSortingInProgress()) {
                                  startAtomic();
<span class="udiff-line-removed">-                                 quietClearSelection();</span>
                                  selectedCellsMap.setAll(updatedSelection);
                                  stopAtomic();
                              } else {
                                  startAtomic();
                                  quietClearSelection();
</pre>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/java/test/javafx/scene/control/TreeTableViewTest.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>